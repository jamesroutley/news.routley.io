<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/">Original</a>
    <h1>AWS Nitro Enclaves: Attack Surface</h1>
    
    <div id="readability-page-1" class="page"><article id="post-108306">
	<!-- .entry-header -->

	<div>
		<p><em>By Paweł Płatek</em></p>
<p>In the race to secure cloud applications, AWS Nitro Enclaves have emerged as a powerful tool for isolating sensitive workloads. But with great power comes great responsibility—and potential security pitfalls. As pioneers in confidential computing security, we at Trail of Bits have scrutinized the attack surface of AWS Nitro Enclaves, uncovering potential bugs that could compromise even these hardened environments.</p>
<p>This post distills our hard-earned insights into actionable guidance for developers deploying Nitro Enclaves. After reading, you’ll be equipped to:</p>
<ul>
<li>Identify and mitigate key security risks in your enclave deployment</li>
<li>Implement best practices for randomness, side-channel protection, and time management</li>
<li>Avoid common pitfalls in virtual socket handling and attestation</li>
</ul>
<p>We’ll cover a number of topics, including:</p>
<ul>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=Nitro%20Enclaves%20system-,Vsocks,-The%20main%20entrypoint">Virtual socket security</a></li>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=this%20communication%20type.-,Randomness,-Enclaves%20must%20have">Randomness and entropy sources</a></li>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=kernel%E2%80%99s%20random%20algorithm.-,Side%20channels,-Application%2Dlevel%20timing">Side-channel attack mitigations</a></li>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=are%20important%20here.-,Memory,-Memory%20for%20enclaves">Memory management</a></li>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=for%20more%20information.-,Time,-A%20less%20common">Time source considerations</a></li>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=related%20security%20issues.-,Attestation,-Cryptographic%20attestation%20is">Attestation best practices</a></li>
<li><a href="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/#:~:text=the%20public_key%20feature.-,The%20NSM%20driver,-Your%20enclave%20applications">NSM driver security</a></li>
</ul>
<p>Whether you’re new to Nitro Enclaves or looking to harden existing deployments, this guide will help you navigate the unique security landscape of confidential computing on AWS.</p>
<h3>A brief threat model</h3>
<p>First, a brief threat model. Enclaves can be attacked from the parent Amazon EC2 instance, which is the only component that has direct access to an enclave. In the context of an attack on an enclave, we should assume that the parent instance’s kernel (including its <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/virt/nitro_enclaves?id=793f55b2971e3a95d77ad08e9da2a3dc6c946cd7"><code>nitro_enclaves</code> drivers</a>) is controlled by the attacker. DoS attacks from the instance are not really a concern, as the parent can always shut down its enclaves.</p>
<p>If the EC2 instance forwards user traffic from the internet, then attacks on its enclaves could come from that direction and could involve all the usual attack vectors (business-logic, memory corruption, cryptographic, etc.). And in the other direction, users could be targeted by malicious EC2 instances with impersonation attacks.</p>
<p>In terms of trust zones, an enclave should be treated as a single trust zone. Enclaves run normal Linux and can theoretically use its access control features to “drive lines” within themselves. But that would be pointless—adversarial access (e.g., via a supply-chain attack) to anything inside the enclave would diminish the benefits of its strong isolation and of attestation. Therefore, compromise of a single enclave component should be treated as a total enclave compromise.</p>
<p>Finally, the hypervisor is trusted—we must assume it behaves correctly and not maliciously.</p>
<div id="attachment_108312"><p><img fetchpriority="high" decoding="async" aria-describedby="caption-attachment-108312" data-attachment-id="108312" data-permalink="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/figure_1-6/" data-orig-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2.png" data-orig-size="1999,1606" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="figure_1" data-image-description="" data-image-caption="&lt;p&gt;Figure 1: A simplified model of the AWS Nitro Enclaves system&lt;/p&gt;
" data-medium-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-300x241.png" data-large-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-1650x1326.png" tabindex="0" role="button" src="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-1650x1326.png" alt="" width="690" height="555" srcset="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-1650x1326.png 1650w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-300x241.png 300w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-768x617.png 768w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2-1536x1234.png 1536w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_1-2.png 1999w" sizes="(max-width: 690px) 100vw, 690px"/></p><p id="caption-attachment-108312">Figure 1: A simplified model of the AWS Nitro Enclaves system</p></div>
<h3>Vsocks</h3>
<p>The main entrypoint to an enclave is the local <a href="https://archive.fosdem.org/2021/schedule/event/vai_virtio_vsock/">virtual socket</a> (vsock). Only the parent EC2 instance can use the socket. Vsocks are managed by the hypervisor—the hypervisor provides the parent EC2 instance’s and the enclave’s kernels with <code>/dev/vsock</code> device nodes.</p>
<p>Vsocks are identified by a context identifier (CID) and port. Every enclave must use a unique CID, which can be set during initialization and can listen on multiple ports. There are a few predefined CIDs:</p>
<ul>
<li><code>VMADDR_CID_HYPERVISOR</code> = 0</li>
<li><code>VMADDR_CID_LOCAL</code> = 1</li>
<li><code>VMADDR_CID_HOST</code> = 2</li>
<li><code>VMADDR_CID_PARENT</code> = 3 (the parent EC2 instance)</li>
<li><code>VMADDR_CID_ANY</code> = <code>0xFFFFFFFF</code> = -1U (listen on all CIDs)</li>
</ul>
<p>Enclaves usually use only the <code>VMADDR_CID_PARENT CID</code> (to send data) and the <code>VMADDR_CID_ANY CID</code> (to listen for data). An example use of the <code>VMADDR_CID_PARENT</code> can be found in the <a href="https://github.com/aws/aws-nitro-enclaves-sdk-bootstrap/blob/ac43d103ba0f98044bf760477c088f1dc6f3702d/init/init.c#L410-L410"><code>init.c</code> module</a> of AWS’s enclaves SDK—the enclave sends a “heartbeat” signal to the parent EC2 instance just after initialization. The signal is <a href="https://github.com/aws/aws-nitro-enclaves-cli/blob/c4fafb2320bc13d1e74e6ba2c1b6ef840cba0988/eif_loader/src/lib.rs#L54-L56">handled by the <code>nitro-cli</code></a> tool.</p>
<p><strong>Standard socket-related issues are the main issues to worry about when it comes to vsocks.</strong> When developing an enclave, consider the following to ensure such issues cannot enable certain attack vectors:</p>
<ul>
<li>Does the enclave accept connections asynchronously (with multithreading)? If not, a single user may block other users from accessing the enclave for a long period of time.</li>
<li>Does the enclave time out connections? If not, a single user may persistently occupy a socket or open multiple connections to the enclave and drain available resources (like file descriptors).</li>
<li>If the enclave uses multithreading, is its state synchronization correctly implemented?</li>
<li>Does the enclave handle errors correctly? Reading from a socket with the <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html"><code>recv</code> method</a> is especially tricky. A <a href="https://github.com/aws/aws-nitro-enclaves-cli/blob/c4fafb2320bc13d1e74e6ba2c1b6ef840cba0988/samples/command_executer/src/protocol_helpers.rs#L51-L65">common pattern is to loop</a> over the <code>recv</code> call until the desired number of bytes is received, but this pattern should be carefully implemented:
<ul>
<li>If the <a href="https://android.googlesource.com/platform/bionic/+/master/docs/EINTR.md"><code>EINTR</code> error is returned</a>, the enclave should retry the <code>recv</code> call. Otherwise, the enclave may drop valid and live connections.</li>
<li>If there is no error but the returned length is 0, the enclave should break the loop. Otherwise, the peer <a href="https://github.com/aws/aws-nitro-enclaves-cli/pull/609">may shut down the connection</a> before sending the expected number of bytes, making the enclave loop infinitely.</li>
<li>If the socket is non-blocking, then reading data correctly is even more tricky.</li>
</ul>
</li>
</ul>
<p>The main risk of these issues is DoS. The parent EC2 instance may shut down any of its enclaves, so the actual risks are present only if a DoS can be triggered by external users. Providing timely access to the system is the responsibility of both the enclave and the EC2 instance communicating with the enclave.</p>
<p>Another vulnerability class involving vsocks is CID confusion: if an EC2 instance runs multiple enclaves, it may send data to the wrong one (e.g., due to a race condition issue). However, even if such a bug exists, it should not pose much risk or contribute much to an enclave’s attack surface, because traffic between users and the enclave should be authenticated end to end.</p>
<p>Finally, note that enclaves use the <code>SOCK_STREAM</code> socket type by default. If you change the type to <code>SOCK_DGRAM</code>, do some research to learn about the security properties of this communication type.</p>
<h3>Randomness</h3>
<p>Enclaves must have access to secure randomness. The word “secure” in this context means that adversaries don’t know or control all the entropy used to produce random data. On Linux, <a href="https://elixir.bootlin.com/linux/latest/source/drivers/char/random.c#L749">a few entropy sources</a> are mixed together by the kernel. Among them are the <a href="https://elixir.bootlin.com/linux/latest/source/drivers/char/random.c#L662">CPU-provided <code>RDRAND/RDSEED</code> source</a> and platform-provided hardware random number generators (RNGs). The AWS Nitro Trusted Platform Module <a href="https://lore.kernel.org/all/20230929133320.74848-1-graf@amazon.com/T/">provides its own hardware RNG</a> (called <code>nsm-hwrng</code>).</p>
<div id="attachment_108319"><p><img decoding="async" aria-describedby="caption-attachment-108319" data-attachment-id="108319" data-permalink="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/figure_2-6/" data-orig-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2.png" data-orig-size="880,856" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="figure_2" data-image-description="" data-image-caption="&lt;p&gt;Figure 2: Randomness sources in the Linux kernel&lt;/p&gt;
" data-medium-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2-300x292.png" data-large-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2.png" tabindex="0" role="button" src="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2.png" alt="" width="705" height="686" srcset="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2.png 880w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2-300x292.png 300w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_2-2-768x747.png 768w" sizes="(max-width: 705px) 100vw, 705px"/></p><p id="caption-attachment-108319">Figure 2: Randomness sources in the Linux kernel</p></div>
<p>The final randomness can be obtained via the <a href="https://man7.org/linux/man-pages/man2/getrandom.2.html"><code>getrandom</code></a> system call or from (less reliable) <code>/dev/{u}random</code> devices. There is also the <code>/dev/hwrng</code> device, which gives more direct access to the selected hardware RNG. This device should not be used by user-space applications.</p>
<p>When a new hardware RNG is registered by the kernel, <a href="https://elixir.bootlin.com/linux/latest/source/drivers/char/hw_random/core.c#L585">it is used right away</a> to add entropy to the system. A list of available hardware RNGs can be found in the <code>/sys/class/misc/hw_random/rng_available</code> file. One of the registered RNGs is selected automatically <a href="https://elixir.bootlin.com/linux/latest/source/drivers/char/hw_random/core.c#L237">to periodically add entropy</a> and is indicated in the <code>/sys/devices/virtual/misc/hw_random/rng_current</code> file.</p>
<p><strong>We recommend configuring your enclaves to explicitly check that the current RNG (<code>rng_current</code>) is set to <code>nsm-hwrng</code>.</strong> This check will ensure that the AWS Nitro RNG was successfully <a href="https://github.com/torvalds/linux/blob/0bbac3facb5d6cc0171c45c9873a2dc96bea9680/drivers/misc/nsm.c#L449-L452">registered</a> and that it’s the one the kernel uses periodically to add entropy.</p>
<p>To further boost the security of your enclave’s randomness, have it pull entropy from external sources whenever there are convenient sources available. A common external source is the AWS Key Management Service, which <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_GenerateRandom.html">provides a convenient <code>GenerateRandom</code> method</a> that enclaves can use to bring in entropy over an encrypted channel.</p>
<p>If you want to follow <a href="https://csrc.nist.gov/csrc/media/Presentations/2023/bridging-the-gap-between-the-sp-800-90-series-and/images-media/session-2-mckay-bridging-the-gap.pdf">NIST/AIS standards</a> (see section 5.3.1 in “<a href="https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/Studies/LinuxRNG/LinuxRNG_EN_V4_5.pdf">Documentation and Analysis of the Linux Random Number Generator</a>”) or suspect <a href="https://en.wikipedia.org/wiki/RDRAND#Security_issues">issues</a> with the <code>RDRAND</code>/<code>RDSEED</code> instructions (see also this <a href="https://lwn.net/Articles/961121/">LWNet article</a> and <a href="https://x.com/pid_eins/status/1149649806056280069">this tweet</a>), you can disable the <code>random.trust_{bootloader,cpu}</code> kernel parameters. That will inform the kernel not to include these sources for estimation of available entropy.</p>
<p>Lastly, make sure that your enclaves use a kernel version greater than <a href="https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.12"><code>5.17.12</code></a>—<a href="https://lore.kernel.org/lkml/20220527084855.501642285@linuxfoundation.org/">important changes were introduced</a> to the kernel’s random algorithm.</p>
<h3>Side channels</h3>
<p>Application-level timing side-channel attacks are a threat to enclaves, as they are to any application. <strong>Applications running inside enclaves must process confidential data in constant time.</strong> Attacks from the parent EC2 instance can use almost system-clock-precise time measurements, so don’t count on network jitter for mitigations. You can read more about timing attack vectors in our blog post “<a href="https://blog.trailofbits.com/2022/01/26/part-1-the-life-of-an-optimization-barrier/">The life of an optimization barrier</a>.”</p>
<p>Also, though this doesn’t really constitute a side-channel attack, error messages returned by an enclave can be used by attackers to reason about the enclave’s state. Think about issues like padding oracles and <a href="https://github.com/OWASP/CheatSheetSeries/blob/5391fd01d1a67cb780b335b922c778a2cc27d91f/cheatsheets/Authentication_Cheat_Sheet.md#authentication-and-error-messages">account enumeration</a>. <strong>We recommend keeping errors returned by enclaves as generic as possible.</strong> How generic errors should be will depend on the given business requirements, as users of any application will need some level of error tracing.</p>
<h3>CPU memory side channels</h3>
<p>The main type of side-channel attack to know about involves CPU memory. CPUs share some memory—most notably the <a href="https://en.wikipedia.org/wiki/CPU_cache">cache lines</a>. If memory is simultaneously accessible to two components from different trust zones—like an enclave and its parent EC2 instance—then it may be possible for one component to indirectly leak the other component’s data via measurements of memory access patterns. Even if an application processes secret data in constant time, attackers with access to this type of side channel can exploit data-dependent branching.</p>
<p>In a typical architecture, CPUs can be categorized into <a href="https://www.kernel.org/doc/html/v4.18/vm/numa.html">NUMA</a> nodes, CPU cores, and CPU threads. The smallest physical processing unit is the CPU core. The core may have multiple logical threads (virtual CPUs)—the smallest logical processing units—and threads share L1 and L2 cache lines. The L3 line (also called the last-level cache) is shared between all cores in a NUMA node.</p>
<div id="attachment_108327"><p><img decoding="async" aria-describedby="caption-attachment-108327" data-attachment-id="108327" data-permalink="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/figure_3-6/" data-orig-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2.png" data-orig-size="1024,1127" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="figure_3" data-image-description="" data-image-caption="&lt;p&gt;Example CPU arrangement of a system, obtained by the lstopo command&lt;/p&gt;
" data-medium-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2-273x300.png" data-large-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2.png" tabindex="0" role="button" src="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2.png" alt="" width="674" height="742" srcset="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2.png 1024w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2-273x300.png 273w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_3-2-768x845.png 768w" sizes="(max-width: 674px) 100vw, 674px"/></p><p id="caption-attachment-108327">Figure 3: Example CPU arrangement of a system, obtained by the lstopo command</p></div>
<p>Parent EC2 instances may have been allocated only a few CPU cores from a NUMA node. Therefore, they may share an L3 cache with other instances. However, the AWS white paper “<a href="https://docs.aws.amazon.com/whitepapers/latest/security-design-of-aws-nitro-system/the-ec2-approach-to-preventing-side-channels.html">The Security Design of the AWS Nitro System</a>” claims that the L3 cache is never shared <em>simultaneously</em>. Unfortunately, there is <a href="https://news.ycombinator.com/item?id=23667433">not much more information</a> on the topic.</p>
<div id="attachment_108329"><p><img loading="lazy" decoding="async" aria-describedby="caption-attachment-108329" data-attachment-id="108329" data-permalink="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/figure_4-4/" data-orig-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1.png" data-orig-size="1288,780" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="figure_4" data-image-description="" data-image-caption="&lt;p&gt;An excerpt from the AWS white paper, stating that instances with one-half the max amount of CPUs should fill a whole CPU core (socket?)&lt;/p&gt;
" data-medium-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1-300x182.png" data-large-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1.png" tabindex="0" role="button" src="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1.png" alt="" width="978" height="592" srcset="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1.png 1288w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1-300x182.png 300w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_4-1-768x465.png 768w" sizes="(max-width: 978px) 100vw, 978px"/></p><p id="caption-attachment-108329">Figure 4: An excerpt from the AWS white paper, stating that instances with one-half the max amount of CPUs should fill a whole CPU core (socket?)</p></div>
<p>What about CPUs in enclaves? CPUs are taken from the parent EC2 instance and assigned to an enclave. According to the AWS and <a href="https://github.com/aws/aws-nitro-enclaves-cli/blob/c4fafb2320bc13d1e74e6ba2c1b6ef840cba0988/bootstrap/nitro-cli-config#L545-L548"><code>nitro-cli</code> source code</a>, the hypervisor enforces the following:</p>
<ul>
<li>The CPU #0 core (all its threads) is not assignable to enclaves.</li>
<li>Enclaves must use full cores.</li>
<li>All cores assigned to an enclave must be from the same NUMA node.</li>
</ul>
<p>In the worst case, an enclave will share the L3 cache with its parent EC2 instance (or with other enclaves). However, whether the L3 cache can be used to carry out side-channel attacks is debatable. On one hand, the AWS white paper doesn’t make a big deal of this attack vector. On the other hand, recent research indicates the practicality of such an attack (see “<a href="https://www.cs.tau.ac.il/~mad/publications/asplos2024-llcfeasible.pdf">Last-Level Cache Side-Channel Attacks Are Feasible in the Modern Public Cloud</a>”).</p>
<p>If you are very concerned about L3 cache side-channel attacks, you can <strong>run the enclave on a full NUMA node</strong>. To do so, you would have to allocate more than one full NUMA node to the parent EC2 instance so that one NUMA node can be used for the enclave while saving some CPUs on the other NUMA node for the parent. Note that this mitigation is resource-inefficient and costly.</p>
<p>Alternatively, you can <strong>experiment with Intel’s <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/introduction-to-cache-allocation-technology.html">Cache Allocation Technology</a></strong> (CAT) to isolate the enclave’s L3 cache (see <a href="https://github.com/intel/intel-cmt-cat/wiki/Usage-Examples#12-cache-allocation-technology-cat-usage">the <code>intel-cmt-cat</code> software</a>) from the parent. Note, however, that we don’t know whether CAT can be changed dynamically for a running enclave—that would render this solution unuseful.</p>
<p>If you implement any of the above mitigations, you will have to add relevant information to the attestation. Otherwise, users won’t be able to ensure that the L3 side-channel attack vector was really mitigated.</p>
<p>Anyway, you want your <strong>security-critical code (like cryptography) to be implemented with secrets-independent memory access patterns</strong>. Both hardware- and software-level security controls are important here.</p>
<h3>Memory</h3>
<p>Memory for enclaves is carved out from parent EC2 instances. It is the hypervisor’s responsibility to protect access to an enclave’s memory and to clear it after it’s returned to the parent. When it comes to enclave memory as an attack vector, developers really only need to worry about DoS attacks. <strong>Applications running inside an enclave should have limits on how much data external users can store.</strong> Otherwise, a single user may be able to consume all of an enclave’s available memory and crash the enclave (try running <code>cat /dev/zero</code> inside the enclave to see how it behaves when a large amount of memory is consumed).</p>
<p>So how much space does your enclave have? The answer is a bit complicated. First of all, the enclave’s init process doesn’t mount a new root filesystem, but keeps the initial <code>initramfs</code> and <a href="https://github.com/aws/aws-nitro-enclaves-sdk-bootstrap/blob/3f79674465f816eeffe4482e1240b792ff75d2d9/init/init.c#L428-L429"><code>chroots</code> to a directory</a> (though there is a <a href="https://github.com/aws/aws-nitro-enclaves-sdk-bootstrap/pull/25">pending PR</a> that will change this behavior once merged). This <a href="https://www.lightofdawn.org/blog/?viewDetailed=00128">puts some limits</a> on the filesystem’s size. Also, data saved in the filesystem will consume available RAM.</p>
<p>You can check the total available RAM and filesystem space by executing the free command inside the enclave. The filesystem’s size limit should be around 40–50% of that total space. You can confirm that by filling the whole filesystem’s space and checking how much data ends up being stored there:</p>
<pre>dd count=9999999999 if=/dev/zero &gt; /fillspace
du -h -d1 /
</pre>
<p>Another issue with memory is that the enclave doesn’t have any persistent storage. Once it is shut down, all its data is lost. Moreover, AWS Nitro doesn’t provide any specific <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/introduction-to-intel-sgx-sealing.html">data sealing mechanism</a>. It’s your application’s responsibility to implement it. Read our blog post “<a href="https://blog.trailofbits.com/2023/12/18/a-trail-of-flipping-bits/">A trail of flipping bits</a>” for more information.</p>
<h3>Time</h3>
<p>A less common source of security issues is an enclave’s time source—namely, from where the enclave gets its time. An attacker who can control an enclave’s time could perform rollback and replay attacks. For example, the attacker could switch the enclave’s time to the past and make the enclave accept expired TLS certificates.</p>
<p>Getting a trusted source of time may be a somewhat <a href="https://www.intel.com/content/www/us/en/support/articles/000057968/software/intel-security-products.html">complex problem in the space of confidential computing</a>. Fortunately, enclaves can rely on the trusted hypervisor for delivery of secure clock sources. <strong>From the developer’s side, there are only three actions worth taking to improve the security and correctness of your enclave’s time sources:</strong></p>
<ul>
<li>Ensure that <code>current_clocksource</code> is set to <code>kvm-clock</code> in the enclave’s kernel configuration; consider even adding an application-level runtime check for the clock (in case something goes wrong during enclave bootstrapping and it ends up with a different clock source).</li>
<li>Enable the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html#connect-to-the-ptp-hardware-clock">Precision Time Protocol</a> for better clock synchronization between the enclave and the hypervisor. It’s like the Network Time Protocol (NTP) but works over a hardware connection. It should be more secure (as it has a smaller attack surface) and easier to <a href="https://github.com/aws/aws-nitro-enclaves-cli/issues/500">set up</a> than the NTP.</li>
<li>For security-critical functionalities (like replay protections) use <a href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a>. Be careful with UTC and time zones, as <a href="https://en.wikipedia.org/wiki/Daylight_saving_time">daylight saving time</a> and <a href="https://cr.yp.to/proto/utctai.html">leap seconds</a> may “move time backwards.”</li>
</ul>
<h3>Why kvm-clock?</h3>
<p>Machines using an x86 architecture <a href="https://blog.trailofbits.com/2019/10/03/tsc-frequency-for-all-better-profiling-and-benchmarking/#:~:text=The%20trouble%20with%20timestamps">can have a few different sources of time</a>. We can use the following command to check the sources available to enclaves:</p>
<pre>cat /sys/devices/system/clocksource/clocksource0/available_clocksource
</pre>
<p>Enclaves should have two sources: <code>tsc</code> and <code>kvm-clock</code> (you can see them if you run <a href="https://github.com/aws/aws-nitro-enclaves-cli/tree/6cb66b8e617d296d23e0cc083495a0306cb92eef/samples/command_executer">a sample enclave</a> and check its sources); the latter is enabled by default, as can be checked in the <code>current_clocksource</code> file. How do these sources work?</p>
<p>The TSC mechanism is based on the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> register. It is a per-CPU monotonic counter implemented as a model-specific register (MSR). Every (virtual) CPU has its own register. The counter increments with every CPU cycle (<a href="https://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#311-cpu-tsc-capabilities">more or less</a>). Linux computes the current time based on the counter scaled by the CPU’s frequency and some initial date.</p>
<p>We can read (and write!) TSC values if we have root privileges. To do so, we need the TSC’s offset (<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/msr-index.h#L793">which is 16</a>) and its size (which is 8 bytes). MSR registers can be accessed through the <code>/dev/cpu</code> device:</p>
<pre>dd iflag=count_bytes,skip_bytes count=8 skip=16 if=/dev/cpu/0/msr
    dd if=&lt;(echo &#34;34d6 f1dc 8003 0000&#34; | xxd -r -p) of=/dev/cpu/0/msr seek=16 oflag=seek_bytes
</pre>
<p>The TSC can also be read with the <a href="https://linux.die.net/man/3/clock_gettime"><code>clock_gettime</code></a> method using the <code>CLOCK_MONOTONIC_RAW</code> clock ID, and with the <a href="https://www.felixcloutier.com/x86/rdtsc"><code>RDTSC</code> assembly instruction</a>.</p>
<p>Theoretically, if we change the TSC, the wall clock reported by <code>clock_gettime</code> with the <code>CLOCK_REALTIME</code> clock ID, by the <a href="https://linux.die.net/man/2/gettimeofday"><code>gettimeofday</code></a> function, and by the <a href="https://man7.org/linux/man-pages/man1/date.1.html"><code>date</code></a> command should change. However, the Linux kernel works hard to try to make TSCs behave reasonably and be synchronized with each other (for example, check out the <a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/tsc.c#L1142"><code>tsc</code> watchdog code</a> and functionality related to the <a href="https://www.spinics.net/lists/kvm/msg331239.html"><code>MSR_IA32_TSC_ADJUST</code></a> register). So breaking the clock is not that easy.</p>
<p>The TSC can be used to track time elapsed, but where do enclaves get the “some initial date” from which the time elapsed is counted? Usually, in other systems, that date is obtained using the NTP. However, enclaves do not have out-of-the-box access to the network and don’t use the NTP (see slide 26 of <a href="https://d1.awsstatic.com/events/reinvent/2020/Deep_dive_on_AWS_Nitro_Enclaves_for_apps_running_on_Amazon_EC2_SEC318.pdf">this presentation</a> from AWS’s 2020 re:Invent conference).</p>
<div id="attachment_108345"><p><img loading="lazy" decoding="async" aria-describedby="caption-attachment-108345" data-attachment-id="108345" data-permalink="https://blog.trailofbits.com/2024/09/24/notes-on-aws-nitro-enclaves-attack-surface/figure_5-5/" data-orig-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2.png" data-orig-size="1837,1061" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="figure_5" data-image-description="" data-image-caption="&lt;p&gt;Figure 5: Possible sources of time for an enclave&lt;/p&gt;
" data-medium-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-300x173.png" data-large-file="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-1650x953.png" tabindex="0" role="button" src="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-1650x953.png" alt="" width="690" height="399" srcset="https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-1650x953.png 1650w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-300x173.png 300w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-768x444.png 768w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2-1536x887.png 1536w, https://blog.trailofbits.com/wp-content/uploads/2024/09/figure_5-2.png 1837w" sizes="(max-width: 690px) 100vw, 690px"/></p><p id="caption-attachment-108345">Figure 5: Possible sources of time for an enclave</p></div>
<p>With the <code>tsc</code> clock and no NTP, the initial date is somewhat randomly selected—<a href="https://www.youtube.com/watch?v=d4sP9lB7z9o">the truth is</a> we haven’t determined where it comes from. You can force an enclave to boot without the <code>kvm-clock</code> by passing the <a href="https://wiki.archlinux.org/title/kernel_parameters"><code>no-kvmclock no-kvmclock-vsyscall</code> kernel parameters</a> (but note that these parameters should not be provided at runtime) and check the initial date for yourself. In our experiments, the date was:</p>
<pre>Tue Nov 30 00:00:00 UTC 1999
</pre>
<p>As you can see, the TSC mechanism doesn’t work well with enclaves. Moreover, it <a href="https://docs.kernel.org/virt/kvm/x86/timekeeping.html#virtualization-problems">breaks badly when the machine is virtualized</a>. Because of that, AWS introduced the <code>kvm-clock</code> as the default source of time for enclaves. It is an implementation of the paravirtual clock driver (pvclock) protocol (see <a href="https://opensource.com/article/17/6/timekeeping-linux-vms#pvclock:~:text=Xen%20and%20KVM%20hypervisors%20came%20up">this article</a> and <a href="https://rwmj.wordpress.com/2010/10/15/kvm-pvclock/">this blog post</a> for more info on pvclock). With this protocol, the host (the AWS Nitro hypervisor in our case) provides the <a href="https://www.kernel.org/doc/html/v6.8/virt/kvm/x86/msr.html?highlight=MSR_KVM_SYSTEM_TIME_NEW"><code>pvclock_vcpu_time_info</code> structure</a> to the guest (the enclave). The structure contains information that enables the guest to adjust its time measurements—most notably, the host’s wall clock (<code>system_time</code> field), which is used as the initial date.</p>
<p>Interestingly, the guest’s userland applications can use the TSC mechanism even if the kvm-clock is enabled. That’s because the RDTSC instruction is (<a href="https://www.spinics.net/lists/kvm/msg330980.html">usually</a>) <a href="https://oliveryang.net/2015/09/pitfalls-of-TSC-usage/#311-cpu-tsc-capabilities:~:text=The%20drawbacks%20of%20kvmclock%20is%20that%20user%20space%20TSC%20read%20will%20still%20have%20the%20problem.">not emulated</a> and therefore may provide non-adjusted TSC register readings.</p>
<p>Please note that if your enclaves use different clock sources or enable NTP, you should do some additional research to see if there are related security issues.</p>
<h3>Attestation</h3>
<p>Cryptographic attestation is the source of trust for end users. It is essential that users correctly parse and validate attestations. Fortunately, <a href="https://github.com/aws/aws-nitro-enclaves-nsm-api/blob/main/docs/attestation_process.md">AWS provides good documentation</a> on how to consume attestations.</p>
<p>The most important attestation data is protocol-specific, but <strong>we have a few generally applicable tips for developers to keep in mind</strong> (in addition to what’s written in the AWS documentation):</p>
<ul>
<li>The enclave should enforce a minimal nonce length.</li>
<li>xUsers should check the timestamp provided in the attestation in addition to nonces.</li>
<li>The attestation’s timestamp should not be used to reason about the enclave’s time. This timestamp may differ from the enclave’s time, as the former is generated by the hypervisor, and the latter by whatever clock source the enclave is using.</li>
<li><a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/">Don’t use RSA</a> for the <code>public_key</code> feature.</li>
</ul>
<h3>The NSM driver</h3>
<p>Your enclave applications will use the NSM driver, which is accessible via the <code>/dev/nsm</code> node. Its source code can be found in the <a href="https://github.com/aws/aws-nitro-enclaves-sdk-bootstrap/blob/main/nsm-driver/nsm.c"><code>aws-nitro-enclaves-sdk-bootstrap</code></a> and <a href="https://github.com/torvalds/linux/blob/b9873755a6c8ccfce79094c4dce9efa3ecb1a749/drivers/misc/nsm.c"><code>kernel</code></a> repositories. Applications communicate with the driver via the <code>IOCTL</code> system call and can use the <a href="https://github.com/aws/aws-nitro-enclaves-nsm-api/blob/4b851f3006c6fa98f23dcffb2cba03b39de9b8af/src/driver/mod.rs#L87-L87"><code>nsm-api</code> library</a> to do so.</p>
<p><strong>Developers should be aware that applications running inside an enclave may misuse the driver or the library.</strong> However, there isn’t much that can go wrong if developers take these steps:</p>
<ul>
<li>The driver lets you <a href="https://github.com/aws/aws-nitro-enclaves-nsm-api/blob/v0.4.0/nsm-lib/src/lib.rs#L118">extend and lock</a> more platform configuration registers (PCRs) than <a href="https://docs.aws.amazon.com/enclaves/latest/user/set-up-attestation.html#where">the basic 0–4 and 8</a> PCRs. Locked PCRs cannot be extended, and they are included in enclave attestations. How these additional PCRs are used depends on how you configure your application. Just make sure that it distinguishes between locked and unlocked ones.</li>
<li>Remember to make the application check the PCRs’ <a href="https://github.com/aws/aws-nitro-enclaves-nsm-api/blob/4b851f3006c6fa98f23dcffb2cba03b39de9b8af/nsm-lib/src/lib.rs#L94-L94">lock state</a> properties when sending the <code>DescribePCR</code> request to the NSM driver. Otherwise, it may be consulting a PCR that may still be manipulated.</li>
<li>Requests and responses are CBOR-encoded. Make sure to get the encoding right. Incorrectly decoded responses may provide false data to your application.</li>
<li>It is not recommended to use the <a href="https://github.com/aws/aws-nitro-enclaves-nsm-api/blob/4b851f3006c6fa98f23dcffb2cba03b39de9b8af/nsm-lib/src/lib.rs#L250-L250"><code>nsm_get_random</code></a> method directly. It skips the kernel’s algorithm for mixing multiple entropy sources and therefore is more prone to errors. Instead, use common randomness APIs (like <code>getrandom</code>).</li>
<li>The <a href="https://github.com/aws/aws-nitro-enclaves-nsm-api/pull/54"><code>nsm_init</code></a> method returns <code>-1</code> on error, which is an unusual behavior in Rust, so make sure your application accounts for that.</li>
</ul>
<h3>That’s (not) all folks</h3>
<p>Securing AWS Nitro Enclaves requires vigilance across multiple attack vectors. By implementing the recommendations in this post—from hardening virtual sockets to verifying randomness sources—you can significantly reduce the risk of compromise to your enclave workloads, helping shape a more secure future for confidential computing.</p>
<p>Key takeaways:</p>
<ol>
<li>Treat enclaves as a single trust zone and implement end-to-end security.</li>
<li>Mitigate side-channel risks through proper CPU allocation and constant-time processing.</li>
<li>Verify enclave entropy sources in the runtime.</li>
<li>Use the right time sources inside the enclave.</li>
<li>Implement robust attestation practices, including nonce and timestamp validation.</li>
</ol>
<p>For more security considerations, see our first post on <a href="https://blog.trailofbits.com/2024/02/16/a-few-notes-on-aws-nitro-enclaves-images-and-attestation/">enclave images and attestation</a>. If your enclave uses external systems—like <a href="https://docs.aws.amazon.com/enclaves/latest/user/kms.html">AWS Key Management Service</a> or <a href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html">AWS Certificate Manager</a>—review the systems and supporting tools for additional security footguns.</p>
<p>We encourage you to critically evaluate your own Nitro Enclave deployments. Trail of Bits offers in-depth security assessments and custom hardening strategies for confidential computing environments. If you’re ready to take your Nitro Enclaves’ security to the next level, <a href="https://www.trailofbits.com/contact/">contact us</a> to schedule a consultation with our experts and ensure that your sensitive workloads remain truly confidential.</p>

			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
