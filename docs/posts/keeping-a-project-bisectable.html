<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andrealmeid.com/post/2022-07-31-keep-bisect/">Original</a>
    <h1>Keeping a project bisectable</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>People write code. Test coverage is never enough. Some angry contributor will
disable the CI. And we all write bugs.</p>
<hr/>
<p>But that’s OK, it part of the job. Programming is hard and sometimes we may miss
a corner case, forget that numbers overflow and all other strange things that
computers can do.</p>
<p>One easy thing that we can do to help the poor developer that needs to find
what changed in the code that stopped their printer to work properly, is to keep
the project bisectable.</p>
<p>A “bisectable” project is a project where one can reliably run <a href="https://git-scm.com/docs/git-bisect"><code>git bisect</code></a>, which is a very useful command
to find a commit that introduces a bug. It works doing a binary search in the
git history until finding the guilty commit. This process involves building
each step of the bisect and running a test on each build to check if it’s good
or bad (that you can magically automate with <a href="https://git-scm.com/docs/git-bisect#_bisect_run"><code>git bisect run</code></a>).  The problem is, if
you can’t compile, you can’t tell if this commit is before or
after the bug (it can even be the culpable commit itself!). Then you need to
jump and try <a href="https://git-scm.com/docs/git-bisect#_avoiding_testing_a_commit">another commit</a>
and hope that it will compile, making the process more painful. A lot of build
breakages along the commit history can easily discourage a brave bisecter.</p>
<h3 id="keep-it-buildable">Keep it buildable</h3>
<p>To make sure we keep the bisectability of a project, we just need to make sure
that <strong>every commit</strong> is buildable. Sometimes we split a feature in a bunch of
cool commits but fail to see if they work as standalone changes. We can simply
do a interactive rebase, building it at each step:</p>
<pre><code>git rebase -i main --exec &#34;make&#34;
</code></pre><p>Replace <code>main</code> with the reference that you want to build from and <code>make</code> with
your fancy build system and ta-da, let the magic happen. If any of the steps
fails to build, the rebase stops (given that “any command that fails will
interrupt the rebase, with exit code 1”) so you can investigate what happened.</p>
<p>Of course, there’s still some room for build breakages for different build
configurations, but if you always follow this practice before upstreaming your
patches you are building a better git log.</p>
<ul>
<li>
<p><strong>Discussion on <a href="https://www.reddit.com/r/programming/comments/wg1ql3/keeping_a_project_bisectable/">Reddit</a>.</strong></p>
</li>
<li>
<p><strong>Discussion on <a href="https://news.ycombinator.com/item?id=32342860">Hacker News</a></strong></p>
</li>
</ul>

      
    </div></div>
  </body>
</html>
