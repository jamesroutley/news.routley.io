<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2025/04/19/things-zig-comptime-wont-do.html">Original</a>
    <h1>Things Zig comptime won&#39;t do</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        

        <figure>
          <blockquote>
            <p>
              Es el disco de Odín. Tiene un solo lado. En la tierra no hay otra
              cosa que tenga un solo lado.
            </p>
          </blockquote>
        </figure>
        <p>
          Zig’s comptime feature is most famous for what it can do: generics!,
          <a href="https://mitchellh.com/writing/zig-comptime-conditional-disable">conditional compilation</a>!,
          <a href="https://mitchellh.com/writing/zig-comptime-tagged-union-subset">subtyping</a>!, serialization!,
          <a href="https://matklad.github.io/2025/03/19/comptime-zig-orm.html">ORM</a>! That’s fascinating, but, to be fair, there’s a bunch of
          languages with quite powerful compile time evaluation capabilities
          that can do equivalent things. What I find more interesting is that
          Zig comptime is actually quite restrictive, by design, and won’t do
          many things! It manages to be very expressive <em>despite</em> being
          pretty limited. Let’s see!
        </p>
        <section id="No-Host-Leakage">
          <h2>
            <a href="#No-Host-Leakage">No Host Leakage </a>
          </h2>
          <p>
            When you execute code at compile time, on which machine does it
            execute? The natural answer is “on your machine”, but it is wrong!
            The code might not run on your machine, it can be cross compiled!
            For overall development sanity, it is important that <code>comptime</code> code observes the same behavior as the runtime
            code, and doesn’t leak details about the host on which the code is
            compiled. Zig doesn’t give comptime code access to host architecture
            (host — machine on which you compile code). Consider this Zig
            program:
          </p>

          <figure>
            <pre><code><span><span>const</span> std = <span>@import</span>(<span>&#34;std&#34;</span>);</span>
<span></span>
<span><span>comptime</span> {</span>
<span>    <span>const</span> x: <span>usize</span> = <span>0xbeef</span>;</span>
<span>    <span>const</span> xs: []<span>const</span> <span>u8</span> = std.mem.asBytes(<span>&amp;</span>x);</span>
<span>    <span>for</span> (xs) <span>|</span>byte<span>|</span> {</span>
<span>        <span>@compileLog</span>(byte);</span>
<span>    }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            I get the following output when compiling normally, on my computer
            for my computer:
          </p>

          <figure>
            <pre><code><span>λ ~/zig-0.14/zig build-lib main.zig</span>
<span>@as(u8, 239)</span>
<span>@as(u8, 190)</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 0)</span></code></pre>
          </figure>
          <p>
            But if I cross compile to a 32 bit big-endian architecture, comptime
            observes correct <code>usize</code>:
          </p>

          <figure>
            <pre><code><span>λ ~/zig-0.14/zig build-lib -target thumbeb-freestanding-none main.zig</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 0)</span>
<span>@as(u8, 190)</span>
<span>@as(u8, 239)</span></code></pre>
          </figure>
          <p>
            My understanding is that Jai, for example, doesn’t do this, and runs
            comptime code on the host.
          </p>
          <p>
            Rust’s declarative macros and const-fn don’t observe host
            architecture, but procedural macros do.
          </p>
        </section>
        <section id="No-eval">
          <h2>
            <a href="#No-eval">No #eval </a>
          </h2>
          <p>
            Many powerful compile-time meta programming systems work by allowing
            you to inject arbitrary strings into compilation, sort of like <code>#include</code> whose argument is a shell-script that generates the
            text to include dynamically. For example, D mixins work that way:
            <a href="https://dlang.org/articles/mixin.html">https://dlang.org/articles/mixin.html</a>
          </p>
          <p>
            And Rust macros, while technically producing a token-tree rather
            than a string, are more or less the same. In contrast, there’s
            absolutely no facility for dynamic source code generation in Zig.
            You just can’t do that, the feature isn’t!
          </p>
          <p>
            Zig has a completely different feature, partial
            evaluation/specialization, which, none the less, is enough to cover
            most of use-cases for dynamic code generation. Let’s see an
            artificial example:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> f</span>(x: <span>u32</span>, y: <span>u32</span>) <span>u32</span> {</span>
<span>    <span>if</span> (x <span>==</span> <span>0</span>) <span>return</span> y <span>+</span> <span>1</span>;</span>
<span>    <span>if</span> (x <span>==</span> <span>1</span>) <span>return</span> y <span>*</span> <span>2</span>;</span>
<span>    <span>return</span> y;</span>
<span>}</span></code></pre>
          </figure>
          <p>
            This is a normal function that dispatches on the first argument to
            select an operation to apply to the second argument. Nothing fancy!
            Now, the single feature that Zig has is marking the first argument
            with <code>comptime</code>
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> f</span>(<span>comptime</span> x: <span>u32</span>, y: <span>u32</span>) <span>u32</span> {</span>
<span>    <span>if</span> (x <span>==</span> <span>0</span>) <span>return</span> y <span>+</span> <span>1</span>;</span>
<span>    <span>if</span> (x <span>==</span> <span>1</span>) <span>return</span> y <span>*</span> <span>2</span>;</span>
<span>    <span>return</span> y;</span>
<span>}</span></code></pre>
          </figure>
          <p>
            The restriction here is that now, of course, when you call <code>f</code>, the first argument must be comptime-known. You can <span><code>f(92, user_input())</code>,</span> but you can’t
            <span><code>f(user_input(), 92)</code>.</span>
          </p>
          <p>
            The carrot you’ll get in exchange is a guarantee that, for each
            specific call with a particular value of <code>x</code>, the
            compiler will partially evaluate <code>f</code>, so only one branch
            will be left.
          </p>
          <p>
            Zig is an imperative language. Not everything is a function, there’s
            also control flow expressions, and they include partially-evaluated
            variations. For example, <code>for(xs)</code> is a normal runtime
            for loop over a slice, <code>comptime for(xs)</code> evaluates the
            entire loop at compile time, requiring that <code>xs</code> is
            comptime-known, and <code>inline for(xs)</code> requires that just
            the length of <code>xs</code> is known at comptime.
          </p>
          <p>
            Let’s apply specialization to the classic problem solved by
            code-generation — printing. You can imagine a proc-macro style
            solution that prints a struct by reflecting on which fields it has
            and emitting the code to print each field.
          </p>
          <p>
            In Zig, the same is achieved by specializing a recursive <code>print</code> function on the value of type:
          </p>

          <figure>
            <pre><code><span><span>const</span> S = <span>struct</span> {</span>
<span>    int: <span>u32</span>,</span>
<span>    string: []<span>const</span> <span>u8</span>,</span>
<span>    nested: <span>struct</span> {</span>
<span>        int: <span>u32</span>,</span>
<span>    },</span>
<span>};</span>
<span></span>
<span><span>pub</span> <span>fn</span><span> main</span>() <span>void</span> {</span>
<span>    <span>const</span> s: S = .{</span>
<span>        .int = <span>1</span>,</span>
<span>        .string = <span>&#34;hello&#34;</span>,</span>
<span>        .nested = .{ .int = <span>2</span> },</span>
<span>    };</span>
<span>    print(S, s);</span>
<span>}</span>
<span></span>
<span><span>fn</span><span> print</span>(<span>comptime</span> T: <span>type</span>, value: T) <span>void</span> {</span>
<span>    <span>if</span> (T <span>==</span> <span>u32</span>) <span>return</span> print_u32(value);</span>
<span>    <span>if</span> (T <span>==</span> []<span>const</span> <span>u8</span>) <span>return</span> print_string(value);</span>
<span>    <span>switch</span> (<span>@typeInfo</span>(T)) {</span>
<span>        .@<span>&#34;struct&#34;</span> =&gt; <span>|</span>info<span>|</span> {</span>
<span>            print_literal(<span>&#34;{&#34;</span>);</span>
<span>            <span>var</span> space: []<span>const</span> <span>u8</span> = <span>&#34;&#34;</span>;</span>
<span>            <span>inline</span> <span>for</span> (info.fields) <span>|</span>field<span>|</span> {</span>
<span>                print_literal(space);</span>
<span>                space = <span>&#34;, &#34;</span>;</span>
<span></span>
<span>                print_literal(field.name);</span>
<span>                print_literal(<span>&#34; = &#34;</span>);</span>
<span>                <span>const</span> field_value = <span>@field</span>(value, field.name);</span>
<span>                print(field.<span>type</span>, field_value);</span>
<span>            }</span>
<span>            print_literal(<span>&#34;}&#34;</span>);</span>
<span>        },</span>
<span>        <span>else</span> =&gt; <span>comptime</span> <span>unreachable</span>,</span>
<span>    }</span>
<span>}</span>
<span></span>
<span><span>fn</span><span> print_u32</span>(value: <span>u32</span>) <span>void</span> {</span>
<span>    std.debug.print(<span>&#34;{d}&#34;</span>, .{value});</span>
<span>}</span>
<span></span>
<span><span>fn</span><span> print_string</span>(value: []<span>const</span> <span>u8</span>) <span>void</span> {</span>
<span>    std.debug.print(<span>&#34;<span>\&#34;</span>{s}<span>\&#34;</span>&#34;</span>, .{value});</span>
<span>}</span>
<span></span>
<span><span>fn</span><span> print_literal</span>(literal: []<span>const</span> <span>u8</span>) <span>void</span> {</span>
<span>    std.debug.print(<span>&#34;{s}&#34;</span>, .{literal});</span>
<span>}</span></code></pre>
          </figure>
          <p>
            Our <code>print</code> is set up exactly as our <code>f</code>
            before — the first argument is a comptime-known dispatch parameter.
            If <code>T</code> is an int or a string, the compiler calls <code>print_u32</code> or <code>print_string</code> directly.
          </p>
          <p>
            The third case is more complicated. First, we use <code>@typeInfo</code> to get a comptime value describing our type, and,
            in particular, the list of fields it has. Then, we iterate this list
            and recursively print each field. Note that although the list of
            fields is known in its entirety, we can’t <code>comptime for</code>
            it, we need <code>inline for</code>. This is because the <em>body</em> of our loop depends on the runtime
            <code>value</code>, and can’t be fully evaluated at compile time.
            This might be easier to see if you think in terms of functions. The
            <code>for</code> loop is essentially a map:
          </p>

          <figure>
            <pre><code><span>map :: [a] -&gt; (a -&gt; b) -&gt; [b]</span>
<span>map xs f = ...</span></code></pre>
          </figure>
          <p>
            If both <code>xs</code> and <code>f</code> are comptime-known, you
            can evaluate the entire loop at compile time. But in our case <code>f</code> actually closes over a runtime value, so we can’t evaluate
            everything. Still, we can specialize on the first argument, which
            <em>is</em> known at compile time. This is precisely the difference
            between <code>comptime</code> and <code>inline</code>
            <code>for</code>.
          </p>
        </section>
        <section id="No-DSLs">
          <h2>
            <a href="#No-DSLs">No DSLs </a>
          </h2>
          <p>
            Many meta programming systems, like macros in Lisp or Rust, not only
            <em>produce</em> arbitrary code, but also take arbitrary custom
            syntax as input, as long as parentheses are matched:
          </p>

          <figure>
            <pre><code><span><span>use</span> inline_python::python;</span>
<span></span>
<span><span>let</span> <span>who</span> = <span>&#34;world&#34;</span>;</span>
<span><span>let</span> <span>n</span> = <span>5</span>;</span>
<span>python! {</span>
<span>    <span>for</span> <span>i</span> <span>in</span> <span>range</span>(<span>&#39;n</span>):</span>
<span>        <span>print</span>(i, <span>&#34;Hello&#34;</span>, <span>&#39;who</span>)</span>
<span>    <span>print</span>(<span>&#34;Goodbye&#34;</span>)</span>
<span>}</span></code></pre>
          </figure>
          <p>
            Zig doesn’t have any extension points for custom syntax. Indeed, you
            can’t pass Zig <em>syntax</em> (code) to comptime functions at all!
            Everything operates on Zig values. That being said, Zig is very
            lightweight when it comes to describing free-form data, so this
            isn’t much of a hindrance. <em>And</em>
            in any case, you can always pass your custom syntax as a comptime
            string. This is exactly how “printf” works:
          </p>

          <figure>
            <pre><code><span><span>pub</span> <span>fn</span><span> print</span>(<span>comptime</span> fmt: []<span>const</span> <span>u8</span>, args: <span>anytype</span>) <span>void</span></span></code></pre>
          </figure>
          <p>
            Here, <code>fmt</code> is an embedded DSL, which is checked at
            compile time to match the arguments.
          </p>
        </section>
        <section id="No-RTTI">
          <h2>
            <a href="#No-RTTI">No RTTI </a>
          </h2>
          <p>
            Zig printing code looks suspiciously close to how you’d do this sort
            of thing in a dynamic language like Python. In fact, it is <em>precisely</em> that same code, except that it is specialized over
            runtime type information Python has to enable this sort of thing.
            Furthermore, Zig actually <em>requires</em> that all type meta
            programming is specialized away. Types as values <em>only</em> exist
            at compile time. Still, looking at our print, we might be concerned
            over code size — we are effectively generating a fresh copy of <code>print</code> for any data structure. Our code will be smaller, and
            will compile faster if there’s just a single <code>print</code> that
            takes an opaque pointer and runtime parameter describing the type of
            the value (its fields and offsets). So let’s roll our own runtime
            type information. For our example, we support ints, strings, and
            structs with fields. For fields, our RTTI should include their names
            and offsets:
          </p>

          <figure>
            <pre><code><span><span>const</span> RTTI = <span>union</span>(<span>enum</span>) {</span>
<span>    <span>u32</span>,</span>
<span>    string,</span>
<span>    @<span>&#34;struct&#34;</span>: []<span>const</span> Field,</span>
<span></span>
<span>    <span>const</span> Field = <span>struct</span> {</span>
<span>        name: []<span>const</span> <span>u8</span>,</span>
<span>        offset: <span>u32</span>,</span>
<span>        rtti: RTTI,</span>
<span>    };</span>
<span>};</span></code></pre>
          </figure>
          <p>
            The printing itself is not particularly illuminating, we just need
            to cast an opaque pointer according to RTTI:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> print_dyn</span>(T: RTTI, value: <span>*</span><span>const</span> anyopaque) <span>void</span> {</span>
<span>    <span>switch</span> (T) {</span>
<span>        .<span>u32</span> =&gt; {</span>
<span>            <span>const</span> value_u32: <span>*</span><span>const</span> <span>u32</span> =</span>
<span>                <span>@alignCast</span>(<span>@ptrCast</span>(value));</span>
<span>            print_u32(value_u32.<span>*</span>);</span>
<span>        },</span>
<span>        .string =&gt; {</span>
<span>            <span>const</span> value_string: <span>*</span><span>const</span> []<span>const</span> <span>u8</span> =</span>
<span>                <span>@alignCast</span>(<span>@ptrCast</span>(value));</span>
<span>            print_string(value_string.<span>*</span>);</span>
<span>        },</span>
<span>        .@<span>&#34;struct&#34;</span> =&gt; <span>|</span>info<span>|</span> {</span>
<span>            print_literal(<span>&#34;{&#34;</span>);</span>
<span>            <span>var</span> space: []<span>const</span> <span>u8</span> = <span>&#34;&#34;</span>;</span>
<span>            <span>for</span> (info) <span>|</span>field<span>|</span> {</span>
<span>                print_literal(space);</span>
<span>                space = <span>&#34;, &#34;</span>;</span>
<span></span>
<span>                print_literal(field.name);</span>
<span>                print_literal(<span>&#34; = &#34;</span>);</span>
<span>                <span>const</span> field_ptr: <span>*</span><span>const</span> anyopaque =</span>
<span>                    <span>@as</span>([<span>*</span>]<span>const</span> <span>u8</span>, <span>@ptrCast</span>(value)) <span>+</span> field.offset;</span>
<span>            }</span>
<span>            print_literal(<span>&#34;}&#34;</span>);</span>
<span>        },</span>
<span>    }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            Finally, we need to compute <code>RTTI</code>, which amounts to
            taking comptime-only Zig type info and extracting important bits
            into an <code>RTTI</code> struct which is computed at compile time,
            but can exist at runtime as well:
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> reflect</span>(<span>comptime</span> T: <span>type</span>) RTTI {</span>
<span>    <span>comptime</span> {</span>
<span>        <span>if</span> (T <span>==</span> <span>u32</span>) <span>return</span> .<span>u32</span>;</span>
<span>        <span>if</span> (T <span>==</span> []<span>const</span> <span>u8</span>) <span>return</span> .string;</span>
<span>        <span>switch</span> (<span>@typeInfo</span>(T)) {</span>
<span>            .@<span>&#34;struct&#34;</span> =&gt; <span>|</span>info<span>|</span> {</span>
<span>                <span>var</span> fields: [info.fields.len]Field = <span>undefined</span>;</span>
<span>                <span>for</span> (<span>&amp;</span>fields, info.fields) <span>|</span><span>*</span>slot, field<span>|</span> {</span>
<span>                    slot.<span>*</span> = .{</span>
<span>                        .name = field.name,</span>
<span>                        .offset = <span>@offsetOf</span>(T, field.name),</span>
<span>                        .rtti = reflect(field.<span>type</span>),</span>
<span>                    };</span>
<span>                }</span>
<span>                <span>const</span> fields_frozen = fields;</span>
<span>                <span>return</span> .{ .@<span>&#34;struct&#34;</span> = <span>&amp;</span>fields_frozen };</span>
<span>            },</span>
<span>            <span>else</span> =&gt; <span>unreachable</span>,</span>
<span>        }</span>
<span>    }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            The call site is illustrative: we need <code>comptime</code> to <em>compute</em> the type information, but then we reify it as some
            real bytes in the binary, and use it as runtime value when calling
            <code>print_dyn</code>.
          </p>

          <figure>
            <pre><code><span><span>pub</span> <span>fn</span><span> main</span>() <span>void</span> {</span>
<span>    <span>const</span> s: S = .{</span>
<span>        .int = <span>1</span>,</span>
<span>        .string = <span>&#34;hello&#34;</span>,</span>
<span>        .nested = .{ .int = <span>2</span> },</span>
<span>    };</span>
<span>    print_dyn(<span>comptime</span> RTTI.reflect(S), <span>&amp;</span>s);</span>
<span>}</span></code></pre>
          </figure>
        </section>
        <section id="No-New-API">
          <h2>
            <a href="#No-New-API">No New API </a>
          </h2>
          <p>
            You can use Zig comptime to create new types. That’s how a <a href="https://matklad.github.io/2025/03/19/comptime-zig-orm.html">Zig ORM</a> can work. However, it is impossible to add methods to
            generated types, they must be inert bundles of fields. In Rust, when
            you use a derive macro, it can arbitrarily extend type’s public API,
            and you need to read proc macro docs (or look at the generated code)
            to figure out what’s available. In Zig, types’s API is always hand
            written, but it can use comptime reflection internally.
          </p>
          <p>
            So, if you are building a JSON serialization library in Zig, you
            can’t add <code>.to_json</code> method to user-types. You’ll
            necessarily have to supply a normal top-level function like
          </p>

          <figure>
            <pre><code><span><span>fn</span><span> to_json</span>(<span>comptime</span> T: <span>type</span>, value: T, writer: Writer) <span>!</span><span>void</span> {</span>
<span>    ...</span>
<span>}</span></code></pre>
          </figure>
          <p>
            If you want to make sure that types explicitly opt-in JSON
            serialization, you need to ask the user to mark types specially:
          </p>

          <figure>
            <pre><code><span><span>const</span> Person = <span>struct</span> {</span>
<span>    first_name: []<span>const</span> <span>u8</span>,</span>
<span>    last_name: []<span>const</span> <span>u8</span>,</span>
<span></span>
<span>    <span>pub</span> <span>const</span> JSONOptions = .{</span>
<span>        .style = .camelCase,</span>
<span>    };</span>
<span>}</span></code></pre>
          </figure>
          <p>
            With this setup, <code>to_json</code> can only allow primitives and
            types with <code>JSONOptions</code>.
          </p>
        </section>
        <section id="No-IO">
          <h2>
            <a href="#No-IO">No IO </a>
          </h2>
          <p>
            Last but not least, Zig comptime does not allow any kind of input
            output. There isn’t even any kind of sandbox, as there are no IO
            facilities in the first place. So, while compiling the code, you
            can’t talk to your database to generate the schema. In exchange,
            compile time evaluation is hermetic, reproducible, safe, and
            cacheable.
          </p>
          <p>
            If you do need to talk to the database at build time, you can still
            do that, just through the build system! Zig’s <code>build.zig</code>
            is a general purpose build system, which easily supports the
            use-case of running an arbitrary Zig program to generate arbitrary
            Zig code which can then be normally
            <code>@import</code>ed.
          </p>
        </section>
        <section id="El-Disco">
          <h2>
            <a href="#El-Disco">El Disco </a>
          </h2>
          <p>
            <a href="https://www.tedinski.com/2018/01/30/the-one-ring-problem-abstraction-and-power.html">Any abstraction has two sides</a>. Powerful abstractions are useful
            because they are more expressive. But the flip-side is that
            abstraction-using code becomes harder to reason about, because the
            space of what it can possibly do is so vast. This dependency is not
            zero sum. A good abstraction can be simultaneously more powerful and
            easier to reason about than a bad one.
          </p>
          <p>
            Meta programming is one of the more powerful abstractions. It is
            very capable in Zig, and comes at a significant cost — Zig doesn’t
            have declaration-site type checking of comptime code. That being
            said, I personally find Zig’s approach to be uniquely tidy, elegant,
            and neat! It does much less than alternative systems, but ends
            extremely ergonomic in practice, and <em>relatively</em> easy to
            wrap ones head around.
          </p>
        </section>
      </article>
    </div></div>
  </body>
</html>
