<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexharri.com/blog/icelandic-name-declension-trie">Original</a>
    <h1>Compressing Icelandic name declension patterns into a 3.27 kB trie</h1>
    
    <div id="readability-page-1" class="page"><div><main><div><p><time datetime="2025-08-02">August 2, 2025</time></p></div><p>Displaying personal names in Icelandic user interfaces is surprisingly hard. This is because of <em>declension</em> — a language feature where the forms of nouns change to communicate a syntactic function.</p>
<p>In Icelandic, personal names have four forms, one for each of the <a target="_blank" href="https://en.wikipedia.org/wiki/Icelandic_grammar#Nouns">grammatical cases of Icelandic nouns</a>. Take the name <em>“Guðmundur”</em>:</p>
<table><tbody><tr><th>Grammatical case</th><th>Form</th></tr><tr><td>Nominative</td><td>Guðmundur</td></tr><tr><td>Accusative</td><td>Guðmund</td></tr><tr><td>Dative</td><td>Guðmundi</td></tr><tr><td>Genitive</td><td>Guðmundar</td></tr></tbody></table>
<p>When including a name in a sentence, the sentence’s structure determines the grammatical case, and correspondingly, a certain form of the name should be used. Using the wrong form results in a “broken” feel that native speakers associate with non-native speakers not yet fluent in the language.</p>
<p>The problem is that Icelandic personal names are always stored in the <a target="_blank" href="https://en.wikipedia.org/wiki/Nominative_case">nominative</a> case. If you’ve loaded a user from a database, their name will be in the nominative case. This creates a problem when you have a sentence structure that requires, for example, the <a target="_blank" href="https://en.wikipedia.org/wiki/Accusative_case">accusative</a> form of the name.</p>
<p>As a developer, you can work around that by rewriting the sentence to use the nominative case, which can be <em>very</em> awkward, or by using a pronoun (e.g. <em>they</em>). Both are unsatisfactory.</p>
<p>A few years ago, I built a JavaScript library to solve this issue. It applies any of the four grammatical cases to an Icelandic name, provided in the nominative case:</p>
<div><div><div><pre><p><span>applyCase</span><span>(</span><span>&#34;Guðmundur&#34;</span><span>,</span><span> </span><span>&#34;accusative&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>When building this library, I did not code <em>any</em> declension rules by hand. Instead, the rules of Icelandic name declension are derived from public Icelandic data for personal names and their forms. The rules are encoded in a trie-like data structure that uses clever compression techniques to get the library’s bundle size under 4.5 kB gzipped. This lets the library be included in web apps without increasing bundle size significantly.</p>
<p>The rest of the post will walk through this problem in detail, and go over the compression techniques I used to get the trie to such a small size.</p>
<h2>Data for Icelandic name declension</h2>
<p>Iceland has a publicly run institution, <a target="_blank" href="https://www.arnastofnun.is/en">Árnastofnun</a>, that manages the <a target="_blank" href="https://bin.arnastofnun.is/DMII/">Database of Icelandic Morphology</a> (DIM). The database was created, amongst other reasons, to support Icelandic language technology.</p>
<p>DIM publishes various <a target="_blank" href="https://bin.arnastofnun.is/DMII/LTdata/">datasets</a>, but we’ll use <a target="_blank" href="https://bin.arnastofnun.is/DMII/LTdata/k-format/">Kristín’s Format</a> (the K-format), downloadable as a CSV. Here’s what the K-format data entries for “Guðmundur” look like:</p>
<div><div><div><pre><p><span><span>Guðmundur</span><span>;355264;kk;ism;1;;;;K;</span><span>Guðmundur</span><span>;</span><span>NFET</span><span>;1;;;</span></span></p><p><span><span>Guðmundur</span><span>;355264;kk;ism;1;;;;K;</span><span>Guðmund</span><span>;</span><span>ÞFET</span><span>;1;;;</span></span></p><p><span><span>Guðmundur</span><span>;355264;kk;ism;1;;;;K;</span><span>Guðmundi</span><span>;</span><span>ÞGFET</span><span>;1;;;</span></span></p><p><span><span>Guðmundur</span><span>;355264;kk;ism;1;;;;K;</span><span>Guðmundar</span><span>;</span><span>EFET</span><span>;1;;;</span></span></p><p><span><span>^^^^^^^^^</span>                      <span>^^^^^^^^^</span> <span>^^^^</span></span></p><p><span><span>Name</span>                           <span>Form</span>      <span>Case</span></span></p></pre></div></div></div>
<p>From this, we can see that the name “Guðmundur” in the accusative (ÞFET) case is “Guðmund”, and so on.</p>
<p>From the K-format data, we can construct an array for each name containing its form for each grammatical case:</p>
<div><div><div><pre><p><span>[</span><span></span></p><p><span>  </span><span>&#34;Guðmundur&#34;</span><span>,</span><span> </span><span></span></p><p><span>  </span><span>&#34;Guðmund&#34;</span><span>,</span><span>   </span><span></span></p><p><span>  </span><span>&#34;Guðmundi&#34;</span><span>,</span><span>  </span><span></span></p><p><span>  </span><span>&#34;Guðmundar&#34;</span><span>,</span><span> </span><span></span></p><p><span></span><span>]</span><span></span></p></pre></div></div></div>
<p>However, the K-format has data for most words in the Icelandic language, not just personal names. With over <strong>7 million</strong> entries, this data set is huge. We’ll need some way to whittle the list down.</p>
<p>Luckily for us, Iceland has the <a target="_blank" href="https://island.is/en/search-in-icelandic-names">Personal Names Register</a>. It lists all Icelandic personal names approved — and rejected — by the <a target="_blank" href="https://en.wikipedia.org/wiki/Icelandic_Naming_Committee">Personal Names Committee</a> (yes, that exists).</p>
<p>We can use the set of approved Icelandic names to filter the K-format data. Of the roughly 4,500 approved Icelandic names, the K-format has declension data for over 3,600. With that, we have declension data for more than 80% of Icelandic names:</p>
<div><div><div><pre><p><span>const</span><span> </span><span>NAME_FORMS</span><span> </span><span>=</span><span> </span><span>[</span><span></span></p><p><span>  </span><span>[</span><span></span></p><p><span>    </span><span>&#34;Aðalberg&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;Aðalberg&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;Aðalberg&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;Aðalbergs&#34;</span><span></span></p><p><span>  </span><span>]</span><span>,</span><span></span></p><p><span>  </span><span>[</span><span></span></p><p><span>    </span><span>&#34;Agnes&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;Agnesi&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;Agnesi&#34;</span><span>,</span><span></span></p><p><span>    </span><span>&#34;Agnesar&#34;</span><span></span></p><p><span>  </span><span>]</span><span>,</span><span></span></p><p><span></span><span>]</span><span></span></p></pre></div></div></div>
<h2>Naive implementation</h2>
<p>With the declension data in place, let’s get to writing our library. The library will export a single <code><span>applyCase</span></code> function that takes a name in the nominative case and the grammatical case that the name should be returned in:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>applyCase</span><span>(</span><span>name</span><span>:</span><span> </span><span>string</span><span>,</span><span> grammaticalCase</span><span>:</span><span> Case</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>applyCase</span><span>(</span><span>&#34;Guðmundur&#34;</span><span>,</span><span> </span><span>&#34;accusative&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>The naive implementation would be to find the forms of the name and the index of the form to return:</p>
<div><div><div><pre><p><span>const</span><span> </span><span>CASES</span><span> </span><span>=</span><span> </span><span>[</span><span>&#34;nominative&#34;</span><span>,</span><span> </span><span>&#34;accusative&#34;</span><span>,</span><span> </span><span>&#34;dative&#34;</span><span>,</span><span> </span><span>&#34;genitive&#34;</span><span>]</span><span>;</span><span></span></p><p><span></span><span>function</span><span> </span><span>applyCase</span><span>(</span><span>name</span><span>:</span><span> </span><span>string</span><span>,</span><span> grammaticalCase</span><span>:</span><span> Case</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> nameForms </span><span>=</span><span> </span><span>NAME_FORMS</span><span>.</span><span>find</span><span>(</span><span>forms </span><span>=&gt;</span><span> forms</span><span>[</span><span>0</span><span>]</span><span> </span><span>===</span><span> name</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>const</span><span> caseIndex </span><span>=</span><span> </span><span>CASES</span><span>.</span><span>indexOf</span><span>(</span><span>grammaticalCase</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>and, with those in hand, return the form at <code><span>caseIndex</span></code> if <code><span>nameForms</span></code> was found for the input <code><span>name</span></code>, otherwise returning <code><span>name</span></code> as a fallback:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>applyCase</span><span>(</span><span>name</span><span>:</span><span> </span><span>string</span><span>,</span><span> grammaticalCase</span><span>:</span><span> Case</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> nameForms </span><span>=</span><span> </span><span>NAME_FORMS</span><span>.</span><span>find</span><span>(</span><span>forms </span><span>=&gt;</span><span> forms</span><span>[</span><span>0</span><span>]</span><span> </span><span>===</span><span> name</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>const</span><span> caseIndex </span><span>=</span><span> </span><span>CASES</span><span>.</span><span>indexOf</span><span>(</span><span>grammaticalCase</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> nameForms</span><span>?.</span><span>[</span><span>caseIndex</span><span>]</span><span> </span><span>||</span><span> name</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>This “works” but has two main issues, the first of which is bundle size. The <code><span>NAME_FORMS</span></code> list is about 30 kB gzipped, which I think is a tad much to add to a web app’s bundle size.</p>
<p>The second issue is that this naive implementation only works for names in the <code><span>NAME_FORMS</span></code> list. As mentioned earlier, there are around 800 approved Icelandic names that are not covered by the DIM data.</p>
<p>Let’s see how we can solve both of those.</p>
<h2>Encoding the forms compactly</h2>
<p>We’re currently storing the four forms of each name in full. We can remove a lot of redundancy by finding the <a target="_blank" href="https://leetcode.com/problems/longest-common-prefix">longest common prefix</a> of the name and the suffixes of each form.</p>
<p>Consider the forms of “Guðmundur”:</p>
<div><div><div><pre><p><span>Guðmundur</span></p><p><span>Guðmund</span></p><p><span>Guðmundi</span></p><p><span>Guðmundar</span></p></pre></div></div></div>
<p>The longest common prefix is “Guðmund”, and the suffixes are as follows:</p>
<div><div><div><pre><p><span><span>Guðmund</span> <span>ur</span></span></p><p><span><span>Guðmund</span></span></p><p><span><span>Guðmund</span> <span>i</span></span></p><p><span><span>Guðmund</span> <span>ar</span></span></p><p><span><span>^^^^^^^</span> <span>^^</span></span></p><p><span><span>Prefix</span>  <span>Suffix</span></span></p></pre></div></div></div>
<p>We can store the suffixes compactly in a string like so:</p>
<div><div><div><pre><p><span>suffixes</span><span>.</span><span>join</span><span>(</span><span>&#34;,&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>Which for Guðmundur, gives us:</p>
<div><div><div><pre><p><span>&#34;ur,,i,ar&#34;</span><span></span></p></pre></div></div></div>
<p>Since <code><span>applyCase</span></code> receives the nominative case of the name as input, we can derive the prefix from the length of the nominative suffix’s length.</p>
<div><div><div><pre><p><span>function</span><span> </span><span>getPrefix</span><span>(</span><span>nameNominative</span><span>,</span><span> suffixLength</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>return</span><span> nameNominative</span><span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span><span> </span><span>-</span><span>suffixLength</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>const</span><span> suffixes </span><span>=</span><span> </span><span>&#34;ur,,i,ar&#34;</span><span>;</span><span></span></p><p><span></span><span>const</span><span> nominativeSuffix </span><span>=</span><span> suffixes</span><span>.</span><span>split</span><span>(</span><span>&#34;,&#34;</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span><span></span></p><p><span></span><span>getPrefix</span><span>(</span><span>&#34;Guðmundur&#34;</span><span>,</span><span> nominativeSuffix</span><span>.</span><span>length</span><span>)</span><span></span></p></pre></div></div></div>
<p>We’ll call this method of encoding the suffixes of each form in a string the “suffix encoding”, or just “encoding”, from here on.</p>
<p>A feature of the suffix encoding is that the encoding is not tied to any specific name (“Guðmund” appears nowhere). Instead, the suffix encoding describes a <em>pattern</em> of declension, which we’ll use to our advantage later.</p>
<h2>Retrieving the suffixes by name</h2>
<p>When we were storing the raw forms in an array, it was very easy to find the forms of any given name:</p>
<div><div><div><pre><p><span>NAME_FORMS</span><span>.</span><span>find</span><span>(</span><span>forms </span><span>=&gt;</span><span> forms</span><span>[</span><span>0</span><span>]</span><span> </span><span>===</span><span> name</span><span>)</span><span></span></p></pre></div></div></div>
<p>But the suffix encoding doesn’t encode the name itself, so we need a way to retrieve the encoding. The simplest method would be a plain hash map:</p>
<div><div><div><pre><p><span>const</span><span> nameToFormsEncoding </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>  Guðmundur</span><span>:</span><span> </span><span>&#34;ur,,i,ar&#34;</span><span>,</span><span></span></p><p><span></span><span>}</span><span>;</span><span></span></p></pre></div></div></div>
<p>Putting bundle size concerns aside, a hash map doesn’t solve the problem of names not in the list of approved Icelandic names being excluded.</p>
<p>Here, one helpful fact about Icelandic declension is that names with similar suffixes <em>tend</em> to follow the same pattern of declension. These names ending in <em>“ur”</em> all have the same suffix encoding of <code><span>&#34;ur,,i,ar&#34;</span></code>:</p>
<div><div><div><pre><p><span>Ástvaldur</span></p><p><span>Bárður</span></p><p><span>Freymundur</span></p><p><span>Ingimundur</span></p><p><span>Sigurður</span></p><p><span>Þórður</span></p></pre></div></div></div>
<p>There are, in fact, 88 approved Icelandic names with this exact pattern of declension, and they all end with <em>“dur”</em>, <em>“tur”</em> or “<em>ður</em>”.</p>
<p>The naive approach, then, would be to implement a <code><span>getSuffixEncoding</span></code> function that captures these patterns:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>getSuffixEncoding</span><span>(</span><span>name</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>/</span><span>(d|ð|t)ur$</span><span>/</span><span>.</span><span>test</span><span>(</span><span>name</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>&#34;ur,,i,ar&#34;</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>But that quickly breaks down. There are other names ending with <em>“ður”</em> or <em>“dur”</em> that follow a different pattern of declension:</p>
<ul>
<li><em>“Aðalráður”</em> and <em>“Arnmóður”</em> have a suffix encoding of <code><span>&#34;ur,,i,s&#34;</span></code></li>
<li><em>“Baldur”</em> has a suffix encoding of <code><span>&#34;ur,ur,ri,urs&#34;</span></code></li>
<li><em>“Hlöður”</em> and <em>“Lýður”</em> both have a suffix encoding of <code><span>&#34;ur,,,s&#34;</span></code></li>
</ul>
<p>In fact, take a look at this <a target="_blank" href="https://gist.github.com/alexharri/2102bad44fbce8f4c41615304b09e1fe">gist</a> showing every approved Icelandic personal name grouped by their suffix encoding (there are 124 unique encodings). You’ll immediately find patterns, but if you take a closer look you’ll find numerous counterexamples to those patterns. Capturing all of these rules and their exceptions in code would be a tedious and brittle affair.</p>
<p>Instead of trying to code up the rules manually, we can use a data structure that lends itself perfectly to this problem.</p>
<h2>Tries</h2>
<p>The <a target="_blank" href="https://en.wikipedia.org/wiki/Trie">trie</a> data structure, also known as a prefix tree, is a tree data structure that maps string keys to values. In tries, each character in the key becomes a node in the tree that points to the next possible characters.</p>
<p>Take, for example, the name <em>“Heimir”</em>, which has a suffix encoding of <code><span>&#34;r,,,s&#34;</span></code>. If we create an empty trie and insert <em>“Heimir”</em> and <code><span>&#34;r,,,s&#34;</span></code> as a key-value pair into it, we get:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/heimir-trie.svg" width="630"/></p></div>
<p>Let’s now insert <em>“Heiðar”</em> into the trie, which has a suffix encoding of <code><span>&#34;r,,i,s&#34;</span></code>. The names share the first three characters, so they share the first three nodes in the trie:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/heimir-heidar-trie.svg" width="630"/></p></div>
<p>However, we actually want to insert the keys <em>backwards</em> into the trie. That is because, like I mentioned earlier, names with similar endings (suffixes) tend to have similar suffix encodings. Inserting keys backwards results in the values for all names sharing a certain suffix being grouped within that suffix’s subtree.</p>
<p>Let’s take a concrete example — consider the following names that end with <em>“ur”</em> and their encodings:</p>
<div><div><div><pre><p><span><span>Ylfur</span>    <span>ur,i,i,ar</span></span></p><p><span><span>Knútur</span>   <span>ur,,i,s</span></span></p><p><span><span>Hrútur</span>   <span>ur,,i,s</span></span></p><p><span><span>Loftur</span>   <span>ur,,i,s</span></span></p><p><span><span>Name</span>     <span>Suffix encoding</span></span></p></pre></div></div></div>
<p>Inserting them <em>backwards</em> into a new trie gives us the following:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/ur-divergence.svg" width="630"/></p></div>
<p>Once we start inserting the names backwards, every node in the trie corresponds to a specific suffix match:</p>
<ul>
<li>The <span><span>r</span><span></span><span>u</span></span> subtree corresponds to the <em>“ur”</em> suffix.</li>
<li>The <span><span>r</span><span></span><span>u</span><span></span><span>t</span></span> subtree corresponds to the <em>“tur”</em> suffix.</li>
</ul>
<p>Additionally:</p>
<ul>
<li>The <span><span>r</span><span></span><span>u</span></span> subtree contains the values for all names ending in <em>“ur”</em>.</li>
<li>The <span><span>r</span><span></span><span>u</span><span></span><span>t</span></span> subtree contains the values for all names ending in <em>“tur”</em>.</li>
</ul>
<p>Having the values of names sharing a common suffix all within the same subtree will help us find patterns in suffix-to-value mappings. We can then apply those patterns to not-before-seen names.</p>
<p>Before we get to that, let’s quickly cover trie lookups.</p>
<h2>Trie lookups</h2>
<p>Let’s implement a <code><span>trieLookup</span></code> function that takes the trie’s <code><span>root</span></code> node and a <code><span>key</span></code> (name) to find a value for:</p>
<div><div><div><pre><p><span>interface</span><span> </span><span>TrieNode</span><span> </span><span>{</span><span></span></p><p><span>  children</span><span>?</span><span>:</span><span> </span><span>{</span><span> </span><span>[</span><span>key</span><span>:</span><span> </span><span>string</span><span>]</span><span>:</span><span> TrieNode </span><span>}</span><span>;</span><span></span></p><p><span>  value</span><span>?</span><span>:</span><span> </span><span>string</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>function</span><span> </span><span>trieLookup</span><span>(</span><span>root</span><span>:</span><span> TrieNode</span><span>,</span><span> key</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>For each character in the key, we traverse to the child <code><span>node</span></code> for that character, stopping if no such <code><span>node</span></code> exists. After that, we return the value of the resulting <code><span>node</span></code>, if present:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>trieLookup</span><span>(</span><span>root</span><span>:</span><span> TrieNode</span><span>,</span><span> key</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> node</span><span>:</span><span> TrieNode </span><span>|</span><span> </span><span>undefined</span><span> </span><span>=</span><span> root</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> char </span><span>of</span><span> </span><span>reverse</span><span>(</span><span>key</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    node </span><span>=</span><span> node</span><span>.</span><span>children</span><span>?.</span><span>[</span><span>char</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>node</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>break</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> node</span><span>?.</span><span>value</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>Note: <!-- -->We reverse the lookup key because names are inserted into the trie backwards.</p>
<p>Looking up a name that we insert into the trie returns its suffix encoding, as expected:</p>
<div><div><div><pre><p><span>trieLookup</span><span>(</span><span>root</span><span>,</span><span> </span><span>&#34;Loftur&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<h2>Compressing the trie</h2>
<p>In our trie from earlier, every leaf in the <span><span>r</span><span></span><span>u</span><span></span><span>t</span></span> subtree has the same value of <code><span>&#34;ur,,i,s&#34;</span></code>:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/ur-divergence.svg" width="630"/></p></div>
<p>When every leaf in a subtree has a common value, we can <em>compress</em> the subtree. We do that by setting the value of the subtree’s root to the value of its leaves, and then deleting every child of the root.</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/ur-divergence-merged.svg" width="450"/></p></div>
<p>The trie from above, compressed.</p>
<p>Let’s quickly implement a recursive <code><span>compress</span></code> function that performs this operation:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>compress</span><span>(</span><span>node</span><span>:</span><span> TrieNode</span><span>)</span><span>:</span><span> </span><span>string</span><span> </span><span>|</span><span> </span><span>null</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>The <code><span>compress</span></code> function should return <code><span>null</span></code> and do nothing if <code><span>node</span></code>’s children do not share a single common value. If they <em>do</em> share a common value, it should delete all of its children and assign their common value to itself.</p>
<p>The first step is to collect the values of <code><span>node</span></code>’s children by invoking <code><span>compress</span></code> recursively (using a <a target="_blank" href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first</a> traversal):</p>
<div><div><div><pre><p><span>const</span><span> values </span><span>=</span><span> Object</span><span>.</span><span>values</span><span>(</span><span>node</span><span>.</span><span>children</span><span>)</span><span>.</span><span>map</span><span>(</span><span>compress</span><span>)</span><span>;</span><span></span></p></pre></div></div></div>
<p>If there is not a single shared value, we return <code><span>null</span></code>:</p>
<div><div><div><pre><p><span>if</span><span> </span><span>(</span><span>new</span><span> </span><span>Set</span><span>(</span><span>values</span><span>)</span><span>.</span><span>size </span><span>!==</span><span> </span><span>1</span><span> </span><span>||</span><span> values</span><span>[</span><span>0</span><span>]</span><span> </span><span>==</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>null</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>Otherwise, we assign the value to <code><span>node</span></code>, remove the children, and return the value.</p>
<div><div><div><pre><p><span>node</span><span>.</span><span>value </span><span>=</span><span> values</span><span>[</span><span>0</span><span>]</span><span>;</span><span></span></p><p><span>node</span><span>.</span><span>children </span><span>=</span><span> </span><span>{</span><span>}</span><span>;</span><span></span></p><p><span></span><span>return</span><span> node</span><span>.</span><span>value</span><span>;</span><span></span></p></pre></div></div></div>
<p>This gives us:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>compress</span><span>(</span><span>node</span><span>:</span><span> TrieNode</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> values </span><span>=</span><span> Object</span><span>.</span><span>values</span><span>(</span><span>node</span><span>.</span><span>children</span><span>)</span><span>.</span><span>map</span><span>(</span><span>compress</span><span>)</span><span>;</span><span></span></p><p><span>  values</span><span>.</span><span>push</span><span>(</span><span>node</span><span>.</span><span>value</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>new</span><span> </span><span>Set</span><span>(</span><span>values</span><span>)</span><span>.</span><span>size </span><span>!==</span><span> </span><span>1</span><span> </span><span>||</span><span> values</span><span>[</span><span>0</span><span>]</span><span> </span><span>==</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>null</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  node</span><span>.</span><span>value </span><span>=</span><span> values</span><span>[</span><span>0</span><span>]</span><span>;</span><span></span></p><p><span>  node</span><span>.</span><span>children </span><span>=</span><span> </span><span>{</span><span>}</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> node</span><span>.</span><span>value</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>compress</span><span>(</span><span>root</span><span>)</span><span>;</span><span></span></p></pre></div></div></div>
<p>Let’s take a second look at the compressed trie:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/ur-divergence-merged.svg" width="450"/></p></div>
<p>After compression, it communicates the following information:</p>
<ul>
<li>All names ending in <em>“fur”</em> resolve to a value of <code><span>&#34;ur,i,i,ar&#34;</span></code></li>
<li>All names ending in <em>“tur”</em> resolve to a value of <code><span>&#34;ur,,i,s&#34;</span></code></li>
</ul>
<p>When we originally inserted <em>“Ylfur”</em> into the trie, the associated value was stored under <span><span>r</span><span></span><span>u</span><span></span><span>f</span><span></span><span>l</span><span></span><span>Y</span></span>, but after compressing the trie, only the <span><span>r</span><span></span><span>u</span><span></span><span>f</span></span> part of that path remains.</p>
<p>This means that our <code><span>trieLookup</span></code> function from earlier will return <code><span>null</span></code> for <em>“Ylfur”</em>:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>trieLookup</span><span>(</span><span>root</span><span>:</span><span> TrieNode</span><span>,</span><span> key</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> node</span><span>:</span><span> TrieNode </span><span>|</span><span> </span><span>undefined</span><span> </span><span>=</span><span> root</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> char </span><span>of</span><span> </span><span>reverse</span><span>(</span><span>key</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    node </span><span>=</span><span> node</span><span>.</span><span>children</span><span>?.</span><span>[</span><span>char</span><span>]</span><span>;</span><span></span></p><div><div><div data-type="info"><p><span> <!-- --> <!-- --> <!-- --> <!-- -->// </span><span></span>&#39;node&#39; will be null for &#39;f-&gt;l&#39;</p></div></div></div><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>node</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>break</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> node</span><span>?.</span><span>value</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>trieLookup</span><span>(</span><span>root</span><span>,</span><span> </span><span>&#34;Ylfur&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>We can fix that by returning the value of the last node we encountered:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>trieLookup</span><span>(</span><span>root</span><span>:</span><span> TrieNode</span><span>,</span><span> key</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> node </span><span>=</span><span> root</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> char </span><span>of</span><span> </span><span>reverse</span><span>(</span><span>key</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> next </span><span>=</span><span> node</span><span>.</span><span>children</span><span>?.</span><span>[</span><span>char</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>next</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>break</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    node </span><span>=</span><span> next</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> node</span><span>.</span><span>value</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>trieLookup</span><span>(</span><span>root</span><span>,</span><span> </span><span>&#34;Ylfur&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>We only override <code><span>node</span></code> if there is a <code><span>next</span></code> node.</p>
<p>Now, looking up the original four input names returns the values for those names:</p>
<div><div><div><pre><p><span>trieLookup</span><span>(</span><span>trie</span><span>,</span><span> </span><span>&#34;Ylfur&#34;</span><span>)</span><span>  </span><span></span></p><p><span></span><span>trieLookup</span><span>(</span><span>trie</span><span>,</span><span> </span><span>&#34;Knútur&#34;</span><span>)</span><span> </span><span></span></p><p><span></span><span>trieLookup</span><span>(</span><span>trie</span><span>,</span><span> </span><span>&#34;Hrútur&#34;</span><span>)</span><span> </span><span></span></p><p><span></span><span>trieLookup</span><span>(</span><span>trie</span><span>,</span><span> </span><span>&#34;Loftur&#34;</span><span>)</span><span> </span><span></span></p></pre></div></div></div>
<p>However, we also get values for lookup keys not in the original input data:</p>
<div><div><div><pre><p><span>trieLookup</span><span>(</span><span>trie</span><span>,</span><span> </span><span>&#34;Bjartur&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>This was not the case prior to compressing the trie — only the original input keys returned a value in the original trie.</p>
<p>Lookups in the compressed trie return</p>
<ul>
<li><code><span>&#34;ur,i,i,ar&#34;</span></code> for all lookup keys matching <code>*fur</code>, and</li>
<li><code><span>&#34;ur,,i,s&#34;</span></code> for all lookup keys matching <code>*tur</code>.</li>
</ul>
<p>The compressed trie has, in some sense, “learned” the suffix patterns of the input data, and returns values based on that.</p>
<p>Names in the input data ending in <code>*tur</code> always resolved to the same value so the <span><span>r</span><span></span><span>u</span><span></span><span>t</span></span> subtree was compressed — same with <code>*fur</code>. However, there were multiple values for names ending in <code>*ur</code> so the tree diverges after <span><span>r</span><span></span><span>u</span></span>:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/ur-divergence-merged.svg" width="430"/></p></div>
<p>This divergence raises a question: what about names matching <code>*ur</code> but neither <code>*fur</code> nor <code>*tur</code>?</p>
<p><em>“Sakur”</em> is one such key. When invoking <code><span>trieLookup</span></code> the last hit <code><span>node</span></code> is the <span><span>u</span></span> node. Since <span><span>u</span></span> has no value, <code><span>null</span></code> is returned:</p>
<div><div><div><pre><p><span>trieLookup</span><span>(</span><span>trie</span><span>,</span><span> </span><span>&#34;Sakur&#34;</span><span>)</span><span></span></p></pre></div></div></div>
<p>If every key in the trie’s input data ending in <code>*ur</code> were to resolve to the same value, then <em>“Sakur”</em> should resolve to that value. However, not every key ending in <code>*ur</code> resolves to the same value — keys ending in <code>*tur</code> resolve to one value and keys ending in <code>*fur</code> to another.</p>
<p>For a key matching <code>*ur</code> but not <code>*(t|f)ur</code>, we <em>could</em> just pick one of the branches. However, at most one of the branches resolves to the correct value (and in many cases, none of the branches do). The natural conclusion, then, is to <em>not</em> return a value.</p>
<hr/>
<p>The compressed trie acts as a sort of suffix-to-value pattern matcher. If a certain suffix in the input data always maps to a certain value, the compressed trie always returns that value for keys matching the suffix. But for “ambiguous” suffix matches, no value is returned.</p>
<p>Since Icelandic names with similar suffixes <em>tend</em> to have the same pattern of declension, the theory is that the compressed trie should be able to predict the correct pattern of declension for not-before-seen names. Let’s see how well that theory holds.</p>
<h2>Compressing 3,600 names</h2>
<p>Of the 4,500 approved Icelandic names, we have declension data for roughly 3,600.</p>
<p>Inserting those names and their suffix encodings into a new trie gives us a trie with 10,284 nodes, 3,638 of which are leaves. Compressing the trie by merging subtrees with common values reduces the total number of nodes to 1,588. Of those, 1,261 are leaves and 327 are not.</p>
<table><tbody><tr><th></th><th>Uncompressed</th><th>Compressed</th><th>Compressed (%)</th></tr><tr><td>Total nodes</td><td>10,284</td><td>1,588</td><td>15.4%</td></tr><tr><td>Non-leaf nodes</td><td>6,646</td><td>327</td><td>4.9%</td></tr><tr><td>Leaf nodes</td><td>3,638</td><td>1,261</td><td>34.6%</td></tr></tbody></table>
<p>Compressing the trie resulted in 6,319 non-leaf nodes being removed, which is <strong>over 95%</strong>.</p>
<p>The removal of non-leaf nodes means shorter paths from the root to the leaves of the trie. Here’s a chart showing the traversal depth of lookups for the keys in the input data for the compressed and uncompressed tries:</p>
<div><div><div></div></div></div>
<p>Lookup depth correspond to the length of the suffix match needed for a value to be returned. For the majority of names in the original input data, that length is three or lower in the compressed trie.</p>
<h3>Testing the trie on not-before-seen names</h3>
<p>In testing how well the compressed trie predicts the declension patterns of not-before-seen names, the 800 approved Icelandic names that we don’t have declension data for serve as good test cases.</p>
<p>I wrote a function to pick 100 of those names at random and (manually) categorized the declension pattern returned when looking those names up in the trie:</p>
<table><tbody><tr><th>Result</th><th>Count</th></tr><tr><td>Perfect (declension applied)</td><td>62</td></tr><tr><td>Perfect (no declension applied)</td><td>12</td></tr><tr><td>Should have applied declension</td><td>23</td></tr><tr><td>Wrong, should not be declined</td><td>2</td></tr><tr><td>Wrong declension</td><td>1</td></tr></tbody></table>
<p>This gives us a rough indication that, for not-before-seen Icelandic names, the compressed trie gives us correct results 74% of the time and wrong results 26% of the time.</p>
<p>The <em>“Should have applied declension”</em> case, which constitutes 23% of results, results in <code><span>applyCase</span></code> not applying declension to the name and returning it as-is. That result <em>is</em> wrong, but I consider it a lesser kind of wrong.</p>
<p>Still, these are just 100 random names. Some names are far more common than others. It’d be more interesting to see how well the compressed trie performs for the most common names.</p>
<p>Luckily for us, <a target="_blank" href="https://www.statice.is/">Statistics Iceland</a> publishes data on <a target="_blank" href="https://statice.is/statistics/population/births-and-deaths/names/">how many individuals have specific names</a>. Using that data, I created the chart below. It shows the number of people holding each name in the approved list of names as a first name. The 3,600 names with declension data available are colored blue. The 800 names without declension data are colored red:</p>
<div><div><div role="checkbox" tabindex="0" aria-checked="true"><div></div><p>Logarithmic</p></div></div><div><div></div></div></div>
<p>Note: <!-- -->Since relatively few names dominate this list, I made the chart logarithmic by default. You can use the toggle in the upper-right corner to make it linear.</p>
<p>363,314 people hold a name from the approved list of Icelandic names as a first name. Of those, 5,833 have names that don’t have declension data available.</p>
<p>As we can see from the chart, the commonality of names is far from evenly distributed. In fact, the top 100 names without declension data are held by 4,990 people. Those 4,990 people constitute 86% of the 5,833 people that hold one of the 800 names without declension data available.</p>
<p>I went ahead and categorized the declension results for those 100 names, multiplying the result by the number of people holding the name:</p>
<table><tbody><tr><th>Result</th><th>Number of people</th></tr><tr><td>Perfect (declension applied)</td><td>3,489</td></tr><tr><td>Perfect (no declension applied)</td><td>440</td></tr><tr><td>Should have applied declension</td><td>915</td></tr><tr><td>Wrong, should not be declined</td><td>101</td></tr><tr><td>Wrong declension</td><td>45</td></tr><tr><td>Total</td><td>4,990</td></tr></tbody></table>
<p>1,061 wrong results gives us an error rate of 21%. If we extrapolate that 21% error rate across the 5,833 people holding names without declension data available, we get 1,240 wrong results. Dividing 1,240 wrong results by the 363,314 people holding names in the approved list of Icelandic names gives us an error rate of 0.34%.</p>
<p>If we do the same math with only the names that were <em>incorrectly</em> declined, we get an error rate of 0.046%.</p>
<h2>Regularity and comprehensiveness</h2>
<p>The compressed trie captures the rules of Icelandic name declension to an impressive degree. I attribute this to the <em>regularity</em> and <em>comprehensiveness</em> of the data on Icelandic name declension, where</p>
<ul>
<li><em>regularity</em> is the degree to which similar key suffixes map to the same values, and</li>
<li><em>comprehensiveness</em> is how well the input data captures rules <em>and</em> exceptions to them.</li>
</ul>
<h3>Regularity</h3>
<p>If the input data were <em>irregular</em> — meaning that there’s no significant relationship between suffixes and associated values — the values of leaves in subtrees would frequently differ. That would prevent subtree compression, resulting in a not-very-compressed trie that is similar, if not identical, to the original trie. The less a trie is compressed, the longer the suffix match needs to be for a value to be returned.</p>
<p>The opposite happens as the input data becomes more regular. Subtrees will be more frequently compressed, leading to shorter suffix matches being required for values to be returned.</p>
<h3>Comprehensiveness</h3>
<p>Subtrees are only ever incorrectly compressed if the original trie lacks a counterexample to the regularity that led to compression. If a counterexample had been present, it would have prevented compression and created an exception to the rule.</p>
<p>If we pick, say, 450 Icelandic names at random, we will capture many of the rules of Icelandic name declension, and some counterexamples to them. Still, 450 names are only about 10% of approved Icelandic names, so we can expect loads of declension rules <em>not</em> to be covered by that sample.</p>
<p>But with over 3,600 samples, as in our case, we have over 80% coverage. With data that comprehensive, the compressed trie captures the rules — and exceptions to those rules — to an impressive degree.</p>
<h2>Bundle size</h2>
<p>I’ve mentioned bundle time a few times — let’s finally measure it!</p>
<p>I measured the size of storing the declension data for the 3,600 names that we have declension data for in the following ways:</p>
<ul>
<li>List (the <code><span>NAME_FORMS</span></code> list from before)</li>
<li>Trie (uncompressed)</li>
<li>Trie (compressed)</li>
</ul>
<p>Here are the results:</p>
<div><div><div><pre><p><span>List</span></p><p><span>    30.17 kB gzipped (152.48 kB minified)</span></p><p><span>Trie (uncompressed)</span></p><p><span>    14.47 kB gzipped (66.68 kB minified)</span></p><p><span>Trie (compressed)</span></p><p><span>    4.01 kB gzipped (14.41 kB minified)</span></p></pre></div></div></div>
<p>Note: <!-- -->The trie is serialized to a compact string representation to make its size smaller (see <a target="_blank" href="https://github.com/alexharri/beygla/blob/77f63a3132275fe58509a024f33b478bb3e54e38/lib/compress/trie/serialize.ts">serializer</a> and <a target="_blank" href="https://github.com/alexharri/beygla/blob/7f5948dac9ff56c4f1293bf845a3331dffdc0a8b/lib/read/deserialize.ts">deserializer</a>). For comparison, the compressed trie represented as JSON is 4.75 kB.</p>
<p>4.01 kB is very compact, but we can take the compression one step further.</p>
<h2>Merging sibling leaves with common suffixes</h2>
<p>Take a look at the <span><span>r</span><span></span><span>u</span><span></span><span>f</span></span> subtree from the compressed trie — it represents names matching <code>*fur</code>:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/fur-trie.svg" width="595"/></p></div>
<p>Note: <!-- -->I’ve hidden the full <code>*lfur</code> subtree to simplify this view.</p>
<p>The <span><span>i</span></span>, <span><span>ó</span></span>, <span><span>ú</span></span>, <span><span>a</span></span> sibling leaves following <span><span>r</span><span></span><span>u</span><span></span><span>f</span></span> all resolve to the same value of <code><span>&#34;ur,,i,s&#34;</span></code>. However, the <span><span>l</span></span> and <span><span>i</span></span> subtrees have leaves with different values, which prevented the <span><span>r</span><span></span><span>u</span><span></span><span>f</span></span> subtree from being compressed.</p>
<p>What we can do here is merge sibling leaves with common values. That results in the <span><span>i</span></span>, <span><span>ó</span></span>, <span><span>ú</span></span>, <span><span>a</span></span> leaves being merged into a single <span><span>ióúa</span></span> leaf node:</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/fur-trie-leaves-merged.svg" width="640"/></p></div>
<p>Let’s implement a <code><span>mergeLeavesWithCommonValues</span></code> function that performs this compression.</p>
<div><div><div><pre><p><span>function</span><span> </span><span>mergeLeavesWithCommonValues</span><span>(</span><span>node</span><span>:</span><span> TrieNode</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>Firstly, if the <code><span>node</span></code> has no children, we can immediately return, otherwise performing the operation recursively on the children:</p>
<div><div><div><pre><p><span>if</span><span> </span><span>(</span><span>!</span><span>node</span><span>.</span><span>children</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>return</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>const</span><span> child </span><span>of</span><span> Object</span><span>.</span><span>values</span><span>(</span><span>node</span><span>.</span><span>children</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>mergeLeavesWithCommonValues</span><span>(</span><span>child</span><span>)</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>For the children of <code><span>node</span></code>, there are two cases to handle:</p>
<ol>
<li>The child is a leaf node with a <code><span>value</span></code>.</li>
<li>The child is a non-leaf node.</li>
</ol>
<p>We want to merge leaf nodes with the same value, so we’ll group the keys of leaf nodes by their value:</p>
<div><div><div><pre><p><span>const</span><span> keysByValue</span><span>:</span><span> Record</span><span>&lt;</span><span>string</span><span>,</span><span> </span><span>string</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>{</span><span>}</span><span>;</span><span></span></p></pre></div></div></div>
<p>However, we want to leave non-leaf nodes alone, so we’ll define a new <code><span>newChildren</span></code> object to place them into as we encounter them:</p>
<div><div><div><pre><p><span>const</span><span> newChildren</span><span>:</span><span> Record</span><span>&lt;</span><span>string</span><span>,</span><span> TrieNode</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>{</span><span>}</span><span>;</span><span></span></p></pre></div></div></div>
<p>With those defined, we’ll iterate through the children, transferring non-leaf nodes immediately and grouping leaf keys by values:</p>
<div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>[</span><span>key</span><span>,</span><span> child</span><span>]</span><span> </span><span>of</span><span> Object</span><span>.</span><span>entries</span><span>(</span><span>node</span><span>.</span><span>children</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> isLeaf </span><span>=</span><span> </span><span>!</span><span>!</span><span>child</span><span>.</span><span>value</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>isLeaf</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    keysByValue</span><span>[</span><span>child</span><span>.</span><span>value</span><span>]</span><span> </span><span>??=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>    keysByValue</span><span>[</span><span>child</span><span>.</span><span>value</span><span>]</span><span>.</span><span>push</span><span>(</span><span>key</span><span>)</span><span></span></p><p><span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span></p><p><span>    newChildren</span><span>[</span><span>key</span><span>]</span><span> </span><span>=</span><span> child</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>When looking at this, one could be concerned that a <code><span>child</span></code> might contain both a value <em>and</em> children. In our Icelandic names trie, however, there is no overlap because each name in the input data starts with an uppercase character.</p>
<p>After iteration, we can construct the merged leaves and add them to <code><span>newChildren</span></code> like so:</p>
<div><div><div><pre><p><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>[</span><span>value</span><span>,</span><span> keys</span><span>]</span><span> </span><span>of</span><span> Object</span><span>.</span><span>entries</span><span>(</span><span>keysByValue</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  newChildren</span><span>[</span><span>keys</span><span>.</span><span>join</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span> value </span><span>}</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span>node</span><span>.</span><span>children </span><span>=</span><span> newChildren</span><span>;</span><span></span></p></pre></div></div></div>
<p>This concludes the implementation. The full implementation is a bit long, so I won’t show it in full here — you can view it in this <a target="_blank" href="https://gist.github.com/alexharri/82e96a93ff2b5c3137adddd3483a16c3">gist on GitHub</a>.</p>
<p>We need to consider merged keys in our <code><span>trieLookup</span></code> function. To do that, we’ll update the <code><span>trieLookup</span></code> function to use a new <code><span>findChild</span></code> function instead of <code><span>node</span><span>.</span><span>children</span><span>?.</span><span>[</span><span>char</span><span>]</span></code> when finding the next node.</p>
<div><div><div><pre><p><span>function</span><span> </span><span>trieLookup</span><span>(</span><span>root</span><span>:</span><span> TrieNode</span><span>,</span><span> key</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> node </span><span>=</span><span> root</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> char </span><span>of</span><span> </span><span>reverse</span><span>(</span><span>key</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> next </span><span>=</span><span> </span><span>findChild</span><span>(</span><span>node</span><span>,</span><span> char</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>!</span><span>next</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>break</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    node </span><span>=</span><span> next</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>return</span><span> node</span><span>.</span><span>value</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>Implementing <code><span>findChild</span></code> is relatively simple: we iterate through the children, returning the current child if its key contains the lookup character:</p>
<div><div><div><pre><p><span>function</span><span> </span><span>findChild</span><span>(</span><span>node</span><span>:</span><span> TrieNode</span><span>,</span><span> char</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>const</span><span> children </span><span>=</span><span> node</span><span>.</span><span>children </span><span>||</span><span> </span><span>{</span><span>}</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>const</span><span> </span><span>[</span><span>key</span><span>,</span><span> child</span><span>]</span><span> </span><span>of</span><span> Object</span><span>.</span><span>entries</span><span>(</span><span>children</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>key</span><span>.</span><span>includes</span><span>(</span><span>char</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>return</span><span> child</span></p><p><span>    </span><span>}</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div>
<p>It’s worth mentioning that, unlike merging subtrees with common values, merging sibling leaves has no functional effect on the trie. This layer of compression is purely to make the trie’s footprint smaller.</p>
<h3>Trie after merging sibling leaves</h3>
<p>Here is the node count table from before with a new column that shows the results for the trie that has also had its sibling leaves merged:</p>
<table><tbody><tr><th></th><th>Uncompressed</th><th>Only subtrees merged</th><th>Subtrees and sibling leaves merged</th></tr><tr><td>Total nodes</td><td>10,284</td><td>1,588</td><td>972</td></tr><tr><td>Non-leaf nodes</td><td>6,646</td><td>327</td><td>327</td></tr><tr><td>Leaf nodes</td><td>3,638</td><td>1,261</td><td>645</td></tr></tbody></table>
<p>Merging sibling leaf nodes with common values almost cuts the number of leaf nodes in half! Since we’re only touching the leaf nodes, the number of non-leaf nodes stays the same. Lookup depth is also not affected.</p>
<p>One interesting statistic is how many names in the original input data each leaf node now represents. Here are the top 50 leaf nodes by the number of names they represent:</p>
<div><div><div></div></div></div>
<p>The top node <span><span>i</span><span></span><span>bdfjklmnpstvxðóú</span></span> is the result of merging 166 leaf nodes. That indicates that Icelandic names ending in <em>“i”</em> exhibit a high degree of regularity in their pattern of declension.</p>
<p>Let’s take a closer look at the <span><span>i</span></span> subtree. Next to each value node, I’ve added the number of names that the leaf node represents in parentheses.</p>
<div><p><img src="https://todaythings.substack.com/images/posts/icelandic-name-declension-trie/i-trie.svg" width="860"/></p></div>
<p>The <span><span>i</span></span> subtree is built from 223 names starting with <em>“i”</em>. Only four of those names don’t follow the declension pattern of <code><span>&#34;i,a,a,a&#34;</span></code>. That’s a really high degree of regularity!</p>
<p>Those four names serve as important counterexamples to the general rule that names ending in <em>“i”</em> have a suffix encoding of <code><span>&#34;i,a,a,a&#34;</span></code>. Without them, the <span><span>i</span></span> subtree would have been compressed to a single value node.</p>
<h2>Final bundle size</h2>
<p>Here’s what merging sibling leaves with common values did for the bundle size of the trie:</p>
<div><div><div><pre><p><span>List</span></p><p><span>    30.17 kB gzipped (152.48 kB minified)</span></p><p><span>Trie (uncompressed)</span></p><p><span>    14.47 kB gzipped (66.68 kB minified)</span></p><p><span>Trie (subtrees merged)</span></p><p><span>    4.01 kB gzipped (14.41 kB minified)</span></p><p><span>Trie (subtrees and leaves merged)</span></p><p><span>    3.27 kB gzipped (9.3 kB minified)</span></p></pre></div></div></div>
<p>It saves us 0.74 kB. That’s a small number in absolute terms, but hey, it’s an 18% improvement!</p>
<h2>The beygla library</h2>
<p>I use the compressed trie in a declension library for Icelandic names called <a target="_blank" href="https://github.com/alexharri/beygla">beygla</a>. The library is 4.46 kB gzipped, 3.27 kB of which is the serialized trie. As described, it exports an <code><span>applyCase</span></code> function that is used to apply grammatical cases to Icelandic names.</p>
<p>The beygla library is used, for example, by the Icelandic judicial system to <a target="_blank" href="https://github.com/island-is/island.is/blob/6a15e6524a452142c4f09d84b9bc256fef544673/apps/judicial-system/web/src/routes/Prosecutor/Indictments/Indictment/Indictment.tsx#L73">decline the names of defendants</a> in indictments.</p>
<p>The library includes a <code><span>&#34;beygla/addresses&#34;</span></code> module (<a target="_blank" href="https://github.com/alexharri/beygla/issues/16">see motivating issue</a>). It uses the exact same approach, with that module’s trie being built from data on Icelandic addresses.</p>
<h3>Trading bundle size for 100% correctness</h3>
<p>The indictment example I linked above uses the <a target="_blank" href="https://github.com/alexharri/beygla/pull/15">strict version</a> of beygla:</p>
<div><div><div><pre><p><span>import</span><span> </span><span>{</span><span> applyCase </span><span>}</span><span> </span><span>from</span><span> </span><span>&#34;beygla/strict&#34;</span><span>;</span><span></span></p></pre></div></div></div>
<p>The <code><span>&#34;beygla/strict&#34;</span></code> module only applies cases to names in the approved list of Icelandic names. I added it after <a target="_blank" href="https://github.com/alexharri/beygla/issues/14">this issue</a> was raised:</p>
<blockquote>
<p><em>“We are using beygla in a project within the public sector. Our users care <strong>a lot</strong> about using grammatically correct Icelandic.”</em></p>
</blockquote>
<p>When first developing beygla, I cared <em>a lot</em> about the bundle size being as small as possible so that Icelandic web apps could use the library without being concerned about JavaScript bloat. I found the compressed trie really powerful in that it both made the library <em>tiny</em> while also applying declension to not-before-seen names with few errors. There’s certainly a cool factor to it.</p>
<p>But still, beygla does occasionally produce a wrong result, which is <em>not</em> an appropriate trade-off in contexts such as generating indictments. <code><span>&#34;beygla/strict&#34;</span></code> is about 15 kB gzipped (10 kB more than the default beygla module), which, honestly, is not that large of a bundle size increase.</p>
<p>Because of that, if I were developing the library again today, I probably would have made <code><span>&#34;beygla/strict&#34;</span></code> the default. For apps willing to trade 100% correctness for bundle size, they could opt for the less-but-mostly-correct 5 kB variant. Perhaps I’ll publish a new major version of beygla with that change soon.</p>
<p>Note: <!-- -->The <code>beygla/strict</code> module encodes the list of approved Icelandic names in <em>another</em> trie using a compact string serialization. The <a target="_blank" href="https://github.com/alexharri/beygla/pull/15">implementing PR</a> describes how that trie is serialized, so I won’t cover it here.</p>
<h2>Final words</h2>
<p>Building beygla was a super fun problem to solve. When I first started the project, I didn’t expect to be able to get the bundle size so low. The compressed trie ended up being really effective for encoding Icelandic declension patterns.</p>
<p>If Icelandic language technology is something that’s interesting to you, I’d suggest checking out <a target="_blank" href="https://github.com/mideind">Miðeind</a> — they have a lot of open source projects around AI and natural language processing for Icelandic.</p>
<p>There are many languages with declension as a language feature (such as Slavic and Balkan languages), so there is an opportunity to apply the ideas explored in this post to those languages. Native speakers of said languages are well suited to explore that.</p>
<p>I’d like to thank <a target="_blank" href="https://eirikur.dev/">Eiríkur Fannar Torfason</a> and <a target="_blank" href="https://www.linkedin.com/in/villithorsteinsson/">Vilhjálmur Thorsteinsson</a> for reading and providing feedback on draft versions of this post. Vilhjálmur actually identified an optimization opportunity in beygla that reduced the size of the trie from 3.43 kB to 3.27 kB (<a target="_blank" href="https://github.com/alexharri/beygla/pull/25">see PR</a>).</p>
<p>Thanks for reading, I hope this was interesting.</p>
<p>— Alex Harri</p><div><div><p>Mailing list</p><div><p>To be notified of new posts, subscribe to my mailing list.</p></div></div></div></main></div></div>
  </body>
</html>
