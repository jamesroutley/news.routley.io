<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/robertdavidgraham/wc2">Original</a>
    <h1>Wc2: Investigates optimizing &#39;wc&#39;, the Unix word count program</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">There have been multiple articles lately implementing the
classic <code>wc</code> program in various programming <em>languages</em>, to
&#34;prove&#34; their favorite language can be &#34;just as fast&#34; as C.</p>
<p dir="auto">This project does something different.
Instead of a different <em>language</em> it uses a different <em>algorithm</em>.
The new algorithm is significantly faster -- implementing in a
slow language like JavaScript is still faster than the original
<code>wc</code> program written in C.</p>
<p dir="auto">The algorithm is known as an &#34;asynchronous state-machine parser&#34;.
It&#39;s a technique for <em>parsing</em> that you don&#39;t learn in college.
It&#39;s more <em>efficient</em>, but more importantly, it&#39;s more <em>scalable</em>.
That&#39;s why your browser uses a state-machine to parse GIFs,
and most web servers use state-machiens to parse incoming HTTP requests.</p>
<p dir="auto">This projects contains three versions:</p>
<ul dir="auto">
<li><code>wc2o.c</code> is a simplified 25 line version highlighting the idea</li>
<li><code>wc2.c</code> is the full version in C, supporting Unicode</li>
<li><code>wc2.js</code> is the version in JavaScript</li>
</ul>

<p dir="auto">The algorithm reads input and passes each byte one at a time
to a state-machine. It looks something like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    length = fread(buf, 1, sizeof(buf), fp);
    for (i=0; i&lt;length; i++) {
        c = buf[i];
        state = table[state][c];
        counts[state]++;
    }"><pre>    <span>length</span> <span>=</span> <span>fread</span>(<span>buf</span>, <span>1</span>, <span>sizeof</span>(<span>buf</span>), <span>fp</span>);
    <span>for</span> (<span>i</span><span>=</span><span>0</span>; <span>i</span><span>&lt;</span><span>length</span>; <span>i</span><span>++</span>) {
        <span>c</span> <span>=</span> <span>buf</span>[<span>i</span>];
        <span>state</span> <span>=</span> <span>table</span>[<span>state</span>][<span>c</span>];
        <span>counts</span>[<span>state</span>]<span>++</span>;
    }</pre></div>
<p dir="auto">No, you aren&#39;t suppose to be able to see how the word-count works
by looking at this code. The complexity happens elsewhere, setting
up the state-machine.</p>
<p dir="auto">The state-machine table is the difference between the simple version
(<code>wc2o.c</code>) and complex version (<code>wc2.c</code>) of the program. The algorithm
is the same, the one shown above, the difference is in how they setup
the table. The simple program creates a table for ASCII, the complex
program creates a much larger table supporting UTF-8.</p>

<p dir="auto">The <code>wc</code> word-count program counts the number of words in a file. A &#34;word&#34;
is some non-space characters separate by space.</p>
<p dir="auto">Those who re-implement <code>wc</code> simplify the problem by only doing ASCII instead
of the full UTF-8 Unicode. This is cheating, because much of the speed of
<code>wc</code> comes from its need to handle character-sets like UTF-8.
The real programs spend most of their time
in functions like <code>mbrtowc()</code> to parse multi-byte characters and
<code>iswspace()</code> to test if they are spaces -- which re-implementations
of <code>wc</code> skip.</p>
<p dir="auto">For this reason, we&#39;ve implemented a full UTF-8 version in this project, to
prove that it works without cheating. Now the real <code>wc</code> works with a lot
more character-sets, and we don&#39;t do that. But by implementing UTF-8, we&#39;ve
shown that it&#39;s possible, and that the speed for any character-set is the same.</p>
<p dir="auto">Another simplification is how invalid input is handled. The original <code>wc</code> program
largley ignores errors, but it&#39;s still an important factor in making sure you
are doing things correctly.</p>

<p dir="auto">This project uses a number of large input files for benchmarking.
The traditional <code>wc</code> program has wildly different performance depending
upon input, such as whether the file is full of illegal characters, or
whether UTF-8 is being handled. The first test file is downloaded
from the Internet as &#34;real-world data&#34;, while the others are generated
using a program built with this project (<code>wctool</code>).</p>
<ul dir="auto">
<li><code>pocorgtfo18.pdf</code> a large 92-million byte PDF file that contains binary/illegal characters</li>
<li><code>ascii.txt</code> a file the same size containing random words, ASCII-only</li>
<li><code>utf8.txt</code> a file containing random UTF-8 sequences of 1, 2, 3, and 4 bytes</li>
<li><code>word.txt</code> a file containing 92-million &#39;x&#39; characters</li>
<li><code>space.txt</code> a file containing 92-million &#39; &#39; (space) characters</li>
</ul>
<p dir="auto">Before benchmarking the old <code>wc</code>, set the character-set to UTF-8. It&#39;s
probably already set to this on new systems, but do this to make sure:</p>
<div data-snippet-clipboard-copy-content="$ export LC_CTYPE=en_US.UTF-8"><pre><code>$ export LC_CTYPE=en_US.UTF-8
</code></pre></div>
<p dir="auto">When running <code>wc</code>, the <code>-lwc</code> is the default for counting words in ASCII text.
To convert it into UTF-8 &#34;multi-byte&#34; mode, change <code>c</code> o <code>m</code>, as in <code>-lwm</code>.</p>
<p dir="auto">The numbers are reported come from the Unix <code>time</code> command, the number of seconds for
<code>user</code> time. In other words, <code>elapsed</code> time or <code>system</code> time aren&#39;t reported.</p>
<p dir="auto">The following table shows benchmarking a 2019 x86 MacBook Air of the old
<code>wc</code> program. As you can see, it has a wide variety of speeds depending
on input.</p>
<p dir="auto">The <code>wc</code> program included with macOS and Linux are completely different.
Therefore, the following table shows them benchmarked against each other
on the same hardware.</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Input File</th>
<th>macOS</th>
<th>Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>wc -lwc</td>
<td>pocorgtfo18.pdf</td>
<td>0.709</td>
<td>5.591</td>
</tr>
<tr>
<td>wc -lwm</td>
<td>pocorgtfo18.pdf</td>
<td>0.693</td>
<td>5.419</td>
</tr>
<tr>
<td>wc -lwc</td>
<td>ascii.txt</td>
<td>0.296</td>
<td>2.509</td>
</tr>
<tr>
<td>wc -lwm</td>
<td>utf8.txt</td>
<td>0.532</td>
<td>1.840</td>
</tr>
<tr>
<td>wc -lwc</td>
<td>space.txt</td>
<td>0.296</td>
<td>0.284</td>
</tr>
<tr>
<td>wc -lwm</td>
<td>space.txt</td>
<td>0.295</td>
<td>0.298</td>
</tr>
<tr>
<td>wc -lwc</td>
<td>word.txt</td>
<td>0.302</td>
<td>1.268</td>
</tr>
<tr>
<td>wc -lwm</td>
<td>word.txt</td>
<td>0.294</td>
<td>1.337</td>
</tr>
</tbody>
</table>
<p dir="auto">These results tell us:</p>
<ul dir="auto">
<li>Illegal characters (in <code>pocorgtfo18.pdf</code>) slow things down a lot,
twice as slow on macOS, 10x slower on Linux.</li>
<li>Text that randomly switches between spaces and words is much slower
than text containing all the same character.</li>
<li>On Linux, the code path that reads all spaces is significantly faster.</li>
<li>The macOS program is in general much faster than the Linux version.</li>
<li>Processing Unicode (the file <code>utf8.txt</code> with the <code>-m</code> option) is slower
than processing ASCII (the file <code>ascii.txt</code> with the <code>-c</code> option).</li>
</ul>

<p dir="auto">The time for our algorithm, in C and JavaScript, are the following.
The state-machine parser is immune to input type, all the input files
show the same results.</p>
<table>
<thead>
<tr>
<th>Program</th>
<th>Input File</th>
<th>macOS</th>
<th>Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td>wc2.c</td>
<td>(all)</td>
<td>0.206</td>
<td>0.278</td>
</tr>
<tr>
<td>wc2.js</td>
<td>(all)</td>
<td>0.281</td>
<td>0.488</td>
</tr>
</tbody>
</table>
<p dir="auto">These results tell us:</p>
<ul dir="auto">
<li>This state machine approach always results in the same speed, regardless
of input.</li>
<li>This state machine approach is faster than the built-in programs.</li>
<li>Even written in JavaScript, the state machine approach is competitive in speed.</li>
<li>The difference in macOS and Linux speed is actually the difference in <code>clang</code> and <code>gcc</code>
speed. The LLVM <code>clang</code> compiler is doing better optimizations for x86 processors here.</li>
<li>I don&#39;t know why Node.js behaves differently on macOS and Linux, it&#39;s probably just
due to different versions.</li>
<li>A JIT (like NodeJS) works well with simple compute algorithms. This tells
us little about it&#39;s relative performance in larger programs. All languages
that have a JIT should compile this sort of algorithm to roughly the same
speed.</li>
</ul>

<p dir="auto">The algorithm is <em>faster</em>, but more importantly, it&#39;s more <em>scalable</em>.</p>
<p dir="auto">Such scalability isn&#39;t usefull for <code>wc</code>, but is incredibly important for network
programs. Consider an HTTP web-server. The traditional way that the Apache web-server
worked was by reading the entire header in and buffering it, before then parsing
the header. This need to buffer the entire header caused an enormous scalability
problem. In contrast, asynchronous web-servers like Nginx use a state-machine
parser. They parse the bytes as they arrive, and discard them.</p>
<p dir="auto">This is analogous to NFA and DFA regular-expressions. If you use the NFA
approach, you need to buffer the entire chunk of data, so that the regex
can backtrack. Using the DFA approach, input can be provided as a stream,
one byte at a time, without needing buffering. DFAs are more scalable than NFAs.</p>

<p dir="auto">This project contains a minimalistic <code>wc2o.c</code> program to highlight
the algorithm, without all the fuss of building UTF-8 tables, supporting
only ASCII.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
int main(void)
{
    static const unsigned char table[4][4] = {
        {2,0,1,0,}, {2,0,1,0,}, {3,0,1,0,},  {3,0,1,0,}
    };
    static const unsigned char column[256] = {
        0,0,0,0,0,0,0,0,0,1,2,1,1,1,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
    };
    unsigned long counts[4] = {0,0,0,0};
    int state = 0;
    int c;

    while ((c = getchar()) != EOF) {
        state = table[state][column[c]];
        counts[state]++;
    }

    printf(&#34;%lu %lu %lu\n&#34;, counts[1], counts[2], 
                counts[0] + counts[1] + counts[2] + counts[3]);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>int</span> <span>main</span>(<span>void</span>)
{
    <span>static</span> <span>const</span> <span>unsigned <span>char</span></span> <span>table</span>[<span>4</span>][<span>4</span>] <span>=</span> {
        {<span>2</span>,<span>0</span>,<span>1</span>,<span>0</span>,}, {<span>2</span>,<span>0</span>,<span>1</span>,<span>0</span>,}, {<span>3</span>,<span>0</span>,<span>1</span>,<span>0</span>,},  {<span>3</span>,<span>0</span>,<span>1</span>,<span>0</span>,}
    };
    <span>static</span> <span>const</span> <span>unsigned <span>char</span></span> <span>column</span>[<span>256</span>] <span>=</span> {
        <span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>1</span>,<span>2</span>,<span>1</span>,<span>1</span>,<span>1</span>,<span>0</span>,<span>0</span>,<span>0</span>,
        <span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>,<span>1</span>,<span>0</span>,
    };
    <span>unsigned long</span> <span>counts</span>[<span>4</span>] <span>=</span> {<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>};
    <span>int</span> <span>state</span> <span>=</span> <span>0</span>;
    <span>int</span> <span>c</span>;

    <span>while</span> ((<span>c</span> <span>=</span> <span>getchar</span>()) <span>!=</span> <span>EOF</span>) {
        <span>state</span> <span>=</span> <span>table</span>[<span>state</span>][<span>column</span>[<span>c</span>]];
        <span>counts</span>[<span>state</span>]<span>++</span>;
    }

    <span>printf</span>(<span>&#34;%lu %lu %lu\n&#34;</span>, <span>counts</span>[<span>1</span>], <span>counts</span>[<span>2</span>], 
                <span>counts</span>[<span>0</span>] <span>+</span> <span>counts</span>[<span>1</span>] <span>+</span> <span>counts</span>[<span>2</span>] <span>+</span> <span>counts</span>[<span>3</span>]);
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">The key part that does all the word counting is in the two lines inside:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    while ((c = getchar()) != EOF) {
        state = table[state][column[c]];
        counts[state]++;
    }"><pre>    <span>while</span> ((<span>c</span> <span>=</span> <span>getchar</span>()) <span>!=</span> <span>EOF</span>) {
        <span>state</span> <span>=</span> <span>table</span>[<span>state</span>][<span>column</span>[<span>c</span>]];
        <span>counts</span>[<span>state</span>]<span>++</span>;
    }</pre></div>
<p dir="auto">This is only defined for ASCII, so you can see the state-machine on a
single-line in the code (<code>table</code>).</p>

<p dir="auto">This project includes additional tools:</p>
<ul dir="auto">
<li><code>wctool</code> to generate large test files</li>
<li><code>wcdiff</code> to find difference between two implementatins of <code>wc</code></li>
<li><code>wcstream</code> to fragment input files (demonstrates a bug in macOS&#39;s <code>wc</code>)</li>
</ul>
<p dir="auto">The program <code>wc2.c</code> has the same logic, the difference being that it
generates a larger state-machine for parsing UTF-8.</p>

<p dir="auto">C has a peculiar idiom called &#34;pointer arithmetic&#34;, where pointers can
be incremented. Looping through a buffer is done with an expression like
<code>*buf++</code> instead of <code>buf[i++]</code>. Many programmers think pointer-arithmetic
is faster.</p>
<p dir="auto">To test this, the <code>wc2.c</code> program has an option <code>-P</code> that makes this
small change, to test the difference in speed.</p>
</article></div></div>
  </body>
</html>
