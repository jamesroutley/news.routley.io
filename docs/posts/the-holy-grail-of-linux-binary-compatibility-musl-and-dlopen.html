<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/quaadgras/graphics.gd/discussions/242">Original</a>
    <h1>The Holy Grail of Linux Binary Compatibility: Musl and Dlopen</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="9388957" data-target-translation-type="discussion">
        <tr>
    <td>
        <p dir="auto">I guess using Go + Godot to <a href="https://github.com/quaadgras/graphics.gd/discussions/184" data-hovercard-type="discussion" data-hovercard-url="/quaadgras/graphics.gd/discussions/184/hovercard">build native &amp; installable Android &amp; iOS binaries</a> (without any proprietary SDKs) was too easy.  So it&#39;s time for a real challenge...</p>
<h3 dir="auto">Linux Binary Compatibility</h3>
<p dir="auto">(some background reading: <a href="https://jangafx.com/insights/linux-binary-compatibility" rel="nofollow">https://jangafx.com/insights/linux-binary-compatibility</a>)</p>
<p dir="auto">For a while now, it&#39;s been very easy to reliably ship command line software &amp; servers for Linux, just run <code>go build</code> and out pops a single static binary that will run on any Linux distribution running kernel 3.2 or later (which was released in 2012, so there&#39;s plenty of room for backwards compatibility).</p>
<p dir="auto">The problems begin to creep in when you want access to hardware accelerated graphics. All the GPU drivers on Linux require accessing dynamic libraries via the C ABI. These C libraries are built against a particular libc, which is most commonly <code>glibc</code> but there are also a selection of <code>musl</code>-based distributions. If you compile a <code>glibc</code> library or executable, it won&#39;t run on a <code>musl</code> system and vice-versa. That&#39;s a big incompatibility right there!</p>
<p dir="auto">In fact, I&#39;ve directly experienced this, as I recently replaced the OS on my personal computer with the <code>musl</code> edition of <a href="https://voidlinux.org/" rel="nofollow">Void Linux</a>. Compiling the <a href="https://zed.dev/" rel="nofollow">Zed</a> editor with musl for example, was quite the challenge. It turns out that building <code>graphics.gd</code> projects on <code>musl</code> was also very broken. Go doesn&#39;t properly support <code>c-shared</code> or <code>c-archive</code> when building against <code>musl</code>.</p>
<p dir="auto">That&#39;s a problem, firstly because this is my distro now, I need to be able to build graphics.gd projects! Secondly, in theory, <code>musl</code> has better support for static linking than <code>glibc</code>; so if there&#39;s any solution to this Linux Binary Compatibility mess, it&#39;s probably going to have something to do with <code>musl</code>.</p>
<h3 dir="auto">Supporting <code>musl</code></h3>
<p dir="auto">To work around <a href="https://github.com/golang/go/issues/13492" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/13492/hovercard">these</a> <code>musl</code> issues with Go, I had to patch the runtime with a build-overlay that applies when building for <code>GOOS=musl</code>. This is a new <code>GOOS</code> that I&#39;ve introduced to graphics.gd, specifically to make <code>musl</code> builds possible.</p>
<p dir="auto">Next up, I decided to ditch c-shared builds for <code>musl</code>, these were only convenient because you could easily plug and play Go into the official Godot binaries. The Godot Foundation doesn&#39;t provide official musl builds, so instead, I&#39;m linking the Go code directly with Godot <code>c-archive</code> to end up with a single binary. Amazing, <code>graphics.gd</code> supports <code>musl</code> now!</p>
<p dir="auto">There&#39;s just one issue, this means whenever somebody wants to release their project for Linux, they would have to create two builds, a Linux <code>glibc</code> build + a <code>musl</code> build and somehow communicate to their users, to pick the correct binary. Hell, before I installed Void Linux <em>I</em> didn&#39;t even fully comprehend the differences between <code>musl</code> and <code>glibc</code>, this feels like I&#39;m simply contributing to the problem!</p>
<h3 dir="auto">Single Static Binaries + Graphics</h3>
<p dir="auto">Hold up! Earlier I reported that a key benefit of <code>musl</code> was better static library support. There should be a way to build a graphics.gd project into a single static binary. Well, here&#39;s the thing. Yes, you can totally do this. Godot includes all of it&#39;s dependencies on Linux, everything else is dynamically loaded at runtime, so just add the <code>-static</code> command and...</p>
<p dir="auto"><code>ERROR Dynamic loading not supported</code></p>
<p dir="auto">Ouch, Godot wants to use <code>dlopen</code> to interface with X11, Wayland, OpenGL, Vulkan etc. As it turns out, <code>musl</code> refuses to implement <code>dlopen</code> for static binaries. They don&#39;t want anyone to load a <code>glibc</code> library from <code>musl</code> because there are fundamental incompatibilities between how they implement  TLS (thread-local-storage).</p>
<p dir="auto">Don&#39;t worry though! As <code>dlopen</code> is compiled as a weak symbol, this means, that as long as <code>graphics.gd</code> implements it, there&#39;s still a chance to get a single static binary that can execute on any Linux system 3.2 onwards.</p>
<h3 dir="auto">The Holy Grail</h3>
<p dir="auto">There&#39;s some precedent for this, there&#39;s the <a href="https://github.com/graphitemaster/detour">detour</a> technique in C which will let you <code>dlopen</code> SDL and show graphics when running <em>without a standard library</em>. There&#39;s also Cosmopolitan&#39;s <a href="https://github.com/jart/cosmopolitan/tree/master/libc/dlopen">dlopen</a> which uses a similar technique. So the solution here is to extend this for <code>musl</code>.</p>
<p dir="auto">The way this works, is by including (or compiling) a small <code>C</code> program for the target machine. We load the program and execute into it from the same process. This program brings in the host&#39;s dynamic linker so that we can <em>steal</em> the system&#39;s <code>dlopen</code> and <code>longjmp</code> back into <code>graphics.gd</code>. We wrap any dynamically loaded functions with an assembly trampoline that switches to the system&#39;s libc TLS for the duration of the call. It all starts looking a lot like cgo.</p>
<p dir="auto">So after much hair pulling and LLM wrangling, it turns out that <code>musl</code> + <code>dlopen</code> is all we need to produce single static binaries + graphics for Linux. Everyone can now enjoy the <em>Go</em> single-static-binary experience on Linux with full support for hardware accelerated graphics.</p>
<h3 dir="auto">Try it!</h3>
<p dir="auto">Here&#39;s a build of the <code>graphics.gd</code> Dodge The Creeps sample project that should execute (and hopefully render graphics) on any Linux system with <code>gcc</code> installed (we don&#39;t embed the helper binaries yet).</p>
<p dir="auto"><a href="https://release.graphics.gd/dodge_the_creeps.static" rel="nofollow">https://release.graphics.gd/dodge_the_creeps.static</a></p>
<p dir="auto">You can also cross-compile your own project (on any supported platform)</p>
<p dir="auto"><code>GOOS=musl GOARCH=amd64 gd build</code></p>
<p dir="auto"><em>Note you may need to delete your <code>export_presets.cfg</code> so that the new musl export preset is added to your project</em></p>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
