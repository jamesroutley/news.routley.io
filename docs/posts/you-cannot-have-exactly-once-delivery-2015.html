<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/">Original</a>
    <h1>You cannot have exactly-once delivery (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>I’m often surprised that people continually have fundamental misconceptions about how distributed systems behave. I myself shared many of these misconceptions, so I try not to demean or dismiss but rather educate and enlighten, hopefully while sounding less preachy than that just did. I continue to learn only by following in the footsteps of others. In retrospect, it shouldn’t be surprising that folks buy into these fallacies as I once did, but it can be frustrating when trying to communicate certain design decisions and constraints.</p>
<p>Within the context of a distributed system, <strong>you cannot have exactly-once message delivery</strong>. Web browser and server? Distributed. Server and database? Distributed. Server and message queue? Distributed. You cannot have exactly-once delivery semantics in any of these situations.</p>
<p>As I’ve <a href="http://www.slideshare.net/TylerTreat/from-mainframe-to-microservice-an-introduction-to-distributed-systems-41004778/23">described in the past</a>, <strong>distributed systems are all about trade-offs</strong>. This is one of them. There are essentially three types of delivery semantics: at-most-once, at-least-once, and exactly-once. Of the three, the first two are feasible and widely used. If you want to be super anal, you might say at-least-once delivery is also impossible because, technically speaking, network partitions are not strictly time-bound. If the connection from you to the server is interrupted indefinitely, you can’t deliver <em>anything. </em>Practically speaking, you have bigger fish to fry at that point—like calling your ISP—so we consider at-least-once delivery, for all intents and purposes, possible. With this model of thinking, network partitions are finitely bounded in time, however arbitrary this may be.</p>
<p>So where does the trade-off come into play, and why is exactly-once delivery impossible? The answer lies in the Two Generals thought experiment or the more generalized Byzantine Generals Problem, which I’ve <a href="https://bravenewgeek.com/understanding-consensus/">looked at extensively</a>. We must also consider the <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">FLP result</a>, which basically says, given the possibility of a faulty process, it’s <em>impossible</em> for a system of processes to agree on a decision.</p>
<p>In the letter I mail you, I ask you to call me once you receive it. You never do. Either you really didn’t care for my letter or it got lost in the mail. <em>That’s the cost of doing business.</em> I can send the one letter and hope you get it, or I can send 10 letters and assume you’ll get at least one of them. The trade-off here is quite clear (postage is expensive!), but sending 10 letters doesn’t really provide any additional guarantees. In a distributed system, we try to guarantee the delivery of a message by waiting for an acknowledgement that it was received, but all sorts of things can go wrong. Did the message get dropped? Did the ack get dropped? Did the receiver crash? Are they just slow? Is the network slow? Am <em>I </em>slow? <strong>FLP and the Two Generals Problem are not design complexities, they are <em>impossibility results</em>.</strong></p>
<p>People often bend the meaning of “delivery” in order to make their system fit the semantics of exactly-once, or in other cases, the term is overloaded to mean something entirely different. State-machine replication is a good example of this. Atomic broadcast protocols ensure messages are delivered reliably and in order. The truth is, we <em>can’t</em> deliver messages reliably and in order in the face of network partitions and crashes without a high degree of coordination. This coordination, of course, comes at a cost (latency and availability), while still relying on at-least-once semantics. <a href="http://web.stanford.edu/class/cs347/reading/zab.pdf">Zab</a>, the atomic broadcast protocol which lays the foundation for ZooKeeper, enforces idempotent operations.</p>
<blockquote><p>State changes are idempotent and applying the same state change multiple times does not lead to inconsistencies as long as the application order is consistent with the delivery order. Consequently, guaranteeing at-least once semantics is sufficient and simplifies the implementation.</p></blockquote>
<p>“Simplifies the implementation” is the authors’ attempt at subtlety. State-machine replication is just that, replicating state. If our messages have side effects, all of this goes out the window.</p>
<p>We’re left with a few options, all equally tenuous. When a message is delivered, it’s acknowledged immediately before processing. The sender receives the ack and calls it a day. However, if the receiver crashes before or during its processing, that data is lost forever. Customer transaction? Sorry, looks like you’re not getting your order. This is the worldview of at-most-once delivery. To be honest, implementing at-most-once semantics is more complicated than this depending on the situation. If there are multiple workers processing tasks or the work queues are replicated, the broker must be strongly consistent (or CP in CAP theorem parlance) so as to ensure a task is not delivered to any other workers once it’s been acked. Apache Kafka uses ZooKeeper to handle this coordination.</p>
<p>On the other hand, we can acknowledge messages after they are processed. If the process crashes after handling a message but before acking (or the ack isn’t delivered), the sender will redeliver. Hello, at-least-once delivery. Furthermore, if you want to deliver messages in order to more than one site, you need an atomic broadcast which is a <em>huge</em> burden on throughput. Fast or consistent. Welcome to the world of distributed systems.</p>
<p>Every major message queue in existence which provides any guarantees will market itself as at-least-once delivery. If it <a href="http://datasys.cs.iit.edu/publications/2014_SCRAMBL14_HDMQ.pdf">claims exactly-once</a>, it’s because they are lying to your face in hopes that you will buy it or they themselves do not understand distributed systems. Either way, it’s not a good indicator.</p>
<p>RabbitMQ attempts to provide <a href="https://www.rabbitmq.com/reliability.html">guarantees</a> along these lines:</p>
<blockquote><p>When using confirms, producers recovering from a channel or connection failure should retransmit any messages for which an acknowledgement has not been received from the broker. There is a possibility of message duplication here, because the broker might have sent a confirmation that never reached the producer (due to network failures, etc). Therefore consumer applications will need to perform deduplication or handle incoming messages in an idempotent manner.</p></blockquote>
<p>The way we achieve exactly-once delivery in practice is by faking it. Either the messages themselves should be idempotent, meaning they can be applied more than once without adverse effects, or we remove the need for idempotency through deduplication. Ideally, our messages don’t require strict ordering and are commutative instead. There are design implications and trade-offs involved with whichever route you take, but this is the reality in which we must live.</p>
<p>Rethinking operations as idempotent actions might be easier said than done, but it mostly requires a change in the way we think about state. This is best described by revisiting the replicated state machine. Rather than distributing operations to apply at various nodes, what if we just distribute the state changes themselves? Rather than mutating state, let’s just report <em>facts</em> at various points in time. This is effectively how Zab works.</p>
<p>Imagine we want to tell a friend to come pick us up. We send him a series of text messages with turn-by-turn directions, but one of the messages is delivered twice! Our friend isn’t too happy when he finds himself in the bad part of town. Instead, let’s just tell him <em>where</em> we are and let him figure it out. If the message gets delivered more than once, it won’t matter. The implications are wider reaching than this, since we’re still concerned with the <em>ordering</em> of messages, which is why solutions like commutative and convergent replicated data types are becoming more popular. That said, we can typically solve this problem through extrinsic means like sequencing, vector clocks, or other partial-ordering mechanisms. <strong>It’s usually causal ordering that we’re after anyway. People who say otherwise don’t quite realize that <em><a href="https://queue.acm.org/detail.cfm?id=2745385">there is no now</a> in a distributed system</em>.</strong></p>
<p>To reiterate, there is no such thing as exactly-once delivery. We must choose between the lesser of two evils, which is at-least-once delivery in most cases. This can be used to simulate exactly-once semantics by ensuring idempotency or otherwise eliminating side effects from operations. Once again, it’s important to understand the trade-offs involved when designing distributed systems. There is asynchrony abound, which means you <em>cannot</em> expect synchronous, guaranteed behavior. Design for failure and resiliency against this asynchronous nature.</p>
<p><a href="https://twitter.com/tyler_treat?ref_src=twsrc%5Etfw" data-show-count="false">Follow @tyler_treat</a></p>
<p id="jp-relatedposts">
	<h3><em>Related</em></h3>
</p>	</div></div>
  </body>
</html>
