<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://papereditor.app/dev">Original</a>
    <h1>9 years of Apple text editor solo dev</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><p><span>‚úçüèª</span>¬†¬†Thoughts on building <a href="https://papereditor.app" target="_blank">Paper</a> as a solo maker.</p><div><p><time datetime="2024-01-02"><span>üìÖ</span>¬†¬†January 2nd, 2024</time></p><p><span>‚è≥</span>¬†¬†19 min read</p></div></div></div><section><p>In 2015 <a href="https://twitter.com/_mihhail" target="_blank">I</a> was a regular full-stack web developer <span>(and still am to this day)</span>. I‚Äôve owned a Mac. I‚Äôve built a tiny iOS app once. That was about the extent of my proximity to the world of Apple dev at the time.</p><p>Having spent some time behind a Mac, I‚Äôve grown fond of its quirky and vibrant ecosystem of indie apps. One day, after stumbling upon a very simple and elegant Markdown editor called <a href="https://ia.net/writer" target="_blank">iA Writer</a>, for one reason or the other, I decided to make something similar.</p><p>Armed with enthusiasm, I started learning how to make a native text editor for the Mac. Xcode, AppKit, Objective-C ‚Äî all of it was new to me and not something I would ever find use for at my day job. I had to learn a completely different tech stack that would live inside my head parallel to all the web knowledge.</p><p>At some point, I started calling the app <em>Paper</em> because, in pursuit of ultimate minimalism, I‚Äôve reduced the editor to nothing more than a blank rectangle. To top it off, I‚Äôve made the corners 90¬∞ instead of the typical rounded ones. Silly? Maybe‚Ä¶ But it was my app so I could do whatever I wanted. üòà</p><p>In January 2017, 2 years after starting from ground zero, I launched the Mac app on the Mac App Store. The iOS app followed in 2019.</p><p>Now, it‚Äôs not every day that a random, unknown web developer decides to build an app in a ridiculously crowded category, in a tech stack they have no experience with, and then actually does it, carrying on for the next 7 years. <span><span>‚Äú</span><span>There‚Äôs gotta be some good material here</span><span>‚Äù</span></span> ‚Äî I thought to myself.</p><p>And so ‚Äî here is a brain dump of all the weird, bizarre, and occasionally smart ways that I‚Äôve organized my dev process, app architecture, and product philosophy, coming from a web developer who has not earned a cent working at a job as a Mac or an iOS developer but has earned quite a few of them selling a native text editor to the users of Apple devices.</p></section><section><h2 id="why-native">Why native?</h2><p>You could make the argument that an Electron app would work as well. Why go through the hassle of learning a brand new tech stack especially when my main job is web-related? I could have reused the skills, saved time, and supported more platforms all at the same time.</p><p>Well, my goal was to deliver the best experience possible. I was trying to compete with highly polished writing apps, thus my app had to be light and fast to begin with. In addition to that, there are simply more ways to mess with the app on the native level ‚Äî to make it unique <span>(especially when it comes to text)</span>. I was not trying to reach the maximum number of users nor to cut down the development time. I had all the time in the world. I was trying to craft an experience that starts with lightning-fast download time and carries on into a native-feeling UI and UX.</p><p>I wanted the best and I was willing to pay the penalty.</p></section><section><h2 id="why-objective-c">Why Objective-C?</h2><p>In 2015 Swift was just getting started. I decided to make a test. I‚Äôve compiled an empty Xcode project in Objective-C and another one in Swift and then examined the respective <code>.app</code> packages. To my surprise, the Swift one had the full Swift runtime embedded into it ‚Äî about <code>5MB</code>, while the Objective-C one was super light ‚Äî tens or maybe <code>100KB</code> in total. That was enough to convince me to go with Objective-C.</p><p>Again ‚Äî I wanted the best and I was willing to pay the penalty of a harder-to-learn, soon-to-be outdated language to get a slimmer distributable.</p><p>To be fair, if you run this experiment today the difference will not be that dramatic. Swift has come a long way and my guess is Apple has either embedded it into their platforms or added some fancy <a href="https://en.wikipedia.org/wiki/Tree_shaking" target="_blank">tree shaking</a> for the binary.</p></section><section><h2 id="third-party-dependencies">Third-party dependencies</h2><p>Paper does not have third-party dependencies.</p><p>I had little trust in my ability to pick the right dependencies from an ecosystem that I was not familiar with. Plus by building everything on my own I could tailor it to my needs, gaining a slight advantage over competitors who often rely on external dependencies even for core parts of their apps.</p><p>For example, the Markdown parsing engine in Paper is bespoke. Why is that a good thing? Because Paper supports less Markdown syntax than the traditional fully-fledged Markdown editor. I can code in just the right amount of parsing logic and nothing more. In addition to that, I can parse it with the right level of <em>metadata granularity</em> which makes implementing features such as highlighting and text transformations simpler and more efficient.</p><p>A similar but even stricter approach applies to UI components. Paper uses only native UI elements from AppKit and UIKit since they have the lowest maintenance overhead: auto-updated by Apple, adjustable to various <a href="https://developer.apple.com/documentation/uikit/uitraitcollection" target="_blank">traits</a>, backward compatible, and guaranteed to work on every device. Not to mention that to the average user, it is the most familiar UI ‚Äî from the way it works to the <em>bounciness</em> of animations.</p><p>In case not a single built-in UI component is suitable to implement the desired feature, then I simply don‚Äôt add the feature. For instance, the <code>NSPopover</code> is a good candidate for <em>bubbles that hint at stuff</em> in the Mac app. An iOS counterpart sadly does not exist, so no bubbles in the iOS app. ü§∑üèº‚Äç‚ôÇÔ∏è</p></section><section><h2 id="vision">Vision</h2><p>The initial vision for Paper was simple ‚Äî build something that has the core tricks of iA Writer, but in a package that feels even more elegant and minimal. To achieve the desired effect I went all-in on cutting down distractions:</p><ul><li>Not having a single extra button inside the app window.</li><li>Not having a standard Preferences window, but instead packing everything into menu items and menu widgets and hiding rarely used menu items under the ‚å• key.</li><li>Slimming down the scroll bar to a <span>2px</span> line that runs on the edge of the window and matches the <span>2px</span> caret.</li><li>Centering characters within the line so that there is an equal amount of caret above and below the character.</li><li><em>Scrolling away</em> the title bar and extending the text area into the title bar <span>(and making the remaining whitespace around the editor <em>draggable</em> to account for the fact that the usual draggable title bar area can be taken by the editor)</span>.</li></ul><p>Have people noticed the effort? Most probably not‚Ä¶ but some have. So much so that at one point Paper received a perfectly succinct review that I use as a tagline to this day.</p><blockquote><p>This is a super-clean writing space with a lot of configurability that stays out of sight when you don‚Äôt need it.</p></blockquote><p>As time went on I started developing a feeling for how the market of minimal Apple text editors looks like and what could be Paper‚Äôs place in it.</p><p>To my observations, minimalist writing apps usually follow 2 paths:</p><ol><li>Become popular and start slowly drifting away from their minimalist roots to satisfy the ever-growing demands of mainstream users.</li><li>Remain too simple and niche to eventually be abandoned by their creators.</li></ol><p>Paper is not <span><span>[</span><span>1.</span><span>]</span></span> but it could be on the path to <span><span>[</span><span>2.</span><span>]</span></span>.</p><p>My plan is to forever keep the app as minimal as it was when it launched ‚Äî to resist adding any visual clutter. For a certain group of people, this is a vital requirement that other apps <span>(apparently)</span> fail to address.</p><blockquote><p>Please do not make Paper more complex! There are plenty and plenty of &#39;full featured&#39; editors out there, and they do not fit the bill for focused writing.</p></blockquote><p>At the same time by having a slow and predictable cadence of small updates <span>(more on that <a href="#releases">at the end</a>)</span> I can slowly add features to the <em>fringes</em> of the app while keeping the <em>default path</em> super clean. Making Paper more useful but not bloated.</p><img src="https://jinnycho.github.io/dev-article/vision.png" width="768" height="1000" alt="A call stack in Xcode on the left. One frame is selected. The right pane shows the machine code of the selected frame."/><p>The slow pace and the overall limited number of features allow me to focus on building a better foundation, to better understand how things work together, and to avoid adding features that bring instability and a high maintenance burden in the future.</p><p>Closed-sourced native UI is a fragile place compared to the predictable JavaScript runtime of the browser. If you don‚Äôt invest substantial resources into refactoring your app and eliminating bugs ‚Äî it‚Äôs death by a thousand crashes. And this is what I am banking on with regard to <span><span>[</span><span>1.</span><span>]</span></span>. The bloat, complexity, and bugs that <span><span>[</span><span>1.</span><span>]</span></span> accumulate from their decision to go mainstream present good opportunities to capture some of the disappointed users that eventually leave them.</p><p>This however may not be enough to make Paper into a viable product. There are simply not enough <span>(reachable)</span> people who need these kinds of ultra-simple writing apps <span>(let alone pay for one)</span>. Power users are the ones who pay the bills because they need power tools to earn money that they can then justify spending on those tools. And while <span><span>[</span><span>1.</span><span>]</span></span> and <span><span>[</span><span>2.</span><span>]</span></span> are the majority, there <em>definitely</em> are cases of simple writing apps that remain simple and/or that are still supported by obsessive single players like me. There might just never be a big enough gap in the market for Paper. ü§∑üèº‚Äç‚ôÇÔ∏è</p></section><section><h2 id="architecture">Architecture</h2><p>I find it convenient to think of Paper‚Äôs code as consisting of two <em>scopes</em>.</p><ul><li><div><p><strong>Application scope</strong></p><ul><li><div><p>Global stuff that exists as a single instance or is applied to the app as a whole.</p><ul><li>macOS menu</li><li>iOS status bar</li><li>Touch bar</li><li>App icon</li><li>Dark mode</li><li>Input language</li><li>Global app config</li><li>Global app logic</li><li>Single instance views</li></ul></div></li></ul></div></li><li><div><p><strong>Document scope</strong></p><ul><li>A collection of views and logic that live inside a view controller representing a single document.</li><li>A new document scope spawns into life the moment the document is opened and dies when it is closed.</li><li>Unlike a singular application scope, zero or more document scopes can exist at the same time.</li></ul></div></li></ul><p>The reality is a bit more nuanced as there are also <em>scenes</em> on iOS that subdivide the global scope, but the mental model holds more or less.</p><p>For every scope, I define a <em>storyboard</em> that serves 2 functions:</p><ul><li>It describes various views and widgets that are used within the scope.</li><li>It acts as a <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank">dependency injection</a> container that glues together all <em>modules</em> within the scope.</li></ul><p>Modules <span>(not to be confused with <code>.modulemap</code> stuff ‚Äî I just happen to use the same name)</span> in Paper are plain Objective-C classes that take responsibility for a piece of functionality within the app. It‚Äôs a way to group functionality related to a particular feature instead of spreading it across multiple places.</p><p>Modules have a well-defined lifecycle:</p><ol><li><div><p>They are created by the storyboard when the <em>main thing</em> within the storyboard gets created.</p><ul><li><div><p><strong>Application scope</strong></p><ul><li>The <em>main thing</em> is the app itself, so all modules are created on startup.</li></ul></div></li><li><div><p><strong>Document scope</strong></p><ul><li>The <em>main thing</em> is the view controller that holds the editor.</li></ul></div></li></ul></div></li><li><div><p>They have a setup method that gets called after the dependencies have been injected, but before the <em>main thing</em> becomes visible.</p><ul><li><div><p><strong>Application scope</strong></p><ul><li><div><p>Called on</p><ul><li><code>ApplicationDidFinishLaunchingNotification</code></li><li><code>UISceneWillConnectNotification</code> for scenes</li></ul></div></li></ul></div></li><li><div><p><strong>Document scope</strong></p><ul><li>Called on <code>didMoveToWindow</code> of the main view.</li></ul></div></li></ul></div></li><li><div><p>They have a tear-down method that gets called before the <em>main thing</em> is destroyed.</p><ul><li><div><p><strong>Application scope</strong></p><ul><li>No need. Modules die with the app.</li></ul></div></li><li><div><p><strong>Document scope</strong></p><ul><li>Called on <code>willMoveToWindow</code> of the main view when the <code>newWindow</code> argument is <code>nil</code>.</li></ul></div></li></ul></div></li></ol><p>Modules declare their dependencies ‚Äî views and other modules.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> TvTextAttributeModule.m</p></div><p><code><span><span>@interface</span> <span>TvTextAttributeModule</span>()</span></code></p></div><p>I resolve them manually in Xcode.</p><p>Dependencies are then injected by the storyboard at runtime when the view controller is instantiated.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> OpenCloseDocumentModule.m</p></div><p><code><span><span>UIStoryboard</span> *sb = [<span>UIStoryboard</span> <span>storyboardWithName</span>:<span>@&#34;Document&#34;</span></span></code></p></div><p>If a document-scoped module needs something from the application scope it can get it from the global variable‚Ä¶</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> DocClosingModule.m</p></div><p><code><span>[<span>self</span>.<span>viewController</span>.<span>presentingViewController</span> <span>dismiss_</span>:^{</span></code></p></div><p>‚Ä¶or from the root of the view hierarchy for scenes.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> DocNavigationBarModule.m</p></div><p><code><span>BOOL</span> unread = <span>self</span>.<span>rootViewController</span>.<span>supportChatModule</span>.<span>unread</span> &gt; <span>0</span>;</code></p></div><p>Modules subscribe to notifications <span>(pub-sub events between classes)</span> during the setup phase of the lifecycle and unsubscribe during the tear-down phase.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> TvCaretHintModule.m</p></div><p><code><span>- (<span>void</span>)<span>addNotificationObservers</span> {</span></code></p></div><p>Modules can let other modules know that something has happened. This is done through direct method calls rather than notifications to keep things simpler, IDE navigable, and faster.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> TvInsetModule.m</p></div><p><code><span><span>UIEdgeInsets</span> contentInset = <span>self</span>.<span>calculateContentInset</span>;</span></code></p></div><p>Modules can ask other modules to do or to calculate something that those other modules are responsible for.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> MoDocWelcomeModule.m</p></div><p><code><span>- (<span>void</span>)<span>textViewDidAnimateCaretFirstAppearance</span> {</span></code></p></div><p>This leaves the delegates, view controllers, and views as proxies that notify modules about stuff that‚Äôs going on in the app and delegate everything to them.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> MaTextView.m</p></div><p><code><span>- (<span>void</span>)<span>insertText</span>:(<span>id</span>)string <span>replacementRange</span>:(<span>NSRange</span>)range {</span></code></p></div><p>All in all, the combination of modules and dependency injection through storyboards gives a nice mechanism to decouple and subdivide what would have been a giant document view controller and/or text view. Applying the same approach to the application scope gives the whole app a uniform structure that is a joy to work with.</p></section><section><h2 id="cross-platform-code">Cross-platform code</h2><p>AppKit and UIKit are both quite similar and annoyingly different in many places.</p><p>I employ 2 Objective-C features to work around the differences:</p><ul><li>Macros <span>(this one is inherited from C)</span></li><li>Categories</li></ul><p>For example, in many cases, the difference comes down to <code>NS</code> vs <code>UI</code> prefix which I mitigate with this macro.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/h.png" width="10" height="15" aria-hidden="true"/> SharedAdapter.h</p></div><p><code><span>#if TARGET_OS_OSX</span></code></p></div><p>Now, whenever I need to declare a view in a shared module I can simply type <code>KIT(View)</code> instead of <code>NSView</code> or <code>UIView</code>.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> TvCaretModule.m</p></div><p><code>- (<span>KIT</span>(View) *)<span>cloneCaretView</span> {</code></p></div><p>Besides that, I can use those <code>#if</code> statements to quickly add platform-specific code in shared classes. To make such code more readable Xcode even has a cool trick that deemphasizes the code that does not apply to the currently selected platform.</p><p>Categories in Objective-C are a way to add new methods to any existing class, including framework classes <span>(categories can also be used to replace methods, which is both powerful and scary üòµ)</span>. I use them to harmonize the API. So if a method in <code>UITextField</code> is called <code>text</code> and in <code>NSTextField</code> it is called <code>stringValue</code> I can add a <code>stringValue</code> method to <code>UITextField</code> that calls <code>text</code> <span>(or vice versa)</span>. Now I can always refer to the <code>stringValue</code> method in my <code>KIT(TextField)</code> variable and it will compile on both platforms.</p><p>I gather all these little patches to an <em>adapter</em> header in the shared library.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/h.png" width="10" height="15" aria-hidden="true"/> SharedApplicationAdapter.h</p></div><p><code><span>@interface</span> <span>UITextField</span>(SharedApplicationAdapter)</code></p></div><p>And then implement this header in respective app projects.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> SharedApplicationAdapter.m</p></div><p><code><span>@implementation</span> <span>UITextField</span>(SharedApplicationAdapter)</code></p></div><p>By the way, I also use categories to shorten long framework methods.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> UIViewController+Mobile_.m</p></div><p><code><span><span>@implementation</span> <span>UIViewController</span>(Mobile_)</span></code></p></div><p>The underscore at the end helps to avoid clashes with public or private methods that Apple might decide to add in the future. Apple often prefixes private methods with an underscore, so having it at the end makes more sense.</p></section><section><h2 id="debugging">Debugging</h2><p>Throughout my career I‚Äôve always learned the quickest and the most about a particular third-party dependency by reading the code rather than going through the docs. Documentation is fine to get a general picture, but the details matter especially when stuff does not work the way it should either by <span>(undocumented)</span> design or due to mistakes of the authors.</p><p>Now in the case of Apple frameworks, documentation is sadly the only readable option you have. A far less readable one is to put a breakpoint in your code and examine the compiled stack trace of the framework.</p><img src="https://jinnycho.github.io/dev-article/call-stack-breakpoint.png" width="768" height="464" alt="A call stack in Xcode on the left. One frame is selected. The right pane shows the machine code of the selected frame."/><p>It looks like gibberish, but the important thing is that the method names are visible. Analyzing the flow of method calls is enough to grasp what is going on. And if you need to inspect something that is outside the stack ending in your source code you can always add a <em>symbolic breakpoint</em> to stop inside the framework. For instance, below it stops at <code>recognizedFlickDirection</code> which is visible at the top of the compiled code above.</p><img src="https://jinnycho.github.io/dev-article/call-stack-symbolic-breakpoint.png" width="768" height="464" alt="A call stack in Xcode on the left. One frame is selected. The right pane shows the machine code of the selected frame."/><p>As a side note, going through a 30-year-old codebase you occasionally discover gems such as <code>if</code> statements adjusting the logic of the framework depending on the <span>(Apple)</span> app that runs the framework, or instances of creative naming. üôÉ</p><img src="https://jinnycho.github.io/dev-article/call-stack.png" width="768" height="198" alt="A call stack in Xcode. The top frame is ‚ÄúreallySendEvent‚Äù. One below it is ‚ÄúsendEvent‚Äù."/></section><section><h2 id="paid-features">Paid features</h2><p>Back in 2015‚Äì17, subscriptions were not a widespread thing yet in the App Store. Pay-to-download was <span>(and is)</span> common, but I did not think that someone would pay for an unknown app without trying it, so the one-time payment freemium seemed like the only option. At the same time, I did not want to just paywall the features or implement a custom time-based trial <span>(only subscriptions have built-in trials in the App Store)</span>. I wanted something extremely user-friendly. Something that feels like you can push all the buttons and adjust all the toggles of the paid offering without limits, without needing to explicitly commit to a trial of arbitrary length.</p><p>My solution was to offer only <em>cosmetic</em> upgrades as part of the Pro offering ‚Äî visual changes rather than functional features <span>(e.g. file syncing or PDF exports)</span>.</p><p>I would then make them <em>trialable</em> for an unlimited amount of time. Users could <em>test drive</em> the features to see how they look and work and then buy the Pro offering if they thought that the features were worth it.</p><p>Of course, there needed to be a measure that prevented people from using the features indefinitely without paying. At first, it was a 60-second timer that would nag them to buy if at least one of the Pro features was active. This proved to be too annoying, so I tied the nagging to characters written instead. It made more sense ‚Äî try everything for as much time as you want without distractions but as soon as you start using Paper to write then every couple of hundred characters you would see a popup.</p><img src="https://jinnycho.github.io/dev-article/trial-popup.png" width="372" height="497" alt="A Mac alert popup that says ‚ÄúEnjoying Pro Features? üòé You are using some of the Pro Features from the View menu. üëÄ Consider Subscribing if you think they are worth it. üí≥ Press Reset to reset Pro Features to defaults and get rid of this popup. üëª‚Äù. Three buttons: Subscribe, Ask Again Later, Reset."/><p>Why does this work only for cosmetic upgrades? Because, unlike functional features whose value is tied to a specific momentary action, cosmetic upgrades enhance your writing experience on a constant basis. You cannot put a functional feature behind the same frictionless trial described above since the value of the feature is fully realized the moment the action is performed. On the other hand, letting the users apply cosmetic changes accompanied by a nagging mechanism gives them a taste of the enhanced writing experience yet limits the prolonged value of this enhancement. Forcing the purchase, yet not limiting the ability to fully explore everything on their terms before spending the money.</p><p>What do users think about it? Here is an excerpt from a recent review.</p><blockquote><p><span>‚Ä¶</span>the fact that it lets you mess around with and test pro features instead of locking them behind a paywall (a reason I do not like a lot of apps. They don‚Äôt let you try the features until you start a subscription or trial you may very well forget about, if it even gives you a trial) is extremely nice. <span>[‚Ä¶]</span> You don‚Äôt even have to necessarily trust me on it: jump in and try it yourself. It lets you test every single feature it has.</p></blockquote></section><section><h2 id="pricing">Pricing</h2><p>Paper started with 2 one-time payments of <span>$5</span> each for 2 sets of Pro Features. Today, after many experiments, it is <span>$10</span> per month or <span>$100</span> lifetime for a single set.</p><p>First, before plunging into the world of subscriptions, I experimented with one-time payments. I started gradually doubling the price and observing if the total amount of money earned would increase or decrease. My App Store traffic was pretty stable, so there were always new people coming through the door who did not know anything about previous prices. That‚Äôs when I first discovered that people were willing to pay up to <span>$100</span> for an app from an unknown developer. I tried going up to <span>$200</span>. I think I‚Äôve gotten like 1 or 2 sales and some amount of complaints over several months so I figured that <span>$200</span> is probably the pain point. Thus the market has decided that <span>$100</span> is an adequate price for Paper.</p><p>Next after a lot of hesitation, I decided to introduce subscriptions. <span><span>‚Äú</span><span>No one would pay a subscription for such a simple app</span><span>‚Äù</span></span> ‚Äî was my conviction. But I was wrong. They worked and today Paper has a healthy mix of monthly, annual, and lifetime payments with subscriptions being the default, promoted payment option <span>(since SaaS is all the rage, right?)</span>.</p><p>Even now I still experiment with prices. Recently I doubled the monthly price for new subscribers in some countries while keeping the annual price unchanged. This is to incentivize the annual option and to reduce churn. Preliminary results show that people continue subscribing though in smaller numbers. Still ‚Äî this could be a positive change taking into account the higher monthly price and annual upgrades. We‚Äôll have to wait and see‚Ä¶</p><p>What‚Äôs also great about the App Store is that you can easily test lowering prices for countries with lower incomes. Since Apple does not charge the typical <span>¬¢50</span> per transaction <span>(e.g. like <a href="https://www.paddle.com/pricing" target="_blank">Paddle</a>)</span> you can go as low as you want without those fees eating into your margins. Currently, I am testing to see if lowering the price has any effect or if people in those countries simply don‚Äôt pay for software <span>(or text editors ü§∑üèº‚Äç‚ôÇÔ∏è)</span> no matter what.</p></section><section><h2 id="gnarly-bits">Gnarly bits</h2><p>Text editors are hard‚Ä¶</p><p>Text is one of those things that always gets things bolted onto it. Copy-paste, drag and drop, undo, caret interactions, right-to-left languages, non-alphabetic languages, dictation, spoken text, scanned text, non-text objects in text, data format recognizers, tap-and-hold link previews, text search overlay, spell check, autocorrection, autocomplete, AI suggestions ‚Äî it never stops. You‚Äôre always at the mercy of the next OS update adding new ways to insert, update, and interact with editable text.</p><p>Figuring out the math behind the text editor rectangle is particularly tricky on iOS with various factors like the Dynamic Island <span>(or the notch)</span>, the Home Bar, and the dynamically appearing software keyboard, times 2 orientations, getting in the way.</p><img src="https://jinnycho.github.io/dev-article/text-editor-math.png" width="768" height="1400" alt="Breakdown of the iPhone app text editor structure."/><p>Input languages and fonts are a headache as well. Alphabetic languages are relatively easy to deal with as most major fonts support even quirky glyphs like <a href="https://en.wikipedia.org/wiki/Umlaut_(diacritic)" target="_blank">umlauts</a> and Cyrillics. The non-alphabetic languages however need specific fonts to display their glyphs. Luckily Apple‚Äôs systems come with at least one of those fonts preinstalled per every non-alphabetic input language. The only problem is that no API maps an input language to supported fonts ‚Äî so I had to brute force it. I‚Äôve installed every input language on my Mac and wrote some text in each of them in TextEdit to see what font TextEdit falls back to when it sees the typed glyphs. The following <code>switch</code> is the result of it <span>(I am pretty sure I‚Äôve messed up the names of some languages or nationalities ‚Äî don‚Äôt judge me too hard, I am just a developer üò©)</span>.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> Font.m</p></div><p><code><span>switch</span> (inputLanguage) {</code></p></div><p>I then detect the selected input language and set the font accordingly.</p><img src="https://jinnycho.github.io/dev-article/non-alphabetic.png" width="377" height="502" alt="A screenshot of Font settings in the iPhone app. The only font available and selected is ‚ÄúApple SD Gothic Neo‚Äù. The label above the font name says ‚ÄúKorean‚Äù. The gray text under the font name reads ‚ÄúPaper has automatically switched to the most optimal font for your keyboard language.‚Äù."/><p>One more thing worth mentioning is the fiddly logic of batched text updates e.g. shortcuts that toggle Markdown formatting on a selected piece of text. A naive solution is straightforward, but coding for all the edge cases to avoid breaking the Markdown can be a pain.</p><img src="https://jinnycho.github.io/dev-article/markdown-formatting.png" width="768" height="1722" alt="Breakdown of the way Bold Markdown formatting shortcut works in Paper."/></section><section><h2 id="gimmicks">Gimmicks</h2><p>A <em>thing</em> I‚Äôve picked up from the amazing <a href="https://culturedcode.com/things/" target="_blank">Things</a> app is the delightful resize bounce.</p><p>After a lot of trial and error, this is the damping logic that I‚Äôve landed on.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> WindowResizeBounceModule.m</p></div><p><code><span>NSRect</span> frame = <span>self</span>.<span>window</span>;</code></p></div><p>The tricky part was figuring out the combination of math functions that yield a realistic rubber band effect. ü§ì</p><p>Another fun mathy feature in Paper is the <em>rotate-to-undo</em> gesture.</p><p>A lot of calculations are involved to make it happen, but at the core of it is this logic.</p><div><div><p><img src="https://jinnycho.github.io/dev-article/m.png" width="15" height="11" aria-hidden="true"/> DocRotateUndoModule.m</p></div><p><code><span>self</span>.<span>wheelView</span>.<span>frameCenterRotation</span> = <span>self</span>.<span>wheelViewRotation</span>;</code></p></div><p>I have no idea if this next one has any effect on sales, but in any case ‚Äî I show the total number of Pro users, the positive delta since the last time the user saw this number, and the annual plan savings <span>(which may differ per country or change on-the-fly due to pricing experiments)</span>.</p><p>The delta number is considered <em>seen</em> when it becomes visible on the screen. So it can sit there, unseen for a long time, and then display a big delta once the user has scrolled to it.</p><p>Moving on to the super gimmicky territory ‚Äî this animation is triggered when the screen goes to sleep while Paper is in the foreground. üí§</p><p>Lastly ‚Äî something I‚Äôve noticed in the world of Mac apps is that despite the attention to detail in the app itself the About window almost always gets zero love. Why not make it a little bit more fun? üë®üèª‚Äçüé®</p><img src="https://jinnycho.github.io/dev-article/about.png" width="462" height="312" alt="A small, white, 2:1 Mac window that contains a centered text saying ‚ÄúCrafted in Tallinn‚Äù. The text is light red in a cursive font. Below this text, there is a little gray number 61 in a regular font."/><p><span>(roughly in the dimensions of a business card)</span></p></section><section><h2 id="feedback">Feedback</h2><p>Back in the day, Paper was using an app lifecycle management platform called HockeyApp. The Mac version of HockeyApp came with a hosted support chat that you could easily launch from within your app. Because this chat was so accessible, people were leaving useful feedback in vastly greater numbers compared to email.</p><p>Then came Microsoft, bought HockeyApp and turned it into AppCenter, sunsetting this feature in the process.</p><p>After going back to the desert that is feedback via email I decided to build the support chat myself for both platforms and integrate it to be a beautiful part of the app experience rather than something <em>tacked on</em> as an afterthought.</p><p>I tried mimicking the aesthetic of the Messages app on respective platforms down to those little curvy tips on chat bubbles.</p><img src="https://jinnycho.github.io/dev-article/support-chat.png" width="768" height="707" alt="A Mac app chat window and an iOS app chat window. Both contain 2 chat bubbles. The first one is from Mihhail and contains the text ‚ÄúHey, I make Paper. üëã What‚Äôs on your mind? ü§î‚Äù. The second one is from the user and contains the text ‚ÄúAre you a bot?‚Äù."/><p>Unlike HockeyApp which required an email to get started, I decided to lower the friction to zero to maximize the feedback potential. I was fine to trade lower entry barriers for more spam.</p><p>For the backend, I wanted something hosted and free so I ended up saving conversations to <code>UUID.json</code> files on Dropbox.</p><img src="https://jinnycho.github.io/dev-article/uuid-json.png" width="768" height="768" alt="A part of the Mac Finder window with a list of UUID-named JSON files. File names are mostly blurred out."/><p>I edit those files in a text editor and it syncs back to Dropbox. Looking back, I should have simply built it on top of a Slack workspace. Nevertheless, Dropbox has worked well and still works great for me.</p><p>With time I even spotted a few clear patterns and coded the logic that looks for keywords both in the unsent message box and in the last sent message to show auto-replies as soon as the user has typed the needed keyword. Now I rarely get these questions ‚Äî they are answered <em>before</em> the send button is pressed.</p><img src="https://jinnycho.github.io/dev-article/auto-replies.png" width="412" height="712" alt="A chat window with 2 chat bubbles. The first one is from Mihhail and contains the text ‚ÄúHey, I make Paper. üëã What‚Äôs on your mind? ü§î‚Äù. The second one is also from Mihhail and contains the text ‚ÄúAre you asking about photos? ü§î Sorry, Paper is for text only. Can‚Äôt add photos. PS: This is an auto-reply ü§ñ‚Äù. The unsent message box contains the text ‚ÄúCan I add photos?‚Äù."/><p>Oh, and of course I can‚Äôt answer at night. üò¥</p><img src="https://jinnycho.github.io/dev-article/sleeping.png" width="412" height="712" alt="A chat window with 2 chat bubbles. The first one is from Mihhail and contains the text ‚ÄúHey, I make Paper. üëã What‚Äôs on your mind? ü§î‚Äù. The second one is also from Mihhail and contains the text ‚ÄúHey, I am sleeping right now üò¥. Go ahead and leave me a message üí¨. I‚Äôll reply as soon as I can üëÄ.‚Äù."/><p>In the end, building a polished, frictionless support chat was one of the best decisions that I have ever made for Paper. Not only did it differentiate the app from the rest <span>(unlike the web, live chats in native apps are not a thing especially in tiny apps like Paper)</span>, but also resulted in happier <span>(and often positively surprised)</span> users, faster feedback in case of bugs, and a lot of great ideas. In fact, at some point, 90% of my roadmap started being informed by ideas from the chat.</p></section><section><h2 id="releases">Releases</h2><p>So I‚Äôve gathered and implemented the feedback from the chat. How are the features then propagated to the users?</p><p>About once a month I release one flagship feature that goes into release notes. Often I prepare multiple features during a development streak and then drip them out one at a time over the next months. This gives me the highest chance that someone would actually read the single sentence that is present in the release notes every month.</p><p>Bug fixes, tweaks, and smaller features go into releases usually without being mentioned. As a developer, you might feel better about putting <span><span>‚Äú</span><span>We‚Äôve fixed some bugs and made a few performance improvements</span><span>‚Äù</span></span> into your release notes, but the average user of a niche, unknown app like Paper has no patience to care.</p><p>If an urgent fix is needed ‚Äî I simply copy-paste the previous release notes to keep the flagship feature advertisement going. I do not mention the fix at all.</p><p>For the version number, I use a single monotonically increasing number. It‚Äôs the simplest thing so why complicate it with 2+ numbers separated by dots?</p><p>And here is the template that I use for the release notes.</p><blockquote><div><p>Dear User,</p></div></blockquote><p>A bit cringey, but I <em>kinda</em> like it. ü´† It‚Äôs like every month the app sends you a letter explaining what‚Äôs new. Some users have even mentioned this as a thing they look forward to.</p><p>Having something to release every month be it small or big is what greases the flywheel of App Store distribution.</p><p>It shows the current users that their subscription is worth it.</p><p>It signals to potential users that the app has been recently updated.</p><p>It tells the App Store algorithm that the app is not abandoned.</p><p>And finally, this slow and steady pace is what allows me to keep this thing going for years to come.</p></section><section><h2 id="acknowledgment">Acknowledgment</h2><p>Early on in Paper‚Äôs life, an artist and a fan of Paper reached out to offer his services.</p><p>The most prominent result of our collaboration is Paper‚Äôs palette of accent colors. Especially the signature <em>Sepia</em> color that was inspired by <a href="https://en.wikipedia.org/wiki/Sepia_(color)" target="_blank">sepia ink</a>.</p><p>Hats off to <a href="https://penwave.com" target="_blank">Ben Marder</a> for his help. üé©</p><img src="https://jinnycho.github.io/dev-article/accents.png" width="377" height="501" alt="A screenshot of the iPhone app accent color picker."/></section></article><p>PS ‚Äî I like sweating the details. If you think I might be useful to you ‚Üí <a href="https://twitter.com/_mihhail" target="_blank">reach out</a>. <span>üòâ</span></p></div>
  </body>
</html>
