<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joshondesign.com/2017/08/18/idealos_essay">Original</a>
    <h1>Ideal OS: Rebooting the Desktop Operating System (2017)</h1>
    
    <div id="readability-page-1" class="page"><div><p><strong><em>Twitter user </em></strong><a href="https://twitter.com/5thgfka"><strong><em>ekse</em></strong></a><strong><em> has graciously translated this blog </em></strong><a href="http://mp.weixin.qq.com/s/xzfLZE1LCCYaVh6nmYcqhQ"><strong><em>to Chinese</em></strong></a><strong><em>. Thanks!</em></strong><strong> TL;DR: </strong>By the end of this essay I hope to convince you of the following facts. First, that modern desktop operating systems are anything but. They are <strong><em>bloated, slow, and layered with legacy cruft</em></strong> that still functions only thanks to Moore&#39;s Law.  Second, that <em><strong>innovation in desktop operating systems stopped about 15 years ago</strong></em> and the major players are unlikely to heavily invest in them again. And finally, I hope to convince you that we can and <em><strong>should start over from scratch</strong></em>, learning the lessons of the past.</p><h3>&#34;Modern&#34; Desktop Operating Systems are Bloated</h3><p>Consider the Raspberry Pi. For 35 dollars I can buy an amazing computer with four CPU cores, each running over a <em>gigahertz</em>. It also has a 3d accelerator, a gig of RAM, and built in wifi &amp; bluetooth &amp; ethernet. For 35 bucks! And yet, for many of the tasks I want to do with it, this Raspberry Pi is no better than the 66 <em>megahertz</em> computer I used in college.</p><p><img src="https://joshondesign.com//images2/snail.jpg"/></p><p>In fact, in some cases it&#39;s worse. It took tremendous effort to get 3D accelerated Doom to work inside of X windows in the mid 2000s, something that was trivial with mid-1990s Microsoft Windows.</p><p>Below is a screenshot of Processing running for the first time on a Raspberry Pi with hardware acceleration, just a couple of years ago. And it was possible only thanks to a completely custom X windows video driver.  This driver is still experimental and unreleased, <em>five years</em> after the Raspberry Pi shipped.</p><p><img src="https://joshondesign.com//images2/processing.png"/></p><p>Despite the problems of X-Windows, the Raspberry Pi has a suprisingly powerful GPU that can do things like the below screenshot, but only once we get X windows out of the way. (the actual screenshot below is from OSX, but the same code does run on a Pi 3 at 60fps).</p><p><img src="https://joshondesign.com//images2/amino.png"/></p><p>Here&#39;s another example. Atom is one of the most popular editors today. Developers love it because it has oodles of plugins, but let us consider how it&#39;s written. Atom uses Electron, which is essentially an entire webbrowser married to a NodeJS runtime. That&#39;s two Javascript engines bundled up into a single app. Electron apps use browser drawing apis which delegate to native drawing apis, which then delegate to the GPU (if you&#39;re luck) for the actual drawing. So many <em>layers</em>.</p><p><img src="https://joshondesign.com//images2/atom.png"/></p><p>For a long time Atom <a href="https://github.com/atom/atom/releases/tag/v0.208.0">couldn&#39;t open a file larger than 2 megabytes</a> because scrolling would be to slow. They solved it by writing the buffer implementation in C++, essentially removing one layer of indirection.</p><p><img src="https://joshondesign.com//images2/mail.png"/></p><p>Even fairly simple apps are pretty complex these days. An email app, like the one above is conceptually simple. It should just be a few database queries, a text editor, and a module that knows how to communicate with IMAP and SMTP servers. Yet writing a new email client is very difficult and consumes many megabytes on disk, so few people do it. And if you wanted to modify your email client, or at least the one above (Mail.app, the default client for Mac), there is no clean way to extend it. There are no plugins. There is no extension API. This is the result of many layers of cruft and bloat.</p><h3>No Innovation</h3><p>Innovation in desktop operating systems is essentially dead. One could argue that it ended sometime in the mid-90s, or even in the 80s with the release of the Mac, but clearly all progress stopped after the smartphone revolution. </p><h3>Mac OS</h3><p>Mac OS X was once a shining beacon of new features, with every release showing profound progress and invention. Quartz 2D! Expose! System wide device syncing! Widgets! Today, however Apple puts little effort into their desktop operating system besides changing the theme every now and then and increasing hooks to their mobile devices.</p><p><img src="https://joshondesign.com//images2/highsierra.jpg"/></p><p>Apple&#39;s newest version of Mac OS X (now renamed macOS in honor of where they were two decades ago) is called High Sierra. What are banner features that we are eagerly awaiting this fall? A new filesystem and a new video encoding format. Really, that&#39;s it? Oh, and they added editing to Photos, which was already there in iPhotos but removed during the upgrade and they will block autoplay videos now in Safari.</p><p>Apple is the most valuable company in the world and this is the best they can do? Desktop UX just isn&#39;t a priority for them.</p><h3>Microsoft Windows</h3><p>On the Windows side there has been a flurry of activity as Microsoft tried to reinvent the desktop as a touch operating system for tablets and phones. This was a disaster that they are still recovering from. In the process of this shift they didn&#39;t add any features that actually helped desktop users, though they did spend an absurd amount of money creating a custom background image.</p><p><img src="https://joshondesign.com//images2/windows10.jpg"/></p><p>Instead of improving the desktop UX they focused on adding new application models with more and more layers on top of the old code. Incidentally, Windows can <em>still</em> run applications from the early 90s.</p><p>CMD.exe, the terminal program which essentially still lets you run DOS apps was only replaced in 2016. And the biggest new feature of the latest Windows 10 release? They added a Linux subsystem. More layers piled on top.</p><h3>X Windows</h3><p><img src="https://joshondesign.com//images2/compiz.jpg"/></p><p>X Windows has improved even less than the other two desktop OSes. In fact, it&#39;s the very model of non-change. People were complaining about it <a href="http://www.art.net/~hopkins/Don/unix-haters/x-windows/disaster.html">in the early 90s</a>. I&#39;m glad that I can reskin my GUI toolkit, but how about a system wide clipboard that holds more than one item at a time? That hasn&#39;t changed since the 80s!</p><p>X added compositing window managers in the mid-2000s, but due to legacy issues it can&#39;t be used for anything beyond sliding your windows around.</p><p><img src="https://joshondesign.com//images2/wayland.jpg"/></p><p>Wayland is supposed to fix everything, but it&#39;s been almost a decade in development and still isn&#39;t ready for prime time.  Compatibility with old stuff is really hard.  I think Apple had the right idea when they bundled the old macOS up in an emulator called Classic, fire-walling it off from the new code.  </p><h3>Work Stations?</h3><p>Fundamentally desktop operating systems became easier to use as they were adopted by the mass market; then the mass market moved to smartphones and all interest in improving the desktop interface stopped. </p><p>I can&#39;t blame Apple and Microsoft (and now Google) for this. 3 billion smartphones replaced every two years is a far bigger market than a few hundred million desktops and laptops replaced every five.</p><p><img src="https://joshondesign.com//images2/steampunk.jpg"/></p><p>I think we need to take back the desktop operating system experience. We used to call these things <em>workstations</em>. If the desktop is freed from being the OS for the masses, then it can go back to being an OS for work.</p><h3>Things we don&#39;t have in 2017</h3><p>This is the year 2017. Let&#39;s consider things that really should exist, but don&#39;t for some reason. </p><p>Why can I dock and undock tabs in my web browser or in my file manager, but I can&#39;t dock a tab between the two apps? There is no technical reason why this shouldn&#39;t be possible. Application windows are just bitmaps at the end of the day, but the OS guys haven&#39;t built it because it&#39;s not a priority.</p><p>Why can&#39;t I have a file in two places at once on my filesystem? Why is it fundamentally hierarchical? Why can I sort by tags and metadata? Database filesystems have existed for decades. Microsoft tried to build it with <a href="https://hal2020.com/2013/02/14/winfs-integratedunified-storage-and-microsoft-part-1/">WinFS</a>, but that was removed from Vista before it shipped thanks to internal conflicts. BeOS <a href="https://en.wikipedia.org/wiki/Be_File_System">shipped it twenty years ago</a>. Why don&#39;t we have them in our desktop OSes today? </p><p><img src="https://birdhouse.org/beos/refugee/trackerbase.gif"/></p><p>Any web app can be zoomed. I can just hit <em>command +</em> and the text grows bigger. Everything inside the window automatically rescales to adapt. Why don&#39;t my native apps do that? Why can&#39;t I have one window big and another small? Or even scale them automatically as I move between the windows?  All of these things are trivial to do with a compositing window manager, which has been commonplace for well over a decade. </p><h3>Limited Interaction</h3><p>My computer has a mouse, keyboard, tilt sensors, light sensors, two cameras, three microphones, and an array of bluetooth accessories; yet only the first two are used as general input devices. Why can&#39;t I speak commands to my computer or have it watch as I draw signs in the air, or better yet watch as I work to tell me when I&#39;m tired and should take a break.</p><p>Why can&#39;t my computer watch my eyes to see what I&#39;m reading, or scan what I&#39;m holding in my hands using some of that cool AR technology coming to my phone. Some of these features do exist as isolated applications, but they aren&#39;t system wide and they aren&#39;t programmable.</p><p>Why can&#39;t my Macbook Pro use Bluetooth for talking to interesting HID devices instead of syncing to my Apple Wait. Oh wait, my Mac <em>can&#39;t</em> sync to my Apple Watch. Another place where my desktop plays second fiddle to my phone.</p><p>My can&#39;t my computer use anything other than the screen for output? My new Razor laptop has an RGB light embedded under every key, and yet <a href="https://www.youtube.com/watch?v=5FZNrnREE8M">it&#39;s only used for waves of color</a>.  How about we use these LEDs for <a href="https://arcan-fe.com/2017/05/21/playing-with-leds/">something useful</a>! (via Bjorn Stahl, I think).</p><p><img src="https://i.ytimg.com/vi/SrITIJStKQo/maxresdefault.jpg"/></p><h3>Application Silos</h3><p>Essentially every application on my computer is a silo. Each application has its own part of the filesystem, its own config system, and its own preferences, database, file formats and search algorithms. Even its own set of key bindings. This is an incredible amount of duplicated effort.</p><p>More importantly, the lack of communication between applications makes it very difficult to get them to coordinate. The founding principle of Unix was small tools that work together, but X Windows doesn&#39;t enable that at all.</p><h3>Build for 1984</h3><p>So why are our computers still so clunky? Essentially because they were built for 1984. The Desktop GUI was invented at a time when most people created a document from scratch, saved it, and printed it. If you were lucky you stored the document on a shared filesystem or emailed it to someone. That was it. The GUI was built to handle tasks that were previously done with paper.</p><p>The problem is that we live in 2017. We don&#39;t work the same way we did in 1984. In a typical day I will bring in code from several remote sites, construct some tests, and generate a data structure representing the result, which are then sent out to the internet for others to use.  Import, synthesize, export.  </p><p>I create VR content. I remix images. I send messages to a dozen social networks. I make the perfect play list from a selection of 30k songs. I process orders of magnitude more data from more locations than I did only 20 years ago, much less 40 years ago when these concepts were  invented. The desktop metaphor just doesn&#39;t scale to today&#39;s tasks.  I need a computer to help me do modern work.</p><h3>We need a modern workstation</h3><p><img src="https://joshondesign.com//images2/workstation.jpg"/></p><p>So now we come to the speculative part.  Suppose we actually had the resources, and had a way to address (or ignore) backwards compatibility. Suppose we actually built something to redesign the desktop around modern work practices. How would we do it?</p><p>We should start by getting rid of things that don&#39;t work very well.</p><ul><li><strong>Traditional filesystems</strong> are hierarchical, slow to search, and don&#39;t natively store all of the metadata we need.</li><li><strong>All IPC.</strong> There are too many ways for programs to communicate. Pipes, sockets, shared memory, RPC, kernel calls, drag and drop, cut and paste. </li><li><strong>Command line interfaces</strong> don&#39;t fit modern application usage. We simply can&#39;t do everything with pure text. I&#39;d like to pipe my Skype call to a video analysis service while I&#39;m chatting, but I can&#39;t really run a video stream through awk or sed.</li><li><strong>Window Managers</strong> on traditional desktops are not context or content aware, and they are not controlable by other programs.</li><li><strong>Native Applications</strong> are heavy weight, take a long time to develop and very siloed.</li></ul><p>So what does that leave us with? Not much.  We have a kernel and device drivers. We can keep a reliable filesystem but it won&#39;t be exposed to end users or applications. NOw let&#39;s add some things back in.</p><h3>Document Database</h3><p>Start with a system wide document database. Wouldn&#39;t it be easier to build a new email client if the database was already built for you? The UI would only be a few lines of code.  In fact, many common applications are just text editors combined with data queries. Consider iTunes, Address Book, Calendar, Alarms, Messaging, Evernote, Todo list, Bookmarks, Browser History, Password Database, and Photo manager.  All of these are backed by their own unique datastore.  Such wasted effort, and a block to interoperability.</p><p>BeOS proved that a database filesystem could really function and provide incredible advantages. We need to bring it back.</p><p><img src="http://toastytech.com/guis/b5petracker.png"/></p><p>A document database filesystem has many advantages over a traditional one. Not only can &#39;files&#39; exist in more than one place, and they become easily searchable, having a guaranteed performant database makes app building far easier.</p><p>Consider iTunes. iTunes stores the actual mp3 files on disk, but all metadata in a private database.  Having two sources of truth causes endless problems. If you add a new song on disk you must manually tell iTunes to rescan it. If you want to make a program that works with the song database you have to reverse engineer iTunes DB format, and pray that Apple doesn&#39;t change it.  All of these problems go away with a single system wide database.</p><h3>Message Bus</h3><p>A message bus will be the only kind of IPC. We get rid of sockets, files, pipes, ioctrls, shared memory, semaphores, and everything else. All communication is through a message bus. This gives us one place to manage security and enables lots of interesting features through clever proxying.  </p><p>In reality we probably would continue to have some of these available as options for apps that need it, like sockets for a webbrowser, but all communication to the system and between apps should be messages.</p><h3>Compositor</h3><p>Now we can add in a compositing window manager that really just moves surfaces around in 3D, transforms coordinates, and is controlled through messages. Most of what a typical window manager does, like arranging windows, overlaying notifications, and determining which window has focus; can actually be done by other programs who just send messages to the compositor to do the real work.</p><p>This means the compositor is heavily integrated with the graphics driver, which is essential to making such a system fast. Below is the diagram for Wayland, the compositor which will eventually become the default for desktop Linux.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/The_Linux_Graphics_Stack_and_glamor.svg/1000px-The_Linux_Graphics_Stack_and_glamor.svg.png"/></p><p>Applications would do their drawing by requesting a graphics surface from the compositor. When they finish their drawing and are ready to update they just send a message saying: please repaint me.  In practice we&#39;d probably have a few types of surfaces for 2d and 3d graphics, and possibly raw framebuffers. The important thing is that at the end of the day it is the compositor which controls what ends up on the real screen, and when.  If one app goes crazy the compositor can throttle it&#39;s repaints to ensure the rest of the system stays live.</p><h3>Apps become Modules</h3><p>All applications become small modules that communicate through the message bus for everything. <strong>Everything</strong>. No more file system access. No hardware access. Everything is a message.</p><p>If you want to play an mp3 you send a play message to an mp3 service. You draw by having the compositor do it for you. This separation makes the system far more secure. In Linux terms each app would be completely isolated through user permissions and chroot, or perhaps all the way to docker containers or virtual machines. There&#39;s a lot of details to work out, but this is very doable today.</p><p>Module apps would be far easier to write than today. If the database is the single source of truth then a lot of the general work of copying data in and out of memory can go away.  In the music player example, instead of the search field loading up data and filtering it to show the list, the search field just specifies a query. The list is then bound to this query and data automatically flows in.  If another application adds a song to the database that matches the search query, the music player UI will automatically update. This is all without any extra work from the app developer. Live queries make so many things easier and more robust.</p><h3>Rebuild the Apps</h3><p>From this base we should be able to build everything we need. However, this also means we <em>have</em> to rebuild everything from scratch. Higher level constructs built on top of the database would make many applications a lot easier to rebuild.  Let&#39;s look at some examples.</p><p>Email.  If we separate the standard email client into GUI and networking modules, which communicate solely through messages, then building a client becomes a lot easier.  The GUI doesn&#39;t have to know anything about GMail vs Yahoo mail or how to process SMTP error messages. It simply looks for documents with type &#39;email&#39; in them. When the GUI wants to send a message it marks an email with the property <em>outgoing=true</em>. A headless module will listing for outgoing emails and do the actual STMP processing. </p><p>Splitting the email app into component makes replacing one part far easier. You could build a new email frontend in an afternoon without having to rebuild the networking parts. You could build a spam detector that has <em>no UI at all</em>,  it just listens for incoming messages, processes them, and marks the bad ones with a spam tag. It doesn&#39;t know or care how spam is visualized. It just does one thing well. </p><p>Email filters could do other interesting things. Perhaps you send an email to your bot with the command &#39;play beatles&#39;. A tiny module looks for this incoming email, sends another message to the mp3 module for playing the music, then marks the email as deleted.</p><p>Once everything becomes a database query the entire system becomes more flexible and hackable.</p><h3>The command line</h3><p>I know I said we would get rid of the commandline before, but I take that back. I really like the commandline as an interface sometimes, it&#39;s the pure text nature that bothers me.  Instead of chaining CLI apps together with text streams we need something richer, like serialized object streams (think JSON but more efficient). Then we start getting some real power.</p><p>Consider the following tasks:</p><ul><li>I want to use my laptop as an amplified microphone. I speak into it and the sound comes out of a bluetooth speaker on the other side of the room.</li><li>Whenever I tweet something with the hashtag #mom I want a copy sent, by email, to my mother.</li><li>I want to use my iphone sitting on a stand made of legos as microscope. It streams to my laptop, which has controls to record, pause, zoom, and rebroadcast as a live stream to youtube. </li><li>I want to make a simple bayesian filter which detects emails from my power company, adds the tag &#39;utility&#39;, logs into the website, fetches the current bill amount and due date, and adds an entry to my calendar.</li></ul><p>Each of these tasks is conceptually simple but think of how much code you would have to write to actually make this work today. With a CLI built on object streams each of these examples could become a one or two line script.  </p><p>We could do complex operations like &#39;find all photos taken in the last four years within 50 miles of Yosemite, and that have a star rating of 3 or higher, resize them to be 1000px on the longest size, then upload them to a Flickr album called &#34;Best of Yosemite&#34;, and link to the album on Facebook&#39;.  This could be done with built in tools, no custom coding required, just by combining a few primitives.</p><p><img src="https://joshondesign.com//images2/automator.png"/></p><p>Apple actually built such a system. It&#39;s called Automator. You can visually create powerful workflows. They never promote it, have started deprecating the Applescript bindings which make it work underneath, and recently laid off or transferred all of the members of the Automator team.  Ah well.</p><h3>System Side Semantic Keybindings</h3><p>Now that we&#39;ve rebuilt the world, what new things could we do?</p><p>Services are available system wide. This means we could have a keybinding service which gives the user one place to set up keybindings. It also means we could have a richer sense of what a keybinding is.  Instead of mapping a key to a function in a particular program, a key binding maps a key combo to a command message. All applications that work on documents could have a &#39;save&#39; or &#39;new&#39; command. The keybinding service would be responsible for turning a control-S into the save command. I call these semantic keybindings.</p><p>Semantic keybindings would also make it a lot easier to support alternate forms of input.  Suppose you built a weird Arduino button thing that speaks every time you mash a button. You wouldn&#39;t need to write any custom code. Just make the arduino send in a new keypress event, then map it to a play audio message in the bindings editor. Turn a digital pot into a custom scroll wheel. Your UI is now fully hackable.  </p><p>I need to do some more research in this area, but I suspect semantic keybindings would make screen readers and other accessibility software easier to build.</p><h3>Windows</h3><p>In our new OS every window is tab dockable. Or side dockable. Or something else. The apps don&#39;t care. We have a lot of freedom to explore here.</p><p><img src="https://joshondesign.com//images2/system8.jpg"/></p><p>The old <a href="https://en.wikipedia.org/wiki/Mac_OS_8">MacOS 8</a> had a form of tabbed windows, at least for Finder windows, where you could dock them at the bottom of the screen for easy access. Another cool thing that was left behind in the transition to Mac OS X</p><p>In the screenshot below the user is lifting the edge of a window up to see what&#39;s underneath. That&#39;s super cool!</p><p><img src="https://joshondesign.com//images2/lift-window.png"/></p><p>This is an example from <a href="http://direction.bordeaux.inria.fr/~roussel/publications/2003-CLIHC-ametista.pdf"><em>Ametista: a mini-toolkit for exploring new window management techniques</em></a>, a research paper by Nicolas Roussel.</p><p>Since the system fully controls the environment of all apps, it could enforce security restrictions and show that to the user. A trusted system app could have a green border. A new app downloaded from the internet would have a red border. An app with an unknown origin could have a black border, or just not be shown at all.  Many kinds of spoofing attacks become impossible.</p><h3>Smart copy and paste</h3><p>When you copy in one window then shift to another, the computer knows that you just copied something. It can now use this knowledge to do something useful, like automatically shift the first window to the side, but still visible, and render the selected text in glowing green. This keeps the user&#39;s mind on the task at hand. When the user pastes into a new window we could show the green text actually leap from one window to another.</p><p>But why stop there.  Let&#39;s make a clipboard that can hold more than one item at at time. We have gigs of RAM. Let&#39;s use it.  When I copy something why do I have to remember what I copied before I paste it? The clipboard isn&#39;t actually visible anywhere. Let&#39;s fix that.</p><p>The clipboard should be visible on screen as some sort of a shelf that shows the recent items I&#39;ve copied. I can visit three webpages, copy each url to the clipboard, then go back to my document and paste all three at once.</p><p>This clipboard viewer can let me scroll through my entire clipping history. I could search and filter it with tags. I could &#39;pin&#39; my favorites for use later.</p><p>Classic macOS actually had an amazing tool built into it called [name], but it was dropped in the shift to OS X. We had the future decades ago!  Let&#39;s bring it back.</p><h3>Working Sets</h3><p>And finally we get to what I think is the most powerful metaphor change in our new Ideal OS.  In the new system all applications are tiny isolated things which only know what the system tells them. If the treat the database as the single source of truth, and the database itself is versioned, and our window manager is fully hackable... then some really interesting things become possible.</p><p>Usually I have a split between personal files and files for work. I tend to use separate folders, accounts, and sometimes separate computers. In the Ideal OS my files could actually be separated by the OS. I could have one screen up with my home email, and another screen with my work email. These are the exact same app, just initialized with different query settings.</p><p>When I open a file browser on the home screen it only shows files designated as home projects. If I create a document on my work screen the new file is automatically tagged as being work only. Managing all of this is trivial; just extra fields in the database.</p><p>Researchers at Georgia Tech actually built a version of this in their research paper: <a href="https://uist.acm.org/archive/adjunct/2007/pdf/demos/p45-voida.pdf"><em>Giornata: Re-Envisioning the Desktop Metaphor to Support Activities in Knowledge Work</em></a>.</p><p><img src="https://joshondesign.com//images2/giornata.png"/></p><p>Now let&#39;s take things one step further. If everything is versioned, even GUI settings and window positioned (since it&#39;s all stored in the database), I could take a snapshot of a screen. This would store the current state of everything, even my keybindings.  I can continue working, but if I want I could <strong>rollback</strong> to that snapshot. Or I could view the old snapshot and restore it to a new screen. Now I have essentially created a &#39;template&#39; that I can use over and over whenever I start a new project. This template can contain anything I want: email settings, chat history, todos, code, issue windows, or even a github view.</p><p>Now we can essentially treat all state in the computer like a github repo, with the ability to fork the state of the entire system.  I think this would be huge. People would exchange useful workspaces online much as they do with Docker images. People could tweak their workflows add useful scripts embedded into the workspaces. The possibilities really are amazing.</p><h3>None of this is New</h3><p>So that&#39;s it. The vision. All of this is built on three things: a system wide versioned <strong>realtime database</strong>, a system wide realtime <strong>message bus</strong>, and a programmable <strong>compositor</strong>. </p><p>I want to stress that <em>absolutely nothing</em> I&#39;ve talked about here is new.  I didn&#39;t come up with any of them. All of these ideas are years or decades old.  Database filesystems were pioneered by BeOS. Plan 9 used a single mechanism for all IPC. Oberon let you customize the environment entirely within an editable document.  And of course tons and tons of fascinating research papers.</p><h3>Why don&#39;t we have it?</h3><p>None of this is new. And yet we still don&#39;t have it? Why is that?  </p><p>I suspect the root cause is simply that building a successful operating system is hard. It&#39;s far better to extend what exists than create something new; but extension means you are limited by choices made in the past.</p><p>Could we actually build this? I suspect not. No one has done it because, quite honestly, there is no money in it.  And without money there simply aren&#39;t enough resources to build it. </p><p>However, if somehow we figured out a team to build it, or at least decided to make a runnable prototype, I would start by targeting hardware with a fixed known set of hardware and existing device drivers.  Driver support has always been the downfall of desktop Linux. A Raspberry Pi 3 would be an excellent choice.</p><p>So now my question to you is: do you think this idea is worth pursuing, at least to the runnable prototype stage? Would you contribute to such a project? What would need to already be working before you&#39;d be willing to test it out.  And of course, what should we call it?</p><p>If you are interested in joining the discussion about the future of desktop UX, please sign up to our new group <a href="https://groups.google.com/forum/#!forum/idealos-design">Ideal OS Design</a>.</p><p>Thanks, Josh</p></div></div>
  </body>
</html>
