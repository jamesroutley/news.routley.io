<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://remusao.github.io/posts/python-dbm-module.html">Original</a>
    <h1>TIL–Python has a built-in persistent key-value store (2018)</h1>
    
    <div id="readability-page-1" class="page"><article><div><p>Python is, in a lot of ways, a very rich language. After years of using it, I still regularly discover new parts of the ecosystem, even in the standard library. In particular, there are a few modules which are not very well-known, but can be very useful in some situations. Today I discovered <code>dbm</code> a persistent key/value store:</p><p>Quick start:</p><pre data-lang="python"><code><span>import</span> dbm

<span>with</span> dbm.<span>open</span>(<span>&#39;my_store&#39;</span>, <span>&#39;c&#39;</span>) <span>as</span> db:
  db[<span>&#39;key&#39;</span>] = <span>&#39;value&#39;</span>
  <span>print</span>(db.keys()) 
  <span>print</span>(db[<span>&#39;key&#39;</span>]) 
  <span>print</span>(<span>&#39;key&#39;</span> <span>in</span> db) 
</code></pre><p>It behaves a lot like a <code>dict</code> except:</p><ul><li>It persists its values on disk</li><li>You can only use <code>str</code> or <code>bytes</code> as key and values</li></ul><p>The performance is also slower than a dictionary, but faster than <code>sqlite3</code>.</p><p>The benchmark consists in performing <em>10k</em> writes and <em>10k</em> random reads:</p><pre data-lang="python"><code><span>from</span> random <span>import</span> random
<span>import</span> time

operations = <span>10000</span>
writes = [<span>str</span>(i) <span>for</span> i <span>in</span> <span>range</span>(operations)]
reads = [<span>str</span>(<span>int</span>(random() * operations)) <span>for</span> _ <span>in</span> <span>range</span>(operations)]


<span>for</span> i <span>in</span> writes:
    db[i] = <span>&#39;x&#39;</span>


<span>for</span> i <span>in</span> reads:
    x = db[i]
</code></pre><p>Here are the results:</p><ul><li><code>dict</code> – total: <em>0.002 seconds</em>, 0.23398 μs/record <strong>x 1</strong></li><li><code>dbm</code> – total: 0.054 seconds, 5.35984 μs/record <strong>x 27</strong></li><li><code>sqlite3</code> in-memory: total: 2.468 seconds, 246.84346 μs/record <strong>x 1234</strong></li><li><code>sqlite3</code> file: total 42.407 seconds, 4240.69593 μs/record <strong>x 21207</strong></li></ul><p>Why is <code>sqlite3</code> so slow? Well, the benchmark is probably not representative of the typical workload for sqlite (lots of individual insertions and selections). If we perform the same operations using <code>executemany</code> and one <code>select</code> of all the keys at once, we get:</p><ul><li><code>:memory:</code> – total: 0.038 seconds, 3.81415 μs/record <strong>x 19</strong></li><li><code>file</code> – total 0.071 seconds, 7.07369 μs/record <strong>x 35</strong></li></ul><p>It’s much better, but still not as fast as <code>dbm</code> (when we persist to a file). So, if you have a workload where keys and values are added and retrieved very often, are always <code>str</code> or <code>bytes</code> and need to be persisted on disk, <code>dbm</code> is a serious contender!</p><p><em>The code used to benchmark can be found here: <a href="https://remusao.github.io/snippets/dbm_bench.py" target="_blank" rel="noopener noreferrer">dbm_bench.py</a></em></p></div></article></div>
  </body>
</html>
