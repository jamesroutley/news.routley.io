<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://viruta.org/reducing-binary-size-generics.html">Original</a>
    <h1>Reducing code size in librsvg by removing an unnecessary generic struct</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Someone mentioned <a href="https://github.com/RazrFalcon/cargo-bloat">cargo-bloat</a> the other day and it
reminded me that I have been wanting to measure the code size for
generic functions in librsvg, and see if there are improvements to be
made.</p>
<p>Cargo-bloat can give you a rough estimate of the code size for each
Rust crate in a compiled binary, and also a more detailed view of the
amount of code generated for individual functions.  It needs a <code>[bin]</code>
target to work on; if you have just a <code>[lib]</code>, it will not do
anything.  So, for librsvg&#39;s purposes, I ran cargo-bloat on the
<code>rsvg-convert</code> binary.</p>
<div><pre><span></span><code><span>$</span><span> </span><span>cargo</span><span> </span><span>bloat</span><span> </span><span>--</span><span>release</span><span> </span><span>--</span><span>crates</span>
<span>    </span><span>Finished</span><span> </span><span>release</span><span> </span><span>[</span><span>optimized</span><span>]</span><span> </span><span>target</span><span>(</span><span>s</span><span>)</span><span> </span><span>in</span><span> </span><span>0.23</span><span>s</span>
<span>    </span><span>Analyzing</span><span> </span><span>target</span><span>/</span><span>release</span><span>/</span><span>rsvg</span><span>-</span><span>bench</span>

<span> </span><span>File</span><span>  </span><span>.</span><span>text</span><span>     </span><span>Size</span><span> </span><span>Crate</span>
<span>10.0</span><span>%</span><span>  </span><span>38.7</span><span>%</span><span>   </span><span>1.0</span><span>MiB</span><span> </span><span>librsvg</span>
<span> </span><span>4.8</span><span>%</span><span>  </span><span>18.8</span><span>%</span><span> </span><span>505.5</span><span>KiB</span><span> </span><span>std</span>
<span> </span><span>2.5</span><span>%</span><span>   </span><span>9.8</span><span>%</span><span> </span><span>262.8</span><span>KiB</span><span> </span><span>clap</span>
<span> </span><span>1.8</span><span>%</span><span>   </span><span>7.1</span><span>%</span><span> </span><span>191.3</span><span>KiB</span><span> </span><span>regex</span>
<span> </span><span>...</span><span> </span><span>lines</span><span> </span><span>omitted</span><span> </span><span>...</span>
<span>25.8</span><span>%</span><span> </span><span>100.0</span><span>%</span><span>   </span><span>2.6</span><span>MiB</span><span> </span><span>.</span><span>text</span><span> </span><span>section</span><span> </span><span>size</span><span>,</span><span> </span><span>the</span><span> </span><span>file</span><span> </span><span>size</span><span> </span><span>is</span><span> </span><span>10.2</span><span>MiB</span>

<span>Note</span><span>:</span><span> </span><span>numbers</span><span> </span><span>above</span><span> </span><span>are</span><span> </span><span>a</span><span> </span><span>result</span><span> </span><span>of</span><span> </span><span>guesswork</span><span>.</span><span> </span><span>They</span><span> </span><span>are</span><span> </span><span>not</span><span> </span><span>100</span><span>%</span><span> </span><span>correct</span><span> </span><span>and</span><span> </span><span>never</span><span> </span><span>will</span><span> </span><span>be</span><span>.</span>
</code></pre></div>

<p>The output above is for <code>cargo bloat --release --crates</code>.  The
<code>--release</code> option is to generate an optimized binary, and <code>--crates</code>
tells cargo-bloat to just print a summary of crate sizes.  The numbers
are not completely accurate since, for example, inlined functions may
affect callers of a particular crate.  Still, this is good enough to
start getting an idea of the sizes of things.</p>
<p>In this case, the librsvg crate&#39;s code is about 1.0 MB.</p>
<p>Now, let&#39;s find what generic functions we may be able to condense.
When cargo-bloat is run without <code>--crates</code>, it prints the size of
individual functions.  After some experimentation, I ended up with
<code>cargo bloat --release -n 0 --filter librsvg</code>.  The <code>-n 0</code> option
tells cargo-bloat to print all functions, not just the top N biggest
ones, and <code>--filter librsvg</code> is to make it print functions only in
that crate, not for example in <code>std</code> or <code>regex</code>.</p>
<div><pre><span></span><code>$<span> </span>cargo<span> </span>bloat<span> </span>--release<span> </span>-n<span> </span><span>0</span><span> </span>--filter<span> </span>librsvg

File<span> </span>.text<span>    </span>Size<span>   </span>Crate<span> </span>Name
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>  </span><span>1</span>.2KiB<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::new
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>  </span><span>1</span>.2KiB<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::new
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>  </span><span>1</span>.2KiB<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::new
...<span> </span>output<span> </span>omitted<span> </span>...
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>    </span>825B<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::set_style_attribute
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>    </span>825B<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::set_style_attribute
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>    </span>825B<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::set_style_attribute
...<span> </span>output<span> </span>omitted<span> </span>...
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>    </span>358B<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::get_cond
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>    </span>358B<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::get_cond
<span>0</span>.0%<span>  </span><span>0</span>.0%<span>    </span>358B<span> </span>librsvg<span> </span>librsvg::element::ElementInner&lt;T&gt;::get_cond
...<span> </span>etc<span> </span>...
</code></pre></div>

<p>After looking a bit at the output, I found the &#34;duplicated&#34; functions
I wanted to find.  What is happening here is that <code>ElementInner&lt;T&gt;</code> is
a type with generics, and rustc is generating one copy of each of its
methods for every type instance.  So, there is one copy of each method
for <code>ElementInner&lt;Circle&gt;</code>, one for <code>ElementInner&lt;Rect&gt;</code>, and so on
for all the SVG element types.</p>
<p>The code around that is a bit convoluted; it&#39;s in a part of the
library that hasn&#39;t gotten much cleanup after the C to Rust port and
initial refactoring.  Let&#39;s see what it is like.</p>
<h2>The initial code</h2>
<p>Librsvg parses the XML in an SVG document and builds something that
resembles a DOM tree.  The tree itself uses the <a href="https://github.com/RazrFalcon/rctree/"><code>rctree</code>
crate</a>; it has reference-counted nodes and functions like
<code>first_child</code> or <code>next_sibling</code>.  Nodes can represent XML elements, or
character content inside XML tags.  Here we are interested in elements
only.</p>
<p>Consider an element like this:</p>
<div><pre><span></span><code><span>&lt;path</span><span> </span><span>d=</span><span>&#34;M0,0 L10,10 L0,10 Z&#34;</span><span> </span><span>fill=</span><span>&#34;black&#34;</span><span>/&gt;</span>
</code></pre></div>

<p>Let&#39;s look at how librsvg represents that.  Inside each
reference-counted node in an <code>rctree</code>, librsvg keeps a <code>NodeData</code> enum
that can differentiate between elements and character content:</p>
<div><pre><span></span><code><span>enum</span> <span>NodeData</span><span> </span><span>{</span>
<span>    </span><span>Element</span><span>(</span><span>Element</span><span>),</span>
<span>    </span><span>Text</span><span>(</span><span>Chars</span><span>),</span>
<span>}</span>
</code></pre></div>

<p>Then, <code>Element</code> is an enum that can distinguish between all the
elements in the <code>svg</code> namespace that librsvg supports:</p>
<div><pre><span></span><code><span>enum</span> <span>Element</span><span> </span><span>{</span>
<span>    </span><span>Circle</span><span>(</span><span>Box</span><span>&lt;</span><span>ElementInner</span><span>&lt;</span><span>Circle</span><span>&gt;&gt;</span><span>),</span>
<span>    </span><span>Ellipse</span><span>(</span><span>Box</span><span>&lt;</span><span>ElementInner</span><span>&lt;</span><span>Ellipse</span><span>&gt;&gt;</span><span>),</span>
<span>    </span><span>Path</span><span>(</span><span>Box</span><span>&lt;</span><span>ElementInner</span><span>&lt;</span><span>Path</span><span>&gt;&gt;</span><span>),</span>
<span>    </span><span>// ... about 50 others omitted ...</span>
<span>}</span>
</code></pre></div>

<p>Inside each of those enum&#39;s variants there is an <code>ElementInner&lt;T&gt;</code>, a
struct with a generic type parameter.  <code>ElementInner</code> holds the data
for the DOM-like element:</p>
<div><pre><span></span><code><span>struct</span> <span>ElementInner</span><span>&lt;</span><span>T</span>: <span>ElementTrait</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>element_name</span>: <span>QualName</span><span>,</span>
<span>    </span><span>attributes</span>: <span>Attributes</span><span>,</span>
<span>    </span><span>// ... other fields omitted</span>
<span>    </span><span>element_impl</span>: <span>T</span><span>,</span>
<span>}</span>
</code></pre></div>

<p>For the <code>&lt;path&gt;</code> element above, this struct would contain the following:</p>
<ul>
<li><code>element_name</code>: a qualified name <code>path</code> with an <code>svg</code> namespace.</li>
<li><code>attributes</code>: an array of <code>(name, value)</code> pairs, in this case <code>(d, &#34;M0,0 L10,10 L0,10 Z&#34;)</code>,
  <code>(fill, &#34;black&#34;)</code>.</li>
<li><code>element_impl</code>: A concrete type, <code>Path</code> in this case.</li>
</ul>
<p>The specifics of the <code>Path</code> type are not terribly interesting here;
it&#39;s just the <a href="https://viruta.org/reducing-memory-consumption-in-librsvg-4.html">internal representation for Bézier paths</a>.</p>
<div><pre><span></span><code><span>struct</span> <span>Path</span><span> </span><span>{</span>
<span>    </span><span>path</span>: <span>Rc</span><span>&lt;</span><span>SvgPath</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div>

<p>Let&#39;s look at the details of the memory layout for all of this.</p>
<h3>Initial memory layout</h3>
<p>Here is how the enums and structs above are laid out in memory, in
terms of allocations, without taking into account the <code>rctree:Node</code>
that wraps a <code>NodeData</code>.</p>
<p><img alt="NodeData enum, and ElementInner&lt;T&gt; (description in text)" src="https://viruta.org/images/generics-layout-before.svg"/></p>
<p>There is one allocated block for the <code>NodeData</code> enum, and that block
holds the enum&#39;s discriminant and the embedded <code>Element</code> enum.  In
turn, the <code>Element</code> enum has its own discriminant and space for a
<code>Box</code> (i.e. a pointer), since each of its variants just holds a single
box.</p>
<p>That box points to an allocation for an <code>ElementInner&lt;T&gt;</code>, which itself
contains a <code>Path</code> struct.</p>
<p>It is awkward that the fields to hold XML-isms like an element&#39;s name
and its attributes are in <code>ElementInner&lt;T&gt;</code>, not in <code>Element</code>.  But
more importantly, <code>ElementInner&lt;T&gt;</code> has a little bunch of methods:</p>
<div><pre><span></span><code><span>impl</span><span>&lt;</span><span>T</span>: <span>ElementTrait</span><span>&gt;</span><span> </span><span>ElementInner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>fn</span> <span>new</span><span>(</span><span>..</span><span>.)</span><span> </span>-&gt; <span>ElementInner</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span>
<span>        </span><span>// lots of construction</span>
<span>    </span><span>}</span>

<span>    </span><span>fn</span> <span>element_name</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>QualName</span><span> </span><span>{</span>
<span>        </span><span>..</span><span>.</span>
<span>    </span><span>}</span>

<span>    </span><span>fn</span> <span>get_attributes</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>Attributes</span><span> </span><span>{</span>
<span>        </span><span>..</span><span>.</span>
<span>    </span><span>}</span>

<span>    </span><span>// A bunch of other methods</span>
<span>}</span>
</code></pre></div>

<p>However, none but one of these methods actually use the <code>element_impl: T</code>
field!  That is, all of them do things that are common to all
element types.  The only method that really deals with the
<code>element_impl</code> field is the <code>::draw()</code> method, and the only thing it
does is to delegate down to the concrete type&#39;s implementation of
<code>::draw()</code>.</p>
<h3>Removing that generic type</h3>
<p>So, let&#39;s shuffle things around.  I did this:</p>
<ul>
<li>
<p>Turn <code>enum Element</code> into a <code>struct Element</code>, with the fields common to all element types.</p>
</li>
<li>
<p>Have an <code>Element.element_data</code> field...</p>
</li>
<li>
<p>... that is of type <code>ElementData</code>, an enum that actually knows about
  all supported element types.</p>
</li>
</ul>
<p>There are no types with generics in here:</p>
<div><pre><span></span><code><span>struct</span> <span>Element</span><span> </span><span>{</span>
<span>    </span><span>element_name</span>: <span>QualName</span><span>,</span>
<span>    </span><span>attributes</span>: <span>Attributes</span><span>,</span>
<span>    </span><span>// ... other fields omitted</span>
<span>    </span><span>element_data</span>: <span>ElementData</span><span>,</span>
<span>}</span>

<span>enum</span> <span>ElementData</span><span> </span><span>{</span>
<span>    </span><span>Circle</span><span>(</span><span>Box</span><span>&lt;</span><span>Circle</span><span>&gt;</span><span>),</span>
<span>    </span><span>Ellipse</span><span>(</span><span>Box</span><span>&lt;</span><span>Ellipse</span><span>&gt;</span><span>),</span>
<span>    </span><span>Path</span><span>(</span><span>Box</span><span>&lt;</span><span>Path</span><span>&gt;</span><span>),</span>
<span>    </span><span>// ...</span>
<span>}</span>
</code></pre></div>

<p>Now the memory layout looks like this:</p>
<p><img alt="NodeData enum with boxes, Element, and ElementData (description in text)" src="https://viruta.org/images/generics-layout-after.svg"/></p>
<p>One extra allocation, but let&#39;s see if this changes the code size.</p>
<h2>Code size</h2>
<p>We want to know the size of the <code>.text</code> section in the ELF file.</p>
<div><pre><span></span><code># old
$ objdump --section-headers ./target/release/rsvg-bench
Idx Name          Size      VMA               LMA               File off  Algn
 15 .text         0029fa17  000000000008a060  000000000008a060  0008a060  2**4
(2750999 bytes)

# new
Idx Name          Size      VMA               LMA               File off  Algn
 15 .text         00271ff7  000000000008b060  000000000008b060  0008b060  2**4
(2564087 bytes)
</code></pre></div>

<p>The new code is is 186912 bytes smaller.  Not earth-shattering, but
cargo-bloat no longer shows duplicated functions which have no reason
to be monomorphized, since they don&#39;t touch the varying data.</p>
<p>old:</p>
<div><pre><span></span><code>$<span> </span>cargo<span> </span>bloat<span> </span>--release<span> </span>--crates
<span> </span>File<span>  </span>.text<span>     </span>Size<span> </span>Crate
<span>10</span>.0%<span>  </span><span>38</span>.7%<span>   </span><span>1</span>.0MiB<span> </span>librsvg
<span># lines omitted</span>
<span>25</span>.8%<span> </span><span>100</span>.0%<span>   </span><span>2</span>.6MiB<span> </span>.text<span> </span>section<span> </span>size,<span> </span>the<span> </span>file<span> </span>size<span> </span>is<span> </span><span>10</span>.2MiB
</code></pre></div>

<p>new:</p>
<div><pre><span></span><code>$<span> </span>cargo<span> </span>bloat<span> </span>--release<span> </span>--crates
<span> </span>File<span>  </span>.text<span>     </span>Size<span> </span>Crate
<span> </span><span>9</span>.2%<span>  </span><span>37</span>.5%<span> </span><span>939</span>.5KiB<span> </span>librsvg
<span>24</span>.6%<span> </span><span>100</span>.0%<span>   </span><span>2</span>.4MiB<span> </span>.text<span> </span>section<span> </span>size,<span> </span>the<span> </span>file<span> </span>size<span> </span>is<span> </span><span>10</span>.0MiB
</code></pre></div>

<p>Less code should help a bit with cache locality, but the functions
involved are not in hot loops.  Practically all of librsvg&#39;s time is
spent in Cairo for rasterization, and Pixman for compositing.</p>
<h2>Dynamic dispatch</h2>
<p>All the concrete types (<code>Circle</code>, <code>ClipPath</code>, etc.) implement
<code>ElementTrait</code>, which has things like a <code>draw()</code> method, although that
is not visible in the types above.  This is what is most convenient
for librsvg; using <code>Box&lt;ElementTrait&gt;</code> for type erasure would be a little
awkward there — we used it a long time ago, but not anymore.</p>
<p>Eventually the code needs to find the <code>ElementTrait</code> vtable that
corresponds to each of <code>ElementData</code>&#39;s variants:</p>
<div><pre><span></span><code><span>let</span><span> </span><span>data</span>: <span>&amp;</span><span>dyn</span><span> </span><span>ElementTrait</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span>
<span>    </span><span>ElementData</span>::<span>Circle</span><span>(</span><span>d</span><span>)</span><span> </span><span>=&gt;</span><span>   </span><span>&amp;**</span><span>d</span><span>,</span>
<span>    </span><span>ElementData</span>::<span>ClipPath</span><span>(</span><span>d</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>&amp;**</span><span>d</span><span>,</span>
<span>    </span><span>ElementData</span>::<span>Ellipse</span><span>(</span><span>d</span><span>)</span><span> </span><span>=&gt;</span><span>  </span><span>&amp;**</span><span>d</span><span>,</span>
<span>    </span><span>// ...</span>
<span>};</span>

<span>data</span><span>.</span><span>some_method_in_the_trait</span><span>(</span><span>..</span><span>.);</span>
</code></pre></div>

<p>The ugly <code>&amp;**d</code> is to arrive at the <code>&amp;dyn ElementTrait</code> that each
variant implements.  It will get less ugly when <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/box-patterns.html">pattern matching for
boxes</a>
gets stabilized in the Rust compiler.</p>
<p><strong>This is not the only way of doing things.</strong>  For librsvg it is
convenient to actually know the type of an element, that is, to keep
an <code>enum</code> of the known element types.  Other kinds of code may be
perfectly happy with the type erasure that happens when you have a
<code>Box&lt;SomeTrait&gt;</code>.  If that code needs to go back to the concrete type,
an alternative is to use something like the
<a href="https://crates.io/crates/downcast-rs">downcast-rs</a> crate, which lets
you recover the concrete type inside the box.</p>
<h2>Heap usage actually changed</h2>
<p>You may notice in the diagrams below that the original <code>NodeData</code>
didn&#39;t box its variants, but now it does.</p>
<p>Old:</p>
<div><pre><span></span><code><span>enum</span> <span>NodeData</span><span> </span><span>{</span>
<span>    </span><span>Element</span><span>(</span><span>Element</span><span>),</span>
<span>    </span><span>Text</span><span>(</span><span>Chars</span><span>),</span>
<span>}</span>
</code></pre></div>

<p>New:</p>
<div><pre><span></span><code><span>enum</span> <span>NodeData</span><span> </span><span>{</span>
<span>    </span><span>Element</span><span>(</span><span>Box</span><span>&lt;</span><span>Element</span><span>&gt;</span><span>),</span>
<span>    </span><span>Text</span><span>(</span><span>Box</span><span>&lt;</span><span>Chars</span><span>&gt;</span><span>),</span>
<span>}</span>
</code></pre></div>

<p>One thing I didn&#39;t notice during <a href="https://viruta.org/reducing-memory-consumption-in-librsvg-1.html">the first round of memory
reduction</a> is that the <code>NodeData::Text(Chars)</code> variant is not
boxed.  That is, the size of <code>NodeData</code> enum is the size of the
biggest of <code>Element</code> and <code>Chars</code>, plus space for the enum&#39;s
discriminant.  I wanted to make both variants the same size, and by
boxing them they occupy only a pointer each.</p>
<p>I measured heap usage for a <a href="https://en.wikipedia.org/wiki/File:India_roadway_map.svg">reasonably large SVG</a>:</p>
<p><img alt="India Roadway Map, from Wikimedia Commons" src="https://viruta.org/images/India_roadway_map.png"/></p>
<p>I used <a href="https://valgrind.org/docs/manual/ms-manual.html">Valgrind&#39;s Massif</a> to measure peak memory consumption during loading:</p>
<div><pre><span></span><code><span>valgrind</span><span> </span><span>--</span><span>tool</span><span>=</span><span>massif</span><span> </span><span>--</span><span>massif</span><span>-</span><span>out</span><span>-</span><span>file</span><span>=</span><span>massif</span><span>.</span><span>out</span><span> </span><span>./</span><span>target</span><span>/</span><span>release</span><span>/</span><span>rsvg</span><span>-</span><span>bench</span><span> </span><span>--</span><span>num</span><span>-</span><span>load</span><span> </span><span>1</span><span> </span><span>--</span><span>num</span><span>-</span><span>render</span><span> </span><span>0</span><span> </span><span>India_roadway_map</span><span>.</span><span>svg</span>
<span>ms_print</span><span> </span><span>massif</span><span>.</span><span>out</span>
</code></pre></div>

<p>The first thing that <code>ms_print</code> shows is an overview of the program&#39;s
memory usage over time, and the list of snapshots it created.  The following is an extract of its output for the <em>new</em> version of the code, where snapshot 36 is the one with peak memory usage:</p>
<div><pre><span></span><code><span>MB</span>
<span>14.22</span><span>^</span><span>                                                                      </span><span>:</span><span> </span>
<span>     </span><span>|</span><span>                                                </span><span>@#</span><span>:::::::::::::::::::::</span><span> </span>
<span>     </span><span>|</span><span>                                              </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                            </span><span>@@@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                          </span><span>@@@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                        </span><span>@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                       </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                    </span><span>@@@@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                  </span><span>@@@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span> </span>
<span>     </span><span>|</span><span>                                 </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>:::</span>
<span>     </span><span>|</span><span>                               </span><span>@@@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>:::</span>
<span>     </span><span>|</span><span>                              </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>:::</span>
<span>     </span><span>|</span><span>                             </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>:::</span>
<span>     </span><span>|</span><span>                          </span><span>@@@@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>:::</span>
<span>     </span><span>|</span><span>                        </span><span>:</span><span>@@@</span><span> </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span>@</span>
<span>     </span><span>|</span><span>                     </span><span>@@@</span><span>:</span><span>@@@</span><span> </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span>@</span>
<span>     </span><span>|</span><span>                 </span><span>@@@@@</span><span> </span><span>@</span><span>:</span><span>@@@</span><span> </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span>@</span>
<span>     </span><span>|</span><span>              </span><span>:::</span><span>@</span><span> </span><span>@</span><span> </span><span>@</span><span> </span><span>@</span><span>:</span><span>@@@</span><span> </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span>@</span>
<span>     </span><span>|</span><span>            </span><span>:</span><span>@</span><span>::</span><span> </span><span>@</span><span> </span><span>@</span><span> </span><span>@</span><span> </span><span>@</span><span>:</span><span>@@@</span><span> </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span>@</span>
<span>     </span><span>|</span><span>     </span><span>@@@@</span><span>::::</span><span>@</span><span>::</span><span> </span><span>@</span><span> </span><span>@</span><span> </span><span>@</span><span> </span><span>@</span><span>:</span><span>@@@</span><span> </span><span>@@@</span><span> </span><span>@@</span><span> </span><span>@@</span><span> </span><span>@@@@</span><span> </span><span>@</span><span> </span><span>@@@#</span><span>:</span><span>      </span><span>::::</span><span> </span><span>::</span><span> </span><span>:::</span><span> </span><span>::</span><span>@</span>
<span>   </span><span>0</span><span> </span><span>+-----------------------------------------------------------------------&gt;</span><span>Mi</span>
<span>     </span><span>0</span><span>                                                                   </span><span>380.9</span>

<span>Number</span><span> </span><span>of</span><span> </span><span>snapshots</span><span>:</span><span> </span><span>51</span>
<span> </span><span>Detailed</span><span> </span><span>snapshots</span><span>:</span><span> </span><span>[</span><span>3</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>9</span><span>,</span><span> </span><span>12</span><span>,</span><span> </span><span>13</span><span>,</span><span> </span><span>14</span><span>,</span><span> </span><span>15</span><span>,</span><span> </span><span>16</span><span>,</span><span> </span><span>18</span><span>,</span><span> </span><span>19</span><span>,</span><span> </span><span>20</span><span>,</span><span> </span><span>21</span><span>,</span><span> </span><span>22</span><span>,</span><span> </span><span>23</span><span>,</span><span> </span><span>24</span><span>,</span><span> </span><span>25</span><span>,</span><span> </span><span>26</span><span>,</span><span> </span><span>27</span><span>,</span><span> </span><span>28</span><span>,</span><span> </span><span>29</span><span>,</span><span> </span><span>30</span><span>,</span><span> </span><span>31</span><span>,</span><span> </span><span>32</span><span>,</span><span> </span><span>33</span><span>,</span><span> </span><span>34</span><span>,</span><span> </span><span>35</span><span>,</span><span> </span><span>36</span><span> </span><span>(</span><span>peak</span><span>),</span><span> </span><span>50</span><span>]</span>
</code></pre></div>

<p>Since we are just measuring memory consumption during <strong>loading</strong>, the
chart shows that memory usage climbs steadily until it peaks when the
complete SVG is loaded, and then it stays more or less constant while
librsvg does the initial CSS cascade.</p>
<p>The version of librsvg without changes shows this (note how the massif
snapshot with peak usage is number 39 in this one):</p>
<div><pre><span></span><code><span>--------------------------------------------------------------------------------</span>
<span>  n        time(i)         total(B)   useful</span><span>-</span><span>heap(B) extra</span><span>-</span><span>heap(B)    stacks(B)</span>
<span>--------------------------------------------------------------------------------</span>
<span> 39    277</span><span>,</span><span>635</span><span>,</span><span>004       15</span><span>,</span><span>090</span><span>,</span><span>640       14</span><span>,</span><span>174</span><span>,</span><span>848       915</span><span>,</span><span>792            0</span>
</code></pre></div>

<p>That is, 15,090,640 bytes.</p>
<p>And after making the changes in memory layout, we get this:</p>
<div><pre><span></span><code><span>--------------------------------------------------------------------------------</span>
<span>  n        time(i)         total(B)   useful</span><span>-</span><span>heap(B) extra</span><span>-</span><span>heap(B)    stacks(B)</span>
<span>--------------------------------------------------------------------------------</span>
<span> 36    276</span><span>,</span><span>041</span><span>,</span><span>810       14</span><span>,</span><span>845</span><span>,</span><span>456       13</span><span>,</span><span>935</span><span>,</span><span>702       909</span><span>,</span><span>754            0</span>
</code></pre></div>

<p>I.e. after the changes, the peak usage of heap memory when the whole
file is loaded is 14,845,456 bytes.  So the changes above not only
reduced the code size, but also slightly lowered memory consumption at runtime.
Nice!</p>
<h2>Wall-clock performance</h2>
<p>This file is not huge — say, 15 MB when loaded — so whatever we gained
in memory consumption is a negligible win.  It&#39;s nice to know that
code size can be reduced, but it is not a problem for librsvg either
way.</p>
<p>I did several measurements of the time used by the old and new
versions to render the same file, and there was no significant
difference.  This is because although we may get better cache locality
and everything, <strong>the time spent executing the element-related code is
much smaller than the rendering code</strong>.  That is, Cairo takes up most
of the runtime of <code>rsvg-convert</code>, and librsvg itself takes relatively
little of it.</p>
<h2>Conclusion</h2>
<p>At least for this case, it was feasible to reduce the amount of code
emitted for generics, since this is a case where we definitely didn&#39;t
need generics!  The code size in the ELF file&#39;s <code>.text</code> section shrank
by 186912 bytes, out of 2.6 MB.</p>
<p>For code that <em>does</em> need generics, one can take different approaches.
For example, a function that take arguments of type <code>AsRef&lt;Path&gt;</code> can
first actually obtain the <code>&amp;Path</code>, and then pass that to a function
that does the real work.  For example, from the standard library:</p>
<div><pre><span></span><code><span>impl</span><span> </span><span>PathBuf</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>push</span><span>&lt;</span><span>P</span>: <span>AsRef</span><span>&lt;</span><span>Path</span><span>&gt;&gt;</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>path</span>: <span>P</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>self</span><span>.</span><span>_push</span><span>(</span><span>path</span><span>.</span><span>as_ref</span><span>())</span>
<span>    </span><span>}</span>

<span>    </span><span>fn</span> <span>_push</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>path</span>: <span>&amp;</span><span>Path</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>// lots of code here</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>The <code>push</code> function will be monomorphized into very tiny functions
that call <code>_push</code> after converting what you passed to a <code>&amp;Path</code>
reference, but the big <code>_push</code> function is only emitted once.</p>
<p>There is also the <a href="https://github.com/llogiq/momo/">momo crate</a>, which helps doing similar things
automatically.  I have not used it yet, so I can&#39;t comment further on
it.</p>
<p>You can see the patches for librsvg <a href="https://gitlab.gnome.org/GNOME/librsvg/-/merge_requests/801">in the merge request</a>.</p>
  </div></div>
  </body>
</html>
