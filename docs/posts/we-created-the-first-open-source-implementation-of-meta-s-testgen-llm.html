<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.codium.ai/blog/we-created-the-first-open-source-implementation-of-metas-testgen-llm/">Original</a>
    <h1>We created the first open source implementation of Meta&#39;s TestGen–LLM</h1>
    
    <div id="readability-page-1" class="page"><article>
<p><img width="690" height="553" src="https://www.codium.ai/wp-content/uploads/2024/05/img-ci-agent-1-690x553.jpg" alt="" decoding="async" fetchpriority="high" srcset="https://www.codium.ai/wp-content/uploads/2024/05/img-ci-agent-1-690x553.jpg 690w, https://www.codium.ai/wp-content/uploads/2024/05/img-ci-agent-1-300x240.jpg 300w, https://www.codium.ai/wp-content/uploads/2024/05/img-ci-agent-1-768x615.jpg 768w, https://www.codium.ai/wp-content/uploads/2024/05/img-ci-agent-1.jpg 924w" sizes="(max-width: 690px) 100vw, 690px"/> </p>
<p>In February, Meta researchers published a paper titled <a href="https://arxiv.org/abs/2402.09171" target="_blank" rel="noopener">Automated Unit Test Improvement using Large Language Models at Meta</a>, which introduces a tool they called TestGen-LLM. The fully automated approach to increasing test coverage “with guaranteed assurances for improvement over the existing code base” <a href="https://news.ycombinator.com/item?id=39486717" target="_blank" rel="noopener">created waves</a> in the software engineering world.</p>
<p>Meta didn’t release the TestGen-LLM code, so we decided to implement it as part of our <a href="https://github.com/Codium-ai/cover-agent" target="_blank" rel="noopener">Cover-Agent</a> open-source and we’re releasing it today!</p>
<p>I’ll share some information here on how we went about implementing it, share some of our findings and outline the challenges we encountered when actually using TestGen-LLM with real-world codebases.</p>
<h2>Automated Test Generation: Baseline Criteria</h2>
<p>Automated test generation using Generative AI is nothing new. Most LLMs that are competent at generating code, such as ChatGPT, Gemini, and Code Llama, are capable of generating tests. The most common pitfall that developers run into when generating tests with LLMs is that most generated tests don’t even work and many don’t add value (e.g. they test the same functionality already covered by other tests).</p>
<p>To overcome this challenge (specifically, for regression unit tests) the TestGen-LLM authors came up with the following criteria:</p>
<ol>
<li>Does the test compile and run properly?</li>
<li>Does the test increase code coverage?</li>
</ol>
<p>Without answering these two fundamental questions, arguably, there’s no point in accepting or analyzing the generated test provided to us by the LLM.</p>
<ol>
<li>How well is the test written?</li>
<li>How much value does it actually add? (We all know that sometimes Code Coverage could be a proxy or even vanity metric)</li>
<li>Does it meet any additional requirements that we may have?</li>
</ol>
<h2>Approach and reported results</h2>
<p>TestGen-LLM (and Cover-Agent) run completely headless (well, kind of; we will discuss this later).</p>
<figure id="attachment_6831" aria-describedby="caption-attachment-6831"><img decoding="async" src="https://www.codium.ai/wp-content/uploads/2024/05/img-testgen-llm-paper.jpg" alt="TestGen-LLM paper" width="750" srcset="https://www.codium.ai/wp-content/uploads/2024/05/img-testgen-llm-paper.jpg 750w, https://www.codium.ai/wp-content/uploads/2024/05/img-testgen-llm-paper-300x81.jpg 300w, https://www.codium.ai/wp-content/uploads/2024/05/img-testgen-llm-paper-690x186.jpg 690w" sizes="(max-width: 750px) 100vw, 750px"/><figcaption id="caption-attachment-6831">From TestGen-LLM paper</figcaption></figure>
<p>First, TestGen-LLM generates a bunch of tests, then it filters out those that don’t build/run and drops any that don’t pass, and finally, it discards those that don’t increase the code coverage. In highly controlled cases, the ratio of generated tests to those that pass all of the steps is 1:4, and in real-world scenarios, Meta’s authors report a 1:20 ratio.</p>
<p>Following the automated process, Meta had a human reviewer accept or reject tests. The authors reported an average acceptance ratio of 1:2, with a 73% acceptance rate in their best reported cases.</p>
<p>It is important to note that the TestGen-LLM tool, as described in the paper, generates on each run a single test that is added to an existing test suite, written previously by a professional developer. Moreover, it doesn’t necessarily generate tests for any given test suite.</p>
<p><strong>From the paper:</strong> “In total, over the three test-a-thons, 196 test classes were successfully improved, while the TestGen-LLM tool was applied to a total of 1,979 test classes. TestGen-LLM was therefore able to automatically improve approximately 10% of the test classes to which it was applied.”</p>
<figure id="attachment_6833" aria-describedby="caption-attachment-6833"><img decoding="async" src="https://www.codium.ai/wp-content/uploads/2024/05/img-cover-agent-flow.jpg" alt="Cover-Agent" width="750" srcset="https://www.codium.ai/wp-content/uploads/2024/05/img-cover-agent-flow.jpg 750w, https://www.codium.ai/wp-content/uploads/2024/05/img-cover-agent-flow-300x162.jpg 300w, https://www.codium.ai/wp-content/uploads/2024/05/img-cover-agent-flow-690x372.jpg 690w" sizes="(max-width: 750px) 100vw, 750px"/><figcaption id="caption-attachment-6833">Cover-Agent v0.1 flow</figcaption></figure>
<p><strong>Cover-Agent v0.1 is implemented as follows:</strong></p>
<ol>
<li>Receive the following user inputs:
<ol>
<li>Source File for code under test</li>
<li>Existing Test Suite to enhance</li>
<li>Coverage Report</li>
<li>The command for building and running test suite</li>
<li>Code coverage target and maximum iterations to run</li>
<li>Additional context and prompting options</li>
</ol>
</li>
<li>Generate more tests in the same style</li>
<li>Validate those tests using your runtime environment
<ol>
<li>Do they build and pass?</li>
</ol>
</li>
<li>Ensure that the tests add value by reviewing metrics such as increased code coverage</li>
<li>Update existing Test Suite and Coverage Report</li>
<li>Repeat until code reaches criteria: either code coverage threshold met, or reached the maximum number of iterations</li>
</ol>
<p><iframe src="https://www.youtube.com/embed/fIYkSEJ4eqE" frameborder="0" scrolling="no" allowfullscreen="allowfullscreen"><span data-mce-type="bookmark" style="display: inline-block; width: 0px; overflow: hidden; line-height: 0;" class="mce_SELRES_start">﻿</span></iframe></p>
<h2>Challenges we encountered when implementing and reviewing TestGen-LLM</h2>
<p>As we worked on putting the TestGen-LLM paper into practice, we ran into some surprising challenges.</p>
<p>The examples presented in the paper mention using <a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a> for writing tests – a language that doesn’t use significant whitespace. With languages like  Python on the other hand, tabs and spaces are not only important but a requirement for the parsing engine. Less sophisticated models, such as GPT 3.5, won’t return code that is consistently indented properly, even when explicitly prompted. An example of where this causes issues is a test class written in Python that requires each test function to be indented. We had to account for this throughout our development lifecycle which added more complexity around pre-processing libraries. There is still plenty to improve on in order to make Cover-Agent robust in scenarios like this.</p>
<figure id="attachment_6832" aria-describedby="caption-attachment-6832"><img decoding="async" src="https://www.codium.ai/wp-content/uploads/2024/05/img-prompt-table.jpg" alt="Prompt Table" width="750" srcset="https://www.codium.ai/wp-content/uploads/2024/05/img-prompt-table.jpg 750w, https://www.codium.ai/wp-content/uploads/2024/05/img-prompt-table-300x104.jpg 300w, https://www.codium.ai/wp-content/uploads/2024/05/img-prompt-table-690x240.jpg 690w" sizes="(max-width: 750px) 100vw, 750px"/><figcaption id="caption-attachment-6832">From TestGen-LLM paper. Original prompts suggested in TestGen-LLM.</figcaption></figure>
<p>After seeing the special test requirements and exceptions we encountered during our trials, we decided to give the user the ability to provide additional input or instructions to prompt the LLM as part of the Cover-Agent flow. The `–additional-instructions` option allows developers to provide any extra information that’s specific to their project, empowering them to customize Cover-Agent. These instructions can be used, for example, to steer Cover-Agent to create a rich set of tests with meaningful edge cases.</p>
<p>Concurring with the general trend of Retrieval-Augmented Generation (RAG) becoming more pervasive in AI based applications, we identified that having more context to go along with unit test generation enables higher quality tests and a higher passing rate. We’ve provided the `–included-files` option to users who want to manually add additional libraries or text-based design documents as context for the LLM to enhance the test generation process.</p>
<p>Complex code that required multiple iterations presented another challenge to the LLMs. As the failed (or non-value added) tests were generated, we started to notice a pattern where the same non-accepted tests were repeatedly suggested in later iterations. To combat this we added a “Failed Tests” section to the prompt to deliver that feedback to the LLM and ensure it generated unique tests and never repeated tests that we deemed unusable (i.e. broken or lack of coverage increase).</p>
<p>Another challenge that came up throughout this process was the inability to add library imports when extending an existing test suite. Developers can sometimes be myopic in their test generation process, only using a single approach to testing frameworks. In addition to many different mocking frameworks, other libraries can help with achieving test coverage. Since the TestGen-LLM paper (and Cover-Agent) are intended to extend existing test suites, the ability to completely restructure the whole test class is out of scope. This is, in my opinion, a limitation of test extension versus test generation and something we plan on addressing in future iterations.</p>
<p>It’s important to make the distinction that in TestGen-LLM’s approach, each test required a manual review from the developer before the next test is suggested. In Cover-Agent on the other hand, we generate, validate, and propose as many tests as possible until achieving the coverage requirement (or stopping at the max iterations), without requiring manual intervention throughout the process. We leverage AI to run in the background, creating an unobtrusive approach to automatic test generation that allows the developer to review the entire test suite once the process has completed.</p>
<h2>Conclusion and what’s next</h2>
<p>While many, including myself, are excited about the TestGen-LLM paper and tool, in this post we have shared its limitations. I believe that we are still in the era of AI assistants and not AI teammates who run fully automated workflows.</p>
<p>At the same time, well-engineered flows, which we plan to develop and share here in <a href="https://github.com/Codium-ai/cover-agent" target="_blank" rel="noopener">Cover-Agent</a>, can help us developers automatically generate test candidates, and increase code coverage in a fraction of the time.</p>
<p>We intend to continue developing and integrating cutting-edge methods related to the test generation domain into the Cover-Agent open-source repo.</p>
<p>In the open-source Cover-Agent repo on GitHub we’ve added a development <a href="https://github.com/Codium-ai/cover-agent" target="_blank" rel="noopener">roadmap</a>. We would love to see you contributing to the repo according to the roadmap or according to your own ideas!</p>
<p>Our vision for Cover-Agent is that in the future it will run automatically for every pre/post-pull request and automatically suggest regression test enhancements that have been validated to work and increase code coverage. We envision that Cover-Agent will automatically scan your codebase, and open PRs with test suites for you.</p>
<p>Let’s leverage AI to help us deal more efficiently with the tasks we don’t like doing!</p>
<p><strong>P.S.</strong></p>
<ol>
<li>We are still looking for a good benchmark for tools like this. Do you know of one? We think it is critical for further development and research.</li>
<li>Check out our <a href="https://twitter.com/talrid23/status/1760351642237477109" target="_blank" rel="noopener">AlphaCodium work</a> for (a) further reading on “Flow Engineering”, as well as an example of (b) a competitive programming benchmark, and (c) a well-designed dataset called CodeContests.</li>
</ol>
</article></div>
  </body>
</html>
