<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yoshuawuyts.com/state-machines-2/">Original</a>
    <h1>State Machines II</h1>
    
    <div id="readability-page-1" class="page"><article>
    <div itemprop="articleBody" id="markdown">
      
      <p>In the past I&#39;ve written about <a href="https://blog.yoshuawuyts.com/state-machines">state machines</a> in Rust. And more recently I&#39;ve
also written about <a href="https://blog.yoshuawuyts.com/more-enum-types/">anonymous enums</a>  in Rust. I&#39;ve been wondering what would
happen if the two interacted? I think the result could actually be quite nice,
and worth daydreaming about. In this post we&#39;ll be discussing state machines,
the language features which could make them easier to use, and ways in which we
could push the ergonomics further.</p>

<h2 id="the-case-for-state-machines">The case for state machines</h2>
<p>A lot of programming is about going from one state to another. We can do that
using conditionals statements, but as the state changes those conditions can be
tricky to reason about and in turn refactor. Instead it&#39;s often more convenient
to use <em>state machines</em>: singular objects which represent all possible states
and their transitions. And in compiled languages specifically to use
<em>compiler-checked state machines</em> .</p>

<p>Say we wanted to implement a basic green-orange-red traffic light that can also
flash. We can imagine the rules for transitions between states could be the
following:</p>
<ol>
<li>
<p>Green can turn to orange</p>
</li>
<li>
<p>Orange can turn to red</p>
</li>
<li>
<p>Red can turn to green</p>
</li>
<li>
<p>Red can turn to flashing red </p>
</li>
<li>
<p>Flashing red can turn to red</p>
</li>

</ol>
<p>All states and their transitions can be represented by the following graph:</p>
<p><img src="https://blog.yoshuawuyts.com/state-machines-2/graph.svg" alt="A graph showing how all states point to each other"/></p>
<p>For the remainder of this post we&#39;ll be implementing the rules of the graph
above. Our goal is to implement a compiler-checked state machine which can
inform us during compilation whether all our state transitions are valid, or if
we&#39;ve accidentally written an invalid transition which we need to fix.</p>
<h2 id="representing-state-machines-in-rust-in-the-future">Representing State Machines in Rust In The Future</h2>
<p>To read about how we can write compiler-checked state machines in Rust <em>today</em> you
can read <a href="https://blog.yoshuawuyts.com/state-machines">my previous post on state machines</a>. In this post I instead want to focus on
✨ the future ✨. How could we plausibly represent this in Rust by extending the
language. In the &#34;future directions&#34; section of the last post we wrote a state
machine without the blinky lights. Using <a href="https://github.com/rust-lang/rfcs/pull/1450">enum variants types</a> (not yet a
thing) combined with <a href="https://github.com/rust-lang/rust/issues/44874">arbitrary self-types</a> (also not
yet a thing), we could write the following:</p>
<pre><span>//! A traffic light without a flashing state.
//! Novel language features: enum-variant-types, arbitrary-self-types

</span><span>enum </span><span>State {
    Green,
    Orange,
    Red,
}

</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Green) -&gt; </span><span>Self::</span><span>Orange {
        </span><span>Self</span><span>::Orange
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Orange) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new(); </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// green
</span><span>}
</span></pre>
<p>What I didn&#39;t realize at the time I wrote my last post is that
this in effect acts like a form of <em>overloading</em>. Functionally the code we&#39;ve
written isn&#39;t different than writing a single <code>next</code> function which internally
updates the state. But instead we expose the state <em>externally</em>. The following
example will be written in valid Rust <em>today</em>, exposing the exact same
functionality as our last example — but with the state only observable
<em>internally</em>:</p>
<pre><span>//! A traffic light without a flashing state.
//! Novel language features: none

</span><span>enum </span><span>State {
    Green,
    Orange,
    Red,
}

</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>) -&gt; </span><span>Self </span><span>{
        </span><span>match </span><span>self </span><span>{
            </span><span>Self</span><span>::Green =&gt; </span><span>Self</span><span>::Orange,
            </span><span>Self</span><span>::Orange =&gt; </span><span>Self</span><span>::Red,
            </span><span>Self</span><span>::Red =&gt; </span><span>Self</span><span>::Green,
        }
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new(); </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// green
</span><span>}
</span></pre>
<p>Let&#39;s continue with the internally observable state examples for a bit. Our
graph shows we need to support a <code>flashing</code> state, so we need to add that.
We need some way to trigger going into a flashing state, so we&#39;ll add a new
method: <code>flash</code>. Not all states can transition into the flashing state, so we
need to make sure we can only go into it from &#34;red&#34; - which means we need to
panic if we attempt to transition into it from any other state:</p>
<pre><span>//! A traffic light with a flashing state.
//! Novel language features: none

</span><span>enum </span><span>State {
    Green,
    Orange,
    Red,
    Flashing,
}

</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>) -&gt; </span><span>Self </span><span>{
        </span><span>match </span><span>self </span><span>{
            </span><span>Self</span><span>::Green =&gt; </span><span>Self</span><span>::Orange,
            </span><span>Self</span><span>::Orange =&gt; </span><span>Self</span><span>::Red,
            </span><span>Self</span><span>::Red =&gt; </span><span>Self</span><span>::Green,
            </span><span>Self</span><span>::Flashing =&gt; </span><span>Self</span><span>::Red,
        }
    }

    </span><span>pub fn </span><span>flash</span><span>(</span><span>self</span><span>) -&gt; </span><span>Self </span><span>{
        </span><span>match </span><span>self </span><span>{
            State::Red =&gt; </span><span>Self</span><span>::Flashing
            _ =&gt; panic!(&#34;</span><span>only red can turn into flashing red</span><span>&#34;),
        }
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new(); </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>    state = state.</span><span>flash</span><span>();        </span><span>// flashing
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>}
</span></pre>
<p>This is not ideal: we now have added a runtime check to a state machine which
was checked entirely during compilation before. The reason a runtime check
is needed is because by adding a method which isn&#39;t available on all types,
the <em>internal</em> state becomes observable <em>externally</em>. And the Rust language
lacks the tools to conveniently represent this .</p>

<p>So let&#39;s try and rewrite this again using enum variant types and arbitrary
self-types. Here the caller knows exactly what state the enum is in, and we can
more precisely represent the states and state transitions:</p>
<pre><span>//! A traffic light with a flashing state.
//! Novel language features: enum-variant-types, arbitrary-self-types

</span><span>enum </span><span>State {
    Green,
    Orange,
    Red,
    Flashing,
}

</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Green) -&gt; </span><span>Self::</span><span>Orange {
        </span><span>Self</span><span>::Orange
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Orange) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>// new
    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Flashing) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>// new
    </span><span>pub fn </span><span>flash</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Flashing {
        </span><span>Self</span><span>::Flashing
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new(); </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>    state = state.</span><span>flash</span><span>();        </span><span>// flashing
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>}
</span></pre>
<p>This would allow us to correctly model and validate the entire state graph at
compile-time, without needing to resort to any runtime checks. Yay us!</p>
<h2 id="ergonomics-overview">Ergonomics: Overview</h2>
<p>Hopefully folks can see the benefit of being able to model state transitions
solely through the type system. Obviously there are other ways of authoring
compiler-checked state machines today - but that&#39;s not the point of this post.
What we&#39;re trying to think about is how we can do so in a way which feels
<em>simple</em> and dare I even say, <em>intuitive</em> for people to use.</p>
<p>I think what we&#39;ve shown so far is pretty good. But it has a few shortcomings,
namely:</p>
<ol>
<li>It&#39;s pretty verbose to individually write each transition</li>
<li>What happens when we have more than one valid return state from a function?</li>
</ol>
<p>Okay, so bear with me for a sec here. In the graph each line goes from a <em>source</em>
to a <em>destination</em>. In the code the sources are represented by the self-types,
and the destinations are represented by the return types. This means that any
node in the graph with more than arrow pointing from or to it could potentially
benefit from refactoring. In the graph above there are instances of this:</p>
<ol>
<li><code>orange</code> and <code>flashing</code> point to <code>red</code></li>
<li><code>red</code> points to both <code>green</code> and <code>flashing</code></li>
</ol>
<p>For any type system enthusiasts reading this post: yes we&#39;re going to be
talking about representing powerset enums natively using Rust&#39;s typesystem
here .</p>

<h2 id="ergonomics-merging-self-types">Ergonomics: Merging Self-Types</h2>
<p>Now let&#39;s start with the first one: &#34;orange&#34; and &#34;flashing&#34; both point to &#34;red&#34;. So
far we&#39;ve been talking about arbitrary self-types as a feature. But there are
ideas floating around about expanding this for structs, called: <a href="https://smallcultfollowing.com/babysteps/blog/2021/11/05/view-types/">view types</a>.
What this allows you to do is inform the borrow checker we don&#39;t actually need
access to the entire struct - we only need access to parts of it. So we can hold
multiple mutable borrows on the same struct as long as the fields don&#39;t overlap.</p>
<p>Now what if we had the equivalent of these struct &#34;views&#34; but for enums. Instead
of &#34;viewing&#34; subsets of fields, we&#39;d be able to &#34;view&#34; subsets of enums. Now
let&#39;s make up a syntax to show what we mean. In patterns we already have <code>Foo | Bar</code> to represent multiple patterns, so let&#39;s reuse that here:</p>
<pre><span>// before
</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Orange) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Flashing) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }
}
</span></pre><pre><span>// after
</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Orange | </span><span>Self::</span><span>Flashing) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }
}
</span></pre>
<p>I know many of you will likely have opinions about the syntax, but let&#39;s not
focus on that for a minute. Instead I want to focus your attention attention on
the semantics at play here: it would bring the same pattern semantics as used in
<code>match</code> statements to methods, which I believe should feel a lot more natural?</p>
<p>Riffing time. There are some real questions about <a href="https://blog.yoshuawuyts.com/safe-pin-projections-through-view-types/">what syntax view types should use</a>.
Niko&#39;s post suggests something like <code>&amp;{golden_tickets} self</code>. But what if
instead we chose to reuse the pattern syntax for the <code>self</code> types  -
which could yield us something like <code>&amp;Self { golden_tickets, .. }</code>. This would
reuse the pattern-destructuring syntax. Which is similar to what we&#39;re doing
here: reusing the pattern enum matching syntax. It feels like there might be
something to it?</p>

<p>The compiler knows that the possible members of <code>self</code> in the example (&#34;orange&#34;,
&#34;flashing&#34;) are only a subset of all members in <code>State</code>. What if the compiler
actually used this information in the function body too? That would mean matching
on <code>self</code> would only need to account for the <em>possible</em> cases rather than <em>all</em>
cases:</p>
<pre><span>match </span><span>self </span><span>{
    </span><span>Self</span><span>::Orange =&gt; {}
    </span><span>Self</span><span>::Flashing =&gt; {}
    </span><span>// no other cases need matching!
</span><span>}
</span></pre>
<p>This isn&#39;t particularly relevant yet for the simple traffic light example we&#39;re
dealing with here, but definitely becomes a lot more relevant when working with
real-world code. No longer needing to <code>panic!</code> for branches you know can&#39;t be
reached anyway would make code both simpler and faster, which is a pretty big deal!</p>
<h2 id="ergonomics-merging-return-types">Ergonomics: Merging Return Types</h2>
<p>The second case is: <em>&#34;red can point to both green and flashing&#34;</em>. This one will be a bit
harder to reason about because instead of taking multiple different parameters
we&#39;re trying to <em>return</em> multiple parameters. This means the compiler can
no longer <em>statically</em> know which variant we have, and instead we have to
perform runtime matching to figure that out. Right now the code we have looks
like this:</p>
<pre><span>// before
</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>flash</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Flashing {
        </span><span>Self</span><span>::Flashing
    }
}
</span></pre>
<p>We have two different methods which take <code>Self::Red</code> and return a type. For
argument&#39;s sake say we wanted a single method with took some data to determine
whether we should go to <code>green</code> or <code>flashing</code> . This could then look
something like this:</p>

<pre><span>// after
</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red, </span><span>data</span><span>: Data) -&gt; </span><span>Self::</span><span>Green | </span><span>Self</span><span>::Flashing {
        </span><span>if </span><span>validate_data</span><span>(data) {
            </span><span>Self</span><span>::Green
        } </span><span>else </span><span>{
            </span><span>Self</span><span>::Flashing
        }
    }
}
</span></pre>
<p>Again, the syntax is not really the point. The idea here is though that just
like in the earlier example the returned value would be known to be a subset of
<code>Self</code>: it would still register as the <code>State</code> enum, but the only two accessible
members are <code>Green</code> and <code>Flashing</code> .</p>

<p>On the usage side things would change too: we could no longer statically know
which state we&#39;re in. All we know is that the state is either green or flashing.
This leads to some very real questions: should we be able to then call <code>next</code>
again to get to <code>orange | red</code>?</p>
<pre><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new(); </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
</span><span>    state = state.</span><span>next</span><span>(data);     </span><span>// green | flashing       - ok I guess?
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange | red           - uhhh,,
</span><span>    state = state.</span><span>next</span><span>(?data);    </span><span>// green | red | flashing - x_x
</span><span>}
</span></pre>
<p>Once we&#39;re in this state, we have different <code>next</code> methods. How do we decide how
we should call them? Even if we can answer this question, the semantics of this
seem pretty complex and hard to teach. So instead I propose we apply some
basic rules here to simplify usage:</p>
<ol>
<li>
<p>Once a variable is assigned to a single enum-member-as-value, it can only be
re-assigned to other single values and vice-versa.</p>
</li>
<li>
<p>Methods with the same name on the same enum need to have the same &#34;base&#34;
(type from which a view is derived) signature.</p>
</li>

</ol>
<p>The first rule would disallow assigning <code>green | flashing</code> to <code>state</code>. Instead
we&#39;d need to <code>match</code> to know which variant we have, and go from there:</p>
<pre><span>//! Never assign an enum view-type to `state`. This requires matching on the data
//! until we&#39;ve extraced a single member. Assume we wait for conditions to change
//! between calls to `state.next`.

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new();                    </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();                            </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();                            </span><span>// red
</span><span>    state = </span><span>handle_flash</span><span>(state.</span><span>next</span><span>(&amp;data), &amp;data);  </span><span>// green
</span><span>}

</span><span>/// Keep looping until we hit a green state.
</span><span>fn </span><span>handle_flash</span><span>(</span><span>mut </span><span>state</span><span>: </span><span>State::</span><span>Green | </span><span>State::</span><span>Flashing, </span><span>data</span><span>: &amp;Data) -&gt; </span><span>State::</span><span>Green {
    </span><span>match</span><span> state {
        State::Green =&gt; State::Green,
        State::Flashing =&gt; {
            state = state.</span><span>next</span><span>();              </span><span>// red
            </span><span>to_green</span><span>(state.</span><span>next</span><span>(&amp;data), &amp;data) </span><span>// green
        </span><span>}
    }

}
</span></pre>
<p>There are a bunch of assumptions baked in here - not in the least that an anonymous enum of
<code>State::Green | State::Flashing</code> can be passed to an enum view-type matching the
same members. But we&#39;re not doing details in this post. We&#39;re doing vibes. Yeehaw.</p>
<p>Okay, so for the second rule we&#39;re proposing: <em>methods with the same name on the same enum
should share the same base signature</em>. This means that methods which return a
<em>view</em> of some enum or struct are fine - because they&#39;re the same &#34;base&#34; type.
But having different methods with different signatures like we&#39;ve done here with
<code>next(data)</code> would be a no-no. This would allow us to keep thinking about
methods which take or return enum views as a form of specialization.</p>
<p>That last point is perhaps not strictly required, but it has the benefit of
making the enum feel more <em>consistent</em>. And it could lead allow for
specialization-like behavior where if you implement the same method for all enum
members, it then becomes unconditionally available on the entire enum - since it
can be called regardless of which state you&#39;re in, even if it yields different
behavior. But on a more intuitive level: it feels pretty weird that
<code>self.next()</code> sometimes takes an argument and sometimes doesn&#39;t. It kind of
feels like parameter overloading like it&#39;s done in other languages, and Rust
kind of steers clear of that. So it feels better to just enforce that methods
with the same name on the same enum need to take the same arguments - even if we
can wiggle around with view-types and sub-types a little.</p>
<h2 id="tying-it-together">Tying It Together</h2>
<p>Phew, that&#39;s been a ride. The last section has been a lot about what <em>not</em> to
do. So let&#39;s show an example of how things might look when we put them all
together. Let&#39;s start with what we had before, but slightly adapted to make the
<code>flash</code> case conditional:</p>
<pre><span>//! A traffic light with a flashing state.
//! Novel language features: enum-variant-types, arbitrary-self-types

</span><span>enum </span><span>State {
    Green,
    Orange,
    Red,
    Flashing,
}

</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Green) -&gt; </span><span>Self::</span><span>Orange {
        </span><span>Self</span><span>::Orange
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Orange) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>// new
    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Flashing) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>// new
    </span><span>pub fn </span><span>flash</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red) -&gt; </span><span>Self::</span><span>Flashing {
        </span><span>Self</span><span>::Flashing
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new(); </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();         </span><span>// red
    </span><span>if </span><span>validate_data</span><span>(data) {
            state = </span><span>self</span><span>.</span><span>next</span><span>();  </span><span>// green
            // handle green
        </span><span>} </span><span>else </span><span>{
            state = </span><span>self</span><span>.</span><span>flash</span><span>(); </span><span>// flashing
            // handle flashing
        </span><span>}
    }
}
</span></pre>
<p>Now if we translate that to our enum views variant, we&#39;re able to inline the
conditional statement into the enum. And together with the arbitrary self enum
pattern syntax, the overall code is a lot more trimmed. And especially the usage
should feel a bit more natural:</p>
<pre><span>//! A traffic light with a flashing state.
//! Novel language features: enum-variant-types, arbitrary-self-types,
//!                          enum-view-types, enum-sum-types

</span><span>enum </span><span>State {
    Green,
    Orange,
    Red,
    Flashing,
}

</span><span>impl </span><span>State {
    </span><span>pub fn </span><span>new</span><span>() -&gt; </span><span>Self::</span><span>Green {
        </span><span>Self</span><span>::Green
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Green) -&gt; </span><span>Self::</span><span>Orange {
        </span><span>Self</span><span>::Orange
    }

    </span><span>pub fn </span><span>next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Orange | </span><span>Self::</span><span>Flashing) -&gt; </span><span>Self::</span><span>Red {
        </span><span>Self</span><span>::Red
    }

    </span><span>// New: Inlines the logic of the previous example to decide whether to go
    //      from &#34;red&#34; to &#34;green&#34; or &#34;flashing&#34;.
    </span><span>pub fn </span><span>try_next</span><span>(</span><span>self</span><span>: </span><span>Self::</span><span>Red, </span><span>data</span><span>: Data) -&gt; </span><span>Self::</span><span>Green | </span><span>Self</span><span>::Flashing {
        </span><span>if </span><span>validate_data</span><span>(data) {
            </span><span>Self</span><span>::Green
        } </span><span>else </span><span>{
            </span><span>Self</span><span>::Flashing
        }
    }
}

</span><span>fn </span><span>main</span><span>() {
    </span><span>let mut</span><span> state = State::new();   </span><span>// green
</span><span>    state = state.</span><span>next</span><span>();           </span><span>// orange
</span><span>    state = state.</span><span>next</span><span>();           </span><span>// red
</span><span>    state.</span><span>try_next</span><span>(data) {
        State::Green =&gt; {},         </span><span>// handle green
        </span><span>State::Flashing =&gt; {},      </span><span>// handle flashing
    </span><span>};
}
</span></pre><h2 id="conclusion">Conclusion</h2>
<p>In this post we&#39;ve looked at how using &#34;enum variant types&#34;, &#34;enum sum
types&#34;, and &#34;enum view types&#34; could allow us to make state machines at the type
level in Rust easier to author and more ergonomic. The example we&#39;ve used here
has been a variation of a basic traffic light. But despite that we expect that
it should be possible to adopt the patterns and features shown here to state
machines in general.</p>
<p><strong>Challenges</strong></p>
<p>It seems that taking enums as self-types should be relatively straight-forward.
But returning anonymous enums is more complicated. I came up with some rules to
help circumvent some of the sharp edges, but I feel those probably could use
some more thought. Maybe folks reading this have some insights on it?</p>
<p><strong>Making Enums More Useful</strong></p>
<p>Also as my colleague <a href="https://github.com/sivadeilra">Arlie</a> pointed out during a recent chat: having
enums-as-types would be really beneficial for other reasons too. Take for
example the <code>syn</code> crate : the <a href="https://docs.rs/syn/latest/syn/enum.WherePredicate.html"><code>WherePredicate</code></a> has a member <code>Type</code> which
contains a struct called <a href="https://docs.rs/syn/latest/syn/struct.PredicateType.html"><code>PredicateType</code></a>. The reason why we have a separate
struct instead of just inlining the data in the enum member, is because members
can&#39;t be used as types. So if we want to author functions which operate on the
data in <code>WherePredicate::Type</code>, we <em>need</em> to create a separate struct .
This makes record-enums less useful than their struct counterparts, and
complicates the API surface area of crates.</p>


<p><strong>Structural Typing and Errors</strong></p>
<p>While we&#39;re on the topic of anonymous enums in general: another important use
case for it would be for error handling. Anonymous enums provide us with
structural typing for enums , which allows for convenient
composition of error types. Say we have a <a href="https://doc.rust-lang.org/std/string/type.ParseError.html"><code>ParseError</code></a> and <a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>io::Error</code></a>, a
function should just be able to specify <code>-&gt; Result&lt;T, ParseError | io::Error&gt;</code>.
But more importantly: we should be able to specify which error variants can be
returned. This is a bit harder with <code>io::Error</code> specifically because of how it&#39;s
constructed. But would work great when using errors returned by <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>.
I&#39;ve been meaning to write about error handling ever since I posted <a href="https://blog.yoshuawuyts.com/error-handling-survey">my error
handling survey</a> three years ago. Maybe I&#39;ll do that later this year.</p>

<p><strong>View Types</strong></p>
<p>Also, while writing this post I realized that being able to use enum variants
as self-types is kind of analogous to view types for structs. Both carve out
subsets of their base type, but for different purposes. Which makes sense
because they&#39;re actually different. But as a general trend the implications seem
fun: by more precisely articulating which sub-types we use, the compiler can
allow more code to function. I think the reason for that is that function
boundaries act as strict guards for what&#39;s allowed, and as a rule are also
pretty coarse-grained. By making the more expressive, the compiler becomes less
strict, and in turn more code can be allowed. It really does feel like view
types and the like might represent a generational leap akin to <a href="https://blog.rust-lang.org/2022/08/05/nll-by-default.html">NLL</a> in terms of
general language ergonomics. I think it&#39;s interesting to think about what else
could be loosened within the framework of Rust&#39;s existing semantics.</p>
<p><strong>Goals of this post</strong></p>
<p>To re-iterate: this post is intentionally incomplete. I&#39;ve knowingly glossed
over details, and left pieces out. The goal of the post was to show what the
<em>outcomes</em> we could have if we combined some features folks are thinking about
anyway. Together with a personal goal to not spend months writing about this,
because I actually should be working on diffferent things. Rust&#39;s
roadmap is always a balance of team prioritization and personal interests; so
showing what can be achieved by combining several features might lower the bar
to make the case these features would be useful, or perhaps even get people
interested in working on this.</p>
<p><strong>Wrapping up</strong></p>
<p>Anyway, that&#39;s probably enough discussion for now. This post was a massive
procrastination from writing another post on &#34;halt points&#34;, which I&#39;ve finished
drafting and am currently editing. This was is mostly thoughts which have been
stewing in the back of my mind after talking with colleages at work about state
machines, type systems, and more accurately modeling programs. Thanks for reading!</p>

    </div>
  </article></div>
  </body>
</html>
