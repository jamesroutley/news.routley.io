<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.propelauth.com/post/generating-chess-puzzles-with-genetic-algorithms">Original</a>
    <h1>Generating chess puzzles with generic algorithms (2022)</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>One of my favorite things to do is to find interesting libraries and test out unusual use cases with them. The python library <a href="https://pypi.org/project/geneticalgorithm/?ref=propelauth.com">geneticalgorithm</a> is beautifully open ended—exposing a simple but powerful interface that we can use for all sorts of weird stuff.</p><p>In this post, we’ll use it to generate chess puzzles that look like this:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-12.52.10-AM.png" alt="" loading="lazy" width="2236" height="1494"/></figure><p>or more tame ones like this:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-6.20.02-PM.png" alt="" loading="lazy" width="2194" height="1476"/></figure><p>If you aren’t familiar with chess, these are both called “mate in 3” puzzles. This means that White can win the game in 3 moves, but only if they find one specific move.</p><p>The first puzzle was generated with the constraint “Include as many Knights as possible,” which explains why both sides have way too many Knights.</p><p>But before we get into all that, we’ll start by understanding the library.</p><h2 id="geneticalgorithm">geneticalgorithm</h2><p>There are a number of good articles that explain what genetic algorithms are (like <a href="https://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b?ref=propelauth.com">this one</a>). The main thing to note, from that article, is</p><blockquote>in order to find a solution using the GA, random changes applied to the current solutions to generate new ones</blockquote><p>So, at a high level, we take some solution to a problem and randomly modify it to get new possible solutions. We won’t go into the details here, and instead will focus on what interfaces the library exposes. Let’s start with an example from the docs:</p><pre><code>import numpy as np
from geneticalgorithm import geneticalgorithm as ga

def f(X):
    return np.sum(X)

varbound=np.array([[0,10]]*3)
model=ga(function=f,dimension=3,variable_type=&#39;int&#39;,variable_boundaries=varbound)
model.run()
</code></pre><p>which outputs:</p><pre><code>The best solution found:
 [0. 0. 0.]

 Objective function:
 0.0
</code></pre><p>If we break this down, what we see is:</p><ul><li>We have a function f(X) that takes in an array of 3 integers</li><li>Those integers are all between 0 and 10, inclusive</li><li>Our goal is to minimize the function f(X)</li><li>Since f(X) just sums up the 3 integers, the best solution is if they are all 0</li></ul><h2 id="how-complicated-can-our-function-be">How complicated can our function be?</h2><p>Adding three numbers together is cool and all, but let’s try something slightly more complicated.</p><pre><code>def f(X):
    return abs(X[0] - 3) + abs(X[1] - 1) + abs(X[2] - 10)

# The best solution found:
# [ 3.  1. 10.]

# Objective function:
# 0.0
</code></pre><p>And that works pretty easily. It’s also worth contrasting that function, with this one:</p><pre><code>def f(X):
    if X[0] == 3 and X[1] == 1 and X[2] == 10:
        return 0
    return 1

# The best solution found:
# [2. 9. 3.]

# Objective function:
# 1
</code></pre><p>These two functions have the same best solution, but the second one fails occasionally (using the default parameters) whereas the first one doesn’t. If you think about how our black box <code>model.run()</code> might work, you can probably figure out why this happens.</p><p>In our first function, solutions close to [3, 1, 10] have lower values than solutions further from [3, 1, 10]. In our second function, our algorithm basically gets no feedback until we happen to get [3, 1, 10]. You can see this in the graphs that are produced:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-4.54.07-PM-2.png" alt="" loading="lazy" width="350" height="264"/><figcaption>Over time, our objective function f(X) decreases</figcaption></figure><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-5.01.03-PM.png" alt="" loading="lazy" width="350" height="271"/><figcaption>Over time, our objective function f(X) stays the same</figcaption></figure><p>In the first graph, we see that the algorithm quickly converged on the right answer, getting feedback that it was on the right path. In the second graph, we just constantly got the same value until we gave up.</p><h2 id="modeling-chess">Modeling Chess</h2><p>Our function is pretty arbitrary though—who’s to say that it needs to represent some mathematical function.</p><p>What if we generate 64 integers - one for each chess position. And the integers will be between 0 and 12, representing an empty square or a piece.</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/0--1---1-.png" alt="" loading="lazy" width="600" height="100"/></figure><p>We can use the python library <a href="https://python-chess.readthedocs.io/en/latest/core.html?ref=propelauth.com">python-chess</a> to construct a chess board object. This will allow us to check more properties of the board—like if it’s a valid position, if it’s currently a stalemate, etc.</p><pre><code>def value_to_piece(value):
    if value == 0:
        return None
    elif value &lt;= 6:
        # Pieces have values 1 through 6
        return chess.Piece(value, chess.WHITE)
    else:
        return chess.Piece(value - 6, chess.BLACK)

def array_to_chess_board(arr):
    # construct an empty chess board
    board = chess.Board(fen=&#39;8/8/8/8/8/8/8/8 w - - 0 1&#39;)
    for i, value in enumerate(arr):
        piece = value_to_piece(value)
        if piece:
            board.set_piece_at(i, piece)
    return board
</code></pre><p>Now all we need is a function to minimize. Let’s start off simple by asking it to generate a <strong>valid chess position</strong> with as <strong>few pieces as possible</strong>.</p><pre><code>def f(X):
    board = array_to_chess_board(X)

    # We want as few pieces as possible, so each piece adds to our penalty
    penalty = len(board.piece_map()) * 0.1
    # Add a big penalty for invalid positions
    if not board.is_valid():
        penalty += 10

    return penalty
</code></pre><p>We also need to modify our constraints to include 64 integers:</p><pre><code>varbound = np.array([[0, 12]] * 64)
</code></pre><p>and the docs say that we should experiment with our own configuration, I used this but these are all values that can be tweaked:</p><pre><code>algorithm_param = {&#39;max_num_iteration&#39;: 50000,
                   &#39;population_size&#39;: 20,
                   &#39;mutation_probability&#39;: 0.05,
                   &#39;elit_ratio&#39;: 0.01,
                   &#39;crossover_probability&#39;: 0.9,
                   &#39;parents_portion&#39;: 0.3,
                   &#39;crossover_type&#39;: &#39;two_point&#39;,
                   &#39;max_iteration_without_improv&#39;: 5000}
</code></pre><p>Finally, let’s run our code and print out a string representation of our best board:</p><pre><code>model = ga(function=f, dimension=64, variable_type=&#39;int&#39;, variable_boundaries=varbound, algorithm_parameters=algorithm_param)
model.run()

best_board = array_to_chess_board(list(model.best_variable))
print(best_board.fen())
# 8/8/2K5/8/8/8/8/5k2 w - - 0 1
</code></pre><p>You can visualize the FEN string on <a href="https://lichess.org/analysis/standard/?ref=propelauth.com">Lichess</a>, and you’ll see:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-5.30.26-PM-1.png" alt="" loading="lazy" width="400" height="400"/></figure><p>This should match what you’d expect. For a position to be “valid” it must include a White and Black king. It doesn’t need any other pieces, so this is actually the optimal solution to our function - a valid chess board with the fewest possible pieces!</p><h2 id="using-stockfish-to-generate-chess-puzzles">Using Stockfish to generate chess puzzles</h2><p>A chess puzzle is a position where there is one, and only one, good move. Puzzles are typically used for training, since it can be a challenge to find the sole good move in a position.</p><p>Typically, the way puzzles are generated is by looking at positions in real games and determining if each position is a puzzle or not (meaning the main move is good and every subsequent move is not).</p><p>How can we know that there’s exactly one good move? We can use the open source chess engine <a href="https://stockfishchess.org/?ref=propelauth.com">Stockfish</a>. Our python-chess library actually has <a href="https://python-chess.readthedocs.io/en/latest/engine.html?ref=propelauth.com">support for communicating with an engine like Stockfish</a>. That means that getting a detailed analysis of a position is as simple as:</p><pre><code># a chess position where white can win in one move
board = chess.Board(&#34;5Q2/5K1k/8/8/8/8/8/8 w - - 0 1&#34;)

# initialize Stockfish 
engine = chess.engine.SimpleEngine.popen_uci(&#34;/opt/homebrew/bin/stockfish&#34;)

# you can control the engine&#39;s search by time or depth
info = engine.analyse(board, chess.engine.Limit(time=0.1))
</code></pre><p><code>info</code> contains a lot of fields, but the two most important are:</p><pre><code>[{
  &#39;score&#39;: PovScore(Mate(+1), WHITE),
  &#39;pv&#39;: [Move.from_uci(&#39;f8g7&#39;)],
}]
</code></pre><p>The <code>score</code> tells us what Stockfish thinks of the position, which is a mate in one.</p><p>The <code>pv</code> (short for <a href="https://www.chessprogramming.org/Principal_Variation?ref=propelauth.com">principal variation</a>) tells us the sequence of moves that the engine expects to be played. In this case, it’s saying that it expects White to move their queen on f8 to g7, which is checkmate.</p><p>Let’s use both of these in a function that generates <strong>mate in three</strong> puzzles, meaning puzzles where white can win in exactly three moves.</p><pre><code>def f(X):
    board = array_to_chess_board(X)

    # Let&#39;s reward having as few pieces as possible
    penalty = len(board.piece_map()) * 0.1

    # Penalize invalid boards heavily, we cannot even analyze them
    if not board.is_valid():
        return 10 + penalty

    # You can tune the depth for performance reasons
    info = engine.analyse(board, chess.engine.Limit(depth=10), multipv=2)

    # If there are no moves (meaning the game is over), return a high penalty
    if len(info) &lt; 1:
        return 9 + penalty

    # Also heavily penalize having only 1 move, puzzles are only interesting
    #   if we have a choice to make
    if len(info) &lt; 2:
        return 8 + penalty

    # We&#39;re specifically looking for puzzles where White can mate in 3 moves
    #   so we&#39;ll penalize cases where white does not have a forced mate
    score = info[0][&#34;score&#34;].white()
    if not score.is_mate() or score.mate() &lt;= 0:
        return 6 + penalty

    # Add a penalty for the distance away from mate in 3 
    penalty += min(3, abs(score.mate() - 3)) / 3

    # Finally, add a high penalty if the second best move is also good.
    # The defining characteristic of a puzzle is that the second best move is bad
    second_move_score = info[1][&#34;score&#34;].white().score(mate_score=1000)
    if second_move_score &gt; 100:
        penalty += min(10.0, second_move_score / 100)

    return penalty
</code></pre><p>Similar to above, we want chess positions that are close to our target to have lower values than chess positions that are further away. That’s why we added cases like:</p><ul><li>A mate in 4 puzzle is better than a mate in 7 puzzle</li><li>An invalid position is heavily penalized, as are cases where the game is already over</li></ul><p>You’ll get a different result every time you run this, but here’s one example:</p><p><code>6kr/7b/8/r6Q/8/B7/5K2/3R2b1 w - - 0 1</code></p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-6.20.02-PM.png" alt="" loading="lazy" width="2194" height="1476"/></figure><p>I included the top four engine moves on the right, but as you can see there’s only one move white can play which will win the game. Every other move allows black to equalize or even gain a small advantage.</p><p>But, how much control do we really have? Our current function tries to include as few pieces as possible. What if instead, we decide that we want as many Knights as possible, preferably enemy Knights? We’ll change our function to add this as a penalty:</p><pre><code># Removed
# penalty = len(board.piece_map()) * 0.1

penalty = 1 - len(board.pieces(chess.KNIGHT, chess.WHITE)) * 0.01
peanlty += 6 - len(board.pieces(chess.KNIGHT, chess.BLACK)) * 0.1
</code></pre><p>And when we run that we get:</p><figure><img src="https://cdn.getmidnight.com/a1241f0fcb8d83a4c0387f234e241914/2022/10/Screen-Shot-2022-10-12-at-12.52.10-AM.png" alt="" loading="lazy" width="2236" height="1494"/></figure><p>So many Knights, and yet, it’s still a mate in 3 puzzle.</p><h2 id="a-quick-aside-can-we-generate-realistic-puzzles">A quick aside: Can we generate realistic puzzles?</h2><p>All the puzzles we generated are a little questionable. The Knight one is pretty obviously not reachable in a real game. This warrants an entire separate post, but one fun way you can generate realistic looking puzzles is by incorporating a “realism score” into the function.</p><p>If you had a classifier that took in chess position and output a score of how “realistic” it is, you can add that to your penalty to penalize unrealistic boards. This requires many examples of “realistic” positions—but luckily Lichess is amazing and has a <a href="https://database.lichess.org/?ref=propelauth.com">dataset</a> of way more games than you’d need to build a good classifier.</p><h2 id="why-do-this">Why do this?</h2><p>The puzzles you get from actual games are absolutely higher quality than what we generated, however, I think of this as an interesting proof of concept.</p><p>We took a library used for function minimization, attached Stockfish to it, and used it to generate surprisingly complex mate in 3 chess puzzles without too much code. Libraries like this excite me because it feels like the limit is your imagination and your ability to transform ideas into code.</p>
    </section></div>
  </body>
</html>
