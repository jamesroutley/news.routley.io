<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lambdafunctions.com/articles/elixir-and-rust">Original</a>
    <h1>Managing mutable data in Elixir with Rust</h1>
    
    <div id="readability-page-1" class="page"><section>

<p>
One of Elixir’s core benefits, and the secret to its robustness and scalability,
is its foundation on immutable data.  Sometimes, though, immutability is just
not a great fit for a particular task—but that task is only one part of a large
project.  Is it possible to enjoy the benefits of Elixir’s data model everywhere
else, but carve out a little mutable exception for one area?</p>
<p>
Yes!</p>
<p>
A long-running Elixir project I’m involved in has just this problem.  The
project is delivered over the web, so moving away from Elixir as a whole is not
on the cards because <a href="https://www.phoenixframework.org/">Phoenix</a> is quite
simply a cheat code for web development.  We <em>could</em> hive off the mutable
section into a microservice, but that would require significant architectural
and management overhead.  All we really need is a little escape hatch for a
limited chunk of code, while still being within the same VM and able to interact
normally with the rest of the service.</p>
<p>
This is just what <a href="https://github.com/rusterlium/rustler">Rustler</a> offers.</p>
<p>
Rustler is “a library for writing Erlang NIFs in safe Rust code”—in other
words, you can write code that looks like standard Elixir functions, but behind
the scenes is actually implemented in Rust.</p>
<p>
<a href="https://www.erlang.org/docs/17/tutorial/nif">NIFs</a> have been a feature of the
Erlang VM since long before either Elixir or Rust arrived on the scene.  What
Rust and Rustler add is:</p>
<ul>
  <li>
    <p>
safety—this is critical since a crash in a NIF will bring down the
whole VM    </p>
  </li>
  <li>
    <p>
a lot of polish and interface glue that makes it feasible to write
more ambitious integrations that you might be inclined to attempt with
C and Erlang’s standard NIF support    </p>
  </li>
  <li>
    <p>
access to all of Rust’s libraries    </p>
  </li>
</ul>
<p>
Unfortunately, most of the Rustler examples on the web focus on the speed
benefits and show the implementation of a trivial <code>add</code> function and then stop
there.  While that’s fine for demonstrating the bare minimum integration
required, for me the interesting part of Rustler is the chance to escape in a
controlled way from the immutable world—I want to explore how to manage a
little mutable chunk of memory in a safe way.  Although Rustler is certainly
capable of this, there’s very little available in the way of tutorials or
examples.</p>
<p>
Hopefully this article will help.</p>
<h2>
Goal</h2>
<p>
As mentioned above, I want to explore memory management.  More specifically, I
want to be able to hold a chunk of data in the Rust world that persists between
multiple calls to different “Elixir” (Rustler) functions.  These functions
should allow the Elixir world to pass data into the Rust world, mutate the data
held there, and then retrieve results.</p>
<p>
To give us something substantial to play with and avoid having to implement our
own data store for this demo, I’ll use Oxigraph.</p>
<p>
<a href="https://github.com/oxigraph">Oxigraph</a> is a Rust graph database library
implementing the SPARQL standard.  Let’s suppose that we want to wrap it, so
that we can have access to a fast graph database from within Elixir.  We’ll call
our wrapper <code>FeGraph</code>.</p>
<p>
We want to be able to:</p>
<ol>
  <li>
    <p>
Make a new in-memory database    </p>
    <pre><code>db = FeGraph.new()</code></pre>
  </li>
  <li>
    <p>
Add data to it    </p>
    <pre><code>FeGraph.set(db, &#34;http://foo.bar.com&#34;)
FeGraph.set(db, &#34;http://foo.baz.com&#34;)</code></pre>
  </li>
  <li>
    <p>
Export the database as a
<a href="https://en.wikipedia.org/wiki/Turtle_(syntax)">Turtle</a> string:    </p>
    <pre><code>FeGraph.dump_db(db) |&gt; IO.puts()</code></pre>
  </li>
</ol>
<p>
To keep this to a reasonable length, we’re not going to implement everything
that would be required to expose all the capabilities of Oxigraph; just enough
to demonstrate holding data on the Rust side and acting on it from Elixir.</p>
<h2>
Implementation</h2>
<p>
(If you want to follow along, I recommend working through one of the many
Rustler <code>add</code> tutorials I mentioned before getting into the code, so that you
have a basic project up and running and have worked through how Rust and Elixir
functions link together.  Everything below here assumes you’re already at that
point.)</p>
<p>
The key to this whole approach is the ability to pass a
<a href="https://erlang.org/doc/man/erl_nif.html#resource_objects">Resource</a> between the
two worlds.  This acts as a handle to a piece of memory; it can be returned from
a NIF and then passed back into another call.  Exactly what we need.</p>
<p>
A BEAM <code>Resource</code> is represented in Rustler by a
<code>rustler::resource::ResourceArc&lt;T&gt;</code> struct.  To get started with our
implementation, let’s define a new type that we can use as a handle to represent
the state of our graph store.</p>
<p>
In a production scenario we’re likely to want to manage more state than this,
but for now it will suffice to define a <code>MyGraph</code> struct that just contains (via
a mutex) the Oxigraph data store; this represents the mutable data we want to
manage outside Elixir.  In the future, more fields could be added to <code>MyGraph</code>
as necessary.</p>
<p>
To turn this into something that can be passed back and forth between Elixir and
Rust, we need to wrap it in a <code>ResourceArc</code>.  In order to make our function
signatures a bit more readable we’ll define a new type of <code>GraphArc</code> to
represent a <code>MyGraph</code> struct in a <code>ResourceArc</code>.</p>
<p>
In <code>lib.rs</code>:</p>
<pre><code>use std::sync::Mutex;
use oxigraph::store::Store;
use rustler::resource::ResourceArc;
use rustler::OwnedBinary;
use rustler::{Env, Term};

struct MyGraph { store: Mutex&lt;Store&gt; }

type GraphArc = ResourceArc&lt;MyGraph&gt;;</code></pre>
<p>
A bit of additional plumbing is required to tell Rustler that a <code>MyGraph</code> is
something that can be used as a <code>Resource</code>:</p>
<pre><code>fn on_load(env: Env, _info: Term) -&gt; bool {
    rustler::resource!(MyGraph, env);
    true
}</code></pre>
<p>
With these definitions in place, we can write a <code>new</code> function that allocates a
new data store and returns a handle to it:</p>
<pre><code>#[rustler::nif]
fn new() -&gt; GraphArc {
    ResourceArc::new(
        MyGraph {
            store: Mutex::new(Store::new().unwrap()),
        }
    )
}</code></pre>
<p>
And on the Elixir side, in <code>fe_graph.ex</code>:</p>
<pre><code>defmodule FeGraph do
  use Rustler, otp_app: :myapp, crate: &#34;fegraph&#34;

  def new(), do: :erlang.nif_error(:nif_not_loaded)
end</code></pre>
<p>
At this point we can test in <code>iex</code>, and see that the Elixir stub above has been
replaced by the Rust NIF we defined, which we can run and which gives us back a
reference:</p>
<pre><code>iex(1)&gt; FeGraph.new
#Reference&lt;0.2659174309.2607677441.115195&gt;</code></pre>
<p>
Granted we can’t yet <em>do</em> anything with it, but we’re already defining a data
store in Rust and seeing evidence of it in Elixir; and behind the scenes the
BEAM and Rustler are taking care of all of the heavy lifting for us.</p>
<p>
How about a simple function to add some data to our new store?  In a way that
will feel very familiar to Elixir code, it will need to both take and return a
<code>GraphArc</code> handle.  We’ll also have it accept a single string to use for all
three parts of the triple to store (normally of course we’d take different
strings for the subject, predicate, and object parts of the triple, but our
focus here isn’t on SPARQL—we just want some data to store.)</p>
<pre><code>#[rustler::nif]
fn set(state: GraphArc, iri: &amp;str) -&gt; GraphArc {
    let store = state.store.lock().unwrap();

    let ex = NamedNode::new(iri).unwrap();
    let quad =
        Quad::new(ex.clone(), ex.clone(), ex.clone(), GraphName::DefaultGraph);
    (*store).insert(&amp;quad).unwrap();

    drop(store);

    state
}</code></pre>
<p>
Within the function we can use our <code>GraphArc</code> state argument to get a hold of
the Oxigraph store that we created back in the <code>new</code> function.  Once we’ve got
it we can add some test data to the graph as normal, then return the unchanged
<code>state</code>.</p>
<p>
The final piece of the puzzle is to retrieve some data from our store.  Rather
than running a query (which would require getting into more SPARQL) we’ll just
dump the whole database and return it as a string.  As before, our new function
will need to accept a <code>GraphArc</code>, but this time we’ll return an <code>OwnedBinary</code>,
which allows us to send a binary back to the BEAM and then wash our hands of it.</p>
<pre><code>#[rustler::nif]
fn dump_db(state: GraphArc) -&gt; OwnedBinary {
    let store = state.store.lock().unwrap();

    let mut buffer = Vec::new();
    (*store)
        .dump_graph(
            &amp;mut buffer,
            GraphFormat::Turtle,
            GraphNameRef::DefaultGraph,
        )
        .unwrap();

    let mut result = OwnedBinary::new(buffer.len()).unwrap();
    result.as_mut_slice().copy_from_slice(&amp;buffer);

    result
}</code></pre>
<p>
The majority of this function turns out to be messing around getting the data
out of Oxigraph into a buffer, and then from the buffer into the <code>OwnedBinary</code>;
the Rustler wrapper has become mostly invisible which is what I was originally
hoping for.</p>
<p>
With this in place we can now demonstrate allocating some memory in Rust,
returning a handle to that memory, then using it to store data outside the BEAM
memory model and finally fetch the data back into the Elixir world:</p>
<pre><code>iex(1)&gt; db = FeGraph.new
#Reference&lt;0.2749498138.3684302852.140448&gt;
iex(2)&gt; FeGraph.set(db, &#34;http://foo.com&#34;)
#Reference&lt;0.2749498138.3684302852.140448&gt;
iex(3)&gt; FeGraph.dump_db(db)
&#34;&lt;http://foo.com&gt; &lt;http://foo.com&gt; &lt;http://foo.com&gt; .\n&#34;</code></pre>
<p>
Note the important part; the reference is the same both times despite the data
changing and we are <em>not</em> storing it after the <code>set</code> call; normally we’d need to
do something like <code>db = FeGraph.set(db, &#34;http://foo.com&#34;)</code> instead.  The only
reason <code>set</code> returns the reference is for convenient use with the pipe operator
or similar.</p>
<h2>
Conclusion</h2>
<p>
While the code shown above does skip past most of the error handling, hopefully
it’s clear just how accessible Rustler makes it to link Rust code into Elixir
projects in a way that allows you to combine the strengths of both.</p>
<p>
Rustler is a tremendous addition to the Elixir ecosystem, and it opens up far
more opportunities than just calculating things more quickly.  Being able to opt
out of the standard BEAM memory model for specific sections of code can open the
doors to custom data stores and other features that would not generally be a
good fit for Elixir, while still allowing you to use the power of Phoenix for
the majority of your application… all with virtually seamless integration.</p>

        </section></div>
  </body>
</html>
