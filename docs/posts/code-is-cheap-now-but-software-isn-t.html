<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.chrisgregori.dev/opinion/code-is-cheap-now-software-isnt">Original</a>
    <h1>Code is cheap now, but software isn&#39;t</h1>
    
    <div id="readability-page-1" class="page"><article><p>Claude Code and Claude Opus 4.5 have poured fuel on the hype. LLM tools existed before, but they’re better than ever now, so a lot more people are paying attention. But we’re not entering a golden age of SaaS. We’re entering an era of personal, disposable software—where engineering shifts from writing code to shaping systems, and engineers are still required for exactly that reason.</p>
<h2>The Shift in Modern Development</h2>
<p><strong>Claude Code</strong> is taking over my feed right now, and for good reason. What’s interesting isn’t just that developers are jumping on it—it’s that <strong>&#34;builders&#34; and makers</strong> who previously relied on platforms like Lovable or Replit are migrating to it.</p>
<p>Don’t get me wrong, those tools are still perfectly viable for shipping fast. But we’re seeing a clear shift as people rediscover the inherent beauty of a <strong>CLI-first workflow</strong>. When you move the interaction into the <strong>terminal</strong>, the abstraction layer thins out. You aren&#39;t just following a managed UI&#39;s happy path; you&#39;re the one in control.</p>
<hr/>
<h2>The collapse of the barrier to entry</h2>
<p>What are people actually building with these tools? If you look around, the answer is: almost everything. In fact, we’ve reached a point of saturation. On one hand, we are witnessing the <strong>true democratisation of software creation</strong>. The barrier to entry has effectively collapsed. For the first time, <strong>non-developers</strong> aren&#39;t just consumers of software - they are the <strong>architects of their own tools</strong>.</p>
<p>In the past, if you had a specific problem, you’d spend hours searching for a SaaS product that solved 80% of it. Today, the workflow has shifted. People are opening a CLI or a voice interface and simply describing what they need. We’re seeing a surge in <strong>&#34;personal software&#34;</strong>:</p>
<ul>
<li>A <strong>subscription tracker</strong> tailored to a specific budget style</li>
<li>A <strong>Chrome extension</strong> that solves one very niche data entry problem</li>
<li>A <strong>fitness app</strong> with an interface exactly how the user wants it</li>
</ul>
<p>This is a massive shift. <strong>Software is becoming a personal utility</strong> you generate, rather than a commodity you buy.</p>
<h2>From SaaS to Scratchpads</h2>
<p>We’re entering a new era of software development where the goal isn&#39;t always longevity. For years, the industry has been obsessed with building &#34;platforms&#34; and &#34;ecosystems,&#34; but the tide is shifting toward something more ephemeral. We&#39;re moving from SaaS to scratchpads.</p>
<p>A lot of this new software isn&#39;t meant to live forever. In fact, it’s the opposite. People are increasingly building tools to solve a single, specific problem exactly once—and then discarding them. It is software as a disposable utility, designed for the immediate &#34;now&#34; rather than the distant &#34;later.&#34;</p>
<p>What makes this viable today is a specific technical philosophy: CLI-first interfaces, local data, and zero onboarding. When you remove the friction of signing up, configuring a database, or navigating a complex UI, the cost of creating a tool drops so low that &#34;temporary&#34; becomes a feature, not a bug. If it takes five minutes to spin up a custom solution for a one-off task, you don&#39;t need it to persist.</p>
<p>The contrast with the traditional SaaS model is stark. SaaS is inherently built to optimize for retention, lock-in, and expansion. It’s a business model designed to keep you inside the ecosystem and growing your footprint. Bespoke tools, on the other hand, optimize for immediacy and control. They don&#39;t care about your lifetime value as a customer; they only care about solving the task at hand.</p>
<p>In many ways, this is a return to how spreadsheets were originally used. You didn&#39;t open a spreadsheet to build a permanent, multi-year database; you used it as a scratchpad to reason through a problem, calculate the results, and move on.</p>
<p>In this new landscape, Claude Code is Excel for developers—a powerful, flexible utility for solving immediate problems—rather than Shopify for founders, which is built to be a permanent foundation for a business. It’s about getting the job done, and then letting the tool go.</p>
<p>This also explains why the next part matters: generating software quickly is one thing; making it survive contact with the real world is another.</p>
<h2><strong>Code Is Cheap. Software Is Still Expensive.</strong></h2>
<p>Here is the reality of the current &#34;AI-native&#34; era: code has become cheap, but software remains incredibly expensive.</p>
<p>LLMs have effectively killed the cost of generating lines of code, but they haven’t touched the cost of truly understanding a problem. We’re seeing a flood of &#34;apps built in a weekend,&#34; but most of these are just thin wrappers around basic CRUD operations and third-party APIs. They look impressive in a Twitter demo, but they often crumble the moment they hit the friction of the real world.</p>
<p>The real cost of software isn’t the initial write; it’s the maintenance, the edge cases, the mounting UX debt, and the complexities of data ownership. These &#34;fast&#34; solutions are brittle.</p>
<p>The subscription tracker breaks the moment a bank changes its CSV export format. The Chrome extension dies the second a target website’s DOM shifts. The fitness app becomes unusable as soon as a user needs robust offline support or reliable data sync.</p>
<p>Lately, I’ve seen plenty of doomsaying on Hacker News, Reddit, and Twitter about &#34;the end of software engineering.&#34; This misses the point entirely. We aren&#39;t witnessing the end of the profession; we’re entering a new era of it.</p>
<p>The value of an engineer is shifting away from the &#34;how&#34; of syntax and toward the &#34;what&#34; and &#34;why&#34; of systems. Real engineering lies in the abstractions and the architecture. It’s about knowing how to structure a system that lasts, understanding why a specific rate-limiting strategy is necessary, knowing how to manage a distributed cache, and knowing exactly where <em>not</em> to store your environment variables.</p>
<p>AI often feels powerful because it hides the complexity, but as an engineer, your job is to manage that complexity, not ignore it. The tools have changed, but the fundamental requirement for engineering rigour has never been higher.</p>
<h2>The distribution illusion</h2>
<p>But there is a flip side. With the barrier to entry gone, the <strong>noise level</strong> has reached an all-time high. My feeds are currently flooded with <strong>&#34;AI entrepreneurs&#34;</strong> claiming <strong>five-figure monthly recurring revenue (MRR)</strong> for apps they built in an afternoon.</p>
<p>In many cases, these claims are highly suspect. When you see a creator with no existing distribution and no clear <span><strong>&#34;moat&#34;</strong></span> claiming $10,000 in MRR on a weekend project, it’s usually a play for engagement rather than a reflection of business reality.</p>
<p>Some of these stories are almost certainly true but in most cases, these aren&#39;t actually blueprints for technical innovation. They are marketing case studies. These individuals succeed because they have mastered the art of capturing attention in a crowded landscape, not just because they have an AI co-pilot.</p>
<p>We’ve entered an era where the ability to generate code is no longer the bottleneck. The <strong>real challenge has shifted to distribution</strong> and, more importantly, distinguishing the <strong>genuine utility</strong> from the &#34;get-rich-quick&#34; posturing that has become so prevalent in the industry.</p>
<p>These people haven&#39;t stumbled upon a secret shortcut; they have simply found a way to execute their existing advantages faster (and potentially unlocked it in the first place if learning to code was rightfully too big of an undertaking for a side project idea).</p>
<p>There is a useful framing for this shift: AI has effectively removed engineering leverage as a primary differentiator. When any developer can use an LLM to build and deploy a complex feature in a fraction of the time it used to take, the ability to write code is no longer the competitive advantage it once was. It is no longer enough to just be a &#34;builder.&#34;</p>
<p>Instead, success now hinges on factors that are much harder to automate. Taste, timing, and deep, intuitive understanding of your audience matter more than ever. You can generate a product in a weekend, but that is worthless if you are building the wrong thing or launching it to a room full of people who aren&#39;t listening.</p>
<p>In this new environment, the code has become the easy part. The hard part remains exactly what it has always been: finding a way to get people to care.</p>
<h2>Who wins</h2>
<p>First, you have domain experts who are stuck with boring, repetitive problems. Then there are the internal teams building throwaway tooling, the kind of scripts and internal apps that need to work immediately rather than look perfect. Power users also see a massive gain here, particularly when they are looking to replace brittle, manual workflows with something more robust. Finally, it is a win for those engineers who prioritise ownership of the solution over high-gloss polish.</p>
<p>And yes — tools like Claude Opus 4.5, Claude Code, and Cursor are genuinely useful for engineers. They are remarkably good at removing boilerplate, implementing features, and writing unit tests. One of my favourite use cases lately, especially since starting a new job, is generating personalised documentation and walkthroughs of features to get up to speed on the product codebase and how all the nuance works - it&#39;s been extremely helpful in getting up to speed.</p>
<p>But here is the reality: LLMs are not perfect at writing code - even if it compiles first time. Even with high quality prompting and clear rules, these models still make mistakes. Speaking as someone who uses these tools every day, you cannot simply trust the output outright. You still have to review the code as if it were a pull request from a teammate. You have to read the logic, check the assumptions, and often make manual edits to get it right.</p>
<p>After all, you&#39;ll likely be sending this to a teammate for a review (and maybe Code Rabbit I guess) - is it fair to make them review something you didn&#39;t write or even bother to check?</p>
<p>These tools help you move faster, but they do not replace the need for a critical eye or your years of experience and do not understand the overall problem space better than you.</p>
<hr/>
<p>The hype makes it look like we’re entering a golden age of SaaS. We aren’t. We’re entering an era of personal software: tools you generate to solve a problem, and then move on.</p>
<p>With twenty dollars, a few hours of spare time, and a bit of patience, almost anyone can ship a functional application. We are entering the era of &#34;personal software,&#34; where the gap between an initial idea and a working product is narrower than ever before.</p>
<p>In this new reality, engineering expertise remains incredibly valuable, but the nature of the role is shifting. Relevance is not fading. Instead, it is about leveraging these tools to build at a higher level than was previously possible. True expertise is now required to steer these systems and provide the technical oversight that LLMs currently lack.</p>
<p>While AI is undeniably good at writing code, it remains poor at architecting maintainable, distributable, and scalable systems. This is where non-technical leaders who think they can fire their development teams are making a significant mistake. Until we see the arrival of an artificial intelligence that renders this entire discussion moot, believing that technical expertise can be replaced by a prompt is a strategic error. Building robust software still requires a human who understands the underlying principles of the craft.</p>
<p>The bottom line is that while the tools have changed, the fundamentals of good engineering have not.</p>
<p>While barrier to entry may be gone - judgment, taste, and responsibility are still the job.</p>
<hr/>
<p>I hope you found this post insightful. <a href="https://www.twitter.com/codestirring" target="_blank" rel="noopener noreferrer">Follow me on Twitter</a> and <a href="https://bsky.app/profile/codestirring.bsky.social" target="_blank" rel="noopener noreferrer">Bluesky</a> for more wild takes and opinions on programming &amp; Elixir.</p>
<p>Check out <a data-state="closed" href="https://defer.to" target="_blank" rel="noopener noreferrer" data-umami-event="link_click">defer.to</a> — my current obsession!</p></article></div>
  </body>
</html>
