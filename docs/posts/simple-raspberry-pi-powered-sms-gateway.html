<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.haschek.at/2021/raspberry-pi-sms-gateway.html">Original</a>
    <h1>Simple Raspberry Pi Powered SMS Gateway</h1>
    
    <div id="readability-page-1" class="page"><article>
                    <div>
                        <div>
                            <div>
                            <p>Sometimes one needs to send a few SMS. Doesn&#39;t matter if it&#39;s because you have a <a href="https://www.reddit.com/r/homelab/">homelab</a> and want to send system alerts, or you built <a href="https://blog.haschek.at/2016/my-door-sends-me-chat-messages.html">your own alarm system</a> and want notifications, or whether you are a programmer that wants to validate phone numbers. SMS is still the ultimate push notification system.</p>
<p>But for most of the scenarios mentioned above you might not rely on external sms gateways or APIs because they should also work if your internet goes out. Especially if you&#39;re building an alarm system because it should also be able to notify you when the power goes out.</p>
<p>The obvious solution is of course</p>

<figure><img loading="lazy" src="https://pictshare.net/1024/x9haua.png"/><figcaption>The result of this project. A fully functioning REST API capable of sending and receiving messages</figcaption></figure>
<p>But how does one build such a system with minimal investments? Let&#39;s find out!</p>

<hr/>

<ul>
<li><a href="#step1">Step 1: Preparing the Pi</a></li>
<li><a href="#step2">Step 2: Setting up Gammu</a></li>
<li><a href="#step3">Step 3: Making an API for sending and receiving SMS</a>
<ul>
<li><a href="#api">The API</a></li>
</ul></li>
<li><a href="#faq">FAQ</a></li>
</ul>

<h2>1. A Raspberry Pi</h2>
<figure><img loading="lazy" src="https://pictshare.net/1024/y6h1pb.png"/><figcaption>Raspberry Pis</figcaption></figure>
<p>It doesn&#39;t matter which one you can even use the original from 2007.</p>
<p>As for the operating system: you can use Raspian or <a href="https://www.alpinelinux.org/">Alpine Linux</a> (or actually any other system for that matter we just need a few easily available packages). I&#39;ll be using Alpine because it runs from a ramdisk so it won&#39;t corrupt the SD card on power loss but I&#39;ll explain all steps also for the raspberry pi OS</p>
<h2>2. A USB 3g/4g Dongle</h2>
<figure><img loading="lazy" src="https://pictshare.net/jh8xii.jpg"/><figcaption>Huawei E303 Dongle</figcaption></figure>
<p>I&#39;ll be using the <a href="https://www.aliexpress.com/item/1005002232840070.html">Huawei E303</a>. Not all USB dongles will work but most Huawei from the series are pretty cheap and easily available. If you already have a 3g dongle you can Google the model combined with &#34;raspberry pi&#34; to be sure.</p>
<p>Obviously you&#39;ll also need a SIM card with some kind of plan capable of sending SMS messages.</p>


<p>I&#39;ll assume that you already have the pi running and can run commands on it whether via ssh or the desktop interface.</p>
<p>We&#39;ll need the following packages:</p>
<p>On Alpine: <code>apk add gammu gammu-smsd php php-json usb-modeswitch usbutils git</code>
On Raspian: <code>apt install gammu gammu-smsd php php-json usb-modeswitch git</code></p>
<p>Most of the USB dongles are by default in <strong>storage mode</strong> and we need to switch it into <strong>modem mode</strong>. To check if this is true for your dongle plug it into a desktop computer and if the system mounts the dongle as usb storage (usually with an installer for the software and drivers) you know you&#39;ll need to modeswitch it.</p>
<p>Modeswitch is a bit different for every model (again: Google might help with yours) but for me this command works like charm:</p>
<pre><code>usb_modeswitch -W -v 12d1 -p 14fe -K -P 14ac -M &#34;55534243000000000000000000000011060000000000000000000000000000&#34;</code></pre>
<p><code>lsusb</code> returns <code>Bus 001 Device 005: ID 12d1:1c05 HUAWEI HUAWEI Mobile</code>. <strong>12d1</strong> is the vendor code for Huawei and the string after that (<strong>1c05</strong> in my case) is the product ID. We&#39;re telling modeswitch</p>
<p>Check out the <a href="https://wiki.archlinux.org/title/Huawei_E173s">arch wiki</a> or the <a href="https://wiki-ubuntuusers-de.translate.goog/USB_ModeSwitch/?_x_tr_sl=de&amp;_x_tr_tl=en&amp;_x_tr_hl=de">Ubuntuusers wiki</a>s. They should get you through modeswitching yours.</p>
<p>You know it worked when you your system created <code>/dev/ttyUSB0</code></p>
<pre><code>pi:~# ls -al /dev/ttyUSB0
crw-rw----    1 root     dialout   188,   0 Dec  3 12:10 /dev/ttyUSB0</code></pre>
<p>That&#39;s it! The pi is prepared for the heart of the project.</p>


<p>Wait, what is Gammu? In the words of the developers </p>
<blockquote>
<p>Gammu command line utility provides access to wide range of phone features.</p>
<ul>
<li>Gammu devs <a href="https://wammu.eu/gammu/">https://wammu.eu/gammu/</a></li>
</ul>
</blockquote>
<p>They have already done all the heavy lifting with parsing messages and sending it out to the carrier. We just need to tell gammu how it can talk to the dongle we set up in step 1 and it will handle the rest.</p>
<p>To see if your dongle is recognized run <code>gammu idenitfy</code>. The output should look something like this</p>
<pre><code>vpnpi:~# gammu identify
Device               : /dev/ttyUSB0
Manufacturer         : Huawei
Model                : E303 (E303)
Firmware             : 21.157.01.00.199
IMEI                 : 860000000000619
SIM IMSI             : 230000000000006</code></pre>
<p>Great, now let&#39;s create a config file with the following content and store it in <code>/etc/gammurc</code></p>
<pre><code>[gammu]
device = /dev/ttyUSB0
name = Bob
connection = at
logfile = /var/log/gammu.log

[smsd]
service = files
logfile = syslog
#PIN = 1234
# Increase for debugging information
debuglevel = 0
# Paths where messages are stored
inboxpath = /var/spool/gammu/inbox/
outboxpath = /var/spool/gammu/outbox/
sentsmspath = /var/spool/gammu/sent/
errorsmspath = /var/spool/gammu/error/</code></pre>
<p>The name can be freely chosen, I chose bob because that&#39;s the name of my carrier.</p>
<p>If your SIM requires a pin you can set it under the [smsd] part.</p>
<h2>Quick SMS test</h2>
<p>To test if everything so far worked and you are able to send SMS just enter <code>echo &#34;some message&#34; | gammu --sendsms TEXT 0664xxxxxxx</code></p>
<p>Obviously you&#39;ll have to replace the number with your phone number.</p>
<pre><code>vpnpi:~# echo &#34;Hello from your Pi&#34; | gammu --sendsms TEXT 0664xxxxxxx
If you want break, press Ctrl+C…
Sending SMS 1/1…waiting for network answer..OK, message reference=22</code></pre>
<figure><img loading="lazy" src="https://pictshare.net/j6dlsn.png"/><figcaption>SMS received successfully</figcaption></figure>
<p>It worked! I got the message on my phone.</p>
<p>You could stop here and automate things over the command line but I wanted to send and receive messages via an API that can be called from my whole home network so I&#39;ll add two more steps</p>


<p>We have been using the gammu command to send SMS messages but receiving them is not as straight forward and hard to automate. At least it would be, had  the creators of gammu not also written gammu-smsd</p>
<h2>gammu-smsd</h2>
<p>Again the developers explain it best</p>
<blockquote>
<p>Gammu SMS Daemon is a program that periodically scans GSM modem for received messages, stores them in defined storage and also sends messages enqueued in this storage.
It is perfect tool for managing big amounts of received or sent messages and automatically process them.</p>
<ul>
<li>Gammu developers <a href="https://wammu.eu/smsd/">https://wammu.eu/smsd/</a></li>
</ul>
</blockquote>
<p>So it&#39;s basically a daemon that waits for new incoming or outgoing messages.</p>
<p>Since our gammu config from before already includes everything for gammu-smsd all that&#39;s left is to create the folders where gammu is going store the data.</p>
<pre><code>mkdir -p /var/spool/gammu/inbox/
mkdir -p /var/spool/gammu/outbox/
mkdir -p /var/spool/gammu/sent/
mkdir -p /var/spool/gammu/error/</code></pre>
<h3>Sending Messages</h3>
<p>Now we just need to start gammu-smsd in daemon mode (meaning it&#39;s going to run in the background) and point it to the config file we created earlier</p>
<pre><code>gammu-smsd -d -c /etc/gammurc</code></pre>
<p>Since we&#39;re now have the gammu-smsd daemon talking to the dongle we can no longer use the gammu command from before to send SMS messages. We still can send them though using the command <code>gammu-smsd-inject</code> which is designed to work with the smsd daemon and just injects the messages into a local queue where it&#39;s then sent by the daemon.</p>
<p>The full example to send SMS messages now would be</p>
<p><code>gammu-smsd-inject TEXT 0664xxxxxxx -unicode -text &#34;hello world from the daemon!&#34;</code></p>
<figure><img loading="lazy" src="https://pictshare.net/09ptgx.png"/><figcaption>SMS received</figcaption></figure>
<p>And again we recieve it. This time it might take a few seconds longer because the daemon seems to wait a specific time before checking the queue for outgoing messages.</p>
<pre><code>pi:~# gammu-smsd-inject TEXT 0664xxxxxxx -unicode -text &#34;hello world from the daemon!&#34;
gammu-smsd-inject[2964]: Warning: No PIN code in /etc/gammu-smsdrc file
gammu-smsd-inject[2964]: Created outbox message OUTC20211203_193330_00_0664xxxxxxx_sms0.smsbackup
Written message with ID /var/spool/gammu/outbox/OUTC20211203_193330_00_0664xxxxxxx_sms0.smsbackup</code></pre>
<h3>Receiving messages</h3>
<p>Okay now it&#39;s time to send some message back and see if  it registers on the device. Just answer on one of the messages you got before and if everything worked, it should appear in /var/spool/gammu/inbox/ as a file.</p>
<p>Wait a few seconds and then check the folder for contents</p>
<pre><code>pi:~# ls /var/spool/gammu/inbox/
IN20211203_194458_00_+43664xxxxxxx_00.txt

pi:~# cat /var/spool/gammu/inbox/IN20211203_194458_00_+43664xxxxxxx_00.txt
Hello also from the outside world!</code></pre>
<p>So each message is contained in its own file. You can guess that the file name <code>IN20211203_194458_00_+43664xxxxxxx_00.txt</code> includes the date,  time, phone number of the sender and a part number (for sms longer than 140 characters as they will be split up).</p>


<p>We want a simple way to send and receive sms via API without installing hundreds of plugins and packages. I&#39;ve written a two very slick php scripts that will do just that.</p>
<p>Get it at <a href="https://github.com/geek-at/gammu-php">https://github.com/geek-at/gammu-php</a></p>
<p>Make sure gammu-smsd is already running as the script won&#39;t work without it.</p>
<p>Then from the directory where the two php files (<code>send.php</code> and <code>get.php</code>) are stored, run <code>php -S 0.0.0.0:8080</code> which will serve the two files to anyone on the network.</p>
<h2>Sending SMS with the API</h2>
<p>Is really straight forward. Just call <code>http://ip.of.your.pi/send.php?phone=0664xxxxxxx&amp;text=Testmessage</code></p>
<p>Which will return a JSON object indicating if it failed (status:error), or succeeded (status:ok)</p>
<pre><code>{
  &#34;status&#34;: &#34;ok&#34;,
  &#34;log&#34;: &#34;2021-12-04 15:43:39\ngammu-smsd-inject TEXT 0664xxxxxxx -unicode -text &#39;Testmessage&#39;\ngammu-smsd-inject[2669]: Warning: No PIN code in /etc/gammu-smsdrc file\ngammu-smsd-inject[2669]: Created outbox message OUTC20211204_164340_00_0664xxxxxxx_sms0.smsbackup\nWritten message with ID /var/spool/gammu/outbox/OUTC20211204_164340_00_0664xxxxxxx_sms0.smsbackup\n\n\n&#34;
}</code></pre>
<h2>Receiving SMS with the API</h2>
<p>Is also very simple. Just call <code>http://ip.of.your.pi/get.php</code></p>
<p>And it will return you all messages also in a JSON object</p>
<pre><code>curl -s http://ip.of.your.pi/get.php | jq .
[
  {
    &#34;id&#34;: &#34;f0a7789a657bb34eddd17c8e64609c48&#34;,
    &#34;timestamp&#34;: 1638636342,
    &#34;year&#34;: &#34;2021&#34;,
    &#34;month&#34;: &#34;12&#34;,
    &#34;day&#34;: &#34;04&#34;,
    &#34;time&#34;: &#34;16:45&#34;,
    &#34;test&#34;: &#34;04.12.2021 16:45:42&#34;,
    &#34;sender&#34;: &#34;+43664xxxxxxx&#34;,
    &#34;message&#34;: &#34;Hello bob!&#34;
  },
  {
    &#34;id&#34;: &#34;c358d0a4ca868c1d7d2eedab181eddd6&#34;,
    &#34;timestamp&#34;: 1638636414,
    &#34;year&#34;: &#34;2021&#34;,
    &#34;month&#34;: &#34;12&#34;,
    &#34;day&#34;: &#34;04&#34;,
    &#34;time&#34;: &#34;16:46&#34;,
    &#34;test&#34;: &#34;04.12.2021 16:46:54&#34;,
    &#34;sender&#34;: &#34;+43664xxxxxxx&#34;,
    &#34;message&#34;: &#34;Hello &#34;
  }
]</code></pre>
<p>Great now you can integrate sending and receiving SMS messages into your projects. Let me know if you want me to feature something you have built on top of this project.</p>


<h2><strong>Q: Why the PHP scripts and not gammu-python?</strong></h2>
<p><strong>A:</strong>
I wanted the smallest possible footprint. I tried a few python implementations and none were as straight forward and easy to use without compiling hundreds of sub-packages. Also my pi was running out of ram compiling some of then and it was just faster to write a small PHP script than optimize the python packages.</p>
<h2><strong>Q: What if a user sends a long SMS message?</strong></h2>
<p><strong>A:</strong>
The API can handle parted messages even if there is another sms in the queue between it. So it should work out of the box as the API stitches it back together.</p>
<h2><strong>Q: What about MMS?</strong></h2>
<p><strong>A:</strong>
MMS or Multimedia Messages are supported by gammu but they are stored in a binary format I have yet to find documentation on how to make something usable out of it for download. Any info in it is greatly appreciated.</p>
                            </div>
                        </div>
                    </div></article></div>
  </body>
</html>
