<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jetbrains.com/ruby/2024/12/mastering_ruby_debugging/">Original</a>
    <h1>Mastering Ruby debugging: From puts to professional tools</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
    <div>
    <div>
        <div>
            <div>
                                    <div>
                        <a href="https://blog.jetbrains.com/ruby/">
                            <img src="https://blog.jetbrains.com/wp-content/uploads/2019/01/RubyMine-1.svg" alt="Ruby logo"/>
                                                                                                
                                                                                    </a>
                                                    <p>Intelligent Ruby and Rails IDE</p>
                                            </div>
                            </div>
            
        </div>
                
                                </div>
</div>
                            <section data-clarity-region="article">
                <div>
                    				<p><a href="https://blog.jetbrains.com/ruby/category/rubymine/">RubyMine</a></p>                    <div>
                                                
                        <div><p data-nosnippet="">Read this post in other languages:</p></div>                    </div>
                    
<p>Hello, Ruby developers!</p>



<p>Debugging is an essential skill in software development, and in this post, we’ll be looking at how to investigate the behavior of Ruby code. As the RubyMine team, we’ve accumulated considerable expertise in creating tools for Ruby developers, and we’re excited to share our experience and knowledge with you.</p>



<p>Recently, at the EuRuKo 2024 conference, our team member Dmitry Pogrebnoy presented the <em><a href="https://2024.euruko.org/speakers/dmitry_pogrebnoy" data-type="link" data-id="https://2024.euruko.org/speakers/dmitry_pogrebnoy" target="_blank" rel="noopener">Demystifying Debuggers</a></em> talk. This blog post is the first in a series based on that presentation, aiming to provide you with valuable insights into debugging Ruby applications.</p>



<p>Every Ruby programmer inevitably encounters situations where their code doesn’t behave as expected. In these moments, we all wish we had an efficient way to pinpoint the problem and fix it quickly. That’s where debugging tools come into play.</p>



<p>In this post, we’ll explore various tools and approaches available to Ruby developers for investigating bugs. We’ll cover several classes of tools, each with its own strengths and weaknesses. Understanding the specifics of each tool will help you choose the most effective one for your particular debugging scenario.</p>



<p>To make our discussion more concrete, we’ll start with a real-world example of a bug we encountered in one of our internal Ruby projects. This case study will illustrate the importance of proper debugging techniques and set the stage for our exploration of debugging tools.</p>



<p>Whether you’re a seasoned Ruby developer or just starting out, this guide will help you sharpen your debugging skills and tackle bugs more efficiently. Let’s get started!</p>



<h2>A real bug case from the RubyMine team</h2>



<p>In the RubyMine team, our development efforts extend beyond the IDE itself. We’ve created several proprietary gems that enhance the IDE’s functionality. To share some insights, we’ll explore a real-world bug we encountered in one of these gems about a year ago. We’ve isolated and simplified the code sample to focus on the core issue.</p>



<p>Consider the following Ruby code:</p>



<pre>def process(thing)
 if defined? thing.to_s || defined? thing.inspect
   puts &#34;Element is Printable&#34;
 else
   puts &#34;Element is Not Printable&#34;
 end
end

process(5)               # -&gt; Element is Printable
process(BasicObject.new) # -&gt; Element is Printable</pre>



<p>At first glance, this <code>process</code> method seems straightforward. It aims to check whether the given argument has either a <code>to_s</code> or an <code>inspect</code> method. If either method exists, <code>process</code> should print “Element is Printable”; otherwise, it prints “Element is Not Printable”.</p>



<p>At the bottom, you can see two calls of this method with their outputs. The first call <code>process(5)</code> produces the message “Element is Printable”. This is correct. But the second call <code>process(BasicObject.new)</code> looks suspicious. It takes <code>BasicObject</code> as an argument, but prints “Element is Printable”. This is incorrect because the <code>BasicObject</code> instance does not respond to either of the methods we are looking for. So apparently this code contains a bug.</p>



<p>Let’s take a moment to examine the <code>process</code> method. Can you spot the bug?</p>



<details><summary>Spoiler – click to expand!</summary>
<p>The bug lies in the <code>if</code> condition:</p>



<p> <code>defined? thing.to_s || defined? thing.inspect</code></p>



<p>Due to Ruby’s operator precedence, the interpreter actually evaluates this as:</p>



<pre>defined?(thing.to_s || defined?(thing.inspect))</pre>



<p>This expression always returns “expression”, regardless of whether <code>thing</code> responds to <code>to_s</code> or <code>inspect</code>. As a result, the condition is always true, and our method incorrectly classifies every object as printable.</p>



<p>The fix is simple but illustrative of how small syntax errors can lead to significant logical flaws. We need to explicitly structure our conditions using parentheses:</p>



<pre>def process(thing)
 if defined?(thing.to_s) || defined?(thing.inspect)
   puts &#34;Element is Printable&#34;
 else
   puts &#34;Element is Not Printable&#34;
 end
end

process(5)               # -&gt; Element is Printable
process(BasicObject.new) # -&gt; Element is Not Printable</pre>



<p>With this correction, our method now accurately distinguishes between objects that implement <code>to_s</code> or <code>inspect</code> and those that don’t.</p>
</details>







<p>By sharing this real-world example, we hope to demonstrate that debugging is a crucial skill for all developers, regardless of experience level. It’s not just about fixing errors; it’s about understanding the intricacies of the language and writing more reliable code.</p>



<p>In more complex, production-level applications, such issues can be far more challenging to identify and resolve. This underscores the importance of robust debugging tools and techniques, which we’ll explore in the following sections.</p>



<h2>Choosing the right tool</h2>



<p>When it comes to debugging Ruby code, developers have several tools and approaches at their disposal. Let’s explore these options, starting with the basics and then moving on to more advanced techniques.</p>



<h3>puts statements</h3>



<p>The most basic debugging technique, requiring no setup or additional gems, is using <code>puts</code> statements. This method involves inserting print statements directly into your code to output variable values or execution flow information. While simple, it can be surprisingly effective for quick investigations.</p>



<p>Let’s apply this technique to our earlier example:</p>



<pre>def process(thing)
 puts &#34;defined? thing.to_s: #{defined? thing.to_s}&#34;
 puts &#34;defined? thing.inspect: #{defined? thing.inspect}&#34;
 puts &#34;defined? thing.to_s || defined? thing.inspect: #{
   defined? thing.to_s || defined? thing.inspect
 }&#34;
 if defined? thing.to_s || defined? thing.inspect
   puts &#34;Element is Printable&#34;
 else
   puts &#34;Element is Not Printable&#34;
 end
end

process(5)
process(BasicObject.new)</pre>



<p>This yields the following output:</p>



<pre>defined? thing.to_s: method
defined? thing.inspect: method
defined? thing.to_s || defined? thing.inspect: expression
Element is Printable
defined? thing.to_s: 
defined? thing.inspect: 
defined? thing.to_s || defined? thing.inspect: expression
Element is Printable</pre>



<p>The inconsistent output from these two methods calls with different arguments hints at where the problem might lie. We can see that, for <code>BasicObject.new</code>, both <code>thing.to_s</code> and <code>thing.inspect</code> are undefined, yet the condition still evaluates to <code>true</code>.</p>



<p>While basic <code>puts</code> statements are useful, several gems can make them more informative:</p>



<p>1. <code><a href="https://github.com/AndyObtiva/puts_debuggerer" data-type="link" data-id="https://github.com/AndyObtiva/puts_debuggerer" target="_blank" rel="noopener">puts_debuggerer</a></code> gem enhances <code>puts</code> output with the file name, line number, and content of this line.</p>



<p>For example:</p>



<pre>require &#39;puts_debuggerer&#39;
pd &#34;defined? thing.to_s: #{defined? thing.to_s}&#34;</pre>



<p>Output:</p>



<pre>[PD] example_puts_debuggerer.rb:5 in Object.process
   &gt; pd &#34;defined? thing.to_s: #{defined? thing.to_s}&#34;
  =&gt; &#34;Debug print 1: method&#34;</pre>



<p>2. <code><a href="https://github.com/awesome-print/awesome_print" data-type="link" data-id="https://github.com/awesome-print/awesome_print" target="_blank" rel="noopener">awesome_print</a></code> and similar gems provide more structured and readable output, especially useful for complex objects.</p>



<p>Generally <code>puts</code> statements are useful and might effectively help you with simple cases or when other tools don’t work for some reason. However, <code>puts</code> statements are really basic. They require modifying your source code every time you need to adjust an existing message or add a new one. They are usually not convenient to use because you need to restart the program whenever you modify what you are printing. </p>



<h4>Pros and cons of debugging using <code>puts</code></h4>



<p>Pros:</p>



<ul>
<li>Simple and quick to implement.</li>



<li>Works in any Ruby environment.</li>



<li>No additional tools or setup are required.</li>
</ul>







<p>Cons:</p>



<ul>
<li>Requires modifying source code.</li>



<li>Can clutter the code if overused.</li>



<li>Forces you to restart the program if you want to change what you print.</li>



<li>Limited information compared to more advanced tools.</li>
</ul>







<p>While <code>puts</code> statements are invaluable for quick checks, they become less efficient for complex scenarios or when frequent changes are needed. In such cases, more advanced tools like interactive consoles or full-fledged debuggers offer greater flexibility and power.</p>



<h3>Interactive consoles</h3>



<p>Interactive consoles represent the next level in bug investigation tools for Ruby developers. The two primary options are <a href="https://github.com/ruby/irb" data-type="link" data-id="https://github.com/ruby/irb" target="_blank" rel="noopener">IRB</a> and <a href="https://github.com/pry/pry" data-type="link" data-id="https://github.com/pry/pry" target="_blank" rel="noopener">Pry</a>, both offering powerful introspection capabilities.</p>



<p>To utilize interactive consoles for debugging, you typically need to insert <code>binding.irb</code> or <code>binding.pry</code> calls into your source code. When the binding command is executed, an interactive console launches, providing access to the current context and the ability to execute arbitrary expressions in this context.</p>



<p>Let’s use IRB in our earlier example:</p>



<pre>def process(thing)
 binding.irb
 if defined? thing.to_s || defined? thing.inspect
   puts &#34;Element is Printable&#34;
 else
   puts &#34;Element is Not Printable&#34;
 end
end

process(5) # -&gt; Element is Printable
process(BasicObject.new) # -&gt; Element is Printable</pre>



<p>When the code hits the <code>binding.irb</code> line, we’ll enter an interactive session:</p>



<pre>From: 5_example_define_irb.rb @ line 2 :

    1: def process(thing)
 =&gt; 2:   binding.irb
    3:   if defined? thing.to_s || defined? thing.inspect
    4:     puts &#34;Element is Printable&#34;
    5:   else
    6:     puts &#34;Element is Not Printable&#34;
    7:   end

irb(main):001&gt; defined? thing.to_s
=&gt; nil
irb(main):002&gt; defined? thing.inspect
=&gt; nil
irb(main):003&gt; defined? thing.to_s || defined? thing.inspect
=&gt; &#34;expression&#34;
irb(main):004&gt; exit
Element is Printable</pre>



<p>This interaction allows us to examine the behavior of the condition’s individual parts, helping to pinpoint the issue.</p>



<h4>Pros and cons of debugging using interactive consoles</h4>



<p>Pros:</p>



<ul>
<li>More complex and flexible than <code>puts</code> statements.</li>



<li>Partially allows for on-the-fly investigation.</li>



<li>No need to predetermine all debugging output.</li>
</ul>







<p>Cons:</p>



<ul>
<li>Still requires source code modification.</li>



<li>Requires you to set predefined introspection points that cannot be changed at runtime.</li>



<li>Forces you to restart the program if you want to change introspection points.</li>
</ul>







<p>While interactive consoles offer more power than simple <code>puts</code> statements, they still have limitations. For complex debugging scenarios or when fine-grained control over execution is needed, full-featured debuggers provide even more capabilities.</p>



<h3>Debuggers</h3>



<p>Debuggers represent the pinnacle of tools available for investigating bugs in Ruby code. They offer capabilities far beyond simple <code>puts</code> statements and interactive consoles, providing full control over program execution. This powerful feature set allows developers to:</p>



<ul>
<li>Pause execution at a specified point using breakpoints.</li>



<li>Inspect and modify variables in real time.</li>



<li>Examine the call stack at every breakpoint.</li>



<li>Step through code line by line.</li>



<li>Evaluate expressions in the current context.</li>
</ul>







<p>Let’s explore the three main debuggers for Ruby:</p>



<p>1. <a href="https://github.com/deivid-rodriguez/byebug" target="_blank" rel="noopener"><code>byebug</code> gem</a></p>



<ul>
<li>Default debugger for Ruby 2.5.X, Ruby 2.6.X, Rails 5, and Rails 6.</li>



<li>Comes with all the essential features you’d expect from a debugger like breakpoints, stepping, context, and stack introspection.</li>



<li>For Rails applications, it requires modification of the application source code. You usually need to place a special call in your code to start the debugger at a certain place.</li>



<li>Has noticeable performance overheads that make it less usable for complicated applications.</li>
</ul>







<p>2. <a href="https://github.com/ruby/debug" target="_blank" rel="noopener"><code>debug</code> gem</a></p>



<ul>
<li>Supports only Ruby versions starting from 2.7.</li>



<li>Has no performance overheads on supported Ruby versions.</li>



<li>For Rails applications, <code>debug</code>, similar to <code>byebug</code>, requires modification of the application source code.</li>



<li>Bundled with Ruby starting from version 3.1.</li>
</ul>







<p>3. <a href="https://www.jetbrains.com/help/ruby/debugging-code.html" target="_blank" rel="noopener">RubyMine debugger</a></p>



<ul>
<li>Supports Ruby versions 2.3 and later – so almost all possible versions of Ruby your application could use.</li>



<li>Has no performance overheads on any of the supported versions of Ruby.</li>



<li>No need to modify the code to use the debugger.</li>



<li>Provides a user-friendly UI out of the box that streamlines debugging.</li>
</ul>







<p>Despite its extensive feature set, debuggers might be difficult to use in some specific configurations. While debuggers are powerful, they’re most effective when combined with other debugging techniques. The choice of debugger often depends on your specific project and configuration requirements, Ruby version, and personal preferences.</p>



<h2>Conclusion</h2>



<p>Debugging in Ruby is both an art and a science, presenting challenges that can be overcome with the right tools. As we’ve explored in this post, Ruby developers have a rich toolkit at their disposal, ranging from simple <code>puts</code> statements to sophisticated debuggers.</p>



<p>Each debugging approach we’ve discussed has its strengths:</p>



<ul>
<li><code>puts</code> statements offer quick, straightforward insights, ideal for simple issues or when other tools are unavailable.</li>



<li>Interactive consoles like IRB and Pry provide a more dynamic environment, allowing for deep context introspection and complex expression evaluation.</li>



<li>Full-fledged debuggers, such as the <code>byebug</code> and <code>debug</code> gems, as well as the RubyMine debugger, offer comprehensive control over program execution, enabling developers to dissect even the most intricate bugs.</li>
</ul>







<p>The journey from encountering an unexpected bug to pinpointing its exact cause often requires a combination of these tools, along with methodical investigation and sometimes a bit of creative problem-solving. By understanding the strengths and limitations of each debugging tool, you can select the most appropriate approach for each unique situation.</p>



<p>As the RubyMine team, we’re particularly interested in how our debugging tools serve the Ruby community. We encourage you to explore the RubyMine debugger and share your experiences in the comments below or create an issue in the <a href="https://youtrack.jetbrains.com/issues/ruby" target="_blank" rel="noopener">issue tracker</a>. Your fellow developers will surely appreciate your insight.</p>



<p>Looking ahead, our next post will delve deeper into the inner workings of debuggers. We’ll explore their internal mechanisms and even tackle an exciting challenge: creating a basic debugger from scratch. This exploration will enhance your understanding of debugging tools and provide deeper insights into Ruby’s internals.</p>



<p>Meanwhile, take advantage of the advanced debugger in RubyMine. <a href="https://www.jetbrains.com/ruby/download/" target="_blank" rel="noopener">Download</a> the latest RubyMine version from our website or via the free <a href="https://www.jetbrains.com/toolbox/app/" target="_blank" rel="noopener">Toolbox App</a>.</p>



<p>Remember, effective debugging is more than just finding and fixing errors – it’s about understanding your code at a fundamental level. Each debugging session is an opportunity to learn, improve, and write more robust Ruby code.</p>







<p>Stay curious, keep exploring, and happy debugging!</p>



<p>The RubyMine team</p>
                    
                                                                                                                                                                                                                            <div>
                                <div>
                                                                            <h4>Subscribe to RubyMine Blog updates</h4>
                                                                                                            
                                </div>
                                
                                <p><img src="https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg" alt="image description"/>
                                                                    </p>
                            </div>
                                                            </div>
                <a href="#"></a>
                
                
            </section>
                    
                </div></div>
  </body>
</html>
