<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://steveklabnik.com/writing/is-rust-faster-than-c/">Original</a>
    <h1>Is Rust faster than C?</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content">  <article>  <time datetime="2025-06-09T00:00:00.000Z"> Jun 9, 2025 </time>  <p>Someone on Reddit recently asked:</p>
<blockquote>
<p>What would make a Rust implementation of something faster than a C
implementation, all things being the same?</p>
</blockquote>
<p>I think this is a great and interesting question! It’s really tough because it
ultimately relies on what exactly you mean by “all things being the same.” And I
think this is something that makes it hard to compare languages.</p>
<p>Here’s some ways in which you can argue that things are “the same” but also,
that they’re not, and what they imply for runtime performance.</p>
<h2 id="inline-assembly">Inline Assembly</h2>
<p>Rust has inline assembly built into the language. C has inline assembly as a
very common compiler extension, to the degree where saying it’s not part of the
language is an arguable nitpick.</p>
<p>Here’s an example in Rust:</p>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> std</span><span>::</span><span>arch</span><span>::</span><span>asm;</span></span>
<span></span>
<span><span>#[</span><span>unsafe</span><span>(no_mangle)]</span></span>
<span><span>pub</span><span> fn</span><span> rdtsc</span><span>() </span><span>-&gt;</span><span> u64</span><span> {</span></span>
<span><span>    let</span><span> lo</span><span>:</span><span>  u32</span><span>;</span></span>
<span><span>    let</span><span> hi</span><span>:</span><span>  u32</span><span>;</span></span>
<span><span>    unsafe</span><span> {</span></span>
<span><span>        asm!</span><span>(</span></span>
<span><span>            &#34;rdtsc&#34;</span><span>,</span></span>
<span><span>            out</span><span>(</span><span>&#34;eax&#34;</span><span>) lo,</span></span>
<span><span>            out</span><span>(</span><span>&#34;edx&#34;</span><span>) hi,</span></span>
<span><span>            options</span><span>(nomem, nostack, preserves_flags),</span></span>
<span><span>        );</span></span>
<span><span>    }</span></span>
<span><span>    ((hi </span><span>as</span><span> u64</span><span>) </span><span>&lt;&lt;</span><span> 32</span><span>) </span><span>|</span><span> (lo </span><span>as</span><span> u64</span><span>)</span></span>
<span><span>}</span></span></code></pre>
<p>This reads the time stamp counter with <code>rdtsc</code>, and returns its value.</p>
<p>Here’s the example in C:</p>
<pre tabindex="0" data-language="c"><code><span><span>#include</span><span> &lt;stdint.h&gt;</span></span>
<span></span>
<span><span>uint64_t</span><span> rdtsc</span><span>(</span><span>void</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    uint32_t</span><span> lo, hi;</span></span>
<span><span>    __asm__</span><span> _</span><span>_volatile__</span><span> (</span></span>
<span><span>        &#34;rdtsc&#34;</span></span>
<span><span>        : </span><span>&#34;=a&#34;</span><span>(lo), </span><span>&#34;=d&#34;</span><span>(hi)</span></span>
<span><span>    );</span></span>
<span><span>    return</span><span> ((</span><span>uint64_t</span><span>)hi </span><span>&lt;&lt;</span><span> 32</span><span>) </span><span>|</span><span> lo;</span></span>
<span><span>}</span></span></code></pre>
<p>These (under <code>-0</code> in both rustc <code>1.87.0</code> and clang <code>20.1.0</code>) produce the same
assembly:</p>
<pre tabindex="0" data-language="asm"><code><span><span>rdtsc</span><span>:</span></span>
<span><span>        rdtsc</span></span>
<span><span>        shl</span><span>     rdx</span><span>, </span><span>32</span></span>
<span><span>        mov</span><span>     eax</span><span>, </span><span>eax</span></span>
<span><span>        or</span><span>      rax</span><span>, </span><span>rdx</span></span>
<span><span>        ret</span></span></code></pre>
<p>Here’s a link on Godbolt: <a href="https://godbolt.org/z/f7K8cfnx7">https://godbolt.org/z/f7K8cfnx7</a></p>
<p>Does this count? I don’t know. I don’t think it really speaks to the question
asked, but it is one way to answer the question.</p>
<h2 id="similar-code-different-results">Similar code, different results</h2>
<p>Rust and C can have different semantics for similar code. Here’s a struct in
Rust:</p>
<pre tabindex="0" data-language="rust"><code><span><span>struct</span><span> Rust</span><span> {</span></span>
<span><span>    x</span><span>:</span><span> u32</span><span>,</span></span>
<span><span>    y</span><span>:</span><span> u64</span><span>,</span></span>
<span><span>    z</span><span>:</span><span> u32</span><span>,</span></span>
<span><span>}</span></span></code></pre>
<p>Here’s “the same” struct in C:</p>
<pre tabindex="0" data-language="c"><code><span><span>struct</span><span> C {</span></span>
<span><span>    uint32_t</span><span> x;</span></span>
<span><span>    uint64_t</span><span> y;</span></span>
<span><span>    uint32_t</span><span> z;</span></span>
<span><span>};</span></span></code></pre>
<p>In Rust, this struct is 16 bytes (on x86_64, again) and in C, it is 24. This is
because Rust is free to reorder the fields to optimize for size, while C
is not.</p>
<p>Is this the same, or different?</p>
<p>In C, you can re-order the fields to get the same size. In Rust, you can write
<code>#[repr(C)]</code> to get the same layout as C. Does this mean we should have written
different Rust or different C to get “the same” thing?</p>

<p>Some people have reported that, thanks to Rust’s checks, they are more willing
to write code that’s a bit more dangerous than in the equivalent C (or C++),
where they’d do a bit more copying to play it a bit safer. This would be “the
same” in the sense of the same devs on the same project, but the code would be
different, due to judgement calls. You can make an argument that that’s not the
same, but is different too.</p>
<p>An example of this from a long time ago is the Stylo project. Mozilla tried to
parallelize Firefox’s style layout twice in C++, and both times the project
failed. The multithreading was too tricky to get right. The third time, they
used Rust, and managed to ship. This is the same project, (though not the same
programmers, I believe) by the same organization, but one was possible and one
was not. Is that “the same”? In some senses, but not in others.</p>
<p>This also goes for a similar question: assuming we have a junior developer
writing Rust, and also writing C, for the same task. Are we going to get faster
code in one or the other? This controls for ability, but not for the same code.
Is that “the same”? I don’t know. What about an expert in each language, someone
who knows Rust super well but doesn’t know C, and vice versa, being given the
same task? Is that different than a junior, or an “average” developer?</p>
<h2 id="compile-time-vs-runtime">Compile time vs runtime?</h2>
<p>Another redditor asks:</p>
<blockquote>
<p>I’m not Rust expert, but aren’t most (all?) of the safety checks compile time
checks? They shouldn’t have any runtime impact.</p>
</blockquote>
<p>A great question! Part of this is another example of defaults being different.</p>
<p><code>array[0]</code> is valid in both languages.</p>
<p>In Rust, there’s a bounds check at runtime. In C, there is not. Does this mean
that they’re the same? In Rust, I could write <code>array.get_unchecked(0)</code>, and get
C’s semantics. In C, I could write a bounds check to get Rust’s semantics. Are
any of those “the same”?</p>
<p>In Rust, that check may be optimized away, if the compiler can prove it’s safe.
In C, if we wrote the bounds check by hand, the check may be optimized away, if
the compiler can prove it’s safe. Are any of those “the same”?</p>
<p>They aren’t wrong that a lot of Rust’s safety checks are at compile time. But
some are at runtime. But this raises another interesting question: That compile-time
check may cause you to write different code for the same task as in C. A common
example is using indices rather than pointers. That may mean that the generated
code performs differently. Is that check truly “at compile time”? Technically,
at the micro level, yes. At the engineering level? Possibly not!</p>
<h2 id="my-conclusions">My Conclusions</h2>
<p>I think the most important part of this question is related to possibility, that
is:</p>
<ol>
<li>If we assume C is the ‘fastest language,’ whatever that means.</li>
<li>Is there any inherent reason why Rust could not do the same things?</li>
</ol>
<p>I think the answer to that is “no,” even ignoring the inline assembly case. So
on that most important, fundamental level, the answer is “there’s no difference
between the two.”</p>
<p>But we’re not usually talking about that. We’re usually talking about something
in the context of engineering, a specific project, with specific developers,
with specific time constraints, and so on. I think that there are so many
variables that it is difficult to draw generalized conclusions.</p>
<hr/>
<p>Here’s my post about this post on BlueSky:</p>
<bluesky-post src="at://did:plc:3danwc67lo7obz2fmdg6jxcr/app.bsky.feed.post/3lr6xouhoxc2i">  </bluesky-post>   </article>  </div></div>
  </body>
</html>
