<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dbohdan.com/fcron">Original</a>
    <h1>Fcron Is the Best Cron</h1>
    
    <div id="readability-page-1" class="page"><div>
          

          


          <div>

<p>Common <a href="https://en.wikipedia.org/wiki/Cron">cron</a> versions suffer from historical limitations, making it harder than necessary to set up recurring tasks the way you want. On this page, I enumerate some of the limitations, examine systemd timers as an alternative, and then explain why I use fcron.</p>
<h2 id="contents">Contents</h2>
<nav id="TOC" role="doc-toc">
<ul>
<li>
<a href="#cron-limitations">The limitations of cron</a>
</li>
<li>
<a href="#systemd-timers">systemd timers</a>
</li>
<li>
<a href="#fcron">fcron</a>
</li>
<li>
<a href="#systemd-timers-from-crontab">A better way to manage systemd timers?</a>
</li>
<li>
<a href="#see-also">See also</a>
</li>
</ul>
</nav>
<h2 id="cron-limitations">The limitations of cron</h2>
<p>Here are some limitations of cron that I have had to work around.</p>
<ul>
<li>Cron emails you if there is any output from the job, even if the job succeeds.</li>
<li>Vixie Cron has no way of running tasks at a random time within an interval. <code>RANDOM_DELAY</code>, present in some versions, is calculated once per daemon restart, not per job or per run. While this mitigates the <a href="https://en.wikipedia.org/wiki/Thundering_herd_problem">thundering herd problem</a> for identical machines, it does nothing for jobs on the same machine. I have arrived at prefixing demanding cron jobs with a command like <code>perl -e &#39;sleep rand(30 * 60)&#39;</code> or <code>sleep &#34;$( jot -r 1 0 $(( 30 * 60 )) )&#34;</code> in order to distribute system load.</li>
<li>Cron does not prevent another copy of the same job from running. Users work around this with locking, often with <a href="https://serverfault.com/questions/82857/prevent-duplicate-cron-jobs-running">flock(1)</a>, or <a href="https://ma.ttias.be/prevent-cronjobs-from-overlapping-in-linux/">scanning the process list with pgrep(1)</a>. When locking fails and leaves the lock file in place, the job won’t run. When scanning the process list fails, multiple copies of the job can run.</li>
<li>Cron can’t spread out heavy tasks. The user usually implements locking per-job.</li>
<li>Cron does not run jobs that were missed because the system wasn’t running. <a href="https://en.wikipedia.org/wiki/Anacron">anacron</a> addresses this—however, only for system-wide jobs. Users do not get their own anacrontab(5).</li>
<li>Commands are limited to a single line in cron. You <em>should</em> write scripts, but for a job that is two commands long, you probably won’t.</li>
</ul>
<h2 id="systemd-timers">systemd timers</h2>
<p>The leading alternative to cron is <a href="https://wiki.archlinux.org/title/systemd/Timers">systemd timers</a>. While timers address cron’s lack of randomization and locking, the first thing you notice about them is that they are less ergonomic. Timers require two <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">systemd unit files</a> per job. That timers separate the unit from the timer and use INI files with multi-word keys seems like reasonable software design, and yet the result is poor UX compared to crontab(5). Timers have no integrated support for email. They are also, of course, not cross-platform.</p>
<p><a href="https://github.com/amlamarra/timertab">timertab</a> removes some friction from creating new timers. However, after the creation stage you are left with the same two unit files to manage.</p>
<p>The systemd timer user experience may be a price well worth paying for commercial deployments. I want something different for jobs on my home machine.</p>
<h2 id="fcron">fcron</h2>
<p>I have found a more pleasant-to-use alternative to forks of Vixie Cron and systemd timers in <a href="http://fcron.free.fr/">fcron</a>. A project started in 2000 with a period website, fcron is ahead of every cron implementation I know. It addresses some of the weaknesses that lead users to switch to systemd timers, while still providing crontab(5)-style configuration.</p>
<p>The following are the main <a href="http://fcron.free.fr/doc/en/fcrontab.5.html">fcrontab(5)</a> features that I use.</p>
<ul>
<li><code>@ 1d</code> (an optional replacement for the date-time fields)—jobs can run daily (or every <em>N</em> minutes, hours, days, weeks, etc.), taking downtime into account.</li>
<li><code>serial</code> (per-job option)—only one <code>serial</code> job runs at a time by default. This limit can be increased, allowing fcron to run no more than a certain number of jobs rather than just one.</li>
<li><code>erroronlymail</code> (global option)—as the name suggests, only email the user if a job fails, regardless of whether it generates output.</li>
<li><code>mail(false)</code> (per-job option)—never send emails, even on errors. Useful if you have another way of monitoring a job.</li>
<li>Line continuations—your job does not have to fit on a single line.</li>
</ul>
<p>Fcron can also schedule jobs based on the system load average. I haven’t tried it.</p>
<p><a href="http://fcron.free.fr/doc/en/fcrondyn.1.html.">fcrondyn(1)</a> is an interactive shell included with fcron where you can examine, run, renice, and kill fcron jobs. It lets you run a job either as a one-off or instead of the next scheduled run. Jobs are referred to by a numeric job identifier. This is something of a disadvantage compared to systemd timers, which can be given meaningful names.</p>
<p>Fcron can import a Vixie Cron crontab. It is cross-platform. Many Linux distributions package it, and it has a port in the FreeBSD ports tree and MacPorts. (<a href="https://repology.org/project/fcron/versions">Repology</a>.) It can run via systemd on Linux.</p>
<h2 id="systemd-timers-from-crontab">A better way to manage systemd timers?</h2>
<p>It may be worth writing a program that completely manages systemd timers entrusted to it based on a crontab(5) variant. While there is a translator for <a href="https://github.com/systemd-cron/systemd-cron">Vixie crontabs</a>, the limitations of Vixie crontabs were the reason people started switching to systemd timers in the first place. You could instead translate a file format derived from fcrontab(5) or <a href="https://man.openbsd.org/crontab.5">OpenBSD crontab(5)</a>. OpenBSD crontab(5) has the options <code>-n</code> (no email if successful) and <code>-s</code> (only allow a single instance of the command) and will soon have random ranges. This set of features seems possible to translate in full. I think it covers what users want from timers for most jobs.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="https://www.admin-magazine.com/Archive/2019/54/Cron-alternatives-fcron-and-hcron">“Cron alternatives fcron and hcron”</a>, Anzela Minosi. ADMIN Magazine (2019)</li>
<li><a href="https://beepb00p.xyz/scheduler.html">“In search of a better job scheduler”</a>, karlicoss (2020). Examines cron, fcron, systemd, launchd, and other options. The author has since written their own job scheduler, <a href="https://github.com/karlicoss/dron">dron</a>.</li>
<li><a href="https://undeadly.org/cgi?action=article;sid=20230507122935">OpenBSD “<code>cron(8)</code> now supports random ranges with step”</a> (2023). OpenBSD’s cron is probably the best this side of fcron.</li>
</ul>


          </div> <!-- .markdown -->

          
        </div></div>
  </body>
</html>
