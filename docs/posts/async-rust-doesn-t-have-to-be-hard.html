<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://itsallaboutthebit.com/async-simple/">Original</a>
    <h1>Async Rust doesn&#39;t have to be hard</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  <div>
  	
  	
  	

    

  	<p>An article titled <a href="https://hirrolot.github.io/posts/rust-is-hard-or-the-misery-of-mainstream-programming.html">Rust Is Hard, Or: The Misery of Mainstream
Programming</a> came
out today and it&#39;s getting a lot of attention. I have a feeling that it&#39;s viewed
in a wrong context, so I&#39;d like to comment on the issue raised there.</p>
<p>A lot of the comments to the article are in a tone of &#34;this is precisely the
reason why I don&#39;t learn Rust, it&#39;s just too hard&#34; or &#34;just don&#39;t use async,
it&#39;s too hard, otherwise Rust is not that bad&#34;. So I&#39;ll start with a note for
all the people intimidated by the techniques the author is trying to use in
the post: when writing Rust code you almost never use this kind of stuff.
Especially when you&#39;re writing applications, as opposed to libraries. And
especially if you&#39;re not writing anything that is traditionally systems
programming, like a database or an operating system (and yes, Rust is great for
non systems programming too). I
really wish the author clearly pointed out that they write the article from a
point of view of a library author trying to come up with generic and flexible
APIs. Then maybe I wouldn&#39;t feel the need to write
a rebuttal and shake my head in disbielief reading some of the comments on HN or
Reddit. But here we are, I guess.</p>
<p>I&#39;ve been coding in Rust for a few years now and although I haven&#39;t done any
advanced stuff, I wrote quite a bit of async code. In fact I learned Rust doing
async, I wrote pretty much only async code when using Rust at work
(unfortunately only for a few months) and I still write mostly async code. In
the article I&#39;m responding to you can read:</p>
<blockquote>
<p>“Fearless concurrency” – a formally correct but nonetheless misleading statement. Yes, you no longer have fear of data races, but you have PAIN, much pain.</p>
</blockquote>
<p>What&#39;s going on here? Why is the language causing so much pain voted as &#34;the
most loved language&#34; for like 7 years in a row in the Stack Overflow survey. Is
it the Stockholm syndrome? Do Rust devs like pain? Or maybe it&#39;s a huge cult:
you get in and you try to lure in as many people as you can so they feel the
pain too.</p>
<p>The truth is: this is probably not the experience most people have with Rust.
It&#39;s definitely not the experience I have with Rust. In fact, it&#39;s vastly different.
Which doesn&#39;t mean Hirrolot is wrong, it just means they
have a different perspective and different experience, probably because of the stuff they
needed to implement in Rust.</p>
<p>Is Rust totally painless? Of course not, I had my fair share of fights with the
compiler to try to make code compile. I definitely get frustrated from time
to time, but as a professional developer I can stomach <em>a lot</em> of compile time
frustration. I have much less tolerance for runtime frustration. Or in other
words: I prefer to spend a few hours being frustrated at a compiler rather than
a few hours debugging a production issue under pressure. This is a tradeoff, for
sure, so your milage may vary, but that&#39;s just where I&#39;m standing after 17 years
or so in the industry.</p>
<h3 id="async-code-in-applications">async code in applications</h3>
<p>While I definitely agree async adds complexity to Rust and if you don&#39;t need it,
it will be most probably easier to not use it, I don&#39;t think it&#39;s practical
to outright recommend not using async at all. But the question is: what do you
use async for? Most of the time it would be probably something like a web
service. And then most of the time your code will look something like:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>#[</span><span>get</span><span>(&#34;</span><span>/todos/{id:</span><span>\\</span><span>d+}</span><span>&#34;)]
</span></td></tr><tr><td>2</td><td><span>async </span><span>fn </span><span>todos_show_handler</span><span>(
</span></td></tr><tr><td>3</td><td><span>    </span><span>id</span><span>: web::Path&lt;</span><span>i64</span><span>&gt;,
</span></td></tr><tr><td>4</td><td><span>    </span><span>pool</span><span>: web::Data&lt;PgPool&gt;,
</span></td></tr><tr><td>5</td><td><span>    </span><span>routing</span><span>: web::Data&lt;RoutingService&gt;,
</span></td></tr><tr><td>6</td><td><span>) -&gt; Result&lt;TodoPresenter, Error&gt; {
</span></td></tr><tr><td>7</td><td><span>    </span><span>let</span><span> todo = sqlx::query_as!(Todo, </span><span>r</span><span>#&#34;</span><span>SELECT * FROM todos WHERE id = $1</span><span>&#34;#, *id)
</span></td></tr><tr><td>8</td><td><span>        .</span><span>fetch_one</span><span>(pool.</span><span>get_ref</span><span>())
</span></td></tr><tr><td>9</td><td><span>        .await?;
</span></td></tr><tr><td>10</td><td><span>
</span></td></tr><tr><td>11</td><td><span>    </span><span>let</span><span> url = routing.</span><span>todo_url</span><span>(*id);
</span></td></tr><tr><td>12</td><td><span>    Ok(TodoPresenter { todo, url })
</span></td></tr><tr><td>13</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>This is one of the handlers from <a href="https://github.com/drogus/todo-backend">my
implementation</a> of a <a href="https://todobackend.com/">Todo
Backend</a>. It&#39;s what you would do in vast majority of
your handlers: get an input from a request, fetch data from the database or
otherwise do some kind of computation and return the result. Notice that there
are no explicit lifetimes here and you need only a very limited undersanding of
the borrow checker. There is shared state here (in the form of the database pool
and the router &#34;service&#34;), but it&#39;s shared using the <code>web::Data</code> type, which is
a type from actix-web very similar to <code>Arc</code>. In fact, that&#39;s also how I think a
lot of async code would be written, also outside of web frameworks: instead of
dealing with lifetimes just use <code>Arc</code> or <code>Arc&lt;Mutex&lt;...&gt;&gt;</code>. That&#39;s also why my first
article on this blog is about <a href="https://itsallaboutthebit.com/arc-mutex"><code>Arc</code> and <code>Mutex</code></a> - I think <code>Arc</code>
should be the first thing you try when you need to share stuff between threads,
not the last. Most of the time it will be fast enough, don&#39;t worry. Then only if you need more performance or you think you can pull
off a better API you can try something more advanced, but otherwise? Why would
you make your life harder?</p>
<h3 id="if-you-always-use-arc-why-not-just-use-gced-language">If you always use <code>Arc</code>, why not just use GCed language</h3>
<p>As my response to most of the ownership and lifetimes problems is to just slap
an <code>Arc</code> or an <code>Rc</code> there, I&#39;ve heard quite a lot of variations of the question:
If you default to using <code>Arc</code>, won&#39;t it be slower than using a language with a
sophisticated garbage collector? It&#39;s a good question and if you really put
every single thing behind an <code>Arc</code>, it would probably be the case. Which would
indeed defeat some of the reasons to use Rust. Not all, mind you, you would
still get data races free programs and predictable memory usage, but yes, it
wouldn&#39;t be optimal.</p>
<p>The good thing is, by saying &#34;just use <code>Arc</code>&#34; I&#39;m not advocating to hide every
single variable behind an <code>Arc</code>. You mostly need it for shared state. Remember the
example from the previous section? It had two things behind an <code>Arc</code>, but the
rest was pretty much regular Rust code. So while, yes, every request to your
application would have to do at least two <code>Arc.clone()</code> operations in this
specific case, the
performance penalty is negligable. And unless you&#39;re writing a &#34;close to the
metal&#34; layer 4 load balancer or something, you probably won&#39;t care. It&#39;s fine,
really.</p>
<h3 id="the-dynamic-dispatcher">The dynamic dispatcher</h3>
<p>Hirrolot tries to implement a dynamic dispatcher in Rust. Not only that - it
takes a closure as an argument. This is one of the things that is just hard to
do in Rust. There are a few things like that, you might have heard about linked
lists already. It&#39;s just one of the tradeoffs. So, yes, if you are planning to
create an API that holds async closures and does zero extra allocations on top of it,
you&#39;re in for a bad, bad time. Fortunately, we can compromise, it&#39;s not like
your manager will come to you and tell you &#34;we need this feature for yesterday.
and remember, no allocations and no <code>Arc</code>!&#34;. Or actually they might, but in this
case you&#39;re probably working in embedded or on something very specific that
would be challenging to write even without Rust.</p>
<p>If I had to implement something like that, I would do it this way:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>async_trait::async_trait;
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>4</td><td><span>struct </span><span>Update;
</span></td></tr><tr><td>5</td><td><span>
</span></td></tr><tr><td>6</td><td><span>#[</span><span>async_trait</span><span>]
</span></td></tr><tr><td>7</td><td><span>trait </span><span>Handler {
</span></td></tr><tr><td>8</td><td><span>    async </span><span>fn </span><span>update</span><span>(&amp;</span><span>self</span><span>, </span><span>update</span><span>: &amp;Update) -&gt; ();
</span></td></tr><tr><td>9</td><td><span>}
</span></td></tr><tr><td>10</td><td><span>
</span></td></tr><tr><td>11</td><td><span>#[</span><span>derive</span><span>(Default)]
</span></td></tr><tr><td>12</td><td><span>struct </span><span>Dispatcher {
</span></td></tr><tr><td>13</td><td><span>    </span><span>handlers</span><span>: Vec&lt;Box&lt;dyn Handler&gt;&gt;,
</span></td></tr><tr><td>14</td><td><span>}
</span></td></tr><tr><td>15</td><td><span>
</span></td></tr><tr><td>16</td><td><span>impl </span><span>Dispatcher {
</span></td></tr><tr><td>17</td><td><span>    </span><span>pub fn </span><span>push_handler</span><span>(&amp;</span><span>mut </span><span>self</span><span>, </span><span>handler</span><span>: Box&lt;dyn Handler&gt;) {
</span></td></tr><tr><td>18</td><td><span>        </span><span>self</span><span>.handlers.</span><span>push</span><span>(handler);
</span></td></tr><tr><td>19</td><td><span>    }
</span></td></tr><tr><td>20</td><td><span>}
</span></td></tr><tr><td>21</td><td><span>
</span></td></tr><tr><td>22</td><td><span>// example handler
</span></td></tr><tr><td>23</td><td><span>struct </span><span>Foo {}
</span></td></tr><tr><td>24</td><td><span>#[</span><span>async_trait</span><span>]
</span></td></tr><tr><td>25</td><td><span>impl </span><span>Handler </span><span>for </span><span>Foo {
</span></td></tr><tr><td>26</td><td><span>    async </span><span>fn </span><span>update</span><span>(&amp;</span><span>self</span><span>, </span><span>update</span><span>: &amp;Update) -&gt; () {
</span></td></tr><tr><td>27</td><td><span>        println!(&#34;</span><span>Update: </span><span>{:?}</span><span>&#34;, update);
</span></td></tr><tr><td>28</td><td><span>    }
</span></td></tr><tr><td>29</td><td><span>}
</span></td></tr><tr><td>30</td><td><span>
</span></td></tr><tr><td>31</td><td><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span></td></tr><tr><td>32</td><td><span>async </span><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>33</td><td><span>    </span><span>let mut</span><span> dispatcher = Dispatcher::default();
</span></td></tr><tr><td>34</td><td><span>    </span><span>let</span><span> handler = Box::new(Foo {});
</span></td></tr><tr><td>35</td><td><span>
</span></td></tr><tr><td>36</td><td><span>    dispatcher.</span><span>push_handler</span><span>(handler);
</span></td></tr><tr><td>37</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Instead of using closures I would make a <code>Handler</code> trait. No <code>Arc</code>, no
lifetimes, no worries. Of course there are potential issues here:</p>
<ol>
<li>I&#39;m using <code>async_trait</code> here (which Hirrolot doesn&#39;t like, but I don&#39;t mind),
so a handler needs to be <code>Send</code>. If this is an issue you could also implement
a <code>!Send</code> version by using <code>#[async_trait(?Send)]</code></li>
<li>It needs more boilerplate than the closure version or even the <code>fn</code> version</li>
<li>We need to wrap handlers in a <code>Box</code></li>
<li>The interface uses <code>&amp;self</code>, so if you need <code>&amp;mut self</code> you would have to
change it</li>
</ol>
<p>And probably more. But does it matter? If you&#39;re writing application code (which
most of the Rust coders do), I don&#39;t think so. All of those things are minor
annoyances and after you write the actual handlers you can adjust the API as
needed. These problems would only matter in any meaningful way if you were
writing a library that has to work for many different scenarios for as many
users as possible. So we get back to what I wrote in the beginning - problems of
library authors are different than problems of application developers.</p>
<p>Also this is a theoretical problem. If it was a practical problem to be solved
the API I come up with might be vastly different, but with the amount of
information I have I don&#39;t think it matters much.</p>
<h3 id="library-code-vs-application-code">Library code vs application code</h3>
<p>(this section was added after posting the initial version)</p>
<p>One of the interesting comments I got in response to this post was asking about
a distinction between library code and application code. Usually when writing
applications you tend to extract duplicated code and the generalized version
is often something you could release as a library. Does it mean that it doesn&#39;t
happen in Rust. It does, but I think the constraints for internal libraries are
usually less strict than for external libraries. It&#39;s also easier to compromise - you
roughly know what you will be using the code for, so you can write
it in a way that works for your use case. And if you don&#39;t get it right the
first time? It&#39;s not a big deal if all of the users of your library are in the
same company.</p>
<p>I know some of you will frown on this. If you don&#39;t get it right it means
updates and updates are costly! Yes and no - I find it that in Rust refactoring
and updating code is much easier than in other languages I know - the type
system will guide you through it.</p>
<h3 id="no-problem-then">No problem then?</h3>
<p>After reading the article this far you may be thinking I&#39;m just an ignorant who
doesn&#39;t see any issues with Rust. A fanboy that would write anything to defend
his favourite language. That&#39;s definitely not the case. Well, at least the
part about writing anything to defend the language. I <em>am</em> a fanboy and Rust <em>is</em>
my favourite language.</p>
<p>I am aware of the issues with Rust. I know it sucks for library authors like
Hirrolot and I wish things were progressing faster. If we had GATs and Polonius
and many other awaited features, stuff like this would be hopefully easier. But
it takes a long time to implement these kind of features and I doubt we will get
any of that very soon.</p>
<p>The issue is, I think, that without proper context, Hirrolot&#39;s article is
discouraging people from learning Rust, especially with the following sentiment
in there:</p>
<blockquote>
<p>Still think that programming with borrow checker is easy and everybody can do it after some practice?</p>
</blockquote>
<p>This is doing a lot of harm, because now beginners reading this might think: oh
no, if this is how Rust works, I better quit now, I will never understand the
language at this level. And it&#39;s sad, because most people won&#39;t have to. If
you&#39;re a beginner in Rust you don&#39;t need to understand everything. You don&#39;t
need to write generic flexible APIs that will work for everyone and every
workload. You don&#39;t need to write zero allocations code.</p>

<p>(this section was added after posting the initial version)</p>
<p>While this article tries to show that Rust is managable for app developers, it
might paint a grim picture for library developers. It&#39;s indeed harder to write
Rust libraries than it is to write libraries in other languages. Getting the API
write usually means you must think about types, consider allocations, sometimes
deal with advanced lifetimes or traits. But it is doable too, you may need to
make compromises, though.</p>
<p>As you saw in both Hirrolot&#39;s article and mine, you can design a relatively
simple API for a dispatcher handling updates. It may not be an ideal API. It may
have some constraints that it wouldn&#39;t have in other languages, but it is
doable. Again, it&#39;s a tradeoff.</p>
<h3 id="summary">Summary</h3>
<p>If there is one thing I want you to get out of this article it&#39;s this: Rust
doesn&#39;t have to be very hard. It is a hard language, especially comparing to
languages like Javascript or Go, but it&#39;s not unachivable. And it will only get
easier over time. Writing Rust in 2022 is a vastly different experience than
writing Rust when it hit 1.0 version and the Rust team is working hard on making
it more approachable.</p>
<p>So if you&#39;re wondering if it&#39;s a language for you I hope you give it a try!</p>



    <div>
      <hr/>
      <p>If you like this post please consider following me on <a href="https://twitter.com/drogus">Twitter</a>!</p>
  </div>

	

  

  </div></div></div>
  </body>
</html>
