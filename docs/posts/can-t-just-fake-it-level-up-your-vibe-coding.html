<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/cant-just-fake-it-level-up-your-vibe-coding/">Original</a>
    <h1>Can&#39;t Just Fake It - Level Up Your Vibe-Coding</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-04-07T12:00Z">
                    07 Apr, 2025
                </time>
            </i>
        </p>
    

    <p>You&#39;ve probably heard about vibe coding‚Äîusing large language models (LLMs) like ChatGPT or Copilot to program via natural language. There‚Äôs been a fair amount of hype, skepticism, and frankly, confusion around whether these models can really handle the complexity of big codebases.</p>
<p>Let&#39;s cut through the noise: vibe coding on large-scale software is not only feasible‚Äîit&#39;s downright practical, as long as you&#39;re disciplined about your software engineering practices. The key isn&#39;t forcing these LLMs to magically comprehend your sprawling, undocumented spaghetti code (spoiler: they won&#39;t), but rather structuring your codebase in ways LLMs can genuinely leverage.</p>
<p>Here&#39;s a practical approach, grounded in proven software architecture principles and battle-tested resources, that&#39;ll actually help you make the most out of vibe coding in large software systems.</p>
<h3 id="step-1-get-serious-about-your-architecture">Step 1: Get Serious About Your Architecture</h3><p>Working with LLMs is fundamentally about clarity. Your first job is to adopt architecture practices that help both humans and LLMs navigate your codebase easily. The absolute essentials are:</p>
<ul>
<li><strong>RFCs and ADRs (Architecture Decision Records)</strong>: Keep your design decisions documented. This is basically leaving breadcrumbs for future-you, your colleagues, and crucially, your LLM partners. When decisions and rationale are explicit, LLMs have a much easier time understanding the context.</li>
<li><strong>Modularization</strong>: Split your codebase into small, focused modules. LLMs thrive in modular codebases because the context they need is tight, concise, and well-defined.</li>
<li><strong>Clear Boundaries</strong>: Strong, explicit boundaries between components keep complexity manageable. This aligns nicely with Domain-Driven Design (DDD) practices, which you should absolutely embrace.</li>
<li><strong>Logging and Monitoring</strong>: Visibility into your application&#39;s runtime behavior isn‚Äôt optional; it‚Äôs foundational. It also dramatically reduces debugging headaches caused by LLM-generated quirks.</li>
</ul>
<p><strong>Essential Reading:</strong></p>
<ul>
<li><a href="https://www.oreilly.com/library/view/software-architecture-the/9781492086888/">Software Architecture: The Hard Parts</a></li>
<li><a href="https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/">Learning Domain-Driven Design</a></li>
<li><a href="https://www.oreilly.com/library/view/building-event-driven-microservices/9798341622180/">Building Event-Driven Microservices</a></li>
</ul>
<h3 id="step-2-know-your-patterns-yes-they-still-matter">Step 2: Know Your Patterns (Yes, They Still Matter)</h3><p>Look, I get it‚Äîclassic enterprise design patterns can seem dry, ancient, or just plain boring. But they&#39;re classics for a reason. Books like Martin Fowler&#39;s &#34;Patterns of Enterprise Application Architecture&#34; or &#34;Enterprise Integration Patterns&#34; by Gregor Hohpe and Bobby Woolf are still goldmines.</p>
<p>They provide exactly the structured, consistent vocabulary that your LLM needs to reliably output decent code. The trick? Avoid overly generic naming conventions. Instead of calling something a <code>ManagerFactoryMessageController</code>, which confuses humans and LLMs alike, pick domain-specific, meaningful terms. Make your intent obvious.</p>
<p><strong>Must-have resources:</strong></p>
<ul>
<li><a href="https://martinfowler.com/eaaCatalog/">Patterns of Enterprise Application Architecture</a></li>
<li><a href="https://enterpriseintegrationpatterns.com/">Enterprise Integration Patterns</a></li>
<li><a href="https://martinfowler.com/books/refactoring.html">Refactoring</a></li>
</ul>
<h3 id="step-3-treat-code-as-a-language-because-it-is">Step 3: Treat Code as a Language (Because it is!)</h3><p>Programming is fundamentally linguistic. You‚Äôre communicating intent to both humans and machines. Peter Norvig&#39;s &#34;Paradigms of Artificial Intelligence Programming&#34; isn&#39;t just for AI nerds‚Äîit&#39;s a masterclass in clear, symbolic, and meaningful code manipulation.</p>
<p>This matters for vibe coding because it&#39;s much easier‚Äîand more reliable‚Äîto ask your LLM to generate small, deterministic transformations rather than recreate entire codebases from scratch. Linters, custom generators, small scripts‚Äîthese are your secret weapons.</p>
<p><strong>Highly recommended:</strong></p>
<ul>
<li><a href="https://norvig.github.io/paip-lisp/#/">Paradigms of Artificial Intelligence Programming</a></li>
</ul>
<h3 id="step-4-actually-do-software-engineering-right">Step 4: Actually Do Software Engineering Right</h3><p>There&#39;s a reason &#34;The Pragmatic Programmer&#34; is basically required reading: it distills decades of experience into actionable advice. Even though vibe coding feels cutting-edge, it thrusts you into an extremely professional context: multiple agents (human and AI) working simultaneously, rapid iteration, and tons of generated code that you‚Äôll need to trust.</p>
<p>Version control, code reviews, robust testing‚Äîthey&#39;re non-negotiable. Skimping here means chaos down the line.</p>
<p><strong>Do yourself a favor and read:</strong></p>
<ul>
<li><a href="https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/">The Pragmatic Programmer</a></li>
</ul>
<h3 id="step-5-deployment-and-monitoring-are-non-negotiable">Step 5: Deployment and Monitoring Are Non-Negotiable</h3><p>Vibe coding allows you to ship faster than ever before. But this speed demands solid practices around continuous integration/deployment and monitoring. Keeping your system robust and stable amidst rapid changes becomes your primary responsibility.</p>
<p>For resources, lean heavily on books by Manning and O&#39;Reilly. They have reliably up-to-date information on best practices in modern deployment, observability, and infrastructure.</p>
<h3 id="step-6-realize-youre-already-an-architect">Step 6: Realize You‚Äôre Already an Architect</h3><p>Even if you don‚Äôt call yourself an &#34;architect,&#34; if you&#39;re seriously vibe coding, you‚Äôre doing architectural work. You&#39;re orchestrating teams composed of humans and AI, bridging gaps, and making decisions about system design.</p>
<p>The human aspect‚Äîcommunication, organizational understanding, stakeholder management‚Äîis critical. The books &#34;12 Essential Skills for Software Architects&#34; and &#34;12 More Essential Skills for Software Architects&#34; by Dave Hendricksen aren&#39;t technical manuals, they&#39;re about managing complexity, relationships, and expectations. Precisely the skills you&#39;ll need more of as you integrate LLMs into your workflow.</p>
<p><strong>Key Reads:</strong></p>
<ul>
<li><a href="https://www.amazon.com/12-Essential-Skills-Software-Architects/dp/0321717295">12 Essential Skills for Software Architects</a></li>
<li><a href="https://www.amazon.com/More-Essential-Skills-Software-Architects/dp/032190947X">12 More Essential Skills for Software Architects</a></li>
</ul>
<h3 id="final-thoughts">Final Thoughts</h3><p>We&#39;re still early in understanding what vibe coding truly means for software development. But the trajectory is clear: structured, modular, and cleanly architected systems will allow LLMs to dramatically accelerate your development workflow. Adopt these best practices, and you&#39;ll not only make the most out of these tools‚Äîyou&#39;ll shape the future of software engineering itself.</p>
<p>So, go read those books. Seriously, they‚Äôre worth your time.</p>
<hr/>
<p>üíª ü§ñ ‚ú® Interested in coding with AI and LLMs? Follow me <a href="https://twitter.com/ProgramWithAI">@ProgramWithAI</a>.</p>
<p>üß† ‚ù§Ô∏è üñ• Connect with me on Mastodon <a href="https://hachyderm.io/@mnl">@mnl@hachyderm.io</a> or check my writing on <a href="https://dev.to/wesen">dev.to/wesen</a>.</p>
<p>For more detailed notes and insights, visit my üß† <a href="https://publish.obsidian.md/manuel">Obsidian vault</a>.</p>
<p>üéµ Explore my music projects as <a href="https://slonomusic.bandcamp.com">slono</a>.</p>
<p>Subscribe via üíå <a href="https://the.scapegoat.dev/feed/?type=rss">RSS</a> to keep updated.</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
