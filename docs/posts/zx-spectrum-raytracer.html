<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gabrielgambetta.com/zx-raytracer.html">Original</a>
    <h1>ZX Spectrum Raytracer</h1>
    
    <div id="readability-page-1" class="page"><div>



<p>I love raytracers; in fact I’ve written <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/02-basic-raytracing.html">half a book</a> about them. Probably less known is my love for the <a href="https://en.wikipedia.org/wiki/ZX_Spectrum">ZX Spectrum</a>, the 1982 home computer I grew up with, and which started my interest in graphics and programming. This machine is so ridiculously underpowered for today’s standards (and even for 1980s standards), the inevitable question is, to what extent could I port the Computer Graphics from Scratch raytracer to a ZX Spectrum?</p>
<p>The ZX Spectrum has a 3.5 MHz Z80 processor (1,000 times slower than current computers) that can’t multiply numbers (!!!), 48 KB of RAM (1,000,000 times smaller), and a 256x176 graphics mode (~200 times lower resolution) capable of displaying 15 colors (1,000,000 times fewer – and with some unusual quirks). This is an interesting setup for a CPU-intensive graphics application!</p>
<p>My plan was to implement this in Sinclair BASIC, the built-in programming language of the Spectrum. This is not just BASIC, but an ancient, very limited dialect of BASIC. For example, the only control structures are <code>FOR</code> and <code>IF</code> (and <code>IF</code> has no <code>ENDIF</code>); all variables are global; there are no function calls, only <code>GO TO</code> and <code>GO SUB</code>; etc. It’s also interpreted, so super slow. But at least it implements multiplications in software! I could always rewrite the raytracer in assembler if I cared about performance.</p>
<p>I set up a minimal environment: I write BASIC code using VS Code, compile it using <a href="https://github.com/speccyorg/bas2tap">BAS2TAP</a>, and run it on the <a href="https://fuse-emulator.sourceforge.net/">FUSE emulator</a>. This gave me a pretty decent iteration speed.</p>
<p>As an aside, I hadn’t written BASIC in something like 30 years, and I was surprised at how quickly it all came back. I was between 4 and 10 when I was doing this, so I guess it sticks in the brain like anything you learn at that age, like languages and accents. Now let’s get coding like it’s 1984!</p>
<h2 id="first-iteration-a-simple-raytracer"><a href="#first-iteration-a-simple-raytracer">First iteration: a simple raytracer</a></h2>
<p>My first iteration was pretty straightforward: I ported the <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/02-basic-raytracing.html#rendering-our-first-spheres">starter CGFS raytracing code</a> to BASIC without much tweaking, outputting a 32x22-block image, and to my surprise, it worked well:</p>
<p><img src="https://gabrielgambetta.com/img/zx-rt-1.png"/></p>
<p>The number in the upper left corner, 879.76, is the time it took to render this image, in seconds. Yes, that’s almost 15 minutes. Here’s the same scene rendered by the CGFS raytracer in about a second, using the same scene and feature set:</p>
<center>
<img src="https://gabrielgambetta.com/img/zx-rt-1-cgfs.png"/>
</center>
<p>The Spectrum version doesn’t look bad, considering the limitations! Let’s take a look at the code:</p>
<pre>   1 BRIGHT 1: CLS

   5 LET ROX = 0
   6 LET ROY = 0
   7 LET ROZ = 0
   8 LET TMIN = 0
   9 LET TMAX = 10000

  10 FOR X = 0 TO 31
  20   FOR Y = 0 TO 21

  30     LET RDX = (X - 16) / 32
  31     LET RDY = (11 - Y) / 32
  32     LET RDZ = 1

  40     GO SUB 1000

  50     PAPER COL
  51     PRINT AT Y, X; &#34; &#34;

 100   NEXT Y
 105   GO SUB 3000: PRINT AT 0, 0; TIME
 110 NEXT X

 120 STOP


1000 REM ===== TraceRay =====
1001 REM Params: (ROX, ROY, ROZ): ray origin; (RDX, RDY, RDZ): ray direction; (TMIN, TMAX): wanted ranges of t
1002 REM Returns: COL: pixel color

1010 LET COL = -1: LET MINT = 0

1100 RESTORE 9000
1101 READ NS
1102 FOR S = 1 TO NS

1110    READ SCX, SCY, SCZ, SRAD, SCOL

1200    LET COX = ROX - SCX
1201    LET COY = ROY - SCY
1202    LET COZ = ROZ - SCZ

1210    LET EQA = RDX*RDX + RDY*RDY + RDZ*RDZ
1211    LET EQB = 2*(RDX*COX + RDY*COY + RDZ*COZ)
1212    LET EQC = (COX*COX + COY*COY + COZ*COZ) - SRAD*SRAD

1220    LET DISC = EQB*EQB - 4*EQA*EQC
1230    IF DISC &lt; 0 THEN GO TO 1500

1240    LET T1 = (-EQB + SQR(DISC)) / 2*EQA
1241    LET T2 = (-EQB - SQR(DISC)) / 2*EQA

1250    IF T1 &gt;= TMIN AND T1 &lt;= TMAX AND (T1 &lt; MINT OR COL = -1) THEN LET COL = SCOL: LET MINT = T1
1300    IF T2 &gt;= TMIN AND T2 &lt;= TMAX AND (T2 &lt; MINT OR COL = -1) THEN LET COL = SCOL: LET MINT = T2

1500 NEXT S

1999 IF COL = -1 THEN LET COL = 0
2000 RETURN

3000 REM ===== Get timestamp in seconds =====
3001 LET TIME = (65536*PEEK 23674 + 256*PEEK 23673 + PEEK 23672) / 50
3002 RETURN

8998 REM ===== Sphere data =====
8999 REM Sphere count, followed by (SCX, SCY, SCZ, SRAD, COLOR)
9000 DATA 4
9001 DATA  0, -1, 4, 1, 2
9002 DATA  2,  0, 4, 1, 1
9003 DATA -2,  0, 4, 1, 4
9004 DATA 0, -5001, 0, 5000, 6</pre>
<p>The structure of the code should look familiar if you’re familiar with raytracers in general, and with the CGFS raytracer in particular, despite being written in an ancient dialect of BASIC. I’ll still walk through the code to point out the quirks of the Spectrum.</p>
<p>First, line numbers. Every line had to have a number, so you could use <code>GO TO</code> or <code>GO SUB</code>. Lines supported multiple statements separated by a colon – especially useful for the <code>IF ... THEN</code> statement, considering there’s no <code>END IF</code>!</p>
<p>You’ll notice the line numbers are all over the place. The Spectrum BASIC editor was line-oriented, so while it was possible to change line numbers, it was very time-consuming. So you’d number your lines in multiples of 10, so you had “space” to add lines in between if needed.</p>
<p>We start with this:</p>
<pre>1 BRIGHT 1: CLS</pre>
<p>The Spectrum has a pretty quirky graphics mode. I’ll get into the details in the next section. For now, let’s just say that <code>BRIGHT 1</code> chooses the bright version of the color palette, and <code>CLS</code> clears the screen. So we’re ready to start drawing something.</p>
<p>Then comes the main loop of the rayrtacer:</p>
<pre>  5 LET ROX = 0
  6 LET ROY = 0
  7 LET ROZ = 0
  8 LET TMIN = 0
  9 LET TMAX = 10000

 10 FOR X = 0 TO 31
 20   FOR Y = 0 TO 21

 30     LET RDX = (X - 16) / 32
 31     LET RDY = (11 - Y) / 32
 32     LET RDZ = 1

 40     GO SUB 1000

 50     PAPER COL
 51     PRINT AT Y, X; &#34; &#34;

100   NEXT Y
105   GO SUB 3000: PRINT AT 0, 0; TIME
110 NEXT X

120 STOP</pre>
<p>Lines 5 to 9 set some of the parameters that are constant throughout the main loop. BASIC had arrays but they were pretty inconvenient to use, so using them to represent points and vectors was a non-starter. So the ray origin <code>RO</code> is represented by the three variables <code>ROX</code>, <code>ROY</code> and <code>ROZ</code>.</p>
<p>Lines 10 to 110 form the main loop, iterating over the canvas (32x22 squares). After each pass of the inner loop, rendering a column of squares, line 105 does the equivalent of a function call: <code>GO SUB 3000</code> transfers control flow to the <em>subroutine</em> at line 3000:</p>
<pre>3000 REM ===== Get timestamp in seconds =====
3001 LET TIME = (65536*PEEK 23674 + 256*PEEK 23673 + PEEK 23672) / 50
3002 RETURN</pre>
<p>Line 3000 starts with <code>REM</code>, short for “remark”. We call them “comments” these days, but the ZX Spectrum is British, the brainchild of mad genius <a href="https://en.wikipedia.org/wiki/Clive_Sinclair">Sir Clive Sinclair</a>. So this line is just a comment.</p>
<p>The magical incantation in line 3001 reads the current timestamp in seconds. How? <code>PEEK</code> takes a memory address and returns its contents. All this line does is read a 24-bit number stored in memory, representing the internal <code>FRAME</code> counter; this counter is incremented every 20ms, so we divide it by 50 to convert it to seconds, and store it in the variable <code>TIME</code>.</p>
<p>Every variable in the program is global, so <code>RETURN</code> in line 3002 just returns flow control to the caller, and the “return value” of the function is implicitly the <code>TIME</code> global variable. This <code>GO SUB</code> / <code>RETURN</code> mechanism is very similar to <code>CALL</code> / <code>RET</code> in assembly.</p>
<p>Finally, line 120 terminates the program.</p>
<p>Now let’s take a look at the inner loop. Lines 30 to 32 convert canvas coordinates to viewport coordinates (<code>CanvasToViewport</code> in CGFS). The ray direction is represented by <code>(RDX, RDY, RDZ)</code>.</p>
<p>Line 40 does another “function call”, this time to the equivalent of <code>TraceRay</code>. When it returns, the variable <code>COL</code> will contain the color of whatever the ray hit.</p>
<p>Lines 50 and 51 finally draw the block. This is done by setting the <code>PAPER</code> (background) color and drawing a space (more on this later).</p>
<p>Now let’s take a look at <code>TraceRay</code> starting at line 1000. It starts with a comment block documenting the implicit inputs and outputs:</p>
<pre>1000 REM ===== TraceRay =====
1001 REM Params: (ROX, ROY, ROZ): ray origin; (RDX, RDY, RDZ): ray direction; (TMIN, TMAX): wanted ranges of t
1002 REM Returns: COL: pixel color</pre>
<p>Because there are no function arguments or return values, everything is global, implicit, and by convention. In this case, the inputs are <code>(ROX, ROY, ROZ)</code>, <code>(RDX, RDY, RDZ)</code>, <code>TMIN</code> and <code>TMAX</code>, and the return value is in the variable <code>COL</code>. This represents an index into the fixed color palette of the ZX Spectrum.</p>
<p>Line 1010 initializes the values we need to keep track of the closest intersection found so far, and the color of the sphere at the intersection:</p>
<pre>1010 LET COL = -1: LET MINT = 0</pre>
<p>Then we start the “for each sphere” loop:</p>
<pre>1100 RESTORE 9000
1101 READ NS
1102 FOR S = 1 TO NS
1110    READ SCX, SCY, SCZ, SRAD, SCOL</pre>
<p>Line 1100 resets a “data pointer” to line 9000, which contains the scene data:</p>
<pre>8998 REM ===== Sphere data =====
8999 REM Sphere count, followed by (SCX, SCY, SCZ, SRAD, COLOR)
9000 DATA 4
9001 DATA  0, -1, 4, 1, 2
9002 DATA  2,  0, 4, 1, 1
9003 DATA -2,  0, 4, 1, 4
9004 DATA  0, -5001, 0, 5000, 6</pre>
<p>The <code>READ</code> statement in line 1101 reads the first value (the number 4 in line 9000) into the variable NS. Then line 1102 starts the “for each sphere” loop, and the first thing we do in line 1110 is read the 5 values defining a sphere into variables. After that first batch of <code>READ</code> statemends the data pointer is now at the first value of line 9002, ready to be read during the next iteration of the loop.</p>
<p>Lines 1200 to 1300 solve a straightforward <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/02-basic-raytracing.html#ray-meets-sphere">ray-sphere intersection equation</a>, with lines 1250 and 1300 keeping track of the closest intersection:</p>
<pre>1200    LET COX = ROX - SCX
1201    LET COY = ROY - SCY
1202    LET COZ = ROZ - SCZ

1210    LET EQA = RDX*RDX + RDY*RDY + RDZ*RDZ
1211    LET EQB = 2*(RDX*COX + RDY*COY + RDZ*COZ)
1212    LET EQC = (COX*COX + COY*COY + COZ*COZ) - SRAD*SRAD

1220    LET DISC = EQB*EQB - 4*EQA*EQC
1230    IF DISC &lt; 0 THEN GO TO 1500

1240    LET T1 = (-EQB + SQR(DISC)) / 2*EQA
1241    LET T2 = (-EQB - SQR(DISC)) / 2*EQA

1250    IF T1 &gt;= TMIN AND T1 &lt;= TMAX AND (T1 &lt; MINT OR COL = -1) THEN LET COL = SCOL: LET MINT = T1
1300    IF T2 &gt;= TMIN AND T2 &lt;= TMAX AND (T2 &lt; MINT OR COL = -1) THEN LET COL = SCOL: LET MINT = T2</pre>
<p>We finish the loop checking if there were no intersections, in which case we set the color to 0 (black), and return:</p>
<pre>1999 IF COL = -1 THEN LET COL = 0
2000 RETURN</pre>
<p>And that’s all there is to it. We get our super slow, super low-res output:</p>
<p><img src="https://gabrielgambetta.com/img/zx-rt-1.png"/></p>
<p>I still find it pretty impressive that this only takes 50 lines of relatively straightforward code in an underpowered early 80s machine!</p>
<p>But this is just a start. Why stick to 32x22 when the usable pixel dimensions of the screen are 256x176?</p>
<h2 id="second-iteration-higher-resolution-and-handling-attribute-clashes"><a href="#second-iteration-higher-resolution-and-handling-attribute-clashes">Second iteration: higher resolution, and handling attribute clashes</a></h2>
<p>You might think that increasing the resolution of this raytracer is as simple as changing the outer loop to 256x176 instead of 32x22 and drawing individual pixels using <code>PLOT</code> instead of chunky squares using <code>PRINT</code>. This would be 64 times slower (16 hours instead of 15 minutes) but it would work – except in the quirky graphics mode of the ZX Spectrum!</p>
<p>The first version of the ZX Spectrum had a grand total of 16 KB of RAM, so memory efficiency was absolutely critical (I had the considerably more luxurious 48 KB model). To help save memory, video RAM was split in two blocks: a bitmap block, using one bit per pixel, and an attributes block, using one byte per 8x8 block of pixels. The attributes block would assign two colors to that block, called <code>INK</code> (foreground) and <code>PAPER</code> (background).</p>
<p>So you could use <code>PLOT</code> to set or clear the bit corresponding to a pixel, which would then take one of the two colors assigned to that block. <strong>This means each 8x8-pixel block can show one or two different colors, but never three or more</strong>.</p>
<p>This all worked great for text-based applications, since characters were also 8x8 blocks, but for anything graphic, especially games, it was super limiting. This limitation gives Spectrum games its very characteristic aesthetic, because artists had to work around this, usually by designing screens and sprites aligned to a 8x8 pixel grid, or going full monochrome, or accepting that attribute clash was a fact of life.</p>
<p>Back to the raytracer. Increasing the resolution is easy. Dealing with attribute clash, not so much.</p>
<p>There’s no perfect solution: no matter what I do, each 8x8 block can show up to two colors. So what I did was implement an approximation algorithm. I collect the colors present in the 8x8 block, find the most common and second most common, and draw every pixel using one of the two.</p>
<p>The outer loop changes a bit to reflect the higher resolution and the processing on 8x8-block chunks:</p>
<pre> 10 FOR X = 0 TO 255 STEP 8
 20   FOR Y = 0 TO 175 STEP 8

...

500   NEXT Y
505   GO SUB 3000: PRINT AT 0, 0; TIME
510 NEXT X
520 STOP</pre>
<p>Then we trace the 64 rays, collecting the colors in an array:</p>
<pre> 30      DIM C(64)
 31      LET CI = 1
 32      DIM A(8)

120     REM --- For each 8x8 block, collect the pixel colors and their counts ---
125     FOR U = X TO X+7
126       FOR V = Y TO Y+7

130         LET RDX = (U - 128) / 256
131         LET RDY = (V - 88) / 256
132         LET RDZ = 1

140         GO SUB 1000
141         LET C(CI) = COL
142         LET CI = CI + 1
143         LET A(COL+1) = A(COL+1) + 1

160       NEXT V
161     NEXT U</pre>
<p>Line 30 <code>DIM</code>ensions the variable <code>C</code> as a 64-element array. Array indexes start at 1, so line 31 initializes <code>CI</code> (<code>C</code>-index) to 1. Line 32 creates another array <code>A</code> which will hold the color counts.</p>
<p>Lines 140 to 143 call <code>TraceRay</code> and store the results: the pixel color in <code>C</code>, and the updated color count in <code>A</code>. Colors go from 0 to 7 but indexes go from 1 to 8, so we need to use <code>COL+1</code> as the index.</p>
<p>Next we need to find the most and second-most frequent colors:</p>
<pre>199     REM --- Find the most and second most frequent colors in this 8x8 block ---
201     LET MFC = 0
202     FOR C = 1 TO 8
203       IF A(C) &gt; MFC THEN LET MFC = A(C): LET MFI = C
204     NEXT C
205     LET FCOL = MFI - 1

207     LET II = MFI: LET MFC = 0: LET MFI = 0
208     FOR C = 1 TO 8
209       IF C &lt;&gt; II AND A(C) &gt; MFC THEN LET MFC = A(C): LET MFI = C
210     NEXT C
211     LET SCOL = MFI - 1</pre>
<p>Time to draw some pixels. If all the pixels are the same color, just paint the block:</p>
<pre>259     REM --- If there&#39;s only one color, paint the whole block --
260     IF SCOL &lt;&gt; -1 THEN GO TO 300
270     POKE 22528 + X/8 + 32*(21-Y/8), 64 + FCOL * 8
280     GO TO 500</pre>
<p>That <code>POKE</code> requires an explanation. <code>POKE</code> puts a byte in a memory address. The first parameter is the address of this 8x8 block in the attributes block. The second parameter, the byte representing the INK and PAPER values, is the combination of the INK color shifted left 3 bits, plus a bit to turn on the BRIGHT attribute.</p>
<p>If not all pixels are the same color, we need to plot them individually. The PAPER color of the block is set to the most frequent color (so there’s fewer pixels to plot), we go over the array, and any pixel that isn’t the most frequent color is drawn with INK color set to the second most frequent color:</p>
<pre>300     REM --- Otherwise set the PAPER to the most frequent color, and draw everything else in the second most frequent color --
301     LET CI = 1
310     FOR U = X TO X+7
311       FOR V = Y TO Y+7

320         IF C(CI) &lt;&gt; FCOL THEN PLOT INK SCOL; PAPER FCOL; U, V
321         LET CI = CI + 1

350       NEXT V
351     NEXT U</pre>
<p>This works pretty well!</p>
<p><img src="https://gabrielgambetta.com/img/zx-rt-2.png"/></p>
<p>Attribute clash still happens. Look at this magnified part:</p>
<center>
<img src="https://gabrielgambetta.com/img/zx-rt-2-clash.png"/>
</center>
<p>With a grid overlaid to show block boundaries, the problem is easier to see. The two blocks that look “wrong” should have three colors: black, yellow, and either green or red. But the Spectrum can’t do that, so this is what the algorithm above ends up doing.</p>
<p>You can take a look at the <a href="https://gabrielgambetta.com/zx-raytracer-2-src.html">full source code for this iteration</a>.</p>
<p>The next thing to notice is that it’s just ridiculously slow - over 17 hours! Even on the emulator hitting 20,000% speed, it takes a while to render. Can we do better?</p>
<h2 id="third-iteration-performance-improvements"><a href="#third-iteration-performance-improvements">Third iteration: performance improvements</a></h2>
<p>I went for an optimization pass. Here’s what I did:</p>
<ul>
<li><p>For each 8x8 block, trace rays for the 4 corners, and if the color is the same in all, paint the whole block. Most of the time this does 4 rays per block instead of 64, so by itself it speeds up rendering by 16x. Of course if there were small objects that fell fully inside a block, the raytracer would miss them; but for this test scene, it feels like it’s a fair approximation.</p></li>
<li><p>Avoid multiplications and divisions at all costs. The Z80 can’t do multiplication in hardware (let alone division), so BASIC implements it in software, and it’s <em>slow</em>.</p></li>
<li><p>Hardcode some constants based on assumptions. Notably, the ray origin is always (0, 0, 0), <code>t_min</code> is always 0, and <code>t_max</code> is always <code>+inf</code>, so that saves some computation.</p></li>
<li><p>Precompute values when possible. Why store the spehre radius as data and square it, when it can be stored squared to begin with?</p></li>
<li><p>Move computed values to outer loops when possible. For example, values related to X are constant for every Y, and can be computed fewer times.</p></li>
<li><p>Inlined the “most frequent color” subroutine, and specialized the first case to not ignore any color.</p></li>
<li><p>Tweaked the line numbers to make sure <code>GO SUB</code> didn’t land on a <code>REM</code> line; believe it or not, processing a line that contains a comment takes time!</p></li>
<li><p>Used shorter variable names. This BASIC is interpreted, so every time you reference a variable, it’s looked up by name…</p></li>
<li><p>I also tried some optimizations that didn’t work, like reading the <code>DATA</code> into an array first, or putting certain expressions into variables. I have the vague feeling that the <em>order</em> in which variables are defined is important – I need to read more about this.</p></li>
<li><p>There’s some optimizations that help marginally, but hinder readability, so I chose not to implement them.</p></li>
</ul>
<p>All in all, the result is pretty good. The image is pixel-identical, but the runtime is down to 2 hours and a bit:</p>
<p><img src="https://gabrielgambetta.com/img/zx-rt-3.png"/></p>
<p>You can take a look at the <a href="https://gabrielgambetta.com/zx-raytracer-3-src.html">full source code for this iteration</a>.</p>
<h2 id="fourth-iteration-light-just-the-one"><a href="#fourth-iteration-light-just-the-one">Fourth iteration: light (just the one)</a></h2>
<p>Initially I had stopped myself here; given the limitations of the environment, I felt like there wasn’t much more that could be done.</p>
<p>The obvious next step is to implement lighting. The <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/03-light.html">lighting equations and algorithms</a> are relatively straightforward, but the main problem is the very limited set of colors the ZX Spectrum can represent. To recap, it’s a fixed set of 7 colors, in normal and bright versions, plus black:</p>
<center>
<img src="https://gabrielgambetta.com/img/zx-colors.png"/>
</center>
<p>Even if I had the light intensity value at every pixel, I can’t just multiply it by the sphere color to get the shaded color, like I can do trivially in RGB. What to do?</p>
<p>Tradeoffs, that’s what. I can simulate shades of a color by alternating the color and black in the right amounts. I can do this on a 8x8 block basis, setting the <code>INK</code> to the color, <code>PAPER</code> to black. The tradeoff is that there will be attribute clashing.</p>
<p>How to decide whether to plot a pixel or leave it black? My first idea was to use the light intensity, a real number between 0.0 and 1.0, as the <em>probability</em> that a pixel would be plotted with the color (and left black otherwise). This worked, but it looked ugly. There’s something better, called <a href="https://en.wikipedia.org/wiki/Ordered_dithering">ordered dithering</a>. The idea is to have a matrix of thresholds, one per pixel, that helps determine whether to plot the pixel. The thresholds are arranged in such a way that they produce repeatable, pleasing patterns of pixels for any intensity level. There’s a 8x8 dithering matrix, which fits perfectly the 8x8 color blocks I’m processing, so it was surprisingly easy to implement.</p>
<p>For the sake of simplicity, I decided to have just one directional light. Even with ordered dithering, there are not enough shades I can display that will adequately represent the nuances of multiple lights illuminating the same object. For the same reason, I went for diffuse lighting only, no specular component.</p>
<p>So the goal was to render something like this:</p>
<center>
<img src="https://gabrielgambetta.com/img/zx-rt-4-cgfs.png"/>
</center>
<p>How close could I get to that on a humble ZX Spectrum?</p>
<p>Here are the relevant changes I made to the code:</p>
<p>I could no longer use the 4-rays-per-8x8-block trick, because the light intensity at each pixel could be different. Could have computed one intensity per block, but I didn’t want to lose light resolution. So performance took a big hit compared to the previous iteration. The exception is if the 4 corners of the 8x8 block are black, in which case I can safely ignore it.</p>
<p>The lighting part is pretty simple: in the <code>TraceRay</code> subroutine, I needed to keep track of the index of the closest sphere (so I also had to load the sphere data into an array <code>S</code> at the start of the program). After the sphere loop, if the ray hits any sphere, I compute the intersection between the ray and the sphere, the normal at that point in the sphere, and finally the illumination at that point:</p>
<pre>1601 LET NX = DX*MT - S(CS, 1): LET NY = DY*MT - S(CS, 2): LET NZ = DZ*MT - S(CS, 3)
1610 LET PL = AI
1615 LET NL = (NX*LX + NY*LY + NZ*LZ)
1620 IF NL &gt; 0 THEN LET PL = PL + DI * NL / SQR(NX*NX + NY*NY + NZ*NZ)</pre>
<p>In that fragment, <code>CS</code> is the index of the Closest Sphere; <code>PL</code> is a new output variable representing Pixel Lighting; (<code>LX</code>, <code>LY</code>, <code>LZ</code>), <code>DI</code> and <code>AI</code> are set elsewhere, and represent the direction of the light, its intensity, and the intensity of the ambient light, respectively. For performance reasons, <code>LX</code>, <code>LY</code>, <code>LZ</code> represent a normalized vector, so I can skip the <code>SQR</code> and the division in line 1620.</p>
<p>I don’t need to find the second most frequent color in each 8x8 block anymore, because each block will only display the most frequent color and black.</p>
<p>I added some code to load the Bayer ordered dither matrix into an array:</p>
<pre>   3 GO SUB 7000

   ...

6999 REM ===== Initialize 8x8 Bayer matrix =====
7000 DIM H(64)
7001 RESTORE 7100
7002 FOR I = 1 TO 64
7003   READ H(I): LET H(I) = H(I) / 64
7004 NEXT I
7005 RETURN

7100 DATA  0, 32,  8, 40,  2, 34, 10, 42
7101 DATA 48, 16, 56, 24, 50, 18, 58, 26
7102 DATA 12, 44,  4, 36, 14, 46,  6, 38
7103 DATA 60, 28, 52, 20, 62, 30, 54, 22
7104 DATA  3, 35, 11, 43,  1, 33,  9, 41
7105 DATA 51, 19, 59, 27, 49, 17, 57, 25
7106 DATA 15, 47,  7, 39, 13, 45,  5, 37
7107 DATA 63, 31, 55, 23, 61, 29, 53, 21</pre>
<p>And finally, before plotting a pixel, I compare its light intensity with the corresponding threshold in the Bayer matrix:</p>
<pre>320 IF C(CI) &gt; 0 AND H(CI) &lt;= L(CI) THEN PLOT U, V</pre>
<p>I ran this iteration, and honestly, I stared at it in disbelief for a good minute:</p>
<p><img src="https://gabrielgambetta.com/img/zx-rt-4.png"/></p>
<p>First of all, <em>it works</em>!</p>
<p>It’s pretty slow compared to the previous iteration, mostly because the missing 4-rays-per-block trick, plus the additional lighting calculations. But it’s not <em>that bad</em>.</p>
<p>Attribute clashing is still there, and it’s a lot more obvious now. Could this be improved? Maybe. The yellow/red clashes look like could be improved by making the blocks red and yellow, and forgoing the shading detail (because there would be no black). For green/yellow and blue/yellow, looks like black/yellow, blue/yellow and again black/yellow would make it look better. Hmmmm. Maybe I’ll get back to this.</p>
<p>You can take a look at the <a href="https://gabrielgambetta.com/zx-raytracer-4-src.html">full source code for this iteration</a>.</p>
<h2 id="fifth-iteration-shadows"><a href="#fifth-iteration-shadows">Fifth iteration: shadows</a></h2>
<p>At this point I’m feeling pretty comfortable with the environment, I’m coding like it’s 1984, so I want to see how far I can take this. Next step: shadows.</p>
<p>Most of the pieces are already in place. <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/04-shadows-and-reflections.html#shadows">The theory</a> is relatively simple: before computing lighting for a point, need to figure out whether there’s an object between the point and the light, blocking it (i.e. casting a shadow). I just had to implement a specialized version of <code>TraceRay</code> that traces from the intersection of the primary ray and a sphere, in the direction of the directional light, and returns as soon as it finds any intersection:</p>
<pre>2090 REM ----- Specialized TraceRay for shadow checks -----
2091 REM Params: (IX, IY, IZ): ray start; (LX, LY, LZ): ray direction (directional light vector)
2092 REM Returns: H = 1 if the ray intersects any sphere, H = 0 otherwise
2093 REM Optimizations: (TMIN, TMAX) hardcoded to (epsilon, +inf)

2100 LET A = 2*(LX*LX + LY*LY + LZ*LZ)

2110 FOR S = 1 TO NS

2111    LET CX = IX - S(S,1): LET CY = IY - S(S,2): LET CZ = IZ - S(S,3)
2120    LET B = -2*(CX*LX + CY*LY + CZ*LZ)
2130    LET C = (CX*CX + CY*CY + CZ*CZ) - S(S, 4)

2140    LET D = B*B - 2*A*C
2150    IF D &lt; 0 THEN GO TO 2210
2160    LET D = SQR(D)

2170    LET T = (B + D) / A
2180    IF T &gt; 0.01 THEN LET H = 1: RETURN
2190    LET T = (B - D) / A
2200    IF T &gt; 0.01 THEN LET H = 1: RETURN

2210 NEXT S
2220 LET H = 0: RETURN</pre>
<p>This is called right before computing illumination:</p>
<pre>1600 LET IX = DX*MT: LET IY = DY*MT: LET IZ = DZ*MT
1601 LET NX = IX - S(CS, 1): LET NY = IY - S(CS, 2): LET NZ = IZ - S(CS, 3)
1610 LET PL = AI

1612 GO SUB 2100: IF H = 1 THEN RETURN

1615 LET NL = (NX*LX + NY*LY + NZ*LZ)
1620 IF NL &gt; 0 THEN LET PL = PL + DI * NL / SQR(NX*NX + NY*NY + NZ*NZ)</pre>
<p>And here’s what comes out…</p>
<p><img src="https://gabrielgambetta.com/img/zx-rt-5.png"/></p>
<p>Compare with the output of the CGFS raytracer:</p>
<center>
<img src="https://gabrielgambetta.com/img/zx-rt-5-cgfs.png"/>
</center>
<p>Pretty slow due to the extra computation (back to 17 hours), but definitely worth it!</p>
<p>You can take a look at the <a href="https://gabrielgambetta.com/zx-raytracer-5-src.html">full source code for this iteration</a>.</p>
<h2 id="what-next"><a href="#what-next">What next?</a></h2>
<p>The obvious next step would be to implement reflections. But it would be practically impossible to blend colors together in a meaningful way. So objects would be either fully reflective or not reflective at all, and it would just look weird. Recursion would be an interesting problem: the Spectsum supports it, but because there are no local variables, each recursive call would overwrite the global variables, so I’d have to manage my own stack. Doable, but doesn’t sound worth the effort.</p>
<p>Another axis is performance. I could rewrite the whole thing in assembly and see how fast can I make it go. I could control how much precision I need, so maybe fixed-point math would do it (or a less precise version of <code>SQR</code>). Maybe some other time!</p>
<p>Finally, the attribute clash at object boundaries still bothers me. I have a couple of ideas that might improve the situation, although the limitations of the Spectrum are such that it will never be 100% fixed.</p>
<h2 id="nostalgic-rant"><a href="#nostalgic-rant">Nostalgic rant</a></h2>
<p>This was a fun weekend project. Entirely pointless, but fun!</p>
<p>It was nice to write Sinclair BASIC after 30 years. Even though the language is the same, I’m not – I found myself thinking higher-level concepts and then translating them to BASIC. I don’t know whether this is because modern languages give me a better vocabulary to think in, that I can then translate to BASIC, or because I’m not 10 anymore. Could be both.</p>
<p>Specifically, this program makes judicious use of <code>GO TO</code>, which as everyone knows, it’s Considered Harmful™. Back in the day it was pretty much all we had: no function calls, only subroutines using <code>GO SUB</code>; no <code>WHILE</code> or <code>REPEAT</code>; <code>IF</code> doesn’t have <code>END IF</code>; <code>FOR</code> doesn’t have <code>BREAK</code> or <code>CONTINUE</code> (the keywords exist, but they don’t do what you think they do). So using <code>GO TO</code> is unavoidable. And sure, it can lead to spaghetti code, but it doesn’t <em>have to</em>; my own code here, although admittedly simple, is structured cleanly.</p>
<p>I also missed the immediacy and the simplicity of the environment. No frameworks, no dependencies, barely any abstractions (even multiplication is implemented in software!). The ZX Spectrum was fully <em>knowable</em>. The whole Z80 instruction set, the quirks of the ROM and the ALU, everything fits in your head pretty easily. You could reason about peformance down to the processor cycle level – no caches or pipelines or anything else to make your life difficult. I miss all that. Kids These Days™ will never get to experience an environment like this, and that makes me sad.</p>
<pre>9999 STOP</pre>


</div></div>
  </body>
</html>
