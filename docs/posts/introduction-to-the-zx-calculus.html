<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pennylane.ai/qml/demos/tutorial_zx_calculus.html">Original</a>
    <h1>Introduction to the ZX-Calculus</h1>
    
    <div id="readability-page-1" class="page"><div id="introduction-to-the-zx-calculus">


<p><em>Author: Romain Moyard. Posted: 6 June, 2023.</em></p>
<p>The ZX-calculus is a graphical language for reasoning about quantum computations and circuits. Introduced by Coecke
and Duncan <a href="#coecke" id="id1">1</a>, it can represent any linear map, and can be considered a diagrammatically complete
generalization of the usual circuit representation. The ZX-calculus is based on category theory, an approach to
mathematics which studies objects in terms of their relations rather than in isolation. Thus, the ZX-calculus
provides a rigorous way to understand the structure underlying quantum problems, using the link between quantum
operations rather than the quantum operations themselves.</p>
<div id="id24">
<p><a href="https://pennylane.ai/qml/_images/ZX_Calculus_animation.gif"><img alt="../_images/ZX_Calculus_animation.gif" src="https://pennylane.ai/qml/_images/ZX_Calculus_animation.gif"/></a></p><p><span>After this tutorial you will understand how to represent quantum teleportation and simplify it in the ZX-calculus!</span><a href="#id24" title="Permalink to this image">¶</a></p>
</div>
<p>In this tutorial, we first give an overview of the building blocks of the ZX-calculus, called <em>ZX-diagrams</em>,
and the rules for transforming them, called <em>rewriting rules</em>. We also show how the ZX-calculus can be extended to ZXH
calculus. The ZX-calculus is also promising for quantum machine learning, thus we present how the parameter-shift rule
can be derived using ZX-diagrams. We will then jump to the coding part of the tutorial and show how PennyLane is
integrated with PyZX <a href="#pyzx" id="id2">2</a>, a Python library for ZX-calculus, and how you can transform your circuit to a
ZX-diagram. We then apply what we’ve learned in order to optimize the number of T-gates of a known benchmark circuit.
We also show that simplifying a ZX-diagram does not always end up with a diagram-like graph, and that circuit
extraction is a main pain point of the ZX framework. This tutorial will give a broad overview of what ZX-calculus can
offer when you want to analyze quantum problems.</p>
<div id="zx-diagrams">
<h2>ZX-diagrams<a href="#zx-diagrams" title="Permalink to this headline">¶</a></h2>
<p>This introduction follows the works of the East et al. <a href="#east2021" id="id3">3</a> and van de Wetering <a href="#jvdw2020" id="id4">4</a>. Our goal is to
introduce a complete language for quantum information, for which we need two elements: ZX-diagrams and their
rewriting rules. We start by introducing ZX-diagrams, a graphical depiction of a tensor network representing an
arbitrary linear map. Later, we will introduce ZX rewriting rules, which together with diagrams defines the
ZX-calculus. We follow the scalar convention of East et al. <a href="#east2021" id="id5">3</a> (it is more suitable to the multi-H box
situations, see the ZXH section).</p>
<p>A ZX-diagram is an undirected multi-graph; you can move vertices without affecting the underlying
linear map. The vertices are called Z- and X-spiders, which represent two kinds of linear maps. The edges are called
wires, and represent the dimensions on which the linear maps are acting. Therefore, the edges represent qubits in
quantum computing. The diagram’s wires on the left and right are called inputs and outputs, respectively.</p>
<p>The first building block of the ZX-diagram is the Z-spider. In most of the literature, it is depicted as a green vertex.
The Z-spider takes a real phase <span>\(\alpha \in \mathbb{R}\)</span> and represents the following linear map (it accepts any
number of inputs and outputs, and the number of inputs does not need to match the number of outputs):</p>
<div id="id25">
<p><a href="https://pennylane.ai/qml/_images/z_spider.jpeg"><img alt="../_images/z_spider.jpeg" src="https://pennylane.ai/qml/_images/z_spider.jpeg"/></a></p><p><span>The Z-spider.</span><a href="#id25" title="Permalink to this image">¶</a></p>
</div>
<p>It is easy to see that the usual Z-gate can be represented with a single-wire Z-gate:</p>
<div id="id26">
<p><a href="https://pennylane.ai/qml/_images/z_gate.jpeg"><img alt="../_images/z_gate.jpeg" src="https://pennylane.ai/qml/_images/z_gate.jpeg"/></a></p><p><span>The Z-gate.</span><a href="#id26" title="Permalink to this image">¶</a></p>
</div>
<p>As you’ve probably already guessed, the second building block of the ZX-diagram is the X-spider. It is usually depicted
as a red vertex. The X-spider also takes a real phase <span>\(\alpha \in \mathbb{R}\)</span> and it represents the following
linear map (it accepts any number of inputs and outputs):</p>
<div id="id27">
<p><a href="https://pennylane.ai/qml/_images/x_spider.jpeg"><img alt="../_images/x_spider.jpeg" src="https://pennylane.ai/qml/_images/x_spider.jpeg"/></a></p><p><span>The X-spider.</span><a href="#id27" title="Permalink to this image">¶</a></p>
</div>
<p>It is easy to see that the usual X-gate can be represented with a single-wire X-spider:</p>
<div id="id28">
<p><a href="https://pennylane.ai/qml/_images/x_gate.jpeg"><img alt="../_images/x_gate.jpeg" src="https://pennylane.ai/qml/_images/x_gate.jpeg"/></a></p><p><span>The X-gate.</span><a href="#id28" title="Permalink to this image">¶</a></p>
</div>
<p>From ordinary quantum theory, we know that the Hadamard gate can be decomposed into X and Z rotations, and can therefore
be represented in ZX-calculus. In order to make the diagram easier to read, we introduce the Hadamard gate as a yellow
box:</p>
<div id="id29">
<p><a href="https://pennylane.ai/qml/_images/hadamard_gate.png"><img alt="../_images/hadamard_gate.png" src="https://pennylane.ai/qml/_images/hadamard_gate.png"/></a></p><p><span>The Hadamard gate as a yellow box and its ZX decomposition.</span><a href="#id29" title="Permalink to this image">¶</a></p>
</div>
<p>This yellow box is also often represented as a blue edge in order to further simplify the display of the diagram.
Below, we will discuss a generalization of the yellow box to a third spider, forming the ZXH-calculus. It is important
to note that the yellow box is by itself a rewrite rule for the decomposition of the Hadamard gate. The yellow box
allows us to write the relationship between the X- and Z-spider as follows.</p>
<div id="id30">
<p><a href="https://pennylane.ai/qml/_images/hxhz.jpg"><img alt="../_images/hxhz.jpg" src="https://pennylane.ai/qml/_images/hxhz.jpg"/></a></p><p><span>How to transform an X-spider to a Z-spider with the Hadamard gate.</span><a href="#id30" title="Permalink to this image">¶</a></p>
</div>
<div id="id31">
<p><a href="https://pennylane.ai/qml/_images/hzhx.jpg"><img alt="../_images/hzhx.jpg" src="https://pennylane.ai/qml/_images/hzhx.jpg"/></a></p><p><span>How to transform an Z-spider to a X-spider with the Hadamard gate.</span><a href="#id31" title="Permalink to this image">¶</a></p>
</div>
<p>A special case of the Z- and X-spiders are diagrams with no inputs (or outputs). They are used to represent states that
are unnormalized. If a spider has no inputs and outputs, it simply represents a complex scalar. You can find the usual
representation of quantum states below:</p>
<div id="id32">
<p><a href="https://pennylane.ai/qml/_images/zero_state_plus_state.jpeg"><img alt="../_images/zero_state_plus_state.jpeg" src="https://pennylane.ai/qml/_images/zero_state_plus_state.jpeg"/></a></p><p><span>The zero state and plus state as a ZX-diagram.</span><a href="#id32" title="Permalink to this image">¶</a></p>
</div>
<p>Similarly, you get the <span>\(\vert 1\rangle\)</span> state and <span>\(\vert -\rangle\)</span> state by replacing the zero phase with
<span>\(\pi\)</span>.</p>
<p>The phases are <span>\(2\pi\)</span> periodic, and when a phase is equal to <span>\(0\)</span> we omit the zero symbol from the spider.
A simple green vertex is a Z-spider with zero phase and a simple red vertex is an X-spider with zero phase.</p>
<p>Now that we have these two basic building blocks, we can start composing them and stacking them on top of each other.
Composition consists of joining the outputs of a diagram to the inputs of another diagram. Stacking two
ZX-diagrams on top of each other represents the tensor product of the corresponding tensors.</p>
<p>We illustrate the rules of stacking and composition by building an equivalent CNOT gate (up to a global phase). We
start by stacking a single wire with a phaseless Z-spider with one input wire and two output wires. We show the
ZX-diagram and corresponding matrix below:</p>
<div id="id33">
<p><a href="https://pennylane.ai/qml/_images/stack_z_w.jpg"><img alt="../_images/stack_z_w.jpg" src="https://pennylane.ai/qml/_images/stack_z_w.jpg"/></a></p><p><span>Phaseless Z-spider with one input wire and two output wires (see the definition of the Z-spider) stacked with a
single wire.</span><a href="#id33" title="Permalink to this image">¶</a></p>
</div>
<p>Next, we stack a single wire with a phaseless X-spider with two input wires and single output wire. Again, we provide
the matrix:</p>
<div id="id34">
<p><a href="https://pennylane.ai/qml/_images/stack_w_x.jpg"><img alt="../_images/stack_w_x.jpg" src="https://pennylane.ai/qml/_images/stack_w_x.jpg"/></a></p><p><span>Single wire stacked with a phaseless X-spider with two inputs wires and one output wire.</span><a href="#id34" title="Permalink to this image">¶</a></p>
</div>
<p>Finally, we compose the two diagrams, meaning that we join the two outputs of the first diagram with the two inputs of
the second diagram. By doing this we obtain a CNOT gate — you can convince yourself by doing the matrix multiplication
between the two diagrams.</p>
<div id="id35">
<p><a href="https://pennylane.ai/qml/_images/compose_zw_wx.jpg"><img alt="../_images/compose_zw_wx.jpg" src="https://pennylane.ai/qml/_images/compose_zw_wx.jpg"/></a></p><p><span>The composition of the two diagrams is a CNOT gate.</span><a href="#id35" title="Permalink to this image">¶</a></p>
</div>
<p>We’ve already mentioned that a ZX-diagram is an undirected multi-graph; the position of the vertices does not matter,
nor does the trajectory of the wires. We can move vertices around, bend and unbend, and cross and uncross wires
as long as the connectivity and the order of the inputs and outputs is maintained. In particular, bending a line so
that it changes direction from left to right, or vice-versa, is not allowed. None of these deformations affect the
underlying linear map, meaning that ZX-diagrams have all sorts of <em>topological</em> symmetries. For instance,
the two diagrams below both represent the CNOT gate:</p>
<div id="id36">
<p><a href="https://pennylane.ai/qml/_images/cnot_moved.jpeg"><img alt="../_images/cnot_moved.jpeg" src="https://pennylane.ai/qml/_images/cnot_moved.jpeg"/></a></p><p><span>Both diagrams represent the same CNOT gate.</span><a href="#id36" title="Permalink to this image">¶</a></p>
</div>
<p>This means that we can draw a vertical line without ambiguity, which is the usual way of representing the CNOT gate:</p>
<div id="id37">
<p><a href="https://pennylane.ai/qml/_images/cnot.jpeg"><img alt="../_images/cnot.jpeg" src="https://pennylane.ai/qml/_images/cnot.jpeg"/></a></p><p><span>Usual representation of the CNOT gate as a ZX-diagram.</span><a href="#id37" title="Permalink to this image">¶</a></p>
</div>
<p>We’ve just shown that we can express any Z rotation and X rotation with Z- and X-spiders. Therefore, it is sufficient
to create any one-qubit rotation on the Bloch sphere. By composing and stacking,
we can also create the CNOT gate. Therefore, we have a universal gate set! We can also create the <span>\(0\)</span> state and
<span>\(+\)</span> state on any number of qubits. Therefore, we can represent any quantum state. Normalization might be needed
(e.g., for the CNOT gate) and we perform this by adding complex scalar vertices.</p>
<p>It turns out that the ability to represent an arbitrary state implies the ability to represent an arbitrary linear
map. Using a mathematical result called the Choi-Jamiolkowski isomorphism <a href="#jvdw2020" id="id6">4</a>, for any linear map <span>\(L\)</span>
from <span>\(n\)</span> to <span>\(m\)</span> wires, we can bend the incoming wires to the right and find an equivalent state on
<span>\(n + m\)</span> wires. Thus, any linear map is equivalent to some state, and since we can create any state,
we can create any map! This shows that ZX-diagrams are a universal tool for reasoning about linear maps. But this
doesn’t mean the representation is simple!</p>
<p>For a more in-depth introduction, see <a href="#coecke" id="id7">1</a> and <a href="#jvdw2020" id="id8">4</a>.</p>
</div>
<div id="zx-calculus-rewriting-rules">
<h2>ZX-calculus: rewriting rules<a href="#zx-calculus-rewriting-rules" title="Permalink to this headline">¶</a></h2>
<p>ZX-diagrams coupled with rewriting rules form the ZX-calculus. Previously, we presented the rules for composing and
stacking diagrams and talked about the topological symmetries corresponding to deformations. In this section,
we provide rewriting rules that can be used to simplify diagrams without changing the underlying linear map. This can
be very useful for quantum circuit optimization and for showing that some computations have a very simple form in the
ZX framework (e.g., teleportation).</p>
<p>In the following rules, the colours are interchangeable.</p>
<ol>
<li><p>Since the X-gate and Z-gate do not commute, non-phaseless vertices of different color do not commute.</p></li>
<li><p>The <strong>fuse</strong> rule applies when two spiders of the same type are connected by one or more wires. We can fuse
spiders by simply adding the two spiders’ phases and removing the connecting wires.</p>
<div id="id38">
<p><a href="https://pennylane.ai/qml/_images/f_rule.jpeg"><img alt="../_images/f_rule.jpeg" src="https://pennylane.ai/qml/_images/f_rule.jpeg"/></a></p><p><span>The (f)use rule.</span><a href="#id38" title="Permalink to this image">¶</a></p>
</div>
</li>
<li><p>The <span>\(\pi\)</span> <strong>-copy</strong> rule describes how to pull an X-gate through a Z-spider (or a Z-gate through an X-spider).
Since X and Z anticommute, pulling the X-gate through a Z-spider introduces a minus sign into the Z phase.</p>
<div id="id39">
<p><a href="https://pennylane.ai/qml/_images/pi_rule.jpeg"><img alt="../_images/pi_rule.jpeg" src="https://pennylane.ai/qml/_images/pi_rule.jpeg"/></a></p><p><span>The (<span>\(\pi\)</span>)-copy rule.</span><a href="#id39" title="Permalink to this image">¶</a></p>
</div>
</li>
<li><p>The <strong>state-copy</strong> rule captures how simple one-qubit states interact with a spider of the opposite colour. It
is only valid for states that are multiples of <span>\(\pi\)</span> (therefore <span>\(a\)</span> is an integer), so we have
computational basis states (in the X or Z basis). Basically, if you pull a basis state through a spider of the
opposite color, it copies it onto each outgoing wire.</p>
<div id="id40">
<p><a href="https://pennylane.ai/qml/_images/c_rule.jpg"><img alt="../_images/c_rule.jpg" src="https://pennylane.ai/qml/_images/c_rule.jpg"/></a></p><p><span>The state (c)opy rule, where <span>\(a\)</span> is an integer.</span><a href="#id40" title="Permalink to this image">¶</a></p>
</div>
</li>
<li><p>The <strong>identity</strong> rule states that phaseless spiders with one input and one output are equivalent to the identity
and can therefore be removed. This is similar to the rule that Z and X rotation gates, which are phaseless,
are equivalent to the identity. This rule provides a way to get rid of self-loops.</p>
<div id="id41">
<p><a href="https://pennylane.ai/qml/_images/id_rule.jpeg"><img alt="../_images/id_rule.jpeg" src="https://pennylane.ai/qml/_images/id_rule.jpeg"/></a></p><p><span>The (id)entity removal rule.</span><a href="#id41" title="Permalink to this image">¶</a></p>
</div>
</li>
<li><p>A <strong>bialgebra</strong> is a mathematical structure with a product (combining two wires into one) and a coproduct (
splitting a wire into two wires) where, roughly speaking, we can pull a product through a coproduct at the cost of
doubling. This is similar to the relation enjoyed by the XOR algebra and the COPY coalgebra. This rule is not
straightforward to verify and details can be found in <a href="#jvdw2020" id="id9">4</a> .</p>
<div id="id42">
<p><a href="https://pennylane.ai/qml/_images/b_rule.jpg"><img alt="../_images/b_rule.jpg" src="https://pennylane.ai/qml/_images/b_rule.jpg"/></a></p><p><span>The (b)ialgebra rule.</span><a href="#id42" title="Permalink to this image">¶</a></p>
</div>
</li>
<li><p>The <strong>Hopf</strong> rule is a bit like the bialgebra rule, telling us what happens when we try to pull a coproduct
through a product. Instead of doubling, however, they decouple, leaving us with an unconnected projector and a state.
Again, this relation is satisfied by XOR and COPY, and the corresponding algebraic structure is called a Hopf
algebra. This turns out to follow from the bialgebra and the state-copy rule <a href="#jvdw2020" id="id10">4</a>, but it’s useful to record
it as a separate rule.</p>
<div id="id43">
<p><a href="https://pennylane.ai/qml/_images/hopf_rule.jpeg"><img alt="../_images/hopf_rule.jpeg" src="https://pennylane.ai/qml/_images/hopf_rule.jpeg"/></a></p><p><span>The (ho)pf rule.</span><a href="#id43" title="Permalink to this image">¶</a></p>
</div>
</li>
</ol>
</div>
<div id="teleportation">
<h2>Teleportation<a href="#teleportation" title="Permalink to this headline">¶</a></h2>
<p>Now that we have all the necessary tools, let’s see how to describe teleportation as a ZX-diagram and simplify it
with our rewriting rules. The results are surprisingly elegant! We follow the explanation from <a href="#jvdw2020" id="id11">4</a>. You can
find an introduction to teleportation in
<a href="https://pennylane.ai/qml/demos/tutorial_mbqc.html">the MBQC demo</a>.</p>
<p>Teleportation is a protocol for transferring quantum information (a state) from Alice (the sender) to Bob (the
receiver). To perform this, Alice and Bob first need to share a maximally entangled state. The protocol for Alice to send
her quantum state to Bob is as follows:</p>
<ol>
<li><p>Alice applies the CNOT gate followed by the Hadamard gate.</p></li>
<li><p>Alice measures the two qubits that she has.</p></li>
<li><p>Alice sends the two measurement results to Bob.</p></li>
<li><p>Given the results, Bob conditionally applies the Z- and X-gate to his qubit.</p></li>
<li><p>Bob ends up with the same state as Alice previously had. Teleportation is complete!</p></li>
</ol>
<p>In the ordinary quantum circuit notation, we can summarize the procedure as follows:</p>
<div id="id44">
<p><a href="https://pennylane.ai/qml/_images/teleportation_circuit.jpeg"><img alt="../_images/teleportation_circuit.jpeg" src="https://pennylane.ai/qml/_images/teleportation_circuit.jpeg"/></a></p><p><span>The teleportation circuit.</span><a href="#id44" title="Permalink to this image">¶</a></p>
</div>
<p>Let us convert this quantum circuit into a ZX-diagram. The measurements are represented by the state X-spider
parameterized with boolean parameters <span>\(\alpha\)</span> and <span>\(\beta\)</span>. The cup represents the maximally entangled
state shared between Alice and Bob. As you might expect from earlier comments about bending wires, their shared state
is Choi-Jamiolkowski-equivalent to the identity linear map.</p>
<p>Let’s simplify the diagram by applying some rewriting rules. The first step is to fuse the <span>\(a\)</span> state with the
X-spider of the CNOT. We also merge the Hadamard gate with the <span>\(\beta\)</span> state, because together it represents a
Z-spider. Then we can fuse the three Z-spiders by simply adding their phases. After that, we see that the Z-spider
phase vanishes (modulo <span>\(2\pi\)</span>) and can therefore be simplified using the identity rule. Then we can fuse the
two X-spiders by adding their phases. We notice that the phase again vanishes modulo <span>\(2\pi\)</span> and we can get rid
of the last X-spider. Teleportation is a simple wire connecting Alice and Bob!</p>
<div id="id45">
<p><a href="https://pennylane.ai/qml/_images/teleportation.png"><img alt="../_images/teleportation.png" src="https://pennylane.ai/qml/_images/teleportation.png"/></a></p><p><span>The teleportation ZX-diagram simplified from <a href="#jvdw2020" id="id12">4</a> but there is a scalar factor because of a different
scalar convention. You are now able to understand, step by step, the teleportation gif from the beginning of this
tutorial!</span><a href="#id45" title="Permalink to this image">¶</a></p>
</div>
</div>
<div id="the-zxh-calculus">
<h2>The ZXH-calculus<a href="#the-zxh-calculus" title="Permalink to this headline">¶</a></h2>
<p>The universality of the ZX-calculus does not guarantee the existence of a simple representation, even for simple
linear maps. For example, the Toffoli gate (the quantum AND gate) requires around 25 spiders (Z and X)! We previously
introduced the Hadamard gate as a yellow box, which motivates the introduction of a new generator: the multi-leg H-box,
defined as follows:</p>
<div id="id46">
<p><a href="https://pennylane.ai/qml/_images/h_box.jpg"><img alt="../_images/h_box.jpg" src="https://pennylane.ai/qml/_images/h_box.jpg"/></a></p><p><span>The H-box, a third generator.</span><a href="#id46" title="Permalink to this image">¶</a></p>
</div>
<p>The parameter <span>\(a\)</span> can be any complex number, and the sum  is over all <span>\(i_1, ... , i_m, j_1, ... ,
j_n \in \{0, 1\}\)</span>. Therefore, an H-box represents a matrix where its entries are equal to <span>\(1\)</span> except for the
bottom right element, which is <span>\(a\)</span>. This will allow us to concisely express the Toffoli gate, as we will see
shortly.</p>
<p>An H-box with one input wire and one output wire, with <span>\(a=-1\)</span>, is a Hadamard gate up to global phase. Thus,
we omit the parameter when it is equal to <span>\(-1\)</span>. The Hadamard gate is sometimes represented by a blue edge
rather than a box.</p>
<p>Thanks to the introduction of the multi-leg H-box, the Toffoli gate can be represented with three Z-spiders and three
H-boxes — two simple Hadamard gates and one three-ary H-box — as shown below:</p>

<p>The addition of the multi-leg H-box together with an additional set of rewriting rules forms the ZXH-calculus. You can
find more details and the rewriting rules in the literature <a href="#east2021" id="id13">3</a>.</p>
<p>Let’s show that this ZXH-diagram is indeed a Toffoli-gate. This operation is defined by conditionally applying an
X-gate on the target wire, it means that only the state <span>\(\ket{110}\)</span> and <span>\(\ket{111}\)</span> will not map to
themselves (<span>\(\ket{110}\)</span> to <span>\(\ket{111}\)</span> and <span>\(\ket{111}\)</span> to <span>\(\ket{110}\)</span>). We will show that if
one provides the state <span>\(\ket{11}\)</span> on the two first wires, it results to a bit flip on the third wire (X-gate).
For that purpose, we need to add a new rewriting rule that is part of the ZXH-calculus: the <strong>absorb</strong> rule.</p>
<div id="id48">
<p><a href="https://pennylane.ai/qml/_images/absorb.jpg"><img alt="../_images/absorb.jpg" src="https://pennylane.ai/qml/_images/absorb.jpg"/></a></p><p><span>The (ab)sorb rule.</span><a href="#id48" title="Permalink to this image">¶</a></p>
</div>
<p>We start by applying our Toffoli diagram on a <span>\(\ket{11}\)</span> state, which corresponds to two X-spiders with a phase
of <span>\(\pi\)</span> stacked with our diagram. We apply the copy rule on the two groups of X-spiders and Z-spiders on the
wires 0 and 1. After that we can apply the newly introduced absorb rule on one of the X-spiders connected to the
H-Box. Then we recognize the Fourier relation and can replace the X-spider and H-Box by a Z-spider. Then it is easy
to apply the fuse rule on the two Z-spiders. Again, we recognize the Fourier relation and obtain a single X-spider on
the target wire. We just proved that by providing the <span>\(\ket{11}\)</span> state on the two control wires,
it always applies an X-spider on the target. It means that we have a bit flip on the target.</p>
<div id="id49">
<p><a href="https://pennylane.ai/qml/_images/11ccnot.jpg"><img alt="../_images/11ccnot.jpg" src="https://pennylane.ai/qml/_images/11ccnot.jpg"/></a></p><p><span>Toffoli-diagram applied on the <span>\(\ket{11}\)</span> state.</span><a href="#id49" title="Permalink to this image">¶</a></p>
</div>
<p>If you do the same procedure with the others states on the two controls (<span>\(\ket{00}\)</span>, <span>\(\ket{11}\)</span>,
<span>\(\ket{10}\)</span>, <span>\(\ket{01}\)</span>) with slightly different rules (the explosion rule), you will always end up with
an empty target and identical states for the controls. We then have proved that our ZXH-diagram is indeed the Toffoli
gate!</p>
</div>
<div id="the-zx-calculus-for-quantum-machine-learning">
<h2>The ZX-calculus for quantum machine learning<a href="#the-zx-calculus-for-quantum-machine-learning" title="Permalink to this headline">¶</a></h2>
<p>We now move away from the standard use of the ZX-calculus in order to show its utility for calculus and,
more specifically, for quantum derivatives (<a href="https://pennylane.ai/qml/glossary/parameter_shift.html">the parameter-shift rule</a>). What follows is not implemented in PennyLane or PyZX.
By adding derivatives to the framework, it shows that the ZX-calculus has a role to play in analyzing quantum machine
learning problems. After reading this section, you should be convinced that the ZX-calculus can be used to study any
kind of quantum-related problem.</p>
<p>Indeed, not only is the ZX-calculus useful for representing and simplifying quantum circuits, but it was shown that we
can use it to represent gradients and integrals of parameterized quantum circuits <a href="#zhao2021" id="id14">5</a> . In this section,
we will follow the proof of the theorem that shows how the derivative of the expectation value of a Hamiltonian
given a parameterized state can be derived as a ZX-diagram (theorem 2 of Zhao et al. <a href="#zhao2021" id="id15">5</a>). We will also show
that the theorem can be used to prove the parameter-shift rule!</p>
<div id="partial-derivative-as-a-zx-diagram">
<h3>Partial derivative as a ZX-diagram<a href="#partial-derivative-as-a-zx-diagram" title="Permalink to this headline">¶</a></h3>
<p>Let’s first describe the problem. Without loss of generalization, let’s suppose that we begin with the pure state
<span>\(\ket{0}\)</span> on all <span>\(n\)</span> qubits. Then we apply a parameterized unitary <span>\(U\)</span> that depends on <span>\(\vec{
\theta}=(\theta_1, ..., \theta_m)\)</span>, where <span>\(\theta_i \in [0, 2\pi]\)</span>.</p>
<p>Consequently, the expectation value of a Hamiltonian <span>\(H\)</span> is given by:</p>
<p>
\[\braket{H} = \bra{0} U(\vec{\theta}) H U(\vec{\theta})^{\dagger} \ket{0}.\]</p>
<p>We have seen that any circuit can be represented by a ZX diagram, but once again, we want to use the graph-like form
(see the Graph optimization and circuit extraction section). There are multiple rules that ensure the transformation
to a graph-like diagram. We replace the 0 state by red phaseless spiders, and we transform the parameterized circuit
to its graph-like ZX diagram. We call the obtained diagram <span>\(G_U(\vec{\theta})\)</span>, this diagram is equal to
the unitary up to a constant <span>\(c\)</span>.</p>
<p><a href="https://pennylane.ai/qml/_images/hamiltonian_diagram.jpg"><img alt="../_images/hamiltonian_diagram.jpg" src="https://pennylane.ai/qml/_images/hamiltonian_diagram.jpg"/></a>
</p>
<p>Now we will investigate the partial derivative of the diagram representing the expectation value. The theorem is
the following:</p>
<div id="id50">
<p><a href="https://pennylane.ai/qml/_images/theorem2.jpg"><img alt="../_images/theorem2.jpg" src="https://pennylane.ai/qml/_images/theorem2.jpg"/></a></p><p><span>Theorem 2: The derivative of the expectation value of a Hamiltonian given a parameterized as a ZX-diagram.</span><a href="#id50" title="Permalink to this image">¶</a></p>
</div>
<p>Let’s prove theorem 2, and first we consider a partial derivative on the spider with respect to <span>\(\theta_j\)</span>. The
spider necessarily appears on both sides, but they have phases of opposite signs and inverse inputs/outputs. By simply
writing their definitions and expanding the formula, we obtain:</p>
<div id="id51">
<p><a href="https://pennylane.ai/qml/_images/symmetric_spiders.jpg"><img alt="../_images/symmetric_spiders.jpg" src="https://pennylane.ai/qml/_images/symmetric_spiders.jpg"/></a></p><p><span>Two Z-spiders depending on the <span>\(j\)</span>-th angle.</span><a href="#id51" title="Permalink to this image">¶</a></p>
</div>
<p>Now we have a simple formula where we can easily take the derivative:</p>
<div id="id52">
<p><a href="https://pennylane.ai/qml/_images/derivative_symmetric_spiders.jpg"><img alt="../_images/derivative_symmetric_spiders.jpg" src="https://pennylane.ai/qml/_images/derivative_symmetric_spiders.jpg"/></a></p><p><span>The derivative of two spiders depending on the <span>\(j\)</span>-th angle.</span><a href="#id52" title="Permalink to this image">¶</a></p>
</div>
<p>The theorem 2 is proved — we just expressed the partial derivative as a ZX-diagram!</p>
</div>
<div id="parameter-shift-rule-as-a-zx-diagram">
<h3>Parameter-shift rule as a ZX-diagram<a href="#parameter-shift-rule-as-a-zx-diagram" title="Permalink to this headline">¶</a></h3>
<p>This theorem can be used to prove the parameter-shift rule. Let’s consider the following ansatz that we transform to
its graph-like diagram.</p>
<div id="id53">
<p><a href="https://pennylane.ai/qml/_images/param_shift_1_0.jpg"><img alt="../_images/param_shift_1_0.jpg" src="https://pennylane.ai/qml/_images/param_shift_1_0.jpg"/></a></p><p><span>The circuit (on the left) is translated to a ZX-diagram.</span><a href="#id53" title="Permalink to this image">¶</a></p>
</div>
<div id="id54">
<p><a href="https://pennylane.ai/qml/_images/param_shift_1_1.jpg"><img alt="../_images/param_shift_1_1.jpg" src="https://pennylane.ai/qml/_images/param_shift_1_1.jpg"/></a></p><p><span>The whole circuit is translated to a graph-like ZX-diagram.</span><a href="#id54" title="Permalink to this image">¶</a></p>
</div>
<p>We then apply the previous theorem to get the partial derivative relative to <span>\(\theta_1\)</span>.</p>
<div id="id55">
<p><a href="https://pennylane.ai/qml/_images/param_shift_1_2.jpg"><img alt="../_images/param_shift_1_2.jpg" src="https://pennylane.ai/qml/_images/param_shift_1_2.jpg"/></a></p><p><span>The derivative is applied on the ZX-diagram</span><a href="#id55" title="Permalink to this image">¶</a></p>
</div>
<p>The second step is to take the X-spider with phase <span>\(\pi\)</span> and explicitly write the formula <span>\(\ket{+}\bra{+}
- \ket{-}\bra{-}\)</span>. We can then separate the diagram into two parts by recalling the definition of the <span>\(\ket{+}\)</span>
(phaseless Z-spider) and <span>\(\ket{-}\)</span> (<span>\(2\pi\)</span> Z-spider) states and using the fusion rule for the Z-spider.
We obtain the parameter-shift rule!</p>
<div id="id56">
<p><a href="https://pennylane.ai/qml/_images/param_shift_2.jpg"><img alt="../_images/param_shift_2.jpg" src="https://pennylane.ai/qml/_images/param_shift_2.jpg"/></a></p><p><span>By using theorem 2, we can add an X-spider and shift the phases in the Z-spiders. Then, by explicitly decomposing
the spider with the <span>\(\ket{+}\)</span> and <span>\(\ket{-}\)</span>  states, we prove the parameter-shift rule!</span><a href="#id56" title="Permalink to this image">¶</a></p>
</div>
<p>You can find more information about the differentiation and integration of ZX-diagrams with QML applications in the
following paper <a href="#wang2022" id="id16">6</a>.</p>
</div>
</div>
<div id="zx-diagrams-with-pennylane">
<h2>ZX-diagrams with PennyLane<a href="#zx-diagrams-with-pennylane" title="Permalink to this headline">¶</a></h2>
<p>Now that we have introduced the formalism of the ZX-calculus, let’s dive into some code and show what you can do with
PennyLane! PennyLane v0.28 added ZX-calculus functionality to the fold. You can use the
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.transforms.to_zx.html#pennylane.transforms.to_zx" title="(in PennyLane v0.30)"><code><span>to_zx()</span></code></a> transform decorator to get a ZX-diagram from a PennyLane
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="(in PennyLane v0.30)"><code><span>QNode</span></code></a>, while <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.transforms.from_zx.html#pennylane.transforms.from_zx" title="(in PennyLane v0.30)"><code><span>from_zx()</span></code></a> transforms a ZX-diagram into a PennyLane
tape. We are using the PyZX library <a href="#pyzx" id="id17">2</a> under the hood to represent the ZX diagram. Once your circuit is a PyZX
graph, you can draw it, apply some optimization, extract the underlying circuit, and go back to PennyLane.</p>
<p>Let’s start with a very simple circuit consisting of three gates and show that you can represent the
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="(in PennyLane v0.30)"><code><span>QNode</span></code></a> as a PyZX diagram:</p>

<p>Now that you have a ZX-diagram as a PyZx object, you can use all the tools from the PyZX library to transform the
graph. You can simplify the circuit, draw it, and get a new understanding of your quantum computation.</p>
<p>For example, you can use the matplotlib drawer to get a visualization of the diagram. The drawer returns a
<code><span>matplotlib</span></code> figure, and therefore you can save it locally with <cite>savefig</cite> function, or simply show it locally.</p>
<div><div><pre><span></span><span>fig</span> <span>=</span> <span>pyzx</span><span>.</span><span>draw_matplotlib</span><span>(</span><span>g</span><span>)</span>

<span># The following lines are added because the figure is automatically closed by PyZX.</span>
<span>manager</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>()</span><span>.</span><span>canvas</span><span>.</span><span>manager</span>
<span>manager</span><span>.</span><span>canvas</span><span>.</span><span>figure</span> <span>=</span> <span>fig</span>
<span>fig</span><span>.</span><span>set_canvas</span><span>(</span><span>manager</span><span>.</span><span>canvas</span><span>)</span>

<span>plt</span><span>.</span><span>show</span><span>()</span>
</pre></div>
</div>
<p><img src="https://pennylane.ai/qml/_images/sphx_glr_tutorial_zx_calculus_001.png" srcset="../_images/sphx_glr_tutorial_zx_calculus_001.png" alt="tutorial zx calculus"/></p><p>You can also take a ZX-diagram in PyZX, convert it into a PennyLane tape and use it in your
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="(in PennyLane v0.30)"><code><span>QNode</span></code></a>. Invoking the PyZX circuit generator:</p>
<div><div><pre><span></span><span>import</span> <span>random</span>

<span>random</span><span>.</span><span>seed</span><span>(</span><span>42</span><span>)</span>
<span>random_circuit</span> <span>=</span> <span>pyzx</span><span>.</span><span>generate</span><span>.</span><span>CNOT_HAD_PHASE_circuit</span><span>(</span><span>qubits</span><span>=</span><span>3</span><span>,</span> <span>depth</span><span>=</span><span>10</span><span>)</span>
<span>print</span><span>(</span><span>random_circuit</span><span>.</span><span>stats</span><span>())</span>

<span>graph</span> <span>=</span> <span>random_circuit</span><span>.</span><span>to_graph</span><span>()</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumScript.html#pennylane.tape.QuantumScript" title="pennylane.tape.QuantumScript"><span>tape</span></a> <span>=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.transforms.from_zx.html#pennylane.transforms.from_zx" title="pennylane.transforms.from_zx"><span>qml</span><span>.</span><span>transforms</span><span>.</span><span>from_zx</span></a><span>(</span><span>graph</span><span>)</span>
<span>print</span><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumScript.html#pennylane.tape.QuantumScript.operations" title="pennylane.tape.QuantumScript.operations"><span>tape</span><span>.</span><span>operations</span></a><span>)</span>
</pre></div>
</div>
<p>Out:</p>
<div><div><pre><span></span>Circuit  on 3 qubits with 10 gates.
        4 is the T-count
        6 Cliffords among which
        5 2-qubit gates (5 CNOT, 0 other) and
        1 Hadamard gates.
[T(wires=[0]), T(wires=[0]), CNOT(wires=[2, 0]), T(wires=[2]), CNOT(wires=[1, 0]), CNOT(wires=[0, 2]), T(wires=[2]), Hadamard(wires=[0]), CNOT(wires=[2, 1]), CNOT(wires=[2, 1])]
</pre></div>
</div>
<p>We get a tape corresponding to the randomly generated circuit that we can use in any <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="(in PennyLane v0.30)"><code><span>QNode</span></code></a>. This
functionality will be very useful for our next topic: circuit optimization.</p>
</div>
<div id="diagram-optimization-and-circuit-extraction">
<h2>Diagram optimization and circuit extraction<a href="#diagram-optimization-and-circuit-extraction" title="Permalink to this headline">¶</a></h2>
<p>The ZX-calculus is more general and more flexible than the usual circuit representation. We can therefore represent
circuits with ZX-diagrams and apply rewriting rules to simplify them — like we did for teleportation. But, not every
ZX-diagram has a corresponding circuit. To get back to circuits, a method for circuit extraction is needed. For
a rigorous introduction to this active and promising field of application, see <a href="#duncan2020" id="id18">7</a>. The basic idea is
captured below:</p>
<div id="id57">
<p><a href="https://pennylane.ai/qml/_images/circuit_opt.jpg"><img alt="../_images/circuit_opt.jpg" src="https://pennylane.ai/qml/_images/circuit_opt.jpg"/></a></p><p><span>The simplification and extraction of ZX-diagrams, content from page 2 of <a href="#duncan2020" id="id19">7</a>.</span><a href="#id57" title="Permalink to this image">¶</a></p>
</div>
<p>To simplify ZX-diagrams, not only can we use the rewriting rules defined previously, but we can also use graph-theoretic
transformations called local complementation and pivoting. These are special transformations that can only be
applied to “graph-like” ZX-diagrams. As defined in <a href="#duncan2020" id="id20">7</a>, a ZX-diagram is graph-like if</p>
<ol>
<li><p>All spiders are Z-spiders.</p></li>
<li><p>Z-spiders are only connected via Hadamard edges.</p></li>
<li><p>There are no parallel Hadamard edges or self-loops.</p></li>
<li><p>Every input or output is connected to a Z-spider and every Z-spider is connected to at most one input or output.</p></li>
</ol>
<p>A ZX-diagram is called a graph state if it is graph-like: every spider is connected to an output and there are no
phaseless spiders. Furthermore, it was proved that every ZX-diagram is equal to a graph-like ZX-diagram. Thus,
after conversion into graph-like form, we can use graph-theoretic tools on all ZX-diagrams.</p>
<p>The basic idea is to use the graph-theoretic transformations to get rid of as many interior spiders as possible.
Interior spiders are the one without inputs or outputs connected to them. We introduce some names for the spiders
depending on their phases:</p>
<ol>
<li><p>A Pauli spider has a phase that is a multiple of <span>\(\pi\)</span>.</p></li>
<li><p>A Clifford spider has a phase that is a multiple of <span>\(\frac{\pi}{2}\)</span>.</p></li>
<li><p>A proper Clifford spider is a Clifford spider with a phase which is an odd multiple of <span>\(\frac{\pi}{2}\)</span>.</p></li>
</ol>
<p>Theorem 5.4 in <a href="#duncan2020" id="id21">7</a> provides an algorithm which takes a graph-like diagram and performs the following:</p>
<ol>
<li><p>Remove all interior proper Clifford spiders,</p></li>
<li><p>Remove adjacent pairs of interior Pauli spiders,</p></li>
<li><p>Remove interior Pauli spiders adjacent to a boundary spider.</p></li>
</ol>
<p>This procedure is implemented in PyZX as the <code><span>full_reduce()</span></code> function. The complexity of the procedure is
<span>\(\mathcal{O}(n^3)\)</span>, where <span>\(n\)</span> is the number of spiders. Let’s create an example with the circuit
<a href="https://github.com/njross/optimizer/blob/master/Arithmetic_and_Toffoli/mod5_4_before">mod_5_4</a>. The circuit
<span>\(63\)</span> gates: <span>\(28\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="(in PennyLane v0.30)"><code><span>T</span></code></a>. gates, <span>\(28\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="(in PennyLane v0.30)"><code><span>CNOT</span></code></a>, <span>\(6\)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="(in PennyLane v0.30)"><code><span>Hadamard</span></code></a> and <span>\(1\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="(in PennyLane v0.30)"><code><span>PauliX</span></code></a>.</p>
<div><div><pre><span></span><span>dev</span> <span>=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device"><span>qml</span><span>.</span><span>device</span></a><span>(</span><span>&#34;default.qubit&#34;</span><span>,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>5</span><span>)</span>


<span>@qml</span><span>.</span><span>transforms</span><span>.</span><span>to_zx</span>
<span>@qml</span><span>.</span><span>qnode</span><span>(</span><span>device</span><span>=</span><span>dev</span><span>)</span>
<span>def</span> <span>mod_5_4</span><span>():</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX"><span>qml</span><span>.</span><span>PauliX</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>4</span><span>),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard"><span>qml</span><span>.</span><span>Hadamard</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>4</span><span>),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>3</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>]))</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>3</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>3</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>]))</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>3</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard"><span>qml</span><span>.</span><span>Hadamard</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>3</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard"><span>qml</span><span>.</span><span>Hadamard</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>4</span><span>),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>]))</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard"><span>qml</span><span>.</span><span>Hadamard</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>2</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard"><span>qml</span><span>.</span><span>Hadamard</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>4</span><span>),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint"><span>qml</span><span>.</span><span>adjoint</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T"><span>qml</span><span>.</span><span>T</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>])),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard"><span>qml</span><span>.</span><span>Hadamard</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>1</span><span>,</span> <span>4</span><span>]),</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT"><span>qml</span><span>.</span><span>CNOT</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>[</span><span>0</span><span>,</span> <span>4</span><span>]),</span>
    <span>return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval"><span>qml</span><span>.</span><span>expval</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ"><span>qml</span><span>.</span><span>PauliZ</span></a><span>(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires"><span>wires</span></a><span>=</span><span>0</span><span>))</span>


<span>g</span> <span>=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode"><span>mod_5_4</span></a><span>()</span>
<span>pyzx</span><span>.</span><span>simplify</span><span>.</span><span>full_reduce</span><span>(</span><span>g</span><span>)</span>

<span>fig</span> <span>=</span> <span>pyzx</span><span>.</span><span>draw_matplotlib</span><span>(</span><span>g</span><span>)</span>

<span># The following lines are added because the figure is automatically closed by PyZX.</span>
<span>manager</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>()</span><span>.</span><span>canvas</span><span>.</span><span>manager</span>
<span>manager</span><span>.</span><span>canvas</span><span>.</span><span>figure</span> <span>=</span> <span>fig</span>
<span>fig</span><span>.</span><span>set_canvas</span><span>(</span><span>manager</span><span>.</span><span>canvas</span><span>)</span>

<span>plt</span><span>.</span><span>show</span><span>()</span>
</pre></div>
</div>
<p><img src="https://pennylane.ai/qml/_images/sphx_glr_tutorial_zx_calculus_002.png" srcset="../_images/sphx_glr_tutorial_zx_calculus_002.png" alt="tutorial zx calculus"/></p><p>We see that after applying the procedure, we end up with only 16 interior Z-spiders and 5 boundary spiders. We also
see that all non-Clifford phases appear on the interior spiders. The simplification procedure was successful,
but we have a graph-like ZX-diagram with no quantum circuit equivalent. We need to extract a circuit!</p>
<p>The extraction of circuits is a highly non-trivial task and can be a #P-hard problem as shown in this paper <a href="#beaudrap2021" id="id22">9</a> by de Beaudrap et al . There are
two different algorithms introduced in the same paper. First, for Clifford circuits, the procedure will erase all
interior spiders, and the diagram is left in a graph-state from which a Clifford circuit can be
extracted using a total of eight layers with only one layer of CNOTs.</p>
<p>For non-Clifford circuits, the problem is more complex because we are left with non-Clifford interior spiders. From
the diagram produced by the simplification procedure, the extraction progresses through the diagram from
right-to-left, consuming gates on the left and adding gates on the right. It produces better results than other
cut-and-resynthesize techniques. The extraction procedure is implemented in PyZX as the function
<cite>pyzx.circuit.extract_circuit</cite>. We can apply this procedure to the example <cite>mod_5_4</cite> above:</p>
<div><div><pre><span></span><span>circuit_extracted</span> <span>=</span> <span>pyzx</span><span>.</span><span>extract_circuit</span><span>(</span><span>g</span><span>.</span><span>copy</span><span>())</span>
<span>print</span><span>(</span><span>circuit_extracted</span><span>.</span><span>stats</span><span>())</span>
</pre></div>
</div>
<p>Out:</p>
<div><div><pre><span></span>Circuit  on 5 qubits with 56 gates.
        8 is the T-count
        48 Cliffords among which
        22 2-qubit gates (0 CNOT, 22 other) and
        26 Hadamard gates.
</pre></div>
</div>
<div id="example-t-count-optimization">
<h3>Example: T-count optimization<a href="#example-t-count-optimization" title="Permalink to this headline">¶</a></h3>
<p>A concrete application of these ZX optimization techniques is the reduction of the expensive non-Clifford T-count
of a quantum circuit. Indeed, T-count optimization is an area where the ZX-calculus has shown very good results <a href="#kissinger2021" id="id23">8</a> .</p>
<p>Let’s start by using with the <cite>mod_5_4</cite> circuit introduced above. We applied the <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.transforms.to_zx.html#pennylane.transforms.to_zx" title="(in PennyLane v0.30)"><code><span>to_zx()</span></code></a>
decorator in order to transform our circuit to a ZX graph. You can get this PyZX graph by calling the
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="(in PennyLane v0.30)"><code><span>QNode</span></code></a>:</p>
<div><div><pre><span></span><span>g</span> <span>=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode"><span>mod_5_4</span></a><span>()</span>
<span>t_count</span> <span>=</span> <span>pyzx</span><span>.</span><span>tcount</span><span>(</span><span>g</span><span>)</span>
<span>print</span><span>(</span><span>&#34;T count before optimization:&#34;</span><span>,</span> <span>t_count</span><span>)</span>
</pre></div>
</div>
<p>Out:</p>
<div><div><pre><span></span>T count before optimization: 28
</pre></div>
</div>
<p>PyZX gives multiple options for optimizing ZX graphs: <code><span>full_reduce()</span></code> and <code><span>teleport_reduce()</span></code>
to name a couple. The <code><span>full_reduce()</span></code> applies all optimization passes, but the final result may not be
circuit-like. Converting back to a quantum circuit from a fully reduced graph might be difficult or impossible.
Therefore, we instead recommend using <code><span>teleport_reduce()</span></code>, as it preserves the diagram structure.
Because of this, the circuit does not need to be extracted and can be directly sent back to PennyLane. Let’s see
how it works:</p>
<div><div><pre><span></span><span>g</span> <span>=</span> <span>pyzx</span><span>.</span><span>simplify</span><span>.</span><span>teleport_reduce</span><span>(</span><span>g</span><span>.</span><span>copy</span><span>())</span>
<span>opt_t_count</span> <span>=</span> <span>pyzx</span><span>.</span><span>tcount</span><span>(</span><span>g</span><span>)</span>
<span>print</span><span>(</span><span>&#34;T count after optimization:&#34;</span><span>,</span> <span>opt_t_count</span><span>)</span>
</pre></div>
</div>
<p>Out:</p>
<div><div><pre><span></span>T count after optimization: 8
</pre></div>
</div>
<p>The <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.transforms.from_zx.html#pennylane.transforms.from_zx" title="(in PennyLane v0.30)"><code><span>from_zx()</span></code></a> transform converts the optimized circuit back into PennyLane format,
and which is made possible because we used <cite>pyzx.teleport_reduce</cite> and do not need to extract
the circuit.</p>

<p>Out:</p>
<div><div><pre><span></span>Number of quantum gates: 53
Circuit gates: defaultdict(&lt;class &#39;int&#39;&gt;, {&#39;PauliX&#39;: 1, &#39;Hadamard&#39;: 6, &#39;CNOT&#39;: 28, &#39;T&#39;: 4, &#39;S&#39;: 6, &#39;Adjoint(T)&#39;: 4, &#39;Adjoint(S)&#39;: 4})
</pre></div>
</div>
<p>We have reduced the T-count! Taking a full census, the circuit contains <span>\(53\)</span> gates: <span>\(8\)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="(in PennyLane v0.30)"><code><span>T</span></code></a> gates, <span>\(28\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="(in PennyLane v0.30)"><code><span>CNOT</span></code></a>, <span>\(6\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="(in PennyLane v0.30)"><code><span>Hadamard</span></code></a>,
<span>\(1\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="(in PennyLane v0.30)"><code><span>PauliX</span></code></a> and <span>\(10\)</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.S.html#pennylane.S" title="(in PennyLane v0.30)"><code><span>S</span></code></a>. We successfully reduced the T-count by
20 and have 10 additional <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.S.html#pennylane.S" title="(in PennyLane v0.30)"><code><span>S</span></code></a> gates. The number of <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="(in PennyLane v0.30)"><code><span>CNOT</span></code></a> gates remained the
same.</p>
</div>
</div>
<div id="conclusion">
<h2>Conclusion<a href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>Now that you have read this tutorial, you should be able to use the ZX-calculus to solve your quantum problems.
You can describe quantum circuits with the ZX-spiders and the H-box and create ZXH-diagrams.
Furthermore, you can use the simplifying rules to get another view of the underlying structure of your
circuit. We have proved its utility for optimizing quantum circuits and shown that the
ZX-calculus is more than promising for quantum machine learning. It was not covered in this introduction, but the
ZX-calculus can also be used for quantum-error correction — it’s no wonder why some quantum physicists
call ZX-calculus the “Swiss army knife” of quantum computing tools!</p>
</div>
<div id="acknowledgement">
<h2>Acknowledgement<a href="#acknowledgement" title="Permalink to this headline">¶</a></h2>
<p>The author would also like to acknowledge the helpful inputs of Richard East, David Wakeham and Isaac De Vlugt. The
author is also thankful for the beautiful drawings by Guillermo Alonso and for the great thumbnail and teleportation
gif by Tarik El-Khateeb.</p>
</div>

<div id="about-the-author">
<h2>About the author<a href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div>
    <p><img src="https://pennylane.ai/qml/_static/authors/romain_moyard.jpg" alt="Romain Moyard"/>
    </p>
    <div>
        
        <p>Romain is currently a quantum software developer at Xanadu working on PennyLane. He works on developing useful quantum machine learning tools.</p>
    </div>
</div><p><strong>Total running time of the script:</strong> ( 0 minutes  0.304 seconds)</p>

<p><a href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div></div>
  </body>
</html>
