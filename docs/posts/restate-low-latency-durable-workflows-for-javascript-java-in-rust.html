<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://restate.dev/">Original</a>
    <h1>Show HN: Restate ‚Äì Low-latency durable workflows for JavaScript/Java, in Rust</h1>
    
    <div id="readability-page-1" class="page"><section><a href="https://restate.dev/blog/announcing-restate-1.0-restate-cloud-and-our-seed-funding-round/"><p>üéâ¬†¬†Announcing Restate 1.0, Restate¬†Cloud, and our Seed Funding Round ¬†¬†<span>Read more</span></p></a></section><div data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" data-doc-height="1" role="banner"><div><p><a href="https://restate.dev/" aria-current="page"><img src="https://cdn.prod.website-files.com/663272930a67769123cdcf53/66552a0c5a6f4d528f1241de_Logo%20Refined.svg" loading="lazy" alt=""/></a></p></div></div><section><div><div id="w-node-_909f3004-9317-0658-ea73-f830f9153f13-23cdcf59" data-w-id="909f3004-9317-0658-ea73-f830f9153f13"><p data-w-id="0e3c2fe2-55e6-bde5-39c2-cefd2408f0b6">As <strong>regular functions and services</strong>, in your existing infrastructure. On FaaS, K8s, servers, containers. Self-hosted or fully managed. Restate meets you where you are.</p></div><div id="w-node-_0a36f96d-1a2c-4e83-c438-e5e08296ce51-23cdcf59"><p><img src="https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background.png" loading="eager" sizes="(max-width: 479px) 261.75px, (max-width: 767px) 282.84375px, 554.75px" srcset="https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background-p-500.png 500w, https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background-p-800.png 800w, https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background-p-1080.png 1080w, https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background-p-1600.png 1600w, https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background-p-2000.png 2000w, https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background-p-2600.png 2600w, https://cdn.prod.website-files.com/663272930a67769123cdcf53/665bd80206cc423e5a2edcf2_hero-background.png 2752w" alt=""/></p></div></div></section><section><div data-w-id="c420d2f0-b483-a654-3cb5-e22ce4cf01f9"><h2 id="w-node-ebe6a069-89b1-fc5f-5813-61aed10405e5-23cdcf59">Easy solutions for common challenges</h2><div id="w-node-_987cb84f-9b03-aa32-df41-957747709f42-23cdcf59"><div id="w-node-_2a2f30dd-96c0-2fec-0599-0c9eac09cb8c-23cdcf59"><div fs-cmstabs-element="list" role="list"><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">Workflows as code</p><h4>Workflows as code</h4><div><p>Durable Execution ensures code runs reliably to the end, even in the presence of failures.</p><p>‚Äç</p><ul role="list"><li>Failures and errors are automatically retried (unless labeled as terminal errors)</li><li>Functions can memoize the results of code blocks, and actions like RPC, in a journal. Completed steps are not re-executed during retries, but replayed from the journal.</li><li>Workflows are built with regular code and control flow, no custom DSLs needed.</li><li>Durable sleeps let code wait and suspend for up to months</li></ul><p>‚Äç</p></div><p><a href="https://github.com/restatedev/examples/blob/main/basics/basics-typescript/src/1_durable_execution.ts" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
export default restate.service({
  name: &#34;roleUpdate&#34;,
  handlers: {
    applyRoleUpdate: async (ctx, update) =&gt; {
      const { userId, role, permissions } = update;
      const applied = await ctx.run(&#34;apply new role&#34;, () =&gt;
        applyUserRole(userId, role)
      );
      if (!applied) {
        return;
      }
      for (const permission of permissions) {
        await ctx.run(&#34;apply permission&#34;, () =&gt;
          applyPermission(userId, permission)
        );
      }
    }
  }
});
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
@Service
public class RoleUpdateService {

    @Handler
    public void applyRoleUpdate(Context ctx, Update update) {

        boolean success = ctx.run(&#34;apply new role&#34;, BOOLEAN,
            () -&gt; applyUserRole(update.getUserId(), update.getRole()));

        if (!success) {
            return;
        }

        for (String permission : update.getPermissions()) {
            ctx.run(&#34;apply permission&#34;,
                () -&gt; applyPermission(update.getUserId(), permission));
        }
    }
}
</code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">API calls and webhooks</p><h4>API calls and webhooks</h4><div><p>Reliably join synchronous code and async events like webhooks</p><ul role="list"><li>Webhooks/events are persisted in Restate‚Äôs log and reliably delivered to services</li><li>Persistent Promises/Futures easily join synchronous and asynchronous code paths</li><li>Durable execution ensures reliable completion, whether webhooks come after milliseconds or months, and avoid re-execution of completed steps.</li></ul></div><p><a href="https://github.com/restatedev/examples/tree/website_snippets_java/patterns-use-cases/async-signals-payment" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
const paymentSvc = restate.service({
  name: &#34;payments&#34;,
  handlers: {
    processPayment: async (ctx, request) =&gt; {
      const webhookPromise = ctx.awakeable();
      const paymentIntent = await ctx.run(&#34;stripe call&#34;, () =&gt;
        createPaymentIntent({
          request,
          metadata: { restate_callback_id: webhookPromise.id }
        })
      );
      if (paymentIntent.status === &#34;processing&#34;) {
        // synchronous response inconclusive, await webhook response
        const paymentIntentFromWebhook = await webhookPromise.promise;
        return verifyPayment(paymentIntentFromWebhook);
      } else {
        return verifyPayment(paymentIntent);
      }
    },
    processWebhook: async (ctx) =&gt; {
      const paymentIntent = verifyAndParseEvent(ctx.request());
      const webhookPromiseId = paymentIntent.metadata.restate_callback_id;
      ctx.resolveAwakeable(webhookPromiseId, paymentIntent);
    }
  }
});
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
@Service
public class PaymentService {
  @Handler
  public void processPayment(Context ctx, PaymentRequest request) {
    var webhookFuture = ctx.awakeable(SERDE);
    var payment = ctx.run(&#34;Stripe call&#34;, SERDE, () -&gt; submitPayment(
            request, Map.of(&#34;restate_callback_id&#34;, webhookFuture.id())
    ));
    if (payment.getStatus().equals(&#34;processing&#34;)) {
      // synchronous response inconclusive, await webhook response
      var updatedPayment = webhookFuture.await();
      verifyPayment(updatedPayment);
    } else {
      verifyPayment(payment);
    }
  }
  @Handler
  public void processWebhook(Context ctx) {
    var paymentEvent = verifyAndParseEvent(ctx.request());
    String callbackId = paymentEvent.getMetadata().get(&#34;restate_callback_id&#34;);
    ctx.awakeableHandle(callbackId).resolve(SERDE, paymentEvent);
  }
}
</code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">Asynchronous Tasks</p><h4>Asynchronous Tasks</h4><div><p>All functions invoked through Restate are executed durably and asynchronous.</p><ul role="list"><li>Deploy async functions serverless or as containers or processes.</li><li>Call functions synchronously, async, or delayed. Re-attach and await from anywhere.</li><li>Build async patterns like fan-out, fan-in, task chains, and subtasks simply with function calls and Futures/Promises.</li><li>Use persistent timers to schedule tasks into the future.</li><li>Use fine-grained virtual queues (via virtual objects) to enforce strict task order and concurrency</li></ul></div><p><a href="https://github.com/restatedev/examples/tree/website_snippets_java/patterns-use-cases/async-tasks" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
// ------ service (= worker) ------
const asyncTaskService = restate.service({
    name: &#34;taskWorker&#34;,
    handlers: { processPayment }
});
// ------ client ------
const rs = clients.connect({ url: process.env.RESTATE_URL });
const taskWorker = rs.serviceSendClient({ name: &#34;taskWorker&#34; });
// submit the payment task 
app.post(&#39;/charge/:paymentId&#39;, async (req, res) =&gt; {
    const taskHandle = await taskWorker.processPayment(
        { request: req.params },
        SendOpts.from({ idempotencyKey: req.params.paymentId })
    );
    res.json(taskHandle);
});
// await the payment task
app.get(&#39;/status&#39;, async (req,res) =&gt; {
        const taskHandle = req.body.json();
        const paymentResult = await restate.result(taskHandle); 
        res.join(paymentResult);
});
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
// --- start payment task ---
server.createContext(&#34;/charge&#34;, httpExchange -&gt; {
  PaymentRequest req = parsePaymentRequest(httpExchange);
  SendResponse handle = AsyncTaskServiceClient
      .fromIngress(RESTATE_URI)
      .send()
      .processPayment(req, idempotencyKey(req.getPaymentId()));

  respondJson(httpExchange, handle);
});
//  --- connect to payment result ---
server.createContext(&#34;/status&#34;, httpExchange -&gt; {
  String handle = parseToHandle(httpExchange);
  String response = IngressClient.defaultClient(RESTATE_URI)
      .invocationHandle(handle, STRING)
      .attach();
  respond(httpExchange, response);
});
</code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">Stateful Event Processing</p><h4>Stateful Event Processing</h4><div><p>Process events (for example from Kafka) with durable functions as event handlers and get fine-grained retries and workflow-as-code semantics.</p><ul role="list"><li>No queue subscriptions, no manual offset management, scaling, or balancing</li><li>Deploy the event processing logic as serverless functions on FaaS</li><li>Keep exactly-once state, delay events, run multiple asynchronous steps or API calls.</li><li>Restate‚Äôs queue-per-key semantics mean no more head-of-the-line waiting effects</li></ul></div><p><a href="https://github.com/restatedev/examples/blob/main/basics/basics-typescript/src/5_events_processing.ts" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
const eventEnricher = restate.object({
  name: &#34;eventEnricher&#34;,
  handlers: {
    userEvent: async (ctx, event) =&gt; {
      // remember event, time box 100 ms to collect features
      // before emitting result
      ctx.set(&#34;user&#34;, event);
      ctx.serviceSendClient(eventEnricher, { delay: 100 }).emit();
    },
    featureEvent: async (ctx, featureEvent) =&gt; {
      // merge feature into event
      const userEvent = (await ctx.get(&#34;user&#34;)) ?? {};
      (userEvent.features ??= []).push(featureEvent);
      ctx.set(&#34;user&#34;, userEvent)
    },
    emit: async (ctx) =&gt; {
      emit(ctx.key, await ctx.get(&#34;user&#34;));
      ctx.clearAll();
    }
  }
})
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
@VirtualObject
public class EventEnricher {
    static final StateKey<user> USER = StateKey.of(&#34;user&#34;, of(User.class));
    @Handler
    public void userEvent(ObjectContext ctx, User event) {
        ctx.set(USER, event);
        // time box 100 ms to collect features before emitting result
        EventEnricherClient.fromContext(ctx, ctx.key())
            .send(ofMillis(100)).emit();
    }
    @Handler
    public void featureEvent(ObjectContext ctx, Feature event) {
        User user = ctx.get(USER).orElse(new User());
        user.addFeature(event);
        ctx.set(USER, user);
    }
    @Handler
    public void emit(ObjectContext ctx) {
        send(ctx.key(), ctx.get(USER));
        ctx.clearAll();
    }
}
</user></code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">Durable Signals</p><h4>Durable Signals</h4><div><p>Create workflows and event handlers that reliably handle external signals, events, human input.</p><p>‚Äç</p><ul role="list"><li>Use durable Promises/Futures to intuitively model signals and conditions</li><li>Create signals from RPCs, webhooks, or Kafka events</li><li>Signals and events are persisted by Restate, no need for a queue</li></ul></div><p><a href="https://github.com/restatedev/examples/blob/main/basics/basics-typescript/src/3_workflows.ts" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
export default workflow({
  name: &#34;verify&#34;,
  handlers: {
    run: async (ctx, { email }) =&gt; {
      const secret = ctx.run(&#34;generate secret&#34;, () =&gt;
        crypto.randomUUID()
      );
      await ctx.run(&#34;send email&#34;, () =&gt; sendEmail({ email, secret }));

      const clickSecret = await ctx.promise(&#34;email.clicked&#34;);
      return clickSecret == secret;
    },
    click: (ctx, { secret }) =&gt; {
      ctx.promise(&#34;email.clicked&#34;).resolve(secret);
    },
  },
});



</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
@Workflow
public class SecretVerifier {

    static final DurablePromiseKey<string> EMAIL_CLICKED =
            DurablePromiseKey.of(&#34;email_clicked&#34;, JsonSerdes.STRING);

    @Workflow
    public boolean run(WorkflowContext ctx, Email email) {
        String secret = ctx.random().nextUUID().toString();
        ctx.run(&#34;send email&#34;,
            () -&gt; sendEmailWithLink(email, secret));

        String clickSecret = ctx.promise(EMAIL_CLICKED).awaitable().await();
        return clickSecret.equals(secret);
    }

    @Handler
    public void click(SharedWorkflowContext ctx, String secret) {
        ctx.promiseHandle(EMAIL_CLICKED).resolve(secret);
    }
}
</string></code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">Idempotency</p><h4>Idempotency</h4><div><p>Add idempotency to any RPC- or event handler.</p><p>‚Äç</p><ul role="list"><li>Every RPC- and event handler call accepts an idempotency key</li><li>Use idempotency keys to re-attach to an ongoing invocation</li><li>Calls from within a durable execution context are automatically idempotent</li></ul></div><p><a href="https://docs.restate.dev/concepts/invocations#idempotent-invocations" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
const rs = restate.connect({ url: process.env.RESTATE_URL });
app.get(&#39;/reserve/:product/:reservationId&#39;, async (req, res) =&gt; {
  const { product, reservationId } = req.params;
  const products = rs.serviceClient(ProductService);
  const reservation = await products.reserve(
    product,
    Opts.from({ idempotencyKey : reservationId })
  );
  res.json(reservation);
})
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
server.createContext(&#34;/reserve&#34;, httpExchange -&gt; {
      ReservationRequest req = parseRequest(httpExchange.getRequestBody());
      // derive an idempotency key from the parameters
      var idempotencyOps = CallRequestOptions.DEFAULT
          .withIdempotency(req.getReservationId());
      // add idempotency opts to the request to let the service automatically
      // fuse repeated requests
      Reservation reservation = ProductServiceClient
          .fromIngress(RESTATE_RUNTIME_ENDPOINT)
          .reserve(req.getProduct(), idempotencyOps);
      sendResponse(httpExchange, reservation);
    });
</code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">Sagas</p><h4>Sagas</h4><div><p>Implements robust sagas and compensation patterns: long-running transactions that undo previous actions when they need to abort and roll back.</p><p>‚Äç</p><ul role="list"><li>Reliably pick up after failures to trigger compensations</li><li>Ensure compensations happen even upon failures during the compensation phase</li><li>Use standard Exception/Error mechanisms and control flow rather than complex DSLs.</li></ul></div><p><a href="https://github.com/restatedev/examples/tree/main/patterns-use-cases/sagas" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
async function reservation(ctx, products) {
  const reservations = [];
  try {
    for (const product of products) {
      const reservation = await ctx.run(`reserve ${product}`,
          () =&gt; reserve(product));
      reservations.push(reservation);
    }
  } catch (error) {
    if (error instanceof TerminalError) {
      for (const reservation of reservations) {
        await ctx.run(&#34;undo reserve&#34;, () =&gt; 
            cancelReservation(reservation));
      }
    }
    throw error;
  }
}
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
@Handler
public void reserveAllProducts(Context ctx, Product[] products) {
    final List<reservation> reservations = new ArrayList&lt;&gt;();
    try {
        for (Product product : products) {
            Reservation res = ctx.run(&#34;Reserve &#34; + product.getId(),
                RESERVE_SERDE, () -&gt; reserve(product)
            );
            reservations.add(res);
        }
    } catch (TerminalException e) {
        reservations.forEach(res -&gt; {
            ctx.run(&#34;Undo reservation&#34;, () -&gt; cancelReservation(res));
        });
        throw e;
    }
}
</reservation></code>
</pre></div></div></div></div></div></div></div><div role="listitem"><div id="w-node-_13e0bcf1-d9ea-6e17-5d98-d31f688c70c6-23cdcf59"><p fs-cmstabs-element="tab-link">State machines</p><h4>State machines</h4><div><p>Create consistent and scalable State Machines without databases or transactions</p><ul role="list"><li>Run millions of State Machines that maintain state directly in the context of their handlers</li><li>State changes commit atomically with function execution, for rock-solid consistency</li><li>Single-writer semantics for a dead simple concurrency model. A virtual queue per state machine for efficiency and scalability.</li><li>State transition can be workflows with all the features from durable execution</li></ul></div><p><a href="https://github.com/restatedev/examples/tree/main/patterns-use-cases/payment-state-machine" target="_blank">&gt; Learn More</a></p></div><div id="w-node-e2a5a4fe-8235-9f45-0a19-48178634d8ac-23cdcf59"><div data-current="Tab 1" data-easing="ease" data-duration-in="300" data-duration-out="100"><div><div data-w-tab="Tab 1"><div><div><pre><code>
const paymentSvc = restate.object({
  name: &#34;payments&#34;,
  handlers: {
    makePayment: async (ctx, payment) =&gt; {
      const paymentId = ctx.key;
      switch (await ctx.get(&#34;status&#34;)) {
        case &#34;CANCELLED&#34;:
            return `${paymentId} was cancelled before`;
        case &#34;SUCCESS&#34;:
            return `${paymentId} previously completed`;
      }
      wireFunds(payment);
      ctx.set(&#34;status&#34;, &#34;SUCCESS&#34;);
      ctx.set(&#34;payment&#34;, payment);
    },
    cancelPayment: async (ctx) =&gt; {
      const status = await ctx.get(&#34;status&#34;);
      if (status === &#34;SUCCESS&#34;) {
        const payment = await ctx.get(&#34;payment&#34;);
        refund(payment);
      }
      ctx.set(&#34;status&#34;, &#34;CANCELLED&#34;);
    }
  }
});
</code>
</pre></div></div></div><div data-w-tab="Tab 2"><div><div><pre><code>
@VirtualObject
public class PaymentStateMachine {
  @Handler
  public String makePayment(ObjectContext ctx, PaymentRequest payment) {
    String paymentId = ctx.key();
    switch (ctx.get(STATE_STATUS).orElse(NEW)) {
      case CANCELLED: return paymentId + &#34; was cancelled before&#34;;
      case SUCCESS:   return paymentId + &#34; was previously completed&#34;;
    }
    wireFunds(payment);
    ctx.set(STATE_STATUS, SUCCESS);
    ctx.set(STATE_PAYMENT_REQUEST, payment);
    return paymentId + &#34; was successfully processed&#34;;
  }
  @Handler
  public void cancelPayment(ObjectContext ctx) {
    Status status = ctx.get(STATE_STATUS).orElse(NEW);
    if (status == SUCCESS) {
      PaymentRequest payment = ctx.get(STATE_PAYMENT_REQUEST).get();
      refund(payment);
    }
    ctx.set(STATE_STATUS, CANCELLED);
  }
}
</code>
</pre></div></div></div></div></div></div></div></div></div></div></div></section><section><div><div id="w-node-_6c62185e-aeb0-0281-3106-2400ea849cab-23cdcf59"><h2>A simple and powerful programming model</h2><p>Restate provides distributed durable version of your everyday building blocks.</p><p><a href="https://restate.dev/programming-model">&gt; See how it works</a></p></div><div id="w-node-_6efa648f-2885-10fe-426b-0822434c8e3d-23cdcf59"><div data-w-id="1f98eac8-7392-f220-f431-d55dd9707ff8"><div><h4>Durable Execution</h4><p>Functions/Services that handle retries, recovery, asynchrony, idempotency.</p></div></div><div data-w-id="fada5290-d344-caa0-93a5-2dca955e7633"><div><h4>Virtual Objects</h4><p>Persistent state directly in your objects with a simple concurrency model.</p></div></div><div data-w-id="6f0d1405-b0e1-174a-5538-0a0fc0cd2f72"><div><h4>Durable Promises</h4><p>Transparent and fault-tolerant communication across services, processes, and time.</p></div></div></div></div></section><section><div><div id="w-node-_64f32bf9-9582-8528-1db5-e498d4a9d807-23cdcf59"><p><img src="https://cdn.prod.website-files.com/663272930a67769123cdcf53/664fdfb3d3abef98f35a8335_FeatureIcon1.svg" loading="lazy" alt=""/></p><h2>Single binary, no dependencies, built in Rust.</h2><p>A system that runs locally and on-prem just as well as in the ‚Ä®cloud. Restate server comes as a single binary. Simple to run, ‚Ä®simple to operate.</p><p>Fully self-contained, resource-efficient, resilient, thanks to ‚Ä®Rust‚Äôs magic.</p></div><div id="w-node-d62c8e4f-b2e9-6271-8c4d-c77645e928de-23cdcf59"><p><img src="https://cdn.prod.website-files.com/663272930a67769123cdcf53/664fdfb4b4dde429290390db_FeatureIcon2.svg" loading="lazy" alt=""/></p><h2>Stellar local dev-experience</h2><p>What‚Äôs better than a local dev server? </p><p>Running the real system on your laptop or in your CI pipeline. No subtle quirks and differences between dev- and prod setups.<br/></p><p>Your Restate-powered code is just functions/services. Develop them with the tools you know and love.<br/></p></div></div></section><section></section><section><div data-w-id="c21848fa-07c8-b134-6d13-aa60a989b3e8"><div><h2>Restate Cloud:¬†The zero-infrastructure option</h2><p>Get a fully serverless Restate experience, managed by the developers of the system.‚Ä®</p><p><a href="https://cloud.restate.dev/" target="_blank">&gt; Get Access</a></p></div><p><img src="https://cdn.prod.website-files.com/663272930a67769123cdcf53/66551349e3bd7f3d6a22e6a9_Clouds.svg" loading="lazy" alt=""/></p></div></section><section></section><section></section><section><div><p>Copyright ¬© 2024 Restate. All rights reserved.</p></div></section>

<!-- üíô MEMBERSCRIPT #92 v0.1 üíô TURN ANYTHING INTO A LINK -->






</div>
  </body>
</html>
