<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://clojure.org/news/2024/09/05/clojure-1-12-0">Original</a>
    <h1>Clojure 1.12.0 is now available</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<h3 id="add_libs"><a href="#add_libs"></a>2.1 Add libraries for interactive use</h3>
<p>There are many development-time cases where it would be useful to add a library interactively without restarting the JVM - speculative evaluation, adding a known dependency to your project, or adding a library to accomplish a specific task.</p>

<div>
<ul>
<li>
<p><a href="https://clojure.github.io/clojure/branch-master/clojure.repl-api.html#clojure.repl.deps/add-lib">add-lib</a> takes a lib that is not available on the classpath, and makes it available by downloading (if necessary) and adding to the classloader. Libs already on the classpath are not updated. If the coordinate is not provided, the newest Maven or git (if the library has an inferred git repo name) version or tag are used.</p>
</li>
<li>
<p><a href="https://clojure.github.io/clojure/branch-master/clojure.repl-api.html#clojure.repl.deps/add-libs">add-libs</a> is like <code>add-lib</code>, but resolves a set of new libraries and versions together.</p>
</li>
<li>
<p><a href="https://clojure.github.io/clojure/branch-master/clojure.repl-api.html#clojure.repl.deps/sync-deps">sync-deps</a> calls <code>add-libs</code> with any libs present in deps.edn, but not yet present on the classpath.</p>
</li>
</ul>
</div>
<p>These new functions are intended only for development-time interactive use at the repl - using a deps.edn is still the proper way to build and maintain production code. To this end, these functions all check that <a href="https://clojure.github.io/clojure/branch-master/clojure.core-api.html#clojure.core/%2Arepl%2A">*repl*</a> is bound to true (that flag is bound automatically by <code>clojure.main/repl</code>). In a clojure.main REPL, these new functions are automatically referred in the <code>user</code> namespace. In other repls, you may need to <code>(require &#39;[clojure.repl.deps :refer :all])</code> before use.</p>
<p>Library resolution and download are provided by <a href="https://github.com/clojure/tools.deps">tools.deps</a>. However, you do not want to add tools.deps and its many dependencies to your project classpath during development, and thus we have also added a new api for invoking functions out of process via the Clojure CLI.</p>
</div>
<div>
<h3 id="tool_functions"><a href="#tool_functions"></a>2.2 Invoke tool functions out of process</h3>
<p>There are many useful tools you can use at development time, but which are not part of your project’s actual dependencies. The Clojure CLI provides explicit support for <a href="https://clojure.org/reference/clojure_cli#tools">tools</a> with their own classpath, but there was not previously a way to invoke these interactively.</p>
<p>Clojure now includes <a href="https://clojure.github.io/clojure/branch-master/clojure.tools.deps.interop-api.html#clojure.tools.deps.interop/invoke-tool">clojure.tools.deps.interop/invoke-tool</a> to invoke a tool function out of process. The classpath for the tool is defined in deps.edn and you do not need to add the tool’s dependencies to your project classpath.</p>
<p><code>add-lib</code> functionality is built using <code>invoke-tool</code> but you can also use it to build or invoke your own tools for interactive use. Find more about the function execution protocol on the <a href="https://clojure.org/reference/clojure_cli#function_protocol">CLI reference</a>.</p>
</div>
<div>
<h3 id="_2_3_start_and_control_external_processes"><a href="#_2_3_start_and_control_external_processes"></a>2.3 Start and control external processes</h3>
<p>For a long time, we’ve had the <code>clojure.java.shell</code> namespace, but over time Java has provided new APIs for process info, process control, and I/O redirection. This release adds a new namespace <a href="https://clojure.github.io/clojure/branch-master/index.html#clojure.java.process">clojure.java.process</a> that takes advantage of these APIs and is easier to use. See:</p>
<div>
<ul>
<li>
<p><a href="https://clojure.github.io/clojure/branch-master/clojure.java.process-api.html#clojure.java.process/start">start</a> - full control over streams with access to the underlying Java objects for advanced usage</p>
</li>
<li>
<p><a href="https://clojure.github.io/clojure/branch-master/clojure.java.process-api.html#clojure.java.process/exec">exec</a> - covers the common case of executing an external process and returning its stdout on completion</p>
</li>
</ul>
</div>
</div>
<div>
<h3 id="method_values"><a href="#method_values"></a>2.4 Method values</h3>
<p>Clojure programmers often want to use Java methods in higher-order functions (e.g. passing a Java method to <code>map</code>). Until now, programmers have had to manually wrap methods in functions. This is verbose, and might require manual hinting for overload disambiguation, or incur incidental reflection or boxing.</p>
<p>Programmers can now use <a href="https://clojure.org/news/2024/09/05/clojure-1-12-0#qualified_methods">qualified methods</a> as ordinary functions in value contexts - the compiler will <a href="https://clojure.org/reference/java_interop#methodvalues">automatically generate the wrapping function</a>. The compiler will generate a reflective call when a qualified method does not resolve due to overloading. Developers can supply <a href="https://clojure.org/news/2024/09/05/clojure-1-12-0#param_tags"><code>:param-tags</code></a> metadata on qualified methods to specify the signature of a single desired method, &#39;resolving&#39; it.</p>
</div>
<div>
<h3 id="qualified_methods"><a href="#qualified_methods"></a>2.5 Qualified methods - <code>Class/method</code>, <code>Class/.method</code>, and <code>Class/new</code></h3>
<p>Java members inherently exist in a class.  For method values we need a way to explicitly specify the class of an instance method because there is no possibility for inference.</p>
<p>Qualified methods have value semantics when used in non-invocation positions:</p>
<div>
<ul>
<li>
<p><code>Classname/method</code> - value is a Clojure function that invokes a static method</p>
</li>
<li>
<p><code>Classname/.method</code> - value is a Clojure function that invokes an instance method</p>
</li>
<li>
<p><code>Classname/new</code> - value is a Clojure function that invokes a constructor</p>
</li>
</ul>
</div>
<p>Note: developers must use <code>Classname/method</code> and <code>Classname/.method</code> syntax to differentiate between static and instance methods.</p>
<p>Qualified method invocations with <a href="https://clojure.org/news/2024/09/05/clojure-1-12-0#param_tags"><code>:param-tags</code></a> use only the tags to resolve the method. Without param-tags they behave like the equivalent <a href="https://clojure.org/reference/java_interop#_the_dot_special_form">dot syntax</a>, except the qualifying class takes precedence over hints of the target object, and over its runtime type when invoked via reflection.</p>
<p>Note: Static fields are values and should be referenced without parens unless they are intended as function calls, e.g <code>(System/out)</code> should be <code>System/out</code>. Future Clojure releases will treat the field’s value as something invokable and invoke it.</p>
</div>
<div>
<h3 id="param-tags"><a href="#param-tags"></a>2.6 :param-tags metadata</h3>
<p>When used as values, qualified methods supply only the class and method name, and thus cannot resolve overloaded methods.</p>
<p>Developers can supply <a href="https://clojure.org/reference/java_interop#paramtags"><code>:param-tags</code></a> metadata on qualified methods to specify the signature of a single desired method, &#39;resolving&#39; it. The <code>:param-tags</code> metadata is a vector of zero or more tags: <code>[tag …​]</code>. A tag is any existing valid <code>:tag</code> metadata value. Each tag corresponds to a parameter in the desired signature (arity should match the number of tags). Parameters with non-overloaded types can use the placeholder <code>_</code> in lieu of the tag. When you supply :param-tags metadata on a qualified method, the metadata must allow the compiler to resolve it to a single method at compile time.</p>
<p>A new metadata reader syntax <code>^[tag …​]</code> attaches <code>:param-tags</code> metadata to member symbols, just as <code>^tag</code> attaches <code>:tag</code> metadata to a symbol.</p>
</div>
<div>
<h3 id="_2_7_array_class_syntax"><a href="#_2_7_array_class_syntax"></a>2.7 Array class syntax</h3>
<p>Clojure supports symbols naming classes both as a value (for class object) and as a type hint, but has not provided syntax for array classes other than strings.</p>
<p>Developers can now refer to an <a href="https://clojure.org/reference/java_interop#_class_access">array class</a> using a symbol of the form <code>ComponentClass/#dimensions</code>, eg <code>String/2</code> refers to the class of a 2 dimensional array of Strings. Component classes can be fully-qualified classes, imported classes, or primitives. Array class syntax can be used as both type hints and values.</p>
<p>Examples: <code>String/1</code>, <code>java.lang.String/1</code>, <code>long/2</code>.</p>
</div>
<div>
<h3 id="_2_8_functional_interfaces"><a href="#_2_8_functional_interfaces"></a>2.8 Functional interfaces</h3>
<p>Java programs emulate functions with Java functional interfaces (marked with the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">@FunctionalInterface</a> annotation), which have a single method.</p>
<p>Clojure developers can now invoke Java methods taking <a href="https://clojure.org/reference/java_interop#functional_interfaces">functional interfaces</a> by passing functions with matching arity. The Clojure compiler implicitly converts Clojure functions to the required functional interface by constructing a lambda adapter. You can explicitly coerce a Clojure function to a functional interface by hinting the binding name in a <code>let</code> binding, e.g. to avoid repeated adapter construction in a loop, e.g. <code>(let [^java.util.function.Predicate p even?] …​)</code>.</p>
</div>
<div>
<h3 id="_2_9_java_supplier_interop"><a href="#_2_9_java_supplier_interop"></a>2.9 Java Supplier interop</h3>
<p>Calling methods that take a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier</a> (a method that supplies a value) had required writing an adapter with reify. Clojure has a &#34;value supplier&#34; interface with semantic support already - <code>IDeref</code>. All <code>IDeref</code> impls (<code>delay</code>, <code>future</code>, <code>atom</code>, etc) now implement the <code>Supplier</code> interface directly.</p>
</div>
<div>
<h3 id="_2_10_streams_with_seq_into_reduce_and_transduce_support"><a href="#_2_10_streams_with_seq_into_reduce_and_transduce_support"></a>2.10 Streams with seq, into, reduce, and transduce support</h3>
<p>Java APIs increasingly return <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>s and are hard to consume because they do not implement interfaces that Clojure already supports, and hard to interop with because Clojure doesn’t directly implement Java functional interfaces.</p>
<p>In addition to functional interface support, Clojure <a href="https://clojure.org/reference/java_interop#streams">now provides these functions</a> to interoperate with streams in an idiomatic manner, all functions behave analogously to their Clojure counterparts:</p>
<div>
<ul>
<li>
<p><code>(stream-seq! stream) ⇒ seq</code></p>
</li>
<li>
<p><code>(stream-reduce! f [init-val] stream) ⇒ val</code></p>
</li>
<li>
<p><code>(stream-transduce! xf f [init-val] stream) ⇒ val</code></p>
</li>
<li>
<p><code>(stream-into! to-coll [xf] stream) ⇒ to-coll</code></p>
</li>
</ul>
</div>
<p>All of these operations are terminal stream operations (they consume the stream).</p>
</div>
<div>
<h3 id="_2_11_persistentvector_implements_spliterable"><a href="#_2_11_persistentvector_implements_spliterable"></a>2.11 PersistentVector implements Spliterable</h3>
<p>Java collections implement streams via <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html">&#34;spliterators&#34;</a>, iterators that can be split for faster parallel traversal. <code>PersistentVector</code> now provides a custom spliterator that supports parallelism, with greatly improved performance.</p>
</div>
<div>
<h3 id="_2_12_efficient_drop_and_partition_for_persistent_or_algorithmic_collections"><a href="#_2_12_efficient_drop_and_partition_for_persistent_or_algorithmic_collections"></a>2.12 Efficient drop and partition for persistent or algorithmic collections</h3>
<p>Partitioning of a collection uses a series of takes (to build a partition) and drops (to skip past that partition). <a href="https://clojure.atlassian.net/browse/CLJ-2713">CLJ-2713</a> adds a new internal interface (IDrop) indicating that a collection can drop more efficiently than sequential traversal, and implements that for persistent collections and algorithmic collections like <code>range</code> and <code>repeat</code>. These optimizations are used in <code>drop</code>, <code>nthrest</code>, and <code>nthnext</code>.</p>
<p>Additionally, there are new functions <code>partitionv</code>, <code>partitionv-all</code>, and <code>splitv-at</code> that are more efficient than their existing counterparts and produce vector partitions instead of realized seq partitions.</p>
</div>
<div>
<h3 id="_2_13_var_interning_policy"><a href="#_2_13_var_interning_policy"></a>2.13 Var interning policy</h3>
<p><a href="https://clojure.org/reference/vars#interning">Interning</a> a var in a namespace (vs aliasing) must create a stable reference that is never displaced, so that all references to an interned var get the same object. There were some cases where interned vars could get displaced and those have been tightened up in 1.12.0-alpha1. If you encounter this situation, you’ll see a warning like &#34;REJECTED: attempt to replace interned var #&#39;some-ns/foo with #&#39;other-ns/foo in some-ns, you must ns-unmap first&#34;.</p>
<p>This addresses the root cause of an issue encountered with Clojure 1.11.0, which added new functions to clojure.core (particularly <code>abs</code>). Compiled code from an earlier version of Clojure with var names that matched the newly added functions in clojure.core would be unbound when loaded in a 1.11.0 runtime. In addition to <a href="https://clojure.atlassian.net/browse/CLJ-2711">CLJ-2711</a>, we rolled back a previous fix in this area (<a href="https://clojure.atlassian.net/browse/CLJ-1604">CLJ-1604</a>).</p>
</div>
</div></div>
  </body>
</html>
