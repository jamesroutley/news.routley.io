<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2024-12-19-enum-of-arrays/">Original</a>
    <h1>Enum of Arrays</h1>
    
    <div id="readability-page-1" class="page"><article id="blogpost">
  
  
  <div><p>A popular data-oriented design pattern is a Struct of Arrays. Is an
Array of Enums also useful? Yes! But let’s do a refresher on struct of
arrays (<code>SoA</code>) first:</p>
<p>If you have a <code>Thing</code>,</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>const</span> Thing <span>=</span> <span>struct</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   checksum<span>:</span> <span>u128</span><span>,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   number<span>:</span> <span>u32</span><span>,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   flag<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>and an array of <code>Thing</code>s,</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>// Array of Structs.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>const</span> AoS <span>=</span> []Thing;</span></code></pre></div>
<p>it&#39;s possible to wrap the data inside out and use</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>// Struct of Arrays.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>const</span> SoA <span>=</span> <span>struct</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>   checksum<span>:</span> []<span>u128</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>   number<span>:</span> []<span>u32</span><span>,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   flag<span>:</span> []<span>u8</span><span>,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>instead. The benefits are:</p>
<ul>
<li>Reduced memory usage due to amortized padding. As <code>flag</code>
is a byte, it requires some padding to align with larger fields like
<code>checksum</code>. In <code>AoS</code>, each individual struct has
this padding. In <code>SoA</code>, there&#39;s still padding for
<code>flag</code>, but it&#39;s just one instance of padding for all the
<code>Thing</code>s.</li>
<li>Better memory bandwidth utilization for batched code. If a loop
needs to process all things, but the processing doesn&#39;t require all
fields (at least for the majority of objects), then an array-based
representation reduces the amount of data that needs to be loaded.</li>
</ul>
<p>You can use the same trick also for a more SIMD-friendly data layout.
A bad way to use SIMD is to try to vectorize the processing of an
individual item. A good way to use SIMD is to process several items at
once.</p>
<p>For example, if a <code>Thing</code> in question is a 3D vector, it&#39;s
usually not a good idea to implement the dot product of two vectors by
loading <code>xyz</code> of one vector into a SIMD register
<code>a</code>, <code>xyz</code> of another vector into a SIMD register
<code>b</code>, and then performing a SIMD multiplication of
<code>a * b</code>. The reason is that your &#34;SIMD width&#34; is still only
three numbers:</p>
<p><img src="https://tigerbeetle.com/blog/2024-12-19-enum-of-arrays/wasteful-simd.webp"/></p>
<p>Much better to simultaneously compute the dot products of multiple
pairs of vectors. Then, you can load a SIMD vector with
<code>xxxxxxx</code>, which is the <code>x</code> coordinate for the
first vector of multiple pairs. And so, the full width of SIMD registers
is used:</p>
<p><img src="https://tigerbeetle.com/blog/2024-12-19-enum-of-arrays/efficient-simd.webp"/></p>
<p>This post is to raise awareness that the same trick works with
enums:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>const</span> Thing <span>=</span> <span>union</span>(<span>enum</span>) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   spam<span>:</span> Spam<span>,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   eggs<span>:</span> Eggs</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span>// With a level of abstraction peeled:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span>const</span> Thing <span>=</span> <span>struct</span> {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   tag<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>   payload<span>:</span> <span>union</span> {</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>       spam<span>:</span> Spam<span>,</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>       eggs<span>:</span> Eggs<span>,</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Here&#39;s an array of enums:</p>

<p>And here&#39;s the dual, an enum of arrays:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>const</span> EoA <span>=</span> <span>struct</span> {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   tag<span>:</span> <span>u8</span><span>,</span> <span>// Sic!</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>   payload<span>:</span> <span>union</span> {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>       spam<span>:</span> []Spam<span>,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>       eggs<span>:</span> []Eggs<span>,</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <em>key</em> idea is that there&#39;s only a single <code>tag</code>
per an entire batch of things. If a batch size is 1024, you can have
1024 spams or 1024 eggs, but not a mix of the two.</p>
<p>The benefits of this representation:</p>
<ul>
<li><p>Tags occupy less bytes in total, because a single tag can be
amortized across many objects at once.</p></li>
<li><p>If individual enum variants are of different sizes, then no
memory is wasted when storing the gap between a small variant and a
large one.</p></li>
<li><p>Finally, the purpose of the tag is for the CPU to branch on it.
By having only one tag per batch of objects, the amount of branching the
CPU has to do is dramatically reduced, which is a very good thing in
itself—unpredictable branching slows down the CPU a lot. But what&#39;s
more, with branching out of the way, the processing is opened up for
SIMD optimizations!</p></li>
</ul>
<p>TigerBeetle is built around this idea of <code>AoE =&gt; EoA</code>
optimizations. TigerBeetle can do two things: create new accounts, and
then create transfers between accounts. This <em>could</em> have been
represented as a heterogeneous enum of the two kinds of operation.
Instead, TigerBeetle uses homogeneous batches. TigerBeetle does eight
thousands operations at a time, and there&#39;s one tag for an entire batch.
So, it’s always 8k transfers followed by 8k accounts, not a mixture of
the two.</p>
<p>This optimization is related to the concept of data plane and control
plane separation. The <code>tag</code> is control plane, a small,
infrequent piece of information which informs decisions. The data plane
then is more voluminous, but processing it doesn&#39;t require many
individual decisions. Just. One. Branch!</p>
<p>That&#39;s all for today. Support your local branch predictor, convert
your AoE to EoA!</p>
  </div>
</article></div>
  </body>
</html>
