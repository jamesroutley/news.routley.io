<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2023/06/29/dynamic-bit-shuffle-using-avx-512/">Original</a>
    <h1>Dynamic bit shuffle using AVX-512</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Suppose that you want to reorder, arbitrarily, the bits in a 64-bit word. This question <a href="https://twitter.com/experquisite/status/1674408604949004288?s=61&amp;t=IypqrYJfR6opCHxnJ-DUrQ">was raised on Twitter by @experquisite</a>. Formally, you might want to provide, for each of the 64 bit position, an original bit position you want to copy.</p>
<p>Hence, the following code would reverse the bit order in your 64-bit word:</p>
<pre>uint64_t w <span>=</span> some value;
uint8_t indexes<span>[</span><span>64</span><span>]</span> <span>=</span> <span>{</span><span>63</span><span>,</span> <span>62</span><span>,</span> <span>61</span><span>,</span> <span>60</span><span>,</span> <span>59</span><span>,</span> <span>58</span><span>,</span> <span>57</span><span>,</span> <span>56</span><span>,</span> <span>55</span><span>,</span> <span>54</span><span>,</span> <span>53</span><span>,</span> <span>52</span><span>,</span> <span>51</span><span>,</span>
<span>                       50</span><span>,</span> <span>49</span><span>,</span> <span>48</span><span>,</span> <span>47</span><span>,</span> <span>46</span><span>,</span> <span>45</span><span>,</span> <span>44</span><span>,</span> <span>43</span><span>,</span> <span>42</span><span>,</span> <span>41</span><span>,</span> <span>40</span><span>,</span> <span>39</span><span>,</span> <span>38</span><span>,</span>
<span>                       37</span><span>,</span> <span>36</span><span>,</span> <span>35</span><span>,</span> <span>34</span><span>,</span> <span>33</span><span>,</span> <span>32</span><span>,</span> <span>31</span><span>,</span> <span>30</span><span>,</span> <span>29</span><span>,</span> <span>28</span><span>,</span> <span>27</span><span>,</span> <span>26</span><span>,</span> <span>25</span><span>,</span>
<span>                       24</span><span>,</span> <span>23</span><span>,</span> <span>22</span><span>,</span> <span>21</span><span>,</span> <span>20</span><span>,</span> <span>19</span><span>,</span> <span>18</span><span>,</span> <span>17</span><span>,</span> <span>16</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>13</span><span>,</span> <span>12</span><span>,</span>
<span>                       11</span><span>,</span> <span>10</span><span>,</span> <span>9</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>}</span><span>;</span>
bit_shuffle<span>(</span>w<span>,</span> indexes<span>);</span> // returns a reversed version 
</pre>
<p>A naive way to do it in C might be as follows:</p>
<pre>uint64_t slow_bit_shuffle<span>(</span>uint64_t w<span>,</span> uint8_t indexes<span>[</span><span>64</span><span>]</span><span>)</span> <span>{</span>
  uint64_t out<span>{</span><span>}</span><span>;</span>
<span>  for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>64</span><span>;</span> i<span>+</span><span>+</span><span>)</span> <span>{</span>
    bool bit_set <span>=</span> w <span>&amp;</span> <span>(</span>uint64_t<span>(</span><span>1</span><span>)</span> <span>&lt;</span><span>&lt;</span> indexes<span>[</span>i<span>]</span><span>)</span><span>;</span>
    out <span>|</span><span>=</span> <span>(</span>uint64_t<span>(</span><span>bit_set</span><span>)</span> <span>&lt;</span><span>&lt;</span> i<span>)</span><span>;
</span>Â <span> }</span>
<span>  return</span> out<span>;</span>
<span>}</span>
</pre>
<p>This might be an acceptable implementation, but what if you want do it using few instructions? You can do it on recent Intel and AMD processors with support for AVX-512 instructions. You go from the general-purpose register to a mask register, to a 512-bit AVX-512 register, you apply a shuffle (<tt>vpermb</tt>), you go back to a mask register and finally back to a general-purpose register.</p>
<p>The code with Intel intrinsic functions looks as follows:</p>
<pre>uint64_t bit_shuffle<span>(</span>uint64_t w<span>,</span> uint8_t indexes<span>[</span><span>64</span><span>]</span><span>)</span> <span>{</span>
  __mmask64 as_mask <span>=</span> _cvtu64_mask64<span>(</span>w<span>)</span><span>;</span>
  __m512i as_vec_register <span>=</span>
  _mm512_maskz_mov_epi8<span>(</span>as_mask<span>,</span> _mm512_set1_epi8<span>(</span><span>0xFF</span><span>)</span><span>)</span><span>;</span>
  __m512i as_vec_register_shuf <span>=</span>
  _mm512_permutexvar_epi8<span>(</span>_mm512_loadu_si512<span>(</span>indexes<span>)</span><span>,</span> as_vec_register<span>)</span><span>;</span>
<span>  return</span> _cvtmask64_u64<span>(</span>_mm512_movepi8_mask<span>(</span>as_vec_register_shuf<span>)</span><span>)</span><span>;</span>
<span>}</span>
</pre>
<p>It might compile to about six instructions:</p>
<pre>kmovq k0<span>,</span> rdi
vpmovm2b zmm0<span>,</span> k0
vmovdqu8 zmm1<span>,</span> ZMMWORD <span>PTR</span> <span>[</span>rsi<span>]</span>
vpermb zmm0<span>,</span> zmm1<span>,</span> zmm0
vpmovb2m k1<span>,</span> zmm0
kmovq rax<span>,</span> k1

</pre>
<p>As one reader points out, you can do better because AVX-512 has a dedicated instruction for bit shuffling which directly returns a mask and work directly from the 64-bit word as long as it is loaded in a vector register:</p>
<pre>uint64_t faster_bit_shuffle<span>(</span>uint64_t w<span>,</span> uint8_t indexes<span>[</span><span>64</span><span>]</span><span>)</span> <span>{</span>
  __m512i as_vec_register <span>=</span> _mm512_set1_epi64<span>(</span>w<span>)</span><span>;</span>
  __mmask64 as_mask <span>=</span> _mm512_bitshuffle_epi64_mask<span>(</span>as_vec_register,
     _mm512_loadu_si512<span>(</span>indexes<span>)</span><span>)</span><span>;</span>
<span>  return</span> _cvtmask64_u64<span>(</span>as_mask<span>)</span><span>;</span>
<span>}</span>
</pre>
<p>The resulting assembly is quite short:<br/>
</p>
<pre>vpbroadcastq zmm0<span>,</span> rdi
vpshufbitqmb k0<span>,</span> zmm0<span>,</span> ZMMWORD <span>PTR</span> <span>[</span>rsi<span>]</span>
kmovq rax<span>,</span> k0
</pre>
<p>Loading your indexes is likely to have a long latency, so if you can buffer the load (<tt>_mm512_loadu_si512(indexes)</tt>), you will reduce significantly the latency.</p>
</div></div>
  </body>
</html>
