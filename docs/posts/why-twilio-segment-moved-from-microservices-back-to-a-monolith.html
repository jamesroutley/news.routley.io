<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.twilio.com/en-us/blog/developers/best-practices/goodbye-microservices">Original</a>
    <h1>Why Twilio Segment moved from microservices back to a monolith</h1>
    
    <div id="readability-page-1" class="page"><div>




    
    <section id="">


    
    

    

    
    <div>

    
    
    




    
        
        
            
            

        
        
    
        
        
            
            

        
        
    
        
        
            
            <div>




    
        
        
        
            
            

<div>
    <div>
        
    
    <div data-ext-icon="&lt;svg viewBox=&#34;0 0 79 79&#34; fill=&#34;none&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon--decorative&#34; role=&#34;presentation&#34;&gt;
    &lt;title&gt;An icon of a outbound link arrow&lt;/title&gt;
    &lt;path class=&#34;icon-stroke&#34; d=&#34;M75.3037 3.98207L3 75.5935M75.3037 3.98207L76.0435 43.3021M75.3037 3.98207L35.951 3.59351&#34; stroke=&#34;#F22F46&#34; stroke-width=&#34;5.5&#34; stroke-linecap=&#34;round&#34; stroke-linejoin=&#34;round&#34;/&gt;
&lt;/svg&gt;
">
        <h2 id="introduction"><a href="#introduction">Goodbye Microservices: From 100s of problem children to 1 superstar</a></h2>
<p>Microservices is a service-oriented software architecture in which server-side applications are constructed by combining many single-purpose, low-footprint network services. The touted benefits are improved modularity, reduced testing burden, better functional composition, environmental isolation, and development team autonomy. The opposite is a Monolithic architecture, where a large amount of functionality lives in a single service which is tested, deployed, and scaled as a single unit.</p>
<p>Twilio Segment adopted this as a best practice early-on, which served us well in some cases, and, as you’ll soon learn, not so well in others.</p>
<p>In the early days of Twilio Segment, we reached a tipping point with a core piece of <a href="https://segment.com/product?utm_referrer=https%3A%2F%2Fwww.twilio.com%2Fen-us%2Fblog%2Fdevelopers%2Fbest-practices%2Fgoodbye-microservices" target="_self" rel="noopener noreferrer">Twilio Segment’s product</a>. It seemed as if we were falling from the microservices tree, hitting every branch on the way down. Instead of enabling us to move faster, the small team found themselves mired in exploding complexity. Essential benefits of this architecture became burdens. As our velocity plummeted, our defect rate exploded.</p>
<p>Eventually, the team found themselves unable to make headway, with 3 full-time engineers spending most of their time just keeping the system alive. Something had to change. This post is the story of how we took a step back and embraced an approach that aligned well with our product requirements and needs of the team.</p>
<h2 id="why-microservices-worked"><a href="#why-microservices-worked">Why Microservices worked</a></h2>
<p>Twilio Segment’s customer data infrastructure ingests hundreds of thousands of events per second and forwards them to partner APIs, what we refer to as <b>server-side destinations</b>. There are <a target="_blank" href="https://segment.com/docs/connections/destinations/catalog/?utm_referrer=https%3A%2F%2Fwww.twilio.com%2Fen-us%2Fblog%2Fdevelopers%2Fbest-practices%2Fgoodbye-microservices" data-dynamic-link="true" rel="noopener noreferrer">over one hundred types of these destinations</a>, such as Google Analytics, Optimizely, or a custom webhook. </p>
<p>Years back, when the product initially launched, the architecture was simple. There was an API that ingested events and forwarded them to a distributed message queue. An event, in this case, is a JSON object generated by a web or mobile app containing information about users and their actions. A sample payload looks like the following:</p>
<p>As events were consumed from the queue, customer-managed settings were checked to decide which destinations should receive the event. The event was then sent to each destination’s API, one after another, which was useful because developers only need to send their event to a single endpoint, Twilio Segment’s API, instead of building potentially dozens of integrations. Twilio Segment handles making the request to every destination endpoint.</p>
<p>If one of the requests to a destination fails, sometimes we’ll try sending that event again at a later time. Some failures are safe to retry while others are not. Retry-able errors are those that could potentially be accepted by the destination with no changes. For example, HTTP 500s, rate limits, and timeouts. Non-retry-able errors are requests that we can be sure will never be accepted by the destination. For example, requests which have invalid credentials or are missing required fields.</p>

    </div>

        
    </div>
</div>
        
    
        
        
        
            
            





	
	
	

	<figure>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_QhV9GV3m.png" alt="A flow diagram illustrating a request processing system with components including an API, a queue, a destination worker, and multiple output endpoints such as google-analytics.com, api.optimizely.com, and api.mixpanel.com." loading="lazy"/>
			
		</p>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_QhV9GV3m.png" alt="A flow diagram illustrating a request processing system with components including an API, a queue, a destination worker, and multiple output endpoints such as google-analytics.com, api.optimizely.com, and api.mixpanel.com." loading="lazy"/>
			
		</p>
		
	</figure>




        
    
        
        
        
            
            

<div>
    <div>
        
    
    <div data-ext-icon="&lt;svg viewBox=&#34;0 0 79 79&#34; fill=&#34;none&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon--decorative&#34; role=&#34;presentation&#34;&gt;
    &lt;title&gt;An icon of a outbound link arrow&lt;/title&gt;
    &lt;path class=&#34;icon-stroke&#34; d=&#34;M75.3037 3.98207L3 75.5935M75.3037 3.98207L76.0435 43.3021M75.3037 3.98207L35.951 3.59351&#34; stroke=&#34;#F22F46&#34; stroke-width=&#34;5.5&#34; stroke-linecap=&#34;round&#34; stroke-linejoin=&#34;round&#34;/&gt;
&lt;/svg&gt;
">
        <p>At this point, a single queue contained both the newest events as well as those which may have had several retry attempts, across all destinations, which resulted in <a target="_blank" href="https://en.wikipedia.org/wiki/Head-of-line_blocking" data-dynamic-link="true" rel="noopener noreferrer">head-of-line blocking</a>. Meaning in this particular case, if one destination slowed or went down, retries would flood the queue, resulting in delays across <i>all</i> our destinations.</p>
<p>Imagine destination X is experiencing a temporary issue and every request errors with a timeout. Now, not only does this create a large backlog of requests which have yet to reach destination X, but also every failed event is put back to retry in the queue. While our systems would automatically scale in response to increased load, the sudden increase in queue depth would outpace our ability to scale up, resulting in delays for the newest events. Delivery times for all destinations would increase because destination X had a momentary outage. Customers rely on the timeliness of this delivery, so we can’t afford increases in wait times anywhere in our pipeline.</p>

    </div>

        
    </div>
</div>
        
    
        
        
        
            
            





	
	
	

	<figure>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_joMYeSNt.png" alt="A flow diagram illustrating a data processing pipeline with components including an API, a queue, a destination worker, and multiple output endpoints such as google-analytics.com, api.optimizely.com, and api.mixpanel.com. It also includes annotations indicating &#34;backpressure&#34; and &#34;retry events.&#34;" loading="lazy"/>
			
		</p>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_joMYeSNt.png" alt="A flow diagram illustrating a data processing pipeline with components including an API, a queue, a destination worker, and multiple output endpoints such as google-analytics.com, api.optimizely.com, and api.mixpanel.com. It also includes annotations indicating &#34;backpressure&#34; and &#34;retry events.&#34;" loading="lazy"/>
			
		</p>
		
	</figure>




        
    
        
        
        
            
            

<div>
    <div>
        
    
    <p>To solve the head-of-line blocking problem, the team created a separate service and queue for each destination. This new architecture consisted of an additional router process that receives the inbound events and distributes a copy of the event to each selected destination. Now if one destination experienced problems, only it’s queue would back up and no other destinations would be impacted. This microservice-style architecture isolated the destinations from one another, which was crucial when one destination experienced issues as they often do.</p>

        
    </div>
</div>
        
    
        
        
        
            
            





	
	
	

	<figure>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_ElKl4CZv.png" alt="A flow diagram illustrating a request processing system with components including an API, a router, queues, and multiple output endpoints such as google-analytics.com, api.optimizely.com, and api.mixpanel.com, with flow annotations." loading="lazy"/>
			
		</p>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_ElKl4CZv.png" alt="A flow diagram illustrating a request processing system with components including an API, a router, queues, and multiple output endpoints such as google-analytics.com, api.optimizely.com, and api.mixpanel.com, with flow annotations." loading="lazy"/>
			
		</p>
		
	</figure>




        
    
        
        
        
            
            

<div>
    <div>
        
    
    <div data-ext-icon="&lt;svg viewBox=&#34;0 0 79 79&#34; fill=&#34;none&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon--decorative&#34; role=&#34;presentation&#34;&gt;
    &lt;title&gt;An icon of a outbound link arrow&lt;/title&gt;
    &lt;path class=&#34;icon-stroke&#34; d=&#34;M75.3037 3.98207L3 75.5935M75.3037 3.98207L76.0435 43.3021M75.3037 3.98207L35.951 3.59351&#34; stroke=&#34;#F22F46&#34; stroke-width=&#34;5.5&#34; stroke-linecap=&#34;round&#34; stroke-linejoin=&#34;round&#34;/&gt;
&lt;/svg&gt;
">
        <h2 id="the-case-for-individual-repos"><a href="#the-case-for-individual-repos">The Case for Individual Repos</a></h2>
<p>Each destination API uses a different request format, requiring custom code to translate the event to match this format. A basic example is destination X requires sending birthday as traits.dob in the payload whereas our API accepts it as traits.birthday. The transformation code in destination X would look something like this:</p>
<p>Many modern destination endpoints have adopted Twilio Segment’s request format making some transforms relatively simple. However, these transforms can be very complex depending on the structure of the destination’s API. For example, for some of the older and most sprawling destinations, we find ourselves shoving values into hand-crafted XML payloads.</p>
<p>Initially, when the destinations were divided into separate services, all of the code lived in one repo. A huge point of frustration was that a single broken test caused tests to fail across all destinations. When we wanted to deploy a change, we had to spend time fixing the broken test even if the changes had nothing to do with the initial change. In response to this problem, it was decided to break out the code for each destination into their own repos. All the destinations were already broken out into their own service, so the transition was natural.</p>
<p>The split to separate repos allowed us to isolate the destination test suites easily. This isolation allowed the development team to move quickly when maintaining destinations.</p>
<h2 id="scaling-microservices-and-repos"><a href="#scaling-microservices-and-repos">Scaling Microservices and Repos</a></h2>
<p>As time went on, we added over 50 new destinations, and that meant 50 new repos. To ease the burden of developing and maintaining these codebases, we created shared libraries to make common transforms and functionality, such as HTTP request handling, across our destinations easier and more uniform.</p>
<p>For example, if we want the name of a user from an event, event.name() can be called in any destination’s code. The shared library checks the event for the property key name and Name. If those don’t exist, it checks for a first name, checking the properties firstName, first_name, and FirstName. It does the same for the last name, checking the cases and combining the two to form the full name.</p>
<p>The shared libraries made building new destinations quick. The familiarity brought by a uniform set of shared functionality made maintenance less of a headache.</p>
<p>However, a new problem began to arise. Testing and deploying changes to these shared libraries impacted all of our destinations. It began to require considerable time and effort to maintain. Making changes to improve our libraries, knowing we’d have to test and deploy dozens of services, was a risky proposition. When pressed for time, engineers would only include the updated versions of these libraries on a single destination’s codebase.</p>
<p>Over time, the versions of these shared libraries began to diverge across the different destination codebases. The great benefit we once had of reduced customization between each destination codebase started to reverse. Eventually, all of them were using different versions of these shared libraries. We could’ve built tools to automate rolling out changes, but at this point, not only was developer productivity suffering but we began to encounter other issues with the microservice architecture.</p>
<p>The additional problem is that each service had a distinct load pattern. Some services would handle a handful of events per day while others handled thousands of events per second. For destinations that handled a small number of events, an operator would have to manually scale the service up to meet demand whenever there was an unexpected spike in load.</p>
<p>While we did have auto-scaling implemented, each service had a distinct blend of required CPU and memory resources, which made tuning the auto-scaling configuration more art than science.</p>
<p>The number of destinations continued to grow rapidly, with the team adding three destinations per month on average, which meant more repos, more queues, and more services. With our microservice architecture, our operational overhead increased linearly with each added destination. Therefore, we decided to take a step back and rethink the entire pipeline.</p>
<h2 id="ditching-microservices-and-queues"><a href="#ditching-microservices-and-queues">Ditching Microservices and Queues</a></h2>
<p>The first item on the list was to consolidate the now over 140 services into a single service. The overhead from managing all of these services was a huge tax on our team. We were literally losing sleep over it since it was common for the on-call engineer to get paged to deal with load spikes.</p>
<p>However, the architecture at the time would have made moving to a single service challenging. With a separate queue per destination, each worker would have to check every queue for work, which would have added a layer of complexity to the destination service with which we weren’t comfortable. This was the main inspiration for Centrifuge. Centrifuge would replace all our individual queues and be responsible for sending events to the single monolithic service. (Note that Centrifuge became the back-end infrastructure for <a href="https://segment.com/product/connections/?utm_referrer=https%3A%2F%2Fwww.twilio.com%2Fen-us%2Fblog%2Fdevelopers%2Fbest-practices%2Fgoodbye-microservices" target="_self" rel="noopener noreferrer">Connections</a>.)</p>

    </div>

        
    </div>
</div>
        
    
        
        
        
            
            





	
	
	

	<figure>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_a0ViVzT6.png" alt="A flow diagram showing an API request passing through a router, then a concentrator, and finally reaching multiple destination services such as google-analytics.com, api.optimizely.com, and api.mixpanel.com." loading="lazy"/>
			
		</p>
		<p><img src="https://www.twilio.com/content/dam/segment/global/en/blog/legacy/2018/goodbye-microservices/asset_a0ViVzT6.png" alt="A flow diagram showing an API request passing through a router, then a concentrator, and finally reaching multiple destination services such as google-analytics.com, api.optimizely.com, and api.mixpanel.com." loading="lazy"/>
			
		</p>
		
	</figure>




        
    
        
        
        
            
            

<div>
    <div>
        
    
    <div data-ext-icon="&lt;svg viewBox=&#34;0 0 79 79&#34; fill=&#34;none&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; class=&#34;icon--decorative&#34; role=&#34;presentation&#34;&gt;
    &lt;title&gt;An icon of a outbound link arrow&lt;/title&gt;
    &lt;path class=&#34;icon-stroke&#34; d=&#34;M75.3037 3.98207L3 75.5935M75.3037 3.98207L76.0435 43.3021M75.3037 3.98207L35.951 3.59351&#34; stroke=&#34;#F22F46&#34; stroke-width=&#34;5.5&#34; stroke-linecap=&#34;round&#34; stroke-linejoin=&#34;round&#34;/&gt;
&lt;/svg&gt;
">
        <h2 id="moving-to-a-monorepo"><a href="#moving-to-a-monorepo">Moving to a Monorepo</a></h2>
<p>Given that there would only be one service, it made sense to move all the destination code into one repo, which meant merging all the different dependencies and tests into a single repo. We knew this was going to be messy.</p>
<p>For each of the 120 unique dependencies, we committed to having one version for all our destinations. As we moved destinations over, we’d check the dependencies it was using and update them to the latest versions. We fixed anything in the destinations that broke with the newer versions.</p>
<p>With this transition, we no longer needed to keep track of the differences between dependency versions. All our destinations were using the same version, which significantly reduced the complexity across the codebase. Maintaining destinations now became less time consuming and less risky.</p>
<p>We also wanted a test suite that allowed us to quickly and easily run all our destination tests. Running all the tests was one of the main blockers when making updates to the shared libraries we discussed earlier.</p>
<p>Fortunately, the destination tests all had a similar structure. They had basic unit tests to verify our custom transform logic was correct and would execute HTTP requests to the partner’s endpoint to verify that events showed up in the destination as expected.</p>
<p>Recall that the original motivation for separating each destination codebase into its own repo was to isolate test failures. However, it turned out this was a false advantage. Tests that made HTTP requests were still failing with some frequency. With destinations separated into their own repos, there was little motivation to clean up failing tests. This poor hygiene led to a constant source of frustrating technical debt. Often a small change that should have only taken an hour or two would end up requiring a couple of days to a week to complete.</p>
<h2 id="building-a-resilient-test-suite"><a href="#building-a-resilient-test-suite">Building a Resilient Test Suite</a></h2>
<p>The outbound HTTP requests to destination endpoints during the test run was the primary cause of failing tests. Unrelated issues like expired credentials shouldn’t fail tests. We also knew from experience that some destination endpoints were much slower than others. Some destinations took up to 5 minutes to run their tests. With over 140 destinations, our test suite could take up to an hour to run.</p>
<p>To solve for both of these, we created Traffic Recorder. Traffic Recorder is built on top of <a target="_blank" href="https://github.com/flickr/yakbak" data-dynamic-link="true" rel="noopener noreferrer">yakbak</a>, and is responsible for recording and saving destinations’ test traffic. Whenever a test runs for the first time, any requests and their corresponding responses are recorded to a file. On subsequent test runs, the request and response in the file is played back instead requesting the destination’s endpoint. These files are checked into the repo so that the tests are consistent across every change. Now that the test suite is no longer dependent on these HTTP requests over the internet, our tests became significantly more resilient, a must-have for the migration to a single repo.</p>
<p>It took milliseconds to complete running the tests for all 140+ of our destinations after we integrated Traffic Recorder. In the past, just one destination could have taken a couple of minutes to complete. <i>It felt like magic.</i></p>
<h2 id="why-a-monolith-works"><a href="#why-a-monolith-works">Why a Monolith works</a></h2>
<p>Once the code for all destinations lived in a single repo, they could be merged into a single service. With every destination living in one service, our developer productivity substantially improved. We no longer had to deploy 140+ services for a change to one of the shared libraries. One engineer can deploy the service in a matter of minutes.</p>
<p>The proof was in the improved velocity. When our microservice architecture was still in place, we made 32 improvements to our shared libraries. One year later,  we’ve made 46 improvements.</p>
<p>The change also benefited our operational story. With every destination living in one service, we had a good mix of CPU and memory-intense destinations, which made scaling the service to meet demand significantly easier. The large worker pool can absorb spikes in load, so we no longer get paged for destinations that process small amounts of load.</p>
<h2 id="trade-offs"><a href="#trade-offs">Trade Offs</a></h2>
<p>Moving from our microservice architecture to a monolith overall was huge improvement, however, there are trade-offs:</p>
<ol><li><p><b>Fault isolation is difficult.</b> With everything running in a monolith, if a bug is introduced in one destination that causes the service to crash, the service will crash for all destinations. We have comprehensive automated testing in place, but tests can only get you so far. We are currently working on a much more robust way to prevent one destination from taking down the entire service while still keeping all the destinations in a monolith.</p>
</li><li><p><b>In-memory caching is less effective.</b> Previously, with one service per destination, our low traffic destinations only had a handful of processes, which meant their in-memory caches of control plane data would stay hot. Now that cache is spread thinly across 3000+ processes so it’s much less likely to be hit. We could use something like Redis to solve for this, but then that’s another point of scaling for which we’d have to account. In the end, we accepted this loss of efficiency given the substantial operational benefits.</p>
</li><li><p><b>Updating the version of a dependency may break multiple destinations.</b> While moving everything to one repo solved the previous dependency mess we were in, it means that if we want to use the newest version of a library, we’ll potentially have to update other destinations to work with the newer version. In our opinion though, the simplicity of this approach is worth the trade-off. And with our comprehensive automated test suite, we can quickly see what breaks with a newer dependency version.</p>
</li></ol>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>Our initial microservice architecture worked for a time, solving the immediate performance issues in our pipeline by isolating the destinations from each other. However, we weren’t set up to scale. We lacked the proper tooling for testing and deploying the microservices when bulk updates were needed. As a result, our developer productivity quickly declined.</p>
<p>Moving to a monolith allowed us to rid our pipeline of operational issues while significantly increasing developer productivity. We didn’t make this transition lightly though and knew there were things we had to consider if it was going to work.</p>
<ol><li>We needed a rock solid testing suite to put everything into one repo. Without this, we would have been in the same situation as when we originally decided to break them apart. Constant failing tests hurt our productivity in the past, and we didn’t want that happening again.</li><li>We accepted the trade-offs inherent in a monolithic architecture and made sure we had a good story around each. We had to be comfortable with some of the sacrifices that came with this change.</li></ol>
<p>When deciding between microservices or a monolith, there are different factors to consider with each. In some parts of our infrastructure, microservices work well but our server-side destinations were a perfect example of how this popular trend can actually hurt productivity and performance. It turns out, the solution for us was a monolith.</p>
<h2 id="acknowledgements"><a href="#acknowledgements">Acknowledgements</a></h2>
<p>The transition to a monolith was made possible by <a target="_blank" href="https://github.com/stephenmathieson" data-dynamic-link="true" rel="noopener noreferrer">Stephen Mathieson</a>, <a target="_blank" href="https://github.com/rbranson" data-dynamic-link="true" rel="noopener noreferrer">Rick Branson</a>, <a target="_blank" href="https://github.com/achille-roussel" data-dynamic-link="true" rel="noopener noreferrer">Achille Roussel</a>, <a target="_blank" href="https://github.com/tsholmes" data-dynamic-link="true" rel="noopener noreferrer">Tom Holmes</a>, and many more.</p>
<p>Special thanks to <a target="_blank" href="https://github.com/rbranson" data-dynamic-link="true" rel="noopener noreferrer">Rick Branson</a> for helping review and edit this post at every stage.</p>

    </div>

        
    </div>
</div>
        
    
</div>

        
        
    
        
        
        
            
            
<div class="page">




<div id="" background-image="" is-background-video="false" mobile-background-image="">

   
   
      <div>
         
            
            








    <p>
        
        
  <h3>
    Ready to see what Twilio Segment can do for you?
  </h3>

        
    </p>


         
            
            







    
    
    
    



         
      </div>
   
   

</div>
</div>


    

        
    
        
        
        
            
            
<div class="page">




<div id="" background-image="" is-background-video="false" mobile-background-image="">

   
   
      <div>
         
            
            



<div id="" background-image="" is-background-video="false" mobile-background-image="">

   
   
      <div>
         
            
            





	
	
	

	<figure>
		<p><img src="https://www.twilio.com/content/dam/segment/cdp-report/CDP-cover-2025.png/_jcr_content/renditions/compressed-original.webp" loading="lazy"/>
			
		</p>
		<p><img src="https://www.twilio.com/content/dam/segment/cdp-report/CDP-cover-2025.png/_jcr_content/renditions/compressed-original.webp" loading="lazy"/>
			
		</p>
		
	</figure>




         
      </div>
   
   

   
   
      <div>
         
            
            








    <p>
        
        
  <h2>
    The Customer Data Platform Report 2025
  </h2>

        
    </p>


         
            
            





    
    <p>Drawing on anonymized insights from thousands of Twilio customers, the Customer Data Platform report explores how companies are using CDPs to unlock the power of their data.</p>




         
            
            







    
    
    
    



         
      </div>
   
   

</div>

         
      </div>
   
   

</div>
</div>


    

        
    

    
    </div>

    


    </section>

</div></div>
  </body>
</html>
