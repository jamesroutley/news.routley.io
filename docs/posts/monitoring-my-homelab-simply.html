<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://b.tuxes.uk/simple-homelab-monitoring.html">Original</a>
    <h1>Monitoring My Homelab, Simply</h1>
    
    <div id="readability-page-1" class="page">
  

  <p>Date: <time>2025-07-09</time></p>

  <p>I have a middling self-hosted/homelab setup, and it
  occasionally breaks.</p>

  <p>Alas, no monitoring tool has ever sparked joy in me.</p>

  <p>Don’t get me wrong, I understand that they’re essential for
  large fleets of services with fast-changing software and teams of
  oncallers working around the clock to understand the complex ways
  that complex systems fail… but my stuff doesn’t change that
  often, failures are mundane and low-scope, and I’m the only
  person coming to rescue this poor stopped systemd unit that
  failed to restart, or open the port that I accidentally blocked
  in an overzealous attempt to stop the barbarians.</p>

  <p>So between no monitoring and Prometheus, I’ll choose no
  monitoring every day.</p>

  <p>But there’s a spectrum.</p>

  <h2 id="what-i-want-from-a-monitoring-setup">What I want from a
  monitoring setup</h2>

  <ul>
    <li>Pages me when my stuff is aggregiously broken.</li>

    <li>Pages me if things are still broken.</li>

    <li>Pages me when my stuff is fixed.</li>

    <li>Stops pages me when I want.</li>

    <li>Can see into my Wireguard mesh network.</li>

    <li>Easy to add probers.</li>
  </ul>

  <p>Simple, by which I mean:</p>

  <ul>
    <li>Easy to understand, e.g. avoid state.</li>

    <li>Easy to maintain: deploy, updates, blah, blah.</li>

    <li>Few moving pieces.</li>
  </ul>

  <p>Out-of-scope:</p>

  <ul>
    <li>Historical data: I’m not chasing down grand mysteries that
    require fleet-wide aggregate metrics.</li>

    <li>Dashboards: I’m okay with logs.</li>

    <li>Perfection: a bit of jank is fine.</li>

    <li>False positives are okay: I don’t mind being pinged of a
    false problem, as long as I get told when things recover.</li>

    <li>False negatives are okay: it’s okay to miss things. My goal
    is to add a little monitoring, to catch agregious issues.</li>
  </ul>

  <h2 id="design">Design</h2>

  <p>tl;dr I wrote a tiny program, that regularly checks
  HTTP/DNS/etc., and pages me via https://ntfy.sh</p>

  <p>I’ve been running this for 2-3 years now.</p>

  <h3 id="show-me-the-code">Show me the code</h3>

  <p>A prober probes at an interval, and has a description.</p>

  <pre><code>type prober interface {
    probe(context.Context) error
    interval() time.Duration
    String() string
}</code></pre>
  <p>Here’s an example prober for checking TLS connectivity and
  cert expiration:</p>

  <pre><code>type tlsProber struct {
    host string
    port int
    duration time.Duration
}

func (p *tlsProber) probe(ctx context.Context) error {
    target := fmt.Sprintf(&#34;%s:%d&#34;, p.host, p.port)
    conn, err := tls.Dial(&#34;tcp&#34;, target, &amp;tls.Config{})
    if err != nil {
        return err
    }
    defer conn.Close()
    cs := conn.ConnectionState()
    if len(cs.PeerCertificates) == 0 {
        return fmt.Errorf(&#34;want &gt;0 certs, got 0&#34;)
    }

    cert := cs.PeerCertificates[0]
    expiration := cert.NotAfter
    if diff := expiration.Sub(time.Now()); diff &lt; 14*24*time.Hour {
        return fmt.Errorf(&#34;cert expires in %v at %v&#34;, diff, expiration)
    }
    return nil
}

func (p *tlsProber) interval() time.Duration {
    return p.duration
}

func (p *tlsProber) String() string {
    return fmt.Sprintf(&#34;TLS %s:%d&#34;, p.host, p.port)
}</code></pre>
  <p>I have similar things for HTTP, TCP, DNS and domain
  expiration. I have a decorator-style <code>retryProber</code> for
  if things are flaky.</p>

  <p>I run each prober in a loop, notifying once for failures, with
  reminder notifications every hour. When the probe proceeds, it
  notifies too.</p>

  <pre><code>const reminderInterval = 1*time.Hour

type state int
const (
    good state = iota
    bad
)

func run(ctx context.Context, p prober, n notifier) {
    defer panic(&#34;Unreachable. Don&#39;t stop ticking. Never return!&#34;)
    log.Printf(&#34;Runner started for prober %q with interval %v.&#34;, p.String(), p.interval())
    ticker := time.NewTicker(p.interval())
    reminderTicker := time.NewTicker(reminderInterval)

    s := good
    var lastErr error
    for {
        select {
        case _ = &lt;-ticker.C:
            // Jitter. Also, prevent crash loops from causing damage.
            time.Sleep(time.Duration(rand.Intn(5000))*time.Millisecond)
            log.Printf(&#34;Probing %s&#34;, p.String())
            err := p.probe(ctx)
            if err != nil {
                // bad
                if s == good {
                    if err := n.notify(ctx, fmt.Sprintf(&#34;%s: %v&#34;, p.String(), err)); err != nil {
                        log.Printf(&#34;Notify failed: %v&#34;, err)
                    }
                } else {
                    log.Printf(&#34;%s failed but not re-notifying: %v&#34;, p.String(), err)
                }
                s = bad
                lastErr = err
                continue
            }

            // good
            if s == bad {
                if err := n.notify(ctx, fmt.Sprintf(&#34;%s: now passing&#34;, p.String())); err != nil {
                    log.Printf(&#34;Notify failed: %v&#34;, err)
                }
                s = good
                lastErr = nil
            }
        case _ = &lt;-reminderTicker.C:
            log.Printf(&#34;Checking whether to ping a reminder for %s&#34;, p.String())
            if s != good {
                if err := n.notify(ctx, fmt.Sprintf(&#34;%s still failing: %v&#34;, p.String(), lastErr)); err != nil {
                    log.Printf(&#34;Notify failed: %v&#34;, err)
                }
            }
        }
    }
}</code></pre>
  <p>If I was to review my own code I’d say <code>s</code> should
  be named <code>prevState</code>, and <code>// bad</code> needs
  more clarification. But this is my code and my blog, so LGTM!</p>

  <p>I’ve left some boring bits out like <code>main</code>,
  <code>notifier</code>, but I will mention that probers are
  defined in code:</p>

  <pre><code>var mythicBeastsNS = []string{
    &#34;ns1.mythic-beasts.com&#34;,
    &#34;ns2.mythic-beasts.com&#34;,
}

var probers = []prober{
    &amp;tlsProber{host: &#34;b.tuxes.uk&#34;, port: 443, duration: 5*time.Minute},
    &amp;tcpProber{host: &#34;my-vps.example.com&#34;, port: 22, duration: 5*time.Minute},
    &amp;domainProber{domain: &#34;tuxes.uk&#34;, rdapURL: &#34;https://rdap.nominet.uk/uk/domain/tuxes.uk&#34;, expectedNS: mythicBeastsNS},
}</code></pre>
  <p>This saves me dealing with parsing, config files, and offers
  the flexibility of code.</p>

  <h3 id="deployment">Deployment</h3>

  <p>This can run ~anywhere. It doesn’t listen, so no need to put
  it somewhere that can be scraped.</p>

  <p>This happens to run as a <code>DynamicUser</code> daemon on my
  router: my most reliable machine; a dependency to me fixing
  things anyway; and something I’ll notice if down.</p>

  <h3 id="receiving-pages">Receiving pages</h3>

  <p>I have https://ntfy.sh installed on my phone to receive pages.
  It’s respectful of battery, and can silence for n hours.</p>

  <p>I can’t silence particular pages, so every silence is
  “global”. This is fine, I just need to know “I should fix a
  thing”. A global silence could mask growing problems. Meh. It’ll
  do.</p>

  <h3 id="how-to-monitor-the-monitor">How to monitor the
  monitor?</h3>

  <p>If my daemon crashes, or I accidentally drop my computer in a
  stew, how long will it be until I notice I have no
  visibility?</p>

  <p>To avoid this, I ping https://healthchecks.io as a dead man’s
  switch. If that doesn’t get a ping in the last 10 minutes it
  notifies me via https://ntfy.sh and email.</p>

  <p>There’s a subtlety here. If my program reliably crashes after
  6 mins of runtime (e.g. due to memory leak, or a panic that
  happens on 2nd probe), but I manage to ping healthchecks.io every
  5 minutes, then my dead man’s switch will be happy, but my less
  frequent probers won’t ever be called.</p>

  <p>So I have two dead man switch’s:</p>

  <ul>
    <li>One which expects pings every 5 mins</li>

    <li>One which expects pings every 2 hours</li>
  </ul>

  <p>Those are also just HTTP probers:</p>

  <pre><code>var probers = []prober{
    // ...
    
    // Shortwave ping that is meant to quickly detect if this server is down.
    &amp;httpProber{url: &#34;https://hc-ping.com/79bfdda2-b162-451c-bc33-58d925240434&#34;, expected: 200, duration: 5*time.Minute},

    // Longwave ping that is meant to detect if this binary is crash looping.
    &amp;httpProber{url: &#34;https://hc-ping.com/05bdb3cc-4a2f-48dd-9a24-b08977e7f6a9&#34;, expected: 200, duration: 2*reminderInterval},
}</code></pre>
  <p>I can’t remember why I decided that the longwave probe should
  have a period of 2*reminderInterval, but I remember thinking hard
  about it, and thinking I was quite the scholar for thinking hard
  about this. If you figure it out and I’m correct, then please let
  me know.</p>

  <h2 id="what-i-like-about-it">What I like about it</h2>

  <ul>
    <li>Every part of this program fits inside my head.
    Mostly.</li>

    <li>Its only dependency is the Go standard library. Go is okay,
    but APIs that don’t break on me are great.</li>

    <li>Its only state is whether the last probe succeeded, and
    what the error message was.</li>

    <li>Adding probers or prober types is just normal code. No
    having to constrain my program with serialisation matters.</li>
  </ul>

  <h2 id="limitations">Limitations</h2>

  <ul>
    <li>No whitebox monitoring. Sometimes I’d like to check things
    like whether OS-level auto upgrades are working. Prometheus
    exporters can do this, and I miss out on those. It might not be
    too much code to parse some simple metrics from
    <code>/metrics</code>, or expose this via <code>/health</code>,
    but I’ve not needed it to bother.</li>
  </ul>

  <h2 id="alternatives">Alternatives</h2>

  <p>Probing is nothing new. There are tons of alternatives.</p>

  <h3 id="no-monitoring">No monitoring</h3>

  <p>I could just wait for me or my family to notice stuff is
  broken. It’s a reliable way to learn of stuff that actually needs
  fixing. But I’d like to spare that inconvenience, and have notice
  to fix things. Besides, I’m usually the cause of breakages, and
  if I can learn shortly after breaking it, I’m usually in a good
  spot to fix it.</p>

  <h3 id="updown.io">updown.io</h3>

  <p>A great site. Sadly it doesn’t have that many probers, and
  can’t see within my mesh network.</p>

  <h3 id="uptime-kuma">Uptime Kuma</h3>

  <p>Pro: Looks nice. Off-the-shelf.</p>

  <p>Con: Difficult to extend. Persistent state.</p>

  <h3 id="prometheus-and-blackbox-exporter">Prometheus and Blackbox
  exporter</h3>

  <p>Nooooo</p>

  <hr/>

  


</div>
  </body>
</html>
