<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/toy-load-store/?utm_source=rss">Original</a>
    <h1>Load and store forwarding in the Toy Optimizer</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>Another entry in the <a href="https://pypy.org/categories/toy-optimizer.html">Toy Optimizer series</a></em>.</p>

<p>A long, long time ago (two years!) <a href="https://cfbolz.de/">CF Bolz-Tereick</a> and I made a <a href="https://www.youtube.com/watch?v=w-UHg0yOPSE">video about
load/store forwarding</a> and an accompanying <a href="https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe">GitHub Gist</a> about
load/store forwarding in the Toy Optimizer. I said I would write a blog post
about it, but never found the time—it got lost amid a sea of large life
changes.</p>

<p>It’s a neat idea: do an abstract interpretation over the trace, modeling the
heap at compile-time, removing redundant reads and writes. That means it’s
possible to optimize traces like this:</p>

<div><div><pre><code>v0 = ...
v1 = load(v0, 5)
v2 = store(v0, 6, 123)
v3 = load(v0, 6)
v4 = load(v0, 5)
v5 = do_something(v1, v3, v4)
</code></pre></div></div>

<p>into traces like this:</p>

<div><div><pre><code>v0 = ...
v1 = load(v0, 5)
v2 = store(v0, 6, 123)
v5 = do_something(v1, 123, v1)
</code></pre></div></div>

<p>This indicates that we were able to remove two redundant loads by keeping
around information about previous loads and stores. Let’s get to work making
this possible.</p>

<h2 id="the-usual-infrastructure">The usual infrastructure</h2>

<p>We’ll start off with the usual infrastructure from the <a href="https://pypy.org/categories/toy-optimizer.html">Toy
Optimizer series</a>: a very stringly-typed representation of a
<a href="https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe#file-port-py-L4-L112">trace-based SSA IR</a> and a union-find rewrite mechamism.</p>

<p>This means we can start writing some new optimization pass and our first test:</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span># TODO: copy an optimized version of bb into opt_bb
</span>    <span>return</span> <span>opt_bb</span>

<span>def</span> <span>test_two_loads</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>var0</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>var2</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var1</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var2</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = load(var0, 0)
var2 = escape(var1)
var3 = escape(var1)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>This test is asserting that we can remove duplicate loads. Why load twice if we
can cache the result? Let’s make that happen.</p>

<h2 id="caching-loads">Caching loads</h2>

<p>To do this, we’ll model the the heap at compile-time. When I say “model”, I
mean that we will have an imprecise but correct abstract representation of the
heap: we don’t (and can’t) have knowledge of every value, but we can know for
sure that some addresses have certain values.</p>

<p>For example, if we have observed a load from object <em>O</em> at offset <em>8</em> <code>v0 =
load(O, 8)</code>, we know that the SSA value <code>v0</code> is at <code>heap[(O, 8)]</code>. That sounds
tautological, but it’s not. Future loads can make use of this information.</p>

<div><div><pre><code><span>def</span> <span>get_num</span><span>(</span><span>op</span><span>:</span> <span>Operation</span><span>,</span> <span>index</span><span>:</span> <span>int</span><span>=</span><span>1</span><span>):</span>
    <span>assert</span> <span>isinstance</span><span>(</span><span>op</span><span>.</span><span>arg</span><span>(</span><span>index</span><span>),</span> <span>Constant</span><span>)</span>
    <span>return</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>index</span><span>).</span><span>value</span>

<span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span># Stores things we know about the heap at... compile-time.
</span>    <span># Key: an object and an offset pair acting as a heap address
</span>    <span># Value: a previous SSA value we know exists at that address
</span>    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span>obj</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>)</span>
            <span>offset</span> <span>=</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>)</span>
            <span>load_info</span> <span>=</span> <span>(</span><span>obj</span><span>,</span> <span>offset</span><span>)</span>
            <span>previous</span> <span>=</span> <span>compile_time_heap</span><span>.</span><span>get</span><span>(</span><span>load_info</span><span>)</span>
            <span>if</span> <span>previous</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>previous</span><span>)</span>
                <span>continue</span>
            <span>compile_time_heap</span><span>[</span><span>load_info</span><span>]</span> <span>=</span> <span>op</span>
        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>This pass records information about loads and uses the result of a previous
cached load operation if available. We treat the pair of (SSA value, offset) as
an address into our abstract heap.</p>

<p>That’s great! If you run our simple test, it should now pass. But what happens
if we store into that address before the second load? Oops…</p>

<div><div><pre><code><span>def</span> <span>test_store_to_same_object_offset_invalidates_load</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>var0</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>var2</span> <span>=</span> <span>bb</span><span>.</span><span>store</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>,</span> <span>5</span><span>)</span>
    <span>var3</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var1</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var3</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = load(var0, 0)
var2 = store(var0, 0, 5)
var3 = load(var0, 0)
var4 = escape(var1)
var5 = escape(var3)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>This test fails because we are incorrectly keeping around <code>var1</code> in our
abstract heap. We need to get rid of it and not replace <code>var3</code> with <code>var1</code>.</p>

<h2 id="invalidating-cached-loads">Invalidating cached loads</h2>

<p>So it turns out we have to also model stores in order to cache loads correctly.
One valid, albeit aggressive, way to do that is to throw away all the
information we know at each store operation:</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;store&#34;</span><span>:</span>
            <span>compile_time_heap</span><span>.</span><span>clear</span><span>()</span>
        <span>elif</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span># ...
</span>        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>That makes our test pass—yay!—but at great cost. It means any store
operation mucks up redundant loads. In our world where we frequently read from
and write to objects, this is what we call a huge bummer.</p>

<p>For example, a store to offset 4 on some object should never interfere with a
load from a different offset on the same object<sup id="fnref:size" role="doc-noteref"><a href="#fn:size" rel="footnote">1</a></sup>. We should be able to
keep our load from offset 0 cached here:</p>

<div><div><pre><code><span>def</span> <span>test_store_to_same_object_different_offset_does_not_invalidate_load</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>var0</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>var2</span> <span>=</span> <span>bb</span><span>.</span><span>store</span><span>(</span><span>var0</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>)</span>
    <span>var3</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var1</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var3</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = load(var0, 0)
var2 = store(var0, 4, 5)
var3 = escape(var1)
var4 = escape(var1)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>We could try instead checking if our specific (object, offset) pair is in the
heap and only removing cached information about that offset and that object.
That would definitely help!</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;store&#34;</span><span>:</span>
            <span>load_info</span> <span>=</span> <span>(</span><span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>),</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>))</span>
            <span>if</span> <span>load_info</span> <span>in</span> <span>compile_time_heap</span><span>:</span>
                <span>del</span> <span>compile_time_heap</span><span>[</span><span>load_info</span><span>]</span>
        <span>elif</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span># ...
</span>        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>It makes our test pass, too, which is great news.</p>

<p>Unfortunately, this runs into problems due to aliasing: it’s entirely possible
that our compile-time heap could contain a pair <code>(v0, 0)</code> and a pair <code>(v1, 0)</code> where <code>v0</code>
and <code>v1</code> are the same object (but not known to the optimizer). Then we might
run into a situation where we incorrectly cache loads because the optimizer
doesn’t know our abstract addresses <code>(v0, 0)</code> and <code>(v1, 0)</code> are actually the
same pointer at run-time.</p>

<p>This means that we are breaking abstract interpretation rules: our abstract
interpreter has to correctly model <em>all</em> possible outcomes at run-time. This
means to me that we should instead pick some tactic in-between clearing all
information (correct but over-eager) and clearing only exact matches of
object+offset (incorrect).</p>

<p>The term that will help us here is called an <em>alias class</em>. It is a name for a
way to efficiently partition objects in your abstract heap into completely
disjoint sets. Writes to any object in one class never affect objects in
another class.</p>

<p>Our very scrappy alias classes will be just based on the offset: each offset is
a different alias class. If we write to any object at offset K, we have to
invalidate all of our compile-time offset K knowledge—even if it’s for
another object. This is a nice middle ground, and it’s possible because our
(made up) object system guarantees that distinct objects do not overlap, and
also that we are not writing out-of-bounds.<sup id="fnref:tbaa" role="doc-noteref"><a href="#fn:tbaa" rel="footnote">2</a></sup></p>

<p>So let’s remove all of the entries from <code>compile_time_heap</code> where the offset
matches the offset in the current <code>store</code>:</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;store&#34;</span><span>:</span>
            <span>offset</span> <span>=</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>)</span>
            <span>compile_time_heap</span> <span>=</span> <span>{</span>
                <span>load_info</span><span>:</span> <span>value</span>
                <span>for</span> <span>load_info</span><span>,</span> <span>value</span> <span>in</span> <span>compile_time_heap</span><span>.</span><span>items</span><span>()</span>
                <span>if</span> <span>load_info</span><span>[</span><span>1</span><span>]</span> <span>!=</span> <span>offset</span>
            <span>}</span>
        <span>elif</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span># ...
</span>        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>Great! Now our test passes.</p>

<p>This concludes the load optimization section of the post. We have modeled
enough of loads and stores that we can eliminate redundant loads. Very cool.
But we can go further.</p>

<h2 id="caching-stores">Caching stores</h2>

<p>Stores don’t just invalidate information. They also give us new information!
Any time we see an operation of the form <code>v1 = store(v0, 8, 5)</code> we also learn
that <code>load(v0, 8) == 5</code>! Until it gets invalidated, anyway.</p>

<p>For example, in this test, we can eliminate the load from <code>var0</code> at offset 0:</p>

<div><div><pre><code><span>def</span> <span>test_load_after_store_removed</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>var0</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>store</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>,</span> <span>5</span><span>)</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>0</span><span>)</span>
    <span>var2</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>var0</span><span>,</span> <span>1</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var1</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var2</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = store(var0, 0, 5)
var2 = load(var0, 1)
var3 = escape(5)
var4 = escape(var2)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>Making that work is thankfully not very hard; we need only add that new
information to the compile-time heap after removing all the
potentially-aliased info:</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;store&#34;</span><span>:</span>
            <span>offset</span> <span>=</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>)</span>
            <span>compile_time_heap</span> <span>=</span> <span># ... as before ...
</span>            <span>obj</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>)</span>
            <span>new_value</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>2</span><span>)</span>
            <span>compile_time_heap</span><span>[(</span><span>obj</span><span>,</span> <span>offset</span><span>)]</span> <span>=</span> <span>new_value</span>  <span># NEW!
</span>        <span>elif</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span># ...
</span>        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>This makes the test pass. It makes another test fail, but only
because—oops—we now know more. You can delete the old test because the new
test supersedes it.</p>

<p>Now, note that we are not removing the store. This is because we have nothing
in our optimizer that keeps track of what might have observed the side-effects
of the store. What if the object got <code>escape</code>d? Or someone did a load later on?
We would only be able to remove the store (<code>continue</code>) if we could guarantee it
was not observable.</p>

<p>In our current framework, this only happens in one case: someone is doing a
store of the exact same value that already exists in our compile-time heap.
That is, either the same constant, or the same SSA value. If we see this, then
we can completely skip the second store instruction.</p>

<p>Here’s a test case for that, where we have gained information from the load
instruction that we can then use to get rid of the store instruction:</p>

<div><div><pre><code><span>def</span> <span>test_load_then_store</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>arg1</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>arg1</span><span>,</span> <span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>store</span><span>(</span><span>arg1</span><span>,</span> <span>0</span><span>,</span> <span>var1</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var1</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = load(var0, 0)
var2 = escape(var1)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>Let’s make it pass. To do that, first we’ll make an equality function that
works for both constants and operations. Constants are equal if their values
are equal, and operations are equal if they are the identical (by
address/pointer) operation.</p>

<div><div><pre><code><span>def</span> <span>eq_value</span><span>(</span><span>left</span><span>:</span> <span>Value</span><span>|</span><span>None</span><span>,</span> <span>right</span><span>:</span> <span>Value</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>left</span><span>,</span> <span>Constant</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span><span>right</span><span>,</span> <span>Constant</span><span>):</span>
        <span>return</span> <span>left</span><span>.</span><span>value</span> <span>==</span> <span>right</span><span>.</span><span>value</span>
    <span>return</span> <span>left</span> <span>is</span> <span>right</span>
</code></pre></div></div>

<p>This is a partial equality: if two operations are not equal under <code>eq_value</code>,
it doesn’t mean that they are different, only that we don’t know that they are
the same.</p>

<p>Then, after that, we need only check if the current value in the compile-time
heap is the same as the value being stored in. If it is, wonderful. No need to
store. <code>continue</code> and don’t append the operation to <code>opt_bb</code>:</p>

<div><div><pre><code><span>def</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>:</span> <span>Block</span><span>):</span>
    <span>opt_bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>compile_time_heap</span><span>:</span> <span>Dict</span><span>[</span><span>Tuple</span><span>[</span><span>Value</span><span>,</span> <span>int</span><span>],</span> <span>Value</span><span>]</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>op</span> <span>in</span> <span>bb</span><span>:</span>
        <span>if</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;store&#34;</span><span>:</span>
            <span>obj</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>)</span>
            <span>offset</span> <span>=</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>)</span>
            <span>store_info</span> <span>=</span> <span>(</span><span>obj</span><span>,</span> <span>offset</span><span>)</span>
            <span>current_value</span> <span>=</span> <span>compile_time_heap</span><span>.</span><span>get</span><span>(</span><span>store_info</span><span>)</span>
            <span>new_value</span> <span>=</span> <span>op</span><span>.</span><span>arg</span><span>(</span><span>2</span><span>)</span>
            <span>if</span> <span>eq_value</span><span>(</span><span>current_value</span><span>,</span> <span>new_value</span><span>):</span>  <span># NEW!
</span>                <span>continue</span>
            <span>compile_time_heap</span> <span>=</span> <span># ... as before ...
</span>            <span># ...
</span>        <span>elif</span> <span>op</span><span>.</span><span>name</span> <span>==</span> <span>&#34;load&#34;</span><span>:</span>
            <span>load_info</span> <span>=</span> <span>(</span><span>op</span><span>.</span><span>arg</span><span>(</span><span>0</span><span>),</span> <span>get_num</span><span>(</span><span>op</span><span>,</span> <span>1</span><span>))</span>
            <span>if</span> <span>load_info</span> <span>in</span> <span>compile_time_heap</span><span>:</span>
                <span>op</span><span>.</span><span>make_equal_to</span><span>(</span><span>compile_time_heap</span><span>[</span><span>load_info</span><span>])</span>
                <span>continue</span>
            <span>compile_time_heap</span><span>[</span><span>load_info</span><span>]</span> <span>=</span> <span>op</span>
        <span>opt_bb</span><span>.</span><span>append</span><span>(</span><span>op</span><span>)</span>
    <span>return</span> <span>opt_bb</span>
</code></pre></div></div>

<p>This makes our load-then-store pass and it also makes other tests pass too,
like eliminating a store after another store!</p>

<div><div><pre><code><span>def</span> <span>test_store_after_store</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>arg1</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>store</span><span>(</span><span>arg1</span><span>,</span> <span>0</span><span>,</span> <span>5</span><span>)</span>
    <span>bb</span><span>.</span><span>store</span><span>(</span><span>arg1</span><span>,</span> <span>0</span><span>,</span> <span>5</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = store(var0, 0, 5)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>Unfortunately, this only works if the values—constants or SSA values—are
known to be the same. If we store <em>different</em> values, we can’t optimize. In the
live stream, we left this an exercise for the viewer:</p>

<div><div><pre><code><span>@</span><span>pytest</span><span>.</span><span>mark</span><span>.</span><span>xfail</span>
<span>def</span> <span>test_exercise_for_the_reader</span><span>():</span>
    <span>bb</span> <span>=</span> <span>Block</span><span>()</span>
    <span>arg0</span> <span>=</span> <span>bb</span><span>.</span><span>getarg</span><span>(</span><span>0</span><span>)</span>
    <span>var0</span> <span>=</span> <span>bb</span><span>.</span><span>store</span><span>(</span><span>arg0</span><span>,</span> <span>0</span><span>,</span> <span>5</span><span>)</span>
    <span>var1</span> <span>=</span> <span>bb</span><span>.</span><span>store</span><span>(</span><span>arg0</span><span>,</span> <span>0</span><span>,</span> <span>7</span><span>)</span>
    <span>var2</span> <span>=</span> <span>bb</span><span>.</span><span>load</span><span>(</span><span>arg0</span><span>,</span> <span>0</span><span>)</span>
    <span>bb</span><span>.</span><span>escape</span><span>(</span><span>var2</span><span>)</span>
    <span>opt_bb</span> <span>=</span> <span>optimize_load_store</span><span>(</span><span>bb</span><span>)</span>
    <span>assert</span> <span>bb_to_str</span><span>(</span><span>opt_bb</span><span>)</span> <span>==</span> <span>&#34;&#34;&#34;</span><span>\
</span><span>var0 = getarg(0)
var1 = store(var0, 0, 7)
var2 = escape(7)&#34;&#34;&#34;</span>
</code></pre></div></div>

<p>We would only be able to optimize this away if we had some notion of a store
being <em>dead</em>. In this case, that is a store in which the value is never read
before being overwritten.</p>

<h2 id="removing-dead-stores">Removing dead stores</h2>

<p>TODO, I suppose. I have not gotten this far yet. If I get around to it, I will
come back and update the post.</p>

<h2 id="in-the-real-world">In the real world</h2>

<p>This small optimization pass may seem silly or fiddly—when would we ever see
something like this in a real IR?—but it’s pretty useful. Here’s the Ruby
code that got me thinking about it again some years later for ZJIT:</p>

<div><div><pre><code><span>class</span> <span>C</span>
  <span>def</span> <span>initialize</span>
    <span>@a</span> <span>=</span> <span>1</span>
    <span>@b</span> <span>=</span> <span>2</span>
    <span>@c</span> <span>=</span> <span>3</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>CRuby has a shape system and ZJIT makes use of it, so we end up optimizing this
code (if it’s monomorphic) into a series of shape checks and stores. The HIR
might end up looking something like the mess below, where I’ve annotated the
shape guards (can be thought of as loads) and stores with asterisks:</p>

<div><div><pre><code>fn initialize@tmp/init.rb:3:
# ...
bb2(v6:BasicObject):
  v10:Fixnum[1] = Const Value(1)
  v31:HeapBasicObject = GuardType v6, HeapBasicObject
* v32:HeapBasicObject = GuardShape v31, 0x400000
* StoreField v32, :@a@0x10, v10
  WriteBarrier v32, v10
  v35:CShape[0x40008e] = Const CShape(0x40008e)
* StoreField v32, :_shape_id@0x4, v35
  v16:Fixnum[2] = Const Value(2)
  v37:HeapBasicObject = GuardType v6, HeapBasicObject
* v38:HeapBasicObject = GuardShape v37, 0x40008e
* StoreField v38, :@b@0x18, v16
  WriteBarrier v38, v16
  v41:CShape[0x40008f] = Const CShape(0x40008f)
* StoreField v38, :_shape_id@0x4, v41
  v22:Fixnum[3] = Const Value(3)
  v43:HeapBasicObject = GuardType v6, HeapBasicObject
* v44:HeapBasicObject = GuardShape v43, 0x40008f
* StoreField v44, :@c@0x20, v22
  WriteBarrier v44, v22
  v47:CShape[0x400090] = Const CShape(0x400090)
* StoreField v44, :_shape_id@0x4, v47
  CheckInterrupts
  Return v22
</code></pre></div></div>

<p>If we had store-load forwarding in ZJIT, we could get rid of the intermediate
shape guards; they would know the shape from the previous <code>StoreField</code>
instruction. If we had dead store elimination, we could get rid of the
intermediate shape writes; they are never read. (And the repeated type guards
to check if it’s a heap object still are just silly and need to get removed
eventually.)</p>

<p>This is on the roadmap and will make object initialization even faster than it
is right now.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Thanks for reading the text version of the video that CF and I made a while
back. Now you know how to do load/store elimination on traces.</p>

<p>I think this does not need too much extra work to get it going on full CFGs; a
block is pretty much the same as a trace, so you can do a block-local version
without much fuss. If you want to go global, you need dominator information and
gen-kill sets.</p>

<p>Maybe I will touch on this in a future post…</p>

<h2 id="thank-you">Thank you</h2>

<p>Thank you to CF, who walked me through this live on a stream two years ago!
This blog post wouldn’t be possible without you.</p>


        </div></div>
  </body>
</html>
