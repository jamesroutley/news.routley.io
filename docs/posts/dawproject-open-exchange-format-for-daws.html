<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/bitwig/dawproject">Original</a>
    <h1>DAWproject: Open exchange format for DAWs</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>The goal of this post is to explore an alternative way for running SQLite in JavaScript environments using the <a href="https://github.com/WebAssembly/component-model">WebAssembly component model</a>, including the implementation of a VFS for data persistence.</p><h3 id="what-is-the-webassembly-component-model">What is the WebAssembly component model?</h3><p>WebAssembly components are interfaces that declare types, functions, imports, and exports. These components are compiled into WebAssembly with a <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md">special ABI</a>.</p><p>After a WebAssembly component is compiled it can be embedded in different environments, such as a web browser or a server. These environments can call the exported interfaces and provide implementations for the imported interfaces that the component needs to function.</p><p>A good explanation is provided on the <a href="https://github.com/WebAssembly/component-model/blob/8f0a9175d5d3982c14aab581fc56a73552c9f74c/design/high-level/UseCases.md">component model GitHub repository</a>.</p><h3 id="what-is-the-sqlite-vfs">What is the SQLite VFS?</h3><p>The SQLite VFS is <a href="https://www.sqlite.org/vfs.html">officially defined as</a>:</p><blockquote><p>The module at the bottom of the SQLite implementation stack that provides portability across operating systems.</p></blockquote><p>In other words, the SQLite VFS allows SQLite to run in any environment, provided that it has support for the following operations:</p><ul><li>Opening files in different modes, such as read only, read write, etc.</li><li>Reading and writing data on open files</li><li>File locking</li><li>Other required system behavior, for example getting the current time</li></ul><p>A SQLite VFS can be implemented by subclassing three modules: <code>sqlite3_vfs</code>, <code>sqlite3_file</code>, and <code>sqlite3_io_methods</code>.</p><p>Once these modules are built, they can be registered with SQLite as a VFS with the <code>sqlite3_vfs_register</code> function.</p><p>Implementing a SQLite VFS in a way that supports data persistence is one of the main challenges of running SQLite in the browser.</p><h3 id="existing-tools">Existing tools</h3><p>It is possible to run SQLite directly in the browser and/or Node using one of these libraries:</p><ul><li><a href="https://github.com/sql-js/sql.js">sql.js</a>, which allows JavaScript access to a SQLite database<ul><li><a href="https://github.com/jlongster/absurd-sql">absurd SQL</a> can be used for implementing a persistent VFS</li></ul></li><li><a href="https://sqlite.org/wasm/doc/tip/about.md">the sqlite3 WASM/JS subproject</a>, which adds a WebAssembly build and JavaScript functionality to SQLite</li><li><a href="https://github.com/rhashimoto/wa-sqlite">wa-sqlite</a>, which allows for writing virtual filesystems (VFS) and virtual tables in Javascript</li></ul><p>These libraries provide various degrees of support for data persistence in the browser.</p><p><a href="https://github.com/rhashimoto/wa-sqlite">wa-sqlite</a> differs slightly from other projects because it provides a <a href="https://github.com/rhashimoto/wa-sqlite/blob/122c46ea4d2f20308c0a3d62b79add048a2bef9c/src/VFS.js">class called VFS.Base</a> that allows library consumers to implement their own VFS. Examples are provided for implementing a VFS with different web storage technologies, including the <a href="https://github.com/rhashimoto/wa-sqlite/blob/122c46ea4d2f20308c0a3d62b79add048a2bef9c/src/examples/AccessHandlePoolVFS.js">origin private file system</a>, and <a href="https://github.com/rhashimoto/wa-sqlite/blob/122c46ea4d2f20308c0a3d62b79add048a2bef9c/src/examples/IDBMinimalVFS.js">IndexedDB</a>.</p><p>In my opinion, the approach by Roy Hashimoto in wa-sqlite feels like the cleanest way to solve this problem, and the best work in this area to date.</p><p>All of the tools, including wa-sqlite, use <a href="https://emscripten.org/">emscripten</a> to compile SQLite to WebAssembly and expose the C FFI in a WebAssembly binary.</p><p>These tools also re-export the C FFI in a JavaScript-friendly interface. This allows library consumers to directly use SQLite in JavaScript.</p><h2 id="how-the-webassembly-component-model-fits-in">How the WebAssembly component model fits in</h2><p>Here is a high level summary of what a library must do to implement SQLite in the browser.</p><p><img src="https://petermalmgren.com/wasm-components-sqlite-vfs/sqlite-wasm.png" alt="a diagram showing the interactions between a SQLite JavaScript library, SQLite itself, and a library"/></p><p>The challenges and complexity lie in three areas:</p><ol><li>Providing bindings between the SQLite WebAssembly module and JavaScript, including manipulating memory, dealing with pointers, and handling function calls</li><li>Using the bindings along with imported code to build a browser-aware SQLite VFS to provide data persistence</li><li>Exposing the bindings as exported code to allow library consumers to use SQLite in the browser</li></ol><p>Theoretically, these are directly addressed by the WebAssembly component model proposal.</p><p>Practically, a number of different tools are needed to build a WebAssembly component:</p><ol><li><a href="https://github.com/bytecodealliance/wit-bindgen">wit-bindgen</a> is used to define the import and export interfaces and generate the glue code in different guest languages</li><li>A supported guest language along with the <a href="https://github.com/WebAssembly/wasi-sdk">WASI SDK</a>. I chose Rust but C/C++, Go, Java, and possibly even <a href="https://github.com/bytecodealliance/jco#componentize">JavaScript</a> are also supported</li><li><a href="https://github.com/bytecodealliance/wasm-tools">wasm-tools</a> is used to create the component from the WebAssembly binary</li><li><a href="https://github.com/bytecodealliance/jco">jco</a> is used to build a JavaScript interface to the WebAssembly component</li></ol><p>Because there <em>are so many tools</em> I made this diagram to keep track of them:</p><p><img src="https://petermalmgren.com/wasm-components-sqlite-vfs/wasm-component-build.png" alt="a diagram demonstrating how the four different sets of tools fit together"/></p><p>The final artifact produced is <code>component.wasm</code>, which can be used along with <a href="https://github.com/bytecodealliance/jco">jco</a> to create a JavaScript library. This library can be given import definitions to do things like implement a VFS or register custom user-defined functions. This library can also provide exports to open a database and perform SQL queries.</p><p>Here is a diagram demonstrating the last part of the build:</p><p><img src="https://petermalmgren.com/wasm-components-sqlite-vfs/component-to-js.png" alt="a diagram demonstrating how jco is used to create a JavaScript library"/></p><h2 id="getting-it-to-work">Getting it to work</h2><p>All of the code below is <a href="https://github.com/pmalmgren/sqlite-wasm-component">here</a>. There are three important parts:</p><ul><li>A Rust library which contains SQLite and the implementation of the WIT interfaces, compiled into WebAssembly</li><li>WIT interfaces which export SQLite functionality to the browser, and import the required methods for a VFS</li><li>A React app which imports the compiled library and provides the VFS implementation</li></ul><h3 id="compiling-sqlite-into-wasm">Compiling SQLite into WASM</h3><p>I chose <a href="https://docs.rs/sqlite/latest/sqlite/">rustqlite</a> because it supports the <code>wasm32-wasi</code> target. <code>wit-bindgen</code> is also included to generate the WIT interfaces.</p><div><pre tabindex="0"><code data-lang="toml"><span><span><span>[</span><span>package</span><span>]</span>
</span></span><span><span><span>name</span> <span>=</span> <span>&#34;sqlite-component&#34;</span>
</span></span><span><span><span>version</span> <span>=</span> <span>&#34;0.1.0&#34;</span>
</span></span><span><span><span>edition</span> <span>=</span> <span>&#34;2021&#34;</span>
</span></span><span><span>
</span></span><span><span><span># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>
</span></span><span><span>
</span></span><span><span><span>[</span><span>lib</span><span>]</span>
</span></span><span><span><span>crate-type</span> <span>=</span> <span>[</span><span>&#34;cdylib&#34;</span><span>]</span>
</span></span><span><span>
</span></span><span><span><span>[</span><span>dependencies</span><span>]</span>
</span></span><span><span><span>wit-bindgen</span> <span>=</span> <span>&#34;0.8.0&#34;</span>
</span></span><span><span><span>rusqlite</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;0.29.0&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[</span><span>&#34;wasm32-wasi-vfs&#34;</span><span>,</span> <span>&#34;bundled&#34;</span><span>]</span> <span>}</span>
</span></span></code></pre></div><p>Getting this to compile correctly is tricky. Hereâ€™s how I got it to work:</p><ol><li>By using the <a href="https://github.com/WebAssembly/wasi-sdk">wasi-sdk</a> linker instead of the default Rust linker</li><li>With a custom <code>build.rs</code> and this linker flag: <code>println!(&#34;cargo:rustc-link-arg=--no-entry&#34;);</code></li><li>With a custom build script that I found on a comment in this <a href="https://github.com/rusqlite/rusqlite/issues/827#issuecomment-1042796161">GitHub issue</a></li></ol><p>This build script was particularly helpful. Thanks to <a href="https://github.com/polyrand">polyrand</a> for putting it together!</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/usr/bin/env bash
</span></span></span><span><span><span></span>
</span></span><span><span><span># set WASI_SDK_PATH to the correct location in your system</span>
</span></span><span><span>
</span></span><span><span><span>export</span> <span>WASI_SYSROOT</span><span>=</span><span>&#34;</span><span>${</span><span>WASI_SDK_PATH</span><span>}</span><span>/share/wasi-sysroot&#34;</span>
</span></span><span><span><span>export</span> <span>CC</span><span>=</span><span>&#34;</span><span>${</span><span>WASI_SDK_PATH</span><span>}</span><span>/bin/clang --sysroot=</span><span>${</span><span>WASI_SYSROOT</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>export</span> <span>AR</span><span>=</span><span>&#34;</span><span>${</span><span>WASI_SDK_PATH</span><span>}</span><span>/bin/llvm-ar&#34;</span>
</span></span><span><span><span>export</span> <span>CC_wasm32_wasi</span><span>=</span><span>&#34;</span><span>${</span><span>CC</span><span>}</span><span>&#34;</span>
</span></span><span><span><span>export</span> <span>CARGO_TARGET_WASM32_WASI_LINKER</span><span>=</span><span>&#34;</span><span>${</span><span>WASI_SDK_PATH</span><span>}</span><span>/bin/wasm-ld&#34;</span>
</span></span><span><span>
</span></span><span><span><span>export</span> <span>LIBSQLITE3_FLAGS</span><span>=</span><span>&#34;\
</span></span></span><span><span><span>    -DSQLITE_TEMP_STORE=2 \
</span></span></span><span><span><span>    -DSQLITE_THREADSAFE=0 \
</span></span></span><span><span><span>    -DSQLITE_OMIT_LOCALTIME \
</span></span></span><span><span><span>    -DSQLITE_OMIT_LOAD_EXTENSION \
</span></span></span><span><span><span>    -DLONGDOUBLE_TYPE=double&#34;</span>
</span></span><span><span>
</span></span><span><span>cargo build --target <span>&#34;wasm32-wasi&#34;</span>
</span></span><span><span>
</span></span><span><span>cp ./target/wasm32-wasi/debug/sqlite_component.wasm sqlite-component-core.wasm
</span></span></code></pre></div><p>This script must be provided with the path to wasi-sdk: <code>WASI_SDK=/lib/wasi-sdk ./build.sh</code></p><h3 id="an-incomplete-sqlite-vfs-wit-interface">An Incomplete SQLite VFS WIT Interface</h3><pre tabindex="0"><code data-lang="wit">// wit/host.wit
package sqlite3-wasm-vfs:vfs

interface types {
  type sqlite-error = s32
  type sqlite-db = s32
  type file-id = s32
  flags open-flags {
    readonly,
    readwrite,
    create,
    deleteonclose,
    exclusive,
    autoproxy,
    uri,
    memory,
    main-db,
    temp-db,
    transient-db,
    main-journal,
    temp-journal,
    subjournal,
    super-journal,
    nomutex,
    fullmutex,
    privatecache,
    wal,
    nofollow,
    exrescode,
  }
}

interface imports {
  use types.{sqlite-error, open-flags, file-id}

  log: func(msg: string)
  vfs-open: func(name: string, id: file-id, in-flags: open-flags) -&gt; result&lt;open-flags, sqlite-error&gt;
}

world vfs {
  use types.{sqlite-db, sqlite-error}
  export init: func()
  export sqlite-open: func(name: string, vfs: string) -&gt; result&lt;sqlite-db, sqlite-error&gt;
  export register-vfs: func(name: string)
  import imports
}
</code></pre><p><em>Note: because my mind was mostly on getting this to work, the interfaces probably arenâ€™t the best. Also, I used raw pointers for passing objects around across the wasm&lt;-&gt;browser boundary, when I could have used a <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md#item-resource">resource</a> for borrowing.</em></p><p>This minimal proof-of-concept allows us to do a few things:</p><ol><li>Initialize a database with the <code>init()</code> import</li><li>Register a custom VFS with the <code>registerVfs(name: string)</code> import, provided it defines and exports a <code>vfsOpen</code> function</li><li>Open a database with a name and the provided VFS</li><li>Log things to the browser provided that the browser code defines an exports a <code>log</code> function</li></ol><h3 id="rust-provide-wasi-wit-files">Rust: Provide WASI WIT Files</h3><p>Because the compilation process uses a version of WASI which is converted to a WebAssembly component, I had to bring in and copy over some WIT files from the <a href="https://github.com/bytecodealliance/preview2-prototyping">preview2-prototyping repository</a>. I copied this stuff directly into the <code>wit/</code> folder of my repository.</p><h3 id="rust-define-exports">Rust: Define Exports</h3><p>The <code>init</code> function calls the <code>sqlite3_initialize()</code> function that is exported from the <code>rustqlite</code> library. It also bypasses some of the <code>rustqlite</code> implementation, which allows us to use sqlite in single-threaded mode.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>init</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>assert_eq!</span><span>(</span><span>sqlite3_initialize</span><span>(),</span><span> </span><span>SQLITE_OK</span><span>,</span><span> </span><span>&#34;Could not initialize SQLite&#34;</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>bypass_sqlite_initialization</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>I wonâ€™t be going over the implementation of <code>registerVfs</code> because itâ€™s a ton of boilerplate, but I invite you to read it over <a href="https://github.com/pmalmgren/sqlite-wasm-component/blob/main/src/lib.rs">here</a> if youâ€™re curious.</p><p>The <code>sqlite_open</code> function builds a path, the VFS name, and calls into <code>sqlite3_open_v2</code>, which in turn calls into the imported function <code>vfs_open</code>, which is where the browser takes over.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>sqlite_open</span><span>(</span><span>path</span>: <span>String</span><span>,</span><span> </span><span>vfs</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>i32</span><span>,</span><span> </span><span>i32</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>filename</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>CString</span>::<span>new</span><span>(</span><span>path</span><span>.</span><span>as_str</span><span>())</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>fname</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>fname</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>err</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>log</span><span>(</span><span>format!</span><span>(</span><span>&#34;Error getting path: {err}&#34;</span><span>).</span><span>as_str</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span><span>Err</span><span>(</span><span>SQLITE_ERROR</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>vfs_name</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>CString</span>::<span>new</span><span>(</span><span>vfs</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>vname</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>vname</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>err</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>log</span><span>(</span><span>format!</span><span>(</span><span>&#34;Error getting path: {err}&#34;</span><span>).</span><span>as_str</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span><span>Err</span><span>(</span><span>SQLITE_ERROR</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>},</span><span>
</span></span></span><span><span><span>    </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>unsafe</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>db_ptr</span>: <span>*</span><span>mut</span><span> </span><span>sqlite3</span><span> </span><span>=</span><span> </span><span>std</span>::<span>ptr</span>::<span>null_mut</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>flags</span><span> </span><span>=</span><span> </span><span>OpenFlags</span>::<span>default</span><span>().</span><span>bits</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>res</span><span> </span><span>=</span><span> </span><span>sqlite3_open_v2</span><span>(</span><span>filename</span><span>.</span><span>as_ptr</span><span>(),</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>db_ptr</span><span>,</span><span> </span><span>flags</span><span>,</span><span> </span><span>vfs_name</span><span>.</span><span>as_ptr</span><span>());</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>res</span><span> </span><span>!=</span><span> </span><span>SQLITE_OK</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>log</span><span>(</span><span>format!</span><span>(</span><span>&#34;Error opening database: {res}&#34;</span><span>).</span><span>as_str</span><span>());</span><span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span><span>Err</span><span>(</span><span>res</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>log</span><span>(</span><span>&#34;Successfully opened connection.&#34;</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>db_ptr</span><span> </span><span>as</span><span> </span><span>i32</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>These functions allow a very minimal version of SQLite to run in the browser.</p><h3 id="javascript-building-the-webassembly-component">JavaScript: Building the WebAssembly Component</h3><p><a href="https://github.com/bytecodealliance/jco">jco</a> can turn compiled WebAssembly into a WebAssembly component, and then turn that into a library that can be used in JavaScript. jco also takes care of building the shims for calling back and forth into WebAssembly, something that can be a major headache otherwise.</p><p>I used the following versions in <code>package.json</code>:</p><div><pre tabindex="0"><code data-lang="json"><span><span><span>{</span>
</span></span><span><span>  <span>&#34;devDependencies&#34;</span><span>:</span> <span>{</span>
</span></span><span><span>    <span>&#34;@bytecodealliance/jco&#34;</span><span>:</span> <span>&#34;0.12.1&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;@bytecodealliance/preview2-shim&#34;</span><span>:</span> <span>&#34;0.0.16&#34;</span><span>,</span>
</span></span><span><span>  <span>},</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Afterwards, we can use the jco CLI to build a WebAssembly component like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ pnpm <span>exec</span> jco new ../sqlite-component-core.wasm --wasi-reactor -o sqlite-component.wasm
</span></span></code></pre></div><p>The <code>--wasi-reactor</code> flag will pull a compatible WASI adapter and use that to build a WebAssembly component.</p><h3 id="javascript-transpiling-the-webassembly-component">JavaScript: Transpiling the WebAssembly Component</h3><p>Next, we use the jco CLI <a href="https://github.com/bytecodealliance/jco#transpile">to transpile</a> the WebAssembly component to JavaScript:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ pnpm <span>exec</span> jco transpile sqlite-component.wasm <span>\
</span></span></span><span><span><span></span>    --no-nodejs-compat <span>\
</span></span></span><span><span><span></span>    --map sqlite3-wasm-vfs:vfs/imports<span>=</span>../imports <span>\
</span></span></span><span><span><span></span>    -o src/wasm
</span></span></code></pre></div><p>We also have to define the imports needed by our library:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>import</span> <span>type</span> <span>{</span> <span>OpenFlags</span> <span>}</span> <span>from</span> <span>&#34;./wasm/interfaces/sqlite3-wasm-vfs-vfs-types&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>log</span> <span>=</span> <span>(</span><span>out</span>: <span>string</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span></span><span><span>  <span>console</span><span>.</span><span>log</span><span>(</span><span>out</span><span>);</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>vfsOpen</span> <span>=</span> <span>(</span><span>name</span>: <span>string</span><span>,</span> <span>fileId</span>: <span>number</span><span>,</span> <span>flags</span>: <span>OpenFlags</span><span>)</span><span>:</span> <span>OpenFlags</span> <span>=&gt;</span> <span>{</span>
</span></span><span><span>  <span>console</span><span>.</span><span>log</span><span>(</span><span>`Opening </span><span>${</span><span>name</span><span>}</span><span> with id </span><span>${</span><span>fileId</span><span>}</span><span>`</span><span>);</span>
</span></span><span><span>  <span>return</span> <span>{</span>
</span></span><span><span>    <span>readwrite</span>: <span>true</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>export</span> <span>{</span> <span>log</span><span>,</span> <span>vfsOpen</span> <span>}</span>
</span></span></code></pre></div><h3 id="javascript-using-sqlite-in-a-react-component">JavaScript: Using SQLite in a React Component</h3><p>Finally, the cool part!</p><p>I used a client-side React app to access SQLite from a React component:</p><div><pre tabindex="0"><code data-lang="tsx"><span><span><span>import</span> <span>{</span> <span>useEffect</span><span>,</span> <span>useState</span> <span>}</span> <span>from</span> <span>&#34;react&#34;</span><span>;</span>
</span></span><span><span><span>import</span> <span>{</span> <span>init</span><span>,</span> <span>registerVfs</span><span>,</span> <span>sqliteOpen</span> <span>}</span> <span>from</span> <span>&#34;../wasm/sqlite-component&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>DB</span> <span>=</span> <span>&#34;path.db&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>export</span> <span>default</span> <span>function</span> <span>Hello() {</span>
</span></span><span><span>  <span>const</span> <span>[</span><span>initialized</span><span>,</span> <span>setInitialized</span><span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>);</span>
</span></span><span><span>  <span>useEffect</span><span>(()</span> <span>=&gt;</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>initialized</span><span>)</span> <span>{</span>
</span></span><span><span>      <span>return</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>init</span><span>();</span>
</span></span><span><span>    <span>registerVfs</span><span>(</span><span>&#34;test&#34;</span><span>);</span>
</span></span><span><span>    <span>setInitialized</span><span>(</span><span>true</span><span>);</span>
</span></span><span><span>  <span>},</span> <span>[</span><span>setInitialized</span><span>,</span> <span>initialized</span><span>]);</span>
</span></span><span><span>  <span>useEffect</span><span>(()</span> <span>=&gt;</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>initialized</span><span>)</span> <span>{</span>
</span></span><span><span>      <span>sqliteOpen</span><span>(</span><span>&#34;path.db&#34;</span><span>,</span> <span>&#34;test&#34;</span><span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>  <span>},</span> <span>[</span><span>initialized</span><span>]);</span>
</span></span><span><span>
</span></span><span><span>  <span>return</span> <span>(&lt;</span><span>h1</span><span>&gt;</span><span>Hello</span> <span>SQLite</span><span>!</span><span>&lt;/</span><span>h1</span><span>&gt;);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The app basically does nothing other than log some output to the console which proves that SQLite is working as expected.</p><p><img src="https://petermalmgren.com/sqliteworks.png" alt="SQLite running in a react app, with console logging to prove it"/></p><p>ðŸŽ‰</p><h2 id="conclusion">Conclusion</h2><p>The goal of this post is to draw attention to the <a href="https://bytecodealliance.org/">awesome work happening in WebAssembly by the Bytecode Alliance</a>, particularly around WebAssembly components and how they can be used to push the boundaries of whatâ€™s possible in JS and embedded environments.</p><p>Even though my WIT interface only defined one VFS function, <code>vfsOpen</code>, I believe that it should be possible to extend and improve the approach I outlined here to run a fully customizable browser version of SQLite using WebAssembly components without the need for emscripten.</p><p>I hope this post sparks some further discussion between the SQLite project and the WebAssembly community on using WebAssembly components to embed and run SQLite.</p><p>I hope you enjoyed this post and found it helpful!</p><h2 id="credits">Credits</h2><p>Thanks to <a href="https://twitter.com/guybedford">@guybedford</a> for proofreading this post and providing some tips on using the jco CLI to build WebAssembly components.</p><p>Thanks to the authors of <a href="https://github.com/rusqlite/rusqlite">rustqlite</a> for providing and maintaining an awesome crate.</p></div></div>
  </body>
</html>
