<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jsbarretto.com/post/actors">Original</a>
    <h1>OOP is shifting between domains, not disappearing</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>OOP is shifting between domains, not disappearing. I think that&#39;s usually a bad thing.</p>
                <hr/>
                <p><i>2025-11-18</i>
                    
                </p>
            </div><div>
                <p>Many bytes have been spilled on the topic of object-oriented programming: What is it? Why is it? Is it good? I’m not sure I have
the answers to these questions, but I have observed an interesting trend that I think has flown under the radar: OOP is not
disappearing, but shifting across domains.</p>
<h2>Some quick and entirely incorrect history</h2>
<p>In times of old, people wrote programs. Things were easy and simple. Then, a manager that didn’t know how much trouble they were
getting themselves into asked two programmers to work on the same program. Bad things happened.</p>
<p>Some bright spark realised that bugs often appeared at the intersection of software functionality, and that it might be a sensible
idea to perform a bit of invasive surgery and separate those functions with an <em>interface</em>: an at-least-vaguely specified contract
describing the behaviour the two functions might expect from one-another.</p>
<p>Other bright sparks jumped in on the action: what if this separation did not rely on the personal hygiene of the programmers -
something that should always be called into question for public health reasons - and was instead enforced by the language? Components
might hide their implementation by default and communicate only though a set of public functions, and the language might reject programs
that tried to skip around these barricades. How quaint.</p>
<p>Nowadays, we have a myriad of terms for these concepts, and others which followed in an attempt to further propagate the core idea:
encapsulation, inheritance, polymorphism. All have the goal of attenuation the information that might travel between components by force.
This core idea isn’t unique to OOP, of course, but it is OOP that champions it and flies its coat of arms into battle with fervour.</p>
<h2>Programs-as-classes</h2>
<p>At around the same time, some bright spark realised that programmers - a population of people not known for good hygiene - might also
not produce the most hygienic of programs, and that it was perhaps important not to trust all of the little doo-dahs that ran on your
computer. And so the process <em>boundary</em> was born, and operating systems morphed from friendly personal assistants with the goal of doing
the dirty work of programs into childminders, whose work mainly consisted of ensuring that those within their care did not accidentally
feed one-another snails or paperclips.</p>
<p>In tandem, other bright sparks were discovering that computers could be made to talk to one-another, and that perhaps this might be useful.
Now, programs written by people that didn’t even know one-another - let alone trust one-another - could start interacting.</p>
<p>When trust dissolves, societies tends to overzealously establish the highest and thickest walls they can, no matter the cost. Software
developers are no different. When every program has evolved into a whirlwind of components created by an army of developers that rarely know
of their software’s inclusion, much less communicate about it, then the only reasonable reaction is maximum distrust.</p>
<p>And so, the process/network boundary naturally became that highest and thickest wall - just in time for it to replace the now-ageing
philosophy of object-oriented programming.</p>
<h2>Was it worth it?</h2>
<p>Our world today is one of microservices, of dockers, of clusters, of ‘scaling’. The great irony is that for all of the OOP-scepticism you’ll
hear when whispering of Java to a colleague, we have replaced it with a behemoth with precisely the same flaws - but magnified tenfold. OpenAPI
schemas replace type-checkers, docker compose replaces service factories, Kubernetes replaces the event loop. Every call across components
acrues failure modes, requires a slow march through (de)serialisation libraries, a long trek through the kernel’s scheduler. A TLB cache
invalidation here, a socket poll there. Perhaps a sneaky HTTP request to localhost for desert.</p>
<p>I am not convinced by the promises of OOP, but I am even less convinced by the weasel words of that which has replaced it.</p>

            </div></div>
  </body>
</html>
