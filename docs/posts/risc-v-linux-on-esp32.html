<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.drorgluska.com/2022/07/risc-v-linux-on-esp32.html">Original</a>
    <h1>RISC-V Linux on ESP32</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><span id="9132715970419551050"><p>I&#39;ve been playing with the idea of running linux on ESP32 since the first days I&#39;ve met its more robust module, the WROVER-B, on paper it seem possible since its a dual core 240Mhz and has 16MB flash and 8MB RAM, compared to our antique machines that could run linux, it seems like a beast.</p><p>Doing some research on it, I&#39;ve understood that its MMU is insufficient for running Linux on it. during the past few years I&#39;ve been looking into it to see if anyone else found the time to implement it and eventually I&#39;ve decided its going to be a good opportunity to learn a bit more about RISCV and Buildroot. Two subjects I&#39;ve been putting off for longer than I&#39;d like to admit.</p><p>I&#39;ve decided to start with something rather to write it all from scratch, which I didn&#39;t have time or energy to do for this project, I&#39;ve looked into <a href="https://wiki.qemu.org/Documentation/Platforms/RISCV">QEMU emulation for RISCV</a> but taking this project apart and getting only a few components out of it to run on an embedded system seemed like too much work. Eventually I&#39;ve found out about Fabrice Bellard&#39;s <a href="https://bellard.org/tinyemu/">TinyEMU</a> (<a href="https://bellard.org/jslinux/vm.html?cpu=riscv64&amp;url=https://bellard.org/jslinux/buildroot-riscv64.cfg&amp;mem=256">demo</a>).</p><div><p><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjQkEdM4GAPNJGcxxyzokiHSIszX_hnyz7MsTOIRsRiOt4dLqCxcH_UY6QWm5ct6FHT9z33PhkgaEXNONtHVFt-y5eDSvcI4rk6nQa130niNhsVeFF-zahimTvrTHV6YGjPnVh_3G_tyoq1QuxbdgnBtcBvu2Nbd6oKHIpSWMRP9s0vN9_FE9KKS0sp"><img alt="" data-original-height="966" data-original-width="1509" height="410" src="https://blogger.googleusercontent.com/img/a/AVvXsEjQkEdM4GAPNJGcxxyzokiHSIszX_hnyz7MsTOIRsRiOt4dLqCxcH_UY6QWm5ct6FHT9z33PhkgaEXNONtHVFt-y5eDSvcI4rk6nQa130niNhsVeFF-zahimTvrTHV6YGjPnVh_3G_tyoq1QuxbdgnBtcBvu2Nbd6oKHIpSWMRP9s0vN9_FE9KKS0sp=w640-h410" width="640"/></a></p></div><h3>RISC-V</h3><p><a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a> is the new ISA kid in the block, well, not really a kid and not really new, but it becomes more and more popular, Espressif got out the <a href="https://www.espressif.com/en/news/ESP32_C3">ESP32-C3</a> at 2020.</p><h3>Previous Successes</h3><p>Max Filippov <a href="https://github.com/jcmvbkbc/linux-xtensa/tree/xtensa-5.19-esp32">patched</a> the kernel to support ESP32 back at <a href="https://www.reddit.com/r/esp32/comments/dtlj7n/booting_linux_on_esp32_realtime_video/">2019</a>, I&#39;m pretty sure it runs a lot faster since its not an emulation.</p><p>Li XiongHui wrote the <a href="https://github.com/juiceRv/JuiceVm">juiceVM</a> which implemented RISCV ISA and runs on ESP32, he wrote about it on <a href="https://whycan.com/p_66202.html">whycan</a> and <a href="https://www.reddit.com/r/esp32/comments/om106r/boot_linux_500_on_esp32/">reddit</a> and has <a href="https://www.youtube.com/watch?v=w9UlZIYZtwI">video of it booting on YouTube</a>, the video does state x30 speedup, which means the system booted in about 6 hours. Li never released the source code so the only improvements that can be done is by him and judging from my own life, you never have enough time for these things.</p><h3>TinyEMU</h3><p>&#34;TinyEMU is a system emulator for the RISC-V and x86 architectures. Its purpose is to be small and simple while being complete.&#34;</p><p>Looking at its <a href="https://bellard.org/tinyemu/tinyemu-2019-12-21.tar.gz">source code</a>, seemed like the project went from mission impossible (with my current resources) to mission possible. Oh the naiveté.</p><h3>ESP32</h3><p>The ESP32 is a dual core 240Mhz MCU, it was released at September 2016 and its still one of the best value for money MCU you can get, one of its versions has 8MB or RAM and 16MB of FLASH. That amount of RAM on any of its competitors takes more than &#34;I want it&#34; to get it working, at the time it came out especially so. Espressif did an amazing job with esp-idf and one of their best features is listening to their customers and with the help of the maker community they&#39;ve built an amazing framework.</p><h3>TinyEMU on ESP32</h3><p>Will it even compile?</p><p>Apparently yes, making it compile was very easy, some tweaks here and there and a missing standard library and it was compiled perfectly. </p><p>But what can I do about memory? the ESP32 only has 8MB and half of it is not even accessible as a standard but rather bank switched with its own APIs (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/himem.html">himem</a>).</p><p>My thinking at the time was that it doesn&#39;t matter so much since the kernel will probably not need so much memory once it starts, for example, if I don&#39;t access files, the memory holding the file system and the file system functions will be left alone other than a periodic flush.</p><p>So something like a swap file will probably be good enough for this experiment, right?</p><p>Not so fast.</p><p>First, I had to find out that the standard way of accessing the SD card is not fast enough at around 150k per second. <a href="https://blog.drorgluska.com/2022/06/esp32-sd-card-optimization.html">So I went to a journey to find all the bottlenecks</a>.</p><p>Then I&#39;ve discovered that 3MB for the virtual pages is too slow due to the <a href="https://www.reddit.com/r/esp32/comments/ezs5sg/how_slow_is_psram_vs_sram_anyone_have/">PSRAM</a>, using 80Mhz only improved a bit, so I went on a journey to find the fastest search trees, I&#39;ve tried <a href="https://en.wikipedia.org/wiki/Splay_tree">splay tree</a> and eventually rested on <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a> which was good enough.</p><p>But I could squeeze more out of the ESP32, I&#39;ve implemented a rudimentary direct-mapped-cache so most memory accesses won&#39;t even search for their page (Professor Luis Ceze has a <a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf">great presentation on the subject</a>).</p><p>I was still not happy enough, my SD card is slow and no matter what I did, it slowed things down. I&#39;ve measured how many page faults I had and decided that dirty pages should only be written once they are abandoned, so my <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">LRU cache</a> pushed dirty pages into himem and only when these himem pages reclaimed they got pushed to the page file.</p><p>At that point I was content enough, my kernel booted in 1:35 minutes. </p><p><iframe allowfullscreen="" height="266" src="https://www.youtube.com/embed/f3a3xeTRj_A" width="320" youtube-src-id="f3a3xeTRj_A"></iframe></p><h3>Buildroot</h3><p>&#34;<a href="https://buildroot.org/">Buildroot</a> is a simple, efficient and easy-to-use tool to generate embedded Linux systems through cross-compilation.&#34;</p><p>I&#39;ve always wanted to learn how the big guys do it, how embedded cameras, kiosks and perhaps even satellites gets their OS build without all the bloat and package managers.</p><p>So once I got my basic emulator working (without all the optimizations), it was time to start learning buildroot. </p><p>Apparently its simple, you just download the archive, work through a few menus, read some documentation, modify the rootfs with overlays and you&#39;re done. issue a make command and you have your kernel and your rootfs.</p><p>In the old days (or so I&#39;ve heard), you&#39;ve had to build RISC-V toolchain and patch the kernel to get things going, These days buildroot comes with a precompiled toolchain from <a href="https://bootlin.com/">bootlin</a>, so the whole experience was fun and easy to learn.</p><h3>Thoughts for the future</h3><p>Using the emulator to run embedded RISC-V code, implement <a href="https://github.com/sifive/example-gpio">SiFive GPIO</a> and provide more flexible VM for running code on multiple embedded platforms. Communicating over the console is implemented in <a href="https://bellard.org/tinyemu/diskimage-linux-riscv-2018-09-23.tar.gz">TinyEMU patches</a>, or see <a href="https://stackoverflow.com/questions/57228650/how-to-print-to-console-in-linux-from-risc-v-assembly">here</a> or through <a href="https://developer.ibm.com/articles/l-virtio/">virtio</a>.</p><h3>Closing</h3><p>This was a wonderful journey of learning, I&#39;ve learned more than I wanted about:</p><ul><li>file systems (thank you <a href="http://elm-chan.org/fsw/ff/00index_e.html">fatfs</a>)</li><li><a href="https://buildroot.org/">buildroot</a></li><li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/himem.html">himem</a></li><li>RISC-V Device Tree and <a href="file:///C:/Users/Dror/Downloads/devicetree-specification-v0.4-rc1.pdf">FDT</a> (Flattened Device Tree)</li><li><a href="https://github.com/riscv-software-src/riscv-pk">Proxy Kernel and BBL</a> (Berkeley Boot Loader)</li><li>SBI (Supervisor Binary Interface)</li><li>hvc0</li><li>virtio</li><li>memory layouts and caches</li><li>kernel memory and size optimizations (<a href="https://elinux.org/Kernel_Size_Tuning_Guide">here</a>, <a href="https://elinux.org/System_Size">here</a> and <a href="https://elinux.org/Kernel_Size_Tuning_Guide_Config_Option_Impact">here</a>).</li></ul><p>You can find the fruits of this labor at:</p></span>
<span><i></i> Tags: <a href="https://blog.drorgluska.com/search/label/buildroot" rel="tag">buildroot</a>, <a href="https://blog.drorgluska.com/search/label/esp32" rel="tag">esp32</a>, <a href="https://blog.drorgluska.com/search/label/linux" rel="tag">linux</a>, <a href="https://blog.drorgluska.com/search/label/riscv" rel="tag">riscv</a>, <a href="https://blog.drorgluska.com/search/label/riscv32" rel="tag">riscv32</a>, <a href="https://blog.drorgluska.com/search/label/riscv64" rel="tag">riscv64</a>, <a href="https://blog.drorgluska.com/search/label/tinyemu" rel="tag">tinyemu</a></span></p>

</div></div>
  </body>
</html>
