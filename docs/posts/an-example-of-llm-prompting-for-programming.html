<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinfowler.com/articles/2023-chatgpt-xu-hao.html">Original</a>
    <h1>An example of LLM prompting for programming</h1>
    
    <div id="readability-page-1" class="page"><p>Xu Hao uses chain of thought and general knowledge prompting with ChatGPT when writing self-testing code</p><p><i>My account of an internal chat with Xu Hao, where he shows how he
  drives ChatGPT to produce useful self-tested code. His initial prompt primes
  the LLM with an implementation strategy (chain of thought prompting). His
  prompt also asks for an implementation plan rather than code (general
  knowledge prompting). Once he has the plan he uses it to refine the
  implementation and generate useful sections of code.</i></p><div>


<p>Recently I watched a fascinating call on Zoom. Xu Hao, Thoughtworks&#39;s
    Head of Technology in China, explained his explorations in using ChatGPT to
    help build <a href="https://martinfowler.com/bliki/SelfTestingCode.html">Self Testing Code</a>. He
    went through the kind of interaction that works for him.</p>

<p>He starts with a prompt that sets the context for the application and how
    he wants the code to be structured.</p>

<pre>The current system is an online whiteboard system. Tech stack:
typescript, react, redux, konvajs and react-konva. And vitest, react
testing library for model, view model and related hooks, cypress component
tests for view.

All codes should be written in the tech stack mentioned above.
Requirements should be implemented as react components in the MVVM
architecture pattern.

There are 2 types
of view model in the system.

1. Shared view model. View model that represents states shared among
local and remote users.

2. Local view model. View model that represents states only applicable
to local user

Here are the common implementation strategy:

1. Shared view model is implemented as Redux store slice. Tested in
vitest.

2. Local view model is implemented as React component props or states(by
useState hook), unless for global local view model, which is also
implemented as Redux store slice. Tested in vitest.

3. Hooks are used as the major view helpers to retrieve data from shared
view model. For most the case, it will use ‘createSelector’ and
‘useSelector’ for memorization. Tested in vitest and react testing
library.

4. Don’t dispatch action directly to change the states of shared view
model, use an encapsulated view model interface instead. In the interface,
each redux action is mapped to a method. Tested in vitest.

5. View is consist of konva shapes, and implemented as react component via
react-konva. Tested in cypress component tests 

Here are certain patterns should be followed when implement and test
the component

1. When write test, use `describe` instead of `test`

2. Data-driven tests are preferred.

3. When test the view component, fake view model via the view model
interface

Awareness Layer 

Requirement: 

Display other users’ awareness info(cursor, name and online
information) on the whiteboard. 

AC1: Don’t display local user

AC2: When remote user changes cursor location, display the change in
animation. 

Provide an overall solution following the guidance mentioned above.
Hint, keep all awareness information in a Konva layer, and an awareness
info component to render cursor, and name. Don’t generate code. Describe
the solution, and breaking the solution down as a task list based on the
guidance mentioned above. And we will refer this task list as our master
plan.
</pre>

<p>There&#39;s a lot going on with this prompt, so he highlighted a few
    points.</p>

<p>He&#39;s using a generic application example in here:  one thing to be
    wary of when interacting with ChatGPT and the like is that we should <b>never
    put anything that may be confidential into the prompt</b>, as that would be a
    security risk. Business rules, any code from a real project - all these must
    not enter the interaction with ChatGPT.</p>

<p>Most of the prompt is setting out the design guidelines that he wants
    ChatGPT&#39;s generated code to follow. He refined this by putting prompts into
    ChatGPT, looking at the result, and crafting the prompt to make it generate
    in the style he wanted. Once he has context working, he can paste it into
    every session he has with ChatGPT, and share it with the rest of the
    team.</p>

<div id="xu-chat-p1.png"><p><img src="https://martinfowler.com/articles/2023-chatgpt-xu-hao/xu-chat-p1.png"/></p><p>Xu Hao begins his session by prompting the
    ChatGPT LLM with context as well as the instruction to generate a plan</p>
</div>



<p>Even though the final goal of this session is to generate code and its
    tests, at this stage he specifically said <code>Don’t generate code</code>.
    At this point he wants ChatGPT to outline its approach before we look to any
    code generation. This is a prompt technique called Generated Knowledge.</p>

<p>A common way of interacting with an LLM is to give it a problem and ask
    it to generate some final product, whether than be prose or (in this case)
    code. With <b>Generated Knowledge</b> we split our interaction into separate steps:
    first ask the LLM to generate some useful information about the problem, and
    then we feed that information back into the LLM to generate the final
    product.</p>

<p>The most interesting part of the prompt is the “implementation strategy”
    section which combines two styles of prompt:</p>

<ul>
<li><b>Instruction</b> prompting provides instructions for the LLM to follow</li>

<li><b>Chain of Thought</b> prompting encourages the LLM to explain its
      reasoning.</li>
</ul>

<p>In the Implementation Strategy section, Xu Hao described the desired
    architecture pattern as an expected “Chain of Thought instructions” for
    ChatGPT to follow. Then he instructed ChatGPT to build a task list (the
    generated knowledge) based on this chain of thought.</p>

<div><div><p>Solution:</p><p>To implement the awareness layer feature, we can follow the guidelines mentioned in the problem statement and use the existing tech stack.</p><p>Task List:</p><ol><li><p>Create a new component named &#34;AwarenessInfo&#34; to render cursor and name for remote users.</p></li><li><p>Create a new Konva layer to hold all the &#34;AwarenessInfo&#34; components.</p></li><li><p>Add the Konva layer to the main whiteboard component.</p></li><li><p>Create a new Redux slice to store the awareness information for remote users.</p></li><li><p>Create an encapsulated view model interface for the awareness Redux slice.</p></li><li><p>Implement the &#34;AwarenessInfo&#34; component to retrieve and display the awareness information for each remote user from the view model.</p></li><li><p>Implement a method in the encapsulated view model interface to update the awareness information for each remote user.</p></li><li><p>When a remote user changes the cursor location, dispatch the update method in the encapsulated view model interface to update the corresponding awareness information.</p></li><li><p>In the &#34;AwarenessInfo&#34; component, use the new location to animate the cursor change.</p></li><li><p>Write tests for the new &#34;AwarenessInfo&#34; component, including data-driven tests to ensure it properly displays the awareness information for all remote users.</p></li><li><p>Write tests for the encapsulated view model interface to ensure it properly updates the awareness information for remote users.</p></li><li><p>Write end-to-end Cypress tests to ensure the awareness layer is properly displayed and updated when remote users change their cursor location.</p></li></ol><p>By following these tasks, we can implement the awareness layer feature in the online whiteboard system.</p></div>
</div>

<p>The response from ChatGPT is non-deterministic, so this result is just
    one run. If you (or I) put this prompt in again, we&#39;ll get a different response.</p>

<p>The key element of the response is an ordered task list, with numbers for
    each step. We can use these numbers to refer to these tasks for the rest of
    the session. </p>

<div id="xu-chat-p2.png"><p><img src="https://martinfowler.com/articles/2023-chatgpt-xu-hao/xu-chat-p2.png"/></p><p>The LLM responds with a plan.</p>
</div>



<p>Xu Hao can now look at the master plan and see if it makes sense. If
    there are problems with it, he can ask ChatGPT to re-write some of the tasks
    or the entire master plan by providing more information. </p>

<p>For example, the current master plan was not grouped by different types
    of components. One possible prompt might be: </p>

<pre>Rewrite the master plan, and group tasks as model, view model and view.</pre>

<p>This could be useful to verify the alignment between the architecture
    vision and master plan. </p>

<p>These tweaks could be added to the initial prompt to get an overall
    better response.For this particular prompt, the following instruction was
    not in the initial prompt, but were added in later iteration:</p>

<pre>4. Don’t dispatch action directly to change the states of shared view
    model, use an encapsulated view model interface instead. In the interface,
    each redux action is mapped to a method. Tested in vitest.</pre>

<p>Once the master plan looks reasonable, Xu Hao asks to regenerate it with
    names for the program elements.</p>

<p>Rewrite the master plan, this time with detailed component names,
    methods, and props</p>

<div><div><p>Sure, here&#39;s a revised master plan with detailed component names, methods, and props:</p><p>Task List:</p><ol><li><p>Create a new component named &#34;AwarenessInfo&#34; to render cursor and name for remote users. This component will receive props such as user name, cursor position, and online status.</p></li><li><p>Create a new Konva layer named &#34;AwarenessLayer&#34; to hold all the &#34;AwarenessInfo&#34; components.</p></li><li><p>Add the &#34;AwarenessLayer&#34; to the main whiteboard component.</p></li><li><p>Create a new Redux slice named &#34;awareness&#34; to store the awareness information for remote users.</p></li><li><p>Create an encapsulated view model interface named &#34;AwarenessViewModel&#34; for the &#34;awareness&#34; Redux slice. This interface will contain a method named &#34;updateUserAwarenessInfo&#34; to update the awareness information for each remote user.</p></li><li><p>Implement the &#34;AwarenessInfo&#34; component to retrieve and display the awareness information for each remote user from the view model. The component will use the &#34;useSelector&#34; hook to retrieve the relevant information.</p></li><li><p>Implement the &#34;updateUserAwarenessInfo&#34; method in the &#34;AwarenessViewModel&#34; interface to dispatch a Redux action to update the awareness information for each remote user. This method will be called by the &#34;MainWhiteboard&#34; component.</p></li><li><p>When a remote user changes the cursor location, dispatch the &#34;updateUserAwarenessInfo&#34; method in the &#34;AwarenessViewModel&#34; interface to update the corresponding awareness information.</p></li><li><p>In the &#34;AwarenessInfo&#34; component, use the new location to animate the cursor change. This can be accomplished using the Konva &#34;Tween&#34; animation.</p></li><li><p>Write tests for the new &#34;AwarenessInfo&#34; component, including data-driven tests to ensure it properly displays the awareness information for all remote users. The tests will be written using the React Testing Library.</p></li><li><p>Write tests for the encapsulated view model interface to ensure it properly updates the awareness information for remote users. These tests will use the Vitest framework.</p></li><li><p>Write end-to-end Cypress tests to ensure the awareness layer is properly displayed and updated when remote users change their cursor location. The tests will simulate user interactions with the whiteboard and verify the state of the &#34;AwarenessLayer&#34; and &#34;AwarenessInfo&#34; components.</p></li></ol></div>
</div>

<p>At this point, Xu Hao is ready to ask ChatGPT to provide code for one of
    the steps</p>

<div id="xu-chat-p3.png"><p><img src="https://martinfowler.com/articles/2023-chatgpt-xu-hao/xu-chat-p3.png"/></p>
</div>



<p>provide me example tests and implementation for the awareness slice
    and AwarenessViewModel. Test first.</p>

<pre>Sure, let&#39;s start with writing tests for the awareness slice and AwarenessViewModel:

Test for Awareness Slice:

describe(&#39;awareness slice&#39;, () =&gt; {
  let store: MockStore<rootstate>;
  beforeEach(() =&gt; {
    store = configureMockStore()(initialState);
  });

  it(&#39;should set the cursor location&#39;, () =&gt; {
    store.dispatch(setCursorLocation({ x: 100, y: 200 }));
    const state = store.getState().awareness;
    expect(state.cursorLocation).toEqual({ x: 100, y: 200 });
  });

  it(&#39;should set the name&#39;, () =&gt; {
    store.dispatch(setName(&#39;John Doe&#39;));
    const state = store.getState().awareness;
    expect(state.name).toBe(&#39;John Doe&#39;);
  });

  it(&#39;should set the online status&#39;, () =&gt; {
    store.dispatch(setOnline(true));
    const state = store.getState().awareness;
    expect(state.isOnline).toBe(true);
  });
});
Test for AwarenessViewModel:

describe(&#39;AwarenessViewModel&#39;, () =&gt; {
  let store: MockStore<rootstate>;
  let awarenessViewModel: AwarenessViewModel;
  beforeEach(() =&gt; {
    store = configureMockStore()(initialState);
    awarenessViewModel = new AwarenessViewModel(store);
  });

  it(&#39;should set the cursor location&#39;, () =&gt; {
    awarenessViewModel.setCursorLocation({ x: 100, y: 200 });
    const state = store.getState().awareness;
    expect(state.cursorLocation).toEqual({ x: 100, y: 200 });
  });

  it(&#39;should set the name&#39;, () =&gt; {
    awarenessViewModel.setName(&#39;John Doe&#39;);
    const state = store.getState().awareness;
    expect(state.name).toBe(&#39;John Doe&#39;);
  });

  it(&#39;should set the online status&#39;, () =&gt; {
    awarenessViewModel.setOnline(true);
    const state = store.getState().awareness;
    expect(state.isOnline).toBe(true);
  });
});
Now, let&#39;s implement the Awareness slice and AwarenessViewModel:

Awareness slice:

interface AwarenessState {
  cursorLocation: { x: number; y: number };
  name: string;
  isOnline: boolean;
}

const initialState: AwarenessState = {
  cursorLocation: { x: 0, y: 0 },
  name: &#39;&#39;,
  isOnline: false,
};

const awarenessSlice = createSlice({
  name: &#39;awareness&#39;,
  initialState,
  reducers: {
    setCursorLocation: (state, action: PayloadAction&lt;{ x: number; y: number }&gt;) =&gt; {
      state.cursorLocation = action.payload;
    },
    setName: (state, action: PayloadAction<string>) =&gt; {
      state.name = action.payload;
    },
    setOnline: (state, action: PayloadAction<boolean>) =&gt; {
      state.isOnline = action.payload;
    },
  },
});

export const { setCursorLocation, setName, setOnline } = awarenessSlice.actions;

export default awarenessSlice.reducer;
AwarenessViewModel:

class AwarenessViewModel {
  private store: Store<rootstate>;

  constructor(store: Store<rootstate>) {
    this.store = store;
  }

  setCursorLocation(cursorLocation: { x: number; y: number }) {
    this.store.dispatch(setCursorLocation(cursorLocation));
  }

  setName(name: string) {
    this.store.dispatch(setName(name));
  }

  setOnline(isOnline: boolean) {
    this.store.dispatch(setOnline(isOnline));
  }
}

Note: In this implementation, I assumed that the AwarenessViewModel is used to
set the values in the store. If it is also used to retrieve the values from the
store, we can add corresponding methods to the AwarenessViewModel class
</rootstate></rootstate></boolean></string></rootstate></rootstate></pre>

<p>(I&#39;ve removed the styling from ChatGPT&#39;s response.)</p>

<div id="xu-chat-final.png"><p><img src="https://martinfowler.com/articles/2023-chatgpt-xu-hao/xu-chat-final.png"/></p>
</div>



<p>Overall this code is neither bad nor perfect. It won&#39;t run as it stands.
    It&#39;s missing a <code>configureMockStore</code> and assumes it uses
    redux-mock-store, which isn&#39;t part of the tech stack. Xu Hao can fix these
    problems by asking the LLM to progressively tweak the code through a
    sequence of rewrites. Here&#39;s one to get rig of redux-mock-store.</p>

<p>rewrite the tests without redux-mock-store</p>

<div><div><p>Sure, here&#39;s an example implementation of the tests for the AwarenessViewModel and the awareness slice without using <code>redux-mock-store</code>:</p><pre><div><p><span>typescript</span></p><p><code><span>import</span> { createAwarenessSlice, <span>AwarenessState</span>, updateAwareness } <span>from</span> <span>&#39;./awarenessSlice&#39;</span>;
<span>import</span> { <span>AwarenessViewModel</span> } <span>from</span> <span>&#39;./AwarenessViewModel&#39;</span>;

<span>describe</span>(<span>&#39;AwarenessViewModel&#39;</span>, <span>() =&gt;</span> {
  <span>const</span> mockDispatch = jest.<span>fn</span>();
  <span>const</span> <span>initialState</span>: <span>AwarenessState</span> = {
    <span>users</span>: {
      <span>&#39;user1&#39;</span>: {
        <span>name</span>: <span>&#39;User 1&#39;</span>,
        <span>cursorPosition</span>: { <span>x</span>: <span>0</span>, <span>y</span>: <span>0</span> },
        <span>online</span>: <span>true</span>,
      },
      <span>&#39;user2&#39;</span>: {
        <span>name</span>: <span>&#39;User 2&#39;</span>,
        <span>cursorPosition</span>: { <span>x</span>: <span>100</span>, <span>y</span>: <span>100</span> },
        <span>online</span>: <span>true</span>,
      },
    },
  };
  <span>let</span> <span>viewModel</span>: <span>AwarenessViewModel</span>;

  <span>beforeEach</span>(<span>() =&gt;</span> {
    viewModel = <span>new</span> <span>AwarenessViewModel</span>(initialState, mockDispatch);
  });

  <span>describe</span>(<span>&#39;getUserNames&#39;</span>, <span>() =&gt;</span> {
    <span>it</span>(<span>&#39;returns the list of user names&#39;</span>, <span>() =&gt;</span> {
      <span>const</span> names = viewModel.<span>getUserNames</span>();
      <span>expect</span>(names).<span>toEqual</span>([<span>&#39;User 1&#39;</span>, <span>&#39;User 2&#39;</span>]);
    });
  });

  <span>describe</span>(<span>&#39;getCursorPosition&#39;</span>, <span>() =&gt;</span> {
    <span>it</span>(<span>&#39;returns the cursor position for a given user ID&#39;</span>, <span>() =&gt;</span> {
      <span>const</span> cursorPosition = viewModel.<span>getCursorPosition</span>(<span>&#39;user1&#39;</span>);
      <span>expect</span>(cursorPosition).<span>toEqual</span>({ <span>x</span>: <span>0</span>, <span>y</span>: <span>0</span> });
    });

    <span>it</span>(<span>&#39;returns undefined for an unknown user ID&#39;</span>, <span>() =&gt;</span> {
      <span>const</span> cursorPosition = viewModel.<span>getCursorPosition</span>(<span>&#39;unknown&#39;</span>);
      <span>expect</span>(cursorPosition).<span>toBeUndefined</span>();
    });
  });

  <span>describe</span>(<span>&#39;updateCursorPosition&#39;</span>, <span>() =&gt;</span> {
    <span>it</span>(<span>&#39;dispatches the updateAwareness action with the new cursor position&#39;</span>, <span>() =&gt;</span> {
      viewModel.<span>updateCursorPosition</span>(<span>&#39;user1&#39;</span>, { <span>x</span>: <span>50</span>, <span>y</span>: <span>50</span> });
      <span>expect</span>(mockDispatch).<span>toHaveBeenCalledWith</span>(<span>updateAwareness</span>({
        <span>user</span>: <span>&#39;user1&#39;</span>,
        <span>cursorPosition</span>: { <span>x</span>: <span>50</span>, <span>y</span>: <span>50</span> },
      }));
    });
  });
});
</code></p></div></pre><p>And here&#39;s an example implementation of the <code>awarenessSlice</code> without using <code>redux-mock-store</code>:</p><pre><div><p><span>typescript</span></p><p><code><span>import</span> { createSlice, <span>PayloadAction</span> } <span>from</span> <span>&#39;@reduxjs/toolkit&#39;</span>;

<span>export</span> <span>type</span> <span>CursorPosition</span> = { <span>x</span>: <span>number</span>, <span>y</span>: <span>number</span> };

<span>export</span> <span>type</span> <span>UserAwareness</span> = {
  <span>name</span>: <span>string</span>;
  <span>cursorPosition</span>: <span>CursorPosition</span>;
  <span>online</span>: <span>boolean</span>;
};

<span>export</span> <span>type</span> <span>AwarenessState</span> = {
  <span>users</span>: <span>Record</span>&lt;<span>string</span>, <span>UserAwareness</span>&gt;;
};

<span>const</span> <span>initialState</span>: <span>AwarenessState</span> = {
  <span>users</span>: {},
};

<span>const</span> awarenessSlice = <span>createSlice</span>({
  <span>name</span>: <span>&#39;awareness&#39;</span>,
  initialState,
  <span>reducers</span>: {
    <span>updateAwareness</span>: <span>(<span>state, action: PayloadAction&lt;{ user: <span>string</span>, cursorPosition: CursorPosition }&gt;</span>) =&gt;</span> {
      <span>const</span> { user, cursorPosition } = action.<span>payload</span>;
      state.<span>users</span>[user].<span>cursorPosition</span> = cursorPosition;
    },
    <span>setOnline</span>: <span>(<span>state, action: PayloadAction&lt;{ user: <span>string</span>, online: <span>boolean</span> }&gt;</span>) =&gt;</span> {
      <span>const</span> { user, online } = action.<span>payload</span>;
      state.<span>users</span>[user].<span>online</span> = online;
    },
  },
});

<span>export</span> <span>const</span> { updateAwareness, setOnline } = awarenessSlice.<span>actions</span>;
<span>export</span> <span>const</span> awarenessReducer = awarenessSlice.<span>reducer</span>;
</code></p></div></pre><p>Note that since we&#39;re not using <code>redux-mock-store</code>, we need to pass a mock dispatch function to the view model constructor, and in the test for <code>updateCursorPosition</code> we need to check that the correct action was dispatched using <code>jest.fn()</code>.</p></div>
</div>

<p>Further rewrites can fit in more adjustments, such as asking it to
    <code>Use `configureTestingStore(‘awareness’, initialState)` to initialize
    the test store</code> can get it to fit in with the team&#39;s test idioms. Then
    with some path adjustments and a small amount of glue for the reducers, the
    code can run just fine.</p>

<p>Once this is working, Xu Hao can repeat the process for the rest of the
    tasks in the master plan.</p>

<section>
<p> My take away from this discussion was that using chain of thought and
      generated knowledge prompting approaches can be a significantly useful tool
      for programming. In particular it shows that to use LLMs well, we need to
      learn how to construct prompts to get the best results. This experience
      suggests that it&#39;s useful to interact with the LLM like a junior partner,
      starting them with architectural guidelines, asking them to show their
      reasoning, and tweaking their outputs as we go.</p>
</section>

<hr/>
</div></div>
  </body>
</html>
