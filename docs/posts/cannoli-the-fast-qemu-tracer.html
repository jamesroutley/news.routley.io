<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://margin.re/blog/cannoli-the-fast-qemu-tracer.aspx">Original</a>
    <h1>Cannoli: The Fast QEMU Tracer</h1>
    
    <div id="readability-page-1" class="page"><div id="content">



<section id="home">
<div>
<div>

<article id="text">
<h2>Cannoli: The Fast QEMU Tracer</h2>
<div>
<p><time><i aria-hidden="true"></i> May 26, 2022</time>

<span><i aria-hidden="true"></i> Posted in: </span>
</p></div>

<p><img alt="" src="https://margin.re/attachments/logo.png"/>Cannoli is a high-performance tracing engine for qemu-user. It can record a trace of both PCs executed as well as memory operations. It consists of a small patch to QEMU to expose locations to inject some code directly into the JIT, a shared library which is loaded into QEMU to decide what and how to instrument, and a final library which consumes the stream produced by QEMU in another process, where analysis can be done on the trace.</p>
<p>Cannoli is designed to record this information with minimum interference of QEMU&#39;s execution. In practice, this means that QEMU needs to produce a stream of events, and hand them off (very quickly) to another process to handle more complex analysis of them. Doing the analysis during execution of the QEMU JIT itself would dramatically slow down execution.</p>
<p>Cannoli can handle billions of target instructions per second, can handle multi-threaded qemu-user applications, and allows multiple threads to consume the data from a single QEMU thread to parallelize processing of traces.</p>
<p>Check out the code here!</p>

<p>When working with program analysis, we often find ourselves scratching our heads at the best way to get information about program execution. There&#39;s the standard way of just... attaching a debugger, there&#39;s using dynamic instrumentation like PIN, using some fancy features like Intel PT, or just throwing it in an emulator. Unfortunately, many of these solutions have some pretty expensive performance costs, or in the case of something like Intel PT, only work on x86.</p>
<p>One of the big problems of tracing is simply performance. Many simple solutions like using Unicorn for emulation can lead to getting only a million or so emulated instructions per second. This may sound like a lot, but a modern x86 processor will often do 2 instructions per cycle. If you&#39;re running on a 4 GHz processor, something that takes 1 second to run or start, often is executing well into the 5-10 billion instructions territory. Simply put, tracing something like this at even 10 million instructions per second is prohibitively slow for any development or research cycle.</p>
<p>Just trying to get a full log of addresses of instructions executed (what we&#39;ll call PC&#39;s), often is a challenge enough, let alone when you want to log all memory accesses as well. It turns out, this is a relatively hard problem, and we&#39;ve taken a swing at it.</p>
<p>That leads us to Cannoli! A high-performance tracing engine for qemu-user. Designed explicitly to minimize overhead of recording full traces of both code flow (all PCs executed), as well as memory operations (address, size, value, and information about if it&#39;s a read or a write).</p>
<p>Cannoli is capable of performing full-tracing of QEMU with about a 20-80% slowdown over base QEMU execution. This means that it&#39;s possible to get about 1 billion target instructions/second of traces. This varies a lot by your CPU clock rate, system noise, etc. We&#39;ll get into the details of performance later on as there is a lot of nuance. Ultimately something around 500M-1B target instructions/second is likely achievable with full tracing of both PCs and memory operations, which is pretty good!</p>
<p>Cannoli has been super carefully designed and can stream over <em>20 GiB/second </em>of data from a single QEMU thread to the multi-threaded trace analysis process. For those more familiar with networking, Cannoli is generating and IPCing about 180Gbps of data from a <em>single </em>producer thread!</p>
<h3>Demo</h3>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/dYyjc2qqG8I" title="YouTube video player" width="560"></iframe></p>
<hr/>

<p>To start off, we should cover what you should expect as an end-user.</p>
<h2>QEMU Patches</h2>
<p>As a user you will have to apply a small patch set to QEMU, consisting of about 200 lines of additions. These are all gated with <code>#ifdef CANNOLI</code>, such that if <code>CANNOLI</code> is not defined, QEMU builds identically to having none of the patches in the first place.</p>
<p>The patches aren&#39;t too relevant to the user, other than understanding that they add a <code>-cannoli</code> flag to QEMU which expects a path to a shared library. This shared library is loaded into QEMU and is invoked at various points of the JIT.</p>
<p>To apply the patches, simply run something like:</p>
<pre><code>git am qemu_patches.patch</code></pre>
<h2>Cannoli Server</h2>
<p>The shared library which is loaded into QEMU is called the Cannoli server. This library exposes two basic callbacks in <code>cannoli_server/src/lib.rs</code>.</p>
<pre><code>/// Called before an instruction is lifted in QEMU. If this function returns
/// `true`, then the instrumentation is added and this PC will generate logs
/// in the traces.
///
/// This may be called from multiple threads
fn hook_inst(_pc: u64) -&gt; bool {
    true
}

/// Called when a memory access is being lifted in QEMU. Returning `true` will
/// cause the memory access to events in the trace buffer.
///
/// This may be called from multiple threads
fn hook_mem(_pc: u64, _write: bool, _size: usize) -&gt; bool {
    true
}</code></pre>
<p>These hooks provide an opportunity for a user to decide whether or not a given instruction or memory access should be hooked. Returning <code>true</code> (the default) results in instrumenting the instruction. Returning <code>false</code> means that no instrumentation is added to the JIT, and thus, QEMU runs with full speed emulation.</p>
<p>This API is invoked when QEMU lifts target instructions. Lifting in this case, is the core operation of an emulator, where it disassembles a target instruction, and transforms it into an IL or JITs it to another architecture for execution. Since QEMU caches instructions it has already lifted, these functions are called &#34;rarely&#34; (with respect to how often the instructions themselves execute), and thus this is the location where you should put in your smart logic to filter what you hook.</p>
<p>If you hook a select few instructions, the performance overhead of this tool is effectively zero. Cannoli is designed to provide very low overhead for full tracing, however if you don&#39;t need full tracing you should filter at this stage. This prevents the JIT from being instrumented in the first place, and provides a filtering mechanism for an end-user.</p>
<h2>Cannoli Client</h2>
<p>Cannoli then has a client component. The client&#39;s goal is to process the massive stream of data being produced by QEMU. Further, the API for Cannoli has been designed with threading in mind, such that a single thread can be running inside qemu-user, and complex analysis of that stream can be done by threading the analysis while getting maximum single-core performance in QEMU itself.</p>
<p>Cannoli exposes a standard Rust trait-style interface, where you implement <code>Cannoli</code> on your structure. As an implementer of this trait, you must implement <code>init</code>. This is where you create a structure for both a single-threaded mutable context, <code>Self</code>, as well as a multi-threaded shared immutable context <code>Self::Context</code>.</p>
<p>You then optionally can implement the following callbacks:</p>
<pre><code>fn exec(_ctxt: &amp;Self::Context, _pc: u64) -&gt; Option&lt;Self::Trace&gt;;
fn read(_ctxt: &amp;Self::Context, _pc: u64, _addr: u64, _val: u64)
    -&gt; Option&lt;Self::Trace&gt;;
fn write(_ctxt: &amp;Self::Context, _pc: u64, _addr: u64, _val: u64);
    -&gt; Option&lt;Self::Trace&gt;;
fn trace(&amp;mut self, _ctxt: &amp;Self::Context, _trace: &amp;[Self::Trace])</code></pre>
<p>These callbacks are relatively self-explanatory, with the exception of the threading aspects. The three main execution callbacks <code>exec</code>, <code>read</code>, and  <code>write</code> can be called from multiple threads in parallel. Thus, these are not called sequentially. This is where stateless processing should be done. These also only have immutable access to the <code>Self::Context</code>, as they run in parallel. This is the correct location to do any processing which does not need to know the ordering/sequence of instructions or memory accesses. For example, applying symbols where you convert from a <code>pc</code> into a <code>symbol + address</code> should be done here, such that you can symbolize the trace in parallel.</p>
<p>All of the main callbacks, <code>exec</code>, <code>read</code>, and <code>write</code>, return an <code>Option&lt;Self::Trace&gt;</code> type. This is a user-defined type which should be thought of as a form of a <code>filter_map</code>. If you return <code>None</code>, the event is not placed into the trace, if you return <code>Some(your_value)</code> then <code>your_value</code> will be placed sequentially into a trace buffer.</p>
<p>This trace is then exposed back to the user fully in-order via the <code>trace</code> callback. The <code>trace</code> callback is called from various threads (eg. you might run in a different TID), however, is it ensured to always be called sequentially and in-order with respect to execution. Due to this, you get mutable access to <code>self</code>, as well as a reference to the shared <code>Self::Context</code>.</p>
<p>I know this is a weird API, but it effectively allows parallelism of processing of the trace until you absolutely need it to be sequential. I hope it&#39;s not too confusing for end users, but processing 1 billion instructions/second of data kind of requires threading on the consumer side, otherwise you bottleneck QEMU!</p>
<hr/>

<p><em>Note: Unless otherwise noted, performance numbers here are on my Intel(R) Xeon(R) Silver 4310 CPU @ 2.10GHz. Hyperthreading enabled, turbo enabled, 128 GiB RAM @ 2667 MHz w/ 8 memory channels</em></p>
<p>At a high level, the entire design revolved around a producer of massive amounts of data (a QEMU thread running in the JIT). For Cannoli we are optimizing specifically for QEMU single-threaded throughput of QEMU such that we can get introspection into long-running or big processes, like a web browser.</p>
<p>This is different from scaling, where you don&#39;t really care about the performance of an individual thread, rather the system as a whole. In our case, we want to support streaming billions of instructions per second from a single QEMU thread, while doing relatively complex analysis of that data with threaded consumers.</p>
<h2>Basic Benchmark</h2>
<p>Included you’ll find a benchmark in examples/benchmark which runs a small mipsel binary that just executes a bunch of nops in a loop. This is meant to benchmark the performance of the PC tracing.</p>
<p>To use this benchmark, spin up the benchmark client:</p>
<pre><code>cd examples/benchmark &amp;&amp; cargo run --release</code></pre>
<p>And then run the benchmark with a cannoli&#39;d QEMU!</p>
<pre><code>/home/pleb/qemu/build/qemu-mipsel -cannoli ~/cannoli/target/release/libcannoli_server.so ./benchmark</code></pre>
<p>In my case, on my 2.1 GHz CPU (read: very low clock rate compared to most desktops), I get the following (in my case I used benchmark_graph ).</p>
<p><img alt="Image showing Cannoli perf graph" src="https://margin.re/attachments/perf_graph.png"/></p>
<p>About 2.2 billion instructions per second of tracing on a single QEMU thread!</p>
<h2>Mempipe</h2>
<p>Getting this level of tracing with a low-performance overhead required some pretty interesting engineering. At the core of Cannoli is a library called mempipe. At a high-level, this is an extremely low-latency shared-memory IPC mechanism.</p>
<p>On top of this, the design for the JIT hooks has been to decrease overhead as much as possible, with careful attention to details like branch prediction, code size (for reducing icache pollution), and being aware of the target architectures bitness to reduce the amount of data produced when running 32-bit targets.</p>
<p>In fact, you&#39;ll find that pretty much all of the APIs, but the top-level <code>Cannoli</code> trait, leverage Rust macros to define two copies of the same code, one for 32-bit targets, and one for 64-bit targets. This slightly increases the code complexity, but when we&#39;re saturating memory bandwidth, we want to special case that 32-bit targets have effectively 1/2 of the data being produced due to</p>
<p>The core mempipe IPC mechanism allows for transferring buffers between processes that fit inside of L1 cache. Since these buffers are so small, the frequency of IPC packets is extremely high. For networking people, this is effectively a high requirement for packets-per-second. In my case, I can do about 10 million transfers per second of a 1-byte payload. This is with one producer thread and one consumer thread. This is effectively saturating what the Intel silicon can do for cache-coherency traffic.</p>
<h2>Cache Coherency</h2>
<p>If you&#39;re not familiar with cache coherency, it&#39;s what your processor does to make sure memory is observed to be the same value on all processors, even if it&#39;s stored in multiple caches.</p>
<p>The simple model is the MESI model. This defines the state each cache line can be in. MESI stands for.</p>
<ul>
<li><em>Modified </em>- Data stored in a cache line is &#34;dirty&#34;, and is the only accurate copy of memory</li>
<li><em>Exclusive </em>- Data stored in a cache line is clean (same data in the cache line as well as memory), and this is the only copy of the memory in a cache line on the system</li>
<li><em>Shared </em>- Data stored in a cache line is clean, and there are multiple different caches on the system which are storing this same information</li>
<li><em>Invalid </em>- Doesn&#39;t mean anything to us at the software level, it just means the cache line is unused (and thus free for using)</li>
</ul>
<p><img alt="Image of MESI" src="https://margin.re/attachments/mesi.png"/></p>
<p>Now, modern processors use a slightly more complicated cache coherency model, but we won&#39;t go into that here. At its core, it&#39;s the same.</p>
<p>What&#39;s important to note is that any time cores have to sync their caches, they have to hit L2 cache (some exceptions, won&#39;t cover that here), and sometimes even memory.</p>
<p>If you think about it like the Rust memory-safety model, modified is a dirty <code>&amp;mut self</code>, exclusive is an unchanged <code>&amp;mut self</code>, and shared is a <code>&amp;self</code>. The costs to switch between these cache line states is <em>not cheap</em>.</p>
<p>More specifically, going to the <code>modified</code> state is an expensive transition. Think about it, to get exclusive access to memory you effectively have to do a lock to get control. In a hardware point of view, you have to tell every other core to invalidate its cache for a given line, and you can&#39;t take ownership until the other cores have done as such. This is effectively like doing a <code>Mutex::lock()</code>.</p>
<p>Going from exclusive to modified is cheap, however. It&#39;s the whole point of the exclusive MESI state. It allows the processor to know it doesn&#39;t have to notify other cores when transitioning to modified, as it&#39;s already known to be the only copy of the memory.</p>
<p>Why are we talking about this? Well, when doing IPC, cache coherency matters a lot. It&#39;s critical that in our hot loops we are not causing cache coherency traffic. At a high level, this means that we need to be able to hot poll all our data structures by reading only. This allows multiple consumer threads to be polling the mailboxes (eg. all of the consumers are polling a cache line that is in the shared state). We only want to pay the cache-coherency cost of writing to memory when the producer has produced a full buffer. The act of the producer flushing a buffer will cause <em>all</em> consumer cores to have their caches invalidated, and they&#39;ll have to fetch the memory through L2 on the subsequent access. This fetch has to drop the producer&#39;s cache state from modified to shared as well.</p>
<p>Thus, we&#39;ve designed the <code>mempipe</code> library to poll a set of mailboxes which is guaranteed to be on a different cache line from the data being transferred. If we had the transfer buffer on the same cache line as the mailboxes then there would be major cache thrashing!</p>
<hr/>

<p><img alt="Cannoli Diagram" src="https://margin.re/attachments/cannoli_diagram.png"/></p>
<h2>Mempipe</h2>
<p>Mempipe is the super-fast IPC mechanism that really enables Cannoli to work in the first place. It provides a low-latency API for transferring buffers from one process to another via <code>shm*()</code> APIs on Linux. Specifically, it is a polling-based IPC mechanism, meaning the consumer is hot-polling a mailbox until new data arrives.</p>
<p>You can find all the code in <code>mempipe/src/lib.rs</code>. At its core it exposes two structures, a <code>SendPipe</code> and a <code>RecvPipe</code>.</p>
<h3>Const Generics</h3>
<p>Both <code>SendPipe</code> and <code>RecvPipe</code> use two constant generics. These are the <code>CHUNK_SIZE</code> and <code>NUM_BUFFERS</code> generics. <code>CHUNK_SIZE</code> defines the size of each buffer in bytes. The smaller this chunk size, the more transfers have to happen, but the more data you fit into caches. This is effectively the size of the buffer which will be filled up with data, and flushed to the consumer when it&#39;s full.</p>
<p>The <code>NUM_BUFFERS</code> generic specifies the number of buffers in the memory pipe. Effectively, this is what enables non-blocking streaming of data from QEMU. A consumer can be processing a buffer while QEMU is producing data to another buffer. Setting this to greater than one is recommended, otherwise QEMU will block while the buffer is processed... but don&#39;t set it too high; that just increases the amount of memory that might be used for streaming, causing more cache thrashing.</p>
<p>Both of these generics are tunables and <em>dramatically</em> affect performance. Personally, I&#39;ve found that setting the <code>CHUNK_SIZE</code> to 1/2 that of L1 cache (16 KiB on most x86 systems), and <code>NUM_BUFFERS</code> to 4 seems to be a good metric.</p>
<h3>Pipe Creation</h3>
<p>Creating a <code>SendPipe</code> is simple. You call <code>SendPipe::create()</code> and it returns back a <code>SendPipe</code>. Internally, it generates a random 64-bit number which is used as the pipe identifier. It then creates a shared memory file with this pipe ID as the filename, sets the length of the shared memory, and maps it in as read-writable. We also place a small header into shared memory so we can make sure when we connect to the pipe it matches the parameters we expect.</p>
<h3>Pipe Opening</h3>
<p>Creating a <code>RecvPipe</code> is also simple, just call <code>RecvPipe::open()</code> with the UID assigned to the <code>SendPipe</code> (obtainable from <code>SendPipe::uid()</code>). This will open the shared memory with the provided UID, Then, make sure the constant generics of the <code>RecvPipe</code> match those of the <code>SendPipe</code> (included in the metadata of the shared memory), and finally it will map the memory and return back the pipe.</p>
<h3>Data Production</h3>
<p>To produce data from the <code>SendPipe</code>, you call <code>SendPipe::alloc_buffer</code>. This gives the user a write-only <code>ChunkWriter</code> which can be written with <code>ChunkWriter::send</code>. Calling <code>alloc_buffer</code> will block in a hot-loop until a buffer is available. It is important that a consumer is consuming the data as fast as possible to prevent the sender from stalling too long. With the right tunables, the consumer should always be ahead of the producer, and thus <code>alloc_buffer</code> should effectively return immediately.</p>
<p>When a buffer is obtained via <code>alloc_buffer</code>, it is guaranteed to be owned by the sending process, and thus we can safely write to it mutably. The memory is uninitialized, but that&#39;s okay because <code>ChunkWriter</code> only provides write access, and thus reading the uninitialized memory is impossible.</p>
<h3>Data Consumption</h3>
<p>Okay, as of this writing I&#39;m not super happy with the final design for consuming data. First, you request a ticket from <code>RecvPipe::request_ticket</code>. This effectively lets the pipe know that you are interested in data, and gets you a unique ID of the data you will process. You then call <code>RecvPipe::try_recv</code> which consumes the ticket, and will return back either a new ticket (if data was processed), or the old ticket (if the recv didn&#39;t have any data). <code>try_recv</code> is non-blocking. If no data is present, it immediately returns.</p> 
<p>The ticket model is a bit strange, but it allows us to round-robin assign consumer threads to buffers. This distributes the load of processing as evenly as possible among the processing threads. It also is important as it determines the sequencing of the data being processed, which is important for our tracing requirements of being well-ordered.</p>
<p>I&#39;d like to find an improvement to this API, but I just haven&#39;t bothered yet, largely because it works fine and is super fast.</p>
<h2>QEMU Patches</h2>
<p>Included with Cannoli are a few patches to QEMU. You&#39;ll find these in the repo in the file <code>qemu_patches.patch</code>. These are currently patches for latest QEMU <code>eec398119fc6911d99412c37af06a6bc27871f85</code> as of this writing), however they are designed to be pretty portable between QEMU versions.</p>
<p>The patches introduce about ~200 lines of code into QEMU.</p>
<h3>QEMU Hooks</h3>
<p>When the <code>-cannoli</code> command line argument is passed into QEMU, it triggers a <code>dlopen()</code> of the Cannoli shared library. It then gets the address of the Cannoli entry point (called <code>query_version32</code> or <code>query_version64</code>). The 32 or 64-bit suffix is not referring to the bitness of the shared library itself (everything currently only supports x86_64 as a host/JIT target), however it refers to the bitness of the target being emulated. All the hooks have been designed to work with 32-bit and 64-bit targets differently, as this decreases the size of the data stream, and thus, maximizes performance when a 32-bit target is being emulated.</p>
<p>Calling <code>query_versionX</code> returns a reference to a <code>Cannoli</code> structure which defines various callbacks which QEMU will dispatch to upon certain events.</p>
<h4>Register reservation</h4>
<p>Since we will be producing data on nearly every single target instruction, we actually want to store a small amount of metadata about the trace buffer and length in registers. Doing this in memory would be quite expensive as it would cause multiple memory accesses to occur for every target instruction.</p>
<p>Thus, we patch the <code>tcg_target_reg_alloc_order</code> to remove the x86_64 registers <code>r12</code>, <code>r13</code>, and <code>r14</code> from use with the QEMU register scheduler. This prevents QEMU from using them for its JIT, and thus gives us exclusive control of these registers during execution inside the JIT. These registers were picked as they are callee-saved registers based on the SYS-V ABI. This is important as QEMU can call into C functions inside the JIT, and we want to make sure our registers are preserved when these calls occur.</p>
<h4>JIT entry and exit</h4>
<p>Since we reserve control over a few registers, we need to make sure those registers are correctly set and preserved across QEMU JIT entries and exits. JIT entries and exits are the boundaries where QEMU transitions from running the QEMU C code, to running the generated JIT code, and back to exiting to QEMU again. These entries and exits are defined for each JIT-target-architecture in the <code>tcg_target_qemu_prologue()</code> function. This effectively sets up context, calls into the JIT, and restores context. For someone familiar with OS-development, this is effectively a context switch.</p>
<p>In our case, the <code>$entry</code> function (<code>cannoli/cannoli_server/src/cannoli_internals.rs</code>) allocates a buffer from <code>mempipe</code>, sets a pointer to it in <code>r12</code>, sets a pointer to the end of it in <code>r13</code>, and returns back. This establishes the state for <code>r12</code> and <code>r13</code> through the execution of the JIT.</p>
<p>The <code>$exit</code> function determines the number of bytes produced by the JIT (as indicated by the current pointer in <code>r12</code>, which has advanced), and sends the data over IPC to the consumer!</p>
<h4>Loads and stores</h4>
<p>For loads and stores we hooked <code>tcg_out_qemu_ld()</code> and <code>tcg_out_qemu_st()</code>. These are x86_64-JIT-target-specific functions and they provide catch-all sinks for memory operations to the guest address space for their respective loads and stores.</p>
<h4>Instruction execution</h4>
<p>For instruction execution we hook <code>tcg_gen_code()</code>, and specifically, the <code>INDEX_op_insnstart()</code> QEMU TCG instruction which denotes the address of the instruction starting execution.</p>
<h4>JIT shellcode injection</h4>
<p>Both the memory and instruction hooks do the same thing. They invoke a callback in our Rust code which is passed a QEMU-provided buffer and length. This callback then can fill the QEMU-provided buffer with shellcode which is emit directly into the JIT stream. This provides our Rust library with the ability to inject arbitrary code into the JIT stream. If you&#39;re a power-user, you can do really cool things with this, by providing different hooks for different instructions.</p>
<h3>Cannoli Server</h3>
<p>The Cannoli server (SO loaded into QEMU with hooks) has a few hooks already pre-defined. These are the instruction and memory operation hooks.</p>
<p>The entire flow of Cannoli (in its default configuration) is to allocate an IPC buffer on JIT entry, fill it in during the JIT, flush it if it fills up, and also flush it on JIT exits.</p>
<p>The default instruction and memory hooks do the minimal amount of assembly needed to make sure there&#39;s enough space left in the trace buffer, flushing it (by calling back into Rust if it&#39;s full, it&#39;s okay to call into Rust here as these events happen &#34;rarely&#34;, eg. every few thousand target instructions), and finally storing the memory or instruction execution instruction into the trace in a relatively simple format.</p>
<p>The Cannoli server shared object contains two copies of all the hooks and code, such that the same shared object can be used with both 32-bit and 64-bit targets, without recompiling!</p>
<p>I&#39;m not going to go into crazy details of all the hooks here, they&#39;re fairly well commented.</p>
<p>TL;DR:</p>
<pre><code>cannoli_insthook\bits:
    ; r12 - Pointer to trace buffer
    ; r13 - Pointer to end of trace buffer
    ; r14 - Scratch

    ; Allocate room in the buffer
    lea r14, [r12 + \width + 1]

    ; Make sure we didn&#39;t run out of buffer space
    cmp r14, r13
    jbe 2f

    ; We&#39;re out of space! This happens &#34;rarely&#34;, only when the buffer is full,
    ; so we can do much more complex work here. We can also save and restore
    ; some registers.
    ;
    ; We directly call into our Rust to reduce the icache pollution and to get
    ; some code sharing for the much more complex flushing operation
    ;
    ; Flushing gets us a new r12, r13, and r14
    mov  r13, {REPLACE_WITH_FLUSH}
    call r13

2:
.if \bits == 32
    ; Opcode
    mov byte ptr [r12], 0x00

    ; PC, directly put into memory from an immediate
    mov dword ptr [r12 + 1], {REPLACE_WITH_PC}
.elseif \bits == 64
    ; Opcode
    mov byte ptr [r12], 0x80

    ; Move PC into a register so we can use imm64 encoding
    mov r14, {REPLACE_WITH_PC}
    mov qword ptr [r12 + 1], r14
.else
.error &#34;Invalid bitness passed to create_insthook&#34;
.endif

    ; Advance buffer
    add r12, \width + 1</code></pre>
<pre><code>cannoli_memhook_\access\()_\data\()_\addr\():
    ; r12 - Pointer to trace buffer
    ; r13 - Pointer to end of trace buffer
    ; r14 - For reads, this always holds the address, for writes, it&#39;s scratch

    ; Allocate room in the buffer (we have to preserve r14 here)
    lea r12, [r12 + (\width * 2 + \datawidth + 1)]
    cmp r12, r13
    lea r12, [r12 - (\width * 2 + \datawidth + 1)]
    jbe 2f

    ; We&#39;re out of space! This happens &#34;rarely&#34;, only when the buffer is full,
    ; so we can do much more complex work here. We can also save and restore
    ; some registers.
    ;
    ; We directly call into our Rust to reduce the icache pollution and to get
    ; some code sharing for the much more complex flushing operation
    ;
    ; Flushing gets us a new r12, r13, and r14
    mov  r13, {REPLACE_WITH_FLUSH}
    call r13

2:
.ifc \access, read
    ; Read opcode
    mov byte ptr [r12], (((\width / 4) - 1) &lt;&lt; 7) | 0x10 | \datawidth
.endif
.ifc \access, write
    ; Write opcode
    mov byte ptr [r12], (((\width / 4) - 1) &lt;&lt; 7) | 0x20 | \datawidth
.endif

    ; Address and data
.if \width == 4
    mov dword ptr [r12 + (\width * 0 + 1)], {REPLACE_WITH_PC}
.elseif \width == 8
    mov r14, {REPLACE_WITH_PC}
    mov [r12 + \width * 0 + 1], r14
.endif
    mov [r12 + \width * 1 + 1], \addr
    mov [r12 + \width * 2 + 1], \data

    ; Advance buffer
    add r12, \width * 2 + \datawidth + 1</code></pre>
<p>These hooks write directly into the buffer provided from <code>mempipe</code>, and it&#39;s really that simple! Anything more complex would have hurt performance too much!</p>
<h3>Cannoli</h3>
<p>Finally, Cannoli itself is the consumer library which revolves around a trait that you implement in Rust.</p>
<p>Since we&#39;re working with potentially billions of instructions per second, we&#39;ve designed all of Cannoli to work with threads. This allows you to do relatively complex consuming and processing of traces on multiple threads, while not affecting the QEMU single-threaded task.</p>
<p>This is pretty straight forward. Cannoli creates the number of threads requested, and spins on those threads waiting for data. With the mempipe ticket system, each thread waits for their turn in line for their data to come in. When the buffer comes up with their ticket number, that thread processes the data from QEMU. This happens in parallel, threads will pick up data when they</p>
<p>Since processing in parallel means that the trace is no longer in-order, we allow the user to return their own structure for each event, which is then returned back to them at a later point after it has been sequenced. This allows a user to do threaded processing until the very point where they require ordering (eg. execution flow is being followed rather than just caring about raw PC events).</p>

<p>Transferring data from one process to another as fast as possible is a really hard problem. Minute details about the processor, such as cache coherency, is critical to getting high-throughput, especially when you want to prevent blocking of the producer thread as much as possible.</p>
<p>I hope you&#39;ve enjoyed this little write up Cannoli, and find some creative uses for the code.</p>
<h2>Future</h2>
<p>I have some crude hooks that allow for logging of registers when an instruction is hit (eg. to get the register state on <code>malloc()</code> and <code>free()</code>) however that&#39;s not quite solidified. Mainly because it requires per-target-architecture hooks in QEMU and requires a consumer to be aware of how many target registers the architecture has. It&#39;d be easy to add in, but kinda hard to do well IMO.</p>
<p>For code coverage I often do self-modifying JITs where the code &#34;patches itself out&#34; once it has been hit once. I&#39;d love to support this as an option, where upon requesting a hook of an instruction, you can also request it to be a one-shot hook. This would allow for cheap hooks that converge to almost zero-cost, for things where you just want to know if it&#39;s been hit or not.</p>
<p>There&#39;s always room for better performance.</p>
<hr/>
<p>Follow Brandon Falk&#39;s work <a href="https://twitter.com/gamozolabs/">Twitter</a> and <a href="https://github.com/gamozolabs">Github</a></p>

<p><a href="https://margin.re/blog/">‹ Return to Blog</a></p>
</article>




</div>
</div>
</section>

</div></div>
  </body>
</html>
