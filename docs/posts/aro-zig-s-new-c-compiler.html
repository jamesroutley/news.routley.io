<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Vexu/arocc">Original</a>
    <h1>Aro â€“ Zig&#39;s new C compiler</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>What can Zig learn from TypeScript, and what can TypeScript learn from Zig?</p>
<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64"/>The <a target="_blank" rel="noopener" href="https://adventofcode.com/" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://adventofcode.com/&#39;, event);">Advent of Code</a> is a fun annual programming competition with an Elf theme. It consists of 25 two-part problems of increasing difficulty, released every day in December leading up to Christmas.</p>
<p>Every December, I complete it in a new programming language. Every January, I intend to blog about the experience. Usually this slips to March or April, but this year it&#39;s fallen all the way back to July! As excuses, I&#39;ll offer <a href="https://effectivetypescript.com/2024/05/21/second-edition/">writing a book</a>, participating in <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://www.recurse.com/&#39;, event);">Recurse Center</a> and implementing a <a href="https://effectivetypescript.com/2024/04/16/inferring-a-type-predicate/">cool new feature</a> in TypeScript 5.5.</p>
<p>Here are the previous installments in this series:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@danvdk/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://medium.com/@danvdk/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&#39;, event);">2019: Python</a></li>
<li><a target="_blank" rel="noopener" href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc&#39;, event);">2020: Rust</a></li>
<li><a href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/">2021: Go</a></li>
<li><a href="https://effectivetypescript.com/2023/04/27/aoc2022/">2022: TypeScript / Deno</a></li>
</ul>
<p>Solving concrete problems is fun, and so is learning new languages. But this is also a good way to break out of the mental bubble of your primary language to see what else is out there. As Alan Perlis <a target="_blank" rel="noopener" href="https://www.goodreads.com/quotes/393595-a-language-that-doesn-t-affect-the-way-you-think-about" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://www.goodreads.com/quotes/393595-a-language-that-doesn-t-affect-the-way-you-think-about&#39;, event);">once said</a>, &#34;A language that doesn&#39;t affect the way you think about programming is not worth knowing.&#34;</p>
<p>Like many people in the JavaScript world, I learned about Zig because <a target="_blank" rel="noopener" href="https://bun.sh/" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://bun.sh/&#39;, event);">Bun</a>, the new JavaScript runtime, is implemented in it. I <a target="_blank" rel="noopener" href="https://zig.news/gwenzek/zig-great-design-for-great-optimizations-638" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://zig.news/gwenzek/zig-great-design-for-great-optimizations-638&#39;, event);">read</a> a <a target="_blank" rel="noopener" href="https://www.avestura.dev/blog/problems-of-c-and-how-zig-addresses-them" onclick="return trackOutboundLink(&#39;a typescripters take on zig advent of code&#39;, &#39;https://www.avestura.dev/blog/problems-of-c-and-how-zig-addresses-them&#39;, event);">little bit</a> about the language, thought it sounded interesting, and decided to do the 2023 Advent of Code in it.</p>
<p>I didn&#39;t know that much about Zig going in. My mental model was that it was a &#34;modernized C&#34; to complement Rust&#39;s &#34;modernized C++.&#34; Having used Zig for a bit, I wouldn&#39;t say that any more. It can be a fine C++ replacement, too. But first things first. What&#39;s Zig?</p>
<ol>
<li><a href="#A-very-quick-intro-to-Zig">A very quick intro to Zig</a></li>
<li><a href="#What-can-TypeScript-learn-from-Zig">What can TypeScript learn from Zig?</a><ol>
<li><a href="#Detectable-Illegal-Behavior">Detectable Illegal Behavior</a></li>
<li><a href="#comptime">comptime</a></li>
</ol>
</li>
<li><a href="#What-can-Zig-learn-from-TypeScript">What can Zig learn from TypeScript?</a><ol>
<li><a href="#Language-Server">Language Server</a></li>
<li><a href="#Error-Message-Ergonomics">Error Message Ergonomics</a></li>
<li><a href="#Documentation">Documentation</a></li>
<li><a href="#Caveats">Caveats</a></li>
</ol>
</li>
<li><a href="#General-impressions-of-Zig">General impressions of Zig</a></li>
<li><a href="#Thoughts-on-this-year-39-s-Advent-of-Code">Thoughts on this year&#39;s Advent of Code</a></li>
<li><a href="#Zig-gotchas-for-JavaScript-developers">Zig gotchas for JavaScript developers</a></li>
<li><a href="#Tips-for-doing-the-Advent-of-Code-in-Zig">Tips for doing the Advent of Code in Zig</a></li>
<li><a href="#Conclusions">Conclusions</a></li>
</ol>
<h2 id="A-very-quick-intro-to-Zig"><a href="#A-very-quick-intro-to-Zig" title="A very quick intro to Zig"></a>A very quick intro to Zig</h2><p><img src="https://effectivetypescript.com/images/zig-logo-dark.svg" title="Zig Logo" width="200" height="70"/>Zig is a low-level programming language that was <a target="_blank" rel="noopener" href="https://andrewkelley.me/post/intro-to-zig.html" onclick="return trackOutboundLink(&#39;a very quick intro to zig&#39;, &#39;https://andrewkelley.me/post/intro-to-zig.html&#39;, event);">first announced in 2016</a>. It fills a similar niche to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C_(programming_language)" onclick="return trackOutboundLink(&#39;a very quick intro to zig&#39;, &#39;https://en.wikipedia.org/wiki/C_(programming_language)&#39;, event);">C</a>: manual memory management, access to the bits of your data structures, compatible with C APIs, no object orientation.</p>
<p>C is a very old language, and some of its design choices haven&#39;t aged well. While a whole source file might not have fit into memory in 1970, that seems like a safe assumption in the 21st century. And the internet has made the cost of bugs like buffer overflows dramatically higher, since they&#39;re now security holes. Zig has a reasonable module system and it doesn&#39;t allow null pointers.</p>
<p>Zig also takes the opportunity to clean up and modernize lots of C syntax. One small example: in C, dereferencing a pointer is a prefix operation (<code>*p</code>), unless you&#39;re accessing a property (<code>p-&gt;prop</code>). In Zig, dereferencing is a postfix operation (<code>p.*</code>) and you always access properties with a dot (<code>p.prop</code>).</p>
<p>Zig also embraces best practices that have emerged over the past few decades: option types instead of null pointers, slices instead of null-terminated strings, type inference, built-in testing tools, UTF-8 source code, and a canonical code formatter.</p>
<p>Here&#39;s what <a target="_blank" rel="noopener" href="https://zig.guide/getting-started/hello-world" onclick="return trackOutboundLink(&#39;a very quick intro to zig&#39;, &#39;https://zig.guide/getting-started/hello-world&#39;, event);">Hello World</a> looks like in Zig:</p>
<figure><div><pre><code>const std = @import(&#34;std&#34;);</code></pre></div></figure>

<p>Beyond modernizing C, Zig introduces a few novel constructs of its own. We&#39;ll take a look at two of these and think about what they&#39;d look like in the context of TypeScript.</p>
<h2 id="What-can-TypeScript-learn-from-Zig"><a href="#What-can-TypeScript-learn-from-Zig" title="What can TypeScript learn from Zig?"></a>What can TypeScript learn from Zig?</h2><p><img src="https://effectivetypescript.com/images/ts-logo-128.svg" title="TypeScript Logo" width="128" height="128"/>Programming language designers sometimes talk about their <a target="_blank" rel="noopener" href="https://craftinginterpreters.com/methods-and-initializers.html#design-note" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://craftinginterpreters.com/methods-and-initializers.html#design-note&#39;, event);">novelty budget</a>: if you want developers to learn your language, you can only deviate so much from languages they already know. So best to think carefully about what these novelties will be, and make sure that they&#39;re high impact.</p>
<p>Two of Zig&#39;s most novel features are <a target="_blank" rel="noopener" href="https://zig.guide/language-basics/runtime-safety" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://zig.guide/language-basics/runtime-safety&#39;, event);">Detectable Illegal Behavior</a> and <a target="_blank" rel="noopener" href="https://zig.guide/language-basics/comptime" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://zig.guide/language-basics/comptime&#39;, event);">comptime</a>. These are both fantastic ideas, and it&#39;s interesting think about what they&#39;d look like in TypeScript.</p>
<h3 id="Detectable-Illegal-Behavior"><a href="#Detectable-Illegal-Behavior" title="Detectable Illegal Behavior"></a>Detectable Illegal Behavior</h3><p>The earlier we can catch errors, the less damage they cause, and the better off we&#39;ll be. You can imagine a hierarchy of bad behavior:</p>
<ul>
<li>Worst: Incorrect runtime behavior, producing a wrong answer, or even data corruption.</li>
<li>Bad: Throwing an exception or crashing at runtime.</li>
<li>Better: Failing a test</li>
<li>Best: Detecting the bug through static analysis (a compiler error)</li>
</ul>
<p>(You could add more levels to this hierarchy, e.g. unit tests, integration tests and manual QA tests.) Detection through static analysis is best because we detect the bug without ever having to run the broken code, and it can&#39;t do any damage!</p>
<p>Languages like C are notorious for the high consequences of mistakes. Coding errors can often turn into memory corruption or security issues. Zig&#39;s &#34;<a target="_blank" rel="noopener" href="https://zig.guide/language-basics/runtime-safety" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://zig.guide/language-basics/runtime-safety&#39;, event);">detectable illegal behavior</a>&#34; is an interesting take on how to improve this. To see how it works, consider an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integer_overflow" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://en.wikipedia.org/wiki/Integer_overflow&#39;, event);">integer overflow</a> bug:</p>
<figure><div><pre><code>pub fn main() void {</code></pre></div></figure>

<p>A <code>u8</code> is an 8-bit unsigned integer. It can only represent values from 0 to 255. When you compile this, you&#39;ll get an error:</p>
<figure><div><pre><code>src/main.zig:4:23: error: type &#39;u8&#39; cannot represent integer value &#39;256&#39;</code></pre></div></figure>

<p>This is the best case scenario. A <code>u8</code> can&#39;t represent 256 and Zig has detected this error statically.</p>
<p>If you make the error a little more subtle, though, the Zig compiler can&#39;t see it:</p>
<figure><div><pre><code>pub fn main() void {</code></pre></div></figure>

<p>What happens now is that you get a crash when you <em>run</em> the program:</p>
<figure><div><pre><code>$ zig run src/main.zig</code></pre></div></figure>

<p>Zig knows that integer addition can cause an overflow, so it inserts a check for this at runtime. If you overflow, you get a panic. Looking at our hierarchy of bad behavior, this is bad but it&#39;s saving us from the worst case scenario: incorrect behavior and chaos at runtime. This comes at a cost, though: because the check happens at runtime, it slows your program down. If this addition is happening in a tight loop, this can be a problem.</p>
<p>Zig lets you take off the safety wheels by changing your release mode:</p>
<figure><div><pre><code>$ zig run -O ReleaseFast src/main.zig</code></pre></div></figure>

<p>Now the safety checks are off and the integer overflow is allowed to happen. There are <a target="_blank" rel="noopener" href="https://ziglang.org/documentation/0.13.0/#Undefined-Behavior" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://ziglang.org/documentation/0.13.0/#Undefined-Behavior&#39;, event);">many more examples</a> of this sort of detectable illegal behavior in Zig, for example <a target="_blank" rel="noopener" href="https://ziglang.org/documentation/0.13.0/#Index-out-of-Bounds" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://ziglang.org/documentation/0.13.0/#Index-out-of-Bounds&#39;, event);">bounds checking</a> on arrays. (Zig doesn&#39;t guarantee that this code will output <code>0</code>. This is also known as &#34;undefined behavior,&#34; and this flexibility gives Zig more opportunities for <a target="_blank" rel="noopener" href="https://zig.news/gwenzek/zig-great-design-for-great-optimizations-638" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://zig.news/gwenzek/zig-great-design-for-great-optimizations-638&#39;, event);">optimization</a>.)</p>
<p>The interesting thing here is that there&#39;s an intermediate between detecting problems statically and not detecting them at all. As a fallback, we can detect a class of problems at runtime in debug builds.</p>
<p>What would this look like in TypeScript? <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number&#39;, event);">JavaScript&#39;s approach to numbers</a> means that integer overflows are uncommon. But array out-of-bounds access can certainly happen:</p>
<figure><div><pre><code><span>const</span> letters = [<span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>];</code></pre></div></figure>

<p>TypeScript does not modify this code when it compiles to JavaScript. But you could imagine <code>tsc</code> compiling this to a sort of &#34;debug build&#34; that added bounds-checking:</p>
<figure><div><pre><code><span>const</span> letters = [<span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>];</code></pre></div></figure>

<p>There&#39;s no static error, but at least this moves us one notch up the hierarchy of bad behavior.</p>
<p>It&#39;s instructive to compare Zig&#39;s behavior to TypeScript&#39;s <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess&#39;, event);"><code>noUncheckedIndexedAccess</code></a> setting. Zig&#39;s approach is &#34;trust but verify:&#34; during static analysis, it assumes your code is correct and only reports an error if it&#39;s confident that it&#39;s not. But then it inserts checks to verify its assumption at runtime.</p>
<p>By contrast, TypeScript with <code>noUncheckedIndexedAccess</code> assumes your code is invalid unless it can prove otherwise. There&#39;s a presumption of incorrectness, but no runtime checks are added:</p>
<figure><div><pre><code><span>const</span> letters = [<span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>];</code></pre></div></figure>

<p>One of the ways to convince TypeScript that your array access is valid is to add a bounds check yourself:</p>
<figure><div><pre><code><span>const</span> letters = [<span>&#39;A&#39;</span>, <span>&#39;B&#39;</span>, <span>&#39;C&#39;</span>];</code></pre></div></figure>

<p>Inserting runtime checks would allow TypeScript to flip over to an &#34;innocent unless proven guilty&#34; model like Zig&#39;s, which would result in fewer false positives and make <code>noUncheckedIndexedAccess</code> easier to adopt.</p>
<p>This is just one instance of the broader issue of <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsoundness</a>. This is when a variable&#39;s TypeScript type doesn&#39;t match its runtime type. There are <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">many ways</a> this can happen, but a common one is a <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions&#39;, event);">type assertion</a> (&#34;as&#34;):</p>
<figure><div><pre><code><span>interface</span> FunFact {</code></pre></div></figure>

<p>Does this API endpoint actually return a <code>FunFact</code>? The type assertion assures TypeScript that it does, but there&#39;s no reason this has to be the case at runtime. When this snippet is converted to JavaScript, it looks like this:</p>
<figure><div><pre><code><span>const</span> response = <span>await</span> fetch(<span>&#39;/api/fun-fact&#39;</span>);</code></pre></div></figure>

<p>There are no checks performed on the response. TypeScript is just trusting us. But perhaps the API has changed or we had a miscommunication with the backend team. If the response is actually some other type, then we may get a runtime crash or display unsightly &#34;undefined&#34;s on the page.</p>
<p>There are <a target="_blank" rel="noopener" href="https://github.com/colinhacks/zod" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/colinhacks/zod&#39;, event);">various</a> <a target="_blank" rel="noopener" href="https://github.com/YousefED/typescript-json-schema" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/YousefED/typescript-json-schema&#39;, event);">standard</a> ways to solve this problem in TypeScript. But what if TypeScript were a little more like Zig? What if it had some notion of a debug build that produced JavaScript that looked more like this:</p>
<figure><div><pre><code><span>const</span> response = <span>await</span> fetch(<span>&#39;/api/fun-fact&#39;</span>);</code></pre></div></figure>

<p>This could be pervasive. For example, a function like this:</p>
<figure><div><pre><code><span><span>function</span> <span>repeat</span>(<span>message: <span>string</span>, times: <span>number</span></span>) </span>{</code></pre></div></figure>

<p>might get compiled to this:</p>
<figure><div><pre><code><span><span>function</span> <span>repeat</span>(<span>message: string, times: number</span>) </span>{</code></pre></div></figure>

<p>You can imagine how this would improve type safety, but also slow down your code at runtime.</p>
<p>The <a target="_blank" rel="noopener" href="https://dart.dev/" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://dart.dev/&#39;, event);">Dart language</a> does <a target="_blank" rel="noopener" href="https://dart.dev/language/type-system#runtime-checks" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://dart.dev/language/type-system#runtime-checks&#39;, event);">something like this</a> to achieve a sound type system. It&#39;s interesting to think about what something similar would look like for TypeScript. I&#39;m sure it would find lots of surprising sources of unsound types!</p>
<h3 id="comptime"><a href="#comptime" title="comptime"></a>comptime</h3><p>In Zig, you can use the <a target="_blank" rel="noopener" href="https://zig.guide/language-basics/comptime" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://zig.guide/language-basics/comptime&#39;, event);"><code>comptime</code> keyword</a> to force a block of code to execute at compile time, rather than runtime:</p>
<figure><div><pre><code>fn fibonacci(n: u16) u16 {</code></pre></div></figure>

<p>If you build this and then run it, you&#39;ll see the first line print instantly, then a noticeable pause before the second line prints the same number. When Zig compiles this code, it becomes something more like this:</p>
<figure><div><pre><code>const comp = 102334155;</code></pre></div></figure>

<p>In the first line, the <em>compiler</em> has run the Fibonacci function.</p>
<p><code>comptime</code> is a particularly powerful, unifying concept in Zig because you can also manipulate <em>types</em> at comptime. This is how Zig implements generic types:</p>
<figure><div><pre><code>// Closed interval parameterized on integer type</code></pre></div></figure>

<p>Notice how this is just an ordinary Zig function, written with all the usual syntax and constructs. It&#39;s a function from from one type to another. This is how we <em>think</em> about types in TypeScript (<a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-generics/functions-on-types.md" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-generics/functions-on-types.md&#39;, event);">Item 50</a> of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a> is called &#34;Think of Generics as Functions Between Types&#34;). But in Zig they really are functions between types. Notice on the last line how &#34;instantiating&#34; a generic type just involves calling the function and assigning the result to a variable.</p>
<p>Compare this to what you&#39;d write in TypeScript:</p>
<figure><div><pre><code><span>interface</span> Interval&lt;T&gt; {</code></pre></div></figure>

<p>TypeScript has two <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/14833" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/microsoft/TypeScript/issues/14833&#39;, event);">Turing-complete</a> languages: JavaScript for the runtime, and TypeScript&#39;s type system for type manipulation. The two are quite different, and TypeScript developers have to <a target="_blank" rel="noopener" href="https://github.com/type-challenges/type-challenges" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/type-challenges/type-challenges&#39;, event);">learn a new language</a> to write complex, type-level code. Moreover, as I argue in <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-generics/codegen-alt.md" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-generics/codegen-alt.md&#39;, event);">Item 58</a> of <em>Effective TypeScript</em>, it&#39;s not a particularly good language, and you should try to avoid doing too much heavy lifting in it lest you fall into the infamous <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Turing_tarpit" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://en.wikipedia.org/wiki/Turing_tarpit&#39;, event);">Turing Tarpit</a>.</p>
<p>Zig, by contrast, only has one language: Zig. To manipulate types, you just write Zig code. The only difference is that it has to be <code>comptime</code>. Manipulating the properties of a type doesn&#39;t require any new concepts like mapped types or conditional types. You just use a <code>for</code> loop and an <code>if</code> statement.</p>
<p>In my 2020 post <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> and <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-generics/template-dsl.md" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-generics/template-dsl.md&#39;, event);">Item 54</a> of <em>Effective TypeScript</em>, I walk through how you can construct a generic type that takes a snake_cased object (<code>{foo_bar: string}</code>) and produces the corresponding camelCased object (<code>{fooBar: string}</code>). This requires a bunch of concepts from TypeScript&#39;s type system: generic types, template literal types, conditional types, mapped types, and <code>infer</code>. It&#39;s not simple, and it doesn&#39;t look at all like JavaScript.</p>
<p>Here&#39;s what it might look like if TypeScript had something like Zig&#39;s <code>comptime</code>:</p>
<figure><div><pre><code><span>// e.g. &#34;foo_bar&#34; -&gt; &#34;fooBar&#34;</span></code></pre></div></figure>

<p>This is just a sketch, but it&#39;s satisfying to see how the code for manipulating the types and the code for manipulating the values are nearly identical. Even better, they both call the same <code>camelCase</code> function, so you know the type and value transformations will stay in sync and have identical edge case behaviors.</p>
<p>Type-level TypeScript is written in a different language and runs in the type checker. comptime Zig is still Zig, it just runs at a different time.</p>
<p>comptime is useful beyond type manipulation. I was afraid to look at the source code for <code>std.fmt.format</code> because I assumed it would involve some completely inscrutable metaprogramming. But it&#39;s <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/blob/4870e002f213d7002ac1941c6a204aff79137d54/lib/std/fmt.zig#L80-L84" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/ziglang/zig/blob/4870e002f213d7002ac1941c6a204aff79137d54/lib/std/fmt.zig#L80-L84&#39;, event);">actually pretty simple</a>! The format string must be <code>comptime</code> known, and the formatting function just runs a for loop over it.</p>
<p>Using the same language for programming and metaprogramming seems like a great idea (see: <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/267880/388951" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://stackoverflow.com/a/267880/388951&#39;, event);">Lisp macros</a>). Are there any downsides? I can think of two: performance and inference.</p>
<ul>
<li><p><strong>Performance</strong>: <code>comptime</code> isn&#39;t free. Your code still has to be run at some point. Zig doesn&#39;t have a very built-out language server (more on that shortly), but TypeScript does. It potentially has to run your type level code on every keystroke as you type in your text editor. To avoid bogging down or hanging, TypeScript sets some strict limits on how deeply recursive your type-level code can be. If your type-level code was written in JavaScript, it would much harder to enforce these limits in any systematic way. Timeouts aren&#39;t really an option in a compiler: you don&#39;t want the validity of code to depend on the developer&#39;s CPU speed.</p>
</li>
<li><p><strong>Inference</strong>: When it&#39;s inferring types, there are situations where TypeScript needs to run your type-level code <em>in reverse</em>. Type-level operations were built with inference in mind, but inverting an arbitrary snippet of JavaScript code isn&#39;t possible.</p>
</li>
</ul>
<p>Here&#39;s a simple example of how this can happen:</p>
<figure><div><pre><code><span>type</span> Box&lt;T&gt; = { <span>value</span>: T };</code></pre></div></figure>

<p>Here <code>Box</code> maps <code>T</code> â†’ <code>{value: T}</code>, but on the last line TypeScript has to go from <code>{value: number}</code> â†’ <code>number</code> to infer <code>T</code>. This even <a href="https://www.typescriptlang.org/play/?noUncheckedIndexedAccess=true&amp;target=6#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeUBuAhgDYCuEAXFClAL4DcAUACYQDGxhATtAGakA7NsACWcAVEEAjRKjQAKGQirxk6AJRUUTRm3EBnYFAGkAtlkkCl8nETKUoARgBMtdUwD0HqD6gA9AH4oPQFDYzMqE1MpCC5GeNBIKABhcWZVOQsaCARgCAFmfShDLhEBAHMoILwSrTooKjwBcQBlYC46hhZ2Th4ofiFRcUslEOY5RUQqVIKMjS0dELDgAHcIYnxobGlEMZtmgTaOp1d3Ri9ffyClo1X1zcizGLjdAyMECx2EPZxaqAByBD-Nyeby+QLBN5QZQAoGMIA" target="_blank" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://www.typescriptlang.org/play/?noUncheckedIndexedAccess=true&amp;target=6#code/C4TwDgpgBAQg9gDwDwBUB8UC8UDeUBuAhgDYCuEAXFClAL4DcAUACYQDGxhATtAGakA7NsACWcAVEEAjRKjQAKGQirxk6AJRUUTRm3EBnYFAGkAtlkkCl8nETKUoARgBMtdUwD0HqD6gA9AH4oPQFDYzMqE1MpCC5GeNBIKABhcWZVOQsaCARgCAFmfShDLhEBAHMoILwSrTooKjwBcQBlYC46hhZ2Th4ofiFRcUslEOY5RUQqVIKMjS0dELDgAHcIYnxobGlEMZtmgTaOp1d3Ri9ffyClo1X1zcizGLjdAyMECx2EPZxaqAByBD-Nyeby+QLBN5QZQAoGMIA&#39;, event);">works with conditional types</a>.</p>
<p>These are both serious issues. In practice I&#39;d hope that caching could mitigate many of the performance concerns. And, to be honest, I&#39;d be fine losing this form of type inference if it meant that we could manipulate types in plain old JavaScript!</p>
<p>To be clear, these would be radical changes to TypeScript and I don&#39;t expect anything like them to happen. But you could imagine building an alternative TypeScript to JavaScript emitter that inserted runtime type checks. (We could call itâ€¦ <a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped" onclick="return trackOutboundLink(&#39;what can typescript learn from zig&#39;, &#39;https://github.com/DefinitelyTyped/DefinitelyTyped&#39;, event);">DefinitelyTyped</a>! ðŸ˜œ) And if an aspiring language designer wants to build the next great flavor of typed JavaScript, including a comptime construct would be a great way to differentiate from TypeScript.</p>
<h2 id="What-can-Zig-learn-from-TypeScript"><a href="#What-can-Zig-learn-from-TypeScript" title="What can Zig learn from TypeScript?"></a>What can Zig learn from TypeScript?</h2><p><img src="https://effectivetypescript.com/images/ziggy.svg" title="Ziggy, the Zig mascot" width="190" height="158"/>Flipping the question around, what are some good ideas from TypeScript that Zig might adopt?</p>
<p>My main suggestion would be to focus more on developer experience. To me, this means a few things:</p>
<ol>
<li>Language server</li>
<li>Error message ergonomics</li>
<li>Documentation</li>
</ol>
<h3 id="Language-Server"><a href="#Language-Server" title="Language Server"></a>Language Server</h3><p>When you install TypeScript in a project, you get two binaries:</p>
<ol>
<li><code>tsc</code>, the TypeScript Compiler</li>
<li><code>tsserver</code>, the TypeScript Language Server</li>
</ol>
<p>It&#39;s pretty rare to run <code>tsserver</code> directly, but if you use VS Code or another editor that supports the language service protocol, you&#39;re interacting with it all the time. The TypeScript team treats these binaries as equally important. Every new language feature is supported by the language server on day one. And the release notes for TypeScript versions include things like <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#quick-fix-for-adding-missing-parameters" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#quick-fix-for-adding-missing-parameters&#39;, event);">new Quick Fixes</a>, which you might not think of as being core to the language itself.</p>
<p>There <em>is</em> a language server available for Zig, <a target="_blank" rel="noopener" href="https://github.com/zigtools/zls" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/zigtools/zls&#39;, event);"><code>zls</code></a>. It&#39;s a third-party tool, though, and while an <a target="_blank" rel="noopener" href="https://github.com/zigtools/zls/commits/master/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/zigtools/zls/commits/master/&#39;, event);">enormous amount of work</a> has gone into it, it has a lot of issues. It provides syntax highlighting and some language service features like go-to-definition. It reports superficial errors like syntax errors and unused variables, but it quickly gets lost with anything much beyond that.</p>
<p>Some of the errors that it fails to report are surprising:</p>
<p><img src="https://effectivetypescript.com/images/zls-no-error.png" alt="zls failing to detect a typo in a function name"/></p><p>It should be <code>print</code>, not <code>prin</code>.</p>
<p>It&#39;s pretty disorienting to see no errors in your editor, only to have lots of them when you build from the command line. <em>(See <a href="#caveats">below</a> for how to improve this.)</em> The language server also hangs a lot. It was quite rare for me to solve an Advent of Code problem without having to restart <code>zls</code>.</p>
<p>Apparently gripes about <code>zls</code> are <a target="_blank" rel="noopener" href="https://www.reddit.com/r/Zig/comments/1d4s9kz/zls_does_not_catch_compile_time_errors_warnings/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://www.reddit.com/r/Zig/comments/1d4s9kz/zls_does_not_catch_compile_time_errors_warnings/&#39;, event);">common</a> in the Zig community, so this may not come as much of a surprise. Andrew Kelley <a target="_blank" rel="noopener" href="https://youtu.be/5eL_LcxwwHg?si=xLEFQqRwGQ7tPbni&amp;t=2260" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://youtu.be/5eL_LcxwwHg?si=xLEFQqRwGQ7tPbni&amp;t=2260&#39;, event);">talks about this a bit</a> in the context of the <a target="_blank" rel="noopener" href="https://lwn.net/Articles/959915/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://lwn.net/Articles/959915/&#39;, event);">2024 Zig Roadmap</a>. He thinks a first-party language server will happen eventually, but it&#39;s not a priority. He also mentions that he uses vim and does not use a language server, so a first-party language server would not benefit him personally.</p>
<p>I think this may be a cultural thing. I used to use vim 15 years go when I worked <a target="_blank" rel="noopener" href="https://github.com/danvk/performance-boggle" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/danvk/performance-boggle&#39;, event);">primarily in C++</a>, and I also didn&#39;t use a language server. There wasn&#39;t much point. C++ is nearly impossible to parse, let alone analyze. It was only when I started working in TypeScript and switched to VS Code that I saw the light. Language servers are great, and it&#39;s hard to go back once you&#39;re used to them.</p>
<p>A language server changes your relationship with the language. A command-line compiler is all about looking over your code and telling you where you&#39;ve made mistakes. A language server is like a partner that&#39;s right there in your editor with you, helping you to get things right. It&#39;s hard to underestimate how valuable a good language server is when you&#39;re coming up to speed on a new language. It lets you quickly experiment and develop an intuition for how types work and what errors result from your changes. A better zls would have greatly improved my experience with Zig.</p>
<p>Let&#39;s all hope Andrew works on a TypeScript side project someday and has a language server conversion experience. May I suggest the 2024 Advent of Code? ðŸ˜€</p>
<h3 id="Error-Message-Ergonomics"><a href="#Error-Message-Ergonomics" title="Error Message Ergonomics"></a>Error Message Ergonomics</h3><p>The user interface of a compiler consists mostly of the errors that it presents to you. So the way those error messages are presented has a huge impact on your experience of using the language. The TypeScript team takes this extremely seriously. There&#39;s an entire <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/labels/Domain%3A%20Error%20Messages" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/microsoft/TypeScript/labels/Domain%3A%20Error%20Messages&#39;, event);">GitHub Issue Label</a> for error messages, and many releases <a href="https://effectivetypescript.com/2023/06/27/ts-51/#Improved-Error-Messages">include improvements</a> in error reporting.</p>
<p>Even more fundamental than messaging, though, is attribution. I ran into at least three cases during the Advent of Code where an error was correctly reported, but in the wrong place. This makes for an incredibly confusing experience, particularly when you&#39;re learning a new language and aren&#39;t very confident about how you&#39;re using it.</p>
<p>When I <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/pull/4" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/danvk/aoc2023/pull/4&#39;, event);">updated to Zig 0.13</a> for this post, I was happy to see that 2/3 of these misattributions had been fixed. The third issue was that calling <code>std.debug.print</code> with the wrong number of arguments doesn&#39;t include the relevant line number in the error message. I <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/issues/18485" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/ziglang/zig/issues/18485&#39;, event);">filed an issue</a> about this in January. A fix was <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/pull/18349" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/ziglang/zig/pull/18349&#39;, event);">quickly posted</a>, but it was rejected by Andrew Kelley, Zig&#39;s creator, as <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/pull/18349#discussion_r1445562741" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/ziglang/zig/pull/18349#discussion_r1445562741&#39;, event);">too hacky</a>.</p>
<p>I have tremendous respect for Andrew&#39;s willingness to hold out for a better solution. Language designers need to do this to avoid bigger problems down the road. But I do hope this issue gets fixed, because missing locations on error messages is a truly terrible, disorienting user experience.</p>
<p>Here was another sort of error that tripped me up a few times:</p>
<figure><div><pre><code>const values = std.AutoHashMap(Point, u32);</code></pre></div></figure>

<p>The mistake here isn&#39;t on that line, and it doesn&#39;t have to do with the number of arguments. Rather, it&#39;s that I forgot to call <code>.init()</code> on the hash map:</p>
<figure><div><pre><code>var values = std.AutoHashMap(Point, u32).init(allocator);</code></pre></div></figure>

<p>I also found Zig pointer types to be pretty hard to read in error messages.</p>
<h3 id="Documentation"><a href="#Documentation" title="Documentation"></a>Documentation</h3><p>Microsoft publishes an official <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://www.typescriptlang.org/docs/handbook/intro.html&#39;, event);">TypeScript Handbook</a>. When it <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-handbook/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-handbook/&#39;, event);">launched</a> in 2021, it was given as much attention and fanfare as the release of a new version of TypeScript itself.</p>
<p>I primarily used ziglearn.org to come up to speed, which is now <a target="_blank" rel="noopener" href="https://zig.guide" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://zig.guide&#39;, event);">zig.guide</a>. There&#39;s a lot of content there, but I found it had quite a few gaps. For example, the documentation on <a target="_blank" rel="noopener" href="https://zig.guide/build-system/zig-build" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://zig.guide/build-system/zig-build&#39;, event);">build.zig</a> is quite sparse, and it didn&#39;t give me much insight into how to set up a 25-day Advent of Code project (One binary? 25?). <em>(Update: there&#39;s now an official <a target="_blank" rel="noopener" href="https://ziglang.org/learn/build-system/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://ziglang.org/learn/build-system/&#39;, event);">docs page</a> and a <a target="_blank" rel="noopener" href="https://ziggit.dev/t/build-system-tricks/3531" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://ziggit.dev/t/build-system-tricks/3531&#39;, event);">community forum</a> post.)</em></p>
<p>I was surprised that Zig didn&#39;t have a <code>toString()</code> convention. Twenty days into the 2023 Advent of Code, I learned that it <em>did</em> (<code>pub fn format</code>) from reading the standard library source code. As it turns out, this does appear in <a target="_blank" rel="noopener" href="https://zig.guide/standard-library/formatting" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://zig.guide/standard-library/formatting&#39;, event);">one example</a> in the docs on formatting, but I&#39;d expect this to be given more front-and-center treatment since it&#39;s so useful any time you define a data structure.</p>
<h3 id="Caveats"><a href="#Caveats" title="Caveats"></a>Caveats</h3><p>After sharing a draft of this post, I <a target="_blank" rel="noopener" href="https://ziggit.dev/t/request-for-feedback-on-draft-blog-post-what-zig-and-typescript-can-learn-from-each-other/5039/3" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://ziggit.dev/t/request-for-feedback-on-draft-blog-post-what-zig-and-typescript-can-learn-from-each-other/5039/3&#39;, event);">learned</a> that&#39;s it&#39;s possible to get <code>zls</code> to display all compile-time errors using the <a target="_blank" rel="noopener" href="https://kristoff.it/blog/improving-your-zls-experience/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://kristoff.it/blog/improving-your-zls-experience/&#39;, event);"><code>buildOnSave</code></a> feature. Here&#39;s a <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/commit/4dfdfd083839f2c43c90ab06274afe4c209932d3" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://github.com/danvk/aoc2023/commit/4dfdfd083839f2c43c90ab06274afe4c209932d3&#39;, event);">commit</a> where I added it to my repo. I wish I&#39;d known about this last December, it would have greatly improved my Zig experience!</p>
<p>And despite my grumblings about some aspects of developer experience, Zig may be making the correct tradeoffs. Why? It&#39;s still an early-stage language whose design is in flux. This is reflected not just in the version number (pre-1.0!) but also in its development: a <a target="_blank" rel="noopener" href="https://ziglang.org/news/0.11.0-postponed-again/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://ziglang.org/news/0.11.0-postponed-again/&#39;, event);">recent release</a> removed an existing async/await feature while they think about a better design. It&#39;s hard to imagine TypeScript doing something like that. If you expect the language to make major changes before 1.0, then building out a language server now will create more work down the road.</p>
<p>On the other hand, if the Zig team built out a language server now, they might gain valuable insights about which language features work well with it and which ones don&#39;t. This could inform the future design of the language. There&#39;s an assumption that a high-quality language service <em>can</em> be built after the language design is stabilized, but this might not be the case. It&#39;s a gamble!</p>
<p>Of course, another big difference between TypeScript and Zig is that <a target="_blank" rel="noopener" href="https://www.microsoft.com/investor/reports/ar23/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://www.microsoft.com/investor/reports/ar23/&#39;, event);">Microsoft&#39;s annual revenue</a> is nearly 500,000 times greater than the <a target="_blank" rel="noopener" href="https://ziglang.org/news/2024-financials/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://ziglang.org/news/2024-financials/&#39;, event);">Zig Foundation&#39;s</a>. This means that the Zig team needs to make harder choices about prioritization. Their <a target="_blank" rel="noopener" href="https://lwn.net/Articles/959915/" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://lwn.net/Articles/959915/&#39;, event);">top four goals</a> are currently performance, language improvements, standard library improvements, and a formal language specification. It&#39;s hard to argue with the focus on build speed (Advent of Code solutions aren&#39;t big enough for this to be an issue), and that will definitely be a boon for developer experience. But I&#39;d love to see other forms of DX move up that list. For what it&#39;s worth, TypeScript&#39;s experience with formal specification is that it&#39;s not worthwhile. A <a target="_blank" rel="noopener" href="https://javascript.xgqfrms.xyz/pdfs/TypeScript%20Language%20Specification.pdf" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://javascript.xgqfrms.xyz/pdfs/TypeScript%20Language%20Specification.pdf&#39;, event);">formal spec</a> was released in 2014 and has been gathering dust ever since.</p>
<p><em>âœ¨ Many thanks to the Zig Forum for <a target="_blank" rel="noopener" href="https://ziggit.dev/t/request-for-feedback-on-draft-blog-post-what-zig-and-typescript-can-learn-from-each-other/5039" onclick="return trackOutboundLink(&#39;what can zig learn from typescript&#39;, &#39;https://ziggit.dev/t/request-for-feedback-on-draft-blog-post-what-zig-and-typescript-can-learn-from-each-other/5039&#39;, event);">feedback</a> on this section.</em></p>
<h2 id="General-impressions-of-Zig"><a href="#General-impressions-of-Zig" title="General impressions of Zig"></a>General impressions of Zig</h2><p>Those issues aside, I wound up really liking Zig! Given a choice, I&#39;d strongly prefer it to C for a new project. I also found it easier to work in <a target="_blank" rel="noopener" href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc&#39;, event);">than Rust</a>.</p>
<p>Zig <a target="_blank" rel="noopener" href="https://ziglang.org/" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://ziglang.org/&#39;, event);">advertises</a> &#34;No hidden control flow&#34; and &#34;No hidden memory allocations.&#34; I incorrectly read the latter to also mean &#34;no hidden copying,&#34; and this led to a lot of confusion at first. For example:</p>
<figure><div><pre><code>const Box = struct {</code></pre></div></figure>

<p>In JavaScript, Python, or Java, <code>var b = a</code> would create a new reference to the same underlying object and this would print two 2s.</p>
<p>In Zig (as in C++ and Go), <code>var b = a</code> creates a copy of the struct and you get two different values:</p>
<figure><div><pre><code>a: main.Box{ .val = 1 } b: main.Box{ .val = 2 }<br/></code></pre></div></figure>

<p>Zig implicitly copies data all the time. Sometimes this can be subtle. If you return a <code>struct</code> from a function, it may be copied. A slice is a struct with a len and a ptr, and these are copied when you assign to a slice (the pointer is copied, not the thing it points to). Understanding implicit copying and building a mental model for it was the key insight that made me feel comfortable programming in Zig. I had a <a href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/#Implicit-copies">similar insight</a> about Go back in 2021.</p>
<p>As I mentioned above, I really liked <code>comptime</code>. It&#39;s a clever, unifying idea. I hope more languages adopt something like this in the future.</p>
<p>Just like C, Zig doesn&#39;t have classes or inheritance, but it does have <code>struct</code>s. Unlike in C, a Zig <code>struct</code> can have methods defined on it and it can be generic. This feels a lot like <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C%2B%2B#History" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://en.wikipedia.org/wiki/C%2B%2B#History&#39;, event);">C with Classes</a>. Unless you&#39;re making heavy use of inheritance (and <a target="_blank" rel="noopener" href="https://codeburst.io/inheritance-is-evil-stop-using-it-6c4f1caf5117" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://codeburst.io/inheritance-is-evil-stop-using-it-6c4f1caf5117&#39;, event);">why would you be?</a>), this means that Zig can also fill many of the same niches as C++. It&#39;s interesting that <code>struct</code>s can have private functions but not private fields. I guess this makes some sense since you have to be able to copy the bytes of a <code>struct</code> to use it.</p>
<p>Most Advent of Code problems start with reading a text file (your puzzle input). The standard way to <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/68879352/388951" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://stackoverflow.com/a/68879352/388951&#39;, event);">read a file line-by-line</a> is a bit verbose:</p>
<figure><div><pre><code>var file = try std.fs.cwd().openFile(&#34;foo.txt&#34;, .{});</code></pre></div></figure>

<p>I thought it would be an interesting exercise to factor this out into a helper function. This wound up being <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/77427514/how-can-i-write-a-function-to-iterate-over-the-lines-in-a-file-in-zig" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://stackoverflow.com/questions/77427514/how-can-i-write-a-function-to-iterate-over-the-lines-in-a-file-in-zig&#39;, event);">dramatically harder</a> than I expected. With some help from Stack Overflow and the <a target="_blank" rel="noopener" href="https://ziggit.dev/t/help-debugging-memory-corruption-while-reading-a-file-with-a-buffered-reader-and-iterator/2203/5" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://ziggit.dev/t/help-debugging-memory-corruption-while-reading-a-file-with-a-buffered-reader-and-iterator/2203/5&#39;, event);">Zig Forum</a>, I was eventually able to come up with a <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/main/src/buf-iter.zig" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://github.com/danvk/aoc2023/blob/main/src/buf-iter.zig&#39;, event);">solution</a>. But the broader point from the forum was that maybe factoring this out isn&#39;t worth the hassle in Zig, because it&#39;s easier to see how all the pieces fit together with the explicit code, and to see what constants you&#39;re assuming (<code>1024</code> and <code>\n</code>).</p>
<p>I eventually found another reason to avoid this pattern: if you read the entire input into a single buffer (rather than line by line), then you can assume this memory is available throughout execution and reference slices of it without having to think about ownership. This is particularly nice if you&#39;re putting them in a <code>StringHashMap</code>, which does not take responsibility for ownership of its keys.</p>
<p>Zig has a distinctive way of <a target="_blank" rel="noopener" href="https://zig.guide/language-basics/errors" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://zig.guide/language-basics/errors&#39;, event);">handling errors</a>: it introduces special syntax (<code>error!type</code>) for something that can be either an error or a success value. Typically the error type can be inferred:</p>
<figure><div><pre><code>fn foo() !u32 {</code></pre></div></figure>

<p>The <code>try</code> keyword checks if the other call returns an error and passes it on up the call chain. The possible error types that <code>foo()</code> returns will be the same as the other function. If <code>foo()</code> had returned <code>u32</code> instead, then it would have needed to handle the error case itself.</p>
<p>I didn&#39;t wind up having very strong feelings about this feature. I almost always allowed error types to be inferred, so the only difference between this and JavaScript-style exceptions is that there were more <code>try</code>s. Remember, no hidden control flow. It wasn&#39;t obvious to me why some failure modes (out of memory) are handled with explicit errors, while others (integer overflow) are handled via detectable illegal behavior. <em>(See <a target="_blank" rel="noopener" href="https://ziggit.dev/t/request-for-feedback-on-draft-blog-post-what-zig-and-typescript-can-learn-from-each-other/5039/3" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://ziggit.dev/t/request-for-feedback-on-draft-blog-post-what-zig-and-typescript-can-learn-from-each-other/5039/3&#39;, event);">this comment</a> for an explanation.)</em></p>
<p>Whether a function can fail affects the way you call it, and this can be seen as an interesting <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nudge_theory#:~:text=A%20nudge%20makes%20it%20more,to%20favour%20the%20desired%20outcome." onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://en.wikipedia.org/wiki/Nudge_theory#:~:text=A%20nudge%20makes%20it%20more,to%20favour%20the%20desired%20outcome.&#39;, event);">nudge</a>. Error-returning functions must be called with <code>try</code>, <code>catch</code>, or some other error-handling construct. Because you&#39;re constantly writing <code>try</code>, you&#39;re always aware of which type of function you&#39;re working with. This makes you prefer calling functions that can&#39;t fail. Since memory allocation can fail, this pushes you to write functions that don&#39;t allocate memory. Usually this means taking a buffer as an argument, or allocating one internally. And this is generally a more efficient design.</p>
<p>Another interesting choice is to <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/issues/229" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://github.com/ziglang/zig/issues/229&#39;, event);">not allow function closures</a>. Instead, higher-level Zig functions like <a target="_blank" rel="noopener" href="https://zig.guide/standard-library/sorting/" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://zig.guide/standard-library/sorting/&#39;, event);"><code>std.mem.sort</code></a> take a context object that&#39;s passed to the comparison function. I believe this is equivalent in power to closures, it just requires the tedium of defining a context data type and populating it. This makes you aware of the context that you&#39;re capturing, and encourages you to capture as little as possible.</p>
<p>It&#39;s worth remembering that the Advent of Code tends to highlight specific aspects of a language, and these puzzles may not be the sorts of problems that the language is designed to solve. There were large parts of Zig that I never interacted with, for example its SIMD support or its C API. Zig is a great language for targeting WASM, but I never needed to do this.</p>
<p>A few other quick notes:</p>
<ul>
<li>An Arena allocator has some similarities to Rust-style lifetime annotations. Rather than tying the lifetimes of two values together, you connect them both to a moment in time during execution.</li>
<li>Zig recently added <a target="_blank" rel="noopener" href="https://ziglang.org/download/0.12.0/release-notes.html#Aggregate-Destructuring" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://ziglang.org/download/0.12.0/release-notes.html#Aggregate-Destructuring&#39;, event);">destructuring assignment for tuples</a>. This is great, but I wish it supported a <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#syntax" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#syntax&#39;, event);">similar syntax for structs</a>, just like JavaScript, to encourage consistent naming. This would be particularly handy for imports. It&#39;s <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/issues/3897#issuecomment-738984680" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://github.com/ziglang/zig/issues/3897#issuecomment-738984680&#39;, event);">unlikely to happen</a>, though.</li>
<li><a target="_blank" rel="noopener" href="https://zig.guide/language-basics/payload-captures" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://zig.guide/language-basics/payload-captures&#39;, event);">Payload capturing</a> is ubiquitous and felt pretty intuitive. I just wish it worked better with the language server.</li>
<li><a target="_blank" rel="noopener" href="https://zig.guide/language-basics/sentinel-termination" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://zig.guide/language-basics/sentinel-termination&#39;, event);">Sentinel termination</a> feels like a trivial generalization of null termination. Are there ever situations where you want to terminate a slice with anything other than a <code>0</code>? (See <a target="_blank" rel="noopener" href="https://ziggit.dev/t/are-sentinels-only-intended-for-null-terminators/2765" onclick="return trackOutboundLink(&#39;general impressions of zig&#39;, &#39;https://ziggit.dev/t/are-sentinels-only-intended-for-null-terminators/2765&#39;, event);">discussion</a>.)</li>
<li>Zig does a pretty good job of inferring types where it can. The various integer types make this a harder problem than it is in TypeScript, though.</li>
<li>I found the many, sight variations on pointer syntax quite hard to read and get comfortable with, particularly in error messages:<ul>
<li><code>*T</code>: pointer to a single item</li>
<li><code>[*]T</code>: pointer to many (unknown number) of items</li>
<li><code>*[N]T</code>: pointer to an array of N items</li>
<li><code>[*:x]T</code>: pointer to a number of items determined by a sentinel</li>
<li><code>[]T</code>: slice, has a pointer of type <code>[*]T</code> and a <code>len</code>.</li>
</ul>
</li>
</ul>
<h2 id="Thoughts-on-this-year-39-s-Advent-of-Code"><a href="#Thoughts-on-this-year-39-s-Advent-of-Code" title="Thoughts on this year&#39;s Advent of Code"></a>Thoughts on this year&#39;s Advent of Code</h2><p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64"/>I completed the 2017 Advent of Code in Zig as a warmup, then did the 2023 Advent of Code as problems came out each day.</p>
<p>This made for quite a contrast. The 2017 Advent of Code was very, very easy (my notes are <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/main/aoc2017/README.md" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://github.com/danvk/aoc2023/blob/main/aoc2017/README.md&#39;, event);">here</a>). The 2023 Advent of Code was quite hard. Even <a target="_blank" rel="noopener" href="https://adventofcode.com/2023/day/1" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://adventofcode.com/2023/day/1&#39;, event);">day 1</a> had potential for trouble. Some of the problem setups were quite convoluted. There&#39;s been speculation that this was an attempt to thwart AI solvers. Whether or not it succeeded, it certainly led to some tedious code.</p>
<p>I learned about a few new things this year:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pick%27s_theorem" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://en.wikipedia.org/wiki/Pick%27s_theorem&#39;, event);">Pick&#39;s Theorem</a> relates the area of a polygon with integer vertices to the number of integer points inside the polygon.</li>
<li>The <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shoelace_formula" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://en.wikipedia.org/wiki/Shoelace_formula&#39;, event);">Shoelace Formula</a> is the standard way to find the area of a simple polygon.</li>
<li>A <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nonogram" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://en.wikipedia.org/wiki/Nonogram&#39;, event);">Nonogram</a>, aka Paint by Numbers, is a type of logic puzzle.</li>
<li><a target="_blank" rel="noopener" href="https://www.sympy.org/en/index.html" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://www.sympy.org/en/index.html&#39;, event);">sympy</a> is a Python library for symbolic manipulation / computer algebra.</li>
</ul>
<p>Notes on a few specific problems (spoiler alert!):</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2023/day/20" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://adventofcode.com/2023/day/20&#39;, event);">Day 20</a>: This one was super frustrating. I had the right idea for part 2, but I used an online <a target="_blank" rel="noopener" href="https://www.calculatorsoup.com/calculators/math/lcm.php" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://www.calculatorsoup.com/calculators/math/lcm.php&#39;, event);">LCM calculator</a> and mistyped a number, leading to the wrong result. I wasted over an hour before realizing the mistake. Note to self: always copy/paste numbers, never type them!</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2023/day/21" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://adventofcode.com/2023/day/21&#39;, event);">Day 21</a>: I solved this by plugging numbers into a spreadsheet and looking for a pattern, even without fully understanding it. Judging by my finish number (#4624 at 11 AM Eastern), this was the hardest problem of the year.</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2023/day/24" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://adventofcode.com/2023/day/24&#39;, event);">Day 24</a>: I completed part 1 before going to a family Christmas. I had part 2 in the back of my head all day, and I was pretty sure I had the solution all figured out. I just needed to code it. When I got home, I realized that the sample input and my puzzle input were very different, and my idea wouldn&#39;t work at all. I wound up spending an enormous amount of time solving the equations, largely by hand. I was a bit disappointed that most people just plugged them into <a target="_blank" rel="noopener" href="https://www.sympy.org/en/index.html" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://www.sympy.org/en/index.html&#39;, event);">sympy</a> to get a solution without any understanding. sympy does look cool, though!</li>
<li><a target="_blank" rel="noopener" href="https://adventofcode.com/2023/day/25" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://adventofcode.com/2023/day/25&#39;, event);">Day 25</a>: My turn to use a Python library without understanding what I&#39;m doing. I gave up on Zig and plugged in NetworkX. The <code>k_edge_components</code> method solves this problem. I did eventually wind up <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/main/src/day25.zig" onclick="return trackOutboundLink(&#39;thoughts on this years advent of code&#39;, &#39;https://github.com/danvk/aoc2023/blob/main/src/day25.zig&#39;, event);">porting my solution</a> to Zig.</li>
</ul>
<h2 id="Zig-gotchas-for-JavaScript-developers"><a href="#Zig-gotchas-for-JavaScript-developers" title="Zig gotchas for JavaScript developers"></a>Zig gotchas for JavaScript developers</h2><p>Zig is a much lower-level language than JavaScript. If you haven&#39;t previously worked in a language with manual memory management, pointers, or a non-primitive string type, it&#39;s going to have a steep learning curve.</p>
<p>That being said, Zig has a few keywords that also exist in JavaScript, but mean completely different things. Watch out for these <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/False_friend" onclick="return trackOutboundLink(&#39;zig gotchas for javascript developers&#39;, &#39;https://en.wikipedia.org/wiki/False_friend&#39;, event);">false friends</a>:</p>
<ul>
<li><code>var</code> and <code>const</code>: These are <em>not</em> analogous to <code>var</code>/<code>let</code> and <code>const</code> in JavaScript. In JavaScript, <code>const</code> is shallow. It just means that you can&#39;t reassign the variable. <a target="_blank" rel="noopener" href="https://www.epicweb.dev/talks/let-me-be" onclick="return trackOutboundLink(&#39;zig gotchas for javascript developers&#39;, &#39;https://www.epicweb.dev/talks/let-me-be&#39;, event);">Some people don&#39;t like it</a>. Zig&#39;s <code>const</code> is much stronger. If you declare a variable with <code>const</code>, you can&#39;t mutate it or call any methods that might mutate it. It&#39;s a deep <code>const</code>. Seeing <code>var</code> in JS should make you flinch because of its <a target="_blank" rel="noopener" href="https://medium.com/@codingsam/awesome-javascript-no-more-var-working-title-999428999994" onclick="return trackOutboundLink(&#39;zig gotchas for javascript developers&#39;, &#39;https://medium.com/@codingsam/awesome-javascript-no-more-var-working-title-999428999994&#39;, event);">weird hoisting semantics</a>. But Zig doesn&#39;t have that historical baggage. <code>var</code> is a great term for something that varies.</li>
<li><code>try</code> and <code>catch</code>: In JavaScript (and C++, Java, and many other languages), these are used to construct <code>try {} catch (e) {}</code> blocks. In Zig, they&#39;re more like operators on expressions. <code>try f()</code> calls <code>f</code>, checks if it returns an error, and returns that error if it does. <code>catch</code> is used to provide fallback values: <code>f() catch val</code> resolves to <code>val</code> if <code>f</code> returns an error.</li>
<li><code>null</code> and <code>undefined</code>: JavaScript finally has company: another language that has both <code>null</code> <em>and</em> <code>undefined</code>! These have pretty specific meanings in Zig, though. <code>null</code> is used exclusively with optional types. <code>undefined</code> is special: it&#39;s not a value; instead it means that you don&#39;t want to initialize the value. Generally you want to avoid this since you&#39;ll get garbage at runtime.</li>
<li><code>for</code> and <code>while</code>: Zig&#39;s <code>for</code> loop is quite limited. You can iterate over a slice or a range with it, and that&#39;s about it. For everything else, including iterators and C-style <code>for(;;)</code> loops, you use a <code>while</code> loop.</li>
<li><code>||</code> and <code>or</code>: In JavaScript (and C), <code>||</code> is logical or. Like Python, Zig spells that <code>or</code> instead. Fair enough. What&#39;s really confusing, though, is that Zig <em>also</em> has a <code>||</code> operator that does something totally different. It unions two error sets, more akin to TypeScript&#39;s type-level <code>|</code>. I never used <code>||</code>.</li>
<li>Zig has a <code>switch</code> statement but it works a bit differently than JavaScript&#39;s. It&#39;s more powerful, doesn&#39;t have fall-through, and must be exhaustive.</li>
<li>Zig uses a different syntax for object literals: <code>.{ .x=1, .y=2 }</code> instead of <code>{ x: 1, y: 2 }</code>. I screwed this up countless times, and so will you.</li>
<li>Zig also has tagged unions but they&#39;re a little more constrained than TypeScript&#39;s.</li>
</ul>
<p>Zig is still a relatively niche language and ChatGPT is going to have more trouble helping you write it than it would with JavaScript.</p>
<h2 id="Tips-for-doing-the-Advent-of-Code-in-Zig"><a href="#Tips-for-doing-the-Advent-of-Code-in-Zig" title="Tips for doing the Advent of Code in Zig"></a>Tips for doing the Advent of Code in Zig</h2><p>Various <a target="_blank" rel="noopener" href="https://cohost.org/strangebroadcasts/post/542139-also-failing-to-lear" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://cohost.org/strangebroadcasts/post/542139-also-failing-to-lear&#39;, event);">other blogs</a> have mentioned <a target="_blank" rel="noopener" href="https://www.forrestthewoods.com/blog/failing-to-learn-zig-via-advent-of-code/" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://www.forrestthewoods.com/blog/failing-to-learn-zig-via-advent-of-code/&#39;, event);">struggling</a> to do AoC in Zig. For the most part, I didn&#39;t find it to be too bad. If you decide to try it, good luck! Feel free to use <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/danvk/aoc2023&#39;, event);">my repo</a> as a template and guide.</p>
<p>Here are a few specific tips:</p>
<ul>
<li>Zig <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/issues/12161" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/ziglang/zig/issues/12161&#39;, event);">doesn&#39;t have a scanf equivalent</a> and <a target="_blank" rel="noopener" href="https://www.openmymind.net/Regular-Expressions-in-Zig/" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://www.openmymind.net/Regular-Expressions-in-Zig/&#39;, event);">regexes are inconvenient</a>. So for parsing inputs, it&#39;s split, split, split. I wound up factoring out a few <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/util.zig#L67" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/util.zig#L67&#39;, event);"><code>splitIntoBuf</code></a> and <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/util.zig#L19" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/util.zig#L19&#39;, event);"><code>extractIntsIntoBuf</code></a> helpers that made short work of reading the input for most of the problems.</li>
<li>Zig supports all sizes of ints, all the way up to <code>u65536</code>. If you&#39;re getting overflows, try using a bigger integer type. I used <code>u128</code> and <code>i128</code> on a few problems.</li>
<li><code>std.meta.stringToEnum</code> is a <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/day10.zig#L173" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/day10.zig#L173&#39;, event);">neat trick</a> for parsing a restricted set of strings or characters.</li>
<li>As mentioned above, you can define a <a target="_blank" rel="noopener" href="https://zig.guide/standard-library/formatting" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://zig.guide/standard-library/formatting&#39;, event);"><code>format</code> method</a> on your <code>struct</code>s to make them print however you like.</li>
<li>Try to avoid copying strings to use as keys in a <code>StringHashMap</code>. This feels natural coming from JS, but it&#39;s awkward in Zig because you need to keep track of those strings to free them later. If you can put your keys into a <code>struct</code> or a tuple, that will work better because they have value semantics. If you need strings, you might be able to use <a target="_blank" rel="noopener" href="https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/day15.zig" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/danvk/aoc2023/blob/6ca7725757f4d2fc347a79d350f6f7da80b8db73/src/day15.zig&#39;, event);">slices of your puzzle input</a>, as described above.</li>
<li>Watch out for off-by-one bugs with numeric ranges. If you want to include <code>max</code>, it&#39;s <code>min..(max+1)</code>, not <code>min..max</code>.</li>
<li>Your code is going to have a lot of <code>@intCast</code>. It&#39;s OK.</li>
<li>I found it odd that Zig has a built-in <code>PriorityQueue</code> but no built-in <code>Queue</code>. I wound up <a target="_blank" rel="noopener" href="https://ziglang.org/learn/samples/#generic-types" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://ziglang.org/learn/samples/#generic-types&#39;, event);">finding one online</a> that I could paste into my repo. <em>(Update: use <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/blob/9d9b5a11e873cc15e3f1b6e506ecf22c8380c87d/lib/std/linked_list.zig" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/ziglang/zig/blob/9d9b5a11e873cc15e3f1b6e506ecf22c8380c87d/lib/std/linked_list.zig&#39;, event);"><code>std.SinglyLinkedList</code></a>)</em></li>
<li>A lot of the functions you use to work with strings are in <code>std.mem</code>, e.g. <code>std.mem.eql</code> and <code>std.mem.startsWith</code>.</li>
<li>Use <code>std.meta.eql</code> to compare structs, not <code>==</code>.</li>
<li>There&#39;s a trick for slicing by offset and <em>length</em>: <code>array[start..][0..length]</code>.</li>
<li>It&#39;s often useful to memoize a function in Advent of Code. I have no idea if there&#39;s a general way to do this in Zig. (This led me to a unique solution that I was proud of on <a target="_blank" rel="noopener" href="https://adventofcode.com/2023/day/12" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://adventofcode.com/2023/day/12&#39;, event);">day 12</a>.)</li>
<li>Debug build are considerably slower than optimized builds, sometimes 10x. If you&#39;re within a factor of 10 of getting an answer in a reasonable amount of time, try a different release mode.</li>
<li>Don&#39;t mutate an <code>ArrayList</code> as you iterate through it. You might change what <code>.items</code> refers to, which will lead to chaos.</li>
<li>You may need to factor out a variable to clarify lifetimes in some situations where JavaScript would let you inline an expression. See <a target="_blank" rel="noopener" href="https://github.com/ziglang/zig/issues/12414" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://github.com/ziglang/zig/issues/12414&#39;, event);">this issue</a>.</li>
</ul>
<p>Here are a few other blog posts I found helpful in learning Zig for Advent of Code:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.openmymind.net/Zig-Quirks/" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://www.openmymind.net/Zig-Quirks/&#39;, event);">Zig Quirks</a></li>
<li><a target="_blank" rel="noopener" href="https://kristoff.it/blog/zig-multi-sequence-for-loops/" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://kristoff.it/blog/zig-multi-sequence-for-loops/&#39;, event);">Zig&#39;s Curious Multi-Sequence For Loops</a></li>
<li><a target="_blank" rel="noopener" href="https://cookbook.ziglang.cc/" onclick="return trackOutboundLink(&#39;tips for doing the advent of code in zig&#39;, &#39;https://cookbook.ziglang.cc/&#39;, event);">Zig Cookbook</a></li>
</ul>
<h2 id="Conclusions"><a href="#Conclusions" title="Conclusions"></a>Conclusions</h2><p>I thoroughly enjoyed doing the Advent of Code and I enjoyed learning Zig in the process. Zig and TypeScript occupy different niches and have different goals, but there are still a few things they can learn from each other.</p>
<p>There&#39;s less than five months until the 2024 Advent of Code starts! Which language will I use this year? After learning a bunch about <a target="_blank" rel="noopener" href="https://github.com/danvk/Stanford-CS-242-Programming-Languages" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://github.com/danvk/Stanford-CS-242-Programming-Languages&#39;, event);">programming languages</a> at <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink(&#39;conclusions&#39;, &#39;https://www.recurse.com/&#39;, event);">Recurse Center</a> this winter, I&#39;m thinking that I should just bite the bullet and use Haskell. We&#39;ll see how I feel about that in December!</p>
<hr/>

          </div></div>
  </body>
</html>
