<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/p4bl0-/9f4e950e6c06fbba7e168097d89b0e46">Original</a>
    <h1>Show HN: A compiler and VM for a simple language, in 150 lines of code</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-00_readme-md">
      
      <div id="file-00_readme-md-readme">
    <article itemprop="text"><p dir="auto">This project is a tiny compiler for a very simple language consisting of boolean expression.</p>
<p dir="auto">The language has two constants: <code>1</code> for true and <code>0</code> for false, and 4 logic gates:
<code>!</code> (not), <code>&amp;</code> (and), <code>|</code> (or), and <code>^</code> (xor).</p>
<p dir="auto">It can also use parentheses to manage priorities.</p>
<p dir="auto">Here is its grammar in BNF format:</p>
<pre><code>expr ::= &#34;0&#34; | &#34;1&#34;
       | &#34;!&#34; expr
       | expr &#34;&amp;&#34; expr
       | expr &#34;|&#34; expr
       | expr &#34;^&#34; expr
       | &#34;(&#34; expr &#34;)&#34;
</code></pre>
<p dir="auto">The goal is to compile it to a virtual machine bytecode.</p>
<p dir="auto">The virual machine has two registers (<code>acc</code> and <code>tmp</code>) and memory stack.</p>
<p dir="auto">The bytecode consists in 6 instructions:</p>
<ul dir="auto">
<li><code>t</code>: sets the acc register to 1</li>
<li><code>f</code>: sets the acc register to 0</li>
<li><code>s</code>: pushes the value of the acc register onto the stack</li>
<li><code>l</code>: pops the top value of the stack and write it to the acc register</li>
<li><code>h</code>: copies the value of the acc register into the tmp register</li>
<li><code>n</code>: sets the acc register to the value of acc nand tmp</li>
</ul>
<p dir="auto">This is sufficient because the nand gate is functionally complete:
<a href="https://en.wikipedia.org/wiki/Functional_completeness" rel="nofollow">https://en.wikipedia.org/wiki/Functional_completeness</a></p>
<p dir="auto">After lexing and parsing, we do not need any semantic analysis or type checking
because there are no names (e.g., no variables) and a single type.</p>
<p dir="auto">This is why we do not keep source location information in the parser&#39;s output.
In a more complex language (e.g., adding support for assignment to variables),
we would need an additional front-end pass after the parser.
This is not a lot to add, I could make it if asked to.</p>
<p dir="auto">The compilation strategy is to first use known formulas to translate the parsed
boolean expression into an equivalent expression that only uses <code>nand</code> gates.
(See <a href="https://en.wikipedia.org/wiki/NAND_logic" rel="nofollow">https://en.wikipedia.org/wiki/NAND_logic</a>)</p>
<p dir="auto">In a second pass, this (functional) expression is compiled down to (imperative)
bytecode instructions.</p>
<p dir="auto">This is were we can see actual compilation work: the paradigm shift from
functional &#34;high level&#34; to imperative &#34;low level&#34; forces us to implement
our language&#39;s abstractions (here, function call) using more primitive
constructs (stack and register manipulation).</p>
<p dir="auto">We can also see that the approach we use will generate non-optimal code,
because our compiler will always treat <code>nand</code> gates in the same way without
regard to the context (e.g. we would manually translate &#34;!1&#34; into &#34;thn&#34; but
our compiler will generate &#34;tsthln&#34;). An additional optimization pass that
look for such patterns and replace them with manually optimized ones would
be quite easy to make. I could also provide it if asked to.</p>
<p dir="auto">The VM is implemented in C.</p>
<p dir="auto">The compiler is implemented in OCaml.</p>
<p dir="auto">The lexer uses ocamllex, the parser uses menhir.</p>
<p dir="auto">Files need to be renamed without the numbers and underscore at the beginging of
their names, which are here so that they appear in the desired order in this gist.</p>
<p dir="auto">To compile the compiler: <code>ocamlbuild -use-menhir main.byte</code>.</p>
<p dir="auto">To compile the vm: <code>gcc nandvm.c -o nandvm</code>.</p>
<p dir="auto">Then you can for example run:</p>
<ul dir="auto">
<li><code>./main.byte &lt;&lt;&lt;&#34;1&#34; | ./nandvm</code></li>
<li><code>./main.byte &lt;&lt;&lt;&#34;!(0 ^ 1)&#34; | ./nandvm</code></li>
<li><code>./main.byte &lt;&lt;&lt;&#34;0 ^ (0 | 1) &amp; !(1 ^ 1)&#34; | ./nandvm</code></li>
</ul>
</article>
  </div>


  </div>
</div></div>
  </body>
</html>
