<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://floooh.github.io/2021/12/06/z80-instruction-timing.html#table-of-content">Original</a>
    <h1>Getting into way too much detail with the Z80 netlist simulation (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="https://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>TL;DR: a detailed look at Z80 instruction timings with the help of a 
Z80 netlist simulation.</p>

<h2 id="table-of-content">Table of Content</h2>

<ul id="markdown-toc">
  <li><a href="#table-of-content" id="markdown-toc-table-of-content">Table of Content</a></li>
  <li><a href="#intro" id="markdown-toc-intro">Intro</a></li>
  <li><a href="#the-shape-of-z80-instructions" id="markdown-toc-the-shape-of-z80-instructions">The shape of Z80 instructions</a></li>
  <li><a href="#general-instruction-timing" id="markdown-toc-general-instruction-timing">General Instruction Timing</a>    <ul>
      <li><a href="#m-cycles-and-t-states" id="markdown-toc-m-cycles-and-t-states">M-cycles and T-states</a></li>
      <li><a href="#opcode-fetch-machine-cycles" id="markdown-toc-opcode-fetch-machine-cycles">Opcode Fetch Machine Cycles</a></li>
      <li><a href="#memory-read-machine-cycles" id="markdown-toc-memory-read-machine-cycles">Memory Read Machine Cycles</a></li>
      <li><a href="#memory-write-machine-cycles" id="markdown-toc-memory-write-machine-cycles">Memory Write Machine Cycles</a></li>
      <li><a href="#io-read-and-write-machine-cycles" id="markdown-toc-io-read-and-write-machine-cycles">IO Read and Write Machine Cycles</a></li>
      <li><a href="#wait-states" id="markdown-toc-wait-states">Wait states</a></li>
      <li><a href="#extra-clock-cycles" id="markdown-toc-extra-clock-cycles">Extra Clock Cycles</a></li>
    </ul>
  </li>
  <li><a href="#overlapped-execution" id="markdown-toc-overlapped-execution">Overlapped Execution</a></li>
  <li><a href="#the-3-instruction-subsets" id="markdown-toc-the-3-instruction-subsets">The 3 Instruction Subsets</a></li>
  <li><a href="#the-2-3-3-opcode-bit-pattern" id="markdown-toc-the-2-3-3-opcode-bit-pattern">The 2-3-3 Opcode Bit Pattern</a></li>
  <li><a href="#main-instructions" id="markdown-toc-main-instructions">Main Instructions</a>    <ul>
      <li><a href="#main-quadrant-1-xx--01" id="markdown-toc-main-quadrant-1-xx--01">Main Quadrant 1 (xx = 01)</a></li>
      <li><a href="#main-quadrant-2-xx--10" id="markdown-toc-main-quadrant-2-xx--10">Main Quadrant 2 (xx = 10)</a></li>
      <li><a href="#main-quadrant-0-xx--00" id="markdown-toc-main-quadrant-0-xx--00">Main Quadrant 0 (xx = 00)</a>        <ul>
          <li><a href="#incdec-hl" id="markdown-toc-incdec-hl">INC/DEC (HL)</a></li>
          <li><a href="#incdec-ss" id="markdown-toc-incdec-ss">INC/DEC ss</a></li>
          <li><a href="#add-hlss" id="markdown-toc-add-hlss">ADD HL,ss</a></li>
          <li><a href="#jr-d" id="markdown-toc-jr-d">JR d</a></li>
          <li><a href="#djnz-d" id="markdown-toc-djnz-d">DJNZ d</a></li>
          <li><a href="#jr-ccd" id="markdown-toc-jr-ccd">JR cc,d</a></li>
        </ul>
      </li>
      <li><a href="#main-quadrant-3-xx--11" id="markdown-toc-main-quadrant-3-xx--11">Main Quadrant 3 (xx == 11)</a>        <ul>
          <li><a href="#call-nn" id="markdown-toc-call-nn">CALL nn</a></li>
          <li><a href="#call-ccnn" id="markdown-toc-call-ccnn">CALL cc,nn</a></li>
          <li><a href="#ret-cc" id="markdown-toc-ret-cc">RET cc</a></li>
          <li><a href="#ld-sphl" id="markdown-toc-ld-sphl">LD SP,HL</a></li>
          <li><a href="#ex-sphl" id="markdown-toc-ex-sphl">EX (SP),HL</a></li>
          <li><a href="#push-qq" id="markdown-toc-push-qq">PUSH qq</a></li>
          <li><a href="#rst-p" id="markdown-toc-rst-p">RST p</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#prefix-instruction-overview" id="markdown-toc-prefix-instruction-overview">Prefix Instruction Overview</a></li>
  <li><a href="#dd-and-fd-prefixes" id="markdown-toc-dd-and-fd-prefixes">DD and FD Prefixes</a>    <ul>
      <li><a href="#special-case-ld-ixdn" id="markdown-toc-special-case-ld-ixdn">Special Case: LD (IX+d),n</a></li>
    </ul>
  </li>
  <li><a href="#ed-prefix" id="markdown-toc-ed-prefix">ED Prefix</a>    <ul>
      <li><a href="#ed-quadrant-1-x--01" id="markdown-toc-ed-quadrant-1-x--01">ED Quadrant 1 (x == 01)</a>        <ul>
          <li><a href="#sbcadc-hlss" id="markdown-toc-sbcadc-hlss">SBC/ADC HL,ss</a></li>
          <li><a href="#ld-ia-and-ld-ra" id="markdown-toc-ld-ia-and-ld-ra">LD I,A and LD R,A</a></li>
          <li><a href="#ld-ai-and-ld-ar" id="markdown-toc-ld-ai-and-ld-ar">LD A,I and LD A,R</a></li>
          <li><a href="#rrd-and-rld" id="markdown-toc-rrd-and-rld">RRD and RLD</a></li>
        </ul>
      </li>
      <li><a href="#ed-quadrant-2-x--10" id="markdown-toc-ed-quadrant-2-x--10">ED Quadrant 2 (x == 10)</a>        <ul>
          <li><a href="#ldi-and-ldd" id="markdown-toc-ldi-and-ldd">LDI and LDD</a></li>
          <li><a href="#ldir-and-lddr" id="markdown-toc-ldir-and-lddr">LDIR and LDDR</a></li>
          <li><a href="#cpi-and-cpd" id="markdown-toc-cpi-and-cpd">CPI and CPD</a></li>
          <li><a href="#cpir-and-cpdr" id="markdown-toc-cpir-and-cpdr">CPIR and CPDR</a></li>
          <li><a href="#ini-and-ind" id="markdown-toc-ini-and-ind">INI and IND</a></li>
          <li><a href="#outi-and-outd" id="markdown-toc-outi-and-outd">OUTI and OUTD</a></li>
          <li><a href="#inir-indr-otir-and-otdr" id="markdown-toc-inir-indr-otir-and-otdr">INIR, INDR, OTIR and OTDR</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#cb-prefix" id="markdown-toc-cb-prefix">CB Prefix</a>    <ul>
      <li><a href="#cb-quadrant-0" id="markdown-toc-cb-quadrant-0">CB Quadrant 0</a></li>
      <li><a href="#cb-quadrant-1" id="markdown-toc-cb-quadrant-1">CB Quadrant 1</a></li>
      <li><a href="#cb-quadrant-2" id="markdown-toc-cb-quadrant-2">CB Quadrant 2</a></li>
      <li><a href="#cb-quadrant-3" id="markdown-toc-cb-quadrant-3">CB Quadrant 3</a></li>
    </ul>
  </li>
  <li><a href="#dd-cb-and-fd-cb-prefix" id="markdown-toc-dd-cb-and-fd-cb-prefix">DD CB and FD CB Prefix</a></li>
  <li><a href="#interrupt-behaviour" id="markdown-toc-interrupt-behaviour">Interrupt Behaviour</a>    <ul>
      <li><a href="#interrupt-detection-timing" id="markdown-toc-interrupt-detection-timing">Interrupt Detection Timing</a></li>
      <li><a href="#prefix-bytes-and-interrupts" id="markdown-toc-prefix-bytes-and-interrupts">Prefix Bytes and Interrupts</a></li>
      <li><a href="#ei-di-and-interrupts" id="markdown-toc-ei-di-and-interrupts">EI, DI and interrupts</a></li>
      <li><a href="#reti-and-retn" id="markdown-toc-reti-and-retn">RETI and RETN</a></li>
      <li><a href="#nmi-timing" id="markdown-toc-nmi-timing">NMI Timing</a></li>
      <li><a href="#mode-0-interrupt-timing" id="markdown-toc-mode-0-interrupt-timing">Mode 0 Interrupt Timing</a></li>
      <li><a href="#mode-1-interrupt-timing" id="markdown-toc-mode-1-interrupt-timing">Mode 1 Interrupt Timing</a></li>
      <li><a href="#mode-2-interrupt-timing" id="markdown-toc-mode-2-interrupt-timing">Mode 2 Interrupt Timing</a></li>
    </ul>
  </li>
</ul>

<h2 id="intro">Intro</h2>

<p>This is part one of a two-part series about a new cycle-stepped Z80 emulator
I wrote recently. In the first post I’ll mainly take a look at the oddities and
irregularities in the Z80 instruction set with the help of the Z80 netlist
simulation from <a href="http://www.visual6502.org/JSSim/expert-z80.html">visual6502.org</a>
which I integrated into my own ‘remix’ before starting to work on the actual
CPU emulator:</p>

<p><a href="https://floooh.github.io/visualz80remix/">https://floooh.github.io/visualz80remix/</a></p>

<p>The ‘remix’ has some usability advantages over the original:</p>

<ul>
  <li>rendering and UI performance is much improved via WASM, WebGL and Dear ImGui</li>
  <li>an integrated assembler simplifies program input</li>
  <li>a tracelog window which shows more information and allows to ‘rewind’ the simulation</li>
</ul>

<p>There’s a lot more information in the project readme here: <a href="https://github.com/floooh/v6502r">https://github.com/floooh/v6502r</a>.</p>

<p>A word of warning though, the Z80 netlist from visual6502 has some subtle
differences in undocumented behaviour from what’s known about original Z80s
(see here for a list of issues I found so far:
<a href="https://github.com/floooh/v6502r/issues/2">https://github.com/floooh/v6502r/issues/2</a>. My guess is that the netlist has
been created from a Z8400 because of those two details found on the die:</p>

<p><img src="https://floooh.github.io/images/z80_detail.jpg" alt="z80_detail"/></p>

<p><img src="https://floooh.github.io/images/z80_detail_2.jpg" alt="z80_detail_2"/></p>

<p>…at least this might explain why the netlist doesn’t suffer from the six
‘reverse engineering traps’ that were placed on the original Z80.  By the time
the Z8400 was created, the Z80 had already been widely cloned so reverse
engineering probably was no longer a concern.</p>

<p>Anyway, back to the actual topic of the blog post:</p>

<p>The Z80 has probably the most messy and irregular instruction set of the popular
8-bit CPUs (certainly when compared to the MOS 6502 or Motorola 6800). The reason
is that the Z80 had to be binary compatible with the Intel 8080. While the 8080
has a reasonably clean and structured instruction set, the only way for the Z80
to add new instructions while remaining 8080-compatible was to fill the ‘gaps’ 
in the 8080 instruction set.</p>

<p>This is why the Z80 instruction set looks clean and structured only in some places
(mainly those inherited from the 8080), while at the same time being peppered
with seemingly random new Z80-specific instructions. This was the right approach
to create an “8080 killer”, but nearly half a century later it makes life a lot
harder for emulator authors :)</p>

<h2 id="the-shape-of-z80-instructions">The shape of Z80 instructions</h2>

<p>Like on the Intel 8080, instructions are made up of one or multiple bytes, where
the first byte is always the opcode byte.</p>

<p>This simple rule is also true for the Z80-specific ‘prefixed instructions’, which
superficially seem to have two opcode bytes. But as we’ll see later, instruction
prefixes are actually complete instructions on their own which just influence how
the following opcode byte is decoded.</p>

<p>Prefixes aside, there are only three basic instruction ‘shapes’:</p>

<p>Just the opcode byte (for example <strong>NOP</strong>, <strong>LD A,B</strong>, <strong>RET</strong>):</p>
<div><div><pre><code>┏━━━━━━━━┓
┃ OPCODE ┃
┗━━━━━━━━┛
    C9      =&gt; RET
</code></pre></div></div>

<p>An opcode byte followed by an 8-bit ‘immediate value’ (for example <strong>LD A,n</strong>, <strong>ADD n</strong>, <strong>JR d</strong>):</p>
<div><div><pre><code>┏━━━━━━━━┳━━━━━━┓
┃ OPCODE ┃ IMM8 ┃
┗━━━━━━━━┻━━━━━━┛
    3E      11      =&gt; LD A,11h
</code></pre></div></div>

<p>An opcode byte followed by a 16-bit immediate value (in little endian order):
<strong>LD HL,nnnn</strong>, <strong>CALL nn</strong>):</p>
<div><div><pre><code>┏━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┓
┃ OPCODE ┃ IMM16LO ┃ IMM16HI ┃
┗━━━━━━━━┻━━━━━━━━━┻━━━━━━━━━┛
    21       34         12      =&gt; LD HL,1234h
</code></pre></div></div>

<p>Instructions that have been ‘modified’ by the DD or FD prefix may come in two additional
shapes where an offset byte is inserted after the opcode and up to one immediate value byte
(this is the ‘d’ in <strong>(IX+d)</strong> or <strong>(IY+d)</strong>). There is no instruction where the d-offset byte
is followed by a 16-bit immediate value (why that’s the case will become clear later in the
section about the DD/FD prefixes):</p>
<div><div><pre><code>┏━━━━━━━━┓┏━━━━━━━━┳━━━━━━━┓
┃ PREFIX ┃┃ OPCODE ┃ DIMM8 ┃
┗━━━━━━━━┛┗━━━━━━━━┻━━━━━━━┛
    DD        86      03        =&gt; ADD A,(IX+3)

┏━━━━━━━━┓┏━━━━━━━━┳━━━━━━━┳━━━━━━┓
┃ PREFIX ┃┃ OPCODE ┃ DIMM8 ┃ IMM8 ┃
┗━━━━━━━━┛┗━━━━━━━━┻━━━━━━━┻━━━━━━┛
    FD        36      03      11        =&gt; LD (IY+3),11h
</code></pre></div></div>

<p>The last special instruction shape looks extremely weird because at first glance it doesn’t
fit into the above patterns at all. In ‘double-prefixed’ instructions (like <strong>SET 1,(IX+3)</strong>)
the d-offset and ‘actual’ opcode have switched places:</p>
<div><div><pre><code>┏━━━━━━━━┓┏━━━━━━━━┓┏━━━━━━━┳━━━━━━━━┓
┃ PREFIX ┃┃ PREFIX ┃┃ DIMM8 ┃ OPCODE ┃
┗━━━━━━━━┛┗━━━━━━━━┛┗━━━━━━━┻━━━━━━━━┛
    DD        CB       03       CE      =&gt; SET 1,(IX+3)
</code></pre></div></div>

<p>More on that later in the dedicated section about <strong>DD CB</strong> and <strong>FD CB</strong> double-prefixes.</p>

<h2 id="general-instruction-timing">General Instruction Timing</h2>

<h3 id="m-cycles-and-t-states">M-cycles and T-states</h3>

<p>The above ‘physical shape’ of Z80 instructions doesn’t tell us much what actually happens
during execution of an instruction (e.g. how many clock cycles the instruction takes to execute,
and how the internal and externally visible state of the CPU changes during execution).</p>

<p>The Z80 netlist simulation is perfect for this because it allows us to inspect the internal
and observable CPU state after each clock cycle (or rather: after each <strong>half</strong>-clock-cycle).</p>

<p>But first an explanation of another Z80 oddity: When reading Z80 documentation there’s
a lot of talk about so called “M-cycles” and “T-states”, often written as <strong>M1/T2</strong> or
<strong>M3/T1</strong> which confused me to no end in the beginning.</p>

<p>Long story short:</p>

<p><strong>M1/T2</strong> simply means “the second clock cycle (T2) in the first machine cycle (M1)”, likewise,
<strong>M3/T1</strong> means “the first clock cycle (T1) in the third machine cycle (M3)”.</p>

<p>So M-cycles and T-states are just a special notation to identify a specific clock cycle in an instruction.</p>

<p>“T-state” is equivalent with a clock cycle.</p>

<p>“M-Cycle” means “machine cycle” and simply means a related group of T-states or
clock cycles. On the Z80, basic operations like reading or writing a memory byte
take more time than a single clock cycle. But it’s useful to understand the
action of reading or writing a memory byte as a single step, and that’s exactly
what a “machine cycle” is.</p>

<p>Machine cycles come in 7 flavours:</p>

<ul>
  <li><strong>Opcode Fetch</strong> (aka M1 cycle): this is always the first (and sometimes only) machine
cycle in an instruction and takes 4 clock cycles</li>
  <li><strong>Memory Read</strong>: read a byte from memory (3 clock cycles)</li>
  <li><strong>Memory Write</strong>: write a byte to memory (3 clock cycles)</li>
  <li><strong>IO Read</strong>: read a byte from an IO port (4 clock cycles)</li>
  <li><strong>IO Write</strong>: write a byte to an IO port (4 clock cycles)</li>
  <li><strong>Interrupt Acknowledge</strong>: these are special machine cycles which are executed at the start
of maskable interrupt handling, they will be handled in detail in the last section of this blog post</li>
  <li><strong>Extra</strong>: many instructions contain extra clock cycles necessary for computations, in the official
CPU documentation these are sometimes identified as separate machine cycles, and sometimes just
lumped together with other machine cycle types.</li>
</ul>

<p>Since machine cycles are the basic building blocks of all instructions, it helps to understand
what exactly happens during their execution.</p>

<p>This is where the ‘tracelog’ of the Z80 netlist simulation comes in. This is a window which records
and visualizes CPU state (chip pins and register values) for each “half-clock-cycle”:</p>

<p><img src="https://floooh.github.io/images/z80_tracelog.jpg" alt="z80_tracelog"/></p>

<h3 id="opcode-fetch-machine-cycles">Opcode Fetch Machine Cycles</h3>

<p>An <strong>Opcode Fetch</strong> looks like this in the tracelog (with all the relevant CPU state visible):</p>

<div><div><pre><code>OPCODE FETCH:
┌─────┬────┬──────┬──────┬────┬──────┬────┬──────┬────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ AB   │ DB │ PC   │ IR │ I  │ R  │
├─────┼────┼──────┼──────┼────┼──────┼────┼──────┼────┼────┼────┤
│ 1/0 │ M1 │      │      │    │ 0004 │ 47 │ 0004 │ 47 │ 22 │ 03 │
│ 1/1 │ M1 │ MREQ │      │ RD │ 0004 │ 47 │ 0005 │ 47 │ 22 │ 03 │
│ 2/0 │ M1 │ MREQ │      │ RD │ 0004 │ 00 │ 0005 │ 47 │ 22 │ 03 │
│ 2/1 │ M1 │ MREQ │      │ RD │ 0004 │ 00 │ 0005 │ 00 │ 22 │ 03 │
│ 3/0 │    │      │ RFSH │    │ 2203 │ 00 │ 0005 │ 00 │ 22 │ 03 │
│ 3/1 │    │ MREQ │ RFSH │    │ 2203 │ 00 │ 0005 │ 00 │ 22 │ 04 │
│ 4/0 │    │ MREQ │ RFSH │    │ 2203 │ 00 │ 0005 │ 00 │ 22 │ 04 │
│ 4/1 │    │      │ RFSH │    │ 2200 │ 00 │ 0005 │ 00 │ 22 │ 04 │
</code></pre></div></div>

<p>Keep in mind that this shows half-clock-cycles, a 4-clock-cycle opcode-fetch machine
cycle is shown as 8 half-clock-cycles in the trace log.</p>

<p>The <strong>M1, MREQ, RFSH and RD</strong> columns show the current state of the respective CPU
pins.</p>

<p><strong>AB</strong> and <strong>DB</strong> are “address bus” and “data bus”. <strong>IR</strong> is an internal register
which holds the current opcode byte. <strong>I</strong> and <strong>R</strong> are the respective CPU registers
(I is the upper byte of the interrupt vector, R is the ‘refresh counter’ register).</p>

<p>Let’s go through each half-cycle of an opcode-fetch machine cycle:</p>

<div><div><pre><code>┌─────┬────┬──────┬──────┬────┬──────┬────┬──────┬────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ AB   │ DB │ PC   │ IR │ I  │ R  │
├─────┼────┼──────┼──────┼────┼──────┼────┼──────┼────┼────┼────┤
│ 1/0 │ M1 │      │      │    │ 0004 │ 47 │ 0004 │ 47 │ 22 │ 03 │
</code></pre></div></div>
<p>The M1 pin is set to active, and the address bus has been loaded with
the current program counter (PC). The data bus and instruction register
still have their values from the last instruction (which happened
to an <strong>LD I,A</strong> instruction (byte sequence: ED 47).</p>

<div><div><pre><code>┌─────┬────┬──────┬──────┬────┬──────┬────┬──────┬────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ AB   │ DB │ PC   │ IR │ I  │ R  │
├─────┼────┼──────┼──────┼────┼──────┼────┼──────┼────┼────┼────┤
│ 1/1 │ M1 │ MREQ │      │ RD │ 0004 │ 47 │ 0005 │ 47 │ 22 │ 03 │
</code></pre></div></div>
<p>In the next half cycle, the MREQ and RD pins have been set in addition
to M1, which initiates a memory read from the address that’s currently
on the address bus (0004). The program counter has been incremented
to the next address.</p>

<div><div><pre><code>┌─────┬────┬──────┬──────┬────┬──────┬────┬──────┬────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ AB   │ DB │ PC   │ IR │ I  │ R  │
├─────┼────┼──────┼──────┼────┼──────┼────┼──────┼────┼────┼────┤
│ 2/0 │ M1 │ MREQ │      │ RD │ 0004 │ 00 │ 0005 │ 47 │ 22 │ 03 │
</code></pre></div></div>
<p>Now the memory system has responded to the <strong>MREQ|RD</strong> pins being active by
putting the content of address 0004 onto the data bus, which happens to be 00
(which is a NOP instruction). The instruction register hasn’t been updated yet.</p>

<div><div><pre><code>┌─────┬────┬──────┬──────┬────┬──────┬────┬──────┬────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ AB   │ DB │ PC   │ IR │ I  │ R  │
├─────┼────┼──────┼──────┼────┼──────┼────┼──────┼────┼────┼────┤
│ 2/1 │ M1 │ MREQ │      │ RD │ 0004 │ 00 │ 0005 │ 00 │ 22 │ 03 │
</code></pre></div></div>
<p>In the next half cycle the 00 value on the data bus has been
written into the instruction register (IR). This concludes the first
half of the opcode fetch machine cycle.</p>

<div><div><pre><code>┌─────┬────┬──────┬──────┬────┬──────┬────┬──────┬────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ AB   │ DB │ PC   │ IR │ I  │ R  │
├─────┼────┼──────┼──────┼────┼──────┼────┼──────┼────┼────┼────┤
│ 3/0 │    │      │ RFSH │    │ 2203 │ 00 │ 0005 │ 00 │ 22 │ 03 │
│ 3/1 │    │ MREQ │ RFSH │    │ 2203 │ 00 │ 0005 │ 00 │ 22 │ 04 │
│ 4/0 │    │ MREQ │ RFSH │    │ 2203 │ 00 │ 0005 │ 00 │ 22 │ 04 │
│ 4/1 │    │      │ RFSH │    │ 2200 │ 00 │ 0005 │ 00 │ 22 │ 04 │
</code></pre></div></div>
<p>The remaining 4 half-cycles (2 clock cycles) are spent with the Z80-specific
‘memory refresh’. A 16-bit value made from the registers I and R is put on the
address bus, the M1 pin is set to inactive, the MREQ|RFSH pins to active and
the R register is incremented. I haven’t figured out so far why the lower 8
bits on the address bus are cleared in the very last half-clock-cycle (this
also happens in the last half-cycle of some other instructions).</p>

<p>Let’s quickly go over the remaining machine cycle types for completeness:</p>

<h3 id="memory-read-machine-cycles">Memory Read Machine Cycles</h3>

<p>A <strong>memory read</strong> machine cycle looks like this (in this case to load the byte value 22 from
address 0001 into the register L):</p>
<div><div><pre><code>MEM READ:
┌─────┬──────┬────┬──────┬────┬──────┐
│  T  │ MREQ │ RD │ AB   │ DB │ HL   │
├─────┼──────┼────┼──────┼────┼──────┤
│ 1/0 │      │    │ 0001 │ 21 │ 5555 │ &lt;== address 0001 on address bus
│ 1/1 │ MREQ │ RD │ 0001 │ 21 │ 5555 │ &lt;== MREQ|RD active
│ 2/0 │ MREQ │ RD │ 0001 │ 22 │ 5555 │ &lt;== memory content 22 on data bus
│ 2/1 │ MREQ │ RD │ 0001 │ 22 │ 5555 │
│ 3/0 │ MREQ │ RD │ 0001 │ 22 │ 5555 │
│ 3/1 │      │    │ 0000 │ 22 │ 5522 │ &lt;== target register L updated
</code></pre></div></div>

<h3 id="memory-write-machine-cycles">Memory Write Machine Cycles</h3>

<p>Here’s a <strong>memory write</strong> machine cycle to store the value in register A (33)
into the address in register HL (1122):</p>

<div><div><pre><code>MEM WRITE:
┌─────┬──────┬────┬──────┬────┬──────┬──────┐
│  T  │ MREQ │ WR │ AB   │ DB │ AF   │ HL   │
├─────┼──────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │      │    │ 1122 │ 77 │ 3355 │ 1122 │ &lt;== address 1122 on address bus
│ 1/1 │ MREQ │    │ 1122 │ 33 │ 3355 │ 1122 │ &lt;== value 33 on data bus
│ 2/0 │ MREQ │    │ 1122 │ 33 │ 3355 │ 1122 │
│ 2/1 │ MREQ │ WR │ 1122 │ 33 │ 3355 │ 1122 │ &lt;== MREQ|WR active
│ 3/0 │ MREQ │ WR │ 1122 │ 33 │ 3355 │ 1122 │
│ 3/1 │      │    │ 1122 │ 33 │ 3355 │ 1122 │
</code></pre></div></div>
<p>Note how the MREQ pin, address and data bus already contain the required values in
the second half cycle (T1/1), but the WR (write) pin is only set active in the
4th half cycle (T2/1).</p>

<h3 id="io-read-and-write-machine-cycles">IO Read and Write Machine Cycles</h3>

<p>The IO read and write machine cycles look similar, but are one clock cycle longer,
and setting the CPU pins is delayed by a half-clock-cycle.</p>

<div><div><pre><code>IO READ:
┌─────┬──────┬────┬────┬──────┬────┐
│  T  │ IORQ │ RD │ WR │ AB   │ DB │
├─────┼──────┼────┼────┼──────┼────┤
│ 1/0 │      │    │    │ 1122 │ 78 │
│ 1/1 │      │    │    │ 1122 │ 78 │ 
│ 2/0 │ IORQ │ RD │    │ 1122 │ 33 │
│ 2/1 │ IORQ │ RD │    │ 1122 │ 33 │
│ 3/0 │ IORQ │ RD │    │ 1122 │ 33 │
│ 3/1 │ IORQ │ RD │    │ 1122 │ 33 │
│ 4/0 │ IORQ │ RD │    │ 1122 │ 33 │
│ 4/1 │      │    │    │ 1122 │ 33 │
</code></pre></div></div>

<div><div><pre><code>IO WRITE:
┌─────┬──────┬────┬────┬──────┬────┐
│  T  │ IORQ │ RD │ WR │ AB   │ DB │
├─────┼──────┼────┼────┼──────┼────┤
│ 1/0 │      │    │    │ 1122 │ 79 │
│ 1/1 │      │    │    │ 1122 │ 21 │
│ 2/0 │ IORQ │    │ WR │ 1122 │ 21 │
│ 2/1 │ IORQ │    │ WR │ 1122 │ 21 │
│ 3/0 │ IORQ │    │ WR │ 1122 │ 21 │
│ 3/1 │ IORQ │    │ WR │ 1122 │ 21 │
│ 4/0 │ IORQ │    │ WR │ 1122 │ 21 │
│ 4/1 │      │    │    │ 1122 │ 21 │
</code></pre></div></div>
<p>It’s interesting here that the ‘pin timing’ is identical between IO reads and
writes. The WR pin is activated at the same moment as the IORQ pin, while in
memory read machine cycles, the WR pin is activated two half cycles after the
MREQ pin.</p>

<h3 id="wait-states">Wait states</h3>

<p>All machine cycles that access memory or IO ports check the WAIT input pin at
exactly one half-clock-cycle. If the WAIT pin is active, the execution
‘freezes’ until the WAIT pin goes inactive. The original intent was to give
slow memory and IO devices time to react, but some computer systems also use
wait states in more creative ways to arbitrate memory access between CPU and
video hardware (for instance on the Amstrad CPC).</p>

<p>The exact (half-)clock cycle where the wait pin is sampled depends on the machine cycle
type.</p>

<p>In the opcode fetch machine cycle, the wait pin is sampled in the second half-cycle
of T2. If the WAIT pin isn’t active in this exact half-cycle, the CPU will not enter
wait mode, otherwise the CPU will insert extra ‘wait cycles’ until the
WAIT pin goes inactive.</p>

<p>For instance if the WAIT pin is only active in the second half cycle of T2, the opcode
fetch machine cycle will be stretched from 4 to 5 clock cycles:</p>

<div><div><pre><code>OPCODE FETCH:
┌─────┬────┬──────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼────┼──────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │ M1 │      │      │    │    │      │ 0000 │ 00 │
│ 1/1 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 00 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ WAIT │ 0000 │ 31 │ &lt;== WAIT pin sampled here
│ 3/0 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │ &lt;== one extra clock cycle inserted
│ 3/1 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │ 
│ 4/0 │    │      │ RFSH │    │    │      │ 0000 │ 31 │ &lt;== regular execution continues here
│ 4/1 │    │ MREQ │ RFSH │    │    │      │ 0000 │ 31 │
│ 5/0 │    │ MREQ │ RFSH │    │    │      │ 0000 │ 31 │
│ 5/1 │    │      │ RFSH │    │    │      │ 0000 │ 31 │
</code></pre></div></div>

<p>If the wait pin goes inactive in the first half cycle, the CPU will leave the wait state mode
at the end of the clock cycle:</p>

<div><div><pre><code>OPCODE FETCH:
┌─────┬────┬──────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼────┼──────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │ M1 │      │      │    │    │      │ 0000 │ 00 │
│ 1/1 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 00 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ WAIT │ 0000 │ 31 │ &lt;== WAIT pin sampled here
│ 3/0 │ M1 │ MREQ │      │ RD │    │ WAIT │ 0000 │ 31 │ &lt;== WAIT pin active for 2 half cycles
│ 3/1 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │ &lt;== extra clock cycle completes
│ 4/0 │    │      │ RFSH │    │    │      │ 0000 │ 31 │ &lt;== regular execution continues here
│ 4/1 │    │ MREQ │ RFSH │    │    │      │ 0000 │ 31 │
│ 5/0 │    │ MREQ │ RFSH │    │    │      │ 0000 │ 31 │
│ 5/1 │    │      │ RFSH │    │    │      │ 0000 │ 31 │
</code></pre></div></div>

<p>Setting the WAIT pin until the second half cycle causes one more clock cycle to be inserted:</p>

<div><div><pre><code>OPCODE FETCH:
┌─────┬────┬──────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼────┼──────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │ M1 │      │      │    │    │      │ 0000 │ 00 │
│ 1/1 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 00 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ WAIT │ 0000 │ 31 │ &lt;== WAIT pin sampled here
│ 3/0 │ M1 │ MREQ │      │ RD │    │ WAIT │ 0000 │ 31 │ &lt;== WAIT pin active for 3 half cycles
│ 3/1 │ M1 │ MREQ │      │ RD │    │ WAIT │ 0000 │ 31 │ &lt;== first inserted clock cycle completes
│ 4/0 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │ &lt;== a second wait clock cycle is inserted    
│ 4/1 │ M1 │ MREQ │      │ RD │    │      │ 0000 │ 31 │
│ 5/0 │    │      │ RFSH │    │    │      │ 0000 │ 31 │ &lt;== regular execution continues here
│ 5/1 │    │ MREQ │ RFSH │    │    │      │ 0000 │ 31 │
│ 6/0 │    │ MREQ │ RFSH │    │    │      │ 0000 │ 31 │
│ 6/1 │    │      │ RFSH │    │    │      │ 0000 │ 31 │
</code></pre></div></div>

<p>In memory-read machine-cycles, the WAIT pin is sampled at the second
half cycle of T2 (same as in an opcode fetch).</p>
<div><div><pre><code>MEM READ:
┌─────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ MREQ │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │      │    │    │      │ 0001 │ 31 │
│ 1/1 │ MREQ │ RD │    │      │ 0001 │ 31 │
│ 2/0 │ MREQ │ RD │    │      │ 0001 │ 30 │
│ 2/1 │ MREQ │ RD │    │ WAIT │ 0001 │ 30 │ &lt;== WAIT pin sampled here
│ 3/0 │ MREQ │ RD │    │      │ 0001 │ 30 │ &lt;== extra clock cycle
│ 3/1 │ MREQ │ RD │    │      │ 0001 │ 30 │
│ 4/0 │ MREQ │ RD │    │      │ 0001 │ 30 │ &lt;== regular execution continues
│ 4/1 │      │    │    │      │ 0000 │ 30 │
</code></pre></div></div>

<p>In memory write machine cycles, the WAIT pin is also sampled at the
second half cycle of T2:</p>

<div><div><pre><code>MEM WRITE:
┌─────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ MREQ │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │      │    │    │      │ 1234 │ 77 │
│ 1/1 │ MREQ │    │    │      │ 1234 │ 11 │
│ 2/0 │ MREQ │    │    │      │ 1234 │ 11 │
│ 2/1 │ MREQ │    │ WR │ WAIT │ 1234 │ 11 │ &lt;== WAIT pin sampled here
│ 3/0 │ MREQ │    │ WR │      │ 1234 │ 11 │ &lt;== extra clock cycle
│ 3/1 │ MREQ │    │ WR │      │ 1234 │ 11 │
│ 4/0 │ MREQ │    │ WR │      │ 1234 │ 11 │ &lt;== regular execution continues
│ 4/1 │      │    │    │      │ 1234 │ 11 │
</code></pre></div></div>

<p>In IO read and write machine cycles, the WAIT pin is sampled one full clock 
cycle later, at the second half-cycle of T3:</p>
<div><div><pre><code>IO READ:
┌─────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ IORQ │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │      │    │    │      │ 1234 │ 78 │
│ 1/1 │      │    │    │      │ 1234 │ 78 │
│ 2/0 │ IORQ │ RD │    │      │ 1234 │ FF │
│ 2/1 │ IORQ │ RD │    │      │ 1234 │ FF │
│ 3/0 │ IORQ │ RD │    │      │ 1234 │ FF │
│ 3/1 │ IORQ │ RD │    │ WAIT │ 1234 │ FF │ &lt;== WAIT pin sampled here
│ 4/0 │ IORQ │ RD │    │      │ 1234 │ FF │ &lt;== extra clock cycle
│ 4/1 │ IORQ │ RD │    │      │ 1234 │ FF │
│ 5/0 │ IORQ │ RD │    │      │ 1234 │ FF │ &lt;== regular execution continues
│ 5/1 │      │    │    │      │ 1234 │ FF │
</code></pre></div></div>

<div><div><pre><code>IO WRITE:
┌─────┬──────┬────┬────┬──────┬──────┬────┐
│  T  │ IORQ │ RD │ WR │ WAIT │ AB   │ DB │
├─────┼──────┼────┼────┼──────┼──────┼────┤
│ 1/0 │      │    │    │      │ 1234 │ 79 │
│ 1/1 │      │    │    │      │ 1234 │ 11 │
│ 2/0 │ IORQ │    │ WR │      │ 1234 │ 11 │
│ 2/1 │ IORQ │    │ WR │      │ 1234 │ 11 │
│ 3/0 │ IORQ │    │ WR │      │ 1234 │ 11 │
│ 3/1 │ IORQ │    │ WR │ WAIT │ 1234 │ 11 │ &lt;== WAIT pin sampled here
│ 4/0 │ IORQ │    │ WR │      │ 1234 │ 11 │ &lt;== extra clock cycle
│ 4/1 │ IORQ │    │ WR │      │ 1234 │ 11 │
│ 5/0 │ IORQ │    │ WR │      │ 1234 │ 11 │ &lt;== regular execution continues
│ 5/1 │      │    │    │      │ 1234 │ 11 │
</code></pre></div></div>



<p>With the knowledge that machine cycles are the basic building blocks of instructions, and
the length of those machine cycles we should be able to predict the number
of clock cycles in an instruction.</p>

<p>For instance <strong>LD HL,nnnn</strong> (load 16-bit immediate value into register pair <strong>HL</strong>)
consists of the following machine cycles</p>

<ol>
  <li>opcode fetch (4 clock cycles) to read the opcode byte</li>
  <li>a memory read (3 clock cycles) to read the next byte into L</li>
  <li>and another memory read (3 clock cycles) to read the next byte into H</li>
</ol>

<p>Together: <strong>4 + 3 + 3 = 10 clock cycles</strong>, which is totally correct.</p>

<p>The instruction <strong>PUSH HL</strong> (push content of HL register on the stack) should be the same,
except that memory reads are replaced with memory writes:</p>

<ol>
  <li>opcode fetch (4 clock cycles)</li>
  <li>a memory write to write H to the stack</li>
  <li>another memory write to write L to the stack</li>
</ol>

<p>This <em>should</em> take 10 clock cycles too, but <strong>PUSH HL</strong> actually takes 11 clock cycles
to execute:</p>
<div><div><pre><code>PUSH HL:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ HL   │ SP   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0006 │ 12 │ 1234 │ 0100 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ 12 │ 1234 │ 0100 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0006 │ E5 │ 1234 │ 0100 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ E5 │ 1234 │ 0100 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ E5 │ 1234 │ 0100 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ E5 │ 1234 │ 0100 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ E5 │ 1234 │ 0100 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ E5 │ 1234 │ 0100 │
│ 5/0 │    │      │      │    │    │ 0002 │ E5 │ 1234 │ 0100 │ &lt;== WTF???
│ 5/1 │    │      │      │    │    │ 0000 │ E5 │ 1234 │ 00FF │ &lt;== WTF???
│ 6/0 │    │      │      │    │    │ 00FF │ E5 │ 1234 │ 00FF │ &lt;== memory write
│ 6/1 │    │ MREQ │      │    │    │ 00FF │ 12 │ 1234 │ 00FF │
│ 7/0 │    │ MREQ │      │    │    │ 00FF │ 12 │ 1234 │ 00FF │
│ 7/1 │    │ MREQ │      │    │ WR │ 00FF │ 12 │ 1234 │ 00FE │
│ 8/0 │    │ MREQ │      │    │ WR │ 00FF │ 12 │ 1234 │ 00FE │
│ 8/1 │    │      │      │    │    │ 00FE │ 12 │ 1234 │ 00FE │
│ 9/0 │    │      │      │    │    │ 00FE │ E5 │ 1234 │ 00FE │ &lt;== memory write
│ 9/1 │    │ MREQ │      │    │    │ 00FE │ 34 │ 1234 │ 00FE │
│10/0 │    │ MREQ │      │    │    │ 00FE │ 34 │ 1234 │ 00FE │
│10/1 │    │ MREQ │      │    │ WR │ 00FE │ 34 │ 1234 │ 00FE │
│11/0 │    │ MREQ │      │    │ WR │ 00FE │ 34 │ 1234 │ 00FE │
│11/1 │    │      │      │    │    │ 00FE │ 34 │ 1234 │ 00FE │
</code></pre></div></div>

<p>There’s an additional clock cycle squeezed inbetween the opcode fetch and
first memory read machine cycle which is used to ‘pre-decrement’
the <strong>SP</strong> register before the memory write machine cycles can happen.</p>

<p>It’s little irregularities like this which complicate writing a Z80 emulator.
In a cycle correct emulator it is not only important that instructions
take the correct number of clock cycles to execute, but also that
memory and IO reads/writes happen at the correct clock cycle within
the instruction.</p>

<h2 id="overlapped-execution">Overlapped Execution</h2>

<p>In some instructions, execution ‘leaks’ into the opcode fetch machine cycle
of the next instruction.</p>

<p>For instance when inspecting the instruction ‘XOR A’ (which clears the A register
and sets flags accordingly) the instruction doesn’t seem to have any effect:</p>

<div><div><pre><code>XOR A:
┌─────┬────┬──────┬──────┬────┬────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AF   │ Flags    │
├─────┼────┼──────┼──────┼────┼────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ FFAC │ SzYhXVnc │
│ 1/1 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │
│ 3/0 │    │      │ RFSH │    │    │ FFAC │ SzYhXVnc │
│ 3/1 │    │ MREQ │ RFSH │    │    │ FFAC │ SzYhXVnc │
│ 4/0 │    │ MREQ │ RFSH │    │    │ FFAC │ SzYhXVnc │
│ 4/1 │    │      │ RFSH │    │    │ FFAC │ SzYhXVnc │ &lt;== A and Flags not modified!
                                     ^^     ^^^^^^^^
</code></pre></div></div>

<p><strong>XOR A</strong> takes 4 clock cycles, yet at the end of the instruction A isn’t zero,
and the flag bits haven’t been updated either. Here’s the same diagram including
the <strong>NOP</strong> instruction that follows:</p>

<div><div><pre><code>XOR A + NOP:
┌─────┬────┬──────┬──────┬────┬────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AF   │ Flags    │
├─────┼────┼──────┼──────┼────┼────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ FFAC │ SzYhXVnc │ &lt;== XOR A start
│ 1/1 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │ 
│ 2/0 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │ 
│ 2/1 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │ 
│ 3/0 │    │      │ RFSH │    │    │ FFAC │ SzYhXVnc │ 
│ 3/1 │    │ MREQ │ RFSH │    │    │ FFAC │ SzYhXVnc │ 
│ 4/0 │    │ MREQ │ RFSH │    │    │ FFAC │ SzYhXVnc │ 
│ 4/1 │    │      │ RFSH │    │    │ FFAC │ SzYhXVnc │ 
├─────┼────┼──────┼──────┼────┼────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ FFAC │ SzYhXVnc │ &lt;== NOP starts here
│ 1/1 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │ 
│ 2/0 │ M1 │ MREQ │      │ RD │    │ FFAC │ SzYhXVnc │ 
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 00AC │ SzYhXVnc │ &lt;== A updated here
│ 3/0 │    │      │ RFSH │    │    │ 00AC │ SzYhXVnc │ 
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0044 │ sZyhxVnc │ &lt;== flags updated here 
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0044 │ sZyhxVnc │ 
│ 4/1 │    │      │ RFSH │    │    │ 0044 │ sZyhxVnc │ 
</code></pre></div></div>

<p>The results of the <strong>XOR A</strong> instruction only become available
at the end of the second and third clock cycles of the following instruction.</p>

<p>Thankfully this overlapped execution is hardly relevant for CPU
emulators, because it only affects the internal state of the CPU, not any state
that’s observable from the outside.</p>

<h2 id="the-3-instruction-subsets">The 3 Instruction Subsets</h2>

<p>The Z80 instruction set is really 3 separate subsets each occupying
256 opcode ‘slots’. There’s the main instruction set which mostly overlaps
with the Intel 8080 instruction set and two additional sets of instructions
selected with the <strong>ED</strong> and <strong>CB</strong> prefix opcodes.</p>

<p>The main and CB subsets each occupy the full range of 256 instructions,
while the ED subset is mostly empty and only implements 59 instructions.</p>

<p>I’m not counting the <strong>DD</strong> and <strong>FD</strong> prefix instruction ranges as separate
subsets because they only slightly modify the behaviour of the main
instructions.</p>

<p>This means there are 571 unique instructions in the Z80 instruction set
(counting the RETI and RETN instructions as one because they have 
identical behaviour).</p>

<h2 id="the-2-3-3-opcode-bit-pattern">The 2-3-3 Opcode Bit Pattern</h2>

<p>Opcode bytes can be split into three bit groups to reveal a hidden
‘octal structure’ of a 256 instruction subset:</p>

<div><div><pre><code>  7 6   5 4 3   2 1 0
| x x | y y y | z z z | 
</code></pre></div></div>

<p>The two top-most bits (xx) split the instruction space into 4 quadrants,
and the remaining 6 bits are divided into two 3-bit groups (yyy) and (zzz)
which are used as arguments to the instruction decoder.</p>

<p>Let’s look at each instruction subset and quadrant one by one:</p>

<h2 id="main-instructions">Main Instructions</h2>

<h3 id="main-quadrant-1-xx--01">Main Quadrant 1 (xx = 01)</h3>

<p>I’m starting with Main Quadrant 1 (not 0) because unlike 0 it is has a simple
and ‘orderly’ structure. In an Z80 emulator this is usually the first quadrant
I’m implementing.</p>

<p>The 64 instructions with the bit pattern <strong>|01|yyy|zzz|</strong> implement
8-bit move instructions where <strong>yyy</strong> defines the target and <strong>zzz</strong>
the source. As a table, the main quadrant 1 looks like this:</p>



<table>
<tbody><tr><th>x=01</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>LD B,B</td><td>LD B,C</td><td>LD B,D</td><td>LD B,E</td><td>LD B,H</td><td>LD B,L</td><td>LD B,(HL)</td><td>LD B,A</td></tr><tr><th>y=001</th><td>LD C,B</td><td>LD C,C</td><td>LD C,D</td><td>LD C,E</td><td>LD C,H</td><td>LD C,L</td><td>LD C,(HL)</td><td>LD C,A</td></tr><tr><th>y=010</th><td>LD D,B</td><td>LD D,C</td><td>LD D,D</td><td>LD D,E</td><td>LD D,H</td><td>LD D,L</td><td>LD D,(HL)</td><td>LD D,A</td></tr><tr><th>y=011</th><td>LD E,B</td><td>LD E,C</td><td>LD E,D</td><td>LD E,E</td><td>LD E,H</td><td>LD E,L</td><td>LD E,(HL)</td><td>LD E,A</td></tr><tr><th>y=100</th><td>LD H,B</td><td>LD H,C</td><td>LD H,D</td><td>LD H,E</td><td>LD H,H</td><td>LD H,L</td><td>LD H,(HL)</td><td>LD H,A</td></tr><tr><th>y=101</th><td>LD L,B</td><td>LD L,C</td><td>LD L,D</td><td>LD L,E</td><td>LD L,H</td><td>LD L,L</td><td>LD L,(HL)</td><td>LD L,A</td></tr><tr><th>y=110</th><td>LD (HL),B</td><td>LD (HL),C</td><td>LD (HL),D</td><td>LD (HL),E</td><td>LD (HL),H</td><td>LD (HL),L</td><td>HALT</td><td>LD (HL),A</td></tr><tr><th>y=111</th><td>LD A,B</td><td>LD A,C</td><td>LD A,D</td><td>LD A,E</td><td>LD A,H</td><td>LD A,L</td><td>LD A,(HL)</td><td>LD A,A</td></tr>
</tbody></table>


<p>I have choosen the green background for instructions that have no ‘timing
surprises’ (like the <strong>PUSH HL</strong> instruction discussed above).  The duration
of ‘green’ instructions is simply the sum of their machine cycle default
clock cycles. All instructions in the Main Quadrant 1 take 4 clock cycles (for the
opcode fetch), except the instructions involving <strong>(HL)</strong> which take an additional
memory read or write machine cycle, resulting in 7 clock cycles.</p>

<p><em>y</em> and <em>z</em> are register indices as binary numbers:</p>

<div><div><pre><code>000 = 0 =&gt; B
001 = 1 =&gt; C
010 = 2 =&gt; D
011 = 3 =&gt; E
100 = 4 =&gt; H
101 = 5 =&gt; L
110 = 6 =&gt; (HL)
111 = 7 =&gt; A
</code></pre></div></div>

<p>The ‘register index’ 6 is a bit special. According to the ‘hardware pattern’ of
the Z80 register bank, index 6 would actually address the F (status flags)
register, but this isn’t directly accessible in the instruction set (and
‘wasting’ one index for the F register in most instructions also wouldn’t make
much sense). Instead index 6 is used as special case to load or store the 8-bit
value in memory addressed by the register pair HL.</p>

<p>And another oddity is the HALT instruction at bit pattern <strong>|01|110|110|</strong> (==
76 hex). Following the ‘table logic’ this instruction slot <em>should</em> be occupied by
an <strong>LD (HL),(HL)</strong> instruction which doesn’t make a lot of sense, so instead
this slot was reused for the HALT instruction.</p>

<h3 id="main-quadrant-2-xx--10">Main Quadrant 2 (xx = 10)</h3>

<p>This is the second ‘beautiful’ quadrant in the main instruction set, this
is where the basic 8-bit ALU instructions live:</p>



<table>
<tbody><tr><th>x=10</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>ADD B</td><td>ADD C</td><td>ADD D</td><td>ADD E</td><td>ADD H</td><td>ADD L</td><td>ADD (HL)</td><td>ADD A</td></tr><tr><th>y=001</th><td>ADC B</td><td>ADC C</td><td>ADC D</td><td>ADC E</td><td>ADC H</td><td>ADC L</td><td>ADC (HL)</td><td>ADC A</td></tr><tr><th>y=010</th><td>SUB B</td><td>SUB C</td><td>SUB D</td><td>SUB E</td><td>SUB H</td><td>SUB L</td><td>SUB (HL)</td><td>SUB A</td></tr><tr><th>y=011</th><td>SBC B</td><td>SBC C</td><td>SBC D</td><td>SBC E</td><td>SBC H</td><td>SBC L</td><td>SBC (HL)</td><td>SBC A</td></tr><tr><th>y=100</th><td>AND B</td><td>AND C</td><td>AND D</td><td>AND E</td><td>AND H</td><td>AND L</td><td>AND (HL)</td><td>AND A</td></tr><tr><th>y=101</th><td>XOR B</td><td>XOR C</td><td>XOR D</td><td>XOR E</td><td>XOR H</td><td>XOR L</td><td>XOR (HL)</td><td>XOR A</td></tr><tr><th>y=110</th><td>OR B</td><td>OR C</td><td>OR D</td><td>OR E</td><td>OR H</td><td>OR L</td><td>OR (HL)</td><td>OR A</td></tr><tr><th>y=111</th><td>CP B</td><td>CP C</td><td>CP D</td><td>CP E</td><td>CP H</td><td>CP L</td><td>CP (HL)</td><td>CP A</td></tr>
</tbody></table>


<p>Again, no timing surprises in this quadrant. The <em>z</em> bit group selects the
source register or <strong>(HL)</strong>, and the <em>y</em> bit group the ALU operation:</p>

<div><div><pre><code>000 =&gt; 0 =&gt; ADD
001 =&gt; 1 =&gt; ADC (add with carry)
010 =&gt; 2 =&gt; SUB
011 =&gt; 3 =&gt; SBC (sub with carry)
100 =&gt; 4 =&gt; AND
101 =&gt; 5 =&gt; XOR
110 =&gt; 6 =&gt; OR
111 =&gt; 7 =&gt; CP (compare - like SUB, but discard result)
</code></pre></div></div>

<p>This table also demonstrates nicely why all ALU operations implicitely use the
register <strong>A</strong> to store the result.  There’s simply no bits left in the 8-bit
opcode to select a destination register.</p>

<h3 id="main-quadrant-0-xx--00">Main Quadrant 0 (xx = 00)</h3>

<p>This is the first of the two ‘messy’ quadrants in the main set:</p>



<table>
<tbody><tr><th>x=00</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>NOP</td><td>LD BC,nn</td><td>LD (BC),A</td><td>INC BC</td><td>INC B</td><td>DEC B</td><td>LD B,n</td><td>RLCA</td></tr><tr><th>y=001</th><td>EX AF,AF&#39;</td><td>ADD HL,BC</td><td>LD A,(BC)</td><td>DEC BC</td><td>INC C</td><td>DEC C</td><td>LD C,n</td><td>RRCA</td></tr><tr><th>y=010</th><td>DJNZ d</td><td>LD DE,nn</td><td>LD (DE),A</td><td>INC DE</td><td>INC D</td><td>DEC D</td><td>LD D,n</td><td>RLA</td></tr><tr><th>y=011</th><td>JR d</td><td>ADD HL,DE</td><td>LD A,(DE)</td><td>DEC DE</td><td>INC E</td><td>DEC E</td><td>LD E,n</td><td>RRA</td></tr><tr><th>y=100</th><td>JR NZ,d</td><td>LD HL,nn</td><td>LD (nn),HL</td><td>INC HL</td><td>INC H</td><td>DEC H</td><td>LD H,n</td><td>DAA</td></tr><tr><th>y=101</th><td>JR Z,d</td><td>ADD HL,HL</td><td>LD HL,(nn)</td><td>DEC HL</td><td>INC L</td><td>DEC L</td><td>LD L,n</td><td>CPL</td></tr><tr><th>y=110</th><td>JR NC,d</td><td>LD SP,nn</td><td>LD (nn),A</td><td>INC SP</td><td>INC (HL)</td><td>DEC (HL)</td><td>LD (HL),n</td><td>SCF</td></tr><tr><th>y=111</th><td>JR C,d</td><td>ADD HL,SP</td><td>LD A,(nn)</td><td>DEC SP</td><td>INC A</td><td>DEC A</td><td>LD A,n</td><td>CCF</td></tr>
</tbody></table>


<p>The red background color means that those instructions insert extra
clock cycles between regular memory or IO machine cycles and need to be
handled with special care in cycle-correct emulators. For the rest of the blog post
I will focus on those ‘red’ instructions (because the timing of the ‘green’ instructions
can trivially be derived from the instruction’s machine cycles).</p>

<h4 id="incdec-hl">INC/DEC (HL)</h4>

<p>The <strong>INC (HL)</strong> and <strong>DEC (HL)</strong> instructions stick out, those are read-modify-write
instructions. Let’s see why they have a red background:</p>

<div><div><pre><code>INC (HL):
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 12 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 12 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 34 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 34 │
│ 3/0 │    │      │ RFSH │    │    │ 0001 │ 34 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0001 │ 34 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0001 │ 34 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ 34 │
│ 5/0 │    │      │      │    │    │ 1234 │ 34 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │ RD │    │ 1234 │ 34 │
│ 6/0 │    │ MREQ │      │ RD │    │ 1234 │ 00 │
│ 6/1 │    │ MREQ │      │ RD │    │ 1234 │ 00 │
│ 7/0 │    │ MREQ │      │ RD │    │ 1234 │ 00 │
│ 7/1 │    │      │      │    │    │ 1234 │ 00 │
│ 8/0 │    │      │      │    │    │ 1234 │ 00 │ &lt;== extra clock cycle
│ 8/1 │    │      │      │    │    │ 1234 │ 00 │
│ 9/0 │    │      │      │    │    │ 1234 │ 00 │ &lt;== memory write
│ 9/1 │    │ MREQ │      │    │    │ 1234 │ 01 │
│10/0 │    │ MREQ │      │    │    │ 1234 │ 01 │
│10/1 │    │ MREQ │      │    │ WR │ 1234 │ 01 │
│11/0 │    │ MREQ │      │    │ WR │ 1234 │ 01 │
│11/1 │    │      │      │    │    │ 1234 │ 01 │
</code></pre></div></div>

<p>As expected, there’s an opcode fetch, memory read and memory write machine cycle.
An extra clock cycle has been squeezed inbetween the read and write machine cycle,
no doubt to increment the byte that’s been loaded from memory before it is 
written back.</p>

<h4 id="incdec-ss">INC/DEC ss</h4>

<p>The 16-bit <strong>INC/DEC</strong> column adds two additional clock cycles after the opcode fetch
machine cycle to perform the 16-bit math:</p>

<div><div><pre><code>INC BC:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ BC   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ FF │ FFFF │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ FF │ FFFF │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 03 │ FFFF │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 03 │ FFFF │
│ 3/0 │    │      │ RFSH │    │    │ 0001 │ 03 │ FFFF │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0001 │ 03 │ FFFF │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0001 │ 03 │ FFFF │
│ 4/1 │    │      │ RFSH │    │    │ 0001 │ 03 │ FFFF │
│ 5/0 │    │      │      │    │    │ 0001 │ 03 │ FFFF │ &lt;== 2 extra clock cycles
│ 5/1 │    │      │      │    │    │ 0001 │ 03 │ 0000 │
│ 6/0 │    │      │      │    │    │ 0001 │ 03 │ 0000 │
│ 6/1 │    │      │      │    │    │ 0000 │ 03 │ 0000 │
</code></pre></div></div>
<p>It’s interesting that the result is already available at the
end of the first extra clock cycle. No idea why there’s 
a second ‘wasted’ clock cycle, especially since the 
16-bit INC/DEC instructions don’t update the flag bits.</p>

<h4 id="add-hlss">ADD HL,ss</h4>

<p>The 16-bit <strong>ADD</strong> instructions add 7 extra clock cycles after
the opcode fetch machine cycle:</p>

<div><div><pre><code>ADD HL,DE
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ DE   │ HL   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0006 │ 22 │ 2222 │ 1111 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ 22 │ 2222 │ 1111 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0006 │ 19 │ 2222 │ 1111 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ 19 │ 2222 │ 1111 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 5/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1111 │ &lt;== 7 extra clock cycles
│ 5/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 6/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 6/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 7/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1111 │
│ 7/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │ &lt;== result low byte
│ 8/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│ 8/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│ 9/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│ 9/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│10/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│10/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│11/0 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 1133 │
│11/1 │    │      │      │    │    │ 0002 │ 19 │ 2222 │ 3333 │ &lt;== result high byte
</code></pre></div></div>

<p>This time, no clock cycles are wasted. The 16-bit result is only
ready in the very last half cycle of the instruction. Not shown 
here is that the flag bits (H and C) are updated in the opcode fetch
machine cycle of the next instruction (at M1/T3/1).</p>

<h4 id="jr-d">JR d</h4>

<p>The relative jump <strong>JR d</strong> performs a regular memory read machine cycle
after the opcode fetch, and then spends 5 more clock cycles to compute
the jump target address:</p>

<div><div><pre><code>JR d
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0002 │ 00 │ 0002 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0002 │ 00 │ 0003 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0002 │ 18 │ 0003 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0002 │ 18 │ 0003 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ 18 │ 0003 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 18 │ 0003 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 18 │ 0003 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ 18 │ 0003 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0003 │ 18 │ 0003 │ 5555 │ &lt;== memory ready
│ 5/1 │    │ MREQ │      │ RD │    │ 0003 │ 18 │ 0004 │ 5555 │
│ 6/0 │    │ MREQ │      │ RD │    │ 0003 │ FC │ 0004 │ 5555 │
│ 6/1 │    │ MREQ │      │ RD │    │ 0003 │ FC │ 0004 │ 5555 │
│ 7/0 │    │ MREQ │      │ RD │    │ 0003 │ FC │ 0004 │ 5555 │
│ 7/1 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5555 │
│ 8/0 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5555 │ &lt;== 5 extra clock cycles
│ 8/1 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5555 │ 
│ 9/0 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5555 │ 
│ 9/1 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5500 │ 
│10/0 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5500 │ 
│10/1 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5500 │ 
│11/0 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5500 │ 
│11/1 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5500 │ 
│12/0 │    │      │      │    │    │ 0003 │ FC │ 0004 │ 5500 │ 
│12/1 │    │      │      │    │    │ 0001 │ FC │ 0004 │ 0000 │ &lt;== dst addr in WZ
</code></pre></div></div>

<p>The computed target address isn’t stored in the <strong>PC</strong> register, but instead
in the internal 16-bit ‘helper’ register <strong>WZ</strong>. In fact the PC register <em>never</em>
contains the actual target address (0000), it switches straight from the address
following the <strong>JR d</strong> instruction (0004) to the address following the
destination address:</p>

<div><div><pre><code>JR d CONTINUED: NOP at the jump destination (address 0000)
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0000 │ FC │ 0004 │ 0000 │ &lt;== PC still 0004!
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ FC │ 0001 │ 0000 │ &lt;== PC goes right to 0001!
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0000 │ 00 │ 0001 │ 0000 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 00 │ 0001 │ 0000 │
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ 00 │ 0001 │ 0000 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ 00 │ 0001 │ 0000 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ 00 │ 0001 │ 0000 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ 00 │ 0001 │ 0000 │
</code></pre></div></div>

<h4 id="djnz-d">DJNZ d</h4>

<p>The <strong>DJNZ d</strong> instruction (Decrement-and-Jump-if-Not-Zero) inserts one clock
cycle between the opcode fetch and memory read machine cycle, and if the branch
is taken, 5 additional clock cycles (this branch part is identical with the
<strong>JR</strong> instruction):</p>

<div><div><pre><code>DJNZ d - branch taken:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 00 │ 0003 │ 0255 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 00 │ 0004 │ 0255 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 10 │ 0004 │ 0255 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 10 │ 0004 │ 0255 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ 10 │ 0004 │ 0255 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 10 │ 0004 │ 0255 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 10 │ 0004 │ 0255 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ 10 │ 0004 │ 0255 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0002 │ 10 │ 0004 │ 0255 │ 5555 │ &lt;== 1 extra clock cycle
│ 5/1 │    │      │      │    │    │ 0000 │ 10 │ 0004 │ 0255 │ 5555 │        
│ 6/0 │    │      │      │    │    │ 0004 │ 10 │ 0004 │ 0255 │ 5555 │ &lt;== memory read
│ 6/1 │    │ MREQ │      │ RD │    │ 0004 │ 10 │ 0005 │ 0155 │ 5555 │ &lt;== B decremented
│ 7/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │
│ 7/1 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │
│ 8/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │
│ 8/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │
│ 9/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │ &lt;== 5 extra clock cycles
│ 9/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │
│10/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5555 │
│10/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5502 │
│11/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5502 │
│11/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5502 │
│12/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5502 │
│12/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5502 │
│13/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 5502 │
│13/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0155 │ 0002 │ &lt;== dst addr in WZ
</code></pre></div></div>

<p>If the branch is not taken, <strong>DJNZ</strong> is finished right after the memory read:</p>

<div><div><pre><code>DJNZ d - branch not taken:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 00 │ 0003 │ 0155 │ 0002 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 00 │ 0004 │ 0155 │ 0002 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 10 │ 0004 │ 0155 │ 0002 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 10 │ 0004 │ 0155 │ 0002 │
│ 3/0 │    │      │ RFSH │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │
│ 5/0 │    │      │      │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │ &lt;== 1 extra clock cycle
│ 5/1 │    │      │      │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │        
│ 6/0 │    │      │      │    │    │ 0004 │ 10 │ 0004 │ 0155 │ 0002 │ &lt;== memory read
│ 6/1 │    │ MREQ │      │ RD │    │ 0004 │ 10 │ 0005 │ 0055 │ 0002 │ &lt;== B decremented
│ 7/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 0055 │ 0002 │
│ 7/1 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 0055 │ 0002 │
│ 8/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 0055 │ 0002 │
│ 8/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0055 │ 0002 │
</code></pre></div></div>

<h4 id="jr-ccd">JR cc,d</h4>

<p>In the conditional relative jump instruction <strong>JR cc,d</strong>, the memory read
directly follows the opcode fetch. If the branch is taken, 5 clock cycles
are added, otherwise the instruction ends with the memory read machine
cycle (so the branch behaviour is identical with DJNZ and JR):</p>

<div><div><pre><code>JR cc,d - branch taken
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 05 │ 0003 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 05 │ 0004 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 20 │ 0004 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 20 │ 0004 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0004 │ 20 │ 0004 │ 5555 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │ RD │    │ 0004 │ 20 │ 0005 │ 5555 │
│ 6/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 5555 │
│ 6/1 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 5555 │
│ 7/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 5555 │
│ 7/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5555 │
│ 8/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5555 │ &lt;== 5 extra clock cycles
│ 8/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5555 │
│ 9/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5555 │
│ 9/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5502 │
│10/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5502 │
│10/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5502 │
│11/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5502 │
│11/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5502 │
│12/0 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5502 │
│12/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 0002 │ &lt;== dest addr in WZ
</code></pre></div></div>

<div><div><pre><code>JR cc,d - branch not taken
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 05 │ 0003 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 05 │ 0004 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 20 │ 0004 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 20 │ 0004 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ 20 │ 0004 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0004 │ 20 │ 0004 │ 5555 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │ RD │    │ 0004 │ 20 │ 0005 │ 5555 │
│ 6/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 5555 │
│ 6/1 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 5555 │
│ 7/0 │    │ MREQ │      │ RD │    │ 0004 │ FD │ 0005 │ 5555 │
│ 7/1 │    │      │      │    │    │ 0004 │ FD │ 0005 │ 5555 │
</code></pre></div></div>

<h3 id="main-quadrant-3-xx--11">Main Quadrant 3 (xx == 11)</h3>



<table>
<tbody><tr><th>x=11</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>RET NZ</td><td>POP BC</td><td>JP NZ,nn</td><td>JP nn</td><td>CALL NZ,nn</td><td>PUSH BC</td><td>ADD n</td><td>RST 0h</td></tr><tr><th>y=001</th><td>RET Z</td><td>RET</td><td>JP Z,nn</td><td>CB prefix</td><td>CALL Z,nn</td><td>CALL nn</td><td>ADC n</td><td>RST 8h</td></tr><tr><th>y=010</th><td>RET NC</td><td>POP DE</td><td>JP NC,nn</td><td>OUT (n),A</td><td>CALL NC,nn</td><td>PUSH DE</td><td>SUB n</td><td>RST 10h</td></tr><tr><th>y=011</th><td>RET C</td><td>EXX</td><td>JP C,nn</td><td>IN A,(n)</td><td>CALL C,nn</td><td>DD prefix</td><td>SBC n</td><td>RST 18h</td></tr><tr><th>y=100</th><td>RET PO</td><td>POP HL</td><td>JP PO,nn</td><td>EX (SP),HL</td><td>CALL PO,nn</td><td>PUSH HL</td><td>AND n</td><td>RST 20h</td></tr><tr><th>y=101</th><td>RET PE</td><td>JP HL</td><td>JP PE,nn</td><td>EX DE,HL</td><td>CALL PE,nn</td><td>ED prefix</td><td>XOR n</td><td>RST 28h</td></tr><tr><th>y=110</th><td>RET P</td><td>POP AF</td><td>JP P,nn</td><td>DI</td><td>CALL P,nn</td><td>PUSH AF</td><td>OR n</td><td>RST 30h</td></tr><tr><th>y=111</th><td>RET M</td><td>LD SP,HL</td><td>JP M,nn</td><td>EI</td><td>CALL M,nn</td><td>FD prefix</td><td>CP n</td><td>RST 38h</td></tr>
</tbody></table>


<h4 id="call-nn">CALL nn</h4>

<p>The <strong>CALL nn</strong> instruction inserts one clock cycle between the last memory read machine
cycle (to load the destination address) and the first memory write machine cycle
(to store the return address on the stack). The destination address is stored in WZ:</p>

<div><div><pre><code>CALL nn
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ SP   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0000 │ 00 │ 0000 │ 0100 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 00 │ 0001 │ 0100 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0000 │ CD │ 0001 │ 0100 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ CD │ 0001 │ 0100 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0000 │ CD │ 0001 │ 0100 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0000 │ CD │ 0001 │ 0100 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0000 │ CD │ 0001 │ 0100 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ CD │ 0001 │ 0100 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0001 │ CD │ 0001 │ 0100 │ 5555 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │ RD │    │ 0001 │ CD │ 0002 │ 0100 │ 5555 │
│ 6/0 │    │ MREQ │      │ RD │    │ 0001 │ 22 │ 0002 │ 0100 │ 5555 │
│ 6/1 │    │ MREQ │      │ RD │    │ 0001 │ 22 │ 0002 │ 0100 │ 5555 │
│ 7/0 │    │ MREQ │      │ RD │    │ 0001 │ 22 │ 0002 │ 0100 │ 5555 │
│ 7/1 │    │      │      │    │    │ 0000 │ 22 │ 0002 │ 0100 │ 5522 │
│ 8/0 │    │      │      │    │    │ 0002 │ 22 │ 0002 │ 0100 │ 5522 │ &lt;== memory read
│ 8/1 │    │ MREQ │      │ RD │    │ 0002 │ 22 │ 0003 │ 0100 │ 5522 │
│ 9/0 │    │ MREQ │      │ RD │    │ 0002 │ 11 │ 0003 │ 0100 │ 5522 │
│ 9/1 │    │ MREQ │      │ RD │    │ 0002 │ 11 │ 0003 │ 0100 │ 5522 │
│10/0 │    │ MREQ │      │ RD │    │ 0002 │ 11 │ 0003 │ 0100 │ 5522 │
│10/1 │    │      │      │    │    │ 0002 │ 11 │ 0003 │ 0100 │ 1122 │ &lt;== branch target in WZ
│11/0 │    │      │      │    │    │ 0002 │ 11 │ 0003 │ 0100 │ 1122 │ &lt;== extra clock cycle
│11/1 │    │      │      │    │    │ 0000 │ 11 │ 0003 │ 00FF │ 1122 │ &lt;== SP pre-decremented
│12/0 │    │      │      │    │    │ 5554 │ 11 │ 0003 │ 00FF │ 1122 │ &lt;== memory write
│12/1 │    │ MREQ │      │    │    │ 5554 │ 00 │ 0003 │ 00FF │ 1122 │
│13/0 │    │ MREQ │      │    │    │ 5554 │ 00 │ 0003 │ 00FF │ 1122 │
│13/1 │    │ MREQ │      │    │ WR │ 5554 │ 00 │ 0003 │ 00FE │ 1122 │
│14/0 │    │ MREQ │      │    │ WR │ 5554 │ 00 │ 0003 │ 00FE │ 1122 │
│14/1 │    │      │      │    │    │ 5550 │ 00 │ 0003 │ 00FE │ 1122 │
│15/0 │    │      │      │    │    │ 5553 │ 11 │ 0003 │ 00FE │ 1122 │ &lt;== memory write
│15/1 │    │ MREQ │      │    │    │ 5553 │ 03 │ 0003 │ 00FE │ 1122 │
│16/0 │    │ MREQ │      │    │    │ 5553 │ 03 │ 0003 │ 00FE │ 1122 │
│16/1 │    │ MREQ │      │    │ WR │ 5553 │ 03 │ 0003 │ 00FE │ 1122 │
│17/0 │    │ MREQ │      │    │ WR │ 5553 │ 03 │ 0003 │ 00FE │ 1122 │
│17/1 │    │      │      │    │    │ 5553 │ 03 │ 0003 │ 00FE │ 1122 │
</code></pre></div></div>

<p>Like in other branch instructions, the <strong>PC</strong> register isn’t updated in the instruction,
instead it switches to <code>dst addr + 1</code> in the second half cycle of the first 
subroutine instruction:</p>

<div><div><pre><code>CALL nn - continued (first opcode fetch in subroutine)
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 1122 │ 11 │ 0003 │ 1122 │ &lt;== PC still at CALL nn + 1
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 1122 │ 11 │ 1123 │ 1122 │ &lt;== PC now at dst addr + 1
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 1122 │ C9 │ 1123 │ 1122 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 1122 │ C9 │ 1123 │ 1122 │
</code></pre></div></div>

<h4 id="call-ccnn">CALL cc,nn</h4>

<p>The conditional <strong>CALL cc,nn</strong> instruction is exactly identical with the unconditional
<strong>CALL nn</strong> instruction if the condition is true. Otherwise the instruction exits
early after the second memory read:</p>

<div><div><pre><code>CALL NZ,nn - branch not taken
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 05 │ 0003 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 05 │ 0004 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ CC │ 0004 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ CC │ 0004 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ CC │ 0004 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ CC │ 0004 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ CC │ 0004 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ CC │ 0004 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0004 │ CC │ 0004 │ 5555 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │ RD │    │ 0004 │ CC │ 0005 │ 5555 │
│ 6/0 │    │ MREQ │      │ RD │    │ 0004 │ 0B │ 0005 │ 5555 │
│ 6/1 │    │ MREQ │      │ RD │    │ 0004 │ 0B │ 0005 │ 5555 │
│ 7/0 │    │ MREQ │      │ RD │    │ 0004 │ 0B │ 0005 │ 5555 │
│ 7/1 │    │      │      │    │    │ 0004 │ 0B │ 0005 │ 550B │
│ 8/0 │    │      │      │    │    │ 0005 │ 0B │ 0005 │ 550B │ &lt;== memory read
│ 8/1 │    │ MREQ │      │ RD │    │ 0005 │ 0B │ 0006 │ 550B │
│ 9/0 │    │ MREQ │      │ RD │    │ 0005 │ 00 │ 0006 │ 550B │
│ 9/1 │    │ MREQ │      │ RD │    │ 0005 │ 00 │ 0006 │ 550B │
│10/0 │    │ MREQ │      │ RD │    │ 0005 │ 00 │ 0006 │ 550B │
│10/1 │    │      │      │    │    │ 0005 │ 00 │ 0006 │ 000B │ &lt;== dst addr in WZ
</code></pre></div></div>

<h4 id="ret-cc">RET cc</h4>

<p>The conditional return instructions <strong>RET cc</strong> adds or inserts one clock cycle after the
opcode fetch. If the condition is false the instruction ends here, otherwise two more 
memory read machine cycles are added to load the return address from the stack into
WZ.</p>

<div><div><pre><code>RET Z - condition false
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ SP   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 000C │ 05 │ 000C │ 00FE │ 0009 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 000C │ 05 │ 000D │ 00FE │ 0009 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 000C │ C8 │ 000D │ 00FE │ 0009 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 000C │ C8 │ 000D │ 00FE │ 0009 │
│ 3/0 │    │      │ RFSH │    │    │ 0004 │ C8 │ 000D │ 00FE │ 0009 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0004 │ C8 │ 000D │ 00FE │ 0009 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0004 │ C8 │ 000D │ 00FE │ 0009 │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ C8 │ 000D │ 00FE │ 0009 │
│ 5/0 │    │      │      │    │    │ 0004 │ C8 │ 000D │ 00FE │ 0009 │ &lt;== one extra clock cycle
│ 5/1 │    │      │      │    │    │ 0004 │ C8 │ 000D │ 00FE │ 0009 │
</code></pre></div></div>

<div><div><pre><code>RET Z - condition true
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ SP   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 2005 │ 05 │ 2005 │ 00FE │ 2000 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 2005 │ 05 │ 2006 │ 00FE │ 2000 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 2005 │ C8 │ 2006 │ 00FE │ 2000 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 2004 │ C8 │ 2006 │ 00FE │ 2000 │
│ 3/0 │    │      │ RFSH │    │    │ 0006 │ C8 │ 2006 │ 00FE │ 2000 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0006 │ C8 │ 2006 │ 00FE │ 2000 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0006 │ C8 │ 2006 │ 00FE │ 2000 │
│ 4/1 │    │      │ RFSH │    │    │ 0006 │ C8 │ 2006 │ 00FE │ 2000 │
│ 5/0 │    │      │      │    │    │ 0006 │ C8 │ 2006 │ 00FE │ 2000 │ &lt;== one extra clock cycle
│ 5/1 │    │      │      │    │    │ 0006 │ C8 │ 2006 │ 00FE │ 2000 │ 
│ 6/0 │    │      │      │    │    │ 00FE │ C8 │ 2006 │ 00FE │ 2000 │ &lt;== memory read
│ 6/1 │    │ MREQ │      │ RD │    │ 00FE │ C8 │ 2006 │ 00FE │ 2000 │
│ 7/0 │    │ MREQ │      │ RD │    │ 00FE │ 06 │ 2006 │ 00FE │ 2000 │
│ 7/1 │    │ MREQ │      │ RD │    │ 00FE │ 06 │ 2006 │ 00FF │ 2000 │
│ 8/0 │    │ MREQ │      │ RD │    │ 00FE │ 06 │ 2006 │ 00FF │ 2000 │
│ 8/1 │    │      │      │    │    │ 00FE │ 06 │ 2006 │ 00FF │ 2006 │
│ 9/0 │    │      │      │    │    │ 00FF │ 06 │ 2006 │ 00FF │ 2006 │ &lt;== memory read 
│ 9/1 │    │ MREQ │      │ RD │    │ 00FF │ 06 │ 2006 │ 00FF │ 2006 │
│10/0 │    │ MREQ │      │ RD │    │ 00FF │ 00 │ 2006 │ 00FF │ 2006 │
│10/1 │    │ MREQ │      │ RD │    │ 00FF │ 00 │ 2006 │ 0100 │ 2006 │
│11/0 │    │ MREQ │      │ RD │    │ 00FF │ 00 │ 2006 │ 0100 │ 2006 │
│11/1 │    │      │      │    │    │ 0000 │ 00 │ 2006 │ 0100 │ 0006 │ &lt;== ret addr in WZ
</code></pre></div></div>

<h4 id="ld-sphl">LD SP,HL</h4>

<p>The <strong>LD SP,HL</strong> instruction just adds two clock cycles after the opcode fetch:</p>

<div><div><pre><code>LD SP,HL
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ HL   │ SP   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 11 │ 0003 │ 1122 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 11 │ 0004 │ 1122 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ F9 │ 0004 │ 1122 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ F9 │ 0004 │ 1122 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 5555 │ &lt;== 2 extra clock cycles
│ 5/1 │    │      │      │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 1122 │
│ 6/0 │    │      │      │    │    │ 0001 │ F9 │ 0004 │ 1122 │ 1122 │
│ 6/1 │    │      │      │    │    │ 0000 │ F9 │ 0004 │ 1122 │ 1122 │
</code></pre></div></div>

<h4 id="ex-sphl">EX (SP),HL</h4>

<p>The <strong>EX (SP),HL</strong> instruction inserts one clock cycle between the last memory
read and first memory write machine cycle, and adds 2 more clock cycles
after the last memory write. The <strong>WZ</strong> register is used as intermediate
storage for the 16-bit value read from the stack:</p>

<div><div><pre><code>EX (SP),HL
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ HL   │ SP   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 000A │ D5 │ 000A │ 4321 │ 00FE │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 000A │ D5 │ 000B │ 4321 │ 00FE │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 000A │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 000A │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0004 │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0004 │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0004 │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 5/0 │    │      │      │    │    │ 00FE │ E3 │ 000B │ 4321 │ 00FE │ 5555 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │ RD │    │ 00FE │ E3 │ 000B │ 4321 │ 00FE │ 5555 │
│ 6/0 │    │ MREQ │      │ RD │    │ 00FE │ 34 │ 000B │ 4321 │ 00FE │ 5555 │
│ 6/1 │    │ MREQ │      │ RD │    │ 00FE │ 34 │ 000B │ 4321 │ 00FE │ 00FF │
│ 7/0 │    │ MREQ │      │ RD │    │ 00FE │ 34 │ 000B │ 4321 │ 00FE │ 00FF │
│ 7/1 │    │      │      │    │    │ 00FE │ 34 │ 000B │ 4321 │ 00FE │ 0034 │ &lt;== Z: low byte from stack
│ 8/0 │    │      │      │    │    │ 00FF │ 34 │ 000B │ 4321 │ 00FE │ 0034 │ &lt;== memory read
│ 8/1 │    │ MREQ │      │ RD │    │ 00FF │ 34 │ 000B │ 4321 │ 00FE │ 0034 │
│ 9/0 │    │ MREQ │      │ RD │    │ 00FF │ 12 │ 000B │ 4321 │ 00FE │ 0034 │
│ 9/1 │    │ MREQ │      │ RD │    │ 00FF │ 12 │ 000B │ 4321 │ 00FE │ 0034 │
│10/0 │    │ MREQ │      │ RD │    │ 00FF │ 12 │ 000B │ 4321 │ 00FE │ 0034 │
│10/1 │    │      │      │    │    │ 00FF │ 12 │ 000B │ 4321 │ 00FE │ 1234 │ &lt;== WZ: 16 bit value from stack
│11/0 │    │      │      │    │    │ 00FF │ 12 │ 000B │ 4321 │ 00FE │ 1234 │ &lt;== extra clock cycle
│11/1 │    │      │      │    │    │ 00FE │ 12 │ 000B │ 4321 │ 00FF │ 1234 │ &lt;== SP incremented
│12/0 │    │      │      │    │    │ 00FF │ 12 │ 000B │ 4321 │ 00FF │ 1234 │ &lt;== memory write (L =&gt; stack)
│12/1 │    │ MREQ │      │    │    │ 00FF │ 43 │ 000B │ 4321 │ 00FF │ 1234 │
│13/0 │    │ MREQ │      │    │    │ 00FF │ 43 │ 000B │ 4321 │ 00FF │ 1234 │
│13/1 │    │ MREQ │      │    │ WR │ 00FF │ 43 │ 000B │ 4321 │ 00FE │ 1234 │ &lt;== SP decremented again
│14/0 │    │ MREQ │      │    │ WR │ 00FF │ 43 │ 000B │ 4321 │ 00FE │ 1234 │
│14/1 │    │      │      │    │    │ 00FE │ 43 │ 000B │ 4321 │ 00FE │ 1234 │
│15/0 │    │      │      │    │    │ 00FE │ 12 │ 000B │ 4321 │ 00FE │ 1234 │ &lt;== memory write (H =&gt; stack)
│15/1 │    │ MREQ │      │    │    │ 00FE │ 21 │ 000B │ 4321 │ 00FE │ 1234 │
│16/0 │    │ MREQ │      │    │    │ 00FE │ 21 │ 000B │ 4321 │ 00FE │ 1234 │
│16/1 │    │ MREQ │      │    │ WR │ 00FE │ 21 │ 000B │ 4321 │ 00FE │ 1234 │
│17/0 │    │ MREQ │      │    │ WR │ 00FE │ 21 │ 000B │ 4321 │ 00FE │ 1234 │
│17/1 │    │      │      │    │    │ 00FE │ 21 │ 000B │ 4321 │ 00FE │ 1234 │
│18/0 │    │      │      │    │    │ 00FE │ 21 │ 000B │ 4321 │ 00FE │ 1234 │ &lt;== two extra clock cycles
│18/1 │    │      │      │    │    │ 00FE │ 21 │ 000B │ 1234 │ 00FE │ 1234 │ &lt;== WZ =&gt; HL
│19/0 │    │      │      │    │    │ 00FE │ 21 │ 000B │ 1234 │ 00FE │ 1234 │
│19/1 │    │      │      │    │    │ 0034 │ 21 │ 000B │ 1234 │ 00FE │ 1234 │
</code></pre></div></div>

<h4 id="push-qq">PUSH qq</h4>

<p>The <strong>PUSH</strong> instruction inserts one clock cycle between the opcode fetch
and first memory write machine cycle:</p>

<div><div><pre><code>PUSH DE:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ DE   │ SP   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0006 │ 12 │ 0006 │ 1234 │ 0100 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ 12 │ 0007 │ 1234 │ 0100 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0006 │ D5 │ 0007 │ 1234 │ 0100 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ D5 │ 0007 │ 1234 │ 0100 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ D5 │ 0007 │ 1234 │ 0100 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ D5 │ 0007 │ 1234 │ 0100 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ D5 │ 0007 │ 1234 │ 0100 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ D5 │ 0007 │ 1234 │ 0100 │
│ 5/0 │    │      │      │    │    │ 0002 │ D5 │ 0007 │ 1234 │ 0100 │ &lt;== extra clock cycle
│ 5/1 │    │      │      │    │    │ 0000 │ D5 │ 0007 │ 1234 │ 00FF │ &lt;== SP pre-decremented
│ 6/0 │    │      │      │    │    │ 00FF │ D5 │ 0007 │ 1234 │ 00FF │ &lt;== memory write
│ 6/1 │    │ MREQ │      │    │    │ 00FF │ 12 │ 0007 │ 1234 │ 00FF │
│ 7/0 │    │ MREQ │      │    │    │ 00FF │ 12 │ 0007 │ 1234 │ 00FF │
│ 7/1 │    │ MREQ │      │    │ WR │ 00FF │ 12 │ 0007 │ 1234 │ 00FE │
│ 8/0 │    │ MREQ │      │    │ WR │ 00FF │ 12 │ 0007 │ 1234 │ 00FE │
│ 8/1 │    │      │      │    │    │ 00FE │ 12 │ 0007 │ 1234 │ 00FE │
│ 9/0 │    │      │      │    │    │ 00FE │ D5 │ 0007 │ 1234 │ 00FE │ &lt;== memory write
│ 9/1 │    │ MREQ │      │    │    │ 00FE │ 34 │ 0007 │ 1234 │ 00FE │
│10/0 │    │ MREQ │      │    │    │ 00FE │ 34 │ 0007 │ 1234 │ 00FE │
│10/1 │    │ MREQ │      │    │ WR │ 00FE │ 34 │ 0007 │ 1234 │ 00FE │
│11/0 │    │ MREQ │      │    │ WR │ 00FE │ 34 │ 0007 │ 1234 │ 00FE │
│11/1 │    │      │      │    │    │ 00FE │ 34 │ 0007 │ 1234 │ 00FE │
</code></pre></div></div>

<h4 id="rst-p">RST p</h4>

<p>The <strong>RST p</strong> instructions insert one clock cycle between the opcode fetch
and first memory write machine cycle to pre-decrement the stack pointer. 
The WZ register is used as temporary storage of the destination address:</p>

<div><div><pre><code>RST 20h
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ SP   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 01 │ 0003 │ 0100 │ 5555 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 01 │ 0004 │ 0100 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ E7 │ 0004 │ 0100 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ E7 │ 0004 │ 0100 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0001 │ E7 │ 0004 │ 0100 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0001 │ E7 │ 0004 │ 0100 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0001 │ E7 │ 0004 │ 0100 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0001 │ E7 │ 0004 │ 0100 │ 5555 │
│ 5/0 │    │      │      │    │    │ 0001 │ E7 │ 0004 │ 0100 │ 5555 │ &lt;== extra clock cycle
│ 5/1 │    │      │      │    │    │ 0000 │ E7 │ 0004 │ 00FF │ 5555 │ &lt;== SP pre-decremented
│ 6/0 │    │      │      │    │    │ 00FF │ E7 │ 0004 │ 00FF │ 5555 │ &lt;== memory write
│ 6/1 │    │ MREQ │      │    │    │ 00FF │ 00 │ 0004 │ 00FF │ 5555 │
│ 7/0 │    │ MREQ │      │    │    │ 00FF │ 00 │ 0004 │ 00FF │ 5555 │
│ 7/1 │    │ MREQ │      │    │ WR │ 00FF │ 00 │ 0004 │ 00FE │ 5555 │
│ 8/0 │    │ MREQ │      │    │ WR │ 00FF │ 00 │ 0004 │ 00FE │ 5555 │
│ 8/1 │    │      │      │    │    │ 00FE │ 00 │ 0004 │ 00FE │ 5520 │
│ 9/0 │    │      │      │    │    │ 00FE │ E7 │ 0004 │ 00FE │ 5520 │ &lt;== memory write
│ 9/1 │    │ MREQ │      │    │    │ 00FE │ 04 │ 0004 │ 00FE │ 5520 │
│10/0 │    │ MREQ │      │    │    │ 00FE │ 04 │ 0004 │ 00FE │ 5520 │
│10/1 │    │ MREQ │      │    │ WR │ 00FE │ 04 │ 0004 │ 00FE │ 5520 │
│11/0 │    │ MREQ │      │    │ WR │ 00FE │ 04 │ 0004 │ 00FE │ 5520 │
│11/1 │    │      │      │    │    │ 00FE │ 04 │ 0004 │ 00FE │ 0020 │ &lt;== WZ dst addr
</code></pre></div></div>

<p>Like in other branch instructions, <strong>PC</strong> isn’t updated within the instruction, instead
it switches from the address following the <strong>RST</strong> instruction to the
destination address + 1 in the second half-cycle of the first
subroutine opcode fetch:</p>

<div><div><pre><code>RST 20h - continued into subroutine
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ SP   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0020 │ E7 │ 0004 │ 00FE │ 0020 │ &lt;== opcode fetch, PC still at RST 20h + 1
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0020 │ E7 │ 0021 │ 00FE │ 0020 │ &lt;== PC now at dst addr + 1
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0020 │ C9 │ 0021 │ 00FE │ 0020 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0020 │ C9 │ 0021 │ 00FE │ 0020 │
</code></pre></div></div>

<h2 id="prefix-instruction-overview">Prefix Instruction Overview</h2>

<p>All prefix bytes (<strong>CB</strong>, <strong>DD</strong>, <strong>ED</strong>, <strong>FD</strong>) execute as regular 4-cycle instruction, except:</p>

<ul>
  <li>no interrupts are handled at the end of the prefix instruction</li>
  <li>the decoding of the following opcode is modified:
    <ul>
      <li>the ED and CB prefixes each select an entirely different instruction subset</li>
      <li>the DD and FD prefix select the main instruction subset but replace usage of
HL with IX or IY (highly simplified, see the DD/FD section for details)</li>
      <li>the ED prefix cancels any “active effects” of the DD and FD prefixes (for instance 
the byte sequence <strong>DD ED B0</strong> doesn’t cause the LDIR instruction to use
IX instead of HL)</li>
    </ul>
  </li>
</ul>

<p>Sequences of the same prefix byte sometimes behave unexpected:</p>

<ul>
  <li>
    <p>Sequences of <strong>DD</strong> or <strong>FD</strong>, or a mix of them inhibit interrupt handling
until the end of the instruction following the DD/FD sequence. The following
instruction will be modified depending on the last prefix byte in the sequence.
<strong>DD</strong> and <strong>FD</strong> prefixes don’t ‘stack’, e.g. it’s not possible to load the 16-bit 
value 3333h into both IX and IY with the following byte sequence: <strong>DD FD 21 33 33</strong>,
instead the <strong>FD</strong> prefix cancels the effect of the <strong>DD</strong> prefix, and only the
<strong>IY</strong> register is loaded with the value.</p>
  </li>
  <li>
    <p>Sequences of <strong>ED</strong> prefixes will be interpreted as pairs of <strong>ED ED</strong> opcode bytes
(which simply acts as an 8-cycle NOP)</p>
  </li>
  <li>
    <p>Sequences of <strong>CB</strong> prefixes will be interpreted as pairs of <strong>CB CB</strong> which is the
regular <strong>SET 1,E</strong> instruction</p>
  </li>
  <li>
    <p><strong>DD/FD CB</strong> sequences result in the most weird behaviour and deserve their own section</p>
  </li>
</ul>

<p>The special ‘chaining behaviour’ of the DD and FD prefixes is simply a side effect of
those prefixes not switching to a different instruction subset. If the next
byte is a <strong>DD</strong>, <strong>ED</strong>, <strong>CB</strong> or <strong>FD</strong>, it will be execute as the respective
prefix instruction.</p>

<h2 id="dd-and-fd-prefixes">DD and FD Prefixes</h2>

<p>The <strong>DD</strong> and <strong>FD</strong> prefix instructions modify the behaviour of the following
opcode byte as follows:</p>

<p>All uses of the <strong>L</strong>, <strong>H</strong>, <strong>HL</strong> and <strong>(HL)</strong> will be replaced with 
<strong>IXL</strong>, <strong>IXH</strong>, <strong>IX</strong> and <strong>(IX+d)</strong> (for the <strong>DD</strong> prefix), or <strong>IYL</strong>,
<strong>IYH</strong>, <strong>IY</strong> and <strong>(IY+d)</strong> (for the <strong>FD</strong> prefix), with the following
exceptions:</p>

<ul>
  <li>If <strong>(HL)</strong> and <strong>L</strong> or <strong>H</strong> are used in the same instruction, <strong>L</strong> and <strong>H</strong>
are not replaced with <strong>IXL</strong> or <strong>IXH</strong>, for instance <strong>LD L,(IX+d)</strong> stores
the content of <strong>(IX+d)</strong> into <strong>L</strong>, not <strong>IXL</strong>.</li>
  <li>In the instruction <strong>EX DE,HL</strong>, <strong>HL</strong> will not be replaced with <strong>IX</strong> or <strong>IY</strong>.</li>
</ul>

<p>Instructions which are reinterpreted from <strong>(HL)</strong> to <strong>(IX+d)</strong> or <strong>(IY+d)</strong> load
an additional offset byte ‘d’ which is signed-added to IX or IY to form the effective
address for the memory access. This extra work consists of a regular memory read
machine cycle (3 clock cycles) followed by 5 extra clock cycles to compute the
resulting address which will be stored in WZ:</p>

<div><div><pre><code>LD A,(IX+3)
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IX   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0004 │ 20 │ 0004 │ 2000 │ 5555 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ 20 │ 0005 │ 2000 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0004 │ DD │ 0005 │ 2000 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ DD │ 0005 │ 2000 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ DD │ 0005 │ 2000 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ DD │ 0005 │ 2000 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ DD │ 0005 │ 2000 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ DD │ 0005 │ 2000 │ 5555 │
│ 5/0 │ M1 │      │      │    │    │ 0005 │ DD │ 0005 │ 2000 │ 5555 │ &lt;== ocode fetch LD A,(HL)
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0005 │ DD │ 0006 │ 2000 │ 5555 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0005 │ 7E │ 0006 │ 2000 │ 5555 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ 7E │ 0006 │ 2000 │ 5555 │
│ 7/0 │    │      │ RFSH │    │    │ 0003 │ 7E │ 0006 │ 2000 │ 5555 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0003 │ 7E │ 0006 │ 2000 │ 5555 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0003 │ 7E │ 0006 │ 2000 │ 5555 │
│ 8/1 │    │      │ RFSH │    │    │ 0000 │ 7E │ 0006 │ 2000 │ 5555 │
│ 9/0 │    │      │      │    │    │ 0006 │ 7E │ 0006 │ 2000 │ 5555 │ &lt;== extra mem read machine cycle
│ 9/1 │    │ MREQ │      │ RD │    │ 0006 │ 7E │ 0007 │ 2000 │ 5555 │
│10/0 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │
│10/1 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │
│11/0 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │
│11/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │
│12/0 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │ &lt;== 5 extra clock cycles for IX+d
│12/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │
│13/0 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5555 │
│13/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5503 │
│14/0 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5503 │
│14/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5503 │
│15/0 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5503 │
│15/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5503 │
│16/0 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 2000 │ 5503 │
│16/1 │    │      │      │    │    │ 0004 │ 03 │ 0007 │ 2000 │ 2003 │ &lt;== address ready in WZ
│17/0 │    │      │      │    │    │ 2003 │ 03 │ 0007 │ 2000 │ 2003 │ &lt;== LD A,(HL) continues
│17/1 │    │ MREQ │      │ RD │    │ 2003 │ 03 │ 0007 │ 2000 │ 2003 │
│18/0 │    │ MREQ │      │ RD │    │ 2003 │ 00 │ 0007 │ 2000 │ 2003 │
│18/1 │    │ MREQ │      │ RD │    │ 2003 │ 00 │ 0007 │ 2000 │ 2003 │
│19/0 │    │ MREQ │      │ RD │    │ 2003 │ 00 │ 0007 │ 2000 │ 2003 │
│19/1 │    │      │      │    │    │ 2003 │ 00 │ 0007 │ 2000 │ 2003 │
</code></pre></div></div>

<p>DD/FD prefixed instructions which don’t involve loading from or storing to (HL)
don’t have any surprises:</p>

<div><div><pre><code>LD IX,1111h
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IX   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0000 │ 00 │ 0000 │ 5555 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 00 │ 0001 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0000 │ DD │ 0001 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ DD │ 0001 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0000 │ DD │ 0001 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0000 │ DD │ 0001 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0000 │ DD │ 0001 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ DD │ 0001 │ 5555 │
│ 5/0 │ M1 │      │      │    │    │ 0001 │ DD │ 0001 │ 5555 │ &lt;== opcode fetch LD HL,nnnn
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0001 │ DD │ 0002 │ 5555 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0001 │ 21 │ 0002 │ 5555 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 21 │ 0002 │ 5555 │
│ 7/0 │    │      │ RFSH │    │    │ 0001 │ 21 │ 0002 │ 5555 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0001 │ 21 │ 0002 │ 5555 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0001 │ 21 │ 0002 │ 5555 │
│ 8/1 │    │      │ RFSH │    │    │ 0000 │ 21 │ 0002 │ 5555 │
│ 9/0 │    │      │      │    │    │ 0002 │ 21 │ 0002 │ 5555 │ &lt;== memory read
│ 9/1 │    │ MREQ │      │ RD │    │ 0002 │ 21 │ 0003 │ 5555 │
│10/0 │    │ MREQ │      │ RD │    │ 0002 │ 11 │ 0003 │ 5555 │
│10/1 │    │ MREQ │      │ RD │    │ 0002 │ 11 │ 0003 │ 5555 │
│11/0 │    │ MREQ │      │ RD │    │ 0002 │ 11 │ 0003 │ 5555 │
│11/1 │    │      │      │    │    │ 0002 │ 11 │ 0003 │ 5511 │
│12/0 │    │      │      │    │    │ 0003 │ 11 │ 0003 │ 5511 │ &lt;== memory read
│12/1 │    │ MREQ │      │ RD │    │ 0003 │ 11 │ 0004 │ 5511 │
│13/0 │    │ MREQ │      │ RD │    │ 0003 │ 11 │ 0004 │ 5511 │
│13/1 │    │ MREQ │      │ RD │    │ 0003 │ 11 │ 0004 │ 5511 │
│14/0 │    │ MREQ │      │ RD │    │ 0003 │ 11 │ 0004 │ 5511 │
│14/1 │    │      │      │    │    │ 0000 │ 11 │ 0004 │ 1111 │
</code></pre></div></div>

<h3 id="special-case-ld-ixdn">Special Case: LD (IX+d),n</h3>

<p>The only timing-oddity in the DD/FD-modified instruction subset is the timing of
the <strong>LD (IX/IY+d),n</strong> instruction. This is the only instruction with indexed
addressing which doesn’t simply insert 8 extra clock cycles to load the d-offset
and compute the effective address. Instead loading the immediate value <strong>n</strong> is
overlayed with the address computation cycles:</p>

<div><div><pre><code>LD (IX+3),11h
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IX   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0004 │ 10 │ 0004 │ 1000 │ 5555 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ 10 │ 0005 │ 1000 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0004 │ DD │ 0005 │ 1000 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ DD │ 0005 │ 1000 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 5/0 │ M1 │      │      │    │    │ 0005 │ DD │ 0005 │ 1000 │ 5555 │ &lt;== opcode fetch LD (HL),n
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0005 │ DD │ 0006 │ 1000 │ 5555 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0005 │ 36 │ 0006 │ 1000 │ 5555 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ 36 │ 0006 │ 1000 │ 5555 │
│ 7/0 │    │      │ RFSH │    │    │ 0003 │ 36 │ 0006 │ 1000 │ 5555 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0003 │ 36 │ 0006 │ 1000 │ 5555 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0003 │ 36 │ 0006 │ 1000 │ 5555 │
│ 8/1 │    │      │ RFSH │    │    │ 0000 │ 36 │ 0006 │ 1000 │ 5555 │
│ 9/0 │    │      │      │    │    │ 0006 │ 36 │ 0006 │ 1000 │ 5555 │ &lt;== memory read to load &#39;d&#39;
│ 9/1 │    │ MREQ │      │ RD │    │ 0006 │ 36 │ 0007 │ 1000 │ 5555 │
│10/0 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│10/1 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│11/0 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│11/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│12/0 │    │      │      │    │    │ 0007 │ 03 │ 0007 │ 1000 │ 5555 │ &lt;== memory read to load &#39;n&#39;
│12/1 │    │ MREQ │      │ RD │    │ 0007 │ 03 │ 0008 │ 1000 │ 5555 │
│13/0 │    │ MREQ │      │ RD │    │ 0007 │ 0B │ 0008 │ 1000 │ 5555 │
│13/1 │    │ MREQ │      │ RD │    │ 0007 │ 0B │ 0008 │ 1000 │ 5503 │
│14/0 │    │ MREQ │      │ RD │    │ 0007 │ 0B │ 0008 │ 1000 │ 5503 │
│14/1 │    │      │      │    │    │ 0007 │ 0B │ 0008 │ 1000 │ 5503 │
│15/0 │    │      │      │    │    │ 0007 │ 0B │ 0008 │ 1000 │ 5503 │ &lt;== 2 remaining extra clock cycles
│15/1 │    │      │      │    │    │ 0007 │ 0B │ 0008 │ 1000 │ 5503 │
│16/0 │    │      │      │    │    │ 0007 │ 0B │ 0008 │ 1000 │ 5503 │
│16/1 │    │      │      │    │    │ 0000 │ 0B │ 0008 │ 1000 │ 1003 │
│17/0 │    │      │      │    │    │ 1003 │ 0B │ 0008 │ 1000 │ 1003 │ &lt;== LD (HL),n continues
│17/1 │    │ MREQ │      │    │    │ 1003 │ 0B │ 0008 │ 1000 │ 1003 │
│18/0 │    │ MREQ │      │    │    │ 1003 │ 0B │ 0008 │ 1000 │ 1003 │
│18/1 │    │ MREQ │      │    │ WR │ 1003 │ 0B │ 0008 │ 1000 │ 1003 │
│19/0 │    │ MREQ │      │    │ WR │ 1003 │ 0B │ 0008 │ 1000 │ 1003 │
│19/1 │    │      │      │    │    │ 1003 │ 0B │ 0008 │ 1000 │ 1003 │
</code></pre></div></div>

<h2 id="ed-prefix">ED Prefix</h2>

<p>The <strong>ED</strong> prefix instruction causes the following opcode byte to be decoded
from an entirely different instruction subset. Of the 256 possible opcode slots,
only 78 are occupied (in quadrants 1 and 2), the remaining 178 instructions
execute as an ED-prefixed NOP instruction.</p>

<p>The <strong>ED</strong> prefix cancels the effects of preceding <strong>DD</strong> or <strong>FD</strong> prefixes,
so sequences of <strong>DD ED op</strong> or <strong>FD ED op</strong> execute as regular <strong>ED op</strong>.</p>

<h3 id="ed-quadrant-1-x--01">ED Quadrant 1 (x == 01)</h3>

<p>ED Quadrant 1 has quite obviously been stuffed with random instructions that didn’t fit into the
main instruction subset. It also looks like the Z80 designers didn’t care too much about making 
efficient use of the available opcodes: 8 opcode slots perform the <strong>NEG</strong> instruction,
8 more are used for the <strong>RETI/RETN</strong> instruction (despite the different names, RETI and RETN
behave identically), and 4 opcode slots are used for <strong>IM 0</strong>. Furthermore, the last two
opcode slots perform a <strong>NOP</strong>.</p>



<table>
<tbody><tr><th>x=01</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>IN B,(C)</td><td>OUT (C),B</td><td>SBC HL,BC</td><td>LD (nn),BC</td><td>NEG</td><td>RETI/RETN</td><td>IM 0</td><td>LD I,A</td></tr><tr><th>y=001</th><td>IN C,(C)</td><td>OUT (C),C</td><td>ADC HL,BC</td><td>LD BC,(nn)</td><td>NEG</td><td>RETI/RETN</td><td>IM 0</td><td>LD R,A</td></tr><tr><th>y=010</th><td>IN D,(C)</td><td>OUT (C),D</td><td>SBC HL,DE</td><td>LD (nn),DE</td><td>NEG</td><td>RETI/RETN</td><td>IM 1</td><td>LD A,I</td></tr><tr><th>y=011</th><td>IN E,(C)</td><td>OUT (C),E</td><td>ADC HL,DE</td><td>LD DE,(nn)</td><td>NEG</td><td>RETI/RETN</td><td>IM 2</td><td>LD A,R</td></tr><tr><th>y=100</th><td>IN H,(C)</td><td>OUT (C),H</td><td>SBC HL,HL</td><td>LD (nn),HL</td><td>NEG</td><td>RETI/RETN</td><td>IM 0</td><td>RRD</td></tr><tr><th>y=101</th><td>IN L,(C)</td><td>OUT (C),L</td><td>ADC HL,HL</td><td>LD HL,(nn)</td><td>NEG</td><td>RETI/RETN</td><td>IM 0</td><td>RLD</td></tr><tr><th>y=110</th><td>IN (C)</td><td>OUT (C),0</td><td>SBC HL,SP</td><td>LD (nn),SP</td><td>NEG</td><td>RETI/RETN</td><td>IM 1</td><td>ED NOP</td></tr><tr><th>y=111</th><td>IN A,(C)</td><td>OUT (C),A</td><td>ADC HL,SP</td><td>LD SP,(nn)</td><td>NEG</td><td>RETI/RETN</td><td>IM 2</td><td>ED NOP</td></tr>
</tbody></table>


<h4 id="sbcadc-hlss">SBC/ADC HL,ss</h4>

<p>The 16-bit SBC and ADC instructions have the same timings and add 7 clock cycles
to compute the result. The WZ register seems to be used as intermediate storage,
but it doesn’t hold the result, instead it is set to HL+1:</p>

<div><div><pre><code>ADC HL,DE
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ DE   │ HL   │ WZ   │ Flags    │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 0007 │ 11 │ 0007 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0007 │ 11 │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0007 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 5/0 │ M1 │      │      │    │    │ 0008 │ ED │ 0008 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │ &lt;== opcode fetch 
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ ED │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0008 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 7/0 │    │      │ RFSH │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 8/1 │    │      │ RFSH │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│ 9/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │ &lt;== 7 extra clock cycles
│ 9/1 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│10/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 5555 │ sZyhxVnc │
│10/1 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 2223 │ sZyhxVnc │
│11/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2222 │ 2223 │ sZyhxVnc │
│11/1 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │ &lt;== result low byte ready
│12/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│12/1 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│13/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│13/1 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│14/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│14/1 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│15/0 │    │      │      │    │    │ 0004 │ 5A │ 0009 │ 1111 │ 2233 │ 2223 │ sZyhxVnc │
│15/1 │    │      │      │    │    │ 0000 │ 5A │ 0009 │ 1111 │ 3333 │ 2223 │ sZyhxVnc │ &lt;== result high byte ready
</code></pre></div></div>

<p>The flag bit update happens overlapped in the next opcode fetch:</p>

<div><div><pre><code>ADC HL,DE continued: following opcode fetch
┌─────┬────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┬──────────┐
│  T  │ M1 │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ DE   │ HL   │ WZ   │ Flags    │
├─────┼────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │ M1 │      │      │    │    │ 0009 │ 5A │ 0009 │ 1111 │ 3333 │ 2223 │ sZyhxVnc │ &lt;== opcode fetch
│ 1/1 │ M1 │ M1 │ MREQ │      │ RD │    │ 0009 │ 5A │ 000A │ 1111 │ 3333 │ 2223 │ sZyhxVnc │
│ 2/0 │ M1 │ M1 │ MREQ │      │ RD │    │ 0009 │ 00 │ 000A │ 1111 │ 3333 │ 2223 │ sZyhxVnc │
│ 2/1 │ M1 │ M1 │ MREQ │      │ RD │    │ 0008 │ 00 │ 000A │ 1111 │ 3333 │ 2223 │ sZyhxVnc │
│ 3/0 │    │    │      │ RFSH │    │    │ 0005 │ 00 │ 000A │ 1111 │ 3333 │ 2223 │ sZyhxVnc │
│ 3/1 │    │    │ MREQ │ RFSH │    │    │ 0005 │ 00 │ 000A │ 1111 │ 3333 │ 2223 │ szYhxvnc │ &lt;== flags updated here
│ 4/0 │    │    │ MREQ │ RFSH │    │    │ 0005 │ 00 │ 000A │ 1111 │ 3333 │ 2223 │ szYhxvnc │
│ 4/1 │    │    │      │ RFSH │    │    │ 0004 │ 00 │ 000A │ 1111 │ 3333 │ 2223 │ szYhxvnc │
</code></pre></div></div>

<h4 id="ld-ia-and-ld-ra">LD I,A and LD R,A</h4>

<p>The <strong>LD I,A</strong> and <strong>LD R,A</strong> instructions add an extra clock cycle after the opcode fetch.
It’s interesting though that the data transfer already happens in the last
half cycle of the opcode fetch machine cycle.</p>

<div><div><pre><code>LD I,A
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ AF   │ I  │ R  │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼────┼────┤
│ 1/0 │ M1 │      │      │    │    │ 0002 │ 01 │ 0002 │ 5555 │ 00 │ 01 │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0002 │ 01 │ 0003 │ 5555 │ 00 │ 01 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0002 │ ED │ 0003 │ 5555 │ 00 │ 01 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0002 │ ED │ 0003 │ 0155 │ 00 │ 01 │
│ 3/0 │    │      │ RFSH │    │    │ 0001 │ ED │ 0003 │ 0155 │ 00 │ 01 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0001 │ ED │ 0003 │ 0155 │ 00 │ 02 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0001 │ ED │ 0003 │ 0155 │ 00 │ 02 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 0003 │ 0155 │ 00 │ 02 │
│ 5/0 │ M1 │      │      │    │    │ 0003 │ ED │ 0003 │ 0155 │ 00 │ 02 │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ ED │ 0004 │ 0155 │ 00 │ 02 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 47 │ 0004 │ 0155 │ 00 │ 02 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 47 │ 0004 │ 0155 │ 00 │ 02 │
│ 7/0 │    │      │ RFSH │    │    │ 0002 │ 47 │ 0004 │ 0155 │ 00 │ 02 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 47 │ 0004 │ 0155 │ 00 │ 03 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 47 │ 0004 │ 0155 │ 00 │ 03 │
│ 8/1 │    │      │ RFSH │    │    │ 0002 │ 47 │ 0004 │ 0155 │ 01 │ 03 │ &lt;== I has been updated
│ 9/0 │    │      │      │    │    │ 0002 │ 47 │ 0004 │ 0155 │ 01 │ 03 │ &lt;== extra clock cycle
│ 9/1 │    │      │      │    │    │ 0002 │ 47 │ 0004 │ 0155 │ 01 │ 03 │
</code></pre></div></div>

<div><div><pre><code>LD R,A
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬────┬────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ AF   │ I  │ R  │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼────┼────┤
│ 1/0 │ M1 │      │      │    │    │ 0005 │ 3C │ 0005 │ 0155 │ 01 │ 04 │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0005 │ 3C │ 0006 │ 0155 │ 01 │ 04 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0005 │ ED │ 0006 │ 0155 │ 01 │ 04 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ ED │ 0006 │ 0255 │ 01 │ 04 │
│ 3/0 │    │      │ RFSH │    │    │ 0104 │ ED │ 0006 │ 0255 │ 01 │ 04 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0104 │ ED │ 0006 │ 0201 │ 01 │ 05 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0104 │ ED │ 0006 │ 0201 │ 01 │ 05 │
│ 4/1 │    │      │ RFSH │    │    │ 0104 │ ED │ 0006 │ 0201 │ 01 │ 05 │
│ 5/0 │ M1 │      │      │    │    │ 0006 │ ED │ 0006 │ 0201 │ 01 │ 05 │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ ED │ 0007 │ 0201 │ 01 │ 05 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0006 │ 4F │ 0007 │ 0201 │ 01 │ 05 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0006 │ 4F │ 0007 │ 0201 │ 01 │ 05 │
│ 7/0 │    │      │ RFSH │    │    │ 0105 │ 4F │ 0007 │ 0201 │ 01 │ 05 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0105 │ 4F │ 0007 │ 0201 │ 01 │ 06 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0105 │ 4F │ 0007 │ 0201 │ 01 │ 06 │
│ 8/1 │    │      │ RFSH │    │    │ 0105 │ 4F │ 0007 │ 0201 │ 01 │ 02 │ &lt;== R has been updated
│ 9/0 │    │      │      │    │    │ 0105 │ 4F │ 0007 │ 0201 │ 01 │ 02 │ &lt;== extra clock cycle
│ 9/1 │    │      │      │    │    │ 0100 │ 4F │ 0007 │ 0201 │ 01 │ 02 │
</code></pre></div></div>

<h4 id="ld-ai-and-ld-ar">LD A,I and LD A,R</h4>

<p>The <strong>LD A,I</strong> and <strong>LD A,R</strong> instructions also add an extra cycle at the end, but the A register
and flags are only updated during the opcode fetch of the next instruction:</p>

<div><div><pre><code>LD A,R
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬────┬────┬──────────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ AF   │ I  │ R  │ Flags    │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼────┼────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 0001 │ AF │ 0001 │ 5555 │ 00 │ 01 │ sZyHxVnC │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0001 │ AF │ 0002 │ 5555 │ 00 │ 01 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0001 │ ED │ 0002 │ 5555 │ 00 │ 01 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ ED │ 0002 │ 0055 │ 00 │ 01 │ sZyHxVnC │
│ 3/0 │    │      │ RFSH │    │    │ 0001 │ ED │ 0002 │ 0055 │ 00 │ 01 │ sZyHxVnC │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0001 │ ED │ 0002 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0001 │ ED │ 0002 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 0002 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 5/0 │ M1 │      │      │    │    │ 0002 │ ED │ 0002 │ 0044 │ 00 │ 02 │ sZyhxVnc │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0002 │ ED │ 0003 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 7/0 │    │      │ RFSH │    │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 02 │ sZyhxVnc │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 03 │ sZyhxVnc │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 03 │ sZyhxVnc │
│ 8/1 │    │      │ RFSH │    │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 03 │ sZyhxVnc │
│ 9/0 │    │      │      │    │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 03 │ sZyhxVnc │ &lt;== extra clock cycle
│ 9/1 │    │      │      │    │    │ 0002 │ 5F │ 0003 │ 0044 │ 00 │ 03 │ sZyhxVnc │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼────┼────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 0003 │ 5F │ 0003 │ 0044 │ 00 │ 03 │ sZyhxVnc │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0003 │ 5F │ 0004 │ 0044 │ 00 │ 03 │ sZyhxVnc │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0003 │ 00 │ 0004 │ 0044 │ 00 │ 03 │ sZyhxVnc │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 00 │ 0004 │ 0344 │ 00 │ 03 │ sZyhxVnc │ &lt;== result in A
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ 00 │ 0004 │ 0344 │ 00 │ 03 │ sZyhxVnc │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ 00 │ 0004 │ 0300 │ 00 │ 04 │ szyhxvnc │ &lt;== flag bits updated
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ 00 │ 0004 │ 0300 │ 00 │ 04 │ szyhxvnc │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ 00 │ 0004 │ 0300 │ 00 │ 04 │ szyhxvnc │
</code></pre></div></div>

<h4 id="rrd-and-rld">RRD and RLD</h4>

<p>The <strong>RRD</strong> and <strong>RLD</strong> instructions add 4 extra clock cycles between the memory read
and write machine cycle. The A register and flag bits are updated during the
opcode fetch of the next instruction:</p>

<div><div><pre><code>RLD:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ AF   │ HL   │ Flags    │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 0007 │ 56 │ 0007 │ 5555 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0007 │ 56 │ 0008 │ 5555 │ 1000 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0007 │ ED │ 0008 │ 5555 │ 1000 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ ED │ 0008 │ 5655 │ 1000 │ sZyHxVnC │
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ ED │ 0008 │ 5655 │ 1000 │ sZyHxVnC │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 0008 │ 5655 │ 1000 │ sZyHxVnC │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 0008 │ 5655 │ 1000 │ sZyHxVnC │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 0008 │ 5655 │ 1000 │ sZyHxVnC │
│ 5/0 │ M1 │      │      │    │    │ 0008 │ ED │ 0008 │ 5655 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ ED │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0008 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 7/0 │    │      │ RFSH │    │    │ 0004 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0004 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0004 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 8/1 │    │      │ RFSH │    │    │ 0004 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│ 9/0 │    │      │      │    │    │ 1000 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │ &lt;== memory read
│ 9/1 │    │ MREQ │      │ RD │    │ 1000 │ 6F │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│10/0 │    │ MREQ │      │ RD │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│10/1 │    │ MREQ │      │ RD │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│11/0 │    │ MREQ │      │ RD │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│11/1 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│12/0 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │ &lt;== 4 extra clock cycles
│12/1 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│13/0 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│13/1 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│14/0 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│14/1 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│15/0 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│15/1 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│16/0 │    │      │      │    │    │ 1000 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │ &lt;== memory write
│16/1 │    │ MREQ │      │    │    │ 1000 │ 46 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│17/0 │    │ MREQ │      │    │    │ 1000 │ 46 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│17/1 │    │ MREQ │      │    │ WR │ 1000 │ 46 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│18/0 │    │ MREQ │      │    │ WR │ 1000 │ 46 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
│18/1 │    │      │      │    │    │ 1000 │ 46 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 0009 │ 34 │ 0009 │ 5655 │ 1000 │ sZyHxVnC │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0009 │ 34 │ 000A │ 5655 │ 1000 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0009 │ 00 │ 000A │ 5655 │ 1000 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ 00 │ 000A │ 5355 │ 1000 │ sZyHxVnC │ &lt;== A register updated
│ 3/0 │    │      │ RFSH │    │    │ 0005 │ 00 │ 000A │ 5355 │ 1000 │ sZyHxVnC │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0005 │ 00 │ 000A │ 5305 │ 1000 │ szyhxVnC │ &lt;== flag bits updated
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0005 │ 00 │ 000A │ 5305 │ 1000 │ szyhxVnC │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ 00 │ 000A │ 5305 │ 1000 │ szyhxVnC │
</code></pre></div></div>

<h3 id="ed-quadrant-2-x--10">ED Quadrant 2 (x == 10)</h3>

<p>The ED Quadrant 2 only houses the 16 block transfer instructions, the remaining 48
opcode slots are filled with NOPs.</p>



<table>
<tbody><tr><th>x=10</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=001</th><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=010</th><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=011</th><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=100</th><td>LDI</td><td>CPI</td><td>INI</td><td>OUTI</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=101</th><td>LDD</td><td>CPD</td><td>IND</td><td>OUTD</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=110</th><td>LDIR</td><td>CPIR</td><td>INIR</td><td>OTIR</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr><tr><th>y=111</th><td>LDDR</td><td>CPDR</td><td>INDR</td><td>OTDR</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td><td>ED NOP</td></tr>
</tbody></table>


<h4 id="ldi-and-ldd">LDI and LDD</h4>

<p>The <strong>LDI</strong> and <strong>LDD</strong> instructions add two extra clock cycles after the memory write machine cycle:</p>

<div><div><pre><code>LDI:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ DE   │ HL   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0009 │ 00 │ 0009 │ 0002 │ 2000 │ 1000 │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0009 │ 00 │ 000A │ 0002 │ 2000 │ 1000 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0009 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 5/0 │ M1 │      │      │    │    │ 000A │ ED │ 000A │ 0002 │ 2000 │ 1000 │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 000A │ ED │ 000B │ 0002 │ 2000 │ 1000 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 000A │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 000A │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 7/0 │    │      │ RFSH │    │    │ 0004 │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0004 │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0004 │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 8/1 │    │      │ RFSH │    │    │ 0004 │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 9/0 │    │      │      │    │    │ 1000 │ A0 │ 000B │ 0002 │ 2000 │ 1000 │ &lt;== memory read
│ 9/1 │    │ MREQ │      │ RD │    │ 1000 │ A0 │ 000B │ 0002 │ 2000 │ 1000 │
│10/0 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1000 │
│10/1 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │ &lt;== HL incremented
│11/0 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│11/1 │    │      │      │    │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│12/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │ &lt;== memory write
│12/1 │    │ MREQ │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│13/0 │    │ MREQ │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│13/1 │    │ MREQ │      │    │ WR │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │ &lt;== DE incremented
│14/0 │    │ MREQ │      │    │ WR │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │
│14/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │
│15/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │ &lt;== 2 extra clock cycles
│15/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │ &lt;== BC decremented
│16/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│16/1 │    │      │      │    │    │ 0000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
</code></pre></div></div>

<h4 id="ldir-and-lddr">LDIR and LDDR</h4>

<p>On the last iteration (BC == 0), <strong>LDIR</strong> and <strong>LDDR</strong> have the same timing as
<strong>LDI</strong> and <strong>LDD</strong>, otherwise they add another 5 clock cycles to rewind <strong>PC</strong>
back to the start of the instruction.</p>

<div><div><pre><code>LDIR - looping
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ DE   │ HL   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0009 │ 00 │ 0009 │ 0002 │ 2000 │ 1000 │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0009 │ 00 │ 000A │ 0002 │ 2000 │ 1000 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0009 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 000A │ 0002 │ 2000 │ 1000 │
│ 5/0 │ M1 │      │      │    │    │ 000A │ ED │ 000A │ 0002 │ 2000 │ 1000 │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 000A │ ED │ 000B │ 0002 │ 2000 │ 1000 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 000A │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 000A │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 7/0 │    │      │ RFSH │    │    │ 0004 │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0004 │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0004 │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 8/1 │    │      │ RFSH │    │    │ 0004 │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│ 9/0 │    │      │      │    │    │ 1000 │ B0 │ 000B │ 0002 │ 2000 │ 1000 │ &lt;== memory read (HL++)
│ 9/1 │    │ MREQ │      │ RD │    │ 1000 │ B0 │ 000B │ 0002 │ 2000 │ 1000 │
│10/0 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1000 │
│10/1 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│11/0 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│11/1 │    │      │      │    │    │ 1000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│12/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │ &lt;== memory write (DE++)
│12/1 │    │ MREQ │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│13/0 │    │ MREQ │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2000 │ 1001 │
│13/1 │    │ MREQ │      │    │ WR │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │
│14/0 │    │ MREQ │      │    │ WR │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │
│14/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │ &lt;== 2 clock cycles: BC--
│15/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0002 │ 2001 │ 1001 │
│15/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│16/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│16/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │ &lt;== last half cycle if BC==0
│17/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │ &lt;== 5 extra clock cycles PC -= 2
│17/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│18/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│18/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│19/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│19/1 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│20/0 │    │      │      │    │    │ 2000 │ 00 │ 000B │ 0001 │ 2001 │ 1001 │
│20/1 │    │      │      │    │    │ 2000 │ 00 │ 0009 │ 0001 │ 2001 │ 1001 │ &lt;== PC ready
│21/0 │    │      │      │    │    │ 2000 │ 00 │ 0009 │ 0001 │ 2001 │ 1001 │
│21/1 │    │      │      │    │    │ 0000 │ 00 │ 0009 │ 0001 │ 2001 │ 1001 │
</code></pre></div></div>

<h4 id="cpi-and-cpd">CPI and CPD</h4>

<p>The <strong>CPI</strong> and <strong>CPD</strong> instructions add 5 extra clock cycles. The flag bits
are updated during the opcode fetch of the next instruction:</p>

<div><div><pre><code>CPI
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ AF   │ BC   │ HL   │ Flags    │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 0008 │ 11 │ 0008 │ 5555 │ 0002 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ 11 │ 0009 │ 5555 │ 0002 │ 1000 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0008 │ ED │ 0009 │ 5555 │ 0002 │ 1000 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ ED │ 0009 │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 3/0 │    │      │ RFSH │    │    │ 0003 │ ED │ 0009 │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 0009 │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0003 │ ED │ 0009 │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ ED │ 0009 │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 5/0 │ M1 │      │      │    │    │ 0009 │ ED │ 0009 │ 1155 │ 0002 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0009 │ ED │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0009 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 7/0 │    │      │ RFSH │    │    │ 0004 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0004 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0004 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 8/1 │    │      │ RFSH │    │    │ 0004 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│ 9/0 │    │      │      │    │    │ 1000 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │ &lt;== memory read
│ 9/1 │    │ MREQ │      │ RD │    │ 1000 │ A1 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│10/0 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1000 │ sZyHxVnC │
│10/1 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │ &lt;== HL incremented
│11/0 │    │ MREQ │      │ RD │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│11/1 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│12/0 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │ &lt;== 5 extra clock cycles
│12/1 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│13/0 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│13/1 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│14/0 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│14/1 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│15/0 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0002 │ 1001 │ sZyHxVnC │
│15/1 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0001 │ 1001 │ sZyHxVnC │ &lt;== BC decremented
│16/0 │    │      │      │    │    │ 1000 │ 00 │ 000A │ 1155 │ 0001 │ 1001 │ sZyHxVnC │
│16/1 │    │      │      │    │    │ 0000 │ 00 │ 000A │ 1155 │ 0001 │ 1001 │ sZyHxVnC │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │    │    │ 000A │ 00 │ 000A │ 1155 │ 0001 │ 1001 │ sZyHxVnC │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 000A │ 00 │ 000B │ 1155 │ 0001 │ 1001 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 000A │ 00 │ 000B │ 1155 │ 0001 │ 1001 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 000A │ 00 │ 000B │ 1155 │ 0001 │ 1001 │ sZyHxVnC │
│ 3/0 │    │      │ RFSH │    │    │ 0005 │ 00 │ 000B │ 1155 │ 0001 │ 1001 │ sZyHxVnC │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0005 │ 00 │ 000B │ 1107 │ 0001 │ 1001 │ szyhxVNC │ &lt;== flag bits updated
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0005 │ 00 │ 000B │ 1107 │ 0001 │ 1001 │ szyhxVNC │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ 00 │ 000B │ 1107 │ 0001 │ 1001 │ szyhxVNC │
</code></pre></div></div>

<h4 id="cpir-and-cpdr">CPIR and CPDR</h4>

<p>On the last iteration (BC == 0 or A == (HL)), <strong>CPIR</strong> and <strong>CPDR</strong> timing is identical
with <strong>CPI</strong> and <strong>CPDR</strong>, otherwise 5 additional clock cycles are added to rewind
<strong>PC</strong> back to the start of the instruction:</p>

<div><div><pre><code>CPIR - looping:
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ AF   │ BC   │ HL   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 000A │ 22 │ 000A │ 5555 │ 0002 │ 1000 │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 000A │ 22 │ 000B │ 5555 │ 0002 │ 1000 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 000A │ ED │ 000B │ 5555 │ 0002 │ 1000 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 000A │ ED │ 000B │ 2255 │ 0002 │ 1000 │
│ 3/0 │    │      │ RFSH │    │    │ 0004 │ ED │ 000B │ 2255 │ 0002 │ 1000 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0004 │ ED │ 000B │ 2255 │ 0002 │ 1000 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0004 │ ED │ 000B │ 2255 │ 0002 │ 1000 │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ ED │ 000B │ 2255 │ 0002 │ 1000 │
│ 5/0 │ M1 │      │      │    │    │ 000B │ ED │ 000B │ 2255 │ 0002 │ 1000 │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 000B │ ED │ 000C │ 2255 │ 0002 │ 1000 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 000B │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│ 7/0 │    │      │ RFSH │    │    │ 0005 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0005 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0005 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│ 8/1 │    │      │ RFSH │    │    │ 0004 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│ 9/0 │    │      │      │    │    │ 1000 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │ &lt;== memory read
│ 9/1 │    │ MREQ │      │ RD │    │ 1000 │ B1 │ 000C │ 2255 │ 0002 │ 1000 │
│10/0 │    │ MREQ │      │ RD │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1000 │
│10/1 │    │ MREQ │      │ RD │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │ &lt;== HL incremented
│11/0 │    │ MREQ │      │ RD │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│11/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│12/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │ &lt;== 5 extra clock cycles BC--
│12/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│13/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│13/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│14/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│14/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│15/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0002 │ 1001 │
│15/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │ &lt;== BC decremented
│16/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│16/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │ &lt;== last half-cycle if BC==0 or A==(HL)
│17/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │ &lt;== 5 more clock cycles PC -= 2
│17/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│18/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│18/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│19/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│19/1 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│20/0 │    │      │      │    │    │ 1000 │ 11 │ 000C │ 2255 │ 0001 │ 1001 │
│20/1 │    │      │      │    │    │ 1000 │ 11 │ 000A │ 2255 │ 0001 │ 1001 │ &lt;== PC ready here
│21/0 │    │      │      │    │    │ 1000 │ 11 │ 000A │ 2255 │ 0001 │ 1001 │
│21/1 │    │      │      │    │    │ 0000 │ 11 │ 000A │ 2255 │ 0001 │ 1001 │
</code></pre></div></div>

<h4 id="ini-and-ind">INI and IND</h4>

<p>The <strong>INI</strong> and <strong>IND</strong> instructions insert an extra clock cycle between
the opcode fetch and IO read machine cycle. The flag bits are updated
in the opcode fetch of the next instruction:</p>

<div><div><pre><code>INI
┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ HL   │ Flags    │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0006 │ 02 │ 0006 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ 02 │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 3/0 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 4/1 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 5/0 │ M1 │      │      │      │    │    │ 0007 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │ 0007 │ ED │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │ 0007 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 7/0 │    │      │      │ RFSH │    │    │ 0003 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │ 0003 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │ 0003 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 8/1 │    │      │      │ RFSH │    │    │ 0003 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 9/0 │    │      │      │      │    │    │ 0003 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== one extra clock cycle
│ 9/1 │    │      │      │      │    │    │ 0000 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│10/0 │    │      │      │      │    │    │ 0280 │ A2 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== IO read
│10/1 │    │      │      │      │    │    │ 0280 │ A2 │ 0008 │ 0180 │ 1000 │ sZyHxVnC │ &lt;== B decremented
│11/0 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│11/1 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│12/0 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│12/1 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│13/0 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│13/1 │    │      │      │      │    │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│14/0 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │ &lt;== memory write
│14/1 │    │ MREQ │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│15/0 │    │ MREQ │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│15/1 │    │ MREQ │      │      │    │ WR │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │ &lt;== HL incremented
│16/0 │    │ MREQ │      │      │    │ WR │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│16/1 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0008 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0008 │ FF │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0008 │ 00 │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0008 │ 00 │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 3/0 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ szyHxvNC │ &lt;== flag bits updated
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ szyHxvNC │
│ 4/1 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ szyHxvNC │
</code></pre></div></div>

<h4 id="outi-and-outd">OUTI and OUTD</h4>

<p>The <strong>OUTI</strong> and <strong>OUTD</strong> instructions are identical with <strong>INI</strong> and <strong>IND</strong> except
that the IO read is replaced with a memory read machine cycle, and the memory write
is replaced with an IO write machine cycle:</p>

<div><div><pre><code>OUTI
┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ HL   │ Flags    │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0006 │ 02 │ 0006 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ 02 │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 3/0 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 4/1 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │
│ 5/0 │ M1 │      │      │      │    │    │ 0007 │ ED │ 0007 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │ 0007 │ ED │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │ 0007 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 7/0 │    │      │      │ RFSH │    │    │ 0003 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │ 0003 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │ 0003 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 8/1 │    │      │      │ RFSH │    │    │ 0003 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│ 9/0 │    │      │      │      │    │    │ 0003 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== one extra clock cycle
│ 9/1 │    │      │      │      │    │    │ 0000 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │
│10/0 │    │      │      │      │    │    │ 1000 │ A3 │ 0008 │ 0280 │ 1000 │ sZyHxVnC │ &lt;== memory read
│10/1 │    │ MREQ │      │      │ RD │    │ 1000 │ A3 │ 0008 │ 0180 │ 1000 │ sZyHxVnC │ &lt;== B decremented
│11/0 │    │ MREQ │      │      │ RD │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │ sZyHxVnC │
│11/1 │    │ MREQ │      │      │ RD │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │ &lt;== HL incremented
│12/0 │    │ MREQ │      │      │ RD │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│12/1 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│13/0 │    │      │      │      │    │    │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │ &lt;== IO write
│13/1 │    │      │      │      │    │    │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│14/0 │    │      │ IORQ │      │    │ WR │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│14/1 │    │      │ IORQ │      │    │ WR │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│15/0 │    │      │ IORQ │      │    │ WR │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│15/1 │    │      │ IORQ │      │    │ WR │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│16/0 │    │      │ IORQ │      │    │ WR │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
│16/1 │    │      │      │      │    │    │ 0180 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0008 │ FF │ 0008 │ 0180 │ 1001 │ sZyHxVnC │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0008 │ FF │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0008 │ 00 │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0008 │ 00 │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 3/0 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ sZyHxVnC │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ szyHxvNC │ &lt;== flag bits updated here
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ szyHxvNC │
│ 4/1 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0009 │ 0180 │ 1001 │ szyHxvNC │
</code></pre></div></div>

<h4 id="inir-indr-otir-and-otdr">INIR, INDR, OTIR and OTDR</h4>

<p>The <strong>INIR</strong>, <strong>INDR</strong>, <strong>OTIR</strong> and <strong>OTDR</strong> instructions are identical with their
respecitve non-repeating versions for the last iteration (when B reaches zero).</p>

<p>When repeating (B != 0), 5 extra clock cycles are added to rewind <strong>PC</strong>
back to the start of the instruction:</p>

<div><div><pre><code>INIR:

┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ HL   │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0006 │ 02 │ 0006 │ 0280 │ 1000 │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ 02 │ 0007 │ 0280 │ 1000 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ ED │ 0007 │ 0280 │ 1000 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0006 │ ED │ 0007 │ 0280 │ 1000 │
│ 3/0 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │
│ 4/1 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0007 │ 0280 │ 1000 │
│ 5/0 │ M1 │      │      │      │    │    │ 0007 │ ED │ 0007 │ 0280 │ 1000 │ &lt;== opcode fetch
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │ 0007 │ ED │ 0008 │ 0280 │ 1000 │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │ 0007 │ B2 │ 0008 │ 0280 │ 1000 │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ B2 │ 0008 │ 0280 │ 1000 │
│ 7/0 │    │      │      │ RFSH │    │    │ 0003 │ B2 │ 0008 │ 0280 │ 1000 │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │ 0003 │ B2 │ 0008 │ 0280 │ 1000 │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │ 0003 │ B2 │ 0008 │ 0280 │ 1000 │
│ 8/1 │    │      │      │ RFSH │    │    │ 0003 │ B2 │ 0008 │ 0280 │ 1000 │
│ 9/0 │    │      │      │      │    │    │ 0003 │ B2 │ 0008 │ 0280 │ 1000 │ &lt;== one extra clock cycle
│ 9/1 │    │      │      │      │    │    │ 0000 │ B2 │ 0008 │ 0280 │ 1000 │
│10/0 │    │      │      │      │    │    │ 0280 │ B2 │ 0008 │ 0280 │ 1000 │ &lt;== IO read
│10/1 │    │      │      │      │    │    │ 0280 │ B2 │ 0008 │ 0180 │ 1000 │ &lt;== B decremented
│11/0 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │
│11/1 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │
│12/0 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │
│12/1 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │
│13/0 │    │      │ IORQ │      │ RD │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │
│13/1 │    │      │      │      │    │    │ 0280 │ FF │ 0008 │ 0180 │ 1000 │
│14/0 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │ &lt;== memory write
│14/1 │    │ MREQ │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │
│15/0 │    │ MREQ │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1000 │
│15/1 │    │ MREQ │      │      │    │ WR │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ &lt;== HL incremented
│16/0 │    │ MREQ │      │      │    │ WR │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│16/1 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│17/0 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │ &lt;== 5 extra clock cycles PC-=2
│17/1 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│18/0 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│18/1 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│19/0 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│19/1 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│20/0 │    │      │      │      │    │    │ 1000 │ FF │ 0008 │ 0180 │ 1001 │
│20/1 │    │      │      │      │    │    │ 1000 │ FF │ 0006 │ 0180 │ 1001 │ &lt;== PC ready
│21/0 │    │      │      │      │    │    │ 1000 │ FF │ 0006 │ 0180 │ 1001 │
│21/1 │    │      │      │      │    │    │ 0000 │ FF │ 0006 │ 0180 │ 1001 │
</code></pre></div></div>

<h2 id="cb-prefix">CB Prefix</h2>

<p>The CB instruction subset is the most ‘orderly’ and contains bit-manipulation and -testing instructions
Timing is as expected (2 opcode fetch machine cycles, 8 clock cycles), except for the read-modify-write instructions
involving (HL) which insert an extra clock cycle between the memory read and memory write machine cycle
and take 15 clock cycles:</p>

<ul>
  <li>opcode fetch CB prefix: 4 clock cycles</li>
  <li>opcode fetch: 4 clock cycles</li>
  <li>memory read: 3 clock cycles</li>
  <li>1 extra clock cycle</li>
  <li>memory write: 3 clock cycles</li>
</ul>

<p>4 + 4 + 3 + 1 + 3 = <strong>15 clock cycles</strong></p>

<p>The <strong>BIT x,(HL)</strong> instructions in CB quadrant 1 don’t have the memory write cycle, but still add 
an extra clock cycle after the memory read:</p>

<ul>
  <li>opcode fetch CB prefix: 4 clock cycles</li>
  <li>opcode fetch: 4 clock cycles</li>
  <li>memory read: 3 clock cycles</li>
  <li>1 extra clock cycle</li>
</ul>

<p>4 + 4 + 3 + 1 = <strong>12 clock cycles</strong></p>

<h3 id="cb-quadrant-0">CB Quadrant 0</h3>

<p>The first CB quadrant contains rotate and shift instructions:</p>



<table>
<tbody><tr><th>x=00</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>RLC B</td><td>RLC C</td><td>RLC D</td><td>RLC E</td><td>RLC H</td><td>RLC L</td><td>RLC (HL)</td><td>RLC A</td></tr><tr><th>y=001</th><td>RRC B</td><td>RRC C</td><td>RRC D</td><td>RRC E</td><td>RRC H</td><td>RRC L</td><td>RRC (HL)</td><td>RRC A</td></tr><tr><th>y=010</th><td>RL B</td><td>RL C</td><td>RL D</td><td>RL E</td><td>RL H</td><td>RL L</td><td>RL (HL)</td><td>RL A</td></tr><tr><th>y=011</th><td>RR B</td><td>RR C</td><td>RR D</td><td>RR E</td><td>RR H</td><td>RR L</td><td>RR (HL)</td><td>RR A</td></tr><tr><th>y=100</th><td>SLA B</td><td>SLA C</td><td>SLA D</td><td>SLA E</td><td>SLA H</td><td>SLA L</td><td>SLA (HL)</td><td>SLA A</td></tr><tr><th>y=101</th><td>SRA B</td><td>SRA C</td><td>SRA D</td><td>SRA E</td><td>SRA H</td><td>SRA L</td><td>SRA (HL)</td><td>SRA A</td></tr><tr><th>y=110</th><td>SLL B</td><td>SLL C</td><td>SLL D</td><td>SLL E</td><td>SLL H</td><td>SLL L</td><td>SLL (HL)</td><td>SLL A</td></tr><tr><th>y=111</th><td>SRL B</td><td>SRL C</td><td>SRL D</td><td>SRL E</td><td>SRL H</td><td>SRL L</td><td>SRL (HL)</td><td>SRL A</td></tr>
</tbody></table>


<h3 id="cb-quadrant-1">CB Quadrant 1</h3>

<p>CB Quadrant one contains the bit testing instructions in all 64 possible combinations:</p>



<table>
<tbody><tr><th>x=01</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>BIT 0,B</td><td>BIT 0,C</td><td>BIT 0,D</td><td>BIT 0,E</td><td>BIT 0,H</td><td>BIT 0,L</td><td>BIT 0,(HL)</td><td>BIT 0,A</td></tr><tr><th>y=001</th><td>BIT 1,B</td><td>BIT 1,C</td><td>BIT 1,D</td><td>BIT 1,E</td><td>BIT 1,H</td><td>BIT 1,L</td><td>BIT 1,(HL)</td><td>BIT 1,A</td></tr><tr><th>y=010</th><td>BIT 2,B</td><td>BIT 2,C</td><td>BIT 2,D</td><td>BIT 2,E</td><td>BIT 2,H</td><td>BIT 2,L</td><td>BIT 2,(HL)</td><td>BIT 2,A</td></tr><tr><th>y=011</th><td>BIT 3,B</td><td>BIT 3,C</td><td>BIT 3,D</td><td>BIT 3,E</td><td>BIT 3,H</td><td>BIT 3,L</td><td>BIT 3,(HL)</td><td>BIT 3,A</td></tr><tr><th>y=100</th><td>BIT 4,B</td><td>BIT 4,C</td><td>BIT 4,D</td><td>BIT 4,E</td><td>BIT 4,H</td><td>BIT 4,L</td><td>BIT 4,(HL)</td><td>BIT 4,A</td></tr><tr><th>y=101</th><td>BIT 5,B</td><td>BIT 5,C</td><td>BIT 5,D</td><td>BIT 5,E</td><td>BIT 5,H</td><td>BIT 5,L</td><td>BIT 5,(HL)</td><td>BIT 5,A</td></tr><tr><th>y=110</th><td>BIT 6,B</td><td>BIT 6,C</td><td>BIT 6,D</td><td>BIT 6,E</td><td>BIT 6,H</td><td>BIT 6,L</td><td>BIT 6,(HL)</td><td>BIT 6,A</td></tr><tr><th>y=111</th><td>BIT 7,B</td><td>BIT 7,C</td><td>BIT 7,D</td><td>BIT 7,E</td><td>BIT 7,H</td><td>BIT 7,L</td><td>BIT 7,(HL)</td><td>BIT 7,A</td></tr>
</tbody></table>


<h3 id="cb-quadrant-2">CB Quadrant 2</h3>

<p>CB Quadrant 2 has all the bit clear instructions…</p>



<table>
<tbody><tr><th>x=10</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>RES 0,B</td><td>RES 0,C</td><td>RES 0,D</td><td>RES 0,E</td><td>RES 0,H</td><td>RES 0,L</td><td>RES 0,(HL)</td><td>RES 0,A</td></tr><tr><th>y=001</th><td>RES 1,B</td><td>RES 1,C</td><td>RES 1,D</td><td>RES 1,E</td><td>RES 1,H</td><td>RES 1,L</td><td>RES 1,(HL)</td><td>RES 1,A</td></tr><tr><th>y=010</th><td>RES 2,B</td><td>RES 2,C</td><td>RES 2,D</td><td>RES 2,E</td><td>RES 2,H</td><td>RES 2,L</td><td>RES 2,(HL)</td><td>RES 2,A</td></tr><tr><th>y=011</th><td>RES 3,B</td><td>RES 3,C</td><td>RES 3,D</td><td>RES 3,E</td><td>RES 3,H</td><td>RES 3,L</td><td>RES 3,(HL)</td><td>RES 3,A</td></tr><tr><th>y=100</th><td>RES 4,B</td><td>RES 4,C</td><td>RES 4,D</td><td>RES 4,E</td><td>RES 4,H</td><td>RES 4,L</td><td>RES 4,(HL)</td><td>RES 4,A</td></tr><tr><th>y=101</th><td>RES 5,B</td><td>RES 5,C</td><td>RES 5,D</td><td>RES 5,E</td><td>RES 5,H</td><td>RES 5,L</td><td>RES 5,(HL)</td><td>RES 5,A</td></tr><tr><th>y=110</th><td>RES 6,B</td><td>RES 6,C</td><td>RES 6,D</td><td>RES 6,E</td><td>RES 6,H</td><td>RES 6,L</td><td>RES 6,(HL)</td><td>RES 6,A</td></tr><tr><th>y=111</th><td>RES 7,B</td><td>RES 7,C</td><td>RES 7,D</td><td>RES 7,E</td><td>RES 7,H</td><td>RES 7,L</td><td>RES 7,(HL)</td><td>RES 7,A</td></tr>
</tbody></table>


<h3 id="cb-quadrant-3">CB Quadrant 3</h3>

<p>…and the last CB Quadrant all the bit-set instructions:</p>



<table>
<tbody><tr><th>x=11</th><th>z=000</th><th>z=001</th><th>z=010</th><th>z=011</th><th>z=100</th><th>z=101</th><th>z=110</th><th>z=111</th></tr><tr><th>y=000</th><td>SET 0,B</td><td>SET 0,C</td><td>SET 0,D</td><td>SET 0,E</td><td>SET 0,H</td><td>SET 0,L</td><td>SET 0,(HL)</td><td>SET 0,A</td></tr><tr><th>y=001</th><td>SET 1,B</td><td>SET 1,C</td><td>SET 1,D</td><td>SET 1,E</td><td>SET 1,H</td><td>SET 1,L</td><td>SET 1,(HL)</td><td>SET 1,A</td></tr><tr><th>y=010</th><td>SET 2,B</td><td>SET 2,C</td><td>SET 2,D</td><td>SET 2,E</td><td>SET 2,H</td><td>SET 2,L</td><td>SET 2,(HL)</td><td>SET 2,A</td></tr><tr><th>y=011</th><td>SET 3,B</td><td>SET 3,C</td><td>SET 3,D</td><td>SET 3,E</td><td>SET 3,H</td><td>SET 3,L</td><td>SET 3,(HL)</td><td>SET 3,A</td></tr><tr><th>y=100</th><td>SET 4,B</td><td>SET 4,C</td><td>SET 4,D</td><td>SET 4,E</td><td>SET 4,H</td><td>SET 4,L</td><td>SET 4,(HL)</td><td>SET 4,A</td></tr><tr><th>y=101</th><td>SET 5,B</td><td>SET 5,C</td><td>SET 5,D</td><td>SET 5,E</td><td>SET 5,H</td><td>SET 5,L</td><td>SET 5,(HL)</td><td>SET 5,A</td></tr><tr><th>y=110</th><td>SET 6,B</td><td>SET 6,C</td><td>SET 6,D</td><td>SET 6,E</td><td>SET 6,H</td><td>SET 6,L</td><td>SET 6,(HL)</td><td>SET 6,A</td></tr><tr><th>y=111</th><td>SET 7,B</td><td>SET 7,C</td><td>SET 7,D</td><td>SET 7,E</td><td>SET 7,H</td><td>SET 7,L</td><td>SET 7,(HL)</td><td>SET 7,A</td></tr>
</tbody></table>


<h2 id="dd-cb-and-fd-cb-prefix">DD CB and FD CB Prefix</h2>

<p>The <strong>DD CB</strong> and <strong>FD CB</strong> double-prefix pseudo-subset is a very special beast. The documented
instructions of the subset just provide the “expected” (IX+d) and (IY+d) versions of the CB-prefixed
(HL) instructions, for instance:</p>

<ul>
  <li>BIT n,(HL) =&gt; BIT n,(IX+d)</li>
  <li>SET n,(HL) =&gt; SET n,(IX+d)</li>
  <li>RES n,(HL) =&gt; RES n,(IX+d)</li>
  <li>RLC (HL) =&gt; RLC (IX+d)</li>
</ul>

<p>But the much larger set of undocumented instructions have the strange behaviour that they store the
result both in (IX+d) <em>and</em> a register (except the BIT instructions, which are ‘read-only’).</p>

<p>But there are more oddities:</p>

<ul>
  <li>
    <p>The d-offset sits between the CB prefix and ‘actual’ opcode, while in all other DD/FD prefixed
instructions, the d-offset follows the opcode byte.</p>
  </li>
  <li>
    <p>The d-offset always exists, also for instructions that don’t involve (HL).</p>
  </li>
  <li>
    <p>The R register is only incremented twice, but for two prefix bytes and an additional opcode
it would be expected that it is incremented three times.</p>
  </li>
</ul>

<p>Let’s first look at the timing of the documented <strong>SET 1,(IX+d)</strong> instruction (machine code byte sequence: <strong>DD CB 03 CE</strong>):</p>

<div><div><pre><code>SET 1,(IX+3):
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IX   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 0004 │ 10 │ 0004 │ 1000 │ 5555 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ 10 │ 0005 │ 1000 │ 5555 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 0004 │ DD │ 0005 │ 1000 │ 5555 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ DD │ 0005 │ 1000 │ 5555 │
│ 3/0 │    │      │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 4/1 │    │      │ RFSH │    │    │ 0002 │ DD │ 0005 │ 1000 │ 5555 │
│ 5/0 │ M1 │      │      │    │    │ 0005 │ DD │ 0005 │ 1000 │ 5555 │ &lt;== opcode fetch CB prefix
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 0005 │ DD │ 0006 │ 1000 │ 5555 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 0005 │ CB │ 0006 │ 1000 │ 5555 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 0004 │ CB │ 0006 │ 1000 │ 5555 │
│ 7/0 │    │      │ RFSH │    │    │ 0003 │ CB │ 0006 │ 1000 │ 5555 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0003 │ CB │ 0006 │ 1000 │ 5555 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0003 │ CB │ 0006 │ 1000 │ 5555 │
│ 8/1 │    │      │ RFSH │    │    │ 0000 │ CB │ 0006 │ 1000 │ 5555 │
│ 9/0 │    │      │      │    │    │ 0006 │ CB │ 0006 │ 1000 │ 5555 │ &lt;== memory read d-offset
│ 9/1 │    │ MREQ │      │ RD │    │ 0006 │ CB │ 0007 │ 1000 │ 5555 │
│10/0 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│10/1 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│11/0 │    │ MREQ │      │ RD │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│11/1 │    │      │      │    │    │ 0006 │ 03 │ 0007 │ 1000 │ 5555 │
│12/0 │    │      │      │    │    │ 0007 │ 03 │ 0007 │ 1000 │ 5555 │ &lt;== memory read (pseudo opcode fetch)
│12/1 │    │ MREQ │      │ RD │    │ 0007 │ 03 │ 0008 │ 1000 │ 5555 │
│13/0 │    │ MREQ │      │ RD │    │ 0007 │ CE │ 0008 │ 1000 │ 5555 │
│13/1 │    │ MREQ │      │ RD │    │ 0007 │ CE │ 0008 │ 1000 │ 5503 │
│14/0 │    │ MREQ │      │ RD │    │ 0007 │ CE │ 0008 │ 1000 │ 5503 │
│14/1 │    │      │      │    │    │ 0007 │ CE │ 0008 │ 1000 │ 5503 │
│15/0 │    │      │      │    │    │ 0007 │ CE │ 0008 │ 1000 │ 5503 │ &lt;== 2 extra clock cycles
│15/1 │    │      │      │    │    │ 0007 │ CE │ 0008 │ 1000 │ 5503 │
│16/0 │    │      │      │    │    │ 0007 │ CE │ 0008 │ 1000 │ 5503 │
│16/1 │    │      │      │    │    │ 0000 │ CE │ 0008 │ 1000 │ 1003 │
│17/0 │    │      │      │    │    │ 1003 │ CE │ 0008 │ 1000 │ 1003 │ &lt;== memory read (operand)
│17/1 │    │ MREQ │      │ RD │    │ 1003 │ CE │ 0008 │ 1000 │ 1003 │
│18/0 │    │ MREQ │      │ RD │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │
│18/1 │    │ MREQ │      │ RD │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │
│19/0 │    │ MREQ │      │ RD │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │
│19/1 │    │      │      │    │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │
│20/0 │    │      │      │    │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │ &lt;== 1 extra clock cycle
│20/1 │    │      │      │    │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │
│21/0 │    │      │      │    │    │ 1003 │ 00 │ 0008 │ 1000 │ 1003 │ &lt;== memory write (operand)
│21/1 │    │ MREQ │      │    │    │ 1003 │ 02 │ 0008 │ 1000 │ 1003 │
│22/0 │    │ MREQ │      │    │    │ 1003 │ 02 │ 0008 │ 1000 │ 1003 │
│22/1 │    │ MREQ │      │    │ WR │ 1003 │ 02 │ 0008 │ 1000 │ 1003 │
│23/0 │    │ MREQ │      │    │ WR │ 1003 │ 02 │ 0008 │ 1000 │ 1003 │
│23/1 │    │      │      │    │    │ 1003 │ 02 │ 0008 │ 1000 │ 1003 │
</code></pre></div></div>

<p>It all starts as expected:</p>

<ul>
  <li>a regular opcode fetch for the DD prefix</li>
  <li>another regular opcode fetch for the CB prefix</li>
  <li>a memory read machine cycle to load the d-offset (03)</li>
</ul>

<p>But now it gets weird. The next byte that must be loaded is the ‘regular’ opcode <strong>CE</strong>,
but this doesn’t happen with an opcode fetch machine cycle, but instead with a
memory read machine cycle. The M1 pin isn’t set, and there are also no RFSH clock
cycles (which also explains why the R register isn’t incremented).</p>

<p>Now let’s have a look at the undocumented instruction <strong>SET 1,(IX+d),B</strong> (machine code
byte sequence <strong>DD CB 03 C8</strong>):</p>

<div><div><pre><code>SET 1,(IX+d),B
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ IX   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 000B │ 00 │ 000B │ 0000 │ 1000 │ 1003 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 000B │ 00 │ 000C │ 0000 │ 1000 │ 1003 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 000B │ DD │ 000C │ 0000 │ 1000 │ 1003 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0008 │ DD │ 000C │ 0000 │ 1000 │ 1003 │
│ 3/0 │    │      │ RFSH │    │    │ 0005 │ DD │ 000C │ 0000 │ 1000 │ 1003 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0005 │ DD │ 000C │ 0000 │ 1000 │ 1003 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0005 │ DD │ 000C │ 0000 │ 1000 │ 1003 │
│ 4/1 │    │      │ RFSH │    │    │ 0004 │ DD │ 000C │ 0000 │ 1000 │ 1003 │
│ 5/0 │ M1 │      │      │    │    │ 000C │ DD │ 000C │ 0000 │ 1000 │ 1003 │ &lt;== opcode fetch CB prefix
│ 5/1 │ M1 │ MREQ │      │ RD │    │ 000C │ DD │ 000D │ 0000 │ 1000 │ 1003 │
│ 6/0 │ M1 │ MREQ │      │ RD │    │ 000C │ CB │ 000D │ 0000 │ 1000 │ 1003 │
│ 6/1 │ M1 │ MREQ │      │ RD │    │ 000C │ CB │ 000D │ 0000 │ 1000 │ 1003 │
│ 7/0 │    │      │ RFSH │    │    │ 0006 │ CB │ 000D │ 0000 │ 1000 │ 1003 │
│ 7/1 │    │ MREQ │ RFSH │    │    │ 0006 │ CB │ 000D │ 0000 │ 1000 │ 1003 │
│ 8/0 │    │ MREQ │ RFSH │    │    │ 0006 │ CB │ 000D │ 0000 │ 1000 │ 1003 │
│ 8/1 │    │      │ RFSH │    │    │ 0006 │ CB │ 000D │ 0000 │ 1000 │ 1003 │
│ 9/0 │    │      │      │    │    │ 000D │ CB │ 000D │ 0000 │ 1000 │ 1003 │ &lt;== memory read (d-offset)
│ 9/1 │    │ MREQ │      │ RD │    │ 000D │ CB │ 000E │ 0000 │ 1000 │ 1003 │
│10/0 │    │ MREQ │      │ RD │    │ 000D │ 03 │ 000E │ 0000 │ 1000 │ 1003 │
│10/1 │    │ MREQ │      │ RD │    │ 000D │ 03 │ 000E │ 0000 │ 1000 │ 1003 │
│11/0 │    │ MREQ │      │ RD │    │ 000D │ 03 │ 000E │ 0000 │ 1000 │ 1003 │
│11/1 │    │      │      │    │    │ 000C │ 03 │ 000E │ 0000 │ 1000 │ 1003 │
│12/0 │    │      │      │    │    │ 000E │ 03 │ 000E │ 0000 │ 1000 │ 1003 │ &lt;== memory read (pseudo opcode fetch)
│12/1 │    │ MREQ │      │ RD │    │ 000E │ 03 │ 000F │ 0000 │ 1000 │ 1003 │
│13/0 │    │ MREQ │      │ RD │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│13/1 │    │ MREQ │      │ RD │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│14/0 │    │ MREQ │      │ RD │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│14/1 │    │      │      │    │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│15/0 │    │      │      │    │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │ &lt;== 2 extra clock cycles
│15/1 │    │      │      │    │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│16/0 │    │      │      │    │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│16/1 │    │      │      │    │    │ 000E │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│17/0 │    │      │      │    │    │ 1003 │ C8 │ 000F │ 0000 │ 1000 │ 1003 │ &lt;== memory read (operand)
│17/1 │    │ MREQ │      │ RD │    │ 1003 │ C8 │ 000F │ 0000 │ 1000 │ 1003 │
│18/0 │    │ MREQ │      │ RD │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │
│18/1 │    │ MREQ │      │ RD │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │
│19/0 │    │ MREQ │      │ RD │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │
│19/1 │    │      │      │    │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │
│20/0 │    │      │      │    │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │ &lt;== 1 extra clock cycle
│20/1 │    │      │      │    │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │
│21/0 │    │      │      │    │    │ 1003 │ 00 │ 000F │ 0000 │ 1000 │ 1003 │ &lt;== memory write (operand)
│21/1 │    │ MREQ │      │    │    │ 1003 │ 02 │ 000F │ 0000 │ 1000 │ 1003 │
│22/0 │    │ MREQ │      │    │    │ 1003 │ 02 │ 000F │ 0000 │ 1000 │ 1003 │
│22/1 │    │ MREQ │      │    │ WR │ 1003 │ 02 │ 000F │ 0000 │ 1000 │ 1003 │
│23/0 │    │ MREQ │      │    │ WR │ 1003 │ 02 │ 000F │ 0000 │ 1000 │ 1003 │
│23/1 │    │      │      │    │    │ 1003 │ 02 │ 000F │ 0000 │ 1000 │ 1003 │
</code></pre></div></div>

<p>…it looks <em>identical</em> to the documented <strong>SET 1,(IX+3)</strong> instruction!</p>

<p>But so far, the B register hasn’t been updated, this happens overlapped
in the opcode fetch of the next instruction:</p>
<div><div><pre><code>SET 1,(IX+d),B - continued into next opcode fetch
┌─────┬────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┬──────┬──────┐
│  T  │ M1 │ MREQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ BC   │ IX   │ WZ   │
├─────┼────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┼──────┼──────┤
│ 1/0 │ M1 │      │      │    │    │ 000F │ 00 │ 000F │ 0000 │ 1000 │ 1003 │
│ 1/1 │ M1 │ MREQ │      │ RD │    │ 000F │ 00 │ 0010 │ 0000 │ 1000 │ 1003 │
│ 2/0 │ M1 │ MREQ │      │ RD │    │ 000F │ 00 │ 0010 │ 0000 │ 1000 │ 1003 │
│ 2/1 │ M1 │ MREQ │      │ RD │    │ 0000 │ 00 │ 0010 │ 0200 │ 1000 │ 1003 │ &lt;== B register updated
│ 3/0 │    │      │ RFSH │    │    │ 0007 │ 00 │ 0010 │ 0200 │ 1000 │ 1003 │
│ 3/1 │    │ MREQ │ RFSH │    │    │ 0007 │ 00 │ 0010 │ 0200 │ 1000 │ 1003 │
│ 4/0 │    │ MREQ │ RFSH │    │    │ 0007 │ 00 │ 0010 │ 0200 │ 1000 │ 1003 │
│ 4/1 │    │      │ RFSH │    │    │ 0000 │ 00 │ 0010 │ 0200 │ 1000 │ 1003 │
</code></pre></div></div>

<h2 id="interrupt-behaviour">Interrupt Behaviour</h2>

<p>Disclaimer: I’m not 100% sure if I have correctly identified the
Z80 netlist node which contains the IFF1 state. At the time this
blog post was written the most likely candidate was node #231.</p>

<p>I haven’t found the IFF2 node yet (but haven’t looked very hard either).</p>

<h3 id="interrupt-detection-timing">Interrupt Detection Timing</h3>

<p>To trigger a maskable interrupt, the INT pin must be active during the first
half-cycle of the last clock cycle of an instruction (and interrupts must
be enabled):</p>

<div><div><pre><code>LD A,03h:
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ INT │ AB   │ DB │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0003 │ 56 │ IFF1 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 56 │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 3E │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0000 │ 3E │ IFF1 │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0000 │ 3E │ IFF1 │
│ 5/0 │    │      │      │      │    │    │     │ 0004 │ 3E │ IFF1 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 3E │ IFF1 │
│ 6/0 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 6/1 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 7/0 │    │ MREQ │      │      │ RD │    │ INT │ 0004 │ 03 │ IFF1 │ &lt;== INT detection happens here!
│ 7/1 │    │      │      │      │    │    │     │ 0004 │ 03 │      │ &lt;== interrupt has been detected
</code></pre></div></div>

<p>Non-maskable interrupts are edge-triggered (meaning that the CPU will remember
that the NMI pin was going from inactive to active during instruction execution).
To trigger an NMI it is enough to activate the NMI pin for one half-cycle in the middle
of an instruction. NMI interrupt handling will start in the last half-cycle of the current
instruction by disabling interrupts (same as maskable interrupts):</p>

<div><div><pre><code>LD A,03h:
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ NMI │ AB   │ DB │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0003 │ 56 │ IFF1 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 56 │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 3E │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ NMI │ 0000 │ 3E │ IFF1 │ &lt;== NMI pin active for at least one half cycle
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0000 │ 3E │ IFF1 │
│ 5/0 │    │      │      │      │    │    │     │ 0004 │ 3E │ IFF1 │
│ 5/1 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 3E │ IFF1 │
│ 6/0 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 6/1 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 7/0 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 7/1 │    │      │      │      │    │    │     │ 0004 │ 03 │      │ &lt;== interrupt has been detected
</code></pre></div></div>

<p>The last moment an NMI is detected is the first half cycle of the
last clock cycle of an instruction (the same half cycle where the
INT pin is sampled):</p>

<div><div><pre><code>LD A,03h
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ NMI │ AB   │ DB │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0003 │ 56 │ IFF1 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 56 │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 3E │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0000 │ 3E │ IFF1 │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ 3E │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0000 │ 3E │ IFF1 │
│ 5/0 │    │      │      │      │    │    │     │ 0004 │ 3E │ IFF1 │ &lt;== memory read
│ 5/1 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 3E │ IFF1 │
│ 6/0 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 6/1 │    │ MREQ │      │      │ RD │    │     │ 0004 │ 03 │ IFF1 │
│ 7/0 │    │ MREQ │      │      │ RD │    │ NMI │ 0004 │ 03 │ IFF1 │ &lt;== NMI active for 1 half-cycle
│ 7/1 │    │      │      │      │    │    │     │ 0004 │ 03 │      │ &lt;== NMI has been detected
</code></pre></div></div>

<p>If the NMI pin is active one half-cycle later, the interrupt handling
will be delayed to the end of the following instruction.</p>

<h3 id="prefix-bytes-and-interrupts">Prefix Bytes and Interrupts</h3>

<p>Interrupts are not handled at the end of prefix opcode fetches. If the NMI pin
is active during a prefix fetch the interrupt will be triggered at the end of the
instruction following the prefix byte. This means that even non-maskable
interrupts will not trigger during long sequences of DD or FD prefix bytes:</p>

<div><div><pre><code>2x DD followed by LD IX,1000h
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ NMI │ AB   │ DB │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0003 │ 56 │ IFF1 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ 56 │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0003 │ DD │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ NMI │ 0000 │ DD │ IFF1 │ &lt;== NMI pin active for 1 half cycle
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0003 │ DD │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ DD │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0003 │ DD │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0000 │ DD │ IFF1 │ &lt;== no interrupt triggered
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0004 │ DD │ IFF1 │ &lt;== opcode fetch DD prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0004 │ DD │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0004 │ DD │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0004 │ DD │ IFF1 │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0004 │ DD │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0004 │ DD │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0004 │ DD │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0004 │ DD │ IFF1 │ &lt;== no interrupt triggered
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0005 │ DD │ IFF1 │ &lt;== opcode fetch DD prefix (LD IX,nnnn)
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0005 │ DD │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0005 │ DD │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0004 │ DD │ IFF1 │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0005 │ DD │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0005 │ DD │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0005 │ DD │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0004 │ DD │ IFF1 │
│ 5/0 │ M1 │      │      │      │    │    │     │ 0006 │ DD │ IFF1 │ &lt;== opcode fetch (21)
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0006 │ DD │ IFF1 │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0006 │ 21 │ IFF1 │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0006 │ 21 │ IFF1 │
│ 7/0 │    │      │      │ RFSH │    │    │     │ 0006 │ 21 │ IFF1 │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │     │ 0006 │ 21 │ IFF1 │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │     │ 0006 │ 21 │ IFF1 │
│ 8/1 │    │      │      │ RFSH │    │    │     │ 0006 │ 21 │ IFF1 │
│ 9/0 │    │      │      │      │    │    │     │ 0007 │ 21 │ IFF1 │ &lt;== memory read
│ 9/1 │    │ MREQ │      │      │ RD │    │     │ 0007 │ 21 │ IFF1 │
│10/0 │    │ MREQ │      │      │ RD │    │     │ 0007 │ 00 │ IFF1 │
│10/1 │    │ MREQ │      │      │ RD │    │     │ 0007 │ 00 │ IFF1 │
│11/0 │    │ MREQ │      │      │ RD │    │     │ 0007 │ 00 │ IFF1 │
│11/1 │    │      │      │      │    │    │     │ 0000 │ 00 │ IFF1 │
│12/0 │    │      │      │      │    │    │     │ 0008 │ 00 │ IFF1 │ &lt;== memory read
│12/1 │    │ MREQ │      │      │ RD │    │     │ 0008 │ 00 │ IFF1 │
│13/0 │    │ MREQ │      │      │ RD │    │     │ 0008 │ 10 │ IFF1 │
│13/1 │    │ MREQ │      │      │ RD │    │     │ 0008 │ 10 │ IFF1 │
│14/0 │    │ MREQ │      │      │ RD │    │     │ 0008 │ 10 │ IFF1 │
│14/1 │    │      │      │      │    │    │     │ 0008 │ 10 │      │ &lt;== NMI triggered here
</code></pre></div></div>

<h3 id="ei-di-and-interrupts">EI, DI and interrupts</h3>

<p>The <strong>EI</strong> instruction enables maskable interrupts during the opcode fetch machine cycle
of the <em>next</em> instruction:</p>

<div><div><pre><code>EI
┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0000 │ 00 │ 0000 │      │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ 00 │ 0001 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ FB │ 0001 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ FB │ 0001 │      │
│ 3/0 │    │      │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0001 │ FB │ 0001 │      │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0001 │ FB │ 0002 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0001 │ 00 │ 0002 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ 00 │ 0002 │ IFF1 │ &lt;== interrupts enabled here
│ 3/0 │    │      │      │ RFSH │    │    │ 0001 │ 00 │ 0002 │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0001 │ 00 │ 0002 │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0001 │ 00 │ 0002 │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │ 0000 │ 00 │ 0002 │ IFF1 │
</code></pre></div></div>

<p>This is the reason why maskable interrupts are delayed until the end of the instruction that
follows <strong>EI</strong>.</p>

<p><strong>EI</strong> also explicitely supresses maskable interrupts in the second half of its opcode fetch
machine cycle. This is why maskable interrupts are not triggered during a sequence of
<strong>EI</strong> instructions:</p>

<div><div><pre><code>2x EI + NOP
┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0000 │ 00 │ 0000 │      │ &lt;== opcode fetch: 1st EI
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ 00 │ 0001 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ FB │ 0001 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ FB │ 0001 │      │
│ 3/0 │    │      │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0000 │ FB │ 0001 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0001 │ FB │ 0001 │      │ &lt;== next opcode fetch: 2nd EI
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0001 │ FB │ 0002 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0001 │ FB │ 0002 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ FB │ 0002 │ IFF1 │ &lt;== int enabled for 1 half cycle
│ 3/0 │    │      │      │ RFSH │    │    │ 0001 │ FB │ 0002 │      │ &lt;== int disabled right away
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0001 │ FB │ 0002 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0001 │ FB │ 0002 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0000 │ FB │ 0002 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0002 │ FB │ 0002 │      │ &lt;== next opcode fetch: NOP
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ FB │ 0003 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ 00 │ 0003 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ 00 │ 0003 │ IFF1 │ &lt;== interrupts enabled
│ 3/0 │    │      │      │ RFSH │    │    │ 0002 │ 00 │ 0003 │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0002 │ 00 │ 0003 │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0002 │ 00 │ 0003 │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │ 0002 │ 00 │ 0003 │ IFF1 │
</code></pre></div></div>

<p>Since maskable interrupts are checked in the fist half-cycle of the last clock
cycle of an instruction, it doesn’t matter that interrupts are enabled
for one half-cycle during a sequence of EI instructions.</p>

<p>The <strong>DI</strong> instruction disables interrupts right in the middle of the opcode
fetch machine cycle:</p>

<div><div><pre><code>DI:
┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0002 │ 00 │ 0002 │ IFF1 │ &lt;== opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ 00 │ 0003 │ IFF1 │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ F3 │ 0003 │ IFF1 │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ F3 │ 0003 │ IFF1 │
│ 3/0 │    │      │      │ RFSH │    │    │ 0002 │ F3 │ 0003 │      │ &lt;== interrupts disabled
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0002 │ F3 │ 0003 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0002 │ F3 │ 0003 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0002 │ F3 │ 0003 │      │
</code></pre></div></div>

<h3 id="reti-and-retn">RETI and RETN</h3>

<p><strong>RETI</strong> and <strong>RETN</strong> behave identical, both copy the IFF2 bit (so far unidentified in the
netlist) back into IFF1 in the following opcode fetch machine cycle).</p>

<p>For instance this is what an NMI interrupt service routine looks like that only consists
of a <strong>RETI</strong> instruction. Maskable interrupts had been enabled when the NMI was triggered:</p>

<div><div><pre><code>RETI/RETN after NMI while interrupts were enabled
┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0066 │ 00 │ 0002 │      │ &lt;= opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0066 │ 00 │ 0067 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0066 │ ED │ 0067 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0066 │ ED │ 0067 │      │
│ 3/0 │    │      │      │ RFSH │    │    │ 0003 │ ED │ 0067 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0003 │ ED │ 0067 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0003 │ ED │ 0067 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0000 │ ED │ 0067 │      │
│ 5/0 │ M1 │      │      │      │    │    │ 0067 │ ED │ 0067 │      │ &lt;== opcode fetch RETI
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │ 0067 │ ED │ 0068 │      │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │ 0067 │ 4D │ 0068 │      │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │ 0060 │ 4D │ 0068 │      │
│ 7/0 │    │      │      │ RFSH │    │    │ 0004 │ 4D │ 0068 │      │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 4D │ 0068 │      │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 4D │ 0068 │      │
│ 8/1 │    │      │      │ RFSH │    │    │ 0004 │ 4D │ 0068 │      │
│ 9/0 │    │      │      │      │    │    │ 5553 │ 4D │ 0068 │      │ &lt;== memory read (return addr)
│ 9/1 │    │ MREQ │      │      │ RD │    │ 5553 │ 4D │ 0068 │      │
│10/0 │    │ MREQ │      │      │ RD │    │ 5553 │ 02 │ 0068 │      │
│10/1 │    │ MREQ │      │      │ RD │    │ 5553 │ 02 │ 0068 │      │
│11/0 │    │ MREQ │      │      │ RD │    │ 5553 │ 02 │ 0068 │      │
│11/1 │    │      │      │      │    │    │ 5550 │ 02 │ 0068 │      │
│12/0 │    │      │      │      │    │    │ 5554 │ 02 │ 0068 │      │ &lt;== memory read (return addr)
│12/1 │    │ MREQ │      │      │ RD │    │ 5554 │ 02 │ 0068 │      │
│13/0 │    │ MREQ │      │      │ RD │    │ 5554 │ 00 │ 0068 │      │
│13/1 │    │ MREQ │      │      │ RD │    │ 5554 │ 00 │ 0068 │      │
│14/0 │    │ MREQ │      │      │ RD │    │ 5554 │ 00 │ 0068 │      │
│14/1 │    │      │      │      │    │    │ 5554 │ 00 │ 0068 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0002 │ 00 │ 0068 │      │ &lt;== next opcode fetch (NOP)
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ 00 │ 0003 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ 00 │ 0003 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0002 │ 00 │ 0003 │ IFF1 │ &lt;== IFF1 restored
│ 3/0 │    │      │      │ RFSH │    │    │ 0005 │ 00 │ 0003 │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0005 │ 00 │ 0003 │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0005 │ 00 │ 0003 │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0003 │ IFF1 │
</code></pre></div></div>

<p>If interrupts had not been enabled when the NMI was triggered,
RETI/RETN will not enable interrupts (because IFF1 is copied from
IFF2).</p>

<div><div><pre><code>RETI/RETN after NMI while interrupts were disabled:

┌─────┬────┬──────┬──────┬──────┬────┬────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0066 │ 00 │ 0001 │      │ &lt;== opcode fetch ED prefix
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0066 │ 00 │ 0067 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0066 │ ED │ 0067 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0066 │ ED │ 0067 │      │
│ 3/0 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0067 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0067 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0002 │ ED │ 0067 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0002 │ ED │ 0067 │      │
│ 5/0 │ M1 │      │      │      │    │    │ 0067 │ ED │ 0067 │      │ &lt;== opcode fetch RETN
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │ 0067 │ ED │ 0068 │      │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │ 0067 │ 45 │ 0068 │      │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │ 0060 │ 45 │ 0068 │      │
│ 7/0 │    │      │      │ RFSH │    │    │ 0003 │ 45 │ 0068 │      │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │ 0003 │ 45 │ 0068 │      │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │ 0003 │ 45 │ 0068 │      │
│ 8/1 │    │      │      │ RFSH │    │    │ 0000 │ 45 │ 0068 │      │
│ 9/0 │    │      │      │      │    │    │ 5553 │ 45 │ 0068 │      │ &lt;== memory read (return addr)
│ 9/1 │    │ MREQ │      │      │ RD │    │ 5553 │ 45 │ 0068 │      │
│10/0 │    │ MREQ │      │      │ RD │    │ 5553 │ 01 │ 0068 │      │
│10/1 │    │ MREQ │      │      │ RD │    │ 5553 │ 01 │ 0068 │      │
│11/0 │    │ MREQ │      │      │ RD │    │ 5553 │ 01 │ 0068 │      │
│11/1 │    │      │      │      │    │    │ 5550 │ 01 │ 0068 │      │
│12/0 │    │      │      │      │    │    │ 5554 │ 01 │ 0068 │      │ &lt;== memory read (return addr)
│12/1 │    │ MREQ │      │      │ RD │    │ 5554 │ 01 │ 0068 │      │
│13/0 │    │ MREQ │      │      │ RD │    │ 5554 │ 00 │ 0068 │      │
│13/1 │    │ MREQ │      │      │ RD │    │ 5554 │ 00 │ 0068 │      │
│14/0 │    │ MREQ │      │      │ RD │    │ 5554 │ 00 │ 0068 │      │
│14/1 │    │      │      │      │    │    │ 5554 │ 00 │ 0068 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ 0001 │ 00 │ 0068 │      │ &lt;== next opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ 0001 │ 00 │ 0002 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ 0001 │ 00 │ 0002 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ 0000 │ 00 │ 0002 │      │ &lt;== interrupts not enabled
│ 3/0 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0002 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 00 │ 0002 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ 0004 │ 00 │ 0002 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ 0004 │ 00 │ 0002 │      │
</code></pre></div></div>

<p>With the typical <strong>EI+RETI</strong> sequence at the end of maskable interrupt service
routines, interrupts will already be enabled in the opcode fetch of the
RETI instruction, so that the next maskable interrupt can kick in right
at the end of RETI (note how the INT pin is active here all the time):</p>

<div><div><pre><code>EI + RETI (maskable interrupt)
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ INT │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ INT │ 0038 │ E0 │ 0004 │      │ &lt;== opcode fetch EI
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ INT │ 0038 │ E0 │ 0039 │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ INT │ 0038 │ FB │ 0039 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ INT │ 0038 │ FB │ 0039 │      │
│ 3/0 │    │      │      │ RFSH │    │    │ INT │ 0005 │ FB │ 0039 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ INT │ 0005 │ FB │ 0039 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ INT │ 0005 │ FB │ 0039 │      │
│ 4/1 │    │      │      │ RFSH │    │    │ INT │ 0004 │ FB │ 0039 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │ INT │ 0039 │ FB │ 0039 │      │ &lt;== opcode fetch ED prefix (RETI)
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │ INT │ 0039 │ FB │ 003A │      │
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │ INT │ 0039 │ ED │ 003A │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │ INT │ 0038 │ ED │ 003A │ IFF1 │ &lt;== interrupts enabled (by EI)
│ 3/0 │    │      │      │ RFSH │    │    │ INT │ 0006 │ ED │ 003A │ IFF1 │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │ INT │ 0006 │ ED │ 003A │ IFF1 │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │ INT │ 0006 │ ED │ 003A │ IFF1 │
│ 4/1 │    │      │      │ RFSH │    │    │ INT │ 0006 │ ED │ 003A │ IFF1 │
│ 5/0 │ M1 │      │      │      │    │    │ INT │ 003A │ ED │ 003A │ IFF1 │ &lt;== opcode fetch RETI
│ 5/1 │ M1 │ MREQ │      │      │ RD │    │ INT │ 003A │ ED │ 003B │ IFF1 │
│ 6/0 │ M1 │ MREQ │      │      │ RD │    │ INT │ 003A │ 4D │ 003B │ IFF1 │
│ 6/1 │ M1 │ MREQ │      │      │ RD │    │ INT │ 003A │ 4D │ 003B │ IFF1 │
│ 7/0 │    │      │      │ RFSH │    │    │ INT │ 0007 │ 4D │ 003B │ IFF1 │
│ 7/1 │    │ MREQ │      │ RFSH │    │    │ INT │ 0007 │ 4D │ 003B │ IFF1 │
│ 8/0 │    │ MREQ │      │ RFSH │    │    │ INT │ 0007 │ 4D │ 003B │ IFF1 │
│ 8/1 │    │      │      │ RFSH │    │    │ INT │ 0000 │ 4D │ 003B │ IFF1 │
│ 9/0 │    │      │      │      │    │    │ INT │ 5553 │ 4D │ 003B │ IFF1 │
│ 9/1 │    │ MREQ │      │      │ RD │    │ INT │ 5553 │ 4D │ 003B │ IFF1 │ &lt;== memory read (return addr)
│10/0 │    │ MREQ │      │      │ RD │    │ INT │ 5553 │ 04 │ 003B │ IFF1 │
│10/1 │    │ MREQ │      │      │ RD │    │ INT │ 5553 │ 04 │ 003B │ IFF1 │
│11/0 │    │ MREQ │      │      │ RD │    │ INT │ 5553 │ 04 │ 003B │ IFF1 │
│11/1 │    │      │      │      │    │    │ INT │ 5550 │ 04 │ 003B │ IFF1 │
│12/0 │    │      │      │      │    │    │ INT │ 5554 │ 04 │ 003B │ IFF1 │ &lt;== memory read (return addr)
│12/1 │    │ MREQ │      │      │ RD │    │ INT │ 5554 │ 04 │ 003B │ IFF1 │
│13/0 │    │ MREQ │      │      │ RD │    │ INT │ 5554 │ 00 │ 003B │ IFF1 │
│13/1 │    │ MREQ │      │      │ RD │    │ INT │ 5554 │ 00 │ 003B │ IFF1 │
│14/0 │    │ MREQ │      │      │ RD │    │ INT │ 5554 │ 00 │ 003B │ IFF1 │
│14/1 │    │      │      │      │    │    │ INT │ 5554 │ 00 │ 003B │      │ &lt;== interrupt handling starts!
</code></pre></div></div>

<h3 id="nmi-timing">NMI Timing</h3>

<p>When an NMI is triggered, the IFF1 bit and the HALT state (if active) will be cleared 
in the last half-cycle of the current instruction.</p>

<p>Next, an opcode fetch machine cycle is performed (NOT an interrupt acknowledge
cycle identified with M1|IORQ). The PC is <em>not</em> incremented during the opcode fetch and
the resulting opcode byte will be ignored.</p>

<p>The opcode fetch is followed by an extra clock cycle.</p>

<p>Next, two regular memory write machine cycles are performed to put the current
PC on the stack.</p>

<p>Execution then continues at the first instruction of the interrupt service
routine at address 0066h.</p>

<div><div><pre><code>NMI timing (starting with last clock cycle of instruction
where NMI was detected):
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ INT │ HALT │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼──────┼────┼──────┼──────┤
│ X/0 │    │ MREQ │      │ RFSH │    │    │     │ HALT │ 0002 │ 00 │ 0002 │ IFF1 │ &lt;== NMI detected
│ X/1 │    │      │      │ RFSH │    │    │     │      │ 0002 │ 00 │ 0002 │      │ &lt;== IFF1 and HALT cleared
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │      │ 0002 │ 00 │ 0002 │      │ &lt;== NMI &#39;opcode fetch&#39; (ignored)
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │      │ 0002 │ 00 │ 0002 │      │ &lt;== PC not incremenred!
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │      │ 0002 │ 00 │ 0002 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │      │ 0002 │ 00 │ 0002 │      │
│ 3/0 │    │      │      │ RFSH │    │    │     │      │ 0003 │ 00 │ 0002 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │      │ 0003 │ 00 │ 0002 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │      │ 0003 │ 00 │ 0002 │      │
│ 4/1 │    │      │      │ RFSH │    │    │     │      │ 0003 │ 00 │ 0002 │      │
│ 5/0 │    │      │      │      │    │    │     │      │ 0003 │ 00 │ 0002 │      │ &lt;== extra clock cycle
│ 5/1 │    │      │      │      │    │    │     │      │ 0001 │ 00 │ 0002 │      │
│ 6/0 │    │      │      │      │    │    │     │      │ 5554 │ 00 │ 0002 │      │ &lt;== memory write (PC =&gt; stack)
│ 6/1 │    │ MREQ │      │      │    │    │     │      │ 5554 │ 00 │ 0002 │      │
│ 7/0 │    │ MREQ │      │      │    │    │     │      │ 5554 │ 00 │ 0002 │      │
│ 7/1 │    │ MREQ │      │      │    │ WR │     │      │ 5554 │ 00 │ 0002 │      │
│ 8/0 │    │ MREQ │      │      │    │ WR │     │      │ 5554 │ 00 │ 0002 │      │
│ 8/1 │    │      │      │      │    │    │     │      │ 5550 │ 00 │ 0002 │      │
│ 9/0 │    │      │      │      │    │    │     │      │ 5553 │ 00 │ 0002 │      │ &lt;== memory write (PC =&gt; stack)
│ 9/1 │    │ MREQ │      │      │    │    │     │      │ 5553 │ 02 │ 0002 │      │
│10/0 │    │ MREQ │      │      │    │    │     │      │ 5553 │ 02 │ 0002 │      │
│10/1 │    │ MREQ │      │      │    │ WR │     │      │ 5553 │ 02 │ 0002 │      │
│11/0 │    │ MREQ │      │      │    │ WR │     │      │ 5553 │ 02 │ 0002 │      │
│11/1 │    │      │      │      │    │    │     │      │ 5553 │ 02 │ 0002 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │      │ 0066 │ 00 │ 0002 │      │ &lt;== ISR: opcode fetch at 0066h
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │      │ 0066 │ 00 │ 0067 │      │ &lt;== PC updated to ISR + 1
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │      │ 0066 │ 00 │ 0067 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │      │ 0066 │ 00 │ 0067 │      │
│ 3/0 │    │      │      │ RFSH │    │    │     │      │ 0004 │ 00 │ 0067 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │      │ 0004 │ 00 │ 0067 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │      │ 0004 │ 00 │ 0067 │      │
│ 4/1 │    │      │      │ RFSH │    │    │     │      │ 0004 │ 00 │ 0067 │      │
</code></pre></div></div>

<h3 id="mode-0-interrupt-timing">Mode 0 Interrupt Timing</h3>

<p>Mode 0 interrupts have been inherited from the Intel 8080. Interrupt
handling starts in the last half cycle of the current instruction by clearing
the IFF1 bit and HALT state.</p>

<p>Next, an “interrupt acknowledge” machine cycle is executed. The hardware
which requested the interrupt is expected to place an opcode byte on the
data bus which is executed after the interrupt acknowledge machine cycle.</p>

<p>Usually this will be the single-byte <strong>RST p</strong> instruction which is a
subroutine call into one of eight hardwired destination addresses.</p>

<p>Here’s an IM0 interrupt which executes an <strong>RST 20h</strong> instruction:</p>

<div><div><pre><code>Mode 0 Interrupt with RST 20h (starting with last clock cycle
of instruction where INT was detected):
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ INT │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ X/0 │    │ MREQ │      │ RFSH │    │    │ INT │ 0003 │ 00 │ 0004 │ IFF1 │ &lt;== interrupt detected
│ X/1 │    │      │      │ RFSH │    │    │     │ 0000 │ 00 │ 0004 │      │ &lt;== IFF1 and HALT cleared
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │ &lt;== interrupt acknowledge 
│ 1/1 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 2/0 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 2/1 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 3/0 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 3/1 │ M1 │      │ IORQ │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 4/0 │ M1 │      │ IORQ │      │    │    │     │ 0004 │ E7 │ 0004 │      │ &lt;== opcode E7 (RST 20) on data bus
│ 4/1 │ M1 │      │ IORQ │      │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 5/0 │    │      │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 5/1 │    │ MREQ │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 6/0 │    │ MREQ │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 6/1 │    │      │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 7/0 │    │      │      │      │    │    │     │ 0004 │ E7 │ 0004 │      │ &lt;== RST 20 starts executing
│ 7/1 │    │      │      │      │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 8/0 │    │      │      │      │    │    │     │ 5554 │ E7 │ 0004 │      │ &lt;== memory write (PC =&gt; stack)
│ 8/1 │    │ MREQ │      │      │    │    │     │ 5554 │ 00 │ 0004 │      │
│ 9/0 │    │ MREQ │      │      │    │    │     │ 5554 │ 00 │ 0004 │      │
│ 9/1 │    │ MREQ │      │      │    │ WR │     │ 5554 │ 00 │ 0004 │      │
│10/0 │    │ MREQ │      │      │    │ WR │     │ 5554 │ 00 │ 0004 │      │
│10/1 │    │      │      │      │    │    │     │ 5550 │ 00 │ 0004 │      │
│11/0 │    │      │      │      │    │    │     │ 5553 │ E7 │ 0004 │      │ &lt;== memory write (PC =&gt; stack)
│11/1 │    │ MREQ │      │      │    │    │     │ 5553 │ 04 │ 0004 │      │
│12/0 │    │ MREQ │      │      │    │    │     │ 5553 │ 04 │ 0004 │      │
│12/1 │    │ MREQ │      │      │    │ WR │     │ 5553 │ 04 │ 0004 │      │
│13/0 │    │ MREQ │      │      │    │ WR │     │ 5553 │ 04 │ 0004 │      │
│13/1 │    │      │      │      │    │    │     │ 5553 │ 04 │ 0004 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0020 │ E7 │ 0004 │      │ &lt;== ISR: opcode fetch at 0020h
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0020 │ E7 │ 0021 │      │ &lt;== PC updated (ISR + 1)
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0020 │ 00 │ 0021 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0020 │ 00 │ 0021 │      │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0005 │ 00 │ 0021 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0005 │ 00 │ 0021 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0005 │ 00 │ 0021 │      │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0004 │ 00 │ 0021 │      │
</code></pre></div></div>

<h3 id="mode-1-interrupt-timing">Mode 1 Interrupt Timing</h3>

<p>In interrupt mode 1 the Z80 first clears the HALT and IFF1 state in the last
half cycle of the current instruction and then executes an interrupt acknowledge
machine cycle, but the value on the data bus will be ignored. Next an extra clock
cycle is executed, followed by two memory write machine cycles to place the PC
as return address on the stack. Next, execution will continue in the interrupt
service routine at the hardwired address 0038h:</p>

<div><div><pre><code>Mode 1 Interrupt (starting with last clock cycle of instruction where 
INT was detected):
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ INT │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ X/0 │    │ MREQ │      │ RFSH │    │    │ INT │ 0003 │ 00 │ 0004 │ IFF1 │ &lt;== INT detected
│ X/1 │    │      │      │ RFSH │    │    │     │ 0000 │ 00 │ 0004 │      │ &lt;== IFF1 and HALT cleared
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │ &lt;== interrupt acknowledge
│ 1/1 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 2/0 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 2/1 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 3/0 │ M1 │      │      │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 3/1 │ M1 │      │ IORQ │      │    │    │     │ 0004 │ 00 │ 0004 │      │
│ 4/0 │ M1 │      │ IORQ │      │    │    │     │ 0004 │ E7 │ 0004 │      │ &lt;== data bus value ignored
│ 4/1 │ M1 │      │ IORQ │      │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 5/0 │    │      │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 5/1 │    │ MREQ │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 6/0 │    │ MREQ │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 6/1 │    │      │      │ RFSH │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 7/0 │    │      │      │      │    │    │     │ 0004 │ E7 │ 0004 │      │ &lt;== one extra clock cycle
│ 7/1 │    │      │      │      │    │    │     │ 0004 │ E7 │ 0004 │      │
│ 8/0 │    │      │      │      │    │    │     │ 5554 │ E7 │ 0004 │      │ &lt;== memory write (PC =&gt; stack)
│ 8/1 │    │ MREQ │      │      │    │    │     │ 5554 │ 00 │ 0004 │      │
│ 9/0 │    │ MREQ │      │      │    │    │     │ 5554 │ 00 │ 0004 │      │
│ 9/1 │    │ MREQ │      │      │    │ WR │     │ 5554 │ 00 │ 0004 │      │
│10/0 │    │ MREQ │      │      │    │ WR │     │ 5554 │ 00 │ 0004 │      │
│10/1 │    │      │      │      │    │    │     │ 5550 │ 00 │ 0004 │      │
│11/0 │    │      │      │      │    │    │     │ 5553 │ E7 │ 0004 │      │ &lt;== memory write (PC =&gt; stack)
│11/1 │    │ MREQ │      │      │    │    │     │ 5553 │ 04 │ 0004 │      │
│12/0 │    │ MREQ │      │      │    │    │     │ 5553 │ 04 │ 0004 │      │
│12/1 │    │ MREQ │      │      │    │ WR │     │ 5553 │ 04 │ 0004 │      │
│13/0 │    │ MREQ │      │      │    │ WR │     │ 5553 │ 04 │ 0004 │      │
│13/1 │    │      │      │      │    │    │     │ 5553 │ 04 │ 0004 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0038 │ E7 │ 0004 │      │ &lt;== ISR: opcode fetch at 0038h
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0038 │ E7 │ 0039 │      │ &lt;== PC updated to ISR + 1
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0038 │ 00 │ 0039 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0038 │ 00 │ 0039 │      │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0005 │ 00 │ 0039 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0005 │ 00 │ 0039 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0005 │ 00 │ 0039 │      │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0004 │ 00 │ 0039 │      │
</code></pre></div></div>

<h3 id="mode-2-interrupt-timing">Mode 2 Interrupt Timing</h3>

<p>Mode 2 interrupts are the most complex:</p>

<ul>
  <li>in the last half cycle of the current instruction, IFF1 and HALT are cleared</li>
  <li>an interrupt acknowledge machine cycle is initiated during which the interrupt
requesting device is expected to place an ‘interrupt vector low byte’ on the data bus</li>
  <li>an extra clock cycle is executed</li>
  <li>next, 2 memory write machine cycles are executed to place the PC on the stack
as return address</li>
  <li>next a 16-bit interrupt vector is constructed from the I register (as high byte)
and the ‘interrupt vector low byte’</li>
  <li>the 16-bit interrupt vector is placed on the address bus and two memory read machine cycles
are performed to read another 16-bit address which is the start of the interrupt
service routine</li>
  <li>execution continues at the interrupt service routine</li>
</ul>

<p>In the following Mode 2 timing diagram the I register has already been
loaded with <strong>01</strong> and the byte <strong>E0</strong> will be placed on the data bus during
the interrupt acknowledge machine cycle. Those two values are combined to
the 16-bit interrupt vector address <strong>01E0</strong>. At address <strong>01E0</strong> the 16-bit
value <strong>0300</strong> is stored, which is the entry address of the interrupt
service routine:</p>

<div><div><pre><code>Mode 2 Interrupt (starting with last clock cycle of instruction where 
INT was detected):
┌─────┬────┬──────┬──────┬──────┬────┬────┬─────┬──────┬────┬──────┬──────┐
│  T  │ M1 │ MREQ │ IORQ │ RFSH │ RD │ WR │ INT │ AB   │ DB │ PC   │ IFF1 │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ X/0 │    │ MREQ │      │ RFSH │    │    │ INT │ 0106 │ 00 │ 0008 │ IFF1 │ &lt;== interrupt detected
│ X/1 │    │      │      │ RFSH │    │    │     │ 0106 │ 00 │ 0008 │      │ &lt;== IFF1 and HALT cleared
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0008 │ 00 │ 0008 │      │ &lt;== interrupt acknowledge
│ 1/1 │ M1 │      │      │      │    │    │     │ 0008 │ 00 │ 0008 │      │
│ 2/0 │ M1 │      │      │      │    │    │     │ 0008 │ 00 │ 0008 │      │
│ 2/1 │ M1 │      │      │      │    │    │     │ 0008 │ 00 │ 0008 │      │
│ 3/0 │ M1 │      │      │      │    │    │     │ 0008 │ 00 │ 0008 │      │
│ 3/1 │ M1 │      │ IORQ │      │    │    │     │ 0008 │ 00 │ 0008 │      │
│ 4/0 │ M1 │      │ IORQ │      │    │    │     │ 0008 │ E0 │ 0008 │      │ &lt;== int vector low byte (E0) on data bus
│ 4/1 │ M1 │      │ IORQ │      │    │    │     │ 0000 │ E0 │ 0008 │      │
│ 5/0 │    │      │      │ RFSH │    │    │     │ 0107 │ E0 │ 0008 │      │
│ 5/1 │    │ MREQ │      │ RFSH │    │    │     │ 0107 │ E0 │ 0008 │      │
│ 6/0 │    │ MREQ │      │ RFSH │    │    │     │ 0107 │ E0 │ 0008 │      │
│ 6/1 │    │      │      │ RFSH │    │    │     │ 0107 │ E0 │ 0008 │      │
│ 7/0 │    │      │      │      │    │    │     │ 0107 │ E0 │ 0008 │      │ &lt;== one extra clock cycle
│ 7/1 │    │      │      │      │    │    │     │ 0105 │ E0 │ 0008 │      │
│ 8/0 │    │      │      │      │    │    │     │ 5554 │ E0 │ 0008 │      │ &lt;== memory write (PC =&gt; stack)
│ 8/1 │    │ MREQ │      │      │    │    │     │ 5554 │ 00 │ 0008 │      │
│ 9/0 │    │ MREQ │      │      │    │    │     │ 5554 │ 00 │ 0008 │      │
│ 9/1 │    │ MREQ │      │      │    │ WR │     │ 5554 │ 00 │ 0008 │      │
│10/0 │    │ MREQ │      │      │    │ WR │     │ 5554 │ 00 │ 0008 │      │
│10/1 │    │      │      │      │    │    │     │ 5550 │ 00 │ 0008 │      │
│11/0 │    │      │      │      │    │    │     │ 5553 │ E0 │ 0008 │      │ &lt;== memory write (PC =&gt; stack)
│11/1 │    │ MREQ │      │      │    │    │     │ 5553 │ 08 │ 0008 │      │
│12/0 │    │ MREQ │      │      │    │    │     │ 5553 │ 08 │ 0008 │      │
│12/1 │    │ MREQ │      │      │    │ WR │     │ 5553 │ 08 │ 0008 │      │
│13/0 │    │ MREQ │      │      │    │ WR │     │ 5553 │ 08 │ 0008 │      │
│13/1 │    │      │      │      │    │    │     │ 5553 │ 08 │ 0008 │      │
│10/0 │    │      │      │      │    │    │     │ 01E0 │ E0 │ 0008 │      │ &lt;== memory read from 01E0 (I&lt;&lt;8)|(E0)
│10/1 │    │ MREQ │      │      │ RD │    │     │ 01E0 │ E0 │ 0008 │      │
│11/0 │    │ MREQ │      │      │ RD │    │     │ 01E0 │ 00 │ 0008 │      │ &lt;== data bus: ISR address low byte (00)
│11/1 │    │ MREQ │      │      │ RD │    │     │ 01E0 │ 00 │ 0008 │      │
│12/0 │    │ MREQ │      │      │ RD │    │     │ 01E0 │ 00 │ 0008 │      │
│12/1 │    │      │      │      │    │    │     │ 01E0 │ 00 │ 0008 │      │
│13/0 │    │      │      │      │    │    │     │ 01E1 │ 00 │ 0008 │      │ &lt;== memory read from 01E1
│13/1 │    │ MREQ │      │      │ RD │    │     │ 01E1 │ 00 │ 0008 │      │
│12/0 │    │ MREQ │      │      │ RD │    │     │ 01E1 │ 03 │ 0008 │      │ &lt;==&gt; data bus: ISR address high byte (03)
│12/1 │    │ MREQ │      │      │ RD │    │     │ 01E1 │ 03 │ 0008 │      │
│13/0 │    │ MREQ │      │      │ RD │    │     │ 01E1 │ 03 │ 0008 │      │
│13/1 │    │      │      │      │    │    │     │ 01E1 │ 03 │ 0008 │      │
├─────┼────┼──────┼──────┼──────┼────┼────┼─────┼──────┼────┼──────┼──────┤
│ 1/0 │ M1 │      │      │      │    │    │     │ 0300 │ 03 │ 0008 │      │ &lt;== ISR: opcode fetch
│ 1/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0300 │ 03 │ 0301 │      │ &lt;== PC updated to ISR + 1
│ 2/0 │ M1 │ MREQ │      │      │ RD │    │     │ 0300 │ 00 │ 0301 │      │
│ 2/1 │ M1 │ MREQ │      │      │ RD │    │     │ 0300 │ 00 │ 0301 │      │
│ 3/0 │    │      │      │ RFSH │    │    │     │ 0108 │ 00 │ 0301 │      │
│ 3/1 │    │ MREQ │      │ RFSH │    │    │     │ 0108 │ 00 │ 0301 │      │
│ 4/0 │    │ MREQ │      │ RFSH │    │    │     │ 0108 │ 00 │ 0301 │      │
│ 4/1 │    │      │      │ RFSH │    │    │     │ 0108 │ 00 │ 0301 │      │
</code></pre></div></div>

  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
