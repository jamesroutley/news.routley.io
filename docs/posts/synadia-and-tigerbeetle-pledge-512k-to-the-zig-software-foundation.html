<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2025-10-25-synadia-and-tigerbeetle-pledge-512k-to-the-zig-software-foundation/">Original</a>
    <h1>Synadia and TigerBeetle Pledge $512k to the Zig Software Foundation</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://www.synadia.com/blog/synadia-tigerbeetle-zig-foundation-pledge">Synadia</a>
and TigerBeetle have together pledged $512,000 to the <a href="https://ziglang.org">Zig Software Foundation</a> over the next two
years in support of the language, leadership, and communities building
the future of simpler systems software.</p>
<h2 id="choosing-zig-for-tigerbeetle"><a href="#choosing-zig-for-tigerbeetle" aria-hidden="true">Choosing Zig for TigerBeetle</a></h2>
<p>I first saw Zig in 2018, seven years ago. Two years later, I chose
Zig over C or Rust for TigerBeetle.</p>
<h2 id="why-not-rust"><a href="#why-not-rust" aria-hidden="true">Why not Rust?</a></h2>
<p>In 2020, I was following Rust closely. At the time, Rust’s default
memory philosophy was to crash when out of memory (OOM). However, for
TigerBeetle, I wanted explicit static allocation, following <a href="https://spinroot.com/gerard/pdf/P10.pdf">NASA’s Power of Ten Rules
for Safety-Critical Code</a>, which would become a part of <a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md">TigerStyle</a>,
a methodology for creating <a href="https://www.youtube.com/watch?v=w3WYdYyjek4">safer software in
less time</a>.</p>
<h2 id="simplified-memory-management"><a href="#simplified-memory-management" aria-hidden="true">Simplified Memory Management</a></h2>
<p>What I learned is that if you could centralize resource allocation in
time and space (the dimensions that prove tricky for humans writing
software) then this could not only simplify memory management, to design
away some of the need for a borrow checker in the first place, but, more
importantly, also be a forcing function for propagating good design, to
encourage teams to think through the explicit limits or physics of the
software (you have no choice).</p>
<h2 id="not-fearlessly-multithreaded"><a href="#not-fearlessly-multithreaded" aria-hidden="true">Not Fearlessly Multithreaded</a></h2>
<p>From a performance perspective, I didn’t want TigerBeetle to be
fearlessly multithreaded. <a href="https://www.youtube.com/watch?v=yKgfk8lTQuE">Transaction
processing workloads tend to have inherent contention</a>, even to the
point of power law, precluding partitioning and necessitating a
single-threaded architecture. Therefore, Rust’s borrow checker, while a
phenomenal tool for the class of problems it targets, made less sense
for TigerBeetle. TigerBeetle never frees memory and never runs
multithreaded, instead using explicit submission/completion queue
interfaces by design.</p>
<h2 id="correctness-is-a-design-problem"><a href="#correctness-is-a-design-problem" aria-hidden="true">Correctness Is a Design Problem</a></h2>
<p>Finally, while the borrow checker could achieve local memory safety,
TigerBeetle needed more correctness properties. TigerBeetle needed to be
always correct, and across literally thousands of invariants. <a href="https://matklad.github.io/2023/03/26/zig-and-rust.html">As matklad
would say, this is a harder problem!</a> I had also spent enough time in
memory safe languages to know that local memory safety is no guarantee
of local correctness, let alone distributed system correctness. Per
systems thinking, I believe that total correctness is a design problem,
not a language problem. Language is valuable. But no human language can
guarantee the next Hemingway or Nabokov. For this you need philosophy.
Even then it’s not a guarantee but a probability.</p>
<p>With Rust off the table, the choice fell to C or Zig. A language of
the past or future?</p>
<h2 id="why-zig"><a href="#why-zig" aria-hidden="true">Why Zig?</a></h2>
<p>Zig was early, which gave me pause, but I felt that the quality of
Andrew Kelley’s design decisions in the language, the standard library
(e.g. the unmanaged hashmap interface) and the cross-compilation
toolchain, even five years ago, was already exceptional.</p>
<h2 id="more-than-a-language-a-philosophy"><a href="#more-than-a-language-a-philosophy" aria-hidden="true">More than a Language, a Philosophy</a></h2>
<p>Andrews’s philosophy resonated with what I wanted to explore in
TigerStyle. No hidden memory allocations. No hidden control flow. No
preprocessor. No macros. And then you get things like comptime, reducing
the grammar and dimensionality of the language, while simultaneously
multiplying its power. The primary benefit of Zig is the favorable ratio
of expressivity to language complexity.</p>
<h2 id="a-better-c"><a href="#a-better-c" aria-hidden="true">A Better C</a></h2>
<p>As a replacement for C, Zig fixed not only the small cuts, such as
explicit alignment in the type system for Direct I/O, or safer casts,
but the showstoppers of spatial memory safety through bounds checking,
and, to a lesser degree (but not guarantee), temporal memory safety
through the debug allocator.</p>
<h2 id="checked-arithmetic"><a href="#checked-arithmetic" aria-hidden="true">Checked Arithmetic</a></h2>
<p>Zig also enabled checked arithmetic by default in safe builds, which
is something I believe only Ada and Swift do (remarkably, Rust disables
checked arithmetic by default in safe builds—a default I would love to
see changed). TigerBeetle separates the data plane from the control
plane by design, through batching, so the runtime cost of these safety
checks was not material, being amortized in the data plane across bigger
buffers. While a borrow checker or static allocation can simplify memory
management, getting logic and arithmetic correct remains hard. Of
course, you can enable checked arithmetic in other languages, but I
appreciated Andrew’s concern for checked arithmetic and stricter
operands by default.</p>
<h2 id="safety-as-a-spectrum"><a href="#safety-as-a-spectrum" aria-hidden="true">Safety as a Spectrum</a></h2>
<p>In all these things, what impressed me most was Zig’s approach to
safety when working with the metal. Not in terms of an on/off decision,
but as a spectrum. Not aiming for 100% guarantees across 1 or 2
categories, but 90% and then across more categories. Not eliminating
classes of bugs, but downgrading their probability. All while preserving
the power-to-weight ratio of the language, to keep the language
beautifully simple.</p>
<h2 id="essential-simplicity"><a href="#essential-simplicity" aria-hidden="true">Essential Simplicity</a></h2>
<p>Many languages start simple and grow complex as features are added.
Zig’s simplicity is unusual in that it comes from a subtractive
discipline (e.g. no private fields) rather than a deferred complexity;
minimizing surface area is part of the ethos of the language. The
simplicity of Zig meant that we could hire great programmers from any
language background—they could pick up Zig in a weekend. Indeed, I’ve
never had to talk to a new hire about learning Zig.</p>
<h2 id="skate-to-where-the-puck-is-going"><a href="#skate-to-where-the-puck-is-going" aria-hidden="true">Skate to Where the Puck Is Going</a></h2>
<p>Finally, there was the timing. Recognizing that TigerBeetle would
take time to reach production (we shipped production in 2024, after 3.5
years of development), giving Zig time to mature, for our trajectories
to intersect.</p>
<p>Investing in creating a database like TigerBeetle is a long term
effort. Databases tend to have a long half life (e.g. Postgres is 30
years old). And so, while Zig being early in 2020 did give me pause,
nevertheless Zig’s quality, philosophy and simplicity made sense for a
multi-decade horizon.</p>
<h2 id="fast-forward-five-years-later"><a href="#fast-forward-five-years-later" aria-hidden="true">Fast Forward Five Years Later</a></h2>
<p>How has the decision for Zig panned out?</p>
<h2 id="surviving-vopr-vörtex-and-jepsen"><a href="#surviving-vopr-vörtex-and-jepsen" aria-hidden="true">Surviving VOPR, Vörtex and Jepsen</a></h2>
<p>TigerBeetle is tested end-to-end under some pretty extreme fuzzing.
We did have three bugs that would have been prevented by the borrow
checker, but these were caught by our fuzzers and online verification.
We run a fuzzing fleet of 1,000 dedicated CPU cores 24/7. We invest in
deterministic simulation testing (e.g. <a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/internals/vopr.md">VOPR</a>),
as well as non-deterministic fault-injection harnesses (e.g. <a href="https://tigerbeetle.com/blog/2025-02-13-a-descent-into-the-vortex/">Vörtex</a>).
We engaged Kyle Kingsbury in <a href="https://jepsen.io/analyses/tigerbeetle-0.16.11">one of the longest
Jepsen audits to date</a>—four times the typical duration. Through all
this, Zig’s quality held up flawlessly.</p>
<h2 id="tight-tolerances-and-velocity"><a href="#tight-tolerances-and-velocity" aria-hidden="true">Tight Tolerances and Velocity</a></h2>
<p>Zig has also been a huge part of our success as a company.
TigerBeetle is only 5 years old but is already migrating some of the
largest brokerages, exchanges and wealth managements in their respective
jurisdictions. Several of our key enterprise contracts were thanks to
the CTOs and even CEOs of these companies also following Zig and seeing
the quality we wanted to achieve with it. I don’t think we could have
written TigerBeetle <a href="https://lobste.rs/s/uhtjdz/rust_vs_zig_reality_somewhat_friendly#c_8rtrto">as
it is, in any other language</a>, at least not to the same tight
tolerances, let alone with the same velocity.</p>
<h2 id="pre-10-breaking-changes"><a href="#pre-10-breaking-changes" aria-hidden="true">Pre-1.0 Breaking Changes</a></h2>
<p>Zig’s language specification will only reach 1.0 when all
experimental areas of the language (e.g. async I/O) are finally done.
For TigerBeetle, we care only about the stable language features we use,
testing our binaries end to end, as we would for any language.
Nevertheless, upgrading to new versions, even with breaking changes, has
only been a pleasure for us as a team. The upgrade work is usually fully
paid for by compilation time reduction. For example, the upgrade from
Zig 0.14.1 to Zig 0.15.2 (with the native x86_64 backend) makes debug
builds 2x faster, and even LLVM release builds become 1.6x faster. With
each release, you can literally feel the sheer amount of effort that the
entire Zig core team put into making Zig the world’s most powerful
programming language—and toolchain.</p>
<h2 id="one-level-deeper"><a href="#one-level-deeper" aria-hidden="true">One Level Deeper</a></h2>
<p>Back in 2020, from a production perspective, Zig was more or less a
frontend to LLVM, the same compiler used by Rust, Swift and other
languages. However, by not shying away from also investing in its own
independent compiler backends and toolchain, by appreciating the value
of replacing LLVM long term, Zig is becoming well positioned to gain a
low-level precision and compilation speed that generic LLVM won’t always
be able to match.</p>
<h2 id="long-live-the-bdfl"><a href="#long-live-the-bdfl" aria-hidden="true">Long Live the BDFL</a></h2>
<p>We want Andrew to take his time, to get these things right for the
long term. Fred Brooks once said that <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month">conceptual
integrity</a> is “the most important consideration” in system design,
that the design must proceed from one mind.</p>
<p>In this spirit, I am grateful for Andrew’s remarkably strong
leadership (and taste) in the design of the language and toolchain.
There can be thankless pressure on an open source project to give in to
the tragedy of the commons. But if anything, in hindsight I think this
is what I’ve most appreciated about choosing Zig for TigerBeetle, that
Zig has a strong BDFL.</p>
<p>Of course, some may hear “BDFL” and see governance risk. But I fear
the opposite: conceptual risk, the harder problem. Brooks was
right—conceptual integrity is almost certainly doomed by committee.
Whereas governance is easier solved: put it in the hands, not of the
corporates, but of the people. The individuals who choose each day to
continue to donate.</p>
<h2 id="a-simple-pledge"><a href="#a-simple-pledge" aria-hidden="true">A Simple Pledge</a></h2>
<p>This is why our pledge today, along with all other ZSF donors, is a
simple donation with no strings attached. The Zig Software Foundation is
well managed, transparent and independent. We want it to remain this
way. The last thing we want is some kind of foundation “seat”. Andrew is
Chef. We want to let him cook, and pay his core team sustainably (e.g.
<a href="https://ziglang.org/news/2025-financials/">92% percent of
budget goes to directly paying contributors</a>).</p>
<h2 id="surfing-the-swell"><a href="#surfing-the-swell" aria-hidden="true">Surfing the Swell</a></h2>
<p>If cooking is one metaphor, then surfing is another. I believe that
technology moves in waves. The art is not in paddling to the wave with a
thousand surfers on it. But in spotting the swell before it breaks. And
then enjoying the ride with the early adopters who did the same. <a href="https://isaacfreund.com/software/river/">River</a>, <a href="https://ghostty.org">Ghostty</a>, <a href="https://bun.com">Bun</a>, <a href="https://github.com/hexops/mach">Mach</a> and many fellow
surfers.</p>
<h2 id="partnering-with-synadia"><a href="#partnering-with-synadia" aria-hidden="true">Partnering with Synadia</a></h2>
<p>In fact, it was through Zig that I met <a href="https://x.com/derekcollison">Derek Collison</a>, who like me had
been sponsoring the language in his personal capacity since 2018. As a
former CTO at VMware, Derek was responsible for backing <a href="https://antirez.com">antirez</a> to work full time on Redis. Derek
later went on to create <a href="https://nats.io">NATS</a>, founding <a href="https://www.synadia.com">Synadia</a>.</p>
<p>As we were about to increase TigerBeetle’s yearly donation to Zig, I
reached out to Derek, and we decided to do a joint announcement, <a href="https://mitchellh.com/writing/zig-donation">following Mitchell
Hashimoto’s lead</a>. For each of our companies to donate $256,000 in
monthly installments over the next two years, with Synadia matching
TigerBeetle, for a total of $512,000—the first installment already
made.</p>
<h2 id="for-great-justice-take-off-every-zig"><a href="#for-great-justice-take-off-every-zig" aria-hidden="true">“For Great Justice, Take Off Every Zig”</a></h2>
<p>Please consider <a href="https://ziglang.org/zsf/">donating</a> or
increasing your donation if you can. And if you are a CEO or CTO, please
team up with another company to outmatch us! Thanks Andrew for creating
something special, and to all who code for the joy of the craft:</p>
<p>Together we serve the users.</p>
  </div></div>
  </body>
</html>
