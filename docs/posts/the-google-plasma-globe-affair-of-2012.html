<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lcamtuf.coredump.cx/plasma_globe/">Original</a>
    <h1>The Google plasma globe affair of 2012</h1>
    
    <div id="readability-page-1" class="page">

<p>
So, the cat&#39;s out of the bag. A recent series of promotional videos published by Google
showcased several aspects of the company&#39;s security program. In episode #3,
Daniel Fabian talks about the redteaming efforts - and in particular, about
an exercise he and I ran together in 2012:
</p>

<p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/TusQWn2TQxQ" allowfullscreen=""></iframe>
</p>

<p>
The centerpriece of that exercise was a USB-powered plasma globe. At the
time, the dangers of USB devices were already well-understood, but most of the
public discourse revolved around the threat posed by malicious payloads stored
on pendrives, or by chargers surreptitiously downloading files off your phone.
</p>

<p>
We wanted to try another attack: a seemingly benign USB gadget that registered
with the computer as a keyboard - and then, when you least expected it, typed
in a malicious payload right under your nose, ideally quickly enough for you
to not even notice.
</p>

<p>
The keyboard attack was interesting for a couple of reasons. First, keyboards
are meant to be plug-and-play and don&#39;t require the installation of drivers or
clicking through any warnings. Just as importantly, at least at the time,
such accessories weren&#39;t closely watched by any enterprise security tools.
</p>

<p>
The first challenge, of course, was designing the hardware; I wanted to build
something that would appear entirely innocuous yet cool enough for the user
who receives it (under a flimsy pretense!) to plug it in and leave it plugged
in for a while.
</p>

<p>
After untold hours of browsing for cheap USB trinkets, I settled on five plasma
globes sourced from eBay. The modifications involved sneaking in a barebone
surface-mount <a href="https://www.microchip.com/en-us/product/ATmega32U4">ATmega32U4</a>
chip near the termination point of the USB cable.
We used the <a href="https://github.com/abcminiuser/lufa">LUFA USB library</a>
for interfacing with the host.
</p>
 
<p>
Beyond concealing the chip, there wasn&#39;t a whole lot going on. I actually had
to replace the original USB cord, as the factory one contained nothing but two
power wires. I also needed an MLCC capacitor on the
power supply lines, a crystal oscillator for precise bus timing, and two small
ceramic caps for the xtal to oscillate. Oh - I made some decals on my trusty
vinyl cutter (possibly Roland Stika SV-8). You can see the end result here:
</p>

<p>
<img src="https://lcamtuf.coredump.cx/plasma_globe/plasma_globe.jpg"/>
</p>

<p>
The software side proved more complicated. We wanted the evil globe to be
platform-agnostic and work equally well on Linux, on Macs, and on Windows. The
company supported all three platforms, and we didn&#39;t want to cheat by choosing
our targets based on insider knowledge of what OS they might be working on
day-to-day.
</p>

<p>
We stumbled into the first issue pretty much right away: as it turns out, if you
connect a non-Apple keyboard to a Mac, you are presented with a rather conspicuous
wizard that needs to be clicked through, something along the lines of:
</p>

<p>
<img src="https://lcamtuf.coredump.cx/plasma_globe/macos.jpg"/>
</p>

<p>
The solution proved to be simple: we &#34;borrowed&#34; the USB vendor and product ID
sent by an Apple-made keyboard taken from a coworker&#39;s desk. Looking at the
prototype plasma globe sitting in my &#34;old projects&#34; box, it seems that we picked
<code>05ac:024f</code>.
</p>

<p>
The other challenge was delivering our payload quickly enough for the attack to
be inconspicuous. The USB HID keyboard protocol is rather antiquated: instead of
having the device push notifications as needed, it relies on the host notionally
polling the keyboard at 125 Hz. This meant that a hypothetical 100-character
payload would take almost a second to deliver - enough for the victim to see that
something is amiss.
</p>

<p>
The first step was to modify the standard USB keyboard descriptor to request the
maximum polling speed (1 kHz) from the host. Another critical optimization boiled
down to realizing that the response packet allows up to six keycodes to be
reported at once (<a href="https://www.addictivetips.com/app/uploads/2018/03/macos-identify-keyboard.jpg">details here</a>).
This might have seemed like a straightforward 6x speed gain, but not so: on MacOS,
the keystrokes were dequeued not in the order they appeared in the packet, but
from the numerically lowest scancode to the highest. This mind-boggling quirk
forced us to tweak the payload to make it locally keystroke-ordering-agnostic
in as many places as possible. In the end, we still managed to get the delivery
time down to around 100 ms - a mere flash on the screen - but it took quite a bit
of work.
</p>

<p>
Several other problems needed to be solved. For starters, we had to write a
&#34;polyglot&#34; stage 1 payload that worked equally well for cmd.exe and bash. IIRC,
on Windows, the payload involved creating and then executing a .js file in the
background (essentially <code>cmd /c cd %tmp%&amp;type con:&gt;f.js&amp;start f.js</code>); the JS
then used <code>ActiveXObject(&#34;MSXML2.XMLHTTP&#34;)</code> to download the second stage and
called <code>eval(...)</code> on the result. The unix
version was simpler, executing <code>curl</code> via <code>nohup</code> to fetch
additional scripts.
</p>

<p>
Beyond that, we also needed extra keystrokes to get from whatever the user
might have been doing to shell - and then go back when done. On Windows, we&#39;d
send <code>WinKey+R</code>, and use <code>Alt+O</code> to delete the payload targeted at other platforms
before delivering the Windows bits. On Ubuntu, we used <code>Ctrl+Alt+T</code>, followed by
<code>stty -echo</code> and <code>read -d...</code> to sink the non-unix stuff. On MacOS, the sequence
was more complicated: <code>Cmd+Space</code> followed by <code>&#34;term&#34;</code> and <code>Cmd+O</code>.
All this needed to happen without messing up whatever the user was working. Then there was a
weird GNOME animation on Linux initiated by sending <code>Cmd+W</code> to close the terminal
window on MacOS... anyway, a pretty fun exercise to choreograph that one perfect
sequence of keystrokes for all three OSes.
</p>

<p>
(Perhaps there was a way for the keyboard to fingerprint the host OS through
some implementation quirk of the HID protocol, but our &#34;project schedule&#34;
didn&#39;t allow for this research.)
</p>

<p>
Additional failsafes needed to be added in case the user&#39;s screen was locked;
the downside of pretending to be a keyboard is that you don&#39;t know what&#39;s going
on on the screen, and you don&#39;t want to leave bits of your payload sitting
there in plain view in a login field - so there was that last <code>Esc</code> keypress to
clean things up.
</p>

<p>
The final hurdle was knowing when to stop: the plasma globe was designed to wait
about 5-10 minutes after being plugged in before doing anything, as to not
arise suspicion. But if the user wandered off and locked their screen, we
wouldn&#39;t succeed on the first try. We wanted to retry after 30 minutes and
then every hour or so - but it was also important to not try more times than
absolutely necessary.
</p>

<p>
Luckily, there is a simple back channel to talk to the keyboard once you have
a shell on the machine: the OS can instruct the keyboard to toggle its standard
LEDs (<code>Num Lock</code>, <code>Scroll Lock</code>, <code>Caps Lock</code>).
So, our secret protocol involved the
host toggling <code>Scroll Lock</code> five times within one second. On Linux, it was
as simple as <code>xset led named &#39;Scroll Lock&#39;</code>; on Windows, you had
<code>ActiveXObject(&#34;WScript.Shell&#34;).SendKeys(&#34;{scrolllock}&#34;)</code>. 
Either way, upon the receipt of this
confirmation code, the plasma globe would set a bit in its EEPROM and go
dormant forever... well, OK - until reflashed.
</p>

<p>
It worked; the Google video tells the rest of the story. As for potential
mitigations, see <a href="https://github.com/google/ukip">https://github.com/google/ukip</a>.
</p>

<p>
<i>
You can contact me at <a href="mailto:lcamtuf@coredump.cx">lcamtuf@coredump.cx</a> or <a href="https://twitter.com/lcamtuf">follow me on Twitter</a>.
For other features, check out <a href="https://lcamtuf.coredump.cx/">my homepage</a>.
</i>
</p>



<p><i>Your lucky number is: 21558077</i></p>
</div>
  </body>
</html>
