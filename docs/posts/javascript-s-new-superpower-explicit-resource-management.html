<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://v8.dev/features/explicit-resource-management">Original</a>
    <h1>JavaScript&#39;s New Superpower: Explicit Resource Management</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><article itemscope="" itemtype="http://schema.org/BlogPosting"><header><p>Published <time datetime="2025-05-09" itemprop="datePublished">09 May 2025</time> · Tagged with <a href="https://v8.dev/features/tags/ecmascript">ECMAScript</a></p></header><div itemprop="articleBody"><p>The <em>Explicit Resource Management</em> proposal introduces a deterministic approach to explicitly manage the lifecycle of resources like file handles, network connections, and more. This proposal brings the following additions to the language: the <code>using</code> and <code>await using</code> declarations, which automatically calls dispose method when a resource goes out of scope; <code>[Symbol.dispose]()</code> and <code>[Symbol.asyncDispose]()</code> symbols for cleanup operations; two new global objects <code>DisposableStack</code> and <code>AsyncDisposableStack</code> as containers to aggregate disposable resources; and <code>SuppressedError</code> as a new type of error (contain both the error that was most recently thrown, as well as the error that was suppressed) to address the scenario where an error occurs during the disposal of a resource, and potientially masking an existing error thrown from the body, or from the disposal of another resource. These additions enable developers to write more robust, performant, and maintainable code by providing fine-grained control over resource disposal.</p><h2 id="using-and-await-using-declarations" tabindex="-1"><code>using</code> and <code>await using</code> declarations <a href="#using-and-await-using-declarations">#</a></h2><p>The core of the Explicit Resource Management proposal lies in the <code>using</code> and <code>await using</code> declarations. The <code>using</code> declaration is designed for synchronous resources, ensuring that the <code>[Symbol.dispose]()</code> method of a disposable resource is called when the scope in which it&#39;s declared exits. For asynchronous resources, the <code>await using</code> declaration works similarly, but ensures that the <code>[Symbol.asyncDispose]()</code> method is called and the result of this calling is awaited, allowing for asynchronous cleanup operations. This distinction enables developers to reliably manage both synchronous and asynchronous resources, preventing leaks and improving overall code quality. The <code>using</code> and <code>await using</code> keywords can be used inside braces <code>{}</code> (such as blocks, for loops and function bodies), and cannot be used in top-levels.</p><p>For example, when working with <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader"><code>ReadableStreamDefaultReader</code></a>, it&#39;s crucial to call <code>reader.releaseLock()</code> to unlock the stream and allow it to be used elsewhere. However, error handling introduces a common problem: if an error occurs during the reading process, and you forget to call <code>releaseLock()</code> before the error propagates, the stream remains locked. Let&#39;s start with a naive example:</p><pre><code><span>let</span> responsePromise <span>=</span> <span>null</span><span>;</span></code></pre><p>So it is crucial for developers to have <code>try...finally</code> block while using streams and put <code>reader.releaseLock()</code> in <code>finally</code>. This pattern ensures that <code>reader.releaseLock()</code> is always called.</p><pre><code><span>async</span> <span>function</span> <span>processData</span><span>(</span><span>response</span><span>)</span> <span>{</span></code></pre><p>An alternative to write this code is to create a disposable object <code>readerResource</code>, which has the reader (<code>response.body.getReader()</code>) and the <code>[Symbol.dispose]()</code> method that calls <code>this.reader.releaseLock()</code>. The <code>using</code> declaration ensures that <code>readerResource[Symbol.dispose]()</code> is called when the code block exits, and remembering to call <code>releaseLock</code> is no longer needed because the using declaration handles it. Integration of <code>[Symbol.dispose]</code> and <code>[Symbol.asyncDispose]</code> in web APIs like streams may happen in the future, so developers do not have to write the manual wrapper object.</p><pre><code> <span>async</span> <span>function</span> <span>processData</span><span>(</span><span>response</span><span>)</span> <span>{</span></code></pre><h2 id="disposablestack-and-asyncdisposablestack" tabindex="-1"><code>DisposableStack</code> and <code>AsyncDisposableStack</code> <a href="#disposablestack-and-asyncdisposablestack">#</a></h2><p>To further facilitate managing multiple disposable resources, the proposal introduces <code>DisposableStack</code> and <code>AsyncDisposableStack</code>. These stack-based structures allow developers to group and dispose of multiple resources in a coordinated manner. Resources are added to the stack, and when the stack is disposed, either synchronously or asynchronously, the resources are disposed of in the reverse order they were added, ensuring that any dependencies between them are handled correctly. This simplifies the cleanup process when dealing with complex scenarios involving multiple related resources. Both structures provide methods like <code>use()</code>, <code>adopt()</code>, and <code>defer()</code> to add resources or disposal actions, and a <code>dispose()</code> or <code>asyncDispose()</code> method to trigger the cleanup. <code>DisposableStack</code> and <code>AsyncDisposableStack</code> have <code>[Symbol.dispose]()</code> and <code>[Symbol.asyncDispose]()</code>, respectively, so they can be used with <code>using</code> and <code>await using</code> keywords. They offer a robust way to manage the disposal of multiple resources within a defined scope.</p><p>Let’s take a look at each method and see an example of it:</p><p><code>use(value)</code> adds a resource to the top of the stack.</p><pre><code><span>{</span></code></pre><p><code>adopt(value, onDispose)</code> adds a non-disposable resource and a disposal callback to the top of the stack.</p><pre><code><span>{</span></code></pre><p><code>defer(onDispose)</code> adds a disposal callback to the top of the stack. It&#39;s useful for adding cleanup actions that don&#39;t have an associated resource.</p><pre><code><span>{</span></code></pre><p><code>move()</code> moves all resources currently in this stack into a new <code>DisposableStack</code>. This can be useful if you need to transfer ownership of resources to another part of your code.</p><pre><code><span>{</span></code></pre><p><code>dispose()</code> in DisposableStack and <code>asyncDispose()</code> in AsyncDisposableStack dispose the resources within this object.</p><pre><code><span>{</span></code></pre><h2 id="availability" tabindex="-1">Availability <a href="#availability">#</a></h2><p>Explicit Resource Management is shipped in Chromium 134 and V8 v13.8.</p><h2 id="explicit-resource-management-support" tabindex="-1">Explicit Resource Management support <a href="#explicit-resource-management-support">#</a></h2><ul><li><a href="https://chromestatus.com/feature/5071680358842368"><span>Chrome:</span> <span>supported since version <span>134</span></span></a></li><li><a href="https://v8.dev/features/(nightly)"><span>Firefox:</span> <span>supported since version <span>134</span></span></a></li><li><a href="https://bugs.webkit.org/show_bug.cgi?id=248707"><span>Safari:</span> <span>no support</span></a></li><li><span>Node.js:</span> <span>no support</span></li><li><a href="https://github.com/zloirock/core-js#explicit-resource-management"><span>Babel:</span> <span>supported</span></a></li></ul></div></article></div></div>
  </body>
</html>
