<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.burntsushi.net/bstr/">Original</a>
    <h1>A byte string library for Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <div role="main">
    <div>
      

      <article>
      <p><a href="https://docs.rs/bstr/1.*"><code>bstr</code></a> is a byte string library for Rust and <a href="https://github.com/BurntSushi/bstr/releases/tag/1.0.0">its 1.0 version has
just been released</a>! It provides string oriented operations on
arbitrary sequences of bytes, but is most useful when those bytes are UTF-8. In
other words, it provides a string type that is UTF-8 by <em>convention</em>, where as
Rust‚Äôs built-in string types are <em>guaranteed</em> to be UTF-8.</p>
<p>This blog will briefly describe the API, do a deep dive on the motivation for
creating <code>bstr</code>, show some short example programs using <code>bstr</code> and conclude
with a few thoughts.</p>
<p><strong>Target audience</strong>: Rust programmers with some background knowledge of UTF-8.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#brief-api-overview">Brief API overview</a></li>
<li><a href="#quick-examples">Quick exampes</a></li>
<li><a href="#motivation-based-on-concepts">Motivation based on concepts</a></li>
<li><a href="#motivation-based-on-performance">Motivation based on performance</a></li>
<li><a href="#example-counting-characters-words-and-lines">Example: counting characters, words and lines</a></li>
<li><a href="#example-windowing-grep">Example: windowing grep</a></li>
<li><a href="#example-detecting-invalid-utf-8">Example: detecting invalid UTF-8</a></li>
<li><a href="#other-crates-that-support-byte-strings">Other crates that support byte strings</a></li>
<li><a href="#should-byte-strings-be-added-to-std">Should byte strings be added to std?</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
</ul>
<h2 id="brief-api-overview">Brief API overview</h2>
<p>The <code>bstr</code> crate works primarily by defining two extension traits,
<a href="https://docs.rs/bstr/1.*/bstr/trait.ByteSlice.html"><code>ByteSlice</code></a> and <a href="https://docs.rs/bstr/1.*/bstr/trait.ByteVec.html"><code>ByteVec</code></a>, that add string oriented
methods to the standard library <code>&amp;[u8]</code> and <code>Vec&lt;u8&gt;</code> types.</p>
<p>Since methods are added to existing types, <code>bstr</code> does not require you to use
any new string types to get access to its APIs. However, <code>bstr</code> does provide
its own <a href="https://docs.rs/bstr/1.*/bstr/struct.BStr.html"><code>BStr</code></a> and <a href="https://docs.rs/bstr/1.*/bstr/struct.BString.html"><code>BString</code></a> string types that
mirror the standard library <code>&amp;str</code> and <code>String</code> string types. The main purpose
of these types is for use in public APIs, for communicating intent, to gain
access to string oriented <code>Debug</code> impls and for optional integration with
<a href="https://serde.rs/">Serde</a>.</p>
<p>That‚Äôs pretty much it. The extension traits are where most of the APIs live.
Most of those APIs look very similar if not identical to the APIs provided
by the standard library <code>&amp;str</code> and <code>String</code> types. The main difference is that
<code>bstr</code>‚Äôs APIs don‚Äôt require valid UTF-8. For some APIs like substring search,
UTF-8 validity isn‚Äôt a concern at all. For other APIs like iterators over
<a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>s, invalid UTF-8 is handled by substituting the Unicode
replacement codepoint (<code>U+FFFD</code>): <code>ÔøΩ</code>.</p>
<p>One last thing to mention is the <a href="https://docs.rs/bstr/1.*/bstr/fn.B.html"><code>B</code> function</a>, which I‚Äôll use occasionally
in this blog. See the API docs for a complete explanation, but it makes it
slightly more convenient to write byte slices. Namely, while <code>&#34;foo&#34;</code> has type
<code>&amp;&#39;static str</code>, the corresponding byte string <code>b&#34;foo&#34;</code> has type <code>&amp;&#39;static [u8; 3]</code>. In some cases, the use of an array leads to annoyances, for example,
<code>vec![&#34;a&#34;, &#34;ab&#34;]</code> compiles but <code>vec![b&#34;a&#34;, b&#34;ab&#34;]</code> does not.</p>
<h2 id="quick-examples">Quick examples</h2>
<p>If you want to follow along at home with the examples, then a simple binary
Rust program is sufficient:</p>
<pre tabindex="0"><code>$ mkdir bstrblog
$ cd bstrblog
$ touch main.rs
$ cargo init --bin
$ cargo add bstr
</code></pre><p>Then open <code>main.rs</code> in your favorite editor and paste examples in there. Run
your program with <code>cargo run --release</code>.</p>
<p>First up is an example demonstrating substring search. Both the needle and
the haystack can be arbitrary bytes, just like classic C <a href="https://man7.org/linux/man-pages/man3/memmem.3.html"><code>memmem</code></a>
routine:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>bstr</span>::<span>ByteSlice</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>haystack</span><span> </span><span>=</span><span> </span><span>b&#34;foo bar foo</span><span>\xFF\xFF</span><span>foo quux foo&#34;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>start</span><span> </span><span>in</span><span> </span><span>haystack</span><span>.</span><span>find_iter</span><span>(</span><span>&#34;foo&#34;</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>matches</span><span>.</span><span>push</span><span>(</span><span>start</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>matches</span><span>,</span><span> </span><span>[</span><span>0</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>13</span><span>,</span><span> </span><span>22</span><span>]);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This makes use of the <a href="https://docs.rs/bstr/1.*/bstr/trait.ByteSlice.html#method.find_iter"><code>ByteSlice::find_iter</code></a> method. Unlike the
standard library, <code>bstr</code> doesn‚Äôt define polymorphic substring search APIs and
instead keeps things a little more concrete. For example, to search for a
<code>char</code>, you can use the <a href="https://docs.rs/bstr/1.*/bstr/trait.ByteSlice.html#method.find_char"><code>ByteSlice::find_char</code></a> method.</p>
<p>Note that if all you need is substring search on arbitrary bytes, or even just
a SIMD accelerated substring search which the standard library doesn‚Äôt yet
have, then you can avoid bringing in all of <code>bstr</code> and just use the <a href="https://docs.rs/memchr/2.*/memchr/memmem/index.html"><code>memmem</code>
sub-module of the <code>memchr</code> crate</a> instead. It‚Äôs the same
substring search that powers <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>.</p>
<p>Here‚Äôs another example that demonstrates Unicode-aware uppercasing, but on text
that is not valid UTF-8.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>bstr</span>::<span>{</span><span>B</span><span>,</span><span> </span><span>ByteSlice</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// \xCE\xB2 is the UTF-8 encoding of Œ≤.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>lower</span><span> </span><span>=</span><span> </span><span>b&#34;</span><span>\xFF</span><span> hello </span><span>\xCE\xB2</span><span>&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>upper</span><span> </span><span>=</span><span> </span><span>lower</span><span>.</span><span>to_uppercase</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>// \xCE\x92 is the UTF-8 encoding of Œí
</span></span></span><span><span><span></span><span>    </span><span>assert_eq!</span><span>(</span><span>B</span><span>(</span><span>b&#34;</span><span>\xFF</span><span> HELLO </span><span>\xCE\x92</span><span>&#34;</span><span>),</span><span> </span><span>upper</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>// Why use &#39;B&#39; here? Because otherwise its type is &amp;[u8; N] and
</span></span></span><span><span><span></span><span>    </span><span>// there is no PartialEq impl for it and Vec&lt;u8&gt;. Another way to
</span></span></span><span><span><span></span><span>    </span><span>// write it would have been &amp;b&#34;\xFF HEL...&#34;[..].
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The above example demonstrates that invalid UTF-8 doesn‚Äôt actually prevent one
from applying Unicode-aware algorithms on the parts of the string that are
valid UTF-8. The parts that are invalid UTF-8 are simply ignored.</p>
<p>Iterating over <code>char</code>s also works just fine even when the byte string is not
entirely valid UTF-8. The parts that are invalid UTF-8 simply get subtituted
with the Unicode replacement codepoint:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>bstr</span>::<span>ByteSlice</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// We write out the raw encoding here because it isn&#39;t possible to
</span></span></span><span><span><span></span><span>    </span><span>// write a string literal in Rust that has both Unicode literals
</span></span></span><span><span><span></span><span>    </span><span>// and invalid UTF-8.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>bytes</span><span> </span><span>=</span><span> </span><span>b&#34;</span><span>\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61</span><span>&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>chars</span>: <span>Vec</span><span>&lt;</span><span>char</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>bytes</span><span>.</span><span>chars</span><span>().</span><span>collect</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>vec!</span><span>[</span><span>&#39;‚òÉ&#39;</span><span>,</span><span> </span><span>&#39;\u{FFFD}&#39;</span><span>,</span><span> </span><span>&#39;ùûÉ&#39;</span><span>,</span><span> </span><span>&#39;\u{FFFD}&#39;</span><span>,</span><span> </span><span>&#39;a&#39;</span><span>],</span><span> </span><span>chars</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This next example shows one of the most useful aspects of <code>bstr</code>: the ability
to get nice <code>Debug</code> representations of byte strings. The downside is that you
need to convert your byte string to a <code>BStr</code> first, because there is no way to
override the standard library <code>Debug</code> impl for <code>&amp;[u8]</code>. (Which just prints each
byte as a decimal number.)</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>bstr</span>::<span>ByteSlice</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// \xCE\xB2 is the UTF-8 encoding of Œ≤.
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>bytes</span><span> </span><span>=</span><span> </span><span>b&#34;</span><span>\xFF</span><span> hello </span><span>\xCE\xB2</span><span>&#34;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;{:?}&#34;</span><span>,</span><span> </span><span>bytes</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>// Output: [255, 32, 104, 101, 108, 108, 111, 32, 206, 178]
</span></span></span><span><span><span></span><span>    </span><span>println!</span><span>(</span><span>&#34;{:?}&#34;</span><span>,</span><span> </span><span>bytes</span><span>.</span><span>as_bstr</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>// Output: &#34;\xFF hello Œ≤&#34;
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="motivation-based-on-concepts">Motivation based on concepts</h2>
<p>Rust‚Äôs primary string types (<code>&amp;str</code>/<code>String</code>) are perfectly fine for nearly
everything. And having the property that strings are guaranteed to be valid
UTF-8 can be quite useful in many contexts. That is, it lets you worry about
whether your data is malformed or not at the edges, and everything downstream
from it can know it‚Äôs clean UTF-8 without ever having to worry about what to do
when it‚Äôs not valid UTF-8.</p>
<p>In other words, if Rust‚Äôs primary string types work for your use case, then you
should probably ignore <code>bstr</code> altogether and continue using them.</p>
<p>So why have a byte string library? The simplest way to explain it is to point
at the <a href="https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read"><code>std::io::Read</code> trait</a>. How does it work? Well, it says
‚Äúanything implementing <code>std::io::Read</code> can take a writable slice of bytes, read
from its underlying source and put the bytes from the source to the writable
slice given.‚Äù Do you see anything missing? There‚Äôs no guarantee whatsoever
about what those bytes are. They can be anything. They might be an image. They
might be a video. Or a PDF. Or a plain text file.</p>
<p>In other words, the fundamental API we use to interact with data streams
doesn‚Äôt make any guarantees about the nature of that stream. This is by design
and it isn‚Äôt a Rust problem. On most mainstream operating systems, this is
how files themselves are represented. They are just sequences of bytes. The
<em>format</em> of those bytes usually exists at some other layer or is determined
through some additional context.</p>
<p>Let‚Äôs try to make this concrete by considering how a <code>grep</code> program works: it
reads lines from stdin and prints lines that match a literal (so no regex
support). We‚Äôll write it using strings, because that‚Äôs what you‚Äôre supposed to
do‚Ä¶ right?</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>Write</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>(),</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>needle</span><span> </span><span>=</span><span> </span><span>&#34;Affiliate&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>result</span><span> </span><span>in</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lines</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>result</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>line</span><span>.</span><span>contains</span><span>(</span><span>needle</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>writeln!</span><span>(</span><span>std</span>::<span>io</span>::<span>stdout</span><span>(),</span><span> </span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The question is, what do you expect the behavior of this program to be if
<code>stdin</code> doesn‚Äôt contain valid UTF-8? And does that expectation line up with
what you <em>want</em> the behavior of the program to be?</p>
<p>Well, let‚Äôs try it out. And there‚Äôs no need to make up our own data either.
Because invalid UTF-8 is more common than you might think. Whether it‚Äôs because
of test data, or just not using UTF-8 (perhaps latin-1 instead) or just
outright errors. The Linux kernel as of a few years ago used to have plenty of
C source files that weren‚Äôt valid UTF-8. That has since been fixed. But
<a href="https://github.com/mozilla/gecko-dev"><code>gecko-dev</code> (the source code for Firefox)</a> has plenty of files
that aren‚Äôt valid UTF-8. Let‚Äôs try running our program above on one:</p>
<pre tabindex="0"><code>$ path/to/bstrblog &lt; ./third_party/aom/PATENTS
1.3. Defensive Termination. If any Licensee, its Affiliates, or its agents
Error: Error { kind: InvalidData, message: &#34;stream did not contain valid UTF-8&#34; }
</code></pre><p>(<strong>Tip</strong>: Check out my little <a href="https://github.com/BurntSushi/dotfiles/blob/cb01234174bd58194363e54e9c3c8b2ffa1774ef/bin/rust/find-invalid-utf8/main.rs"><code>find-invalid-utf8</code> utility</a>
for how I quickly discover files that contain invalid UTF-8. It also doubles
as a nice example usage of <code>bstr</code> APIs that would be pretty annoying to write
using Rust‚Äôs standard library string types.)</p>
<p>Now, to be clear, it is perfectly reasonable for you to say, ‚ÄúI‚Äôm okay with
this.‚Äù Indeed, plain text files that are also not valid UTF-8 are pretty rare.
And if you‚Äôre building a purpose driven tool for data you control, it‚Äôs
probably pretty likely that you don‚Äôt care about your tool barfing on invalid
UTF-8.</p>
<p>On the other hand, if you‚Äôre building a general purpose tool, invalid UTF-8 is
not quite rare enough to declare you don‚Äôt care about it. Rust‚Äôs own file path
handling, for example, goes to great pains to ensure it can handle all possible
file paths, even when they don‚Äôt conform to any UTF encoding.</p>
<p>So‚Ä¶ what do you? There are a few choices I can think of:</p>
<ol>
<li>Skip any line that contains invalid UTF-8 and possibly print a warning
message to stderr.</li>
<li>If a line isn‚Äôt valid UTF-8, lossily decode it and search that. This does
mean you won‚Äôt be able to search for a needle that itself contains invalid
UTF-8, but it will handle a lot of cases. This is maybe not so bad for our
little literal searching tool, but is probably less ideal if your <code>grep</code>
program supported regexes. Do you or don‚Äôt you want something like <code>.+</code> to
match through invalid UTF-8?</li>
<li>Use byte strings pretty much like you‚Äôd use <code>&amp;str</code>/<code>String</code>, but have it
work automatically even when there‚Äôs invalid UTF-8. And it will work even if
the needle contains invalid UTF-8.</li>
</ol>
<p>The first two options can be done with Rust‚Äôs standard library pretty easily,
but the third option cannot be. So if the third option is the choice you want
to make, then <code>bstr</code> is probably exactly what you‚Äôre looking for. While the
standard library provides the <code>&amp;[u8]</code>/<code>Vec&lt;u8&gt;</code> types, there is effectively
almost no support for treating them as byte strings. For example, the <em>only</em>
substring search that the standard library provides is defined on <code>&amp;str</code>. You
can‚Äôt use the standard library to do a substring search on <code>&amp;[u8]</code>. So unless
you write your own substring search implementation (you probably shouldn‚Äôt),
you‚Äôre probably going to be looking for some kind of crate to do (3).</p>
<p>So what does this program look like with <code>bstr</code>? (It‚Äôs about the same size, but
I‚Äôve added some comments explaining a few things in the likely event that
you‚Äôre unfamiliar with <code>bstr</code>.)</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>Write</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// BufReadExt is an extension trait to std::io::BufRead
</span></span></span><span><span><span>// that defines a number of byte string oriented methods,
</span></span></span><span><span><span>// primarily for iterating over lines. These are useful
</span></span></span><span><span><span>// because most of the line iterators in the standard
</span></span></span><span><span><span>// library require valid UTF-8!
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>{</span><span>io</span>::<span>BufReadExt</span><span>,</span><span> </span><span>ByteSlice</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>(),</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>needle</span><span> </span><span>=</span><span> </span><span>&#34;Affiliate&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>result</span><span> </span><span>in</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>().</span><span>byte_lines</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>result</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>// &#39;[T]::contains&#39; is already defined in std and is not
</span></span></span><span><span><span></span><span>        </span><span>// substring search, so bstr defines it under a new name and
</span></span></span><span><span><span></span><span>        </span><span>// makes it generic so that it accepts anything that implements
</span></span></span><span><span><span></span><span>        </span><span>// AsRef&lt;[u8]&gt;.
</span></span></span><span><span><span></span><span>        </span><span>if</span><span> </span><span>line</span><span>.</span><span>contains_str</span><span>(</span><span>needle</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// We can&#39;t use &#39;writeln!&#39; any more because we
</span></span></span><span><span><span></span><span>            </span><span>// want to output exactly what we read, and the
</span></span></span><span><span><span></span><span>            </span><span>// &#39;writeln!&#39; family of macros can only write
</span></span></span><span><span><span></span><span>            </span><span>// valid UTF-8.
</span></span></span><span><span><span></span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>&amp;</span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>b&#34;</span><span>\n</span><span>&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Running it gives:</p>
<pre tabindex="0"><code>$ bstrblog &lt; ./third_party/aom/PATENTS
1.3. Defensive Termination. If any Licensee, its Affiliates, or its agents
2.1. Affiliate.  Affiliate means an entity that directly or indirectly
</code></pre><p>In summary, when a program is given data, unless there is some other mechanism
for describing what that data is, the program simply does not know how to
interpret it. In <em>most</em> cases, this is a bad thing. You really want to have
some kind of expected format and barf when the data does not conform.</p>
<p>But for general purpose Unix-like tooling on plain text files, what is your
expected format? It‚Äôs probably something like ‚Äúvalid UTF-8 with a reasonably
small number of bytes between newline characters.‚Äù (And an honorable mention
for UTF-16 on Windows.) But when there are so many files in practice that just
aren‚Äôt valid UTF-8 but are still mostly plain text, it winds up being important
for your general purpose tool to handle them by simply skipping over those
invalid UTF-8 bytes. But crucially, when it comes time for your tool to print
its output, like a <code>grep</code>, it‚Äôs important for it to print exactly what was
read. Doing this with string types that are guaranteed to be valid UTF-8 is
often difficult and sometimes just impossible.</p>
<p>(<strong>Note</strong>: a <code>grep</code> tool doesn‚Äôt just search plain text. It can also search
binary data. But most <code>grep</code> tools have heuristics for detecting binary data.
In those cases, the data is still searched but output is often suppressed
unless a special flag is given.)</p>
<p>But this is only half of the story. The other reason why a byte string library
is useful is performance.</p>
<h2 id="motivation-based-on-performance">Motivation based on performance</h2>
<p>The high level idea for why byte strings might be faster than strings that
are guaranteed to be valid UTF-8 is relatively simple. Namely, when you‚Äôre
expecting to see plain text, in most cases and in most contexts, that plain
text is going to be valid UTF-8. If you‚Äôre using a byte string library, how
much does it cost to build the string in memory? It costs exactly as much as
it takes to load the data from the file and into memory. But how much does it
cost if your string types are guaranteed to be valid UTF-8? Well, the relative
cost from byte strings is UTF-8 validation, which requires a full scan over the
string.</p>
<p>That‚Äôs pretty much it. Byte strings optimistically assume your strings are
UTF-8 and deal with invalid UTF-8 by defining some reasonable behavior on all
of its APIs for when invalid UTF-8 is encountered. In contrast, strings that
are guaranteed to be valid UTF-8 have to pessimistically assume the data might
be invalid UTF-8. Thus, UTF-8 validation must run during construction. Strings
that are guaranteed to be valid UTF-8 do have some performance upsides on
usage, for example, iterating over <code>char</code>s in a string <em>can</em> be faster because
code that knows and can rely on valid UTF-8 is likely to be faster than code
that needs to deal with error conditions.</p>
<p>(<strong>Musing</strong>: it is perhaps possible to build a string type between these two
design points, but Rust‚Äôs <code>&amp;str</code> API as it is certainly requires validation
to be run before permitting the construction of a <code>&amp;str</code>. Otherwise it‚Äôs not
really possible to call it a type that guarantees valid UTF-8.)</p>
<p>(<strong>Fun fact</strong>: <code>str</code> types merely have a <em>safety</em> invariant that they are
always valid UTF-8. They used to have a language level <em>validity</em> invariant,
but <a href="https://github.com/rust-lang/reference/pull/792">this was relaxed some time ago</a>. This doesn‚Äôt have
much practical impact, but the short story is that building a <code>str</code> that isn‚Äôt
valid UTF-8 <em>isn‚Äôt</em> instantly undefined behavior, but using almost any API on
<code>str</code> will probably result in undefined behavior.)</p>
<p>Let‚Äôs continue with our <code>grep</code> example in the previous section. We‚Äôll start
with the <code>grep</code> program that uses <code>&amp;str</code>/<code>String</code> for string types with a
couple tweaks:</p>
<ul>
<li>We use a needle that we know occurs a small number of times in the haystack.
This simplifies our benchmarking model somewhat by declaring that all we care
about is raw throughput. (Remember, all models are wrong, but some are useful.
This is not the <em>only</em> model, but it‚Äôs a decent one that balances real world
use cases with simplicity.) We could instead choose a needle that never
matches, but it‚Äôs good sense to pick one that matches sometimes to know that
we‚Äôre actually achieving the problem we set out to solve: to print matching
lines. When it comes to throughput of a grep program, there is no practical
difference between printing a small number of matching lines and printing no
matching lines.</li>
<li>Despite chiding one against implementing a substring search algorithm above,
we do exactly that here to ensure we are comparing apples to apples. In
particular, <code>bstr</code>‚Äôs substring search (which just uses the <code>memchr::memmem</code>
implementation) is <em>oodles</em> faster than the standard library‚Äôs due to its SIMD
acceleration. We‚Äôll do a quick bonus round at the end of this section to show
the difference.</li>
<li>We do our best to eliminate ‚Äúobvious‚Äù performance problems by amortizing
allocations. That is, we don‚Äôt create a whole new allocation for every line.
However, we resist the urge to ‚Äúwrite a fast grep.‚Äù I <a href="https://github.com/BurntSushi/ripgrep">cover that
elsewhere</a>, and instead stick to a decently simple program.</li>
<li>We change our haystack to something a bit bigger. If we use a haystack that‚Äôs
too small, then our benchmarking model likely needs to become more complicated
to account for noise. But if the haystack is big enough, noise is unlikely to
meaningfully impact our measurements.</li>
</ul>
<p>To generate the haystack, clone the Rust repo and concatenate all
Rust files into a single file. For this blog post, I used commit
<code>b44197abb0b3ffe4908892e1e08ab1cd721ff3b9</code>. Note also that the files are sorted
before concatenating, so that the result is guaranteed to be deterministic.
I‚Äôve also duplicated the result 5 times to make it just a little bigger. Here
are the precise commands to generate the haystack:</p>
<pre tabindex="0"><code>$ git clone https://github.com/rust-lang/rust
$ cd rust
$ git checkout b44197abb0b3ffe4908892e1e08ab1cd721ff3b9
$ find ./ -regex &#39;[^ ]+\.rs&#39; | sort | xargs cat &gt; /tmp/rust.rs
$ for ((i=0; i&lt;5; i++)); do cat /tmp/rust.rs; done &gt; /tmp/rust.5x.rs
</code></pre><p>So with that, here‚Äôs our revised <code>grep</code> program:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>BufRead</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>std</span>::<span>result</span>::<span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>shiftor</span><span> </span><span>=</span><span> </span><span>ShiftOr</span>::<span>new</span><span>(</span><span>&#34;Sushi&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rdr</span><span> </span><span>=</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>line</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>nread</span><span> </span><span>=</span><span> </span><span>rdr</span><span>.</span><span>read_line</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>nread</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>shiftor</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>line</span><span>).</span><span>is_some</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// &#39;read_line&#39; doesn&#39;t strip the line
</span></span></span><span><span><span></span><span>            </span><span>// terminator, so no need to write our own.
</span></span></span><span><span><span></span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>line</span><span>.</span><span>as_bytes</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[derive(Debug)]</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>ShiftOr</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>masks</span>: <span>[</span><span>u8</span><span>;</span><span> </span><span>256</span><span>],</span><span>
</span></span></span><span><span><span>    </span><span>needle_len</span>: <span>usize</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>ShiftOr</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>new</span><span>&lt;</span><span>T</span>: <span>AsRef</span><span>&lt;</span><span>[</span><span>u8</span><span>]</span><span>&gt;&gt;</span><span>(</span><span>needle</span>: <span>T</span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>ShiftOr</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>needle</span><span> </span><span>=</span><span> </span><span>needle</span><span>.</span><span>as_ref</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>needle_len</span><span> </span><span>=</span><span> </span><span>needle</span><span>.</span><span>len</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>needle_len</span><span> </span><span>&gt;</span><span> </span><span>7</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// A match is found when bit 7 is set in &#39;result&#39; in the search
</span></span></span><span><span><span></span><span>            </span><span>// routine below. So our needle can&#39;t be bigger than 7. We could
</span></span></span><span><span><span></span><span>            </span><span>// permit bigger needles by using u16, u32 or u64 for our mask
</span></span></span><span><span><span></span><span>            </span><span>// entries. But this is all we need for this example.
</span></span></span><span><span><span></span><span>            </span><span>return</span><span> </span><span>Err</span><span>(</span><span>&#34;needle exceeds 7 bytes, too long&#34;</span><span>.</span><span>into</span><span>());</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>searcher</span><span> </span><span>=</span><span> </span><span>ShiftOr</span><span> </span><span>{</span><span> </span><span>masks</span>: <span>[</span><span>!</span><span>0</span><span>;</span><span> </span><span>256</span><span>],</span><span> </span><span>needle_len</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>&amp;</span><span>byte</span><span>)</span><span> </span><span>in</span><span> </span><span>needle</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>searcher</span><span>.</span><span>masks</span><span>[</span><span>usize</span>::<span>from</span><span>(</span><span>byte</span><span>)]</span><span> </span><span>&amp;=</span><span> </span><span>!</span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>i</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>searcher</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>find</span><span>&lt;</span><span>T</span>: <span>AsRef</span><span>&lt;</span><span>[</span><span>u8</span><span>]</span><span>&gt;&gt;</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>haystack</span>: <span>T</span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;</span><span>usize</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>haystack</span><span> </span><span>=</span><span> </span><span>haystack</span><span>.</span><span>as_ref</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>!</span><span>1</span><span>u8</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>&amp;</span><span>byte</span><span>)</span><span> </span><span>in</span><span> </span><span>haystack</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>result</span><span> </span><span>|=</span><span> </span><span>self</span><span>.</span><span>masks</span><span>[</span><span>usize</span>::<span>from</span><span>(</span><span>byte</span><span>)];</span><span>
</span></span></span><span><span><span>            </span><span>result</span><span> </span><span>&lt;&lt;=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>result</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>self</span><span>.</span><span>needle_len</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>return</span><span> </span><span>Some</span><span>(</span><span>i</span><span> </span><span>-</span><span> </span><span>self</span><span>.</span><span>needle_len</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>None</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>(<strong>Note</strong>: I chose to use the <a href="https://en.wikipedia.org/wiki/Bitap_algorithm">Shift-Or</a> algorithm because it‚Äôs simple
and visits each byte in the haystack at most once. It‚Äôs not going to come close
to something that is SIMD accelerated in terms of performance, but it keeps
our benchmark model simple without making it totally naive. The other thing
to notice here is that our substring search implementation works on <code>&amp;[u8]</code>.
There is absolutely nothing about it that requires <code>&amp;str</code>. And this is indeed
true for just about all substring search algorithms. It‚Äôs just dealing with
bytes and doesn‚Äôt care about UTF-8 at all. The key thing to remember is that if
it weren‚Äôt for trying to do an apples-to-apples comparison here, we would of
course be using the standard library <a href="https://doc.rust-lang.org/std/primitive.str.html#method.contains"><code>str::contains</code></a> method.
We have to kind of hold our nose a little bit here and acknowledge that the
Shift-Or code is purely a property of our measurement model. We‚Äôll explore what
‚Äúreal world‚Äù code performance looks like later.)</p>
<p>Now let‚Äôs build our code and run it. Since we chose a needle that occurs
exactly three times, we should see three lines of output on the smaller
haystack (which will be duplicated 5 times in the bigger haystack):</p>
<pre tabindex="0"><code>$ cargo build --release
$ cp ./target/release/bstrblog grep-str
$ ./grep-str &lt; /tmp/rust.rs
        repo: &#34;https://github.com/BurntSushi/ripgrep&#34;,
        repo: &#34;https://github.com/BurntSushi/xsv&#34;,
//! @BurntSushi.
</code></pre><p>Now let‚Äôs write the byte string version. If we did everything right, the only
operational difference between this program and the previous one is that this
program doesn‚Äôt do UTF-8 validation. But everything else should be the same.
Note that we omit the <code>ShiftOr</code> type from this code listing since it remains
unchanged.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>BufRead</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>std</span>::<span>result</span>::<span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>shiftor</span><span> </span><span>=</span><span> </span><span>ShiftOr</span>::<span>new</span><span>(</span><span>&#34;Sushi&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rdr</span><span> </span><span>=</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>line</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>nread</span><span> </span><span>=</span><span> </span><span>rdr</span><span>.</span><span>read_until</span><span>(</span><span>b&#39;\n&#39;</span><span>,</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>nread</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>shiftor</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>line</span><span>).</span><span>is_some</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// &#39;read_line&#39; doesn&#39;t strip the line
</span></span></span><span><span><span></span><span>            </span><span>// terminator, so no need to write our own.
</span></span></span><span><span><span></span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>&amp;</span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Now build the new program and save the binary to a different name like we did
above. Also do our quick test to ensure it‚Äôs doing the same work:</p>
<pre tabindex="0"><code>$ cp ./target/release/bstrblog ./grep-bytes
$ ./grep-bytes &lt; /tmp/rust.rs
        repo: &#34;https://github.com/BurntSushi/ripgrep&#34;,
        repo: &#34;https://github.com/BurntSushi/xsv&#34;,
//! @BurntSushi.
</code></pre><p>Now let‚Äôs bake them off with <a href="https://github.com/sharkdp/hyperfine/">Hyperfine</a></p>
<pre tabindex="0"><code>$ hyperfine --warmup 5 &#34;./grep-str &lt; /tmp/rust.5x.rs&#34; &#34;./grep-bytes &lt; /tmp/rust.5x.rs&#34;
Benchmark #1: ./grep-str &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     573.0 ms ¬±   5.1 ms    [User: 531.1 ms, System: 41.3 ms]
  Range (min ‚Ä¶ max):   567.1 ms ‚Ä¶ 583.5 ms    10 runs

Benchmark #2: ./grep-bytes &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     449.2 ms ¬±   2.0 ms    [User: 407.5 ms, System: 41.2 ms]
  Range (min ‚Ä¶ max):   446.6 ms ‚Ä¶ 452.6 ms    10 runs

Summary
  &#39;./grep-bytes &lt; /tmp/rust.5x.rs&#39; ran
    1.28 ¬± 0.01 times faster than &#39;./grep-str &lt; /tmp/rust.5x.rs&#39;
</code></pre><p>There we go. The byte string version of the program is 1.28 times faster. It‚Äôs
not Earth shattering by any means, but it‚Äôs also nothing to sneeze at either.</p>
<p>Before popping up a level to discuss our findings, I think it would be fun to
compare the performance of similar programs, but without our Shift-Or
implementation. At the very least, it should tell us what kind of mistake we
would have made if we had just assumed that the standard library‚Äôs substring
search had the same performance characteristics as the one found in <code>bstr</code>.</p>
<p>So here‚Äôs the program using standard library routines:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>BufRead</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>std</span>::<span>result</span>::<span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>needle</span><span> </span><span>=</span><span> </span><span>&#34;Sushi&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rdr</span><span> </span><span>=</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>line</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>nread</span><span> </span><span>=</span><span> </span><span>rdr</span><span>.</span><span>read_line</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>nread</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>line</span><span>.</span><span>contains</span><span>(</span><span>needle</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>line</span><span>.</span><span>as_bytes</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And now the program using <code>bstr</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>BufRead</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>ByteSlice</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>std</span>::<span>result</span>::<span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>needle</span><span> </span><span>=</span><span> </span><span>&#34;Sushi&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rdr</span><span> </span><span>=</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>line</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>nread</span><span> </span><span>=</span><span> </span><span>rdr</span><span>.</span><span>read_until</span><span>(</span><span>b&#39;\n&#39;</span><span>,</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>nread</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>line</span><span>.</span><span>contains_str</span><span>(</span><span>needle</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>line</span><span>.</span><span>as_bytes</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And now let‚Äôs bake them off with Hyperfine again:</p>
<pre tabindex="0"><code>$ hyperfine --warmup 5 &#34;./grep-simple-str &lt; /tmp/rust.5x.rs&#34; &#34;./grep-simple-bytes &lt; /tmp/rust.5x.rs&#34;
Benchmark #1: ./grep-simple-str &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     710.2 ms ¬±   7.7 ms    [User: 667.6 ms, System: 41.9 ms]
  Range (min ‚Ä¶ max):   704.1 ms ‚Ä¶ 731.1 ms    10 runs

Benchmark #2: ./grep-simple-bytes &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     549.6 ms ¬±   2.9 ms    [User: 509.5 ms, System: 39.6 ms]
  Range (min ‚Ä¶ max):   546.5 ms ‚Ä¶ 556.1 ms    10 runs

Summary
  &#39;./grep-simple-bytes &lt; /tmp/rust.5x.rs&#39; ran
    1.29 ¬± 0.02 times faster than &#39;./grep-simple-str &lt; /tmp/rust.5x.rs&#39;
</code></pre><p>Errrmmm‚Ä¶ Wait, the byte string version is 1.29 times faster, which is almost
identical to our apples-to-apples version above. And on top of that, both
programs are <em>slower</em> than our Shift-Or programs despite supposedly both using
much fancier and faster substring search algorithms. Indeed, it turns out that
a significant portion of the runtime of our program (~25% from a quick glance
at a profile) is the <em>construction of the substring searcher</em>. Owch! This means
we‚Äôre really not measuring just throughput, but some combination of search
throughput added on to searcher construction.</p>
<p>Indeed, if you look back to our apples-to-apples comparison above, you‚Äôll
notice that the <code>ShiftOr</code> searcher is constructed <em>once</em> at the start of the
program because our needle is invariant throughout the lifetime of the program.
Rebuilding it for every line doesn‚Äôt make sense.</p>
<p>So now what? Well, the standard library doesn‚Äôt really give us any options. You
can‚Äôt build a substring searcher once like we did for <code>ShiftOr</code>. You just have
to call <code>contains</code> every time and eat the overhead.</p>
<p><code>bstr</code> does provide a way to build the searcher once through, via its <a href="https://docs.rs/bstr/1.*/bstr/struct.Finder.html"><code>Finder</code>
API</a>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>BufRead</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>ByteSlice</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>std</span>::<span>result</span>::<span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>searcher</span><span> </span><span>=</span><span> </span><span>bstr</span>::<span>Finder</span>::<span>new</span><span>(</span><span>&#34;Sushi&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rdr</span><span> </span><span>=</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>line</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>line</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>nread</span><span> </span><span>=</span><span> </span><span>rdr</span><span>.</span><span>read_until</span><span>(</span><span>b&#39;\n&#39;</span><span>,</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>line</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>nread</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>searcher</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>line</span><span>).</span><span>is_some</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>line</span><span>.</span><span>as_bytes</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And now let‚Äôs bake this one off against our standard library routine:</p>
<pre tabindex="0"><code>$ hyperfine --warmup 5 &#34;./grep-simple-str &lt; /tmp/rust.5x.rs&#34; &#34;./grep-opt1-bytes &lt; /tmp/rust.5x.rs&#34;
Benchmark #1: ./grep-simple-str &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     708.1 ms ¬±   2.4 ms    [User: 663.6 ms, System: 43.9 ms]
  Range (min ‚Ä¶ max):   704.5 ms ‚Ä¶ 710.8 ms    10 runs

Benchmark #2: ./grep-opt1-bytes &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     329.6 ms ¬±   2.9 ms    [User: 290.8 ms, System: 38.5 ms]
  Range (min ‚Ä¶ max):   326.7 ms ‚Ä¶ 335.1 ms    10 runs

Summary
  &#39;./grep-opt1-bytes &lt; /tmp/rust.5x.rs&#39; ran
    2.15 ¬± 0.02 times faster than &#39;./grep-simple-str &lt; /tmp/rust.5x.rs&#39;
</code></pre><p>This is now the fastest <code>grep</code> program we‚Äôve written. There is simply not an
apples-to-apples comparison we can do with the standard library here, because
the API is not available.</p>
<p>There is one more <code>bstr</code> API that helps things: its <a href="https://docs.rs/bstr/1.*/bstr/io/trait.BufReadExt.html"><code>BufReadExt</code> extension
trait</a>. It provides internal iterators over lines in a buffered
reader. In effect, it lets one avoid an additional copy of the bytes into our
caller provided <code>line</code> buffer in the code above. In exchange, we have to
provide a closure and invent our own protocol for stopping iteration early:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>Write</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>{</span><span>io</span>::<span>BufReadExt</span><span>,</span><span> </span><span>ByteSlice</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>std</span>::<span>result</span>::<span>Result</span><span>&lt;</span><span>T</span><span>,</span><span> </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>std</span>::<span>error</span>::<span>Error</span><span>&gt;&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>searcher</span><span> </span><span>=</span><span> </span><span>bstr</span>::<span>Finder</span>::<span>new</span><span>(</span><span>&#34;Sushi&#34;</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>rdr</span><span> </span><span>=</span><span> </span><span>std</span>::<span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>rdr</span><span>.</span><span>for_byte_line_with_terminator</span><span>(</span><span>|</span><span>line</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>searcher</span><span>.</span><span>find</span><span>(</span><span>line</span><span>).</span><span>is_some</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>std</span>::<span>io</span>::<span>stdout</span><span>().</span><span>write_all</span><span>(</span><span>line</span><span>.</span><span>as_bytes</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>true</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Baking this one off against our standard library routine gives us our best
run yet:</p>
<pre tabindex="0"><code>$ hyperfine --warmup 5 &#34;./grep-simple-str &lt; /tmp/rust.5x.rs&#34; &#34;./grep-opt2-bytes &lt; /tmp/rust.5x.rs&#34;
Benchmark #1: ./grep-simple-str &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     707.7 ms ¬±   3.0 ms    [User: 665.3 ms, System: 41.7 ms]
  Range (min ‚Ä¶ max):   702.4 ms ‚Ä¶ 712.7 ms    10 runs

Benchmark #2: ./grep-opt2-bytes &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     252.9 ms ¬±   1.1 ms    [User: 211.2 ms, System: 41.3 ms]
  Range (min ‚Ä¶ max):   251.3 ms ‚Ä¶ 254.5 ms    11 runs

Summary
  &#39;./grep-opt2-bytes &lt; /tmp/rust.5x.rs&#39; ran
    2.80 ¬± 0.02 times faster than &#39;./grep-simple-str &lt; /tmp/rust.5x.rs&#39;
</code></pre><p>So where does this leave us? Arguably, this section was just as much about
benchmarking methodology than it was about byte strings versus Rust‚Äôs default
strings. But the benchmarking methodology is critical because it‚Äôs important to
know what we‚Äôre measuring. It also lets us examine some of the strengths and
weaknesses of our model.</p>
<p>One strength is that it lets us precisely characterize the performance we‚Äôre
leaving on the table by doing UTF-8 validation for every line we iterate over.
This isn‚Äôt a micro-benchmark either. It‚Äôs a real program or part of a program
that someone might conceivably write, with perhaps a few alterations.
Iterating over lines and doing something with each matching line is a common
task.</p>
<p>But, this does expose a weakness: the model is <em>simplistic</em>. By being
simplistic, we are inherently leaving some performance on the table. For
example, we <em>could</em> rearchitect our program to decrease the granularity with
which we run UTF-8 validation. Instead of doing it once per line, we might try
to do it once per 64KB buffer. Since it‚Äôs likely that UTF-8 validation might
have some non-zero overhead, that could begin to add up when it‚Äôs called for
every line. And it‚Äôs likely that 64KB is <em>a lot</em> of lines. So it would
effectively eliminate that overhead cost.</p>
<p>This not only results in a more complex program, and while it might eliminate
the <em>overhead</em> of UTF-8 validation, it does not eliminate the cost of UTF-8
validation itself. That is, regardless of how you architect your program to
make UTF-8 validation faster, it will always have the relative disadvantage to
a program that uses byte strings that might not ever need to care about UTF-8
at all. It is perhaps <a href="https://lemire.me/blog/2018/05/16/validating-utf-8-strings-using-as-little-as-0-7-cycles-per-byte/">conceivable that UTF-8 validation could be made to run
so fast</a> that it is a nearly unnoticeable given the other work the
program is doing. But you‚Äôll still need to architect your program around it to
ensure you aren‚Äôt getting bitten by overhead.</p>
<p>Program rearchitecture can actually make a very significant difference in the
<code>grep</code> problem domain. Consider baking off our fastest variant so far with
ripgrep (GNU grep achieves a similar speed up):</p>
<pre tabindex="0"><code>$ hyperfine --warmup 5 &#34;./grep-opt2-bytes &lt; /tmp/rust.5x.rs&#34; &#34;rg Sushi &lt; /tmp/rust.5x.rs&#34;
Benchmark #1: ./grep-opt2-bytes &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):     253.6 ms ¬±   2.2 ms    [User: 210.1 ms, System: 43.2 ms]
  Range (min ‚Ä¶ max):   250.6 ms ‚Ä¶ 257.8 ms    11 runs

Benchmark #2: rg Sushi &lt; /tmp/rust.5x.rs
  Time (mean ¬± œÉ):      13.3 ms ¬±   0.9 ms    [User: 4.6 ms, System: 8.9 ms]
  Range (min ‚Ä¶ max):    11.3 ms ‚Ä¶  16.9 ms    178 runs

Summary
  &#39;rg Sushi &lt; /tmp/rust.5x.rs&#39; ran
   19.01 ¬± 1.35 times faster than &#39;./grep-opt2-bytes &lt; /tmp/rust.5x.rs&#39;
</code></pre><p>As I said, I‚Äôm not going to do a deep dive on how to write a fast <code>grep</code> in
this blog, but it‚Äôs likely the main reason why ripgrep is so much faster here
is because it doesn‚Äôt actually iterate over the lines of the input. While line
iteration itself can be quite fast, what isn‚Äôt fast is calling the substring
search implementation over and over again for every line. The substring search
implementation has overhead and that overhead adds up. Since the number of
matches are rare, ripgrep spends the vast majority of its time in substring
search, where as <code>grep-opt2-bytes</code> spends its time ping-ponging between line
iteration and substring search.</p>
<p>I leave it as an exercise to the reader to compare these programs when matches
are more frequent.</p>
<h2 id="example-counting-characters-words-and-lines">Example: counting characters, words and lines</h2>
<p>In this example, we‚Äôre going to write a stripped down version of <code>wc</code>, which
counts things like lines, words and characters. We aren‚Äôt going to try to be
POSIX compliant or even match GNU‚Äôs <code>wc</code> behavior (or performance) precisely,
but we will make use of Unicode‚Äôs grapheme and word segmentation algorithms.
Moreover, our program will work even when the input contains invalid UTF-8.</p>
<p>Let‚Äôs initialize our project and setup some dependencies:</p>
<pre tabindex="0"><code>$ mkdir wc
$ cd wc
$ touch main.rs
$ cargo init --bin
$ cargo add anyhow bstr lexopt
</code></pre><p>(<strong>Shout</strong> out to the <a href="https://docs.rs/lexopt/0.2.*"><code>lexopt</code></a> crate, which provides what I think is
the best minimalist argument parser in Rust. Note that, by design, it doesn‚Äôt
do <code>--help</code> generation. But it gets all the corner cases correct and is just
perfect for short little programs like these.)</p>
<p>Speaking of <code>lexopt</code>, let‚Äôs start with the argument parsing part of this
program:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// A configuration that says what we should count.
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// If no options are selected via arg parsing, then all options are
</span></span></span><span><span><span>/// enabled.
</span></span></span><span><span><span></span><span>#[derive(Clone, Debug, Default)]</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>Config</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>chars</span>: <span>bool</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>words</span>: <span>bool</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>lines</span>: <span>bool</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Config</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// Parse the given OS string args into a `wc` configuration.
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>parse</span><span>&lt;</span><span>I</span><span>&gt;</span><span>(</span><span>args</span>: <span>I</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>Config</span><span>&gt;</span><span>
</span></span></span><span><span><span>    </span><span>where</span><span>
</span></span></span><span><span><span>        </span><span>I</span>: <span>IntoIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>std</span>::<span>ffi</span>::<span>OsString</span><span>&gt;</span><span> </span><span>+</span><span> </span><span>&#39;</span><span>static</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>use</span><span> </span><span>lexopt</span>::<span>Arg</span>::<span>*</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>Config</span>::<span>default</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>// lexopt is just the bee&#39;s knees for small little
</span></span></span><span><span><span></span><span>        </span><span>// programs like this!
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>parser</span><span> </span><span>=</span><span> </span><span>lexopt</span>::<span>Parser</span>::<span>from_iter</span><span>(</span><span>args</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>while</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>arg</span><span>)</span><span> </span><span>=</span><span> </span><span>parser</span><span>.</span><span>next</span><span>()</span><span>?</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>match</span><span> </span><span>arg</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>Short</span><span>(</span><span>&#39;m&#39;</span><span>)</span><span> </span><span>|</span><span> </span><span>Long</span><span>(</span><span>&#34;chars&#34;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>config</span><span>.</span><span>chars</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>
</span></span></span><span><span><span>                </span><span>Short</span><span>(</span><span>&#39;l&#39;</span><span>)</span><span> </span><span>|</span><span> </span><span>Long</span><span>(</span><span>&#34;lines&#34;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>config</span><span>.</span><span>lines</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>
</span></span></span><span><span><span>                </span><span>Short</span><span>(</span><span>&#39;w&#39;</span><span>)</span><span> </span><span>|</span><span> </span><span>Long</span><span>(</span><span>&#34;words&#34;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>config</span><span>.</span><span>words</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>
</span></span></span><span><span><span>                </span><span>Short</span><span>(</span><span>&#39;h&#39;</span><span>)</span><span> </span><span>|</span><span> </span><span>Long</span><span>(</span><span>&#34;help&#34;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                    </span><span>anyhow</span>::<span>bail</span><span>!</span><span>(</span><span>
</span></span></span><span><span><span>                        </span><span>&#34;Usage: wc [-m/--chars -l/--lines -w/--words]&#34;</span><span>
</span></span></span><span><span><span>                    </span><span>);</span><span>
</span></span></span><span><span><span>                </span><span>}</span><span>
</span></span></span><span><span><span>                </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Err</span><span>(</span><span>arg</span><span>.</span><span>unexpected</span><span>().</span><span>into</span><span>()),</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>// If nothing is asked for, we do them all.
</span></span></span><span><span><span></span><span>        </span><span>if</span><span> </span><span>!</span><span>config</span><span>.</span><span>chars</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>config</span><span>.</span><span>words</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>config</span><span>.</span><span>lines</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>config</span><span>.</span><span>chars</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>config</span><span>.</span><span>words</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>config</span><span>.</span><span>lines</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>config</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>There isn‚Äôt too much to see here. We set the fields on <code>Config</code> based on the
flags we see. If we don‚Äôt see any flags, then we enable all of them.</p>
<p>And now for the main part of our program:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>self</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>{</span><span>io</span>::<span>BufReadExt</span><span>,</span><span> </span><span>ByteSlice</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Usage:
</span></span></span><span><span><span>///   wc [options] &lt; stdin
</span></span></span><span><span><span>///   foo ... | wc [options]
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// Where &#39;options&#39; is zero or more flags:
</span></span></span><span><span><span>///   -m, --chars   Counts grapheme clusters.
</span></span></span><span><span><span>///   -l, --lines   Counts lines, terminated by \n.
</span></span></span><span><span><span>///   -w, --words   Counts words, using Unicode Word Segmentation.
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>Config</span>::<span>parse</span><span>(</span><span>std</span>::<span>env</span>::<span>args_os</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>(</span><span>mut</span><span> </span><span>chars</span><span>,</span><span> </span><span>mut</span><span> </span><span>words</span><span>,</span><span> </span><span>mut</span><span> </span><span>lines</span><span>)</span><span> </span><span>=</span><span> </span><span>(</span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bufrdr</span><span> </span><span>=</span><span> </span><span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>bufrdr</span><span>.</span><span>for_byte_line_with_terminator</span><span>(</span><span>|</span><span>line</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>lines</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>config</span><span>.</span><span>chars</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>chars</span><span> </span><span>+=</span><span> </span><span>line</span><span>.</span><span>graphemes</span><span>().</span><span>count</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>config</span><span>.</span><span>words</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>words</span><span> </span><span>+=</span><span> </span><span>line</span><span>.</span><span>words</span><span>().</span><span>count</span><span>();</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>true</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>toprint</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>config</span><span>.</span><span>lines</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>toprint</span><span>.</span><span>push</span><span>(</span><span>lines</span><span>.</span><span>to_string</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>config</span><span>.</span><span>words</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>toprint</span><span>.</span><span>push</span><span>(</span><span>words</span><span>.</span><span>to_string</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>config</span><span>.</span><span>chars</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>toprint</span><span>.</span><span>push</span><span>(</span><span>chars</span><span>.</span><span>to_string</span><span>());</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>writeln!</span><span>(</span><span>io</span>::<span>stdout</span><span>(),</span><span> </span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>toprint</span><span>.</span><span>join</span><span>(</span><span>&#34;\t&#34;</span><span>))</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The parts of this program that actually make use of <code>bstr</code> are quite brief, but
this simplicity comes in part because of how byte strings optimistically assume
valid UTF-8. Those parts are:</p>
<ul>
<li><a href="https://docs.rs/bstr/1.*/bstr/io/trait.BufReadExt.html#method.for_byte_line_with_terminator"><code>BufReadExt::for_byte_line_with_terminator</code></a> gives us a
super fast way of iterating over lines. We do have to provide a closure, but
in exchange, we don‚Äôt need to amortize allocations ourselves and there is no
extra copying.</li>
<li><a href="https://docs.rs/bstr/1.*/bstr/trait.ByteSlice.html#method.graphemes"><code>ByteSlice::graphemes</code></a> gives us an iterator over all
<a href="https://www.unicode.org/reports/tr29/tr29-39.html#Grapheme_Cluster_Boundaries">grapheme clusters</a> in a byte string. Grapheme clusters are
Unicode‚Äôs answer to how to <em>approximate</em> what an end user might think of as
a character. When invalid UTF-8 is encountered, it is substituted with the
Unicode replacement codepoint and yielded as its own grapheme.</li>
<li><a href="https://docs.rs/bstr/1.*/bstr/trait.ByteSlice.html#method.words"><code>ByteSlice:::words</code></a> gives us an iterator over all
<a href="https://www.unicode.org/reports/tr29/tr29-39.html#Word_Boundaries">Unicode words</a> in a byte string. Like with graphemes, when
invalid UTF-8 is encountered, it is subtituted with the Unicode replacement
codepoint and yielded as its own word.</li>
</ul>
<p>This program <em>could</em> be written using <code>&amp;str</code>/<code>String</code> with the
<a href="https://docs.rs/unicode-segmentation/1.*/"><code>unicode-segmentation</code> crate</a>. But, in order to use that
crate, you need a <code>&amp;str</code>. This runs into similar issues we faced when writing
our <code>grep</code> program above. You could error out completely if invalid UTF-8 is
seen, skip lines that are invalid UTF-8, or try to lossily decode lines that
contain invalid UTF-8. Depending on your requirements, any of these options are
workable, but they come with extra code complexity and probably additional
runtime overhead. (I say ‚Äúprobably‚Äù because the grapheme and word counting
might dwarf UTF-8 validation, but this is very hand-wavy. Optimizing a
Unicode-aware <code>wc</code> is a deep rabbit hole that is beyond the scope of this
blog.)</p>
<h2 id="example-windowing-grep">Example: windowing grep</h2>
<p>In this example, we‚Äôre going to adapt our <code>grep</code> program above so that it
prints a window of grapheme clusters around each match on a line. This is
especially useful when searching files with large lines (like minified
Javascript). This way, you can still see a bit of context for each match, but
without dumping a bunch of jibberish to your terminal.</p>
<p>We‚Äôll get started similarly as the previous example, except we‚Äôll add
<code>termcolor</code> so that we can colorize our matches.</p>
<pre tabindex="0"><code>$ mkdir window-grep
$ cd window-grep
$ touch main.rs
$ cargo init --bin
$ cargo add anyhow bstr lexopt termcolor
</code></pre><p>Let‚Äôs again start with the argument parsing aspect of the program:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>bstr</span>::<span>ByteVec</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// A configuration that says what we should look for and big the
</span></span></span><span><span><span>/// window to print around each match.
</span></span></span><span><span><span></span><span>#[derive(Clone, Debug)]</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>Config</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// The needle we want to search for.
</span></span></span><span><span><span></span><span>    </span><span>needle</span>: <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>/// A window size bigger than 255 kind of defeats the purpose.
</span></span></span><span><span><span></span><span>    </span><span>window</span>: <span>u8</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Config</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// Parse the given OS string args into a `window-grep`
</span></span></span><span><span><span></span><span>    </span><span>/// configuration.
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>parse</span><span>&lt;</span><span>I</span><span>&gt;</span><span>(</span><span>args</span>: <span>I</span><span>)</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>Config</span><span>&gt;</span><span>
</span></span></span><span><span><span>    </span><span>where</span><span>
</span></span></span><span><span><span>        </span><span>I</span>: <span>IntoIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>std</span>::<span>ffi</span>::<span>OsString</span><span>&gt;</span><span> </span><span>+</span><span> </span><span>&#39;</span><span>static</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>use</span><span> </span><span>lexopt</span>::<span>{</span><span>Arg</span>::<span>*</span><span>,</span><span> </span><span>ValueExt</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>const</span><span> </span><span>USAGE</span>: <span>&amp;</span><span>str</span> <span>=</span><span> </span><span>&#34;Usage: window-grep [-w/--window SIZE] &lt;needle&gt;&#34;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>Config</span><span> </span><span>{</span><span> </span><span>needle</span>: <span>vec</span><span>!</span><span>[],</span><span> </span><span>window</span>: <span>10</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>saw_needle</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>parser</span><span> </span><span>=</span><span> </span><span>lexopt</span>::<span>Parser</span>::<span>from_iter</span><span>(</span><span>args</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>while</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>arg</span><span>)</span><span> </span><span>=</span><span> </span><span>parser</span><span>.</span><span>next</span><span>()</span><span>?</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>match</span><span> </span><span>arg</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>Short</span><span>(</span><span>&#39;w&#39;</span><span>)</span><span> </span><span>|</span><span> </span><span>Long</span><span>(</span><span>&#34;window&#34;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                    </span><span>config</span><span>.</span><span>window</span><span> </span><span>=</span><span> </span><span>parser</span><span>.</span><span>value</span><span>()</span><span>?</span><span>.</span><span>parse</span><span>()</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>                </span><span>}</span><span>
</span></span></span><span><span><span>                </span><span>Short</span><span>(</span><span>&#39;h&#39;</span><span>)</span><span> </span><span>|</span><span> </span><span>Long</span><span>(</span><span>&#34;help&#34;</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                    </span><span>anyhow</span>::<span>bail</span><span>!</span><span>(</span><span>USAGE</span><span>);</span><span>
</span></span></span><span><span><span>                </span><span>}</span><span>
</span></span></span><span><span><span>                </span><span>Value</span><span>(</span><span>v</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                    </span><span>anyhow</span>::<span>ensure</span><span>!</span><span>(</span><span>!</span><span>saw_needle</span><span>,</span><span> </span><span>USAGE</span><span>);</span><span>
</span></span></span><span><span><span>                    </span><span>saw_needle</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span><span>
</span></span></span><span><span><span>                    </span><span>// This is a bstr API that is a no-op on Unix and
</span></span></span><span><span><span></span><span>                    </span><span>// returns an error on Windows if the OS string
</span></span></span><span><span><span></span><span>                    </span><span>// wasn&#39;t originally valid UTF-16. Such things are
</span></span></span><span><span><span></span><span>                    </span><span>// rare on Windows and we don&#39;t care to support
</span></span></span><span><span><span></span><span>                    </span><span>// them.
</span></span></span><span><span><span></span><span>                    </span><span>config</span><span>.</span><span>needle</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>from_os_string</span><span>(</span><span>v</span><span>).</span><span>map_err</span><span>(</span><span>|</span><span>_</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                        </span><span>anyhow</span>::<span>anyhow</span><span>!</span><span>(</span><span>
</span></span></span><span><span><span>                            </span><span>&#34;needle is not valid UTF-16 on Windows&#34;</span><span>,</span><span>
</span></span></span><span><span><span>                        </span><span>)</span><span>
</span></span></span><span><span><span>                    </span><span>})</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>                </span><span>}</span><span>
</span></span></span><span><span><span>                </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Err</span><span>(</span><span>arg</span><span>.</span><span>unexpected</span><span>().</span><span>into</span><span>()),</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>anyhow</span>::<span>ensure</span><span>!</span><span>(</span><span>saw_needle</span><span>,</span><span> </span><span>USAGE</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>anyhow</span>::<span>ensure</span><span>!</span><span>(</span><span>!</span><span>config</span><span>.</span><span>needle</span><span>.</span><span>is_empty</span><span>(),</span><span> </span><span>&#34;needle must be non-empty&#34;</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>config</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Now let‚Äôs write a couple routines to extract the leading and trailing grapheme
clusters from an arbitrary byte string:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>bstr</span>::<span>ByteSlice</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Return a slice of the `size` leading grapheme clusters from `slice`.
</span></span></span><span><span><span></span><span>fn</span> <span>leading_graphemes</span><span>(</span><span>slice</span>: <span>&amp;</span><span>[</span><span>u8</span><span>],</span><span> </span><span>size</span>: <span>u8</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>[</span><span>u8</span><span>]</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>slice</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>grapheme_indices</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>take</span><span>(</span><span>usize</span>::<span>from</span><span>(</span><span>size</span><span>))</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>last</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>map_or</span><span>(</span><span>&amp;</span><span>[],</span><span> </span><span>|</span><span>(</span><span>_</span><span>,</span><span> </span><span>end</span><span>,</span><span> </span><span>_</span><span>)</span><span>|</span><span> </span><span>&amp;</span><span>slice</span><span>[</span><span>..</span><span>end</span><span>])</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Return a slice of the `size` trailing grapheme clusters from `slice`.
</span></span></span><span><span><span></span><span>fn</span> <span>trailing_graphemes</span><span>(</span><span>slice</span>: <span>&amp;</span><span>[</span><span>u8</span><span>],</span><span> </span><span>size</span>: <span>u8</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>[</span><span>u8</span><span>]</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>slice</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>grapheme_indices</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>rev</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>take</span><span>(</span><span>usize</span>::<span>from</span><span>(</span><span>size</span><span>))</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>last</span><span>()</span><span>
</span></span></span><span><span><span>        </span><span>.</span><span>map_or</span><span>(</span><span>&amp;</span><span>[],</span><span> </span><span>|</span><span>(</span><span>start</span><span>,</span><span> </span><span>_</span><span>,</span><span> </span><span>_</span><span>)</span><span>|</span><span> </span><span>&amp;</span><span>slice</span><span>[</span><span>start</span><span>..</span><span>])</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>These routines make use of the
<a href="https://docs.rs/bstr/1.*/bstr/trait.ByteSlice.html#method.grapheme_indices"><code>ByteSlice::grapheme_indices</code></a> API in <code>bstr</code>, which not
only provides the grapheme cluster itself, but also the byte offsets at which
the cluster started and ended in the original byte string. (It‚Äôs similar to the
standard library <a href="https://doc.rust-lang.org/std/primitive.str.html#method.char_indices"><code>str::char_indices</code></a> API, but for grapheme
clusters.)</p>
<p>(<strong>Note</strong>: A similar approach is <a href="https://github.com/BurntSushi/ripgrep/blob/60a1db34a69b0d57adb9c2725366e9d8adb5efdc/crates/printer/src/standard.rs#L1319-L1381">used in ripgrep</a> to
implement a similar windowing feature.)</p>
<p>Consider how one might implement something like this without an API
to decode graphemes from byte strings. Even if you had a substring
search implementation that works on byte strings, how would you go about
finding the surrounding grapheme cluster window? Since crates like
<a href="https://docs.rs/unicode-segmentation/1.*/"><code>unicode-segmentation</code></a> require a <code>&amp;str</code>, you‚Äôd have
to do some kind of UTF-8 validation. In that case, you would in turn have to
either validate the entire line, or find some way to write an incremental
UTF-8 validator (which is difficult/annoying to do with just standard library
routines). But even if you had that, how would you know when to stop? The key
problem here is that you don‚Äôt know when to stop decoding grapheme clusters
without actually decoding them. The <code>unicode-segmentation</code> crate could
potentially help you by exposing an API that works on an <code>Iterator&lt;Item=char&gt;</code>,
but it‚Äôs not totally clear if that‚Äôs a good idea, and it could require big
internal refactoring.</p>
<p>Okay, let‚Äôs move on to a function that prints and colorizes the match:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Write the given slice as a colored match.
</span></span></span><span><span><span></span><span>fn</span> <span>write_match</span><span>&lt;</span><span>W</span>: <span>WriteColor</span><span>&gt;</span><span>(</span><span>mut</span><span> </span><span>wtr</span>: <span>W</span><span>,</span><span> </span><span>slice</span>: <span>&amp;</span><span>[</span><span>u8</span><span>])</span><span> </span>-&gt; <span>io</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>termcolor</span>::<span>{</span><span>Color</span><span>,</span><span> </span><span>ColorSpec</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>color</span><span> </span><span>=</span><span> </span><span>ColorSpec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>color</span><span>.</span><span>set_fg</span><span>(</span><span>Some</span><span>(</span><span>Color</span>::<span>Red</span><span>)).</span><span>set_bold</span><span>(</span><span>true</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>wtr</span><span>.</span><span>set_color</span><span>(</span><span>&amp;</span><span>color</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>wtr</span><span>.</span><span>write_all</span><span>(</span><span>slice</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>wtr</span><span>.</span><span>reset</span><span>()</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>There‚Äôs nothing much interesting to note here. So now finally, let‚Äôs look at
the meat of the program that looks for matches and does the printing:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>self</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>io</span>::<span>BufReadExt</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Usage:
</span></span></span><span><span><span>///   window-grep [options] &lt;needle&gt; &lt; stdin
</span></span></span><span><span><span>///   foo ... | window-grep [options] &lt;needle&gt;
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// Where &#39;options&#39; is zero or more flags:
</span></span></span><span><span><span>///   -w SIZE, --window SIZE   The window size in graphemes. Default is 10.
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>config</span><span> </span><span>=</span><span> </span><span>Config</span>::<span>parse</span><span>(</span><span>std</span>::<span>env</span>::<span>args_os</span><span>())</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>searcher</span><span> </span><span>=</span><span> </span><span>bstr</span>::<span>Finder</span>::<span>new</span><span>(</span><span>&amp;</span><span>config</span><span>.</span><span>needle</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bufrdr</span><span> </span><span>=</span><span> </span><span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>wtr</span><span> </span><span>=</span><span> </span><span>termcolor</span>::<span>StandardStream</span>::<span>stdout</span><span>(</span><span>ColorChoice</span>::<span>Auto</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>lineno</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>bufrdr</span><span>.</span><span>for_byte_line</span><span>(</span><span>|</span><span>line</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>lineno</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>// Contains the offset of the last printed byte. This ensures
</span></span></span><span><span><span></span><span>        </span><span>// we don&#39;t print overlapping windows if the span between
</span></span></span><span><span><span></span><span>        </span><span>// matches is less than our window size.
</span></span></span><span><span><span></span><span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>printed</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span><span>(</span><span>mut</span><span> </span><span>start</span><span>,</span><span> </span><span>mut</span><span> </span><span>end</span><span>)</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>searcher</span><span>.</span><span>find</span><span>(</span><span>line</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>true</span><span>),</span><span>
</span></span></span><span><span><span>            </span><span>Some</span><span>(</span><span>i</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>config</span><span>.</span><span>needle</span><span>.</span><span>len</span><span>()),</span><span>
</span></span></span><span><span><span>        </span><span>};</span><span>
</span></span></span><span><span><span>        </span><span>write!</span><span>(</span><span>wtr</span><span>,</span><span> </span><span>&#34;{}:&#34;</span><span>,</span><span> </span><span>lineno</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>before</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>line</span><span>[</span><span>printed</span><span>..</span><span>start</span><span>];</span><span>
</span></span></span><span><span><span>            </span><span>wtr</span><span>.</span><span>write_all</span><span>(</span><span>trailing_graphemes</span><span>(</span><span>before</span><span>,</span><span> </span><span>config</span><span>.</span><span>window</span><span>))</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>write_match</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>wtr</span><span>,</span><span> </span><span>&amp;</span><span>config</span><span>.</span><span>needle</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>printed</span><span> </span><span>=</span><span> </span><span>end</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>match</span><span> </span><span>searcher</span><span>.</span><span>find</span><span>(</span><span>&amp;</span><span>line</span><span>[</span><span>end</span><span>..</span><span>])</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>break</span><span>,</span><span>
</span></span></span><span><span><span>                </span><span>Some</span><span>(</span><span>i</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                    </span><span>start</span><span> </span><span>=</span><span> </span><span>end</span><span> </span><span>+</span><span> </span><span>i</span><span>;</span><span>
</span></span></span><span><span><span>                    </span><span>end</span><span> </span><span>=</span><span> </span><span>start</span><span> </span><span>+</span><span> </span><span>config</span><span>.</span><span>needle</span><span>.</span><span>len</span><span>();</span><span>
</span></span></span><span><span><span>                </span><span>}</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>wtr</span><span>.</span><span>write_all</span><span>(</span><span>leading_graphemes</span><span>(</span><span>&amp;</span><span>line</span><span>[</span><span>end</span><span>..</span><span>],</span><span> </span><span>config</span><span>.</span><span>window</span><span>))</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>write!</span><span>(</span><span>wtr</span><span>,</span><span> </span><span>&#34;\n&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>true</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The offset management is a bit dense, but it‚Äôs mostly to avoid printing
overlapping windows when the span between matches is smaller than our
configured window size. Otherwise, our <code>leading_graphemes</code> and
<code>trailing_graphemes</code> functions are doing the most interesting work. And that‚Äôs
really where byte strings keep things simple in this program. If you were
forced to work with <code>&amp;str</code>/<code>String</code> for this, then you‚Äôre likely either paying
some non-trivial additional cost or adding some complexity to your code. Having
a grapheme cluster segmenter that works directly on byte strings ends up being
a nice convenience!</p>
<h2 id="example-detecting-invalid-utf-8">Example: detecting invalid UTF-8</h2>
<p>In this very short example, we‚Äôre going to demonstrate how to detect invalid
UTF-8 by using <code>bstr</code>‚Äôs decode-one-codepoint-at-a-time API. We‚Äôll do this by
writing a program that prints only the lines from stdin that contain invalid
UTF-8. It will print the invalid UTF-8 bytes in their hexadecimal form and
colorize them to make it easier to see.</p>
<p>We‚Äôll start like we did with the previous examples. We won‚Äôt need <code>lexopt</code> for
this one, but we keep <code>termcolor</code> around for colorizing.</p>
<pre tabindex="0"><code>$ mkdir badutf8
$ cd badutf8
$ touch main.rs
$ cargo init --bin
$ cargo add anyhow bstr termcolor
</code></pre><p>First, let‚Äôs write a helper function that will be responsible for printing the
invalid UTF-8 bytes. That is, it should print them in hexadecimal form and
colorize them.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// Write each byte in the slice in its hexadecimal form,
</span></span></span><span><span><span>/// and with bold coloring.
</span></span></span><span><span><span></span><span>fn</span> <span>write_invalid_utf8</span><span>&lt;</span><span>W</span>: <span>WriteColor</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>mut</span><span> </span><span>wtr</span>: <span>W</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>slice</span>: <span>&amp;</span><span>[</span><span>u8</span><span>],</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>io</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>use</span><span> </span><span>termcolor</span>::<span>{</span><span>Color</span><span>,</span><span> </span><span>ColorSpec</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>color</span><span> </span><span>=</span><span> </span><span>ColorSpec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>color</span><span>.</span><span>set_fg</span><span>(</span><span>Some</span><span>(</span><span>Color</span>::<span>Red</span><span>)).</span><span>set_bold</span><span>(</span><span>true</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>wtr</span><span>.</span><span>set_color</span><span>(</span><span>&amp;</span><span>color</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>&amp;</span><span>byte</span><span> </span><span>in</span><span> </span><span>slice</span><span>.</span><span>iter</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>write!</span><span>(</span><span>wtr</span><span>,</span><span> </span><span>r&#34;\x{:X}&#34;</span><span>,</span><span> </span><span>byte</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>wtr</span><span>.</span><span>reset</span><span>()</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And now let‚Äôs see our <code>main</code> function that is responsible for iterating over
all lines, looking for invalid UTF-8 and printing the line:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>{</span><span>self</span><span>,</span><span> </span><span>Write</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>bstr</span>::<span>{</span><span>io</span>::<span>BufReadExt</span><span>,</span><span> </span><span>ByteSlice</span><span>};</span><span>
</span></span></span><span><span><span></span><span>use</span><span> </span><span>termcolor</span>::<span>{</span><span>ColorChoice</span><span>,</span><span> </span><span>WriteColor</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Usage:
</span></span></span><span><span><span>///   badutf8 &lt; stdin
</span></span></span><span><span><span>///   foo ... | badutf8
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>anyhow</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>bufrdr</span><span> </span><span>=</span><span> </span><span>io</span>::<span>stdin</span><span>().</span><span>lock</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>wtr</span><span> </span><span>=</span><span> </span><span>termcolor</span>::<span>StandardStream</span>::<span>stdout</span><span>(</span><span>ColorChoice</span>::<span>Auto</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>lineno</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>bufrdr</span><span>.</span><span>for_byte_line</span><span>(</span><span>|</span><span>mut</span><span> </span><span>line</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>lineno</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>if</span><span> </span><span>line</span><span>.</span><span>is_utf8</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>true</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>write!</span><span>(</span><span>wtr</span><span>,</span><span> </span><span>&#34;{}:&#34;</span><span>,</span><span> </span><span>lineno</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>(</span><span>ch</span><span>,</span><span> </span><span>size</span><span>)</span><span> </span><span>=</span><span> </span><span>bstr</span>::<span>decode_utf8</span><span>(</span><span>line</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>size</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>ch</span><span>.</span><span>is_some</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>wtr</span><span>.</span><span>write_all</span><span>(</span><span>&amp;</span><span>line</span><span>[</span><span>..</span><span>size</span><span>])</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                </span><span>write_invalid_utf8</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>wtr</span><span>,</span><span> </span><span>&amp;</span><span>line</span><span>[</span><span>..</span><span>size</span><span>])</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>            </span><span>line</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>line</span><span>[</span><span>size</span><span>..</span><span>];</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>write!</span><span>(</span><span>wtr</span><span>,</span><span> </span><span>&#34;\n&#34;</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>true</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>This makes use of the <a href="https://docs.rs/bstr/1.*/bstr/fn.decode_utf8.html"><code>bstr::decode_utf8</code></a> API. It permits
incrementally decoding one codepoint at a time from a byte string. It is
occasionally useful when you just want to pluck out a codepoint from somewhere
in a byte string, and have complete control over how invalid UTF-8 is handled.</p>
<p>Here‚Äôs an example of how this program is used:</p>
<pre tabindex="0"><code>$ echo &#39;foo\xFFbar\xE2\x98quux&#39; | badutf8
1:foo\xFFbar\xE2\x98quux
$ badutf8 &lt; gecko-dev/third_party/aom/PATENTS
60:2.1. Affiliate.  \x93Affiliate\x94 means an entity that directly or indirectly
63:2.2. Control. \x93Control\x94 means direct or indirect control of more than 50% of
73:2.5. Final Deliverable.  \x93Final Deliverable\x94 means the final version of a
82:2.7. License. \x93License\x94 means this license.
84:2.8. Licensee. \x93Licensee\x94 means any person or entity who exercises patent
101:2.11. Reference Implementation. \x93Reference Implementation\x94 means an Encoder
105:2.12. Specification. \x93Specification\x94 means the specification designated by
</code></pre><p>You can‚Äôt see the color here, but all of the hexadecimal numbers are bolded and
colored in red when printed to a terminal.</p>
<h2 id="other-crates-that-support-byte-strings">Other crates that support byte strings</h2>
<p>Almost every crate I publish that deals with text works on both <code>&amp;str</code> and
<code>&amp;[u8]</code>. Some examples:</p>
<ul>
<li>The <a href="https://docs.rs/regex/1.*/regex/bytes/index.html"><code>bytes</code> submodule of the <code>regex</code> crate</a> provides a <code>Regex</code>
that can search a <code>&amp;[u8]</code> instead of a <code>&amp;str</code>. A <code>bytes::Regex</code> is also
permitted to match invalid UTF-8 (or even split a codepoint if you want it
to), where as the top-level <code>Regex</code> can never match invalid UTF-8 no matter
what.</li>
<li>The <a href="https://docs.rs/aho-corasick/0.7.*/aho_corasick/"><code>aho-corasick</code></a> crate provides APIs that work on anything
that implements <code>AsRef&lt;[u8]&gt;</code>. This includes both the needles and the
haystack.</li>
<li>The <a href="https://docs.rs/memchr/1.*/memchr/"><code>memchr</code></a> crate works exclusively on <code>&amp;[u8]</code>.</li>
</ul>
<p>The byte string support in these crates is absolutely critical for tools like
ripgrep to exist at all. Writing ripgrep using strings that are guaranteed to
be valid UTF-8 everywhere is flatly infeasible for much of the reasons
discussed earlier in this blog. But it‚Äôs worth discussing one other reason as
well: file backed memory maps.</p>
<p>While searching files via memory maps isn‚Äôt necessarily faster, it can be a bit
faster in some cases. ripgrep tries to use memory maps in those cases. A memory
map effectively exposes the contents of a file as a <code>&amp;[u8]</code>. The full slice
might not actually be loaded into memory, but as your program accesses it, page
faults occur and the operating system loads data from the file into the <code>&amp;[u8]</code>
for you automatically. It‚Äôs all transparent and awesome. (But also, there are
pitfalls, and it‚Äôs beyond the scope of this blog to explore them.)</p>
<p>So that <code>&amp;[u8]</code> you get back might be huge. It might be bigger than available
memory. Now let‚Äôs say none of the crates above had byte string support. How do
you run a regex search on a <code>&amp;[u8]</code> when all you have are APIs that work on
<code>&amp;str</code>? The regex crate doesn‚Äôt provide any way to incrementally feed it data.
You could run it line-by-line, but that is quite slow and doesn‚Äôt work in the
case of multi-line searches. You‚Äôre kind of stuck. Your choices are:</p>
<ul>
<li>Don‚Äôt use memory maps and miss out on the optimization.</li>
<li>Modify the regex crate to support <a href="https://github.com/rust-lang/regex/issues/425">searching streams of some
kind</a>.</li>
<li>UTF-8 validate the entire <code>&amp;[u8]</code> and convert it to a <code>&amp;str</code>.</li>
</ul>
<p>(<strong>Note</strong>: A similar problem exists with running regex or glob searches on
file paths. You can <a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes">get the underlying bytes of a file path to search on
Unix</a> without any additional cost, but on Windows, you‚Äôre
pretty much forced to pay some kind of cost because the internal WTF-8
representation used by <code>Path</code> is hidden.)</p>
<p>These are all pretty bad choices. The last one in particular will force you to
do two passes over the data, which is likely in turn to dramatically slow
things down for large files. And it also won‚Äôt let you deal with files that
have just a little invalid UTF-8 at all. <em>And</em> it won‚Äôt let you deal with
binary data at all either.</p>
<p>And that‚Äôs why these crates support byte strings. It is by far the easiest
alternative. More to the point, none of these crates really need or benefit
much from using <code>&amp;str</code> internally anyway. So the only cost of exposing a byte
string API is the API surface itself. A small price to pay when compared to the
alternatives.</p>
<h2 id="should-byte-strings-be-added-to-std">Should byte strings be added to std?</h2>
<p>Some folks have expressed a desire for <code>bstr</code> or something like it to be put
into the standard library. I‚Äôm not sure how I feel about wholesale adopting
<code>bstr</code> as it is. <code>bstr</code> is somewhat opinionated in that it provides several
Unicode operations (like grapheme, word and sentence segmentation), for
example, that std has deliberately chosen to leave to the crate ecosystem.</p>
<p>Moreover, adding the <code>BStr</code> and <code>BString</code> API is likely to confuse matters and
add to ‚Äústring fatigue‚Äù that Rust programmers sometimes experience. Adding new
byte string types is likely to cause at least some decision paralysis when it
comes to choosing between, say, <code>Vec&lt;u8&gt;</code> and <code>BString</code>. It‚Äôs worth pointing
out that the primary advantage of the <code>BStr</code> and <code>BString</code> types is to serve as
a target for trait impls like <code>std::fmt::Debug</code> and <code>serde::{Deserialize, Serialize}</code>. The standard library could help with the <code>Debug</code> impl by perhaps
providing a <code>debug()</code> method on <code>&amp;[u8]</code>, similar to the <code>display()</code> method on
<code>Path</code>.</p>
<p>Otherwise, I think the highest value addition that std could adopt is substring
search where the needle and haystack are permitted to be <code>&amp;[u8]</code>.</p>
<p>Other API additions are likely useful too (I‚Äôm a big fan of <code>bstr::decode_utf8</code>
for example), but I‚Äôm not sure whether they belong in std. It might be wise to
let <code>bstr 1.0</code> bake for a bit and see how it‚Äôs used in the ecosystem after a
few years.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Big thanks to <a href="https://github.com/thomcc">Thom Chiovoloni</a> and <a href="https://github.com/lopopolo">Ryan Lopopolo</a> for not
only their code contributions to <code>bstr</code>, but for also participating in API
design discussions. They were extremely helpful in fleshing out the current
API and catching mistakes.</p>
      </article>

      

    </div>
  </div>
</div></div>
  </body>
</html>
