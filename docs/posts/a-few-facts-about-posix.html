<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vorakl.com/articles/posix/">Original</a>
    <h1>A few facts about POSIX</h1>
    
    <div id="readability-page-1" class="page"><div>   <h3>A journey to portable software</h3> </div><div><p><a href="#summary">TLDR: quick summary of the article</a></p>  <div id="how-did-we-get-there"> <h2>How did we get there?</h2>  <p>In the early days of computing, programmers could only dream of portability. All programs were written directly in machine code for each computer architecture they were intended to run on. <a href="https://en.wikipedia.org/wiki/Assembly_language">Assembly languages</a> with mnemonic names for each CPU instruction and other goodies made programmers&#39; lives a little easier, but programs were still architecture-specific. Operating systems (OS) had not yet been invented, so a program not only controlled the entire computer system, it also had to initialize and manage the peripherals. In fact, such bare-metal programs implemented drivers for every device they used. And every time a program needed to run on hardware with a different architecture, it was literally rewritten to accommodate a difference in the <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">CPU instruction</a> set, memory layout, and so on.</p>  <p>This is exactly what happened with Unix, which was originally written in assembly language by Ken Thompson over 50 years ago. The first versions of Unix were written for the <a href="https://en.wikipedia.org/wiki/PDP-7">PDP-7</a> platform, and porting it to the <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11</a> meant rewriting the code. When Dennis Ritchie created the C programming language, and <a href="https://www.invent.org/sites/default/files/2019-02/Inductee-UNIX_Thompson_Ritchie.jpg">together they</a> rewrote most of the Unix code in it, software portability suddenly became possible. There are two main reasons for this. First, the code written in a high-level programming language is platform-agnostic, because compilers translate it into the assembly language for a target architecture. This is even more important for target systems based on <a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC CPUs</a>, as they require writing significantly more assembly instructions than <a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer">CISC CPU</a> architecture. Even porting Unix to another platform was mostly a matter of adapting the architecture-dependent parts of the code. On the other hand, the operating system itself abstracts away all hardware specifics from a user program. Programmers don&#39;t have to implement multitasking, memory management, or drivers for different devices as they used to, because it&#39;s all part of the OS kernel and runs in the kernel address space. In contrast, user programs run in the user address space and access all of the features provided by the OS through the the system call interface. In <a href="https://en.wikipedia.org/wiki/Real-time_operating_system">Real-time OSes</a>, such as <a href="https://www.zephyrproject.org/">Zephyr OS</a>, it&#39;s <a href="https://www.youtube.com/watch?v=4_uL43V79xw">slightly different</a>, but the idea of memory isolation and protection for user programs is preserved. This leads to two conclusions:</p> <ul> <li><em>User programs become portable when they are written in a high-level programming language for a particular OS</em>. Once both requirements are met, programs are compiled into instructions for a target CPU and linked with system functions provided by the <a href="https://en.wikipedia.org/wiki/C_standard_library">libc</a> and OS-specific libraries to access the underlying hardware.</li> <li>Portability is intended to be achieved <strong>at the source code level</strong>.</li> </ul>  </div> <div id="the-birth-of-posix"> <h2>The birth of POSIX</h2>  <p>This could have been the end of the story, but something fateful happened. Due to a legal restriction, AT&amp;T was not allowed to sell Unix, so there was no money to be made from the newly born OS, which became increasingly popular after it was introduced to the world. However, it turned out to be possible to distribute Unix to any interested organization for the cost of the media. That&#39;s how Unix got to Berkeley in 1974 and many other places, leading to the creation of a number of OS derivatives. Some of the best known and still popular today are OSes based on the software distributed by Berkley (BSD), e.g. FreeBSD and OpenBSD. Despite sharing the same ancestors and principles, each operating system followed its own unique path. Each of these operating systems had a unique interface (API) and implementation of kernel subsystems, syscalls, different system tools, etc. Even libc, which provides common functionality and wrappers on top of syscalls, used to be very OS-specific. All of these OSes were Unix-like, but at the same time, it wasn&#39;t possible to take the source code of a program written for one OS and recompile it on another.</p>  <p>Over 35 years ago, these problems with software portability led to the emergence of the first <a href="https://stackoverflow.com/a/31865755">POSIX standard</a> in 1988. The acronym <a href="https://opensource.com/article/19/7/what-posix-richard-stallman-explains">was coined by Richard Stallman</a>, who added &#34;X&#34; to the end of <em>Portable Operating System Interface</em>. It&#39;s meant to provide a <a href="https://www.techtarget.com/whatis/definition/POSIX-Portable-Operating-System-Interface">specification of the interface</a> that different Unix operating systems should have in common, including programming languages and tools. It&#39;s important to note that <strong>the interface is portable</strong>, and not the implementation.</p>  <p>This was the common ground that made it possible to compile the same source code of a user program on any OS without modification, if both sides strictly followed the same standard. And this is still true to some extent today, as most modern and widely used Unix-like systems, such as Linux, and <cite>*BSD</cite>, do not strictly and completely follow POSIX standard, but rather use it as a guide. However, there are <a href="https://en.wikipedia.org/wiki/POSIX#POSIX-oriented_operating_systems">a number of operating systems, such as MacOS</a>, that are fully compliant with the POSIX standard and can therefore be called <a href="https://www.opengroup.org/openbrand/register/">Unix operating systems</a>, not just Unix-like. Originally, POSIX was only created for Unix-like OSes, but over time it became so popular that its specification, in the form of the <a href="https://en.wikipedia.org/wiki/Operating_system_abstraction_layer">Operating System Abstraction Layer (OSAL)</a>, was partially implemented (some subset of the interface that applicable to the target system) in non-Unix OSes, such as <a href="https://en.wikipedia.org/wiki/Cygwin">Windows</a>, <a href="https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_POSIX/index.html">FreeRTOS</a>, <a href="https://docs.zephyrproject.org/latest/services/portability/posix/index.html">Zephyr</a>, etc.</p>  </div> <div id="the-posix-spec"> <h2>The POSIX spec</h2>  <p>The very first standard was ratified by the IEEE in 1988 as IEEE Std 1003.1-1988, so it&#39;s called <em>POSIX.1-1988</em>. Since then, the standard has gone through several revisions, with different subsets of the specification being ratified under different names. For example, <em>POSIX.1-1990</em> (IEEE 1003.1-1990) defined <em>the system interface and computing environment</em>, <em>POSIX.2</em> (IEEE Std 1003.2-1992) defined <em>command language (shell) and tools</em>, etc. A very good and brief overview of the standard&#39;s revisions can be found in the <a href="https://man7.org/linux/man-pages/man7/standards.7.html">standards(7)</a> Linux man page. You may even come across references to some old revisions, such as POSIX.2, for example, when reading the <a href="https://git.savannah.gnu.org/cgit/bash.git/tree/jobs.c#n4269">Bash source code</a>. In 2001, POSIX.1, POSIX.2, and the Single UNIX Specification (SUS) were merged into a single document called <em>POSIX.1-2001</em>. Despite the somewhat misleading name, it does include the shell and tools specifications from POSIX.2. <strong>The latest version of the standard is POSIX.1-2017</strong>, also known as <a href="https://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1-2017</a>, which is almost identical to POSIX.1-2008.</p>  <p>The document of the standard basically describes a specification that spans over two environments (a build-time and a run-time) and is represented by a few volumes:</p> <ul> <li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/toc.html">Base Definitions</a>: defines common to all volumes general terms and concepts, conformant requirements (symbolic constants, options, option groups), computing environment (locales, regexp, directory structure, tty, environment variables, etc), and C-language header files which need to be implemented by the compliant systems.</li> <li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/idx/xsh.html">System Interfaces</a>: defines the C language standard (<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">ISO C99, ISO/IEC 9899:1999</a>), system service functions, and the extension of the C standard library (libc) in terms of header files and functions.</li> <li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/idx/xcu.html">Shell &amp; Utilities</a>: defines a source code-level interface to the Shell Command Language (sh) and the system utilities (awk, sed, wc, cat, ...), including behavior, command line parameters, exit statuses, etc.</li> <li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/idx/xrat.html">Rationale</a>: includes considerations for portability, subprofiling, option groups, and additional rationale that didn&#39;t fit any other volumes.</li> </ul>  <p>The current POSIX standard defines source code-level compatibility for only two programming languages: <em>The C language (C99)</em> and <em>the command language (shell)</em>. Strictly speaking, the C standard library (libc) doesn&#39;t have to implement any additional functionality (functions and headers) that is not defined by the C standard (ISO C99 in this case), but most of them do. For example, the ISO C99 standard, defines 24 header files, including math functions (&lt;math.h&gt;), standard input/output (&lt;stdio.h&gt;), date and time (&lt;time.s&gt;), signal management (&lt;signal.h&gt;), string operations (&lt;string.h&gt;), and so on. However, the latest POSIX standard, defines 82 header files and, being fully compliant with ISO C99, extends it with with POSIX threads (&lt;pthreads.h&gt;), semaphores (&lt;semaphore.h&gt;), and many others. Modern libc implementations, e.g. <a href="https://musl.libc.org/about.html">musl libc</a>, are also very OS-specific, providing library functions to access operating system services (wrappers for system calls). Sometimes, the overlap with the POSIX specifications leads to difficulties in implementing the POSIX abstraction layer in the non-Unix operating systems, which also use some portable standalone libc implementations with their own POSIX support, e.g. using <a href="https://keithp.com/picolibc/">picolibc</a> together with <a href="https://docs.zephyrproject.org/latest/services/portability/posix/implementation/index.html">Zephyr&#39;s POSIX library</a>.</p>  </div> <div id="options-and-option-groups"> <h2>Options and Option Groups</h2>  <p>While POSIX standardizes the system interface (C language headers and functions), shell, and utilities, it is not necessary to follow the entire specification to be <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_03">POSIX conformant</a>. Some features in &#34;POSIX System Interfaces&#34;, &#34;POSIX Shell and Utilities&#34;, and &#34;XSI System Interfaces&#34; are optional. The <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html">&lt;unistd.h&gt; header file</a> contains definitions of the <em>standard symbolic constants</em> for <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_06">Options</a>, which reflect a particular feature, and <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap02.html#tag_02_01_05">Option Groups</a> which define a set of related functions or options. Names of option groups, unlike options, typically do not begin with the underscore symbol. POSIX Conformant systems are intended to implement and support a set of mandatory options with one or more additional options. The symbolic constants for mandatory options should have specific values, e.g. <em>200809L</em>, while other options may be</p> <ul> <li><em>undefined or contain -1</em>, which means that the option is not supported for compilation</li> <li><em>0</em>, which means the option might or might not be supported at runtime</li> <li><em>some other value</em>, which means the option is always supported</li> </ul>  <p>These symbolic constants are used by user applications to check the availability of a particular feature. At the C source code-level, constansts may be checked either at build time (in #if preprocessing directives) or at runtime, by calling one of the <em>sysconf()</em>, <em>pathconf()</em>, <em>fpathconf()</em>, or <em>confstr(3)</em> functions. In the shell source code, the <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html">getconf</a> utility should be used for runtime checks. A very good collection of the POSIX options, their corresponding names for use as the sysconf(3) parameters, and the list of header files and functions that these options represent can be found in the <a href="https://man7.org/linux/man-pages/man7/posixoptions.7.html">posixoptions(7)</a> Linux man page.</p>  <p><a href="https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html">Subprofiling Option Groups</a> are intended for use within the systems where implementing a full POSIX specification is not reasonable. For example, real-time embedded systems are typically resource-constrained, do not have shells, user interfaces, and OS kernels are often designed to run as a single process (with multiple threads). Such systems may only implement subsets of related functions defined by option groups.</p>  </div> <div id="summary"> <h2>Summary</h2> <ul> <li>The development of high-level programming languages like C, along with operating systems that abstract away hardware details, enabled software portability at the source code level.</li> <li>The POSIX standard emerged in the 1988 to provide a portable interface specification for Unix-like operating systems, allowing programs to be compiled across different platforms.</li> <li>The POSIX standard has evolved over time, with the latest version being POSIX.1-2017 (IEEE Std 1003.1-2017).</li> <li>Modern Unix-like systems like Linux and <cite>*BSD</cite> do not strictly follow the POSIX standard, but rather use it as a guide.</li> <li>POSIX standardizes a based on ISO C99 (ISO/IEC 9899:1999) standard the C language API (header files and functions), the shell (command language) and system utilities.</li> <li>POSIX-compliant systems are expected to implement mandatory options and may support additional optional features.</li> <li>Applications can check for POSIX feature availability at both compile-time and runtime using symbolic constants and system functions.</li> <li>For resource-constrained systems like real-time embedded platforms, POSIX allows for the implementation of subsets of the full specification through &#34;subprofile&#34; option groups.</li> </ul>  <!-- Links --> </div> </div></div>
  </body>
</html>
