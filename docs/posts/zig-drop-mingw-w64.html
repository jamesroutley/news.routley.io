<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ziglang/zig/issues/9998">Original</a>
    <h1>Zig: Drop MinGW-w64</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <p dir="auto">Lengthy write-up incoming, hoping this is useful to whoever else stumbles across this issue and attempts to solve it. After spending ~2 weeks on this, I don&#39;t feel I&#39;ve made much progress and feel a bit ill at how large of a problem I now realize this may be for Zig w.r.t. cross compiling for Windows.</p>
<p dir="auto">Hopefully some of this information is useful for us finding a long-term solution to this. It feels a bit like I&#39;ve traveled inside a broken Fukushima reactor and back again, I&#39;m planning to find some band-aids for myself and I probably won&#39;t dive back in again for now.</p>
<p dir="auto">Here goes..</p>

<h2 dir="auto">Authoritative sources for Windows API headers</h2>
<p dir="auto">We can find these in two places:</p>
<ol dir="auto">
<li>The IDL files that Microsoft releases as part of the Windows SDK, which are redistributed under an MIT license here: <a href="https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders">https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders</a>
<ul dir="auto">
<li>But note the authoritative source is actually the Windows source code inside of Microsoft, the win32metadata repository merely has a script which copies them from the Windows SDK into the repo.</li>
<li><a href="https://github.com/microsoft/DirectX-Headers">https://github.com/microsoft/DirectX-Headers</a> similarly is a redistributed copy, Microsoft allows constributions to this repository to <code>.h</code> and <code>.idl</code> files, but ultimately they periodically synchronize the changes in this repository with the IDL files in the Windows internal repository and regenerate the <code>.h</code> files from the <code>.idl</code> sources found in the Windows SDK.</li>
</ul>
</li>
<li>Wine, they have a hand crafted (emphasis on that) recreation of Microsoft&#39;s IDL files. They&#39;re not the same at all as the IDL sources Microsoft distributes due to licensing concerns in the past.</li>
</ol>
<p dir="auto">MinGW-w64 may have some other headers (sal.h?) which it does not acquire from Wine, I didn&#39;t investigate this, but I strongly suspect almost all headers mingw-w64 distributes are generated from Wine&#39;s IDL files. Could be wrong though.</p>
<h2 dir="auto">Non-authoritative sources for Windows API headers</h2>
<ul dir="auto">
<li>Any <code>.h</code> file you find is actually generated from the IDL file from either Windows SDK or Wine. <code>.h</code> files are never the authoritative source.</li>
<li><a href="https://github.com/microsoft/DirectX-Headers">https://github.com/microsoft/DirectX-Headers</a> for example redistributes the IDL files and Microsoft employees periodically push commits to this repository which synchronize the IDL files from the Windows SDK with the IDL files distributed in this repository. The header files are generated using the MIDL compiler distributed with Visual Studio.</li>
<li>mingw-w64 pulls various headers from Wine&#39;s implementation, which generates them from their own hand-crafted IDL files.</li>
</ul>

<h2 dir="auto">How IDL -&gt; .h happens</h2>
<p dir="auto">There exist two IDL compilers which parse <code>.idl</code> files and generate <code>.h</code> files from them:</p>
<ol dir="auto">
<li>MIDL, Microsoft IDL compiler, distributed with Visual Studio. Closed source.</li>
<li>WIDL, Wine IDL compiler, found in <code>tools/widl</code> of the Wine source code.</li>
</ol>
<p dir="auto">IDL files are actually incredibly similar to the C header files themselves, what the generator does is quite minimal translation of syntax (but more on this below.)</p>
<h2 dir="auto">Incompatibilities</h2>
<p dir="auto">Any header compiled with Microsoft&#39;s MIDL compiler, i.e. the <code>.h</code> files in:</p>
<ul dir="auto">
<li>The Windows SDK</li>
<li><a href="https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders">https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders</a></li>
<li><a href="https://github.com/microsoft/DirectX-Headers">https://github.com/microsoft/DirectX-Headers</a></li>
</ul>
<p dir="auto">Are <em>fundamentally incompatible</em> with mingw-w64 and gcc outright, and fundamentally incompatible with clang/zig when targeting a GNU ABI.</p>
<p dir="auto">Header files generated using the Wine WIDL compiler (those distributed by Zig, those distributed by mingw-w64, and those in the Wine repository) are compatible with with all compilers (more on this below.)</p>
<h2 dir="auto">Atrocities of COM / win32 headers</h2>
<p dir="auto">The COM calling convention differs from the C calling convention, in specific msvc has undocumented behavior in which aggregates are returned by pointer using a hidden 2nd parameter in COM C/C++ functions and methods. Clang and Zig emulate this undocumented msvc behavior when targetting msvc ABI, but not gnu ABI.</p>
<p dir="auto">the IDL files distributed by Microsoft <a href="https://stackoverflow.com/a/22361485" rel="nofollow">have attributes</a> which denote which COM methods require a hidden parameter in order to store the return value.</p>
<p dir="auto">How this is handled is where Wine and Microsoft headers differ greatly. When it comes to the C definitions, they are identical. For example Wine and Microsoft headers both define:</p>
<div data-snippet-clipboard-copy-content="      D3D12_CPU_DESCRIPTOR_HANDLE *( STDMETHODCALLTYPE *GetCPUDescriptorHandleForHeapStart )( 
          ID3D12DescriptorHeap * This,
          D3D12_CPU_DESCRIPTOR_HANDLE * RetVal);"><pre>      D3D12_CPU_DESCRIPTOR_HANDLE *( STDMETHODCALLTYPE *GetCPUDescriptorHandleForHeapStart )( 
          ID3D12DescriptorHeap * This,
          D3D12_CPU_DESCRIPTOR_HANDLE * RetVal);</pre></div>
<p dir="auto">However, when it comes to C++ definitions Microsoft defines just:</p>
<div data-snippet-clipboard-copy-content="virtual D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE GetCPUDescriptorHandleForHeapStart( void) = 0;"><pre><span>virtual</span> D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE <span>GetCPUDescriptorHandleForHeapStart</span>( <span>void</span>) = 0;</pre></div>
<p dir="auto">Despite what is written above, msvc and msvc-emulating compilers detect that the return value of this function is an aggregate and inject a second parameter (the return pointer.)</p>
<p dir="auto">Wine on the other hand defines this same C++ virtual method as:</p>
<div data-snippet-clipboard-copy-content="#ifdef WIDL_EXPLICIT_AGGREGATE_RETURNS
    virtual D3D12_CPU_DESCRIPTOR_HANDLE* STDMETHODCALLTYPE GetCPUDescriptorHandleForHeapStart(D3D12_CPU_DESCRIPTOR_HANDLE *__ret) = 0;
    D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE GetCPUDescriptorHandleForHeapStart()
    {
        D3D12_CPU_DESCRIPTOR_HANDLE __ret;
        return *GetCPUDescriptorHandleForHeapStart(&amp;__ret);
    }
#else
    // We crash here!
    virtual D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE GetCPUDescriptorHandleForHeapStart() = 0;
#endif"><pre>#<span>ifdef</span> WIDL_EXPLICIT_AGGREGATE_RETURNS
    <span>virtual</span> D3D12_CPU_DESCRIPTOR_HANDLE* STDMETHODCALLTYPE <span>GetCPUDescriptorHandleForHeapStart</span>(D3D12_CPU_DESCRIPTOR_HANDLE *__ret) = 0;
    D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE <span>GetCPUDescriptorHandleForHeapStart</span>()
    {
        D3D12_CPU_DESCRIPTOR_HANDLE __ret;
        <span>return</span> *<span>GetCPUDescriptorHandleForHeapStart</span>(&amp;__ret);
    }
#<span>else</span>
    <span><span>//</span> We crash here!</span>
    <span>virtual</span> D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE <span>GetCPUDescriptorHandleForHeapStart</span>() = 0;
#<span>endif</span></pre></div>
<p dir="auto">When <code>WIDL_EXPLICIT_AGGREGATE_RETURNS</code> is defined, the headers are compatible with gcc, mingw-w64, and clang (when targetting gnu ABI.) Otherwise, the definition matches that found in the Microsoft headers and the headers become fundamentally broken for non-msvc-emulating compilers.</p>
<p dir="auto">Relevant links:</p>
<ul dir="auto">
<li>Change where Wine added the hack <code>WIDL_EXPLICIT_AGGREGATE_RETURNS</code>: <a href="https://source.winehq.org/git/wine.git/commitdiff/b42a15513eaa973b40ab967014b311af64acbb98" rel="nofollow">https://source.winehq.org/git/wine.git/commitdiff/b42a15513eaa973b40ab967014b311af64acbb98</a></li>
<li>Open bug report on GCC issue tracker: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52792" rel="nofollow">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52792</a></li>
<li>Much earlier bug report from 2014 on GCC issue tracker: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64384" rel="nofollow">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64384</a></li>
</ul>
<p dir="auto">Today, GCC/MinGW-w64 still cannot emulate msvc&#39;s COM calling convention behavior. Only clang can: <a href="https://github.com/llvm/llvm-project/commit/85a0f8fe6c5c8ab35790c40d078d4fa103a5a54a#diff-48f9c7403ada1feaf517d77cd12f97c5bd239d6247190543d74b463c7da242ccR1058">llvm/llvm-project@<tt>85a0f8f</tt>#diff-48f9c7403ada1feaf517d77cd12f97c5bd239d6247190543d74b463c7da242ccR1058</a> (here you can see the ARM logic they use to detect an aggregate requiring a hidden return-by-paramete, which is much more complex than just &#34;uses the COM calling convention&#34;.)</p>
<p dir="auto">@marler32 and <a data-hovercard-type="user" data-hovercard-url="/users/michal-z/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/michal-z">@michal-z</a> ran into this for example in <a data-error-text="Failed to load title" data-id="988314343" data-permission-text="Title is private" data-url="https://github.com/microsoft/win32metadata/issues/636" data-hovercard-type="issue" data-hovercard-url="/microsoft/win32metadata/issues/636/hovercard" href="https://github.com/microsoft/win32metadata/issues/636">microsoft/win32metadata#636</a> and thought the Microsoft header definitions may be wrong, unfortunately not - msvc just has undocumented behavior of injecting a hidden parameter. Microsoft actually cannot alter the header definitions to match C calling convention, as msvc would still inject the secret parameter.</p>
<p dir="auto">Me and <a data-hovercard-type="user" data-hovercard-url="/users/Andoryuuta/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Andoryuuta">@Andoryuuta</a> found only one single semi-official reference to this undocumented behavior in msvc, as almost a footnote of this Raymond Chen article in 2014: <a href="https://devblogs.microsoft.com/oldnewthing/20040114-00/?p=41053" rel="nofollow">https://devblogs.microsoft.com/oldnewthing/20040114-00/?p=41053</a></p>
<blockquote>
<p dir="auto">&#34;The return value is placed in rax. If the return value is larger than 64 bits, then a secret first parameter is passed which contains the address where the return value should be stored. &#34;</p>
</blockquote>
<p dir="auto">The harsh reality of all of this is that any Zig project which includes Microsoft headers and uses the default GNU ABI will compile just fine, but get a segfault when they invoke a COM method returning an aggregate as the hidden return parameter will be null.</p>
<p dir="auto">Additionally, it means any C++ project compiled with Zig or MinGW that does not explicitly define <code>WIDL_EXPLICIT_AGGREGATE_RETURNS</code> themselves will find the same segfault. Truly horrific.</p>

<h2 dir="auto">The headers distributed in win32metadata are not sufficient</h2>
<p dir="auto"><a data-hovercard-type="user" data-hovercard-url="/users/andrewrk/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/andrewrk">@andrewrk</a> suggested we might be able to drop the GNU ABI support and only support msvc ABI. On that note, I checked to see if we can just use the <code>.h</code> headers distributed in <a href="https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders">https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders</a> (which are MSVC compatible) and only use clang&#39;s msvc-emulating ABI target</p>
<p dir="auto">The problem with this approach is that win32metadata is not complete: the headers included in this repository are generated by the Microsoft MIDL compiler distributed with Visual Studio and because of this they have a dependency on <code>vcruntime.h</code> and all the other headers distributed as part of Visual Studio, which are not open source.</p>
<ol dir="auto">
<li>Even if we had a way to include those headers legally, it seems our libcxx is incompatible with those headers (at least when I tried swapping our any-windows-any headers dir for all of those): <a href="https://gist.github.com/slimsag/da3a5ffbba121289917eae5c49c5365a">https://gist.github.com/slimsag/da3a5ffbba121289917eae5c49c5365a</a> - I am not smart enough to resolve this.</li>
<li>For cross-compilation, we still have no msvc runtime libraries we can redistribute. We need to depend on mingw/wine for libraries still, I&#39;m unsure if we will run into more incompatibilities here. For example, I have seen indications MinGW-w64 and clang both may emit __mingw prefix&#39;d references when invoking COM methods in gnu ABI targets.</li>
</ol>
<h2 dir="auto">Could we run the Wine WIDL compiler on Microsoft&#39;s IDL files?</h2>
<p dir="auto">Another thought I had was: what if we could merely run Wine&#39;s WIDL compiler on Microsoft&#39;s IDL files? Effectively giving us super-up-to-date headers for MinGW-w64 that could theoretically even be used by MinGW and Wine themselves.</p>
<p dir="auto">I ran quite far with this experiment, and I believe it may be possible however I ran into two hurdles:</p>
<ol dir="auto">
<li>The IDL files in <a href="https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders">https://github.com/microsoft/win32metadata/tree/master/generation/WinSDK/RecompiledIdlHeaders</a> depend on what seems to be just two files not distributed as OSS: <code>stdole32.tlb</code> and <code>stdole2.tlb</code> which you can see are used <a href="https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/microsoft/win32metadata%24+importlib%28%22&amp;patternType=literal" rel="nofollow">via <code>importlib</code> here</a>. Maybe we could get Microsoft to distribute these under a permissive license? Unsure.</li>
<li>The Wine WIDL compiler does not support a whole litany of more modern syntax features that the Microsoft IDL files use. I have <a href="https://gist.github.com/slimsag/33a0aba712d0ce9439aa92b0e12c2320">categorized these here</a> but basically I think we&#39;d either be looking at writing our own IDL compiler (which I think would not be too hard) or contributing some major changes to Wine&#39;s.</li>
</ol>
<p dir="auto">This was the approach I got furthest with. In fact, with relatively few patches I was able to use the WIDL compiler to compile most of the DirectX headers from Microsoft. I have not tested these yet, but I suspect they&#39;ll work and be compatible with MinGW/clang/zig with GNU ABIs using the <code>WIDL_EXPLICIT_AGGREGATE_RETURNS</code> definition hack. See recent commits in <a href="https://github.com/slimsag/win32metadata">https://github.com/slimsag/win32metadata</a> (21277d9f9c8860c75c9aee7319fe51d67a1301b7 and before)</p>
<h2 dir="auto">Can we stick with wine/mingw-w64 headers and contribute to them?</h2>
<p dir="auto">This is the path of least effort, and what we&#39;re currently doing. I will say however that after what I have found here.. I feel quite confident the Wine headers are currently, and I suspect will remain for quite some time, very outdated.</p>
<p dir="auto">Unfortunately, merging win32metadata IDL file changes into Wine&#39;s IDL files would be extremely non-trivial, too, because Wine&#39;s are hand-crafted much in the same way Microsoft&#39;s are - they differ quite a lot in syntax, ordering of definitions, and even which files symbols are defined in sometimes. Attempting to merge the two would be a seriously tedious undertaking.</p>
      </div>
</div></div>
  </body>
</html>
