<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.learncsdesign.com/an-overview-of-distributed-caching/">Original</a>
    <h1>An Overview of Distributed Caching</h1>
    
    <div id="readability-page-1" class="page"><div>
			
<blockquote><p>This is the 4th post in a series on System Design.</p></blockquote>



<blockquote><p>Nearly 3% of infrastructure at Twitter is dedicated to application-level caching <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale" rel="noreferrer noopener" target="_blank">Link</a></p></blockquote>



<p id="4325">In an application, caches can be found in many places. CPUs that run your applications have fast, multilevel hardware caches to reduce main memory access times.</p>



<p id="c610">Scalable systems require distributed caching. By caching the results of expensive queries and computations, subsequent requests can reuse them at a low cost. The system can scale to handle more workloads because it does not have to reconstruct the cached results for every request.</p>







<p id="df99">By caching the results of queries and computations in memory, application caching improves request responsiveness. As many queries can be served directly from the cache, caching relieves databases of heavy read traffic. Additionally, it reduces the computation costs of expensive objects.</p>



<p id="5660">Storage of cached results requires additional resources and therefore costs. When compared to upgrading database and service nodes, well-designed caching schemes are low cost.</p>



<p id="ba67">Dedicated distributed cache engines are used for application-level caching. <a href="https://memcached.org/" rel="noreferrer noopener" target="_blank">Memcached</a> and <a href="https://redis.io/" rel="noreferrer noopener" target="_blank">Redis</a> are the two most prevalent technologies in this area. Essentially, both are distributed in-memory hash tables for arbitrary data, such as results of database queries or API calls to downstream services</p>



<p id="49a1">Data from user sessions and the results of database queries are commonly stored in caches. Application services see the cache as a single store, and objects are assigned to individual cache servers based on their key.</p>



<p id="c1d6">First, the service checks the cache to see if the data it needs is there. A cache hit occurs when the cached contents are returned as the results. Cache misses occur when the data is not in the cache, so the service retrieves the requested data from the database and writes the query results to the cache for future client requests.</p>



<figure><img src="https://i0.wp.com/miro.medium.com/max/862/1*mn5azEDBH5xWzaC6H11Cgw.png?w=800&amp;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p id="e5d6">The results of cache access must be associated with a key. Cache contents can be invalidated by using an expiry time, such as the TTL. This prevents clients from receiving stale, out-of-date results from a service. Additionally, it allows the system to control cache contents, which are typically limited. The cache will fill up if cached items are not flushed periodically. To free up space for more current, timely results, a cache will adopt a policy such as least recently used or least accessed.</p>



<p id="391f">Application caching can boost throughput, reduce latencies, and improve client application responsiveness. In order to achieve these desirable qualities, the cache must satisfy as many requests as possible. As a general principle, the cache hit rate should be maximized and the cache miss rate minimized. In the event of a cache miss, the request must be fulfilled by querying databases or downstream services. The results of the request can then be written to the cache and hence be available for further access.</p>



<p id="c86f">The cost of cache misses can negate the cache’s benefits when items are updated regularly. In order to construct caching mechanisms that yield the most benefit, service designers must carefully examine the query and update patterns an application experiences. Once a service is in production, it is crucial to monitor cache usage to ensure the hit and miss rates are within design expectations. To monitor cache usage characteristics, caches will provide both management utilities and APIs.</p>



<p id="2ad4">Application-level caching is also known as cache-aside caching. When the required results are available in the cache, the application code effectively bypasses the data storage systems.</p>



<p id="b050">In contrast, other caching patterns require the application to read from and write to the cache continuously. The following are defined as follows:</p>



<ul><li><strong>Read-through Cache</strong>—By accessing the cache, the application fulfills all requests. If the data required is not in the cache, a loader is invoked to access the data systems and load the results into the cache.</li></ul>



<figure><img src="https://i0.wp.com/miro.medium.com/max/1400/1*Gx6evntFB9GkNGd2tFXN8g.png?w=800&amp;ssl=1" alt="" data-recalc-dims="1"/></figure>



<ul><li><strong>Write-through Cache</strong>— Updates are always written to the cache by the application. As soon as the cache is updated, a writer is invoked to write the new cache values to the database. The application can complete the request once the database has been updated.</li></ul>



<figure><img src="https://i0.wp.com/miro.medium.com/max/1400/1*m-otNnVmp2zTkmW8BMDA4A.png?w=800&amp;ssl=1" alt="" data-recalc-dims="1"/></figure>



<ul><li><strong>Write-behind Cache</strong> — The application does not wait for the cached value to be written to the database like a write-through. Caching increases request responsiveness at the expense of possible lost updates if the cache server crashes before a database update is completed. It is also called a write-back cache and is the strategy most database engines use internally.</li></ul>



<figure><img src="https://i0.wp.com/miro.medium.com/max/1400/1*emz6TR7ziwU6JbaqDVIR1Q.png?w=800&amp;ssl=1" alt="" data-recalc-dims="1"/></figure>



<p id="96f3">The read-through, write-through, and write-behind strategies require caching technology augmented with an application-specific handler to perform database reads and write when the application accesses the cache.</p>



<p id="adc8">The cache-aside strategy has the advantage of being resilient to cache failure. When the cache is unavailable, all requests are treated as cache misses. The performance will suffer, but services will still be able to satisfy requests. As a result of their simple, distributed hash table model, cache-aside platforms like Redis and Memcached are easy to scale. Massively scalable systems primarily use the cache-aside pattern because of these reasons.</p>







<p id="45de">Due to the abundance of web caches on the internet, websites are incredibly responsive. A copy of a given resource is stored in a web cache.</p>



<p id="c746">Typically, caches store only the results of GET requests, and the cache key is the associated URI. A client’s GET request may be intercepted by one or more caches along the request path. Any cache that has a fresh copy of the requested resource can respond to the request. The origin server serves the request if no cached content is found.</p>



<p id="de15">HTTP caching directives allow services to control what results are cached and for how long. These directives are set in various HTTP response headers.</p>



<h2 id="0320">Cache-Control</h2>



<p id="e3d9">Client requests and service responses can use the Cache-Control HTTP header to specify how caching should be used for the resources in question. The following values are possible:</p>



<p id="6525"><strong>no-store </strong>— Request-response resources should not be cached. Typically, this is used for sensitive data that needs to be retrieved from the origin servers.</p>



<p id="e8a0"><strong>no-cache</strong> — Before using a cached resource, it must be revalidated with an origin server</p>



<p id="0935"><strong>private </strong>— Specifies that a resource can only be cached by a user-specific device, such as a web browser.</p>



<p id="3c0d"><strong>public </strong>— Provides a resource that can be cached by any proxy server.</p>



<p id="66eb"><strong>max-age</strong> — Sets the amount of time in seconds that a cached copy of a resource should be retained. After expiration, a cache must refresh the resource by sending a request to the origin server.</p>



<h2 id="2b57">Expires and Last-Modified</h2>



<p id="2966">To control how long cached data is retained, the Expires and Last-Modified HTTP headers interact with the max-age directive.</p>



<p id="f79e">Since caches have limited storage resources, they must periodically evict items from memory to free up space. Services can specify how long cached resources should remain valid or fresh in order to influence cache eviction. In response to a fresh resource request, the cache serves the locally stored results without contacting the origin server. When a cached resource’s retention period expires, it becomes stale and is eligible for eviction.</p>



<p id="2b6e">A combination of header values is used to calculate freshness. As the primary directive, the “Cache-Control: max-age=Value” header specifies the freshness period in seconds. The Expires header is checked next if max-age is not specified. This header is used to calculate the freshness period if it exists. The Expires header specifies a date and time after which the resource should be considered stale. Resource retention periods can be calculated using the Last-Modified header as the last resort.</p>



<h2 id="37bb">Etag</h2>



<p id="7daf">Another HTTP directive can be used to control cache item freshness. An Etag is what we call it. Using Etag values, web caches can determine if cached resources are still valid.</p>



<p id="68ab">The origin server responds with a maximum age that defines the cache freshness, as well as an Etag that represents the last version of the response.</p>



<p id="d3a5">When a cache expires, the resource becomes stale. In response to a request for a stale resource, the cache forwards the request to the origin server with an If-None-Match directive and the Etag to determine if it is still valid. It is called revalidation.</p>



<p><strong>There are two possible responses to this request:</strong></p>



<ul><li>When the Etag in the request matches the value associated with the resource in the service, the cached value remains valid. It is therefore possible for the origin server to return a 304 (Not Modified) response. Since the cached value is still current, no response body is required, saving bandwidth, especially for large resources. Additionally, the response may include new cache directives to update the freshness of the cached resource.</li><li>An origin server may ignore the revalidation request and respond with a 200 OK response code, a response body, and an Etag representing the latest version of the resource.</li></ul>



<p id="4c87">The use of web caching can significantly reduce latencies and save network bandwidth when used effectively. Especially for large items like images and documents, this is true. Additionally, web caches handle requests rather than application services, reducing the load on origin servers.</p>



<p id="1b9f">Proxy caches such as <a href="http://www.squid-cache.org/" rel="noreferrer noopener" target="_blank">Squid</a> and <a href="https://varnish-cache.org/" rel="noreferrer noopener" target="_blank">Varnish</a> are extensively deployed on the internet.</p>







<p id="e6d2">Scalable distributions require caching. Caching stores information that is requested by many clients in memory and serves it as requested by clients. The information can be served potentially millions of times without having to recreate it.</p>



<p id="2596">The most common method of caching in scalable systems is through the use of a distributed cache. When a client request arrives, the application logic checks for cached values and returns them if they exist. It is possible to significantly reduce the load on backend services and databases if the cache hit rate is high.</p>



<p id="0881">A multilevel caching infrastructure is also built into the internet. HTTP headers contain cache directives that can be exploited by applications. Caching directives allow services to specify what information can be cached and for how long, and to check if stale cache entries are still valid using a protocol. When used wisely, HTTP caching can significantly reduce the load on downstream services and databases.</p>







<p id="2420">Book: Memcached A Complete Guide</p>

		</div></div>
  </body>
</html>
