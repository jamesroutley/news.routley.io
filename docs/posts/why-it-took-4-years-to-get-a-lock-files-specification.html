<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://snarky.ca/why-it-took-4-years-to-get-a-lock-files-specification/">Original</a>
    <h1>Why it took 4 years to get a lock files specification</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>(This is the blog post version of <a href="https://youtu.be/MMVVboVL5eU?si=_aoKRKmK59HaZTpy">my keynote from EuroPython 2025</a> in Prague, Czechia.)</p><p>We now have a <a href="https://packaging.python.org/en/latest/specifications/pylock-toml/">lock file format specification</a>. That might not sound like a big deal, but for me it took 4 years of active work to get us that specification. Part education, part therapy, this post is meant to help explain what make creating a lock file difficult and why it took so long to reach this point.</p><p>A lock file is meant to record <strong>all</strong> the dependencies your code needs to work along with how to install those dependencies.</p><p>That involves The &#34;how&#34; is <a href="https://packaging.python.org/en/latest/specifications/source-distribution-format/#source-trees">source trees</a>, <a href="https://packaging.python.org/en/latest/specifications/source-distribution-format/">source distributions</a> (aka sdists), and <a href="https://packaging.python.org/en/latest/specifications/binary-distribution-format/">wheels</a>. With all of these forms, the trick is recording the right details in order to know how to install code in any of those three forms. Luckily we already had the <a href="https://packaging.python.org/en/latest/specifications/direct-url/"><code>direct_url.json</code> specification</a> that just needed translation into <a href="https://toml.io/">TOML</a> for source trees. As for sdists and wheels, it&#39;s effectively recording what an index server provides you when you look at a project&#39;s release.</p><p>The much trickier part is figuring what to install when. For instance, let&#39;s consider where your top-level, direct dependencies come from. In <a href="https://packaging.python.org/en/latest/specifications/pyproject-toml/"><code>pyproject.toml</code></a> there&#39;s <a href="https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies"><code>project.dependencies</code></a> for dependencies you always need for your code to run, <a href="https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies"><code>project.optional-dependencies</code></a> (aka extras), for when you want to offer your users the option to install additional dependencies, and then there&#39;s <a href="https://packaging.python.org/en/latest/specifications/dependency-groups/"><code>dependency-groups</code></a> for dependencies that are not meant for end-users (e.g. listing your test dependencies).</p><p>But letting users control what is (not) installed isn&#39;t the end of things. There&#39;s also the <a href="https://packaging.python.org/en/latest/specifications/dependency-specifiers/"><em>specifiers</em></a> you can add to any of your listed dependencies. They allow you to not only restrict what versions of things you want (i.e. setting a lower-bound and <strong>not</strong> setting an upper-bound if you can help it), but also when the dependency actually applies (e.g. is it specific to Windows?).</p><p>Put that all together and you end up with a graph of dependencies who edges dictate whether a dependency applies on some platform. If you manage to write it all out then you have <em>multi-use</em> lock files which are portable across platforms and whatever options the installing users selects, compared to <em>single-use</em> lock files that have a specific applicability due to only supporting a single platform and set of input dependencies.</p><p>Oh, and even getting the complete list of dependencies in either case is an NP-complete problem.</p><p>And it make makes things &#34;interesting&#34;, I also wanted the file format to be written by software but readable by people, secure by default, fast to install, and allow the <em>locker</em> which write the lock file to be different from the <em>installer</em> that performs the install (and either be written in a language other than Python).</p><p>In the end, it all worked out (luckily); you can read the spec for all the nitty-gritty details about <code>pylock.toml</code> or <a href="https://youtu.be/MMVVboVL5eU?si=_aoKRKmK59HaZTpy">watch the keynote</a> where I go through the spec. But it sure did take a while to get to this point.</p><p>I&#39;m not sure if this qualifies as the longest single project I have ever taken on for Python (rewriting the import system might still hold that record for me), but it definitely felt the most intense over a prolonged period of time.</p><p>The oldest record I have that I was thinking about this problem is a tweet from Feb 2019:</p><figure><img src="https://snarky.ca/content/images/2025/10/lock-file-format-idea-on-Twitter.png" alt="" loading="lazy" width="912" height="771" srcset="https://snarky.ca/content/images/size/w600/2025/10/lock-file-format-idea-on-Twitter.png 600w, https://snarky.ca/content/images/2025/10/lock-file-format-idea-on-Twitter.png 912w" sizes="(min-width: 720px) 720px"/></figure><h2 id="2019">2019</h2><p>That year there were 106 posts on discuss.python.org about a <code>requirements.txt</code> v2 proposal. It didn&#39;t come to any specific conclusion that I can recall, but it at least got the conversation started.</p><h2 id="2020">2020</h2><p>The next year, the conversation continued and generated 43 posts. I was personally busy with <a href="https://peps.python.org/pep-0621/">PEP 621</a> and the <code>[project]</code> table in <code>pyproject.toml</code>.</p><h2 id="2021">2021</h2><p>In January of 2021 Tzu-Ping Chung, Pradyun Gedam, and myself began researching how other language ecosystems did lock files. It culminated in us writing <a href="https://peps.python.org/pep-0665/">PEP 665</a> and posting it in July. That led to 359 posts that year.</p><p>The goal of PEP 665 was a very secure lock file which partially achieved that goal by only supporting wheels. With no source trees or sdists to contend with, it meant installation didn&#39;t involve executing a build back-end which can be slow, be indeterminate, and a security risk simply due to running more code. We wrote the PEP with the idea that any source trees or sdists would be built into wheels out-of-band so you could then lock against those wheels.</p><h2 id="2022">2022</h2><p>In the end, <a href="https://discuss.python.org/t/pep-665-take-2-a-file-format-to-list-python-dependencies-for-reproducibility-of-an-application/11736/141">PEP 665 was rejected</a> in January of 2022, generating 106 posts on the subject both before and after the rejection. It turns out enough people had workflows dependent on sdists that they balked at having the added step of building wheels out-of-band. There was also some desire to also lock the build back-end dependencies.</p><h2 id="2023">2023</h2><p>After the failure of PEP 665, I decided to try to tackle the problem again entirely on my own. I didn&#39;t want to drag other poor souls into this again and I thought that being opinionated might make things a bit easier (compromising to please everyone can lead to bad outcomes when a spec if large and complicated like I knew this would be).</p><p>I also knew I was going to need a proof-of-concept. That meant I needed code that could get metadata from an index server, resolve all the dependencies some set of projects needed (at least from a wheel), and at least know what I would install on any given platform. Unfortunately a lot of that didn&#39;t exist as some library on PyPI, so I had to write a bunch of it myself. Luckily I had already started the journey before with my <a href="https://github.com/brettcannon/mousebender">mousebender</a> project, but that only covered the metadata from an index server. I still needed to be able to read <code>MEtADATA</code> files from a wheel and do the resolution. The former Donald Stufft had taken a stab at and which I picked up and completed, leading to <a href="https://packaging.pypa.io/en/stable/metadata.html"><code>packaging.metadata</code></a>. I then used <a href="https://pypi.org/project/resolvelib/">resolvelib</a> to create a resolver.</p><p>As such there were only 54 posts about lock files that were general discussion. The key outcome there was trying to lock for build back-ends confused people too much, and so I dropped that feature request from my thinking.</p><h2 id="2024">2024</h2><p>Come 2024, I was getting enough pieces together to actually have a proof-of-concept. And then <a href="https://docs.astral.sh/uv/">uv</a> came out in February. That complicated things a bit as it did/planned to do things I had planned to help entice people to care about lock files. I also knew I couldn&#39;t keep up with the folks at <a href="https://astral.sh">Astral</a> as I didn&#39;t get to work on this full-time as a job (although I did get a lot more time starting in September of 2024).</p><p>I also became a parent in April which initially gave me a chunk of time (babies for the first couple of months sleep a lot, so if gives you a bit of time). And so in July I posted the first draft of <a href="https://peps.python.org/pep-0751/">PEP 751</a>. It was based on <code>pdm.lock</code> (which itself is based on <code>poetry.lock</code>). It covered sdists and wheels and was multi-use, all by recording the projects to install as a set which made installation fast.</p><p>But uv&#39;s popularity was growing and they had extra needs that <a href="https://pdm-project.org/">PDM</a> and <a href="https://python-poetry.org">Poetry</a>â€“ the other major participants in the PEP discussions --didn&#39;t. And do I wrote another draft where I pivoted from a set of projects to a graph of projects. But otherwise the original feature set was all there.</p><p>And then <a href="https://hynek.me">Hynek</a> came by with what seemed like an innocuous request about making the version of a listed project optional instead of required (which was done because the <a href="https://packaging.python.org/en/latest/specifications/core-metadata/#version">version</a> is required in <code>PKG-INFO</code> in sdists and <code>METADATA</code> in wheels).</p><figure><img src="https://snarky.ca/content/images/2025/10/hynek-post.png" alt="" loading="lazy" width="763" height="164" srcset="https://snarky.ca/content/images/size/w600/2025/10/hynek-post.png 600w, https://snarky.ca/content/images/2025/10/hynek-post.png 763w" sizes="(min-width: 720px) 720px"/></figure><p>Unfortunately the back-and-forth on that was enough to cause the Astral folks to want to scale the whole project back all the way to the <code>requirements.txt</code> v2 solution.</p><figure><img src="https://snarky.ca/content/images/2025/10/charlie-backtracks.png" alt="" loading="lazy" width="709" height="113" srcset="https://snarky.ca/content/images/size/w600/2025/10/charlie-backtracks.png 600w, https://snarky.ca/content/images/2025/10/charlie-backtracks.png 709w"/></figure><p>While I understood their reasoning and motivation, I would be lying if I said it wasn&#39;t disappointing. I felt we were extremely close up to that point in reaching an agreement on the PEP, and then having to walk back so much work and features did not exactly make me happy.</p><p>This was covered by 974 posts on discuss.python.org.</p><h2 id="2025">2025</h2><p>But to get consensus among uv, Poetry, and PDM, I did a third draft of PEP 751. This went back to the set of projects to install, but was single-use only. I also became extremely stringent with timelines on when people could provide feedback as well as what would be required to add/remove anything. At this point I was fighting burn-out on this subject and my own wife had grown tired of the subject and seeing me feel dejected every time there was a setback. And so I set a deadline of the end of March to get things done, even if I had to drop features to make it happen.</p><p>And in February I thought we had reached and agreement on this third draft. But then Frost Ming, the maintainer of PDM, asked why did we drop multi-use lock files when they thought the opposition wasn&#39;t that strong?</p><figure><img src="https://snarky.ca/content/images/2025/10/frost-disappointed.png" alt="" loading="lazy" width="770" height="161" srcset="https://snarky.ca/content/images/size/w600/2025/10/frost-disappointed.png 600w, https://snarky.ca/content/images/2025/10/frost-disappointed.png 770w" sizes="(min-width: 720px) 720px"/></figure><p>And so, with another 150 posts and some very strict deadlines for feedback, we managed to bring back multi-use lock files and get PEP 751 accepted-- with no changes! -- on March 31.</p><h2 id="2-peps-and-6-years-later">2 PEPs and 6 years later ...</h2><p>If you add in some ancillary discussions, the total number of posts on the subject of lock files since 2019 comes to over 1.8K. But as I write this post, less than 7 months since PEP 751 was accepted, PDM has already been updated to allow users to opt into using <code>pylock.toml</code> over <code>pdm.lock</code> (which shows that the lock file format works and meets the needs of at least one of the three key projects I tried to make happy). Uv and pip also have some form of support.</p><p>I will say, though, that I think I&#39;m done with major packaging projects (work has also had me move on from working on packaging since April, so any time at this point would be my free time, which is scant when you have a toddler). Between <code>pyproject.toml</code> and <code>pylock.toml</code>, I&#39;m ready to move on to the next area of Python where I think I could be the most useful.</p>
        </div></div>
  </body>
</html>
