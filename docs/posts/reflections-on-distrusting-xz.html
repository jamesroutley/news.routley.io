<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joeyh.name/blog/entry/reflections_on_distrusting_xz/">Original</a>
    <h1>Reflections on Distrusting xz</h1>
    
    <div id="readability-page-1" class="page"><article class="page">







<div id="pagebody">

<section id="content" role="main">
<p>Was the ssh backdoor the only goal that &#34;Jia Tan&#34; was pursuing
with their multi-year operation against xz?</p>

<p>I doubt it, and if not, then every fix so far has been incomplete,
because everything is still running code written by that entity.</p>

<p>If we assume that they had a multilayered plan, that their every action was
calculated and malicious, then we have to think about the full threat
surface of using xz. This quickly gets into nightmare scenarios of the
&#34;trusting trust&#34; variety.</p>

<p>What if xz contains a hidden buffer overflow or other vulnerability, that
can be exploited by the xz file it&#39;s decompressing? This would let the
attacker target other packages, as needed.</p>

<p>Let&#39;s say they want to target gcc. Well, gcc contains a lot of
documentation, which includes png images. So they spend a while getting
accepted as a documentation contributor on that project, and get added to
it a png file that is specially constructed, it has additional binary data
appended that exploits the buffer overflow. And instructs xz to modify the
source code that comes later when decompressing <code>gcc.tar.xz</code>.</p>

<p>More likely, they wouldn&#39;t bother with an actual trusting trust attack on
gcc, which would be a lot of work to get right. One problem with the ssh
backdoor is that well, not all servers on the internet run ssh. (Or
systemd.) So webservers seem a likely target of this kind of second stage
attack. Apache&#39;s docs include png files, nginx does not, but there&#39;s always
scope to add improved documentation to a project.</p>

<p>When would such a vulnerability have been introduced? In February, &#34;Jia
Tan&#34; wrote a <a href="https://git.tukaani.org/?p=xz.git;a=commitdiff;h=de5c5e417645ad8906ef914bc059d08c1462fc29">new decoder for xz</a>.
This added 1000+ lines of new C code across several commits. So much code
and in just the right place to insert something like this. And why take on
such a significant project just two months before inserting the ssh
backdoor? &#34;Jia Tan&#34; was already fully accepted as maintainer, and doing
lots of other work, it doesn&#39;t seem to me that they needed to start this
rewrite as part of their cover.</p>

<p>They were working closely with xz&#39;s author Lasse Collin in this, by
indications exchanging patches offlist as they developed it. So Lasse
Collin&#39;s commits in this time period are also worth scrutiny, because
they could have been influenced by &#34;Jia Tan&#34;. One that
caught my eye comes immediately afterwards:
<a href="https://git.tukaani.org/?p=xz.git;a=commitdiff;h=e0c0ee475c0800c08291ae45e0d66aa00d5ce604">&#34;prepares the code for alternative C versions and inline assembly&#34;</a>
Multiple versions and assembly mean even more places to hide such a
security hole.</p>

<p>I stress that I have not found such a security hole, I&#39;m only considering
what the worst case possibilities are. I think we need to fully consider
them in order to decide how to fully wrap up this mess.</p>

<p>Whether such stealthy security holes have been introduced into xz by &#34;Jia
Tan&#34; or not, there are definitely indications that the ssh backdoor was not
the end of what they had planned.</p>

<p>For one thing, the &#34;test file&#34; based system they introduced
<a href="https://openwall.com/lists/oss-security/2024/03/30/15">was extensible</a>.
They could have been planning to add more test files later, that backdoored
xz in further ways.</p>

<p>And then there&#39;s the matter of the disabling of the Landlock sandbox. This
was not necessary for the ssh backdoor, because the sandbox is only used by
the <code>xz</code> command, not by liblzma. So why did they potentially tip their
hand by adding that rogue &#34;.&#34; that disables the sandbox?</p>

<p>A sandbox would not prevent the kind of attack I discuss above, where xz is
just modifying code that it decompresses. Disabling the sandbox suggests
that they were going to make xz run arbitrary code, that perhaps wrote to
files it shouldn&#39;t be touching, to install a backdoor in the system.</p>

<p>Both deb and rpm use xz compression, and with the sandbox disabled,
whether they link with liblzma or run the <code>xz</code> command, a backdoored xz can
write to any file on the system while dpkg or rpm is running and noone is
likely to notice, because that&#39;s the kind of thing a package manager does.</p>

<p>My impression is that all of this was well planned and they were in it for
the long haul. They had no reason to stop with backdooring ssh, except for
the risk of additional exposure. But they decided to take that risk, with
the sandbox disabling. So they planned to do more, and every commit
by &#34;Jia Tan&#34;, and really every commit that they could have influenced
needs to be distrusted.</p>

<p>This is why I&#39;ve suggested to Debian that they
<a href="https://bugs.debian.org/1068024">revert to an earlier version of xz</a>.
That would be my advice to anyone distributing xz.</p>

<p>I do have a <a href="https://git.joeyh.name/index.cgi/xz-unscathed/">xz-unscathed</a>
fork which I&#39;ve carefully constructed to avoid all &#34;Jia Tan&#34; involved
commits. It feels good to not need to worry about <code>dpkg</code> and <code>tar</code>.
I only plan to maintain this fork minimally, eg security fixes.
Hopefully Lasse Collin will consider these possibilities and address
them in his response to the attack.</p>

</section>









</div>



</article></div>
  </body>
</html>
