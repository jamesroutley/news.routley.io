<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://javarome.medium.com/design-noframework-bbc00a02d9b3">Original</a>
    <h1>Building a web app with no framework</h1>
    
    <div id="readability-page-1" class="page"><div><p><h2 id="178f">Is it as hard as you think?</h2></p><figure><p><img alt="" src="https://miro.medium.com/max/1024/1*g4UwfUA3WdO3fRhgMZuFkQ.png" width="512" height="512" role="presentation"/></p><figcaption>Is the framework layer really a good thing?</figcaption></figure><p id="77f7"><span>T</span>rendy ones used to be <a href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">Angular</a>, then <a href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">React</a>, now <a href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank">Vue.js</a>… others like <a href="https://emberjs.com/" rel="noopener ugc nofollow" target="_blank">Ember</a>, <a href="http://backbonejs.org/" rel="noopener ugc nofollow" target="_blank">Backbone</a> or <a href="https://knockoutjs.com/index.html" rel="noopener ugc nofollow" target="_blank">Knockout</a> have nearly disappeared. Standard ones like <a href="https://www.webcomponents.org/" rel="noopener ugc nofollow" target="_blank">Web Components</a> are seldom used, “yet another framework” seem to ship every year, like <a href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">Svelte</a>, <a href="https://aurelia.io/" rel="noopener ugc nofollow" target="_blank">Aurelia</a>, and each one is now featuring its server side counterpart (<a href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank">NestJS</a>, <a href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">NextJS</a> or <a href="https://nuxtjs.org/fr/" rel="noopener ugc nofollow" target="_blank">Nuxt</a> for the first mentioned ones, <a href="https://sapper.svelte.dev/" rel="noopener ugc nofollow" target="_blank">Sapper</a> for Svelte, etc.). Not speaking about non-Javascript web frameworks (<a href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank">Django</a>, <a href="https://spring.io/web-applications" rel="noopener ugc nofollow" target="_blank">Spring</a>, <a href="https://laravel.com/" rel="noopener ugc nofollow" target="_blank">Laravel</a>, <a href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank">Rails</a>, etc.). There’s even frameworks over frameworks (<a href="https://quasar.dev/" rel="noopener ugc nofollow" target="_blank">Quasar</a>, <a href="https://www.solidjs.com/" rel="noopener ugc nofollow" target="_blank">SolidJS</a>) and, at the end of that spectrum, <a href="https://en.wikipedia.org/wiki/No-code_development_platform" rel="noopener ugc nofollow" target="_blank">NCDP</a>s<strong>.</strong></p><p id="3491">This <a href="https://medium.com/hackernoon/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.758uh588b" rel="noopener">multiplicity is confusing</a> for both developers who want to know which technology is worth learning, and deciders who have to make strategic choices.</p><p id="ae74">Pretending to help, comparison articles are published or updated as often. However most of them are usually biased as “I worked with this one” versus “I tried others a bit”. Less biased authors will conclude that with a “it depends” (on performance, tooling, support, community, etc.), which is just another way of being inconclusive.</p><p id="f180">Even benchmarks, by comparing the same application on every framework, can hardly provide a realistic comparison, as limited by the scope of dummy app (such as a todo list).</p><p id="1965">In the end, frameworks look like religions (or politics): each of them pretend to have the solution, but each of them is different. Each of them claim to provide the best vision of ̶t̶h̶e̶ ̶w̶o̶r̶l̶d̶ an app, but there are heated debates about which one holds the truth. Each of them require you to follow specific rules and, while there may be similarities, it is always difficult to convert from one to another.</p><p id="d9c7">Let’s look at an “atheist” approach of frameworks: use none.</p><h2 id="c82d">Where am I talking from?</h2><p id="7f91">Aside from a 25+ years of professional experience in software development, this article is based on experience in building a real-world vanilla JS web app (front and back).</p><p id="bea1">Actually the idea is now new. As back as 2017, Adrian Holovaty, co-creator of the <a href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank">Django</a> web framework, spoke about his own frameworks <em>fatigue</em> and why he left Django to build <a href="https://www.soundslice.com/" rel="noopener ugc nofollow" target="_blank">his own vanilla JS project</a>.</p><figure><div></div><figcaption>Holovaty’s talk at <a href="https://www.dotconferences.com/2017/12/adrian-holovaty-a-framework-author-case-against-frameworks" rel="noopener ugc nofollow" target="_blank">dotJS 2017</a></figcaption></figure><p id="57cf">One may wonder why would someone want to dive into such a (supposedly) hard task as building a web app without a framework. Why not building an app on top of previous work, using robust frameworks with hundreds of years of combined engineering hours? Is it a <a href="https://en.wikipedia.org/wiki/Not_invented_here" rel="noopener ugc nofollow" target="_blank">NIH</a> syndrom that will eventually lead to building a custom framework?</p><p id="1405">No. Developers are not more inclined to masochism than the general population. Actually, they are probably more lazy than anyone: they want to write less code (so they get less bugs), they want to automate processes (to avoid human mistakes)…</p><figure><p><img alt="" src="https://miro.medium.com/max/1022/1*nLKw4XoG4kDjCcsB6w7fUA.jpeg" width="511" height="287" role="presentation"/></p></figure><p id="662c">…but they also want to be <strong>agile</strong>, that is, to be able to handle any problem easily and so, quickly.</p><p id="ace8">While “quick” sounds akin to one promise frameworks make (to save you time by doing plumbing for you, while increasing reliability), this doesn’t come for free: they want you to sign a contract to agree with a <strong>tax</strong> and put your code into a <strong>silo*</strong>.</p><h2 id="9c4d">The Framework Tax</h2><p id="6d80">Framework services come with a cost. They require you to:</p><ul><li id="9100"><strong>comply</strong> with their API so that they <em>can</em> provide your their services. This is just <a rel="noopener" href="https://javarome.medium.com/framework-or-library-6711f998d978">the way a framework works</a>: your code will have to adhere to some rules, including more or less <a href="https://en.wikipedia.org/wiki/Boilerplate_code" rel="noopener ugc nofollow" target="_blank">boilerplate code</a>. So it’s the framework way, or the highway. Your daily challenges will be less about “how to do this” than “how to make the framework (not) do this”. Dodge those constraints at your own risks: if you bypass a framework by directly calling low-level APIs, don’t expect it to understand what you’re trying to do, don’t expect it to stay consistent. So it’s a false promise frameworks make that you’ll be “focusing on your business”: in reality you have to care on the framework too, and a lot.</li><li id="3b6e"><strong>upgrades</strong> are effectively <em>forced</em> if you:</li><li id="22d9"><strong>train</strong> to learn how they work (what they can/cannot do, what are their concepts, APIs, ecosystem, tools), including changes that may occur in new versions. Should you pick the most popular framework of the day, this might be easier, but it’s unlikely that you’ll ever know about every aspects of a given framework. Also, hype comes and goes: should you decide to use another framework for a new app (or even worse, to migrate from one to another), the cost of investing in such proprietary knowledge will be lost. This explains a lot of inertia in enterprise projects, even if each project is different than the previous one. “Compatibility means deliberately repeating other people’s mistakes,” said the late David Wheeler.</li><li id="b8ef"><strong>compromise</strong> with the drawbacks implied by delegating control: you may not be able to do whatever you want (or to <em>prevent</em> the framework from doing things you do <em>not</em> want) or you may not achieve the performance you want (because of additional layering, too-generic code, bigger code size or backward compatibility requirements).</li><li id="0376"><strong>loose</strong> skills. A number of developers either don’t know much about the lower-level APIs (because they always used the framework layer instead) or live in the past (i.e. are stick on an outdated knowledge of it, not being aware of the latest improvements and new capabilities). The <a href="https://en.wikipedia.org/wiki/Law_of_the_instrument" rel="noopener ugc nofollow" target="_blank">law of the instrument</a> then leads too often to build overkill solutions to simple problems, and loose (if even once acquired) knowledge to build simpler ones. Being guided by blueprints and recipes, they loose (or not gain) a culture of good software design (principles, patterns) and barely build a significant engineering experience. Just like users of CSS frameworks (<a href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank">Bootstrap</a>, <a href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">Tailwind</a>, etc.) lack CSS skills, users of web frameworks are doomed to lack experience in both modern web APIs and software design in general.</li></ul><figure><p><img alt="" src="https://miro.medium.com/max/1280/1*AFT4ONeWYqeO2F86BQbpvQ.jpeg" width="640" height="400" role="presentation"/></p><figcaption>Once you put your money inside a framework, it’s hard to get it out.</figcaption></figure><h2 id="331e">The Framework Silo</h2><p id="d52e">Aside the “tax” that you have to pay to get their benefits, frameworks can also induce an additional major issue <em>when they are not standard</em>.</p><p id="371b">As they enforce rules — but each one of them is different — this implies binding your app with a <em>proprietary</em> ecosystem. That means <strong>locking</strong> your app code with a proprietary API (and its upgrade process). That’s a risky bet for your project, as it implies:</p><ul><li id="f89c"><strong>no portability</strong>: migrating your code toward another framework (or a new version of it with breaking changes, or even vanilla code) will be very costly, including the cost of possible re-training ;</li><li id="e482"><strong>no interoperability</strong> of your code with other frameworks runtime or other framework’s components libraries that you’d like to use: as their rules are different, most frameworks do not interoperate easily one with each other.</li></ul><p id="e86c">Of course you can get reassured by selecting the most popular framework… at the time of your project starts. That may be acceptable for an app that is quite short lived, but not for a long term investment.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*WLK_net4jm9w6w1Cvk5EUQ.png" width="700" height="484" role="presentation"/></p></div><figcaption>Frameworks come and go. Their fate is a decline in <a href="https://2021.stateofjs.com/en-us/libraries/front-end-frameworks/" rel="noopener ugc nofollow" target="_blank">interest</a>, replaced by 1 to 3 new ones per year, since 2018.</figcaption></figure><p id="5a8b"><strong>Standard </strong>frameworks, however, don’t imply this silo effect. On the web platform (i.e. the browser framework), using standard web APIs makes your investment less risky are they are expected to work on most browsers. If not all (or not all the ones you target), support can still be provided through <a href="https://en.wikipedia.org/wiki/Polyfill_(programming)" rel="noopener ugc nofollow" target="_blank"><em>polyfills</em></a>.</p><p id="e58c">For instance, Web components are today both <em>portable</em> (they can be used in <a href="https://caniuse.com/?search=web%20components" rel="noopener ugc nofollow" target="_blank">nearly all browsers</a>) and <em>interoperable</em> (can be used by any code, including proprietary frameworks) as they are encapsulated as any HTML element. Even better for performance, their runtime (Custom Elements, Shadow DOM, HTML Templates) is executed as part of the browser, so it’s both <em>already there</em> (i.e. not downloaded) and <em>native</em>.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*s66ryQPHOA2_8PC5XrMLnA.jpeg" width="700" height="466" role="presentation"/></p></div><figcaption>Rare image of developers trying to escape a framework silo.</figcaption></figure><h2 id="9cfd">So are frameworks bad by nature?</h2><p id="1f02">No, if only because coding an app almost always results in creating your own framework: any app implement its <em>own business rules</em>, that apply to its business objects.</p><p id="2b2a">So frameworks are a good thing if either they:</p><ul><li id="369b">are <strong>app-specific</strong>: any app ends up designing its own “business” framework.</li><li id="1fe1">are <strong>standard </strong>or end up with a standard. For instance the web platform is a standard web framework, and Web Components frameworks (<a href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank">lit</a>, <a href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank">stencil</a>, <a href="https://skatejs.netlify.app/" rel="noopener ugc nofollow" target="_blank">skatejs</a>, etc.) end up building components that comply with the standard.</li><li id="22bc">add some <strong>unique value </strong>that you’re missing in all other alternatives (including other frameworks). In such a case you have almost no choice, as the unique added value justifies the implied cost of locking with it. For instance, an OS-specific framework makes sense since it enforce OS standards and there is no other other way to provide an app or extension for it.</li><li id="5b08">are used to build <strong>non-critical apps</strong> (short lived, with lower quality expectations) where tax and silo effect are acceptable. For instance it makes sense to use Bootstrap to build some prototype, MVP or internal tool.</li></ul><h2 id="39ae">The goal</h2><p id="0197">So, in a nutshell, avoiding a framework to build an app aims to:</p><ul><li id="1ade"><strong>maximize flexibility</strong> by avoiding “one size fits all” constraints from frameworks. Also, not having blueprints avoids the <a href="https://en.wikipedia.org/wiki/Law_of_the_instrument" rel="noopener ugc nofollow" target="_blank">law of the instrument</a> to increase the <em>creativity </em>for ambitious applications. Most web apps using Bootstrap can be recognized as such, because they’re having a hard time getting out of the predefined components and styles. In the end, they’ll have a hard time <em>thinking</em> another way.</li><li id="ddf2"><strong>minimize dependency</strong> to any of the currently hyped frameworks. Not being locked with a framework avoids issues with portability and interoperability.</li><li id="da67"><strong>maximize performance</strong> by allowing the most fine-grained operations only when required (no framework-dependent refresh cycle for instance) and reducing dependencies to a selection of precise, required-only, set of lightweight libraries.</li></ul><p id="70b8">And, of course, the goal is neither to “reinvent the wheel”. Let’s see how we can do that.</p><p id="e149">So, what is it to build apps without framework tax and silo?</p><p id="0dcb">First, we must clarify the anti-goal: <strong>“building an app without a framework” is NOT to be confused with “replacing the framework”</strong>. This is <em>not</em> the challenge at stake: a framework is a <em>general purpose</em> technical solution to host virtually <em>any</em> app, so it is less about <em>your</em> app than <em>all</em> apps. On the opposite, going vanilla is an opportunity to focus on <em>your</em> app’s needs <em>only</em>.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*7vZPXY_8zq-FZKA1iwi49g.png" width="700" height="361" role="presentation"/></p></div><figcaption>Developing an app without a framework doesn’t mean to re-implement the framework.</figcaption></figure><p id="bf50">This is an important scope narrowing to make to assess the (non-)difficulty of building your app without a framework: it is <em>not</em> as hard as building a framework, because you do <em>NOT</em> aim to build:</p><ul><li id="4b49">a proprietary component model (a container implementing a specific components lifecycle)</li><li id="47e7">a proprietary plugins/extension system :</li><li id="8999">a fancy template syntax (JSX, Angular HTML, etc.)</li><li id="a80b">optimizations that make sense for general-purpose (change detection, virtual DOM)</li><li id="cbcc">framework-specific tools (debugging extensions, UI builders, version migration tools)</li></ul><p id="62cf">So building a vanilla app is not an enormous task of “reinventing the wheel” as often caricatured, because the major part of this “wheel” is actually about the APIs/contracts, their implementations, the general-purpose engine and associated optimizations, the debugging capabilities, etc.. Leaving the general-purpose goal and focusing on <em>your app’s</em> goals means that you can rid of most of it. Ironically, this is the<em> real</em> “focus on your app” approach.</p><p id="d846">Now, how to design and implement a vanilla app? When most of apps are built using a framework, it may indeed be hard to devise a way to achieve similar results without <a href="https://en.wikipedia.org/wiki/Law_of_the_instrument" rel="noopener ugc nofollow" target="_blank">that familiar instrument</a>. You’ll have to:</p><ul><li id="27e0"><strong>change your state of mind</strong>: don’t look for the framework-specific services mentioned above. As a vanilla app, you will probably don’t need it. Don’t think change detection, just update the DOM, etc.</li><li id="9956"><strong>use technical alternatives</strong> for the common tasks you performed with frameworks (updating the DOM — including reactively — , loading lazily, etc.)</li></ul><p id="c458">This latter topic has been addressed by authors like Jeremy Likness (who has devised some bits of JS to <a href="https://blog.jeremylikness.com/blog/build-a-spa-site-with-vanillajs/" rel="noopener ugc nofollow" target="_blank">provide common framework facilities to a vanillaJS app</a>) or <a href="https://gomakethings.com/" rel="noopener ugc nofollow" target="_blank">Chris Ferdinandi</a> (a.k.a. “the vanilla JS guy”) but, by definition, any vanilla app may choose to use one of those techniques or not, depending on its needs. For instance, <a href="https://www.smashingmagazine.com/2017/05/why-no-framework/" rel="noopener ugc nofollow" target="_blank">the authors of MeetSpace didn’t need much more than the standard APIs</a>.</p><p id="6e3d">Let’s look at a number of common recipes, though.</p><h2 id="3a68">Standards</h2><p id="84bd">As we have seen above, standards APIs are among the “good frameworks” as they:</p><ul><li id="db3d">allow <strong>portability</strong>: they are <a href="https://wpt.fyi/interop-2022" rel="noopener ugc nofollow" target="_blank">expected to be available everywhere</a>. When not yet available, they can be polyfilled.</li><li id="49d3">allow <strong>interoperability</strong>: they can interact with other standards and be used by proprietary code.</li><li id="9d2f">are <strong>long lived:</strong> as devised by multiple industry actors rather than only one, they are well designed and here to stay once released. So investing in them is less risky.</li><li id="38b3">are <strong>immediately available</strong> in the browser most of the time, which avoids downloading them. In some case you may have to download polyfills instead but, contrary to proprietary frameworks (which are doomed to be less and less trendy), their fate is to be more and more available (thus reducing download probability).</li></ul><p id="76bd">One could also consider that the choice of the <em>programing language</em> should focus on standards. JavaScript have evolved over the years, and now contains features usually provided by other languages like the <code>class</code> keyword, or limited type checking support through JSDoc comments such as <code>@type</code>.</p><p id="91e3">A number of languages transpile to JavaScript: <a href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript</a>, <a href="http://coffeescript.org/" rel="noopener ugc nofollow" target="_blank">CoffeeScript</a>, <a href="https://guide.elm-lang.org/interop/" rel="noopener ugc nofollow" target="_blank">Elm</a>, <a href="https://kotlinlang.org/docs/js-overview.html" rel="noopener ugc nofollow" target="_blank">Kotlin</a>, <a href="https://www.scala-js.org/" rel="noopener ugc nofollow" target="_blank">Scala.js</a>, <a href="https://haxe.org/manual/target-javascript.html" rel="noopener ugc nofollow" target="_blank">Haxe</a>, <a href="https://dart.dev/tutorials/web/get-started" rel="noopener ugc nofollow" target="_blank">Dart</a>, <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm" rel="noopener ugc nofollow" target="_blank">Rust</a>, <a href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">Flow</a>, etc. Each of them adds different values to your source code (type checking, additional abstractions, syntax sugar); should a vanilla app use them? To answer that question, let’s look if they imply the same drawbacks as frameworks:</p><ul><li id="3cc9"><strong>comply</strong> with their syntax: by definition, most languages enforce this (CoffeeScript, Elm, Kotlin, etc.) with the notable exception of those which are <em>supersets</em> of JavaScript (<a href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript</a>, <a href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">Flow</a>) which allows you to write some the parts of your choice using pure, lower-level JavaScript.</li><li id="460f"><strong>upgrade</strong> can be required if you use very old versions of any language (including JavaScript itself) but at a very lower pace than frameworks.</li><li id="821b"><strong>train</strong>, by definition again, is required to use their syntax. However superset languages allow you learn progressively, since you can stick on traditional JS in some parts of your code.</li><li id="2955"><strong>loosing</strong> skills about the target language (JavaScript) is indeed a risk for non-superset languages, as the transpilation/compilation is general-purpose, can be non-optimal, and you may be unaware of it. Maybe you could have performed the same operation with more simple and efficient JS code.</li><li id="8b33"><strong>compromise</strong> with the drawbacks is indeed required, as you cannot change the transpilation to JS (or just customize it a bit, using <code>tsconfig.json</code> for instance) nor the compilation to WebAssembly. Some languages may also <a href="https://coffeescript.org/#unsupported" rel="noopener ugc nofollow" target="_blank">omit some JS languages concepts</a>.</li><li id="2e6b"><strong>portability</strong> is achieved, as transpilation can usually target ES5 (but sometimes you will have to compromise with that target even if you’d wanted to target ES6). WebAssembly is more recent but supported by all modern browsers.</li><li id="b331"><strong>interoperability</strong> with other JS code is provided or not. Typescript can be configured to allow JS for instance.</li></ul><p id="6885">As you can see, you should we wary about the source language to use in a vanilla app, as all of them imply more or less constraints. Superset languages (<a href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript</a>, <a href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">Flow</a>) allow to minimize those constraints by avoiding an “all or nothing choice” and can be used only where it adds value.</p><p id="ee89">In any case, keep in mind that adding a language layer above JavaScript implies a layer of complexity in your tooling chain that may fail for some reason (see below). Also, development-time benefits are lost after compilation/transpilation (type checking or restricted visibility might not be enforced at runtime typically).</p><h2 id="b784">Libraries</h2><p id="6a5e">As for the “rewrite a framework” false assumption, it is often considered that vanilla JS apps are <em>NOT </em>supposed to use libraries. This is utterly false. Once again, “reinventing the wheel”, i.e. rewriting everything from scratch cannot be a sensible goal. The vanilla goal of <em>removing constraints</em> <a rel="noopener" href="https://javarome.medium.com/framework-or-library-6711f998d978">implied by frameworks and not libraries</a>, must not be confused with a “write everything by yourself” dogma.</p><p id="f5ff">So <strong>there is nothing wrong in using libraries</strong> as code that you cannot write by yourself (because you don’t have time to do it, or because this requires too much expertise). All you have to care about:</p><ul><li id="aef1"><strong>modularity</strong>:<strong> </strong>avoid using a big lib if you use only a small percentage of it;</li><li id="34a3">avoid <strong>redundancy</strong>: only use a lib if there is no standard (or polyfill of it), and prefer libs that implement a standard;</li><li id="14e1">avoid <strong>locking</strong>: don’t use the lib API directly, <a rel="noopener" href="https://javarome.medium.com/framework-or-library-6711f998d978#8e2b">wrap it in your own app API</a>.</li></ul><p id="b0df">Oh, and don’t be fooled by frameworks documentation or <a href="https://www.freecodecamp.org/news/is-react-a-library-or-a-framework/" rel="noopener ugc nofollow" target="_blank">articles</a> that would claim that they are not a framework (because they would be “unopinionated”, or not defining a “complete application“, etc.): as soon as they imply a contract, they are.</p><h2 id="d449">Patterns</h2><p id="3f8c"><a href="https://www.youtube.com/watch?v=VvOsegaN9Wk&amp;t=804s" rel="noopener ugc nofollow" target="_blank">As Holovaty says</a>, the option to just applying <a href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">patterns</a> to structure your software (instead of using frameworks) is not considered enough.</p><p id="e4ca">Those patterns are well-known and are not specific to vanilla development. <strong>They are themselves self-documenting</strong> since they are <em>quickly recognized</em> by experienced developers (providing you <a rel="noopener" href="https://javarome.medium.com/programming-naming-361a41c86928#777c">name them correctly</a>).</p><p id="2c8b">To name only a few:</p><ul><li id="cd6f">splitting <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"><strong>Model, View and Controller (MVC)</strong></a>;</li><li id="33a2"><a href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank"><strong>factories</strong></a> to create objects depending on configuration;</li><li id="3490"><a href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank"><strong>observers</strong></a> to ease <a href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">reactive programming</a>;</li><li id="4324"><a href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener ugc nofollow" target="_blank"><strong>iterators</strong></a> to virtualize collections (lazy load their elements);</li><li id="78ec"><a href="https://en.wikipedia.org/wiki/Proxy_pattern" rel="noopener ugc nofollow" target="_blank"><strong>proxies</strong></a> for lazy loading, security checks, etc.</li><li id="48d3"><a href="https://en.wikipedia.org/wiki/Command_pattern" rel="noopener ugc nofollow" target="_blank"><strong>commands</strong></a> to encapsulate operations that might be triggered from various contexts.</li></ul><p id="2f2c">This list is not exhaustive, nor required: you are free to use what fits your needs, but when one pattern provides a typical solution to a typical problem of your app, you should definitely apply it. More generally, anything that fulfills <a href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">SOLID</a> principles and a good <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">cohesion</a> is good for your app flexibility and maintainability.</p><h2 id="a2a9">Updating</h2><p id="9a4a">When interviewing developers about what would be their primary concerns when trying to build a vanilla application, most of them reply that it would be complicated to implement model change detection and subsequent updates in the relevant “views” of the app. This is a typical <a href="https://en.wikipedia.org/wiki/Law_of_the_instrument" rel="noopener ugc nofollow" target="_blank">law of the instrument</a> effect, which makes you think in a framework way, whereas not being a framework actually implies much more simple needs:</p><ol><li id="d12d">The “views” are just DOM elements. You can abstract them of course (and you should) but in the end they are just that.</li><li id="a517">Updating them is just a matter of <code>viewElement.replaceChild(newContent)</code>. That’s it. No unnecessary update of a larger DOM scope, no unwanted redraw or scrolling. There are several ways to update the DOM, from <a href="https://gomakethings.com/four-different-ways-to-inject-text-and-html-into-an-element-with-vanilla-javascript/" rel="noopener ugc nofollow" target="_blank">inserting text</a> to <a href="https://gomakethings.com/five-more-ways-to-inject-html-into-the-dom-with-vanilla-javascript/" rel="noopener ugc nofollow" target="_blank">manipulating real DOM objects</a>. Just pick the one that fits your need.</li><li id="6f86">“Detecting” when updating is required is usually not necessary in a vanilla app, since most often you just <em>know</em> what is to be updated following an event as you can just do it imperatively. You grab your DOM target and update it, period. In some cases of course you might want to do a more generic update by reversing the dependency and notifying observers (see below) that will update themselves.</li></ol><h2 id="10d2">Templates</h2><p id="ebbd">Another feature that developers fear to miss is the ability to write HTML snippets with dynamics parts, even listeners, etc.</p><p id="a033">First of all the DOM API (<code>document.createElement(&#34;button&#34;)</code>, etc.) is not that hard, and actually more powerful than any template language since this allows you full access to the API. It can be tedious to build long HTML fragments but, hey, if they are that long, it’s probably that you need to split it in more fine grained components.</p><p id="50e7">It is true, however, that viewing those elements as a template improves readability. So how to have them? There are actually multiple ways:</p><ul><li id="1537"><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots" rel="noopener ugc nofollow" target="_blank"><strong>HTML Templates</strong></a><strong> </strong>are now available in browsers (since 2017 at worse). They provide the ability to build a reusable, off-screen, HTML<code>&lt;template&gt;</code> snippet. This is this actually a part of Web Components and yes, they can support transclusion through <code>&lt;slot&gt;</code>.</li><li id="3674"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"><strong>Template literals</strong></a> are available in JavaScript since ES6 (2015). They allow you to easily embed values inside a string. That be enough to embed primitives (numbers, strings, including other HTML code, etc.) but not more sophisticated elements like DOM elements on which you registered listeners for instance.</li><li id="affc">A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"><strong>tagged template literal function</strong></a> can help embedding complex values like DOM Nodes into such a template that would result in a Node itself. ObservableHQ has devised a <a href="https://observablehq.com/@observablehq/htl" rel="noopener ugc nofollow" target="_blank">pretty handy one</a> that allows you to write things like <code><strong>html`</strong>&lt;header&gt;${<strong>stringOrNode</strong>}&lt;/header&gt;</code> or to do more complex templating like <code><strong>html`</strong>&lt;ul&gt;${<strong>items.map(item =&gt; </strong>`&lt;li&gt;<strong>${item.title}</strong>&lt;/li&gt;}&lt;/ul&gt;</code> .</li></ul><p id="045b">What about conditionals or loops in a template? Aside the fact that this might have never been a good idea (UIs should be dumb and not contain logic), you can (and should) just do it JS, then insert the result in your template, using one of the techniques above.</p><h2 id="c7f1">Events</h2><p id="6acc">Ok now we have basic templates, but how to bind events to DOM Nodes inside them? There are also several alternatives:</p><ul><li id="e7cb"><strong>HTML event handlers</strong> (<code>&lt;button <strong>onclick</strong>=&#34;myClickHandler(event)“&gt;</code>) can be inserted in any HTML source, but they not very practicable, since they require the specified handlers to be available on the specified scope.</li><li id="ce6f"><strong>Event handlers API</strong> (<code>button.<strong>addEventListener</strong>(&#34;click&#34;, myClickHandler)</code>) can be used on any node created through the DOM API or an HTML tagged template literal function.</li></ul><p id="08ed">Now what about custom/business events? What if I need to react to some event triggered by a component of my app. There are also multiple options for that:</p><ul><li id="7dd2"><strong>Custom events</strong>: You can create you own events classes extending <code>EventTarget</code> and dispatch or listen to them, just like any “standard” event.</li><li id="0eeb"><strong>EventEmitter</strong> is theoretically an option (exists in Node and as libs in the browser), but is rarely used.</li><li id="1a3a"><strong>Observer pattern</strong>: <a href="https://benlesh.medium.com/learning-observable-by-building-observable-d5da57405d87" rel="noopener">You can build your own</a> but <a href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank">RxJs</a> is the de facto-standard for doing such reactive programming: build a <code>Subject</code> then notify all subscribers of a new value so they can react to it.</li></ul><h2 id="f3e2">Components?</h2><p id="ff8f">Whereas vanilla development is not about writing any complex infrastructure to host components (a.k.a. containers), it is still a good idea design software items as <em>reusable </em>(i.e. context-independent)<em> </em>if they can occur multiple times in your system. Whatever the technology you use, <a rel="noopener" href="https://javarome.medium.com/design-srp-a5bc51a1a3d1">well-grained</a> <strong>abstractions </strong>remain useful, whether they are business or technical: it’s always a good idea to group data and rules pertaining to the same business concept into a <em>reusable</em> object or to build a widget that can be instantiated in multiple places in your app.</p><p id="8f39">There are a number of ways to create components, depending on what you need. As soon as 2017, Mev-Rael <a href="https://medium.com/bunnyllc/vanilla-js-components-8d20c58b69f4" rel="noopener">proposed a number of technical tips</a> to handle state, custom properties and views for vanilla JavaScript components. Again, don’t feel constrained to stick to a given recommended technique but think about your need first then pick the ones that fits with it.</p><p id="2f9d">Aside standard widget components (which would typically be implemented as standard <a href="https://www.webcomponents.org/" rel="noopener ugc nofollow" target="_blank"><strong>Web Components</strong></a>), any component should typically be able to:</p><ul><li id="e528"><strong>split its logic and its view</strong> (through a MVC typically). Mixing the two usually makes the code less maintainable, and less flexible (for instance, should you want to display a record in both detailed or tabular form, your RecordComponent would just need to use either a DetailRecordView or a RowRecordView).</li><li id="8425"><strong>read inputs</strong> to parameterize its behavior or its view.</li><li id="b30e"><strong>trigger events</strong> to notify parties that something occurred in the component (following a user interaction typically).</li><li id="6e3b"><strong>synchronize</strong>: your component should be able to redraw if some event occurs. This can be achieved quite easily using reactive libraries such as <a href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank">RxJS</a>.</li></ul><p id="2256">In any case, whatever the design strategy you choose, you component (or more specifically its associated “view”) must be able to provide some HTML rendering result. A string containing HTML code could be used, but an actual <code>HTMLElement</code> (or just <code>Element</code>) is usually a better choice (easier to read/update rather than parsing, allowing to bind event handlers on it) and a more performant one (no parsing required).</p><p id="e62e">Also, you might want to use <strong>external components</strong> from third-party libraries. For sure, proprietary frameworks, because of their popularity, benefit from a larger number of libraries and components developed by their community. Although most of them are actually not so different from what they would be if they’d had been implemented in pure Javascript (like this was the case at JQuery times) they do suffer from lack of interoperability, and you find yourself looking for either vanilla or Web components.</p><p id="a3c6">Hopefully such libraries exist, such as the <a href="https://vanillajstoolkit.com/" rel="noopener ugc nofollow" target="_blank">Vanilla JS Toolkit</a>, even if less common. Regarding standards ones, WebComponents.org list <a href="https://www.webcomponents.org/elements" rel="noopener ugc nofollow" target="_blank">2000+ elements</a>. There’s even <a href="https://github.com/vanillawc/.github" rel="noopener ugc nofollow" target="_blank">vanilla web components</a>, but the vanilla aspect is less relevant here (more about implementation lightweightness than interoperability).</p><h2 id="3146">Routing</h2><p id="4a6c">Managing routes in a SPA today requires using the web <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" rel="noopener ugc nofollow" target="_blank">History API</a>. Whereas <a href="https://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url" rel="noopener ugc nofollow" target="_blank">this is less complex that you imagine</a>, you might want to delegate this to a simple router library such as <a href="https://github.com/krasimir/navigo" rel="noopener ugc nofollow" target="_blank">Navigo</a>.</p><p id="0e08">All you have to do, then, is to replace an DOM element by another (using <code>replaceChildren()</code> or <code>replaceWith()</code>) when a route is reached.</p><h2 id="3473">Lazy loading</h2><p id="348b">Loading JavaScript code on demand is a legit concern for any web app. You don’t want to load the full code of your app to display a login form.</p><p id="8b26">As soon as 2009, before the advent of web frameworks, James Burke (a <a href="https://dojotoolkit.org/" rel="noopener ugc nofollow" target="_blank">Dojo</a> developer) shipped <a href="https://requirejs.org/" rel="noopener ugc nofollow" target="_blank">RequireJS</a> (initially “RunJS”) to tackle that problem. Since then, more modern techniques have emerged, with the advent of modules. Since ES6 (2015) those can be loaded <em>dynamically</em>. Yes, at runtime. This works in Node, but in browsers too, since at least 4 years now:</p><pre><span id="fac0">{WelcomeModule} = <strong>await import</strong>(&#34;./welcome/ModuleImpl&#34;)</span></pre><p id="8edc">How to insulate the modules in dedicated files? Bundlers like <a href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">Webpack</a> can do the chunks for you.</p><p id="af3f"><em>Beware that you should only use constants in the import path</em>, though: otherwise, the bundler cannot guess what you will load and will package the whole set of possible files in a single chunk. For instance <code>await import(`./welcome/<strong>${moduleName}</strong>`)</code> will bundle everything in the specified directory, given that your bundler doesn’t know what the moduleName variable will hold at runtime.</p><h2 id="1ca4">Native apps</h2><p id="48eb">More and more frameworks provide a way to run or migrate/compile their apps for native platforms (such as <a href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank">React native</a>) in order to deploy them as standalone apps on <strong>Android</strong> or <strong>iOS</strong> mobile systems.</p><p id="d81b">Aside the fact that you should also consider writing a real native app, note that more general solutions also existed to embed webapps in native containers before the advent of frameworks. This used to be PhoneGap (<a href="https://blog.phonegap.com/update-for-customers-using-phonegap-and-phonegap-build-cc701c77502c" rel="noopener ugc nofollow" target="_blank">now discontinued</a>)/Apache Cordova ; this is now <a href="https://nativescript.org/" rel="noopener ugc nofollow" target="_blank">NativeScript</a> (which supports frameworks like Angular, but also vanilla apps) or native webapp wrappers like <a href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">Electron</a> or its lightweight successors like <a href="https://tauri.studio/" rel="noopener ugc nofollow" target="_blank">Tauri</a>.</p><h2 id="202a">Server-Side Rendering</h2><p id="9231">A number of frameworks have the benefit of being <strong>isomorphic</strong>: you run a similar code both on front and back end, thus making SEO-friendly server-side rendering (SSR) easy to implement.</p><p id="ab8c">This can be a cool and (albeit complex) convenient feature, but you should also keep in mind that its also about <strong><em>extending your framework locking</em></strong> up to the server. So you should think twice before inserting such another level of framework locking in your app: think about the impact on your project, infrastructure, required clients technologies, etc.</p><p id="e906">Hopefuly you can also do this without a framework.</p><p id="4f66"><strong>Rendering from the server</strong></p><p id="e899">Using a vanilla implementation strategy, it seems pretty easy at first: isn’t it about just returning HTML? You already have the components to do that. Yes, but:</p><ul><li id="8b53">You need a <strong>server-side DOM API</strong>, as there is no DOM API on the server side by default (<a href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank">JSDOM</a> — maintained, among others, by <a href="https://github.com/domenic" rel="noopener ugc nofollow" target="_blank">Domenic Denicola</a> — or the optimized <a href="https://github.com/capricorn86/happy-dom" rel="noopener ugc nofollow" target="_blank">Happy DOM</a> are good choices for that).</li><li id="338f">Your rendering components must take care to <strong>never assume if the DOM is client side or server side</strong>. To do so, you’ll want to always pick your DOM objects (<code>window</code>, <code>document</code> and types like <code>Node</code>, <code>HTMLElement</code>, <code>NodeFilter</code>) from a (client or server) app context, not directly.</li><li id="c685"><strong>share your rendering components in a shared package</strong> between client and server apps. There are multiple strategies to do so, like publishing it in a package repository, but the most flexible one is probably to have your apps packages reference its module in a <em>monorepo</em>.</li></ul><p id="1ad5"><strong>Adding interactivity</strong></p><p id="a2b8">However, once your HTML elements are translated to string, you loose all event handlers that you might have set up on those. This is where frameworks provide <strong>hydratation</strong> to restore the missed interactivity of HTML.</p><p id="7e05">Doing the same in a vanilla server app means injecting JS script(s) into your response (either referenced or inlined) that will execute once on the client side. These will typically include runtime code for the Web Components that are part of your HTML response.</p><h2 id="131d">I18N</h2><p id="a0ee">Internationalization have been handled by libraries for many years now (and finally integrated within frameworks). You can easily integrate one of those libs but this could also be a good candidate for an in-house implementation, which would allow more simple and efficient messages types than a general-purpose lib can.</p><p id="d248">It’s just as simple as that:</p><pre><span id="67a4">interface WelcomeMessages {</span><span id="cd78">class WelcomeMessage_en <strong>implements WelcomeMessage</strong> {</span><span id="aee4">class WelcomeMessage_fr <strong>implements WelcomeMessage</strong> {</span></pre><p id="16f9">Note that this provides you:</p><ul><li id="d227"><strong>type checking</strong>: every message has a static type (and several implementations/translations), so your IDE can check if you’re using a valid message property or not, and provide you auto-completion.</li><li id="afea">translation <strong>exhaustivity</strong> check: you can’t compile until all interface keys are implemented in all languages.</li></ul><p id="0d3a">All you have is to (load and) instantiate the message class that is relevant to you user’s locale. General purpose libs can’t provide such business-specific types.</p><h2 id="5261">Tools</h2><p id="4844">If you want to free yourself from dependency on a too constraining software stack, it is likely that you’d want to do the same with your tools: you don’t want to depend on them (their limitations, their performance, their bugs, their versions) to be able to move forward. You don’t want tot get stuck with a build problem that you cannot solve (or need hours or days to solve) because you do not own it (especially when using trendy but recent build tools which are not fully battle-tested yet).</p><p id="acee">That said, you will hardy avoid those tools. Most often your production code will have to be <strong>bundled</strong> in a clever way, involving minification, obfuscation, code splitting, tree shaking, lazy loading, style inclusion, etc. and there is little doubt that existing packagers such as <a href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank">Webpack</a>, <a href="https://parceljs.org" rel="noopener ugc nofollow" target="_blank">Parcel</a>, <a href="https://github.com/evanw/esbuild" rel="noopener ugc nofollow" target="_blank">ESBuild</a> or <a href="https://vitejs.dev/" rel="noopener ugc nofollow" target="_blank">Vite</a> will do it better that you could.</p><p id="49de">All you can do about it is:</p><ul><li id="4c56">Use <strong>less transformations as possible</strong>. For instance, using TypeScript might a good thing but implies an additional level of complexity that has to be handled by your tooling chain. Maybe your CSS also, especially with the latest modern versions, is not worth using preprocessors like <a href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank">Sass</a>.</li><li id="20df">Use <strong>less tools as possible</strong>. The more you add, the more one can fail / not support your needs.</li><li id="96c3">When using one, use the <strong>most popular tool</strong> so what you need is more likely to be supported by such a battle-tested software (and so you won’t be stuck in a position of “change need or change tool”). Moving to the latest hyped bundler too early might save you a few build seconds that might be compensated by the time devoted understanding the new beta documentation, handling bugs or lack of support.</li></ul><p id="79d8">In the end, the biggest difficulty here is <em>not a technical one</em>. It is about people:</p><ul><li id="9edf"><strong>Yourself</strong>, to accept to step out of your comfort zone. Hopefully you’ll see that, after all, going vanilla is not so hard and the framework stuff that you used to leverage is more over-complex than magic. Also, you will probably discover new APIs (WebComponents, ES6 Modules, Proxies, <code>MutationObserver</code>…), and that the web is more modern and powerful that you thought.</li><li id="6574"><strong>Others </strong>to convince them. They will be reluctant to do so, because anybody is reluctant to change for a journey they never attempted.</li></ul><p id="472a">Regarding that latter challenge, you will be told** that:</p><ul><li id="eac8">“you’re going to write <strong>your own framework</strong>”: no, you’re going to write an app instead of a framework.</li><li id="45cf">“you’re going to <strong>write <em>more</em> code</strong>”: maybe, maybe not so much (depending on your use of libraries) as this has to be compared with the boilerplate code required by frameworks. In any case, the overall loaded code size will be smaller,</li><li id="3b09">“you’re going to <strong>reinvent the wheel constantly</strong>”: of course not: not using a framework is just choosing to not comply with its predefined rules (configuration, lifecycle, refresh mechanism, etc.) but it’s not forgetting DRY principles and, as stated above, you can still (and should) use battle-tested third-party libraries.</li><li id="17f0">“you will <strong>write more code for every feature</strong>”: no, you’ll just use your own rules instead of the framework boilerplate.</li><li id="bcd0">“there will be <strong>no documentation</strong>”: no documentation about the framework for sure (since there’s isn’t any) but, as for<em> any</em> software development, you are still expected to document your app. Notably, the use of patterns will help to auto-document your software design. Your app’s code documentation is the one you care about ; having an additional framework’s documentation is just the consequence of having a framework.</li><li id="c7c3">“there will be <strong>no constraints or patterns to guide the developer</strong>”: no, nothing prevents you to enforce constraints if you need it (you just have to define contracts). The difference is that they will be the constraints of your choice, tailored for your app.</li><li id="b7c0">“<strong>you will miss performance improvements</strong>” such as the once-hyped Virtual Dom (<a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead" rel="noopener ugc nofollow" target="_blank">which is today challenged</a>, including by subsequent frameworks like Svelte or Aurelia): no, as those “performance improvements” are actually more need by the general-purpose nature of frameworks, not by custom apps. On the opposite, general purpose framework will more likely miss a number of performance improvements that a custom code can implement.</li><li id="2461"><strong>“You get this problem because you didn’t use a framework” </strong>Every difficulty (bug, delay, recruitment, etc) will be blamed on that unorthodox choice. Because most developers’ experience is that everything that has worked was using a framework, not using them will be assumed risky by default. This assumption will be considered as confirmed as soon as a problem will arise, whether it is related to not using a framework or not. They will forget all the similar issues they had when using framework.</li><li id="6b99"><strong>“We can’t find developers”</strong>: You’ll be told that it’s difficult to find developers who can develop vanilla code. That’s both true and false. True because a lot of developers (not speaking about managers) will find themselves more comfortable using known recipes such as frameworks. Candidates might feel a bit scared about building a webapp from scratch if they never did it once, or if they don’t know the basic web APIs well. False because, if you want to build quality apps, you should not look for this kind of developers. For sure it is currently easier to find any React developer, but what you need is not a React developer, but a good developer.</li><li id="3f3b"><strong>“You won’t get the code quality of frameworks”</strong>. For sure frameworks or libraries are usually written by major industry players or experienced developers. However, as we saw above, the code of frameworks is mostly related to framework-specific activities (components lifecycle, general-purpose refresh and optimizations, tooling, etc.), not your app. Furthermore, you can still make bad design choices and write poor code using frameworks. The quality of your application always depends more on the quality of your team, than the lack of blueprints.</li><li id="8ec8"><strong>“You won’t get same performance as frameworks”</strong>: No, we’ll get better performance. The marketed argument that framework include sophisticated technologies that can “improve performance” such as the “virtual DOM” (which allowed to bufferize DOM changes in order to limit their changes on it) is off-topic, as it relates to solving the performance drawbacks of a general-purpose solution. When the developer updates the DOM by him/herself, (s)he can get the best performance because (s)he will now if it’s worth bufferizing/caching it or if it’s pure overhead.</li></ul><figure><p><img alt="" src="https://miro.medium.com/max/1362/1*_EYRqPFaKWMSZjUvhC5Ueg.png" width="681" height="329" role="presentation"/></p><figcaption>With no surprise, the <a href="https://engineering.linecorp.com/en/blog/the-baseline-for-web-development-in-2022/#id-1/26ArticleEnglish-Comparingframeworkperformanceinlabtests" rel="noopener ugc nofollow" target="_blank">most performant frameworks</a> are the ones that adds less layers above vanilla code. Frameworks “optimizations” are more about compensating frameworks overhead.</figcaption></figure><p id="51bd">The vanilla approach to build a web app is <strong><em>not</em> about building your own framework</strong>. It is about building an app without a general purpose engine, to:</p><ul><li id="c7bb"><strong>avoid loose of control and the implied constraints</strong> (locking, upgrade cost, etc.)</li><li id="5f57"><strong>allow optimizations</strong> (performance, size, design).</li></ul><p id="7ebd">This implies writing <strong>only app-specific code</strong> (business and technical), including with the use of <strong>libraries</strong>. The only framework you should really focus on is <em>your </em>framework, the one which is application specific. This is the true “focus on your business” approach, and the most efficient one.</p><p id="0dc2">The good news is that <strong>it isn’t as hard as you may think</strong>, especially when using modern standards (evergreen browsers leveled up when necessary by polyfills).</p></div></div>
  </body>
</html>
