<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/whats-behind-just-implementation/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>What&#39;s hidden behind &#34;just implementation details&#34;</h1>
    
    <div id="readability-page-1" class="page"><div><p>Something I hear occasionally from some software people is something along the lines of: &#34;Well, the hard part is figured out, and the rest is just implementation details.&#34;
This typically means they&#39;ve created an algorithm to do something, and the rest of it is all the supporting activities to build an application or production system <em>around</em> this algorithm.
I hear variations on this also from software engineers who dismiss some web apps as &#34;just CRUD&#34; and thus trivial.</p>
<p>These statements don&#39;t usually come from malice, but they do still diminish the work of many software engineers.
There is so <em>much</em> complexity, difficulty, and beauty in the art of &#34;just getting it to production&#34; or &#34;just CRUD&#34; apps.
If these parts <em>were</em> trivial, we wouldn&#39;t need highly skilled software engineers to lead execution of precisely these areas at startups.</p>
<p>So, what <em>is</em> that complexity that underlies moving things toward production?
What&#39;s hard about something that&#39;s &#34;just CRUD&#34;?
And why do people not notice this?</p>

<p>When people say the hard part is shown and done, they&#39;re often referring to the part that&#39;s interesting to <em>them</em>, academically, and where we&#39;re not necessarily sure if it&#39;s even possible.
Beyond the fact that it&#39;s not necessarily harder to show something&#39;s possible than to do it, there&#39;s still quite a bit that&#39;s hard and necessary remaining.
These parts are unlikely to succeed if given to an inexperienced engineer.
Some of these things <em>are</em> deeply interesting and sometimes we&#39;re not even sure if they&#39;re possible, either, in the real world.</p>
<p>Here is a quick survey of some of the hard-and-maybe-impossible parts of getting things into production that I&#39;ve run into in my own work.</p>
<h2 id="getting-started">Getting started</h2>
<p>The first hard thing you run into is just <em>getting started</em>.
It seems almost trivial, but it takes way more time than people expect, even with past experience doing it.
This time spent is very important.
You could move quickly and cut corners, but the way you set things up at the beginning form the foundation of the project and have a ripple effect on everything you do afterwards.</p>
<p>Getting started well requires that you can make some good predictions about what your software will need.
Which foundational technologies should we use?
How should we structure the project?
What tooling will work well for us?
Answering these questions takes a lot of experience and a little magic.
You can kick the can down the road on some decisions, but that will cost you because a deferred decision often slows down development.
It&#39;s helpful to predict well as early as you can.</p>
<h2 id="creating-a-maintainable-design">Creating a maintainable design</h2>
<p>Writing software itself is also a hard problem.
In a research context, the maintainability of code is less critical: the code isn&#39;t being used long-term (usually), it&#39;s more self-contained, and it&#39;s worked on by a narrower set of maintainers.
For a production system, you want to make sure that it&#39;s designed soundly in a way that you can evolve and maintain for the life of the product.
And this code is long-term: it will be around for many years longer than you expect.</p>
<p>That&#39;s a big challenge, not least because we usually don&#39;t know what the future holds.
While we can try to predict it (as we do when getting started), some things are out of our control.
We have to make our code flexible enough to be able to add new features, but not so flexible that it starts to impede our ability to work on the product itself.</p>
<p>This is a <em>huge</em> topic, and it&#39;s one that is a really big part of getting things into production.</p>
<h2 id="making-it-robust-and-observable">Making it robust (and observable)</h2>
<p>We also have to make the system robust.
In a research context, things can fail or they can be unpredictable, and it&#39;s easier to deal with.
In a production setting, that results in bug reports and getting woken up at 2am <a href="https://ntietz.com/blog/lessons-from-my-first-on-call/">each night for two weeks</a>.
If it&#39;s not robust, things will go wrong.
I mean, they will anywayâ€”but more often.</p>
<p>So when things <em>do</em> go wrong, you have to have observability in place to be able to figure out what went wrong and why.
This is something people can dedicate whole careers to.
Figuring out what information is going to be helpful, how to record it, and then later how to use that information is a <em>big</em> field.</p>
<h2 id="user-experience-and-user-interface-design">User experience and user interface design</h2>
<p>Of course, there&#39;s also the whole question of how are <em>people</em> even going to use this?
A proof-of-concept or an algorithm can show you that something is possible if people do the right things.
And how are we going to make it so that that&#39;s a reasonable experience for them?
If the proof-of-concept requires a lot of data entry, maybe people won&#39;t do that!
Or maybe there are clever ways to approach it where it is a better experience, and more appetizing.</p>
<p>I&#39;ve tried my hand at frontend and user interface design enough times to really deeply respect that this is a very wide and deep field.
It&#39;s certainly far from trivial, and things that seem like they&#39;re sure to work will run into the pesky problem of &#34;people.&#34;
Until the prototype exists in a real-world thing that people can touch and use, including a UI, it&#39;s probably not really a sealed deal as working.</p>
<p>This particular area is incredibly interesting to me, because any issues that are discovered require collaboration between researchers, designers, product managers, and software engineers.
It&#39;s a multi-disciplinary festival!</p>
<h2 id="acceptable-performance">Acceptable performance</h2>
<p>We don&#39;t even have to aim for <em>good</em> performance to hit a snag.
Even getting to something <em>acceptable</em> is often pretty hard.
Prototypes are often slow or assume conditions that don&#39;t exist in the real world.</p>
<p>Maybe your prototype finishes its computations in a minute, but users will bounce off the page in a few seconds if they don&#39;t see something.
(We come back to UI/UX concerns!)
Or maybe it works if you have really powerful hardware, but it doesn&#39;t work on the devices your users will have.
Or it just falls down on production data sizes.</p>
<p>Whatever the case may be, this is a project in itself.
You have to understand what performance is required for production use, and how the prototype performs, and then do a lot of work to bridge that gap.
If you can.</p>

<p>In addition to all the normal concerns of going to production, &#34;just CRUD&#34; apps have some particular concerns that are sometimes missed.
An app that&#39;s really just CRUD is also <em>extremely</em> rare today, because they&#39;re typically dealing with complex associations of data or they need some trickier user interactions.</p>
<h2 id="designing-the-database">Designing the database</h2>
<p>CRUD apps are heralded as being simple because they expose the database design, so you have fairly standard patterns for the views in your app.
That assumes, though, that you have a database schema that&#39;s going to work to show users.
If the DB design and views are 1:1, then the DB design <em>is</em> user interface design, and how you design it has big UX implications.
If they&#39;re <em>not</em> 1:1, then your &#34;just CRUD&#34; app now requires creating views that wrap around the database schema with a lot of business logic, and you bring in a lot of the non-CRUD difficulties again.
Oh, and when you change your DB design?
Bye bye CRUD benefits!</p>
<h2 id="production-support-and-observability">Production support and observability</h2>
<p>As mentioned above, making things robust enough to withstand a production workload is hard.
You have the entire fields of SRE and DevOps because there is so much to consider here.
Reliability, observability, logging, alerting, deployment, change management, security.
Not to mention supporting users!</p>
<h2 id="you-don-t-escape-performance-here">You don&#39;t escape performance here</h2>
<p>Being CRUD doesn&#39;t make it so performance is trivial.
Your data might grow to be large, or your schema might be hard to scale up.
Who knows!
From all the other hidden complexity, it&#39;s easy to run into performance problems.</p>
<h2 id="background-jobs">Background jobs</h2>
<p>Many CRUD apps require background work to be done.
This might be pre-computing things, sending reminder emails, or processing asynchronous tasks.
There are some <a href="https://docs.celeryq.dev/en/stable/">standard</a> <a href="https://en.wikipedia.org/wiki/Sidekiq">ways</a> to do these jobs.</p>
<p>And when you set them up, you now get to manage extra servers, a message broker, and a distributed system.
Throw in observability and monitoring for the lot, and you&#39;ve really piled on quite a bit.</p>
<h2 id="user-login-and-permissions">User login and permissions</h2>
<p>When people want to use the system, you have to check permissions.
You also have to validate their credentials at the door to make sure they can actually log in.
Both of these are <em>very</em> nuanced, even if you&#39;re using a service provider, and have a lot of depth that you have to grok.</p>
<p>There are standard patterns for user logins.
User permissions are more commonly bespoke per application, with some shared patterns but a lot is highly domain specific.
Even so, there is a lot of complexity to wind up mired in here, especially once you start getting into SAML and SSO or other more intricate login mechanisms.</p>
<p>Even communicating about these is hard, because there are lots of different words for the concepts.
And the <a href="https://ntietz.com/blog/lets-say-instead-of-auth/">standard choices are bad</a>!</p>

<p>The thing about putting something into production is that each individual piece looks pretty easy when you talk about it in isolation.
We <em>know</em> how to make user logins.
We <em>know</em> how to design schemas.
We <em>know</em> how to profile for performance.
We <em>know</em> how to do background jobs.</p>
<p>But the pile of all of these together?
Each one of these can interact with the other pieces of the system.
They impact the design and implementation of other pieces.
And we expect all of them in the application!</p>
<p>It&#39;s a lot of things to know, and each of them is a field in itself.
A lot of the complexity is the breadth, and knowing what you need to know.
You can&#39;t solve it by hiring an expert in each individual thing, either.
You <em>have</em> to have people who can bridge the domains, or you&#39;ll end up with a mishmash of pieces from completely different jigsaw puzzles, none of which are the one you were trying to put together.</p>

<p>I don&#39;t think people set out to miss the complexity in other fields.
We don&#39;t wake up in the morning and say &#34;today I&#39;m going to call someone&#39;s work trivial!&#34;
(If you <em>do</em> wake up in the morning and say that, please stop.)</p>
<p>It&#39;s more that a lot of complexity is hidden, especially when people do their jobs well.
You get to see all the complexity in your own job, because it&#39;s what you wade through every day.
It&#39;s harder to see it in work you&#39;re less familiar with, because you don&#39;t have that same closeness.
Instead you just see people breeze through it, and you don&#39;t see the rough edges.</p>
<p>We do this a <em>lot</em> though.
Backend engineers have a history of belittling frontend engineers (I personally find frontend <em>much</em> harder, and also very <em>different</em>).
Systems programmers have a history of belittling web developers.
And we as a field tend to label other fields as lesser for being &#34;non-technical.&#34;</p>
<p>It&#39;s unfortunate, because there&#39;s such beauty out there!
Almost every job has complexity, and all the different roles I&#39;ve seen in tech are interesting and challenging.
In each of those jobs, there is the beauty of wrangling complexity into something useful, and making it look easy.</p>
<p>Instead, we should approach things we don&#39;t know about with curiosity.
Each time you think &#34;huh, that doesn&#39;t seem like it should take so long&#34; is an opportunity to figure out what complexity you&#39;re not seeing and gain a deeper appreciation.
Or, maybe you&#39;ll find out you <em>can</em> build Twitter in a weekend.
Who knows?</p>
<hr/>
<p>Thank you to <a href="https://www.linkedin.com/in/aanthony1243/">Adam Anthony</a> and Dan Reich for providing feedback to me on a draft of this post.</p>
<hr/>







</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://github.com/newsletter/">newsletter</a>. There is also an <a href="https://github.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
