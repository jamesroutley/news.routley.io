<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikipedia.org/wiki/Tacit_programming">Original</a>
    <h1>Tacit programming</h1>
    
    <div id="readability-page-1" class="page"><div>
							

						<p>From Wikipedia, the free encyclopedia</p>
					</div><div id="mw-content-text"><div lang="en" dir="ltr">
<p><b>Tacit programming</b>, also called <b>point-free style</b>, is a <a href="https://en.wikipedia.org/wiki/Programming_paradigm" title="Programming paradigm">programming paradigm</a> in which function definitions do not identify the <a href="https://en.wikipedia.org/wiki/Parameter_(computer_science)" title="Parameter (computer science)">arguments</a> (or &#34;points&#34;) on which they operate. Instead the definitions merely <a href="https://en.wikipedia.org/wiki/Function_composition_(computer_science)" title="Function composition (computer science)">compose</a> other functions, among which are <a href="https://en.wikipedia.org/wiki/Combinatory_logic" title="Combinatory logic">combinators</a> that manipulate the arguments. Tacit programming is of theoretical interest, because the strict use of composition results in programs that are well adapted for <a href="https://en.wikipedia.org/wiki/Equational_logic" title="Equational logic">equational</a> reasoning.<sup id="cite_ref-cunha2005_1-0"><a href="#cite_note-cunha2005-1">[1]</a></sup> It is also the natural style of certain <a href="https://en.wikipedia.org/wiki/Programming_languages" title="Programming languages">programming languages</a>, including <a href="https://en.wikipedia.org/wiki/APL_(programming_language)" title="APL (programming language)">APL</a> and its derivatives,<sup id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> and <a href="https://en.wikipedia.org/wiki/Concatenative_programming_language" title="Concatenative programming language">concatenative languages</a> such as <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>. The lack of argument naming gives point-free style a reputation of being unnecessarily obscure, hence the epithet &#34;pointless style&#34;.<sup id="cite_ref-cunha2005_1-1"><a href="#cite_note-cunha2005-1">[1]</a></sup>
</p><p><a href="https://en.wikipedia.org/wiki/Unix" title="Unix">Unix</a> <a href="https://en.wikipedia.org/wiki/Command-line_interface" title="Command-line interface">scripting</a> uses the paradigm with <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)" title="Pipeline (Unix)">pipes</a>.
</p>
<meta property="mw:PageProp/toc"/>
<h2><span id="Examples">Examples</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=1" title="Edit section: Examples"><span>edit</span></a><span>]</span></span></h2>
<h3><span id="Python">Python</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=2" title="Edit section: Python"><span>edit</span></a><span>]</span></span></h3>
<p>Tacit programming can be illustrated with the following <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" title="Python (programming language)">Python</a> code. A sequence of operations such as the following:
</p>
<div dir="ltr"><pre><span></span><span>def</span> <span>example</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>baz</span><span>(</span><span>bar</span><span>(</span><span>foo</span><span>(</span><span>x</span><span>)))</span>
</pre></div>
<p>... can be written in point-free style as the composition of a sequence of functions, without parameters:<sup id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>
</p>
<div dir="ltr"><pre><span></span><span>from</span> <span>functools</span> <span>import</span> <span>partial</span><span>,</span> <span>reduce</span>
<span>def</span> <span>compose</span><span>(</span><span>*</span><span>fns</span><span>):</span>
    <span>return</span> <span>partial</span><span>(</span><span>reduce</span><span>,</span> <span>lambda</span> <span>v</span><span>,</span> <span>fn</span><span>:</span> <span>fn</span><span>(</span><span>v</span><span>),</span> <span>fns</span><span>)</span>

<span>example</span> <span>=</span> <span>compose</span><span>(</span><span>foo</span><span>,</span> <span>bar</span><span>,</span> <span>baz</span><span>)</span>
</pre></div>
<p>For a more complex example, the Haskell code <code id="" dir="ltr">p = ((.) f) . g</code> can be translated as:
</p>
<div dir="ltr"><pre><span></span><span>p</span> <span>=</span> <span>partial</span><span>(</span><span>compose</span><span>,</span> <span>partial</span><span>(</span><span>compose</span><span>,</span> <span>f</span><span>),</span> <span>g</span><span>)</span>
</pre></div>
<h3><span id="Functional_programming">Functional programming</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=3" title="Edit section: Functional programming"><span>edit</span></a><span>]</span></span></h3>
<p>A simple example (in <a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>) is a program which computes the sum of a list of numbers. We can define the sum function recursively using a <i>pointed</i> style (cf. <a href="https://en.wikipedia.org/wiki/Value-level_programming" title="Value-level programming"><i>value</i>-level programming</a>) as:
</p>
<div dir="ltr"><pre><span></span><span>sum</span><span> </span><span>(</span><span>x</span><span>:</span><span>xs</span><span>)</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>sum</span><span> </span><span>xs</span>
<span>sum</span><span> </span><span>[]</span><span> </span><span>=</span><span> </span><span>0</span>
</pre></div>
<p>However, using a <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" title="Fold (higher-order function)">fold</a> we can replace this with:
</p>

<p>And then the argument is not needed, so this simplifies to
</p>

<p>which is point-free.
</p><p>Another example uses <a href="https://en.wikipedia.org/wiki/Function_composition_(computer_science)" title="Function composition (computer science)">function composition</a>:
</p>

<p>The following Haskell-like pseudo-code exposes how to reduce a function definition to its point-free equivalent:
</p>
<div dir="ltr"><pre><span></span><span>p</span><span> </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>\</span><span>y</span><span> </span><span>-&gt;</span><span> </span><span>\</span><span>z</span><span> </span><span>-&gt;</span><span> </span><span>f</span><span> </span><span>(</span><span>g</span><span> </span><span>x</span><span> </span><span>y</span><span>)</span><span> </span><span>z</span>
<span>  </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>\</span><span>y</span><span> </span><span>-&gt;</span><span> </span><span>f</span><span> </span><span>(</span><span>g</span><span> </span><span>x</span><span> </span><span>y</span><span>)</span>
<span>  </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>\</span><span>y</span><span> </span><span>-&gt;</span><span> </span><span>(</span><span>f</span><span> </span><span>.</span><span> </span><span>(</span><span>g</span><span> </span><span>x</span><span>))</span><span> </span><span>y</span>
<span>  </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>f</span><span> </span><span>.</span><span> </span><span>(</span><span>g</span><span> </span><span>x</span><span>)</span>
<span>  </span><span>(</span><span>*</span><span> </span><span>Here</span><span> </span><span>the</span><span> </span><span>infix</span><span> </span><span>compose</span><span> </span><span>operator</span><span> </span><span>&#34;.&#34;</span><span> </span><span>is</span><span> </span><span>used</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>curried</span><span> </span><span>function</span><span>.</span><span> </span><span>*</span><span>)</span>
<span>  </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>((</span><span>.</span><span>)</span><span> </span><span>f</span><span>)</span><span> </span><span>(</span><span>g</span><span> </span><span>x</span><span>)</span>
<span>  </span><span>=</span><span> </span><span>\</span><span>x</span><span> </span><span>-&gt;</span><span> </span><span>(((</span><span>.</span><span>)</span><span> </span><span>f</span><span>)</span><span> </span><span>.</span><span> </span><span>g</span><span>)</span><span> </span><span>x</span>

<span>p</span><span> </span><span>=</span><span> </span><span>((</span><span>.</span><span>)</span><span> </span><span>f</span><span>)</span><span> </span><span>.</span><span> </span><span>g</span>
</pre></div>
<p>Finally, to see a complex example imagine a map filter program which takes a list, applies a function to it, and then filters the elements based on a criterion
</p>
<div dir="ltr"><pre><span></span><span>mf</span><span> </span><span>criteria</span><span> </span><span>operator</span><span> </span><span>list</span><span> </span><span>=</span><span> </span><span>filter</span><span> </span><span>criteria</span><span> </span><span>(</span><span>map</span><span> </span><span>operator</span><span> </span><span>list</span><span>)</span>
</pre></div>
<p>It can be expressed point-free<sup id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup> as 
</p>
<div dir="ltr"><pre><span></span><span>mf</span><span> </span><span>=</span><span> </span><span>(</span><span>.</span><span> </span><span>map</span><span>)</span><span> </span><span>.</span><span> </span><span>(</span><span>.</span><span>)</span><span> </span><span>.</span><span> </span><span>filter</span>
</pre></div><p>Note that, as stated previously, the points in &#39;point-free&#39; refer to the arguments, not to the use of dots; a common misconception.<sup id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>
</p><p>A few programs have been written to automatically convert a Haskell expression to a point-free form.
</p>
<h3><span id="APL_family">APL family</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=4" title="Edit section: APL family"><span>edit</span></a><span>]</span></span></h3>
<p>In <a href="https://en.wikipedia.org/wiki/J_(programming_language)" title="J (programming language)">J</a>, the same sort of point-free code occurs in a function made to compute the average of a list (array) of numbers:
</p>

<p><code>+/</code> sums the items of the array by mapping (<code>/</code>) summation (<code>+</code>) to the array. <code>%</code> divides the sum by the number of elements (<code>#</code>) in the array.
</p><p><a href="https://en.wikipedia.org/wiki/Euler%27s_formula" title="Euler&#39;s formula">Euler&#39;s formula</a> <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aab1fcd1a6db5cc6678bb9cbd871580eeeb86eda" aria-hidden="true" alt="{\displaystyle e^{ix}=\cos x+i\sin x,}"/></span> expressed tacitly:
</p>
<div dir="ltr"><pre><span></span><span>cos</span><span> </span><span>=:</span><span> </span><span>2</span><span> </span><span>o</span><span>.</span><span> </span><span>]</span>
<span>sin</span><span> </span><span>=:</span><span> </span><span>1</span><span> </span><span>o</span><span>.</span><span> </span><span>]</span>
<span>Euler</span><span> </span><span>=:</span><span> </span><span>^@</span><span>j</span><span>.</span><span> </span><span>=</span><span> </span><span>cos</span><span> </span><span>j</span><span>.</span><span> </span><span>sin</span>
</pre></div>
<p>(<code>j.</code> is a primitive function whose monadic definition is <code>0j1</code> times x and whose dyadic definition is <code>x+0j1×y</code>.)  The same tacit computations expressed in <a href="https://en.wikipedia.org/wiki/APL_(programming_language)#Dyalog_APL" title="APL (programming language)">Dyalog APL</a>:
</p>
<div dir="ltr"><pre><span></span><span>avg</span><span> </span><span>←</span><span> </span><span>+</span><span>⌿</span><span> </span><span>÷</span><span> </span><span>≢</span>

<span>cos</span><span> </span><span>←</span><span> </span><span>2</span><span> </span><span>○</span><span> </span><span>⊢</span>
<span>sin</span><span> </span><span>←</span><span> </span><span>1</span><span> </span><span>○</span><span> </span><span>⊢</span>
<span>EulerCalc</span><span>←</span><span>   </span><span>cos</span><span> </span><span>+</span><span> </span><span>0j1</span><span> </span><span>×</span><span> </span><span>sin</span><span>   </span><span>⍝ 0j1 is what&#39;s usually written as i </span>
<span>EulerDirect</span><span>←</span><span> </span><span>*</span><span>0J1</span><span>×⊢</span><span>            </span><span>⍝ Same as ¯12○⊢ </span>
<span>⍝ Do the 2 methods produce the same result? </span>
<span>EulerCheck</span><span>←</span><span> </span><span>EulerDirect</span><span>=</span><span>EulerCalc</span>
<span>EulerCheck</span><span> </span><span>¯1</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span>     </span>
<span>1</span><span> </span><span>1</span><span> </span><span>1</span><span> </span><span>1</span><span>   </span>
<span>⍝ Yes, so far so good!</span>
</pre></div>
<h3><span id="Stack-based">Stack-based</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=5" title="Edit section: Stack-based"><span>edit</span></a><span>]</span></span></h3>
<p>In <a href="https://en.wikipedia.org/wiki/Stack-oriented_programming_language" title="Stack-oriented programming language">stack-oriented programming languages</a> (and <a href="https://en.wikipedia.org/wiki/Concatenative_programming_language" title="Concatenative programming language">concatenative ones</a>, most of which are stack based<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (January 2020)">citation needed</span></a></i>]</sup>), point-free methods are commonly used. For example, a procedure to compute the <a href="https://en.wikipedia.org/wiki/Fibonacci_number" title="Fibonacci number">Fibonacci numbers</a> might look like the following in <a href="https://en.wikipedia.org/wiki/PostScript" title="PostScript">PostScript</a>:
</p>
<div dir="ltr"><pre><span></span><span>/fib</span>
<span>{</span>
<span>   </span><span>dup</span><span> </span><span>dup</span><span> </span><span>1</span><span> </span><span>eq</span><span> </span><span>exch</span><span> </span><span>0</span><span> </span><span>eq</span><span> </span><span>or</span><span> </span><span>not</span>
<span>   </span><span>{</span>
<span>      </span><span>dup</span><span> </span><span>1</span><span> </span><span>sub</span><span> </span><span>fib</span>
<span>      </span><span>exch</span><span> </span><span>2</span><span> </span><span>sub</span><span> </span><span>fib</span>
<span>      </span><span>add</span>
<span>   </span><span>}</span><span> </span><span>if</span>
<span>}</span><span> </span><span>def</span>
</pre></div>
<h3><span id="Pipelines">Pipelines</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=6" title="Edit section: Pipelines"><span>edit</span></a><span>]</span></span></h3>
<h4><span id="Unix_pipeline">Unix pipeline</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=7" title="Edit section: Unix pipeline"><span>edit</span></a><span>]</span></span></h4>

<p>In Unix scripting the functions are computer programs which receive data from <a href="https://en.wikipedia.org/wiki/Standard_streams" title="Standard streams">standard input</a> and send the results to <a href="https://en.wikipedia.org/wiki/Standard_streams" title="Standard streams">standard output</a>.  For example,
</p>
<div dir="ltr"><pre><span></span>sort<span> </span><span>|</span><span> </span>uniq<span> </span>-c<span> </span><span>|</span><span> </span>sort<span> </span>-rn
</pre></div>
<p>is a tacit or point-free composition which returns the counts of its arguments and the arguments, in the order of decreasing counts.  The &#39;sort&#39; and &#39;uniq&#39; are the functions, the &#39;-c&#39; and &#39;-rn&#39; control the functions, but the arguments are not mentioned.  The pipe &#39;|&#39; is the composition operator.
</p><p>Due to the way pipelines work, it is only normally possible to pass one &#34;argument&#34; at a time in the form of a pair of standard input/output stream.  Although extra <a href="https://en.wikipedia.org/wiki/File_descriptor" title="File descriptor">file descriptors</a> can be opened from <a href="https://en.wikipedia.org/wiki/Named_pipe" title="Named pipe">named pipes</a>, this no longer constitutes a point-free style.
</p>
<h4><span id="jq">jq</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=8" title="Edit section: jq"><span>edit</span></a><span>]</span></span></h4>
<p><a href="https://en.wikipedia.org/wiki/Jq_(programming_language)" title="Jq (programming language)">jq</a> is a JSON-oriented programming language in which
the &#39;|&#39; symbol is used to connect filters to form a pipeline
in a familiar way. For example:
</p>
<pre>   [1,2] | add
</pre>
<p>evaluates to 3.  (Yes, the JSON array is a jq filter that evaluates to an array.)
</p><p>Although similar to Unix pipelines, jq pipelines allow the
incoming data to be sent to more than one recipient on the
RHS of the &#39;|&#39; as though in parallel.  For example, the program `add/length`
will compute the average of the numbers in an array, so that:
</p>
<pre>   [1,2] | add/length
</pre>
<p>evaluates to 1.5
</p><p>Similarly:
</p>
<pre>   [1,2] | [length, add, add/length]
</pre>
<p>evaluates to [2,3,1.5]
</p><p>A dot (&#39;.&#39;) can be used to define an attachment point on the RHS, e.g.:
</p>
<pre>   1 | [., .]
</pre>
<p>evaluates to [1,1]
</p><p>and similarly:
</p>
<pre>   2 | pow(.; .)
</pre>
<p>evaluates to 4 since pow(x;y) is x to the power y.
</p>
<h5><span id="Fibonacci_sequence">Fibonacci sequence</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=9" title="Edit section: Fibonacci sequence"><span>edit</span></a><span>]</span></span></h5>
<p>A tacit jq program for generating the Fibonacci sequence would be:
</p>
<pre>   [0,1] | recurse( [last, add] ) | first
</pre>
<p>Here, [0,1] is the initial pair to be taken as the first two items
in the Fibonacci sequence. (The pair [1,1] could likewise be used for
the variant definition.)
</p><p>The alphabetic tokens are built-in filters: `first` and `last`
emit the first and last elements of their input arrays respectively;
and `recurse(f)` applies a filter, f, to its input recursively.
</p><p>jq also allows new filters to be defined in a tacit style, e.g.:
</p>
<pre>   def fib: [0,1] | recurse( [last, add] ) | first;
</pre>
<h5><span id="Composition_of_unary_functions">Composition of unary functions</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=10" title="Edit section: Composition of unary functions"><span>edit</span></a><span>]</span></span></h5>
<p>In the section on Python in this article, the following Python definition is considered:
</p>
<div dir="ltr"><pre><span></span><span>def</span> <span>example</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>baz</span><span>(</span><span>bar</span><span>(</span><span>foo</span><span>(</span><span>x</span><span>)))</span>
</pre></div>
<p>In point-free style, this could be written in Python as:
</p>
<div dir="ltr"><pre><span></span><span>example</span> <span>=</span> <span>compose</span><span>(</span><span>foo</span><span>,</span> <span>bar</span><span>,</span> <span>baz</span><span>)</span>
</pre></div>
<p>In jq, the equivalent point-free definition would be:
</p>
<pre>   def example: foo | bar | baz;
</pre>
<h2><span id="See_also">See also</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=11" title="Edit section: See also"><span>edit</span></a><span>]</span></span></h2>
<ul><li><a href="https://en.wikipedia.org/wiki/Combinatory_logic" title="Combinatory logic">Combinatory logic</a></li>
<li><a href="https://en.wikipedia.org/wiki/Concatenative_programming_language" title="Concatenative programming language">Concatenative programming language</a></li>
<li><a href="https://en.wikipedia.org/wiki/Function-level_programming" title="Function-level programming">Function-level programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Joy_(programming_language)" title="Joy (programming language)">Joy (programming language)</a>, modern highly tacit language</li></ul>
<h2><span id="References">References</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=12" title="Edit section: References"><span>edit</span></a><span>]</span></span></h2>

<h2><span id="External_links">External links</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Tacit_programming&amp;action=edit&amp;section=13" title="Edit section: External links"><span>edit</span></a><span>]</span></span></h2>
<ul><li><a rel="nofollow" href="https://function-level.github.io/">From Function-Level Programming to Pointfree Style</a></li>
<li><a rel="nofollow" href="http://portal.acm.org/citation.cfm?id=114065&amp;dl=GUIDE&amp;coll=GUIDE">Pure Functions in APL and J</a> How to use tacit programming in any APL-like language</li>
<li><a rel="nofollow" href="http://dirkgerrits.com/publications/john-backus.pdf#section.8">Closed applicative languages 1971 - 1976 ff</a>, in John W. Backus (Publications)</li></ul>

<!-- 
NewPP limit report
Parsed by mw1391
Cached time: 20240223043317
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.275 seconds
Real time usage: 1.219 seconds
Preprocessor visited node count: 806/1000000
Post‐expand include size: 46134/2097152 bytes
Template argument size: 988/2097152 bytes
Highest expansion depth: 12/100
Expensive parser function count: 20/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 32468/5000000 bytes
Lua time usage: 0.155/10.000 seconds
Lua memory usage: 4524971/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00% 1133.043      1 -total
  6.76%   76.569      3 Template:Navbox
  6.73%   76.265      1 Template:Reflist
  6.55%   74.229      1 Template:Short_description
  6.35%   71.951      1 Template:Programming_paradigms_navbox
  5.58%   63.221      2 Template:Cite_web
  4.34%   49.193      2 Template:Pagetype
  3.03%   34.313      1 Template:Cn
  2.46%   27.856      1 Template:Fix
  1.71%   19.427      2 Template:Category_handler
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:5158722-0!canonical and timestamp 20240223043317 and revision id 1202044976. Rendering was triggered because: page-view
 -->
</div><!--esi <esi:include src="/esitest-fa8a495983347898/content" /> -->
</div></div>
  </body>
</html>
