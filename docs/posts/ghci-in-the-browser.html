<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vaibhavsagar.com/blog/2024/07/03/ghci-in-the-browser/">Original</a>
    <h1>GHCi in the Browser</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            

            <p>
    Posted on  3 July 2024
    
</p>


<p>I’m happy to announce that you can now run GHCi entirely in your browser (if
your browser supports WebAssembly and you’re willing to download approximately
220MB of compressed WASM).</p>
<h2 id="where">Where?</h2>
<p><a href="https://vaibhavsagar.com/amd64-ghc-wasi-demo">Here</a>.</p>
<h2 id="how">How?</h2>
<p>I used <a href="https://github.com/ktock/container2wasm"><code>container2wasm</code></a> to convert
an OCI image containing GHC to a WASM blob that I could serve using a lightly
modified <a href="https://github.com/ktock/container2wasm-demo"><code>container2wasm-demo</code></a>.
If you’re curious, the website repo is
<a href="https://github.com/vaibhavsagar/amd64-ghc-wasi-demo">here</a> and the chunks of
WASM are <a href="https://github.com/vaibhavsagar/amd64-ghc-wasi-container">here</a>.</p>
<p>As of this writing, only images with an uncompressed size below 2GB can be used
with <code>container2wasm</code> (tracked
<a href="https://github.com/ktock/container2wasm/issues/230">here</a>) and my initial
attempts using an OCI image generated by Nix were unsuccessful because of
duplicate filenames (tracked
<a href="https://github.com/ktock/container2wasm/issues/263">here</a>).</p>
<h2 id="why">Why?</h2>
<p>I’ve wanted to do something like this for a long time. In my capacity as
a maintainer of <a href="https://github.com/IHaskell/IHaskell">IHaskell</a>, installation
issues are the most common category of support request I receive. Wouldn’t it
be great if a user could simply navigate to a webpage and have a correctly
configured Jupyter notebook waiting for them? The Jupyter folks also seem to be
thinking the same thing, based on the existence of
<a href="https://jupyterlite.readthedocs.io/en/stable/">JupyterLite</a>. Unfortunately
we’re a long way off from Haskell support<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>, but I hope my proof-of-concept
shows that this is possible.</p>
<p>Even outside Jupyter-land, a fully-functional GHCi REPL in the browser would be
generally useful. For example, currently
<a href="https://www.haskell.org/">Haskell.org</a> has a “Try it!” section where you can
enter expressions, which are currently passed to a backend server to execute.
A client-side GHCi could provide a better experience and allow us to get rid of
the backend entirely. Another wild idea: the Hackage documentation for
a package could provide a REPL with that package pre-installed for users to try
out immediately. Wouldn’t that be amazing?</p>
<h2 id="why-not-compile-ghci-directly-to-javascriptwasm-using-the-new-backends">Why not compile GHCi directly to JavaScript/WASM using the new backends?</h2>
<p>I don’t think that would work/result in a usable Haskell interpreter with
access to <code>base</code> or other GHC boot packages. As of this writing it is on <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript-backend?version_id=bff087ec5b0231e12b3a8d902522f3d41aed530b">the
roadmap for GHC
9.12+</a>
so hopefully that will eventually be possible (tracked
<a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25067">here</a>). If you get this
working I’d love to know about it!</p>


        </div></div>
  </body>
</html>
