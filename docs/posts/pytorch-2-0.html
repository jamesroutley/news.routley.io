<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pytorch.org/get-started/pytorch-2.0/">Original</a>
    <h1>PyTorch 2.0</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div data-id="">
        <article><h2 id="overview">Overview</h2>

<p>Introducing PyTorch 2.0, our first steps toward the next generation 2-series release of PyTorch. Over the last few years we have innovated and iterated from PyTorch 1.0 to the most recent 1.13 and moved to the newly formed PyTorch Foundation, part of the Linux Foundation.</p>

<p>PyTorch’s biggest strength beyond our amazing community is that we continue as a first-class Python integration, imperative style, simplicity of the API and options. PyTorch 2.0 offers the same eager-mode development and user experience, while fundamentally changing and supercharging how PyTorch operates at compiler level under the hood. We are able to provide faster performance and support for Dynamic Shapes and Distributed.</p>

<p>Below you will find all the information you need to better understand what PyTorch 2.0 is, where it’s going and more importantly how to get started today (e.g., tutorial, requirements, models, common FAQs). There is still a lot to learn and develop but we are looking forward to community feedback and contributions to make the 2-series better and thank you all who have made the 1-series so successful.</p>

<h2 id="pytorch-2x-faster-more-pythonic-and-as-dynamic-as-ever">PyTorch 2.x: faster, more pythonic and as dynamic as ever</h2>

<p>Today, we announce <code>torch.compile</code>, a feature that pushes PyTorch performance to new heights and starts the move for parts of PyTorch from C++ back into Python. We believe that this is a substantial new direction for PyTorch – hence we call it 2.0. <code>torch.compile</code> is a fully additive (and optional) feature and hence 2.0 is 100% backward compatible by definition.</p>

<p>Underpinning <code>torch.compile</code> are new technologies – TorchDynamo, AOTAutograd, PrimTorch and TorchInductor.</p>

<ul>
  <li>
    <p><strong>TorchDynamo</strong> captures PyTorch programs safely using Python Frame Evaluation Hooks and is a significant innovation that was a result of 5 years of our R&amp;D into safe graph capture</p>
  </li>
  <li>
    <p><strong>AOTAutograd</strong> overloads PyTorch’s autograd engine as a tracing autodiff for generating ahead-of-time backward traces.</p>
  </li>
  <li><strong>PrimTorch</strong> canonicalizes ~2000+ PyTorch operators down to a closed set of ~250 primitive operators that developers can target to build a complete PyTorch backend. This substantially lowers the barrier of writing a PyTorch feature or backend.</li>
  <li><strong>TorchInductor</strong> is a deep learning compiler that generates fast code for multiple accelerators and backends. For NVIDIA GPUs, it uses OpenAI Triton as a key building block.</li>
</ul>

<p>TorchDynamo, AOTAutograd, PrimTorch and TorchInductor are written in Python and support dynamic shapes (i.e. the ability to send in Tensors of different sizes without inducing a recompilation), making them flexible, easily hackable and lowering the barrier of entry for developers and vendors.</p>

<p>To validate these technologies, we used a diverse set of 163 open-source models across various machine learning domains. We built this benchmark carefully to include tasks such as Image Classification, Object Detection, Image Generation, various NLP tasks such as Language Modeling, Q&amp;A, Sequence Classification, Recommender Systems and Reinforcement Learning. We separate the benchmarks into three categories:</p>

<ul>
  <li>46 models from <a href="https://github.com/huggingface/transformers" target="_blank">HuggingFace Transformers</a></li>
  <li>61 models from <a href="https://github.com/rwightman/pytorch-image-models" target="_blank">TIMM</a>: a collection of state-of-the-art PyTorch image models by Ross Wightman</li>
  <li>56 models from <a href="https://github.com/pytorch/benchmark/" target="_blank">TorchBench</a>: a curated set of popular code-bases from across github</li>
</ul>

<!--
- 46 models from [HuggingFace Transformers](https://github.com/huggingface/transformers)
- 61 models from [TIMM](https://github.com/rwightman/pytorch-image-models): a collection of state-of-the-art PyTorch image models by Ross Wightman
- 56 models from [TorchBench](https://github.com/pytorch/benchmark/): a curated set of popular code-bases from across github -->

<p>We don’t modify these open-source models except to add a <code>torch.compile</code> call wrapping them.</p>

<p>We then measure speedups and validate accuracy across these models. Since speedups can be dependent on data-type, we measure speedups on both float32 and Automatic Mixed Precision (AMP). We report an uneven weighted average speedup of <em>0.75 * AMP + 0.25 * float32</em> since we find AMP is more common in practice.</p>

<p>Across these 163 open-source models <code>torch.compile</code> works 93% of time, and the model runs 43% faster in training on an NVIDIA A100 GPU. At Float32 precision, it runs 21% faster on average and at AMP Precision it runs 51% faster on average.</p>

<p><strong>Caveats:</strong> On a desktop-class GPU such as a NVIDIA 3090, we’ve measured that speedups are lower than on server-class GPUs such as A100. As of today, our default backend TorchInductor supports CPUs and NVIDIA Volta and Ampere GPUs. It does not (yet) support other GPUs, xPUs or older NVIDIA GPUs.</p>

<p>
<img src="https://pytorch.org/assets/images/Caveats.jpg" width="90%"/>
</p><center> <u> Speedups for torch.compile against eager mode on an NVIDIA A100 GPU </u> </center>


<p><strong>Try it:</strong> <code>torch.compile</code> is in the early stages of development. Starting today, you can try out <code>torch.compile</code> in the <code>nightly</code> binaries. We expect to ship the first stable 2.0 release in early March 2023.</p>

<p>In the roadmap of PyTorch 2.x we hope to push the compiled mode further and further in terms of performance and scalability. Some of this work is in-flight, as we talked about at the Conference today. Some of this work has not started yet. Some of this work is what we hope to see, but don’t have the bandwidth to do ourselves. If you are interested in contributing, come chat with us at the <strong>Ask the Engineers: 2.0 Live Q&amp;A Series</strong> starting this month (details at the end of this post) and/or via Github / Forums.</p>

<p>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img2.png" width="90%"/>
</p>

<h3 id="testimonials">Testimonials</h3>

<p>Here is what some of PyTorch’s users have to say about our new direction:</p>

<p><strong>Sylvain Gugger</strong> the <strong>primary maintainer of HuggingFace transformers</strong>:</p>

<p><em>“With just one line of code to add, PyTorch 2.0 gives a speedup between 1.5x and 2.x in training Transformers models. This is the most exciting thing since mixed precision training was introduced!”</em></p>

<p><strong>Ross Wightman the primary maintainer of TIMM</strong> (one of the largest vision model hubs within the PyTorch ecosystem):</p>

<p><em>“It just works out of the box with majority of TIMM models for inference and train workloads with no code changes”</em></p>

<p><strong>Luca Antiga</strong> the <strong>CTO of grid.ai</strong> and one of the <strong>primary maintainers of PyTorch Lightning</strong></p>

<p><em>“PyTorch 2.0 embodies the future of deep learning frameworks. The possibility to capture a PyTorch program with effectively no user intervention and get massive on-device speedups and program manipulation out of the box unlocks a whole new dimension for AI developers.”</em></p>

<h2 id="motivation">Motivation</h2>

<p>Our philosophy on PyTorch has always been to keep flexibility and hackability our top priority, and performance as a close second. We strived for:</p>

<ol>
  <li>High-Performance eager execution</li>
  <li>Pythonic internals</li>
  <li>Good abstractions for Distributed, Autodiff, Data loading, Accelerators, etc.</li>
</ol>

<p>Since we launched PyTorch in 2017, hardware accelerators (such as GPUs) have become ~15x faster in compute and about ~2x faster in the speed of memory access. So, to keep eager execution at high-performance, we’ve had to move substantial parts of PyTorch internals into C++. Moving internals into C++ makes them less hackable and increases the barrier of entry for code contributions.</p>

<p>From day one, we knew the performance limits of eager execution. In July 2017, we started our first research project into developing a Compiler for PyTorch. The compiler needed to make a PyTorch program fast, but not at the cost of the PyTorch experience. Our key criteria was to preserve certain kinds of flexibility – support for dynamic shapes and dynamic programs which researchers use in various stages of exploration.</p>

<p>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img3.gif" width="90%"/>
</p>

<h2 id="technology-overview">Technology Overview</h2>

<p>Over the years, we’ve built several compiler projects within PyTorch. Let us break down the compiler into three parts:</p>

<ul>
  <li>graph acquisition</li>
  <li>graph lowering</li>
  <li>graph compilation</li>
</ul>

<p>Graph acquisition was the harder challenge when building a PyTorch compiler.</p>

<p>In the past 5 years, we built <code>torch.jit.trace</code>, TorchScript, FX tracing, Lazy Tensors. But none of them felt like they gave us everything we wanted. Some were flexible but not fast, some were fast but not flexible and some were neither fast nor flexible. Some had bad user-experience (like being silently wrong). While TorchScript was promising, it needed substantial changes to your code and the code that your code depended on. This need for substantial change in code made it a non-starter for a lot of PyTorch users.</p>

<p>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img4.jpg" width="90%"/>
</p><center><u>The PyTorch compilation process</u></center>


<h3 id="torchdynamo-acquiring-graphs-reliably-and-fast">TorchDynamo: Acquiring Graphs reliably and fast</h3>

<p>Earlier this year, we started working on TorchDynamo, an approach that uses a CPython feature introduced in <a href="https://peps.python.org/pep-0523/">PEP-0523</a> called the Frame Evaluation API. We took a data-driven approach to validate its effectiveness on Graph Capture. We used 7,000+ Github projects written in PyTorch as our validation set. While TorchScript and others struggled to even acquire the graph 50% of the time, often with a big overhead, TorchDynamo acquired the graph <a href="https://dev-discuss.pytorch.org/t/torchdynamo-update-8-torchdynamo-passed-correctness-check-on-7k-github-models/663">99% of the time</a>, correctly, safely and with negligible overhead – without needing any changes to the original code. This is when we knew that we finally broke through the barrier that we were struggling with for many years in terms of flexibility and speed.</p>

<h3 id="torchinductor-fast-codegen-using-a-define-by-run-ir">TorchInductor: fast codegen using a define-by-run IR</h3>

<p>For a new compiler backend for PyTorch 2.0, we took inspiration from how our users were writing high performance custom kernels: increasingly using the <a href="https://github.com/openai/triton">Triton</a> language. We also wanted a compiler backend that used similar abstractions to PyTorch eager, and was general purpose enough to support the wide breadth of features in PyTorch. TorchInductor uses a pythonic define-by-run loop level IR to automatically map PyTorch models into generated Triton code on GPUs and C++/OpenMP on CPUs. TorchInductor’s core loop level IR contains only ~50 operators, and it is implemented in Python, making it easily hackable and extensible.</p>

<h3 id="aotautograd-reusing-autograd-for-ahead-of-time-graphs">AOTAutograd: reusing Autograd for ahead-of-time graphs</h3>

<p>For PyTorch 2.0, we knew that we wanted to accelerate training. Thus, it was critical that we not only captured user-level code, but also that we captured backpropagation. Moreover, we knew that we wanted to reuse the existing battle-tested PyTorch autograd system. AOTAutograd leverages PyTorch’s <strong>torch_dispatch</strong> extensibility mechanism to trace through our Autograd engine, allowing us to capture the backwards pass “ahead-of-time”. This allows us to accelerate both our forwards <em>and</em> backwards pass using TorchInductor.</p>

<h3 id="primtorch-stable-primitive-operators">PrimTorch: Stable Primitive operators</h3>

<p>Writing a backend for PyTorch is challenging. PyTorch has 1200+ operators, and 2000+ if you consider various overloads for each operator.</p>

<p>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img5.png" width="90%"/>
</p><center> <i> <u> A breakdown of the 2000+ PyTorch operators </u></i> </center>


<p>Hence, writing a backend or a cross-cutting feature becomes a draining endeavor. Within the PrimTorch project, we are working on defining smaller and stable operator sets. PyTorch programs can consistently be lowered to these operator sets. We aim to define two operator sets:</p>

<ul>
  <li>Prim ops with about ~250 operators, which are fairly low-level. These are suited for compilers because they are low-level enough that you need to fuse them back together to get good performance.</li>
  <li>ATen ops with about ~750 canonical operators and suited for exporting as-is. These are suited for backends that already integrate at the ATen level or backends that won’t have compilation to recover performance from a lower-level operator set like Prim ops.</li>
</ul>

<p>We discuss more about this topic below in the Developer/Vendor Experience section</p>

<h2 id="user-experience">User Experience</h2>

<p>We introduce a simple function <code>torch.compile</code> that wraps your model and returns a compiled model.</p>

<div><div><pre><code><span>compiled_model</span> <span>=</span> <span>torch</span><span>.</span><span>compile</span><span>(</span><span>model</span><span>)</span>
</code></pre></div></div>

<p>This <code>compiled_model</code> holds a reference to your model and compiles the <code>forward</code> function to a more optimized version. When compiling the model, we give a few knobs to adjust it:</p>

<div><div><pre><code>def torch.compile(model: Callable,
*,
mode: Optional[str] = &#34;default&#34;,
dynamic: bool = False,
fullgraph:bool = False,
backend: Union[str, Callable] = &#34;inductor&#34;,
# advanced backend options go here as kwargs
**kwargs
) -&gt; torch._dynamo.NNOptimizedModule
</code></pre></div></div>

<ul>
  <li>
    <p><strong>mode</strong> specifies what the compiler should be optimizing while compiling.</p>

    <ul>
      <li>The default mode is a preset that tries to compile efficiently without taking too long to compile or using extra memory.</li>
      <li>Other modes such as <code>reduce-overhead</code> reduce the framework overhead by a lot more, but cost a small amount of extra memory. <code>max-autotune</code> compiles for a long time, trying to give you the fastest code it can generate.</li>
    </ul>
  </li>
  <li><strong>dynamic</strong> specifies whether to enable the code path for Dynamic Shapes. Certain compiler optimizations cannot be applied to dynamic shaped programs. Making it explicit whether you want a compiled program with dynamic shapes or with static shapes will help the compiler give you better optimized code.</li>
  <li><strong>fullgraph</strong> is similar to Numba’s <code>nopython</code>. It compiles the entire program into a single graph or gives an error explaining why it could not do so. Most users don’t need to use this mode. If you are very performance conscious, then you try to use it.</li>
  <li><strong>backend</strong> specifies which compiler backend to use. By default, TorchInductor is used, but there are a few others available.</li>
</ul>

<p>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img6.png" width="90%"/>
</p>

<p>The compile experience intends to deliver most benefits and the most flexibility in the default mode. Here is a mental model of what you get in each mode.</p>

<p>Now, let us look at a full example of compiling a real model and running it (with random data)</p>

<div><div><pre><code><span>import</span> <span>torch</span>
<span>import</span> <span>torchvision.models</span> <span>as</span> <span>models</span>

<span>model</span> <span>=</span> <span>models</span><span>.</span><span>resnet18</span><span>().</span><span>cuda</span><span>()</span>
<span>optimizer</span> <span>=</span> <span>torch</span><span>.</span><span>optim</span><span>.</span><span>SGD</span><span>(</span><span>model</span><span>.</span><span>parameters</span><span>(),</span> <span>lr</span><span>=</span><span>0.01</span><span>)</span>
<span>compiled_model</span> <span>=</span> <span>torch</span><span>.</span><span>compile</span><span>(</span><span>model</span><span>)</span>

<span>x</span> <span>=</span> <span>torch</span><span>.</span><span>randn</span><span>(</span><span>16</span><span>,</span> <span>3</span><span>,</span> <span>224</span><span>,</span> <span>224</span><span>).</span><span>cuda</span><span>()</span>
<span>optimizer</span><span>.</span><span>zero_grad</span><span>()</span>
<span>out</span> <span>=</span> <span>compiled_model</span><span>(</span><span>x</span><span>)</span>
<span>out</span><span>.</span><span>sum</span><span>().</span><span>backward</span><span>()</span>
<span>optimizer</span><span>.</span><span>step</span><span>()</span>
</code></pre></div></div>

<p>The first time you run the <code>optimized_model(x)</code>, it compiles the model.. Hence, it takes longer to run. Subsequent runs are fast.</p>

<h3 id="modes">Modes</h3>

<p>The compiler has a few presets that tune the compiled model in different ways.
You might be running a small model that is slow because of framework overhead. Or, you might be running a large model that barely fits into memory. Depending on your need, you might want to use a different mode.</p>

<div><div><pre><code><span># API NOT FINAL
# default: optimizes for large models, low compile-time
#          and no extra memory usage
</span><span>torch</span><span>.</span><span>compile</span><span>(</span><span>model</span><span>)</span>

<span># reduce-overhead: optimizes to reduce the framework overhead
#                and uses some extra memory. Helps speed up small models
</span><span>torch</span><span>.</span><span>compile</span><span>(</span><span>model</span><span>,</span> <span>mode</span><span>=</span><span>&#34;reduce-overhead&#34;</span><span>)</span>

<span># max-autotune: optimizes to produce the fastest model,
#               but takes a very long time to compile
</span><span>torch</span><span>.</span><span>compile</span><span>(</span><span>model</span><span>,</span> <span>mode</span><span>=</span><span>&#34;max-autotune&#34;</span><span>)</span>

</code></pre></div></div>

<h3 id="reading-and-updating-attributes">Reading and updating Attributes</h3>

<p>Accessing model attributes work as they would in eager mode.
You can access or modify attributes of your model (such as <code>model.conv1.weight</code>) as you generally would. This is completely safe and sound in terms of code correction. TorchDynamo inserts guards into the code to check if its assumptions hold true. If attributes change in certain ways, then TorchDynamo knows to recompile automatically as needed.</p>

<div><div><pre><code><span># optimized_model works similar to model, feel free to access its attributes and modify them
</span><span>optimized_model</span><span>.</span><span>conv1</span><span>.</span><span>weight</span><span>.</span><span>fill_</span><span>(</span><span>0.01</span><span>)</span>

<span># this change is reflected in model
</span></code></pre></div></div>

<h3 id="hooks">Hooks</h3>

<p>Module and Tensor <a href="https://pytorch.org/docs/stable/notes/modules.html#module-hooks">hooks</a> don’t fully work at the moment, but they will eventually work as we finish development.</p>

<h3 id="serialization">Serialization</h3>

<p>You can serialize the state-dict of the <code>optimized_model</code> OR the <code>model</code>. They point to the same parameters and state and hence are equivalent.</p>

<div><div><pre><code><span>torch</span><span>.</span><span>save</span><span>(</span><span>optimized_model</span><span>.</span><span>state_dict</span><span>(),</span> <span>&#34;foo.pt&#34;</span><span>)</span>
<span># both these lines of code do the same thing
</span><span>torch</span><span>.</span><span>save</span><span>(</span><span>model</span><span>.</span><span>state_dict</span><span>(),</span> <span>&#34;foo.pt&#34;</span><span>)</span>
</code></pre></div></div>

<p>You cannot serialize <code>optimized_model</code> currently. If you wish to save the object directly, save <code>model</code> instead.</p>

<div><div><pre><code><span>torch</span><span>.</span><span>save</span><span>(</span><span>optimized_model</span><span>,</span> <span>&#34;foo.pt&#34;</span><span>)</span> <span># Error
</span><span>torch</span><span>.</span><span>save</span><span>(</span><span>model</span><span>,</span> <span>&#34;foo.pt&#34;</span><span>)</span>           <span># Works
</span></code></pre></div></div>

<h3 id="inference-and-export">Inference and Export</h3>

<p>For model inference, after generating a compiled model using torch.compile, run some warm-up steps before actual model serving. This helps mitigate latency spikes during initial serving.</p>

<p>In addition, we will be introducing a mode called <code>torch.export</code> that carefully exports the entire model and the guard infrastructure for environments that need guaranteed and predictable latency. <code>torch.export</code> would need changes to your program, especially if you have data dependent control-flow.</p>

<div><div><pre><code><span># API Not Final
</span><span>exported_model</span> <span>=</span> <span>torch</span><span>.</span><span>_dynamo</span><span>.</span><span>export</span><span>(</span><span>model</span><span>,</span> <span>input</span><span>)</span>
<span>torch</span><span>.</span><span>save</span><span>(</span><span>exported_model</span><span>,</span> <span>&#34;foo.pt&#34;</span><span>)</span>
</code></pre></div></div>

<p>This is in early stages of development. Catch the talk on Export Path at the PyTorch Conference for more details. You can also engage on this topic at our “Ask the Engineers: 2.0 Live Q&amp;A Series” starting this month (more details at the end of this post).</p>

<h3 id="debugging-issues">Debugging Issues</h3>

<p>A compiled mode is opaque and hard to debug. You will have questions such as:</p>

<ul>
  <li>why is my program crashing in compiled mode?</li>
  <li>is compiled mode as accurate as eager mode?</li>
  <li>why am I not seeing speedups?</li>
</ul>

<p>If compiled mode produces an error or a crash or diverging results from eager mode (beyond machine precision limits), it is very unlikely that it is your code’s fault. However, understanding what piece of code is the reason for the bug is useful.</p>

<p>To aid in debugging and reproducibility, we have created several tools and logging capabilities out of which one stands out: <strong>The Minifier.</strong></p>

<p>The minifier automatically reduces the issue you are seeing to a small snippet of code. This small snippet of code reproduces the original issue and you can file a github issue with the minified code. This will help the PyTorch team fix the issue easily and quickly.</p>

<p>If you are not seeing the speedups that you expect, then we have the <strong>torch._dynamo.explain</strong> tool that explains which parts of your code induced what we call “graph breaks”. Graph breaks generally hinder the compiler from speeding up the code, and reducing the number of graph breaks likely will speed up your code (up to some limit of diminishing returns).</p>

<p>You can read about these and more in our <a href="https://pytorch.org/docs/master/dynamo/troubleshooting.html">troubleshooting guide</a>.</p>

<h3 id="dynamic-shapes">Dynamic Shapes</h3>

<p>When looking at what was necessary to support the generality of PyTorch code, one key requirement was supporting dynamic shapes, and allowing models to take in tensors of different sizes without inducing recompilation every time the shape changes.</p>

<p>As of today, support for Dynamic Shapes is limited and a rapid work in progress. It will be fully featured by stable release. It is gated behind a <code>dynamic=True</code> argument, and we have more progress on a feature branch (symbolic-shapes), on which we have successfully run BERT_pytorch in training with full symbolic shapes with TorchInductor. For inference with dynamic shapes, we have more coverage. For example, let’s look at a common setting where dynamic shapes are helpful - text generation with language models.</p>

<p>We can see that even when the shape changes dynamically from 4 all the way to 256, Compiled mode is able to consistently outperform eager by up to 40%. Without support for dynamic shapes, a common workaround is to pad to the nearest power of two. However, as we can see from the charts below, it incurs a significant amount of performance overhead, and also results in significantly longer compilation time. Moreover, padding is sometimes non-trivial to do correctly.</p>

<p>By supporting dynamic shapes in PyTorch 2.0’s Compiled mode, we can get the best of performance <em>and</em> ease of use.</p>

<p><img src="https://pytorch.org/assets/images/pytorch-2.0-img7.png" width="50%"/>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img8.png" width="50%"/>
</p>

<p>The current work is evolving very rapidly and we may temporarily let some models regress as we land fundamental improvements to infrastructure. The latest updates for our progress on dynamic shapes can be found <a href="https://dev-discuss.pytorch.org/t/state-of-symbolic-shapes-branch/777/19">here</a>.</p>

<h2 id="distributed">Distributed</h2>

<p>In summary, torch.distributed’s two main distributed wrappers work well in compiled mode.</p>

<p>Both <code>DistributedDataParallel</code> (DDP) and <code>FullyShardedDataParallel</code> (FSDP) work in compiled mode and provide improved performance and memory utilization relative to eager mode, with some caveats and limitations.</p>

<center> <u>Speedups in AMP Precision</u></center>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img9.png" width="90%"/>
<center><u>Left: speedups for FSDP in Compiled mode over eager mode (AMP precision).</u></center>


<p><img src="https://pytorch.org/assets/images/pytorch-2.0-img10.png" width="50%"/>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img11.png" width="50%"/>
</p>

<p>External launcher scripts and wrappers that simply apply DDP under the hood generally should work out of the box. Hugging Face Accelerate, Lightning, torchrun, and Ray Train have all been tested and verified working. DeepSpeed and Horovod have not been tested and we expect to enable them soon.</p>

<p>Manual gradient checkpointing (i.e. <code>torch.utils.checkpoint*</code> ) is in the works, and expected to be enabled in the near future. There is ongoing work to enable it, and this is partially mitigated by AOTAutograd’s min-cut partitioner, which recomputes some values in the <code>backward</code> call to reduce peak memory usage. This is evident from the memory compression results shown in the graph with FSDP in compiled mode.</p>

<p>Other experimental distributed subsystems, such as DistributedTensor and PiPPy, have not yet been tested with TorchDynamo.</p>

<h3 id="distributeddataparallel-ddp">DistributedDataParallel (DDP)</h3>

<p>DDP relies on overlapping AllReduce communications with backwards computation, and grouping smaller per-layer AllReduce operations into ‘buckets’ for greater efficiency. AOTAutograd functions compiled by TorchDynamo prevent communication overlap, when combined naively with DDP, but performance is recovered by compiling separate subgraphs for each ‘bucket’ and allowing communication ops to happen outside and in-between the subgraphs. DDP support in compiled mode also currently requires <code>static_graph=True</code> and <code>find_unused_parameters=True</code>, but these shouldn’t be a long term requirement. See <a href="https://dev-discuss.pytorch.org/t/torchdynamo-update-9-making-ddp-work-with-torchdynamo/860">this post</a> for more details on the approach and results for DDP + TorchDynamo.</p>

<h3 id="fullyshardeddataparallel-fsdp">FullyShardedDataParallel (FSDP)</h3>

<p>FSDP itself is a “beta” PyTorch feature and has a higher level of system complexity than DDP due to the ability to tune which submodules are wrapped and because there are generally more configuration options. FSDP works with TorchDynamo and TorchInductor for a variety of popular models, if configured with the <code>use_original_params=True</code> flag. Some compatibility issues with particular models or configurations are expected at this time, but will be actively improved, and particular models can be prioritized if github issues are filed.</p>

<p>Users specify an <code>auto_wrap_policy</code> argument to indicate which submodules of their model to wrap together in an FSDP instance used for state sharding, or manually wrap submodules in FSDP instances. For example, many transformer models work well when each ‘transformer block’ is wrapped in a separate FSDP instance and thus only the full state of one transformer block needs to be materialized at one time. Dynamo will insert graph breaks at the boundary of each FSDP instance, to allow communication ops in forward (and backward) to happen outside the graphs and in parallel to computation.</p>

<p>If FSDP is used without wrapping submodules in separate instances, it falls back to operating similarly to DDP, but without bucketing. Hence all gradients are reduced in one operation, and there can be no compute/communication overlap even in Eager. This configuration has only been tested with TorchDynamo for functionality but not for performance.</p>

<h2 id="developervendor-experience">Developer/Vendor Experience</h2>

<p>With PyTorch 2.0, we want to simplify the backend (compiler) integration experience. To do this, we have focused on <strong>reducing the number of operators</strong> and <strong>simplifying the semantics</strong> of the operator set necessary to bring up a PyTorch backend.</p>

<p>In graphical form, the PT2 stack looks like:</p>

<p>
<img src="https://pytorch.org/assets/images/pytorch-2.0-img12.png" width="90%"/>
</p>

<p>Starting in the middle of the diagram, AOTAutograd dynamically captures autograd logic in an ahead-of-time fashion, producing a graph of forward and backwards operators in FX graph format.</p>

<p>We provide a set of hardened decompositions (i.e. operator implementations written in terms of other operators) that can be leveraged to <strong>reduce</strong> the number of operators a backend is required to implement. We also <strong>simplify</strong> the semantics of PyTorch operators by selectively rewriting complicated PyTorch logic including mutations and views via a process called <em>functionalization</em>, as well as guaranteeing operator metadata information such as shape propagation formulas. This work is actively in progress; our goal is to provide a <em>primitive</em> and <em>stable</em> set of ~250 operators with simplified semantics, called <em>PrimTorch,</em> that vendors can leverage (i.e. opt-in to) in order to simplify their integrations.</p>

<p><strong>Dynamo Backend</strong></p>

<p>Vendors with existing compiler stacks may find it easiest to integrate as a TorchDynamo backend, receiving an FX Graph in terms of ATen/Prims IR. Note that for both training and inference, the integration point would be immediately after AOTAutograd, since we currently apply decompositions as part of AOTAutograd, and merely skip the backward-specific steps if targeting inference.</p>

<p><strong>Inductor backend</strong></p>

<p>Vendors can also integrate their backend directly into Inductor. Inductor takes in a graph produced by AOTAutograd that consists of ATen/Prim operations, and further lowers them down to a loop level IR. Today, Inductor provides lowerings to its loop-level IR for pointwise, reduction, scatter/gather and window operations. In addition, Inductor creates fusion groups, does indexing simplification, dimension collapsing, and tunes loop iteration order in order to support efficient code generation. Vendors can then integrate by providing the mapping from the loop level IR to hardware-specific code. Currently, Inductor has two backends: (1) C++ that generates multithreaded CPU code, (2) Triton that generates performant GPU code. These Inductor backends can be used as an inspiration for the alternate backends.</p>

<p><strong>Mixture of Backends Interface (coming soon)</strong></p>

<p>We have built utilities for partitioning an FX graph into subgraphs that contain operators supported by a backend and executing the remainder eagerly. These utilities can be extended to support a “mixture of backends,” configuring which portions of the graphs to run for which backend. However, there is not yet a stable interface or contract for backends to expose their operator support, preferences for patterns of operators, etc. This remains as ongoing work, and we welcome feedback from early adopters.</p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>We are super excited about the direction that we’ve taken for PyTorch 2.0 and beyond. The road to the final 2.0 release is going to be rough, but come join us on this journey early-on. If you are interested in deep-diving further or contributing to the compiler, please continue reading below which includes more information on how to get started (e.g., tutorials, benchmarks, models, FAQs) and <strong>Ask the Engineers: 2.0 Live Q&amp;A Series</strong> starting this month. Additional resources include:</p>

<ul>
  <li>Getting Started @ <a href="https://pytorch.org/docs/master/dynamo/get-started.html">https://pytorch.org/docs/master/dynamo/get-started.html</a></li>
  <li>Tutorials @ <a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></li>
  <li>Documentation @ <a href="https://pytorch.org/docs/master">https://pytorch.org/docs/master</a> and <a href="http://pytorch.org/docs/master/dynamo">pytorch.org/docs/master/dynamo</a></li>
  <li>Developer Discussions @ <a href="https://dev-discuss.pytorch.org">https://dev-discuss.pytorch.org</a></li>
</ul>







<h2 id="accelerating-hugging-face-and-timm-models-with-pytorch-20">Accelerating Hugging Face and TIMM models with PyTorch 2.0</h2>

<p>Author: Mark Saroufim</p>

<p><code>torch.compile()</code> makes it easy to experiment with different compiler backends to make PyTorch code faster with a single line decorator <code>torch.compile()</code>. It works either directly over an nn.Module as a drop-in replacement for torch.jit.script() but without requiring you to make any source code changes. We expect this one line code change to provide you with between 30%-2x training time speedups on the vast majority of models that you’re already running.</p>

<div><div><pre><code><span>opt_module</span> <span>=</span> <span>torch</span><span>.</span><span>compile</span><span>(</span><span>module</span><span>)</span>
</code></pre></div></div>

<p>torch.compile supports arbitrary PyTorch code, control flow, mutation and comes with experimental support for dynamic shapes. We’re so excited about this development that we call it PyTorch 2.0.</p>

<p>What makes this announcement different for us is we’ve already benchmarked some of the most popular open source PyTorch models and gotten substantial speedups ranging from 30% to 2x <a href="https://github.com/pytorch/torchdynamo/issues/681">https://github.com/pytorch/torchdynamo/issues/681</a>.</p>

<p>There are no tricks here, we’ve pip installed popular libraries like <a href="https://github.com/huggingface/transformers">https://github.com/huggingface/transformers</a>, <a href="https://github.com/huggingface/accelerate">https://github.com/huggingface/accelerate</a> and <a href="https://github.com/rwightman/pytorch-image-models">https://github.com/rwightman/pytorch-image-models</a> and then ran torch.compile() on them and that’s it.</p>

<p>It’s rare to get both performance and convenience, but this is why the core team finds PyTorch 2.0 so exciting.</p>

<h2 id="requirements">Requirements</h2>

<p>For GPU (newer generation GPUs will see drastically better performance)</p>

<div><div><pre><code>pip3 install numpy --pre torch[dynamo] --force-reinstall --extra-index-url https://download.pytorch.org/whl/nightly/cu117
</code></pre></div></div>

<p>For CPU</p>

<div><div><pre><code>pip3 install --pre torch --extra-index-url https://download.pytorch.org/whl/nightly/cpu
</code></pre></div></div>

<p>Optional: Verify Installation</p>

<div><div><pre><code>git clone https://github.com/pytorch/pytorch
cd tools/dynamo
python verify_dynamo.py
</code></pre></div></div>

<p>Optional: Docker installation</p>

<p>We also provide all the required dependencies in the PyTorch nightly
binaries which you can download with</p>

<div><div><pre><code>docker pull ghcr.io/pytorch/pytorch-nightly
</code></pre></div></div>

<p>And for ad hoc experiments just make sure that your container has access to all your GPUs</p>

<div><div><pre><code>docker run --gpus all -it ghcr.io/pytorch/pytorch-nightly:latest /bin/bash
</code></pre></div></div>

<h2 id="getting-started">Getting Started</h2>

<p>Please read Mark Saroufim’s <a href="https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models/">full blog post</a> where he walks you through a tutorial and real models for you to try PyTorch 2.0 today.</p>

<p>Our goal with PyTorch was to build a breadth-first compiler that would speed up the vast majority of actual models people run in open source. The Hugging Face Hub ended up being an extremely valuable benchmarking tool for us, ensuring that any optimization we work on actually helps accelerate models people want to run.</p>

<p>The blog tutorial will show you exactly how to replicate those speedups so you can be as excited as to PyTorch 2.0 as we are. So please try out PyTorch 2.0, enjoy the free perf and if you’re not seeing it then please open an issue and we will make sure your model is supported <a href="https://github.com/pytorch/torchdynamo/issues">https://github.com/pytorch/torchdynamo/issues</a></p>

<p>After all, we can’t claim we’re created a breadth-first unless <strong>YOUR</strong> models actually run faster.</p>

<h2 id="faqs">FAQs<a href="#faqs" aria-label="Anchor" data-anchorjs-icon=""></a></h2>

<ol>
  <li><b>What is PT 2.0?</b></li>

  <li><b>Why 2.0 instead of 1.14? </b></li>

  <li>
    <p><b>How do I install 2.0? Any additional requirements?</b></p>
    <p>Install the latest nightlies:</p>
    <p>CUDA 11.7</p>
    <div><div><pre><code>pip3 install numpy --pre torch[dynamo] torchvision torchaudio --force-reinstall --extra-index-url https://download.pytorch.org/whl/nightly/cu117</code></pre></div></div>
    <p>CUDA 11.6</p>
    <div><div><pre><code>pip3 install numpy --pre torch[dynamo] torchvision torchaudio --force-reinstall --extra-index-url https://download.pytorch.org/whl/nightly/cu116</code></pre></div></div>
    <p>CPU</p>
    <div><div><pre><code>pip3 install numpy --pre torch torchvision torchaudio --force-reinstall --extra-index-url https://download.pytorch.org/whl/nightly/cpu</code></pre></div></div>
  </li>

  <li><b>Is 2.0 code backwards-compatible with 1.X?</b></li>

  <li><b>Is 2.0 enabled by default?</b></li>

  <li><b>How do I migrate my PT1.X code to PT2.0?</b></li>

  <li><b>Why should I use PT2.0 instead of PT 1.X? </b></li>

  <li><b>Are there any applications where I should NOT use PT 2.0?</b></li>

  <li><b>What is my code doing differently when running PyTorch 2.0?</b>
  Out of the box, PyTorch 2.0 is the same as PyTorch 1.x, your models run in eager-mode i.e. every line of Python is executed one after the other. </li>
  <li><b>What new components does PT2.0 add to PT?</b></li>

  <li><b> What compiler backends does 2.0 currently support?</b>
    <p>The default and the most complete backend is <a href="https://github.com/pytorch/pytorch/tree/master/torch/_inductor" target="_blank">TorchInductor</a>, but TorchDynamo has a growing list of backends that can be found by calling <code>torchdynamo.list_backends().</code>
    </p>
  </li>

  <li><b>How does distributed training work with 2.0?</b>
    <p>DDP and FSDP in Compiled mode  can run up to 15% faster than Eager-Mode in FP32 and up to 80% faster in AMP precision. PT2.0 does some extra optimization to ensure DDP’s communication-computation overlap works well with Dynamo’s partial graph creation. Ensure you run DDP with static_graph=False. More details <a href="https://dev-discuss.pytorch.org/t/torchdynamo-update-9-making-ddp-work-with-torchdynamo/860" target="_blank">here</a>.</p>
  </li>

  <li><b>Help my code is running slower with 2.0’s Compiled Model</b>
    <p>The most likely reason for performance hits is too many graph breaks. For instance, something innocuous as a print statement in your model’s forward triggers a graph break. We have ways to diagnose these - read more <a href="https://pytorch.org/docs/master/dynamo/faq.html#why-am-i-not-seeing-speedups" target="_blank">here</a>.</p>
  </li>

  <li> <b> My previously-running code is crashing with 2.0! How do I debug it?</b>
    <p>Here are some techniques to triage where your code might be failing, and printing helpful logs: <a href="https://pytorch.org/docs/master/dynamo/faq.html#why-is-my-code-crashing" target="_blank">https://pytorch.org/docs/master/dynamo/faq.html#why-is-my-code-crashing</a>
    </p>
  </li>
</ol>

<h2 id="ask-the-engineers-20-live-qa-series">Ask the Engineers: 2.0 Live Q&amp;A Series</h2>

<p>We will be hosting a series of live Q&amp;A sessions for the community to have deeper questions and dialogue with the experts. Please check back to see the full calendar of topics throughout the year. If you are unable to attend: 1) They will be recorded for future viewing and 2) You can attend our Dev Infra Office Hours every Friday at 10 AM PST @ <a href="https://github.com/pytorch/pytorch/wiki/Dev-Infra-Office-Hours">https://github.com/pytorch/pytorch/wiki/Dev-Infra-Office-Hours</a></p>

<p><strong>Note: Schedules, topics and links are subject to change, so please check back often.</strong></p>

<table>
  <tbody><tr>
   <td><b>TOPIC</b></td>
   <td><b>HOST</b></td>
   <td><b>DATE | TIME</b></td>
  </tr>
  <tr>
   <td><b>The new developer experience of using 2.0 (install, setup, clone an example, run with 2.0)</b></td>
   <td>Suraj Subramanian</td>
   <td>12/13/22 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>PT2 Profiling and Debugging</b></td>
   <td>Bert Maher</td>
   <td>12/15/11 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>A deep dive on TorchInductor and PT 2.0 Backend Integration</b></td>
   <td>Natalia Gimelshein, Bin Bao and Sherlock Huang</td>
   <td>1/10/23 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>Extend PyTorch without C++ and functorch: JAX-like composable function transforms for PyTorch</b></td>
   <td>Anjali Chourdia and Samantha Andow</td>
   <td>1/5/23 | 9 AM PST</td>
  </tr>
  <tr>
   <td><b>A deep dive on TorchDynamo</b></td>
   <td>Michael Voznesensky</td>
   <td>12/19/22 | 1 PM PST</td>
  </tr>
  <tr>
   <td><b>Rethinking data loading with TorchData:Datapipes and Dataloader2</b></td>
   <td>Kevin Tse</td>
   <td>2/1/23 | 11 AM PST</td>
  </tr>
  <tr>
   <td><b>Composable training (+ torcheval, torchsnapshot)</b></td>
   <td>Ananth Subramaniam</td>
   <td>TBD</td>
  </tr>
  <tr>
   <td><b>How and why contribute code and tutorials to PyTorch</b></td>
   <td>Zain Rizvi, Svetlana Karslioglu and Carl Parker</td>
   <td>12/15/22 | 2 PM PST</td>
  </tr>
  <tr>
   <td><b>Dynamic Shapes and Calculating Maximum Batch Size</b></td>
   <td>Edward Yang and Elias Ellison</td>
   <td>2/7/23 | 1 PM PST</td>
  </tr>
  <tr>
   <td><b>PyTorch 2.0 Export: Sound Whole Graph Capture for PyTorch</b></td>
   <td>Michael Suo and Yanan Cao</td>
   <td>12/21/22 | 2 PM PST</td>
  </tr>
  <tr>
   <td><b>2-D Parallelism using DistributedTensor and PyTorch DistributedTensor</b></td>
   <td>Wanchao Liang and Alisson Gusatti Azzolini</td>
   <td>2/15/23 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>TorchRec and FSDP in Production</b></td>
   <td>Dennis van der Staay, Andrew Gu and Rohan Varma</td>
   <td>12/21/22 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>The Future of PyTorch On-Device</b></td>
   <td>Raziel Alvarez Guevara</td>
   <td>2/8/23 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>TorchMultiModal</b></td>
   <td>Kartikay Khandelwal</td>
   <td>2/23/23 | 10 AM PST</td>
  </tr>
  <tr>
   <td><b>BetterTransformers (+ integration with Hugging Face), Model Serving and Optimizations</b></td>
   <td>Hamid Shojanazeri and Mark Saroufim</td>
   <td>1/10/23 | 1 PM PST</td>
  </tr>
  <tr>
   <td><b>PT2 and Distributed</b></td>
   <td>Will Constable</td>
   <td>1/24/23 | 2 PM PST</td>
  </tr>
</tbody></table>

<h2 id="watch-the-talks-from-pytorch-conference">Watch the Talks from PyTorch Conference</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=vbtGZL7IrAw" target="_blank">TorchDynamo</a></li>
  <li><a href="https://www.youtube.com/watch?v=vbtGZL7IrAw" target="_blank">TorchInductor</a></li>
  <li><a href="https://www.youtube.com/watch?v=vbtGZL7IrAw" target="_blank">Dynamic Shapes</a></li>
  <li><a href="https://www.youtube.com/watch?v=vbtGZL7IrAw" target="_blank">Export Path</a></li>
</ul>



</article>
      </div>
    </div></div>
  </body>
</html>
