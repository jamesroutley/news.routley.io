<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pytorch.org/blog/pytorch-2.0-release/">Original</a>
    <h1>PyTorch 2.0</h1>
    
    <div id="readability-page-1" class="page"><article>
                    
                    <p>We are excited to announce the release of <a href="https://github.com/pytorch/pytorch/releases/tag/v2.0.0">PyTorch® 2.0</a> which we highlighted during the <a href="https://www.youtube.com/@PyTorch/playlists?view=50&amp;sort=dd&amp;shelf_id=2">PyTorch Conference</a> on 12/2/22! PyTorch 2.0 offers the same eager-mode development and user experience, while fundamentally changing and supercharging how PyTorch operates at compiler level under the hood with faster performance and support for Dynamic Shapes and Distributed.</p>

<p>This next-generation release includes a Stable version of Accelerated Transformers (formerly called Better Transformers); Beta includes torch.compile as the main API for PyTorch 2.0,  the scaled_dot_product_attention function as part of torch.nn.functional, the MPS backend, functorch APIs in the torch.func module; and other Beta/Prototype improvements across various inferences, performance and training optimization features on GPUs and CPUs. For a comprehensive introduction and technical overview of torch.compile, please visit the 2.0 <a href="https://pytorch.org/get-started/pytorch-2.0">Get Started page</a>.</p>

<p>Along with 2.0, we are also releasing a series of beta updates to the PyTorch domain libraries, including those that are in-tree, and separate libraries including TorchAudio, TorchVision, and TorchText. An update for TorchX is also being released as it moves to community supported mode. More details can be found in this <a href="https://pytorch.org/blog/new-library-updates-in-pytorch-2.0/">library blog</a>.</p>

<p>This release is composed of over 4,541 commits and 428 contributors since 1.13.1. We want to sincerely thank our dedicated community for your contributions. As always, we encourage you to try these out and report any issues as we improve 2.0 and the overall 2-series this year.</p>

<p>Summary:</p>
<ul>
  <li>torch.compile is the main API for PyTorch 2.0, which wraps your model and returns a compiled model. It is a fully additive (and optional) feature and hence 2.0 is 100% backward compatible by definition.</li>
  <li>As an underpinning technology of torch.compile, TorchInductor with Nvidia and AMD GPUs will rely on OpenAI Triton deep learning compiler to generate performant code and hide low level hardware details. OpenAI Triton-generated kernels achieve performance that’s on par with hand-written kernels and specialized cuda libraries such as cublas.</li>
  <li>Accelerated Transformers introduce high-performance support for training and inference using a custom kernel architecture for scaled dot product attention (SPDA). The API is integrated with torch.compile() and model developers may also use the <a href="#beta-scaled-dot-product-attention-20">scaled dot product attention</a> kernels directly by calling the new scaled_dot_product_attention() operator.</li>
  <li>Metal Performance Shaders (MPS) backend provides GPU accelerated PyTorch training on Mac platforms with added support for Top 60 most used ops, bringing coverage to over 300 operators.</li>
  <li>Amazon AWS optimizes the PyTorch CPU inference on AWS Graviton3 based <a href="https://aws.amazon.com/blogs/aws/new-amazon-ec2-c7g-instances-powered-by-aws-graviton3-processors/">C7g instances</a>. PyTorch 2.0 improves inference performance on Graviton compared to the previous releases, including improvements for Resnet50 and Bert.</li>
  <li>New prototype features and technologies across TensorParallel, DTensor, 2D parallel, TorchDynamo, AOTAutograd, PrimTorch and TorchInductor.</li>
</ul>

<table>
<thead>
  <tr>
   <td scope="col">
<strong>Stable</strong>
   </td>
   <td scope="col"><strong>Beta</strong>
   </td>
   <td scope="col"><strong>Prototype</strong>
   </td>
   <td scope="col"><strong>Performance Improvements</strong>
   </td>
  </tr>
  </thead>
  <tbody><tr>
   <td>

<a href="#stable-features">Accelerated PT 2 Transformers</a>
   </td>
   <td>

<a href="#beta-features">torch.compile</a>
   </td>
   <td>

<a href="#prototype-features">DTensor</a>
   </td>
   <td>

<a href="#deprecation-of-cuda-116-and-python-17-support-for-pytorch-20">CUDA support for 11.7 &amp; 11.8 (deprecating CUDA 11.6) </a>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>

<a href="#beta-pytorch-mps-backend">PyTorch MPS Backend</a>
   </td>
   <td>

<a href="#prototype-tensorparallel">TensorParallel</a>
   </td>
   <td> 

<a href="#deprecation-of-cuda-116-and-python-17-support-for-pytorch-20">Python 1.8 (deprecating Python 1.7)</a>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>

<a href="#beta-scaled-dot-product-attention-20">Scaled dot product attention</a>
   </td>
   <td>

<a href="#prototype-2d-parallel">2D Parallel</a>
   </td>
   <td>

<a href="#optimized-pytorch-inference-with-aws-graviton-processors">AWS Graviton3</a>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>

<a href="#beta-functorch---torchfunc">functorch</a>
   </td>
   <td rowspan="2">

<a href="#beta-torchcompile">Torch.compile (dynamic=True)</a>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td><a href="#beta-dispatchable-collectives">Dispatchable Collectives</a>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td><a href="#beta-torchset_default_device-and-torchdevice-as-context-manager">Torch.set_default &amp; torch.device</a>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>

<a href="#beta-x86-as-the-new-default-quantization-backend-for-x86-cpu">X86 quantization backend</a>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>

<a href="#beta-gnn-inference-and-training-optimization-on-cpu">GNN inference and training performance</a>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</tbody></table>

<p>*To see a full list of public 2.0, 1.13 and 1.12 feature submissions click <a href="https://docs.google.com/spreadsheets/d/1H3jazwO8BBCwK8JwLNYspLiHfUrzshEtyqjL-X93I9g/edit#gid=790902532">here</a>.</p>

<h2 id="stable-features">Stable Features</h2>

<h3 id="stable-accelerated-pytorch-2-transformers">[Stable] Accelerated PyTorch 2 Transformers</h3>

<p>The PyTorch 2.0 release includes a new high-performance implementation of the PyTorch Transformer API. In releasing Accelerated PT2 Transformers, our goal is to make training and deployment of state-of-the-art Transformer models affordable across the industry. This release introduces high-performance support for training and inference using a custom kernel architecture for scaled dot product attention (SPDA), extending the inference “fastpath” architecture, previously known as “Better Transformer.”</p>

<p>Similar to the “fastpath” architecture, custom kernels are fully integrated into the PyTorch Transformer API – thus, using the native Transformer and MultiHeadAttention API will enable users to:</p>

<ul>
  <li>transparently see significant speed improvements;</li>
  <li>support many more use cases including models using Cross-Attention, Transformer Decoders, and for training models; and</li>
  <li>continue to use fastpath inference for fixed and variable sequence length Transformer Encoder and Self Attention use cases.</li>
</ul>

<p>To take full advantage of different hardware models and Transformer use cases, multiple SDPA custom kernels are supported (see below), with custom kernel selection logic that will pick the highest-performance kernel for a given model and hardware type. In addition to the existing Transformer API, model developers may also use the <a href="#beta-scaled-dot-product-attention-20">scaled dot product attention</a> kernels directly by calling the new scaled_dot_product_attention() operator. Accelerated PyTorch 2 Transformers are integrated with torch.compile() .  To use your model while benefiting from the additional acceleration of PT2-compilation (for inference or training), pre-process the model with <code>model = torch.compile(model)</code>.</p>

<p>We have achieved major speedups for training transformer models and in particular large language models with Accelerated PyTorch 2 Transformers using a combination of custom kernels and torch.compile().</p>

<p><img src="https://pytorch.org/assets/images/pytorch20post.png" alt="alt_text" title="Accelerated PyTorch 2 speed" width="100%"/>
<small><em>Figure: Using scaled dot product attention with custom kernels and torch.compile delivers significant speedups for training large language models, such as for <a href="https://github.com/karpathy/nanoGPT">nanoGPT</a> shown here.</em></small></p>

<h2 id="beta-features">Beta Features</h2>

<h3 id="beta-torchcompile">[Beta] torch.compile</h3>

<p>torch.compile is the main API for PyTorch 2.0, which wraps your model and returns a compiled model. It is a fully additive (and optional) feature and hence 2.0 is 100% backward compatible by definition.</p>

<p>Underpinning torch.compile are new technologies – TorchDynamo, AOTAutograd, PrimTorch and TorchInductor:</p>
<ul>
  <li>TorchDynamo captures PyTorch programs safely using Python Frame Evaluation Hooks and is a significant innovation that was a result of 5 years of our R&amp;D into safe graph capture.</li>
  <li>AOTAutograd overloads PyTorch’s autograd engine as a tracing autodiff for generating ahead-of-time backward traces.</li>
  <li>PrimTorch canonicalizes ~2000+ PyTorch operators down to a closed set of ~250 primitive operators that developers can target to build a complete PyTorch backend. This substantially lowers the barrier of writing a PyTorch feature or backend.</li>
  <li>TorchInductor is a deep learning compiler that generates fast code for multiple accelerators and backends. For NVIDIA and AMD GPUs, it uses OpenAI Triton as a key building block. For intel CPUs, we generate C++ code using multithreading, vectorized instructions and offloading appropriate operations to mkldnn when possible.</li>
</ul>

<p>With all the new technologies, torch.compile is able to work 93% of time across 165 open-source models and runs 20% faster on average at float32 precision and 36% faster on average at AMP precision.</p>

<p>For more information, please refer to <a href="https://pytorch.org/get-started/pytorch-2.0/">https://pytorch.org/get-started/pytorch-2.0/</a> and for TorchInductor CPU with Intel <a href="https://dev-discuss.pytorch.org/t/torchinductor-update-5-cpu-backend-backend-performance-update-and-deep-dive-on-key-optimizations/1117">here</a>.</p>

<h3 id="beta-pytorch-mps-backend">[Beta] PyTorch MPS Backend</h3>

<p>MPS backend provides GPU-accelerated PyTorch training on Mac platforms. This release brings improved correctness, stability, and operator coverage.</p>

<p>MPS backend now includes support for the Top 60 most used ops, along with the most frequently requested operations by the community, bringing coverage to over 300 operators. The major focus of the release was to enable full OpInfo-based forward and gradient mode testing to address silent correctness issues. These changes have resulted in wider adoption of MPS backend by 3rd party networks such as Stable Diffusion, YoloV5, WhisperAI, along with increased coverage for Torchbench networks and Basic tutorials. We encourage developers to update to the latest macOS release to see the best performance and stability on the MPS backend.</p>

<p>Links</p>

<ol>
  <li><a href="https://pytorch.org/docs/stable/notes/mps.html">MPS Backend</a></li>
  <li><a href="https://github.com/pytorch/pytorch/wiki/MPS-Backend">Developer information</a></li>
  <li><a href="https://developer.apple.com/metal/pytorch/">Accelerated PyTorch training on Mac</a></li>
  <li><a href="https://developer.apple.com/documentation/metal?language=objc">Metal</a>, <a href="https://developer.apple.com/documentation/metalperformanceshaders?language=objc">Metal Performance Shaders</a> &amp; <a href="https://developer.apple.com/documentation/metalperformanceshadersgraph?language=objc">Metal Performance Shaders Graph</a></li>
</ol>

<h3 id="beta-scaled-dot-product-attention-20">[Beta] Scaled dot product attention 2.0</h3>

<p>We are thrilled to announce the release of PyTorch 2.0, which introduces a powerful scaled dot product attention function as part of torch.nn.functional. This function includes multiple implementations that can be seamlessly applied depending on the input and hardware in use.</p>

<p>In previous versions of PyTorch, you had to rely on third-party implementations and install separate packages to take advantage of memory-optimized algorithms like <a href="https://github.com/HazyResearch/flash-attention">FlashAttention</a>. With PyTorch 2.0, all these implementations are readily available by default.</p>

<p>These implementations include <a href="https://arxiv.org/abs/2205.14135">FlashAttention</a> from HazyResearch, Memory-Efficient Attention from the <a href="https://github.com/facebookresearch/xformers">xFormers</a> project, and a native C++ implementation that is ideal for non-CUDA devices or when high-precision is required.</p>

<p>PyTorch 2.0 will automatically select the optimal implementation for your use case, but you can also toggle them individually for finer-grained control. Additionally, the scaled dot product attention function can be used to build common transformer architecture components.</p>

<p>Learn more with the <a href="https://pytorch.org/docs/master/generated/torch.nn.functional.scaled_dot_product_attention.html?highlight=scaled_dot_product#torch.nn.functional.scaled_dot_product_attention">documentation</a> and this <a href="https://pytorch.org/tutorials/intermediate/scaled_dot_product_attention_tutorial.html">tutorial</a>.</p>

<h3 id="beta-functorch---torchfunc">[Beta] functorch -&gt; torch.func</h3>

<p>Inspired by <a href="https://github.com/google/jax">Google JAX</a>, functorch is a library that offers composable vmap (vectorization) and autodiff transforms. It enables advanced autodiff use cases that would otherwise be tricky to express in PyTorch. Examples include:</p>
<ul>
  <li><a href="https://pytorch.org/tutorials/intermediate/ensembling.html">model ensembling</a></li>
  <li><a href="https://pytorch.org/tutorials/intermediate/jacobians_hessians.html">efficiently computing jacobians and hessians</a></li>
  <li><a href="https://pytorch.org/tutorials/intermediate/per_sample_grads.html">computing per-sample-gradients (or other per-sample quantities)</a></li>
</ul>

<p>We’re excited to announce that, as the final step of upstreaming and integrating functorch into PyTorch, the functorch APIs are now available in the torch.func module. Our function transform APIs are identical to before, but we have changed how the interaction with NN modules work. Please see the <a href="https://pytorch.org/docs/master/func.html">docs</a> and the <a href="https://pytorch.org/docs/master/func.migrating.html">migration guide</a> for more details.</p>

<p>Furthermore, we have <a href="https://pytorch.org/docs/master/notes/extending.func.html">added support for torch.autograd.Function</a>: one is now able to apply function transformations (e.g. vmap, grad, jvp) over torch.autograd.Function.</p>

<h3 id="beta-dispatchable-collectives">[Beta] Dispatchable Collectives</h3>

<p>Dispatchable collectives is an improvement to the existing init_process_group() API which changes backend to an optional argument. For users, the main advantage of this feature is that it will allow them to write code that can run on both GPU and CPU machines without having to change the backend specification. The dispatchability feature will also make it easier for users to support both GPU and CPU collectives, as they will no longer need to specify the backend manually (e.g. “NCCL” or “GLOO”). Existing backend specifications by users will be honored and will not require change.</p>

<p>Usage example:</p>
<div><div><pre><code>import torch.distributed.dist
…
# old
dist.init_process_group(backend=”nccl”, ...)
dist.all_reduce(...) # with CUDA tensors works
dist.all_reduce(...) # with CPU tensors does not work

# new
dist.init_process_group(...) # backend is optional
dist.all_reduce(...) # with CUDA tensors works
dist.all_reduce(...) # with CPU tensors works
</code></pre></div></div>

<p>Learn more <a href="https://pytorch.org/docs/master/distributed.html#torch.distributed.init_process_group">here</a>.</p>

<h3 id="beta-torchset_default_device-and-torchdevice-as-context-manager">[Beta] torch.set_default_device and torch.device as context manager</h3>

<p>torch.set_default_device allows users to change the default device that factory functions in PyTorch allocate on. For example, if you torch.set_default_device(‘cuda’), a call to torch.empty(2) will allocate on CUDA (rather than on CPU). You can also use torch.device as a context manager to change the default device on a local basis. This resolves a long standing feature request from PyTorch’s initial release for a way to do this.</p>

<p>Learn more <a href="https://pytorch.org/tutorials/intermediate/scaled_dot_product_attention_tutorial.html">here</a>.</p>

<h3 id="beta-x86-as-the-new-default-quantization-backend-for-x86-cpu">[Beta] “X86” as the new default quantization backend for x86 CPU</h3>

<p>The new X86 quantization backend, which utilizes FBGEMM and oneDNN kernel libraries, replaces FBGEMM as the default quantization backend for x86 CPU platforms and offers improved int8 inference performance compared to the original FBGEMM backend, leveraging the strengths of both libraries, with 1.3X – 2X inference performance speedup measured on 40+ deep learning models. The new backend is functionally compatible with the original FBGEMM backend.</p>

<p><strong>Table: Geomean Speedup of X86 Quantization Backend vs. FBGEMM Backend</strong></p>

<table>
  <tbody><tr>
   <td> 
   </td>
   <td>1 core/instance
   </td>
   <td>2 cores/instance
   </td>
   <td>4 cores/instance
   </td>
   <td>1 socket (32 cores)/instance
   </td>
  </tr>
  <tr>
   <td>Intel(R) Xeon(R) Platinum 8358 CPU @ 2.60GHz
   </td>
   <td>1.76X
   </td>
   <td>1.80X
   </td>
   <td>2.04X
   </td>
   <td>1.34X
   </td>
  </tr>
</tbody></table>

<p>By default, users on x86 platforms will utilize the x86 quantization backend and their PyTorch programs will remain unchanged when using the default backend. Alternatively, users have the option to specify “X86” as the quantization backend explicitly. Example code is shown below:</p>

<div><div><pre><code>import torch
from torch.ao.quantization import get_default_qconfig_mappingfrom torch.quantization.quantize_fx
import prepare_fx, convert_fx
 
# get default configuration
qconfig_mapping = get_default_qconfig_mapping()
 
# or explicitly specify the backend
# qengine = &#39;x86&#39;
# torch.backends.quantized.engine = qengine
# qconfig_mapping = get_default_qconfig_mapping(qengine)
 
# construct fp32 model
model_fp32 = ...
 
# prepare
prepared_model = prepare_fx(model_fp32, qconfig_mapping, example_inputs=x)
 
# calibrate
...
 
# convert
quantized_model = convert_fx(prepared_model)
</code></pre></div></div>

<p>Find more information: <a href="https://github.com/pytorch/pytorch/issues/83888">https://github.com/pytorch/pytorch/issues/83888</a> and <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/accelerate-pytorch-int8-inf-with-new-x86-backend.html">https://www.intel.com/content/www/us/en/developer/articles/technical/accelerate-pytorch-int8-inf-with-new-x86-backend.html</a>.</p>

<h3 id="beta-gnn-inference-and-training-optimization-on-cpu">[Beta] GNN inference and training optimization on CPU</h3>

<p>PyTorch 2.0 includes several critical optimizations to improve GNN inference and training performance on CPU. Before 2.0, GNN models of PyG suffers from low efficiency on CPU due to lack of performance tuning for several critical kernels (scatter/gather, etc) and the lack of GNN-related sparse matrix multiplication ops. To be specific, optimizations include:</p>
<ul>
  <li>scatter_reduce: performance hotspot in Message Passing when the edge index is stored in Coordinate format (COO).</li>
  <li>gather: backward of scatter_reduce, specially tuned for the GNN compute when the index is an expanded tensor.</li>
  <li>torch.sparse.mm with reduce flag: performance hotspot in Message Passing when the edge index is stored in Compressed Sparse Row (CSR). Supported reduce flag of: sum, mean, amax, amin.</li>
</ul>

<p>On PyG benchmarks/examples, OGB benchmarks, a 1.12x - 4.07x performance speedup is measured (1.13.1 compared with 2.0) for single node inference and training.</p>

<table>
  <thead>
  <tr>
   <td scope="col"><strong>Model-Dataset</strong>
   </td>
   <td scope="col"><strong>Option</strong>
   </td>
   <td scope="col"><strong>Speedup Ratio</strong>
   </td>
  </tr>
  </thead>
  <tbody><tr>
   <td rowspan="5">GCN-Reddit (inference)
   </td>
   <td>512-2-64-dense
   </td>
   <td>1.22x
   </td>
  </tr>
  <tr>
   <td>1024-3-128-dense
   </td>
   <td>1.25x
   </td>
  </tr>
  <tr>
   <td>512-2-64-sparse
   </td>
   <td>1.31x
   </td>
  </tr>
  <tr>
   <td>1024-3-128-sparse
   </td>
   <td>1.68x
   </td>
  </tr>
  <tr>
   <td>512-2-64-dense
   </td>
   <td>1.22x
   </td>
  </tr>
  <tr>
   <td rowspan="4"> 
GraphSage-ogbn-products (inference)
   </td>
   <td>1024-3-128-dense
   </td>
   <td>1.15x
   </td>
  </tr>
  <tr>
   <td>512-2-64-sparse
   </td>
   <td>1.20x
   </td>
  </tr>
  <tr>
   <td>1024-3-128-sparse
   </td>
   <td>1.33x
   </td>
  </tr>
  <tr>
   <td>full-batch-sparse
   </td>
   <td>4.07x
   </td>
  </tr>
  <tr>
   <td>GCN-PROTEINS (training)
   </td>
   <td>3-32
   </td>
   <td>1.67x
   </td>
  </tr>
  <tr>
   <td>GCN-REDDIT-BINARY (training)
   </td>
   <td>3-32
   </td>
   <td>1.67x
   </td>
  </tr>
  <tr>
   <td rowspan="2">GCN-Reddit (training)
   </td>
   <td>512-2-64-dense
   </td>
   <td>1.20x
   </td>
  </tr>
  <tr>
   <td>1024-3-128-dense
   </td>
   <td>1.12x
   </td>
  </tr>
</tbody></table>

<p>Learn more: <a href="https://www.pyg.org/ns-newsarticle-accelerating-pyg-on-intel-cpus">PyG CPU Performance Optimization</a>.</p>

<h3 id="beta-accelerating-inference-on-cpu-with-pytorch-by-leveraging-onednn-graph">[Beta] Accelerating inference on CPU with PyTorch by leveraging oneDNN Graph</h3>

<p><a href="https://spec.oneapi.io/onednn-graph/latest/introduction.html">oneDNN Graph API</a> extends <a href="https://spec.oneapi.io/versions/latest/elements/oneDNN/source/index.html">oneDNN</a> with a flexible graph API to maximize the optimization opportunity for generating efficient code on AI hardware.</p>
<ul>
  <li>It automatically identifies the graph partitions to be accelerated via fusion.</li>
  <li>The <a href="https://github.com/oneapi-src/oneDNN/blob/dev-graph/doc/programming_model/ops_and_patterns.md#fusion-patterns">fusion patterns</a> focus on fusing compute-intensive operations such as convolution, matmul and their neighbor operations for both inference and training use cases.</li>
  <li>Although work is ongoing to integrate oneDNN Graph with TorchDynamo as well, its integration with the PyTorch JIT Fuser attained beta status in PyTorch 2.0 for <a href="https://github.com/pytorch/pytorch/tree/master/torch/csrc/jit/codegen/onednn#example-with-float">Float32</a> &amp; <a href="https://github.com/pytorch/pytorch/tree/master/torch/csrc/jit/codegen/onednn#example-with-bfloat16">BFloat16</a> inference (on machines that support AVX512_BF16 ISA).</li>
</ul>

<p>From a developer’s/researcher’s perspective, the usage is quite simple &amp; intuitive, with the only change in code being an API invocation:</p>
<ul>
  <li>Leverage oneDNN Graph, with <a href="https://pytorch.org/docs/stable/generated/torch.jit.trace.html">JIT-tracing</a>, a model is profiled with an example input.</li>
  <li>The context manager <em>with torch.jit.fuser(“fuser3”):</em> can also be used instead of invoking <em>torch.jit.enable_onednn_fusion(True)</em>.</li>
  <li>For accelerating <a href="https://github.com/pytorch/pytorch/tree/master/torch/csrc/jit/codegen/onednn#example-with-bfloat16">BFloat16 inference</a>, we rely on eager-mode AMP (Automatic Mixed Precision) support in PyTorch &amp; disable JIT mode’s AMP, as both of them are currently divergent:</li>
</ul>

<div><div><pre><code># Assuming we have a model of the name &#39;model&#39;
 
example_input = torch.rand(1, 3, 224, 224)
 
# enable oneDNN Graph
torch.jit.enable_onednn_fusion(True)
# Disable AMP for JIT
torch._C._jit_set_autocast_mode(False)
with torch.no_grad(), torch.cpu.amp.autocast():
	model = torch.jit.trace(model, (example_input))
	model = torch.jit.freeze(model)
 	# 2 warm-ups (2 for tracing/scripting with an example, 3 without an example)
	model(example_input)
	model(example_input)
 
	# speedup would be observed in subsequent runs.
	model(example_input)
</code></pre></div></div>

<p>Learn more <a href="https://pytorch.org/tutorials/recipes/recipes/tuning_guide.html#use-onednn-graph-with-torchscript-for-inference">here</a>.</p>

<h2 id="prototype-features">Prototype Features</h2>

<h3 id="distributed-api">Distributed API</h3>

<h4 id="prototype-dtensor">[Prototype] DTensor</h4>

<p>PyTorch <a href="https://github.com/pytorch/pytorch/blob/master/torch/distributed/_tensor/README.md">DistributedTensor</a> (DTensor) is a prototyping effort with distributed tensor primitives to allow easier distributed computation authoring in the SPMD (Single Program Multiple Devices) paradigm. The primitives are simple but powerful when used to express tensor distributions with both sharded and replicated parallelism strategies. PyTorch DTensor empowered PyTorch <a href="https://pytorch.org/docs/master/distributed.tensor.parallel.html">Tensor Parallelism</a> along with other advanced parallelism explorations. In addition, it also offers a uniform way to save/load state_dict for distributed checkpointing purposes, even when there’re complex tensor distribution strategies such as combining tensor parallelism with parameter sharding in FSDP. More details can be found in this <a href="https://github.com/pytorch/pytorch/issues/88838">RFC</a> and the <a href="https://colab.research.google.com/drive/12Pl5fvh0eLPUrcVO7s6yY4n2_RZo8pLR#scrollTo=stYPKb9Beq4e">DTensor examples notebook</a>.</p>

<h4 id="prototype-tensorparallel">[Prototype] TensorParallel</h4>

<p>We now support DTensor based Tensor Parallel which users can distribute their model parameters across different GPU devices. We also support Pairwise Parallel which shards two concatenated linear layers in a col-wise and row-wise style separately so that only one collective(all-reduce/reduce-scatter) is needed in the end. More details can be found in this <a href="https://github.com/pytorch/examples/blob/main/distributed/tensor_parallelism/example.py">example</a>.</p>

<h4 id="prototype-2d-parallel">[Prototype] 2D Parallel</h4>

<p>We implemented the integration of the aforementioned TP with FullyShardedDataParallel(FSDP) as 2D parallel to further scale large model training. More details can be found in this <a href="https://docs.google.com/presentation/d/17g6WqrO00rP3MsxbRENsPpjrlSkwiA_QB4r93_eB5is/edit?usp=sharing">slide</a> and <a href="https://github.com/pytorch/pytorch/blob/master/test/distributed/tensor/parallel/test_2d_parallel.py">code example</a>.</p>

<h4 id="prototype-torchcompiledynamictrue">[Prototype] torch.compile(dynamic=True)</h4>

<p>Experimental support for PT2 compilation with dynamic shapes is available in this release. Inference compilation with inductor for simple models is supported, but there are a lot of limitations:</p>

<ul>
  <li>Training available in a future release (This is partially fixed in nightlies!)</li>
  <li>Minifier available in a future release.</li>
  <li>It is easy to end up in a situation where the dimension you wanted to be dynamic gets specialized anyway. Some of these issues are fixed in nightlies, others are not.</li>
  <li>We do not appropriately propagate Inductor guards to the top-level, this is tracked at <a href="https://github.com/pytorch/pytorch/issues/96296">#96296</a>.</li>
  <li>Data-dependent operations like nonzero still require a graph break.</li>
  <li>Dynamic does not work with non-standard modes like reduce-overhead or max-autotune.</li>
  <li>There are many bugs in Inductor compilation. To track known bugs, check the <a href="https://github.com/pytorch/pytorch/issues?q=is%3Aopen+is%3Aissue+label%3A%22module%3A+dynamic+shapes%22">dynamic shapes</a> label on the PyTorch issue tracker.</li>
</ul>

<p>For the latest and greatest news about dynamic shapes support on master, check out <a href="https://dev-discuss.pytorch.org/t/state-of-symbolic-shapes-branch/777/43">our status reports</a>.</p>

<h2 id="highlightsperformance-improvements">Highlights/Performance Improvements</h2>

<h3 id="deprecation-of-cuda-116-and-python-17-support-for-pytorch-20"><a href="https://pytorch.org/blog/deprecation-cuda-python-support/">Deprecation of Cuda 11.6 and Python 1.7 support</a> for PyTorch 2.0</h3>

<p>If you are still using or depending on CUDA 11.6 or Python 3.7 builds, we strongly recommend moving to at least CUDA 11.7 and Python 3.8, as it would be the minimum versions required for PyTorch 2.0. For more detail, please refer to the <a href="https://github.com/pytorch/pytorch/blob/master/RELEASE.md#release-compatibility-matrix">Release Compatibility Matrix for PyTorch</a> releases.</p>

<h3 id="python-311-support-on-anaconda-platform">Python 3.11 support on Anaconda Platform</h3>

<p>Due to lack of Python 3.11 support for packages that PyTorch depends on, including NumPy, SciPy, SymPy, Pillow and others on the Anaconda platform. We will not be releasing Conda binaries compiled with Python 3.11 for PyTorch Release 2.0. The Pip packages with Python 3.11 support will be released, hence if you intend to use PyTorch 2.0 with Python 3.11 please use our Pip packages. Please note: Conda packages with Python 3.11 support will be made available on our nightly channel. Also we are planning on releasing Conda Python 3.11 binaries as part of future release once Anaconda provides these key dependencies. More information and instructions on how to download the Pip packages can be found <a href="https://dev-discuss.pytorch.org/t/pytorch-2-0-message-concerning-python-3-11-support-on-anaconda-platform/1087">here</a>.</p>

<h3 id="optimized-pytorch-inference-with-aws-graviton-processors">Optimized PyTorch Inference with AWS Graviton processors</h3>

<p>The optimizations focused on three key areas: GEMM kernels, bfloat16 support, primitive caching and the memory allocator. For aarch64 platforms, PyTorch supports Arm Compute Library (ACL) GEMM kernels via Mkldnn(OneDNN) backend. The ACL library provides Neon/SVE GEMM kernels for fp32 and bfloat16 formats. The bfloat16 support on c7g allows efficient deployment of bfloat16 trained, AMP (Automatic Mixed Precision) trained, or even the standard fp32 trained models. The standard fp32 models leverage bfloat16 kernels via OneDNN fast math mode, without any model quantization. Next we implemented primitive caching for conv, matmul and inner product operators. More information on the updated PyTorch user guide with the upcoming 2.0 release improvements and TorchBench benchmark details can be found <a href="https://github.com/aws/aws-graviton-getting-started">here</a>.</p>

                </article></div>
  </body>
</html>
