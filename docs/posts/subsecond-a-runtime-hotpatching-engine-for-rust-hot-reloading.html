<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/index.html">Original</a>
    <h1>Subsecond: A runtime hotpatching engine for Rust hot-reloading</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="subsecond-hot-patching-for-rust"><a href="#subsecond-hot-patching-for-rust">§</a>Subsecond: Hot-patching for Rust</h2>
<p>Subsecond is a library that enables hot-patching for Rust applications. This allows you to change
the code of a running application without restarting it. This is useful for game engines, servers,
and other long-running applications where the typical edit-compile-run cycle is too slow.</p>
<p>Subsecond also implements a technique we call “ThinLinking” which makes compiling Rust code
significantly faster in development mode, which can be used outside of hot-patching.</p>
<h2 id="usage"><a href="#usage">§</a>Usage</h2>
<p>Subsecond is designed to be as simple for both application developers and library authors.</p>
<p>Simply call your existing functions with <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/fn.call.html" title="fn subsecond::call"><code>call</code></a> and Subsecond will automatically detour
that call to the latest version of the function.</p>

<div><pre><code><span>for </span>x <span>in </span><span>0</span>..<span>5 </span>{
    subsecond::call(|| {
        <span>println!</span>(<span>&#34;Hello, world! {}&#34;</span>, x);
    });
}</code></pre></div>
<p>To actually load patches into your application, a third-party tool that implements the Subsecond
compiler and protocol is required. Subsecond is built and maintained by the Dioxus team, so we
suggest using the dioxus CLI tool to use subsecond.</p>
<p>To install the Dioxus CLI, we recommend using <a href="https://crates.io/crates/cargo-binstall"><code>cargo binstall</code></a>:</p>
<div><pre><code>cargo binstall dioxus-cli</code></pre></div>
<p>The Dioxus CLI provides several tools for development. To run your application with Subsecond enabled,
use <code>dx serve</code> - this takes the same arguments as <code>cargo run</code> but will automatically hot-reload your
application when changes are detected.</p>
<p>As of Dioxus 0.7, “–hotpatch” is required to use hotpatching while Subsecond is still experimental.</p>
<h3 id="how-it-works"><a href="#how-it-works">§</a>How it works</h3>
<p>Subsecond works by detouring function calls through a jump table. This jump table contains the latest
version of the program’s function pointers, and when a function is called, Subsecond will look up
the function in the jump table and call that instead.</p>
<p>Unlike libraries like <a href="https://crates.io/crates/detour">detour</a>, Subsecond <em>does not</em> modify your
process memory. Patching pointers is wildly unsafe and can lead to crashes and undefined behavior.</p>
<p>Instead, an external tool compiles only the parts of your project that changed, links them together
using the addresses of the functions in your running program, and then sends the new jump table to
your application. Subsecond then applies the patch and continues running. Since Subsecond doesn’t
modify memory, the program must have a runtime integration to handle the patching.</p>
<p>If the framework you’re using doesn’t integrate with subsecond, you can rely on the fact that calls
to stale <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/fn.call.html" title="fn subsecond::call"><code>call</code></a> instances will emit a safe panic that is automatically caught and retried
by the next <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/fn.call.html" title="fn subsecond::call"><code>call</code></a> instance up the callstack.</p>
<p>Subsecond is only enabled when debug_assertions are enabled so you can safely ship your application
with Subsecond enabled without worrying about the performance overhead.</p>
<h3 id="workspace-support"><a href="#workspace-support">§</a>Workspace support</h3>
<p>Subsecond currently only patches the “tip” crate - ie the crate in which your <code>main.rs</code> is located.
Changes to crates outside this crate will be ignored, which can be confusing. We plan to add full
workspace support in the future, but for now be aware of this limitation. Crate setups that have
a <code>main.rs</code> importing a <code>lib.rs</code> won’t patch sensibly since the crate becomes a library for itself.</p>
<p>This is due to limitations in rustc itself where the build-graph is non-deterministic and changes
to functions that forward generics can cause a cascade of codegen changes.</p>
<h3 id="globals-statics-and-thread-locals"><a href="#globals-statics-and-thread-locals">§</a>Globals, statics, and thread-locals</h3>
<p>Subsecond <em>does</em> support hot-reloading of globals, statics, and thread locals. However, there are several limitations:</p>
<ul>
<li>You may add new globals at runtime, but their destructors will never be called.</li>
<li>Globals are tracked across patches, but will renames are considered to be <em>new</em> globals.</li>
<li>Changes to static initializers will not be observed.</li>
</ul>
<p>Subsecond purposefully handles statics this way since many libraries like Dioxus and Tokio rely
on persistent global runtimes.</p>
<p>HUGE WARNING: Currently, thread-locals in the “tip” crate (the one being patched) will seemingly
reset to their initial value on new patches. This is because we don’t currently bind thread-locals
in the patches to their original addresses in the main program. If you rely on thread-locals heavily
in your tip crate, you should be aware of this. Sufficiently complex setups might crash or even
segfault. We plan to fix this in the future, but for now, you should be aware of this limitation.</p>
<h3 id="struct-layout-and-alignment"><a href="#struct-layout-and-alignment">§</a>Struct layout and alignment</h3>
<p>Subsecond currently does not support hot-reloading of structs. This is because the generated code
assumes a particular layout and alignment of the struct. If layout or alignment change and new
functions are called referencing an old version of the struct, the program will crash.</p>
<p>To mitigate this, framework authors can integrate with Subsecond to either dispose of the old struct
or to re-allocate the struct in a way that is compatible with the new layout. This is called “re-instancing.”</p>
<p>In practice, frameworks that implement subsecond patching properly will throw out the old state
and thus you should never witness a segfault due to misalignment or size changes. Frameworks are
encouraged to aggressively dispose of old state that might cause size and alignment changes.</p>
<p>We’d like to lift this limitation in the future by providing utilities to re-instantiate structs,
but for now it’s up to the framework authors to handle this. For example, Dioxus apps simply throw
out the old state and rebuild it from scratch.</p>
<h3 id="pointer-versioning"><a href="#pointer-versioning">§</a>Pointer versioning</h3>
<p>Currently, Subsecond does not “version” function pointers. We have plans to provide this metadata
so framework authors can safely memoize changes without much runtime overhead. Frameworks like
Dioxus and Bevy circumvent this issue by using the TypeID of structs passed to hot functions as
well as the <code>ptr_address</code> method on <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/struct.HotFn.html" title="struct subsecond::HotFn"><code>HotFn</code></a> to determine if the function pointer has changed.</p>
<p>Currently, the <code>ptr_address</code> method will always return the most up-to-date version of the function
even if the function contents itself did not change. In essence, this is equivalent to a version
of the function where every function is considered “new.” This means that framework authors who
integrate re-instancing in their apps might dispose of old state too aggressively. For now, this
is the safer and more practical approach.</p>
<h3 id="nesting-calls"><a href="#nesting-calls">§</a>Nesting Calls</h3>
<p>Subsecond calls are designed to be nested. This provides clean integration points to know exactly
where a hooked function is called.</p>
<p>The highest level call is <code>fn main()</code> though by default this is not hooked since initialization code
tends to be side-effectual and modify global state. Instead, we recommend wrapping the hot-patch
points manually with <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/fn.call.html" title="fn subsecond::call"><code>call</code></a>.</p>

<div><pre><code><span>fn </span>main() {
    subsecond::call(|| {
        <span>for </span>x <span>in </span><span>0</span>..<span>5 </span>{
            subsecond::call(|| {
                <span>println!</span>(<span>&#34;Hello, world! {}&#34;</span>, x);
            });
        }
   });
}</code></pre></div>
<p>The goal here is to provide granular control over where patches are applied to limit loss of state
when new code is loaded.</p>
<h3 id="applying-patches"><a href="#applying-patches">§</a>Applying patches</h3>
<p>When running under the Dioxus CLI, the <code>dx serve</code> command will automatically apply patches when
changes are detected. Patches are delivered over the <a href="https://crates.io/crates/dioxus-devtools">Dioxus Devtools</a>
websocket protocol and received by corresponding websocket.</p>
<p>If you’re using Subsecond in your own application that doesn’t have a runtime integration, you can
build an integration using the <a href="https://docs.rs/subsecond/0.7.0-alpha.1/subsecond/fn.apply_patch.html" title="fn subsecond::apply_patch"><code>apply_patch</code></a> function. This function takes a <code>JumpTable</code> which
the dioxus-cli crate can generate.</p>
<p>To add support for the Dioxus Devtools protocol to your app, you can use the <a href="https://crates.io/crates/dioxus-devtools">dioxus-devtools</a>
crate which provides a <code>connect</code> method that will automatically apply patches to your application.</p>
<p>Unfortunately, one design quirk of Subsecond is that running apps need to communicate the address
of <code>main</code> to the patcher. This is due to a security technique called <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>
which randomizes the address of functions in memory. See the subsecond-harness and subsecond-cli
for more details on how to implement the protocol.</p>
<h3 id="thinlink"><a href="#thinlink">§</a>ThinLink</h3>
<p>ThinLink is a program linker for Rust that is designed to be used with Subsecond. It implements
the powerful patching system that Subsecond uses to hot-reload Rust applications.</p>
<p>ThinLink is simply a wrapper around your existing linker but with extra features:</p>
<ul>
<li>Automatic dynamic linking to dependencies</li>
<li>Generation of Subsecond jump tables</li>
<li>Diffing of object files for function invalidation</li>
</ul>
<p>Because ThinLink performs very to little actual linking, it drastically speeds up traditional Rust
development. With a development-optimized profile, ThinLink can shrink an incremental build to less than 500ms.</p>
<p>ThinLink is automatically integrated into the Dioxus CLI though it’s currently not available as
a standalone tool.</p>
<h3 id="limitations"><a href="#limitations">§</a>Limitations</h3>
<p>Subsecond is a powerful tool but it has several limitations. We talk about them above, but here’s
a quick summary:</p>
<ul>
<li>Struct hot reloading requires instancing or unwinding</li>
<li>Statics are tracked but not destructed</li>
</ul>
<h3 id="platform-support"><a href="#platform-support">§</a>Platform support</h3>
<p>Subsecond works across all major platforms:</p>
<ul>
<li>Android (arm64-v8a, armeabi-v7a)</li>
<li>iOS (arm64)</li>
<li>Linux (x86_64, aarch64)</li>
<li>macOS (x86_64, aarch64)</li>
<li>Windows (x86_64, arm64)</li>
<li>WebAssembly (wasm32)</li>
</ul>
<p>If you have a new platform you’d like to see supported, please open an issue on the Subsecond repository.
We are keen to add support for new platforms like wasm64, riscv64, and more.</p>
<p>Note that iOS device is currently not supported due to code-signing requirements. We hope to fix
this in the future, but for now you can use the simulator to test your app.</p>
<h3 id="adding-the-subsecond-badge-to-your-project"><a href="#adding-the-subsecond-badge-to-your-project">§</a>Adding the Subsecond badge to your project</h3>
<p>If you’re a framework author and want your users to know that your library supports Subsecond, you
can add the Subsecond badge to your README! Users will know that your library is hot-reloadable and
can be used with Subsecond.</p>
<p><a href="https://crates.io/crates/subsecond"><img src="https://img.shields.io/badge/Subsecond-Enabled-orange" alt="Subsecond"/></a></p>
<div><pre><code>[![Subsecond](https://img.shields.io/badge/Subsecond-Enabled-orange)](https://crates.io/crates/subsecond)</code></pre></div><h3 id="license"><a href="#license">§</a>License</h3>
<p>Subsecond and ThinLink are licensed under the MIT license. See the LICENSE file for more information.</p>
<h3 id="supporting-this-work"><a href="#supporting-this-work">§</a>Supporting this work</h3>
<p>Subsecond is a project by the Dioxus team. If you’d like to support our work, please consider
<a href="https://github.com/sponsors/DioxusLabs">sponsoring us on GitHub</a> or eventually deploying your
apps with Dioxus Deploy (currently under construction).</p>
</div></div>
  </body>
</html>
