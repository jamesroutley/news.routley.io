<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/drinking-from-the-bluesky-firehose/">Original</a>
    <h1>Drinking from the Bluesky Firehose</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-onuac4el=""> 
<p>I recently built a Bluesky bot called <a href="https://bsky.app/profile/linknotifier.bsky.social" data-astro-cid-bi7aps5f="">Link Notifier</a><a data-tooltip="" href="https://bsky.app/profile/linknotifier.bsky.social" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Link Notifier (@linknotifier.bsky.social)</span> <span data-astro-cid-bi7aps5f="">Follow me to receive a DM whenever someone posts a link to your website!

Made by @jakelazaroff.com</span> <span data-astro-cid-bi7aps5f=""> <img src="https://bsky.app/static/favicon-32x32.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">bsky.app/profile/linknotifier.bsky.social</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> that sends you a DM whenever someone posts a link to your website.
To build it, I had to dig into the Bluesky firehose.
That seems like a pretty common entry point for people looking to build on top of Bluesky, so I figured I’d share what I learned.</p>
<p>There are a couple ways to get at the Bluesky firehose:</p>
<ol>
<li>Consume it directly.
This is pretty complex, involving binary WebSocket messages containing CBOR-encoded Merkle Search Tree blocks.
If reading that makes you feel adrift in a sea of jargon, you’re not alone!</li>
<li>Use <a href="https://github.com/bluesky-social/jetstream" data-astro-cid-bi7aps5f="">Jetstream</a><a data-tooltip="" href="https://github.com/bluesky-social/jetstream" data-astro-cid-bi7aps5f=""> <img src="https://opengraph.githubassets.com/cdfe3125e4c017e24ccdf56aae681ec242a05bdc6b10c02746eedfb10c73bb7c/bluesky-social/jetstream" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">GitHub - bluesky-social/jetstream: A simplified JSON event stream for AT Proto</span> <span data-astro-cid-bi7aps5f="">A simplified JSON event stream for AT Proto. Contribute to bluesky-social/jetstream development by creating an account on GitHub.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://github.githubassets.com/favicons/favicon.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">github.com/bluesky-social/jetstream</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, a first-party Bluesky service that converts the firehose into normal JSON.<sup><a href="#user-content-fn-readinglist" id="user-content-fnref-readinglist" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup>
You can self-host it if you want, but Bluesky provides official instances that you can connect to.</li>
</ol>
<p>You might be tempted — as I was at first — to avoid <em>all</em> the gory details and just reach for a library like <a href="https://www.npmjs.com/package/@skyware/jetstream" data-astro-cid-bi7aps5f=""><code>@skyware/jetstream</code></a><a data-tooltip="" href="https://www.npmjs.com/package/@skyware/jetstream" data-astro-cid-bi7aps5f=""> <img src="https://static-production.npmjs.com/338e4905a2684ca96e08c7780fc68412.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">@skyware/jetstream</span> <span data-astro-cid-bi7aps5f="">A fully typed client for the Bluesky Jetstream (https://github.com/bluesky-social/jetstream) service.. Latest version: 0.2.0, last published: a month ago. Start using @skyware/jetstream in your project by running `npm i @skyware/jetstream`. There are no other projects in the npm registry using @skyware/jetstream.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://static-production.npmjs.com/b0f1a8318363185cc2ea6a40ac23eeb2.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">www.npmjs.com/package/@skyware/jetstream</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</p>
<p><em>Don’t be intimidated!</em>
The Jetstream API is actually remarkably simple, and you can easily consume it without adding a dependency to your project.</p>
<p>Here’s a small example running in the browser that consumes the Bluesky Jetstream: a web component that shows the latest post every second.
(This is totally unfiltered; I’m sorry if anything unsavory shows up here.)</p>
<bluesky-jetstream></bluesky-jetstream>
<p>The <em>full code</em> of this component is less than 40 lines — including the templating and all the web component boilerplate!
The code that reads from the Jetstream takes up about six.
There are no dependencies outside of the browser’s standard library.</p>
<p>Before we look at any code, though, let’s take a quick detour through the AT Protocol and Jetstream API.</p>
<h3 id="the-jetstream-api">The Jetstream API</h3>
<p>Jetstream is a WebSocket server: we connect via a WebSocket connection, and it sends events as WebSocket messages encoded in JSON.
You can host a Jetstream instance yourself, but as of today Bluesky hosts official instances that you can use without authentication.</p>
<p>The connection string for a Jetstream instance looks like this:</p>
<pre><code is:raw="">wss://jetstream2.us-west.bsky.network/subscribe</code></pre>
<p>Once you’re connected, Jetstream will start sending events.
They look like this:</p>
<pre><code is:raw=""><span>{</span>
  <span>&#34;did&#34;</span><span>:</span> <span>&#34;did:plc:eygmaihciaxprqvxpfvl6flk&#34;</span><span>,</span>
  <span>&#34;time_us&#34;</span><span>:</span> <span>1725911162329308</span><span>,</span>
  <span>&#34;kind&#34;</span><span>:</span> <span>&#34;commit&#34;</span><span>,</span>
  <span>&#34;commit&#34;</span><span>:</span> <span>{</span>
    <span>&#34;rev&#34;</span><span>:</span> <span>&#34;3l3qo2vutsw2b&#34;</span><span>,</span>
    <span>&#34;operation&#34;</span><span>:</span> <span>&#34;create&#34;</span><span>,</span>
    <span>&#34;collection&#34;</span><span>:</span> <span>&#34;app.bsky.feed.like&#34;</span><span>,</span>
    <span>&#34;rkey&#34;</span><span>:</span> <span>&#34;3l3qo2vuowo2b&#34;</span><span>,</span>
    <span>&#34;record&#34;</span><span>:</span> <span>{</span>
      <span>&#34;$type&#34;</span><span>:</span> <span>&#34;app.bsky.feed.like&#34;</span><span>,</span>
      <span>&#34;createdAt&#34;</span><span>:</span> <span>&#34;2024-09-09T19:46:02.102Z&#34;</span><span>,</span>
      <span>&#34;subject&#34;</span><span>:</span> <span>{</span>
        <span>&#34;cid&#34;</span><span>:</span> <span>&#34;bafyreidc6sydkkbchcyg62v77wbhzvb2mvytlmsychqgwf2xojjtirmzj4&#34;</span><span>,</span>
        <span>&#34;uri&#34;</span><span>:</span> <span>&#34;at://did:plc:wa7b35aakoll7hugkrjtf3xf/app.bsky.feed.post/3l3pte3p2e325&#34;</span>
      <span>}</span>
    <span>}</span><span>,</span>
    <span>&#34;cid&#34;</span><span>:</span> <span>&#34;bafyreidwaivazkwu67xztlmuobx35hs2lnfh3kolmgfmucldvhd3sgzcqi&#34;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>That’s the full event of a post being liked.</p>
<p>It’s pretty dense!
There are bunch of terms like “collection” and “did” that are idiosyncratic to AT Protocol.
Most of them can be found in <a href="https://atproto.com/guides/glossary" data-astro-cid-bi7aps5f="">the glossary</a><a data-tooltip="" href="https://atproto.com/guides/glossary" data-astro-cid-bi7aps5f=""> <img src="https://atproto.com/default-social-card.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Glossary of terms - AT Protocol</span> <span data-astro-cid-bi7aps5f="">A collection of terminology used in the AT Protocol and their definitions.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://atproto.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">atproto.com/guides/glossary</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, but I’ll try to define them in my own words as they come up as well.</p>
<p>In AT Protocol, everything a user does is found in a repo.
Each repo has a DID: a Decentralized ID that uniquely identifies it.
The ‌<code>did</code> property at the root of the event object is a reference to the repo of the user who took the action (in this case, the user who liked the post).</p>
<p>The <code>kind</code> property disambiguates between three types of events:</p>
<ul>
<li><code>commit</code> for events that create, update or delete something in a repo.</li>
<li><code>identity</code> for events that describe some change to the repo itself (not quite sure which — I assume changing a handle would be one example).</li>
<li><code>account</code> for events that describe a change in account status (e.g. from “active” to “deactivated”).</li>
</ul>
<p>For our purposes, we’re only worried about <code>commit</code> events.
Those events all have a nested <code>commit</code> object with an <code>operation</code> property: <code>create</code>, <code>update</code> or <code>delete</code>.
I’ll let you guess what those mean.</p>
<p>Each commit object also has a <code>collection</code> property.
This is way to “group” events across repos.
For example, to listen to all new posts, we’d ignore all events in collections other than <code>app.bsky.feed.post</code>.</p>
<p>If we do all the filtering in the client, we’d be receiving a ton of data we don’t need.
Jetstream provides a way to avoid this: append a <code>wantedCollections</code> query string parameter to the connection string.<sup><a href="#user-content-fn-options" id="user-content-fnref-options" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup></p>
<p>Say we’re only interested in new posts and likes.
We’d connect to this long URL:</p>
<pre><code is:raw="">wss://jetstream2.us-west.bsky.network/subscribe?wantedCollections=app.bsky.feed.post&amp;wantedCollections=app.bsky.feed.like‌</code></pre>
<p>That wouldn’t absolve us of the need to filter on the client — we’d still need to branch between new posts and likes within our app — but it would prevent us from sifting through a ton of <em>other</em> events we don’t care about.</p>
<p>We can also use asterisks as “wildcards” to filter through multiple collections at once.
For example, to get events in all feed collections, we’d set <code>wantedCollections</code> to <code>app.bsky.feed.*</code>.</p>
<p>On <code>create</code> and <code>update</code> commits, the <code>record</code> is the “contents” of it — either the thing that was just created, or the thing with which to replace the <em>previous</em> record.
As a reminder, here’s what the record looked like in the example event:</p>
<pre><code is:raw=""><span>{</span>
  <span>&#34;$type&#34;</span><span>:</span> <span>&#34;app.bsky.feed.like&#34;</span><span>,</span>
  <span>&#34;createdAt&#34;</span><span>:</span> <span>&#34;2024-09-09T19:46:02.102Z&#34;</span><span>,</span>
  <span>&#34;subject&#34;</span><span>:</span> <span>{</span>
    <span>&#34;cid&#34;</span><span>:</span> <span>&#34;bafyreidc6sydkkbchcyg62v77wbhzvb2mvytlmsychqgwf2xojjtirmzj4&#34;</span><span>,</span>
    <span>&#34;uri&#34;</span><span>:</span> <span>&#34;at://did:plc:wa7b35aakoll7hugkrjtf3xf/app.bsky.feed.post/3l3pte3p2e325&#34;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>And here’s what a record might look like for posts:</p>
<pre><code is:raw=""><span>{</span>
  <span>&#34;$type&#34;</span><span>:</span> <span>&#34;app.bsky.feed.post&#34;</span><span>,</span>
  <span>&#34;text&#34;</span><span>:</span> <span>&#34;Hello World!&#34;</span><span>,</span>
  <span>&#34;createdAt&#34;</span><span>:</span> <span>&#34;2023-08-07T05:31:12.156888Z&#34;</span>
<span>}</span></code></pre>
<p>This is a minimal example; Bluesky’s <a href="https://docs.bsky.app/docs/advanced-guides/posts" data-astro-cid-bi7aps5f="">documentation</a><a data-tooltip="" href="https://docs.bsky.app/docs/advanced-guides/posts" data-astro-cid-bi7aps5f=""> <img src="https://docs.bsky.app/img/social-card-default.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Posts | Bluesky</span> <span data-astro-cid-bi7aps5f="">This is an in-depth dive into how creating a post works on Bluesky. We&#39;ll use Python below, without a SDK, so you can see how it works behind the scenes.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://docs.bsky.app/img/favicon.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">docs.bsky.app/docs/advanced-guides/posts</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> details how to handle links, quotes and so forth.
Notice that in some cases (such as the <code>text</code> property of a post record) the record itself contains information, while in others (such as the <code>subject</code> property of a like record) it contains references to other records.</p>
<h3 id="the-client">The Client</h3>
<p>The simplest possible Jetstream client looks something like this:</p>
<pre><code is:raw=""><span>const</span> jetstream <span>=</span> <span>new</span> <span>WebSocket</span><span>(</span><span>&#34;wss://jetstream1.us-east.bsky.network/subscribe&#34;</span><span>)</span><span>;</span>
jetstream<span>.</span><span>onmessage</span> <span>=</span> e <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span>e<span>.</span>data<span>)</span><span>;</span></code></pre>
<p>Voilà: two lines of code and every event from the Bluesky firehose gets logged to the console!</p>
<p>With a little elbow grease, we can come up with something a little more ergonomic.
Let’s write a client that mimics the <code>@skyware/jetstream</code> API:</p>
<pre><code is:raw=""><span>const</span> jetstream <span>=</span> <span>new</span> <span>Jetstream</span><span>(</span><span>)</span><span>;</span>

jetstream<span>.</span><span>onCreate</span><span>(</span><span>&#34;app.bsky.graph.follow&#34;</span><span>,</span> event <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>}</span><span>)</span><span>;</span>

jetstream<span>.</span><span>onDelete</span><span>(</span><span>&#34;app.bsky.feed.post&#34;</span><span>,</span> event <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>}</span><span>)</span><span>;</span>

jetstream<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span></code></pre>
<p>This is still a pretty simple client that doesn’t cover everything we might ever want to do with Jetstream, but it’s more than enough to get us started.</p>
<p>We’ll start by writing a <code>Jetstream</code> class:</p>
<pre><code is:raw=""><span>class</span> <span>Jetstream</span> <span>{</span>
  endpoint <span>=</span> <span>&#34;jetstream1.us-east.bsky.network&#34;</span><span>;</span>
  emitters <span>=</span> <span>new</span> <span>Map<span>&lt;</span><span>string</span><span>,</span> EventTarget<span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
  ws<span>?</span><span>:</span> WebSocket<span>;</span>

  <span>constructor</span><span>(</span>options<span>:</span> <span>{</span> endpoint<span>?</span><span>:</span> <span>string</span> <span>}</span> <span>=</span> <span>{</span><span>}</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>endpoint <span>=</span> options<span>.</span>endpoint <span>??</span> <span>this</span><span>.</span>endpoint<span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>By default, our client connects to the Bluesky-hosted Jetstream instance at <code>jetstream1.us-east.bsky.network</code>.
The user can override that by passing an endpoint into the constructor.</p>
<p>We also see two additional members:</p>
<ul>
<li><code>emitters</code>, which holds a map of <code>EventTarget</code>s keyed by the collection names.</li>
<li><code>ws</code>, which will hold the WebSocket client when we connect to the Jetstream instance.</li>
</ul>
<p>First, we’ll write a private <code>#listen</code> method that calls an event listener when the client receives an in a given collection with a specific operation:</p>
<pre><code is:raw=""><span>class</span> <span>Jetstream</span> <span>{</span>
  <span>// ...</span>

  <span>#listen</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> operation<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>const</span> emitter <span>=</span> <span>this</span><span>.</span>emitters<span>.</span><span>get</span><span>(</span>collection<span>)</span> <span>||</span> <span>new</span> <span>EventTarget</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>emitters<span>.</span><span>set</span><span>(</span>collection<span>,</span> emitter<span>)</span><span>;</span>

    emitter<span>.</span><span>addEventListener</span><span>(</span>operation<span>,</span> event <span>=&gt;</span> <span>listener</span><span>(</span>event<span>.</span>detail<span>)</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>It gets an <code>EventTarget</code> from the map at the given collection key — creating one if it doesn’t exist — and attaches an event listener for events matching the given commit operation.<sup><a href="#user-content-fn-unknown" id="user-content-fnref-unknown" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup></p>
<p>When we’re dispatching the events later, we’ll use <code>CustomEvent</code>s, which allow you to include arbitrary data in their <code>detail</code> property.
Since the use of <code>CustomEvent</code>s is an implementation detail, we’ll just pass that property to the listener, rather than the whole event.</p>
<p>From here, we can make public wrapper methods for each of those commit operations:</p>
<pre><code is:raw=""><span>class</span> <span>Jetstream</span> <span>{</span>
  <span>// ...</span>

  <span>onCreate</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>#listen</span><span>(</span>collection<span>,</span> <span>&#34;create&#34;</span><span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>

  <span>onUpdate</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>#listen</span><span>(</span>collection<span>,</span> <span>&#34;update&#34;</span><span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>

  <span>onDelete</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>#listen</span><span>(</span>collection<span>,</span> <span>&#34;delete&#34;</span><span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>These don’t really do much other than make that <code>#listen</code> method slightly more convenient to use.</p>
<p>Next, let’s take a look at the <code>start</code> method:</p>
<pre><code is:raw=""><span>class</span> <span>Jetstream</span> <span>{</span>
  <span>// ...</span>

  <span>start</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>ws<span>)</span> <span>this</span><span>.</span>ws<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

    <span>this</span><span>.</span>ws <span>=</span> <span>new</span> <span>WebSocket</span><span>(</span><span>this</span><span>.</span>url<span>)</span><span>;</span>
    <span>this</span><span>.</span>ws<span>.</span><span>onmessage</span> <span>=</span> ev <span>=&gt;</span> <span>{</span>
      <span>const</span> data <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>ev<span>.</span>data<span>)</span><span>;</span>
      <span>if</span> <span>(</span>data<span>.</span>kind <span>!==</span> <span>&#34;commit&#34;</span><span>)</span> <span>return</span><span>;</span>

      <span>const</span> emitter <span>=</span> <span>this</span><span>.</span>emitters<span>.</span><span>get</span><span>(</span>data<span>.</span>commit<span>.</span>collection<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>!</span>emitter<span>)</span> <span>return</span><span>;</span>

      emitter<span>.</span><span>dispatch</span><span>(</span><span>new</span> <span>CustomEvent</span><span>(</span>data<span>.</span>commit<span>.</span>operation<span>,</span> <span>{</span> detail<span>:</span> data <span>}</span><span>)</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>This looks pretty familiar: it’s a thin abstraction over the barebones client we saw earlier.</p>
<ol>
<li>First, if there’s already an open WebSocket connection, close it.</li>
<li>Next, set up a new WebSocket connection at the appropriate URL.</li>
<li>When we receive a message, parse the data into JSON.</li>
<li>Discard any non-<code>commit</code> events.</li>
<li>Get the event emitter corresponding to the event’s collection.</li>
<li>Dispatch the event using the commit operation as a key.</li>
</ol>
<p>Sharp-eyed readers might notice that we haven’t defined the class’s <code>url</code> member yet:</p>
<pre><code is:raw=""><span>class</span> <span>Jetstream</span> <span>{</span>
  <span>// ...</span>

  <span>get</span> <span>url</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> url <span>=</span> <span>new</span> <span><span>URL</span></span><span>(</span><span><span>`</span><span>wss://</span><span><span>${</span><span>this</span><span>.</span>endpoint<span>}</span></span><span>/subscribe</span><span>`</span></span><span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>const</span> collection <span>of</span> <span>this</span><span>.</span>emitters<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      url<span>.</span>searchParams<span>.</span><span>append</span><span>(</span><span>&#34;wantedCollections&#34;</span><span>,</span> collection<span>)</span><span>;</span>
    <span>}</span>

    <span>return</span> url<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>It’s a getter that constructs the WebSocket URL, adding <code>wantedCollections</code> query string parameters for any collections in which we’re listening for events.
That way, we’ll only receive the slice of the Jetstream containing the collections we care about.</p>
<p>For posterity, here’s the full code:</p>
<pre><code is:raw=""><span>class</span> <span>Jetstream</span> <span>{</span>
  endpoint <span>=</span> <span>&#34;jetstream1.us-east.bsky.network&#34;</span><span>;</span>
  emitters <span>=</span> <span>new</span> <span>Map<span>&lt;</span><span>string</span><span>,</span> EventTaret<span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
  ws<span>?</span><span>:</span> WebSocket<span>;</span>

  <span>get</span> <span>url</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> url <span>=</span> <span>new</span> <span><span>URL</span></span><span>(</span><span><span>`</span><span>wss://</span><span><span>${</span><span>this</span><span>.</span>endpoint<span>}</span></span><span>/subscribe</span><span>`</span></span><span>)</span><span>;</span>

    <span>for</span> <span>(</span><span>const</span> collection <span>of</span> <span>this</span><span>.</span>emitters<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      url<span>.</span>searchParams<span>.</span><span>append</span><span>(</span><span>&#34;wantedCollections&#34;</span><span>,</span> collection<span>)</span><span>;</span>
    <span>}</span>

    <span>return</span> url<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>constructor</span><span>(</span>options<span>:</span> <span>{</span> endpoint<span>?</span><span>:</span> <span>string</span> <span>}</span> <span>=</span> <span>{</span><span>}</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>endpoint <span>=</span> options<span>.</span>endpoint <span>??</span> <span>this</span><span>.</span>endpoint<span>;</span>
  <span>}</span>

  <span>#listen</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> operation<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>const</span> emitter <span>=</span> <span>this</span><span>.</span>emitters<span>.</span><span>get</span><span>(</span>collection<span>)</span> <span>||</span> <span>new</span> <span>EventTarget</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>emitters<span>.</span><span>set</span><span>(</span>collection<span>,</span> emitter<span>)</span><span>;</span>

    emitter<span>.</span><span>addEventListener</span><span>(</span>operation<span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>

  <span>onCreate</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>#listen</span><span>(</span>collection<span>,</span> <span>&#34;create&#34;</span><span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>

  <span>onUpdate</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>#listen</span><span>(</span>collection<span>,</span> <span>&#34;update&#34;</span><span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>

  <span>onDelete</span><span>(</span>collection<span>:</span> <span>string</span><span>,</span> <span>listener</span><span>:</span> <span>(</span>event<span>:</span> <span>unknown</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>#listen</span><span>(</span>collection<span>,</span> <span>&#34;delete&#34;</span><span>,</span> listener<span>)</span><span>;</span>
  <span>}</span>

  <span>start</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>ws<span>)</span> <span>this</span><span>.</span>ws<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

    <span>this</span><span>.</span>ws <span>=</span> <span>new</span> <span>WebSocket</span><span>(</span><span>this</span><span>.</span>url<span>)</span><span>;</span>
    <span>this</span><span>.</span>ws<span>.</span><span>onmessage</span> <span>=</span> ev <span>=&gt;</span> <span>{</span>
      <span>const</span> data <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>ev<span>.</span>data<span>)</span><span>;</span>
      <span>if</span> <span>(</span>data<span>.</span>kind <span>!==</span> <span>&#34;commit&#34;</span><span>)</span> <span>return</span><span>;</span>

      <span>const</span> emitter <span>=</span> <span>this</span><span>.</span>emitters<span>.</span><span>get</span><span>(</span>data<span>.</span>commit<span>.</span>collection<span>)</span><span>;</span>
      <span>if</span> <span>(</span><span>!</span>emitter<span>)</span> <span>return</span><span>;</span>

      emitter<span>.</span><span>dispatch</span><span>(</span><span>new</span> <span>CustomEvent</span><span>(</span>data<span>.</span>commit<span>.</span>operation<span>,</span> <span>{</span> detail<span>:</span> data <span>}</span><span>)</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>40 lines of code and we’ve replicated a significant portion of <code>@skyware/jetstream</code>!
Use it, modify it and make something cool.</p>

<section data-footnotes="">
<ol>
<li id="user-content-fn-readinglist">
<p>There’s an <a href="https://docs.bsky.app/blog/jetstream" data-astro-cid-bi7aps5f="">official blog post</a><a data-tooltip="" href="https://docs.bsky.app/blog/jetstream" data-astro-cid-bi7aps5f=""> <img src="https://docs.bsky.app/img/social-card-default.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Introducing Jetstream | Bluesky</span> <span data-astro-cid-bi7aps5f="">One of most popular aspects of atproto for developers is the firehose: an aggregated stream of all the public data updates in the network. Independent developers have used the firehose to build real-time monitoring tools (like Firesky), feed generators, labeling services, bots, entire applications, and more.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://docs.bsky.app/img/favicon.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">docs.bsky.app/blog/jetstream</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> announcing it, as well as <a href="https://jazco.dev/2024/09/24/jetstream/" data-astro-cid-bi7aps5f="">a more in-depth explanation on the original author Jaz’s blog</a><a data-tooltip="" href="https://jazco.dev/2024/09/24/jetstream/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Jetstream: Shrinking the AT Proto Firehose by &gt;99%</span> <span data-astro-cid-bi7aps5f="">Jetstream is a streaming service that consumes an AT Proto Sync Firehose and converts it into lightweight, filterable, friendly JSON, allowing us to live tail all posts on Bluesky for as little as ~850 MB/day</span> <span data-astro-cid-bi7aps5f=""> <img src="https://jazco.dev/public/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jazco.dev/2024/09/24/jetstream/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.
Both are worth reading, but not required to understand the rest of this article. <a href="#user-content-fnref-readinglist" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-options">
<p>There are a bunch of other options as well.
For instance, you can have Jetstream only send events for specific repos by including a <code>wantedDids</code> query string parameter.
All the options are listed in the GitHub readme. <a href="#user-content-fnref-options" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-unknown">
<p>Why does the listener take an event of type <code>unknown</code>?
Technically, Jetstream could send <em>anything</em> over the wire!
<code>@skyware/jetstream</code> provides a typed event definition, but they just cast the type rather than actually checking that it’s correct.
If you want type safety, you should parse the incoming events using a library like <a href="https://valibot.dev" data-astro-cid-bi7aps5f="">Valibot</a><a data-tooltip="" href="https://valibot.dev" data-astro-cid-bi7aps5f=""> <img src="https://valibot.dev/og-image" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Valibot: The modular and type safe schema library</span> <span data-astro-cid-bi7aps5f="">Validate unknown data with Valibot, the open source schema library with bundle size, type safety and developer experience in mind.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://valibot.dev/icon-32px.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">valibot.dev</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>. <a href="#user-content-fnref-unknown" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
</ol>
</section> </div></div>
  </body>
</html>
