<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2019/02/08/faster-remainders-when-the-divisor-is-a-constant-beating-compilers-and-libdivide/">Original</a>
    <h1>Faster remainders when divisor is a constant: beating compilers and libdivide</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Not all instructions on modern processors cost the same. Additions and subtractions are cheaper than multiplications which are themselves cheaper than divisions. For this reason, compilers frequently replace division instructions by multiplications. Roughly speaking, it works in this manner. Suppose that you want to divide a variable <tt>n</tt> by a constant <tt>d</tt>. You have that <tt>n/d</tt> = <tt>n</tt> <tt>*</tt> (2<sup>N</sup>/<tt>d</tt>) <tt>/</tt> (2<sup>N</sup>). The division by a power of two (<tt>/</tt> (2<sup>N</sup>)) can be implemented as a right shift if we are working with unsigned integers, which compiles to single instruction: that is possible because the underlying hardware uses a base 2. Thus if 2<sup>N</sup>/<tt>d</tt> has been precomputed, you can compute the division <tt>n/d</tt> as a multiplication and a shift. Of course, if <tt>d</tt> is not a power of two, 2<sup>N</sup>/<tt>d</tt> cannot be represented as an integer. Yet for <tt>N</tt> large enough<sup><a href="#footnote123">footnote</a></sup>, we can approximate 2<sup>N</sup>/<tt>d</tt> by an integer and have the exact computation of the remainder for all possible <tt>n</tt> within a range. I believe that all optimizing C/C++ compilers know how to pull this trick and it is generally beneficial irrespective of the processor’s architecture.</p>
<p>The idea is not novel and goes back to at least 1973 (Jacobsohn). However, engineering matters because computer registers have finite number of bits, and multiplications can overflow. I believe that, historically, this was first introduced into a major compiler (the GNU GCC compiler) by <a href="https://dl.acm.org/citation.cfm?id=178249">Granlund and Montgomery (1994)</a>. While GNU GCC and the Go compiler still rely on the approach developed by Granlund and Montgomery, other compilers like LLVM’s clang use a slightly improved version described by <a href="https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685/">Warren in his book Hacker’s Delight</a>.</p>
<p>What if <tt>d</tt> is a constant, but not known to the compiler? Then you can use a library like <a href="https://libdivide.com">libdivide</a>. In some instances, libdivide can even be more efficient than compilers because it uses an approach introduced by <a href="https://www.computer.org/csdl/proceedings/arith/2005/2366/00/23660131-abs.html">Robison (2005)</a> where we not only use multiplications and shifts, but also an addition to avoid arithmetic overflows.</p>
<p>Can we do better? It turns out that in some instances, we can beat both the compilers and a library like libdivide.</p>
<p>Everything I have described so far has to do with the computation of the quotient (<tt>n/d</tt>) but quite often, we are looking for the remainder (noted <tt>n % d</tt>). How do compilers compute the remainder? They first compute the quotient <tt>n/d</tt> and then they multiply it by the divisor, and subtract all of that from the original value (using the identity <tt>n % d = n - (n/d) * d</tt>).</p>
<p>Can we take a more direct route? We can.</p>
<p>Let us go back to the intuitive formula <tt>n/d</tt> = <tt>n</tt> <tt>*</tt> (2<sup>N</sup>/<tt>d</tt>) <tt>/</tt> (2<sup>N</sup>). Notice how we compute the multiplication and then drop the least significant <tt>N</tt> bits? It turns out that if, instead, we keep these least significant bits, and multiply them by the divisor, we get the remainder, directly without first computing the quotient.</p>
<p>The intuition is as follows. To divide by four, you might choose to multiply by 0.25 instead. Take 5 * 0.25, you get 1.25. The integer part (1) gives you the quotient, and the decimal part (0.25) is indicative of the remainder: multiply 0.25 by 4 and you get 1, which is the remainder. Not only is this more direct and potential useful in itself, it also gives us a way to check quickly whether the remainder is zero. That is, it gives us a way to check that we have an integer that is divisible by another: do <tt>x * 0.25</tt>, the decimal part is less than 0.25 if and only if <tt>x</tt> is a multiple of 4.</p>
<p>This approach was known to Jacobsohn in 1973, but as far as I can tell, he did not derive the mathematics. Vowels in 1994 worked it out for the case where the divisor is 10, but (to my knowledge), nobody worked out the general case. It has now been worked out in a paper to appear in Software: Practice and Experience called <a href="https://arxiv.org/abs/1902.01961">Faster Remainder by Direct Computation</a>.</p>
<p>In concrete terms, here is the C code to compute the remainder of the division by some fixed divisor <tt>d</tt>:</p>
<pre>uint32_t d <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span><span>// your divisor &gt; 0</span>

uint64_t c <span>=</span> UINT64_C<span>(</span><span>0xFFFFFFFFFFFFFFFF</span><span>)</span> <span>/</span> d <span>+</span> <span>1</span><span>;</span>

<span>// fastmod computes (n mod d) given precomputed c</span>
uint32_t fastmod<span>(</span>uint32_t n <span>)</span> <span>{</span>
  uint64_t lowbits <span>=</span> c <span>*</span> n<span>;</span>
  <span>return</span> <span>(</span><span>(</span>__uint128_t<span>)</span>lowbits <span>*</span> d<span>)</span> <span>&gt;</span><span>&gt;</span> <span>64</span><span>;</span> 
<span>}</span>
</pre>
<p>The divisibility test is similar…</p>
<pre>uint64_t c <span>=</span> <span>1</span> <span>+</span> UINT64_C<span>(</span><span>0xffffffffffffffff</span><span>)</span> <span>/</span> d<span>;</span>


<span>// given precomputed c, checks whether n % d == 0</span>
bool is_divisible<span>(</span>uint32_t n<span>)</span> <span>{</span>
  <span>return</span> n <span>*</span> c <span>&lt;</span><span>=</span> c <span>-</span> <span>1</span><span>;</span> 
<span>}</span>
</pre>
<p>To test it out, we did many things, but in one particular tests, we used a hashing function that depends on the computation of the remainder. We vary the divisor and compute many random values. In one instance, we make sure that the compiler cannot assume that the divisor is known (so that the division instruction is used), in another case we let the compiler do its work, and finally we plug in our function. On a recent Intel processor (Skylake), we beat state-of-the-art compilers (e.g., LLVM’s clang, GNU GCC).</p>
<p><a href="https://lemire.me/blog/wp-content/uploads/2019/02/hashbenches-skylake-clang.png"><img src="https://lemire.me/blog/wp-content/uploads/2019/02/hashbenches-skylake-clang-300x180.png" alt="" width="80%" srcset="https://lemire.me/blog/wp-content/uploads/2019/02/hashbenches-skylake-clang-300x180.png 300w, https://lemire.me/blog/wp-content/uploads/2019/02/hashbenches-skylake-clang.png 750w" sizes="(max-width: 300px) 100vw, 300px"/></a></p>
<p>The computation of the remainder is nice, but I really like better the divisibility test. Compilers generally don’t optimize divisibility tests very well. A line of code like <tt>(n % d) = 0</tt> is typically compiled to the computation of the remainder (<tt>(n % d)</tt>) and a test to see whether it is zero. Granlund and Montgomery have a better approach if <tt>d</tt> is known ahead of time and it involves computing the inverse of an odd integer using Newton’s method. Our approach is simpler and faster (on all tested platforms) in our tests. It is a multiplication by a constant followed by a comparison of the result with said constant: it does not get much cheaper than that. It seems that compilers could easily apply such an approach.</p>
<p><a href="https://github.com/lemire/fastmod">We packaged the functions as part of a header-only library</a> which works with all major C/C++ compilers (GNU GCC, LLVM’s clang, Visual Studio). <a href="https://github.com/lemire/constantdivisionbenchmarks">We also published our benchmarks</a> for research purposes.</p>
<p>I feel that the paper is short and to the point. There is some mathematics, but we worked hard so that it is as easy to understand as possible. And don’t skip the introduction! It tells a nice story.</p>
<p>The paper contains carefully crafted benchmarks, but I came up with a fun one for this blog post which I call “fizzbuzz”. Let us go through all integers in sequence and count how many are divisible by 3 and how many are divisible by 5. There are far more efficient ways to do that, but here is the programming 101 approach in C:</p>
<pre>  <span>for</span> <span>(</span>uint32_t i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> N<span>;</span> i<span>+</span><span>+</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>(</span>i <span>%</span> <span>3</span><span>)</span> <span>=</span><span>=</span> <span>0</span><span>)</span>
      count3 <span>+</span><span>=</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>(</span>i <span>%</span> <span>5</span><span>)</span> <span>=</span><span>=</span> <span>0</span><span>)</span>
      count5 <span>+</span><span>=</span> <span>1</span><span>;</span>
  <span>}</span>
</pre>
<p>Here is the version with our approach:</p>
<pre><span>static</span> <span>inline</span> bool is_divisible<span>(</span>uint32_t n<span>,</span> uint64_t M<span>)</span> <span>{</span>
  <span>return</span> n <span>*</span> M <span>&lt;</span><span>=</span> M <span>-</span> <span>1</span><span>;</span>
<span>}</span>

<span>.</span><span>.</span><span>.</span>


  uint64_t M3 <span>=</span> UINT64_C<span>(</span><span>0xFFFFFFFFFFFFFFFF</span><span>)</span> <span>/</span> <span>3</span> <span>+</span> <span>1</span><span>;</span>
  uint64_t M5 <span>=</span> UINT64_C<span>(</span><span>0xFFFFFFFFFFFFFFFF</span><span>)</span> <span>/</span> <span>5</span> <span>+</span> <span>1</span><span>;</span>
  <span>for</span> <span>(</span>uint32_t i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> N<span>;</span> i<span>+</span><span>+</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>is_divisible<span>(</span>i<span>,</span> M3<span>)</span><span>)</span>
      count3 <span>+</span><span>=</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span>is_divisible<span>(</span>i<span>,</span> M5<span>)</span><span>)</span>
      count5 <span>+</span><span>=</span> <span>1</span><span>;</span>
  <span>}</span>
</pre>
<p>Here is the number of CPU cycles spent on each integer checked (average):</p>
<table>
<tbody>
<tr>
<td>Compiler</td>
<td>4.5 cycles per integer</td>
</tr>
<tr>
<td>Fast approach</td>
<td>1.9 cycles per integer</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2019/02/08">I make my benchmarking code available</a>. For this test, I am using an Intel (skylake) processing and GCC 8.1.</p>
<p>Your results will vary. Our proposed approach may not always be faster. However, we can claim that some of time, it is advantageous.</p>
<p><strong>Update</strong>: There is a <a href="https://github.com/bmkessler/fastdiv">Go library</a> implementing this technique.</p>
<p><strong>Further reading</strong>: <a href="https://arxiv.org/abs/1902.01961">Faster Remainder by Direct Computation: Applications to Compilers and Software Libraries</a>, Software: Practice and Experience 49 (6), 2019.</p>
<p><a name="footnote123"></a><strong>Footnote</strong>: What is <tt>N</tt>? If both the numerator <tt>n</tt> and the divisor <tt>d</tt> are 32-bit unsigned integers, then you can pick <tt>N=64</tt>. This is not the smallest possible value. <a href="https://arxiv.org/abs/1902.01961">The smallest possible value is given by Algorithm 2 in our paper</a> and it involves a bit of mathematics (note: the notation in my blog post differs from the paper, <tt>N</tt> becomes <tt>F</tt>).</p>
<p><strong>Follow-up blog post</strong>: <a href="https://lemire.me/blog/2019/02/20/more-fun-with-fast-remainders-when-the-divisor-is-a-constant/">More fun with fast remainders when the divisor is a constant</a> (where I discuss finer points)</p>
</div></div>
  </body>
</html>
