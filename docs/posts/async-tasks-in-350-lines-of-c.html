<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rkaehn/cr_task.h">Original</a>
    <h1>Show HN: Async tasks in 350 lines of C</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This library provides a minimal set of types and functions for an asynchronous task system in C.
It was designed to be lock-free in the common case, with locks only needed for allocations of backing memory for the task pool and when the worker threads are starved for tasks to execute. It is written in standard C11 with no dependencies besides the C POSIX library.</p>
<p dir="auto">To get started, create an executor with the desired number of worker threads and define a task.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cr_executor_t* exec = cr_executor_create(4);
cr_task_t* task = cr_task_create(exec, func, args);
cr_task_run(task);"><pre><span>cr_executor_t</span><span>*</span> <span>exec</span> <span>=</span> <span>cr_executor_create</span>(<span>4</span>);
<span>cr_task_t</span><span>*</span> <span>task</span> <span>=</span> <span>cr_task_create</span>(<span>exec</span>, <span>func</span>, <span>args</span>);
<span>cr_task_run</span>(<span>task</span>);</pre></div>
<p dir="auto">By default, the task is going to run immediately on <code>cr_task_run</code>. If you want it to run later, call <code>cr_task_wait</code> before <code>run</code>, and <code>cr_task_signal</code> later.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cr_task_t* task = cr_task_create(exec, func, args);
cr_task_wait(task);
cr_task_run(task);
// Later... (possibly on a different thread or inside a task)
cr_task_signal(task);"><pre><span>cr_task_t</span><span>*</span> <span>task</span> <span>=</span> <span>cr_task_create</span>(<span>exec</span>, <span>func</span>, <span>args</span>);
<span>cr_task_wait</span>(<span>task</span>);
<span>cr_task_run</span>(<span>task</span>);
<span>// Later... (possibly on a different thread or inside a task)</span>
<span>cr_task_signal</span>(<span>task</span>);</pre></div>
<p dir="auto">Instead of calling <code>signal</code> yourself, you can also request a signal from another task, creating a dependency. Here, <code>task_1</code> has to finish before <code>task_2</code> can start.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cr_task_t* task_1 = cr_task_create(exec, func, args);
cr_task_t* task_2 = cr_task_create(exec, func, args);
cr_task_wait(task_2);
cr_task_request_signal(task_2, task_1);
cr_task_run(task_2);
// task_2 does not execute yet
cr_task_run(task_1);
// task_1 executes, then task_2"><pre><span>cr_task_t</span><span>*</span> <span>task_1</span> <span>=</span> <span>cr_task_create</span>(<span>exec</span>, <span>func</span>, <span>args</span>);
<span>cr_task_t</span><span>*</span> <span>task_2</span> <span>=</span> <span>cr_task_create</span>(<span>exec</span>, <span>func</span>, <span>args</span>);
<span>cr_task_wait</span>(<span>task_2</span>);
<span>cr_task_request_signal</span>(<span>task_2</span>, <span>task_1</span>);
<span>cr_task_run</span>(<span>task_2</span>);
<span>// task_2 does not execute yet</span>
<span>cr_task_run</span>(<span>task_1</span>);
<span>// task_1 executes, then task_2</span></pre></div>
<p dir="auto">Since telling one task to wait and requesting a signal from another is such a common operation, there is a shorthand function called <code>cr_task_wait_request_signal</code>. <code>wait</code> and <code>signal</code> calls must always be balanced, and as soon as the wait count hits zero and <code>run</code> has been called, the task executes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cr_task_t* task = cr_task_create(exec, func, args);
cr_task_wait_request_signal(task, task_dep_1);
cr_task_wait_request_signal(task, task_dep_2);
cr_task_run(task);
// task_dep_1 and task_dep_2 execute, then task"><pre><span>cr_task_t</span><span>*</span> <span>task</span> <span>=</span> <span>cr_task_create</span>(<span>exec</span>, <span>func</span>, <span>args</span>);
<span>cr_task_wait_request_signal</span>(<span>task</span>, <span>task_dep_1</span>);
<span>cr_task_wait_request_signal</span>(<span>task</span>, <span>task_dep_2</span>);
<span>cr_task_run</span>(<span>task</span>);
<span>// task_dep_1 and task_dep_2 execute, then task</span></pre></div>
<p dir="auto">When you want to synchronously wait for a task to finish execution, call <code>cr_task_sync</code>. Since a task destroys itself automatically after it has run, you need to call <code>cr_task_retain</code> before, and <code>cr_task_release</code> after waiting. And again, because this pattern of <code>retain</code>, <code>run</code>, <code>sync</code>, and <code>release</code> is relatively common, there is a shorthand called <code>cr_task_run_sync</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="cr_task_t* task = cr_task_create(exec, func, args);
cr_task_retain(task);
cr_task_run(task);
cr_task_sync(task);
cr_task_release(task);
// Or the shorthand...
cr_task_run_sync(task);"><pre><span>cr_task_t</span><span>*</span> <span>task</span> <span>=</span> <span>cr_task_create</span>(<span>exec</span>, <span>func</span>, <span>args</span>);
<span>cr_task_retain</span>(<span>task</span>);
<span>cr_task_run</span>(<span>task</span>);
<span>cr_task_sync</span>(<span>task</span>);
<span>cr_task_release</span>(<span>task</span>);
<span>// Or the shorthand...</span>
<span>cr_task_run_sync</span>(<span>task</span>);</pre></div>
</article></div></div>
  </body>
</html>
