<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.elbeno.com/blog/?p=1738">Original</a>
    <h1>std::source_location Is Broken</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1738">

	<!-- .entry-header -->

	<div>
		
<p>Everyone knows that the best way to get something done on the Internet is with an inflammatory title and a potentially incorrect contention, so here goes.</p>



<p>What do you if you want to capture/log the filename of an assertion? Prior to C++20, you use good old <code>__FILE__</code>, which gives you a C-style array of <code>char</code>s. But of course this is a macro, and means that your logging/assertion code has to be a macro. With all the usual downsides of macros. Ho hum, that’s how it is for now, and it works. You go on your way.</p>



<p>After upgrading to C++20, you wonder if you can upgrade your logging/assertion code to use <code>std::source_location</code>. Then maybe you could get rid of the macros. It looks odd at first, because you have to set it up as a default argument to your log function. But hey, this was someone’s clever solution to the problem, right? Obviously arguments are supplied at the call site, and default arguments are arguments, so they are too. So the <code>std::source_location</code> default argument picks up the location of the call site, and you can grab the <code>file_name</code> from it as a <code>const char*</code>.</p>



<p> But… now it doesn’t work. Because that’s not how your logging works. You’re working in embedded. No room for strings in your binary. Instead, you model your (statically-known) strings as types like <code>string_constant&lt;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&gt;</code>, you use <code>nm</code> to extract the symbols from your library, and you generate tiny function specializations which turn the types into numbers, and melt away with LTO. (<a href="https://www.youtube.com/watch?v=Dt0vx-7e_B0">Like this.</a>)</p>



<p>You need strings to be types. You need to know the size at compile time. <code>std::source_location::file_name()</code> gives you a <code>const char*</code> – you don’t know the size of the string. And because it has to be a function argument, it can’t be <code>constexpr</code>. There is no way to get back into type land. (At least, none that I know of yet, and believe me, I’ve tried. If you know how, let me know!) It’s the same story for the intrinsics that <code>std::source_location</code> is built upon (<code>__builtin_FILE_NAME</code>).</p>



<p>So you sadly accept that until and unless you get <s>jam tomorrow</s> another mechanism to do this, be it <code>constexpr</code> function arguments or whatever, you’re stuck with <code>__FILE__</code>, which works, because it gives you a <em>sized</em> <code>char</code> array which you <em>can</em> turn into a type.</p>



<p>Of course the irony here is that <code>std::source_location</code> provides information that is known <em>only</em> at compile time. But we can’t <em>use</em> that information fully at compile time, because it’s inadequately specified/implemented.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
