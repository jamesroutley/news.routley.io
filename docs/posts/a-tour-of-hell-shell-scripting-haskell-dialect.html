<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrisdone.com/posts/tour-of-hell/">Original</a>
    <h1>A Tour of Hell â€“ Shell scripting Haskell dialect</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-9.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-9.png"/></a></p><p>This set of slides sketches out the
            implementation of <a href="https://chrisdone.github.io/hell/">Hell</a>, in technical detail. I do tend to switch
            between the slides, old code, and the present code, so
            bear with me. It&#39;s more about the ideas. If you want to
            see a complete implementation, the complete
            implementation of Hell
            is <a href="https://github.com/chrisdone/hell/blob/main/src/Hell.hs">one
            file</a>, which you can look through easily.</p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-11.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-11.png"/></a></p><div>
          <p>There are a few limits on the language; no imports, no
            polymorphism (poly types) i.e. no declaration is ever
            inferred with a <code>forall a.</code> in it. Poly types are
            awesome, but they make the implementation harder, and are a
            form of abstraction that you might not need in a scripting
            language. I don&#39;t need them in my case, YMMV.
          </p>
          <p>
            No imports: instead, all names that usually come under a
            package name like <code>async</code>
            become <code>Async.race</code>, <code>List.map</code>,
            etc. All identifiers are explicitly qualified except
            lambda parameters: <code>\x -&gt; x</code> -- not qualified.
          </p>
          <p>
            Recursion is completely ruled out, but <code>fix</code>
            works fine, so you still have it as a primitive
            function. It&#39;s just not something you can produce
            yourself.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-15.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-15.png"/></a></p><div>
          <p>
            Rather than bothering to implement a parser, I used
            haskell-src-exts. That package isn&#39;t really maintained
            anymore, but I&#39;m kind of used to it now, and GHC&#39;s parser is
            a bit too wordy for me.
          </p>
          <p>
            Re-using a parser is usually wise, parsing layout in Haskell
            is fiddly and I just wanted something that works as I&#39;m used
            to.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-16.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-16.png"/></a></p><p>
            The next step is to desugar this syntax into something
            smaller. <code>do</code>-notation becomes
            nested <code>&gt;&gt;=</code> calls, etc.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-17.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-17.png"/></a></p><p>
            Parsing is the beginning of the pipeline. For this
            project, a primary concern was to make the evaluator as
            lean as possible, and, ideally,
            <a href="https://en.wikipedia.org/wiki/Partial_function">total</a>
            and complete. With this in mind, I started at the
            interpreter and worked backwards from there. What does a
            trivial but total evaluator look like in Haskell?
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-18.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-18.png"/></a></p><div>
          <p>
            Here&#39;s a basic one. It&#39;s called &#34;higher-order abstract
            syntax&#34; because you&#39;ve got syntax productions that take
            functions as arguments. Rather than carrying an
            environment around, like in,
            e.g. <a href="https://norvig.com/lispy.html">How to Write
              a (Lisp) Interpreter (in Python)</a>, you store a
            function <em>as a real function</em>. When you pass an
            environment around, you tend to have a lookup function
            that could throw an error if you got your evaluator wrong.
          </p>
          <p>
            This evaluator is <em>total</em> and won&#39;t crash. This is
            really neat and tidy. The only downside really is that
            it&#39;s opaque. It&#39;s hard to work with functions, because you
            can&#39;t look inside them once you&#39;ve made them. You also
            can&#39;t smooth out the wrinkles inside them, at least, as
            far as I&#39;m aware. I&#39;ve heard of cunning approaches to do
            so, but some things are best left alone.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-19.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-19.png"/></a></p><p>
            I encountered another approach while perusing Oleg
            Kiselyov&#39;s
            <a href="https://okmij.org/ftp/tagless-final/course/lecture.pdf"><em>Typed Tagless Final Interpreters</em></a> paper and he dropped in
            this example like it was the most normal thing in the
            world. I&#39;m not sure where Oleg got this from.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-20.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-20.png"/></a></p><div>
          <p>
            This evaluator is not higher order. It features environment lookup and
            the evaluator carries around an environment. But there&#39;s something
            clever here: that lookup will always succeed.
          </p>
          <p>
            The environment is a simple stack of tuples. When
            evaluating a lambda, simply wrap the environment in
            another tuple with the argument being passed.
          </p>
          <p>
            Variables are church numerals: 0 is <code>VZ</code>, 1
            is <code>VS VZ</code>, 2 is <code>VS (VS VZ)</code>, etc.
            It&#39;s
            a <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de
            Bruijn index</a> that is statically typed. It means &#34;how
            far up the stack do you go?&#34; Lookup simply walks both the
            church numeral and the environment until the zero case
            (<code>VZ</code>) is reached, and then what&#39;s there in the
            stack is returned.
          </p>
          <p>
            The way to make this total and guaranteed to be correct is via the
            <code>env</code> type parameter that both the <code>Exp</code> type and the <code>Var</code> type
            share.
            It took me a few readings to believe that this actually works. It&#39;s
            beautiful.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-21.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-21.png"/></a></p><div>
          <p>Hell&#39;s core AST and evaluator are almost identical, with a couple
            adjustments.</p>

          <ol>
            <li>Oleg&#39;s example hard-codes Bool just for demonstration
              purposes. Hell&#39;s AST has <code>Lit</code> instead, which can produce any
              <code>a</code>. All primitive functions e.g. <code>List.map</code> or e.g. literals like
              <code>123</code> are kept in there.</li>
            <li>
              In the zero case for <code>Var</code>, Hell keeps a function as a final
              accessor function. This lets us easily pull out a tuple slot from a
              function argument, e.g. <code>\(x,y) -&gt; x</code> becomes, conceptually, <code>\xy
                -&gt; fst x</code>. This could later possibly be used for e.g. <code>\X{x,y} -&gt;
                x</code>.
            </li>
          </ol>
          <p>(The <code>TypeRep</code> is gone now. It was just
            handy for debugging at the time.)</p>

          <p>Otherwise it&#39;s exactly the same, and in the year since I wrote the
            first version of Hell, this AST and the evaluator function have not
            changed at all. For me, this is an achievement. It&#39;s lovely to keep it so simple.</p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-22.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-22.png"/></a></p><div>
          <p>
            Working backwards, an immediate question arises: how do you
            produce this quite strongly-typed AST from a completely
            untyped text input?
          </p>
          <p>Stephanie Weirich published a
            single <a href="https://www.cs.ox.ac.uk/projects/gip/school/tc.hs">file</a>
            type checker implementation that addresses this problem
            neatly. It blew my mind that this was possible in Haskell
            so cleanly.</p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-23.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-23.png"/></a></p><p>
            The type signature essentially goes
            from <code>UTerm</code> (an untyped term) to a
            typed <code>Term</code> which has the type of the term as
            a parameter.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-24.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-24.png"/></a></p><div>
          <p>The <code>UTerm</code> AST is a simple model of an AST that
            you might parse from a string. Note: there is
            a <code>UType</code> explicit type attached to the lambda
            that tells us what type the parameter is; your parser
            would parse e.g. <code>\(x::Bool) -&gt; ..</code> into this.</p>
          <p>In this example, <code>UType</code> is simply an &#34;untyped&#34; (meaning
            in the meta language doesn&#39;t have attached type
            information) type, which is either <code>Bool</code> or <code>Bool -&gt;
              Bool</code> etc.</p>
          <p>
            There&#39;s a familiar pattern here. Just like the evaluator
            seen above in Oleg&#39;s paper, the <code>Var</code> type
            gives us a variable reference whose scope is statically
            determined. Note the <code>Term (g,a)</code> in
            the <code>Lam</code> constructor; the <code>g</code>
            corresponds to the one in <code>Var g t</code>.
          </p>
          <p>The type-checkers job is to not only check that the types match up,
            but to build up this well-typed variable referencing.</p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-25.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-25.png"/></a></p><div>
          <p>
            As for the <code>Ty</code> itself, it&#39;s a type-indexed equivalent of
            the <code>UType</code> type. The meta language (or host language) is
            using its own type system to mirror what&#39;s in the object
            language (or guest language). In the types as well as in
            term-level code.
          </p>
          <p>
            Here&#39;s how the <code>UType</code> becomes a <code>Ty
          t</code>. A handy existential is needed that&#39;ll be used in
          the type-checker called
<code>ExType</code> that just holds the result of the type-check.
          </p>
          <p>With these types in place, the type checker for <code>UType -&gt;
            ExType</code> practically writes itself.</p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-26.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-26.png"/></a></p><div>
  <p>
    Turning to type-checking terms, type-checking an if requires an
    extra trick which is to compare that two types are equal and get a
    proof that they are so.  The
    <code>cmpTy</code> function starts with an <code>a</code> and <code>b</code> and by
    pattern-matching and aided by a handy GADT called <code>Equal</code> which
    essentially makes first class the ability to get both a
    value-level and type-level proof that <code>a ~ b</code>. There
    are shorter ways to do this, of course, but this is how it&#39;s done
    in this small example file.
  </p>
  <p>
    Finally, it can produce a convenient type
    called <code>Typed</code> that just couples up a thing with its
    type, as both the thing and the ty are indexed by the same
    thing. It locks in that relationship.
  </p>
</div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-27.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-27.png"/></a></p><div>
  <p>
    To both type-check and also scope-check a variable, there&#39;s need
    for an environment to keep track of those things in a typed lookup
    table while doing type-checking. It&#39;s like the stack earlier, but
    has a <code>String</code> in it to help build the correct de Bruijn index
    level based on the name. The more the <code>TyEnv</code> is walked, the more
    nested <code>Var</code> becomes.
  </p>
  <p>Type-checking a <code>UVar</code> then just becomes a lookup. (Imagine that
  the <code>error</code> calls are instead returning <code>Left</code>, but they were
    omitted for simplicity of the implementation.)</p>
  <p>Type-checking a lambda is more complicated and where the meat
  is:</p>
  <ol>
    <li>First, get a <code>Ty a</code> of the lambda&#39;s parameter type.</li>
    <li>Type-check the body <em>with the parameter in scope</em>.</li>
    <li>Construct an <code>a -&gt; b</code> type with <code>Arr</code> for the binder and
      the body.</li>
    <li>Finally, the <code>Lam</code> has enough type proofs in scope to be
      constructed.</li>
  </ol>
</div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-28.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-28.png"/></a></p><p>
            Comparatively, type-checking applications is easy. It&#39;s
            just a quick check that the function being applied is of
            type <code>a -&gt; b</code> and then that the argument is of type <code>a</code>.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-29.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-29.png"/></a></p><div>
          <p>
            In review, this is the whole type checker. The example
            <code>main</code> shows how one might construct a basic untyped
            <code>UTerm</code> and then type-check it. The initial argument to
            <code>tc</code> is, unsurprisingly, <code>Nil</code> for the environment.
          </p>
          <p>That&#39;s it! Isn&#39;t that beautiful!</p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-30.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-30.png"/></a></p><p>
            Evaluating this AST is exactly the same as evaluating as
            seen above. This shows that you can type-check an untyped
            AST and then evaluate it with a total evaluator. Noice!
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-31.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-31.png"/></a></p><div>
          <p>
            According
            to <a href="https://chrisdone.com/posts/three-questions-of-lang-design/">Three
            questions of language design</a>, it&#39;s not long before the
            question of how to do equality and ordering comes up. How
            do you compare strings, integers, etc? And how do you do
            things like sets and maps that require some kind of
            ordering.
          </p>
          <p>
            Haskell already has good answers for this:
            type-classes. For Hell, I didn&#39;t want to have to
            support <em>full</em> type-classes and all attendant
            features, but I equally didn&#39;t want to give up on
            including <code>Map</code> and <code>Set</code> or
            even <code>List.lookup</code>, and end up with <code>Int.eq</code>,
            <code>Text.eq</code>, etc.
          </p>
          <p>
            Luckily I discovered that Eitan Chatav had posted
            somewhere on
            reddit <a href="https://gist.github.com/chrisdone-artificial/8d807f6f26f08363a860330223591e70">an
            example</a> of exactly what I wanted to do, which was to
            infer based on known types type-class dictionaries for a
            few specific type-classes.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-32.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-32.png"/></a></p><p>
            In the term type, an actual class constraint can be added
            in there! Eitan&#39;s terms, types and <code>Ty</code>-equivalent are
            slightly different, but are otherwise identical.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-33.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-33.png"/></a></p><div>
          <p>
            The trick here is simply to dispatch on the well-typed
            type-indexed GADT of <code>Type</code> and in that case one can
            &#34;capture&#34; the type-class instance dictionary and then the
            <code>T_Add</code> constructor is able to use that for its class
            constraint!
          </p>
          <p>
            This makes sense after you&#39;ve seen it, but it blew my mind
            when I first saw it.
          </p>
          <p>
            This is <strong>not</strong> how how I did it in Hell, obviously;
            the <code>Term</code> type has no class constraints in it
            as seen above. But it gave me the key first step that I
            was able to evolve to what I needed.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-34.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-34.png"/></a></p><p>
            The <code>Ty</code> type defined earlier is fine, and the <code>Equal</code>
            utility, but it turns out Stephanie later made the
            <code>Type.Reflection</code> abstraction which replaces <code>Ty a</code> with
            <code>TypeRep a</code>, and provides equality, too. It can
            also deal with any Haskell type, of any kind.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-35.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-35.png"/></a></p><p>
            As a reminder, I showed that the <code>TypeRep (a ::
            Type)</code> is used in the <code>Term</code> type instead
            of the <code>Ty a</code> used in Stephanie&#39;s demo file
            that was much older.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-36.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-36.png"/></a></p><div>
          <p>
            From <code>Type.Reflection</code> you&#39;ve got a <code>TypeRep a</code> type, you
            can get a <code>TypeRep a</code> from any type that&#39;s an instance of
            <code>Typeable</code>, and can compare types for equality.
          </p>
          <p>
            Because any kind of type can be worked with, you often
            have to check that the kind is the one you expect before
            working with the type, so <code>typeRepKind</code> comes in handy
            there, too.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-37.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-37.png"/></a></p><p>
            Here&#39;s an example of how I wrote a trivial function to
            apply some unknown one type to another which is used in
            the inferer later on. There&#39;s a much better implementation
            later down the page, but this is fairly easy to read.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-38.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-38.png"/></a></p><p>
            Up to here I&#39;ve covered a parser which yields
            <code>HSE.Exp</code> (the haskell-src-exts type) and I&#39;ve described
            the <code>Term</code> AST that a type-checker is able to produce and
            an evaluator able to interpret. What&#39;s missing is the
            &#34;untyped&#34; term type, <code>UTerm</code>. Additionally, I
            want type inference, which is a step that should sit
            somewhere between parsing and final type-checking.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-39.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-39.png"/></a></p><p>
            Desugaring in Hell goes from <code>HSE.Exp HSE.SrcSpanInfo</code>
            (haskell-src-exts) to <code>UTerm ()</code>.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-40.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-40.png"/></a></p><div>
          <p>
            The <code>UTerm</code> type now takes an extra parameter <code>t</code> in which
            I&#39;ll put <code>SomeTypeRep</code> - so it&#39;s similar to earlier, but
            I can now put other choices of type annotation in there.
          </p>
          <p>
            I use a handy type <code>SomeStarType</code> which just constrains
            the kind of the <code>a</code> in the <code>TypeRep a</code> to be <code>Type</code>
            (previously <code>*</code> in GHC); the type of regular
            values. You can see this concept in action in <code>toStarType</code>
            seen in the slide.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-41.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-41.png"/></a></p><p>I tried for a while with Hell to avoid type inference,
          because it can complicate everything. I don&#39;t need no
          stinkin&#39; type inference! ... But after trying to write a real
          script in Hell, I realised that writing out the types of
          everything gets tedious really quickly.
        </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-42.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-42.png"/></a></p><p>
            When doing type inference, instead of working with
            <code>SomeTypeRep</code> as seen above, which has no concept
            of <em>variables</em>, I&#39;ve defined <code>IRep</code>
            (<em>inference</em> type rep) for that. It has a type
            parameter for the representation of variables. While doing
            inference, it&#39;s going to be a little newtype wrapper
            around numbers called <code>IMetaVar</code>. When inference is
            finished, it&#39;ll be <code>Void</code>, ready for converting to
            <code>SomeTypeRep</code>.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-43.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-43.png"/></a></p><div>
          <p>
            <code>inferExp</code>&#39;s job is to make a <code>UTerm ()</code> into a <code>UTerm
            SomeTypeRep</code> -- if it can&#39;t do that, then there&#39;s either a
            type mismatch, an ambiguous type
            (<a href="https://stackoverflow.com/questions/31889048/what-does-the-ghc-source-mean-by-zonk">zonking</a>
            failed), or an infinite type. You can see in the
            implementation of <code>zonk</code> that it&#39;s just making sure that
            there are no type variables anymore.</p>
          <p>After that,
            <code>toSomeTypeRep</code> just converts
            our <code>IRep</code> tree into
            a <code>SomeTypeRep</code>. That can still fail if our
            type inferer has a bug. Unlikely, but it&#39;s not ruled out.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-44.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-44.png"/></a></p><p>
            A typical split in a type inferer is &#34;elaborate, unify&#34;
            which means first walk the AST and simply generate
            equality constraints like <code>f ~ a -&gt; b</code>
            and <code>a ~ [Char]</code> and <code>b ~ Int</code>, and
            then the second part is to unify these constraints to get
            e.g. <code>[Char] -&gt; Int</code>. It&#39;s a nice clean
            separation. Many industrial compilers will do these two
            phases in the same phase in the name of efficiency and the
            ability to generate new constraints on the fly, but I
            prefer the clean separation.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-45.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-45.png"/></a></p><div>
          <p>
            <code>fromSomeStarType</code> produces an <code>IRep void</code> for the case
            that I know the type of something ahead of time, i.e. my
            primitives (<code>Int.plus</code>, etc.).
          </p>
          <p>
            On the right is a sample of elaborations of different
            parts of the AST. There isn&#39;t really anything in here
            that&#39;s out of the ordinary or that I&#39;m excited to go into
            detail about.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-46.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-46.png"/></a></p><div>
          <p>
            For unification, there&#39;s nothing new in here, either; it&#39;s
            very by the book. Given a set of equality constraints,
            generate a set of substitutions (replace these variables
            with these types). Afterwards, one can apply those
            substitutions to any type. In our case, that&#39;s all
            the <code>t</code> in <code>UTerm</code>.
          </p>
          <p>
            You can use off-the-shelf unification libraries like
            unification-fd or implement a mutable algorithm for extra
            speed, or use union-find, but this one fits on a page and
            does the job presently.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-47.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-47.png"/></a></p><div>
          <p>
            Initially the AST had this for primitive terms:
          </p>
          <pre>ConBool :: Bool -&gt; Term g Bool
ConString :: String -&gt; Term g String</pre>
          <p>
            Which is fine if you want to enumerate every single type
            of value you want to be able to work with. I didn&#39;t want
            to do that. There&#39;s a way to make that shorter:
          </p>
          <pre>Lit :: a -&gt; Term g a
...
ULit (forall g. Typed (Term g))</pre>
          
          <p>
            And then when you want to express e.g. <code>True</code> in the
            object language, you can just write a handy function like
            this that&#39;ll go straight from any <code>Typeable</code> into a
            <code>Typed</code>:
          </p>
          <pre>lit :: Type.Reflection.Typeable a =&gt; a -&gt; UTerm
lit l = ULit (Typed (Type.Reflection.typeOf l) (Lit l))</pre>
          <p>The type checker case is a no-op:</p>
          <p>
            <code>tc (ULit lit) _env = lit</code>
          </p>
          <p>
            And then simply <code>lit True</code> will work.
          </p>
          <p>So far so good, but what about polymorphic things? Like
            the function <code>id</code>? My solution was to make a newtype
            around a function, and that function accepted the type as
            an argument, just like in system F:</p>
          <pre>newtype Forall =
  Forall (forall (a :: Type) g.
   TypeRep a -&gt; Typed (Term g))
...
UForall SomeStarType Forall</pre>
          
          <p>And in <code>UTerm</code>, carry a type and the forall together. So
          e.g. <code>id</code> would be represented like this:</p>
          <pre>id_ :: Forall
id_ = Forall (\a -&gt; Typed (Type.Reflection.Fun a a) (Lit id))</pre>
          <p>I can then instantiate <code>id_</code> with whatever
          type I want, such as <code>Bool</code>:</p>
          <pre>UForall (SomeStarType (Type.Reflection.typeRep @Bool)) id_</pre>
          
          <p>It would merely be the type inferer&#39;s job to provide
            these type reps to the <code>UForall</code>, with the checker just
            applying the function:
          </p>
          <pre>tc (UForall (SomeStarType typeRep) (Forall f)) _env =
              f typeRep</pre>
          
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-48.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-48.png"/></a></p><div>
        <p>Since that initial discovery and implementing type
        inference, I changed <code>Forall</code> to be a GADT which represents a
        chain, so that it can be for example: <code>Eq a =&gt; Monad m =&gt; ...</code>
        </p>
        <p>Type inference adds a load of extra metadata to the
          <code>UForall</code> constructor, but the core idea is the
          same.</p>
</div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-49.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-49.png"/></a></p><div><p>
  The example of <code>id</code> hasn&#39;t changed very much, although here I&#39;m
  using the <code>TypeRep</code> pattern to be able to bring the <code>a</code>
  type variable in directly. </p><p>In fact, I&#39;ve since
  enabled any kind of type, so it becomes a full <code>SomeTypeRep</code> in
  <code>UForall</code>, in order to support records (which I&#39;ll show
  later) and their <code>Symbol</code> field names.</p></div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-50.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-50.png"/></a></p><p>
When type-checking these foralls, it&#39;s just a loop that successively
applies poly type arguments to functions that accept them. In the case
of type-classes like <code>OrdEqShow</code>, I use Eitan&#39;s trick of proving that
the type is e.g. one of <code>Int</code>, <code>Bool</code> etc. known types that support
<code>Ord</code>, <code>Eq</code> and <code>Show</code> and then simply continue applying the
arguments. Yes, this works, and yes, I was surprised. Even
higher-order kinded stuff like <code>Monad</code> had no trouble.
</p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-51.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-51.png"/></a></p><div>
<p>
Elaboration of foralls was straight-forward and this hasn&#39;t changed
since I made these slides. All I&#39;m doing is generating a
meta-variable for each poly type in the <code>forall</code>, so <code>a</code>, <code>b</code>,
etc. Then I transform the type signature like <code>forall a. a -&gt; a</code> that
is originally <code>IRep TH.Uniq</code> (template-haskell&#39;s way of
generating unique references) to <code>IRep IMetaVar</code>. Now I
can use it in the unifier.
</p><p>
The <code>types</code> variable represents any manually specified types like
<code>id @Int</code>, in which case we can emit an equality constraint on
the first poly type as <code>a ~ Int</code>.
</p></div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-52.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-52.png"/></a></p><p>Primops that aren&#39;t polymorphic can all be defined via <code>lit</code>,
    like this.</p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-53.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-53.png"/></a></p><p>As you saw above, writing out polymorphic prims
  like <code>id</code> is a bit boring and long. So i wrote some
  template-haskell to generate them for me based on a list like
  this. I won&#39;t go into the implementation because you can imagine
  it. Just generate the boilerplate.</p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-54.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-54.png"/></a></p><p>The nice thing about using <code>TypeRep</code> is I didn&#39;t have to write
  much when listing out the supported types. I just specify their
  name and use <code>typeRep</code>. It doesn&#39;t matter what kind they
  are, which is quite nice.</p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-55.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-55.png"/></a></p><div>
          <p>
            I&#39;d originally intended to eventually add records to the
            language, just for ferry data around within a script. But
            I took some months before settling on an approach.
          </p>
          <p>
            The hard part about supporting records that are type-safe
            in both the meta language and the object language is
            mostly about lookup. A fairly obvious thing is that I&#39;d
            need some kind of anonymous records implementation, but it
            wasn&#39;t clear for a while about how to do safe lookup.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-56.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-56.png"/></a></p><div>
          <p>
            In the language, declaring records is regular
            Haskell. Accessing records is done via getters and
            setters, rather than pattern-matching or dot-notation. I
            would like dot-notation, but that requires work on the
            parser, so I&#39;ll return to it in the future.
          </p>
          <p>
            The constructor must be qualified like all other names.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-57.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-57.png"/></a></p><div>
          <p>
            I used a classic GADT-driven implementation of records,
            with a type-level list consisting of a <code>Symbol</code> (which is
            why I had to support any <code>SomeTypeRep</code> in the type
            inferer) and a type. There isn&#39;t anything particularly
            special about <code>Record</code> and <code>List</code>, unless you&#39;ve never
            seen HList or anonymous records before.
          </p>
          <p>
            One thing that is a little new is simply that the types,
            like <code>Person</code> above, are simply <code>Tagged &#34;Main.Person&#34;
            (ConsR .. )</code> which avoids accidentally permitting two
            structurally equivalent types from unifying; the tag keeps
            it <em>nominal</em>. Handily, this does permit me to
            support true anonymous records down the line, though at
            the moment, I don&#39;t want to stray much from &#34;regular&#34;
            Haskell if I can help it.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-58.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-58.png"/></a></p><p>
            As I said above, having to support <code>SomeTypeRep</code> motivated
            me to write a much better implementation of <code>applyTypes</code>
            which works for any kind of types. And it turns out to be
            shorter. Although it took a couple of tries to get it
            right. Unlike, say, Idris or Agda, this kind of type magic
            in Haskell has bad error messages and not a lot of helpful
            explanation to guide you along.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-59.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-59.png"/></a></p><div>
          <p>I really did not want to have to write some kind of
            <code>HashMap</code>-based record implementation with <code>error</code> calls in
            it. That would harsh my vibe.</p>
          <p>
            Fortunately, I figured out another way using
            <code>Type.Reflection</code> again. I&#39;m really happy with this
            result; I was able to generate accessors (get, set,
            modify) for a record that is type-safe in the meta
            language and also the object language, with no
            partiality. At type-checking time in Hell&#39;s type-checker,
            it simply returns a <code>Maybe ...</code>  function, and
            if you get a <code>Just</code>, it compiles; if not, no
            compile.
          </p>
          <p>
            The implementation I did not expect to work at all. First
            I unwrap the <code>Tagged</code>. Then I have a
            loop, <code>go</code>, which walks the
            record&#39;s <em>type</em>, and while walking the type,
            accumulates a function capable of walking a
            record&#39;s <em>value</em>. If all the types match up and it
            can find the field with the right name and type, at the
            end you&#39;ll get an accessor function. If not, you get
            <code>Nothing</code>. Good day, sir!
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-60.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-60.png"/></a></p><div>
          <p>
          A few notes follow about some things that have been
          desugared.
          </p>
          <p>
            I will note that Hell desugars everything <em>before</em>
            type-checking, and inlines everything, all in one step to
            get one giant expression to type check. That&#39;s not normal;
            usually you type check and then desugar. But it does mean I
            don&#39;t have to implement <a href="https://en.wikipedia.org/wiki/System_F">System F</a>. It&#39;s just plain old
            <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply
            typed lambda calculus</a> with a few built-in primitive
            type constructors.
          </p>
        </div>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-61.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-61.png"/></a></p><p>
            This slide shows that record expressions really are just
            rewritten to applications of <code>Tagged &#34;x&#34; (ConsR @&#34;a&#34;
            .. NilR)</code>. It all happens before type-checking happens.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-62.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-62.png"/></a></p><p>
            <code>do</code>-notation follows the usual Haskell approach; it&#39;s
            desugared into a series of <code>&gt;&gt;=</code> and <code>&gt;&gt;</code>. I&#39;ve later
            adjusted this to rewrite <code>HSE.Exp -&gt; HSE.Exp</code> and then
            call the desugarer on that expression, rather than going
            straight from <code>do</code>-notation to a <code>UTerm</code>, just to make
            scope-checking better.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-63.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-63.png"/></a></p><p>
            While working on this I&#39;ve been thinking of Hell&#39;s
            compiler as &#34;front-loaded&#34;. <em>All</em> the heavy lifting
            happens in the desugarer and the inferer. The type checker
            is on the order of 100 lines and the evaluator is about 10
            lines. I really quite like this style of compiler.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-64.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-64.png"/></a></p><p>
            The main entry point that executes scripts looks like
            this. Parse it, desugar it, infer it, type check it, and
            then finally, check that <code>main</code> is of
            type <code>IO ()</code>. If so, simply run the function!
            That&#39;s it.
          </p>
      </div>
      <div>
        <p><a href="https://chrisdone.com/posts/tour-of-hell/slide-65.png"><img src="https://chrisdone.com/posts/tour-of-hell/slide-65.png"/></a></p><div>
          <p>
            End of slides. Hopefully this will actually be legible,
            both for myself and anyone with niche interest enough to
            be reading through it.
          </p>
          <p>
            Future work probably includes at
            least <a href="https://www.youtube.com/watch?v=rdVqQUOvxSU">adding
            locations to types</a>, adding sum types, and adding a
            <code>case</code> syntax.
          </p>
        </div>
      </div>
<p>
  <a href="https://chrisdone.com/">Back to homepage</a>
</p>
    </div></div>
  </body>
</html>
