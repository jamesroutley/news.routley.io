<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://crocidb.com/post/kernel-adventures/demystifying-the-shebang/">Original</a>
    <h1>Demystifying the (Shebang): Kernel Adventures</h1>
    
    <div id="readability-page-1" class="page"><article>
      <p>From my first experience creating a shell script, I learned about the <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)"><strong>shebang</strong></a> (<code>#!</code>), the special first line used to specify the interpreter for executing the script:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span><span>#! /usr/bin/sh
</span></span></span><span><span><span></span>echo <span>&#34;Hello, World!&#34;</span>
</span></span></code></pre></div><p>So that you can just invoke it with <code>./hello.sh</code> and it will run with the specified interpreter, assuming the file has execute permissions.</p>
<p>Of course, the shebang isn’t limited to shell scripts; you can use it for any script type:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>#! /usr/bin/python3</span>
</span></span><span><span>print(<span>&#34;Hello, World!&#34;</span>)
</span></span></code></pre></div><p>This is particularly useful because many bundled Linux utilities are actually scripts. Thanks to the shebang, you don’t need to explicitly invoke their interpreters. For example, there are two (very confusing) programs to create a user on Linux: <code>useradd</code> and <code>adduser</code>. One of them is the actual program that will create the user in the system, the other one is a utility that will create the user, the home directory and configure the user for you. Since I never remember which one is which, a good way to check is using the utility <code>file</code>:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ file <span>$(</span>which useradd<span>)</span>
</span></span><span><span>/usr/sbin/useradd: ELF 64-bit LSB pie executable, x86-64, version <span>1</span> <span>(</span>SYSV<span>)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2 <span>(</span>...<span>)</span>
</span></span><span><span>
</span></span><span><span>$ file <span>$(</span>which adduser<span>)</span>
</span></span><span><span>/usr/sbin/adduser: Perl script text executable
</span></span></code></pre></div><p>Ok, we know that <code>addser</code> is the tool we want to use, because it’s more user-friendly and generally does what you’d expect when adding a user. And yes, if you check how it starts:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ head -n <span>1</span> /usr/sbin/adduser
</span></span><span><span><span>#! /usr/bin/perl</span>
</span></span></code></pre></div><p>I had always assumed the <em>shell</em> used the shebang as a hint, but that’s incorrect! <strong>This functionality is actually handled directly by the Linux Kernel.</strong></p>

<p>One good way to track any executable in Linux is using <code>strace</code>, which traces all the system calls made by a process:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ strace ./test.sh
</span></span><span><span>execve<span>(</span><span>&#34;./test.sh&#34;</span>, <span>[</span><span>&#34;./test.sh&#34;</span><span>]</span>, 0x7ffed15d9828 /* <span>33</span> vars */<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span>brk<span>(</span>NULL<span>)</span>                               <span>=</span> 0x59aea5a28000
</span></span><span><span>mmap<span>(</span>NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0<span>)</span> <span>=</span> 0x78ee2be49000
</span></span><span><span>access<span>(</span><span>&#34;/etc/ld.so.preload&#34;</span>, R_OK<span>)</span>      <span>=</span> -1 ENOENT <span>(</span>No such file or directory<span>)</span>
</span></span><span><span><span>(</span>...<span>)</span>
</span></span></code></pre></div><p>Interesting, the call to <code>test.sh</code> goes straight into <code>execve</code>, the syscall to start running a program from a file. This implies the kernel itself is <em>responsible for finding</em> the correct interpreter and executing it.</p>
<p>If we start digging into the kernel code, we can see that the entry point for the <code>execve</code> syscall is in the function <code>do_execveat_common</code>, found in <a href="https://github.com/torvalds/linux/blob/master/fs/exec.c#L1967"><code>fs/exec.c</code></a>. It starts by creating a <code>struct linux_binprm *bprm;</code> which means “binary program”, then performing some checks, and eventually calling <code>bprm_execve</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>retval <span>=</span> <span>bprm_execve</span>(bprm);
</span></span></code></pre></div><p><code>bprm_execve</code> then proceeds to <code>exec_binprm</code>, which will then eventually invoke <code>search_binary_handler</code>. This function is responsible for identifying the file’s executable format. It starts with <code>retval = prepare_binprm(bprm)</code> and following that function, we realize it’s actually copying part of the contents of the file into the <code>bprm-&gt;buf</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/*
</span></span></span><span><span><span> * Fill the binprm structure from the inode.
</span></span></span><span><span><span> * Read the first BINPRM_BUF_SIZE bytes
</span></span></span><span><span><span> *
</span></span></span><span><span><span> * This may be called multiple times for binary chains (scripts for example).
</span></span></span><span><span><span> */</span>
</span></span><span><span><span>static</span> <span>int</span> <span>prepare_binprm</span>(<span>struct</span> linux_binprm <span>*</span>bprm)
</span></span><span><span>{
</span></span><span><span>	<span>loff_t</span> pos <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>	<span>memset</span>(bprm<span>-&gt;</span>buf, <span>0</span>, BINPRM_BUF_SIZE);
</span></span><span><span>	<span>return</span> <span>kernel_read</span>(bprm<span>-&gt;</span>file, bprm<span>-&gt;</span>buf, BINPRM_BUF_SIZE, <span>&amp;</span>pos);
</span></span><span><span>}
</span></span></code></pre></div><p><code>BINPRM_BUF_SIZE</code> is <em>256</em> in <code>include/linux/binfmts.h</code></p>
<p>Then it proceeds to look through a list of formats and checks which one the current program is:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>list_for_each_entry</span>(fmt, <span>&amp;</span>formats, lh) {
</span></span><span><span>	<span>if</span> (<span>!</span><span>try_module_get</span>(fmt<span>-&gt;</span>module))
</span></span><span><span>		<span>continue</span>;
</span></span><span><span>	<span>read_unlock</span>(<span>&amp;</span>binfmt_lock);
</span></span><span><span>
</span></span><span><span>	retval <span>=</span> fmt<span>-&gt;</span><span>load_binary</span>(bprm);
</span></span><span><span>
</span></span><span><span>	<span>read_lock</span>(<span>&amp;</span>binfmt_lock);
</span></span><span><span>	<span>put_binfmt</span>(fmt);
</span></span><span><span>	<span>if</span> (bprm<span>-&gt;</span>point_of_no_return <span>||</span> (retval <span>!=</span> <span>-</span>ENOEXEC)) {
</span></span><span><span>		<span>read_unlock</span>(<span>&amp;</span>binfmt_lock);
</span></span><span><span>		<span>return</span> retval;
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Those format modules are:</p>
<ul>
<li>binfmt_elf.c</li>
<li>binfmt_elf_fdpic.c</li>
<li>binfmt_flat.c</li>
<li>binfmt_misc.c</li>
<li>binfmt_script.c</li>
</ul>
<p>And they all are responsible for registering themselves so <code>search_binary_handler</code> test each one of them. We know that <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> is the regular binary format that Linux uses, <a href="https://cateee.net/lkddb/web-lkddb/BINFMT_ELF_FDPIC.html">ELF FDPIC</a> is an extension to ELF, FLAT binaries are just the instructions without any specific system configuration (<a href="https://stackoverflow.com/questions/1283342/executing-a-flat-binary-file-under-linux">this question</a> explains a bit), SCRIPT is the format that interprets our shebang, but what really caught my eye was MISC.</p>
<p>According to the <a href="https://docs.kernel.org/admin-guide/binfmt-misc.html">official Kernel Admin Guide</a>:</p>
<blockquote>
<p>This Kernel feature allows you to invoke almost (for restrictions see below) every program by simply typing its name in the shell. This includes for example compiled Java(TM), Python or Emacs programs. To achieve this you must tell binfmt_misc which interpreter has to be invoked with which binary. Binfmt_misc recognises the binary-type by matching some bytes at the beginning of the file with a magic byte sequence (masking out specified bits) you have supplied. Binfmt_misc can also recognise a filename extension aka <code>.com</code> or <code>.exe</code>.</p></blockquote>
<p>It’s another way to tell the Kernel what interpreter to run when invoking a program that’s not native (ELF). For scripts (text files) we mostly use a shebang, but for byte-coded binaries, such as Java’s JAR or Mono EXE files, it’s the way to go!</p>
<p>Returning to our shebang investigation, let’s examine <code>fs/binfmt_script.c</code>. Checking its registration mechanism near the end of the file reveals some key information:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>core_initcall</span>(init_script_binfmt);
</span></span><span><span><span>module_exit</span>(exit_script_binfmt);
</span></span><span><span><span>MODULE_DESCRIPTION</span>(<span>&#34;Kernel support for scripts starting with #!&#34;</span>);
</span></span><span><span><span>MODULE_LICENSE</span>(<span>&#34;GPL&#34;</span>);
</span></span></code></pre></div><p>There’s the module description (yep, shebang is not an official term), then a <code>core_initcall</code> call pointing to <code>init_script_binfmt</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>int</span> __init <span>init_script_binfmt</span>(<span>void</span>)
</span></span><span><span>{
</span></span><span><span>	<span>register_binfmt</span>(<span>&amp;</span>script_format);
</span></span><span><span>	<span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>That registers the <code>script_format</code> object, which is defined like this:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>struct</span> linux_binfmt script_format <span>=</span> {
</span></span><span><span>	.module		<span>=</span> THIS_MODULE,
</span></span><span><span>	.load_binary	<span>=</span> load_script,
</span></span><span><span>};
</span></span></code></pre></div><p>And when we examine the <code>load_script</code> function, boom:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>int</span> <span>load_script</span>(<span>struct</span> linux_binprm <span>*</span>bprm)
</span></span><span><span>{
</span></span><span><span>	<span>const</span> <span>char</span> <span>*</span>i_name, <span>*</span>i_sep, <span>*</span>i_arg, <span>*</span>i_end, <span>*</span>buf_end;
</span></span><span><span>	<span>struct</span> file <span>*</span>file;
</span></span><span><span>	<span>int</span> retval;
</span></span><span><span>
</span></span><span><span>	<span>/* Not ours to exec if we don&#39;t start with &#34;#!&#34;. */</span>
</span></span><span><span>	<span>if</span> ((bprm<span>-&gt;</span>buf[<span>0</span>] <span>!=</span> <span>&#39;#&#39;</span>) <span>||</span> (bprm<span>-&gt;</span>buf[<span>1</span>] <span>!=</span> <span>&#39;!&#39;</span>))
</span></span><span><span>		<span>return</span> <span>-</span>ENOEXEC;
</span></span><span><span>(...)
</span></span></code></pre></div><p>There the check is!</p>
<p>This function is very well-commented, detailing almost every step, so I recommend reading the source code <a href="https://github.com/torvalds/linux/blob/e48e99b6edf41c69c5528aa7ffb2daf3c59ee105/fs/binfmt_script.c#L34">here</a>. Essentially, it reads the first line, parses the interpreter path (and any arguments), opens the interpreter’s executable file, and assigns a reference to it to <code>bprm-&gt;interpreter</code>.</p>
<p>Back in <code>exec_binprm</code>, it will check for if an interpreter (from script or misc binary formats) was found, then if so:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>(...)
</span></span><span><span>ret <span>=</span> <span>search_binary_handler</span>(bprm);
</span></span><span><span><span>if</span> (ret <span>&lt;</span> <span>0</span>)
</span></span><span><span>	<span>return</span> ret;
</span></span><span><span><span>if</span> (<span>!</span>bprm<span>-&gt;</span>interpreter)
</span></span><span><span>	<span>break</span>;
</span></span><span><span>
</span></span><span><span>exec <span>=</span> bprm<span>-&gt;</span>file;
</span></span><span><span>bprm<span>-&gt;</span>file <span>=</span> bprm<span>-&gt;</span>interpreter;
</span></span><span><span>bprm<span>-&gt;</span>interpreter <span>=</span> NULL;
</span></span><span><span>
</span></span><span><span><span>exe_file_allow_write_access</span>(exec);
</span></span><span><span><span>if</span> (<span>unlikely</span>(bprm<span>-&gt;</span>have_execfd)) {
</span></span><span><span>	<span>if</span> (bprm<span>-&gt;</span>executable) {
</span></span><span><span>		<span>fput</span>(exec);
</span></span><span><span>		<span>return</span> <span>-</span>ENOEXEC;
</span></span><span><span>	}
</span></span><span><span>	bprm<span>-&gt;</span>executable <span>=</span> exec;
</span></span><span><span>} <span>else</span>
</span></span><span><span>	<span>fput</span>(exec);
</span></span><span><span>(...)
</span></span></code></pre></div><p>If an interpreter <em>is</em> found, <code>bprm-&gt;file</code> is updated to point to the interpreter’s file (replacing the script file), and the reference count for the original script file (<code>exec</code>) is decremented via <code>fput(exec)</code>.</p>
<p>So, a single <code>execve</code> syscall on the script file triggers the kernel to: open the script, detect the <code>#!</code>, find and open the specified interpreter, and finally load and execute the <em>interpreter</em>, passing the script path as an argument. The kernel effectively replaces the process image with the interpreter’s.</p>

<p>That’s true. You don’t really need #! to run shellscripts, but that’s a fallback mechanism implemented by the shell, rather than the kernel, for example, if you try to strace the execution of a shell script lacking a shebang:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ cat test.sh
</span></span><span><span>echo <span>&#34;Hello, World!&#34;</span>
</span></span><span><span>
</span></span><span><span>$ ./test.sh
</span></span><span><span>Hello, World!
</span></span><span><span>
</span></span><span><span>$ strace ./test.sh
</span></span><span><span>execve<span>(</span><span>&#34;./test.sh&#34;</span>, <span>[</span><span>&#34;./test.sh&#34;</span><span>]</span>, 0x7ffd9a1afcf0 /* <span>33</span> vars */<span>)</span> <span>=</span> -1 ENOEXEC <span>(</span>Exec format error<span>)</span>
</span></span><span><span>strace: exec: Exec format error
</span></span><span><span>+++ exited with <span>1</span> +++
</span></span></code></pre></div><p>It will fail with <code>ENOEXEC (Exec format error)</code>, since there’s no indication of format for that file.</p>
<p>To observe the shell’s fallback behavior, we can trace a <em>new</em> shell instance invoking the script. We use <code>sh -c &#39;./test.sh&#39;</code> to ensure the child shell attempts the <code>execve</code>, rather than the parent shell interpreting the script directly. We’ll use <code>strace</code> with <code>-f</code> (to follow child processes) and filter for key syscalls:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>strace -e trace<span>=</span>execve,openat,read,close -f sh -c <span>&#34;./test.sh&#34;</span>
</span></span></code></pre></div><p>If there’s a <code>#!</code> in <code>test.sh</code>, it will return this:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ cat test.sh
</span></span><span><span><span>#! /usr/bin/sh</span>
</span></span><span><span>echo <span>&#34;Hello, World!&#34;</span>
</span></span><span><span>
</span></span><span><span>$ strace -e trace<span>=</span>execve,openat,read,close -f sh -c <span>&#34;./test.sh&#34;</span>
</span></span><span><span>execve<span>(</span><span>&#34;/usr/bin/sh&#34;</span>, <span>[</span><span>&#34;sh&#34;</span>, <span>&#34;-c&#34;</span>, <span>&#34;./test.sh&#34;</span><span>]</span>, 0x7ffd51f86418 /* <span>33</span> vars */<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>(</span>...<span>)</span>
</span></span><span><span>strace: Process <span>2522303</span> attached
</span></span><span><span><span>[</span>pid 2522303<span>]</span> execve<span>(</span><span>&#34;./test.sh&#34;</span>, <span>[</span><span>&#34;./test.sh&#34;</span><span>]</span>, 0x5ec40c994540 /* <span>33</span> vars */<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>(</span>...<span>)</span>
</span></span><span><span><span>[</span>pid 2522303<span>]</span> openat<span>(</span>AT_FDCWD, <span>&#34;./test.sh&#34;</span>, O_RDONLY<span>)</span> <span>=</span> <span>3</span>
</span></span><span><span><span>[</span>pid 2522303<span>]</span> close<span>(</span>3<span>)</span>                  <span>=</span> <span>0</span>
</span></span><span><span><span>[</span>pid 2522303<span>]</span> read<span>(</span>10, <span>&#34;#! /usr/bin/sh\necho \&#34;Hello, Worl&#34;</span>..., 8192<span>)</span> <span>=</span> <span>36</span>
</span></span><span><span>Hello, World!
</span></span><span><span><span>[</span>pid 2522303<span>]</span> read<span>(</span>10, <span>&#34;&#34;</span>, 8192<span>)</span>        <span>=</span> <span>0</span>
</span></span><span><span><span>[</span>pid 2522303<span>]</span> +++ exited with <span>0</span> +++
</span></span><span><span><span>(</span>...<span>)</span>
</span></span></code></pre></div><p>If no <code>#!</code> is found:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ cat test.sh
</span></span><span><span>echo <span>&#34;Hello, World!&#34;</span>
</span></span><span><span>
</span></span><span><span>$ strace -e trace<span>=</span>execve,openat,read,close -f sh -c <span>&#34;./test.sh&#34;</span>
</span></span><span><span>execve<span>(</span><span>&#34;/usr/bin/sh&#34;</span>, <span>[</span><span>&#34;sh&#34;</span>, <span>&#34;-c&#34;</span>, <span>&#34;./test.sh&#34;</span><span>]</span>, 0x7ffd4de7e798 /* <span>33</span> vars */<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>(</span>...<span>)</span>
</span></span><span><span>strace: Process <span>2524967</span> attached
</span></span><span><span><span>[</span>pid 2524967<span>]</span> execve<span>(</span><span>&#34;./test.sh&#34;</span>, <span>[</span><span>&#34;./test.sh&#34;</span><span>]</span>, 0x651ce522f540 /* <span>33</span> vars */<span>)</span> <span>=</span> -1 ENOEXEC <span>(</span>Exec format error<span>)</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> openat<span>(</span>AT_FDCWD, <span>&#34;./test.sh&#34;</span>, O_RDONLY|O_NOCTTY<span>)</span> <span>=</span> <span>3</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> read<span>(</span>3, <span>&#34;echo \&#34;Hello, World!\&#34;\n&#34;</span>, 128<span>)</span> <span>=</span> <span>21</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> close<span>(</span>3<span>)</span>                  <span>=</span> <span>0</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> execve<span>(</span><span>&#34;/bin/sh&#34;</span>, <span>[</span><span>&#34;/bin/sh&#34;</span>, <span>&#34;./test.sh&#34;</span><span>]</span>, 0x651ce522f540 /* <span>33</span> vars */<span>)</span> <span>=</span> <span>0</span>
</span></span><span><span><span>(</span>...<span>)</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> openat<span>(</span>AT_FDCWD, <span>&#34;./test.sh&#34;</span>, O_RDONLY<span>)</span> <span>=</span> <span>3</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> close<span>(</span>3<span>)</span>                  <span>=</span> <span>0</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> read<span>(</span>10, <span>&#34;echo \&#34;Hello, World!\&#34;\n&#34;</span>, 8192<span>)</span> <span>=</span> <span>21</span>
</span></span><span><span>Hello, World!
</span></span><span><span><span>[</span>pid 2524967<span>]</span> read<span>(</span>10, <span>&#34;&#34;</span>, 8192<span>)</span>        <span>=</span> <span>0</span>
</span></span><span><span><span>[</span>pid 2524967<span>]</span> +++ exited with <span>0</span> +++
</span></span><span><span><span>(</span>...<span>)</span>
</span></span></code></pre></div><p>After filtering the output, it’s clear that in the first case (with shebang), it’s doing the initial <code>execve</code>for the shell instance we’re creating, then another <code>execve</code> for <code>test.sh</code> and do all the process we described before. In the second case (no shebang), the child process’s <code>execve</code> on <code>./test.sh</code> fails with <code>ENOEXEC</code>. The parent shell (<code>sh -c</code>) catches this error. It then likely uses <code>openat</code> and <code>read</code> to examine the file. Detecting it’s likely a shell script, it then explicitly executes <code>/bin/sh ./test.sh</code> via a <em>second</em> <code>execve</code> call.</p>

<p>We found out that the kernel runs the scripts through its own <code>execve</code> syscall assuming it contains a <code>#!</code> <em>and</em> has execute permission set. But where is that permission checked?</p>
<p>If we try to invoke a script that doesn’t have execute permissions, we’ll get this:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ ./test.sh
</span></span><span><span>zsh: permission denied: ./test.sh
</span></span></code></pre></div><p>But it doesn’t give off too much. However, if we <code>strace</code> it again:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ strace ./test.sh
</span></span><span><span>execve<span>(</span><span>&#34;./test.sh&#34;</span>, <span>[</span><span>&#34;./test.sh&#34;</span><span>]</span>, 0x7ffd2b4a52d0 /* <span>33</span> vars */<span>)</span> <span>=</span> -1 EACCES <span>(</span>Permission denied<span>)</span>
</span></span><span><span>strace: exec: Permission denied
</span></span><span><span>+++ exited with <span>1</span> +++
</span></span></code></pre></div><p>It returns the error code and description from the syscall: <code>EACCES (Permission denied)</code>. <strong>Error codes are always a good start point</strong>. Searching for <code>EACCES</code> in <code>fs/exec.c</code> leads us to the check within the <code>do_open_execat</code> function</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>if</span> (<span>WARN_ON_ONCE</span>(<span>!</span><span>S_ISREG</span>(<span>file_inode</span>(file)<span>-&gt;</span>i_mode)) <span>||</span>
</span></span><span><span>	<span>path_noexec</span>(<span>&amp;</span>file<span>-&gt;</span>f_path))
</span></span><span><span>	<span>return</span> <span>ERR_PTR</span>(<span>-</span>EACCES);
</span></span></code></pre></div><p>Tracing the call stack back from <code>do_open_execat</code>, we find it’s called during the setup of the <code>bprm</code> structure within <code>do_execveat_common</code>, the entrypoint to the <code>execve</code> syscall:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>bprm <span>=</span> <span>alloc_bprm</span>(fd, filename, flags);
</span></span><span><span><span>if</span> (<span>IS_ERR</span>(bprm)) {
</span></span><span><span>	retval <span>=</span> <span>PTR_ERR</span>(bprm);
</span></span><span><span>	<span>goto</span> out_ret;
</span></span><span><span>}
</span></span></code></pre></div><p>Now, understanding how <code>path_noexec</code> checks the <em>execute</em> permission in the file involves a lot of other stuff like understanding how the kernel deals with the filesystem. But that’ll be a future post.</p>
<h3 id="edit">EDIT</h3>
<ul>
<li>Switched the usage of <code>where</code> for <code>which</code>, since it’s a zsh-only command. These add to my list of confusing commands just like <code>adduser</code> and <code>useradd</code>. Thanks <strong>u/pihkal</strong>.</li>
<li>I corrected calling ELF the “traditional binary format” of linux to “regular binary format”. Although ELF has been the regular format for so many years, calling it traditional was maybe not correct. Thanks <strong>/u/Admqui</strong>. Some material on ELF and the old <code>a.out</code> format:
<ul>
<li><a href="https://web.archive.org/web/20040713171954/http://www.ibiblio.org/pub/historic-linux/distributions/slackware/3.9/docs/ELF-HOWTO">The Linux ELF HOWTO (1996)</a></li>
<li><a href="https://lwn.net/Articles/631631/">How programs get run: ELF binaries (2015)</a></li>
</ul>
</li>
</ul>
<p>Join the discussion on <a href="https://www.reddit.com/r/programming/comments/1jukuv3/demystifying_the_shebang_kernel_adventures/">Reddit</a>.</p>

      </article></div>
  </body>
</html>
