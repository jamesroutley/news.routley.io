<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antithesis.com/blog/madness/">Original</a>
    <h1>At the Mountains of Madness</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
        <nav><a href="https://antithesis.com/blog">← Blog</a></nav>
        <header>
            
            
            
            <p>July 10, 2024</p>

        </header>
        <blockquote>
<p data-sid="6000006">I am forced into speech because men of science have refused to follow my advice without knowing why… Doubt of the real facts, as I must reveal them, is inevitable; yet if I suppressed what will seem extravagant and incredible there would be nothing left… In the end I must rely on the judgment and standing of the few scientific leaders who have, on the one hand, sufficient independence of thought to weigh my data on its own hideously convincing merits or in the light of certain primordial and highly baffling myth-cycles; and on the other hand, sufficient influence to deter the exploring world in general from any rash and overambitious programme in the region of those mountains of madness.</p>
<p data-sid="6000007">– H.P. Lovecraft, <a href="https://www.hplovecraft.com/writings/texts/fiction/mm.aspx">At the Mountains of Madness</a></p>
</blockquote>
<p data-sid="6000008">tl;dr: we are <a href="https://github.com/antithesishq/madness">open-sourcing an internal tool</a> that solves a problem that we think many NixOS shops are likely to run into. The rest of this post is just the story of how we came to write this tool, which is totally a skippable story. But along the way we learned things which have <em>opened up such terrifying vistas of reality that we shall either go mad from the revelation or flee from the light into the peace and safety of a new dark age.</em> We hope you find it interesting too!</p>
<p><picture><source type="image/webp" srcset="/img_opt/WIEPEK2K_g-1265.webp 1265w"/><img alt="A barren landscape filled with strange ruins" loading="lazy" decoding="async" src="https://antithesis.com/img_opt/WIEPEK2K_g-1265.png" width="1265" height="1265"/></picture></p>
<div><p data-sid="6000009">We are big fans of <a href="https://nixos.org/">Nix</a>, the build system, and we use NixOS literally everywhere at our company.<sup>1</sup> But not everybody in the world runs NixOS, so we are frequently in the business of building native executables and shared libraries that need to run both on NixOS and on the kinds of Linux used by normal people (insofar as any Linux user is a normal person). Does that sound like it should be straightforward? Buckle up and prepare yourself for a descent into the depths of ELF program interpretation and loading. We survived this journey, we even brought back an artifact. But at what cost? At what terrible cost?</p></div>
<p data-sid="6000011">I used to think computers were straightforward. I used to think computers made sense. I could do things like compile a program. See? Like this:</p>
<pre tabindex="0" data-sid="6000012"><code><span><span>$</span><span> gcc</span><span> hello.c</span></span>
<span><span>$</span><span> ./a.out</span></span>
<span><span>&gt;</span><span> Hello, world</span><span>!</span></span>
<span></span></code></pre>
<p data-sid="6000013">Amazing! And of course, since I compiled my program on NixOS, when I run <code>ldd</code> on it I’m going to get this wonderful, comforting gobbledygook:</p>
<pre tabindex="0" data-sid="6000014"><code><span><span>$</span><span> ldd</span><span> a.out</span></span>
<span><span>&gt;</span><span> linux-vdso.so.1 (</span><span>0x00007ffebf234000</span><span>)</span></span>
<span><span>&gt;</span><span> libm.so.6 =</span><span>&gt;</span><span> /nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/libm.so.6 (</span><span>0x00007f12d80e2000</span><span>)</span></span>
<span><span>&gt;</span><span> libpthread.so.0 =</span><span>&gt;</span><span> /nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/libpthread.so.0 (</span><span>0x00007f12d80dd000</span><span>)</span></span>
<span><span>&gt;</span><span> libc.so.6 =</span><span>&gt;</span><span> /nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/libc.so.6 (</span><span>0x00007f12d7ef0000</span><span>)</span></span>
<span><span>&gt;</span><span> /nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib/ld-linux-x86-64.so.2 =</span><span>&gt;</span><span> /nix/store/k7zgvzp2r31zkg9xqgjim7mbknryv6bs-glibc-2.39-52/lib64/ld-linux-x86-64.so.2 (</span><span>0x00007f12d81c7000</span><span>)</span></span>
<span></span></code></pre>
<p data-sid="6000015">Those paths that start with <code>/nix/store</code> followed by a long pseudorandom string might look ugly to you, but to me they look like salvation. Yes, salvation from the depths of <a href="https://en.wikipedia.org/wiki/DLL_Hell">DLL Hell</a>. You see, in ancient times dynamic linking was invented to save a few kilobytes here and there. If a bunch of different programs all needed the same library, the OS could provide just one copy of the library, and everybody could map it into their address space. This seemed like a great idea at the time, and then it led to 40 years of version conflicts, inscrutable error messages, and total dependency resolution insanity.</p>
<p data-sid="6000016">It was partly in the interest of slaying this monster that containers were invented. One way to think of a container is that you’re just static-linking your entire userspace, which seems excessive unless you remember the world where it was normal to see your process spitting out errors like “cannot open shared object file” when you deployed it to prod, and vowed to become a wandering hermit and never to touch a computer again. Hypothetically. NixOS is a different way to solve the same problem. Instead of wrapping an entire Linux userspace around your process like a warm parka, we just store every version of every dependency, uniquely identified by the hash of all of <em>its</em> dependencies, and then recursively do the same thing to those, and so on. The result is that you can have multiple versions of your entire operating system happily coexisting on the same hard drive, and a lot of other crazy tricks.</p>
<div><div><p data-sid="6000017">If you’ve been around the software packaging block, then you probably know the first error you’ll run into when you try to run our hello world program on Ubuntu. Yes, it has to do with <code>glibc</code> version symbols, the bane of every software packager and maintainer. The problem boils down to the fact that it’s not safe to have a newer version of <code>glibc</code> on your build machine than on your deployment machine (developers who want to build one binary that targets multiple Linuxes generally have to keep around a computer with the <a href="https://gist.github.com/wagenet/35adca1a032cec2999d47b6c40aa45b1">lowest common denominator</a> version of <code>glibc</code>).<sup>2</sup> NixOS tends to have an extremely bleeding edge <code>glibc</code>, so this will always be a problem. Fortunately, it’s trivial on NixOS to summon another universe into existence where every program and every dynamic dependency was built with an old <code>glibc</code>, then do your build in that universe. Cool.</p>
<p data-sid="6000018">But you do that and then it still doesn’t work.</p>
<p><picture><source type="image/webp" srcset="/img_opt/shONoiPHyg-1265.webp 1265w"/><img alt="An explorer happens upon something unexpected" loading="lazy" decoding="async" src="https://antithesis.com/img_opt/shONoiPHyg-1265.png" width="1265" height="1265"/></picture></p>
</div></div>
<p data-sid="6000020">Here I am running <code>ldd</code> on my nice, new binary linked to an ancient and rotting <code>glibc</code>. Notice how everything is now pointing to an older <code>glibc</code> in the Nix store. So why is it still not working?</p>
<pre tabindex="0" data-sid="6000021"><code><span><span>$</span><span> ldd</span><span> a.out</span></span>
<span><span>&gt;</span><span> linux-vdso.so.1 (</span><span>0x00007ffebf234000</span><span>)</span></span>
<span><span>&gt;</span><span> libpthread.so.0 =</span><span>&gt;</span><span> /nix/store/kpsz7y412y5f95mv468bs4v5c2g9zy67-glibc-2.27/lib/libpthread.so.0 (</span><span>0x00007f12d80dd000</span><span>)</span></span>
<span><span>&gt;</span><span> libc.so.6 =</span><span>&gt;</span><span> /nix/store/kpsz7y412y5f95mv468bs4v5c2g9zy67-glibc-2.27/lib/libc.so.6 (</span><span>0x00007f12d7ef0000</span><span>)</span></span>
<span><span>&gt;</span><span> /nix/store/kpsz7y412y5f95mv468bs4v5c2g9zy67-glibc-2.27/lib/ld-linux-x86-64.so.2 =</span><span>&gt;</span><span> /nix/store/j6mwswpa6zqhdm1lm2lv9iix3arn774g-glibc-2.38-27/lib64/ld-linux-x86-64.so.2 (</span><span>0x00007f3b6f66a000</span><span>)</span></span>
<span></span></code></pre>
<p data-sid="6000022">Well, let’s try running it in a nice, normal Ubuntu LTS container:</p>
<pre tabindex="0" data-sid="6000023"><code><span><span>$</span><span> docker</span><span> run</span><span> -it</span><span> -v</span><span> a.out:/tmp/a.out</span><span> docker.io/ubuntu:20.04</span></span>
<span><span>root@a00e456aafc8:/#</span><span> /tmp/a.out</span></span>
<span><span>&gt;</span><span> bash: /tmp/a.out: No such file or directory</span></span>
<span></span></code></pre>
<p data-sid="6000024">I beg your pardon?</p>
<pre tabindex="0" data-sid="6000025"><code><span><span>root@a00e456aafc8:/#</span><span> ls</span><span> /tmp</span></span>
<span><span>&gt;</span><span> a.out</span></span>
<span></span></code></pre>
<p data-sid="6000026">Wat.</p>
<pre tabindex="0" data-sid="6000027"><code><span><span>root@9cd480a40ee7:/#</span><span> ls</span><span> -l</span><span> /tmp</span></span>
<span><span>&gt;</span><span> total 5</span></span>
<span><span>&gt;</span><span> -rwxr-xr-x 1 root root 15504 Jun 26 01:38 a.out</span></span>
<span></span></code></pre>
<p data-sid="6000028">Is it some crazy Docker bug? Did this turn into a character device or something?</p>
<pre tabindex="0" data-sid="6000029"><code><span><span>root@9cd480a40ee7:/#</span><span> stat</span><span> /tmp/a.out</span><span> </span></span>
<span><span>&gt;</span><span>  File: /tmp/a.out</span></span>
<span><span>&gt;</span><span>  Size: 15504     	Blocks: 9          IO Block: 15872  regular file</span></span>
<span><span>&gt;</span><span> Device: 26h/38d	Inode: 33547       Links: 1</span></span>
<span><span>&gt;</span><span> Access: (</span><span>0755/-rwxr-xr-x</span><span>)  Uid: (    </span><span>0/</span><span>    root</span><span>)   Gid: (    </span><span>0/</span><span>    root</span><span>)</span></span>
<span><span>&gt;</span><span> Access: 2024-06-29 02:54:28.411329967 +0000</span></span>
<span><span>&gt;</span><span> Modify: 2024-06-26 01:38:50.576992464 +0000</span></span>
<span><span>&gt;</span><span> Change: 2024-06-26 01:38:50.576992464 +0000</span></span>
<span><span>&gt;</span><span> Birth: -</span></span>
<span></span></code></pre>
<p data-sid="6000030">Maybe… a dependency resolution bug? Maybe it can’t find some shared library?</p>
<pre tabindex="0" data-sid="6000031"><code><span><span>root@9cd480a40ee7:/#</span><span> ldd</span><span> /tmp/a.out</span></span>
<span><span>&gt;</span><span> linux-vdso.so.1 (</span><span>0x00007fff625c4000</span><span>)</span></span>
<span><span>&gt;</span><span> libpthread.so.0 =</span><span>&gt;</span><span> /lib/x86_64-linux-gnu/libpthread.so.0 (</span><span>0x00007fb8ed817000</span><span>)</span></span>
<span><span>&gt;</span><span> libc.so.6 =</span><span>&gt;</span><span> /lib/x86_64-linux-gnu/libc.so.6 (</span><span>0x00007fb8ed625000</span><span>)</span></span>
<span><span>&gt;</span><span> /nix/store/kpsz7y412y5f95mv468bs4v5c2g9zy67-glibc-2.27/lib/ld-linux-x86-64.so.2 =</span><span>&gt;</span><span> /lib64/ld-linux-x86-64.so.2 (</span><span>0x00007fb8ed98d000</span><span>)</span></span>
<span></span></code></pre>
<p data-sid="6000032">The clue is actually right there in that <code>ldd</code> output. Can you figure it out? Meditate on this picture of a heroic anteater facing down a nightmarish monster, and then scroll down when you have a guess.</p>
<p><picture><source type="image/webp" srcset="/img_opt/SGsqieHeaa-1294.webp 1294w"/><img alt="Sometimes systems programming feels like this..." loading="lazy" decoding="async" src="https://antithesis.com/img_opt/SGsqieHeaa-1294.png" width="1294" height="1294"/></picture></p>
<p data-sid="6000033"><code>ldd</code> is a tool that tells you about the dynamic dependencies of your program, <em>and</em> what they got resolved to. The library you were looking for is on the left side of each of the arrows, and the actual, resolved library from your load path is on the right side. Since we’re running this in an Ubuntu container, the libraries it finds are all in normal locations under <code>/lib</code> rather than zany locations under <code>/nix/store</code>.</p>
<p data-sid="6000034"><code>ldd</code> prints the location of <code>ld-linux.so</code> (the Linux ELF program loader) in the same format, but in this case it’s a total lie. When you ran <code>ldd</code> on the program, it was able to find a copy of <code>ld-linux.so</code> for you. But when you run the actual program, <code>ld-linux.so</code> itself is the thing that does library name resolution! It can’t very well find itself, so every ELF native binary on Linux hardcodes the location of the <code>ld-linux.so</code> that it should use. Thus, if you want to know the copy of <code>ld-linux.so</code> that your program will use, <code>ldd</code> gives a very misleading answer. Only the thing on the <em>left</em> side of the arrow matters, the thing on the right-hand side is a lie that will not matter when your program actually runs. And in our case, the hardcoded path to <code>ld-linux.so</code> points to a location in the Nix store that definitely doesn’t exist on Ubuntu, and that’s what leads to the “No such file or directory” error. It’s a little clearer if you look at the output of the <code>file</code> utility:</p>
<pre tabindex="0" data-sid="6000035"><code><span><span>root@9cd480a40ee7:/#</span><span> file</span><span> /tmp/a.out</span><span> </span></span>
<span><span>&gt;</span><span> /tmp/a.out: ELF 64-bit LSB executable, x86-64, version 1 (</span><span>SYSV</span><span>), dynamically linked, interpreter /nix/store/kpsz7y412y5f95mv468bs4v5c2g9zy67-glibc-2.27/lib/ld-linux-x86-64.so.2, </span><span>for</span><span> GNU/Linux 3.10.0, not stripped</span></span>
<span></span></code></pre>
<p data-sid="6000036">Where does this hardcoded path to <code>ld-linux.so</code> come from? Well, it’s injected in the link phase of your compilation toolchain, based on information provided by your installation of the C standard library. Fortunately, the good people at NixOS have produced a handy utility called <a href="https://github.com/NixOS/patchelf">patchelf</a> that lets you selectively modify the ELF headers of an existing executable or shared library, and <code>patchelf</code> has an option, <code>--set-interpreter</code> that lets you modify this path. So that’s it, we just need to add a call to <code>patchelf</code> in our toolchain, and we should be good…</p>
<p data-sid="6000037">…but what do we set the path to? If we set it to a location in the Nix store, this won’t work on any other kind of Linux. If we set it to the <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">FHS standard location</a>, it won’t work on NixOS. We want the same binary to work in both locations. Is this possible?</p>
<p data-sid="6000038">Yes… if you’re willing to embrace Madness.</p>
<div><p data-sid="6000039">Our first thought was that since the FHS location is fixed, we could simply configure our NixOS machines to have a symlink from that standard location to the “real” location of the <code>ld-linux.so</code> we wanted to use. Then, we would simply patch all the binaries we built to have the FHS loader location. This would mean they work out of the box on Ubuntu, and on NixOS they’d just require a line or two in your <code>configuration.nix</code>. In fact this approach is so sensible that in NixOS 24.05 they use <a href="https://search.nixos.org/options?channel=24.05&amp;show=environment.stub-ld.enable&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=stub-ld">something very much like it</a> to print a sensible error message when you try to run a binary compiled on a different system.<sup>3</sup></p></div>
<p data-sid="6000041">But we want to do better than that! We don’t want you to get an error message when you run a binary with an FHS loader path, we want it to actually work! Should be straightforward right? Just point the symlink at a real copy of <code>ld-linux.so</code>. There’s only one problem…</p>
<p data-sid="6000042">Which one?</p>
<p><picture><source type="image/webp" srcset="/img_opt/REYEFhAVtq-1294.webp 1294w"/><img alt="...and sometimes it feels like this." loading="lazy" decoding="async" src="https://antithesis.com/img_opt/REYEFhAVtq-1294.png" width="1294" height="1294"/></picture></p>
<p data-sid="6000043">Remember the part where I said the amazing thing about NixOS is that you can have multiple versions of every library happily coexisting on your computer? On a normal version of Linux, you have one copy and one version of all of your core system libraries. So on a normal Linux you also have one version of <code>ld-linux.so</code>, living in a canonical location, that’s tested and confirmed to work with those libraries. But a moment ago I just showed you that you can have multiple versions of <code>glibc</code> on the same Nix machine, and moreover entire non-overlapping software ecosystems using those different versions of <code>glibc</code>. Can we guarantee that the <code>ld-linux.so</code> we choose will work with all of them?</p>
<p data-sid="6000044">Unfortunately, this is not some theoretical issue. If you go try to build your own copy of <code>ld-linux.so</code>, you’ll discover that it’s part of the <code>glibc</code> project, and that it’s versioned together with <code>glibc</code>. There’s no documentation anywhere about what the rules are around using mismatched <code>glibc</code>/<code>ld-linux.so</code> versions, but we’ve determined via exhaustive experimentation that it is not guaranteed to work. So if we pick a random version of <code>ld-linux.so</code> out of the Nix store for our canonical symlink to point to, it might not work for some programs. In Nix jargon, this is what’s called an impurity, an arbitrary source of out-of-band state about your system that could cause a program to fail, and that’s a big no-no.</p>
<div><p data-sid="6000045">This is a tricky issue. There’s a project which I discovered while I was writing this post, called <a href="https://github.com/Mic92/nix-ld">nix-ld</a>, that is basically trying to deal with this same problem using a similar approach. They also ran into this impurity issue and decided that the best course was to force the <em>user</em> to specify which version of <code>ld-linux.so</code> to use via an environment variable. That’s a totally valid approach, and their program has some other very nice features,<sup>4</sup> but what if we could somehow scan the binary and just <em>figure out</em> dynamically which <code>ld-linux.so</code> to use?</p></div>
<p data-sid="6000047">If we <em>could</em> figure this out dynamically, there would be an easy way to take advantage of the information. You see, there’s a way to override the program loader path hardcoded into a binary, which is just to invoke the loader directly as the first argument of your command (even before the program you’re trying to run). So for instance: <code>$ foo</code> will execute the program <code>foo</code> using the path to <code>ld-linux.so</code> in <code>foo</code>’s ELF headers. But <code>$ /home/will/my_crazy_ld-linux.so foo</code> will ignore the one that’s present in <code>foo</code>’s ELF headers, and directly use <code>/home/will/my_crazy_ld-linux.so</code>. But what this means is that you can “chain” program loaders – it’s possible to write a “meta-loader” which when asked to load a program, invokes some other loader to finish the job. To make this concrete, here’s the simplest possible example of such a meta-loader:</p>
<pre tabindex="0" data-sid="6000048"><code><span><span>#!/usr/bin/env bash</span></span>
<span><span>/lib64/ld-linux-x86-64.so.2</span><span> $1</span></span>
<span></span></code></pre>
<p data-sid="6000049">So if we knew what the correct loader should be, then we could have the meta-loader invoke it (and hardcode the path to the meta-loader into our program). But is there a foolproof way to decide what the correct loader is? Again, YES! There’s another special header in your executable which defines the <a href="https://en.wikipedia.org/wiki/Rpath">“RPATH” and the “RUNPATH”</a>, think of these as a way of providing hints to the dynamic linker about where to go looking for certain libraries that you’ve linked against. But for a binary compiled on NixOS, these actually contain store paths for (among other things) the <code>glibc</code> that your program was built against. And that same store path will contain a copy of <code>ld-linux.so</code> that is guaranteed (well, I hope) to work with that version of <code>glibc</code>. Best of all, having a bunch of extra <code>RPATH</code>s pointing to nonexistent Nix store locations doesn’t break anything on normal Linux. And that means we can actually have a plan that works.</p>
<p><picture><source type="image/webp" srcset="/img_opt/abgCANcj6P-1265.webp 1265w"/><img alt="That moment when you&#39;ve figured it all out" loading="lazy" decoding="async" src="https://antithesis.com/img_opt/abgCANcj6P-1265.png" width="1265" height="1265"/></picture></p>
<p data-sid="6000050">Let’s consider the 4 possible cases of has/does not have a Nix-style <code>RPATH</code> and running on NixOS/normal linux:</p>
<ul>
<li data-sid="6000051"><span>Normal</span> binary, <span>Normal</span> Linux: No problem, the loader is where we expect and library resolution works as normal.</li>
<li data-sid="6000052"><span>Nix</span> binary, <span>Normal</span> Linux: No problem, we <code>patchelf</code>’d the binary so it works on normal linux. Library resolution using the <code>RPATH</code> will fail, and then it will fall back on the system library path and find what it needs.</li>
<li data-sid="6000053"><span>Nix</span> binary, <span>NixOS</span>: No problem, our symlink will point it at the meta-loader, which will then read the <code>RPATH</code> and pick the correct “real” loader to use.</li>
<li data-sid="6000054"><span>Normal</span> binary, <span>NixOS</span>: <strong>ALSO NO PROBLEM!!!</strong> Assuming that your binary is able to run at all, there is some <code>glibc</code> it will pick up at runtime (perhaps via your shell’s <code>PATH</code> or <code>LD_LIBRARY_PATH</code>). Our symlink will point the binary at the meta-loader, which will fail to read the <code>RPATH</code>, and fall back on the <code>ld-linux.so</code> provided by the <code>glibc</code> installation that your binary would have used. This will exactly match the <code>glibc</code> that gets loaded by the process, so everything will still work.</li>
</ul>
<p data-sid="6000055">So great, now we have a design that should work. Can we just write a little shell script to do this and act as our meta-loader?</p>
<p data-sid="6000056">Lol. Lmao, even.</p>
<p data-sid="6000057">Remember our simplest possible meta-loader? It takes your program and invokes it again using the real loader. It looked like this:</p>
<pre tabindex="0" data-sid="6000058"><code><span><span>#!/usr/bin/env bash</span></span>
<span><span>/lib64/ld-linux-x86-64.so.2</span><span> $1</span></span>
<span></span></code></pre>
<p data-sid="6000059">This minimal meta-loader will totally work if you invoke it directly like <code>$ meta_loader.sh foo</code>, and it will totally <em>not</em> work if you hardcode its path (or a symlink to it) in the ELF headers of a binary. Why? I dunno man, haven’t you learned not to ask these sorts of questions? This is the part of programming that feels more like archaeology. We are descending through geological strata, marveling at perfectly preserved skulls and papyri and stuff, pondering how to run our sewer line through here without triggering a lot of red tape.</p>
<div><div><p data-sid="6000060">Great, no shell script. Let’s write a C program. Yeah, a simple C program. C programs are great. C has a standard library. Unfortunately, if you attempt to use that standard library, your little meta-loader will fail in all sorts of gory ways.<sup>5</sup> Again, we don’t have an exact diagnosis of why this is. We are in the region of the space-time continuum where we sort of shrug our shoulders and roll with things.</p>
<p data-sid="6000061">Great, no standard library. We will write a C program like God intended: using raw system calls, intrinsics, and a little inline assembly. Unfortunately that is not the most productive programming environment, so we cheat and have our meta-loader actually just bootstrap the loading process, and defer all the hard work to a… shell script which we exec. This <em>totally</em> works.<sup>6</sup> Yes, after all that it really genuinely works. This program has never let us down. If you want to try it, we’ve open-sourced it <a href="https://github.com/antithesishq/madness">here</a> and turned it into a tiny NixOS module that’s trivial to enable. Enjoy!</p>
<p><picture><source type="image/webp" srcset="/img_opt/ieGeYRYTbh-1265.webp 1265w"/><img alt="We promise it will be good for your computer" loading="lazy" decoding="async" src="https://antithesis.com/img_opt/ieGeYRYTbh-1265.png" width="1265" height="1265"/></picture></p>
</div></div>

    </section>
</div></div>
  </body>
</html>
