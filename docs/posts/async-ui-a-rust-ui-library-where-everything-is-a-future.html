<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wishawa.github.io/posts/async-ui-intro/">Original</a>
    <h1>Show HN: Async UI: A Rust UI Library Where Everything is a Future</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>This blog post is intended for readers with some experiences in async Rust. It assumes you know what a <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/std/future/trait.Future.html">Future</a> is!</p>
<h2 id="what-is-async-ui">What is Async UI?</h2>
<p>Async UI is a <strong>proof-of-concept</strong> Rust UI library with backends for the web (HTML/JS) and GTK 4.</p>
<h2 id="screenshots">Screenshots</h2>
<p>Todo List Demo <a rel="noopener nofollow" target="_blank" href="https://wishawa.github.io/async_ui/todomvc">(interactive version here)</a></p>
<p><img src="https://wishawa.github.io/posts/async-ui-intro/web-todomvc.png" alt="Todo List demo"/></p>
<p>GTK Hacker News Screenshot</p>
<p><img src="https://wishawa.github.io/posts/async-ui-intro/gtk-hackernews.png" alt="GTK Hacker News screenshot"/></p>
<h2 id="why-async-for-uis">Why Async for UIs?</h2>
<p>UI widgets are <strong>retained</strong>: they run some code, stay there and wait for some events (such as user interactions), and then run some more code to handle those events.</p>
<p>Sync Rust cannot handle the <em>stay there and wait for some events</em> step in a clean way. Widgets can live for arbitrarily long, and sync Rust lifetimes cannot express that.</p>
<p>Async Rust solves this problem: in async functions, lifetimes can span across await points, and await points may pause for however long we want. This allows us to express a widgets&#39; lifetimes directly with Rust lifetimes. To do so, we represent components as async functions.</p>

<pre data-lang="rust"><code data-lang="rust"><span>async </span><span>fn </span><span>hello_world</span><span>() {
</span><span>	</span><span>text</span><span>(</span><span>&amp;</span><span>&#34;Hello World!&#34;</span><span>).await;
</span><span>}
</span></code></pre>
<p>Here <code>text</code> is a built-in component provided by the library.
It is an async function. To render it you simply await it.
The <code>hello_world</code> function we just made is also a component. To render it, just <code>hello_world().await</code>.</p>
<h2 id="easily-compose-components">Easily Compose Components</h2>
<p>Modern UI programming is all about <em>composition</em> â€” encapsulating many child components in a single parent component.
This is analogous to <a rel="noopener nofollow" target="_blank" href="https://docs.rs/futures/latest/futures/future/fn.join.html">joining</a> futures: you join many child futures together to get one future that runs all the children in parallel.</p>
<p>In Async UI, composition/joining is done with <em>fragments</em>. A <code>Fragment</code> is a future that contains multiple widgets. When you await the Fragment, all the widgets in it are rendered.</p>
<pre data-lang="rust"><code data-lang="rust"><span>async </span><span>fn </span><span>hello_world_2</span><span>() {
</span><span>	</span><span>// create a Fragment
</span><span>	</span><span>fragment</span><span>((
</span><span>		</span><span>// use the component we previously made!
</span><span>		</span><span>hello_world</span><span>(),
</span><span>		</span><span>// have a button beside it
</span><span>		</span><span>button</span><span>(ButtonProps {
</span><span>			children: </span><span>fragment</span><span>((
</span><span>				</span><span>text</span><span>(</span><span>&amp;</span><span>&#34;Say hello back&#34;</span><span>),
</span><span>			)),
</span><span>			on_press: Some(
</span><span>				</span><span>&amp;</span><span>mut </span><span>|</span><span>_ev: PressEvent</span><span>| </span><span>{
</span><span>					todo!();
</span><span>				}
</span><span>			),
</span><span>			</span><span>..</span><span>Default::default()
</span><span>		})
</span><span>	)).await;
</span><span>}
</span></code></pre>
<p>Here, we are rendering the &#34;Hello World!&#34; and a button next to it. Inside the button we have the text &#34;Say hello back&#34;.</p>
<h2 id="express-complex-ui-flows">Express Complex UI Flows</h2>
<p>Components being async functions makes writing UI flows as easy as writing code flows.</p>
<p>With if/else, loop/break, and <a rel="noopener nofollow" target="_blank" href="https://docs.rs/futures-lite/latest/futures_lite/future/fn.race.html">race</a>, you can describe complicated UI flows very intuitively.</p>
<pre data-lang="rust"><code data-lang="rust"><span>async </span><span>fn </span><span>login_flow</span><span>() {
</span><span>	</span><span>loop </span><span>{
</span><span>		</span><span>let </span><span>(username, password) </span><span>= </span><span>login_form</span><span>().await;
</span><span>		</span><span>if </span><span>check_login</span><span>(username, password).await {
</span><span>			</span><span>// Login successful!
</span><span>			</span><span>break</span><span>;
</span><span>		}
</span><span>		</span><span>else </span><span>{
</span><span>			</span><span>race</span><span>(
</span><span>				</span><span>// Render the popup component.
</span><span>				</span><span>invalid_login_popup</span><span>(),
</span><span>
</span><span>				</span><span>// Race with a future that will complete in 5 seconds.
</span><span>				</span><span>// In 5 seconds, this future will &#34;win&#34; the race and cause
</span><span>				</span><span>// the popup future to be dropped, unmounting the popup.
</span><span>				</span><span>wait_5_seconds</span><span>()
</span><span>			).await;
</span><span>			</span><span>// Loop back to the login form!
</span><span>		}
</span><span>	}
</span><span>}
</span></code></pre>
<p>The full code for this control flow example is available <a rel="noopener nofollow" target="_blank" href="https://github.com/wishawa/async_ui/blob/main/examples/gtk-login-form/src/main.rs">here</a>.</p>
<h2 id="bring-your-own-reactivity">Bring your own Reactivity</h2>
<p>The core of Async UI doesn&#39;t know anything about reactivity.
It&#39;s just async Rust! To communicate between your components, you can use channels (<a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/async-channel">async-channel</a> is a great crate), signals (<a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/futures-signals">futures-signals</a> is a great crate), or whatever works in async Rust.</p>
<p>The built-in components for both Web and GTK support reactivity through a simple interface provided by the <code>observables</code> crate. The crate provides basic reactivity with: <code>ReactiveCell&lt;T&gt;</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span>async </span><span>fn </span><span>counter</span><span>() {
</span><span>	</span><span>let mut</span><span> count </span><span>= </span><span>0</span><span>;
</span><span>
</span><span>	</span><span>// Like a RefCell that you can subscribe to!
</span><span>	</span><span>let</span><span> count_string </span><span>= </span><span>ReactiveCell::new(count.</span><span>to_string</span><span>());
</span><span>
</span><span>	</span><span>fragment</span><span>((
</span><span>		</span><span>// When count_string changes, the text will change.
</span><span>		</span><span>text</span><span>(</span><span>&amp;</span><span>count_string.</span><span>as_observable</span><span>()),
</span><span>
</span><span>		</span><span>button</span><span>(ButtonProps {
</span><span>			children: </span><span>fragment</span><span>((
</span><span>				</span><span>text</span><span>(</span><span>&amp;</span><span>&#34;+&#34;</span><span>),
</span><span>			)),
</span><span>			on_press: Some(</span><span>&amp;</span><span>mut </span><span>|</span><span>_ev</span><span>| </span><span>{
</span><span>				</span><span>// Upon press, increment count and update the string accordingly.
</span><span>				count </span><span>+= </span><span>1</span><span>;
</span><span>				</span><span>*</span><span>count_string.</span><span>borrow_mut</span><span>() </span><span>=</span><span> count.</span><span>to_string</span><span>();
</span><span>			}),
</span><span>			</span><span>..</span><span>Default::default()
</span><span>		})
</span><span>	)).await;
</span><span>}
</span></code></pre>
<p>For advanced reactivity and state management, I&#39;m not sure what model will fit best with Async UI yet. <a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/x-bow">X-Bow</a> is a state management library I&#39;ve been experimenting with, and it seems to be working pretty well (I used it in the Todo App demoed above). <a rel="noopener nofollow" target="_blank" href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html">Streams</a> and <a rel="noopener nofollow" target="_blank" href="https://github.com/rust-lang/wg-async/blob/master/rfc-drafts/stream.md#lending-streams">LendingStreams</a> are also potential solutions.</p>
<h2 id="take-advantage-of-the-async-ecosystem">Take Advantage of the Async Ecosystem</h2>
<p>Async UI is &#34;<strong>just async Rust</strong>&#34;, so it is very easy to use together with other Rust libraries.
Under the hood, Async UI uses <a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/async-executor">async-executor</a> from the smol team. This is <strong>the same executor used by async-std</strong>, so anything that works on async-std should be compatible with Async UI. Our GTK Hacker News demo, for example, uses the <a rel="noopener nofollow" target="_blank" href="https://github.com/http-rs/surf">surf</a> crate to fetch data.</p>
<h2 id="end-notes">End Notes</h2>
<p>Async UI is <strong>still under development</strong>. The core idea is complete, but lots of work remain to be done on the built-in components.</p>
<p>There&#39;s a lot more to explain about the workings of the library. I&#39;ll post more blog posts soon. Stay tuned!</p>
<p><a rel="noopener nofollow" target="_blank" href="https://github.com/wishawa/async_ui">GitHub repo for Async UI</a></p>
<p>Discuss this post on <a rel="noopener nofollow" target="_blank" href="https://users.rust-lang.org/t/blog-post-async-ui-a-rust-ui-library-where-everything-is-a-future/82256">Rust Users</a>, <a rel="noopener nofollow" target="_blank" href="https://www.reddit.com/r/rust/comments/xvv49w/async_ui_a_rust_ui_library_where_everything_is_a/">Reddit</a>, <a rel="noopener nofollow" target="_blank" href="https://news.ycombinator.com/item?id=33089131">Hacker News</a>.</p>

          </div></div>
  </body>
</html>
