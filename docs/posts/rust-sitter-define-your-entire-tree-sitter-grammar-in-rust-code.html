<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hydro-project/rust-sitter">Original</a>
    <h1>Rust-sitter: Define your entire tree-sitter grammar in Rust code</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Rust Sitter makes it easy to create efficient parsers in Rust by leveraging the <a href="https://tree-sitter.github.io/tree-sitter/" rel="nofollow">Tree Sitter</a> parser generator. With Rust Sitter, you can define your entire grammar with annotations on idiomatic Rust code, and let macros generate the parser and type-safe bindings for you!</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p dir="auto">First, add Rust/Tree Sitter to your <code>Cargo.toml</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
rust-sitter = &#34;0.2.1&#34;

[build-dependencies]
rust-sitter-tool = &#34;0.2.1&#34;"><pre>[<span>dependencies</span>]
<span>rust-sitter</span> = <span><span>&#34;</span>0.2.1<span>&#34;</span></span>

[<span>build-dependencies</span>]
<span>rust-sitter-tool</span> = <span><span>&#34;</span>0.2.1<span>&#34;</span></span></pre></div>
<p dir="auto"><em>Note: By default, Rust Sitter uses a fork of Tree Sitter with a pure-Rust runtime to support <code>wasm32-unknown-unknown</code>. To use the standard C runtime instead, disable default features and enable the <code>tree-sitter-standard</code> feature</em></p>
<p dir="auto">The first step is to configure your <code>build.rs</code> to compile and link the generated Tree Sitter parser:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use std::path::PathBuf;

fn main() {
    println!(&#34;cargo:rerun-if-changed=src&#34;);
    rust_sitter_tool::build_parsers(&amp;PathBuf::from(&#34;src/main.rs&#34;));
}"><pre><span>use</span> std<span>::</span>path<span>::</span><span>PathBuf</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>println</span><span>!</span><span>(</span><span>&#34;cargo:rerun-if-changed=src&#34;</span><span>)</span><span>;</span>
    rust_sitter_tool<span>::</span><span>build_parsers</span><span>(</span><span>&amp;</span><span>PathBuf</span><span>::</span><span>from</span><span>(</span><span>&#34;src/main.rs&#34;</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-defining-a-grammar" aria-hidden="true" href="#defining-a-grammar"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Defining a Grammar</h2>
<p dir="auto">Now that we have Rust Sitter added to our project, we can define our grammar. Rust Sitter grammars are defined in annotated Rust modules. First, we define the module that will contain our grammar</p>
<div dir="auto" data-snippet-clipboard-copy-content="#[rust_sitter::grammar(&#34;arithmetic&#34;)]
mod grammar {

}"><pre><span>#<span>[</span>rust_sitter<span>::</span>grammar<span>(</span><span>&#34;arithmetic&#34;</span><span>)</span><span>]</span></span>
<span>mod</span> grammar <span>{</span>

<span>}</span></pre></div>
<p dir="auto">Then, inside the module, we can define individual AST nodes. For this simple example, we&#39;ll define an expression that can be used in a mathematical expression. Note that we annotate this type as <code>#[rust_sitter::language]</code> to indicate that it is the root AST type.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#[rust_sitter::language]
pub enum Expr {
    Number(u32),
    Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;)
}"><pre><span>#<span>[</span>rust_sitter<span>::</span>language<span>]</span></span>
<span>pub</span> <span>enum</span> <span>Expr</span> <span>{</span>
    <span>Number</span><span>(</span><span>u32</span><span>)</span><span>,</span>
    <span>Add</span><span>(</span><span>Box</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>,</span> <span>Box</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>)</span>
<span>}</span></pre></div>
<p dir="auto">Now that we have the type defined, we must annotate the enum variants to describe how to identify them in the text being parsed. First, we can apply <code>rust_sitter::leaf</code> to use a regular expression to match digits corresponding to a number, and define a transformation that parses the resulting string into a <code>u32</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Number(
    #[rust_sitter::leaf(pattern = r&#34;\d+&#34;, transform = |v| v.parse().unwrap())]
    u32,
)"><pre><span>Number</span><span>(</span>
    <span>#<span>[</span>rust_sitter<span>::</span>leaf<span>(</span>pattern = <span>r&#34;\d+&#34;</span>, transform = |v| v.parse<span>(</span><span>)</span>.unwrap<span>(</span><span>)</span><span>)</span><span>]</span></span>
    u32<span>,</span>
<span>)</span><span></span></pre></div>
<p dir="auto">For the <code>Add</code> variant, things are a bit more complicated. First, we add an extra field corresponding to the <code>+</code> that must sit between the two sub-expressions. This can be achieved with <code>text</code> parameter of <code>rust_sitter::leaf</code>, which instructs the parser to match a specific string. Because we are parsing to <code>()</code>, we do not need to provide a transformation.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Add(
    Box&lt;Expr&gt;,
    #[rust_sitter::leaf(text = &#34;+&#34;)] (),
    Box&lt;Expr&gt;,
)"><pre><span>Add</span><span>(</span>
    <span>Box</span>&lt;<span>Expr</span>&gt;<span>,</span>
    <span>#<span>[</span>rust_sitter<span>::</span>leaf<span>(</span>text = <span>&#34;+&#34;</span><span>)</span><span>]</span></span> <span>(</span><span>)</span><span>,</span>
    <span>Box</span>&lt;<span>Expr</span>&gt;<span>,</span>
<span>)</span><span></span></pre></div>
<p dir="auto">If we try to compile this grammar, however, we will see ane error due to conflicting parse trees for expressions like <code>1 + 2 + 3</code>, which could be parsed as <code>(1 + 2) + 3</code> or <code>1 + (2 + 3)</code>. We want the former, so we can add a further annotation specifying that we want left-associativity for this rule.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#[rust_sitter::prec_left(1)]
Add(
    Box&lt;Expr&gt;,
    #[rust_sitter::leaf(text = &#34;+&#34;)] (),
    Box&lt;Expr&gt;,
)"><pre><span>#<span>[</span>rust_sitter<span>::</span>prec_left<span>(</span><span>1</span><span>)</span><span>]</span></span>
<span>Add</span><span>(</span>
    <span>Box</span>&lt;<span>Expr</span>&gt;<span>,</span>
    <span>#<span>[</span>rust_sitter<span>::</span>leaf<span>(</span>text = <span>&#34;+&#34;</span><span>)</span><span>]</span></span> <span>(</span><span>)</span><span>,</span>
    <span>Box</span>&lt;<span>Expr</span>&gt;<span>,</span>
<span>)</span><span></span></pre></div>
<p dir="auto">All together, our grammar looks like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#[rust_sitter::grammar(&#34;arithmetic&#34;)]
mod grammar {
    #[rust_sitter::language]
    pub enum Expr {
        Number(
            #[rust_sitter::leaf(pattern = r&#34;\d+&#34;, transform = |v| v.parse().unwrap())]
            u32,
        ),
        #[rust_sitter::prec_left(1)]
        Add(
            Box&lt;Expr&gt;,
            #[rust_sitter::leaf(text = &#34;+&#34;)] (),
            Box&lt;Expr&gt;,
        )
    }
}"><pre><span>#<span>[</span>rust_sitter<span>::</span>grammar<span>(</span><span>&#34;arithmetic&#34;</span><span>)</span><span>]</span></span>
<span>mod</span> grammar <span>{</span>
    <span>#<span>[</span>rust_sitter<span>::</span>language<span>]</span></span>
    <span>pub</span> <span>enum</span> <span>Expr</span> <span>{</span>
        <span>Number</span><span>(</span>
            <span>#<span>[</span>rust_sitter<span>::</span>leaf<span>(</span>pattern = <span>r&#34;\d+&#34;</span>, transform = |v| v.parse<span>(</span><span>)</span>.unwrap<span>(</span><span>)</span><span>)</span><span>]</span></span>
            <span>u32</span><span>,</span>
        <span>)</span><span>,</span>
        <span>#<span>[</span>rust_sitter<span>::</span>prec_left<span>(</span><span>1</span><span>)</span><span>]</span></span>
        <span>Add</span><span>(</span>
            <span>Box</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>,</span>
            <span>#<span>[</span>rust_sitter<span>::</span>leaf<span>(</span>text = <span>&#34;+&#34;</span><span>)</span><span>]</span></span> <span>(</span><span>)</span><span>,</span>
            <span>Box</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>,</span>
        <span>)</span>
    <span>}</span>
<span>}</span></pre></div>
<p dir="auto">We can then parse text using this grammar:</p>
<div dir="auto" data-snippet-clipboard-copy-content="dbg!(grammar::parse(&#34;1+2+3&#34;));
/*
grammar::parse(&#34;1+2+3&#34;) = Ok(Add(
    Add(
        Number(
            1,
        ),
        (),
        Number(
            2,
        ),
    ),
    (),
    Number(
        3,
    ),
))
*/"><pre><span>dbg</span><span>!</span><span>(</span>grammar::parse<span>(</span><span>&#34;1+2+3&#34;</span><span>)</span><span>)</span><span>;</span>
<span>/*</span>
<span>grammar::parse(&#34;1+2+3&#34;) = Ok(Add(</span>
<span>    Add(</span>
<span>        Number(</span>
<span>            1,</span>
<span>        ),</span>
<span>        (),</span>
<span>        Number(</span>
<span>            2,</span>
<span>        ),</span>
<span>    ),</span>
<span>    (),</span>
<span>    Number(</span>
<span>        3,</span>
<span>    ),</span>
<span>))</span>
<span>*/</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-field-annotations" aria-hidden="true" href="#field-annotations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Field Annotations</h2>
<p dir="auto">Rust Sitter supports a number of annotations that can be applied to fields in your grammar. These annotations can be used to control how the parser behaves, and how the resulting AST is constructed.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-rust_sitterleaf" aria-hidden="true" href="#rust_sitterleaf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>#[rust_sitter::leaf(...)]</code></h3>
<p dir="auto">The <code>#[rust_sitter::leaf(...)]</code> annotation can be used to define a leaf node in the AST. This annotation takes a number of parameters that control how the parser behaves:</p>
<ul dir="auto">
<li>the <code>pattern</code> parameter takes a regular expression that is used to match the text of the leaf node. This parameter is required.</li>
<li>the <code>text</code> parameter takes a string that is used to match the text of the leaf node. This parameter is mutually exclusive with <code>pattern</code>.</li>
<li>the <code>transform</code> parameter takes a function that is used to transform the matched text (an <code>&amp;str</code>) into the desired type. This parameter is optional if the target type is <code>()</code>.</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-rust_sitterprec_left--rust_sitterprec_right" aria-hidden="true" href="#rust_sitterprec_left--rust_sitterprec_right"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>#[rust_sitter::prec_left(...)]</code> / <code>#[rust_sitter::prec_right(...)]</code></h3>
<p dir="auto">This annotation can be used to define a left/right-associative operator. This annotation takes a single parameter, which is the precedence level of the operator (higher binds more tightly).</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-rust_sitterskip" aria-hidden="true" href="#rust_sitterskip"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>#[rust_sitter::skip(...)]</code></h3>
<p dir="auto">This annotation can be used to define a field that does not correspond to anything in the input string, such as some metadata. This annotation takes a single parameter, which is the value that should be used to populate that field at runtime.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-rust_sitterword" aria-hidden="true" href="#rust_sitterword"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>#[rust_sitter::word]</code></h3>
<p dir="auto">This annotation marks the field as a Tree Sitter <a href="https://tree-sitter.github.io/tree-sitter/creating-parsers#keywords" rel="nofollow">word</a>, which is useful when handling errors involving keywords. Only one field in the grammar can be marked as a word.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-special-types" aria-hidden="true" href="#special-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Special Types</h2>
<p dir="auto">Rust Sitter has a few special types that can be used to define more complex grammars.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-vect" aria-hidden="true" href="#vect"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Vec&lt;T&gt;</code></h3>
<p dir="auto">To parse repeating structures, you can use a <code>Vec&lt;T&gt;</code> to parse a list of <code>T</code>s. Note that the <code>Vec&lt;T&gt;</code> type <strong>cannot</strong> be wrapped in another <code>Vec</code> (create additional structs if this is necessary). There are two special attributes that can be applied to a <code>Vec</code> field to control the parsing behavior.</p>
<p dir="auto">The <code>#[rust_sitter::delimited(...)]</code> attribute can be used to specify a separator between elements of the list, and takes a parameter of the same format as an unnamed field. For example, we can define a grammar that parses a comma-separated list of expressions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pub struct CommaSeparatedExprs {
    #[rust_sitter::delimited(
        #[rust_sitter::leaf(text = &#34;,&#34;)]
        ()
    )]
    numbers: Vec&lt;Expr&gt;,
}"><pre><span>pub</span> <span>struct</span> <span>CommaSeparatedExprs</span> <span>{</span>
    <span>#<span>[</span>rust_sitter<span>::</span>delimited<span>(</span></span>
<span>        #<span>[</span>rust_sitter::leaf<span>(</span>text = <span>&#34;,&#34;</span><span>)</span><span>]</span></span>
<span>        <span>(</span><span>)</span></span>
<span>    <span>)</span><span>]</span></span>
    <span>numbers</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>,</span>
<span>}</span></pre></div>
<p dir="auto">The <code>#[rust_sitter::repeat(...)]</code> attribute can be used to specify additional configuration for the parser. Currently, there is only one available parameter: <code>non_empty</code>, which takes a boolean that specifies if the list must contain at least one element. For example, we can define a grammar that parses a non-empty comma-separated list of numbers:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pub struct CommaSeparatedExprs {
    #[rust_sitter::repeat(non_empty = true)]
    #[rust_sitter::delimited(
        #[rust_sitter::leaf(text = &#34;,&#34;)]
        ()
    )]
    numbers: Vec&lt;Expr&gt;,
}"><pre><span>pub</span> <span>struct</span> <span>CommaSeparatedExprs</span> <span>{</span>
    <span>#<span>[</span>rust_sitter<span>::</span>repeat<span>(</span>non_empty = <span>true</span><span>)</span><span>]</span></span>
    <span>#<span>[</span>rust_sitter<span>::</span>delimited<span>(</span></span>
<span>        #<span>[</span>rust_sitter::leaf<span>(</span>text = <span>&#34;,&#34;</span><span>)</span><span>]</span></span>
<span>        <span>(</span><span>)</span></span>
<span>    <span>)</span><span>]</span></span>
    <span>numbers</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>,</span>
<span>}</span></pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-optiont" aria-hidden="true" href="#optiont"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Option&lt;T&gt;</code></h3>
<p dir="auto">To parse optional structures, you can use an <code>Option&lt;T&gt;</code> to parse a single <code>T</code> or nothing. Like <code>Vec</code>, the <code>Option&lt;T&gt;</code> type <strong>cannot</strong> be wrapped in another <code>Option</code> (create additional structs if this is necessary). For example, we can make the list elements in the previous example optional so we can parse strings like <code>1,,2</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pub struct CommaSeparatedExprs {
    #[rust_sitter::repeat(non_empty = true)]
    #[rust_sitter::delimited(
        #[rust_sitter::leaf(text = &#34;,&#34;)]
        ()
    )]
    numbers: Vec&lt;Option&lt;Expr&gt;&gt;,
}"><pre><span>pub</span> <span>struct</span> <span>CommaSeparatedExprs</span> <span>{</span>
    <span>#<span>[</span>rust_sitter<span>::</span>repeat<span>(</span>non_empty = <span>true</span><span>)</span><span>]</span></span>
    <span>#<span>[</span>rust_sitter<span>::</span>delimited<span>(</span></span>
<span>        #<span>[</span>rust_sitter::leaf<span>(</span>text = <span>&#34;,&#34;</span><span>)</span><span>]</span></span>
<span>        <span>(</span><span>)</span></span>
<span>    <span>)</span><span>]</span></span>
    <span>numbers</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>&gt;</span><span>,</span>
<span>}</span></pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-rust_sitterspannedt" aria-hidden="true" href="#rust_sitterspannedt"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>rust_sitter::Spanned&lt;T&gt;</code></h3>
<p dir="auto">When using Rust Sitter to power diagnostic tools, it can be helpful to access spans marking the sections of text corresponding to a parsed node. To do this, you can use the <code>Spanned&lt;T&gt;</code> type, which captures the underlying parsed <code>T</code> and a pair of indices for the start (inclusive) and end (exclusive) of the corresponding substring. <code>Spanned</code> types can be used anywhere, and do not affect the parsing logic. For example, we could capture the spans of the expressions in our previous example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pub struct CommaSeparatedExprs {
    #[rust_sitter::repeat(non_empty = true)]
    #[rust_sitter::delimited(
        #[rust_sitter::leaf(text = &#34;,&#34;)]
        ()
    )]
    numbers: Vec&lt;Option&lt;Spanned&lt;Expr&gt;&gt;&gt;,
}"><pre><span>pub</span> <span>struct</span> <span>CommaSeparatedExprs</span> <span>{</span>
    <span>#<span>[</span>rust_sitter<span>::</span>repeat<span>(</span>non_empty = <span>true</span><span>)</span><span>]</span></span>
    <span>#<span>[</span>rust_sitter<span>::</span>delimited<span>(</span></span>
<span>        #<span>[</span>rust_sitter::leaf<span>(</span>text = <span>&#34;,&#34;</span><span>)</span><span>]</span></span>
<span>        <span>(</span><span>)</span></span>
<span>    <span>)</span><span>]</span></span>
    <span>numbers</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>Spanned</span><span>&lt;</span><span>Expr</span><span>&gt;</span><span>&gt;</span><span>&gt;</span><span>,</span>
<span>}</span></pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-boxt" aria-hidden="true" href="#boxt"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Box&lt;T&gt;</code></h3>
<p dir="auto">Boxes are automatically constructed around the inner type when parsing, but Rust Sitter doesn&#39;t do anything extra beyond that.</p>
</article>
          </div></div>
  </body>
</html>
