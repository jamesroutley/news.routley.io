<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/11/15/push-ifs-up-and-fors-down.html">Original</a>
    <h1>Push Ifs Up and Fors Down</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <p>A short note on two related rules of thumb.</p>
        <section id="Push-Ifs-Up">
          <h2>
            <a href="#Push-Ifs-Up">Push Ifs Up </a>
          </h2>
          <p>
            If there’s an <code>if</code> condition inside a function, consider
            if it could be moved to the caller instead:
          </p>

          <figure>
            <pre><code><span></span>
<span><span>fn</span> <span>frobnicate</span>(walrus: Walrus) {</span>
<span>    ...</span>
<span>}</span>
<span></span>
<span></span>
<span><span>fn</span> <span>frobnicate</span>(walrus: <span>Option</span>&lt;Walrus&gt;) {</span>
<span>  <span>let</span> <span>walrus</span> = <span>match</span> walrus {</span>
<span>    <span>Some</span>(it) =&gt; it,</span>
<span>    <span>None</span> =&gt; <span>return</span>,</span>
<span>  };</span>
<span>  ...</span>
<span>}</span></code></pre>
          </figure>
          <p>
            As in the example above, this often comes up with preconditions: a
            function might check precondition inside and “do nothing” if it
            doesn’t hold, or it could push the task of precondition checking to
            its caller, and enforce via types (or an assert) that the
            precondition holds. With preconditions especially, “pushing up” can
            become viral, and result in fewer checks overall, which is one
            motivation for this rule of thumb.
          </p>
          <p>
            Another motivation is that control flow and <code>if</code>s are
            complicated, and are a source of bugs. By pushing <code>if</code>s
            up, you often end up centralizing control flow in a single function,
            which has a complex branching logic, but all the actual work is
            delegated to straight line subroutines.
          </p>
          <p>
            <em>If</em> you have complex control flow, better to fit it on a
            screen in a single function, rather than spread throughout the file.
            What’s more, with all the flow in one place it often is possible to
            notice redundancies and dead conditions. Compare:
          </p>

          <figure>
            <pre><code><span><span>fn</span> <span>f</span>() {</span>
<span>  <span>if</span> foo &amp;&amp; bar {</span>
<span>    <span>if</span> foo {</span>
<span></span>
<span>    } <span>else</span> {</span>
<span></span>
<span>    }</span>
<span>  }</span>
<span>}</span>
<span></span>
<span><span>fn</span> <span>g</span>() {</span>
<span>  <span>if</span> foo &amp;&amp; bar {</span>
<span>    <span>h</span>()</span>
<span>  }</span>
<span>}</span>
<span></span>
<span><span>fn</span> <span>h</span>() {</span>
<span>  <span>if</span> foo {</span>
<span></span>
<span>  } <span>else</span> {</span>
<span></span>
<span>  }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            For <code>f</code>, it’s much easier to notice a dead branch than
            for a combination of <code>g</code> and <code>h</code>!
          </p>
          <p>
            A related pattern here is what I call “dissolving enum” refactor.
            Sometimes, the code ends up looking like this:
          </p>

          <figure>
            <pre><code><span><span>enum</span> <span>E</span> {</span>
<span>  <span>Foo</span>(<span>i32</span>),</span>
<span>  <span>Bar</span>(<span>String</span>),</span>
<span>}</span>
<span></span>
<span><span>fn</span> <span>main</span>() {</span>
<span>  <span>let</span> <span>e</span> = <span>f</span>();</span>
<span>  <span>g</span>(e)</span>
<span>}</span>
<span></span>
<span><span>fn</span> <span>f</span>() <span>-&gt;</span> E {</span>
<span>  <span>if</span> condition {</span>
<span>    E::<span>Foo</span>(x)</span>
<span>  } <span>else</span> {</span>
<span>    E::<span>Bar</span>(y)</span>
<span>  }</span>
<span>}</span>
<span></span>
<span><span>fn</span> <span>g</span>(e: E) {</span>
<span>  <span>match</span> e {</span>
<span>    E::<span>Foo</span>(x) =&gt; <span>foo</span>(x),</span>
<span>    E::<span>Bar</span>(y) =&gt; <span>bar</span>(y)</span>
<span>  }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            There are two branching instructions here and, by pulling them up,
            it becomes apparent that it is the exact same condition, triplicated
            (the third time reified as a data structure):
          </p>

          <figure>
            <pre><code><span><span>fn</span> <span>main</span>() {</span>
<span>  <span>if</span> condition {</span>
<span>    <span>foo</span>(x)</span>
<span>  } <span>else</span> {</span>
<span>    <span>bar</span>(y)</span>
<span>  }</span>
<span>}</span></code></pre>
          </figure>
        </section>
        <section id="Push-Fors-Down">
          <h2>
            <a href="#Push-Fors-Down">Push Fors Down </a>
          </h2>
          <p>
            This comes from data oriented school of thought. Few things are few,
            many things are many. Programs usually operate with bunches of
            objects. Or at least the hot path usually involves handling many
            entities. It is the volume of entities that makes the path hot in
            the first place. So it often is prudent to introduce a concept of a
            “batch” of objects, and make operations on batches the base case,
            with a scalar version being a special case of a batched ones:
          </p>

          <figure>
            <pre><code><span></span>
<span><span>frobnicate_batch</span>(walruses)</span>
<span></span>
<span></span>
<span><span>for</span> <span>walrus</span> <span>in</span> walruses {</span>
<span>  <span>frobnicate</span>(walrus)</span>
<span>}</span></code></pre>
          </figure>
          <p>
            The primary benefit here is performance. Plenty of performance, <a href="http://venge.net/graydon/talks/VectorizedInterpretersTalk-2023-05-12.pdf">in extreme cases</a>.
          </p>
          <p>
            If you have a whole batch of things to work with, you can amortize
            startup cost and be flexible about the order you process things. In
            fact, you don’t even need to process entities in any particular
            order, you can do vectorized/struct-of-array tricks to process one
            field of all entities first, before continuing with other fields.
          </p>
          <p>
            Perhaps the most fun example here is <a href="https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">FFT-based polynomial multiplication</a>: turns out, evaluating a
            polynomial at a bunch of points simultaneously could be done faster
            than a bunch of individual point evaluations!
          </p>
          <p>
            The two pieces of advice about <code>for</code>s and <code>if</code>s even compose!
          </p>

          <figure>
            <pre><code><span></span>
<span><span>if</span> condition {</span>
<span>  <span>for</span> <span>walrus</span> <span>in</span> walruses {</span>
<span>    walrus.<span>frobnicate</span>()</span>
<span>  }</span>
<span>} <span>else</span> {</span>
<span>  <span>for</span> <span>walrus</span> <span>in</span> walruses {</span>
<span>    walrus.<span>transmogrify</span>()</span>
<span>  }</span>
<span>}</span>
<span></span>
<span></span>
<span><span>for</span> <span>walrus</span> <span>in</span> walruses {</span>
<span>  <span>if</span> condition {</span>
<span>    walrus.<span>frobnicate</span>()</span>
<span>  } <span>else</span> {</span>
<span>    walrus.<span>transmogrify</span>()</span>
<span>  }</span>
<span>}</span></code></pre>
          </figure>
          <p>
            The <code>GOOD</code> version is good, because it avoids repeatedly
            re-evaluating <code>condition</code>, removes a branch from the hot
            loop, and potentially unlocks vectorization. This pattern works on a
            micro level and on a macro level — the good version is the
            architecture of TigerBeetle, where in the data plane we operate on
            batches of objects at the same time, to amortize the cost of
            decision making in the control plane.
          </p>
          <p>
            While performance is perhaps the primary motivation for the <code>for</code> advice, sometimes it helps with expressiveness as well.
            <code>jQuery</code> was quite successful back in the day, and it
            operates on collections of elements. The language of abstract vector
            spaces is often a better tool for thought than bunches of
            coordinate-wise equations.
          </p>
          <p>
            To sum up, push the <code>if</code>s up and the <code>for</code>s
            down!
          </p>
        </section>
      </article>
    </div></div>
  </body>
</html>
