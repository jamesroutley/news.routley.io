<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.masteringemacs.org/article/lets-write-a-treesitter-major-mode">Original</a>
    <h1>Let&#39;s write a treesitter major mode for Emacs</h1>
    
    <div id="readability-page-1" class="page"><article>
    
    
    
      
    
    
      
    
    
      
        <section>
          Creating a standard programming major mode presents significant challenges, with the intricate tasks of establishing proper indentation and font highlighting being among the two hardest things to get right. It&#39;s painstaking work, and it&#39;ll quickly descend into a brawl between the font lock engine and your desire for correctness.
</section>
      
      
        <figure>
          <img src="https://www.masteringemacs.org/static/uploads/article-images/technicolor-tree.jpg"/>
        </figure>
      
      
        
      
      
        <p>Updated for <strong>emacs 29</strong></p>
      
      <img src="https://www.masteringemacs.org/static/img/fleuron2.gif"/>
      
<p>Ah, major modes. There are hundreds of them, and most work in the background, rarely surfacing to tell you what they do or why. They power Emacs, and they grant purpose and verisimilitude <a href="https://www.masteringemacs.org/article/why-emacs-has-buffers">to buffers, one of the most important concepts in Emacs</a>. Without major modes – or indeed the buffers that depend on them – you’d be stuck with a rather dumb and basic editor.</p><p>Major modes – particularly programming major modes – are often complex because they have to deal with the raw complexity of interfacing with the syntax of a language: font locking, so the text is highlighted; indentation, so you can format your code; navigation, to help you go where you need to; and editing, so you can avail yourself of Emacs’s complex editing facilities. Major modes are often layered: one major mode deriving some of its complexity from another major mode; others, still, depend on a litany of complex interactions with other parts of Emacs to function. To unravel one complex major mode, you’ll spend weeks pulling at strings woven into the cloth that Emacs is cut from.</p><p>It’s a clever system that holds up well for many of its users: the presentable, user-visible edifice is there for all to behold and is generally manageable, once you know your way around Emacs. Peer beneath the surface – perhaps you want to tweak the font locking or indentation – and you might encounter a fiendishly intricate tangle of regular expressions and elisp code that binds the indentation and font lock system together — if you’re lucky you’ll find a neat braid, and if you’re not… a Gordian knot.</p><p>That’s hardly the fault of Emacs: it’s just… really complex to get right. The indentation engine for C-like languages (<code>cc-engine.el</code>) is half a meg of dense elisp code: its module description is “core syntax guessing engine for CC mode”, which is a delightfully gnomic summary. It contains 40 years of continued, incremental development and hard-won lessons. It’s a testament to the complexity of some programming languages – <em>cough</em> C and C++ – that it’s even required, and still receiving updates.</p><p>Tree-sitter is a standard bearer for a new way of doing things, and the topic of this post. I’ve been writing a lot about tree-sitter, and <a href="https://www.masteringemacs.org/article/tree-sitter-complications-of-parsing-languages">the complications of parsing languages</a>. One of tree-sitter’s benefits is that it eschews the need for error-prone regexp by scanning your code and yielding a detailed <em>concrete syntax tree</em>, much like a real compiler would do.</p><blockquote><p>Side note: as ambrosial as tree-sitter may be, even it can’t half nelson C into complete submission; achieving tree-like perfection will have to wait if you write tangled preprocessor statements, or regularly write code to the standards required by <a href="https://www.ioccc.org/">the IOCCC</a>.</p></blockquote><p>But for all other languages, it’s generally very good — and much, <em>much</em> simpler to work with. As I’ll demonstrate by writing a major mode for HTML with indentation, syntax highlighting, and Imenu support. Curiously, Emacs 29 doesn’t ship with tree-sitter-enabled HTML support, so this should serve as a fine template for all the other languages that build on top of HTML.</p><figure>
<img src="https://www.masteringemacs.org/static/uploads/html-ts-mode.svg" alt=""/>
<figcaption>HTML major mode powered by tree-sitter</figcaption>
</figure><p>I’m hoping this will demonstrate just how approachable it is to write or amend a TS-enabled major mode. If your favorite language has a TS grammar but lacks an Emacs major mode, you could probably write something that’ll get 80% of the job done in a day or two, even if you’re reasonably new to elisp.</p><p>Anyway. Let’s get cracking.</p><h2 id="prerequisites">Prerequisites</h2><p>You’ll need Emacs 29 compiled with tree-sitter, and you’ll need to know how to install TS grammars. My article <a href="https://www.masteringemacs.org/article/how-to-get-started-tree-sitter">on getting started with tree-sitter</a> will show you how to do all of this. Start with that.</p><p>Next, you’ll need to install the HTML language grammar. You can find it on <a href="https://github.com/tree-sitter/tree-sitter-html">on Github</a>. Note that, for reasons that strain credulity, TS grammars are unversioned. There is no way, aside from a commit hash, to tell which version is which. So “use the latest source, Luke” is, unfortunately, the guiding principle here.</p><p>Let’s talk about nice-to-haves. You don’t <em>have</em> to do this, but you might find it useful, particularly if you’re following along with another grammar and you are merely using this for reference.</p><p>Combobulate, my structured and editing package, has code completion, syntax highlighting, and more for tree-sitter’s query language. Query building is essential: you’ll need it for indentation and font locking. Here’s an article where I talk about the feature in more detail: <a href="https://www.masteringemacs.org/article/combobulate-editing-searching-new-query-builder">Combobulate: Editing and Searching with the new Query Builder</a>.</p><p>Some knowledge of Emacs’s tree-sitter implementation is helpful, if not required, if you want to really delve into it: <code>(info &#34;(elisp) Parsing Program Source&#34;)</code>. The <a href="https://tree-sitter.github.io/tree-sitter/">official manual</a> is worth reading also. Make sure you read the chapter on query syntax as I will only cover what we need for HTML, which is a simple language with few moving parts.</p><p>You’ll want to use <code>M-x treesit-explore-mode</code> to visualize the tree hierarchy in a buffer. You can only do this once you’ve created the parser, which is one of the first things we configure in the new major mode.</p><p>You can find the complete <a href="https://github.com/mickeynp/html-ts-mode">source on my Github</a>.</p><h2 id="how-tree-sitter-interacts-with-buffers">How Tree-Sitter Interacts with Buffers</h2><p>It’s important to recognize that a tree-sitter-powered “major mode” need not be a major mode. The new major modes in Emacs 29 configure a bunch of stuff like font locking and so on, but you don’t <em>have</em> to rewrite everything. You can create a tree-sitter parser against any buffer, and keep it at arms length from your existing major modes. Combobulate, for instance, would work reasonably well in non-TS-powered modes (though it does not officially support this presently.)</p><p>So, you can have your cake and eat it. It also means you don’t <em>necessarily</em> have to use TS for everything: you can often pick and choose. But keep in mind that some major modes use indentation to help with font locking, or font locking to help with indentation. Replace one, and the other may not work!</p><p>If you just want to experiment with structured movement and editing, then know that you don’t <em>have</em> to create a new major mode. You can build stuff on top of an existing major mode that you like.</p><h2 id="defining-the-major-mode">Defining the Major Mode</h2><p>One of the main things to remember is that we should leverage what’s already there. There’s already an HTML mode in Emacs, naturally. To find it, use <code>M-x find-function</code> to go to where <code>html-mode</code> is. We can see from its form that it inherits from <code>sgml-mode</code>: <code>(define-derived-mode html-mode sgml-mode ...)</code>. <code>sgml-mode</code>, in turn, derives from <code>text-mode</code>.</p><p>Now, we <em>could</em> inherit from <code>html-mode</code> and try to leverage what that major mode does already, but given that we want to effectively undo all the work that mode does, I think it makes more sense to just use <code>sgml-mode</code>. SGML does do some things that seem a bit off when you first look at its <code>define-derived-mode</code> declaration.</p><h3 id="a-quick-overview-of-sgml-mode">A quick overview of SGML-mode</h3><p><em>You’ll have to crack open <code>sgml-mode.el</code> to follow along, as it’s too much stuff to include here.</em></p><ol type="1"><li><p>It’s got a bunch of stuff referencing <code>tildify</code>. What’s that? Well, given the insignificance of whitespace in SGML-alike languages, you need a way of representing “hard” spaces: <code>&amp;nbsp;</code> is one such method. So, there’s a bunch of complex code to do all of that in <code>tildify</code>. It doesn’t really interfere with what we want to do, and besides: we’re not interested in converting <code>tildify</code> to tree-sitter either.</p><p>Also, even if you’re a heavy user of Emacs and HTML, I’m 99% sure that you’ve never heard of tildify!</p></li><li>Aside from that, it does a bunch of work around paragraphs – it’s common for major modes to adjust the paragraph syntax, as it’s meant for prose and not code, to something akin to “paragraphs in code” – and that is what it’s doing here too.</li><li>Adaptive fill is another useful and expansive feature. It’s bound to <code>M-q</code> (<code>fill-paragraph</code>) and many other commands. And all the code here is doing is to try and guide the fill code so it plays well with SGML-like syntax. Whether it works well or not is in the eye of the beholder.</li><li>There’s code to set the comment start, end, and how line breaks are determined. Again, this is something you could reimplement in TS if you wanted, but you’d be leaping ahead of Emacs 29 as there is little official support for TS-powered commenting.</li><li><p>Skeleton is a code templating tool that is often used for more than just that: before <code>M-x electric-pair</code> became a thing, it was often a stand-in for a wide range of things, such as closing braces or sneakily inserting spaces and newlines in the right places.</p><p>It’s very similar to its cousin, Tempo, in that they work in much the same way, and both have been neglected for the better part of twenty years.</p></li><li>There’s some font lock stuff – we’ll ditch that for sure.</li><li><code>syntax-propertize-function</code> is part of Emacs’s core machinery – a lot of it written in C – to help Emacs determine boundaries of things like braces and other syntactically important pairs, like quotes for strings. It does more than that; but it’s commonly used for that.</li><li>Imenu takes a regexp (or in TS, a function or regexp) to help you jump to semantically useful HTML element. We’ll be replacing that also.</li><li>Indentation is controlled in part by <code>indent-line-function</code>. We’ll definitely replace that.</li><li><p>The syntax table is also worth mentioning. It’s a table mapping characters to a purpose. Like defining <code>;</code> is a comment in C; or that <code>&#34;</code> denotes the beginning and end of a string. It’s also responsible for what Emacs consider a word, a symbol, and so on. There’s an existing one called <code>sgml-mode-syntax-table</code>.</p><p>We <em>could</em> write our own, or we can trust that 30 years of incremental improvements to SGML-mode and friends has resulted in a syntax table that, out of the box at least, probably does what we want.</p></li></ol><p>So… yeah, there is not a lot to the initialization of the major mode. And as you can see, I’m picking and choosing what I want to replace: if the indentation engine works well, you can probably get away with reusing it, if you’re fortunate enough to have an existing one to work from.</p><h3 id="bare-bones-html-major-mode">Bare bones HTML major mode</h3><p>With that in mind, we can write our skeleton major mode.</p><pre><code>(<span>require</span> &#39;sgml-mode)

<span>;;;###autoload</span>
(define-derived-mode html-ts-mode sgml-mode <span>&#34;HTML[ts]&#34;</span>
  <span>&#34;Major mode for editing HTML with tree-sitter.&#34;</span>
  :syntax-table sgml-mode-syntax-table

  (setq-local font-lock-defaults <span>nil</span>)
  (<span>when</span> (treesit-ready-p &#39;html)
    (treesit-parser-create &#39;html)
    (html-ts-setup)))</code></pre><p>The awkwardly named <code>treesit-ready-p</code> returns non-nil if it is “ready” to deal with the symbol you give it. The symbol being the name of the grammar, which in turn depends on the name of the compiled grammar library you’ve installed.</p><p>As far as I know, this is the best (and only) way to check for the presence of a valid grammar. There are no user-facing commands to do this. Either way, if you <a href="https://www.masteringemacs.org/article/evaluating-elisp-emacs">eval the elisp</a> as it’s shown, you should get back <code>t</code>.</p><p>The next step is creating the parser. To do that, you execute <code>treesit-parser-create</code>. Note that it does indeed return the parser object you asked for, but it <em>also</em> installs it into the current buffer — so the function name is a bit misleading.</p><p>Effectively, despite creating a parser, we want the side-effect of it installing itself into the buffer. To list parsers belonging to a buffer, consult <code>treesit-parser-list</code>.</p><p>I recommend you keep the logic of configuring tree-sitter in its own function like I’ve done with <code>html-ts-setup</code>. It just makes debugging and resetting the state easier, so it’s not a hard requirement.</p><pre><code>(<span>defun</span><span> html-ts-setup </span>()
  <span>&#34;Setup treesit for html-ts-mode.&#34;</span>
  <span>;; Our tree-sitter setup goes here.</span>

  <span>;; This handles font locking -- more on that below.</span>
  (setq-local treesit-font-lock-settings
               (<span>apply</span> #&#39;treesit-font-lock-rules
                    html-ts-font-lock-rules)))

  <span>;; This handles indentation -- again, more on that below.</span>
  (setq-local treesit-simple-indent-rules html-ts-indent-rules)

  <span>;; ... everything else we talk about go here also ...</span>

  <span>;; End with this</span>
  (treesit-major-mode-setup))</code></pre><p>The <em>one thing</em> you must remember to do after you’ve configured tree-sitter, is to call <code>treesit-major-mode-setup</code>. Do it after you’ve set up your indentation and font lock rules. It’s an essential step, and if you miss it, or apply it inconsistently during development, your font lock and indentation rules won’t apply properly.</p><p>Now, let’s write some font lock rules.</p><h2 id="font-locking">Font Locking</h2><p>One common criticism of trad-style font locking is the lack of granularity. You had a few levels ranging from zero, to mostly zero, to angry fruit salad, as people who disliked full font locking would often call it. And the lack of contextual granularity didn’t help either: <code>M-x customize-apropos-face</code> and type <code>font lock face</code> and you’ll see a lot more than you did in earlier Emacsen. That’s a good thing: now we have the option to highlight function calls and function names differently, for example.</p><p>To better understand how that’s applied, you need to look at <code>treesit-font-lock-feature-list</code>. It’s a list of lists: the sub-lists contain symbols that are unique to each TS major mode. The symbols map to what they’re going to highlight (like <code>comment</code> for comments, and <code>tag</code> for the HTML tag names), and the lists they’re in correspond to the level of font lock engagement. Set <code>treesit-font-lock-level</code> to a number corresponding to how many of the tiers in the list you want Emacs to render. It’s a nice marriage of old and new: you can reshuffle the list to match what you want, if you’re so inclined, or you can set <code>treesit-font-lock-level</code> to a number, if you prefer a simpler approach to managing this.</p><p>I’ve opted for this simple feature list. By all means add or remove things to suit your needs.</p><pre><code>(setq-local treesit-font-lock-feature-list
              &#39;((comment)
                (constant tag attribute)
                (<span>declaration</span>)
                (delimiter)))</code></pre><p>Next up, you need to write the font lock rules. The variable <code>treesit-font-lock-settings</code> is the ultimate variable that controls how font locking works. You probably don’t need to touch it directly. Instead, you’re encouraged to use the function <code>treesit-font-lock-rules</code> to build your rules.</p><p>The <code>treesit-font-lock-rules</code> function again is a bit peculiar. It takes a variadic number of arguments which must follow a prescribed pattern, like so:</p><pre><code>(treesit-font-lock-rules
 :language &#39;html
 :override <span>t</span>
 :feature &#39;delimiter
 &#39;([ <span>&#34;&lt;&#34;</span> <span>&#34;&gt;&#34;</span> <span>&#34;/&gt;&#34;</span> <span>&#34;&lt;/&#34;</span>] @font-lock-bracket-face)

 :language &#39;html
 :override <span>t</span>
 :feature &#39;comment
 &#39;((comment) @font-lock-comment-face)

 ... )</code></pre><p>As you can see, you must specify the <code>:language</code> the rule belongs to. That means you can interleave multiple languages – but more on that in a bit. The <code>:override</code> property is there so you can optionally override a previously-applied font lock rule. Useful as you’ll undoubtedly end up with overlapping rules if your language is complex.</p><p>The <code>:feature</code> is the name of the feature. You can pick anything you like, but you’ll need to ensure it is somewhere in <code>treesit-font-lock-feature-list</code> also.</p><p>And finally, you write the query you want to highlight.</p><p>Top tip. <em>Don’t</em> make the mistake a lot of the TS major mode authors did by cramming all their rules into a function call to <code>treesit-font-lock-rules</code>. That’s what the function asks you to do, but I think it’s a huge faux pas, and a peculiar design choice.</p><p>If you hardcode the rules as arguments to that function, you (or more likely, a user of your mode) can’t amend the rules post-facto. You can if you put them in a variable first, and then <code>apply</code> them: that way you don’t have to quote everything left, right and center like I did above.</p><p>Do this instead:</p><pre><code>(<span>defvar</span><span> html-ts-font-lock-rules</span>
    &#39;(:language html
      :override <span>t</span>
      :feature delimiter
      ([<span>&#34;&lt;&#34;</span> <span>&#34;&gt;&#34;</span> <span>&#34;/&gt;&#34;</span> <span>&#34;&lt;/&#34;</span>] @font-lock-bracket-face)

      :language html
      :override <span>t</span>
      :feature comment
      ((comment) @font-lock-comment-face))</code></pre><p>If you need to make it dynamic, you still can, using functions or other methods for building the list dynamically from composable variables. (This is more important than you think if you have a grammar that largely intersects with other ones.)</p><p>And to apply the rules:</p><pre><code>(setq-local treesit-font-lock-settings
            (<span>apply</span> #&#39;treesit-font-lock-rules
                 html-ts-font-lock-rules)))</code></pre><p>Much nicer, and someone else can use your rules in their major mode.</p><p>Regardless of the method used, you can safely append to <code>treesit-font-lock-settings</code> at any point, if you so desire. You can add your own rules (using <code>:override t</code> if you have to) to add custom highlighters to an existing major mode, even.</p><p>Curiously, there’s no customizable variable for this sort of thing, and so this is the only way. Still, you can do it, and Combobulate’s query builder can do it for you also, if you use it for highlighting.</p><h3 id="resetting-the-font-lock-engine">Resetting the Font Lock Engine</h3><p>One common problem is cycling the font lock changes. You can try <code>C-x x f</code> to call <code>font-lock-update</code>. That might do it, depending on your workflow. <code>defvar</code> forms don’t re-set when you <code>M-x eval-buffer</code>, so be sure to eval them manually (<code>C-M-x</code> or <code>C-x C-e</code>) if you do it this way.</p><p>A courtesy call to <code>treesit-major-mode-setup</code> won’t go amiss if you think things aren’t working out for you. Query errors may not surface depending on how you reset things. So try different things; go back to a known state (comment stuff out), and retry.</p><p>Another way that I like is to cycle the major modes: switch to <code>M-x fundamental-mode</code> and back again.</p><p>And what if you to do all of it in one go? <a href="https://www.masteringemacs.org/article/keyboard-macros-are-misunderstood">Record a quick keyboard macro</a>.</p><h3 id="writing-queries">Writing Queries</h3><p>The cardinal rule is the capturing group – which is what tree-sitter matches against, which needn’t be the whole query, much like regexp capturing groups – must be named after the font lock face you want to use. So use something like <code>@font-lock-comment-face</code> for comments.</p><figure>
<img src="https://www.masteringemacs.org/static/uploads/combobulate-query-builder-example.svg" alt=""/>
<figcaption>Combobulate&#39;s query builder in action. Here I am highlighting just the start tags in gold. You can use the query builder to help you design the queries you want to font lock.</figcaption>
</figure><p>Here’s an example from Combobulate. I’m using Combobulate’s builtin highlighter shortcuts, but you can use <code>@some-font-lock-face</code> instead.</p><p>If you don’t want to use Combobulate to help you, the builtin method – the only method – is to call <code>treesit-query-capture</code> with a starting node (often the one from <code>treesit-buffer-root-node</code> or <code>treesit-parser-root-node</code>) and the query and then manually inspect the output to see if it’s right. Ugh. It’s messy, and it’s hard work. Trust me, I know. I recommend you <a href="https://www.masteringemacs.org/article/evaluating-elisp-emacs">learn how to use IELM</a> if you decide to go this route.</p><p>Also keep in mind that you can give the query machinery (including the font lock rules function) two different styles of queries: strings, which exactly match the syntax that tree-sitter’s official query manual (and engine) expects; <em>or</em>, an s-expression form with a few crucial differences. (Combobulate’s query builder works with strings.)</p><p>The differences are rather important to know about:</p><ul><li><code>.</code> in the string form (indicating anchoring) becomes <code>:anchor</code> in the s-expression format.</li><li>Predicates, like <code>#match</code> and <code>#eq</code>, become <code>:match</code> and <code>:eq</code>.</li><li>Quantifiers, such as <code>+</code> and <code>*</code>, turn into <code>:+</code> and <code>:*</code>.</li></ul><p>That’s it.</p><p>When you write a query, make sure you use at least one capturing group or you’ll get zero matches. It’s a design feature: no capture group, no matches. Confusing, but that’s how it is.</p><p>So, building on the example query from the screenshot above, the complete version would look a bit like this:</p><pre><code>(<span>defvar</span><span> html-ts-font-lock-rules</span>
   &#39;(:language html
     :override <span>t</span>
     :feature tag
     ((element
       [(start_tag (tag_name) @font-lock-variable-name-face)
        (self_closing_tag (tag_name) @font-lock-variable-name-face)
        (end_tag (tag_name) @font-lock-variable-name-face)]))))</code></pre><p>Not much to it.</p><p>Here’s the complete list:</p><pre><code>(<span>defvar</span><span> html-ts-font-lock-rules</span>
  &#39;(:language html
    :feature delimiter
    ([ <span>&#34;&lt;!&#34;</span> <span>&#34;&lt;&#34;</span> <span>&#34;&gt;&#34;</span> <span>&#34;/&gt;&#34;</span> <span>&#34;&lt;/&#34;</span>] @font-lock-bracket-face)

    :language html
    :feature comment
    ((comment) @font-lock-comment-face)

    :language html
    :feature attribute
    ((attribute (attribute_name)
                @font-lock-constant-face
                <span>&#34;=&#34;</span> @font-lock-bracket-face
                (quoted_attribute_value) @font-lock-string-face))

    :language html
    :feature tag
    ((script_element
      [(start_tag (tag_name) @font-lock-doc-face)
       (end_tag (tag_name) @font-lock-doc-face)]))

    :language html
    :feature tag
    ([(start_tag (tag_name) @font-lock-function-call-face)
      (self_closing_tag (tag_name) @font-lock-function-call-face)
      (end_tag (tag_name)  @font-lock-function-call-face)])
    :language html
    :override <span>t</span>
    :feature <span>declaration</span>
    ((doctype) @font-lock-keyword-face)))</code></pre><p>Done right, when you activate <code>M-x html-ts-mode</code> you’ll see everything light up. If not, try fidgeting with <code>treesit-font-lock-level</code> — but beware! It has an edge-trigger to reset font locking in all tree-sitter buffers so changes take effect. You’ll have to set it with <code>setopt</code> or <code>customize-set-variable</code> for the changes to take effect. (Or reset it manually like I showed you above.)</p><p>But, yeah, well. That’s it. Churn out some queries and stick ’em in a variable. That’s the long and the short of it. I’ve only covered the basics, but you can use <code>#match</code> and friends to match nodes by regexp — convenient, if you want to highlight comments beginning with TODO, or what have you. The sky is the limit here.</p><p>Now, let’s do indentation.</p><h2 id="indentation">Indentation</h2><p>If you’ve never written an indentation engine ‘the old-fashioned way,’ then, well, <em>lucky you</em>. Indentation engines are approximately one-third art, one-third science, and one-third misery.</p><p>Rewriting an existing indentation engine with tree-sitter will likely shed a chunk of weight and complexity. The declarative indentation engine – based on SMIE, the Simple-Minded Indentation Engine, that’s been in Emacs for years – does cut down on the tedium also.</p><p>The key take-away here is to write <em>one</em> rule at a time. Pick one corner of the buffer and start from there and work your way through, adding one rule as you go. That’s my recommendation, anyway. Enabling <code>treesit--indent-verbose</code> is also helpful here: when you indent, Emacs will tell you the rule that fired.</p><p>Much like font locking, one variable controls indentation: <code>treesit-simple-indent-rules</code>. You feed it declarative rules that look a bit like this:</p><pre><code><span>;; Alist of (LANGUAGE . RULES)</span>
`((html
     <span>;; Rule 1</span>
     ((parent-is <span>&#34;element&#34;</span>) parent <span>2</span>)
     <span>;; Rule 2</span>
     ((node-is ,(regexp-opt &#39;(<span>&#34;element&#34;</span> <span>&#34;self_closing_tag&#34;</span>))) parent <span>2</span>)
     ...
     ))</code></pre><p>Such that each RULES entry is of the form <code>(MATCHER ANCHOR OFFSET)</code>. Where <code>(node-is &#34;element&#34;)</code> is the MATCHER, in this case a special form defined in <code>treesit-simple-indent-presets</code>. There are many other useful forms, each matching a different node in the tree. Make sure you look, even if you can probably get by with just one or two matchers.</p><p>The second value is the ANCHOR, <code>parent</code>, indicating that the indentation engine must find the parent of the node point is near or on: here it’s <code>element</code> for the first rule. The OFFSET is how much to indent, and you can use a variable instead of a scalar.</p><p>With little more than simple declarative rules like this one, you can build an effective indentation engine with a bit of grit and perseverance. You probably don’t need more than 10-15 rules for most languages. As always, you can look at how other major modes in Emacs are doing it for inspiration.</p><p>You need to read the docstring for <code>treesit-simple-indent-presets</code> and <code>treesit-simple-indent-rules</code>. The manual entries are must-reads also: just punch <code>i</code> from the <code>*Help*</code> window to jump to the pertinent manual node.</p><p>One way to write rules is with a simple 1-2-3 exercise:</p><ol type="1"><li>Add or amend a rule to <code>treesit-simple-indent-rules</code>. <code>*scratch*</code> or IELM are good ways to do this.</li><li>Reload your major mode, as per above. Now hit <code>TAB</code> at where you want to test your new rule and observe (with <code>treesit--indent-verbose</code> set to <code>t</code>) that it’s firing the right rule <em>and</em> that you’re happy with the indentation.</li><li>Hit <code>RET</code> at the end of the newly-indented line and check if the indentation of the new line is also correct.</li></ol><p>You can also try <code>M-x indent-region</code> (bound to <code>C-M-\\</code>) and indent the whole region and observe that everything is properly indented. Combine with <code>C-M-% ^\s-+ RET RET</code> to clear out lines beginning with whitespace to test this.</p><p>I can’t promise this will work flawlessly. It <em>might</em> work, but it comes down to your major mode and your requirements: it would not work in Python or YAML, for example, as whitespace is contextual in those languages.</p><p>There is no amount of writing endlessly about this that can make up for the fact that this is a case of sitting down and experimenting.</p><p>I do have some general tips that may help:</p><ol><li><p>The ANCHOR determines the baseline indentation that you can optionally add or subtract from with OFFSET. Never forget this. You first match <em>something</em> (<code>parent-is</code>, <code>node-is</code>, etc.) and <em>then</em> you find an anchor from <em>that</em> node: perhaps its <code>parent</code>, or something else.</p><p>The OFFSET is exactly that: a change from the ANCHOR’s position.</p></li><li>You can pass regexps to the node type. You can use this to compress node rules that are identical to one another. Use <code>regexp-opt</code> or <code>rx</code> to do this.</li><li><p>Some code is <em>self-similar</em>. That is, you can nest the same node type inside the other. Not always, but often. Think of arrays: <code>[1, 2, [3, ...]]</code>.</p><p>You can define these with two rules: <code>((node-is &#34;element&#34;) parent 2)</code>, to indent the current node; and <code>((parent-is &#34;element&#34;) parent 2)</code> to catch the parent. That’ll ensure arbitrarily nested nodes indent properly.</p><p>Bear in mind that you’ll have to decide on the indentation style separately, of course. For HTML it’s simple.</p></li><li>Order matters, so if things don’t work well, and you get snared by an earlier rule than the one you wanted, try moving the rules around. They’re processed first-to-last in the order they’re kept in the list.</li><li><p>Ending with a <code>no-node</code> rule can be useful as a “catch-all” at the end of your rules list. <code>(no-node parent 0)</code>, for example, simply looks at the parent and maintains its indentation offset.</p><p>Don’t sleep on this rule. It can carry you through an awful lot of “yeah, just keep the current offset”.</p></li><li>It’s just lisp. So if you want feature switches or toggles, you can splice stuff with backquote (or any number of other ways) to make up the ultimate set of rules.</li><li>You probably want a rule for the root node. In HTML it’s <code>fragment</code>, and in other languages it might be <code>program</code>, <code>source</code>, <code>document</code>, etc. This is the baseline rule. I’d put it at the top, but it’s not an iron clad rule.</li></ol><p>Let’s look at how to indent HTML. Well… one way of doing it, anyway!</p><pre><code>(setq-local treesit-simple-indent-rules
    `((html
       ((parent-is <span>&#34;fragment&#34;</span>) parent-bol <span>0</span>)
       ((node-is ,(regexp-opt &#39;(<span>&#34;element&#34;</span> <span>&#34;self_closing_tag&#34;</span>))) parent <span>2</span>)
       ((node-is <span>&#34;end_tag&#34;</span>) parent <span>0</span>)
       ((node-is <span>&#34;/&#34;</span>) parent <span>0</span>)
       ((parent-is <span>&#34;element&#34;</span>) parent <span>2</span>)
       ((node-is <span>&#34;text&#34;</span>) parent <span>0</span>)
       ((node-is <span>&#34;attribute&#34;</span>) prev-sibling <span>0</span>)
       ((node-is <span>&#34;&gt;&#34;</span>) parent <span>0</span>)
       ((parent-is <span>&#34;start_tag&#34;</span>) prev-sibling <span>0</span>)
       (no-node parent <span>0</span>))))</code></pre><p>That’s it. There’s more to do in terms of tidying it up (you can merge more nodes, but this is supposed to be readable and instructive) but that is all it takes.</p><p>Let me explain the rules as they are.</p><ul><li><code>fragment</code> is the root node, and if it’s the parent of point when we indent then we anchor against <em>its</em> offset (<code>parent-bol</code>) and add zero to the offset. In other words, the base indentation for anything that is a child of <code>fragment</code> is 0, because the node itself has an offset of zero also.</li><li><code>element</code> and <code>self_closing_tag</code> are the bread-and-butter of SGML languages. The rule looks at those two nodes at point, checks the parent’s offset and adds two. This gives us nice, simple tree-like indentation so that nested elements are indented properly.</li><li><p><code>end_tag</code> needs a bit of explaining. In tree terms, the structure looks a bit like this <code>(element (start_tag) (end_tag))</code>. Meaning, the end and start tags are children of a super-node called <code>element</code>.</p><p>So when I tell Emacs I want the offset of <code>end_tag</code>’s <code>parent</code>, I’m getting the offset of <code>element</code>. I want it to be zero, because I want the HTML start and end tags to line up:</p><pre><code>&lt;foo&gt;
  &lt;bar/&gt;
  Hello, World!
&lt;/foo&gt;</code></pre></li><li>You can match against anonymous nodes, as I do with <code>/</code> and <code>&gt;</code>. All I want from them that they respect the offset of their parent so they indent properly also.</li><li>I occasionally need to align things according to the parent of a node. In the little example above, this would correspond to things like <code>text</code>. In this case I want to indent by two where the parent is <code>element</code>. That catches <code>text</code>.</li><li>Attributes are much the same as what we’ve seen before, but with a crucial difference. I want my attributes to look at their sibling to determine their own indentation: in this case with <code>prev-sibling</code> and an offset of 0. Emacs will essentially respect the offset of the preceding attribute when it has to indent the current attribute node.</li><li><code>start_tag</code> gets the same treatment as attributes do: try to hew to the previous sibling’s offset.</li><li>And finally, a catch-all <code>no-node</code> entry that maintains the offset of its parent.</li></ul><p>I’m sure there are better ways of doing it; there are worse ways, too. Ultimately, you can arrive at something that works well using any number of approaches, which I think is a positive thing indeed.</p><p>Imenu is the last piece of the puzzle for our scrappy HTML tree-sitter major mode. Conceptually, ignoring tree-sitter here, Imenu is nothing more than a manicured list of stuff to show. It’s not hard to write manually, from scratch, either.</p><p>The tree-sitter “simple imenu” system is anything but, though. It’s a bit awkward to use, as it finds its initial matches with either a regular expression or a custom function that is passed each node in the tree. You cannot use a query directly. If you want to pick the name for the Imenu entry (the node name itself is rarely useful or expressive enough) then you’ll have to write a function to do this also. That, or start tangling with the way the tree-sitter defun finder works, as it’s tightly coupled to that system.</p><p>Anyway. Here’s a basic example to demonstrate what I am talking about.</p><pre><code>(<span>defun</span><span> html-ts-imenu-node-p </span>(node)
  (<span>and</span> (string-match-p <span>&#34;^h[0-6]$&#34;</span> (treesit-node-text node))
       (<span>equal</span> (treesit-node-type (treesit-node-parent node))
              <span>&#34;start_tag&#34;</span>)))

(<span>defun</span><span> html-ts-imenu-name-function </span>(node)
  (<span>let</span> ((name (treesit-node-text node)))
    (<span>if</span> (html-ts-imenu-node-p node)
        (concat name <span>&#34; / &#34;</span>
                (thread-first (treesit-node-parent node)
                              (treesit-node-next-sibling)
                              (treesit-node-text)))
      name)))

(setq-local treesit-simple-imenu-settings
              `((<span>&#34;Heading&#34;</span> html-ts-imenu-node-p <span>nil</span> html-ts-defun-name-function)))</code></pre><p>The gist here is, we need a way to pick the right nodes, which I am doing here with <code>html-ts-imenu-node-p</code>. You’ll also need a way of building the name of the Imenu entry (<code>html-ts-imenu-name-function</code>). Note that I am using a lesser-known feature in Emacs called <code>thread-first</code>. It “threads” the output from <code>(treesit-node-parent node)</code> into the <em>first</em> argument slot of <code>treesit-node-next-sibling</code>, and <em>that</em> output into the first argument of <code>treesit-node-text</code>, which is then returned.</p><p>Retrieving the element’s <code>raw_text</code> takes a bit of work, but it’s manageable. To see why I need to do this, look at (with <code>treesit-explore-mode</code>) the structure of the node I want to match: the <code>tag_name</code> element is the one we’re matching against to begin with. To get to <code>raw_text</code> I need to get its parent and then its sibling.</p><p>Finally, I just assign the desired category (“Heading”) and how to match them.</p><p>Imenu caches its results. Use <code>M-: (imenu-flush-cache)</code> to clear out the Imenu cache between tests. And don’t forget about <a href="https://www.masteringemacs.org/article/which-function-mode">Which Function Mode</a>, which plugs into the Imenu machinery to show you the current “function” point is in.</p><p>And that’s that.</p><h2 id="next-steps">Next Steps</h2><p>With that in place, and knowledge of how to do all of this, tackling <code>treesit-defun-name-function</code> and <code>treesit-defun-type-regexp</code> should be a walk in the park, as it’s similar to Imenu.</p><p>Other things worth considering is adding font locking and indentation to the <code>style</code> and <code>script</code> tags. One benefit of tree-sitter is that it can seamlessly merge multiple grammars rather easily with <code>treesit-range-rules</code>.</p><p>Unfortunately, Emacs 29’s support for this is still rather poor and immature. And ideally, you’d want to recycle the CSS and JS rules from their respective TS-enabled major modes. But, sadly, that is not so easy to do, as the rules are not declared directly in a variable. You’d have to come up with a wide range of gnarly tricks to get at them. It’s not hard or impossible, but it’s harder than it should be.</p><p>And it does not solve the tricky problem of having their respective major modes activate in the right places, either. <a href="https://www.masteringemacs.org/article/polymode-multiple-major-modes-how-to-use-sql-python-in-one-buffer">Polymode can share major modes in a buffer</a> but it’s not seen much in the way of improvement over the years, and it does not understand tree-sitter.</p><p>Still, though, a job well done. I spent longer writing the article than I did writing this integration, which I think says it all.</p><p>You can find the complete file, which should work out of the box in the <a href="https://github.com/mickeynp/html-ts-mode">html-ts-mode</a> repo on my Github.</p>

    
    
  </article></div>
  </body>
</html>
