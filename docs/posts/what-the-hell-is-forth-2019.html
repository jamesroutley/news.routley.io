<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.information-superhighway.net/what-the-hell-is-forth">Original</a>
    <h1>What the hell is Forth? (2019)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Forth is perhaps the tiniest possible useful interactive programming language.  It is tiny along a number of dimensions:</p>
<ul><li>The amount of code required to implement it</li>
<li>The size of the code that is generated</li>
<li>The amount of memory used</li>
<li>The number of features it considers necessary for useful work</li></ul>

<p>It is a language that makes complexity painful, but which reveals that a surprising amount can be accomplished without introducing any. Forth is the opposite of “bloat”. If you&#39;ve ever been like “Oh my God this Electron-based chat app is taking up 10% of my CPU at idle, what the HELL is it DOING, modern computing has gone MAD”, Forth is there to tell you that computing went mad decades ago, and that programs could be doing SO MUCH MORE with SO MUCH LESS.</p>

<h2 id="what-do-you-mean-forth">WHAT DO YOU MEAN, “FORTH”</h2>

<p>There is an expression about Forth: “If you&#39;ve seen one Forth, you&#39;ve seen one Forth.” Forth isn&#39;t a strictly-defined language, though there is a standardized dialect; it&#39;s more a set of ideas that tend to work well together.</p>

<p>In the past month, I wrote a tiny Forth system on a 286 running MS-DOS using Turbo C++ 1.01. It is my first time using Forth in anger, though I read a lot about it 15 years ago. When I refer to my Forth, I am referring to a system literally thrown together in two weeks, written by someone who does not really know Forth that well. It is slow and wildly nonstandard and it doesn&#39;t do very much, but I have enjoyed the process of writing it very much. If you are a grizzled old Forth grognard, please let me know if I have misrepresented anything.</p>

<h2 id="what-does-forth-not-do">WHAT DOES FORTH NOT DO</h2>

<p>Here is an incomplete list of things you may take for granted as a programmer that Forth, in its purest form, generally considers unnecessary waste:</p>
<ul><li>Garbage collection</li>
<li>Dynamic memory allocation</li>
<li>Garbage</li>
<li>Memory safety</li>
<li>Static types</li>
<li>Dynamic types</li>
<li>Objects</li>
<li>Polymorphic methods</li>
<li>Closures</li>
<li>Lexical scoping</li>
<li>The concept of global variables being in any way “bad”</li>
<li>Local variables</li>
<li>The ability to write “IF” statements at the REPL</li></ul>

<p>Most or all of these <em>can</em> be added to the language – the Forth standard, ANS Forth, specifies words for dynamic memory allocation and local variables. There are lots of object systems that people have built on top of Forth. Forth is a flexible medium, if you&#39;re willing to put in the work.</p>

<p>But the inventor of Forth, <a href="http://www.ultratechnology.com/1xforth.htm" rel="nofollow">Chuck Moore, literally said, in <em>1999</em></a>: “I remain adamant that local variables are not only useless, they are harmful.” In the Forth philosophy, <em>needing to use local variables</em> is a sign that you have not simplified the problem enough; that you should restructure things so that the meaning is clear without them.</p>

<h2 id="what-does-forth-look-like">WHAT DOES FORTH LOOK LIKE</h2>

<p>A core part of Forth is that all functions, or “words” in Forth terminology, operate on “the stack”. Words take arguments from the stack, and return their results on the stack.  There are a handful of primitive built-in words that do no useful work besides manipulating the stack.</p>

<p>What this means is that writing an expression tree as Forth code ends up turning into postfix notation. <code>(1 + 2) * (3 - 4)</code> becomes <code>1 2 + 3 4 - *</code>. Writing a number in Forth means “push that number onto the stack”.</p>

<p>Forth syntax is, with a few exceptions, radically, stupefyingly simple: Everything that&#39;s not whitespace is a word. Once the interpreter has found a word, it looks it up in the global dictionary, and if it has an entry, it executes it. If it doesn&#39;t have an entry, the interpreter tries to parse it as a number; if that works, it pushes that number on the stack. If it&#39;s not a number either, it prints out an error and pushes on.</p>

<p>Oops, I meant to describe the syntax but instead I wrote down the entire interpreter semantics, because <em>it fits in three sentences</em>.</p>

<p>The exception to the “whatever is not whitespace is a word” rule is that the interpreter is not the only piece of Forth code that can consume input. For example, <code>(</code> is a word that reads input and discards it until it finds a <code>)</code> character. That&#39;s how comments work – the interpreter sees the <code>(</code> with a space after it, runs the word, and then the next character it looks at is after the comment has ended. You can trivially define <code>(</code> in one line of Forth.</p>

<h2 id="why-the-hell-would-i-use-that">WHY THE HELL WOULD I USE THAT</h2>

<p>There are practical reasons:</p>
<ul><li>You need something tiny and reasonably powerful, and you don&#39;t care about memory safety</li>
<li>I&#39;m not sure I can think of any others</li></ul>

<p>And there are intangible reasons:</p>
<ul><li>Implementing a programming language that fits into a few kilobytes of RAM, that you understand every line of, that you can build one piece at a time and extend infinitely, makes you feel like a god-damn all-powerful wizard</li></ul>

<p>Part of the mystique of Forth is that you can get very metacircular with it – control flow words like IF and FOR are implemented in Forth, not part of the compiler/interpreter. So are comments, and string literals. The compiler/interpreter itself is usually, in some way, written in Forth. It turns out that you can discard virtually every creature comfort of modern programming and still end up with a useful language that is extensible in whatever direction you choose to put effort into.</p>

<p>Forth enters that rarefied pantheon of languages where the interpreter is, like, half a page of code, written in itself. In many ways it&#39;s kind of like a weird backwards lisp with no parentheses. And it can be made to run on the tiniest hardware!</p>

<p>The mental model for bootstrapping a Forth system goes something like:</p>
<ul><li>Write primitive words in assembly – this includes the complete Forth “VM”, as distinct from the Forth language interpreter/compiler. The set of built-in words can be very, very small – in the document “<a href="http://www.exemark.com/FORTH/eForthOverviewv5.pdf" rel="nofollow">eForth Overview</a>” by C. H. Ting, which I have seen recommended as an excellent deep-dive into the details of how to build a Forth environment, Ting states that his system is built with 31 “primitive” words written in assembly.</li>
<li>Hand-assemble “VM bytecode” for the interpreter/compiler and required dependencies – because of the extreme simplicity of the VM, you can generally program your macro assembler to do this job, and so this can meaningfully resemble the act of simply writing Forth code directly</li>
<li>Write all new words using the interpreter/compiler you just got running</li></ul>

<p>I say “interpreter/compiler” and not “interpreter and compiler” because they are literally mixed together; there is a global flag that determines whether the interpreter is in “compile mode” or not. It is done this way because it turns out that if you add the ability to mark a word as “always interpret, even in compile mode”, you have added the ability to extend the compiler in arbitrary ways.</p>

<h2 id="what-sucks-about-writing-forth">WHAT SUCKS ABOUT WRITING FORTH</h2>

<h3 id="any-word-that-takes-more-than-two-or-three-parameters-is-a-nightmare-to-read-or-write">Any word that takes more than two or three parameters is a nightmare to read or write</h3>

<p>Right now in my codebase I have a word that uses two global variables because I cannot deal with juggling all of the values on the stack. This word is absolutely not re-entrant and at some point I&#39;m going to need to rewrite it so that it is, and I am <em>not looking forward to it</em>. If I had local variables, it would be substantially less of a problem. But there&#39;s also part of me that thinks there must be some way to rewrite it to be simpler that I haven&#39;t figured out yet.</p>

<p>There&#39;s another word in my codebase that takes 4 or 5 parameters that I managed to write by breaking it up into, like, 8 smaller words, over the course of writing / rewriting for like an hour or two. I felt pretty proud when I finally got it working, but honestly I think it would have been pretty trivial to write in C with local variables. I miss them.</p>

<h3 id="shit-crashes">Shit crashes</h3>

<p>Remember the part about no memory safety? Yeah, there&#39;s <em>all kinds</em> of ways a wayward Forth system can go wrong. I forgot a <code>DROP</code> once in a frequently-used word and my computer hard-locked when the stack overflowed. (To be fair: my computer was a 286 running MS-DOS, so I was already in a situation where programming it meant rebooting it when I inevitably fucked something up.)</p>

<h3 id="nonexistent-error-messages">Nonexistent error messages</h3>

<p>The only error message my Forth system has is, if it doesn&#39;t recognize the word “foo”, it prints “foo?”  If, for example, I write an <code>IF</code> statement, but forget to end it with <code>THEN</code>, I don&#39;t get a compile error, I get — you guessed it — a runtime hard crash.</p>

<h2 id="what-rules-about-writing-forth">WHAT RULES ABOUT WRITING FORTH</h2>

<h3 id="it-s-compact-as-hell">It&#39;s compact as hell</h3>

<p>The majority of words I write are literally one line of code. They do a small job and get out.</p>

<h3 id="it-s-direct-as-hell">It&#39;s direct as hell</h3>

<p>Building abstractions in Forth is... different than building abstractions in other languages.  It&#39;s still a really core, important thing, but as building complex / expensive code is so much work, stacking expensive abstractions on top of each other is not really tenable. So you&#39;re left with very basic building blocks to do your job as straightforwardly as possible.</p>

<h3 id="you-are-absolutely-empowered-to-fix-any-problems-with-your-particular-workflow-and-environment">You are absolutely empowered to fix any problems with your particular workflow and environment</h3>

<p>People turn Forth systems into tiny OSes, complete with text editors, and I absolutely did not understand this impulse until I wrote my own. The Forth interpreter is an interactive commandline, and you can absolutely make it your own. Early on I wrote a decompiler, because it was easy. It&#39;s like half a screen of code. There are some cases it falls down on, but I wrote it in like a half hour and it works well enough for what I need.</p>

<h3 id="everything-is-tiny-and-easy-to-change-or-extend">Everything is tiny and easy to change or extend</h3>

<p>Remember when I said I wrote a decompiler because it was easy? Other things I changed in an evening or two:</p>
<ul><li>Added co-operative multitasking (green threads)</li>
<li>Custom I/O overrides, so my interactive REPL sessions could be saved to disk</li>
<li>Rewrote the core interpreter loop in Forth</li>
<li>Rewrote the VM loop to not use the C stack</li>
<li>Instrumenting the VM with debug output to catch a crash bug</li></ul>

<p>One of the things on my todo list is a basic interactive step-through debugger, which I suspect I&#39;ll be able to get basically up and running within, like, an hour or two? When things stay tiny and simple, you don&#39;t worry too much about changing them to make them better, you just do it.</p>

<h3 id="if-you-have-ever-wanted-an-assembly-code-repl-this-is-about-as-close-as-you-re-going-to-get">If you have ever wanted an assembly code REPL, this is about as close as you&#39;re going to get</h3>

<p>Forth is a dynamic language in which the only type is “a 16-bit number” and you can do whatever the fuck you want with that number. This is dangerous as hell, of course, but if you are writing code that has no chance of having to handle arbitrary adversarial input from the internet (like my aforementioned MS-DOS 286), it is surprising how refreshing and fun this is.</p>

<h2 id="this-sounds-interesting-what-is-the-best-way-to-learn-more">THIS SOUNDS INTERESTING, WHAT IS THE BEST WAY TO LEARN MORE</h2>

<p>I honestly do not know if there is a better way to understand Forth than just trying to build your own, and referring to other Forth implementations and documents when you get stuck. It&#39;s been my experience that they just don&#39;t make sense until you&#39;re neck deep into it.  And it&#39;s tiny enough that you feel <em>good</em> about throwing away pieces that aren&#39;t working once you understand what does work.</p>

<p>I&#39;ve found the process of writing my own Forth and working within its constraints to be <em>far</em> more rewarding than any time I have tried working with existing Forths, even if on occasion I have wished for more complex functionality than I&#39;m willing to build on my own.</p>

<h2 id="what-have-i-learned-from-all-this">WHAT HAVE I LEARNED FROM ALL THIS</h2>

<p>I&#39;m very interested in alternate visions of what computing can look like, and who it can be for. Forth has some very interesting ideas embedded in it:</p>
<ul><li>A system does not have to be complex to be flexible, extensible, and customizable</li>
<li>A single person should be able to understand a computing system in its entirety, so that they can change it to fit their needs</li></ul>

<p>I find myself wondering a lot what a more accessible Forth might look like; are there more flexible, composable, simple abstractions like the Forth “word” out there? Our current GUI paradigms can&#39;t be irreducible in complexity; is there a radically simpler alternative that empowers individuals? What else could an individual-scale programming language look like, that is not only designed to enable simplicity, but to outright disallow complexity?</p>

<p>Forth is a radical language because it does not “scale up”; you cannot build a huge system in it that no one person understands and expect it to work. Most systems I have used that don&#39;t scale up – Klik &amp; Play, Hypercard, Scratch, that sort of thing – are designed for accessibility. Forth is not; it&#39;s designed for leverage. That&#39;s an interesting design space I wasn&#39;t even really aware of.</p>

<p>The lesson that implementing abstractions as directly as possible enables you to more easily change them is a useful one. And the experience of succeeding in building a programming environment from scratch on an underpowered computer in a couple of weeks is something I will bring with me to other stalled projects – you can sit down for a couple of hours, radically simplify, make progress, and learn.</p>
</div></div>
  </body>
</html>
