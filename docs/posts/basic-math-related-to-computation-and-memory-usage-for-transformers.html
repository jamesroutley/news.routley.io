<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.eleuther.ai/transformer-math/">Original</a>
    <h1>Basic math related to computation and memory usage for transformers</h1>
    
    <div id="readability-page-1" class="page"><div>
	<article>
		 
		<div>
<p>A lot of basic, important information about transformer language models can be computed quite simply. Unfortunately, the equations for this are not widely known in the NLP community. The purpose of this document is to collect these equations along with related knowledge about where they come from and why they matter.</p>
<p><strong>Note:</strong> This post is primarily concerned with training costs, which are dominated by VRAM considerations. For an analogous discussion of inference costs with a focus on latency, check out <a href="https://kipp.ly/blog/transformer-inference-arithmetic/">this excellent blog post</a> by Kipply.</p>

<p>The basic equation giving the cost to train a transformer model is given by:</p>
<p>$$
C\approx\tau T = 6PD
$$</p>
<p>where:</p>
<ul>
<li>$C$ is the compute required to train the transformer model, in total floating point operations</li>
<li>$C=C_{\text{forward}}+C_{\text{backward}}$</li>
<li>$C_{\text{forward}}\approx2PD$</li>
<li>$C_{\text{backward}}\approx4PD$</li>
<li>$\tau$ is the aggregate throughput of your hardware setup ($\tau=(\text{No. GPUs}) \times (\text{Actual FLOPs}/\text{GPU})$), in FLOPs</li>
<li>$T$ is the time spent training the model, in seconds</li>
<li>$P$ is the number of parameters in the transformer model</li>
<li>$D$ is the dataset size, in tokens</li>
</ul>
<p>These equations are proposed and experimentally validated in <a href="https://arxiv.org/abs/2001.08361">OpenAI’s scaling laws paper</a> and <a href="https://arxiv.org/abs/2203.15556">DeepMind’s scaling laws paper</a>. Please see each paper for more information.</p>
<p>It’s worth taking an aside and discussing the units of $C$. $C$ is a measure of total compute, but can be measured by many units such as:</p>
<ul>
<li>FLOP-seconds, which is in units of $[\frac{\text{Floating Point Operations}}{\text{Second}}] \times [\text{Seconds}]$</li>
<li>GPU-hours, which is in units of $[\text{No. GPUs}]\times[\text{Hours}]$</li>
<li>Scaling laws papers tend to report values in PetaFLOP-days, or $10^{15}\times24\times3600$ total floating point operations</li>
</ul>
<p>One useful distinction to keep in mind is the concept of $\text{Actual FLOPs}$. While GPU accelerator whitepapers usually advertise their theoretical FLOPs, these are never met in practice (especially in a distributed setting!). Some common reported values of $\text{Actual FLOPs}$ in a distributed training setting are reported below in the Computing Costs section.</p>
<p>Note that we use the throughput-time version of the cost equation as used in <a href="https://medium.com/@dzmitrybahdanau/the-flops-calculus-of-language-model-training-3b19c1f025e4">this wonderful blog post on LLM training costs</a>.</p>
<h2 id="parameter-vs-dataset-tradeoffs">Parameter vs Dataset Tradeoffs</h2>
<p>Although strictly speaking you can train a transformer for as many tokens as you like, the number of tokens trained can highly impact both the computing costs and the final model performance making striking the right balance important.</p>
<p><strong>Let’s start with the elephant in the room: “compute optimal” language models.</strong> Often  referred to as “Chinchilla scaling laws” after the model series in the paper that gave rise to current beliefs about the number of parameters, a compute optimal language model has a <strong>number of parameters</strong> and a <strong>dataset size</strong> that satisfies the approximation $D=20P$. This is optimal in one very specific sense: in a resource regime where using 1,000 GPUs for 1 hour and 1 GPU for 1,000 hours cost you the same amount, if your goal is to maximize performance while minimizing the cost in GPU-hours to train a model you should use the above equation.</p>
<p><strong>We do not recommend training a LLM for less than 200B tokens.</strong> Although this is “chinchilla optimal” for many models, the resulting models are typically quite poor. For almost all applications, we recommend determining what inference cost is acceptable for your usecase and training the largest model you can to stay under that inference cost for as many tokens as you can.</p>
<h2 id="engineering-takeaways-for-compute-costs">Engineering Takeaways for Compute Costs</h2>
<p>Computing costs for transformers are typically listed in GPU-hours or FLOP-seconds.</p>
<ul>
<li>GPT-NeoX achieves 150 TFLOP/s/A100 with normal attention and 180 FLOP/s/A100 with Flash Attention. This is in line with other highly optimized libraries at scale, for example Megatron-DS reports between 137 and 163 TFLOP/s/A100.</li>
<li>As a general rule of thumb, you should always be able to achieve approximately 120 FLOP/s/A100. If you are seeing below 115 FLOP/s/A100 there is probably something wrong with your model or hardware configuration.</li>
<li>With high-quality interconnect such as InfiniBand, you can achieve linear or sublinear scaling across the data parallel dimension (i.e. increasing the data parallel degree should increase the overall throughput nearly linearly). Shown below is a plot from testing the GPT-NeoX library on Oak Ridge National Lab’s Summit supercomputer. Note that V100s are on the x-axis, while most of the numerical examples in the post are for A100s.</li>
</ul>
<figure>
    <img loading="lazy" src="https://blog.eleuther.ai/images/blog/transformer-math/neox-scaling.png#center" alt="GPT-NeoX scaling"/> 
</figure>


<p>Transformers are typically described in terms of their <em>size in parameters</em>. However, when determining what models can fit on a given set of computing resources you need to know <strong>how much space in bytes</strong> the model will take up. This can tell you how large a model will fit on your local GPU for inference, or how large a model you can train across your cluster with a certain amount of total accelerator memory.</p>
<h2 id="inference">Inference</h2>
<h3 id="model-weights">Model Weights</h3>
<figure>
    <img loading="lazy" src="https://cdn.discordapp.com/attachments/938462108721483787/1052372619577532467/image.png#center" alt="Model Weights"/> 
</figure>

<p>Most transformers are trained in <strong>mixed precision</strong>, either fp16 + fp32 or bf16 + fp32. This cuts down on the amount of memory required to train the models, and also the amount of memory required to run inference. We can cast language models from fp32 to fp16 or even int8 without suffering a substantial performance hit. These numbers refer to the size <em>in bits</em> a single parameter requires. Since there are 8 bits in a Byte, we divide this number by 8 to see how many Bytes each parameter requires</p>
<ul>
<li>In int8, $\text{memory}_{\text{model}}=(1 \text{ byte} /\text{param})\cdot ( \text{No. params})$</li>
<li>In fp16 and bf16, $\text{memory}_{\text{model}}=(2 \text{ bytes} /\text{param})\cdot ( \text{No. params})$</li>
<li>In fp32, $\text{memory}_{\text{model}}=(4 \text{ bytes} /\text{param})\cdot (\text{No. params})$</li>
</ul>
<p>There is also a small amount of additional overhead, which is typically irrelevant to determining the largest model that will fit on your GPU. In our experience this overhead is ≤ 20%.</p>
<h3 id="total-inference-memory">Total Inference Memory</h3>
<p>In addition to the memory needed to store the model weights, there is also a small amount of additional overhead during the actual forward pass. In our experience this overhead is ≤ 20% and is typically irrelevant to determining the largest model that will fit on your GPU.</p>
<p>In total, a good heuristic answer for “will this model fit for inference” is:</p>
<p>$\text{Total Memory}_{\text{Inference}}\approx(1.2) \times \text{Model Memory}$</p>
<p>We will not investigate the sources of this overhead in this blog post and leave it to other posts or locations for now, instead focusing on memory for model training in the rest of this post. If you’re interested in learning more about the calculations required for inference, check out <a href="https://kipp.ly/blog/transformer-inference-arithmetic/">this fantastic blog post covering inference in depth</a>. Now, on to training!</p>
<h2 id="training">Training</h2>
<p>In addition to the model parameters, training requires the storage of optimizer states and gradients in device memory. This is why asking “how much memory do I need to fit model X” immediately leads to the answer “this depends on training or inference.” Training always requires more memory than inference, often very much more!</p>
<h3 id="model-parameters">Model Parameters</h3>
<p>First off, models can be trained in pure fp32 or fp16:</p>
<ul>
<li>Pure fp32, $\text{memory}_{\text{model}}=(4 \text{ bytes} /\text{param})\cdot (\text{No. params})$</li>
<li>Pure fp16, $\text{memory}_{\text{model}}=(2 \text{ bytes} /\text{param})\cdot (\text{No. params})$</li>
</ul>
<p>In addition to the common model weight datatypes discussed in Inference, training introduces <strong>mixed-precision</strong> training such as <a href="https://developer.nvidia.com/automatic-mixed-precision">AMP</a>. This technique seeks to maximize the throughput of GPU tensor cores while maintaining convergence. The modern DL training landscape frequently uses mixed-precision training because: 1) fp32 training is stable, but has a high memory overhead and doesn’t exploit NVIDIA GPU tensor cores, and 2) fp16 training is stable but difficult to converge. For more information on mixed-precision training, we recommend reading <a href="https://nbviewer.org/github/tunib-ai/large-scale-lm-tutorials/blob/main/notebooks/08_zero_redundancy_optimization.ipynb">this notebook by tunib-ai</a>. Note that mixed-precision requires an fp16/bf16 and fp32 version of the model to be stored in memory, requiring:</p>
<ul>
<li>Mixed-precision (fp16/bf16 and fp32), $\text{memory}_{\text{model}}=(2 \text{ bytes} /\text{param})\cdot (\text{No. params})$</li>
</ul>
<p>plus an additional size $(4\text{ bytes/param}) \cdot (\text{#params})$ copy of the model <strong>that we count within our optimizer states</strong>.</p>
<h3 id="optimizer-states">Optimizer States</h3>
<p>Adam is magic, but it’s highly memory inefficient. In addition to requiring you to have a copy of the model parameters and the gradient parameters, you also need to keep an additional three copies of the gradient parameters. Therefore,</p>
<ul>
<li>For vanilla AdamW, $\text{memory}_{\text{optimizer}}=(12 \text{ bytes}/\text{param})\cdot (\text{No. params})$
<ul>
<li>fp32 copy of parameters: 4 bytes/param</li>
<li>Momentum: 4 bytes/param</li>
<li>Variance: 4 bytes/param</li>
</ul>
</li>
<li>For 8-bit optimizers like <a href="https://github.com/TimDettmers/bitsandbytes">bitsandbytes</a>, $\text{memory}_{\text{optimizer}}=(6 \text{ bytes} /\text{param})\cdot (\text{No. params})$
<ul>
<li>fp32 copy of parameters: 4 bytes/param</li>
<li>Momentum: 1 byte/param</li>
<li>Variance: 1 byte/param</li>
</ul>
</li>
<li>For SGD-like optimizers with momentum, $\text{memory}_{\text{optimizer}}=(8 \text{ bytes} /\text{param})\cdot (\text{No. params})$
<ul>
<li>fp32 copy of parameters: 4 bytes/param</li>
<li>Momentum: 4 bytes/param</li>
</ul>
</li>
</ul>
<h3 id="gradients">Gradients</h3>
<p>Gradients can be stored in fp32 or fp16 (Note that the gradient datatype often matches the model datatype. We see that it therefore is stored in fp16 for fp16 mixed-precision training), so their contribution to memory overhead is given by:</p>
<ul>
<li>In fp32, $\text{memory}_{\text{gradients}}=(4 \text{ bytes} /\text{param})\cdot (\text{No. params})$</li>
<li>In fp16, $\text{memory}_{\text{gradients}}=(2 \text{ bytes} /\text{param})\cdot (\text{No. params})$</li>
</ul>
<h3 id="activations-and-batch-size">Activations and Batch Size</h3>
<p>Modern GPUs are typically bottlenecked by memory, not FLOPs, for LLM training. Therefore activation recomputation/checkpointing is an extremely popular method of trading reduced memory costs for extra compute costs. Activation recomputation/checkpointing works by recomputing activations of certain layers instead of storing them in GPU memory. The reduction in memory depends on how selective we are when deciding which layers to clear, but Megatron’s selective recomputation scheme is depicted in the figure below:</p>
<figure>
    <img loading="lazy" src="https://blog.eleuther.ai/images/blog/transformer-math/activations.png#center" alt="activation memory"/> 
</figure>

<p>Where the dashed red line indicates the memory capacity of an A100-80GB GPU, and “present work” indicates the memory requirements after applying selective activation recomputation. See  <a href="https://arxiv.org/abs/2205.05198">Reducing Activation Recomputation in Large Transformer Models</a> for further details and the derivation of the equations below</p>
<p>The basic equation giving the memory required to store activations for a transformer model is given by:</p>
<p>$$
\begin{align*}\text{memory}^{\text{No Recomputation}}_{\text{activations}}=sbhL(10+\frac{24}{t}+5\frac{a \cdot s}{h\cdot t}) \text{ bytes}\end{align*}
$$</p>
<p>$$
\begin{align*}\text{memory}^{\text{Selective Recomputation}}_{\text{activations}}=sbhL(10+\frac{24}{t}) \text{ bytes}\end{align*}
$$</p>
<p>$$
\begin{align*}\text{memory}^{\text{Full Recomputation}}_{\text{activations}}=2 \cdot sbhL \text{ bytes}\end{align*}
$$</p>
<p>where:</p>
<ul>
<li>$s$ is the sequence length, in tokens</li>
<li>$b$ is the batch size per GPU</li>
<li>$h$ is the dimension of the hidden size within each transformer layer</li>
<li>$L$ is the number of layers in the transformer model</li>
<li>$a$ is the number of attention heads in the transformer model</li>
<li>$t$ is the degree of tensor parallelism being used (1 if not)</li>
<li>We assume no sequence parallelism is being used</li>
<li>We assume that activations are stored in fp16</li>
</ul>
<p>The additional recomputation necessary also depends on the selectivity of the method, but it’s bounded above by a full additional forward pass. Hence the updated cost of the forward pass is given by:</p>
<p>$$
2PD\leq C_{\text{forward}}\leq4PD
$$</p>
<h3 id="total-training-memory">Total Training Memory</h3>
<p>Therefore, a good heuristic answer for “will this model fit for training” is:</p>
<p>$$
\begin{align*}\text{Total Memory}<em>{\text{Training}} = \text{memory}</em>{\text{model}}+\text{memory}<em>{\text{optimizer}}+\text{memory}</em>{\text{activations}}+\text{memory}_{\text{gradients}}\end{align*}
$$</p>
<h2 id="distributed-training">Distributed Training</h2>
<h3 id="sharded-optimizers">Sharded Optimizers</h3>
<p>The massive memory overheads for optimizers is the primary motivation for sharded optimizers such as <a href="https://arxiv.org/abs/1910.02054">ZeRO</a> and <a href="https://engineering.fb.com/2021/07/15/open-source/fsdp/">FSDP</a>. Such sharding strategies reduce the optimizer overhead by a factor of $\text{No. GPUs}$, which is why a given model configuration may fit at large scale but OOM at small scales. If you’re looking to calculate the memory overhead required by training using a sharded optimizer, you will need to include the equations from the figure below. For some sample calculations of sharded optimization, see the following figure from the <a href="https://arxiv.org/abs/1910.02054">ZeRO</a> paper (Note that $P_{os}$ $P_{os+g}$ and $P_{os+g+p}$ are commonly denoted as ZeRO-1, ZeRO-2, ZeRO-3, respectively. ZeRO-0 commonly means “ZeRO disabled”):</p>
<figure>
    <img loading="lazy" src="https://blog.eleuther.ai/images/blog/transformer-math/zero_fig.png#center" alt="ZeRO illustration"/> 
</figure>

<figure>
    <img loading="lazy" src="https://blog.eleuther.ai/images/blog/transformer-math/zero_legend.png#center" alt="ZeRO legend"/> 
</figure>

<p>In the language of this blog post (assuming mixed-precision and the Adam optimizer):</p>
<ul>
<li>For ZeRO-1,</li>
</ul>
<p>$$
\begin{align*}\text{Total Memory}_{\text{Training}}\approx\text{Model Memory}+\frac{\text{Optimizer memory}}{(\text{No. GPUs})}+\text{Activation Memory}+\text{Gradient Memory}\end{align*}
$$</p>
<ul>
<li>For ZeRO-2,</li>
</ul>
<p>$$
\begin{align*}\text{Total Memory}_{\text{Training}}\approx\text{Model Memory}+\text{Activation Memory}+\frac{\text{Optimizer Memory}+\text{Gradient Memory}}{(\text{No. GPUs})}\end{align*}
$$</p>
<ul>
<li>For ZeRO-3,</li>
</ul>
<p>$$
\begin{align*}\text{Total Memory}_{\text{Training}}\approx \text{Activation Memory}+\frac{\text{Model Memory}+\text{Optimizer Memory}+\text{Gradient Memory}}{(\text{No. GPUs})} + \text{(ZeRO-3 Live Params)}\end{align*}
$$</p>
<p>Where $(\text{DP Degree})$ is just $(\text{No. GPUs})$ unless pipeline and/or tensor parallelism are applied. See <a href="https://www.notion.so/Sharded-Optimizers-3D-Parallelism-9c476d020d7641a299fb6be6ae82e9f8">Sharded Optimizers + 3D Parallelism</a> for details.</p>
<p>Note that ZeRO-3 introduces a set of live parameters. This is because ZeRO-3 introduces a set of config options (<em><strong>stage3_max_live_parameters, stage3_max_reuse_distance, stage3_prefetch_bucket_size, stage3_param_persistence_threshold</strong></em>) that control how many parameters are within GPU memory at a time (larger values take more memory but require less communication). Such parameters can have a significant effect on total GPU memory.</p>
<p>Note that ZeRO can also partition activations over data parallel ranks via <strong>ZeRO-R</strong>. This would also bring the $\text{memory}_\text{activations}$ above the tensor parallelism degree $t$. For more details, read the associated <a href="https://arxiv.org/abs/1910.02054">ZeRO paper</a> and <a href="https://www.deepspeed.ai/docs/config-json/#activation-checkpointing">config options</a> (note in GPT-NeoX, this is the <code>partition_activations</code> flag). If you are training a huge model, you would like to trade some memory overhead for additional communication cost, and activations become a bottleneck. As an example of using ZeRO-R along with ZeRO-1:</p>
<p>$$
\begin{align*}\text{Total Memory}_{\text{Training}}\approx\text{Model Memory}+\frac{\text{Optimizer Memory}}{(\text{No. GPUs})}+\frac{\text{Activation Memory}}{\text{(Tensor-Parallel-Size)}}+\text{Gradient Memory}\end{align*}
$$</p>
<h3 id="3d-parallelism">3D Parallelism</h3>
<p>Parallelism for LLMs comes in 3 primary forms:</p>
<p><strong>Data parallelism:</strong> Split the data among (possibly model-parallel) replicas of the model</p>
<p><strong>Pipeline or Tensor/Model parallelism:</strong> These parallelism schemes split the parameters of the model across GPUs. Such schemes require significant communication overhead, but their memory reduction is approximately:</p>
<p>$$
\begin{align*}\text{memory}^{\text{w/ parallelism}}_{\text{model}}\approx\frac{\text{Model Memory}}{\text{(Pipe-Parallel-Size})\times\text{(Tensor-Parallel-Size)}}\end{align*}
$$</p>
<p>$$
\begin{align*}\text{memory}^{\text{w/ parallelism}}_{\text{gradients}}\approx\frac{\text{Gradient Memory}}{\text{(Pipe-Parallel-Size})}\end{align*}
$$</p>
<p>Note that this equation is approximate due to the facts that (1) pipeline parallelism doesn’t reduce the memory footprint of activations, (2) pipeline parallelism requires that all GPUs store the activations for all micro-batches in-flight, which becomes significant for large models, and (3) GPUs need to temporarily store the additional communication buffers required by parallelism schemes.</p>
<h3 id="sharded-optimizers--3d-parallelism">Sharded Optimizers + 3D Parallelism</h3>
<p>When ZeRO is combined with tensor and/or pipeline parallelism, the resulting parallelism strategy forms a mesh like the following:</p>
<figure>
    <img loading="lazy" src="https://i.imgur.com/xMgptTN.png#center" alt="3D parallelism"/> 
</figure>

<p>As an important aside, the DP degree is vital for use in calculating the global batch size of training. The data-parallel degree depends on the number of complete model replicas:</p>
<p>$$
\begin{align*}\text{DP Degree = }\frac{\text{No. GPUs}}{\text{(Pipe-Parallel-Size})\times\text{(Tensor-Parallel-Size)}}\end{align*}
$$</p>
<p>While pipeline parallelism and tensor parallelism are compatible with all stages of ZeRO (e.g. ZeRO-3 with tensor parallelism would lead to us first slicing the tensors, then applying ZeRO-3 within each tensor-parallel unit), only ZeRO-1 tends to perform well in conjunction with tensor and/or pipeline parallelism. This is due to the conflicting parallelism strategies for gradients (pipeline parallelism and ZeRO-2 both split gradients) (tensor parallelism and ZeRO-3 both split model parameters), which leads to a significant communication overhead.</p>
<p>Putting everything together for a typical 3D-parallel ZeRO-1 run with activation partitioning:</p>
<p>$$
\begin{align*}\text{Total Memory}_{\text{Training}}\approx\frac{\text{Model Memory}}{\text{(Pipe-Parallel-Size})\times\text{(Tensor-Parallel-Size)}}+\frac{\text{Optimizer Memory}}{(\text{No. GPUs})}+\frac{\text{Activation Memory}}{\text{(Tensor-Parallel-Size)}}+\frac{\text{Gradient Memory}}{\text{(Pipe-Parallel-Size})}\end{align*}
$$</p>

<p>EleutherAI engineers frequently use heuristics like the above to plan efficient model training and to debug distributed runs. We hope to provide some clarity on these often-overlooked implementation details, and would love to hear your feedback at <a href="mailto:contact@eleuther.ai">contact@eleuther.ai</a> if you would like to discuss or think we’ve missed anything!</p>
<p>To cite this blog post, please use:</p>
<div><pre tabindex="0"><code data-lang="bibtex"><span><span><span>@misc</span>{transformer-math-eleutherai,
</span></span><span><span>  <span>title</span> = <span>{Transformer Math 101}</span>,
</span></span><span><span>  <span>author</span> = <span>{Anthony, Quentin and Biderman, Stella and Schoelkopf, Hailey}</span>,
</span></span><span><span>  <span>howpublished</span> = \url<span>{blog.eleuther.ai/}</span>,
</span></span><span><span>  <span>year</span> = <span>{2023}</span>
</span></span><span><span>}
</span></span></code></pre></div>

		</div>
	</article>
	</div></div>
  </body>
</html>
