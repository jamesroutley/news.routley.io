<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.computerenhance.com/p/turns-are-better-than-radians">Original</a>
    <h1>Turns are better than radians</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg" width="1456" height="971" data-attrs="{&#34;src&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:971,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:8701736,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/jpeg&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F20e598bd-cac0-4b10-8222-b432167c9159_5616x3744.jpeg 1456w" sizes="100vw"/></picture></div></a></figure></div><p><span>Some time ago, much effort was expended to convince people to replace approximations of “pi” (3.14159…) with approximations of “tau” (6. 28318…). The idea, according to numerous blog posts and </span><a href="https://www.youtube.com/results?search_query=tau+pi" rel="">YouTube videos</a><span>, was that common formulas become simpler, and it’s easier to work with a constant describing an </span><em>entire</em><span> circle instead of </span><em>half</em><span> a circle.</span></p><p>Generally, I agree. While it’s a minor point, it’s worth making. Most code does get slightly better if you replace pi with tau. </p><p><span>However, in all the fanfare, a far more impactful opportunity was overlooked. Instead of replacing pi with tau, most of the time pi can be </span><em>removed entirely</em><span>.</span></p><p><span>First, consider the common case for </span><em>pi</em><span> and </span><em>tau</em><span> in code: converting things to and from radians for calls to trigonometric functions. If you’ve ever used these constants, the vast majority of what you wrote probably did something like this:</span></p><pre><code>y = center.y + (center.y * Math::sin(h * Math_TAU) * s) - 
    (cursor-&gt;get_height() / 2);</code></pre><p><span>That’s not me constructing an example, that’s me randomly opening the source code for the </span><a href="https://godotengine.org/" rel="">Godot Engine</a><span> on github and searching for “tau”. </span><a href="https://github.com/godotengine/godot/blob/61c0cb712d854881def4f266ca419de8c6fc6f37/scene/gui/color_picker.cpp#L786" rel="">The piece of code above</a><span>, and dozens of similar uses, is what comes up.</span></p><p>There is nothing special here about Godot. If you opened any random game engine codebase, you could do the exact same search and see the exact same kind of usage.</p><p><span>Notice what is going on here: the programmer has a value </span><em>h</em><span> which is already periodic on the range 0 to 1, but they </span><em>multiply</em><span> by tau because they need to call sin.</span></p><p><span>This may seem very sensible if that’s as far as you look. But what about the </span><em>implementation</em><span> of sin?</span></p><p>There are many implementations of sin, but no matter which one you look at, near the entry point of the function you’ll see something like this:</p><pre><code>_PS256_CONST(cephes_FOPI, 1.27323954473516);
...
y = _mm256_mul_ps(x, *(v8sf*)_ps256_cephes_FOPI);</code></pre><p><span>Again, not me making up an example - that’s from </span><a href="https://github.com/reyoung/avx_mathfun/blob/be617bbcf66993c4f7e7d267ed9926cd8e7d4f02/avx_mathfun.h#L346" rel="">this commonly referenced AVX2 implementation of sin</a><span>. It’s not unusual or weird - pretty much every fast trig library is going to do something very similar.</span></p><p>What does this line do? It multiplies the input by the constant 1.27323954473516. </p><p><span>Which just so happens to be </span><em>4/pi</em><span>.</span></p><p>So the calling code is doing this:</p><pre><code>sin(h * 2 * pi)</code></pre><p>but the library code immediately does this:</p><pre><code>y = (4 / pi) * x</code></pre><p><span>which means the calling code is multiplying by a factor of pi </span><em>just so the library code can immediately divide it back out again</em><span>. It’s literally a conversion to radians and back </span><em>for no reason</em><span>. If both programmers had just agreed not to use radians, and instead used the original [0, 1] domain that </span><em>h</em><span> was already on, both their jobs get simpler: the caller saves a multiply, while the library gets a simpler-to-understand, </span><em>exact</em><span> constant.</span></p><p><span>And the “exact” part is actually quite interesting. Not only do you pay for an extra multiply when you spuriously convert to radians, but it’s also worth noting that all common radian angles besides 0 are </span><em>difficult to represent.</em><span> Want to store 90 degrees in radians? No matter how many bits you use, it will never be exact.</span></p><p><span>90 degrees on [0, 1], however, is just 0.25 - a bit pattern that </span><em>doesn’t even require any bits of mantissa at all!</em><span> 0.5? Same! 0.75? Just </span><em>one bit</em><span> of mantissa to represent exactly.</span></p><p>So the [0, 1] range is not only more computationally efficient than radians, it is also more compact and precise when representing typical values that frequently occur in practical use.</p><p>I can understand why some people would be worried about making this switch. Even if you believe me that all user-side code multiplies by pi or tau, and all library-side code divides it back out, you still may have that sinking “math class feeling” that you’d be doing something wrong if you stopped using radians.</p><p>But math never decreed that sine and cosine have to take radian arguments!</p><p><span>The idea of parameterizing a circle from zero to one instead of from zero to tau is not a random idea I made up for this blog post. It’s actually a legitimate, existing mathematical construct, and it even has a name: it’s called a </span><em><a href="https://en.wikipedia.org/wiki/Turn_(angle)#:~:text=A%20turn%20is%20a%20unit,rot.)%20or%20full%20circle." rel="">turn</a></em><span>.</span></p><p><span>In </span><em>turns</em><span>, 0 is 0 degrees, 0.5 is 180 degrees, 1 is 360 degrees, 2 is 720 degrees, and so on. It’s exactly what we wanted.</span></p><p><span>So if you are worried that your math teacher will get mad at you, there is no cause for concern. Just tell them that you considered the matter carefully, and decided that parameterizing your angles in </span><em>turns</em><span> instead of in radians was the most efficient method for the problem at hand!</span></p><p><span>If you wrote your own math library, or you copied someone else’s into your project, hopefully it is quite clear how you can switch away from radians and eliminate pi and tau from your codebase. All you have to do is take your sin and cos functions and make them take </span><em>turns </em><span>instead of radians, which usually involves nothing but a quick adjustment to a single constant.</span></p><p>If you want to support legacy code, pick a different name for the new turn-based trig functions. Then, for legacy code, you can still support the old radian-based sin and cos by making those routines thunk through to the new routines, doing the divide-by-tau along the way.</p><p>It’s very simple - just a few lines of code to make the switch.</p><p><span>However, although I find turns to be the most convenient reparameterization, it’s not the only alternative. Especially if you </span><em>don’t</em><span> roll your own math routines (and perhaps even if you do), you may instead want to consider using </span><em>half turns</em><span>, where a full circle is [0, 2]. It’s a bit more confusing, but…</span></p><p><span>It turns out (pun intended!) that if you go looking for it, in some math libraries you will already find sin and cos functions parameterized on half-turns instead of radians. For example, </span><a href="https://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__SINGLE.html#group__CUDA__MATH__SINGLE_1gab8978300988c385e0aa4b6cba44225e" rel="">the CUDA sincospi intrinsic</a><span> computes the sine and cosine of the input </span><em>multiplied by pi</em><span>, which is a half-turn.</span></p><p>This is great. If you’re targeting a platform with sincospi already available, you can stop using pi and tau constants in your code right now without touching your libraries at all. Just start calling sincospi with half-turns instead of sin and cos with radians, and you’re good to go.</p><p>Having now managed entire codebases where I stopped using radians, I can safely say I never miss them. All the superfluous tau’s and pi’s disappear, and everything reads more clearly. </p><p><span>The same logic for modifying sin and cos applies to the rest of the standard trig functions as well, so you can eliminate radians everywhere if you choose. Libraries almost always convert away from radians internally anyway, and then convert back to radians on the way out, so switching to turns or half-turns everywhere is usually just a matter of </span><em>deleting</em><span> code and not much else.</span></p></div></div></div></article></div></div></div>
  </body>
</html>
