<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jimmyhmiller.com/machine-code-isnt-scary">Original</a>
    <h1>Machine Code Isn&#39;t Scary</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>The first programming language I ever learned was ActionScript. Writing code for Macromedia&#39;s Flash might be the furthest away from &#34;bare metal&#34; as you can possibly get. As I continued learning new languages, this starting heritage stuck with me. I was mostly interested in high-level, &#34;web languages&#34;. Low-level languages felt impenetrable. Over time, I learned a bit more about them here and there, but for some reason, this notion stuck with me. Low-level things are scary, and machine code epitomized that most directly. When I Googled things asking about writing in &#34;straight machine code&#34;, I was met with discouraging messages rather than learning.</p>
<p>Eventually, I decided I needed to overcome this barrier if I was going to achieve my goals. In doing so, I learned something I didn&#39;t expect.</p>
<blockquote>
<p>Machine code isn&#39;t scary. If you can make sure your JSON conforms to a JSON schema, you can write machine code.</p>
</blockquote>
<h3>Which Machine Code?</h3>
<p>One problem with machine code is that there isn&#39;t simply one standard. There are many different &#34;instruction sets&#34; depending on the processor. Most modern PCs use x86-64 machine code, but newer Macs, Raspberry Pis, and most mobile devices use ARM. There are other architectures out there, especially as you go back in time. The goal of this article won&#39;t be to give you a deep understanding of any particular instruction set, but instead, to give you enough information about how machine code typically works so you cannot be afraid of machine code. So we will start by having our examples be in ARM 64-bit (also written as aarch64). Once we have a decent understanding of that, we will talk a bit about x86-64.</p>
<h2>Machine Code Basics</h2>
<p>To understand the basics of machine code, you need three concepts:</p>
<ol>
<li>Instructions</li>
<li>Registers</li>
<li>Memory</li>
</ol>
<p>Instructions are exactly what they sound like; they are the code that will run. Machine code instructions are just numbers. In fact, in AArch64, every instruction is a 32-bit number. Instructions encode what operation the machine should run (add, move, subtract, jump, etc.) and accept some arguments for what data to operate on. These arguments might be constants (meaning like the number 2; these constants are often called &#34;immediates&#34;), but they can also be registers or a memory address. For now, just think of a register as a variable and memory as a list.</p>
<h3>Arm Instructions</h3>
<p>Here is an example of the instruction <a href="https://developer.arm.com/documentation/ddi0596/2021-03/Base-Instructions/ADD--immediate---Add--immediate--">add immediate</a>.</p>
<div><table><thead><tr><th>31</th><th>30</th><th>29</th><th>28</th><th>27</th><th>26</th><th>25</th><th>24</th><th>23</th><th>22</th><th>21</th><th>20</th><th>19</th><th>18</th><th>17</th><th>16</th><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>sf</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>sh</td><td colspan="12">imm12</td><td colspan="5">Rn</td><td colspan="5">Rd</td></tr></tbody></table></div>
<p>Now this might look a bit confusing, but once you&#39;ve seen these tables long enough, they start to be fairly straightforward. Each column in this table represents a single bit in a 32-bit number. If the value is a 0 or 1, that just means it is already filled in. If it has a label, it is a variable that needs to be filled in. <code>sf</code> tells us whether the registers we are going to use are 64-bit or 32-bit registers. <code>sh</code> stands for shift. <code>sh</code> goes in conjunction with imm12, which stands for a 12-bit immediate (constant). So if we want to add <code>42</code> to something, we would put <code>000000101010</code> in for <code>imm12</code> and set sh to 0 (meaning we aren&#39;t shifting the number). But what if we want to represent a number larger than 12 bits? Well, the add instruction doesn&#39;t let us represent all such numbers; but setting sh to 1 lets us shift our number by 12 bits. So for example we can represent <code>172032172032</code> by leaving our 42 alone and setting sh to 1. This is a clever technique for encoding larger numbers in a small space. Variables that start with R are registers, in this case, Rn is our argument to add, and Rd is our destination.</p>
<p>So the above instruction can be thought of like this:</p>
<pre><code><span>struct</span> Add <span>{</span>
 is_sixty_four_bit<span>:</span> boolean<span>,</span>
 shift<span>:</span> boolean<span>,</span>
 immediate<span>:</span> u12<span>,</span>
 n<span>:</span> Register<span>,</span>
 destination<span>:</span> Register<span>,</span>
<span>}</span>
</code></pre>
<p>Our add instruction is really just a data structure where we put the right parts in the right places.</p>
<h2>Registers</h2>
<p>Registers are small places to store values. Every instruction set will have a different number of these registers, different sizes of registers, different kinds of registers, and different naming conventions for registers. For AArch64, there are 31 general-purpose registers numbered X0 through X30 for 64-bit registers. Let&#39;s say we want to add 42 to register X0 and store the result in X1; we use this binary number.</p>
<div><table><thead><tr><th>sf</th><th colspan="8">operation</th><th>sh</th><th colspan="12">imm12</th><th colspan="5">Rn</th><th colspan="5">Rd</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div>
<p>To encode our registers into our instruction, we just use their number. So register X0 would be 00000 and register X18 would be <code>10010</code>. Registers are simply places where we can store values. But by convention, registers can be used for different things. These are called calling conventions and they are how &#34;higher&#34; level languages like C encode function calls.</p>
<p>Writing out all these binary numbers all the time (or even converting them to hex) can often be tedious. So instead, we usually talk about instructions in a simple text format called assembly.</p>
<pre><code>add x1, x0, #0x2a 
</code></pre>
<p>In order to feel cool, people usually write numbers in assembly as hex values. This is just the number 42. You can see that assembly hides some of the details of the encoding we just made. We don&#39;t think about sf, sh, what size our number is, that a register is Rn vs Rd. Instead, the destination comes first and the arguments after. Because of this lack of detail, a single assembly instruction <code>add</code> might actually map to many different machine code instructions depending on its arguments.</p>
<h2>Memory</h2>
<p>The last piece we have to understand for machine code is memory. To understand what is going on with memory, we will look at an instruction that lets us store things in memory. This instruction is called <a href="https://developer.arm.com/documentation/ddi0602/2025-03/Base-Instructions/STR--immediate---Store-register--immediate--?lang=en#iclass_unsigned_offset">STR</a> or not written in shorthand, store.</p>
<div><table><thead><tr><th>31</th><th>30</th><th>29</th><th>28</th><th>27</th><th>26</th><th>25</th><th>24</th><th>23</th><th>22</th><th>21</th><th>20</th><th>19</th><th>18</th><th>17</th><th>16</th><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>1</td><td>x</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td colspan="12">imm12</td><td colspan="5">Rn</td><td colspan="5">Rt</td></tr></tbody></table></div>
<p>Using this instruction, we are going to store some value (RT) into the address (RN) + some offset (imm12). So if we think about memory as a big array, this instruction is like writing into that array. <code>array[offset] = value</code>. The x here is like our sf before, it controls whether we are using 64-bit values or not. If we want to make this concrete, let&#39;s say we have a value in X2, we have an address of memory in X1 and we want to store a value 2 bytes offset from that. We would get this structure:</p>
<div><table><thead><tr><th></th><th>x</th><th colspan="8">operation</th><th colspan="12">imm12</th><th colspan="5">Rn</th><th colspan="5">Rt</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table></div>
<p>Since writing that all is tedious, we often just write the assembly notation. We are storing the value in x2 based on the address stored in x1 + 2.</p>
<pre><code>str x2, [x1, #0x2]
</code></pre>
<h2>X86-64</h2>
<p>X86 encoding is a bit different, but it more or less has the same parts. We are still working with instructions, registers, and memory. Some names are a bit different. Instead of the consistent 0-30 naming, we get the historical baggage of the following 64-bit registers: rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8-r15). However, the biggest difference is that x86 is not a fixed width instruction set. We can&#39;t simply give a nice little diagram of every instruction using 32 bits. Instead, instructions are assembled from parts. These parts are given different names; when you see an instruction encoding, it tells you how to put the parts together.</p>
<h3>REX</h3>

<p>The first part is called the REX. This is a prefix that we can use to help us with 64-bit operations. Not sure if there is an official justification for the name REX, but my understanding is that it is the &#34;Register Extension Prefix&#34;. Unfortunately, because the REX is a prefix, it will only make sense when we see what comes later. REX is there for backward compatibility. The W in REX lets us signal that we are using 64-bit or not for certain operations. The R and B will &#34;extend&#34; our registers in certain operations.  In other words, it allows more registers than you used to be able to (These are those r8-r15 registers with a different naming convention than the older registers). We need these because, before 64-bit x86, we had fewer registers and our instructions only had 3 bits per register. With 16 registers, we need an extra bit. (X is for the SIB structure, which we don&#39;t cover here).</p>
<h3>ModR/M</h3>

<p>Our next part is ModR/M. ModR/M keeps up with the tradition of naming things incredibly short and confusing names. <code>mod</code> actually means Mode. <code>mod</code> tells us if <code>rm</code> is acting as a register or if it is a pointer to memory. If <code>mod == 11</code> then rm is being used as a register, otherwise, it is being used as a pointer. <code>reg</code> just is a register.</p>
<h3>OpCode</h3>
<p><code>OpCode</code> is simple, it is a number. It can be 1-3 bytes long.</p>
<h2>Putting It Together</h2>
<p>There are other parts, but we won&#39;t cover them here. With just these parts, we can build up an instruction. Let&#39;s say we want to move a 32-bit signed immediate to a 64-bit register. We can consult <a href="https://www.felixcloutier.com/x86/mov">a table of instruction encodings</a> and we will get this:</p>
<pre><code>REX.W + C7 /0 id
</code></pre>
<p>So now we can assemble our parts and make our instruction. Let&#39;s start with REX.W. This notation just means REX with W set to 1. Then there’s B8, which is just a number written in hex. <code>/0</code> is yet more shorthand for using the ModR/M but setting the reg to 0. Finally, <code>id</code> means &#34;immediate doubleword&#34;, in other words, a constant number that is 32 bits long. So given all that, we can write our instruction. So let&#39;s move the number 42 to the rbx register.</p>
<table><thead><tr><th>Byte Index</th><th>Bits</th><th>Description</th></tr></thead><tbody><tr><td>Byte 0</td><td>55–48</td><td>01001000      REX.W = 1</td></tr><tr><td>Byte 1</td><td>47–40</td><td>11000111      Opcode C7</td></tr><tr><td>Byte 2</td><td>39–32</td><td>11000011      ModR/M: reg=000, r/m=011 (RBX)</td></tr><tr><td>Byte 3</td><td>31–24</td><td>00101010      42</td></tr><tr><td>Byte 4</td><td>23–16</td><td>00000000      the rest of 42</td></tr><tr><td>Byte 5</td><td>15–8</td><td>00000000      ...</td></tr><tr><td>Byte 6</td><td>7–0</td><td>00000000      ...</td></tr></tbody></table>
<p>Why is RBX 011? Well, because <a href="https://wiki.osdev.org/X86-64_Instruction_Encoding#Registers">the table</a> says so. Yeah, I did say that x86 is a bit weird.</p>
<h2>The Rest of It</h2>
<p>I won&#39;t pretend that this is all you need. But I will say that starting here can get you further than you think. There are some other things to learn, like various flags for things like overflow, there’s also calling conventions, which are about which registers you use when for things like function calls. We haven&#39;t really talked about the stack here, but that&#39;s memory that you write to to keep track of things. Nor have we talked about jumps, or how to encode larger immediates in ARM, but you’ve gotten the basics. It’s easier than you would think to hop on <a href="https://godbolt.org/">compiler explorer</a> and learn how things are done.</p>
<p>Learning machine code and writing things at this low level has unlocked so many things that were mental blocks for me before. Relying on libraries made by others to do these low-level things always left a gap in my knowledge that made me doubt my understanding. Even if I intellectually could explain things, actually doing them has made a huge difference for me. So if you, like me, find low-level things intimidating, I can&#39;t recommend enough starting from scratch, at the lowest possible level for your task. What I&#39;ve found over and over again with low-level details, their not hard, their just poorly documented and poorly explained.</p></div></div>
  </body>
</html>
