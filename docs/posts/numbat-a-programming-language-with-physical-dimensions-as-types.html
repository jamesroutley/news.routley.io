<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://numbat.dev/articles/intro.html">Original</a>
    <h1>Show HN: Numbat – A programming language with physical dimensions as types</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><i>Part I: The type system</i></p>

    <p>Numbat is a programming language that aims to provide a convenient way
    to perform computations with physical units.
    One of the main goals of the language is to help users write <em>correct</em> programs.

    It has a static type system where <em>physical dimensions</em> act as types.
    The expression <code><span>3</span> <span>months</span></code>, for example, has a <em>type</em> of <code>Time</code>.
    Similarly, the expression <code><span>2</span> <span>years</span></code> also has a type of <code>Time</code>.
    The compound expression <code><span>3</span> <span>months</span> + <span>2</span> <span>years</span></code> is therefore well-typed:
    </p>

    <p>3 months + 2 years    # you can edit these examples!</p>
    <pre id="output1"></pre>

    <p>
    On the other hand, <code><span>3</span> <span>months</span> + <span>2</span> <span>lightyears</span></code> is <em>ill</em>-typed, because the right-hand side is of type <code>Length</code>.
    You can change ‘years’ to ‘lightyears’ in the editor above to see the resulting compiler error.
    </p>

    <p>
    Before we describe the type system in more detail, let&#39;s look at two simple examples. The first program
    computes the oscillation period of a (mathematical) pendulum using the gravitational acceleration
    <code>g0</code>.
    Note that you can change the unit of the pendulum length to, say, <code span="numbat-unit">inch</code> without
    having to change the type annotations. This is in contrast to a lot of unit libraries in other
    programming languages that typically lift <em>units</em> — not the physical dimensions — to the type level.

    Also, note that you can completely remove the explicit <code><span>:</span> <span>Type</span></code> annotations and let the compiler infer the types:
    </p>

    <p>let pendulum_length: Length = 30 cm
let t_oscillation: Time = 2 π sqrt(pendulum_length / g0)

t_oscillation</p>
    <pre id="output2"></pre>

    

    <p>The second example demonstrates how explicit type annotations
    can help avoid mistakes. We want to compute the ratio of gravitational forces exerted on Earth by both the Sun and the Moon.
    However, the computation contains a mistake. Try to annotate the definitions of <code>force_sun</code> and <code>force_moon</code> with the intended <span>Force</span> dimension
    and see if the compiler error can help you fix the <a href="https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation">equations</a>.
    The correct result should be closer to <code>180</code>.
    </p>

    <p>let distance_sun: Length = 1 AU  # astronomical unit
let distance_moon: Length = 384_400 km

let force_sun = G * earth_mass * solar_mass / distance_sun
let force_moon = G * earth_mass * lunar_mass / distance_moon

force_sun / force_moon</p>
    <pre id="output3"></pre>

    

    <p>
        A type in Numbat can be one of three things. It can be <code>1</code> — which is a special type for dimensionless quantities, it can be a base dimension, or it can be an algebraic combination of other types.
        We use the <code>dimension</code> keyword to introduce new types. For example, this
        is how basic physical dimensions from classical mechanics are defined in Numbat&#39;s <a href="https://github.com/sharkdp/numbat/tree/master/numbat/modules">prelude</a>:
    </p>

    <p>dimension Length
dimension Area = Length²

dimension Time
dimension Frequency = 1 / Time
dimension Velocity = Length / Time
dimension Acceleration = Length / Time²

dimension Mass
dimension Force = Mass × Acceleration
dimension Pressure = Force / Area
dimension Energy = Force × Length
dimension Power = Energy / Time</p>

    <p>
        Note how the three base dimensions <em>length</em>, <em>time</em> and <em>mass</em> can be combined using multiplication, division and exponentiation. Now there is not a lot we can do with those types until we
        introduce corresponding <em>units</em> to build quantities that inhabit those types:
    </p>

    <p>unit metre: Length
unit second: Time
unit kilogram: Mass  # in the real prelude, we properly handle prefixes

unit hertz: Frequency = 1 / second
unit newton: Force = kilogram metre / second²
unit pascal: Pressure = newton / metre²
unit joule: Energy = newton metre
unit watt: Power = joule / second

2 * newton + 1 * watt / (metre / second)</p>
    <pre id="output4and5"></pre>

    <p>
    Now take a look at the last line. When the type checker encounters an expression like this, it infers
    the overall type (<code>Force</code>) by recursively walking the
    syntax tree. Multiplication and division nodes are easy. We simply combine the types
    in the same way that we combine the expressions:
    </p>

    <pre><span>type</span>(a * b) = <span>type</span>(a) * <span>type</span>(b)
<span>type</span>(a / b) = <span>type</span>(a) / <span>type</span>(b)</pre>

    <p>
    However, addition and subtraction are different. If the types
    on both hand sides are the same, we return that type. If they are not, we raise a type check
    error:
    </p>

    <pre><span>type</span>(a + b) =
  <b>if</b> <span>type</span>(a) == <span>type</span>(b) {
    <span>type</span>(a)
  } <b>else</b> {
    error(<span>&#34;incompatible dimensions in addition …&#34;</span>)
  }</pre>

    <p>
    Comparison operators like <code>==</code> or <code>&gt;</code> also work in a
    similar way — can&#39;t compare apples and oranges — except that they return a boolean type. You can try this by replacing addition with a comparison operator in the
    example above.</p>


    <p>
    Finally, there is exponentiation: <code>a^b</code>. And it turns out to be quite a bit more complicated.
    We first note that the exponent <code>b</code> needs to be dimensionless. An expression like <code>(<span>2</span> <span>m</span>)^(<span>3</span> <span>kg</span>)</code> is not
    meaningful. But even then there is a problem. Imagine something like <code>(<span>2</span> <span>m</span>)^(<span>1</span> + <span>2</span>)</code>. It should have a type of <code><span>Length</span>^<span>3</span></code>. But this means that the <em>type</em> of the expression depends on the <em>value</em> of the exponent. It turns out we need to <em>evaluate</em> the expression
    <code>b</code> <em>at compile time</em> to determine the type of <code>a^b</code>:
    </p>

    <pre><span>type</span>(a ^ b) =
  <b>if</b> <span>type</span>(b) != <span>1</span> {
    error(<span>&#34;exponent needs to be dimensionless&#34;</span>)
  } <b>else</b> {
      <b>if</b> <span>type</span>(a) == <span>1</span> {
        <span>1</span>
      } <b>else</b> {
        <span>type</span>(a) ^ <span>consteval</span>(b)
      }
  }</pre>

    <p>
    Numbat therefore has a special const-evaluation mode that can compute a subset of expressions as part of the type-checking phase.
    Note that the restriction to a subset of operations is not a limitation in practice. Real world computations often have complicated expressions in the exponent.
    But in those cases, the left-hand side (<code>a</code>) is always dimensionless and the overall type is simply <code>1</code>. And when <code>a</code> is not dimensionless, the exponent expression is typically just a (rational) number.</p>

    <p>fn my_sqrt&lt;D&gt;(x: D^2) -&gt; D = x^(1/2)

my_sqrt(ℏ G / c^5)  # Planck time</p>
    <pre id="output6"></pre>

    <p>
    Here, <code>D</code> is a generic type parameter. The function takes an argument of type
    <code><span>D</span>^<span>2</span></code> and returns a <code>D</code>. In the example here, it turns
    <code><span>Time</span>^<span>2</span></code> into <code>Time</code>.
    In general, type inference for functions is <a href="https://github.com/sharkdp/numbat/issues/29">an interesting topic</a> for another day.
    </p>

    <p>
    Our final example demonstrates how you can make use of custom dimensions and units. This
    is often useful when you want to count things (people, atoms, pixels, or in this case: drops).
    Say we want to compute the required IV drip rate for an infusion of 1200 mL of saline solution
    over 6 hours. Even if it might look like overkill in this simple example, note how the
    introduction of a new unit not just helps with correctness, but also with readability:
    </p>

    <p>unit drops  # Implicitly creates a new base dimension &#39;Drops&#39;

dimension DripRate = Drops / Time

let saline_volume = 1200 mL
let drop_factor = 15 drops / mL
let total_time = 6 hours

let iv_drip_rate = saline_volume * drop_factor / total_time

iv_drip_rate -&gt; drops / min</p>
    <pre id="output7"></pre>

    

</article></div>
  </body>
</html>
