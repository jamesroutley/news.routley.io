<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.meca.sh/3lxoty3shjc2z">Original</a>
    <h1>Next.js is infuriating</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content"><p id="0" data-index="0"><span>Hey, it&#39;s finally happened. I&#39;ve decided to write a blog post. And if you&#39;re reading this, I&#39;ve also finished one. I have wanted to do this for a long time, but could never find the motivation to start. But you know what they say: anger is the best motivator. They do say that, right?</span></p><h3 id="1" data-index="1"><span>Some context that&#39;s in the background</span></h3><p id="2" data-index="2"><span>We&#39;re going on a journey, you and I. But first, we need to set the scene. Imagine we&#39;re working for </span><span>$COMPANY</span><span> and one of our Next.js services did an oopsie. This being Next.js, we of course have no idea what actually happened since the default logging is only enabled during development.</span></p><p id="3" data-index="3"><span>Our quest is to go in and setup some production ready logging. It&#39;s not going to be easy, but then again, nothing ever is.</span></p><h3 id="4" data-index="4"><span>Middleware? Middle of nowhere!</span></h3><p id="5" data-index="5"><span>The first step of our journey is the middleware. </span><a href="https://nextjs.org/docs/app/api-reference/file-conventions/middleware" target="_blank">The documentation even states this</a><span>:</span></p><blockquote id="6" data-index="6"><span>Middleware executes before routes are rendered. It&#39;s particularly useful for implementing custom server-side logic like authentication, </span><span>logging</span><span>, or handling redirects.</span></blockquote><p id="7" data-index="7"><span>Alright, looks simple enough. Time to pick a logging library. I went with </span><a href="https://github.com/pinojs/pino" target="_blank">pino</a><span> since we have used it before. Anything is an upgrade over </span><code>console.log</code><span> anyways. We&#39;ll get this done before lunch.</span></p><p id="8" data-index="8"><span>Let&#39;s set up a basic middleware:</span></p><div><pre tabindex="0"><code><span><span>// middleware.ts</span></span>
<span><span>import</span><span> { NextResponse, NextRequest } </span><span>from</span><span> &#34;next/server&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> async</span><span> function</span><span> middleware</span><span>(</span><span>request</span><span>:</span><span> NextRequest</span><span>) {</span></span>
<span><span>  return</span><span> new</span><span> NextResponse.</span><span>next</span><span>({</span></span>
<span><span>    request: request,</span></span>
<span><span>    headers: request.headers,</span></span>
<span><span>    // status: 200,</span></span>
<span><span>    // statusText: &#39;OK&#39;</span></span>
<span><span>  });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>export</span><span> const</span><span> config</span><span> =</span><span> {</span></span>
<span><span>  matcher: </span><span>&#34;/:path*&#34;</span><span>,</span></span>
<span><span>};</span></span></code></pre></div><p id="10" data-index="10"><span>I think we already have a problem here. You can pass a grand total of 4 parameters from your middleware. The only thing that actually affects the invoked route is the </span><code>headers</code><span>. Let&#39;s not skip over the fact that you can&#39;t have multiple middlewares or chain them either. How do you fuck this up so bad? We&#39;ve had middlewares since at least the early 2010s when Express came out.</span></p><p id="11" data-index="11"><span>Anyways, we&#39;re smart and modern Node.js has some pretty nifty tools. Let&#39;s reach for </span><code>AsyncLocalStorage</code><span>.</span></p><div><pre tabindex="0"><code><span><span>// app/logger.ts</span></span>
<span><span>import</span><span> { AsyncLocalStorage } </span><span>from</span><span> &#34;async_hooks&#34;</span><span>;</span></span>
<span><span>import</span><span> { Logger, pino } </span><span>from</span><span> &#34;pino&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> loggerInstance</span><span> =</span><span> pino</span><span>({</span></span>
<span><span>  // Whatever config we need</span></span>
<span><span>  level: process.env.</span><span>LOG_LEVEL</span><span> ??</span><span> &#34;trace&#34;</span><span>,</span></span>
<span><span>});</span></span>
<span></span>
<span><span>export</span><span> const</span><span> LoggerStorage</span><span> =</span><span> new</span><span> AsyncLocalStorage</span><span>&lt;</span><span>Logger</span><span>&gt;();</span></span>
<span></span>
<span><span>export</span><span> function</span><span> logger</span><span>()</span><span>:</span><span> Logger</span><span> |</span><span> null</span><span> {</span></span>
<span><span>  return</span><span> LoggerStorage.</span><span>getStore</span><span>() </span><span>??</span><span> null</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>export</span><span> function</span><span> requestLogger</span><span>()</span><span>:</span><span> Logger</span><span> {</span></span>
<span><span>  return</span><span> loggerInstance.</span><span>child</span><span>({ requestId: crypto.</span><span>randomUUID</span><span>() });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// middleware.ts</span></span>
<span><span>export</span><span> async</span><span> function</span><span> middleware</span><span>(</span><span>request</span><span>:</span><span> NextRequest</span><span>) {</span></span>
<span><span>  LoggerStorage.</span><span>enterWith</span><span>(</span><span>requestLogger</span><span>());</span></span>
<span><span>  logger</span><span>()?.</span><span>debug</span><span>({ url: request.url }, </span><span>&#34;Started processing request!&#34;</span><span>);</span></span>
<span></span>
<span><span>  return</span><span> NextResponse.</span><span>next</span><span>();</span></span>
<span><span>}</span></span></code></pre></div><p id="13" data-index="13"><span>Whew, hard work done. Let&#39;s test it out. Visit </span><a href="https://localhost:3000" target="_blank">localhost:3000</a><span> and we see this:</span></p><div><pre tabindex="0"><code><span><span>{ requestId: &#39;ec7718fa-b1a2-473e-b2e2-8f51188efa8f&#39; } { url: &#39;http://localhost:3000/&#39; } &#39;Started processing request!&#39;</span></span>
<span><span> GET / 200 in 71ms</span></span>
<span><span>{ requestId: &#39;09b526b1-68f4-4e90-971f-b0bc52ad167c&#39; } { url: &#39;http://localhost:3000/next.svg&#39; } &#39;Started processing request!&#39;</span></span>
<span><span>{ requestId: &#39;481dd2ff-e900-4985-ae15-0b0a1eb5923f&#39; } { url: &#39;http://localhost:3000/vercel.svg&#39; } &#39;Started processing request!&#39;</span></span>
<span><span>{ requestId: &#39;e7b29301-171c-4c91-af25-771471502ee4&#39; } { url: &#39;http://localhost:3000/file.svg&#39; } &#39;Started processing request!&#39;</span></span>
<span><span>{ requestId: &#39;13766de3-dd00-42ce-808a-ac072dcfd4c6&#39; } { url: &#39;http://localhost:3000/window.svg&#39; } &#39;Started processing request!&#39;</span></span>
<span><span>{ requestId: &#39;317e054c-1a9a-4dd8-ba21-4c0201fbeada&#39; } { url: &#39;http://localhost:3000/globe.svg&#39; } &#39;Started processing request!&#39;</span></span></code></pre></div><p id="15" data-index="15"><span>I don&#39;t know if you&#39;ve ever used pino before, but this is wrong. Can you figure out why?</span></p><p id="16" data-index="16"><span>Unlike Next.js I won&#39;t keep you waiting in limbo. This is the browser output. Why? Well, it&#39;s because the default Next.js middleware runtime is </span><code>edge</code><span>. We can of course switch to the </span><code>nodejs</code><span> runtime which should work. Except, of course, it might not.</span></p><p id="17" data-index="17"><span>I&#39;ve tried it on a fresh Next.js project and it does work. But it didn&#39;t when I was trying it out on our actual project. I swear I&#39;m not crazy. Anyways, this isn&#39;t the main issue. We&#39;re slowly getting there.</span></p><h3 id="18" data-index="18"><span>Paging the local mental asylum</span></h3><p id="19" data-index="19"><span>Logging in the middleware is cool and all, but it&#39;s not where the bulk of the magic happens. For that, we need to log in pages and layouts. Let&#39;s try it out.</span></p><div><pre tabindex="0"><code><span><span>// app/page.tsx</span></span>
<span><span>export</span><span> default</span><span> function</span><span> Home</span><span>() {</span></span>
<span><span>  logger</span><span>()?.</span><span>info</span><span>(</span><span>&#34;Logging from the page!&#34;</span><span>);</span></span>
<span></span>
<span><span>  return</span><span> &lt;</span><span>div</span><span>&gt;Real simple website</span><span>!&lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>}</span></span></code></pre></div><p id="21" data-index="21"><span>Refresh the page and we get this:</span></p><div><pre tabindex="0"><code><span><span>✓ Compiled / in 16ms</span></span>
<span><span> GET / 200 in 142ms</span></span></code></pre></div><p id="23" data-index="23"><span>That&#39;s it? That&#39;s it. Nothing. Nada. Zilch.</span></p><p id="24" data-index="24"><span>For posterity&#39;s sake, this is what it&#39;s supposed to look like:</span></p><div><pre tabindex="0"><code><span><span>✓ Compiled / in 2.2s</span></span>
<span><span>[11:38:59.259] INFO (12599): Logging from the page!</span></span>
<span><span>    requestId: &#34;2ddef9cf-6fee-4d1d-8b1e-6bb16a3e636b&#34;</span></span>
<span><span> GET / 200 in 2520ms</span></span></code></pre></div><p id="26" data-index="26"><span>Ok,this is getting a bit long, so I&#39;ll get to the point. The </span><code>logger</code><span> function returns </span><code>null</code><span>. Why? I&#39;m not entirely sure, but it seems like rendering is not executed in the same async context as the middleware.</span></p><p id="27" data-index="27"><span>What&#39;s the solution then? You&#39;re not going to believe this. Remember how the only value you can pass from the middleware is </span><code>headers</code><span>? Yeah. That&#39;s what we need to use.</span></p><p id="28" data-index="28"><span>The following is for people with strong stomachs:</span></p><div><pre tabindex="0"><code><span><span>// app/log/serverLogger.ts</span></span>
<span><span>import</span><span> { pino } </span><span>from</span><span> &#34;pino&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> const</span><span> loggerInstance</span><span> =</span><span> pino</span><span>({</span></span>
<span><span>  // Whatever config we need</span></span>
<span><span>  level: process.env.</span><span>LOG_LEVEL</span><span> ??</span><span> &#34;info&#34;</span><span>,</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// app/log/middleware.ts</span></span>
<span><span>// Yes, we need to split up the loggers ...</span></span>
<span><span>// Mostly the same as before</span></span>
<span><span>import</span><span> { loggerInstance } </span><span>from</span><span> &#34;./serverLogger&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> function</span><span> requestLogger</span><span>(</span><span>requestId</span><span>:</span><span> string</span><span>)</span><span>:</span><span> Logger</span><span> {</span></span>
<span><span>  return</span><span> loggerInstance.</span><span>child</span><span>({ requestId });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// app/log/server.ts</span></span>
<span><span>import</span><span> { headers } </span><span>from</span><span> &#34;next/headers&#34;</span><span>;</span></span>
<span><span>import</span><span> { loggerInstance } </span><span>from</span><span> &#34;./serverLogger&#34;</span><span>;</span></span>
<span><span>import</span><span> { Logger } </span><span>from</span><span> &#34;pino&#34;</span><span>;</span></span>
<span><span>import</span><span> { NextRequest } </span><span>from</span><span> &#34;next/server&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> REQUEST_ID_HEADER</span><span> =</span><span> &#34;dominik-request-id&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> function</span><span> requestHeaders</span><span>(</span></span>
<span><span>  request</span><span>:</span><span> NextRequest</span><span>,</span></span>
<span><span>  requestId</span><span>:</span><span> string</span><span>,</span></span>
<span><span>)</span><span>:</span><span> Headers</span><span> {</span></span>
<span><span>  const</span><span> head</span><span> =</span><span> new</span><span> Headers</span><span>(request.headers);</span></span>
<span><span>  head.</span><span>set</span><span>(</span><span>REQUEST_ID_HEADER</span><span>, requestId);</span></span>
<span><span>  return</span><span> head;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Yeah, this has to be async ...</span></span>
<span><span>export</span><span> async</span><span> function</span><span> logger</span><span>()</span><span>:</span><span> Promise</span><span>&lt;</span><span>Logger</span><span>&gt; {</span></span>
<span><span>  const</span><span> hdrs</span><span> =</span><span> await</span><span> headers</span><span>();</span></span>
<span><span>  const</span><span> requestId</span><span> =</span><span> hdrs.</span><span>get</span><span>(</span><span>REQUEST_ID_HEADER</span><span>);</span></span>
<span></span>
<span><span>  return</span><span> loggerInstance.</span><span>child</span><span>({ requestId });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// middleware.ts</span></span>
<span><span>import</span><span> { logger, LoggerStorage, requestLogger } </span><span>from</span><span> &#34;./app/log/middleware&#34;</span><span>;</span></span>
<span><span>import</span><span> { requestHeaders } </span><span>from</span><span> &#34;./app/log/server&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> async</span><span> function</span><span> middleware</span><span>(</span><span>request</span><span>:</span><span> NextRequest</span><span>) {</span></span>
<span><span>  const</span><span> requestId</span><span> =</span><span> crypto.</span><span>randomUUID</span><span>();</span></span>
<span><span>  LoggerStorage.</span><span>enterWith</span><span>(</span><span>requestLogger</span><span>(requestId));</span></span>
<span></span>
<span><span>  logger</span><span>()?.</span><span>debug</span><span>({ url: request.url }, </span><span>&#34;Started processing request!&#34;</span><span>);</span></span>
<span></span>
<span><span>  return</span><span> NextResponse.</span><span>next</span><span>({ headers: </span><span>requestHeaders</span><span>(request, requestId) });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// app/page.tsx</span></span>
<span><span>export</span><span> default</span><span> async</span><span> function</span><span> Home</span><span>() {</span></span>
<span><span>  (</span><span>await</span><span> logger</span><span>())?.</span><span>info</span><span>(</span><span>&#34;Logging from the page!&#34;</span><span>);</span></span>
<span></span>
<span><span>  // ...</span></span>
<span><span>}</span></span></code></pre></div><p id="30" data-index="30"><span>Isn&#39;t it beautiful? I especially appreciate how it&#39;s now possible to import the middleware logging code from the server. Which of course won&#39;t work. Or import the server logging code from the middleware. Which also won&#39;t work. Better not mess up. Also, we haven&#39;t even touched upon logging in client components, which despite the name also run on the server. Yeah, that&#39;s a third split.</span></p><h3 id="31" data-index="31"><span>Congratulations, you&#39;re being coddled. Please do not resist.</span></h3><p id="32" data-index="32"><span>Listen. I wanted to apologize, because I&#39;ve led you into this trap. You see, I have already fallen into it several times before. A middleware system can be pretty useful when designed correctly and I wanted you to see what it looks like when it&#39;s not. The reason for writing this blog post actually started here.</span></p><p id="33" data-index="33"><span>I think every one of us has reached a point in their lives where they&#39;ve had enough. For me, it was right here. Fuck it, let&#39;s use a </span><a href="https://nextjs.org/docs/app/guides/custom-server" target="_blank">custom server</a><span>.</span></p><blockquote id="34" data-index="34"><span>A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it&#39;s available if you need to eject.</span></blockquote><p id="35" data-index="35"><span>Let&#39;s take a look at the example from the documentation:</span></p><div><pre tabindex="0"><code><span><span>import</span><span> { createServer } </span><span>from</span><span> &#39;http&#39;</span></span>
<span><span>import</span><span> { parse } </span><span>from</span><span> &#39;url&#39;</span></span>
<span><span>import</span><span> next </span><span>from</span><span> &#39;next&#39;</span></span>
<span><span> </span></span>
<span><span>const</span><span> port</span><span> =</span><span> parseInt</span><span>(process.env.</span><span>PORT</span><span> ||</span><span> &#39;3000&#39;</span><span>, </span><span>10</span><span>)</span></span>
<span><span>const</span><span> dev</span><span> =</span><span> process.env.</span><span>NODE_ENV</span><span> !==</span><span> &#39;production&#39;</span></span>
<span><span>const</span><span> app</span><span> =</span><span> next</span><span>({ dev })</span></span>
<span><span>const</span><span> handle</span><span> =</span><span> app.</span><span>getRequestHandler</span><span>()</span></span>
<span><span> </span></span>
<span><span>app.</span><span>prepare</span><span>().</span><span>then</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  createServer</span><span>((</span><span>req</span><span>, </span><span>res</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    const</span><span> parsedUrl</span><span> =</span><span> parse</span><span>(req.url</span><span>!</span><span>, </span><span>true</span><span>)</span></span>
<span><span>    handle</span><span>(req, res, parsedUrl)</span></span>
<span><span>  }).</span><span>listen</span><span>(port)</span></span>
<span><span> </span></span>
<span><span>  console.</span><span>log</span><span>(</span></span>
<span><span>    `&gt; Server listening at http://localhost:${</span><span>port</span><span>} as ${</span></span>
<span><span>      dev</span><span> ?</span><span> &#39;development&#39;</span><span> :</span><span> process</span><span>.</span><span>env</span><span>.</span><span>NODE_ENV</span></span>
<span><span>    }`</span></span>
<span><span>  )</span></span>
<span><span>})</span></span></code></pre></div><p id="37" data-index="37"><span>Note that once again, </span><code>handle</code><span> doesn&#39;t really take any parameters. Only the request URL and the raw request and response.</span></p><p id="38" data-index="38"><span>Anyways, we still have </span><code>AsyncLocalStorage</code><span> so this doesn&#39;t concern us too much. Let&#39;s modify the example a bit.</span></p><div><pre tabindex="0"><code><span><span>// app/logger.ts</span></span>
<span><span>// Reverted back to our AsyncLocalStorage variaton</span></span>
<span><span>import</span><span> { pino, Logger } </span><span>from</span><span> &#34;pino&#34;</span><span>;</span></span>
<span><span>import</span><span> { AsyncLocalStorage } </span><span>from</span><span> &#34;async_hooks&#34;</span><span>;</span></span>
<span></span>
<span><span>const</span><span> loggerInstance</span><span> =</span><span> pino</span><span>({</span></span>
<span><span>  // Whatever config we need</span></span>
<span><span>  level: process.env.</span><span>LOG_LEVEL</span><span> ??</span><span> &#34;info&#34;</span><span>,</span></span>
<span><span>});</span></span>
<span></span>
<span><span>export</span><span> const</span><span> LoggerStorage</span><span> =</span><span> new</span><span> AsyncLocalStorage</span><span>&lt;</span><span>Logger</span><span>&gt;();</span></span>
<span></span>
<span><span>export</span><span> function</span><span> logger</span><span>()</span><span>:</span><span> Logger</span><span> |</span><span> null</span><span> {</span></span>
<span><span>  return</span><span> LoggerStorage.</span><span>getStore</span><span>() </span><span>??</span><span> null</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>export</span><span> function</span><span> requestLogger</span><span>()</span><span>:</span><span> Logger</span><span> {</span></span>
<span><span>  return</span><span> loggerInstance.</span><span>child</span><span>({ requestId: crypto.</span><span>randomUUID</span><span>() });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// server.ts</span></span>
<span><span>import</span><span> { logger, LoggerStorage, requestLogger } </span><span>from</span><span> &#34;./app/logger&#34;</span><span>;</span></span>
<span></span>
<span><span>app.</span><span>prepare</span><span>().</span><span>then</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>  createServer</span><span>(</span><span>async</span><span> (</span><span>req</span><span>, </span><span>res</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    // This is new</span></span>
<span><span>    LoggerStorage.</span><span>enterWith</span><span>(</span><span>requestLogger</span><span>());</span></span>
<span><span>    logger</span><span>()?.</span><span>info</span><span>({}, </span><span>&#34;Logging from server!&#34;</span><span>);</span></span>
<span></span>
<span><span>    const</span><span> parsedUrl</span><span> =</span><span> parse</span><span>(req.url</span><span>!</span><span>, </span><span>true</span><span>);</span></span>
<span><span>    await</span><span> handle</span><span>(req, res, parsedUrl);</span></span>
<span><span>  }).</span><span>listen</span><span>(port);</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// middleware.ts</span></span>
<span><span>import</span><span> { logger } </span><span>from</span><span> &#34;./app/logger&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> async</span><span> function</span><span> middleware</span><span>(</span><span>request</span><span>:</span><span> NextRequest</span><span>) {</span></span>
<span><span>  logger</span><span>()?.</span><span>info</span><span>({}, </span><span>&#34;Logging from middleware!&#34;</span><span>);</span></span>
<span><span>  return</span><span> NextResponse.</span><span>next</span><span>();</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// app/page.tsx</span></span>
<span><span>import</span><span> { logger } </span><span>from</span><span> &#34;./logger&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> default</span><span> async</span><span> function</span><span> Home</span><span>() {</span></span>
<span><span>  logger</span><span>()?.</span><span>info</span><span>(</span><span>&#34;Logging from the page!&#34;</span><span>);</span></span>
<span><span>  </span></span>
<span><span>  // ...</span></span>
<span><span>}</span></span></code></pre></div><p id="40" data-index="40"><span>Ok, let&#39;s test it out. Refresh the browser and ...</span></p><div><pre tabindex="0"><code><span><span>&gt; Server listening at http://localhost:3000 as development</span></span>
<span><span>[12:29:52.183] INFO (19938): Logging from server!</span></span>
<span><span>    requestId: &#34;2ffab9a2-7e15-4188-8959-a7822592108f&#34;</span></span>
<span><span> ✓ Compiled /middleware in 388ms (151 modules)</span></span>
<span><span> ○ Compiling / ...</span></span>
<span><span> ✓ Compiled / in 676ms (769 modules)</span></span></code></pre></div><p id="42" data-index="42"><span>That&#39;s it. Are you fucking kidding me right now? What the fuck?</span></p><p id="43" data-index="43"><span>Now, you might be thinking that this is just not how </span><code>AsyncLocalStorage</code><span> works. And you might be right. But I would like to point out that </span><code>headers()</code><span> and </span><code>cookies()</code><span> use </span><code>AsyncLocalStorage</code><span>. This is a power that the Next.js devs have that we don&#39;t.</span></p><p id="44" data-index="44"><span>As far as I can tell there are only two ways to pass information from a middleware to a page.</span></p><ul><li><p id="45.0" data-index="45.0"><span>Headers</span></p></li><li><p id="45.1" data-index="45.1"><code>NextResponse.redirect</code><span> / </span><code>NextResponse.rewrite</code><span> to a route with extra params (eg. </span><span>/[requestId]/page.tsx</span><span>)</span></p></li></ul><p id="46" data-index="46"><span>As you might have noticed, neither of these are very pleasant to use in this case.</span></p><p id="47" data-index="47"><span>You are being coddled. The Next.js devs have a vision and it&#39;s either their way or the highway. Note that if it was just the middleware, I wouldn&#39;t be sitting here, wasting away my weekend, ranting about a React framework. Believe it or not, I&#39;ve got better things to do. It&#39;s constant pain you encounter daily when working with Next.js.</span></p><h3 id="48" data-index="48"><span>Vercel can do better</span></h3><p id="49" data-index="49"><span>What&#39;s infuriating about this example is that Vercel can very much do better. I don&#39;t want to sing too many praises at Svelte(Kit) because I have some misgivings about its recent direction, but it&#39;s so much better than Next.js. </span><a href="https://svelte.dev/docs/kit/hooks#Server-hooks" target="_blank">Let&#39;s look at their middleware docs</a><span>:</span></p><blockquote id="50" data-index="50"><span>handle </span><span>- This function runs every time the SvelteKit server receives a request [...] This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).</span></blockquote><p id="51" data-index="51"><span>Looking good so far.</span></p><blockquote id="52" data-index="52"><span>locals</span><span> - To add custom data to the request, which is passed to handlers in </span><code>+server.js</code><span> and server </span><code>load</code><span> functions, populate the </span><code>event.locals</code><span> object, as shown below.</span></blockquote><p id="53" data-index="53"><span>I&#39;m crying tears of joy right now. You can also stuff real objects/classes in there. Like a logger for instance.</span></p><blockquote id="54" data-index="54"><span>You can define multiple handle functions and execute them with sequence.</span></blockquote><p id="55" data-index="55"><span>This is what real engineering looks like. SvelteKit is a Vercel product. How is the flagship offering worse than what is essentially a side project. What the hell?</span></p><h3 id="56" data-index="56"><span>Scientists discover a new super massive black hole at </span><a href="https://github.com/vercel/next.js/issues" target="_blank">https://github.com/vercel/next.js/issues</a></h3><p id="57" data-index="57"><span>I don&#39;t have anything else to add, but while I&#39;m here I feel like I have to talk about the GitHub issue tracker. This is perhaps the crown jewel of the dumpster fire that is Next.js. It&#39;s a place where hopes and issues come to die. The mean response time for a bug report is </span><span>never</span><span>. I&#39;ve made it a sport to search the issue tracker/discussion for problems I&#39;m currently facing and bet on how many years it takes to even get a response from a Next.js dev.</span></p><p id="58" data-index="58"><span>You think I&#39;m joking? There are hundreds of issues with as many 👍 emojis with no official response for years. And when you finally get a response, it&#39;s to tell you that what you&#39;re doing is wrong and a solution to your </span><span>real </span><span>problems is on the way. Then they proceed to keep the &#34;solution&#34; in canary for years on end.</span></p><p id="59" data-index="59"><span>I personally reported two issues a year ago. Keep in mind that to have a valid bug report, you need a reproduction.</span></p><ul><li></li><li></li></ul><p id="61" data-index="61"><span>So, what do you get for taking the time to make a minimal reproduction? That&#39;s right. Complete silence.</span></p><p id="62" data-index="62"><span>I would have reported about a dozen other issues I have encountered, but after this experience I gave up.</span></p><p id="63" data-index="63"><span>Honestly, I don&#39;t even know if the issues are still valid. </span></p><h3 id="64" data-index="64"><span>Have we learned anything?</span></h3><p id="65" data-index="65"><span>I don&#39;t know. For me, personally, I don&#39;t want to use Next.js anymore. You might think that this is just a singular issue and I&#39;m overreacting. But there&#39;s bugs and edge cases around every corner. How did they manage to make TypeScript compile slower than Rust? Why make a distinction between code running on client and server and then not give me any tools to take advantage of that? Why? Why? Why?</span></p><p id="66" data-index="66"><span>I don&#39;t think I quite have enough pull to move us out of Next.js land. But, I think I will voice my opinion if we end up writing another app. We&#39;ll see if the grass is any greener on the other side.</span></p></div></div>
  </body>
</html>
