<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://davedelong.com/blog/2022/12/03/adventures-in-advent-of-code/">Original</a>
    <h1>Adventures in Advent of Code</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    


    

    
    
    
    


    

    
    
    
    


    

    
    
    
    




    <p>I‚Äôve been participating regularly in <a href="https://adventofcode.com">Advent of Code</a> for the past couple of years. It‚Äôs one of the highlights of my holiday season. The puzzles are fun, the stories are appropriately ridiculous, and it‚Äôs a neat way for me to keep the cobwebs brushed off some of the things I learned years ago that I don‚Äôt regularly use. Every year there are puzzles that take me a couple of minutes to solve, and puzzles that take me hours: I will forever curse the Intcode puzzles from 2019.</p>

<p><a href="https://adventofcode.com/2022/day/3">Last night‚Äôs puzzle</a> was something new. The problem itself was pretty straight-forward (finding values that are common in multiple collections), but it resulted in a 45-minute debugging session that culminated in finding a bug in Swift‚Äôs implementation of <a href="https://developer.apple.com/documentation/swift/set/intersection(_:)-6uts9"><code>Set.intersection(_:)</code></a>.</p>

<p>The nature of last night‚Äôs problem was that, when I had a bunch of inputs, I could expect that there was only a single common element between all of them. After getting lucky and solving the problem correctly, I started <a href="https://en.wikipedia.org/wiki/Code_golf">golfing</a> my code to make it terser. That‚Äôs when I started noticing something odd.</p>

<p>My initial version of the code looked something like this:</p>

<div><div><pre><code><span>let</span> <span>firstGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>
<span>let</span> <span>secondGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>
<span>let</span> <span>thirdGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>

<span>let</span> <span>uniqueLettersInFirstGroup</span> <span>=</span> <span>Set</span><span>(</span><span>firstGroup</span><span>)</span>
<span>let</span> <span>uniqueLettersInSecondGroup</span> <span>=</span> <span>Set</span><span>(</span><span>secondGroup</span><span>)</span>
<span>let</span> <span>uniqueLettersInThirdGroup</span> <span>=</span> <span>Set</span><span>(</span><span>thirdGroup</span><span>)</span>

<span>let</span> <span>commonLetters</span> <span>=</span> <span>uniqueLettersInFirstGroup</span><span>.</span><span>intersection</span><span>(</span><span>uniqueLettersInSecondGroup</span><span>)</span><span>.</span><span>intersection</span><span>(</span><span>uniqueLettersInThirdGroup</span><span>)</span>
<span>let</span> <span>commonLetter</span> <span>=</span> <span>commonLetters</span><span>.</span><span>first</span><span>!</span> <span>// safe to unwrap, because if this crashes the input is bad</span>
<span>// ... do processing with the common letter</span>
</code></pre></div></div>

<p>This worked great, but it‚Äôs also a lot of code. So I started combining things:</p>

<div><div><pre><code><span>let</span> <span>firstGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>
<span>let</span> <span>secondGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>
<span>let</span> <span>thirdGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>

<span>let</span> <span>commonLetters</span> <span>=</span> <span>Set</span><span>(</span><span>firstGroup</span><span>)</span><span>.</span><span>intersection</span><span>(</span><span>secondGroup</span><span>)</span><span>.</span><span>intersection</span><span>(</span><span>thirdGroup</span><span>)</span>
<span>let</span> <span>commonLetter</span> <span>=</span> <span>commonLetters</span><span>.</span><span>first</span><span>!</span>
</code></pre></div></div>

<p>Eventually I decided to make an extension, since this sort of algorithm (‚Äúfind what‚Äôs in common between these groups of things‚Äù) is a pretty normal thing to encounter in Advent of Code:</p>

<div><div><pre><code><span>extension</span> <span>Collection</span> <span>where</span> <span>Element</span><span>:</span> <span>Collection</span><span>,</span> <span>Element</span><span>.</span><span>Element</span><span>:</span> <span>Hashable</span> <span>{</span>

    <span>var</span> <span>commonElements</span><span>:</span> <span>Set</span><span>&lt;</span><span>Element</span><span>.</span><span>Element</span><span>&gt;</span> <span>{</span>
        <span>// intersect all the elements</span>
        <span>// return the final intersection</span>
    <span>}</span>

<span>}</span>

<span>let</span> <span>firstGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>
<span>let</span> <span>secondGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>
<span>let</span> <span>thirdGroup</span><span>:</span> <span>String</span> <span>=</span> <span>...</span>

<span>let</span> <span>commonLetters</span> <span>=</span> <span>[</span><span>firstGroup</span><span>,</span> <span>secondGroup</span><span>,</span> <span>thirdGroup</span><span>]</span><span>.</span><span>commonElements</span>
<span>let</span> <span>commonLetter</span> <span>=</span> <span>commonLetters</span><span>.</span><span>first</span><span>!</span>
</code></pre></div></div>

<p>It was about this point that I started noticing something weird: every time I ran my code, I‚Äôd get a different answer.</p>

<p>This is not how Advent of Code works. It is very <a href="https://en.wikipedia.org/wiki/Deterministic_algorithm">deterministic</a>: for each input, there is a single correct output. And as luck would have it, I‚Äôd already found the correct output. What I was getting now as everything <em>except</em> correct.</p>

<h2 id="questioning-the-nature-of-my-existence">Questioning The Nature Of My Existence</h2>

<p>After putting in a <a href="https://medium.com/supernova-invention-park/the-caveman-debugging-ab8f7151415f">hefty number of log statements</a>, I realized: my set of ‚Äúcommon elements‚Äù would sometimes have <em>more than one element in it</em>.</p>

<div><div><pre><code>Starting with gnmCjzwnmCPTPhBwPjzBgqPjllJJSWlhfhQDSrpJRhDSlfJl
Intersecting rLHNHrLHVNbVHMMctZFHsbcsDSDWpSDSGfSRsRWSRllfGSSG
Intersecting NNtdMVrLNdZNvLvLZrzCndqBgwwPmwgjggBn
ERROR
Common Elements??? - [&#34;j&#34;, &#34;r&#34;, &#34;B&#34;, &#34;m&#34;, &#34;z&#34;, &#34;n&#34;, &#34;q&#34;, &#34;w&#34;, &#34;g&#34;, &#34;C&#34;, &#34;P&#34;]
</code></pre></div></div>

<p>As a general principle that‚Äôs fine. <code>[&#34;apple&#34;, &#34;pear&#34;, &#34;papaya&#34;].commonElements</code> would have multiple things in it: <code>[&#34;a&#34;, &#34;p&#34;]</code>. But in this case it was not what I wanted, because I knew that I should only be getting a single element in common (due to the nature of this particular Advent of Code puzzle).</p>

<details>
    <summary>Why I was getting a different answer every time the code ran?</summary>

<blockquote><p>This problem of &#34;getting many things back when I was only expecting one&#34; also fully explains why I kept getting different results every time I ran the code. The <code>Set</code> of common elements was returning many things, but I was asking for the <code>.first</code> element in the Set. Sets, by their very nature, do not have a specific ordering, so when I ran the code over and over again, the &#34;first&#34; thing would be different each time. That meant that, each time, I&#39;d get a different final result.</p></blockquote>
</details>

<p>After staring at my code for a good 10 minutes, I did the sane thing: I asked for help.</p>

<p><img src="https://davedelong.com/files/screen-shot-20221203-at-95307-am.png" alt="Screenshot of a slack post where I state &#34;man i‚Äôve got something really weird going on with my code. i‚Äôm getting a proper chunk of 3 strings, but when i try to do the part 2 logic on them, it‚Äôs saying there are 11 elements in common between them. It‚Äôs consistently ignoring the second value&#34;"/></p>

<p>Some of the others who were also up doing Advent of Code in this particular forum graciously popped into the thread and started doing what I was doing: digging apart every single line of code, trying to identify assumptions or gaps in logic. The questions started simple: ‚Äúdo you have typos?‚Äù. Then they started digging in to my <code>commonElements</code> implementation. ‚ÄúWhat‚Äôs this extension? What if you use <code>dropFirst()</code>? Are there assumptions that fail because this will be a <code>SubSequence</code> instead of an <code>Array</code>? Are you using the <a href="https://github.com/apple/swift-algorithms/blob/main/Sources/Algorithms/Chunked.swift">Swift Algorithms</a> version of <code>.chunks(ofCount:)</code> or your own?‚Äù. Each question and it‚Äôs corresponding answer confirmed that, by all accounts, the code looked correct.</p>

<p>Then on a whim I asked:</p>

<blockquote>
  <p>is it possible there‚Äôs a bug in <code>Set</code>? üòõ</p>
</blockquote>

<p>Now, the likelihood of this actually being the case is very very very very small. So many people are using <code>Set</code>, a <em>fundamental</em> collection type, every single day that idea of there being a bug in its implementation‚Äìespecially in something as important as <a href="https://en.wikipedia.org/wiki/Intersection_%28set_theory%29">set intersection</a>‚Äìseemed laughably absurd.</p>

<blockquote>
  <p>WTF. Did Set intersection break and we‚Äôre just noticing?</p>
</blockquote>

<p>We tried different versions of Xcode. We even considered manually downloading Swift:</p>

<blockquote>
  <p>Try downloading a recent swift toolchain</p>
</blockquote>

<p>And yet, the code was still broken. And it <em>continued</em> to be broken when pulled out into a Swift playground, removing all of my fancy extensions:</p>

<div><div><pre><code><span>let</span> <span>a</span> <span>=</span> <span>&#34;gnmCjzwnmCPTPhBwPjzBgqPjllJJSWlhfhQDSrpJRhDSlfJl&#34;</span>
<span>let</span> <span>b</span> <span>=</span> <span>&#34;rLHNHrLHVNbVHMMctZFHsbcsDSDWpSDSGfSRsRWSRllfGSSG&#34;</span>
<span>let</span> <span>c</span> <span>=</span> <span>&#34;NNtdMVrLNdZNvLvLZrzCndqBgwwPmwgjggBn&#34;</span>

<span>var</span> <span>s</span> <span>=</span> <span>Set</span><span>(</span><span>a</span><span>)</span>
<span>s</span><span>.</span><span>formIntersection</span><span>(</span><span>b</span><span>)</span>
<span>s</span><span>.</span><span>formIntersection</span><span>(</span><span>c</span><span>)</span>

<span>print</span><span>(</span><span>s</span><span>)</span> <span>// [&#34;C&#34;, &#34;q&#34;, &#34;m&#34;, &#34;r&#34;, &#34;j&#34;, &#34;n&#34;, &#34;z&#34;, &#34;g&#34;, &#34;w&#34;, &#34;P&#34;, &#34;B&#34;]</span>
</code></pre></div></div>

<p>At this point, we had to conclude that something really strange was going on. Then one poster hit on an idea:</p>

<blockquote>
  <p>Yikes, try converting a b and c to sets before intersecting</p>
</blockquote>

<p>This change was simple. Instead of <code>s.formIntersection(a)</code>, I changed it to <code>set.formIntersection(Set(a))</code>. The change here is that instead of using the generic <a href="https://github.com/apple/swift/blob/main/stdlib/public/core/Set.swift#L955">‚Äúfind things in common with this other <em>sequence</em> of characters‚Äù</a>, I was now using the method <a href="https://github.com/apple/swift/blob/main/stdlib/public/core/Set.swift#L1242">‚Äúfind things in common with this other <code>Set</code>‚Äù</a>. These have different implementations because, due to the nature of how sets work, the second can be done much more ‚Äúcheaply‚Äù than the first.</p>

<blockquote>
  <p>I think you found a (known) bug</p>
</blockquote>

<p>So I tried it, and suddenly my code started working. The one who suggested this then dug up this pull request on the Swift repo: <a href="https://github.com/apple/swift/pull/59422">PR #59422: Fix handling of duplicate items in generic Set.intersection</a>. It turns out, there <em>was</em> a bug in <code>Set.intersection(_:)</code>, but it had only been discovered this past June, and the fix only applies to macOS Ventura and later (my machine is running Monterey still). The scope of the bug is fairly limited: it only showed up if you were using the general intersection method, and the sequence had ‚Äúexactly as many duplicate items as items missing from <code>self</code>‚Äù. As it turned out, Advent of Code happened to provide me with exactly the right input to hit this multiple times.</p>

<p>In the end, <a href="https://github.com/davedelong/AOC/blob/main/Sources/AOCCore/Data%20Structures/Collection.swift#L366-L384">my workaround was simple</a>: I could simply make sure I pass in <code>Set(item)</code> instead of just <code>item</code>. But the adventure of digging this deep into my code, questioning assumption after assumption, and coming up with ways to test those assumptions was quite exhilarating.</p>

<p>And it proves that maybe‚Ä¶¬†<em>just maybe</em>‚Ä¶ it really <em>is</em> a bug in the standard library.</p>

<hr/>

<p>Edit: An earlier version of this post claimed the bug was not fixed yet. This is incorrect. The bug <em>is</em> fixed in Swift 5.7, but my computer is running macOS Monterey (12.6) and thus using an earlier version of Swift. I have since confirmed that the code works as expected on macOS Ventura.</p>

  </div></div>
  </body>
</html>
