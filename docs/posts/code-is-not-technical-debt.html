<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gavinhoward.com/2023/12/code-is-not-technical-debt/">Original</a>
    <h1>Code Is Not Technical Debt</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="the-introduction">The Introduction</h2><p>So I saw a post today, and it’s so wrong I was about to post a ranty missive on
Hacker News.</p><p>But my ranty missives get long, so here’s a blog post instead.</p><p><strong>tl;dr</strong>: Code is an asset, and tech debt is when the software <em>and its
internal model</em> do not match the problem and the mental model, or when the
internal interfaces do not minimize assumptions.</p><h2 id="the-post">The Post</h2><p>The post is <a href="https://www.tokyodev.com/articles/all-code-is-technical-debt">“All Code Is Technical Debt”</a> written by <a href="https://www.tokyodev.com/authors/paul-mcmahon">Paul McMahon</a>.</p><p>And everything is just <em>slightly</em> wrong, starting from the title.</p><p>So let’s break it down.</p><h2 id="the-thesis">The Thesis</h2><p>Paul’s thesis is at the end of his introduction:</p><blockquote><p>As the more code you add to an application, the slower development becomes, I
view all code as technical debt.</p></blockquote><p>But is this true? Does development speed always get slower if you add code?</p><p>Let’s look at the corollary: does development speed always get faster if you
<em>remove</em> code?</p><p>That is false on its face!</p><p>One of the reasons people don’t like C (besides <a href="https://gavinhoward.com/2023/02/why-i-use-c-when-i-believe-in-memory-safety/">memory bugs</a>) is its paltry
standard library! C is basically the extreme of “remove code,” and I can tell
you from experience that its tiny standard library slows development.</p><p>I’ve spent about <a href="https://git.yzena.com/Yzena/Yc/commit/8b803cf03f98b3864">7 years</a> building my own C libraries as a replacement.</p><p>So if the corollary is not true, is the thesis?</p><p><strong>It is absolutely not true.</strong></p><p>Take <a href="https://git.gavinhoward.com/gavin/bc/commit/1ead5b9652a1be00">this commit</a> from my <a href="https://gavinhoward.com/2023/02/my-code-conquered-another-os/">most famous</a> <a href="https://git.gavinhoward.com/gavin/bc">project</a>.</p><p>In that commit, I am adding three, <em>three!</em>, new keywords and commands to <code>bc</code>
<em>and</em> <code>dc</code>.</p><p>For that commit, I deleted 7 lines and added 108.</p><p>More accurately, I changed 7 lines and added 101.</p><p>That means I deleted an average of 1 line per keyword <em>per program</em>, and added
an average of 18 lines per keyword per program.</p><p>Okay, let’s see how much of that code exists 537 commits later.</p><p>To get the 537 number, I ran <code>git rev-list 1ead5b96..HEAD | wc -l</code>.</p><p>I ran blames and took out whitespace-only code style fixes. Of the 108 lines,
77 still exist. That’s 71.2%.</p><p>And most of the ones that changed were numbers or other data that got changed
when I added <em>other</em> keywords.</p><p>But the other key is how <em>easy</em> it was to add those features; even if we count
both programs together, adding a keyword took me 36 lines. That’s easy to
review, easy to test, and easy to change. It’s like technical debt does not
exist.</p><p>“Okay, Gavin, but what does that have to do with Paul’s thesis?”</p><p>Paul’s point is that adding code is always more technical debt. He said,</p><blockquote><p>When you’re first building out an application, you can develop new features at
incredible speed. There’s no need to worry about the impact on existing users.
You can just focus on implementing new features.</p><p>However, as an application matures, development speed will inevitably slow
down. On a poorly implemented product, development speed slows down quickly.
But even on a beautifully implemented one, development speed still slows down
over time.</p></blockquote><p>But that was not the case for these three features. They took me about two hours
<em>total</em>, including testing!</p><p>This was <em>not</em> the case when I started; I could take <em>weeks</em> to add just <em>one</em>
new feature!</p><p>So my development speed has <em>increased</em> even though my code has grown!</p><p>How much has it grown? This much:</p><p><a href="https://gavinhoward.com/img/bc_stack_plot.png"><img src="https://gavinhoward.com/img/bc_stack_plot.png" alt="Git of Theseus stack plot for bc as of Dec 20, 2023" aria-label="Git of Theseus stack plot for bc as of Dec 20, 2023"/></a></p><p>And that image only counts files in <code>include/</code>, <code>src/</code>, and <code>gen/</code>. It also
excludes text files in <code>gen/</code>.</p><p>In particular, note that the only month that lost a significant amount of code
is Aug 2018, which was early.</p><p>If you were to plot the survival rates of code in <code>bc</code>, it would look like this:</p><p><a href="https://gavinhoward.com/img/bc_survival_plot1.png"><img src="https://gavinhoward.com/img/bc_survival_plot1.png" alt="Git of Theseus stack plot for bc as of Dec 20, 2023" aria-label="Git of Theseus stack plot for bc as of Dec 20, 2023"/></a></p><p>And again, that only counts files in the same directories as above. If you plot
the survival rate for the entire repo, you’ll get this:</p><p><a href="https://gavinhoward.com/img/bc_survival_plot2.png"><img src="https://gavinhoward.com/img/bc_survival_plot2.png" alt="Second Git of Theseus stack plot for bc as of Dec 20, 2023" aria-label="Second Git of Theseus stack plot for bc as of Dec 20, 2023"/></a></p><p>Notice that the first 40% disappeared in six months, but the next 40% is <em>still</em>
not gone more than five years later.</p><p>Also, do you see those small cliffs at various points? Those are where I did a
refactor to reduce tech debt.</p><p>There was a large cliff at the beginning because I was exploring and refactoring
as I went. I finally settled into something good after six months, but I didn’t
rest on my laurels; when I saw a problem, I fixed it.</p><p>In fact, I often <em>added</em> code to reduce tech debt.</p><p>An example is when I implemented my own <a href="https://git.gavinhoward.com/gavin/bc/src/branch/master/src/file.c">file I/O</a> in <code>bc</code>.</p><p>“Oh, Gavin…”</p><p><a href="https://media1.tenor.com/m/ofdD0cJ5xQ0AAAAC/you-are-so-dumb-you-are-really-dumb.gif"><img src="https://media1.tenor.com/m/ofdD0cJ5xQ0AAAAC/you-are-so-dumb-you-are-really-dumb.gif" alt="You are so dumb" aria-label="You are so dumb"/></a></p><p>No I’m not.</p><p>You see, I have a built-in command-line history implementation, and that needs
raw access to the terminal for obvious reasons.</p><p>If I used the regular file I/O, it would have “worked,” but I would deal with
sticky issues between it and history.</p><p>But by implementing my own, I got rid of the sticky issues and reduced my tech
debt.</p><p><em>Adding</em> code <em>reduced</em> my tech debt.</p><p>Paul is right by <a href="https://en.wikipedia.org/wiki/Rule_of_thumb">rule of thumb</a>, but I would rather not be ruled by
<a href="https://spykids.fandom.com/wiki/Thumb_Thumbs">thumbs</a>.</p><p>So let’s find a more precise “rule.”</p><h2 id="the-rule">The Rule</h2><p>I already <a href="https://gavinhoward.com/2022/10/technical-debt-costs-more-than-you-think-or-my-software-development-process/">came up with one</a>:</p><blockquote><p>Your software is trying to solve a problem, and every problem has an unknown
shape because <a href="http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail">reality has a surprising amount of detail</a>…</p><p><strong>Technical debt is every place where the software does not fit the
problem.</strong></p></blockquote><p>(Emphasis added.)</p><p>And it is that simple: tech debt is when your software (and the model behind it)
do not fit the problem it is trying to solve.</p><p>Well, not quite…</p><p>“Okay, Gavin, so what about our metaphor? Should we want more code or less?
Because it sure sounds like you’re advocating for more code.”</p><p>Nah, less code <em>is</em> better, all else being equal. But “all else equal” is
lottery-rare.</p><p>That’s not to say that “less code equals better” is <em>also</em> rare; it’s not.</p><p>I would like to propose a different metaphor: code/software is an <a href="https://en.wikipedia.org/wiki/Asset"><em>asset</em></a>.</p><p>“Well, what’s tech debt, then?”</p><p>Patience.</p><p>If I’m going to go all in on financial terms, let’s add <a href="https://en.wikipedia.org/wiki/Liability_(financial_accounting)">liabilities</a>:</p><dl><dt>Liability</dt><dd><p>The quantity of value that a[n]…entity owes.</p></dd></dl><p>As a programmer, you owe the ability to solve a problem. Anything in the code
that doesn’t solve the problem is part of that liability.</p><p>So technical <em>debt</em> is really <em>code liability</em>.</p><p>“That’s stupid, Gavin; assets can’t be liabilities, so your metaphor is wrong.”</p><p>True, assets cannot be liabilities, but they <em>can</em> have liabilities attached to
them.</p><p>For example, say I buy a car with financing; that debt is a <em>liability</em> even
though the car itself is an <em>asset</em>, and that liability is attached to the car.</p><p>In like manner, code as an asset can have a liability attached that lessens the
value of the asset.</p><p>It goes further: you can be <a href="https://www.investopedia.com/terms/u/underwater.asp">“underwater”</a> on an asset. This means that your
asset may be worth <em>less</em> than the liability attached to it.</p><p>You can experience this with code as well; when development slows to a crawl,
you’ve gone under.</p><p>It can happen in two ways: the problem changes (your liability increases) or
your software becomes less useful (your asset <a href="https://en.wikipedia.org/wiki/Depreciation">depreciates</a>).</p><p>Yep, I’m <em>still</em> going on the financial metaphors.</p><p>“How can software depreciate, Gavin? It’s just code.”</p><p><em><strong><code>node_modules</code> enters the chat</strong></em></p><p>If its environment changes, it may not run. And software that won’t run has
depreciated to nothing.</p><p>This is <em>another</em> reason <a href="https://gavinhoward.com/2023/02/why-i-use-c-when-i-believe-in-memory-safety/">I choose C</a>: the environment does not change.</p><p>“But that doesn’t explain your supposed ‘zero’ code liability, Gavin.”</p><p>You’re partially right. I do keep up to date on the problem, and I do update my
software to fit the problem.</p><h2 id="the-interfaces">The Interfaces</h2><p>But that is not the only reason I have nigh nil code liability and why you do
not.</p><p>Paul says, <a href="https://www.tokyodev.com/articles/all-code-is-technical-debt#adding-new-assumptions-increases-debt">“Adding new assumptions increases debt,”</a> and in this, he is
correct.</p><p>But he is assuming that adding features requires adding assumptions. If you
create and use interfaces properly, few to no new assumptions are necessary.</p><p>Don’t believe me?</p><p>Remember that I added keywords to my <code>bc</code>; all three needed <em>zero</em> additional
assumptions.</p><p>The parsing followed the existing assumptions of the parser (parse up to the
character you need and no more) and the existing assumption of the virtual
machine (remove operands from the results stack and replace them with the
result).</p><p>“But that’s just because you were making a programming language and could make
easy assumptions!”</p><p>Uh, this programming language is <a href="https://en.wikipedia.org/wiki/Turing_completeness"><em>Turing-complete!</em></a> That is the very
<em>definition</em> of <strong>hard</strong> in programming. It’s also hard to making a programming
language match the problem it is made to solve.</p><div><p>And I have pulled off the same thing in a larger language with <em>user-defined
keywords</em> and <em>user-defined lexers!</em></p><p>Coming soon…</p></div><p>To wit: <strong>your interfaces should minimize assumptions</strong>.</p><p>Or in other words, the code’s internal model (assumptions) needs to match the
internal interfaces.</p><p>I do this by:</p><ul><li>Never programming past my limited ability.</li><li>Strictly documenting interfaces, including preconditions and postconditions.</li><li>Strictly programming to those interfaces, adjusting one or the other as
necessary.</li><li>Iterating until the interfaces are close to perfect.</li></ul><p>I know I have succeeded when those interfaces make it easy to add stuff without
intefering with other features.</p><h2 id="the-model">The Model</h2><p>And yet, that is <em>still</em> not enough.</p><p>The last way software can have a liability is that it doesn’t match the model.</p><p>The <em>mental</em> model.</p><p><a href="https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1">“Programming as Theory Building”</a> (<a href="https://pages.cs.wisc.edu/~remzi/Naur.pdf">original</a>) is a famous essay (which
you should go read <em>right now!</em>) that uses the word <em>theory</em> for this concept,
but it is the same concept.</p><p>Whatever the term, the model/theory is the software as it exists in the minds of
those who create and use it.</p><p>Of course, the mental model will be inaccurate; if it wasn’t, we would never
have bugs, so the <em>other</em> form of code liability is when the software is
different from the mental model.</p><p>I fix this by testing, testing, testing. I fuzz with a crash-happy build, and I
fix every bug.</p><p>“But how does that improve your mental model?”</p><p>Because for me, one of the definitions of a bug is a <em>mismatch between my mental
model and the reality of the software</em>.</p><p>So when I fix a bug, I’m bring my model and the reality closer together. And I
do this until they are in harmony.</p><p>Sometimes, this includes changing my mental model when the reality is better.</p><h2 id="the-bloat">The Bloat</h2><p>In addition, unneeded bloat is also code liability.</p><p>All code has a cost because assets have to be maintained, so extra code will
have a higher maintenance cost than necessary.</p><p>I regularly look for code to purge.</p><h2 id="the-prevention">The Prevention</h2><p>I also do one more thing that almost no developer does: I actually <em>design</em> my
code before I ever start coding.</p><p>In other words, I build a mental model, including the problem that the software
solves, before I start.</p><p>This keeps my coding laser-focused on its purpose and helps me prevent
divergence between reality and model.</p><p>Of course, I do have to update the initial model, but an ounce of prevention is
worth a pound of cure.</p><p>And <em>that</em> is how I smash code liability.</p><h2 id="the-other-points">The Other Points</h2><p>I guess I should respond to Paul’s other points.</p><p>Yes, that is true, and that matches with my metaphor.</p><p>A feature that does not match the problem has negative value, but it is still
an <em>asset</em>, just a bad one, like a junker car.</p><p>In the real world, assets can <em>also</em> be a poor match for their purpose, such as
the <a href="https://simpleflying.com/airbus-a380-programme-cancelled/">Airbus A380</a>.</p><p>Yes, that is true.</p><p>Code that does not match the problem has negative value.</p><p>You heard that right: this is just a restatement of of <strong>“Features can have
negative value.”</strong></p><p>This is also mostly true.</p><p>This is why I’m bullish on keeping code liability to a minimum from the start;
if I ruthlessly prune features before they can entrench themselves, this
terrible fact is not a fact for me.</p><p>I suggest you do the same if you can while still meeting your business goals.</p><p>Well, yes, but this is also like saying “to avoid missing in basketball, don’t
shoot.”</p><p>Code is an asset, but you need assets to do stuff.</p><p>Just remember that assets need maintenance to remain above water. Write code to
solve problems, and make sure that code matches the problem. Maintain it to keep
it that way.</p><p>Yes, this is great advice; it is the same advice I gave above about assumptions,
although you should change bad assumptions if you can.</p><h2 id="the-conclusion">The Conclusion</h2><p>Tech debt and code liability are hotly debated, so let me throw out my opinion:</p><ul><li>Code is an asset.</li><li>Code can have a liability attached, which can be one or more of:<ul><li>When the code does not match the problem.</li><li>When the code’s internal model does not match the problem.</li><li>When the code’s internal model does not match the mental model of users
and programmers.</li><li>When the code’s internal model does not match the code’s internal
interfaces.</li><li>And yes, when there is more code than necessary to match the problem.</li></ul></li><li>You can be underwater on code; this is when development stalls.</li><li>Thus, code must be maintained, just like any other asset.</li></ul><p>Am I right? Well, I’ll leave that for you to decide.</p><p><a href="https://news.ycombinator.com/item?id=38717873">Let the debate rage on!</a></p><hr/><p><strong>Edit (2023-12-21)</strong>: Added “The Bloat” section based on Hacker News comments.</p></div></div>
  </body>
</html>
