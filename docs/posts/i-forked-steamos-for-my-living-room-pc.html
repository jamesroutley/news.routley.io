<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iliana.fyi/blog/build-your-own-steamos-updates/">Original</a>
    <h1>I forked SteamOS for my living room PC</h1>
    
    <div id="readability-page-1" class="page"><div><p>SteamOS 3 (“Holo”) is the Arch-based Linux distribution built for the Steam Deck, Valve Software’s portable PC gaming device. It’s a very interesting Linux distribution even when you only focus on how it updates itself: updates are performed atomically by downloading a new read-only root filesystem to an inactive partition, then rebooting into that partition. But consumers can also run <code>steamos-devmode</code> to unlock the root filesystem, put the pacman database in working order, and give them a working Linux distro with a normal package manager.</p><p>This A/B atomic updates system is pretty standard for OSes these days, but there’s a lot going on in SteamOS that makes them work even with heavy customization by the end-user. I wanted to explore that while still being able to make changes to the root filesystem images. <code>steamos-devmode</code> is the easy way out; I wanted to make a proper fork. Here’s how I did it.</p><ili-callout role="note"><p>I use these instructions, but am providing them here to help publicly document some of what SteamOS does. I’m not responsible for you breaking your Steam Deck, and if you send me questions asking why these steps don’t work for you I won’t answer.</p></ili-callout><h2>Why?</h2><p>I don’t own a Steam Deck. A bunch of my friends do, but they know better than to let me have root access on a device they actually like using. What I do have is a recently-built living room PC that I wanted to play games on… and SteamOS seemed like a reasonable choice. It almost even worked perfectly out of the box, although I think that is primarily because I built a computer that looks vaguely similar to a really heavy, battery-less Steam Deck<sup><a href="#user-content-fn-fragile" aria-describedby="footnote-label" data-footnote-ref="" id="user-content-fnref-fragile">1</a></sup>.</p><p>The one thing that didn’t work was resume from suspend. Other distributions running on my computer using mainline or stable kernels did. Eventually, I found <a href="https://steamdeck-packages.steamos.cloud/archlinux-mirror/sources/">the sources for Valve’s kernel</a> (it’s weird, I’ll explain when we get there) and started a <code>git bisect</code>, leading me to a commit that seems to fix resume from suspend on Steam Deck hardware, but ultimately breaks it on mine. Needing to revert this commit and do my own build is the ultimate reason I headed down this path.</p><p>At several points in this process my partner asked if this made more sense than just using Arch or something else directly. I still don’t know the answer, although I think I still prefer relying on a Valve-tested set of packages than whatever’s current in the Arch repos. If I’m going to have to tinker with a Linux distro for running games, it may as well be one that people actually test their games on.</p><p>I apparently have a tendency to make poor choices like this, because you are reading the second post in what has become a series on <a href="https://iliana.fyi/blog/installing-fedora-on-mac-mini/">installing Linux distros onto systems they’re not ready for yet</a>.</p><h2>SteamOS in a nutshell</h2><p>A SteamOS system has eight partitions. The stage 1 bootloader is stored on the EFI system partition, along with metadata files that describe the two A/B partition sets and how to choose which one to boot. Each of the two partition sets contains a stage 2 bootloader (GRUB), the root filesystem, and a <code>/var</code> partition. Finally, there’s a single <code>home</code> partition that fills the rest of the disk.</p><pre><code>Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048          133119   64.0 MiB    EF00  esp
   2          133120          198655   32.0 MiB    0700  efi-A
   3          198656          264191   32.0 MiB    0700  efi-B
   4          264192        10749951   5.0 GiB     8304  rootfs-A
   5        10749952        21235711   5.0 GiB     8304  rootfs-B
   6        21235712        21759999   256.0 MiB   8310  var-A
   7        21760000        22284287   256.0 MiB   8310  var-B
   8        22284288      4000797319   1.9 TiB     8302  home
</code></pre><p>When the system boots, a number of other pseudo-filesystems get mounted. Almost a dozen directories, including <code>/var/log</code>, <code>/root</code>, and <code>/nix</code>, are bind-mounted from <code>/home/.steamos/offload</code> to keep their data persistent.</p><p>Perhaps my favorite detail of SteamOS is how it handles <code>/etc</code>: it mounts an overlayfs on top of it, with modifications persisted at <code>/var/lib/overlays/etc/upper</code>. This allows persisting the usual things that need to be persisted in <code>/etc</code> (e.g. the <code>machine-id</code> file, NetworkManager connections) while allowing updates to untouched configuration files. Most Linux package managers have similar behaviors around <code>/etc</code>, only updating config files that haven’t been changed from their defaults, but Valve’s approach makes this work with the A/B partition system without any package manager logic.</p><p>A system update is started when the Steam client, or a user in a terminal, runs <code>steamos-update</code>. This runs a Python program, <code>steamos-atomupd-client</code>, which sends a request containing the current OS information and the user’s update channel configuration to the URLs in <code>/etc/steamos-atomupd/client.conf</code> in order to determine whether there is a new update.</p><p>If there is, the servers respond with a path to a <a href="https://rauc.io/">RAUC bundle</a>, which the client downloads and runs <code>rauc install</code> on. RAUC verifies the signature of the bundle and looks for the <code>rootfs.img.caibx</code> file, then runs <code>casync extract</code> to download all the necessary pieces of the new image and write them to the inactive rootfs partition. RAUC then runs a post-install script that selectively<sup><a href="#user-content-fn-selectively" aria-describedby="footnote-label" data-footnote-ref="" id="user-content-fnref-selectively">2</a></sup> synchronizes data from the active <code>/var</code> partition to the inactive <code>/var</code> partition, and modifies the stage 1 bootloader configuration on the EFI system partition to boot into the newly-written partition set.</p><h2>Patching the kernel</h2><p>Valve uses a heavily-modified Linux kernel in SteamOS. We can know this because we can readily download the sources. It’s a little more convoluted than <code>git clone</code>, but not by much. Their <a href="https://steamdeck-packages.steamos.cloud/archlinux-mirror/">pacman mirror</a> can be found in <code>/etc/pacman.d/mirrorlist</code>, and the sources used for current (as of writing) SteamOS images are in the <code>sources/holo-3.5</code> and <code>sources/jupiter-3.5</code>. Right now, the current stable image’s kernel is <code>6.1.52-valve9-1-neptune-61</code>, whose source lives at <a href="https://steamdeck-packages.steamos.cloud/archlinux-mirror/sources/jupiter-3.5/linux-neptune-61-6.1.52.valve9-1.src.tar.gz">https://steamdeck-packages.steamos.cloud/archlinux-mirror/sources/jupiter-3.5/linux-neptune-61-6.1.52.valve9-1.src.tar.gz</a>.</p><p>This is a 2.9 GiB tarball. Why is it that big? Because there’s an entire Linux Git tree in here.</p><pre><code>$ tar xvf linux-neptune-61-6.1.52.valve9-1.src.tar.gz
linux-neptune-61/
linux-neptune-61/config
linux-neptune-61/config-neptune
linux-neptune-61/PKGBUILD
linux-neptune-61/archlinux-linux-neptune/
linux-neptune-61/.SRCINFO
linux-neptune-61/archlinux-linux-neptune/hooks/
linux-neptune-61/archlinux-linux-neptune/branches/
linux-neptune-61/archlinux-linux-neptune/HEAD
linux-neptune-61/archlinux-linux-neptune/config
linux-neptune-61/archlinux-linux-neptune/description
linux-neptune-61/archlinux-linux-neptune/objects/
linux-neptune-61/archlinux-linux-neptune/refs/
linux-neptune-61/archlinux-linux-neptune/info/
linux-neptune-61/archlinux-linux-neptune/packed-refs
linux-neptune-61/archlinux-linux-neptune/info/exclude
linux-neptune-61/archlinux-linux-neptune/refs/tags/
linux-neptune-61/archlinux-linux-neptune/refs/heads/
linux-neptune-61/archlinux-linux-neptune/objects/pack/
linux-neptune-61/archlinux-linux-neptune/objects/info/
linux-neptune-61/archlinux-linux-neptune/objects/pack/pack-6e0e2b73767937e4f217e55f6d3628af296eecfc.idx
linux-neptune-61/archlinux-linux-neptune/objects/pack/pack-6e0e2b73767937e4f217e55f6d3628af296eecfc.pack
linux-neptune-61/archlinux-linux-neptune/objects/pack/pack-6e0e2b73767937e4f217e55f6d3628af296eecfc.rev
...
</code></pre><p>This was likely generated by <code>makepkg --allsource</code> from a PKGBUILD with:</p><pre><code>_tag=6.1.52-valve9
# ...
source=(
  &#34;$_srcname::git+ssh://git@gitlab.steamos.cloud/jupiter/linux-integration.git#tag=$_tag&#34;
  config          # Upstream Arch Linux kernel configuration file, DO NOT EDIT!!!
  config-neptune  # Jupiter: the neptune kernel fragment file (overrides &#39;config&#39; above)
)
</code></pre><p>So we can’t clone directly from their private GitLab repo or link to various commits, but we can get regular snapshots of every tag with full commit history in the repo from their <code>makepkg</code> sources. This is very useful for, say, bisecting which commit breaks suspend on your living room PC.</p><p>The source tarball isn’t a working Git tree that you can <code>cd</code> into and start hacking on. It’s a <a href="https://git-scm.com/docs/gitrepository-layout/2.22.0">bare repository</a>, which you can clone into a normal working tree<sup><a href="#user-content-fn-worktree" aria-describedby="footnote-label" data-footnote-ref="" id="user-content-fnref-worktree">3</a></sup>. My recommendation is to maintain your own branch of changes, tag your releases, and push them to your favorite Git host so that you can use it in the PKGBUILD file. <a href="https://git.iliana.fyi/linux">Here’s mine!</a></p><pre><code>wget https://steamdeck-packages.steamos.cloud/archlinux-mirror/sources/jupiter-3.5/linux-neptune-61-6.1.52.valve9-1.src.tar.gz
tar xvzf linux-neptune-61-6.1.52.valve9-1.src.tar.gz
git clone linux-neptune-61/archlinux-linux-neptune/ linux-neptune
cd linux-neptune
git switch --create my-branch 6.1.52-valve9
</code></pre><p>Fix up your PKGBUILD (pointing to your Git repo, not mine):</p><pre><code data-syntax-highlighted=""><span>--- a/PKGBUILD</span>
<span>+++ b/PKGBUILD</span>
<span>@@ -3,5 +3,5 @@</span>

<span> pkgbase=linux-neptune-61</span>
<span>-_tag=6.1.52-valve9</span>
<span>+_tag=6.1.52-valve9-iliana1</span>
<span> pkgver=${_tag//-/.}</span>
<span> pkgrel=1</span>
<span>@@ -19,5 +19,5 @@</span><span> options=(&#39;!strip&#39; &#39;!debug&#39;)</span>
<span> _srcname=archlinux-linux-neptune</span>
<span> source=(</span>
<span>-  &#34;$_srcname::git+ssh://git@gitlab.steamos.cloud/jupiter/linux-integration.git#tag=$_tag&#34;</span>
<span>+  &#34;$_srcname::git+https://git.iliana.fyi/linux#tag=$_tag&#34;</span>
<span>   config          # Upstream Arch Linux kernel configuration file, DO NOT EDIT!!!</span>
<span>   config-neptune  # Jupiter: the neptune kernel fragment file (overrides &#39;config&#39; above)</span>
</code></pre><p>Then <code>makepkg</code> should spit out a package. (Tip: <code>makepkg MAKEFLAGS=-j$(nproc)</code>, or updating <code>/etc/makepkg.conf</code>, is a good idea if you are not building in a tiny virtual machine.) This same general process should apply for any SteamOS-specific packages; all the ones I’ve looked at similarly use a Git repository as their first source.</p><p>To make the next steps easier, I set up a pacman repo containing my package outputs. This also helps the <code>steamos-devmode</code> tool work properly if you choose to run that in the future. This is <a href="https://archlinux.org/pacman/repo-add.8.html">very simple</a>: put the packages in a directory, run <code>repo-add $REPO_NAME.db.tar.zst [PACKAGES...]</code> in that directory, and upload the directory to a web host somewhere.</p><h2>Repacking the root filesystem</h2><p>The update client is perfectly-readable Python, and the sources for the rest of the packages on the system can be found adjacent to Valve’s pacman repos, but I haven’t yet found any release engineering scripts. Reverse engineering these would be fraught, time-consuming, and beyond what I believe my attention span would allow, so I decided to take the existing root filesystem and “repack” it to fit my needs.</p><p>If you want my scripts without the explanations and commentary, you can find them at <a href="https://git.iliana.fyi/fauxlo/tree/">https://git.iliana.fyi/fauxlo/tree/</a>.</p><h3>Getting the root filesystem</h3><ili-callout role="note"><p>The normal way to get a copy of the SteamOS root filesystem image is to buy a Steam Deck or download the recovery image from <a href="https://store.steampowered.com/steamos/download?ver=steamdeck">https://store.steampowered.com/steamos/download?ver=steamdeck</a>, both of which require agreeing to the Steam End User License Agreement<sup><a href="#user-content-fn-agreement" aria-describedby="footnote-label" data-footnote-ref="" id="user-content-fnref-agreement">4</a></sup>. The methods I describe below don’t make you do this, but now you’re aware of it.</p></ili-callout><p>First, we need the root filesystem. You could install SteamOS, run an update, and pull it off the disk, but that is kind of obnoxious, especially if you don’t have any hardware to install it on.</p><p>Every build of a Steam Deck image can be found at <a href="https://steamdeck-images.steamos.cloud/steamdeck/">https://steamdeck-images.steamos.cloud/steamdeck/</a>, but to find the current release version you can look at what appears to be a fallback URL for the updates system, <a href="https://steamdeck-atomupd.steamos.cloud/meta/steamos/amd64/snapshot/steamdeck.json">https://steamdeck-atomupd.steamos.cloud/meta/steamos/amd64/snapshot/steamdeck.json</a> (or <a href="https://steamdeck-atomupd.steamos.cloud/meta/steamos/amd64/snapshot/steamdeck-beta.json">this path for the preview channel</a>). As of writing, the current stable version is <a href="https://steamdeck-images.steamos.cloud/steamdeck/20231122.1/">https://steamdeck-images.steamos.cloud/steamdeck/20231122.1/</a>.</p><p>To download the root filesystem, we follow the same steps <code>steamos-atomupd-client</code> does: first, download the RAUC bundle (the <code>.raucb</code> file). Then extract the <code>rootfs.img.caibx</code> from inside; these RAUC bundles are SquashFS filesystems with a signature at the end, so you can either mount it or use unsquashfs (from squashfs-tools) or p7zip to extract it without mounting. Finally, use casync to fetch the image using the <code>.castr</code> store adjacent to the <code>.raucb</code> bundle:</p><pre><code>casync extract \
	--store=https://steamdeck-images.steamos.cloud/steamdeck/20231122.1/steamdeck-20231122.1-3.5.7.castr \
	rootfs.img.caibx rootfs.img
</code></pre><p>The casync store URL is the RAUC bundle URL, but with <code>.raucb</code> replaced with <code>.castr</code> (this is hardcoded in <code>steamos-atomupd</code>).</p><p><a href="https://git.iliana.fyi/fauxlo/tree/fetch-current.sh?id=c50eb80f23c08f1ffc824d4983d5b9a740fb1273">Here is a script I use to do all this.</a></p><ili-tangent role="note"><p>The adjacent <code>.img.zip</code> and <code>.img.zst</code> files are not the root filesystem, sadly, but are separate bootable recovery images:</p><pre><code>$ sgdisk --print disk.img
Disk disk.img: 15125000 sectors, 7.2 GiB
[...]

Number  Start (sector)    End (sector)  Size       Code  Name
   1              34          131071   64.0 MiB    EF00  esp
   2          131072          393215   128.0 MiB   0700  efi-A
   3          655360        11141119   5.0 GiB     8304  rootfs-A
   4        11141120        11665407   256.0 MiB   8310  var-A
   5        11665408        15124966   1.6 GiB     8302  home
</code></pre><p>You could extract the rootfs partition and use it in the next steps, but for some reason it’s not a bit-for-bit copy of the image that is downloaded via RAUC and casync, and doing this doesn’t save you from having to use those tools as we need them to turn our repacked image back into an update bundle.</p></ili-tangent><h3>Mounting the root filesystem</h3><p>First, we should randomize the filesystem UUID. If you update from a currently-released SteamOS image to your customized one without randomizing the filesystem UUID, you will end up with two distinct filesystems with the same UUID. This can cause problems.</p><pre><code>btrfstune -fu rootfs.img
</code></pre><p>Valve is currently using Btrfs images with zstd compression, so to maintain that compression as we change the image, we need to mount it with the appropriate option:</p><pre><code>mkdir rootfs
mount -o compress=zstd rootfs.img rootfs
</code></pre><p>SteamOS uses Btrfs’s <code>readonly</code> subvolume property; clear that flag:</p><pre><code>btrfs property set -ts rootfs ro false
</code></pre><p>Modifying certain packages, such as the Linux kernel, triggers scripts that want /dev and /proc, so mount those:</p><pre><code>mount -t devtmpfs dev rootfs/dev
mount -t proc proc rootfs/proc
</code></pre><p>It’s also a good idea to prevent writes to directories that will be mounted by the booted system. We can mount tmpfs to these directories:</p><pre><code>mount -t tmpfs tmpfs rootfs/tmp
mount -t tmpfs -o mode=755 tmpfs rootfs/run
mount -t tmpfs -o mode=755 tmpfs rootfs/var
mount -t tmpfs -o mode=755 tmpfs rootfs/home
</code></pre><p>In this example we’ll be installing packages via pacman repositories in a chroot (using pacman’s <code>--sysroot</code> option). Networking functions fine in a chroot, but name resolution still relies on a correct /etc/resolv.conf, so bind mount one in:</p><pre><code>mount --bind &#34;$(realpath /etc/resolv.conf)&#34; rootfs/etc/resolv.conf
</code></pre><h3>Replacing packages</h3><p>To add your custom repository, make it the first repository entry in <code>/etc/pacman.conf</code>. This will ensure your packages override any newer-versioned ones from Valve’s repositories. It also allows your packages to be reinstalled by <code>steamos-devmode</code> if you run that on this image. I used this stanza:</p><pre><code>[fauxlo]
Server = https://fauxlo.ili.fyi/pacman/$arch
SigLevel = Never
</code></pre><p><code>SigLevel = Never</code> allows the packages to have no signatures. If you want to GPG-sign your packages, go for it, but that’s beyond what I have patience for.</p><ili-tangent role="note"><p>If you do end up installing GPG-signed packages, you’ll need to populate the pacman keyring. I think it’s best to avoid messing with the empty keyring in <code>/etc/pacman.d/gnupg</code> by populating a new keyring on a tmpfs:</p><pre><code>chroot rootfs pacman-key --gpgdir /tmp/gnupg --init
chroot rootfs pacman-key --gpgdir /tmp/gnupg --populate
# These start a gpg-agent, which we need to stop before we can unmount at the end.
chroot rootfs gpgconf --homedir /tmp/gnupg --kill all
</code></pre><p>Then add <code>--gpgdir /tmp/gnupg</code> to your pacman incantation.</p></ili-tangent><p>Then, we install:</p><pre><code>pacman --sysroot rootfs --noconfirm -Sy linux-neptune-61
</code></pre><ili-tangent role="note"><p>In my script, I avoid using <code>-y</code> and instead synchronize my repository’s database behind pacman’s back before running the install command:</p><pre><code>curl -Ro rootfs/usr/lib/holo/pacmandb/sync/fauxlo.db \
	https://fauxlo.ili.fyi/pacman/x86_64/fauxlo.db
</code></pre><p>This keeps the state of the other repositories on disk frozen at the same point in time when the image was originally built. I don’t think this actually matters, but it reduces the changes that show up if I diff my image against Valve’s.</p></ili-tangent><h3>Changing the build ID</h3><p><code>steamos-atomupd</code> reads from <code>/lib/steamos-atomupd/manifest.json</code>, or if that is somehow missing, <code>/etc/os-release</code>, to determine the version and build ID of the current image. It will refuse to perform an update if the server says the available update’s build ID is the same as the current image. It’s also good to know what image you’re running.</p><p>The build ID <em>must</em> be of the form YYYYMMDD.N. If it isn’t, <code>steamos-atomupd</code> exits with a Python traceback upon encountering it. To avoid having to remember to count up manually, I set N to a timestamp; either HHMMSS or a Unix timestamp would work fine.</p><p>Update the <code>buildid</code> field in <code>rootfs/lib/steamos-atomupd/manifest.json</code> and the <code>BUILD_ID</code> field in <code>rootfs/etc/os-release</code> with whatever you pick. You can steal from <a href="https://git.iliana.fyi/fauxlo/tree/repack.sh?id=c50eb80f23c08f1ffc824d4983d5b9a740fb1273#n47">the Bash script I wrote to do this</a>.</p><pre><code data-syntax-highlighted=""><span>--- a/lib/steamos-atomupd/manifest.json</span>
<span>+++ b/lib/steamos-atomupd/manifest.json</span>
<span>@@ -4,7 +4,7 @@</span>
<span>   &#34;variant&#34;: &#34;steamdeck&#34;,</span>
<span>   &#34;arch&#34;: &#34;amd64&#34;,</span>
<span>   &#34;version&#34;: &#34;3.5.7&#34;,</span>
<span>-  &#34;buildid&#34;: &#34;20231122.1&#34;,</span>
<span>+  &#34;buildid&#34;: &#34;20231219.55534&#34;,</span>
<span>   &#34;checkpoint&#34;: false,</span>
<span>   &#34;estimated_size&#34;: 0</span>
<span> }</span>
<span>--- a/etc/os-release</span>
<span>+++ b/etc/os-release</span>
<span>@@ -11,4 +11,4 @@</span>
<span> LOGO=steamos</span>
<span> VARIANT_ID=steamdeck</span>
<span> VERSION_ID=3.5.7</span>
<span>-BUILD_ID=20231122.1</span>
<span>+BUILD_ID=20231219.55534</span>
</code></pre><p>Keep a copy of the updated <code>manifest.json</code> handy, as it’s useful in building the updates server later.</p><h3>Changing the update URLs and signing keys</h3><p>RAUC uses X.509 certificates to establish trust. The trusted certificate lives at <code>/etc/rauc/keyring.pem</code>. You can make an overcomplicated PKI scheme, such as the <a href="https://github.com/rauc/rauc/blob/master/test/openssl-ca-create.sh">one generated in RAUC’s tests</a>, but <a href="https://rauc.readthedocs.io/en/latest/examples.html#pki-setup">a simple self-signed certificate</a> is fine. Install your new certificate at <code>rootfs/etc/rauc/keyring.pem</code>.</p><p>You’ll need to modify the URLs in <code>rootfs/etc/steamos-atomupd/client.conf</code> with your own:</p><pre><code data-syntax-highlighted=""><span>--- a/rootfs/etc/steamos-atomupd/client.conf</span>
<span>+++ b/rootfs/etc/steamos-atomupd/client.conf</span>
<span>@@ -1,5 +1,5 @@</span>
<span> [Server]</span>
<span>-QueryUrl = https://steamdeck-atomupd.steamos.cloud/updates</span>
<span>-ImagesUrl = https://steamdeck-images.steamos.cloud/</span>
<span>-MetaUrl = https://steamdeck-atomupd.steamos.cloud/meta</span>
<span>+QueryUrl = https://fauxlo.ili.fyi/updates</span>
<span>+ImagesUrl = https://fauxlo.ili.fyi/</span>
<span>+MetaUrl = https://fauxlo.ili.fyi/meta</span>
<span> Variants = rel;rc;beta;bc;main</span>
</code></pre><h3>Other changes</h3><p>You can make pretty much any change you want at this point as long as you don’t run out of space in a 5 GiB Btrfs image. For instance, if you want your SteamOS device to be resolvable as <code>hostname.local</code> on your network, you could remove <code>rootfs/usr/lib/systemd/resolved.conf.d/00-disable-mdns.conf</code>. This <em>can</em> be overridden with a configuration in the <code>/etc</code> overlay, but it’s kind of a pain in the ass.</p><p>In general, my philosophy here is that you should avoid making changes that are trivial to perform without modifying the image. You <em>could</em> install Firefox in the root filesystem this way, instead of using Flatpak or Nix, but then you’d need to repack the image every time you want to install a Firefox security update.</p><h3>Unmounting the root filesystem</h3><p>Mark the filesystem read-only once again:</p><pre><code>btrfs property set -ts rootfs ro true
</code></pre><p>Discard any unused blocks:</p><pre><code>fstrim -v rootfs
</code></pre><p>Then, unmount. <code>--recursive</code> is particularly helpful here to take care of all the pseudo-filesystems we mounted in:</p><pre><code>umount --recursive rootfs
</code></pre><h2>Creating the RAUC bundle</h2><p>First we need to create the casync store and blob index. We can do this with:</p><pre><code>mkdir bundle
casync make --store=rootfs.img.castr \
	bundle/rootfs.img.caibx rootfs.img
</code></pre><p>The RAUC bundle needs two other files. The first is <code>manifest.raucm</code>:</p><pre><code data-syntax-highlighted=""><span>cat</span><span> </span><span>&gt;</span><span>bundle/manifest.raucm</span><span> </span><span>&lt;&lt;</span><span>EOF</span>
<span>[update]</span>
<span>compatible=steamos-amd64</span>
<span>version=</span><span>$version</span>

<span>[image.rootfs]</span>
<span>sha256=$(</span><span>sha256sum</span><span> rootfs.img </span><span>|</span><span> </span><span>awk</span><span> &#39;{ print $1 }&#39;)</span>
<span>size=$(</span><span>stat</span><span> </span><span>-c</span><span> %s rootfs.img)</span>
<span>filename=rootfs.img.caibx</span>
<span>EOF</span>
</code></pre><p>The second is a <code>UUID</code> file containing the filesystem UUID:</p><pre><code>blkid -s UUID -o value rootfs.img &gt;bundle/UUID
</code></pre><p>With those three files:</p><pre><code>$ ls bundle
manifest.raucm  rootfs.img.caibx  UUID
</code></pre><p>we can now call <code>rauc bundle</code>:</p><pre><code>rauc bundle \
	--signing-keyring=cert.pem --cert=cert.pem --key=key.pem \
	bundle rootfs.img.raucb
</code></pre><p>Upload <code>rootfs.img.raucb</code> and <code>rootfs.img.caibx</code> to the web server specified by <code>ImagesUrl</code> in <code>rootfs/etc/steamos-atomupd/client.conf</code>. These need to be in the same directory.</p><h2>Final update server setup</h2><p>The web server you used for <code>QueryUrl</code> and <code>MetaUrl</code> in <code>rootfs/etc/steamos-atomupd/client.conf</code> will need to serve a JSON file. This doesn’t need to be fancy; what I do is write a <code>live.json</code> file with these contents:</p><pre><code data-syntax-highlighted=""><span>{</span>
<span>  </span><span>&#34;minor&#34;</span><span>: {</span>
<span>    </span><span>&#34;release&#34;</span><span>: </span><span>&#34;holo&#34;</span><span>,</span>
<span>    </span><span>&#34;candidates&#34;</span><span>: [</span>
<span>      {</span>
<span>        </span><span>&#34;image&#34;</span><span>: {</span>
<span>          </span><span>&#34;product&#34;</span><span>: </span><span>&#34;steamos&#34;</span><span>,</span>
<span>          </span><span>&#34;release&#34;</span><span>: </span><span>&#34;holo&#34;</span><span>,</span>
<span>          </span><span>&#34;variant&#34;</span><span>: </span><span>&#34;steamdeck&#34;</span><span>,</span>
<span>          </span><span>&#34;arch&#34;</span><span>: </span><span>&#34;amd64&#34;</span><span>,</span>
<span>          </span><span>&#34;version&#34;</span><span>: </span><span>&#34;3.5.7&#34;</span><span>,</span>
<span>          </span><span>&#34;buildid&#34;</span><span>: </span><span>&#34;20231219.55534&#34;</span><span>,</span>
<span>          </span><span>&#34;checkpoint&#34;</span><span>: </span><span>false</span><span>,</span>
<span>          </span><span>&#34;estimated_size&#34;</span><span>: </span><span>0</span>
<span>        },</span>
<span>        </span><span>&#34;update_path&#34;</span><span>: </span><span>&#34;rootfs.img.raucb&#34;</span>
<span>      }</span>
<span>    ]</span>
<span>  }</span>
<span>}</span>
</code></pre><p>Note that the object at <code>.minor.candidates[0].image</code> should be the same as <code>/lib/steamos-atomupd/manifest.json</code> in your image. <code>update_path</code> is what the updates client will append to your <code>ImagesUrl</code> to download the bundle.</p><p>I use the following Caddy configuration to rewrite the requests <code>steamos-atomupd</code> makes to <code>QueryUrl</code> and <code>MetaUrl</code> to the above <code>live.json</code>:</p><pre><code>root * /var/www/fauxlo.ili.fyi
rewrite /updates /live.json
rewrite /meta/*/*/*/*.json /live.json
rewrite /meta/*/*/*/*/*.json /live.json
file_server browse
</code></pre><p>The real SteamOS <code>QueryUrl</code> and <code>MetaUrl</code> seem to have quite a bit more logic to them, but this is sufficient to get <code>steamos-atomupd</code> to find the new update. It has logic to avoid updating if it’s already running the image advertised as currently available.</p><h2>Updating!</h2><p>Once you have all this in place, you can update an existing SteamOS installation to this by modifying <code>/etc/rauc/keyring.pem</code> and <code>/etc/steamos-atomupd/client.conf</code>. (No <code>steamos-readonly disable</code> required, as your changes will land on the <code>/etc</code> overlay; after you run <code>steamos-update</code>, consider cleaning those changes out of <code>/var/lib/overlays/etc/upper</code>.)</p><p>You can also probably install your modified SteamOS by modifying one of Valve’s recovery images, replacing their rootfs with your own. I haven’t tested this, but I also haven’t seen anything that would contradict this.</p><ili-callout role="note"><p>Thanks for reading! 2023 has been a busier-than-usual year for my blog, and I’m pretty happy about getting more writing out there. If you’ve found any of my blog posts helpful, give a trans person all of your money. See you next year!</p></ili-callout></div></div>
  </body>
</html>
