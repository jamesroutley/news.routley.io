<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.amazon.science/blog/better-performing-25519-elliptic-curve-cryptography">Original</a>
    <h1>Better-performing “25519” elliptic-curve cryptography</h1>
    
    <div id="readability-page-1" class="page"><div>
                    
                    
                        <div>
                            
                                <div>
    
        <div><p>Cryptographic algorithms are essential to online security, and at Amazon Web Services (AWS), we implement cryptographic algorithms in our open-source cryptographic library, <a href="https://github.com/aws/aws-lc" target="_blank" data-cms-ai="0">AWS LibCrypto</a> (AWS-LC), based on code from Google’s BoringSSL project. AWS-LC offers AWS customers implementations of cryptographic algorithms that are secure and optimized for AWS hardware.</p><p>Two cryptographic algorithms that have become increasingly popular are <a href="https://doi.org/10.1007/11745853_14" target="_blank" data-cms-ai="0">x25519</a> and <a href="https://doi.org/10.1007/s13389-012-0027-1" target="_blank" data-cms-ai="0">Ed25519</a>, both based on an <a href="https://en.wikipedia.org/wiki/Elliptic_curve" target="_blank" data-cms-ai="0">elliptic curve</a> known as curve25519. To improve the customer experience when using these algorithms, we recently took a deeper look at their implementations in AWS-LC. Henceforth, we use x/Ed25519 as shorthand for “x25519 and Ed25519”.</p><p>In 2023, AWS released multiple assembly-level implementations of x/Ed25519 in AWS-LC. By combining <a href="https://aws.amazon.com/what-is/automated-reasoning" target="_blank" data-cms-ai="0">automated reasoning</a> and state-of-the-art optimization techniques, these implementations improved performance over the existing AWS-LC implementations and also increased assurance of their correctness.</p><p>In particular, we prove functional correctness using automated reasoning and employ optimizations targeted to specific CPU microarchitectures for the instruction set architectures x86_64 and Arm64. We also do our best to execute the algorithms in <i>constant time</i>, to thwart side-channel attacks that infer secret information from the durations of computations.</p><p>In this post, we explore different aspects of our work, including the process for proving correctness via automated reasoning, microarchitecture (<i>μ</i>arch) optimization techniques, the special considerations for constant-time code, and the quantification of performance gains.<br/></p><h2><p>Elliptic-curve cryptography</p></h2><p>Elliptic-curve cryptography is a method for doing public-key cryptography, which uses a pair of keys, one public and one private. One of the best-known public-key cryptographic schemes is RSA, in which the public key is a very large integer, and the corresponding private key is prime factors of the integer. The RSA scheme can be used both to encrypt/decrypt data and also to sign/verify data. (Members of our team recently blogged on Amazon Science about how we used automated reasoning to make the RSA implementation on Amazon’s Graviton2 chips <a href="https://www.amazon.science/blog/formal-verification-makes-rsa-faster-and-faster-to-deploy" data-cms-ai="0">faster and easier to deploy</a>.)</p><div data-align-right-narrow="">
            <div><figure>
    

    
        <p><figcaption>Example of an elliptic curve.</figcaption></p>
    
</figure></div>
        </div><p>Elliptic curves offer an alternate way to mathematically relate public and private keys; sometimes, this means we can implement schemes more efficiently. While the mathematical theory of elliptic curves is both broad and deep, the elliptic curves used in cryptography are typically defined by an equation of the form <i>y<sup>2</sup> = x<sup>3</sup> + ax<sup>2</sup> + bx + c</i>, where <i>a, b,</i> and <i>c</i> are constants. You can plot the points that satisfy the equation on a 2-D graph.</p><p>An elliptic curve has the property that a line that intersects it at two points intersects it at at most one other point. This property is used to define operations on the curve. For instance, the addition of two points on the curve can be defined not, indeed, as the third point on the curve collinear with the first two but as that third point’s reflection around the axis of symmetry.</p><div data-align-center="">
            <div><figure>
    

    
        <p><figcaption>Addition on an elliptic curve.</figcaption></p>
    
</figure></div>
        </div><p>Now, if the coordinates of points on the curve are taken modulo some integer, the curve becomes a scatter of points in the plane, but a scatter that still exhibits symmetry, so the addition operation remains well defined. Curve25519 is named after a large prime integer — specifically, 2<sup>255</sup> – 19. The set of numbers modulo the curve25519 prime, together with basic arithmetic operations such as multiplication of two numbers modulo the same prime, define the <i>field </i>in which our elliptic-curve operations take place.</p><p>Successive execution of elliptic-curve additions is called scalar multiplication, where the scalar is the number of additions. With the elliptic curves used in cryptography, if you know only the result of the scalar multiplication, it is intractable to recover the scalar, if the scalar is sufficiently large. The result of the scalar multiplication becomes the basis of a public key, the original scalar the basis of a private key.<br/></p><h2><p>The x25519 and Ed25519 cryptographic algorithms</p></h2><p>The x/Ed25519 algorithms have distinct purposes. The x25519 algorithm is a key agreement algorithm, used to securely establish a shared secret between two peers; Ed25519 is a digital-signature algorithm, used to sign and verify data.</p><p>The x/Ed25519 algorithms have been adopted in transport layer protocols such as TLS and SSH. In 2023, NIST announced an update to its FIPS185-6 Digital Signature Standard that included the addition of Ed25519. The x25519 algorithm also plays a role in post-quantum safe cryptographic solutions, having been included as the classical algorithm in the TLS 1.3 and SSH hybrid scheme specifications for post-quantum key agreement.<br/></p><h2><p>Microarchitecture optimizations</p></h2><p>When we write assembly code for a specific CPU architecture, we use its instruction set architecture (ISA). The ISA defines resources such as the available assembly instructions, their semantics, and the CPU registers accessible to the programmer. Importantly, the ISA defines the CPU in abstract terms; it doesn’t specify how the CPU should be realized in hardware.</p><p>The detailed implementation of the CPU is called the microarchitecture, and every <i>μ</i>arch has unique characteristics. For example, while the AWS Graviton 2 CPU and AWS Graviton 3 CPU are both based on the Arm64 ISA, their <i>μ</i>arch implementations are different. We hypothesized that if we could take advantage of the <i>μ</i>arch differences, we could create x/Ed25519 implementations that were even faster than the existing implementations in AWS-LC. It turns out that this intuition was correct.</p><p>Let us look closer at how we took advantage of <i>μ</i>arch differences. Different arithmetic operations can be defined on curve25519, and different combinations of those operations are used to construct the x/Ed25519 algorithms. Logically, the necessary arithmetic operations can be considered at three levels:<br/></p><ol><li><b>Field operations:</b> Operations within the field defined by the curve25519 prime 2<sup>255</sup> – 19.</li><li><b>Elliptic-curve group operations:</b> Operations that apply to elements of the curve itself, such as the addition of two points, P1 and P2.</li><li><b>Top-level operations:</b> Operations implemented by iterative application of elliptic-curve group operations, such as scalar multiplication.</li></ol><div data-align-center-expanded="">
            <div><figure>
    

    
        <p><figcaption>Examples of operations at different levels. Arrows indicate dependency relationships between levels.</figcaption></p>
    
</figure></div>
        </div><p>Each level has its own avenues for optimization. We focused our <i>μ</i>arch-dependent optimizations on the level-one operations, while for levels two and three our implementations employ known state-of-the-art techniques and are largely the same for different <i>μ</i>archs. Below, we give a summary of the different <i>μ</i>arch-dependent choices we made in our implementations of x/Ed25519.<br/></p><ul><li>For modern x86_64 <i>μ</i>archs, we use the instructions MULX, ADCX, and ADOX, which are variations of the standard assembly instructions MUL (multiply) and ADC (add with carry) found in the instruction set extensions commonly called <a href="https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set" target="_blank" data-cms-ai="0">BMI</a> and <a href="https://en.wikipedia.org/wiki/Intel_ADX" target="_blank" data-cms-ai="0">ADX</a>. These instructions are special because, when used in combination, they can maintain two carry chains in parallel, which has been observed to boost performance up to 30%. For older x86_64 <i>μ</i>archs that don’t support the instruction set extensions, we use more traditional single-carry chains.<br/></li><li>For Arm64 <i>μ</i>archs, such as AWS Graviton 3 with improved integer multipliers, we use relatively straightforward schoolbook multiplication, which turns out to give good performance. AWS Graviton 2 has smaller multipliers. For this Arm64 <i>μ</i>arch, we use subtractive forms of <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm" target="_blank" data-cms-ai="0">Karatsuba multiplication</a>, which breaks down multiplications recursively. The reason is that, on these <i>μ</i>archs, 64x64-bit multiplication producing a 128-bit result has substantially lower throughput relative to other operations, making the number size at which Karatsuba optimization becomes worthwhile much smaller.</li></ul><p>We also optimized level-one operations that are the same for all <i>μ</i>archs. One example concerns the use of the binary greatest-common-divisor (GCD) algorithm to compute <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse" target="_blank" data-cms-ai="0">modular inverses</a>. We use the <a href="https://gcd.cr.yp.to/safegcd-20190413.pdf" target="_blank" data-cms-ai="0">“divstep” form of binary GCD</a>, which lends itself to efficient implementation, but it also complicates the second goal we had: formally proving correctness.</p><p>Binary GCD is an iterative algorithm with two arguments, whose initial values are the numbers whose greatest common divisor we seek. The arguments are successively reduced in a well-defined way, until the value of one of them reaches zero. With two <i>n</i>-bit numbers, the standard implementation of the algorithm removes at least one bit total per iteration, so 2<i>n</i> iterations suffice.</p><p>With divstep, however, determining the number of iterations needed to get down to the base case seems analytically difficult. The most tractable proof of the bound uses an elaborate inductive argument based on an intricate “stable hull” provably overapproximating the region in two-dimensional space containing the points corresponding to the argument values. Daniel Bernstein, one of the inventors of x25519 and Ed25519, proved the <a href="https://cr.yp.to/papers.html#pwccp" target="_blank" data-cms-ai="0">formal correctness</a> of the bound using <a href="https://hol-light.github.io/" target="_blank" data-cms-ai="0">HOL Light</a>, a proof assistant that one of us (John) created. (For more on HOL Light, see, again, our earlier <a href="https://www.amazon.science/blog/formal-verification-makes-rsa-faster-and-faster-to-deploy" data-cms-ai="0">RSA post</a>.)<br/></p><h2><p>Performance results</p></h2><p>In this section, we will highlight improvements in performance. For the sake of simplicity, we focus on only three <i>μ</i>archs: AWS Graviton 3, AWS Graviton 2, and Intel Ice Lake. To gather performance data, we used EC2 instances with matching CPU <i>μ</i>archs — c6g.4xlarge, c7g.4xlarge, and c6i.4xlarge, respectively; to measure each algorithm, we used the <a href="https://github.com/aws/aws-lc/tree/main/tool#benchmarking-tools" target="_blank" data-cms-ai="0">AWS-LC speed tool</a>.</p><p>In the graphs below, all units are operations per second (ops/sec). The “before” columns represent the performance of the existing x/Ed25519 implementations in AWS-LC. The “after” columns represent the performance of the new implementations.</p><div data-align-center="">
            <div><figure>
    

    
        <p><figcaption>For the Ed25519 signing operation, the number of operations per second, over the three μarchs, is, on average, 108% higher with the new implementations.</figcaption></p>
    
</figure></div>
        </div><div data-align-center="">
            <div><figure>
    

    
        <p><figcaption>For the Ed25519 verification operation, we increased the number of operations per second, over the three μarchs, by an average of 37%.</figcaption></p>
    
</figure></div>
        </div><p>We observed the biggest improvement for the x25519 algorithm. Note that an x25519 operation in the graph below includes the two major operations needed for an x25519 key exchange agreement: base-point multiplication and variable-point multiplication.</p><div data-align-center="">
            <div><figure>
    

    
        <p><figcaption>With x25519, the new implementation increases the number of operations per second, over the three μarchs, by an average of 113%.</figcaption></p>
    
</figure></div>
        </div><p>On average, over the AWS Graviton 2, AWS Graviton 3, and Intel Ice Lake microarchitectures, we saw an 86% improvement in performance.<br/></p><h2><p>Proving correctness</p></h2><p>We develop the core parts of the x/Ed25519 implementations in AWS-LC in <a href="https://github.com/awslabs/s2n-bignum" target="_blank" data-cms-ai="0">s2n-bignum</a>, an AWS-owned library of integer arithmetic routines designed for cryptographic applications. The s2n-bignum library is also where we prove the functional correctness of the implementations using <a href="https://hol-light.github.io/" target="_blank" data-cms-ai="0">HOL Light</a>. HOL Light is an interactive theorem prover for higher-order logic (hence HOL), and it is designed to have a particularly simple (hence light) “correct by construction” approach to proof. This simplicity offers assurance that anything “proved” has really been proved rigorously and is not the artifact of a prover bug.</p><p>We follow the same principle of simplicity when we write our implementations in assembly. Writing in assembly is more challenging, but it offers a distinct advantage when proving correctness: our proofs become independent of any compiler.</p><p>The diagram below shows the process we use to prove x/Ed25519 correct. The process requires two different sets of inputs: first is the algorithm implementation we’re evaluating; second is a proof script that models both the correct mathematical behavior of the algorithm and the behavior of the CPU. The proof is a sequence of functions specific to HOL Light that represent proof strategies and the order in which they should be applied. Writing the proof is not automated and requires developer ingenuity.</p><p>From the algorithm implementation and the proof script, HOL Light either determines that the implementation is correct or, if unable to do so, fails. HOL Light views the algorithm implementation as a sequence of machine code bytes. Using the supplied specification of CPU instructions and the developer-written strategies in the proof script, HOL Light reasons about the correctness of the execution.</p><div data-align-left="">
            <div><figure>
    

    
        <p><figcaption>CI integration provides assurance that no changes to the algorithm implementation code can be committed to s2n-bignum’s code repository without successfully passing a formal proof of correctness.</figcaption></p>
    
</figure></div>
        </div><p>This part of the correctness proof is automated, and we even implement it inside s2n-bignum’s continuous-integration (CI) workflow. The workflow covered in the CI is highlighted by the red dotted line in the diagram below. CI integration provides assurance that no changes to the algorithm implementation code can be committed to s2n-bignum’s code repository without successfully passing a formal proof of correctness.</p><p>The CPU instruction specification is one of the most critical ingredients in our correctness proofs. For the proofs to be true in practice, the specification must capture the real-world semantics of each instruction. To improve assurance on this point, we apply randomized testing against the instruction specifications on real hardware, “fuzzing out” inaccuracies.<br/></p><h2><p>Constant time</p></h2><p>We designed our implementations and optimizations with security as priority number one. Cryptographic code must strive to be free of <a href="https://en.wikipedia.org/wiki/Side-channel_attack" target="_blank" data-cms-ai="0">side channels</a> that could allow an unauthorized user to extract private information. For example, if the execution time of cryptographic code depends on secret values, then it might be possible to infer those values from execution times. Similarly, if CPU cache behavior depends on secret values, an unauthorized user who shares the cache could infer those values.</p><p>Our implementations of x/Ed25519 are designed with constant time in mind. They perform exactly the same sequence of basic CPU instructions regardless of the input values, and they avoid any CPU instructions that might have data-dependent timing.<br/></p><h2><p>Using x/Ed25519 optimizations in applications</p></h2><p>AWS uses AWS-LC extensively to power cryptographic operations in a diverse set of AWS service subsystems. You can take advantage of the x/Ed25519 optimizations presented in this blog by using AWS-LC in your application(s). Visit <a href="https://github.com/aws/aws-lc" target="_blank" data-cms-ai="0">AWS-LC on Github</a> to learn more about how you can integrate AWS-LC into your application.</p><p>To allow easier integration for developers, AWS has created bindings from AWS-LC to multiple programming languages. These bindings expose cryptographic functionality from AWS-LC through well-defined APIs, removing the need to reimplement cryptographic algorithms in higher-level programming languages. At present, AWS has open-sourced bindings for Java and Rust — the Amazon Corretto Cryptographic Provider (<a href="https://aws.amazon.com/blogs/security/accelerating-jvm-cryptography-with-amazon-corretto-crypto-provider-2" target="_blank" data-cms-ai="0">ACCP</a>) for Java, and AWS-LC for Rust (<a href="https://aws.amazon.com/blogs/opensource/introducing-aws-libcrypto-for-rust-an-open-source-cryptographic-library-for-rust" target="_blank" data-cms-ai="0">aws-lc-rs</a>). Furthermore, we have contributed patches allowing <a href="https://discuss.python.org/t/support-building-ssl-and-hashlib-modules-against-aws-lc/44505/8" target="_blank" data-cms-ai="0">CPython</a> to build against AWS-LC and use it for all cryptography in the Python standard library. Below we highlight some of the open-source projects that are already using AWS-LC to meet their cryptographic needs.</p><div data-align-center="">
            <div><figure>
    

    
        <p><figcaption>Open-source projects using AWS-LC to meet their cryptographic needs.</figcaption></p>
    
</figure></div>
        </div><p>We are not done yet. We continue our efforts to improve x/Ed25519 performance as well as pursuing optimizations for other cryptographic algorithms supported by s2n-bignum and AWS-LC. Follow the <a href="https://github.com/awslabs/s2n-bignum" target="_blank" data-cms-ai="0">s2n-bignum</a> and <a href="https://github.com/aws/aws-lc" target="_blank" data-cms-ai="0">AWS-LC</a> repositories for updates.</p></div>
    
</div>

                            
                        </div>
                    
                </div><div>
                        
                            
    <div>
        <div>
            
                
            
            
            
                <p>
                    Torben Hansen is an applied scientist with AWS Cryptography.
                </p>
            
        </div>
    </div>


                        
                            
    <div>
        <div>
            
                
            
            
            
                <p>
                    John Harrison is a senior principal applied scientist in Amazon’s Automated Reasoning Group. He is a maintainer of s2n-bignum and the HOL Light theorem prover.
                </p>
            
        </div>
    </div>


                        
                    </div></div>
  </body>
</html>
