<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bvisness.me/luax/">Original</a>
    <h1>LuaX: A Lua Dialect with JSX</h1>
    
    <div id="readability-page-1" class="page"><div>
        

        
    <article>
      <header>
        
        
        <p><time datetime="2023-12-27T12:00:00+0000" itemprop="datePublished">December 27, 2023</time>
        </p>
    
      </header>
      
  <p>
    This website now runs on a custom language called <strong>LuaX</strong>.
  </p>
  
  <p>
    It’s like JSX, but for Lua. You just write a Lua file that returns a chunk of HTML. You can compose more interesting pages by writing functions that return HTML. Here’s what the home page of my site looks like in LuaX:
  </p>

<pre><code><span><span><span>-- I can define whatever data I like in plain old Lua.</span>
</span></span><span><span><span>local</span> <span>articles</span> <span>=</span> <span>{</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    <span>title</span> <span>=</span> <span>&#34;I made JSX for Lua (because I hate static sites)&#34;</span><span>,</span>
</span></span><span><span>    <span>description</span> <span>=</span> <span>&#34;This site now runs on a custom dialect of Lua.&#34;</span><span>,</span>
</span></span><span><span>    <span>slug</span> <span>=</span> <span>&#34;luax&#34;</span><span>,</span>
</span></span><span><span>    <span>date</span> <span>=</span> <span>os.time</span><span>({</span> <span>year</span> <span>=</span> <span>2023</span><span>,</span> <span>month</span> <span>=</span> <span>12</span><span>,</span> <span>day</span> <span>=</span> <span>27</span> <span>}),</span>
</span></span><span><span>  <span>},</span>
</span></span><span><span>  <span>-- more articles...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>-- &#34;Components&#34; are just Lua functions that return HTML.</span>
</span></span><span><span><span>-- Lua expressions can be placed in attributes or text.</span>
</span></span><span><span><span>function</span> <span>Article</span><span>(</span><span>atts</span><span>,</span> <span>children</span><span>)</span>
</span></span><span><span>  <span>local</span> <span>a</span> <span>=</span> <span>atts.article</span>
</span></span><span><span>  <span>return</span> <span><span><span>&lt;</span><span>article</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>header</span><span>&gt;</span>
</span></span><span><span>      <span>&lt;</span><span>h1</span><span>&gt;&lt;</span><span>a</span> <span>href</span><span>=</span><span><span>{</span> <span>absurl</span><span>(</span><span>a.slug</span><span>)</span> <span>}</span></span><span>&gt;</span><span>{{</span> <span>a.title</span> <span>}}</span><span>&lt;/</span><span>a</span><span>&gt;&lt;/</span><span>h1</span><span>&gt;</span>
</span></span><span><span>      <span>&lt;</span><span>span</span> <span>class</span><span>=</span><span>&#34;post-details&#34;</span><span>&gt;</span>
</span></span><span><span>        <span>&lt;</span><span>time</span> <span>datetime</span><span>=</span><span>{</span> <span><span>os.date</span><span>(</span><span>&#34;%Y-%m-%dT%H:%M:%S%z&#34;</span><span>,</span> <span>atts.date</span><span>)</span></span> <span>}</span> <span>itemprop</span><span>=</span><span>&#34;datePublished&#34;</span><span>&gt;</span>
</span></span><span><span>          <span>{{</span> <span>os.date</span><span>(</span><span>&#34;%B %-d, %Y&#34;</span><span>,</span> <span>atts.date</span><span>)</span> <span>}}</span>
</span></span><span><span>        <span>&lt;/</span><span>time</span><span>&gt;</span>
</span></span><span><span>      <span>&lt;/</span><span>span</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;/</span><span>header</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>p</span><span>&gt;</span>
</span></span><span><span>      <span>{{</span> <span>a.description</span> <span>}}</span>
</span></span><span><span>    <span>&lt;/</span><span>p</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;/</span><span>article</span><span>&gt;</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>-- I can use Lua&#39;s package system to organize my templates.</span>
</span></span><span><span><span>require</span><span>(</span><span>&#34;base&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>-- Whatever the file returns will be rendered and sent to the browser.</span>
</span></span><span><span><span>return <span>&lt;</span><span>Base</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;</span><span>div</span> <span>class</span><span>=</span><span>&#34;list&#34;</span><span>&gt;</span>
</span></span><span><span>    <span>{{</span> <span>map</span><span>(</span><span>articles</span><span>,</span> <span>function</span> <span>(</span><span>a</span><span>)</span>
</span></span><span><span>      <span>&lt;</span><span>Article</span> <span>article</span><span>=</span><span>{</span> <span>a</span> <span>}</span> <span>/&gt;</span>
</span></span><span><span>    <span>end</span><span>)</span> <span>}}</span>
</span></span><span><span>  <span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span><span><span><span>&lt;/</span><span>Base</span><span>&gt;</span>
</span></span></span></span></span></code></pre>

  <h2 id="butwhy">But…why?</h2>

  <p>Because I hate static sites. No, seriously. I actually hate static sites.</p>
  <p>I got into programming because I wanted to make websites. When I started out, you could just copy HTML files up to your server and you had a website. It was magical! And PHP made it even better; you could just throw in a little snippet of server-side code and you had a dynamic page.</p>
  <p>Those days are gone. Today I spend my time organizing Markdown files into folders so a janky tool can cobble them together into a website. I spend my time learning weird template languages with weird functions and bad control flow. I spend my time in cloud control panels getting confused by bucket permissions and CDN settings.</p>
  <p>It feels like we’ve regressed. 15 years ago it was fine to run a script from scratch on every single request, but today we insist that we have to serve every personal website from a CDN. That means no fun allowed—if you so much as want the ©2023 in the footer to update, you’ll need to rebuild and redeploy the site.</p>
  <p>I don’t want that. I want my ©2023 to update dynamically, dammit.</p>
  <p>What’s saddest to me is that when people <em>do</em> want that dynamism (and they often do), they end up doing it with JavaScript, making their pages heavier and slower. Then to compensate for this, they’ll add some kind of “serverless” backend, server-side rendering + hydration, and a pile of extra complexity. Instead of just doing a little server-side code, they’re wasting people’s CPU time and their own money.</p>
  <p>I don’t miss PHP, of course. But I do miss the workflow. For my own personal site, I don’t want to worry about a “backend” and “frontend”—I just want to send some HTML and JavaScript to the browser. I want a “deployment” to be as simple as copying a new batch of files to my server, but I want to be able to do interesting logic in those files too.</p>
  <p>I want a dynamic site, not a static one.</p>

  <h2 id="butwhy-jsx">But…why JSX?</h2>
  <p>Because I like it.</p>
  <p>I have tried so many template languages over the years. I’ve used <a href="https://mustache.github.io/">mustache</a>, <a href="https://jekyllrb.com/docs/liquid/">Liquid</a>, <a href="https://mozilla.github.io/nunjucks/">nunjucks</a>, <a href="https://laravel.com/docs/5.0/templates">Blade</a>, <a href="https://docs.djangoproject.com/en/1.11/ref/templates/">Django</a>, and of course <a href="https://pkg.go.dev/text/template">Go templates</a> (commonly seen in systems like <a href="https://gohugo.io/">Hugo</a>).</p>
  <p>All of these languages have basically the same design, which I’ll call the <strong>preprocessor model</strong>. They all start with the assumption that a “template” is a mostly static piece of content (in this case HTML) with some slots to paste in dynamic values. It’s more or less just the C preprocessor, a simple find-and-replace pass over the original content.</p>
  <p>But this is never actually enough. You start out with simple values and ranges, but rapidly escalate to tricky conditional logic, weird inheritance systems, and eventually custom functions written in the host language that are injected into the template language.</p>
  <p>Just like the C preprocessor, these template languages are not real languages. They are inflexible and inextensible. The few tools they provide for reuse and composition are incredibly weak. And just like C macros, these languages aren’t powerful enough to manipulate the data they’re given, only to blindly spit it back out.</p>
  <p>Basically, these languages are too weak to do anything interesting. When writing my article about doing <a href="https://bvisness.me/advent-of-dreams/">Advent of Code on a PS5</a>, I found myself frequently reusing specific layouts, e.g. a wide layout that displayed two columns side-by-side but reflowed to vertical on mobile. In Go templates, this was an utter disaster:</p>

  <pre><code><span><span><span>&lt;!-- Template definitions --&gt;</span>
</span></span><span><span>{{ define &#34;wide-start&#34; }}
</span></span><span><span><span>&lt;</span><span>div</span> <span>class</span><span>=</span><span>&#34;wide flex justify-center mv4&#34;</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;</span><span>div</span> <span>class</span><span>=</span><span>&#34;flex flex-column flex-row-l {{ if not . }}items-center{{ else }}{{ . }}{{ end }} g4&#34;</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>div</span> <span>class</span><span>=</span><span>&#34;w-100 flex-fair-l p-dumb&#34;</span><span>&gt;</span>
</span></span><span><span>{{ end }}
</span></span><span><span>{{ define &#34;wide-middle&#34; }}
</span></span><span><span>    <span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>div</span> <span>class</span><span>=</span><span>&#34;w-100 flex-fair-l p-dumb&#34;</span><span>&gt;</span>
</span></span><span><span>{{ end }}
</span></span><span><span>{{ define &#34;wide-end&#34; }}
</span></span><span><span>    <span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span><span><span><span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span><span><span>{{ end }}
</span></span><span><span>
</span></span><span><span><span>&lt;!-- Later in the article --&gt;</span>
</span></span><span><span>{{ template &#34;wide-start&#34; }}
</span></span><span><span><span>&lt;</span><span>p</span><span>&gt;</span>Before we go further, let me introduce you to programming in Dreams...<span>&lt;/</span><span>p</span><span>&gt;</span>
</span></span><span><span>{{ template &#34;wide-middle&#34; . }}
</span></span><span><span>{{ template &#34;video&#34; &#34;basics&#34; }}
</span></span><span><span>{{ template &#34;wide-end&#34; . }}</span></span></code></pre>

  <p>The problem is that no preprocessor-style template language actually allows you to manipulate the HTML <em>as data</em>. The HTML is opaque; the template language doesn’t understand it. But web pages are complex documents that often need serious logic to assemble—logic that requires the template language to work with the document structure instead of just text.</p>
  <p>Even PHP falls short of this standard. <a href="https://www.php.net/manual/en/types.comparisons.php#60202">Language jank</a> and <a href="http://phpsadness.com/">terrible design</a> aside, PHP is at least a “real” programming language. It has arrays and loops and functions and so on. But it still doesn’t understand HTML. It’s basically just a fancier version of the preprocessor model, and it suffers from the same problems. (This design also can be blamed for the long history of XSS vulnerabilities in PHP apps. PHP itself doesn’t understand how to escape things, so the developer must be constantly vigilant.)</p>
  <p>The preprocessor model is fundamentally wrong. HTML documents should be built with a system that understands HTML.</p>
  <p>This is why JSX is so much better. Instead of JS-inside-HTML, it’s HTML-inside-JS. It flips the ownership around. When you need to do something interesting, you don’t need to learn some underpowered language, or contort your work to fit a broken system, or remember which escaping functions to use. You just <em>write code</em> and the rest sorts itself out.</p>
  <p>It’s important to note that JSX is distinct from React, or Svelte, or whatever other frontend framework it is usually associated with. I’m not a fan of those frameworks; they have lots of ideas about client-side reactivity that I don’t like and don’t care about. But I really like writing HTML inside a real programming language.</p>
  <h2 id="butwhy-lua">But…why Lua?</h2>
  <p>Because I like it.</p>
  <p>I considered just using JSX. But my website is built in Go, and I wanted to keep it that way. I find Go’s tooling to be best-in-class when it comes to deploying on a server—build a binary, start it up, the end. In contrast, every time I’ve deployed a Node app, I have suffered immensely.</p>
  <p>What I wanted was something I could embed easily in an existing app. Lua fit the bill nicely. But even more importantly, Lua is <em>extremely</em> easy to parse. The <a href="https://www.lua.org/manual/5.1/manual.html#8">entire language grammar</a> fits on one screen, and the <a href="https://www.lua.org/source/5.1/lparser.c.html">official parser</a> is less than 1500 lines of code. Furthermore, Lua didn’t use <code>&lt;</code> for anything except comparisons, so there was no ambiguity—HTML tags could be used wherever tables were used.</p>
  <p>It was therefore very easy to create a custom recursive descent parser. I mostly just ported the official parser to Go, and modified <code>parseSimpleExp</code> to parse tags as well as tables.</p>

  <pre><code><span><span><span>func</span> <span>(</span><span>t</span> <span>*</span><span>Transpiler</span><span>)</span> <span>parseSimpleExp</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>switch</span> <span>tok</span> <span>:=</span> <span>t</span><span>.</span><span>peekToken</span><span>();</span> <span>tok</span> <span>{</span>
</span></span><span><span>  <span>case</span> <span>&#34;nil&#34;</span><span>,</span> <span>&#34;true&#34;</span><span>,</span> <span>&#34;false&#34;</span><span>,</span> <span>&#34;...&#34;</span><span>:</span>
</span></span><span><span>    <span>t</span><span>.</span><span>nextToken</span><span>()</span>
</span></span><span><span>  <span>case</span> <span>&#34;{&#34;</span><span>:</span>
</span></span><span><span>    <span>t</span><span>.</span><span>parseTable</span><span>()</span>
</span></span><span><span>  <span>case</span> <span>&#34;&lt;&#34;</span><span>:</span>                    <span>// these two lines were all I needed to add :)
</span></span></span><span><span><span></span>    <span>t</span><span>.</span><span>parseTag</span><span>(</span><span>t</span><span>.</span><span>indent</span><span>,</span> <span>true</span><span>)</span> <span>// (well and t.parseTag itself obviously)
</span></span></span><span><span><span></span>  <span>case</span> <span>&#34;function&#34;</span><span>:</span>
</span></span><span><span>    <span>t</span><span>.</span><span>nextToken</span><span>()</span>
</span></span><span><span>    <span>t</span><span>.</span><span>parseFuncBody</span><span>()</span>
</span></span><span><span>  <span>default</span><span>:</span>
</span></span><span><span>    <span>if</span> <span>isNumber</span><span>(</span><span>tok</span><span>)</span> <span>||</span> <span>isString</span><span>(</span><span>tok</span><span>)</span> <span>{</span>
</span></span><span><span>      <span>t</span><span>.</span><span>nextToken</span><span>()</span>
</span></span><span><span>      <span>return</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>t</span><span>.</span><span>parseSuffixedExp</span><span>()</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span></span></span></code></pre>

  <p>My transpiler doesn’t even produce an abstract syntax tree. It doesn’t need to. It just emits the vanilla Lua code as-is, and converts HTML tags to Lua tables as it goes.</p>

  <pre><code><span><span><span>-- Before:</span>
</span></span><span><span><span>local</span> <span>image</span> <span>=</span> <span>&lt;</span><span>img</span> <span>class</span><span>=</span><span>&#34;w-100&#34;</span> <span>src</span><span>=</span><span>&#34;cool.png&#34;</span> <span>/&gt;</span>
</span></span><span><span><span>-- After:</span>
</span></span><span><span><span>local</span> <span>image</span> <span>=</span> <span>{</span> <span>type</span> <span>=</span> <span>&#34;html&#34;</span><span>,</span> <span>name</span> <span>=</span> <span>&#34;img&#34;</span><span>,</span> <span>atts</span> <span>=</span> <span>{</span> <span>class</span> <span>=</span> <span>&#34;w-100&#34;</span><span>,</span> <span>src</span> <span>=</span> <span>&#34;cool.png&#34;</span> <span>},</span> <span>children</span> <span>=</span> <span>{}</span><span>,</span> <span>}</span></span></span></code></pre>

  <p>The <a href="https://github.com/bvisness/bvisness.me/blob/2719c40e620f5721801758d4d4e6714abfaabc2b/bhp/transpile.go">end result</a> is less than 1000 lines of code. About 700 of them are just parsing Lua, with the remaining ~300 being used for my new features. And it took me only a couple days!</p>

  <h2 id="before-and-after">Before and after</h2>
  <p>I’ve ported every page of this website over to LuaX, and the more I use it, the more I like it. It elegantly handles all the things that were so painful to do in previous template systems.</p>
  <p>For example: I have an image-resizing system built into my site, designed for use with the HTML <code>&lt;picture&gt;</code> tag. When using this system with Go templates, I couldn’t include the <code>&lt;picture&gt;</code> tag in the template because I needed to be able to set arbitrary CSS classes on it. This meant that using the template required me to manually write the outer tag, then use the template on the inside. Furthermore, I had to built a custom “options” system for the <code>alt</code> attribute, and of course I had to implement all this in a custom template function written in Go. This is all easy now and I don’t have to switch languages.</p>

  

  <p>My <a href="https://bvisness.me/desmos/">Desmos 3D</a> article required me to generate unique IDs for each Desmos graph. In Hugo I had to use the <a href="https://gohugo.io/methods/page/scratch/">“scratch”</a> system to store and manipulate data in Hugo itself. Now I can just do a global  in my LuaX file. Furthermore, I had to register a new <code>desmos</code> <a href="https://gohugo.io/content-management/shortcodes/">shortcode</a> globally across my entire site; this is now just a Lua function specific to that article.</p>

  

  <p>A tag’s children can be accessed programmatically, enabling me to make wrapper components like <code>Wide</code> with ease. This was extraordinarily painful in Go templates, requiring me to define separate templates for the beginning, middle, and end of the HTML.</p>

  

  <p>But by far the biggest impact was on my <a href="https://bvisness.me/advent-of-dreams/">Advent of Code on a PlayStation</a> article. Before, due to the limited expressiveness of Go templates, I had to carefully construct all the HTML for each day of Advent of Code, with templates only for smaller reusable chunks. Doing things differently with Go templates would have required me to encode all the data in my Go code and then pass it into the template, which might be reasonable but didn’t fit my workflow. With LuaX, though, I can just loop over a Lua table and call it a day—no need to switch languages.</p>

  

  <h2 id="closing-thoughts">Closing thoughts</h2>
  <p>My goal with this project was to make myself happy, and I think I succeeded. 🙂</p>
  <p>I’m very happy with how LuaX feels so far. It’s not “ready for production”, in the sense that I have cut several corners on the parser, but it meets all my needs right now and I love using it.</p>
  <p>Taking a step back, though, it’s very gratifying to be able to bang out a transpiler in a weekend. Earlier in my career I would have started with lex and yacc and probably gotten lost. (This has happened to me multiple times.) These days though I understand compilers well enough to just sit down and write one, and it feels great.</p>
  <p>I spent almost all of this year working on projects for other people. While I am proud of the work I did, and enjoyed it, there’s still something special about making tools for yourself. Does anyone else in the world want to make their websites in a weird dialect of Lua? Maybe not. But I do, and that’s enough.</p>
  <p>I don’t know what the future holds for LuaX. It’s not ready for other people to use, and I’m not sure it will ever be. So rather than tell you all to go to luax dot dev and start building your websites with my tool, here’s what I’ll say instead:</p>
  <p><strong>Try building something for yourself.</strong> Try writing code for you, and you alone. Don’t worry about whether it will look good on your resumé or attract lots of stars on GitHub. Just write something that feels good to you. Explore a weird idea and see where it takes you.</p>
  <p>Who knows—maybe someday other people will like it too.</p>


    </article>
  
      </div></div>
  </body>
</html>
