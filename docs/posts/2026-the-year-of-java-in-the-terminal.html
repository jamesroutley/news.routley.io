<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xam.dk/blog/lets-make-2026-the-year-of-java-in-the-terminal/">Original</a>
    <h1>2026: The Year of Java in the Terminal?</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
      <div>
          <div>
              <div id="preamble">
<div>
<p>Look, I’m going to say something that might sound crazy to some of you: Java deserves to be better in the terminal. And 2026? That’s going to be the year we fix it!</p>
<p>I’ve been watching people get absolutely amazed by AI terminal applications lately. LLM-powered CLI tools that help you write code, answer questions, generate content—all from your terminal. And you know what they’re all written in? Python. Rust. Go. Node.js. Everything except Java.</p>
<p>Meanwhile, millions of Java developers are sitting there thinking they need to learn Rust or Go to build something cool in the terminal. You don’t.</p>
<p>But here’s the thing: there’s nothing stopping us from building those exact same tools in Java. Nothing. We’ve got HTTP clients, JSON libraries, streaming APIs, everything you need. The only thing we’re missing is the belief that Java belongs and works well in the terminal.</p>
<p>For too long, we’ve accepted this weird reality where Java is everywhere—running massive enterprise systems, powering Android apps, handling billions of transactions—but when it comes to quick CLI tools, scripting, or just hacking around in the terminal, most Java developers reach for Python, Node, Go, or worse - do nothing at all. That needs to change.</p>
</div>
</div>
<div>
<h2 id="why-now">Why Now</h2>
<div>
<p>Most of the needed tools are here. PicoCLI is well-known for handling argument passing. Project Loom gave us virtual threads—great for easy concurrency. GraalVM native image keeps getting better and faster. JBang makes running Java scripts as easy as running Python. JBang and JReleaser handle all your distribution headaches. The Java platform and its ecosystem have matured to the point where the old excuses just don’t hold up anymore.</p>
<p>Remember when we said &#34;Java is too slow to start&#34;?</p>
<p>Try a modern Java runtime. It’s not slow.</p>
<p>&#34;Java tooling is too heavy&#34;? Modern Java with jshell, single-file source programs, and tools like jbang are as lightweight as you want them to be.</p>
<p>&#34;Java is too verbose for quick scripts&#34;? JBang lets you write a single .java file with dependencies declared right at the top and run it immediately. No build files, no ceremony, just code. JBang works on any Java version.</p>
<p>&#34;Distribution is too complicated&#34;? JReleaser automates the entire release process—GitHub releases, Homebrew taps, SDKMAN, Docker images, native packages, you name it.</p>
<p>Every excuse you’ve been telling yourself? It’s outdated. The Java you think you know isn’t the Java that exists today.</p>
</div>
</div>
<div>
<h2 id="but-waitits-not-just-about-scripts">But Wait—It’s Not Just About Scripts</h2>
<div>
<p>Here’s where it gets really interesting: I’m not just talking about replacing your bash scripts with Java. I’m talking about building proper terminal applications. You know, the kind of beautiful TUIs you see in the Rust ecosystem with <a href="https://ratatui.rs/">ratatui</a>, or Python with <a href="https://textual.textualize.io/">textual</a> or Go’s Bubble Tea from <a href="https://charm.land/">Charm</a>.</p>
<p>Think about it. Why should terminal UI applications be the exclusive domain of other languages? We’ve had <a href="https://github.com/mabe02/lanterna">Lanterna</a> and <a href="https://jexer.sourceforge.io/">Jexer</a> for decades, but never really reaching the mainstream. Now Jexer has a new fork in <a href="https://github.com/crramirez/casciian">Casciian</a>, and there’s even a start of a Bubbletea port at <a href="https://github.com/flatscrew/latte">Latte</a>. The pieces are there to build something amazing.</p>
<p>Imagine dashboards, file managers, log viewers, monitoring tools, AI chat interfaces with rich formatting—all with gorgeous terminal UIs, all written in Java, all running fast with native images, all leveraging the entire Java ecosystem.</p>
<p>We need our <strong>ratatui moment</strong>.</p>
<p>And honestly? The foundation is already there. We just need to push it forward, make it easier, make it beautiful.</p>
</div>
</div>
<div>
<h2 id="this-is-not-about-competition-it-is-about-addition">This Is Not About Competition - It Is About Addition</h2>
<div>
<p>Let me be clear: this isn’t about taking away from the amazing work happening in Rust, Python, Go, or any other ecosystem. Those communities are doing incredible things with terminal tooling, and we should celebrate and be inspired by that.</p>
<p>This is about making the Java ecosystem aware that they can just as easily—if not even better—help add to the world of terminal-based tools. We have millions of Java developers who know the language deeply, understand the ecosystem, and could be building amazing CLI tools and TUIs but think they need to learn Rust or Go first.</p>
<p>You don’t.</p>
<p>You already know Java. You already know how to build things. Stop reaching for another language just because you think Java &#34;doesn’t do terminals.&#34; It does. You just haven’t tried.</p>
<p>The terminal tool landscape benefits from diversity. Different tools, different approaches, different ecosystems all contributing. Java developers bring something unique to the table: a massive library ecosystem, battle-tested concurrency primitives, enterprise-grade reliability, and now with modern Java, the performance and startup characteristics to match anyone.</p>
<p>We’re not trying to replace anything. We’re trying to expand what’s possible. More tools. More options. More developers contributing to making terminal experiences better for everyone.</p>
</div>
</div>
<div>
<h2 id="the-jbang-revolution">The JBang Revolution</h2>
<div>
<p>And let’s talk about what <a href="https://www.jbang.dev/">JBang</a> really is, because I think many are missing its true potential.</p>
<p>Yes, JBang runs single-file Java scripts. But it’s so much more than that.</p>
<p>Got a fat JAR from a Gradle or Maven build? <code>jbang myapp.jar</code> and you’re running.</p>
<p>Want to run something straight from Maven Central? <code>jbang group:artifact:version</code> and JBang downloads it and runs it.</p>
<p>Need custom Java flags for better performance or native libraries? JBang handles that too.</p>
<p>This is the distribution model we’ve been missing.</p>
<p>You don’t need Docker containers for simple CLI tools. You don’t need complex installation instructions. You don’t need users to have the right Java version installed — JBang can even manage that.</p>
<p>&#34;Here’s my tool: <code>jbang app@myuser/myrepo`&#34;, or just `jbang org.example:mytool:1.0.0</code> and run it directly from Maven central.</p>
<p>Done. That’s the entire installation instruction. JBang downloads, resolves dependencies, and runs it.</p>
<p>It’s trivial today to make most Java applications runnable on anyone else’s machine.</p>
</div>
</div>
<div>
<h2 id="distribution-that-actually-works">Distribution That Actually Works</h2>
<div>
<p>But here’s where it gets even better. You know what used to be a nightmare? Actually releasing your Java CLI tool. Creating GitHub releases. Building native images for multiple platforms. Getting into package managers. Making Homebrew formulas. Getting on SDKMAN.</p>

<p>JReleaser takes all that pain and makes it configuration. You describe what you want—native images for Linux, macOS, Windows; Homebrew tap; SDKMAN distribution; Docker images; whatever—and JReleaser handles it. One command, and your release goes out to all these channels.</p>
<p>Now you can build a Java CLI tool or TUI, compile it to native images with GraalVM, and have JReleaser distribute it everywhere. Mac users can <code>brew install your-tool</code>. Linux users can use SDKMAN or native packages. Windows users get installers or Scoop packages.</p>
<p>Suddenly, distributing Java CLI tools is as easy as—no, easier than— in any other ecosystem.. And you get the whole Java ecosystem as your foundation.</p>
</div>
</div>
<div>
<h2 id="what-java-in-the-terminal-actually-looks-like">What Java in the Terminal Actually Looks Like</h2>
<div>
<p>I’m talking about reaching for Java when you need to:</p>
<div>
<ul>
<li>
<p>Parse some JSON from an API and transform it</p>
</li>
<li>
<p>Build a quick CLI tool to automate something</p>
</li>
<li>
<p>Write a one-off script that needs proper error handling</p>
</li>
<li>
<p>Create utilities that your whole team can easily install and run</p>
</li>
<li>
<p>Prototype something fast, share it easily, and scale up later</p>
</li>
<li>
<p>Ship professional CLI tools that users install via their favorite package manager</p>
</li>
<li>
<p>Create a beautiful TUI dashboard for monitoring systems</p>
</li>
<li>
<p>Build an AI-powered assistant that runs in your terminal</p>
</li>
</ul>
</div>
<p>The beauty is that these &#34;quick scripts&#34; and tools can grow up. That thing you wrote in 20 minutes? When it needs to become more serious, you’re already in Java. You’ve got the type safety, the IDE support, the testing frameworks, the entire ecosystem. You don’t need to rewrite it in a &#34;real&#34; language because it already is one.</p>
<p>Stop thinking of Java as only for &#34;serious&#34; applications. It’s also for that quick script you need right now. It’s for that TUI you want to build this weekend. It’s for that CLI tool your team needs next week.</p>
</div>
</div>
<div>
<h2 id="the-path-forward">The Path Forward</h2>
<div>
<p>Here’s what we need to do to make this happen:</p>
<p><strong>Build the TUI ecosystem.</strong> We need to rally around terminal UI libraries. Contribute to them. Make them easier to use. Create examples that make developers go &#34;wow, I want that.&#34;</p>
<p><strong>Share more examples.</strong> When you solve something with Java in the terminal, blog it. Tweet it. Show people it’s not just possible but actually pleasant. When you build a TUI, record a demo. Show it off.</p>
<p><strong>Distribute with JBang and JReleaser.</strong> Make your CLI tools and TUIs JBang-runnable for quick testing, then use JReleaser to get them into Homebrew, SDKMAN, and native package managers. Make installation so easy that nobody has an excuse not to try it.</p>
<p><strong>Embrace native images.</strong> For tools that need fast startup, invest in GraalVM native image. Yes, there’s a learning curve with reflection configuration, but the payoff is real. And JReleaser makes building for multiple platforms straightforward.</p>
<p><strong>Normalize the single-file Java program.</strong> Not everything needs a Maven project structure. Sometimes a script is just a script, and that’s fine.</p>
<p><strong>Leverage Frameworks.</strong> Frameworks like my own favourite Quarkus, but also Micronaut, Spring Boot, and others already have great CLI support and have made native image compilation significantly easier. They allow building everything from small tools to full-blown applications — doing TUIs here should be a breeze.</p>
<p><strong>Push the boundaries.</strong> Build something ambitious. A file manager in Java. A system monitor with a gorgeous TUI. An AI coding assistant with a rich terminal interface. A log analysis tool that makes jq look boring. Show what’s possible.</p>
</div>
</div>
<div>
<h2 id="the-bottom-line">The Bottom Line</h2>
<div>
<p>Java is already an incredible language with a massive ecosystem, excellent performance, and rock-solid reliability. We’ve just been leaving it on the bench for an entire category of programming that it’s actually well-suited for.</p>
<p>The terminal isn’t just about quick scripts—it’s about powerful, interactive applications that developers use every day. Java can participate in this space.</p>
<p>The world of terminal tools gets better when more ecosystems participate. We’re not here to compete—we’re here to contribute. To add our unique strengths and perspective. To make the terminal experience richer for everyone.</p>
<p>2026 is the year we change that. The tools are ready. The language is ready. JBang makes distribution trivial. JReleaser makes professional releases easy. Native images make startup instant. Virtual threads make async programming elegant. We just need to shift our mindset and start building.</p>
<p><strong>Who’s with me?</strong></p>
<p>Go write some Java based tools. Build some TUIs. Make them useful. Make them beautiful. Distribute them with JBang. Get feedback, iterate. Eventually Release them fully with JReleaser. Let’s show the world what Java in the terminal can do.</p>
<p>Because honestly? We’ve been sleeping on this for too long. Time to wake up.</p>
<p>Stay tuned — and let’s have fun in 2026!</p>

</div>
</div>
          </div>
      </div>
  </div>
</div></div>
  </body>
</html>
