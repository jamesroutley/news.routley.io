<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://loup-vaillant.fr/articles/physics-of-readability">Original</a>
    <h1>The Physics of Readability</h1>
    
    <div id="readability-page-1" class="page"><article> 
<p>August 2023</p>

<p><a href="https://lwn.net/Articles/250967/">What Every Programmer
Should Know About Memory</a> explains how memory works in modern
computers, and how it affects performance. Though from 2007, this paper
aged very well. One reason is the <em>laws of physics</em>: Transistors
can only be so small. Frequency can only be so high. Buses can only be
so wide. Light can only go so fast. Want more memory? That means more
space, moving away from the CPU, and increased latency.</p>
<p>That’s why we have caches: they work around fundamental limitations
to give the illusion of having tons of impossibly fast memory.
Maintaining this illusion however requires our programs to exhibit good
<em><a href="https://en.wikipedia.org/wiki/Locality_of_reference" title="Wikipedia">memory locality</a></em>: data that is accessed
together, should be stored together.</p>
<p>I could go on advocating data oriented programming, but my point here
is that <em>we programmers operate under similar constraints</em>: we
have little short term memory, and we tend to forget things after going
away from them long enough. Our screens offers only a small window, and
even the smartest IDE can’t give us instant access to everything.</p>
<p>Of course those constraints are quite different from those of an
automatic computer. But they do have a similar structure: it’s easier
for us to act upon code that we’ve just read. It’s even easier to act
upon code we can <em>see</em> right there on the screen. How much code
that is however, is fundamentally limited.</p>
<p>Thus, to efficiently grow and maintain programs, <em>code that is
read together should be written together.</em> Put another way, <em>code
that is written apart should not have to be read together</em>. I like
to call this rule “code locality”. It’s a simple rule, but we can derive
quite a few guidelines from it.</p>
<h2 id="high-cohesion-low-coupling">High cohesion, low coupling</h2>
<p>Not a guideline, but a rewording of the above, though perhaps in a
slightly narrower context.</p>
<p><em>High cohesion</em> is about making sure all the code in a given
module is related, so it forms a coherent whole. In practice this means
that understanding parts of the module likely requires understanding
most of it. Most such modules tend to have a single purpose, but that’s
not the focus here.</p>
<p><em>Low coupling</em> on the other hand is about minimising
dependencies <em>between</em> modules. Understanding how a given module
is implemented should require minimum understanding of other modules.
Modifying a given module should have minimum impact upon other
modules.</p>
<p>Note that “module” here means pretty much any meaningful unit of
code. Functions, classes, actual modules, or even components. Also, the
bigger the unit, the more important is its independence from other
modules. If the thing itself is big, we won’t have much brain space left
to understand the surrounding context. The less that context matters the
better.</p>
<h2 id="write-less-code">Write less code</h2>
<p>More precisely, keep the code base small. In general, when we can
achieve the same functionality with less code, things get better pretty
much across the board: fewer bugs, easier maintenance, shorter time to
market, even better runtime performance. Now don’t go cheating with Code
Golf. Counting source lines of code only works if you honestly observe
similar coding conventions.</p>
<p>You might go “duh, of course” on this one, but I noticed I could
trivially shave off 30% of most code I come across on the job. Often I
can reduce it in half. Sometimes I can divide it by three. Once I
managed to reduce code <em>that was praised for its simplicity</em> by a
factor of <em>five</em>.</p>
<p>I bet this happens to other people. How do we do it? I believe our
main advantage here is <em>hindsight</em>. It’s easy when reviewing code
to muse about alternative designs, spot a small mistake here, or notice
sloppy code there. It’s just hard for authors to edit their own
work.</p>
<p>There is however a way to cheat our way into getting it right the
first time: instead of designing a (piece of) program once, we can
design it two or three times over, compare, and keep the best approach.
Nobody has to know about our embarrassing failures. This takes time and
effort, but I believe all significant projects deserve it. That said, I
understand why in practice most of the code I see is just a rushed first
draft: stopping as soon as it “works” is just too damn tempting.</p>
<h2 id="keep-your-modules-deep">Keep your modules deep</h2>
<p>Obviously there is a limit to how small programs can be. In many
cases there inevitably comes a point where we cannot hold the entire
program in our head, let alone in our short term memory. We
<em>need</em> low coupling at some point.</p>
<p>The easiest and most potent way to achieve low coupling in my opinion
is to keep your modules (functions, classes, components) <em>deep</em>:
small interfaces packing significant functionality. The idea here is to
give users of the module the biggest benefit for the least learning.
This makes sure that when you work on a piece of code, you won’t be
forced to understand loads of complicated interfaces.</p>
<p>For instance if you have a class that solves a difficult problem
with, say, only 2 methods with no more than 3 arguments each, you’re in
good shape. Conversely, there are a number of red flags to watch out
for:</p>
<ul>
<li>Functions with many arguments.</li>
<li>Small functions.</li>
<li>Classes with many functions.</li>
<li>Getters and setters.</li>
</ul>
<p>You may not agree with all of those, especially small functions.
Still, small functions are shallower than bigger ones. They’re justified
if they’re called often enough, but that’s about it. That guy who said
functions should be small, and then smaller than that? Ignore him. Even
if small functions are easier to understand <em>in isolation</em>, depth
is more important to the program as a whole.</p>
<h2 id="avoid-repeating-yourself">Avoid repeating yourself</h2>
<p>Too much duplication causes two problems: this gives us more code (we
want less), and every time we find a bug in one instance we need to fix
<em>all</em> instances, wherever they may be. This destroys code
locality: duplicated code is code written <em>apart</em> that must be
fixed <em>together</em>.</p>
<p><em>Sometimes</em>, a little duplication is okay. A small amount can
shorten some programs. Some pieces of code that look similar aren’t
always related. And in some cases, trying too hard to spot &amp; merge
duplicated code can lead to too many indirections, which again hurts
code locality.</p>
<p>Mostly though, do avoid repeating yourself.</p>
<h2 id="define-variables-close-to-their-point-of-use">Define variables
close to their point of use</h2>
<p>Many programmers like to group declarations at the beginning of the
function. In some cases this helps us find them: though we most easily
scan around where we are looking at, we can quickly jump to anchor
points such as the beginning of a function.</p>
<p>In many cases however this is a habit we picked up from limitations
of the languages we use: some used to mandate that all declarations be
grouped at the beginning of a block. Others scope all variables at the
function level. This is a pity, because many variables are used only
once or twice, and as such could be declared right next to where they
are actually used, making them even easier to find.</p>
<p>Also, declaring variables late often allows us to merge declaration
and initialisation, thus removing an opportunity to reach an incoherent
state. This has little to do with code locality, but it does help
some.</p>
<h2 id="dont-waste-vertical-space">Don’t waste vertical space</h2>
<p>Ideally we want to cram as much code as we can in a single screen,
making it easier to scan for. I’m always annoyed at code like that:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>char</span><span>*</span> string_of_enum<span>(</span><span>enum</span> foo e<span>)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span>switch</span> <span>(</span>e<span>)</span> <span>{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span>case</span> FOO<span>:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#34;FOO&#34;</span><span>;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span>case</span> BAR<span>:</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#34;BAR&#34;</span><span>;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span>case</span> BAZ<span>:</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#34;BAZ&#34;</span><span>;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span>default</span> <span>:</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#34;default&#34;</span><span>;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>When it could have been <em>this</em> instead:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>const</span> <span>char</span><span>*</span> string_of_enum<span>(</span><span>enum</span> foo e<span>)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span>switch</span> <span>(</span>e<span>)</span> <span>{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span>case</span> FOO<span>:</span> <span>return</span> <span>&#34;FOO&#34;</span><span>;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span>case</span> BAR<span>:</span> <span>return</span> <span>&#34;BAR&#34;</span><span>;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span>case</span> BAZ<span>:</span> <span>return</span> <span>&#34;BAZ&#34;</span><span>;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span>default</span> <span>:</span> <span>return</span> <span>&#34;default&#34;</span><span>;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The problem is not that the former is less readable than the latter.
It could be if we had 30 cases instead of just 4, but that’s not the
point. The problem is that the former makes code <em>around</em> it less
readable. Those 8 extra lines mean 8 more lines pushed out of the
screen, forcing us to scroll or click to in cases where we could have
just looked.</p>
<p>Just… please don’t use this as an excuse to exceed 160 columns just
because you have a 12K triple width monitor. Others don’t, and even then
overly long lines have their own problems.</p>
<p><em>(Note: I prefer the K&amp;R brace style for the same reason: they
save one line per opening brace. Though maybe one day I’ll stop being a
hypocrite and do that with function braces as well.)</em></p>
<h2 id="consider-inlining-variables-that-are-used-only-once">Consider
inlining variables that are used only once</h2>
<p>There’s a balance between naming a variable and just using its value.
Sometimes the name can help document things, other times the name hardly
helps and the additional line of code was for nothing.</p>
<h2 id="inline-functions-that-are-used-only-once">Inline functions that
are used only once</h2>
<p>The reasoning is the same as variables, only magnified: function
declarations often incur significant overhead, and for technical or
cultural reasons rarely occur next to their point of use in most
languages. If a function is used only once, just inline it. It’s
generally the shortest path to increased code locality.</p>
<p>Likewise, never break up a function just because it feels too long.
If doing so decreases duplication, sure. But if the function is merely
hard to understand and work with, consider delimiting sections inside;
each with a comment, and a dedicated scope so local variables don’t
spill to the next sections. Often that is enough to make it amenable
again.</p>
<p>Some may think IDE support makes this moot: we can just jump to the
definition or have a pop-up displaying the function on mouse hover. But
this only works when we didn’t <em>already</em> did that. After two
jumps we need to backtrack again, and the relevant code is no longer on
screen. We could compensate by having 3 wide monitors with 8 files open
at the same time, but this too has its limits, like having to remember
which screen displays the code you wanted to look at.</p>
<p>As for one liners that are called only once, just inline them. The
small functions guy can take a hike.</p>

 </article></div>
  </body>
</html>
