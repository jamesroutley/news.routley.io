<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0day.work/parsing-the-ds_store-file-format/">Original</a>
    <h1>Parsing the .DS_Store File Format</h1>
    
    <div id="readability-page-1" class="page"><div role="main">

    <article>

        <header>
        


        </header>

        <section>
            <!--kg-card-begin: markdown--><p>About two years ago I came across a <code>.DS_Store</code> file and wanted to extract its information (e.g. file names). After researching the file format and its security implications, as well as writing a parser for it, I would like to share my (limited) knowledge and the parser in Go / Python with the world.</p>
<!-- more -->

<p>Let us begin with a small introduction to this blogpost and how I got to look at a file format from Apple. If you want to directly jump into the technical stuff, then skip to the next section.</p>
<p>While conducting reasearch focused on sensitive files on webservers about two years ago, I came across a file called <code>.DS_Store</code>. Back then I wrote and used a tool in Go to scan the Alexa Top 1M for different security issues, but there were no parsers in that language for the <code>.DS_Store</code> file format. I found one in Perl and a couple in Python, but none of them worked properly or could reliably parse the set of files that I obtained. Furthermore, I wanted to call a class/function that extracts the interesting information directly from Go without having to use external programs.</p>
<p>Therefore, I thought that re-implementing a parser for this file format in Go would be a nice excercise and learning experience, because I was still quite new to that language. The resulting code ended up on <a href="https://github.com/gehaxelt/ds_store">GitHub: Gehaxelt - Go DS_Store</a> (Do not look at this if you know how to write Go ;) ). Unfortunately, I didn&#39;t comment the code much during development, but it eventually workedâ„¢ :)</p>
<p>At the 34C3 conference in Leipzig last year, a colleague and me decided to catch up with the research of this file format again. We finished it by now and I felt like I should share my knowledge with the rest of the world. Being unable to fully understand the code that I had written two years ago and therefore explain the file format, I started to dig into the details again and decided to re-implement the parser in Python!</p>
<p>I am still lacking some tiny parts of the specification/details that I managed to know some years ago, but the new parser should have the same functionality and I will try to give an introduction to the file format.</p>

<p>Before we start with the parsing of a <code>.DS_Store</code> file, let me tell you a bit about it. You might have received the (hidden) file on an USB stick from a colleague with MacOs or seen it somewhere else. Apple&#39;s operating system creates this file in apparently all directories to store meta information about its contents. In fact, it contains the names of <a href="https://en.wikipedia.org/wiki/.DS_Store">all files (and also directories) in that folder</a>. The equivalent on Microsoft Windows might be considered the <code>desktop.ini</code> or <code>Thumbs.db</code>.</p>
<p>Due to the fact that <code>.DS_Store</code> is prefixed with a dot, it is hidden from MacOs&#39; Finder, so Mac-users might not be aware of its existence. Furthermore, the file format is proprietary and not much documentation about it is available online.</p>

<p>I am not the first to write a parser for this kind of file, so I do not want to claim this, but writing a parser for it was a good learning experience. The following resources helped me to learn and understand its format:</p>
<ul>
<li><a href="https://wiki.mozilla.org/DS_Store_File_Format">https://wiki.mozilla.org/DS_Store_File_Format</a></li>
<li><a href="http://search.cpan.org/~wiml/Mac-Finder-DSStore/DSStoreFormat.pod">http://search.cpan.org/~wiml/Mac-Finder-DSStore/DSStoreFormat.pod</a></li>
<li><a href="https://digi.ninja/projects/fdb.php">https://digi.ninja/projects/fdb.php</a></li>
</ul>
<p>I recommend reading all three of them to get a rough understanding of the file before continuing!</p>
<p>Anyway, let&#39;s start: I will use an example <code>.DS_Store</code> file to explain its structure. The parsers use a similar methodology to process the file.</p>

<p>The file is in big-endian format and begins with a header of 36 bytes:</p>
<h2 id="rootblock">Root block</h2>
<p>Now that the basic information about the root block is in our hands, we can focus on its contents between <code>0x1004</code> and <code>0x1804</code>. Note that we use the previously obtained position <code>0x1000</code> with an additional block-alignment of <code>0x04</code>.</p>
<p>The information about the file names is stored in a tree-like structure where the root block contains important metadata about the tree and its other blocks. In general, the metadata can be split in three different sections:</p>
<ul>
<li>Offsets</li>
<li>Tables of content</li>
<li>Free list</li>
</ul>
<h3 id="offsets">Offsets</h3>
<p>The offsets section contains information about the offsets of the tree&#39;s (leaf) blocks in the file. Those blocks store the actual information like file names etc. and the offsets are needed to traverse the tree.</p>
<p><img src="https://0day.work/content/images/2018/03/dsstore_offsets-1.png" alt="dsstore_offsets-1"/></p>
<p>The blue integer (<code>0x03</code>) tells us how many offsets we need to read after we skipped another four grey bytes that appear to always be zero. The following twelve green bytes are the three 4-bytes integers that should be added to an <code>offsets</code> list:</p>
<ul>
<li><code>0x0000100B</code></li>
<li><code>0x00000045</code></li>
<li><code>0x00000209</code></li>
</ul>
<p>The order is important, because we will later access the values by their index in the list. Those offsets are the tree&#39;s block positions in the file. The rest of the section is padded with zeroes (red bytes) and the padding is aligned to go up to the next multiple of 256 entries (1024 bytes). In our case the padding goes up to <code>0x140c</code>, because it equals <code>0x1000</code> + 3*4 bytes for the three integers (skipped/count/skipped) + 3*4 bytes for the three offsets + (256 entries - 3 entries)*4 bytes of padding.</p>
<p>Therefore, the next section will start at <code>0x140c</code>.</p>
<h3 id="tablesofcontent">Tables of content</h3>
<p>After the offsets, the tables of content section follows. It usually contains at least one table named <code>DSDB</code> with the value <code>0x01</code>. This particular table references the first block&#39;s id that we will traverse.</p>
<p>The red bytes are the padding from the offsets section and the TOC starts at <code>0x140c</code> with four blue bytes representing the count of TOCs to parse. In our case that&#39;s only one (<code>0x01</code>).</p>
<ul>
<li>[&#39;DSDB&#39;] = <code>0x01</code></li>
</ul>
<h3 id="freelist">Free list</h3>
<p>The last section is the free list, where unused or free blocks of the tree can be saved. In practice, I haven&#39;t used any values of that list to retrieve the file names, but it might be useful somewhen else.</p>
<p><img src="https://0day.work/content/images/2018/03/dsstore_freelist.png" alt="dsstore_freelist"/></p>
<p>From the hexdump above we see that the first five buckets from <code>0x1419</code> to <code>0x142d</code> have zero elements. The sixth bucket after <code>0x142d</code> has a value of <code>0x02</code> and therefore two elements <code>0x00000020</code> and <code>0x00000060</code>.</p>
<p>After the complete iteration of the loop, the resulting free list should look similar to this:</p>
<pre><code>{
1: [],
2: [],
4: [],
8: [],
16: [],
32: [32, 96],
64: [],
128: [128],
256: [256],
512: [],
1024: [1024],
2048: [2048, 6144],
4096: [],
8192: [8192],
16384: [16384],
32768: [32768],
65536: [65536],
131072: [131072],
262144: [262144],
524288: [524288],
1048576: [1048576],
2097152: [2097152],
4194304: [4194304],
8388608: [8388608],
16777216: [16777216],
33554432: [33554432],
67108864: [67108864],
134217728: [134217728],
268435456: [268435456],
536870912: [536870912],
1073741824: [1073741824],
2147483648: []
}
</code></pre>
<p>After parsing all three sections, we are done with the root block and can continue with the tree.</p>
<h2 id="tree">Tree</h2>
<p>As I said earlier, the information is arranged in a tree-like structure. This tree needs to be traversed to obtain the file names or other information stored in the <code>.DS_Store</code> file.</p>
<h3 id="blockidsandoffsets">Block IDs and offsets</h3>
<p>I explained that the TOC contains the block id and in particular, the <code>DSDB</code> TOC references the first block by its ID that we will traverse. In our example the ID was <code>0x01</code>.</p>
<p>We use the ID as the index to our previously computed <code>offsets</code> list to obtain an address: <code>offsets[0x01] =&gt; 0x00000045</code></p>
<p>However, we cannot simply use the data at the location of <code>0x00000045</code>, because the real offset and size of the block is encoded within this value:</p>
<ul>
<li><code>2^k</code>, with k being the five least-significant bits, is the block&#39;s size. It shouldn&#39;t be lower than 32 bytes.</li>
<li>it becomes the block&#39;s offset when the five bits are set to zero.</li>
</ul>
<p>With our example address <code>0x00000045</code> and some bit operation magic, we get the following results:</p>
<ul>
<li>offset: <code>int(0x00000045) &gt;&gt; 0x5 &lt;&lt; 0x5</code> = <code>0x40</code></li>
<li>size: <code>1 &lt;&lt; (int(0x00000045) &amp; 0x1f)</code> = <code>0x20</code></li>
</ul>
<p>Our example block with ID <code>0x01</code> will therefore start at <code>0x40</code>+<code>0x4</code> = <code>0x44</code> and be <code>0x20</code> bytes long.</p>
<h3 id="traversingthetree">Traversing the tree</h3>
<p>To get the file names, we need to traverse the tree from its root block. As previously described, it is referenced by the block ID in the <code>DSDB</code> TOC and starts at <code>0x44</code>.</p>
<ul>
<li>green: Levels of internal blocks (<code>0x00</code>)</li>
<li>yellow: Records in the tree (<code>0x06</code>)</li>
<li>blue: Blocks in the tree (<code>0x01</code>)</li>
<li>brown: Always the same value (<code>0x1000</code>)</li>
</ul>
<p>Using the parsed block-ID <code>0x02</code> we can traverse the tree using recursion and extract the file names.</p>
<p>The data block&#39;s address is <code>offsets[0x02] =&gt; 0x00000209</code> that becomes:</p>
<ul>
<li>offset: <code>int(0x00000209) &gt;&gt; 0x5 &lt;&lt; 0x5</code> = <code>0x200</code></li>
<li>size: <code>1 &lt;&lt; (int(0x00000209) &amp; 0x1f)</code> = <code>0x200</code></li>
</ul>
<p>Knowing that the data block will start at <code>0x204</code> in the file, we continue with the following hexdump:</p>
<ul>
<li>red: Block mode (<code>0x00</code>)</li>
<li>green: Record count (<code>0x06</code>)</li>
</ul>
<p>If the mode is <code>0x00</code> then it is immediately followed by <code>count</code> records.</p>
<p>However, our example block is in mode <code>0x00</code> and therefore only <code>0x06</code> records need to be parsed.</p>
<h3 id="arecord">A Record</h3>
<p>Let&#39;s look at how the records inside a block look like.</p>
<p>Once the parser finishes, a list of six file names should be the result:</p>
<ul>
<li>favicon.ico</li>
<li>flag</li>
<li>static</li>
<li>templates</li>
<li>vulnerable.py</li>
<li>vulnerable.wsgi</li>
</ul>
<h2 id="code">Code</h2>
<p>I am going to share the code that I have written over the years, but please do not expect bug-free, perfect code. As I said in the beginning, I am not the first to try to write a parser; the code is based on the work of others and might not be feature-complete. Bugfixes and PRs are always welcome!</p>
<p>If you are brave enough to look at it (or even use it!) then here are the links:</p>
<ul>
<li><a href="https://github.com/gehaxelt/ds_store">Go version @ GitHub</a></li>
<li><a href="https://github.com/gehaxelt/Python-dsstore">Python version @ GitHub</a></li>
</ul>
<p>If you just want to try and parse a <code>.DS_Store</code> to see its contents, then you can also use the webservice that I am providing here:</p>
<ul>
<li><a href="https://labs.internetwache.org/ds_store/">Online .DS_Store parser </a></li>
</ul>
<h2 id="knownissues">Known Issues</h2>
<p>While developing the code and writing the blogpost, I discovered some issues in the implementation and parsing logic, which I would like to discuss briefly. Maybe you will find a fix?</p>
<h3 id="rootblockoffset">Root block offset</h3>
<p>I came across at least one <code>.DS_Store</code> file, where the root block&#39;s offset from the initial header parsing was off by 4 bytes. This resulted in a incorrectly parsed offsets list as well as TOC. However, this seemed to be a rare occurence and I am not sure, how or why it occured.</p>
<h3 id="incorrectfilenamelength">Incorrect file name length</h3>
<p>Another issue that I encountered was that the file name length inside a record had a wrong value. For example, it appeared as <code>0x0a</code> (10 * 2 bytes), but the UTF-16 file name was actually &gt; 20 bytes long. Often, this resulted in an unmatched structure type and an error. Setting the correct length with an hexeditor usually fixed the issue, but I am unsure how that obviously wrong length made it there.</p>
<p>Nonetheless, I have implemented a brute-force like approach to resolve this issue: Re-reading the next two bytes of the file name until a known structure-ID appears. This mostly fixed the issue, but it does not feel like it&#39;s the best approach.</p>

<p>Until now I only discussed the structure and contents of .DS_Store files, but this is a security-related blog, and I promised to answer the above question: <strong>YES</strong>, this file has some security implications if it&#39;s being uploaded to webservers!</p>
<p>Regarding to me, the juicy parts of the .DS_Store file are the file names that it contains. MacOs creates a .DS_Store file in almost all folders and you won&#39;t even notice it, because it is prepended with a dot and Finder won&#39;t show <code>dot</code>-files per default. Each file in a directory has an entry in the directorie&#39;s .DS_Store file.</p>
<h3 id="informationdisclosureofsensitivefiles">Information disclosure (of sensitive files)</h3>
<p>With the <a href="https://internetwache.org/">Internetwache.org</a> project that I&#39;m part of, we scanned the Alexa Top 1M domains for this file in their document root. It turns out that sensitive files are exposed and potentially accesible by the existence of that file. We discovered file names that indicated the existence of full document root backups, databases, configuration files, swap/temporary files or even private keys!</p>
<h3 id="howtocheckandprotectyourself">How to check and protect yourself?</h3>
<p>An important thing that needs to be clarified is that the file names stored in a .DS_Store file only represent the contents of a directory on a local MacOs based system. This, however, means that the files we have found on the internet must had been (unknowingly) uploaded by someone. On the other side this means that not all file names necessarily exist on the server!</p>
<p>The upload might happen if...</p>
<ul>
<li>you committed the file to your version control system (e.g. git/svn/etc) and pulled the repo&#39;s contents on the server.</li>
<li>you upload the files using <code>rsync</code>/<code>sftp</code>/etc without excluding/removing them first.</li>
<li>(the server runs on Mac :D)</li>
</ul>
<p>If you feel like checking your webserver now, I would recommend running the the following command (on a linux system):</p>
<pre><code>cd /var/www/ #wherever your webserver&#39;s document root is 
find . -type f -iname &#34;*.DS_Store*&#34;
</code></pre>
<p>This command searches through all folders in the <code>/var/www</code> directory for files that have <code>.DS_Store</code> in their name and prints them.</p>
<p>Furthermore, you can harden your webserver to deny access to those files.</p>
<h4 id="apache">Apache</h4>
<p>Add the following block to your <code>httpd.conf</code>:</p>
<pre><code>&lt;Files ~ &#34;\.DS_Store$&#34;&gt;
    Order allow,deny
    Deny from all
&lt;/Files&gt;
</code></pre>
<h4 id="nginx">Nginx</h4>
<p>Put the following lines into your <code>server</code> block:</p>
<pre><code>location ~ \.DS_Store$ {
      deny all;
}
</code></pre>

<p>Let me finish with a short conclusion about the things that I (or we?) have learned from this blogpost. Writing a parser for a (proprietary) file format allowed my to learn about the internals of file formats and how those can be structured and parsed. Unfortunately, the <em>.DS_Store</em> format is not fully open, so some features are missing and some bugs cannot be explained/fixed. Another important thing that I&#39;ve learned: Commenting your code is a <strong>MUST</strong> if you want to understand it a couple of years later. Especially, when it is a more &#34;complex&#34; piece of software like a file format parser ;)</p>
<p>Furtermore, I hopefully convinced you to check your webserver if there are any .DS_Store files laying around that might expose some sensitive files. If you cannot find any, you should still add a configuration rule to deny access to those files and check back with your developers that those files will not be committed or uploaded anywhere in the first place!</p>
<p>Last but not least, I would like to thank the people who did the hard reversing part and published their notes online! Otherwise I would not have managed to have my fun with the file format :)</p>
<p>-=-</p>
<!--kg-card-end: markdown-->
        </section>

        

    </article>
    
</div></div>
  </body>
</html>
