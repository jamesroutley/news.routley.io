<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mclare.blog/posts/making-3d-hexplots-with-maplibre">Original</a>
    <h1>Making 3D Hexplots With Maplibre</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of the curses I’ve found about being a software developer is <em>knowing</em> there has to be a way (or a better way) to do something, and then <a href="https://xkcd.com/356/" target="_blank" rel="nofollow noopener noreferrer">nerd sniping</a> yourself until you figure out <em>how to do the thing</em>.</p>
<p><span><figure>
    <span>
      <a href="https://mclare.blog/static/0410ac827bb193c12c4312ed8bc3add7/50383/nerd_sniping.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/0410ac827bb193c12c4312ed8bc3add7/8ac56/nerd_sniping.webp 240w,
/static/0410ac827bb193c12c4312ed8bc3add7/d3be9/nerd_sniping.webp 480w,
/static/0410ac827bb193c12c4312ed8bc3add7/ca4a8/nerd_sniping.webp 740w" sizes="(max-width: 740px) 100vw, 740px" type="image/webp"/>
          <source srcset="/static/0410ac827bb193c12c4312ed8bc3add7/8ff5a/nerd_sniping.png 240w,
/static/0410ac827bb193c12c4312ed8bc3add7/e85cb/nerd_sniping.png 480w,
/static/0410ac827bb193c12c4312ed8bc3add7/50383/nerd_sniping.png 740w" sizes="(max-width: 740px) 100vw, 740px" type="image/png"/>
          <img src="https://mclare.blog/static/0410ac827bb193c12c4312ed8bc3add7/50383/nerd_sniping.png" alt="Nerd Sniping - XKCD 356" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span>
    <figcaption>Nerd Sniping - XKCD 356</figcaption>
  </figure></span></p><p>Cue me, over Christmas break, wanting to make a map. I <em>knew</em> I could do some 3d visualization based on some of the <a href="https://maplibre.org/" target="_blank" rel="nofollow noopener noreferrer">Maplibre</a> <a href="https://maplibre.org/maplibre-gl-js/docs/examples/3d-extrusion-floorplan/" target="_blank" rel="nofollow noopener noreferrer">examples</a>, but I had a very <em>specific</em> idea in my brain of what I wanted to make.</p>
<p>I’d done a lot of work with <a href="https://bridge.watch" target="_blank" rel="nofollow noopener noreferrer">Bridge.Watch</a> using D3 for 2D data visualizations, but I really wanted to see what I could add as 3d data on a real map, rather than just a country/state/county svg from the <a href="https://observablehq.com/@d3/u-s-map" target="_blank" rel="nofollow noopener noreferrer">TopoJSON U.S. Atlas</a>.</p>
<p>To further complicate things, I really liked the visualization I’d done with <a href="https://github.com/d3/d3-hexbin" target="_blank" rel="nofollow noopener noreferrer">hexbinning</a> for the <a href="https://bridge.watch/?plot_type=percent_poor" target="_blank" rel="nofollow noopener noreferrer">national</a> bridge overview.</p>
<p>I wanted a <em>3D hexbin</em>, and after a bit of mucking around with some hacky scripts, I <em>finally</em> have it.</p>
<p><span><figure>
    <span>
      <a href="https://mclare.blog/static/74091dd41f57dbde348f60336922cf8e/5e17e/map.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/74091dd41f57dbde348f60336922cf8e/8ac56/map.webp 240w,
/static/74091dd41f57dbde348f60336922cf8e/d3be9/map.webp 480w,
/static/74091dd41f57dbde348f60336922cf8e/e46b2/map.webp 960w,
/static/74091dd41f57dbde348f60336922cf8e/f992d/map.webp 1440w,
/static/74091dd41f57dbde348f60336922cf8e/882b9/map.webp 1920w,
/static/74091dd41f57dbde348f60336922cf8e/e6b50/map.webp 2668w" sizes="(max-width: 960px) 100vw, 960px" type="image/webp"/>
          <source srcset="/static/74091dd41f57dbde348f60336922cf8e/8ff5a/map.png 240w,
/static/74091dd41f57dbde348f60336922cf8e/e85cb/map.png 480w,
/static/74091dd41f57dbde348f60336922cf8e/d9199/map.png 960w,
/static/74091dd41f57dbde348f60336922cf8e/07a9c/map.png 1440w,
/static/74091dd41f57dbde348f60336922cf8e/29114/map.png 1920w,
/static/74091dd41f57dbde348f60336922cf8e/5e17e/map.png 2668w" sizes="(max-width: 960px) 100vw, 960px" type="image/png"/>
          <img src="https://mclare.blog/static/74091dd41f57dbde348f60336922cf8e/d9199/map.png" alt="3D Hexbin Map" title="" loading="lazy" decoding="async"/>
        </picture>
  </a>
    </span>
    <figcaption>3D Hexbin Map</figcaption>
  </figure></span></p><p>To utilize the d3-hexbin library rather than rewriting my own hex functions, I had to transform the data into the projected coordinates of a 2d visualization, and then transform them back out to latitudes and longitude coordinates that could be stored as polygonal features in a geojson.</p>
<h4 id="projection-and-hexbin-functions"><a href="#projection-and-hexbin-functions" aria-label="projection and hexbin functions permalink"><span><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></span></a>Projection and Hexbin functions</h4>
<p><span><div data-language="text"><pre><code>const width = 975;
const height = 610;
const scaleValue = 1300;
const radius = 6;

const projection = d3
  .geoAlbersUsa()
  .scale(scaleValue)
  .translate([width * 0.5, height * 0.5]);

const customHexbin = hexbin()
  .extent([
    [0, 0],
    [width, height],
  ])
  .radius(radius);</code></pre></div></span></p><p>I used the same width/height/scaling I’d used in a few other maps, and played with the radius a bit to come up with the right balance of bins to data.</p>
<p>The data I wanted to plot was all the plants and factories contained within the EC3 Environmental Product Declaration Database. The data set wasn’t <em>too</em> large, and I knew it would have a fairly sparse distribution, with a lot of the EPDs coming from plants in metropolitan areas and ports. I ran the material data through the projection function and filtered out any EPDs/Plants that were missing latitudes and longitudes before running it through the <span><code>customHexbin</code></span> function.</p>
<p><span><div data-language="text"><pre><code>let hexBins = [];
if (Array.isArray(materials)) {
  const projectedData = materials
    .map((d) =&gt; projection([d.longitude, d.latitude]))
    .filter((d) =&gt; d !== null);
  hexBins = customHexbin(projectedData);
}</code></pre></div></span></p><p>The hexbin API is pretty limited. The most I could figure out for actually getting the points was to run the <span><code>hexbin.hexagon([radius])</code></span> function, obtain the svg path, and then extracting the points from the path data using a <em>very</em> complicated regular expression. I did this for a single <span><code>baseHex</code></span> centered at the origin, and then offset all the other points based on the center points of each hex, which I could extract via <span><code>hexbin.centers()</code></span>.</p>
<p><span><div data-language="text"><pre><code>function svgPathToCoordinates(pathData) {
  const coordinates = [];
  const pathCommands =
    pathData.match(
      /[a-df-z]?\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?,?\s*-?\d+(\.\d+)?(?:[eE][+-]?\d+)?/g
    ) || [];

  let currentX = 0;
  let currentY = 0;

  let startingPoint = [];
  pathCommands.forEach((command) =&gt; {
    const cmd = command[0];
    const values = command
      .slice(1)
      .split(/[,\s]+/)
      .map(parseFloat);

    switch (cmd) {
      case &#34;m&#34;:
        currentX = values[0];
        currentY = values[1];
        coordinates.push([currentX, currentY]);
        startingPoint = [currentX, currentY];
        break;
      case &#34;l&#34;:
        currentX = currentX + values[0];
        currentY = currentY + values[1];
        coordinates.push([currentX, currentY]);
        break;
    }
  });

  coordinates.push(startingPoint);

  return coordinates;
}

const baseHex = svgPathToCoordinates(customHexbin.hexagon(radius));</code></pre></div></span></p><p>Once I had the base coordinates for the properly scaled hexagon, I simply mapped all the hexbins to their projected coordinates (so within the 975 x 610 box), and inverted the projection to obtain the latitudes and longitudes of the hexes, and then made the properly shaped polygon feature with a height attribute of the length of the hexbin (how many items fall within the boundaries).</p>
<p><span><div data-language="text"><pre><code>const hexFeatures = hexBins.map((hex, i) =&gt; {
  const newCoordinates = baseHex.map((point) =&gt; [
    point[0] + hex.x,
    point[1] + hex.y,
  ]);
  const latLong = newCoordinates.map((point) =&gt; projection.invert(point));
  return {
    type: &#34;Feature&#34;,
    geometry: {
      type: &#34;Polygon&#34;,
      coordinates: [latLong],
    },
    properties: {
      count: hex.length,
      height: hex.length,
      base_height: 0,
      color: &#34;green&#34;,
    },
    id: `h_${i}`,
  };
});</code></pre></div></span></p><p>I wrote all the hexes as a <span><code>FeatureCollection</code></span> to a JSON file, and then loaded the static file into an existing <span><code>Map</code></span> component:</p>
<p><span><div data-language="text"><pre><code>map.on(&#34;load&#34;, function () {
      map.resize();

      map.addSource(&#34;hexes&#34;, {
        type: &#34;geojson&#34;,
        data: hexbins,
      });

      map.addLayer({
        id: &#34;boundary&#34;,
        type: &#34;fill-extrusion&#34;,
        source: &#34;hexes&#34;,
        paint: {
          // See the MapLibre Style Specification for details on data expressions.
          // https://maplibre.org/maplibre-style-spec/expressions/

          // Get the fill-extrusion-color from the source &#39;color&#39; property.
          &#34;fill-extrusion-color&#34;: [&#34;get&#34;, &#34;color&#34;],

          // Get fill-extrusion-height from the source &#39;height&#39; property.
          &#34;fill-extrusion-height&#34;: [&#34;*&#34;, [&#34;get&#34;, &#34;height&#34;], 100],

          // Get fill-extrusion-base from the source &#39;base_height&#39; property.
          &#34;fill-extrusion-base&#34;: [&#34;get&#34;, &#34;base_height&#34;],

          // Make extrusions slightly opaque for see through indoor walls.
          &#34;fill-extrusion-opacity&#34;: 0.8,
        },
      });
    });</code></pre></div></span></p><p>I’m sure with a little work, I could skip the writing/loading step, and even make the hex sizing interactive on the UI, but for now, this is enough to keep me out of the road.</p>
<p><img src="https://mclare.blog/static/map-6142d68b8feb7078b15073af27a79397.gif" alt="Zoomable Map"/></p></div></div>
  </body>
</html>
