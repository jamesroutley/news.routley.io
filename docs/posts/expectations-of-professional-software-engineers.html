<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adamj.eu/tech/2022/06/17/mike-actons-expectations-of-professional-software-engineers/">Original</a>
    <h1>Expectations of professional software engineers</h1>
    
    <div id="readability-page-1" class="page"><p>In a 2019 talk/rant titled <a href="https://www.youtube.com/watch?v=cV5HArLYajE">“Everyone Watching This Is Fired”</a>, games industry veteran Mike Acton rattled off a sample of 50 things he expects of developers he works with. The title refers to his tongue-in-cheek suggestion that anyone who doesn’t meet all these requirements would be immediately fired.</p><p>Although his sense of humour isn’t for everyone, the suggestions are valuable. The list forms a baseline for software engineers to compare themselves against, and it’s not very specific to the games industry.</p><p>I couldn’t find a textual version, so I’ve written up the list below, with my own expansions of each point and some further quotes from Mike. I hope this list inspires you to improve as an engineer, as it has me.</p><div><li><p><strong>I can articulate precisely what problem I am trying to solve.</strong></p> <p>It’s all too easy to get stuck in the weeds and lose track of why you’re doing what you’re doing. Keep top of mind what the actual end goal is do, and you might spot an alternative path.</p></li><li><p><strong>I have articulated precisely what problem I am trying to solve.</strong></p> <p>Communicate the problem “out loud” to other team members, your product manager, etc.</p></li><li><p><strong>I have confirmed that someone else can articulate what problem I am trying to solve.</strong></p> <p>Communication! Ensure your team is all on the same page. Make sure your understanding of the problem is complete.</p></li><li><p><strong>I can articulate why my problem is important to solve.</strong></p> <p>If you solve the problem you’re working on, who benefits, and how much?</p></li><li><p><strong>I can articulate how much my problem is worth solving.</strong></p> <p>If you say it’s worth “as long as it takes”… Mike does not have friendly words for you. For <em>any</em> problem there’s a maximum amount of time and effort worth investing in solving it. At least have some idea of the upper bound.</p></li><li><p><strong>I have a Plan B in case my solution to my current problem doesn’t work.</strong></p> <p>Imagine you’re days or hours before the deadline, and you can tell that completing Plan A will be impossible. What do you do instead? Maybe you have a simplified algorithm, or you can disable a certain subsystem. Have more than one plan.</p></li><li><p><strong>I have already implemented my Plan B in case my solution to my current problem doesn’t work.</strong></p> <p>Mitigate risk by writing the backup version first. This means you always have a safety net and you can learn more about the problem space in order to iterate on Plan A.</p></li><li><p><strong>I can articulate the steps required to solve my current problem.</strong></p> <p>Programming only works when you break down problems into manageable chunks. Have a sketch of the steps to the end state before you begin.</p></li><li><p><strong>I can clearly articulate unknowns and risks associated with my current problem.</strong></p> <p>There are always going to be things you don’t know. You should know where they are in your plan, so you can manage them.</p></li><li><p><strong>I have not thought or said “I can just make up the time” without immediately talking to someone.</strong></p> <p>Say it’s Wednesday, you have a project due on Friday, and you get some new task dropped on your lap. You think “I’ll do the new thing now, and make up the time for the original task by Friday”… mistake! Communicate about the conflict on Wednesday. Your product manager will help manage the timing and risk.</p></li><li><p><strong>I write a “framework” and have used it multiple times to actually solve a problem it was intended to solve.</strong></p> <p>If you’re writing a tool of some kind, you should verify it works in practice. Too often people create something in isolation and it doesn’t end up delivering in the real world.</p> <p>(This is <a href="https://docs.djangoproject.com/en/stable/faq/general/#why-does-this-project-exist">how Django came to be</a>: from a real team making real websites, on deadlines!)</p></li><li><p><strong>I can articulate what the test for completion of my current problem is.</strong></p> <p>If you don’t know when to stop, you might find yourself going down rabbit holes, chasing unimportant marginal gains.</p></li><li><p><strong>I can articulate the hypothesis related to my problem and how I could falsify it.</strong></p> <p>If a hypothesis cannot be proven wrong, there’s no knowledge to be gained. As Karl Popper showed, science only works through <a href="https://en.wikipedia.org/wiki/Falsifiability">falsification</a>.</p></li><li><p><strong>I can articulate the (various) latency requirements for my current problem.</strong></p> <p>Any time you write code, you should consider when the output data is required. Not every caller needs output data instantly, and nor do you have an unbounded amount of time to perform everything. At least get an idea of the sensible bounds.</p></li><li><p><strong>I can articulate the (various) throughput requirements for my current problem.</strong></p> <p>How much data needs to come through the system? How many bytes, requests, or frames per second?</p></li><li><p><strong>I can articulate the most common concrete use case of the system I am developing.</strong></p> <p>You should know what actual users of your system will actually be doing most of the time. Having a vague idea doesn’t help, since knowing which pattersn are common informs which way to write a given piece of code.</p></li><li><p><strong>I know the most common actual, real-life values of the data I am transforming.</strong></p> <p>Beyond use cases, you should know the data inside the system. For example, if your function works with integers, you’d probably write it quite differently if 99% of the values are 0.</p></li><li><p><strong>I know the acceptable ranges of values of all the data I am transforming.</strong></p> <p>Computer systems always have limits. Know the ranges for the data types you’re working with (and enforce them).</p></li><li><p><strong>I can articulate what will happen when (somehow) data outside that range enters the system.</strong></p> <p>Murphy’s Law says “anything that can go wrong will go wrong”. Know how your system will behave in such cases, and handle such problems if necessary.</p></li><li><p><strong>I can articulate a list of input data into my system roughly sorted by likelihood.</strong></p> <p>Have an idea of the space of possible data, what’s most likely, second most likely, etc. Code appropriately, for example checking for common error conditions first.</p></li><li><p><strong>I know the frequency of change of the actual, real-life values of the data I am transforming.</strong></p> <p>Reason about the frequency of change and figure out how often you’ll want to calculate derived values.</p></li><li><p><strong>I have (at least partially) read the (available) documentation for the hardware, platform, and tools I use most commonly.</strong></p> <p>Read the friendly manual! Go a step beyond day-to-day reference, and try reading the full documentation to gain a deep understanding.</p> <p>(Jens Oliver Meiert calls reading the HTML specification <a href="https://meiert.com/en/blog/web-developer-pilgrimage/">the Web Developer’s Pilgrimage</a>.)</p></li><li><p><strong>I have sat and watched an actual user of my system.</strong></p> <p>Watching users can massively break shift your view of how your software works. Do it!</p></li><li><p><strong>I know the slowest part of the users of my system’s workflow with high confidence.</strong></p> <p>Any workflow has a bottleneck. Make sure you know what it is so you can focus efforts there, if need be.</p></li><li><p><strong>I know what information users of my system will need to make effective use of the solution.</strong></p> <p>Think about what documentation or data users need to understand and use your solution.</p></li><li><p><strong>I can articulate the finite set of hardware I am designing my solution to work for.</strong></p> <p>Software requires hardware. Know what hardware your program targets, such as:</p> <ul><li>CPU architectures</li><li>Minimum requirements for memory, CPU speed, and network bandwidth</li><li>Input devices</li><li>Output devices</li><li>The environment the hardware runs in (e.g. data centre or living room)</li></ul></li><li><p><strong>I can articulate how that set of hardware specifically affects the design of my system.</strong></p> <p>If you’re targetting low end devices, how do you ensure you don’t exhaust memory? If some users don’t have pointing devices, how do you accommodate them?</p></li><li><p><strong>I have recently profiled the performance of my system.</strong></p> <p>If you’re developing a local app, run profiling tools regularly to gain an idea of performance over time. With server based programs, you can install an APM (Application Performance Monitoring) tool in production and have continuous profiling data.</p></li><li><p><strong>I have recently profiled memory usage of my system.</strong></p> <p>Make sure you aren’t wasting memory.</p></li><li><p><strong>I have used multiple different profiling methods to measure the performance of my system.</strong></p> <p>There’s no perfect profiling tool, so know how to use more than one.</p> <p>For example, some great Python profilers are <a href="https://docs.python.org/3/library/profile.html">cProfile</a>, <a href="https://github.com/benfred/py-spy">py-spy</a>, <a href="https://github.com/P403n1x87/austin">Austin</a>, <a href="https://github.com/plasma-umass/scalene">Scalene</a>, <a href="https://pythonspeed.com/fil/">Fil</a>, and <a href="https://bloomberg.github.io/memray/">memray</a>. They all have different characteristics and complement each other.</p></li><li><p><strong>I know how to significantly improve the performance of my system without changing the input/output interface of the system.</strong></p> <p>Do you know the next step to optimize your system? You don’t have to do it right now, as it may not be worth it, but you should have an idea what you’d do next to make your code faster. For example, use a faster but less convenient data structure, or convert a hot function into a faster language (such as Python to C with Cython).</p> <p>This should also guide you to designing interfaces that are optimizable in the first place. For example, don’t commit to returning expensive-to-compute results immediately, but instead return a promise.</p></li><li><p><strong>I know specifically how I can and will debug live release builds of my work when they fail.</strong></p> <p>Bugs are inevitable. You should know the tools that will let you work through those problems in production, such as logs, debuggers, or a live shell.</p></li><li><p><strong>I know what data I am reading as part of my solution and where it comes from.</strong></p> <p>Know where the data comes from, in what format, and how you can read it.</p></li><li><p><strong>I know how often I am reading data I do not need as part of my solution.</strong></p> <p>Data access is rarely optimal. You’ll often be moving data that’s not required for your solution, such as unnecessary fields or wrapper objects. If you don’t know about this waste, you can’t reason about whether it’s worth the overhead or not.</p></li><li><p><strong>I know what data I am writing as part of my solution and where it is used.</strong></p> <p>All output data is intended for use by a human or another program. Be organized enough to know what the downstream consumers of your output are.</p></li><li><p><strong>I know how often I am writing data I do not need to as part of my solution.</strong></p> <p>Data output is also rarely optimal. Are you frequently writing out data that hasn’t changed? Are you writing many fields when only one is used downstream? Again, know about it so you can reason about it.</p></li><li><p><strong>I can articulate how all the data I use is laid out in memory.</strong></p> <p>Many programming languages and frameworks can handle memory for you, but that doesn’t abdicate you of responsibility. Know how your tools lay out memory, so you can tell when another approach makes sense.</p> <p>For example, in Python most objects are based on dictionaries, so you should have a solid understanding of how they work, and alternatives like <a href="https://docs.python.org/3/reference/datamodel.html#slots">slotted classes</a> or <a href="https://docs.python.org/3.10/library/array.html">arrays</a>.</p></li><li><p><strong>I never use the phrase “platform independent” when referring to my work.</strong></p> <p>Any system depends on many things below it. Know what they are.</p></li><li><p><strong>I never use the phrase “future proof” when referring to my work.</strong></p> <p>Future-proofing is “100% a fool’s errand”. “You can’t pre-solve problems you have no information of.”</p></li><li><p><strong>I can schedule my own time well.</strong></p> <p>“You’re an adult person, just use a calendar.”</p></li><li><p><strong>I am vigilant about not wasting others’ time.</strong></p> <p>Don’t waste time asking questions that you can google in five seconds. But also don’t waste loads of time struggling for days alone when you could get help from a team member in minutes! Find the balance.</p></li><li><p><strong>I actively seek constructive feedback and take it seriously.</strong></p> <p>Ask for feedback and do something about it.</p></li><li><p><strong>I am not actively avoiding any uncomfortable (professional) conversations.</strong></p> <p>If there’s something wrong at work, don’t put off talking about it.</p></li><li><p><strong>I am not actively avoiding any (professional) conflicts.</strong></p> <p>If you’ve noticed something is going wrong, whether technically or communication wise, get those conflicts out in the open. Letting them stew never helps.</p></li><li><p><strong>I consistently interact with other professionals, professionally.</strong></p> <p>Be courteous and professional! Mike jokes about setting an incredibly low bar: no yelling, no hitting, …</p></li><li><p><strong>I can articulate what I believe others should expect from me.</strong></p> <p>Have a standard for yourself and be ready to tell your co-workers what it is.</p></li><li><p><strong>I do not require multiple reminders to respond to a request or complete work.</strong></p> <p>“Waiting for someone else to poke you is not an effective way to get your job done.”</p></li><li><p><strong>I pursue opportunities to return value to the commons (when appropriate).</strong></p> <p>All our work builds on top of the work of countless others. At some point, you’ll have opportunities to give back to the community at large. For example, talking at meetups, making open source contributions, or even just discussing topics with your team to boost everyone’s skills.</p></li><li><p><strong>I actively work to bring value to the people I work with.</strong></p> <p>You’re part of a team, so work to help them.</p></li><li><p><strong>I actively work to ensure under-represented voices are heard.</strong></p> <p>Don’t stand by leaving this to be someone else’s problem. Do something to make sure that minorities are heard. This might mean ensuring that the minority person at work gets a chance to speak, that your hiring process is unbiased, or that your website is accessible for users who rely on screen readers.</p></li></div><p><small>One summary email a week, no spam, I pinky promise.</small></p></div>
  </body>
</html>
