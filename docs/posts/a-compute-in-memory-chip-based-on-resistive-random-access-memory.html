<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nature.com/articles/s41586-022-04992-8">Original</a>
    <h1>A compute-in-memory chip based on resistive random-access memory</h1>
    
    <div id="readability-page-1" class="page"><div>
            <section aria-labelledby="Abs1" data-title="Abstract" lang="en"><div id="Abs1-section"><h2 id="Abs1">Abstract</h2><p>Realizing increasingly complex artificial intelligence (AI) functionalities directly on edge devices calls for unprecedented energy efficiency of edge hardware. Compute-in-memory (CIM) based on resistive random-access memory (RRAM)<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 1" title="Wong, H. S. P. et al. Metal-oxide RRAM. Proc. IEEE 100, 1951–1970 (2012)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR1" id="ref-link-section-d163879637e577">1</a></sup> promises to meet such demand by storing AI model weights in dense, analogue and non-volatile RRAM devices, and by performing AI computation directly within RRAM, thus eliminating power-hungry data movement between separate compute and memory<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Prezioso, M. et al. Training and operation of an integrated neuromorphic network based on metal-oxide memristors. Nature 521, 61–64 (2015)." href="#ref-CR2" id="ref-link-section-d163879637e581">2</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Ambrogio, S. et al. Equivalent-accuracy accelerated neural-network training using analogue memory. Nature 558, 60–67 (2018)." href="#ref-CR3" id="ref-link-section-d163879637e581_1">3</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Ielmini, D. &amp; Wong, H. S. P. In-memory computing with resistive switching devices. Nat. Electron. 1, 333–343 (2018)." href="#ref-CR4" id="ref-link-section-d163879637e581_2">4</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 5" title="Yao, P. et al. Fully hardware-implemented memristor convolutional neural network. Nature 577, 641–646 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR5" id="ref-link-section-d163879637e584">5</a></sup>. Although recent studies have demonstrated in-memory matrix-vector multiplication on fully integrated RRAM-CIM hardware<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Mochida, R. et al. A 4M synapses integrated analog ReRAM based 66.5 TOPS/W neural-network processor with cell current controlled writing and flexible network architecture. In Symposium on VLSI Technology, Digest of Technical Papers 175–176 (IEEE, 2018)." href="#ref-CR6" id="ref-link-section-d163879637e588">6</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Chen, W. H. et al. CMOS-integrated memristive non-volatile computing-in-memory for AI edge processors. Nat. Electron. 2, 420–428 (2019)." href="#ref-CR7" id="ref-link-section-d163879637e588_1">7</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Khaddam-Aljameh, R. et al. HERMES core-A 14nm CMOS and PCM-based in-memory compute core using an array of 300ps/LSB linearized CCO-based ADCs and local digital processing. In IEEE Symposium on VLSI Circuits, Digest of Technical Papers JFS2-5 (IEEE, 2021)." href="#ref-CR8" id="ref-link-section-d163879637e588_2">8</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Hung, J. M. et al. A four-megabit compute-in-memory macro with eight-bit precision based on CMOS and resistive random-access memory for AI edge devices. Nat. Electron. 4, 921–930 (2021)." href="#ref-CR9" id="ref-link-section-d163879637e588_3">9</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Xue, C. X. et al. A 1Mb multibit ReRAM computing-in-memory macro with 14.6ns parallel MAC computing time for CNN based AI edge processors. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 388–390 (IEEE, 2019)." href="#ref-CR10" id="ref-link-section-d163879637e588_4">10</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Cai, F. et al. A fully integrated reprogrammable memristor–CMOS system for efficient multiply–accumulate operations. Nat. Electron. 2, 290–299 (2019)." href="#ref-CR11" id="ref-link-section-d163879637e588_5">11</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Ishii, M. et al. On-chip trainable 1.4M 6T2R PCM synaptic array with 1.6K stochastic LIF neurons for spiking RBM. In International Electron Devices Meeting (IEDM), Technical Digest 14.2.1–14.2.4 (IEEE, 2019)." href="#ref-CR12" id="ref-link-section-d163879637e588_6">12</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Yan, B. et al. RRAM-based spiking nonvolatile computing-in-memory processing engine with precision-configurable in situ nonlinear activation. In Symposium on VLSI Technology, Digest of Technical Papers T86–T87 (IEEE, 2019)." href="#ref-CR13" id="ref-link-section-d163879637e588_7">13</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Wan, W. et al. A 74 TMACS/W CMOS-RRAM neurosynaptic core with dynamically reconfigurable dataflow and in-situ transposable weights for probabilistic graphical models. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 498–500 (IEEE, 2020)." href="#ref-CR14" id="ref-link-section-d163879637e588_8">14</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Liu, Q. et al. A fully integrated analog ReRAM based 78.4TOPS/W compute-in-memory chip with fully parallel MAC computing. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 500–502 (IEEE, 2020)." href="#ref-CR15" id="ref-link-section-d163879637e588_9">15</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Xue, C. X. et al. A CMOS-integrated compute-in-memory macro based on resistive random-access memory for AI edge devices. Nat. Electron. 4, 81–90 (2021)." href="#ref-CR16" id="ref-link-section-d163879637e588_10">16</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 17" title="Narayanan, P. et al. Fully on-chip MAC at 14 nm enabled by accurate row-wise programming of PCM-based weights and parallel vector-transport in duration-format. IEEE Trans. Electron Devices 68, 6629–6636 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR17" id="ref-link-section-d163879637e591">17</a></sup>, it remains a goal for a RRAM-CIM chip to simultaneously deliver high energy efficiency, versatility to support diverse models and software-comparable accuracy. Although efficiency, versatility and accuracy are all indispensable for broad adoption of the technology, the inter-related trade-offs among them cannot be addressed by isolated improvements on any single abstraction level of the design. Here, by co-optimizing across all hierarchies of the design from algorithms and architecture to circuits and devices, we present NeuRRAM—a RRAM-based CIM chip that simultaneously delivers versatility in reconfiguring CIM cores for diverse model architectures, energy efficiency that is two-times better than previous state-of-the-art RRAM-CIM chips across various computational bit-precisions, and inference accuracy comparable to software models quantized to four-bit weights across various AI tasks, including accuracy of 99.0 percent on MNIST<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 18" title="LeCun, Y., Bottou, L., Bengio, Y. &amp; Haffner, P. Gradient-based learning applied to document recognition. Proc. IEEE 86, 2278–2323 (1998)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR18" id="ref-link-section-d163879637e595">18</a></sup> and 85.7 percent on CIFAR-10<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 19" title="Krizhevsky, A. &amp; Hinton, G. Learning Multiple Layers of Features from Tiny Images (2009); 
                  https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf
                  
                " href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR19" id="ref-link-section-d163879637e599">19</a></sup> image classification, 84.7-percent accuracy on Google speech command recognition<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 20" title="Warden, P. Speech commands: a dataset for limited-vocabulary speech recognition. Preprint at 
                  https://arxiv.org/abs/1804.03209
                  
                 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR20" id="ref-link-section-d163879637e604">20</a></sup>, and a 70-percent reduction in image-reconstruction error on a Bayesian image-recovery task.</p></div></section>
            

                
            
                <section data-title="Main"><div id="Sec1-section"><h2 id="Sec1">Main</h2><div id="Sec1-content"><p>Early research in the area of resistive random-access memory (RRAM) compute-in-memory (CIM) focused on demonstrating artificial intelligence (AI) functionalities on fabricated RRAM devices while using off-chip software and hardware to implement essential functionalities such as analogue-to-digital conversion and neuron activations for a complete system<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 2" title="Prezioso, M. et al. Training and operation of an integrated neuromorphic network based on metal-oxide memristors. Nature 521, 61–64 (2015)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR2" id="ref-link-section-d163879637e625">2</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 3" title="Ambrogio, S. et al. Equivalent-accuracy accelerated neural-network training using analogue memory. Nature 558, 60–67 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR3" id="ref-link-section-d163879637e628">3</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 6" title="Mochida, R. et al. A 4M synapses integrated analog ReRAM based 66.5 TOPS/W neural-network processor with cell current controlled writing and flexible network architecture. In Symposium on VLSI Technology, Digest of Technical Papers 175–176 (IEEE, 2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR6" id="ref-link-section-d163879637e631">6</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Warden, P. Speech commands: a dataset for limited-vocabulary speech recognition. Preprint at 
                  https://arxiv.org/abs/1804.03209
                  
                 (2018)." href="#ref-CR20" id="ref-link-section-d163879637e634">20</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="#ref-CR21" id="ref-link-section-d163879637e634_1">21</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Alibart, F., Zamanidoost, E. &amp; Strukov, D. B. Pattern classification by memristive crossbar circuits using ex situ and in situ training. Nat. Commun. 4, 2072 (2013)." href="#ref-CR22" id="ref-link-section-d163879637e634_2">22</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Eryilmaz, S. B. et al. Experimental demonstration of array-level learning with phase change synaptic devices. In International Electron Devices Meeting (IEDM), Technical Digest 25.5.1–25.5.4 (IEEE, 2013)." href="#ref-CR23" id="ref-link-section-d163879637e634_3">23</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Burr, G. W. et al. Experimental demonstration and tolerancing of a large-scale neural network (165 000 synapses) using phase-change memory as the synaptic weight element. IEEE Trans. Electron Devices 62, 3498–3507 (2015)." href="#ref-CR24" id="ref-link-section-d163879637e634_4">24</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Eryilmaz, S. B. et al. Training a probabilistic graphical model with resistive switching electronic synapses. IEEE Trans. Electron Devices 63, 5004–5011 (2016)." href="#ref-CR25" id="ref-link-section-d163879637e634_5">25</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Sheridan, P. M. et al. Sparse coding with memristor networks. Nat. Nanotechnol. 12, 784–789 (2017)." href="#ref-CR26" id="ref-link-section-d163879637e634_6">26</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 27" title="Yao, P. et al. Face classification using electronic synapses. Nat. Commun. 8, 15199 (2017)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR27" id="ref-link-section-d163879637e637">27</a></sup>. Although these studies proposed various techniques to mitigate the impacts of analogue-related hardware non-idealities on inference accuracy, the AI benchmark results reported were often obtained by performing software emulation based on characterized device data<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 3" title="Ambrogio, S. et al. Equivalent-accuracy accelerated neural-network training using analogue memory. Nature 558, 60–67 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR3" id="ref-link-section-d163879637e641">3</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 5" title="Yao, P. et al. Fully hardware-implemented memristor convolutional neural network. Nature 577, 641–646 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR5" id="ref-link-section-d163879637e644">5</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 21" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR21" id="ref-link-section-d163879637e647">21</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 24" title="Burr, G. W. et al. Experimental demonstration and tolerancing of a large-scale neural network (165 000 synapses) using phase-change memory as the synaptic weight element. IEEE Trans. Electron Devices 62, 3498–3507 (2015)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR24" id="ref-link-section-d163879637e650">24</a></sup>. Such an approach often overestimates accuracies compared with fully hardware-measured results owing to incomplete modelling of hardware non-idealities.</p><p>More recent studies have demonstrated fully integrated RRAM complementary metal–oxide–semiconductor (CMOS) chips capable of performing in-memory matrix-vector multiplication (MVM)<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Mochida, R. et al. A 4M synapses integrated analog ReRAM based 66.5 TOPS/W neural-network processor with cell current controlled writing and flexible network architecture. In Symposium on VLSI Technology, Digest of Technical Papers 175–176 (IEEE, 2018)." href="#ref-CR6" id="ref-link-section-d163879637e657">6</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Chen, W. H. et al. CMOS-integrated memristive non-volatile computing-in-memory for AI edge processors. Nat. Electron. 2, 420–428 (2019)." href="#ref-CR7" id="ref-link-section-d163879637e657_1">7</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Khaddam-Aljameh, R. et al. HERMES core-A 14nm CMOS and PCM-based in-memory compute core using an array of 300ps/LSB linearized CCO-based ADCs and local digital processing. In IEEE Symposium on VLSI Circuits, Digest of Technical Papers JFS2-5 (IEEE, 2021)." href="#ref-CR8" id="ref-link-section-d163879637e657_2">8</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Hung, J. M. et al. A four-megabit compute-in-memory macro with eight-bit precision based on CMOS and resistive random-access memory for AI edge devices. Nat. Electron. 4, 921–930 (2021)." href="#ref-CR9" id="ref-link-section-d163879637e657_3">9</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Xue, C. X. et al. A 1Mb multibit ReRAM computing-in-memory macro with 14.6ns parallel MAC computing time for CNN based AI edge processors. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 388–390 (IEEE, 2019)." href="#ref-CR10" id="ref-link-section-d163879637e657_4">10</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Cai, F. et al. A fully integrated reprogrammable memristor–CMOS system for efficient multiply–accumulate operations. Nat. Electron. 2, 290–299 (2019)." href="#ref-CR11" id="ref-link-section-d163879637e657_5">11</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Ishii, M. et al. On-chip trainable 1.4M 6T2R PCM synaptic array with 1.6K stochastic LIF neurons for spiking RBM. In International Electron Devices Meeting (IEDM), Technical Digest 14.2.1–14.2.4 (IEEE, 2019)." href="#ref-CR12" id="ref-link-section-d163879637e657_6">12</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Yan, B. et al. RRAM-based spiking nonvolatile computing-in-memory processing engine with precision-configurable in situ nonlinear activation. In Symposium on VLSI Technology, Digest of Technical Papers T86–T87 (IEEE, 2019)." href="#ref-CR13" id="ref-link-section-d163879637e657_7">13</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Wan, W. et al. A 74 TMACS/W CMOS-RRAM neurosynaptic core with dynamically reconfigurable dataflow and in-situ transposable weights for probabilistic graphical models. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 498–500 (IEEE, 2020)." href="#ref-CR14" id="ref-link-section-d163879637e657_8">14</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Liu, Q. et al. A fully integrated analog ReRAM based 78.4TOPS/W compute-in-memory chip with fully parallel MAC computing. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 500–502 (IEEE, 2020)." href="#ref-CR15" id="ref-link-section-d163879637e657_9">15</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Xue, C. X. et al. A CMOS-integrated compute-in-memory macro based on resistive random-access memory for AI edge devices. Nat. Electron. 4, 81–90 (2021)." href="#ref-CR16" id="ref-link-section-d163879637e657_10">16</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 17" title="Narayanan, P. et al. Fully on-chip MAC at 14 nm enabled by accurate row-wise programming of PCM-based weights and parallel vector-transport in duration-format. IEEE Trans. Electron Devices 68, 6629–6636 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR17" id="ref-link-section-d163879637e660">17</a></sup>. However, for a RRAM-CIM chip to be broadly adopted in practical AI applications, it needs to simultaneously deliver high energy efficiency, the flexibility to support diverse AI model architectures and software-comparable inference accuracy. So far, there has not been a study aimed at simultaneously improving all these three aspects of a design. Moreover, AI application-level benchmarks in previous studies have limited diversity and complexity. None of the studies have experimentally measured multiple edge AI applications with complexity matching those in MLPerf Tiny, a commonly used benchmark suite for edge AI hardware<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 28" title="Banbury, C. et al. MLPerf tiny benchmark. In Conference on Neural Information Processing Systems (NeurIPS) Track on Datasets and Benchmarks (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR28" id="ref-link-section-d163879637e664">28</a></sup>. The challenge arises from the inter-related trade-offs between efficiency, flexibility and accuracy. The highly-parallel analogue computation within RRAM-CIM architecture brings superior efficiency, but makes it challenging to realize the same level of functional flexibility and computational accuracy as in digital circuits. Meanwhile, attaining algorithmic resiliency to hardware non-idealities becomes more difficult for more complex AI tasks owing to using less over-parameterized models on the edge<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 29" title="Roy, S., Sridharan, S., Jain, S. &amp; Raghunathan, A. TxSim: modeling training of deep neural networks on resistive crossbar systems. IEEE Trans. Very Large Scale Integr. Syst. 29, 730–738 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR29" id="ref-link-section-d163879637e668">29</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 30" title="Yang, T. J. &amp; Sze, V. Design considerations for efficient deep neural networks on processing-in-memory accelerators. In International Electron Devices Meeting (IEDM), Technical Digest 22.1.1–22.1.4 (IEEE, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR30" id="ref-link-section-d163879637e671">30</a></sup>.</p><p>To address these challenges, we present NeuRRAM, a 48-core RRAM-CIM hardware encompassing innovations across the full stack of the design. (1) At the device level, 3 million RRAM devices with high analogue programmability are monolithically integrated with CMOS circuits. (2) At the circuit level, a voltage-mode neuron circuit supports variable computation bit-precision and activation functions while performing analogue-to-digital conversion at low power consumption and compact-area footprint. (3) At the architecture level, a bidirectional transposable neurosynaptic array (TNSA) architecture enables reconfigurability in dataflow directions with minimal area and energy overheads. (4) At the system level, 48 CIM cores can perform inference in parallel and supports various weight-mapping strategies. (5) Finally, at the algorithm level, various hardware-algorithm co-optimization techniques mitigate the impact of hardware non-idealities on inference accuracy. We report fully hardware-measured inference results for a range of AI tasks including image classifications using CIFAR-10<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 19" title="Krizhevsky, A. &amp; Hinton, G. Learning Multiple Layers of Features from Tiny Images (2009); 
                  https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf
                  
                " href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR19" id="ref-link-section-d163879637e678">19</a></sup> and MNIST<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 18" title="LeCun, Y., Bottou, L., Bengio, Y. &amp; Haffner, P. Gradient-based learning applied to document recognition. Proc. IEEE 86, 2278–2323 (1998)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR18" id="ref-link-section-d163879637e682">18</a></sup> datasets, Google speech command recognition<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 20" title="Warden, P. Speech commands: a dataset for limited-vocabulary speech recognition. Preprint at 
                  https://arxiv.org/abs/1804.03209
                  
                 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR20" id="ref-link-section-d163879637e686">20</a></sup> and MNIST image recovery, implemented with diverse AI models including convolutional neural networks (CNNs)<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 31" title="Lecun, Y., Bengio, Y. &amp; Hinton, G. Deep learning. Nature 521, 436–444 (2015)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR31" id="ref-link-section-d163879637e690">31</a></sup>, long short-term memory (LSTM)<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 32" title="Hochreiter, S. &amp; Schmidhuber, J. Long short-term memory. Neural Comput. 9, 1735–1780 (1997)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR32" id="ref-link-section-d163879637e694">32</a></sup> and probabilistic graphical models<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 33" title="Koller, D. &amp; Friedman, N. Probabilistic Graphical Models: Principles and Techniques (Adaptive Computation and Machine Learning series) (MIT Press, 2009)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR33" id="ref-link-section-d163879637e699">33</a></sup> (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig1">1e</a>). The chip is measured to achieve an energy-delay product (EDP) lower than previous state-of-the-art RRAM-CIM chips, while it operates over a range of configurations to suit various AI benchmark applications (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig1">1d</a>).</p><div data-test="figure" data-container-section="figure" id="figure-1" data-title="Design methodology and main contributions of the NeuRRAM chip."><figure><figcaption><b id="Fig1" data-test="figure-caption-text">Fig. 1: Design methodology and main contributions of the NeuRRAM chip.</b></figcaption><div><div><a data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/1" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig1_HTML.png?as=webp"/><img aria-describedby="Fig1" src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig1_HTML.png" alt="figure 1" loading="lazy" width="685" height="443"/></picture></a></div><p><b>a</b>, Cross-layer co-optimizations across the full stack of the design enable NeuRRAM to simultaneously deliver high versatility, computational efficiency and software-comparable inference accuracy. <b>b</b>, Micrograph of the NeuRRAM chip. <b>c</b>, Reconfigurability in various aspects of the design enables NeuRRAM to implement diverse AI models for a wide variety of applications. <b>d</b>, Comparison of EDP, a commonly used energy-efficiency and performance metric among recent RRAM-based CIM hardware. <b>e</b>, Fully hardware-measured inference accuracy on NeuRRAM is comparable to software models quantized to 4-bit weights across various AI benchmarks.</p></div></figure></div></div></div></section><section data-title="Reconfigurable RRAM-CIM architecture"><div id="Sec2-section"><h2 id="Sec2">Reconfigurable RRAM-CIM architecture</h2><div id="Sec2-content"><p>A NeuRRAM chip consists of 48 CIM cores that can perform computation in parallel. A core can be selectively turned off through power gating when not actively used, whereas the model weights are retained by the non-volatile RRAM devices. Central to each core is a TNSA consisting of 256 × 256 RRAM cells and 256 CMOS neuron circuits that implement analogue-to-digital converters (ADCs) and activation functions. Additional peripheral circuits along the edge provides inference control and manages RRAM programming.</p><p>The TNSA architecture is designed to offer flexible control of dataflow directions, which is crucial for enabling diverse model architectures with different dataflow patterns. For instance, in CNNs that are commonly applied to vision-related tasks, data flows in a single direction through layers to generate data representations at different abstraction levels; in LSTMs that are used to process temporal data such as audio signals, data travel recurrently through the same layer for multiple time steps; in probabilistic graphical models such as a restricted Boltzmann machine (RBM), probabilistic sampling is performed back and forth between layers until the network converges to a high-probability state. Besides inference, the error back-propagation during gradient-descent training of multiple AI models requires reversing the direction of dataflow through the network.</p><p>However, conventional RRAM-CIM architectures are limited to perform MVM in a single direction by hardwiring rows and columns of the RRAM crossbar array to dedicated circuits on the periphery to drive inputs and measure outputs. Some studies implement reconfigurable dataflow directions by adding extra hardware, which incurs substantial energy, latency and area penalties (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig7">2</a>): executing bidirectional (forwards and backwards) dataflow requires either duplicating power-hungry and area-hungry ADCs at both ends of the RRAM array<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 11" title="Cai, F. et al. A fully integrated reprogrammable memristor–CMOS system for efficient multiply–accumulate operations. Nat. Electron. 2, 290–299 (2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR11" id="ref-link-section-d163879637e760">11</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 34" title="Su, J. W. et al. A 28nm 64Kb inference-training two-way transpose multibit 6T SRAM compute-in-memory macro for AI edge chips. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 240–242 (IEEE, 2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR34" id="ref-link-section-d163879637e763">34</a></sup> or dedicating a large area to routing both rows and columns of the array to shared data converters<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 15" title="Liu, Q. et al. A fully integrated analog ReRAM based 78.4TOPS/W compute-in-memory chip with fully parallel MAC computing. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 500–502 (IEEE, 2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR15" id="ref-link-section-d163879637e767">15</a></sup>; the recurrent connections require writing the outputs to a buffer memory outside of the RRAM array, and reading them back for the next time-step computation<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 35" title="Guo, R. et al. A 5.1pJ/neuron 127.3us/inference RNN-based speech recognition processor using 16 computing-in-memory SRAM macros in 65nm CMOS. In IEEE Symposium on VLSI Circuits, Digest of Technical Papers 120–121 (IEEE, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR35" id="ref-link-section-d163879637e771">35</a></sup>.</p><p>The TNSA architecture realizes dynamic dataflow reconfigurability with little overhead. Whereas in conventional designs, CMOS peripheral circuits such as ADCs connect at only one end of the RRAM array, the TNSA architecture physically interleaves the RRAM weights and the CMOS neuron circuits, and connects them along the length of both rows and columns. As shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2e</a>, a TNSA consists of 16 × 16 of such interleaved corelets that are connected by shared bit-lines (BLs) and word-lines (WLs) along the horizontal direction and source-lines (SLs) along the vertical direction. Each corelet encloses 16 × 16 RRAM devices and one neuron circuit. The neuron connects to 1 BL and 1 SL out of the 16 BLs and the 16 SLs that pass through the corelet, and is responsible for integrating inputs from all the 256 RRAMs connecting to the same BL or SL. Sixteen of these RRAMs are within the same corelet as the neuron; and the other 240 are within the other 15 corelets along the same row or column. Specifically, Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2f</a> shows that the neuron within corelet (<i>i</i>, <i>j</i>) connects to the (16<i>i</i> + <i>j</i>)th BL and the (16<i>j</i> <i>+</i> <i>i</i>)th SL. Such a configuration ensures that each BL or SL connects uniquely to a neuron, while doing so without duplicating neurons at both ends of the array, thus saving area and energy.</p><div data-test="figure" data-container-section="figure" id="figure-2" data-title="Reconfigurable architecture of the NeuRRAM chip."><figure><figcaption><b id="Fig2" data-test="figure-caption-text">Fig. 2: Reconfigurable architecture of the NeuRRAM chip.</b></figcaption><div><div><a data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/2" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig2_HTML.png?as=webp"/><img aria-describedby="Fig2" src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig2_HTML.png" alt="figure 2" loading="lazy" width="685" height="639"/></picture></a></div><p><b>a</b>, Multi-core architecture of the NeuRRAM chip, and various ways, labelled (1) to (6), to map neural-network layers onto CIM cores. <b>b</b>, Zoomed-in chip micrograph on a single CIM core. <b>c</b>, A cross-sectional transmission electron microscopy image showing the layer stack of the monolithically integrated RRAM and CMOS. <b>d</b>, Block diagram of a CIM core. A core consists of a TNSA, drivers for BLs, WLs, and SLs, registers that store MVM inputs and outputs, a LFSR pseudo-random number generator (PRNG), and a controller. During the MVM input stage, the drivers convert register inputs (REG) and PRNG inputs (PRN) to analogue voltages and send them to TNSA; during the MVM output stage, the drivers pass digital outputs from neurons back to registers through REG. <b>e</b>, The architecture of a TNSA consists of 16 × 16 corelets with interleaving RRAM weights and CMOS neurons. Each neuron integrates inputs from 256 RRAMs connecting to the same horizontal BL or vertical SL. <b>f</b>, Each corelet contains 16 × 16 RRAMs and 1 neuron. The neuron connects to 1 of the 16 BLs and 1 of the 16 SLs that pass through the corelet, and can use a BL and a SL for both its input and output. <b>g</b>, The TNSA can be dynamically configured for MVM in forwards, backwards or recurrent directions. <b>h</b>, Differential input and differential output schemes used to implement real-valued weights during forwards and backwards MVMs. Weights are encoded as the differential conductance between two RRAM cells on adjacent rows (G+ and G-).</p></div></figure></div><p>Moreover, a neuron uses its BL and SL switches for both its input and output: it not only receives the analogue MVM output coming from BL or SL through the switches but also sends the converted digital results to peripheral registers through the same switches. By configuring which switch to use during the input and output stages of the neuron, we can realize various MVM dataflow directions. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2g</a> shows the forwards, backwards and recurrent MVMs enabled by the TNSA. To implement forwards MVM (BL to SL), during the input stage, input pulses are applied to the BLs through the BL drivers, get weighted by the RRAMs and enter the neuron through its SL switch; during the output stage, the neuron sends the converted digital outputs to SL registers through its SL switch; to implement recurrent MVM (BL to BL), the neuron instead receives input through its SL switch and sends the digital output back to the BL registers through its BL switch.</p><p>Weights of most AI models take both positive and negative values. We encode each weight as difference of conductance between two RRAM cells on adjacent rows along the same column (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2h</a>). The forwards MVM is performed using a differential input scheme, where BL drivers send input voltage pulses with opposite polarities to adjacent BLs. The backwards MVM is performed using a differential output scheme, where we digitally subtract outputs from neurons connecting to adjacent BLs after neurons finish analogue-to-digital conversions.</p><p>To maximize throughput of AI inference on 48 CIM cores, we implement a broad selection of weight-mapping strategies that allow us to exploit both model parallelism and data parallelism (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2a</a>) through multi-core parallel MVMs. Using a CNN as an example, to maximize data parallelism, we duplicate the weights of the most computationally intensive layers (early convolutional layers) to multiple cores for parallel inference on multiple data; to maximize model parallelism, we map different convolutional layers to different cores and perform parallel inference in a pipelined fashion. Meanwhile, we divide the layers whose weight dimensions exceed the RRAM array size into multiple segments and assign them to multiple cores for parallel execution. A more detailed description of the weight-mapping strategies is provided in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>. The intermediate data buffers and partial-sum accumulators are implemented by a field-programmable gate array (FPGA) integrated on the same board as the NeuRRAM chip. Although these digital peripheral modules are not the focus of this study, they will eventually need to be integrated within the same chip in production-ready RRAM-CIM hardware.</p></div></div></section><section data-title="Efficient voltage-mode neuron circuit"><div id="Sec3-section"><h2 id="Sec3">Efficient voltage-mode neuron circuit</h2><div id="Sec3-content"><p>Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig1">1d</a> and Extended Data Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Tab2">1</a> show that the NeuRRAM chip achieves 1.6-times to 2.3-times lower EDP and 7-times to 13-times higher computational density (measured by throughput per million of RRAMs) at various MVM input and output bit-precisions than previous state-of-the-art RRAM-based CIM chips, despite being fabricated at an older technology node<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Narayanan, P. et al. Fully on-chip MAC at 14 nm enabled by accurate row-wise programming of PCM-based weights and parallel vector-transport in duration-format. IEEE Trans. Electron Devices 68, 6629–6636 (2021)." href="#ref-CR17" id="ref-link-section-d163879637e886">17</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="LeCun, Y., Bottou, L., Bengio, Y. &amp; Haffner, P. Gradient-based learning applied to document recognition. Proc. IEEE 86, 2278–2323 (1998)." href="#ref-CR18" id="ref-link-section-d163879637e886_1">18</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Krizhevsky, A. &amp; Hinton, G. Learning Multiple Layers of Features from Tiny Images (2009); 
                  https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf
                  
                " href="#ref-CR19" id="ref-link-section-d163879637e886_2">19</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Warden, P. Speech commands: a dataset for limited-vocabulary speech recognition. Preprint at 
                  https://arxiv.org/abs/1804.03209
                  
                 (2018)." href="#ref-CR20" id="ref-link-section-d163879637e886_3">20</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="#ref-CR21" id="ref-link-section-d163879637e886_4">21</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Alibart, F., Zamanidoost, E. &amp; Strukov, D. B. Pattern classification by memristive crossbar circuits using ex situ and in situ training. Nat. Commun. 4, 2072 (2013)." href="#ref-CR22" id="ref-link-section-d163879637e886_5">22</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Eryilmaz, S. B. et al. Experimental demonstration of array-level learning with phase change synaptic devices. In International Electron Devices Meeting (IEDM), Technical Digest 25.5.1–25.5.4 (IEEE, 2013)." href="#ref-CR23" id="ref-link-section-d163879637e886_6">23</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Burr, G. W. et al. Experimental demonstration and tolerancing of a large-scale neural network (165 000 synapses) using phase-change memory as the synaptic weight element. IEEE Trans. Electron Devices 62, 3498–3507 (2015)." href="#ref-CR24" id="ref-link-section-d163879637e886_7">24</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Eryilmaz, S. B. et al. Training a probabilistic graphical model with resistive switching electronic synapses. IEEE Trans. Electron Devices 63, 5004–5011 (2016)." href="#ref-CR25" id="ref-link-section-d163879637e886_8">25</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Sheridan, P. M. et al. Sparse coding with memristor networks. Nat. Nanotechnol. 12, 784–789 (2017)." href="#ref-CR26" id="ref-link-section-d163879637e886_9">26</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 27" title="Yao, P. et al. Face classification using electronic synapses. Nat. Commun. 8, 15199 (2017)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR27" id="ref-link-section-d163879637e889">27</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 36" title="Wang, Z. et al. Fully memristive neural networks for pattern classification with unsupervised learning. Nat. Electron. 1, 137–145 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR36" id="ref-link-section-d163879637e892">36</a></sup>. The reported energy and delay are measured for performing an MVM with a 256 × 256 weight matrix. It is noted that these numbers and those reported in previous RRAM-CIM work represent the peak energy efficiency achieved when the array utilization is 100% and does not account for energy spent on intermediate data transfer. Network-on-chip and program scheduling need to be carefully designed to achieve good end-to-end application-level energy efficiency<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 37" title="Shafiee, A. et al. ISAAC: a convolutional neural network accelerator with in-situ analog arithmetic in crossbars. In Proc. 2016 43rd International Symposium on Computer Architecture (ISCA) 14-26 (IEEE/ACM, 2016)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR37" id="ref-link-section-d163879637e896">37</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 38" title="Ankit, A. et al. PUMA: a programmable ultra-efficient memristor-based accelerator for machine learning inference. In International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) 715–731 (ACM, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR38" id="ref-link-section-d163879637e899">38</a></sup>.</p><p>Key to the NeuRRAM’s EDP improvement is a novel in-memory MVM output-sensing scheme. The conventional approach is to use voltage as input, and measure the current as the results based on Ohm’s law (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3a</a>). Such a current-mode-sensing scheme cannot fully exploit the high-parallelism nature of CIM. First, simultaneously turning on multiple rows leads to a large array current. Sinking the large current requires peripheral circuits to use large transistors, whose area needs to be amortized by time-multiplexing between multiple columns, which limits ‘column parallelism’. Second, MVM results produced by different neural-network layers have drastically different dynamic ranges (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3c</a>). Optimizing ADCs across such a wide dynamic range is difficult. To equalize the dynamic range, designs typically activate a fraction of input wires every cycle to compute a partial sum, and thus require multiple cycles to complete an MVM, which limits ‘row parallelism’.</p><div data-test="figure" data-container-section="figure" id="figure-3" data-title="Voltage-mode MVM with multi-bit inputs and outputs."><figure><figcaption><b id="Fig3" data-test="figure-caption-text">Fig. 3: Voltage-mode MVM with multi-bit inputs and outputs.</b></figcaption><div><div><a data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/3" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig3_HTML.png?as=webp"/><img aria-describedby="Fig3" src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig3_HTML.png" alt="figure 3" loading="lazy" width="685" height="649"/></picture></a></div><p><b>a</b>, Conventional current-mode-sensing scheme needs to activate a small fraction of total <i>N</i> rows each cycle to limit total current <i>I</i><sub>SL </sub>and time-multiplex ADCs across multiple columns to amortize ADC area, thus limiting its computational parallelism. <b>b</b>, Voltage-mode sensing employed by NeuRRAM can activate all the rows and all the columns in a single cycle, enabling higher parallelism. <b>c</b>, MVM output distribution from a CNN layer and from an LSTM layer (weights normalized to the same range). Voltage-mode sensing intrinsically normalizes wide variation in output dynamic range. <b>d</b>, Schematic of the voltage-mode neuron circuit, where BL<sub>sel</sub>, SL<sub>sel</sub>, Sample, Integ, Reset, Latch, Decr, and WR are digital signals controlling state of the switches. <b>e</b>, Sample waveforms to perform MVM and 4-bit signed inputs digital-to-analogue conversion. WLs are pulsed once per magnitude-bit; sampling and integration are performed 2<sup><i>n</i>−1</sup> times for the <i>n</i>th LSB. <b>f</b>, Two-phase MVM: for input precision greater than 4 bits, inputs are divided into a MSB segment and a LSB segment. MVMs and ADCs are performed separately for each segment, followed by a shift-and-add to obtain final outputs. <b>g</b>, Sample waveforms to perform 5-bit signed outputs analogue-to-digital conversion. The sign-bit is first generated by a comparison operation. The magnitude-bits are generated through a binary search process realized by adding/subtracting charge on <i>C</i><sub>integ</sub>. From MSB to LSB, added/subtracted charge is halved every bit. <b>h</b>, Chip-measured 64 × 64 MVM outputs versus ideal outputs under 4-bit input and 6-bit output.</p></div></figure></div><p>NeuRRAM improves computation parallelism and energy efficiency by virtue of a neuron circuit implementing a voltage-mode sensing scheme. The neuron performs analogue-to-digital conversion of the MVM outputs by directly sensing the settled open-circuit voltage on the BL or SL line capacitance<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 39" title="Wan, W. et al. A voltage-mode sensing scheme with differential-row weight mapping for energy-efficient RRAM-based in-memory computing. In Symposium on VLSI Technology, Digest of Technical Papers (IEEE, 2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR39" id="ref-link-section-d163879637e983">39</a></sup> (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3b</a>): voltage inputs are driven on the BLs whereas the SLs are kept floating, or vice versa, depending on the MVM direction. WLs are activated to start the MVM operation. The voltage on the output line settles to the weighted average of the voltages driven on the input lines, where the weights are the RRAM conductances. Upon deactivating the WLs, the output is sampled by transferring the charge on the output line to the neuron sampling capacitor (<i>C</i><sub>sample</sub> in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3d</a>). The neuron then accumulates this charge onto an integration capacitor (<i>C</i><sub>integ</sub>) for subsequent analogue-to-digital conversion.</p><p>Such voltage-mode sensing obviates the need for power-hungry and area-hungry peripheral circuits to sink large current while clamping voltage, improving energy and area efficiency and eliminating output time-multiplexing. Meanwhile, the weight normalization owing to the conductance weighting in the voltage output (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3c</a>) results in an automatic output dynamic range normalization for different weight matrices. Therefore, MVMs with different weight dimensions can all be completed within a single cycle, which significantly improves computational throughput. To eliminate the normalization factor from the final results, we pre-compute its value and multiply it back to the digital outputs from the ADC.</p><p>Our voltage-mode neuron supports MVM with 1-bit to 8-bit inputs and 1-bit to 10-bit outputs. The multi-bit input is realized in a bit-serial fashion where charge is sampled and integrated onto <i>C</i><sub>integ</sub> for 2<sup><i>n</i>−1</sup> cycles for the <i>n</i>th least significant bit (LSB) (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3e</a>). For MVM inputs greater than 4 bits, we break the bit sequence into two segments, compute MVM for each segment separately and digitally perform a shift-and-add to obtain the final results (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3f</a>). Such a two-phase input scheme improves energy efficiency and overcomes voltage headroom clipping at high-input precisions.</p><p>The multi-bit output is generated through a binary search process (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3g</a>). Every cycle, neurons add or subtract <i>C</i><sub>sample</sub><i>V</i><sub>decr</sub> amount of charge from <i>C</i><sub>integ</sub>, where <i>V</i><sub>decr</sub> is a bias voltage shared by all neurons. Neurons then compare the total charge on <i>C</i><sub>integ</sub> with a fixed threshold voltage <i>V</i><sub>ref</sub> to generate a 1-bit output. From the most significant bit (MSB) to the least significant bit (LSB), <i>V</i><sub>decr</sub> is halved every cycle. Compared with other ADC architectures that implement a binary search, our ADC scheme eliminates the residue amplifier of an algorithmic ADC, and does not require an individual DAC for each ADC to generate reference voltages like a successive approximation register (SAR) ADC<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 40" title="Murmann, B. Digitally assisted data converter design. In European Conference on Solid-State Circuits (ESSCIRC) 24–31 (IEEE, 2013)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR40" id="ref-link-section-d163879637e1065">40</a></sup>. Instead, our ADC scheme allows sharing a single digital-to-analogue converter (DAC) across all neurons to amortize the DAC area, leading to a more compact design. The multi-bit MVM is validated by comparing ideal and measured results, as shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3h</a> and Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig10">5</a>. More details on the multi-bit input and output implementation can be found in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>.</p><p>The neuron can also be reconfigured to directly implement Rectified Linear Unit (ReLU)/sigmoid/tanh as activations when needed. In addition, it supports probabilistic sampling for stochastic activation functions by injecting pseudo-random noise generated by a linear-feedback shift register (LFSR) block into the neuron integrator. All the neuron circuit operations are performed by dynamically configuring a single amplifier in the neuron as either an integrator or a comparator during different phases of operations, as detailed in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>. This results in a more compact design than other work that merges ADC and neuron activation functions within the same module<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 12" title="Ishii, M. et al. On-chip trainable 1.4M 6T2R PCM synaptic array with 1.6K stochastic LIF neurons for spiking RBM. In International Electron Devices Meeting (IEDM), Technical Digest 14.2.1–14.2.4 (IEEE, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR12" id="ref-link-section-d163879637e1084">12</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 13" title="Yan, B. et al. RRAM-based spiking nonvolatile computing-in-memory processing engine with precision-configurable in situ nonlinear activation. In Symposium on VLSI Technology, Digest of Technical Papers T86–T87 (IEEE, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR13" id="ref-link-section-d163879637e1087">13</a></sup>. Although most existing CIM designs use time-multiplexed ADCs for multiple rows and columns to amortize the ADC area, the compactness of our neuron circuit allows us to dedicate a neuron for each pair of BL and SL, and tightly interleave the neuron with RRAM devices within the TNSA architecture, as can be seen in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig16">11d</a>.</p></div></div></section><section data-title="Hardware-algorithm co-optimizations"><div id="Sec4-section"><h2 id="Sec4">Hardware-algorithm co-optimizations</h2><div id="Sec4-content"><p>The innovations on the chip architecture and circuit design bring superior efficiency and reconfigurability to NeuRRAM. To complete the story, we must ensure that AI inference accuracy can be preserved under various circuit and device non-idealities<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 3" title="Ambrogio, S. et al. Equivalent-accuracy accelerated neural-network training using analogue memory. Nature 558, 60–67 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR3" id="ref-link-section-d163879637e1102">3</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 41" title="Zhao, M. et al. Investigation of statistical retention of filamentary analog RRAM for neuromophic computing. In International Electron Devices Meeting (IEDM), Technical Digest 39.4.1–39.4.4 (IEEE, 2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR41" id="ref-link-section-d163879637e1105">41</a></sup>. We developed a set of hardware-algorithm co-optimization techniques that allow NeuRRAM to deliver software-comparable accuracy across diverse AI applications. Importantly, all the AI benchmark results presented in this paper are obtained entirely from hardware measurements on complete datasets. Although most previous efforts (with a few exceptions<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 8" title="Khaddam-Aljameh, R. et al. HERMES core-A 14nm CMOS and PCM-based in-memory compute core using an array of 300ps/LSB linearized CCO-based ADCs and local digital processing. In IEEE Symposium on VLSI Circuits, Digest of Technical Papers JFS2-5 (IEEE, 2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR8" id="ref-link-section-d163879637e1109">8</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 17" title="Narayanan, P. et al. Fully on-chip MAC at 14 nm enabled by accurate row-wise programming of PCM-based weights and parallel vector-transport in duration-format. IEEE Trans. Electron Devices 68, 6629–6636 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR17" id="ref-link-section-d163879637e1112">17</a></sup>) have reported benchmark results using a mixture of hardware characterization and software simulation, for example, emulate the array-level MVM process in software using measured device characteristics<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 3" title="Ambrogio, S. et al. Equivalent-accuracy accelerated neural-network training using analogue memory. Nature 558, 60–67 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR3" id="ref-link-section-d163879637e1116">3</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 5" title="Yao, P. et al. Fully hardware-implemented memristor convolutional neural network. Nature 577, 641–646 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR5" id="ref-link-section-d163879637e1119">5</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 21" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR21" id="ref-link-section-d163879637e1122">21</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 24" title="Burr, G. W. et al. Experimental demonstration and tolerancing of a large-scale neural network (165 000 synapses) using phase-change memory as the synaptic weight element. IEEE Trans. Electron Devices 62, 3498–3507 (2015)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR24" id="ref-link-section-d163879637e1125">24</a></sup>, such an approach often fails to model the complete set of non-idealities existing in realistic hardware. As shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig4">4a</a>, these non-idealities may include (1) Voltage drop on input wires (<i>R</i><sub>wire</sub>), (2) on RRAM array drivers (<i>R</i><sub>driver</sub>) and (3) on crossbar wires (e.g. BL resistance <i>R</i><sub>BL</sub>), (4) limited RRAM programming resolution, (5) RRAM conductance relaxation<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 41" title="Zhao, M. et al. Investigation of statistical retention of filamentary analog RRAM for neuromophic computing. In International Electron Devices Meeting (IEDM), Technical Digest 39.4.1–39.4.4 (IEEE, 2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR41" id="ref-link-section-d163879637e1145">41</a></sup>, (6) capacitive coupling from simultaneously switching array wires, and (7) limited ADC resolution and dynamic range. Our experiments show that omitting certain non-idealities in simulation leads to over-optimistic prediction of inference accuracy. For example, the third and the fourth bars in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig5">5a</a> show a 2.32% accuracy difference between simulation and measurement for CIFAR-10 classification<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 19" title="Krizhevsky, A. &amp; Hinton, G. Learning Multiple Layers of Features from Tiny Images (2009); 
                  https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf
                  
                " href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR19" id="ref-link-section-d163879637e1152">19</a></sup>, whereas the simulation accounts for only non-idealities (5) and (7), which are what previous studies most often modelled<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 5" title="Yao, P. et al. Fully hardware-implemented memristor convolutional neural network. Nature 577, 641–646 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR5" id="ref-link-section-d163879637e1157">5</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 21" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR21" id="ref-link-section-d163879637e1160">21</a></sup>.</p><div data-test="figure" data-container-section="figure" id="figure-4" data-title="Hardware-algorithm co-optimization techniques to improve NeuRRAM inference accuracy."><figure><figcaption><b id="Fig4" data-test="figure-caption-text">Fig. 4: Hardware-algorithm co-optimization techniques to improve NeuRRAM inference accuracy.</b></figcaption><div><div><a data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/4" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig4_HTML.png?as=webp"/><img aria-describedby="Fig4" src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig4_HTML.png" alt="figure 4" loading="lazy" width="685" height="474"/></picture></a></div><p><b>a</b>, Various device and circuit non-idealities (labelled (1) to (7)) of in-memory MVM. <b>b</b>, Model-driven chip calibration technique to search for optimal chip operating conditions and record offsets for subsequent cancellation. <b>c</b>, Noise-resilient neural-network training technique to train the model with noise injection. The noise distribution is obtained from hardware characterization. The trained weights are programmed to the continuous analogue conductance of RRAMs without quantization as shown by the continuous diagonal band at the bottom. <b>d</b>, Chip-in-the-loop progressive fine-tuning technique: weights are progressively mapped onto the chip one layer at a time. The hardware-measured outputs from layer <i>n</i> are used as inputs to fine-tune the remaining layers <i>n</i> + 1 to <i>N</i>.</p></div></figure></div><div data-test="figure" data-container-section="figure" id="figure-5" data-title="Measured results showing the efficacy of the hardware-algorithm co-optimization techniques."><figure><figcaption><b id="Fig5" data-test="figure-caption-text">Fig. 5: Measured results showing the efficacy of the hardware-algorithm co-optimization techniques.</b></figcaption><div><div><a data-test="img-link" data-track="click" data-track-label="image" data-track-action="view figure" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/5" rel="nofollow"><picture><source type="image/webp" srcset="//media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig5_HTML.png?as=webp"/><img aria-describedby="Fig5" src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig5_HTML.png" alt="figure 5" loading="lazy" width="685" height="300"/></picture></a></div><p><b>a</b>, Simulated (blue) and measured (red) CIFAR-10 test-set classification accuracies. <b>b</b>, CIFAR-10 classification accuracy at various time steps of chip-in-the-loop fine-tuning. From left to right, each data point represents a new layer (Conv0 to Dense) programmed onto the chip. The accuracy at a layer is evaluated by using the hardware-measured outputs from that layer as inputs to the remaining layers that are simulated in software. Two curves compare the test-set inference accuracy with and without applying fine-tuning during training. <b>c</b>, RBM-based image recovery on noisy images (top) and partially occluded images measured on NeuRRAM (bottom).</p></div></figure></div><p>Our hardware-algorithm co-optimization approach includes three main techniques: (1) model-driven chip calibration, (2) noise-resilient neural-network training and analogue weight programming, and (3) chip-in-the-loop progressive model fine-tuning. Model-driven chip calibration uses the real model weights and input data to optimize chip operating conditions such as input voltage pulse amplitude, and records any ADC offsets for subsequent cancellation during inference. Ideally, the MVM output voltage dynamic range should fully utilize the ADC input swing to minimize discretization error. However, without calibration, the MVM output dynamic range varies with network layers even with the weight normalization effect of the voltage-mode sensing. To calibrate MVM to the optimal dynamic range, for each network layer, we use a subset of training-set data as calibration input to search for the best operating conditions (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig4">4b</a>). Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig11">6</a> shows that different calibration input distributions lead to different output distributions. To ensure that the calibration data can closely emulate the distribution seen at test time, it is therefore crucial to use training-set data as opposed to randomly generated data during calibration. It is noted that when performing MVM on multiple cores in parallel, those shared bias voltages cannot be optimized for each core separately, which might lead to sub-optimal operating conditions and additional accuracy loss (detailed in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>).</p><p>Stochastic non-idealities such as RRAM conductance relaxation and read noises degrade the signal-to-noise ratio (SNR) of the computation, leading to an inference accuracy drop. Some previous work obtained a higher SNR by limiting each RRAM cell to store a single bit, and encoding higher-precision weights using multiple cells<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 9" title="Hung, J. M. et al. A four-megabit compute-in-memory macro with eight-bit precision based on CMOS and resistive random-access memory for AI edge devices. Nat. Electron. 4, 921–930 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR9" id="ref-link-section-d163879637e1248">9</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 10" title="Xue, C. X. et al. A 1Mb multibit ReRAM computing-in-memory macro with 14.6ns parallel MAC computing time for CNN based AI edge processors. In IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers 388–390 (IEEE, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR10" id="ref-link-section-d163879637e1251">10</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 16" title="Xue, C. X. et al. A CMOS-integrated compute-in-memory macro based on resistive random-access memory for AI edge devices. Nat. Electron. 4, 81–90 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR16" id="ref-link-section-d163879637e1254">16</a></sup>. Such an approach lowers the weight memory density. Accompanying that approach, the neural network is trained with weights quantized to the corresponding precision. In contrast, we utilize the intrinsic analogue programmability of RRAM<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 42" title="Alibart, F., Gao, L., Hoskins, B. D. &amp; Strukov, D. B. High precision tuning of state for memristive devices by adaptable variation-tolerant algorithm. Nanotechnology 23, 762–775 (2012)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR42" id="ref-link-section-d163879637e1258">42</a></sup> to directly store high-precision weights and train the neural networks to tolerate the lower SNR. Instead of training with quantized weights, which is equivalent to injecting uniform noise into weights, we train the model with high-precision weights while injecting noise with the distribution measured from RRAM devices. RRAMs on NeuRRAM are characterized to have a Gaussian-distributed conductance spread, caused primarily by conductance relaxation. Therefore, we inject a Gaussian noise into weights during training, similar to a previous study<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 21" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR21" id="ref-link-section-d163879637e1262">21</a></sup>. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig5">5a</a> shows that the technique significantly improves the model’s immunity to noise, from a CIFAR-10 classification accuracy of 25.34% without noise injection to 85.99% with noise injection. After the training, we program the non-quantized weights to RRAM analogue conductances using an iterative write–verify technique, described in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>. This technique enables NeuRRAM to achieve an inference accuracy equivalent to models trained with 4-bit weights across various applications, while encoding each weight using only two RRAM cells, which is two-times denser than previous studies that require one RRAM cell per bit.</p><p>By applying the above two techniques, we already can measure inference accuracy comparable to or better than software models with 4-bit weights on Google speech command recognition, MNIST image recovery and MNIST classification (Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig1">1e</a>). For deeper neural networks, we found that the error caused by those non-idealities that have nonlinear effects on MVM outputs, such as voltage drops, can accumulate through layers, and become more difficult to mitigate. In addition, multi-core parallel MVM leads to large instantaneous current, further exacerbating non-idealities such as voltage drop on input wires ((1) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig4">4a</a>). As a result, when performing multi-core parallel inference on a deep CNN, ResNet-20<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 43" title="He, K., Zhang, X., Ren, S. &amp; Sun, J. Deep residual learning for image recognition. In Proc. IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR) 770–778 (IEEE, 2016)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR43" id="ref-link-section-d163879637e1281">43</a></sup>, the measured accuracy on CIFAR-10 classification (83.67%) is still 3.36% lower than that of a 4-bit-weight software model (87.03%).</p><p>To bridge this accuracy gap, we introduce a chip-in-the-loop progressive fine-tuning technique. Chip-in-the-loop training mitigates the impact of non-idealities by measuring training error directly on the chip<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 44" title="Cauwenberghs, G. &amp; Bayoumi, M. A. Learning on Silicon—Adaptive VLSI Neural Systems (Kluwer Academic, 1999)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR44" id="ref-link-section-d163879637e1289">44</a></sup>. Previous work has shown that fine-tuning the final layers using the back-propagated gradients calculated from hardware-measured outputs helped improve accuracy<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 5" title="Yao, P. et al. Fully hardware-implemented memristor convolutional neural network. Nature 577, 641–646 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR5" id="ref-link-section-d163879637e1293">5</a></sup>. We find this technique to be of limited effectiveness in countering those nonlinear non-idealities. Such a technique also requires re-programming RRAM devices, which consumes additional energy. Our chip-in-the-loop progressive fine-tuning overcomes nonlinear model errors by exploiting the intrinsic nonlinear universal approximation capacity of the deep neural network<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 45" title="Hornik, K., Stinchcombe, M. &amp; White, H. Multilayer feedforward networks are universal approximators. Neural Netw. 2, 359–366 (1989)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR45" id="ref-link-section-d163879637e1297">45</a></sup>, and furthermore eliminates the need for weight re-programming. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig4">4d</a> illustrates the fine-tuning procedure. We progressively program the weights one layer at a time onto the chip. After programming a layer, we perform inference using the training-set data on the chip up to that layer, and use the measured outputs to fine-tune the remaining layers that are still training in software. In the next time step, we program and measure the next layer on the chip. We repeat this process until all the layers are programmed. During the process, the non-idealities of the programmed layers can be progressively compensated by the remaining layers through training. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig5">5b</a> shows the efficacy of this progressive fine-tuning technique. From left to right, each data point represents a new layer programmed onto the chip. The accuracy at each layer is evaluated by using the chip-measured outputs from that layer as inputs to the remaining layers in software. The cumulative CIFAR-10 test-set inference accuracy is improved by 1.99% using this technique. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig13">8a</a> further illustrates the extent to which fine-tuning recovers the training-set accuracy loss at each layer, demonstrating the effectiveness of the approach in bridging the accuracy gap between software and hardware measurements.</p><p>Using the techniques described above, we achieve inference accuracy comparable to software models trained with 4-bit weights across all the measured AI benchmark tasks. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig1">1e</a> shows that we achieve a 0.98% error rate on MNIST handwritten digit recognition using a 7-layer CNN, a 14.34% error rate on CIFAR-10 object classification using ResNet-20, a 15.34% error rate on Google speech command recognition using a 4-cell LSTM, and a 70% reduction of L2 image-reconstruction error compared with the original noisy images on MNIST image recovery using an RBM. Some of these numbers are not yet to the accuracies achieved by full-precision digital implementations. The accuracy gap mainly comes from low-precision (≤4-bit) quantization of inputs and activations, especially on the most sensitive input and output layers<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 46" title="Choi, J. et al. PACT: parameterized clipping activation for quantized neural networks. Preprint at 
                  https://arxiv.org/abs/1805.06085
                  
                 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR46" id="ref-link-section-d163879637e1317">46</a></sup>. For instance, Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig13">8b</a> presents an ablation study that shows that quantizing input images to 4-bit alone results in a 2.7% accuracy drop for CIFAR-10 classification. By contrast, the input layer only accounts for 1.08% of compute and 0.16% of weights of a ResNet-20 model. Therefore, they can be off-loaded to higher-precision digital compute units with little overheads. In addition, applying more advanced quantization techniques and optimizing training procedures such as data augmentation and regularization should further improve the accuracy for both quantized software models and hardware-measured results.</p><p>Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Tab1">1</a> summarizes the key features of each demonstrated model. Most of the essential neural-network layers and operations are implemented on the chip, including all the convolutional, fully connected and recurrent layers, neuron activation functions, batch normalization and the stochastic sampling process. Other operations such as average pooling and element-wise multiplications are implemented on an FPGA integrated on the same board as NeuRRAM (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig16">11a</a>). Each of the models is implemented by allocating the weights to multiple cores on a single NeuRRAM chip. We developed a software toolchain to allow easy deployment of AI models on the chip<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 47" title="Wan, W. weierwan/Neurram_48core: Initial Release (Version 1.0) [Computer software]. Zenodo 
                  https://doi.org/10.5281/zenodo.6558399
                  
                 (2022)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR47" id="ref-link-section-d163879637e1333">47</a></sup>. The implementation details are described in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>. Fundamentally, each of the selected benchmarks represents a general class of common edge AI tasks: visual recognition, speech processing and image de-noising. These results demonstrate the versatility of the TNSA architecture and the wide applicability of the hardware-algorithm co-optimization techniques.</p><div data-test="inline-table" data-container-section="table" id="table-1"><figure><figcaption><b id="Tab1" data-test="table-caption">Table 1 Summary of AI applications and models demonstrated on NeuRRAM</b></figcaption></figure></div><p>The NeuRRAM chip simultaneously improves efficiency, flexibility and accuracy over existing RRAM-CIM hardware by innovating across the entire hierarchy of the design, from a TNSA architecture enabling reconfigurable dataflow direction, to an energy- and area-efficient voltage-mode neuron circuit, and to a series of algorithm-hardware co-optimization techniques. These techniques can be more generally applied to other non-volatile resistive memory technologies such as phase-change memory<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 8" title="Khaddam-Aljameh, R. et al. HERMES core-A 14nm CMOS and PCM-based in-memory compute core using an array of 300ps/LSB linearized CCO-based ADCs and local digital processing. In IEEE Symposium on VLSI Circuits, Digest of Technical Papers JFS2-5 (IEEE, 2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR8" id="ref-link-section-d163879637e1623">8</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 17" title="Narayanan, P. et al. Fully on-chip MAC at 14 nm enabled by accurate row-wise programming of PCM-based weights and parallel vector-transport in duration-format. IEEE Trans. Electron Devices 68, 6629–6636 (2021)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR17" id="ref-link-section-d163879637e1626">17</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 21" title="Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. Nat. Commun. 11, 2473 (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR21" id="ref-link-section-d163879637e1629">21</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 23" title="Eryilmaz, S. B. et al. Experimental demonstration of array-level learning with phase change synaptic devices. In International Electron Devices Meeting (IEDM), Technical Digest 25.5.1–25.5.4 (IEEE, 2013)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR23" id="ref-link-section-d163879637e1632">23</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 24" title="Burr, G. W. et al. Experimental demonstration and tolerancing of a large-scale neural network (165 000 synapses) using phase-change memory as the synaptic weight element. IEEE Trans. Electron Devices 62, 3498–3507 (2015)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR24" id="ref-link-section-d163879637e1635">24</a></sup>, magnetoresistive RAM<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 48" title="Jung, S. et al. A crossbar array of magnetoresistive memory devices for in-memory computing. Nature 601, 211–216 (2022)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR48" id="ref-link-section-d163879637e1639">48</a></sup> and ferroelectric field-effect transistors<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 49" title="Jerry, M. et al. Ferroelectric FET analog synapse for acceleration of deep neural network training. In International Electron Devices Meeting (IEDM), Technical Digest 6.2.1–6.2.4 (IEEE, 2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR49" id="ref-link-section-d163879637e1643">49</a></sup>. Going forwards, we expect NeuRRAM’s peak energy efficiency (EDP) to improve by another two to three orders of magnitude while supporting bigger AI models when scaling from 130-nm to 7-nm CMOS and RRAM technologies (detailed in <a data-track="click" data-track-label="link" data-track-action="section anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Sec5">Methods</a>). Multi-core architecture design with network-on-chip that realizes efficient and versatile data transfers and inter-array pipelining is likely to be the next major challenge for RRAM-CIM<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 37" title="Shafiee, A. et al. ISAAC: a convolutional neural network accelerator with in-situ analog arithmetic in crossbars. In Proc. 2016 43rd International Symposium on Computer Architecture (ISCA) 14-26 (IEEE/ACM, 2016)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR37" id="ref-link-section-d163879637e1650">37</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 38" title="Ankit, A. et al. PUMA: a programmable ultra-efficient memristor-based accelerator for machine learning inference. In International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) 715–731 (ACM, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR38" id="ref-link-section-d163879637e1653">38</a></sup>, which needs to be addressed by further cross-layer co-optimization. As resistive memory continues to scale towards offering tera-bits of on-chip memory<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 50" title="Jiang, Z. et al. Next-generation ultrahigh-density 3-D vertical resistive switching memory (VRSM)–Part II: design guidelines for device, array, and architecture. IEEE Trans. Electron Devices 66, 5147–5154 (2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR50" id="ref-link-section-d163879637e1658">50</a></sup>, such a co-optimization approach will equip CIM hardware on the edge with sufficient performance, efficiency and versatility to perform complex AI tasks that can only be done on the cloud today.</p></div></div></section><section data-title="Methods"><div id="Sec5-section"><h2 id="Sec5">Methods</h2><div id="Sec5-content"><h3 id="Sec6">Core block diagram and operating modes</h3><p>Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2d</a> and Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig6">1</a> show the block diagram of a single CIM core. To support versatile MVM directions, most of the design is symmetrical in the row (BLs and WLs) and column (SLs) directions. The row and column register files store the inputs and outputs of MVMs, and can be written externally by either an Serial Peripheral Interface (SPI) or a random-access interface that uses an 8-bit address decoder to select one register entry, or internally by the neurons. The SL peripheral circuits contain an LFSR block used to generate pseudo-random sequences used for probabilistic sampling. It is implemented by two LFSR chains propagating in opposite directions. The registers of the two chains are XORed to generate spatially uncorrelated random numbers<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 51" title="Cauwenberghs, G. An analog VLSI recurrent neural network learning a continuous-time trajectory. IEEE Trans. Neural Netw. 7, 346–361 (1996)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR51" id="ref-link-section-d163879637e1680">51</a></sup>. The controller block receives commands and generates control waveforms to the BL/WL/SL peripheral logic and to the neurons. It contains a delay-line-based pulse generator with tunable pulse width from 1 ns to 10 ns. It also implements clock-gating and power-gating logic used to turn off the core in idle mode. Each WL, BL and SL of the TNSA is driven by a driver consisting of multiple pass gates that supply different voltages. On the basis of the values stored in the register files and the control signals issued by the controller, the WL/BL/SL logic decides the state of each pass gate.</p><p>The core has three main operating modes: a weight-programming mode, a neuron-testing mode and an MVM mode (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig6">1</a>). In the weight-programming mode, individual RRAM cells are selected for read and write. To select a single cell, the registers at the corresponding row and column are programmed to ‘1’ through random access with the help of the row and column decoder, whereas the other registers are reset to ‘0’. The WL/BL/SL logic turns on the corresponding driver pass gates to apply a set/reset/read voltage on the selected cell. In the neuron-testing mode, the WLs are kept at ground voltage (GND). Neurons receive inputs directly from BL or SL drivers through their BL or SL switch, bypassing RRAM devices. This allows us to characterize the neurons independently from the RRAM array. In the MVM mode, each input BL and SL is driven to <i>V</i><sub>ref</sub> − <i>V</i><sub>read</sub>, <i>V</i><sub>ref</sub> + <i>V</i><sub>read</sub> or <i>V</i><sub>ref</sub> depending on the registers’ value at that row or column. If the MVM is in the BL-to-SL direction, we activate the WLs that are within the input vector length while keeping the rest at GND; if the MVM is in the SL-to-BL direction, we activate all the WLs. After neurons finish analogue-to-digital conversion, the pass gates from BLs and SLs to the registers are turned on to allow neuron-state readout.</p><h3 id="Sec7">Device fabrication</h3><p>RRAM arrays in NeuRRAM are in a one-transistor–one-resistor (1T1R) configuration, where each RRAM device is stacked on top of and connects in series with a selector NMOS transistor that cuts off the sneak path and provides current compliance during RRAM programming and reading. The selector n-type metal-oxide-semiconductor (NMOS), CMOS peripheral circuits and the bottom four back-end-of-line interconnect metal layers are fabricated in a standard 130-nm foundry process. Owing to the higher voltage required for RRAM forming and programming, the selector NMOS and the peripheral circuits that directly interface with RRAM arrays use thick-oxide input/output (I/O) transistors rated for 5-V operation. All the other CMOS circuits in neurons, digital logic, registers and so on use core transistors rated for 1.8-V operations.</p><p>The RRAM device is sandwiched between metal-4 and metal-5 layers shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2c</a>. After the foundry completes the fabrication of CMOS and the bottom four metal layers, we use a laboratory process to finish the fabrication of the RRAM devices and the metal-5 interconnect, and the top metal pad and passivation layers. The RRAM device stack consists of a titanium nitride (TiN) bottom-electrode layer, a hafnium oxide (HfO<sub><i>x</i></sub>) switching layer, a tantalum oxide (TaO<sub><i>x</i></sub>) thermal-enhancement layer<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 52" title="Wu, W. et al. A methodology to improve linearity of analog RRAM for neuromorphic computing. In Symposium on VLSI Technology, Digest of Technical Papers 103–104 (IEEE, 2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR52" id="ref-link-section-d163879637e1733">52</a></sup> and a TiN top-electrode layer. They are deposited sequentially, followed by a lithography step to pattern the lateral structure of the device array.</p><h3 id="Sec8">RRAM write–verify programming and conductance relaxation</h3><p>Each neural-network weight is encoded by the differential conductance between two RRAM cells on adjacent rows along the same column. The first RRAM cell encodes positive weight, and is programmed to a low conductance state (<i>g</i><sub>min</sub>) if the weight is negative; the second cell encodes negative weight, and is programmed to <i>g</i><sub>min</sub> if the weight is positive. Mathematically, the conductances of the two cells are <span>\({\rm{\max }}({g}_{{\rm{\max }}}\frac{W}{{w}_{{\rm{\max }}}},{g}_{{\rm{\min }}})\)</span> and <span>\({\rm{\max }}(-{g}_{{\rm{\max }}}\frac{W}{{w}_{{\rm{\max }}}},{g}_{{\rm{\min }}})\)</span> respectively, where <i>g</i><sub>max</sub> and <i>g</i><sub>min</sub> are the maximum and minimum conductance of the RRAMs, <i>w</i><sub>max</sub> is the maximum absolute value of weights, and <i>W</i> is the unquantized high-precision weight.</p><p>To program an RRAM cell to its target conductance, we use an incremental-pulse write–verify technique<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 42" title="Alibart, F., Gao, L., Hoskins, B. D. &amp; Strukov, D. B. High precision tuning of state for memristive devices by adaptable variation-tolerant algorithm. Nanotechnology 23, 762–775 (2012)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR42" id="ref-link-section-d163879637e1936">42</a></sup>. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig8">3a,b</a> illustrates the procedure. We start by measuring the initial conductance of the cell. If the value is below the target conductance, we apply a weak set pulse aiming to slightly increase the cell conductance. Then we read the cell again. If the value is still below the target, we apply another set pulse with amplitude incremented by a small amount. We repeat such set–read cycles until the cell conductance is within an acceptance range to the target value or overshoots to the other side of the target. In the latter case, we reverse the pulse polarity to reset, and repeat the same procedure as with set. During the set/reset pulse train, the cell conductance is likely to bounce up and down multiple times until eventually it enters the acceptance range or reaches a time-out limit.</p><p>There are a few trade-offs in selecting programming conditions. (1) A smaller acceptance range and a higher time-out limit improve programming precision, but require a longer time. (2) A higher <i>g</i><sub>max</sub> improves the SNR during inference, but leads to higher energy consumption and more programming failures for cells that cannot reach high conductance. In our experiments, we set the initial set pulse voltage to be 1.2 V and the reset pulse voltage to be 1.5 V, both with an increment of 0.1 V and pulse width of 1 μs. A RRAM read takes 1–10 μs, depending on its conductance. The acceptance range is ±1 μS to the target conductance. The time-out limit is 30 set–reset polarity reversals. We used <i>g</i><sub>min</sub> = 1 μS for all the models, and <i>g</i><sub>max</sub> = 40 μS for CNNs and <i>g</i><sub>max</sub> = 30 μS for LSTMs and RBMs. With such settings, 99% of the RRAM cells can be programmed to the acceptance range within the time-out limit. On average each cell requires 8.52 set/reset pulses. In the current implementation, the speed of such a write–verify process is limited by external control of DAC and ADC. If integrating everything into a single chip, such write–verify will take on average 56 µs per cell. Having multiple copies of DAC and ADC to perform write–verify on multiple cells in parallel will further improve RRAM programming throughput, at the cost of more chip area.</p><p>Besides the longer programming time, another reason to not use an overly small write–verify acceptance range is RRAM conductance relaxation. RRAM conductance changes over time after programming. Most of the change happens within a short time window (less than 1 s) immediately following the programming, after which the change becomes much slower, as shown in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig8">3d</a>. The abrupt initial change is called ‘conductance relaxation’ in the literature<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 41" title="Zhao, M. et al. Investigation of statistical retention of filamentary analog RRAM for neuromophic computing. In International Electron Devices Meeting (IEDM), Technical Digest 39.4.1–39.4.4 (IEEE, 2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR41" id="ref-link-section-d163879637e1969">41</a></sup>. Its statistics follow a Gaussian distribution at all conductance states except when the conductance is close to <i>g</i><sub>min</sub>. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig8">3c,d</a> shows the conductance relaxation measured across the whole <i>g</i><sub>min</sub>-to<i>-g</i><sub>max</sub> conductance range. We found that the loss of programming precision owing to conductance relaxation is much higher than that caused by the write–verify acceptance range. The average standard deviation across all levels of initial conductance is about 2.8 μS. The maximum standard deviation is about 4 μS, which is close to 10% of <i>g</i><sub>max</sub>.</p><p>To mitigate the relaxation, we use an iterative programming technique. We iterate over the RRAM array for multiple times. In each iteration, we measure all the cells and re-program those whose conductance has drifted outside the acceptance range. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig8">3e</a> shows that the standard deviation becomes smaller with more programming iterations. After 3 iterations, the standard deviation becomes about 2 μS, a 29% decrease compared with the initial value. We use 3 iterations in all our neural-network demonstrations and perform inference at least 30 min after the programming such that the measured inference accuracy would account for such conductance relaxation effects. By combining the iterative programming with our hardware-aware model training approach, the impact of relaxation can be largely mitigated.</p><h3 id="Sec9">Implementation of MVM with multi-bit inputs and outputs</h3><p>The neuron and the peripheral circuits support MVM at configurable input and output bit-precisions. An MVM operation consists of an initialization phase, an input phase and an output phase. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig9">4</a> illustrates the neuron circuit operation. During the initialization phase (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig9">4a</a>), all BLs and SLs are precharged to <i>V</i><sub>ref</sub>. The sampling capacitors <i>C</i><sub>sample</sub> of the neurons are also precharged to <i>V</i><sub>ref</sub>, whereas the integration capacitors <i>C</i><sub>integ</sub> are discharged.</p><p>During the input phase, each input wire (either BL or SL depending on MVM direction) is driven to one of three voltage levels, <i>V</i><sub>ref</sub> <i>−</i> <i>V</i><sub>read</sub>, <i>V</i><sub>ref</sub> and <i>V</i><sub>ref</sub> <i>+</i> <i>V</i><sub>read</sub>, through three pass gates, as shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3b</a>. During forwards MVM, under differential-row weight mapping, each input is applied to a pair of adjacent BLs. The two BLs are driven to the opposite voltage with respect to <i>V</i><sub>ref</sub>. That is, when the input is 0, both wires are driven to <i>V</i><sub>ref</sub>; when the input is +1, the two wires are driven to <i>V</i><sub>ref</sub> + <i>V</i><sub>read</sub> and <i>V</i><sub>ref</sub> <i>−</i> <i>V</i><sub>read</sub>; and when the input is <i>−</i>1, to <i>V</i><sub>ref</sub> <i>−</i> <i>V</i><sub>read</sub> and <i>V</i><sub>ref</sub> + <i>V</i><sub>read</sub>. During backwards MVM, each input is applied to a single SL. The difference operation is performed digitally after neurons finish analogue-to-digital conversions.</p><p>After biasing the input wires, we then pulse those WLs that have inputs for 10 ns, while keeping output wires floating. As voltages of the output wires settle to <span>\({V}_{j}=\frac{{\sum }_{i}{V}_{i}{G}_{{ij}}}{{\sum }_{i}{G}_{{ij}}}\)</span>, where <i>G</i><sub>ij</sub> represents conductance of RRAM at the <i>i-</i>th row and the <i>j-</i>th column, we turn off the WLs to stop all current flow. We then sample the charge remaining on the output wire parasitic capacitance to <i>C</i><sub>sample</sub> located within neurons, followed by integrating the charge onto <i>C</i><sub>integ</sub>, as shown in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig9">4b</a>. The sampling pulse is 10 ns (limited by the 100-MHz external clock from the FPGA); the integration pulse is 240 ns, limited by large integration capacitor (104 fF), which was chosen conservatively to ensure function correctness and testing different neuron operating conditions.</p><p>The multi-bit input digital-to-analogue conversion is performed in a bit-serial fashion. For the <i>n</i>th LSB, we apply a single pulse to the input wires, followed by sampling and integrating charge from output wires onto <i>C</i><sub>integ</sub> for 2<sup><i>n</i>−1</sup> cycles. At the end of multi-bit input phase, the complete analogue MVM output is stored as charge on <i>C</i><sub>integ</sub>. For example, as shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3e</a>, when the input vectors are 4-bit signed integers with 1 sign-bit and 3 magnitude-bits, we first send pulses corresponding to the first (least significant) magnitude-bit to input wires, followed by sampling and integrating for one cycle. For the second and the third magnitude-bits, we again apply one pulse to input wires for each bit, followed by sampling and integrating for two cycles and four cycles, respectively. In general, for <i>n</i>-bit signed integer inputs, we need a total of <i>n</i> − 1 input pulses and 2<sup><i>n</i>−1</sup> − 1 sampling and integration cycles.</p><p>Such a multi-bit input scheme becomes inefficient for high-input bit-precision owing to the exponentially increasing sampling and integration cycles. Moreover, headroom clipping becomes an issue as charge integrated at <i>C</i><sub>integ</sub> saturates with more integration cycles. The headroom clipping can be overcome by using lower <i>V</i><sub>read</sub>, but at the cost of a lower SNR, so the overall MVM accuracy might not improve when using higher-precision inputs. For instance, Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig10">5a,c</a> shows the measured root-mean-square error (r.m.s.e.) of the MVM results. Quantizing inputs to 6-bit (r.m.s.e. = 0.581) does not improve the MVM accuracy compared with 4-bit (r.m.s.e. = 0.582), owing to the lower SNR.</p><p>To solve both the issues, we use a 2-phase input scheme for input greater than 4-bits. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3f</a> illustrates the process. To perform MVM with 6-bit inputs and 8-bit outputs, we divide inputs into two segments, the first containing the three MSBs and the second containing the three LSBs. We then perform MVM including the output analogue-to-digital conversion for each segment separately. For the MSBs, neurons (ADCs) are configured to output 8-bits; for the LSBs, neurons output 5-bits. The final results are obtained by shifting and adding the two outputs in digital domain. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig10">5d</a> shows that the scheme lowers MVM r.m.s.e. from 0.581 to 0.519. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12c–e</a> further shows that such a two-phase scheme both extends the input bit-precision range and improves the energy efficiency.</p><p>Finally, during the output phase, the analogue-to-digital conversion is again performed in a bit-serial fashion through a binary search process. First, to generate the sign-bit of outputs, we disconnect the feedback loop of the amplifier to turn the integrator into a comparator (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig9">4c</a>). We drive the right side of <i>C</i><sub>integ</sub> to <i>V</i><sub>ref</sub>. If the integrated charge is positive, the comparator output will be GND, and supply voltage VDD otherwise. The comparator output is then inverted, latched and readout to the BL or SL via the neuron BL or SL switch before being written into the peripheral BL or SL registers.</p><p>To generate <i>k</i> magnitude-bits, we add or subtract charge from <i>C</i><sub>integ</sub> (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig9">4d</a>), followed by comparison and readout for <i>k</i> cycles. From MSB to LSB, the amount of charge added or subtracted is halved every cycle. Whether to add or to subtract is automatically determined by the comparison result stored in the latch from the previous cycle. Figure <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig3">3g</a> illustrates such a process. A sign-bit of ‘1’ is first generated and latched in the first cycle, representing a positive output. To generate the most significant magnitude-bit, the latch turns on the path from <i>V</i><sub>decr−</sub> = <i>V</i><sub>ref</sub> − <i>V</i><sub>decr</sub> to <i>C</i><sub>sample</sub>. The charge sampled by <i>C</i><sub>sample</sub> is then integrated on <i>C</i><sub>integ</sub> by turning on the negative feedback loop of the amplifier, resulting in <i>C</i><sub>sample</sub><i>V</i><sub>decr</sub> amount of charge being subtracted from <i>C</i><sub>integ</sub>. In this example, <i>C</i><sub>sample</sub><i>V</i><sub>decr</sub> is greater than the original amount of charge on <i>C</i><sub>integ</sub>, so the total charge becomes negative, and the comparator generates a ‘0’ output. To generate the second magnitude-bit, <i>V</i><sub>decr</sub> is reduced by half. This time, the latch turns on the path from <i>V</i><sub>decr+</sub> = <i>V</i><sub>ref</sub> + 1/2<i>V</i><sub>decr</sub> to <i>C</i><sub>sample</sub>. As the total charge on <i>C</i><sub>integ</sub> after integration is still negative, the comparator outputs a ‘0’ again in this cycle. We repeat this process until the least significant magnitude-bit is generated. It is noted that if the initial sign-bit is ‘0’, all subsequent magnitude-bits are inverted before readout.</p><p>Such an output conversion scheme is similar to an algorithmic ADC or a SAR ADC in the sense that a binary search is performed for <i>n</i> cycles for a <i>n</i>-bit output. The difference is that an algorithmic ADC uses a residue amplifier, and a SAR ADC requires a multi-bit DAC for each ADC, whereas our scheme does not need a residue amplifier, and uses a single DAC that outputs 2 × (<i>n</i> − 1) different <i>V</i><sub>decr+</sub> and <i>V</i><sub>decr−</sub> levels, shared by all neurons (ADCs). As a result, our scheme enables a more compact design by time-multiplexing an amplifier for integration and comparison, eliminating the residual amplifier, and amortizing the DAC area across all neurons in a CIM core. For CIM designs that use a dense memory array, such a compact design allows each ADC to be time-multiplexed by a fewer number of rows and columns, thus improving throughput.</p><p>To summarize, both the configurable MVM input and output bit-precisions and various neuron activation functions are implemented using different combinations of the four basic operations: sampling, integration, comparison and charge decrement. Importantly, all the four operations are realized by a single amplifier configured in different feedback modes. As a result, the design realizes versatility and compactness at the same time.</p><h3 id="Sec10">Multi-core parallel MVM</h3><p>NeuRRAM supports performing MVMs in parallel on multiple CIM cores. Multi-core MVM brings additional challenges to computational accuracy, because certain hardware non-idealities that do not manifest in single-core MVM become more severe with more cores. They include voltage drop on input wires, core-to-core variation and supply voltage instability. voltage drop on input wires (non-ideality (1) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig4">4a</a>) is caused by large current drawn from a shared voltage source simultaneously by multiple cores. It makes equivalent weights stored in each core vary with applied inputs, and therefore have a nonlinear input-dependent effect on MVM outputs. Moreover, as different cores have a different distance from the shared voltage source, they experience a different amounts of voltage drops. Therefore, we cannot optimize read-voltage amplitude separately for each core to make its MVM output occupy exactly the full neuron input dynamic range.</p><p>These non-idealities together degrade the multi-core MVM accuracy. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig10">5e,f</a> shows that when performing convolution in parallel on the 3 cores, outputs of convolutional layer 15 are measured to have a higher r.m.s.e. of 0.383 compared with 0.318 obtained by performing convolution sequentially on the 3 cores. In our ResNet-20 experiment, we performed 2-core parallel MVMs for convolutions within block 1 (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9a</a>), and 3-core parallel MVMs for convolutions within blocks 2 and 3.</p><p>The voltage-drop issue can be partially alleviated by making the wires that carry large instantaneous current as low resistance as possible, and by employing a power delivery network with more optimized topology. But the issue will persist and become worse as more cores are used. Therefore, our experiments aim to study the efficacy of algorithm-hardware co-optimization techniques in mitigating the issue. Also, it is noted that for a full-chip implementation, additional modules such as intermediate result buffers, partial-sum accumulators and network-on-chip will need to be integrated to manage inter-core data transfers. Program scheduling should also be carefully optimized to minimize buffer size and energy spent at intermediate data movement. Although there are studies on such full-chip architecture and scheduling<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 37" title="Shafiee, A. et al. ISAAC: a convolutional neural network accelerator with in-situ analog arithmetic in crossbars. In Proc. 2016 43rd International Symposium on Computer Architecture (ISCA) 14-26 (IEEE/ACM, 2016)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR37" id="ref-link-section-d163879637e2469">37</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 38" title="Ankit, A. et al. PUMA: a programmable ultra-efficient memristor-based accelerator for machine learning inference. In International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) 715–731 (ACM, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR38" id="ref-link-section-d163879637e2472">38</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 53" title="Ji, Y. et al. FPSA: a full system stack solution for reconfigurable ReRAM-based NN accelerator architecture. In International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS) 733–747 (ACM, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR53" id="ref-link-section-d163879637e2475">53</a></sup>, they are outside the scope of this study.</p><h3 id="Sec11">Noise-resilient neural-network training</h3><p>During noise-resilient neural-network training, we inject noise into weights of all fully connected and convolutional layers during the forwards pass of neural-network training to emulate the effects of RRAM conductance relaxation and read noises. The distribution of the injected noise is obtained by RRAM characterization. We used the iterative write–verify technique to program RRAM cells into different initial conductance states and measure their conductance relaxation after 30 min. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig8">3d</a> shows that measured conductance relaxation has an absolute value of mean &lt;1 μS (<i>g</i><sub>min</sub>) at all conductance states. The highest standard deviation is 3.87 μS, about 10% of the <i>g</i><sub>max</sub> 40 μS, found at about 12 μS initial conductance state. Therefore, to simulate such conductance relaxation behaviour during inference, we inject a Gaussian noise with a zero mean and a standard deviation equal to 10% of the maximum weights of a layer.</p><p>We train models with different levels of noise injection from 0% to 40%, and select the model that achieves the highest inference accuracy at 10% noise level for on-chip deployment. We find that injecting a higher noise during training than testing improves models’ noise resiliency. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig12">7a–c</a> shows that the best test-time accuracy in the presence of 10% weight noise is obtained with 20% training-time noise injection for CIFAR-10 image classification, 15% for Google voice command classification and 35% for RBM-based image reconstruction.</p><p>For CIFAR-10, the better initial accuracy obtained by the model trained with 5% noise is most likely due to the regularization effect of noise injection. A similar phenomenon has been reported in neural-network quantization literature where a model trained with quantization occasionally outperforms a full-precision model<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 54" title="Esser, S. K., Mckinstry, J. L., Bablani, D., Appuswamy, R. &amp; Modha, D. S. Learned step size quantization. In International Conference on Learning Representations (ICLR) (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR54" id="ref-link-section-d163879637e2507">54</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 55" title="Jung, S. et al. Learning to quantize deep networks by optimizing quantization intervals with task loss. In IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR) 4345–4354 (IEEE/CVF, 2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR55" id="ref-link-section-d163879637e2510">55</a></sup>. In our experiments, we did not apply additional regularization on top of noise injection for models trained without noise, which might result in sub-optimal accuracy.</p><p>For RBM, Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig12">7d</a> further shows how reconstruction errors reduce with the number of Gibbs sampling steps for models trained with different noises. In general, models trained with higher noises converge faster during inference. The model trained with 20% noise reaches the lowest error at the end of 100 Gibbs sampling steps.</p><p>Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig12">7e</a> shows the effect of noise injection on weight distribution. Without noise injection, the weights have a Gaussian distribution. The neural-network outputs heavily depend on a small fraction of large weights, and thus become vulnerable to noise injection. With noise injection, the weights distribute more uniformly, making the model more noise resilient.</p><p>To efficiently implement the models on NeuRRAM, inputs to all convolutional and fully connected layers are quantized to 4-bit or below. The input bit-precisions of all the models are summarized in Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Tab1">1</a>. We perform the quantized training using the parameterized clipping activation technique<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 46" title="Choi, J. et al. PACT: parameterized clipping activation for quantized neural networks. Preprint at 
                  https://arxiv.org/abs/1805.06085
                  
                 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR46" id="ref-link-section-d163879637e2533">46</a></sup>. The accuracies of some of our quantized models are lower than that of the state-of-the-art quantized model because we apply &lt;4-bit quantization to the most sensitive input and output layers of the neural networks, which have been reported to cause large accuracy degradation and are thus often excluded from low-precision quantization<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 46" title="Choi, J. et al. PACT: parameterized clipping activation for quantized neural networks. Preprint at 
                  https://arxiv.org/abs/1805.06085
                  
                 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR46" id="ref-link-section-d163879637e2537">46</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 54" title="Esser, S. K., Mckinstry, J. L., Bablani, D., Appuswamy, R. &amp; Modha, D. S. Learned step size quantization. In International Conference on Learning Representations (ICLR) (2020)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR54" id="ref-link-section-d163879637e2540">54</a></sup>. To obtain better accuracy for quantized models, one can use higher precision for sensitive input and output layers, apply more advanced quantization techniques, and use more optimized data preprocessing, data augmentation and regularization techniques during training. However, the focus of this work is to achieve comparable inference accuracy on hardware and on software while keeping all these variables the same, rather than to obtain state-of-the-art inference accuracy on all the tasks. The aforementioned quantization and training techniques will be equally beneficial for both our software baselines and hardware measurements.</p><h3 id="Sec12">Chip-in-the-loop progressive fine-tuning</h3><p>During the progressive chip-in-the-loop fine-tuning, we use the chip-measured intermediate outputs from a layer to fine-tune the weights of the remaining layers. Importantly, to fairly evaluate the efficacy of the technique, we do not use the test-set data (for either training or selecting checkpoint) during the entire process of fine-tuning. To avoid over-fitting to a small fraction of data, measurements should be performed on the entire training-set data. We reduce the learning rate to 1/100 of the initial learning rate used for training the baseline model, and fine-tune for 30 epochs, although we observed that the accuracy generally plateaus within the first 10 epochs. The same weight noise injection and input quantization are applied during the fine-tuning.</p><h3 id="Sec13">Implementations of CNNs, LSTMs and RBMs</h3><p>We use CNN models for the CIFAR-10 and MNIST image classification tasks. The CIFAR-10 dataset consists of 50,000 training images and 10,000 testing images belonging to 10 object classes. We perform image classification using the ResNet-20<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 43" title="He, K., Zhang, X., Ren, S. &amp; Sun, J. Deep residual learning for image recognition. In Proc. IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR) 770–778 (IEEE, 2016)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR43" id="ref-link-section-d163879637e2560">43</a></sup>, which contains 21 convolutional layers and 1 fully connected layer (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9a</a>), with batch normalizations and ReLU activations between the layers. The model is trained using the Keras framework. We quantize the input of all convolutional and fully connected layers to a 3-bit unsigned fixed-point format except for the first convolutional layer, where we quantize the input image to 4-bit because the inference accuracy is more sensitive to the input quantization. For the MNIST handwritten digits classification, we use a seven-layer CNN consisting of six convolutional layers and one fully connected layer, and use max-pooling between layers to down-sample feature map sizes. The inputs to all the layers, including the input image, are quantized to a 3-bit unsigned fixed-point format.</p><p>All the parameters of the CNNs are implemented on a single NeuRRAM chip including those of the convolutional layers, the fully connected layers and the batch normalization. Other operations such as partial-sum accumulation and average pooling are implemented on an FPGA integrated on the same board as the NeuRRAM. These operations amount to only a small fraction of the total computation and integrating their implementation in digital CMOS would incur negligible overhead; the FPGA implementation was chosen to provide greater flexibility during test and development.</p><p>Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9a–c</a> illustrates the process to map a convolutional layer on a chip. To implement the weights of a four-dimensional convolutional layer with dimension <i>H</i> (height), <i>W</i> (width), <i>I</i> (number of input channels), <i>O</i> (number of output channels) on two-dimensional RRAM arrays, we flatten the first three dimensions into a one-dimensional vector, and append the bias term of each output channel to each vector. If the range of the bias values is <i>B</i> times of the weight range, we evenly divide the bias values and implement them using <i>B</i> rows. Furthermore, we merge the batch normalization parameters into convolutional weights and biases after training (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9b</a>), and program the merged <i>W</i>ʹ and <i>b</i>ʹ onto RRAM arrays such that no explicit batch normalization needs to be performed during inference.</p><p>Under the differential-row weight-mapping scheme, the parameters of a convolutional layer are converted into a conductance matrix of size (2(<i>HWI</i> + <i>B</i>), <i>O</i>). If the conductance matrix fits into a single core, an input vector is applied to 2(<i>HWI</i> + <i>B</i>) rows and broadcast to <i>O</i> columns in a single cycle. <i>HWIO</i> multiply–accumulate (MAC) operations are performed in parallel. Most ResNet-20 convolutional layers have a conductance matrix height of 2(<i>HWI</i> + <i>B</i>) that is greater than the RRAM array length of 256. We therefore split them vertically into multiple segments, and map the segments either onto different cores that are accessed in parallel, or onto different columns within a core that are accessed sequentially. The details of the weight-mapping strategies are described in the next section.</p><p>The Google speech command dataset consists of 65,000 1-s-long audio recordings of voice commands, such as ‘yes’, ‘up’, ‘on’, ‘stop’ and so on, spoken by thousands of different people. The commands are categorized into 12 classes. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9d</a> illustrates the model architecture. We use the Mel-frequency cepstral coefficient encoding approach to encode every 40-ms piece of audio into a length-40 vector. With a hop length of 20 ms, we have a time series of 50 steps for each 1-s recording.</p><p>We build a model that contains four parallel LSTM cells. Each cell has a hidden state of length 112. The final classification is based on summation of outputs from the four cells. Compared with a single-cell model, the 4-cell model reduces the classification error (of an unquantized model) from 10.13% to 9.28% by leveraging additional cores on the NeuRRAM chip. Within a cell, in each time step, we compute the values of four LSTM gates (input, activation, forget and output) based on the inputs from the current step and hidden states from the previous step. We then perform element-wise operations between the four gates to compute the new hidden-state value. The final logit outputs are calculated based on the hidden states of the final time step.</p><p>Each LSTM cell has 3 weight matrices that are implemented on the chip: an input-to-hidden-state matrix with size 40 × 448, a hidden-state-to-hidden-state matrix with size 112 × 448 and a hidden-state-to-logits matrix with size 112 × 12. The element-wise operations are implemented on the FPGA. The model is trained using the PyTorch framework. The inputs to all the MVMs are quantized to 4-bit signed fixed-point formats. All the remaining operations are quantized to 8-bit.</p><p>An RBM is a type of generative probabilistic graphical model. Instead of being trained to perform discriminative tasks such as classification, it learns the statistical structure of the data itself. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9e</a> shows the architecture of our image-recovery RBM. The model consists of 794 fully connected visible neurons, corresponding to 784 image pixels plus 10 one-hot encoded class labels and 120 hidden neurons. We train the RBM using the contrastive divergence learning procedure in software.</p><p>During inference, we send 3-bit images with partially corrupted or blocked pixels to the model running on a NeuRRAM chip. The model then performs back-and-forth MVMs and Gibbs sampling between visible and hidden neurons for ten cycles. In each cycle, neurons sample binary states <i>h</i> and <i>v</i> from the MVM outputs based on the probability distributions: <span>\(p({h}_{j}=1| {\bf{v}})=\sigma ({b}_{j}+{\sum }_{i}{v}_{i}{w}_{ij})\)</span> and <span>\(p({h}_{j}=1| {\bf{v}})=\)</span> <span>\(\sigma ({b}_{j}+{\sum }_{i}{v}_{i}{w}_{ij})\)</span>, where <i>σ</i> is the sigmoid function, <i>a</i><sub><i>i</i></sub> is a bias for hidden neurons (<i>h</i>) and <i>b</i><sub><i>j</i></sub> is a bias for visible neurons (<i>v</i>). After sampling, we reset the uncorrupted pixels (visible neurons) to the original pixel values. The final inference performance is evaluated by computing the average L2-reconstruction error between the original image and the recovered image. Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig15">10</a> shows some examples of the measured image recovery.</p><p>When mapping the 794 × 120 weight matrix to multiple cores of the chip, we try to make the MVM output dynamic range of each core relatively consistent such that the recovery performance will not overly rely on the computational accuracy of any single core. To achieve this, we assign adjacent pixels (visible neurons) to different cores such that every core sees a down-sampled version of the whole image, as shown in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9f</a>). Utilizing the bidirectional MVM functionality of the TNSA, the visible-to-hidden neuron MVM is performed from the SL-to-BL direction in each core; the hidden-to-visible neuron MVM is performed from the BL-to-SL direction.</p><h3 id="Sec14">Weight-mapping strategy onto multiple CIM cores</h3><p>To implement an AI model on a NeuRRAM chip, we convert the weights, biases and other relevant parameters (for example, batch normalization) of each model layer into a single two-dimensional conductance matrix as described in the previous section. If the height or the width of a matrix exceed the RRAM array size of a single CIM core (256 × 256), we split the matrix into multiple smaller conductance matrices, each with maximum height and width of 256.</p><p>We consider three factors when mapping these conductance matrices onto the 48 cores: resource utilization, computational load balancing and voltage drop. The top priority is to ensure that all conductance matrices of a model are mapped onto a single chip such that no re-programming is needed during inference. If the total number of conductance matrices does not exceed 48, we can map each matrix onto a single core (case (1) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2a</a>) or multiple cores. There are two scenarios when we map a single matrix onto multiple cores. (1) When a model has different computational intensities, defined as the amount of computation per weights, for different layers, for example, CNNs often have higher computational intensity for earlier layers owing to larger feature map dimensions, we duplicate the more computationally intensive matrices to multiple cores and operate them in parallel to increase throughput and balance the computational loads across the layers (case (2) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2a</a>). (2) Some models have ‘wide’ conductance matrices (output dimension &gt;128), such as our image-recovery RBM. If mapping the entire matrix onto a single core, each input driver needs to supply large current for its connecting RRAMs, resulting in a significant voltage drop on the driver, deteriorating inference accuracy. Therefore, when there are spare cores, we can split the matrix vertically into multiple segments and map them onto different cores to mitigate the voltage drop (case (6) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2a</a>).</p><p>By contrast, if a model has more than 48 conductance matrices, we need to merge some matrices so that they can fit onto a single chip. The smaller matrices are merged diagonally such that they can be accessed in parallel (case (3) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2a</a>). The bigger matrices are merged horizontally and accessed by time-multiplexing input rows (case (4) in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig2">2a</a>). When selecting the matrices to merge, we want to avoid the matrices that belong to the same two categories described in the previous paragraph: (1) those that have high computational intensity (for example, early layers of ResNet-20) to minimize impact on throughput; and (2) those with ‘wide’ output dimension (for example, late layers of ResNet-20 have large number of output channels) to avoid a large voltage drop. For instance, in our ResNet-20 implementation, among a total of 61 conductance matrices (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig14">9a</a>: 1 from input layer, 12 from block 1, 17 from block 2, 28 from block 3, 2 from shortcut layers and 1 from final dense layer), we map each of the conductance matrices in blocks 1 and 3 onto a single core, and merge the remaining matrices to occupy the 8 remaining cores.</p><p>Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Tab1">1</a> summarizes core usage for all the models. It is noted that for partially occupied cores, unused RRAM cells are either unformed or programmed to high resistance state; WLs of unused rows are not activated during inference. Therefore, they do not consume additional energy during inference.</p><h3 id="Sec15">Test-system implementation</h3><p>Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig16">11a</a> shows the hardware test system for the NeuRRAM chip. The NeuRRAM chip is configured by, receives inputs from and sends outputs to a Xilinx Spartan-6 FPGA that sits on an Opal Kelly integrated FPGA board. The FPGA communicates with the PC via a USB 3.0 module. The test board also houses voltage DACs that provide various bias voltages required by RRAM programming and MVM, and ADCs to measure RRAM conductance during the write–verify programming. The power of the entire board is supplied by a standard ‘cannon style’ d.c. power connector and integrated switching regulators on the Opal Kelly board such that no external lab equipment is needed for the chip operation.</p><p>To enable fast implementation of various machine-learning applications on the NeuRRAM chip, we developed a software toolchain that provides Python-based application programming interfaces (APIs) at various levels. The low-level APIs provide access to basic operations of each chip module such as RRAM read and write and neuron analogue-to-digital conversion; the middle-level APIs include essential operations required for implementing neural-network layers such as the multi-core parallel MVMs with configurable bit-precision and RRAM write–verify programming; the high-level APIs integrate various middle-level modules to provide complete implementations of neural-network layers, such as weight mapping and batch inference of convolutional and fully connected layers. The software toolchain aims to allow software developers who are not familiar with the NeuRRAM chip design to deploy their machine-learning models on the NeuRRAM chip.</p><h3 id="Sec16">Power and throughput measurements</h3><p>To characterize MVM energy efficiency at various input and output bit-precisions, we measure the power consumption and latency of the MVM input and output stages separately. The total energy consumption and the total time are the sum of input and output stages because the two stages are performed independently as described in the above sections. As a result, we can easily obtain the energy efficiency of any combinations of input and output bit-precisions.</p><p>To measure the input-stage energy efficiency, we generate a 256 × 256 random weight matrix with Gaussian distribution, split it into 2 segments, each with dimension 128 × 256, and program the two segments to two cores using the differential-row weight mapping. We measure the power consumption and latency for performing 10 million MVMs, or equivalently 655 billion MAC operations. The comparison with previous work shown in Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig1">1d</a> uses the same workload as benchmark.</p><p>Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12a</a> shows the energy per operation consumed during the input and the output stages of MVMs under various bit-precisions. The inputs are in the signed integer format, where the first bit represents the sign, and the other bits represent the magnitude. One-bit (binary) and two-bit (ternary) show similar energy because each input wire is driven to one of three voltage levels. Binary input is therefore just a special case for ternary input. It is noted that the curve shown in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12a</a> is obtained without the two-phase operation. As a result, we see a super-linear increase of energy as input bit-precision increases. Similar to the inputs, the outputs are also represented in the signed integer format. The output-stage energy consumption grows linearly with output bit-precision because one additional binary search cycle is needed for every additional bit. The output stage consumes less energy than the input stage because it does not involve toggling highly capacitive WLs that are driven at a higher voltage, as we discuss below.</p><p>For the MVM measurements shown in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12b–e</a>, the MVM output stage is assumed to use 2-bit-higher precision than inputs to account for the additional bit-precision required for partial-sum accumulations. The required partial-sum bit-precision for the voltage-mode sensing implemented by NeuRRAM is much lower than that required by the conventional current-mode sensing. As explained before, conventional current-sensing designs can only activate a fraction of rows each cycle, and therefore need many partial-sum accumulation steps to complete an MVM. In contrast, the proposed voltage-sensing scheme can activate all the 256 input wires in a single cycle, and therefore requires less partial-sum accumulation steps and lower partial-sum precisions.</p><p>Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12b</a> shows the energy consumption breakdown. A large fraction of energy is spent in switching on and off the WLs that connect to gates of select transistors of RRAM devices. These transistors use thick-oxide I/O transistors to withstand high-voltage during RRAM forming and programming. They are sized large enough (width 1 µm and length 500 nm) to provide sufficient current for RRAM programming. As a result, they require high operating voltages and add large capacitance to the WLs, both contributing to high power consumption (<i>P</i> = <i>fCV</i><sup>2</sup>, where <i>f</i> is the frequency at which the capacitance is charged and discharged). Simulation shows that each of the 256 access transistors contributes about 1.5 fF to a WL; WL drivers combined contribute about 48 fF to each WL; additional WL capacitance is mostly from the inter-wire capacitance from neighbouring BLs and WLs. The WL energy is expected to decrease significantly if RRAMs can be written by a lower voltage and have a lower conductance state, and if a smaller transistor with better drivability can be used.</p><p>For applications that require probabilistic sampling, the two counter-propagating LFSR chains generate random Bernoulli noises and inject the noises as voltage pulses into neurons. We measure each noise-injection step to consume on average 121 fJ per neuron, or 0.95 fJ per weight, which is small compared with other sources of energy consumption shown in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12b</a>.</p><p>Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12c–e</a> shows the measured latency, peak throughput and throughput-power efficiency for performing the 256 × 256 MVMs. It is noted that we used EDP as a figure of merit for comparing designs rather than throughput-power efficiency as tera-operations per second per watt (TOPS W<sup>−1</sup>, reciprocal of energy per operation), because it captures the time-to-solution aspect in addition to energy consumption. Similar to previous work in this field, the reported throughput and energy efficiency represent their peak values when the CIM array utilization is 100%, and does not include time and energy spent at buffering and moving intermediate data. Future work that integrates intermediate data buffers, partial-sum accumulators and so on within a single complete CIM chip should show energy efficiency measured on end-to-end AI applications.</p><h3 id="Sec17">Projection of NeuRRAM energy efficiency with technology scaling</h3><p>The current NeuRRAM chip is fabricated using a 130-nm CMOS technology. We expect the energy efficiency to improve with the technology scaling. Importantly, isolated scaling of CMOS transistors and interconnects is not sufficient for the overall energy-efficiency improvement. RRAM device characteristics must be optimized jointly with CMOS. The current RRAM array density under a 1T1R configuration is limited not by the fabrication process but by the RRAM write current and voltage. The current NeuRRAM chip uses large thick-oxide I/O transistors as the ‘T’ to withstand &gt;4-V RRAM forming voltage and provide enough write current. Only if we lower both the forming voltage and the write current can we obtain higher density and therefore lower parasitic capacitance for improved energy efficiency.</p><p>Assuming that RRAM devices at a newer technology node can be programmed at a logic-compatible voltage level, and the required write current can be reduced such that the size of the connecting transistor keeps shrinking, the EDP improvements will come from (1) lower operating voltage and (2) smaller wire and transistor capacitance, that is, Energy <span>∝</span> <i>CV</i><sup>2</sup> and Delay <span>∝</span> <i>CV/I</i>. At 7 nm, for instance, we expect the WL switching energy (Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Fig17">12b</a>) to reduce by about 22.4 times, including 2.6 times from WL voltage scaling (1.3 V → 0.8 V), and 8.5 times from capacitance scaling (capacitance from select transistors, WL drivers and wires are all assumed to scale with minimum metal pitch 340 nm → 40 nm). Peripheral circuit energy (dominated by the neuron readout process) is projected to reduce by 42 times, including 5 times from VDD scaling (1.8 V → 0.8 V) and 8.5 times from smaller parasitic capacitance. The energy consumed by the MVM pulses and charge transfer process is independent of the range of RRAM conductance, as power consumption and settling time of the RRAM array scale with the same conductance factor that cancels in their product. Specifically the energy per RRAM MAC is <i>E</i><sub>MAC</sub> = <i>C</i><sub>par</sub> var(<i>V</i><sub>in</sub>), limited only by the parasitic capacitance per unit RRAM cell <i>C</i><sub>par</sub>, and the variance in the driven input voltage var(<i>V</i><sub>in</sub>). Therefore, the MVM energy consumption will reduce by approximately 34 times, including 4 times from read-voltage scaling (0.5 V → 0.25 V), and 8.5 times from smaller parasitic capacitance. Overall, we expect an energy consumption reduction of about 34 times when scaling the design from 130 nm to 7 nm.</p><p>In terms of the latency, the current design is limited by the long integration time of neuron, caused primarily by the relatively large integration capacitor size (104 fF), which was chosen conservatively to ensure function correctness and testing different neuron operating conditions. At more advanced technology nodes, one could use a much smaller capacitor size to achieve a higher speed. The main concern for scaling-down capacitor size is that the fabrication-induced capacitor size mismatch will take up a higher fraction of total capacitance, resulting in a lower SNR. However, previous ADC designs have used a unit capacitor size as small as 50 aF (ref. <sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 56" title="Stepanovic, D. &amp; Nikolic, B. A 2.8 GS/s 44.6 mW time-interleaved ADC achieving 50.9 dB SNDR and 3 dB effective resolution bandwidth of 1.5 GHz in 65 nm CMOS. IEEE J. Solid State Circuits 48, 971–982 (2013)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR56" id="ref-link-section-d163879637e3112">56</a></sup>; 340 times smaller than our <i>C</i><sub>sample</sub>). For a more conservative design, a study has shown that in a 32-nm process, a 0.45-fF unit capacitor has only 1.2% average standard deviation<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 57" title="Tripathi, V. &amp; Murmann, B. Mismatch characterization of small metal fringe capacitors. IEEE Trans. Circuits Syst. I Regul. Pap. 61, 2236–2242 (2014)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR57" id="ref-link-section-d163879637e3120">57</a></sup>. Besides, the integration time also depends on the drive current of the transistors. Assuming that the transistor current density (μA μm<sup>−1</sup>) stays relatively unchanged after VDD scaling, and that the transistor width in the neuron scales with the contact gate pitch (310 nm → 57 nm), the total transistor drive current will reduce by 5.4 times. As a result, when scaling <i>C</i><sub>sample</sub> from 17 fF to 0.2 fF and <i>C</i><sub>integ</sub> proportionally from 104 fF to 1.22 fF, the latency will improve by 15.7 times. Therefore, conservatively, we expect the overall EDP to improve by at least 535 times when scaling the design from 130-nm to 7-nm technology. Extended Data Table <a data-track="click" data-track-label="link" data-track-action="table anchor" href="https://donnywinston.com/articles/s41586-022-04992-8#Tab3">2</a> shows that such scaling will enable NeuRRAM to deliver higher energy and area efficiency than today’s state-of-the-art edge inference accelerators<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Chen, Y. H., Krishna, T., Emer, J. S. &amp; Sze, V. Eyeriss: an energy-efficient reconfigurable accelerator for deep convolutional neural networks. IEEE J. Solid State Circuits 52, 127–138 (2017)." href="#ref-CR58" id="ref-link-section-d163879637e3138">58</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Zimmer, B. et al. A 0.32-128 TOPS, scalable multi-chip-module-based deep neural network inference accelerator with ground-referenced signaling in 16 nm. IEEE J. Solid State Circuits 55, 920–932 (2020)." href="#ref-CR59" id="ref-link-section-d163879637e3138_1">59</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Lee, J. et al. UNPU: an energy-efficient deep neural network accelerator with fully variable weight bit precision. IEEE J. Solid State Circuits 54, 173–185 (2019)." href="#ref-CR60" id="ref-link-section-d163879637e3138_2">60</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 61" title="Pei, J. et al. Towards artificial general intelligence with hybrid Tianjic chip architecture. Nature 572, 106–111 (2019)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR61" id="ref-link-section-d163879637e3141">61</a></sup>.</p></div></div></section>
            

            <section data-title="Data availability"><div id="data-availability-section"><h2 id="data-availability">Data availability</h2><p>The datasets used for benchmarks are publicly available<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="LeCun, Y., Bottou, L., Bengio, Y. &amp; Haffner, P. Gradient-based learning applied to document recognition. Proc. IEEE 86, 2278–2323 (1998)." href="#ref-CR18" id="ref-link-section-d163879637e3228">18</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" title="Krizhevsky, A. &amp; Hinton, G. Learning Multiple Layers of Features from Tiny Images (2009); 
                  https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf
                  
                " href="#ref-CR19" id="ref-link-section-d163879637e3228_1">19</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 20" title="Warden, P. Speech commands: a dataset for limited-vocabulary speech recognition. Preprint at 
                  https://arxiv.org/abs/1804.03209
                  
                 (2018)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR20" id="ref-link-section-d163879637e3231">20</a></sup>. Other data that support the findings of this study are available in a public repository<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 47" title="Wan, W. weierwan/Neurram_48core: Initial Release (Version 1.0) [Computer software]. Zenodo 
                  https://doi.org/10.5281/zenodo.6558399
                  
                 (2022)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR47" id="ref-link-section-d163879637e3235">47</a></sup>.</p></div></section><section data-title="Code availability"><div id="code-availability-section"><h2 id="code-availability">Code availability</h2><p>The software toolchain used to test and deploy AI tasks on the NeuRRAM chip, and the codes used to perform noise-resilient model training and chip-in-the-loop progressive model fine-tuning are available in a public repository<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 47" title="Wan, W. weierwan/Neurram_48core: Initial Release (Version 1.0) [Computer software]. Zenodo 
                  https://doi.org/10.5281/zenodo.6558399
                  
                 (2022)." href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR47" id="ref-link-section-d163879637e3247">47</a></sup>.</p></div></section><div id="MagazineFulltextArticleBodySuffix"><section aria-labelledby="Bib1" data-title="References"><div id="Bib1-section"><h2 id="Bib1">References</h2><div id="Bib1-content"><div data-container-section="references"><ol data-track-category="outbound reference"><li data-counter="1."><p id="ref-CR1">Wong, H. S. P. et al. Metal-oxide RRAM. <i>Proc. IEEE</i> <b>100</b>, 1951–1970 (2012).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC38XhtVeiurfI" aria-label="CAS reference 1">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FJPROC.2012.2190369" aria-label="Article reference 1">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 1" href="http://scholar.google.com/scholar_lookup?&amp;title=Metal-oxide%20RRAM&amp;journal=Proc.%20IEEE&amp;volume=100&amp;pages=1951-1970&amp;publication_year=2012&amp;author=Wong%2CHSP">
                    Google Scholar</a> 
                </p></li><li data-counter="2."><p id="ref-CR2">Prezioso, M. et al. Training and operation of an integrated neuromorphic network based on metal-oxide memristors. <i>Nature</i> <b>521</b>, 61–64 (2015).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2015Natur.521...61P" aria-label="ADS reference 2">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC2MXnvFWjtb4%3D" aria-label="CAS reference 2">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fnature14441" aria-label="Article reference 2">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 2" href="http://scholar.google.com/scholar_lookup?&amp;title=Training%20and%20operation%20of%20an%20integrated%20neuromorphic%20network%20based%20on%20metal-oxide%20memristors&amp;journal=Nature&amp;volume=521&amp;pages=61-64&amp;publication_year=2015&amp;author=Prezioso%2CM">
                    Google Scholar</a> 
                </p></li><li data-counter="3."><p id="ref-CR3">Ambrogio, S. et al. Equivalent-accuracy accelerated neural-network training using analogue memory. <i>Nature</i> <b>558</b>, 60–67 (2018).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2018Natur.558...60A" aria-label="ADS reference 3">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC1cXhtV2lsr3O" aria-label="CAS reference 3">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41586-018-0180-5" aria-label="Article reference 3">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 3" href="http://scholar.google.com/scholar_lookup?&amp;title=Equivalent-accuracy%20accelerated%20neural-network%20training%20using%20analogue%20memory&amp;journal=Nature&amp;volume=558&amp;pages=60-67&amp;publication_year=2018&amp;author=Ambrogio%2CS">
                    Google Scholar</a> 
                </p></li><li data-counter="4."><p id="ref-CR4">Ielmini, D. &amp; Wong, H. S. P. In-memory computing with resistive switching devices. <i>Nat. Electron.</i> <b>1</b>, 333–343 (2018).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41928-018-0092-2" aria-label="Article reference 4">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 4" href="http://scholar.google.com/scholar_lookup?&amp;title=In-memory%20computing%20with%20resistive%20switching%20devices&amp;journal=Nat.%20Electron.&amp;volume=1&amp;pages=333-343&amp;publication_year=2018&amp;author=Ielmini%2CD&amp;author=Wong%2CHSP">
                    Google Scholar</a> 
                </p></li><li data-counter="5."><p id="ref-CR5">Yao, P. et al. Fully hardware-implemented memristor convolutional neural network. <i>Nature</i> <b>577</b>, 641–646 (2020).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2020Natur.577..641Y" aria-label="ADS reference 5">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BB3cXktFegt74%3D" aria-label="CAS reference 5">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41586-020-1942-4" aria-label="Article reference 5">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 5" href="http://scholar.google.com/scholar_lookup?&amp;title=Fully%20hardware-implemented%20memristor%20convolutional%20neural%20network&amp;journal=Nature&amp;volume=577&amp;pages=641-646&amp;publication_year=2020&amp;author=Yao%2CP">
                    Google Scholar</a> 
                </p></li><li data-counter="6."><p id="ref-CR6">Mochida, R. et al. A 4M synapses integrated analog ReRAM based 66.5 TOPS/W neural-network processor with cell current controlled writing and flexible network architecture. In <i>Symposium on VLSI Technology</i>, <i>Digest of Technical Papers</i> 175–176 (IEEE, 2018).</p></li><li data-counter="7."><p id="ref-CR7">Chen, W. H. et al. CMOS-integrated memristive non-volatile computing-in-memory for AI edge processors. <i>Nat. Electron.</i> <b>2</b>, 420–428 (2019).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC1MXhs1Gisr3K" aria-label="CAS reference 7">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41928-019-0288-0" aria-label="Article reference 7">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 7" href="http://scholar.google.com/scholar_lookup?&amp;title=CMOS-integrated%20memristive%20non-volatile%20computing-in-memory%20for%20AI%20edge%20processors&amp;journal=Nat.%20Electron.&amp;volume=2&amp;pages=420-428&amp;publication_year=2019&amp;author=Chen%2CWH">
                    Google Scholar</a> 
                </p></li><li data-counter="8."><p id="ref-CR8">Khaddam-Aljameh, R. et al. HERMES core-A 14nm CMOS and PCM-based in-memory compute core using an array of 300ps/LSB linearized CCO-based ADCs and local digital processing. In <i>IEEE Symposium on VLSI Circuits, Digest of Technical Papers</i> JFS2-5 (IEEE, 2021).</p></li><li data-counter="9."><p id="ref-CR9">Hung, J. M. et al. A four-megabit compute-in-memory macro with eight-bit precision based on CMOS and resistive random-access memory for AI edge devices. <i>Nat. Electron.</i> <b>4</b>, 921–930 (2021).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41928-021-00676-9" aria-label="Article reference 9">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 9" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20four-megabit%20compute-in-memory%20macro%20with%20eight-bit%20precision%20based%20on%20CMOS%20and%20resistive%20random-access%20memory%20for%20AI%20edge%20devices&amp;journal=Nat.%20Electron.&amp;volume=4&amp;pages=921-930&amp;publication_year=2021&amp;author=Hung%2CJM">
                    Google Scholar</a> 
                </p></li><li data-counter="10."><p id="ref-CR10">Xue, C. X. et al. A 1Mb multibit ReRAM computing-in-memory macro with 14.6ns parallel MAC computing time for CNN based AI edge processors. In <i>IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers</i> 388–390 (IEEE, 2019).</p></li><li data-counter="11."><p id="ref-CR11">Cai, F. et al. A fully integrated reprogrammable memristor–CMOS system for efficient multiply–accumulate operations. <i>Nat. Electron.</i> <b>2</b>, 290–299 (2019).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC1MXhtlOlsLjP" aria-label="CAS reference 11">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41928-019-0270-x" aria-label="Article reference 11">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 11" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20fully%20integrated%20reprogrammable%20memristor%E2%80%93CMOS%20system%20for%20efficient%20multiply%E2%80%93accumulate%20operations&amp;journal=Nat.%20Electron.&amp;volume=2&amp;pages=290-299&amp;publication_year=2019&amp;author=Cai%2CF">
                    Google Scholar</a> 
                </p></li><li data-counter="12."><p id="ref-CR12">Ishii, M. et al. On-chip trainable 1.4M 6T2R PCM synaptic array with 1.6K stochastic LIF neurons for spiking RBM. In <i>International Electron Devices Meeting (IEDM), Technical Digest</i> 14.2.1–14.2.4 (IEEE, 2019).</p></li><li data-counter="13."><p id="ref-CR13">Yan, B. et al. RRAM-based spiking nonvolatile computing-in-memory processing engine with precision-configurable in situ nonlinear activation. In <i>Symposium on VLSI Technology</i>, <i>Digest of Technical Papers</i> T86–T87 (IEEE, 2019).</p></li><li data-counter="14."><p id="ref-CR14">Wan, W. et al. A 74 TMACS/W CMOS-RRAM neurosynaptic core with dynamically reconfigurable dataflow and in-situ transposable weights for probabilistic graphical models. In <i>IEEE International Solid-State Circuits Conference (ISSCC)</i>, <i>Digest of Technical Papers</i> 498–500 (IEEE, 2020).</p></li><li data-counter="15."><p id="ref-CR15">Liu, Q. et al. A fully integrated analog ReRAM based 78.4TOPS/W compute-in-memory chip with fully parallel MAC computing. In <i>IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers</i> 500–502 (IEEE, 2020).</p></li><li data-counter="16."><p id="ref-CR16">Xue, C. X. et al. A CMOS-integrated compute-in-memory macro based on resistive random-access memory for AI edge devices. <i>Nat. Electron.</i> <b>4</b>, 81–90 (2021).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BB3cXis1WhtrbL" aria-label="CAS reference 16">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41928-020-00505-5" aria-label="Article reference 16">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 16" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20CMOS-integrated%20compute-in-memory%20macro%20based%20on%20resistive%20random-access%20memory%20for%20AI%20edge%20devices&amp;journal=Nat.%20Electron.&amp;volume=4&amp;pages=81-90&amp;publication_year=2021&amp;author=Xue%2CCX">
                    Google Scholar</a> 
                </p></li><li data-counter="17."><p id="ref-CR17">Narayanan, P. et al. Fully on-chip MAC at 14 nm enabled by accurate row-wise programming of PCM-based weights and parallel vector-transport in duration-format. <i>IEEE Trans. Electron Devices</i> <b>68</b>, 6629–6636 (2021).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2021ITED...68.6629N" aria-label="ADS reference 17">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FTED.2021.3115993" aria-label="Article reference 17">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 17" href="http://scholar.google.com/scholar_lookup?&amp;title=Fully%20on-chip%20MAC%20at%2014%20nm%20enabled%20by%20accurate%20row-wise%20programming%20of%20PCM-based%20weights%20and%20parallel%20vector-transport%20in%20duration-format&amp;journal=IEEE%20Trans.%20Electron%20Devices&amp;volume=68&amp;pages=6629-6636&amp;publication_year=2021&amp;author=Narayanan%2CP">
                    Google Scholar</a> 
                </p></li><li data-counter="18."><p id="ref-CR18">LeCun, Y., Bottou, L., Bengio, Y. &amp; Haffner, P. Gradient-based learning applied to document recognition. <i>Proc. IEEE</i> <b>86</b>, 2278–2323 (1998).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2F5.726791" aria-label="Article reference 18">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 18" href="http://scholar.google.com/scholar_lookup?&amp;title=Gradient-based%20learning%20applied%20to%20document%20recognition&amp;journal=Proc.%20IEEE&amp;volume=86&amp;pages=2278-2323&amp;publication_year=1998&amp;author=LeCun%2CY&amp;author=Bottou%2CL&amp;author=Bengio%2CY&amp;author=Haffner%2CP">
                    Google Scholar</a> 
                </p></li><li data-counter="19."><p id="ref-CR19">Krizhevsky, A. &amp; Hinton, G. <i>Learning Multiple Layers of Features from Tiny Images</i> (2009); <a href="https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf">https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf</a></p></li><li data-counter="20."><p id="ref-CR20">Warden, P. Speech commands: a dataset for limited-vocabulary speech recognition. Preprint at <a href="https://arxiv.org/abs/1804.03209">https://arxiv.org/abs/1804.03209</a> (2018).</p></li><li data-counter="21."><p id="ref-CR21">Joshi, V. et al. Accurate deep neural network inference using computational phase-change memory. <i>Nat. Commun.</i> <b>11</b>, 2473 (2020).</p></li><li data-counter="22."><p id="ref-CR22">Alibart, F., Zamanidoost, E. &amp; Strukov, D. B. Pattern classification by memristive crossbar circuits using ex situ and in situ training. <i>Nat. Commun.</i> <b>4</b>, 2072 (2013).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2013NatCo...4.2072A" aria-label="ADS reference 22">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fncomms3072" aria-label="Article reference 22">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 22" href="http://scholar.google.com/scholar_lookup?&amp;title=Pattern%20classification%20by%20memristive%20crossbar%20circuits%20using%20ex%20situ%20and%20in%20situ%20training&amp;journal=Nat.%20Commun.&amp;volume=4&amp;publication_year=2013&amp;author=Alibart%2CF&amp;author=Zamanidoost%2CE&amp;author=Strukov%2CDB">
                    Google Scholar</a> 
                </p></li><li data-counter="23."><p id="ref-CR23">Eryilmaz, S. B. et al. Experimental demonstration of array-level learning with phase change synaptic devices. In <i>International Electron Devices Meeting (IEDM)</i>, <i>Technical Digest</i> 25.5.1–25.5.4 (IEEE, 2013).</p></li><li data-counter="24."><p id="ref-CR24">Burr, G. W. et al. Experimental demonstration and tolerancing of a large-scale neural network (165 000 synapses) using phase-change memory as the synaptic weight element. <i>IEEE Trans. Electron Devices</i> <b>62</b>, 3498–3507 (2015).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2015ITED...62.3498B" aria-label="ADS reference 24">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FTED.2015.2439635" aria-label="Article reference 24">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 24" href="http://scholar.google.com/scholar_lookup?&amp;title=Experimental%20demonstration%20and%20tolerancing%20of%20a%20large-scale%20neural%20network%20%28165%20000%20synapses%29%20using%20phase-change%20memory%20as%20the%20synaptic%20weight%20element&amp;journal=IEEE%20Trans.%20Electron%20Devices&amp;volume=62&amp;pages=3498-3507&amp;publication_year=2015&amp;author=Burr%2CGW">
                    Google Scholar</a> 
                </p></li><li data-counter="25."><p id="ref-CR25">Eryilmaz, S. B. et al. Training a probabilistic graphical model with resistive switching electronic synapses. <i>IEEE Trans. Electron Devices</i> <b>63</b>, 5004–5011 (2016).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2016ITED...63.5004E" aria-label="ADS reference 25">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FTED.2016.2616483" aria-label="Article reference 25">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 25" href="http://scholar.google.com/scholar_lookup?&amp;title=Training%20a%20probabilistic%20graphical%20model%20with%20resistive%20switching%20electronic%20synapses&amp;journal=IEEE%20Trans.%20Electron%20Devices&amp;volume=63&amp;pages=5004-5011&amp;publication_year=2016&amp;author=Eryilmaz%2CSB">
                    Google Scholar</a> 
                </p></li><li data-counter="26."><p id="ref-CR26">Sheridan, P. M. et al. Sparse coding with memristor networks. <i>Nat. Nanotechnol.</i> <b>12</b>, 784–789 (2017).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC2sXot1yrsLg%3D" aria-label="CAS reference 26">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fnnano.2017.83" aria-label="Article reference 26">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 26" href="http://scholar.google.com/scholar_lookup?&amp;title=Sparse%20coding%20with%20memristor%20networks&amp;journal=Nat.%20Nanotechnol.&amp;volume=12&amp;pages=784-789&amp;publication_year=2017&amp;author=Sheridan%2CPM">
                    Google Scholar</a> 
                </p></li><li data-counter="27."><p id="ref-CR27">Yao, P. et al. Face classification using electronic synapses. <i>Nat. Commun.</i> <b>8</b>, 15199 (2017).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2017NatCo...815199Y" aria-label="ADS reference 27">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC2sXnslKntr4%3D" aria-label="CAS reference 27">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fncomms15199" aria-label="Article reference 27">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 27" href="http://scholar.google.com/scholar_lookup?&amp;title=Face%20classification%20using%20electronic%20synapses&amp;journal=Nat.%20Commun.&amp;volume=8&amp;publication_year=2017&amp;author=Yao%2CP">
                    Google Scholar</a> 
                </p></li><li data-counter="28."><p id="ref-CR28">Banbury, C. et al. MLPerf tiny benchmark. In <i>Conference on Neural Information Processing Systems (NeurIPS) Track on Datasets and Benchmarks</i> (2021).</p></li><li data-counter="29."><p id="ref-CR29">Roy, S., Sridharan, S., Jain, S. &amp; Raghunathan, A. TxSim: modeling training of deep neural networks on resistive crossbar systems. <i>IEEE Trans. Very Large Scale Integr. Syst.</i> <b>29</b>, 730–738 (2021).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FTVLSI.2021.3063543" aria-label="Article reference 29">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 29" href="http://scholar.google.com/scholar_lookup?&amp;title=TxSim%3A%20modeling%20training%20of%20deep%20neural%20networks%20on%20resistive%20crossbar%20systems&amp;journal=IEEE%20Trans.%20Very%20Large%20Scale%20Integr.%20Syst.&amp;volume=29&amp;pages=730-738&amp;publication_year=2021&amp;author=Roy%2CS&amp;author=Sridharan%2CS&amp;author=Jain%2CS&amp;author=Raghunathan%2CA">
                    Google Scholar</a> 
                </p></li><li data-counter="30."><p id="ref-CR30">Yang, T. J. &amp; Sze, V. Design considerations for efficient deep neural networks on processing-in-memory accelerators. In <i>International Electron Devices Meeting (IEDM)</i>, <i>Technical Digest</i> 22.1.1–22.1.4 (IEEE, 2019).</p></li><li data-counter="31."><p id="ref-CR31">Lecun, Y., Bengio, Y. &amp; Hinton, G. Deep learning. <i>Nature</i> <b>521</b>, 436–444 (2015).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2015Natur.521..436L" aria-label="ADS reference 31">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC2MXht1WlurzP" aria-label="CAS reference 31">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fnature14539" aria-label="Article reference 31">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 31" href="http://scholar.google.com/scholar_lookup?&amp;title=Deep%20learning&amp;journal=Nature&amp;volume=521&amp;pages=436-444&amp;publication_year=2015&amp;author=Lecun%2CY&amp;author=Bengio%2CY&amp;author=Hinton%2CG">
                    Google Scholar</a> 
                </p></li><li data-counter="32."><p id="ref-CR32">Hochreiter, S. &amp; Schmidhuber, J. Long short-term memory. <i>Neural Comput.</i> <b>9</b>, 1735–1780 (1997).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:STN:280:DyaK1c%2FhvVahsQ%3D%3D" aria-label="CAS reference 32">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1162%2Fneco.1997.9.8.1735" aria-label="Article reference 32">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 32" href="http://scholar.google.com/scholar_lookup?&amp;title=Long%20short-term%20memory&amp;journal=Neural%20Comput.&amp;volume=9&amp;pages=1735-1780&amp;publication_year=1997&amp;author=Hochreiter%2CS&amp;author=Schmidhuber%2CJ">
                    Google Scholar</a> 
                </p></li><li data-counter="33."><p id="ref-CR33">Koller, D. &amp; Friedman, N. <i>Probabilistic Graphical Models: Principles and Techniques (Adaptive Computation and Machine Learning series)</i> (MIT Press, 2009).</p></li><li data-counter="34."><p id="ref-CR34">Su, J. W. et al. A 28nm 64Kb inference-training two-way transpose multibit 6T SRAM compute-in-memory macro for AI edge chips. In <i>IEEE International Solid-State Circuits Conference (ISSCC), Digest of Technical Papers</i> 240–242 (IEEE, 2020).</p></li><li data-counter="35."><p id="ref-CR35">Guo, R. et al. A 5.1pJ/neuron 127.3us/inference RNN-based speech recognition processor using 16 computing-in-memory SRAM macros in 65nm CMOS. In <i>IEEE Symposium on VLSI Circuits, Digest of Technical Papers</i> 120–121 (IEEE, 2019).</p></li><li data-counter="36."><p id="ref-CR36">Wang, Z. et al. Fully memristive neural networks for pattern classification with unsupervised learning. <i>Nat. Electron.</i> <b>1</b>, 137–145 (2018).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41928-018-0023-2" aria-label="Article reference 36">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 36" href="http://scholar.google.com/scholar_lookup?&amp;title=Fully%20memristive%20neural%20networks%20for%20pattern%20classification%20with%20unsupervised%20learning&amp;journal=Nat.%20Electron.&amp;volume=1&amp;pages=137-145&amp;publication_year=2018&amp;author=Wang%2CZ">
                    Google Scholar</a> 
                </p></li><li data-counter="37."><p id="ref-CR37">Shafiee, A. et al. ISAAC: a convolutional neural network accelerator with in-situ analog arithmetic in crossbars. In <i>Proc. 2016 43rd International Symposium on Computer</i> <i>Architecture (ISCA)</i> 14-26 (IEEE/ACM, 2016).</p></li><li data-counter="38."><p id="ref-CR38">Ankit, A. et al. PUMA: a programmable ultra-efficient memristor-based accelerator for machine learning inference. In <i>International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS</i>) 715–731 (ACM, 2019).</p></li><li data-counter="39."><p id="ref-CR39">Wan, W. et al. A voltage-mode sensing scheme with differential-row weight mapping for energy-efficient RRAM-based in-memory computing. In <i>Symposium on VLSI Technology, Digest of Technical Papers</i> (IEEE, 2020).</p></li><li data-counter="40."><p id="ref-CR40">Murmann, B. Digitally assisted data converter design. In <i>European Conference on Solid-State Circuits (ESSCIRC)</i> 24–31 (IEEE, 2013).</p></li><li data-counter="41."><p id="ref-CR41">Zhao, M. et al. Investigation of statistical retention of filamentary analog RRAM for neuromophic computing. In <i>International Electron Devices Meeting (IEDM), Technical Digest</i> 39.4.1–39.4.4 (IEEE, 2018).</p></li><li data-counter="42."><p id="ref-CR42">Alibart, F., Gao, L., Hoskins, B. D. &amp; Strukov, D. B. High precision tuning of state for memristive devices by adaptable variation-tolerant algorithm. <i>Nanotechnology</i> <b>23</b>, 762–775 (2012).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1088%2F0957-4484%2F23%2F7%2F075201" aria-label="Article reference 42">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 42" href="http://scholar.google.com/scholar_lookup?&amp;title=High%20precision%20tuning%20of%20state%20for%20memristive%20devices%20by%20adaptable%20variation-tolerant%20algorithm&amp;journal=Nanotechnology&amp;volume=23&amp;pages=762-775&amp;publication_year=2012&amp;author=Alibart%2CF&amp;author=Gao%2CL&amp;author=Hoskins%2CBD&amp;author=Strukov%2CDB">
                    Google Scholar</a> 
                </p></li><li data-counter="43."><p id="ref-CR43">He, K., Zhang, X., Ren, S. &amp; Sun, J. Deep residual learning for image recognition. In <i>Proc. IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR)</i> 770–778 (IEEE, 2016).</p></li><li data-counter="44."><p id="ref-CR44">Cauwenberghs, G. &amp; Bayoumi, M. A. <i>Learning on Silicon—Adaptive VLSI Neural Systems</i> (Kluwer Academic, 1999).</p></li><li data-counter="45."><p id="ref-CR45">Hornik, K., Stinchcombe, M. &amp; White, H. Multilayer feedforward networks are universal approximators. <i>Neural Netw.</i> <b>2</b>, 359–366 (1989).</p></li><li data-counter="46."><p id="ref-CR46">Choi, J. et al. PACT: parameterized clipping activation for quantized neural networks. Preprint at <a href="https://arxiv.org/abs/1805.06085">https://arxiv.org/abs/1805.06085</a> (2018).</p></li><li data-counter="47."><p id="ref-CR47">Wan, W. weierwan/Neurram_48core: Initial Release (Version 1.0) [Computer software]. <i>Zenodo</i> <a href="https://doi.org/10.5281/zenodo.6558399">https://doi.org/10.5281/zenodo.6558399</a> (2022).</p></li><li data-counter="48."><p id="ref-CR48">Jung, S. et al. A crossbar array of magnetoresistive memory devices for in-memory computing. <i>Nature</i> <b>601</b>, 211–216 (2022).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2022Natur.601..211J" aria-label="ADS reference 48">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BB38XhtVOlu7s%3D" aria-label="CAS reference 48">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41586-021-04196-6" aria-label="Article reference 48">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 48" href="http://scholar.google.com/scholar_lookup?&amp;title=A%20crossbar%20array%20of%20magnetoresistive%20memory%20devices%20for%20in-memory%20computing&amp;journal=Nature&amp;volume=601&amp;pages=211-216&amp;publication_year=2022&amp;author=Jung%2CS">
                    Google Scholar</a> 
                </p></li><li data-counter="49."><p id="ref-CR49">Jerry, M. et al. Ferroelectric FET analog synapse for acceleration of deep neural network training. In <i>International Electron Devices Meeting</i> (<i>IEDM), Technical Digest</i> 6.2.1–6.2.4 (IEEE, 2018).</p></li><li data-counter="50."><p id="ref-CR50">Jiang, Z. et al. Next-generation ultrahigh-density 3-D vertical resistive switching memory (VRSM)–Part II: design guidelines for device, array, and architecture. <i>IEEE Trans. Electron Devices</i> <b>66</b>, 5147–5154 (2019).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2019ITED...66.5147J" aria-label="ADS reference 50">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BB3cXhsVeju7jM" aria-label="CAS reference 50">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FTED.2019.2950595" aria-label="Article reference 50">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 50" href="http://scholar.google.com/scholar_lookup?&amp;title=Next-generation%20ultrahigh-density%203-D%20vertical%20resistive%20switching%20memory%20%28VRSM%29%E2%80%93Part%20II%3A%20design%20guidelines%20for%20device%2C%20array%2C%20and%20architecture&amp;journal=IEEE%20Trans.%20Electron%20Devices&amp;volume=66&amp;pages=5147-5154&amp;publication_year=2019&amp;author=Jiang%2CZ">
                    Google Scholar</a> 
                </p></li><li data-counter="51."><p id="ref-CR51">Cauwenberghs, G. An analog VLSI recurrent neural network learning a continuous-time trajectory. <i>IEEE Trans. Neural Netw.</i> <b>7</b>, 346–361 (1996).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:STN:280:DC%2BD1c%2FpvVagsQ%3D%3D" aria-label="CAS reference 51">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2F72.485671" aria-label="Article reference 51">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 51" href="http://scholar.google.com/scholar_lookup?&amp;title=An%20analog%20VLSI%20recurrent%20neural%20network%20learning%20a%20continuous-time%20trajectory&amp;journal=IEEE%20Trans.%20Neural%20Netw.&amp;volume=7&amp;pages=346-361&amp;publication_year=1996&amp;author=Cauwenberghs%2CG">
                    Google Scholar</a> 
                </p></li><li data-counter="52."><p id="ref-CR52">Wu, W. et al. A methodology to improve linearity of analog RRAM for neuromorphic computing. In <i>Symposium on VLSI Technology, Digest of Technical Papers</i> 103–104 (IEEE, 2018).</p></li><li data-counter="53."><p id="ref-CR53">Ji, Y. et al. FPSA: a full system stack solution for reconfigurable ReRAM-based NN accelerator architecture. In <i>International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</i> 733–747 (ACM, 2019).</p></li><li data-counter="54."><p id="ref-CR54">Esser, S. K., Mckinstry, J. L., Bablani, D., Appuswamy, R. &amp; Modha, D. S. Learned step size quantization. In <i>International Conference on Learning Representations (ICLR)</i> (2020).</p></li><li data-counter="55."><p id="ref-CR55">Jung, S. et al. Learning to quantize deep networks by optimizing quantization intervals with task loss. In <i>IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</i> 4345–4354 (IEEE/CVF, 2019).</p></li><li data-counter="56."><p id="ref-CR56">Stepanovic, D. &amp; Nikolic, B. A 2.8 GS/s 44.6 mW time-interleaved ADC achieving 50.9 dB SNDR and 3 dB effective resolution bandwidth of 1.5 GHz in 65 nm CMOS. <i>IEEE J. Solid State Circuits</i> <b>48</b>, 971–982 (2013).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2013IJSSC..48..971S" aria-label="ADS reference 56">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FJSSC.2013.2239005" aria-label="Article reference 56">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 56" href="http://scholar.google.com/scholar_lookup?&amp;title=A%202.8%20GS%2Fs%2044.6%20mW%20time-interleaved%20ADC%20achieving%2050.9%20dB%20SNDR%20and%203%20dB%20effective%20resolution%20bandwidth%20of%201.5%20GHz%20in%2065%20nm%20CMOS&amp;journal=IEEE%20J.%20Solid%20State%20Circuits&amp;volume=48&amp;pages=971-982&amp;publication_year=2013&amp;author=Stepanovic%2CD&amp;author=Nikolic%2CB">
                    Google Scholar</a> 
                </p></li><li data-counter="57."><p id="ref-CR57">Tripathi, V. &amp; Murmann, B. Mismatch characterization of small metal fringe capacitors. <i>IEEE Trans. Circuits Syst. I Regul. Pap.</i> <b>61</b>, 2236–2242 (2014).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FTCSI.2014.2332264" aria-label="Article reference 57">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 57" href="http://scholar.google.com/scholar_lookup?&amp;title=Mismatch%20characterization%20of%20small%20metal%20fringe%20capacitors&amp;journal=IEEE%20Trans.%20Circuits%20Syst.%20I%20Regul.%20Pap.&amp;volume=61&amp;pages=2236-2242&amp;publication_year=2014&amp;author=Tripathi%2CV&amp;author=Murmann%2CB">
                    Google Scholar</a> 
                </p></li><li data-counter="58."><p id="ref-CR58">Chen, Y. H., Krishna, T., Emer, J. S. &amp; Sze, V. Eyeriss: an energy-efficient reconfigurable accelerator for deep convolutional neural networks. <i>IEEE J. Solid State Circuits</i> <b>52</b>, 127–138 (2017).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2017IJSSC..52..127C" aria-label="ADS reference 58">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FJSSC.2016.2616357" aria-label="Article reference 58">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 58" href="http://scholar.google.com/scholar_lookup?&amp;title=Eyeriss%3A%20an%20energy-efficient%20reconfigurable%20accelerator%20for%20deep%20convolutional%20neural%20networks&amp;journal=IEEE%20J.%20Solid%20State%20Circuits&amp;volume=52&amp;pages=127-138&amp;publication_year=2017&amp;author=Chen%2CYH&amp;author=Krishna%2CT&amp;author=Emer%2CJS&amp;author=Sze%2CV">
                    Google Scholar</a> 
                </p></li><li data-counter="59."><p id="ref-CR59">Zimmer, B. et al. A 0.32-128 TOPS, scalable multi-chip-module-based deep neural network inference accelerator with ground-referenced signaling in 16 nm. <i>IEEE J. Solid State Circuits</i> <b>55</b>, 920–932 (2020).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2020IJSSC..55..920Z" aria-label="ADS reference 59">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FJSSC.2019.2960488" aria-label="Article reference 59">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 59" href="http://scholar.google.com/scholar_lookup?&amp;title=A%200.32-128%20TOPS%2C%20scalable%20multi-chip-module-based%20deep%20neural%20network%20inference%20accelerator%20with%20ground-referenced%20signaling%20in%2016%20nm&amp;journal=IEEE%20J.%20Solid%20State%20Circuits&amp;volume=55&amp;pages=920-932&amp;publication_year=2020&amp;author=Zimmer%2CB">
                    Google Scholar</a> 
                </p></li><li data-counter="60."><p id="ref-CR60">Lee, J. et al. UNPU: an energy-efficient deep neural network accelerator with fully variable weight bit precision. <i>IEEE J. Solid State Circuits</i> <b>54</b>, 173–185 (2019).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2019IJSSC..54..173L" aria-label="ADS reference 60">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1109%2FJSSC.2018.2865489" aria-label="Article reference 60">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 60" href="http://scholar.google.com/scholar_lookup?&amp;title=UNPU%3A%20an%20energy-efficient%20deep%20neural%20network%20accelerator%20with%20fully%20variable%20weight%20bit%20precision&amp;journal=IEEE%20J.%20Solid%20State%20Circuits&amp;volume=54&amp;pages=173-185&amp;publication_year=2019&amp;author=Lee%2CJ">
                    Google Scholar</a> 
                </p></li><li data-counter="61."><p id="ref-CR61">Pei, J. et al. Towards artificial general intelligence with hybrid Tianjic chip architecture. <i>Nature</i> <b>572</b>, 106–111 (2019).</p><p><a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="ads reference" href="http://adsabs.harvard.edu/cgi-bin/nph-data_query?link_type=ABSTRACT&amp;bibcode=2019Natur.572..106P" aria-label="ADS reference 61">ADS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="cas reference" href="https://donnywinston.com/articles/cas-redirect/1:CAS:528:DC%2BC1MXhsFShu7bF" aria-label="CAS reference 61">CAS</a> 
    <a data-track="click" data-track-label="link" rel="nofollow noopener" data-track-action="article reference" href="https://doi.org/10.1038%2Fs41586-019-1424-8" aria-label="Article reference 61">Article</a> 
    <a data-track="click" data-track-action="google scholar reference" data-track-label="link" rel="nofollow noopener" aria-label="Google Scholar reference 61" href="http://scholar.google.com/scholar_lookup?&amp;title=Towards%20artificial%20general%20intelligence%20with%20hybrid%20Tianjic%20chip%20architecture&amp;journal=Nature&amp;volume=572&amp;pages=106-111&amp;publication_year=2019&amp;author=Pei%2CJ">
                    Google Scholar</a> 
                </p></li><li data-counter="62."><p id="ref-CR62">Murmann, B. <i>ADC Performance Survey 1997–2021</i> (2021); <a href="https://web.stanford.edu/~murmann/adcsurvey.html">https://web.stanford.edu/~murmann/adcsurvey.html</a></p></li></ol><p><a data-track="click" data-track-action="download citation references" data-track-label="link" href="https://citation-needed.springer.com/v2/references/10.1038/s41586-022-04992-8?format=refman&amp;flavour=references">Download references<svg width="16" height="16" focusable="false" role="img" aria-hidden="true"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-download"></use></svg></a></p></div></div></div></section></div><section data-title="Acknowledgements"><div id="Ack1-section"><h2 id="Ack1">Acknowledgements</h2><p>This work is supported in part by NSF Expeditions in Computing (Penn State, award number 1317470), the Office of Naval Research (Science of AI program), the SRC JUMP ASCENT Center, Stanford SystemX Alliance, Stanford NMTRI, Beijing Innovation Center for Future Chips, National Natural Science Foundation of China (61851404), and Western Digital Corporation.</p></div></section><section aria-labelledby="author-information" data-title="Author information"><div id="author-information-section"><h2 id="author-information">Author information</h2><div id="author-information-content"><h3 id="affiliations">Authors and Affiliations</h3><ol><li id="Aff1"><p>Stanford University, Stanford, CA, USA</p><p>Weier Wan, Sukru Burc Eryilmaz, Priyanka Raina &amp; H.-S. Philip Wong</p></li><li id="Aff2"><p>University of California San Diego, La Jolla, CA, USA</p><p>Weier Wan, Rajkumar Kubendran, Stephen Deiss, Siddharth Joshi &amp; Gert Cauwenberghs</p></li><li id="Aff3"><p>University of Pittsburgh, Pittsburgh, PA, USA</p><p>Rajkumar Kubendran</p></li><li id="Aff4"><p>University of Notre Dame, Notre Dame, IN, USA</p><p>Clemens Schaefer &amp; Siddharth Joshi</p></li><li id="Aff5"><p>Tsinghua University, Beijing, China</p><p>Wenqiang Zhang, Dabin Wu, He Qian, Bin Gao &amp; Huaqiang Wu</p></li></ol><h3 id="contributions">Contributions</h3><p>W.W., R.K., S.B.E., S.J., H.-S.P.W. and G.C. designed the NeuRRAM chip architecture and circuits. W.W., S.B.E., W.Z. and D.W. implemented physical layout of the chip. W.Z., H.Q., B.G. and H.W. contributed to the RRAM device fabrication and integration with CMOS. W.W., R.K., S.D. and G.C. developed the test system. W.W. developed the software toolchain, implemented the AI models on the chip and conducted all chip measurements. W.W., C.S. and S.J. worked on the development of AI models. W.W., R.K., C.S., P.R., S.J., H.-S.P.W. and G.C. contributed to the experiment design and analysis and interpretation of the measurements. B.G., S.J., H.W., H.-S.P.W. and G.C. supervised the project. All authors contributed to the writing and editing of the manuscript.</p><h3 id="corresponding-author">Corresponding authors</h3><p id="corresponding-author-list">Correspondence to
                <a id="corresp-c1" href="mailto:weierwan@stanford.edu">Weier Wan</a>, <a id="corresp-c2" href="mailto:gaob1@tsinghua.edu.cn">Bin Gao</a>, <a id="corresp-c3" href="mailto:sjoshi2@nd.edu">Siddharth Joshi</a>, <a id="corresp-c4" href="mailto:wuhq@tsinghua.edu.cn">Huaqiang Wu</a>, <a id="corresp-c5" href="mailto:hspwong@stanford.edu">H.-S. Philip Wong</a> or <a id="corresp-c6" href="mailto:gert@ucsd.edu">Gert Cauwenberghs</a>.</p></div></div></section><section data-title="Ethics declarations"><div id="ethics-section"><h2 id="ethics">Ethics declarations</h2><div id="ethics-content">
              
                <h3 id="FPar2">Competing interests</h3>
                <p>The authors declare no competing interests.</p>
              
            </div></div></section><section data-title="Peer review"><div id="peer-review-section"><h2 id="peer-review">Peer review</h2><div id="peer-review-content">
              
              
                <h3 id="FPar1">Peer review information</h3>
                <p><i>Nature</i> thanks Matthew Marinella and the other, anonymous, reviewer(s) for their contribution to the peer review of this work.</p>
              
            </div></div></section><section data-title="Additional information"><div id="additional-information-section"><h2 id="additional-information">Additional information</h2><p><b>Publisher’s note</b> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></div></section><section data-title="Extended data figures and tables"><div id="Sec19-section"><h2 id="Sec19">Extended data figures and tables</h2><div id="Sec19-content"><div data-test="supplementary-info"><div data-test="supp-item" id="Fig6"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/6" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig6_ESM.jpg">Extended Data Fig. 1 Peripheral driver circuits for TNSA and chip operating modes.</a></h3><p><b>a</b>, driver circuits’ configuration under the weight-programming mode. <b>b</b>, under the neuron-testing mode. <b>c</b>, under the MVM mode. <b>d</b>, circuit diagram of the two counter-propagating LFSR chains XORed to generate pseudo-random sequences for probabilistic sampling.</p></div><div data-test="supp-item" id="Fig7"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/7" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig7_ESM.jpg">Extended Data Fig. 2 Various MVM dataflow directions and their CIM implementations.</a></h3><p>Left, various MVM dataflow directions commonly seen in different AI models. Middle, conventional CIM implementation of various dataflow directions. Conventional designs typically locate all peripheral circuits such as ADCs outside of RRAM array. The resulting implementations of bidirectional and recurrent MVMs incur overheads in area, latency, and energy. Right, the Transposable Neurosynaptic Array (TNSA) interleaves RRAM weights and CMOS neurons across the array and supports diverse MVM directions with minimal overhead.</p></div><div data-test="supp-item" id="Fig8"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/8" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig8_ESM.jpg">Extended Data Fig. 3 Iterative write–verify RRAM programming.</a></h3><p><b>a</b>, Flowchart of the incremental-pulse write–verify technique to program RRAMs into target analogue conductance range. <b>b</b>, An example sequence of the write–verify programming. <b>c</b>, RRAM conductance distribution measured during and after the write–verify programming. Each blue dot represents one RRAM cell measured during write–verify. The grey shades show that the RRAM conductance relaxation cause the distribution to spread out from the target values. The darker shade shows that the iterative programming helps narrow the distribution. <b>d</b>, Standard deviation of conductance change measured at different initial conductance states and different time duration after the initial programming. The initial conductance relaxation happens at a faster rate than longer term retention degradation. <b>e</b>, Standard deviation of conductance relaxation decreases with increasing iterative programming cycles. <b>f</b>, Distribution of the number of SET/RESET pulses needed to reach conductance acceptance range.</p></div><div data-test="supp-item" id="Fig9"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/9" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig9_ESM.jpg">Extended Data Fig. 4 4 basic neuron operations that enable MVM with multi-bit inputs and outputs.</a></h3><p><b>a</b>, Initialization, precharge sampling capacitor <i>C</i><sub><i>sample</i></sub> and output wires (SLs), and discharge integration capacitor <i>C</i><sub><i>integ</i></sub>. <b>b</b>, Sampling and integration, sample SL voltage onto <i>C</i><sub><i>sample</i></sub>, followed by integrating the charge onto <i>C</i><sub><i>integ</i></sub>. <b>c</b>, Comparison and readout. The amplifier is turned into comparator mode to determine the polarity of the integrated voltage. Comparator outputs are written out of the neuron through the outer feedback loop. <b>d</b>, Charge decrement, charge is added or subtracted on <i>C</i><sub><i>integ</i></sub> through the outer feedback loop, depending on value stored in the latch.</p></div><div data-test="supp-item" id="Fig10"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/10" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig10_ESM.jpg">Extended Data Fig. 5 Scatter plots of measured MVMs vs. ideal MVMs.</a></h3><p>Results in a-d are generated using the same 64×64 normally distributed random matrix and 1000 uniformed distributed floating-point vectors ϵ [-1, 1]. <b>a</b>, Forward MVM using differential input scheme with inputs quantized to 4-bit and outputs 6-bit. <b>b</b>, Backward MVM using differential output scheme. The higher RMSE is caused by more voltage drop on each SL driver that needs to drive 128 RRAM cells, compared to 64 cells driven by each BL driver during forward MVM. <b>c</b>, MVM root-mean-square error (RMSE) does not reduce when increasing input from 4-bit (a) to 6-bit. This is caused by using a lower input voltage that leads to worse signal-to-noise-ratio. <b>d</b>, 2-phase operation reduces MVM RMSE with 6-bit input by breaking inputs into 2 segments and performing MVMs separately, such that input voltage does not need to be reduced. <b>e–f</b>, Outputs from conv15 layer of ResNet-20. Weights of conv15 are divided to 3 CIM cores. Layer outputs show a higher RMSE when performing MVM in parallel on the 3 cores (f) than sequentially on the 3 cores (e).</p></div><div data-test="supp-item" id="Fig11"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/11" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig11_ESM.jpg">Extended Data Fig. 6 Data distribution with and without model-driven chip calibration.</a></h3><p>Left, Distribution of inputs to the final fully connected layer of ResNet-20 when the inputs are generated from (top-to-bottom) CIFAR-10 test-set data, training-set data, and random uniform data. Right, Distribution of outputs from the final fully connected layer of ResNet-20. The test-set and training-set have similar distributions while random uniform data produces a markedly different output distribution. To ensure that the MVM output voltage dynamic range during testing is calibrated to occupy the full ADC input swing, the calibration data should come from training-set data that closely resembles the test-set data.</p></div><div data-test="supp-item" id="Fig12"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/12" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig12_ESM.jpg">Extended Data Fig. 7 Noise-resilient training of CNNs, LSTMs and RBMs.</a></h3><p><b>a</b>, Change in CIFAR-10 test-set classification accuracy under different weight noise levels during inference. Noise is represented as fraction of the maximum absolute value of weights. Different curves represent models trained at different levels of noise injection. <b>b</b>, Change in voice command recognition accuracy with weight noise levels. <b>c</b>, Change in MNIST image-reconstruction error with weight noise levels. <b>d</b>, Decreasing of image-reconstruction error with Gibbs sampling steps during RBM inference. <b>e</b>, Differences in weight distributions when trained without and with noise injection.</p></div><div data-test="supp-item" id="Fig13"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/13" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig13_ESM.jpg">Extended Data Fig. 8 Measured chip inference performance.</a></h3><p><b>a</b>, CIFAR-10 training-set accuracy loss due to hardware non-idealities, and accuracy recovery at each step of the chip-in-the-loop progressive fine-tuning. From left to right, each data point represents a new layer programmed onto the chip. The blue solid lines represent the accuracy loss measured when performing inference of that layer on-chip. The red dotted lines represent the measured recovery in accuracy by fine-tuning subsequent layers. <b>b</b>, Ablation study showing the impacts of input, activation, and weight quantizations, and weight noise injection on inference errors.</p></div><div data-test="supp-item" id="Fig14"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/14" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig14_ESM.jpg">Extended Data Fig. 9 Implementation of various AI models.</a></h3><p><b>a</b>, Architecture of ResNet-20 for CIFAR-10 classification. <b>b</b>, The batch normalization parameters are merged into convolutional weights and biases before mapping on-chip. <b>c</b>, Illustration of the process to map 4-dimensional weights of a convolutional layer to NeuRRAM CIM cores. <b>d</b>, Architecture of the LSTM model used for Google speech command recognition. The model contains 4 parallel LSTM cells and makes predictions based on the sum of outputs from the 4 cells. <b>e</b>, Architecture of the RBM model used for MNIST image recovery. During inference, MVMs and Gibbs sampling are performed back and-forth between visible and hidden neurons. <b>f</b>, Process to map RBM on NeuRRAM CIM cores. Adjacent pixels are assigned to different cores to equalize the MVM output dynamic range at different cores.</p></div><div data-test="supp-item" id="Fig15"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/15" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig15_ESM.jpg">Extended Data Fig. 10 Chip-measured image recovery using RBM.</a></h3><p>Top: Recovery of MNIST test-set images with randomly selected 20% of pixels flipped to complementary intensity. Bottom: Recovery of MNIST test-set images with bottom 1/3 of pixels occluded.</p></div><div data-test="supp-item" id="Fig16"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/16" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig16_ESM.jpg">Extended Data Fig. 11 NeuRRAM test system and chip micrographs at various scales.</a></h3><p><b>a</b>, A NeuRRAM chip wire-bonded to a package. <b>b</b>, Measurement board that connects a packaged NeuRRAM chip (left) to a field-programmable gate array (FPGA, right). The board houses all the components necessary to power, operate and measure the chip. No external lab equipment is needed for the chip operations. <b>c</b>, Micrograph of a 48-core NeuRRAM chip. <b>d</b>, Zoomed-in micrograph of a single CIM core. <b>e</b>, Zoomed-in micrograph of 2×2 corelets within the TNSA. One neuron circuit occupies 1270 μm<sup>2</sup>, which is &gt;100× smaller than most ADC designs in 130-nm summarized in an ADC survey<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 62" title="Murmann, B. ADC Performance Survey 1997–2021 (2021); 
                  https://web.stanford.edu/~murmann/adcsurvey.html
                  
                " href="https://donnywinston.com/articles/s41586-022-04992-8#ref-CR62" id="ref-link-section-d163879637e3661">62</a></sup>. <b>f</b>, Chip area breakdown.</p></div><div data-test="supp-item" id="Fig17"><h3><a data-track="click" data-track-action="view supplementary info" data-track-label="link" data-test="supp-info-link" href="https://donnywinston.com/articles/s41586-022-04992-8/figures/17" data-supp-info-image="//media.springernature.com/lw685/springer-static/esm/art%3A10.1038%2Fs41586-022-04992-8/MediaObjects/41586_2022_4992_Fig17_ESM.jpg">Extended Data Fig. 12 Energy consumption, latency, and throughput measurement results.</a></h3><p><b>a</b>, Measured energy consumption per operation during the MVM input stage (without 2-phase operation) and output stage, where one multiply–accumulate (MAC) counts as two operations. <b>b</b>, Energy consumption breakdown at various MVM input and output bit-precisions. Outputs are 2-bit higher than inputs during a MVM to account for additional precision requirements from partial-sum accumulation. <b>c</b>, Latency for performing one MVM with 256×256 weight matrix. <b>d</b>, Peak computational throughput (in giga-operations per second). <b>e</b>, Throughput-power efficiency (in tera-operations per watt).</p></div><div data-test="supp-item"><div data-test="inline-table" data-container-section="table" id="table-2"><figure><figcaption><b id="Tab2" data-test="table-caption">Extended Data Table 1 Comparison of fully integrated RRAM-based CIM hardware</b></figcaption></figure></div></div><div data-test="supp-item"><div data-test="inline-table" data-container-section="table" id="table-3"><figure><figcaption><b id="Tab3" data-test="table-caption">Extended Data Table 2 Comparison with digital CMOS AI inference accelerators</b></figcaption></figure></div></div></div></div></div></section><section data-title="Rights and permissions"><div id="rightslink-section"><h2 id="rightslink">Rights and permissions</h2><div id="rightslink-content">
                <p><b>Open Access</b>  This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">http://creativecommons.org/licenses/by/4.0/</a>.</p>
              <p><a data-track="click" data-track-action="view rights and permissions" data-track-label="link" href="https://s100.copyright.com/AppDispatchServlet?title=A%20compute-in-memory%20chip%20based%20on%20resistive%20random-access%20memory&amp;author=Weier%20Wan%20et%20al&amp;contentID=10.1038%2Fs41586-022-04992-8&amp;copyright=The%20Author%28s%29&amp;publication=0028-0836&amp;publicationDate=2022-08-17&amp;publisherName=SpringerNature&amp;orderBeanReset=true&amp;oa=CC%20BY">Reprints and Permissions</a></p></div></div></section><section aria-labelledby="article-info" data-title="About this article"><div id="article-info-section"><h2 id="article-info">About this article</h2><div id="article-info-content"><div><p><a data-crossmark="10.1038/s41586-022-04992-8" target="_blank" rel="noopener" href="https://crossmark.crossref.org/dialog/?doi=10.1038/s41586-022-04992-8" data-track="click" data-track-action="Click Crossmark" data-track-label="link" data-test="crossmark"><img width="57" height="81" alt="Verify currency and authenticity via CrossMark" src="data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjgxIiB3aWR0aD0iNTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJtMTcuMzUgMzUuNDUgMjEuMy0xNC4ydi0xNy4wM2gtMjEuMyIgZmlsbD0iIzk4OTg5OCIvPjxwYXRoIGQ9Im0zOC42NSAzNS40NS0yMS4zLTE0LjJ2LTE3LjAzaDIxLjMiIGZpbGw9IiM3NDc0NzQiLz48cGF0aCBkPSJtMjggLjVjLTEyLjk4IDAtMjMuNSAxMC41Mi0yMy41IDIzLjVzMTAuNTIgMjMuNSAyMy41IDIzLjUgMjMuNS0xMC41MiAyMy41LTIzLjVjMC02LjIzLTIuNDgtMTIuMjEtNi44OC0xNi42Mi00LjQxLTQuNC0xMC4zOS02Ljg4LTE2LjYyLTYuODh6bTAgNDEuMjVjLTkuOCAwLTE3Ljc1LTcuOTUtMTcuNzUtMTcuNzVzNy45NS0xNy43NSAxNy43NS0xNy43NSAxNy43NSA3Ljk1IDE3Ljc1IDE3Ljc1YzAgNC43MS0xLjg3IDkuMjItNS4yIDEyLjU1cy03Ljg0IDUuMi0xMi41NSA1LjJ6IiBmaWxsPSIjNTM1MzUzIi8+PHBhdGggZD0ibTQxIDM2Yy01LjgxIDYuMjMtMTUuMjMgNy40NS0yMi40MyAyLjktNy4yMS00LjU1LTEwLjE2LTEzLjU3LTcuMDMtMjEuNWwtNC45Mi0zLjExYy00Ljk1IDEwLjctMS4xOSAyMy40MiA4Ljc4IDI5LjcxIDkuOTcgNi4zIDIzLjA3IDQuMjIgMzAuNi00Ljg2eiIgZmlsbD0iIzljOWM5YyIvPjxwYXRoIGQ9Im0uMiA1OC40NWMwLS43NS4xMS0xLjQyLjMzLTIuMDFzLjUyLTEuMDkuOTEtMS41Yy4zOC0uNDEuODMtLjczIDEuMzQtLjk0LjUxLS4yMiAxLjA2LS4zMiAxLjY1LS4zMi41NiAwIDEuMDYuMTEgMS41MS4zNS40NC4yMy44MS41IDEuMS44MWwtLjkxIDEuMDFjLS4yNC0uMjQtLjQ5LS40Mi0uNzUtLjU2LS4yNy0uMTMtLjU4LS4yLS45My0uMi0uMzkgMC0uNzMuMDgtMS4wNS4yMy0uMzEuMTYtLjU4LjM3LS44MS42Ni0uMjMuMjgtLjQxLjYzLS41MyAxLjA0LS4xMy40MS0uMTkuODgtLjE5IDEuMzkgMCAxLjA0LjIzIDEuODYuNjggMi40Ni40NS41OSAxLjA2Ljg4IDEuODQuODguNDEgMCAuNzctLjA3IDEuMDctLjIzcy41OS0uMzkuODUtLjY4bC45MSAxYy0uMzguNDMtLjguNzYtMS4yOC45OS0uNDcuMjItMSAuMzQtMS41OC4zNC0uNTkgMC0xLjEzLS4xLTEuNjQtLjMxLS41LS4yLS45NC0uNTEtMS4zMS0uOTEtLjM4LS40LS42Ny0uOS0uODgtMS40OC0uMjItLjU5LS4zMy0xLjI2LS4zMy0yLjAyem04LjQtNS4zM2gxLjYxdjIuNTRsLS4wNSAxLjMzYy4yOS0uMjcuNjEtLjUxLjk2LS43MnMuNzYtLjMxIDEuMjQtLjMxYy43MyAwIDEuMjcuMjMgMS42MS43MS4zMy40Ny41IDEuMTQuNSAyLjAydjQuMzFoLTEuNjF2LTQuMWMwLS41Ny0uMDgtLjk3LS4yNS0xLjIxLS4xNy0uMjMtLjQ1LS4zNS0uODMtLjM1LS4zIDAtLjU2LjA4LS43OS4yMi0uMjMuMTUtLjQ5LjM2LS43OC42NHY0LjhoLTEuNjF6bTcuMzcgNi40NWMwLS41Ni4wOS0xLjA2LjI2LTEuNTEuMTgtLjQ1LjQyLS44My43MS0xLjE0LjI5LS4zLjYzLS41NCAxLjAxLS43MS4zOS0uMTcuNzgtLjI1IDEuMTgtLjI1LjQ3IDAgLjg4LjA4IDEuMjMuMjQuMzYuMTYuNjUuMzguODkuNjdzLjQyLjYzLjU0IDEuMDNjLjEyLjQxLjE4Ljg0LjE4IDEuMzIgMCAuMzItLjAyLjU3LS4wNy43NmgtNC4zNmMuMDcuNjIuMjkgMS4xLjY1IDEuNDQuMzYuMzMuODIuNSAxLjM4LjUuMjkgMCAuNTctLjA0LjgzLS4xM3MuNTEtLjIxLjc2LS4zN2wuNTUgMS4wMWMtLjMzLjIxLS42OS4zOS0xLjA5LjUzLS40MS4xNC0uODMuMjEtMS4yNi4yMS0uNDggMC0uOTItLjA4LTEuMzQtLjI1LS40MS0uMTYtLjc2LS40LTEuMDctLjctLjMxLS4zMS0uNTUtLjY5LS43Mi0xLjEzLS4xOC0uNDQtLjI2LS45NS0uMjYtMS41MnptNC42LS42MmMwLS41NS0uMTEtLjk4LS4zNC0xLjI4LS4yMy0uMzEtLjU4LS40Ny0xLjA2LS40Ny0uNDEgMC0uNzcuMTUtMS4wNy40NS0uMzEuMjktLjUuNzMtLjU4IDEuM3ptMi41LjYyYzAtLjU3LjA5LTEuMDguMjgtMS41My4xOC0uNDQuNDMtLjgyLjc1LTEuMTNzLjY5LS41NCAxLjEtLjcxYy40Mi0uMTYuODUtLjI0IDEuMzEtLjI0LjQ1IDAgLjg0LjA4IDEuMTcuMjNzLjYxLjM0Ljg1LjU3bC0uNzcgMS4wMmMtLjE5LS4xNi0uMzgtLjI4LS41Ni0uMzctLjE5LS4wOS0uMzktLjE0LS42MS0uMTQtLjU2IDAtMS4wMS4yMS0xLjM1LjYzLS4zNS40MS0uNTIuOTctLjUyIDEuNjcgMCAuNjkuMTcgMS4yNC41MSAxLjY2LjM0LjQxLjc4LjYyIDEuMzIuNjIuMjggMCAuNTQtLjA2Ljc4LS4xNy4yNC0uMTIuNDUtLjI2LjY0LS40MmwuNjcgMS4wM2MtLjMzLjI5LS42OS41MS0xLjA4LjY1LS4zOS4xNS0uNzguMjMtMS4xOC4yMy0uNDYgMC0uOS0uMDgtMS4zMS0uMjQtLjQtLjE2LS43NS0uMzktMS4wNS0uN3MtLjUzLS42OS0uNy0xLjEzYy0uMTctLjQ1LS4yNS0uOTYtLjI1LTEuNTN6bTYuOTEtNi40NWgxLjU4djYuMTdoLjA1bDIuNTQtMy4xNmgxLjc3bC0yLjM1IDIuOCAyLjU5IDQuMDdoLTEuNzVsLTEuNzctMi45OC0xLjA4IDEuMjN2MS43NWgtMS41OHptMTMuNjkgMS4yN2MtLjI1LS4xMS0uNS0uMTctLjc1LS4xNy0uNTggMC0uODcuMzktLjg3IDEuMTZ2Ljc1aDEuMzR2MS4yN2gtMS4zNHY1LjZoLTEuNjF2LTUuNmgtLjkydi0xLjJsLjkyLS4wN3YtLjcyYzAtLjM1LjA0LS42OC4xMy0uOTguMDgtLjMxLjIxLS41Ny40LS43OXMuNDItLjM5LjcxLS41MWMuMjgtLjEyLjYzLS4xOCAxLjA0LS4xOC4yNCAwIC40OC4wMi42OS4wNy4yMi4wNS40MS4xLjU3LjE3em0uNDggNS4xOGMwLS41Ny4wOS0xLjA4LjI3LTEuNTMuMTctLjQ0LjQxLS44Mi43Mi0xLjEzLjMtLjMxLjY1LS41NCAxLjA0LS43MS4zOS0uMTYuOC0uMjQgMS4yMy0uMjRzLjg0LjA4IDEuMjQuMjRjLjQuMTcuNzQuNCAxLjA0Ljcxcy41NC42OS43MiAxLjEzYy4xOS40NS4yOC45Ni4yOCAxLjUzcy0uMDkgMS4wOC0uMjggMS41M2MtLjE4LjQ0LS40Mi44Mi0uNzIgMS4xM3MtLjY0LjU0LTEuMDQuNy0uODEuMjQtMS4yNC4yNC0uODQtLjA4LTEuMjMtLjI0LS43NC0uMzktMS4wNC0uN2MtLjMxLS4zMS0uNTUtLjY5LS43Mi0xLjEzLS4xOC0uNDUtLjI3LS45Ni0uMjctMS41M3ptMS42NSAwYzAgLjY5LjE0IDEuMjQuNDMgMS42Ni4yOC40MS42OC42MiAxLjE4LjYyLjUxIDAgLjktLjIxIDEuMTktLjYyLjI5LS40Mi40NC0uOTcuNDQtMS42NiAwLS43LS4xNS0xLjI2LS40NC0xLjY3LS4yOS0uNDItLjY4LS42My0xLjE5LS42My0uNSAwLS45LjIxLTEuMTguNjMtLjI5LjQxLS40My45Ny0uNDMgMS42N3ptNi40OC0zLjQ0aDEuMzNsLjEyIDEuMjFoLjA1Yy4yNC0uNDQuNTQtLjc5Ljg4LTEuMDIuMzUtLjI0LjctLjM2IDEuMDctLjM2LjMyIDAgLjU5LjA1Ljc4LjE0bC0uMjggMS40LS4zMy0uMDljLS4xMS0uMDEtLjIzLS4wMi0uMzgtLjAyLS4yNyAwLS41Ni4xLS44Ni4zMXMtLjU1LjU4LS43NyAxLjF2NC4yaC0xLjYxem0tNDcuODcgMTVoMS42MXY0LjFjMCAuNTcuMDguOTcuMjUgMS4yLjE3LjI0LjQ0LjM1LjgxLjM1LjMgMCAuNTctLjA3LjgtLjIyLjIyLS4xNS40Ny0uMzkuNzMtLjczdi00LjdoMS42MXY2Ljg3aC0xLjMybC0uMTItMS4wMWgtLjA0Yy0uMy4zNi0uNjMuNjQtLjk4Ljg2LS4zNS4yMS0uNzYuMzItMS4yNC4zMi0uNzMgMC0xLjI3LS4yNC0xLjYxLS43MS0uMzMtLjQ3LS41LTEuMTQtLjUtMi4wMnptOS40NiA3LjQzdjIuMTZoLTEuNjF2LTkuNTloMS4zM2wuMTIuNzJoLjA1Yy4yOS0uMjQuNjEtLjQ1Ljk3LS42My4zNS0uMTcuNzItLjI2IDEuMS0uMjYuNDMgMCAuODEuMDggMS4xNS4yNC4zMy4xNy42MS40Ljg0LjcxLjI0LjMxLjQxLjY4LjUzIDEuMTEuMTMuNDIuMTkuOTEuMTkgMS40NCAwIC41OS0uMDkgMS4xMS0uMjUgMS41Ny0uMTYuNDctLjM4Ljg1LS42NSAxLjE2LS4yNy4zMi0uNTguNTYtLjk0LjczLS4zNS4xNi0uNzIuMjUtMS4xLjI1LS4zIDAtLjYtLjA3LS45LS4ycy0uNTktLjMxLS44Ny0uNTZ6bTAtMi4zYy4yNi4yMi41LjM3LjczLjQ1LjI0LjA5LjQ2LjEzLjY2LjEzLjQ2IDAgLjg0LS4yIDEuMTUtLjYuMzEtLjM5LjQ2LS45OC40Ni0xLjc3IDAtLjY5LS4xMi0xLjIyLS4zNS0xLjYxLS4yMy0uMzgtLjYxLS41Ny0xLjEzLS41Ny0uNDkgMC0uOTkuMjYtMS41Mi43N3ptNS44Ny0xLjY5YzAtLjU2LjA4LTEuMDYuMjUtMS41MS4xNi0uNDUuMzctLjgzLjY1LTEuMTQuMjctLjMuNTgtLjU0LjkzLS43MXMuNzEtLjI1IDEuMDgtLjI1Yy4zOSAwIC43My4wNyAxIC4yLjI3LjE0LjU0LjMyLjgxLjU1bC0uMDYtMS4xdi0yLjQ5aDEuNjF2OS44OGgtMS4zM2wtLjExLS43NGgtLjA2Yy0uMjUuMjUtLjU0LjQ2LS44OC42NC0uMzMuMTgtLjY5LjI3LTEuMDYuMjctLjg3IDAtMS41Ni0uMzItMi4wNy0uOTVzLS43Ni0xLjUxLS43Ni0yLjY1em0xLjY3LS4wMWMwIC43NC4xMyAxLjMxLjQgMS43LjI2LjM4LjY1LjU4IDEuMTUuNTguNTEgMCAuOTktLjI2IDEuNDQtLjc3di0zLjIxYy0uMjQtLjIxLS40OC0uMzYtLjctLjQ1LS4yMy0uMDgtLjQ2LS4xMi0uNy0uMTItLjQ1IDAtLjgyLjE5LTEuMTMuNTktLjMxLjM5LS40Ni45NS0uNDYgMS42OHptNi4zNSAxLjU5YzAtLjczLjMyLTEuMy45Ny0xLjcxLjY0LS40IDEuNjctLjY4IDMuMDgtLjg0IDAtLjE3LS4wMi0uMzQtLjA3LS41MS0uMDUtLjE2LS4xMi0uMy0uMjItLjQzcy0uMjItLjIyLS4zOC0uM2MtLjE1LS4wNi0uMzQtLjEtLjU4LS4xLS4zNCAwLS42OC4wNy0xIC4ycy0uNjMuMjktLjkzLjQ3bC0uNTktMS4wOGMuMzktLjI0LjgxLS40NSAxLjI4LS42My40Ny0uMTcuOTktLjI2IDEuNTQtLjI2Ljg2IDAgMS41MS4yNSAxLjkzLjc2cy42MyAxLjI1LjYzIDIuMjF2NC4wN2gtMS4zMmwtLjEyLS43NmgtLjA1Yy0uMy4yNy0uNjMuNDgtLjk4LjY2cy0uNzMuMjctMS4xNC4yN2MtLjYxIDAtMS4xLS4xOS0xLjQ4LS41Ni0uMzgtLjM2LS41Ny0uODUtLjU3LTEuNDZ6bTEuNTctLjEyYzAgLjMuMDkuNTMuMjcuNjcuMTkuMTQuNDIuMjEuNzEuMjEuMjggMCAuNTQtLjA3Ljc3LS4ycy40OC0uMzEuNzMtLjU2di0xLjU0Yy0uNDcuMDYtLjg2LjEzLTEuMTguMjMtLjMxLjA5LS41Ny4xOS0uNzYuMzFzLS4zMy4yNS0uNDEuNGMtLjA5LjE1LS4xMy4zMS0uMTMuNDh6bTYuMjktMy42M2gtLjk4di0xLjJsMS4wNi0uMDcuMi0xLjg4aDEuMzR2MS44OGgxLjc1djEuMjdoLTEuNzV2My4yOGMwIC44LjMyIDEuMi45NyAxLjIuMTIgMCAuMjQtLjAxLjM3LS4wNC4xMi0uMDMuMjQtLjA3LjM0LS4xMWwuMjggMS4xOWMtLjE5LjA2LS40LjEyLS42NC4xNy0uMjMuMDUtLjQ5LjA4LS43Ni4wOC0uNCAwLS43NC0uMDYtMS4wMi0uMTgtLjI3LS4xMy0uNDktLjMtLjY3LS41Mi0uMTctLjIxLS4zLS40OC0uMzctLjc4LS4wOC0uMy0uMTItLjY0LS4xMi0xLjAxem00LjM2IDIuMTdjMC0uNTYuMDktMS4wNi4yNy0xLjUxcy40MS0uODMuNzEtMS4xNGMuMjktLjMuNjMtLjU0IDEuMDEtLjcxLjM5LS4xNy43OC0uMjUgMS4xOC0uMjUuNDcgMCAuODguMDggMS4yMy4yNC4zNi4xNi42NS4zOC44OS42N3MuNDIuNjMuNTQgMS4wM2MuMTIuNDEuMTguODQuMTggMS4zMiAwIC4zMi0uMDIuNTctLjA3Ljc2aC00LjM3Yy4wOC42Mi4yOSAxLjEuNjUgMS40NC4zNi4zMy44Mi41IDEuMzguNS4zIDAgLjU4LS4wNC44NC0uMTMuMjUtLjA5LjUxLS4yMS43Ni0uMzdsLjU0IDEuMDFjLS4zMi4yMS0uNjkuMzktMS4wOS41M3MtLjgyLjIxLTEuMjYuMjFjLS40NyAwLS45Mi0uMDgtMS4zMy0uMjUtLjQxLS4xNi0uNzctLjQtMS4wOC0uNy0uMy0uMzEtLjU0LS42OS0uNzItMS4xMy0uMTctLjQ0LS4yNi0uOTUtLjI2LTEuNTJ6bTQuNjEtLjYyYzAtLjU1LS4xMS0uOTgtLjM0LTEuMjgtLjIzLS4zMS0uNTgtLjQ3LTEuMDYtLjQ3LS40MSAwLS43Ny4xNS0xLjA4LjQ1LS4zMS4yOS0uNS43My0uNTcgMS4zem0zLjAxIDIuMjNjLjMxLjI0LjYxLjQzLjkyLjU3LjMuMTMuNjMuMi45OC4yLjM4IDAgLjY1LS4wOC44My0uMjNzLjI3LS4zNS4yNy0uNmMwLS4xNC0uMDUtLjI2LS4xMy0uMzctLjA4LS4xLS4yLS4yLS4zNC0uMjgtLjE0LS4wOS0uMjktLjE2LS40Ny0uMjNsLS41My0uMjJjLS4yMy0uMDktLjQ2LS4xOC0uNjktLjMtLjIzLS4xMS0uNDQtLjI0LS42Mi0uNHMtLjMzLS4zNS0uNDUtLjU1Yy0uMTItLjIxLS4xOC0uNDYtLjE4LS43NSAwLS42MS4yMy0xLjEuNjgtMS40OS40NC0uMzggMS4wNi0uNTcgMS44My0uNTcuNDggMCAuOTEuMDggMS4yOS4yNXMuNzEuMzYuOTkuNTdsLS43NC45OGMtLjI0LS4xNy0uNDktLjMyLS43My0uNDItLjI1LS4xMS0uNTEtLjE2LS43OC0uMTYtLjM1IDAtLjYuMDctLjc2LjIxLS4xNy4xNS0uMjUuMzMtLjI1LjU0IDAgLjE0LjA0LjI2LjEyLjM2cy4xOC4xOC4zMS4yNmMuMTQuMDcuMjkuMTQuNDYuMjFsLjU0LjE5Yy4yMy4wOS40Ny4xOC43LjI5cy40NC4yNC42NC40Yy4xOS4xNi4zNC4zNS40Ni41OC4xMS4yMy4xNy41LjE3LjgyIDAgLjMtLjA2LjU4LS4xNy44My0uMTIuMjYtLjI5LjQ4LS41MS42OC0uMjMuMTktLjUxLjM0LS44NC40NS0uMzQuMTEtLjcyLjE3LTEuMTUuMTctLjQ4IDAtLjk1LS4wOS0xLjQxLS4yNy0uNDYtLjE5LS44Ni0uNDEtMS4yLS42OHoiIGZpbGw9IiM1MzUzNTMiLz48L2c+PC9zdmc+"/></a></p><div><h3 id="citeas">Cite this article</h3><p>Wan, W., Kubendran, R., Schaefer, C. <i>et al.</i> A compute-in-memory chip based on resistive random-access memory.
                    <i>Nature</i> <b>608</b>, 504–512 (2022). https://doi.org/10.1038/s41586-022-04992-8</p><p><a data-test="citation-link" data-track="click" data-track-action="download article citation" data-track-label="link" data-track-external="" href="https://citation-needed.springer.com/v2/references/10.1038/s41586-022-04992-8?format=refman&amp;flavour=citation">Download citation<svg width="16" height="16" focusable="false" role="img" aria-hidden="true"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#global-icon-download"></use></svg></a></p><ul data-test="publication-history"><li><p>Received<span>: </span><span><time datetime="2021-07-27">27 July 2021</time></span></p></li><li><p>Accepted<span>: </span><span><time datetime="2022-06-17">17 June 2022</time></span></p></li><li><p>Published<span>: </span><span><time datetime="2022-08-17">17 August 2022</time></span></p></li><li><p>Issue Date<span>: </span><span><time datetime="2022-08-18">18 August 2022</time></span></p></li><li><p><abbr title="Digital Object Identifier">DOI</abbr><span>: </span><span>https://doi.org/10.1038/s41586-022-04992-8</span></p></li></ul></div></div></div></div></section>

            

            
                <section data-title="Comments"><div id="article-comments-section"><h2 id="article-comments">Comments</h2><p>By submitting a comment you agree to abide by our <a href="https://donnywinston.com/info/tandc.html">Terms</a> and <a href="https://donnywinston.com/info/community-guidelines.html">Community Guidelines</a>. If you find something abusive or that does not comply with our terms or guidelines please flag it as inappropriate.</p></div></section>
                
            

            </div></div>
  </body>
</html>
