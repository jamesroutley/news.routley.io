<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glitch.at.goth.cafe/osx-keychain-for-cli-secrets/">Original</a>
    <h1>OSX Keychain For CLI Secrets</h1>
    
    <div id="readability-page-1" class="page"><div><hr/><p><em>Important Correction</em>: 12 Jan, 2024</p><p>In the initial version of this blog, I described a method to pass the secret to the <code>security</code> command using a subshell. This is not secure, as the secret is exposed to process exploration tools such as <code>ps</code>. I have updated the blog to use a custom tool written in go to pass the secret. I wish to thank my respected peer at Recurse Center, Jacob Vosmaer, for pointing this issue out.</p><hr/><h2 id="goals">Goals</h2><p>For one of my current projects, I’m trying to create a secure way to store and access secrets such as API keys on my Mac, such that they can be accessed from bash scripts. I’m using the MacOS Keychain to store these secrets, so I decided to write about it because it is generally useful. Ideally, I would use a yubikey or something similar to store and access these secrets, but this alternative is an interesting option, and it balances security and convenience.</p><h2 id="keychain-settings-hardening-for-mac">Keychain Settings Hardening for Mac</h2><p>Before using this process I hardened the default settings for my Keychain. I want to make sure that the Keychain locks after a period of inactivity. To do this, I followed the steps below:</p><ol><li><p><strong>Open Keychain Access:</strong></p><ul><li>Open the Keychain Access application on your Mac. You can find it in the Utilities folder within your Applications folder, or you can use Spotlight to search for it.</li></ul></li><li><p><strong>Adjust Auto-Lock Settings:</strong></p><ul><li>In Keychain Access, select the “login” keychain from the list on the left side.</li><li>Go to the menu bar and choose Edit &gt; Change Settings for Keychain “login”.</li><li>Here, you can set the Keychain to lock after a certain period of inactivity. Check the “Lock after” checkbox and enter the desired number of minutes.</li><li>You can also choose to lock the Keychain when your computer goes to sleep by selecting the “Lock when sleeping” checkbox.</li><li>After adjusting these settings, click Save.</li></ul></li></ol><p>When these settings are in place, and your Keychain locks, accessing it again should prompt for your Mac login password. This is preferable to having the Keychain unlocked all the time.</p><h2 id="require-touch-id">Require Touch ID?</h2><p>Unfortunately, I haven’t found a way to require Touch ID for every use of the Keychain. I might revisit this later and write an update after contacting Apple Support. This would be an excellent feature to add to the Keychain, biometric authentication for every use on some chains? If that is not a planned feature, I will revisit this and write an update that uses a yubikey or something similar.</p><h2 id="lets-get-started">Lets Get Started</h2><h3 id="storing-and-retrieving-secrets-from-keychain">Storing And Retrieving Secrets From Keychain</h3><p>Apple provides a command-line interface to create and retrieve secrets in macOS Keychain, this is especially handy for bash scripts. It is under the <code>security</code> command as two subcommands <code>add-generic-password</code> and <code>find-generic-password</code>.</p><hr/><h4 id="to-create-a-new-secret-item">To Create A New Secret Item</h4><p>To securely store a new secret item in the keychain, normally we would use the command <code>security add-generic-password</code>. Like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>security add-generic-password -U -a <span>&#34;MyAPIUser&#34;</span> -s <span>&#34;MyAPIService&#34;</span> -w <span>&#34;thepassword&#34;</span>
</span></span></code></pre></div><p>Where:</p><ul><li><code>security add-generic-password</code>: Adds a password to the Keychain.</li><li><code>-a &#34;MyAPIUser&#34;</code>: Sets the service user name (here, “MyAPIUser”).</li><li><code>-s &#34;MyAPIService&#34;</code>: Sets the service name (here, “MyAPIService”).</li><li><code>-w &#34;thepassword&#34;</code>: Sets the password (here, “thepassword”).</li><li><code>-U</code>: Updates the item if it already exists in the keystore.</li></ul><p>But this is where things got inconvenient for me. In fact, I struggled to find a way to pass the secret to the <code>security</code> command without exposing it in the terminal history or environment.</p><p>I tried using a subshell to pass the value to <code>-w</code>, and I tried using a temporary file and redirection. But, I couldn’t get either to work in a way that didn’t expose the secret or just fail to be read by the <code>security</code> command as intended.</p><p>After the error was spotted in my initial solution, I paused, and took a step back. I realized that I could write a tool to do this. Its not as elegant as pure shell scripting, but it works. I have included the code as a gist at the end of this blog. To use the tool, you simply compile it and pass the secret inside of a file.</p><p>Here’s an example of running it:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>glitch@cafe% printf <span>&#34;a secret&#34;</span> &gt; secret.txt <span># don&#39;t do this in real life</span>
</span></span><span><span>glitch@cafe% ./keychain-tool -account <span>&#34;MyAPIUser&#34;</span> -service <span>&#34;MyAPIService&#34;</span> -file secret.txt
</span></span><span><span>Duplicate item found. Updating existing item...
</span></span></code></pre></div><hr/><h4 id="to-retrieve-the-new-secret-item">To Retrieve The New Secret Item</h4><p>When retrieving the secret, it’s crucial not to print it to the console. Instead, you should pipe the output directly to the command that requires the secret. Or pass it via an environment variable. However, make sure to unset the environment variable after use. Here is an example of retrieving the value of the secret that we stored above:</p><p>Here’s an example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>security find-generic-password -a <span>&#34;MyAPIUser&#34;</span> -s <span>&#34;MyAPIService&#34;</span> -w | &lt;command_that_needs_the_secret&gt;
</span></span></code></pre></div><p>Where:</p><ul><li><code>security find-generic-password</code>: This is a command to retrieve a stored password from the macOS Keychain.</li><li><code>-a &#34;MyAPIUser&#34;</code>: Specifies the account name associated with the password.</li><li><code>-s &#34;MyAPIService&#34;</code>: Indicates the service name for which the password is stored.</li><li><code>-w</code>: Directs the command to output only the password itself, not the entire Keychain item object.</li><li><code>|</code>: This is a pipe symbol that passes the output of the preceding command as input to another command.</li><li><code>&lt;command_that_needs_the_secret&gt;</code>: Replace this with the command that needs the API key. The key is passed directly to this command without being printed or stored in a temporary variable.</li></ul><p>This approach ensures the API key remains secure and is not exposed in the terminal history or environment.</p><hr/><h3 id="a-practical-example-ssh-key">A Practical Example (SSH Key)</h3><p>This example involves storing and retrieving an ssh private key from the keystore. The key is stored in the Keychain using our custom tool <code>keychain-tool</code>, and encoded in base64 to avoid issues with special characters.</p><p>When needed, it’s retrieved, decoded, and passed to <code>ssh-add</code> via a temporary file. The temporary file is created with <code>mktemp</code> and securely overwritten with random data after use. Clearly this is not the most secure method, but I think it is better than persistently storing the key in a file on disk. A much better method would be to use a yubikey or something similar, so that the key is completely stored in hardware.</p><h4 id="to-store-the-ssh-key">To Store The SSH Key</h4><div><pre tabindex="0"><code data-lang="bash"><span><span>glitch@cafe% cd ~/.ssh/
</span></span><span><span>glitch@cafe% base64 -i the-key.pem &gt; sshkey.b64 <span># base64 encoded ssh key</span>
</span></span><span><span>glitch@cafe% ./keychain-tool -account <span>&#34;ec2user&#34;</span> -service <span>&#34;MySSHHost&#34;</span> -file sshkey.b64
</span></span><span><span>glitch@cafe% dd <span>if</span><span>=</span>/dev/urandom of<span>=</span>sshkey.b64 bs<span>=</span><span>1</span> count<span>=</span><span>$(</span>stat -f%z sshkey.b64<span>)</span>
</span></span><span><span>glitch@cafe% rm sshkey.b64
</span></span></code></pre></div><p>Note: The <code>dd</code> command is used to securely overwrite the temporary file with random data. This is done to prevent the secret from being recovered from the disk.</p><ul><li><code>if=/dev/urandom</code>: Specifies the input file as <code>/dev/urandom</code>, which generates pseudo-random bytes.</li><li><code>of=sshkey.txt</code>: Specifies the output file where the random data will be written.</li><li><code>bs=1</code>: Sets the block size to 1 byte. This means <code>dd</code> will read and write up to 1 byte at a time.</li><li><code>count=$(stat -f%z sshkey.txt)</code>: Uses the <code>stat</code> command to get the size of <code>sshkey.txt</code> in bytes and sets this as the <code>count</code>. This tells <code>dd</code> to write only as many bytes as the size of <code>sshkey.txt</code>.</li></ul><p>The purpose of this command is to overwrite the file <code>sshkey.txt</code> with random data, effectively making the original content unrecoverable. This is often done for security reasons to securely erase sensitive data.</p><h4 id="to-retrieve-the-ssh-key-and-use-it">To Retrieve The SSH Key And Use It</h4><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Create a secure temporary file in the home directory</span>
</span></span><span><span>tmpfile<span>=</span><span>$(</span>mktemp ~/sshkey.XXXXXX<span>)</span>
</span></span><span><span>chmod <span>600</span> <span>&#34;</span>$tmpfile<span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span># Retrieve the SSH key from Keychain and decode it into the temp file</span>
</span></span><span><span>security find-generic-password -a <span>&#34;ec2user&#34;</span> -s <span>&#34;MySSHHost&#34;</span> -w | base64 --decode &gt; <span>&#34;</span>$tmpfile<span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span># Load the SSH key into ssh-agent</span>
</span></span><span><span>ssh-add <span>&#34;</span>$tmpfile<span>&#34;</span> <span># ssh-agent requires a file with restricted permissions, so we can&#39;t use and fd/pipe</span>
</span></span><span><span>
</span></span><span><span><span># Securely overwrite the temporary file with random data</span>
</span></span><span><span>dd <span>if</span><span>=</span>/dev/urandom of<span>=</span><span>&#34;</span>$tmpfile<span>&#34;</span> bs<span>=</span><span>1</span> count<span>=</span><span>$(</span>stat -f%z <span>&#34;</span>$tmpfile<span>&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># Remove the temporary file</span>
</span></span><span><span>rm <span>&#34;</span>$tmpfile<span>&#34;</span>
</span></span></code></pre></div><h4 id="to-delete-the-ssh-key-from-the-keychain">To Delete The SSH Key From The Keychain</h4><p>You may need to remove the secret. To do so, you can use the <code>security delete-generic-password</code> command. This command requires the account name and service name, which you can find using the <code>security find-generic-password</code> command. Heres an example using out ssh key from above:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>security delete-generic-password -a <span>&#34;ec2user&#34;</span> -s <span>&#34;MySSHHost&#34;</span>
</span></span></code></pre></div><hr/><h2 id="conclusion">Conclusion</h2><p>I hope this helps someone. I’m going to try to write and make more this year. Sending warmth and kindness to my reader. As always, I hope you are well.</p><hr/><h2 id="appendix">Appendix</h2><h3 id="keychain-tool">Keychain Tool</h3><h5 id="tool-code">Tool Code</h5><h5 id="to-compile">To Compile</h5><div><pre tabindex="0"><code data-lang="bash"><span><span>go mod init example.com/m/v2
</span></span><span><span>go mod tidy
</span></span><span><span>go build -o keychain-tool
</span></span></code></pre></div></div></div>
  </body>
</html>
