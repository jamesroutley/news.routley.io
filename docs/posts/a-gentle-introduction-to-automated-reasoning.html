<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning">Original</a>
    <h1>A gentle introduction to automated reasoning</h1>
    
    <div id="readability-page-1" class="page"><div>
                    
                    
                        <div>
                            
                                <div>
    
        <div><div data-align-right-narrow="">
            <div><figure>
    <p><a href="https://www.amazon.science/research-areas/automated-reasoning" data-cms-ai="0">
        <img alt="Untitled-1" width="1200" height="1200" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-src="https://assets.amazon.science/dims4/default/065717c/2147483647/strip/true/crop/1080x1080+0+0/resize/1200x1200!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2Fcd%2Fe6%2Fb043d2db4326aa895a5ed8899fd6%2Famazonscience-fullimage-automatedreasoning.jpg"/>
    </a>



        

        
    </p>

    
        <p><figcaption>The new automated-reasoning icon</figcaption></p>
    
</figure></div>
        </div><p>This week, Amazon Science added <i>automated reasoning</i> to its list of <a href="https://www.amazon.science/research-areas" data-cms-ai="0">research areas</a>. We made this change because of the impact that automated reasoning is having here at Amazon. For example, Amazon Web Services’ customers now have direct access to automated-reasoning-based features such as <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/what-is-access-analyzer.html" target="_blank" data-cms-ai="0">IAM Access Analyzer</a>, <a href="https://aws.amazon.com/blogs/aws/amazon-s3-block-public-access-another-layer-of-protection-for-your-accounts-and-buckets/" target="_blank" data-cms-ai="0">S3 Block Public Access</a>, or <a href="https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html" target="_blank" data-cms-ai="0">VPC Reachability Analyzer</a>. We also see Amazon development teams <a href="https://www.amazon.science/blog/how-automated-reasoning-improves-the-prime-video-experience" target="_blank" data-cms-ai="0">integrating automated-reasoning tools</a> into their development processes, raising the bar on the <a href="https://www.amazon.science/latest-news/how-awss-automated-reasoning-group-helps-make-aws-and-other-amazon-products-more-secure" target="_blank" data-cms-ai="0">security</a>, <a href="https://www.amazon.science/blog/aws-team-wins-best-paper-award-for-work-on-automated-reasoning" data-cms-ai="0">durability</a>, availability, and quality of our products.</p><p>The goal of this article is to provide a gentle introduction to automated reasoning for the industry professional who knows nothing about the area but is curious to learn more. All you will need to make sense of this article is to be able to read a few small C and Python code fragments. I will refer to a few specialist concepts along the way, but only with the goal of introducing them in an informal manner. I close with links to some of our favorite publicly available tools, videos, books, and articles for those looking to go more in-depth.</p><p>Let’s start with a simple example. Consider the following C function:</p><div data-align-center="">
            <div><div>
    <pre>bool f(unsigned int x, unsigned int y) {
   return (x+y == y+x);
}<pre></pre></pre></div>
</div>
        </div><p>Take a few moments to answer the question <i>“Could </i>f<i> ever return false?”</i> This is not a trick question: I’ve purposefully used a simple example to make a point.</p><p>To check the answer with exhaustive testing, we could try executing the following doubly nested test loop, which calls <i>f </i>on all possible pairs of values of the type unsigned int:</p><div data-align-center="">
            <div><div>
    <pre>#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;limits.h&gt;

bool f(unsigned int x, unsigned int y) {
   return (x+y == y+x);
}

void main() {
   for (unsigned int x=0;1;x++) {
      for (unsigned int y=0;1;y++) {
         if (!f(x,y)) printf(&#34;Error!\n&#34;);
         if (y==UINT_MAX) break;
      }
      if (x==UINT_MAX) break;
   }
}<pre></pre></pre></div>
</div>
        </div><p>Unfortunately, even on modern hardware, this doubly nested loop will run for a <i>very long</i> time. I compiled it and ran it on a 2.6 GHz Intel processor for over 48 hours before giving up.</p><p>Why does testing take so long? Because UINT_MAX is typically 4,294,967,295, there are 18,446,744,065,119,617,025 separate <i>f</i> calls to consider. On my 2.6 GHz machine, the compiled test loop called <i>f</i> approximately 430 million times a second. But to test all 18 quintillion cases at this performance, we would need over 1,360 years.</p><p>When we show the above code to industry professionals, they almost immediately work out that <i>f</i> can&#39;t return false as long as the underlying compiler/interpreter and hardware are correct. How do they do that? They <i>reason</i> about it. They remember from their school days that <i>x + y</i> can be rewritten as <i>y + x</i> and conclude that <i>f</i> always returns true.</p><div data-align-right="">
            <div><div data-video-disable-history="">
    
        <p><ps-youtubeplayer data-video-player="" data-player-id="feaa2f78002284bc89f6771779ee8e652" data-video-id="9NEQbFLtDmg" data-video-title="Re:Invent 2021 keynote address by Peter DeSantis, senior vice president for utility computing at Amazon Web Services">

    <iframe id="YouTubeVideoPlayer-feaa2f78002284bc89f6771779ee8e652" role="application" title="YouTube embedded video player" allowfullscreen="" src="https://www.youtube.com/embed/9NEQbFLtDmg?enablejsapi=1"></iframe>
</ps-youtubeplayer>
</p>
    
    <div>
        
            <p>Re:Invent 2021 keynote address by Peter DeSantis, senior vice president for utility computing at Amazon Web Services</p>
        
        
            <p>Skip to <a href="https://youtu.be/9NEQbFLtDmg?t=949" target="_blank" data-cms-ai="0">15:49</a> for a discussion of Amazon Web Services&#39; work on automated reasoning.</p>
        
    </div>
</div>
</div>
        </div><p>An <i>automated</i> reasoning tool does this work for us: it attempts<i> </i>to answer questions about a program (or a logic formula) by using known techniques from mathematics. In this case, the tool would use algebra to deduce that <i>x + y == y + x</i> can be replaced with the simple expression true.</p><p>Automated-reasoning tools can be incredibly fast, even when the domains are infinite (e.g., unbounded mathematical integers rather than finite C ints). Unfortunately, the tools may answer <i>“Don’t know” </i>in some instances. We&#39;ll see a famous example of that below.</p><p>The <i>science</i> of automated reasoning is essentially focused on driving the frequency of these <i>“Don’t know”</i> answers down as far as possible: the less often the tools report <i>&#34;Don&#39;t know&#34;</i> (or time out while trying), the more useful they are.</p><p>Today’s tools are able to give answers for programs and queries where yesterday’s tools could not. Tomorrow’s tools will be even more powerful. We are seeing rapid progress in this field, which is why at Amazon, we are increasingly getting so much value from it. In fact, we see automated reasoning forming its own Amazon-style virtuous cycle, where more input problems to our tools drive improvements to the tools, which encourages more use of the tools.</p><p>A slightly more complex example. Now that we know the rough outlines of what automated reasoning is, the next small example gives a slightly more realistic taste of the sort of complexity that the tools are managing for us.</p><div data-align-center="">
            <div><div>
    <pre>void g(int x, int y) {
   if (y &gt; 0)
      while (x &gt; y)
         x = x - y;
}<pre></pre></pre></div>
</div>
        </div><p>Or, alternatively, consider a similar Python program over unbounded integers:</p><div data-align-center="">
            <div><div>
    <pre>def g(x, y):
   assert isinstance(x, int) and isinstance(y, int)
   if y &gt; 0:
      while x &gt; y:
         x = x - y<pre></pre></pre></div>
</div>
        </div><p>Try to answer this question: <i>“Does </i>g<i> always eventually return control back to its caller?”</i></p><p>When we show this program to industry professionals, they usually figure out the right answer quickly. A few, especially those who are aware of results in theoretical computer science, sometimes mistakenly think that we can&#39;t answer this question, with the rationale <i>“This is an example of the </i><a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" data-cms-ai="0">halting problem</a><i>, which has been proved insoluble”. </i>In fact, we <i>can </i>reason about the halting behavior for <i>specific</i> programs, including this one. We’ll talk more about that later.</p><p>Here’s the reasoning that most industry professionals use when looking at this problem:<br/></p><ol><li>In the case where <i>y</i> is not positive, execution jumps to the end of the function <i>g</i>. That’s the easy case.</li><li>If, in every iteration of the loop, the value of the variable <i>x</i> decreases, then eventually, the loop condition <i>x</i> &gt; <i>y</i> will fail, and the end of <i>g</i> will be reached.</li><li>The value of <i>x</i> always decreases only if <i>y</i> is always positive, because only then does the update to x (i.e., <i>x</i> = <i>x</i> - <i>y</i>) decrease <i>x</i>. But <i>y</i>’s positivity is established by the conditional expression, so <i>x</i> always decreases.</li></ol><p>The experienced programmer will usually worry about underflow in the <i>x</i> = <i>x</i> - <i>y</i> command of the C program but will then notice that <i>x</i> &gt; <i>y</i> before the update to <i>x</i> and thus cannot underflow.</p><p>If you carried out the three steps above yourself, you now have a very intuitive view of the type of thinking an automated-reasoning tool is performing on our behalf when reasoning about a computer program. There are many nitty-gritty details that the tools have to face (e.g., heaps, stacks, strings, pointer arithmetic, recursion, concurrency, callbacks, etc.), but there’s also decades of research papers on techniques for handling these and other topics, along with various practical tools that put these ideas to work.</p><div data-align-right="">
            <div><figure>
    <p><img alt="Policy-code.gif" width="1200" height="675" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-src="https://assets.amazon.science/dims4/default/ac70ec3/2147483647/strip/true/crop/800x450+0+0/resize/1200x675!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2Fe4%2F73%2F45f43a434b28b094b8609ec8c129%2Fpolicy-code.gif"/>
    



        

        
    </p>

    
        <p><figcaption>Automated reasoning can be applied to both policies <i>(top)</i> and code <i>(bottom)</i>. In both cases, an essential step is reasoning about what&#39;s <i>always</i> true.</figcaption></p>
    
</figure></div>
        </div><p>The main takeaway is that automated-reasoning tools are usually working through the three steps above on our behalf: Item 1 is reasoning about the program’s <i>control structure</i>. Item 2 is reasoning about what is <i>eventually</i> true within the program. Item 3 is reasoning about what is <i>always</i> true in the program.</p><p>Note that configuration artifacts such as AWS resource policies, VPC network descriptions, or even makefiles can be thought of as code. This viewpoint allows us to use the same techniques we use to reason about C or Python code to answer questions about the <i>interpretation</i> of configurations. It’s this insight that gives us tools like IAM Access Analyzer or VPC Reachability Analyzer.</p><h2>An end to testing?</h2><p>As we saw above when looking at <i>f</i> and <i>g</i>, automated reasoning can be dramatically faster than exhaustive testing. With tools available today, we can show properties of <i>f</i> or <i>g</i> in milliseconds, rather than waiting lifetimes with exhaustive testing.</p><p>Can we throw away our testing tools now and just move to automated reasoning? Not quite. Yes, we can dramatically reduce our dependency on testing, but we will not be completely eliminating it any time soon, if ever. Consider our first example:</p><div data-align-center="">
            <div><div>
    <pre>bool f(unsigned int x, unsigned int y) {
   return (x + y == y + x);
}<pre></pre></pre></div>
</div>
        </div><p>Recall the worry that a buggy compiler or microprocessor could in fact cause an executable program constructed from this source code to return false. We might also need to worry about the language runtime. For example, the C math library or the Python garbage collector might have bugs that cause a program to misbehave.</p><p>What’s interesting about testing, and something we often forget, is that it’s doing much more than just telling us about the C or Python source code. It’s also testing the compiler, the runtime, the interpreter, the microprocessor, etc. A test failure could be rooted in any of those tools in the stack.</p><p>Automated reasoning, in contrast, is usually applied to just one layer of that stack — the source code itself, or sometimes the compiler or the microprocessor. What we find so valuable about reasoning is it allows us to clearly define both what we <i>do</i> know and what we <i>do not</i> know about the layer under inspection.</p><p>Furthermore, the models of the surrounding environment (e.g., the compiler or the procedure calling our procedure) used by the automated-reasoning tool make our assumptions <i>very</i> precise. Separating the layers of the computational stack helps make better use of our time, energy, and money and the capabilities of the tools today and tomorrow.</p><p>Unfortunately, we will almost always need to make assumptions about <i>something </i>when using<i> </i>automated reasoning — for example, the principles of physics that govern our silicon chips. Thus, testing will never be fully replaced. We will want to perform end-to-end testing to try and validate our assumptions as best we can.</p><h2>An impossible program</h2><p>I previously mentioned that automated-reasoning tools sometimes return <i>“Don’t know”</i> rather than <i>“yes”</i> or <i>“no”</i>. They also sometimes run forever (or time out), thus never returning an answer. Let’s look at the famous &#34;halting problem&#34; program, in which we know tools <i>cannot</i> return <i>“yes”</i> or <i>“no”</i>.</p><p>Imagine that we have an automated-reasoning API, called <i>terminates</i>, that returns <i>“yes” </i>if a C function always terminates or <i>“no” </i>when the function could execute forever. As an example, we could build such an API using the tool described <a href="https://vimeo.com/81641895" target="_blank" data-cms-ai="0">here</a> (shameless self-promotion of author’s previous work). To get the idea of what a termination tool can do for us, consider two basic C functions, <i>g</i> (from above),</p><div data-align-center="">
            <div><div>
    <pre>void g(int x, int y) {
   if (y &gt; 0)
      while (x &gt; y)
         x = x - y;
}<pre></pre></pre></div>
</div>
        </div><p>and g2:</p><div data-align-center="">
            <div><div>
    <pre>void g2(int x, int y) {
   while (x &gt; y)
      x = x - y;
}<pre></pre></pre></div>
</div>
        </div><p>For the reasons we have already discussed, the function <i>g</i> always returns control back to its caller, so <i>terminates(g)</i> should return true. Meanwhile, <i>terminates(g2)</i> should return false because, for example, <i>g2(5, 0)</i> will never terminate.</p><p>Now comes the difficult function. Consider <i>h</i>:</p><div data-align-center="">
            <div><div>
    <pre>void h() {
   if terminates(h) while(1){}
}<pre></pre></pre></div>
</div>
        </div><p>Notice that it&#39;s recursive. What’s the right answer for <i>terminates(h)</i>? The answer cannot be &#34;yes&#34;. It also cannot be &#34;no&#34;. Why?</p><p>Imagine that <i>terminates(h)</i> were to return &#34;yes&#34;. If you read the code of <i>h</i>, you’ll see that in this case, the function does not terminate because of the conditional statement in the code of <i>h</i> that will execute the infinite loop <i>while(1){}</i>. Thus, in this case, the <i>terminates(h)</i> answer would be wrong, because <i>h</i> is defined recursively, calling terminates on itself.</p><p>Similarly, if <i>terminates(h)</i> were to return &#34;no&#34;, then <i>h</i> would in fact terminate and return control to its caller, because the <i>if </i>case of the conditional statement is not met, and there is no else branch. Again, the answer would be wrong. This is why the <i>“Don’t know”</i> answer is actually unavoidable in this case.</p><p>The program <i>h</i> is a variation of examples given in Turing’s <a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf" target="_blank" data-cms-ai="0">famous 1936 paper</a> on decidability and <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems" target="_blank" data-cms-ai="0">Gödel’s incompleteness theorems</a> from 1931. These papers tell us that problems like the halting problem cannot be “solved”, if by<i>“</i>solved<i>” </i>we mean that the solution procedure itself always terminates and answers either <i>“yes”</i> or <i>“no”</i> but never <i>“Don’t know”</i>. But that is not the definition of “solved” that many of us have in mind. For many of us, a tool that sometimes times out or occasionally returns <i>“Don’t know”</i> but, when it gives an answer, always gives the right answer is good enough.</p><p>This problem is analogous to airline travel: we know it’s not 100% safe, because crashes have happened in the past, and we are sure that they will happen in the future. But when you land safely, you <i>know</i> it worked that time. The goal of the airline industry is to reduce failure as much as possible, even though it’s in principle unavoidable.</p><p>To put that in the context of automated reasoning: for some programs, like <i>h</i>, we can never improve the tool enough to replace the <i>&#34;Don&#39;t know&#34;</i> answer. But there are many other cases where today&#39;s tools answer <i>&#34;Don&#39;t know&#34;</i>, but future tools may be able to answer <i>&#34;yes&#34;</i> or <i>&#34;no&#34;</i>. The modern scientific challenge for automated-reasoning subject-matter experts is to get the practical tools to return <i>“yes”</i> or <i>“no” </i>as often as possible. As an example of current work, check out CMU professor and <a href="https://www.amazon.science/scholars" data-cms-ai="0">Amazon scholar</a> <a href="https://www.cs.cmu.edu/~mheule/" target="_blank" data-cms-ai="0">Marijn Heule</a> and his <a href="https://www.quantamagazine.org/computer-scientists-attempt-to-corner-the-collatz-conjecture-20200826/" target="_blank" data-cms-ai="0">quest to solve the Collatz termination problem</a>.</p><p>Another thing to keep in mind is that automated-reasoning tools are regularly trying to solve “intractable” problems, e.g.<i>, </i>problems in the <a href="https://news.mit.edu/2009/explainer-pnp" target="_blank" data-cms-ai="0">NP</a> complexity class. Here, the same thinking applies that we saw in the case of the halting problem: automated-reasoning tools have powerful heuristics that often work around the intractability problem for specific cases, but those heuristics can (and sometimes do) fail, resulting in <i>“Don’t know”</i> answers or impractically long execution time. The science is to improve the heuristics to minimize that problem.</p><h2>Nomenclature</h2><p>A host of names are used in the scientific literature to describe interrelated topics, of which automated reasoning is just one. Here’s a quick glossary:</p><ul><li>A <i>logic</i> is a formal and mechanical system for defining what is true and untrue. Examples: <a href="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank" data-cms-ai="0">propositional logic</a> or <a href="https://en.wikipedia.org/wiki/First-order_logic" target="_blank" data-cms-ai="0">first-order logic</a>.</li><li>A <i>theorem</i> is a true statement in logic. Example: the <a href="https://en.wikipedia.org/wiki/Four_color_theorem" target="_blank" data-cms-ai="0">four-color theorem</a>.</li><li>A <i>proof</i> is a valid argument in logic of a theorem. Example: Gonthier&#39;s <a href="http://www.ams.org/notices/200811/tx081101382p.pdf" target="_blank" data-cms-ai="0">proof of the four-color theorem</a>. </li><li>A <i>mechanical theorem prover</i> is a semi-automated-reasoning tool that checks a machine-readable expression of a proof often written down by a human. These tools often require human guidance. Example: <a href="https://github.com/jrh13/hol-light/" target="_blank" data-cms-ai="0">HOL-light</a>, from Amazon researcher <a href="https://www.cl.cam.ac.uk/~jrh13/" target="_blank" data-cms-ai="0">John Harrison</a>. </li><li><i>Formal verification</i> is the use of theorem proving when applied to models of computer systems to prove desired properties of the systems. Example: the <a href="https://compcert.org/doc/" target="_blank" data-cms-ai="0">CompCert verified C compiler</a>. </li><li><i>Formal methods</i> is the broadest term, meaning simply the use of logic to reason formally about models of systems. </li><li><i>Automated reasoning</i> focuses on the automation of formal methods. </li><li>A <i>semi-automated-reasoning</i> tool is one that requires hints from the user but still finds valid proofs in logic. </li></ul><p>As you can see, we have a choice of monikers when working in this space. At Amazon, we’ve chosen to use automated reasoning, as we think it best captures our ambition for automation and scale. In practice, some of our internal teams use both automated and <i>semi-</i>automated reasoning tools, because the scientists we&#39;ve hired can often get semi-automated reasoning tools to succeed where the heuristics in fully automated reasoning might fail. For our externally facing customer features, we currently use only fully automated approaches.</p><h2>Next steps</h2><p>In this essay, I’ve introduced the idea of automated reasoning, with the smallest of toy programs. I haven’t described how to handle realistic programs, with heap or concurrency. In fact, there are a wide variety of automated-reasoning tools and techniques, solving problems in all kinds of different domains, some of them quite narrow. To describe them all and the many branches and sub-disciplines of the field (e.g. “SMT solving”, “higher-order logic theorem proving”, “separation logic”) would take thousands of blogs posts and books.</p><p>Automated reasoning goes back to the early inventors of computers. And logic itself (which automated reasoning attempts to solve) is thousands of years old. In order to keep this post brief, I’ll stop here and suggest further reading. Note that it’s very easy to get lost in the weeds reading depth-first into this area, and you could emerge more confused than when you started. I encourage you to use a bounded depth-first search approach, looking sequentially at a wide variety of tools and techniques in only some detail and then moving on, rather than learning only one aspect deeply.</p><h3>Suggested books:</h3><ul><li><a href="https://www.amazon.com/Handbook-Practical-Logic-Automated-Reasoning/dp/0521899575" target="_blank" data-cms-ai="0">Handbook of Practical Logic and Automated Reasoning</a></li><li><a href="https://link.springer.com/book/10.1007/978-1-4612-4222-2" target="_blank" data-cms-ai="0">Temporal Verification of Reactive Systems</a></li><li><a href="https://www.decision-procedures.org/" target="_blank" data-cms-ai="0">Decision Procedures</a></li><li><a href="https://mitpress.mit.edu/books/model-checking-second-edition" target="_blank" data-cms-ai="0">Model Checking</a></li><li><a href="https://softwarefoundations.cis.upenn.edu/current/index.html" target="_blank" data-cms-ai="0">Software Foundations</a></li><li><a href="https://lamport.azurewebsites.net/tla/book.html#download" target="_blank" data-cms-ai="0">Specifying Systems</a></li><li><a href="https://mitpress.mit.edu/books/introduction-static-analysis" target="_blank" data-cms-ai="0">Introduction to Static Analysis</a></li><li><a href="https://www.amazon.com/Logic-Computer-Science-Modelling-Reasoning/dp/052154310X" target="_blank" data-cms-ai="0">Logic in Computer Science: Modelling and Reasoning about Systems</a></li><li><a href="https://functional-algorithms-verified.org/" target="_blank" data-cms-ai="0">Functional Algorithms, Verified!</a></li><li><a href="https://ebooks.iospress.nl/volume/handbook-of-satisfiability-second-edition" target="_blank" data-cms-ai="0">Handbook of Satisfiability</a></li><li><a href="https://link.springer.com/book/10.1007/978-3-540-74113-8" target="_blank" data-cms-ai="0">The Calculus of Computation</a></li></ul><h3>International conferences/workshops:</h3><ul><li><a href="https://etaps.org/2020/tacas" target="_blank" data-cms-ai="0">https://etaps.org/2020/tacas</a></li><li><a href="http://i-cav.org/2020/" target="_blank" data-cms-ai="0">http://i-cav.org/2020/</a></li><li><a href="https://ijcar2020.org/" target="_blank" data-cms-ai="0">https://ijcar2020.org/</a></li><li><a href="https://popl21.sigplan.org/" target="_blank" data-cms-ai="0">https://popl21.sigplan.org/</a></li><li><a href="https://sat2020.idea-researchlab.org/" target="_blank" data-cms-ai="0">https://sat2020.idea-researchlab.org/</a></li><li><a href="http://smt-workshop.cs.uiowa.edu/" target="_blank" data-cms-ai="0">http://smt-workshop.cs.uiowa.edu/</a></li></ul><h3>Tool competitions:</h3><ul><li><a href="http://termination-portal.org/wiki/Termination_Competition" target="_blank" data-cms-ai="0">http://termination-portal.org/wiki/Termination_Competition</a></li><li><a href="https://sv-comp.sosy-lab.org/2020/" target="_blank" data-cms-ai="0">https://sv-comp.sosy-lab.org/2020/</a></li><li><a href="https://smt-comp.github.io/2020/" target="_blank" data-cms-ai="0">https://smt-comp.github.io/2020/</a></li><li><a href="http://www.satcompetition.org/" target="_blank" data-cms-ai="0">http://www.satcompetition.org/</a></li><li><a href="http://www.tptp.org/CASC/27/" target="_blank" data-cms-ai="0">http://www.tptp.org/CASC/27/</a></li></ul><h3>Some tools:</h3><ul><li>AGREE: <a href="http://loonwerks.com/tools/agree.html" target="_blank" data-cms-ai="0">http://loonwerks.com/tools/agree.html</a></li><li>Alloy: <a href="https://alloytools.org/" target="_blank" data-cms-ai="0">https://alloytools.org/</a></li><li>Aprove: <a href="https://aprove.informatik.rwth-aachen.de/" target="_blank" data-cms-ai="0">https://aprove.informatik.rwth-aachen.de/</a></li><li>BioModelAnalzyer: <a href="https://biomodelanalyzer.com/" target="_blank" data-cms-ai="0">https://biomodelanalyzer.com/</a></li><li>Boogie: <a href="https://github.com/boogie-org/boogie.git" target="_blank" data-cms-ai="0">https://github.com/boogie-org/boogie.git</a></li><li>CBMC: <a href="https://www.cprover.org/cbmc/" target="_blank" data-cms-ai="0">https://www.cprover.org/cbmc/</a></li><li>Checked C: <a href="https://plum-umd.github.io/projects/checkedc.html" target="_blank" data-cms-ai="0">https://plum-umd.github.io/projects/checkedc.html</a></li><li>Checker Framework: <a href="https://checkerframework.org/" target="_blank" data-cms-ai="0">https://checkerframework.org/</a></li><li>CoCoSim: <a href="https://github.com/NASA-SW-VnV/CoCoSim" target="_blank" data-cms-ai="0">https://github.com/NASA-SW-VnV/CoCoSim</a></li><li>Coq: <a href="https://coq.inria.fr/" target="_blank" data-cms-ai="0">https://coq.inria.fr/</a></li><li>CPA Checker: <a href="https://cpachecker.sosy-lab.org/" target="_blank" data-cms-ai="0">https://cpachecker.sosy-lab.org/</a></li><li>CVC4: <a href="https://cvc4.github.io/" target="_blank" data-cms-ai="0">https://cvc4.github.io/</a></li><li>Dafny: <a href="https://github.com/dafny-lang/dafny" target="_blank" data-cms-ai="0">https://github.com/dafny-lang/dafny</a></li><li>Dreal: <a href="https://github.com/dreal/dreal4" target="_blank" data-cms-ai="0">https://github.com/dreal/dreal4</a></li><li>HOL light: <a href="https://www.cl.cam.ac.uk/~jrh13/hol-light/" target="_blank" data-cms-ai="0">https://www.cl.cam.ac.uk/~jrh13/hol-light/</a></li><li>Infer: <a href="https://fbinfer.com/" target="_blank" data-cms-ai="0">https://fbinfer.com</a></li><li>Iris: <a href="https://iris-project.org/" target="_blank" data-cms-ai="0">https://iris-project.org/</a></li><li>Isabelle: <a href="https://isabelle.in.tum.de/" target="_blank" data-cms-ai="0">https://isabelle.in.tum.de/</a></li><li>Java PathFinder: <a href="https://github.com/javapathfinder" target="_blank" data-cms-ai="0">https://github.com/javapathfinder</a></li><li>JKind: <a href="https://github.com/loonwerks/jkind" target="_blank" data-cms-ai="0">https://github.com/loonwerks/jkind</a></li><li>Keymaera X: <a href="https://keymaerax.org/" target="_blank" data-cms-ai="0">https://keymaerax.org/</a></li><li>Kind2: <a href="https://kind2-mc.github.io/kind2" target="_blank" data-cms-ai="0">https://kind2-mc.github.io/kind2</a></li><li>KLEE: <a href="https://klee.github.io/" target="_blank" data-cms-ai="0">https://klee.github.io</a></li><li>Lean: <a href="https://leanprover.github.io/" target="_blank" data-cms-ai="0">https://leanprover.github.io/</a></li><li>MiniSat: <a href="http://minisat.se/" target="_blank" data-cms-ai="0">http://minisat.se/</a></li><li>Nagini: <a href="https://github.com/marcoeilers/nagini" target="_blank" data-cms-ai="0">https://github.com/marcoeilers/nagini</a></li><li>P: <a href="https://github.com/p-org/P" target="_blank" data-cms-ai="0">https://github.com/p-org/P</a></li><li>PRISM:<a href="https://www.prismmodelchecker.org/" target="_blank" data-cms-ai="0">https://www.prismmodelchecker.org</a></li><li>PVS: <a href="https://pvs.csl.sri.com/" target="_blank" data-cms-ai="0">https://pvs.csl.sri.com</a></li><li>Rosette: <a href="http://emina.github.io/rosette/" target="_blank" data-cms-ai="0">http://emina.github.io/rosette/</a></li><li>Rust programming language: <a href="https://www.rust-lang.org/" target="_blank" data-cms-ai="0">https://www.rust-lang.org/</a> [When you are programming in Rust you are essentially proving the absence of memory corruption in a type system (assuming you&#39;re not using &#34;unsafe&#34; regions)]</li><li>Sally: <a href="https://github.com/SRI-CSL/sally" target="_blank" data-cms-ai="0">https://github.com/SRI-CSL/sally</a></li><li>SAW: <a href="https://saw.galois.com/" target="_blank" data-cms-ai="0">https://saw.galois.com/</a></li><li>SeaHorn: <a href="http://seahorn.github.io/" target="_blank" data-cms-ai="0">http://seahorn.github.io/</a></li><li>SMACK: <a href="https://smackers.github.io/" target="_blank" data-cms-ai="0">https://smackers.github.io</a></li><li>Soot: <a href="http://soot-oss.github.io/soot/" target="_blank" data-cms-ai="0">http://soot-oss.github.io/soot/</a></li><li>SPIN: <a href="http://spinroot.com/spin/whatispin.html" target="_blank" data-cms-ai="0">http://spinroot.com/spin/whatispin.html</a></li><li>T2: <a href="https://mmjb.github.io/T2/" target="_blank" data-cms-ai="0">https://mmjb.github.io/T2/</a></li><li>TLA+: <a href="https://lamport.azurewebsites.net/tla/tla.html" target="_blank" data-cms-ai="0">https://lamport.azurewebsites.net/tla/tla.html</a></li><li>Vampire: <a href="https://vprover.github.io/" target="_blank" data-cms-ai="0">https://vprover.github.io/</a></li><li>VCC: <a href="https://github.com/microsoft/vcc" target="_blank" data-cms-ai="0">https://github.com/microsoft/vcc</a></li><li>Verifast: <a href="https://github.com/verifast/verifast" target="_blank" data-cms-ai="0">https://github.com/verifast/verifast</a></li><li>Z3: <a href="https://github.com/Z3Prover/z3" target="_blank" data-cms-ai="0">https://github.com/Z3Prover/z3</a></li></ul><h3>Interviews of Amazon staff about their use of automated reasoning:</h3><ul><li><a href="https://www.youtube.com/watch?v=MHON17HzPZI" target="_blank" data-cms-ai="0">Byron Cook PLDI&#39;20 Ask Me Anything</a></li><li><a href="https://www.youtube.com/watch?v=J9Da3VsLH44" target="_blank" data-cms-ai="0">Byron Cook on The CUBE</a></li><li><a href="https://www.youtube.com/watch?v=CWVehV9PsPQ" target="_blank" data-cms-ai="0">Neha Rungta on The CUBE</a></li><li><a href="https://www.youtube.com/watch?v=Awy04VNIFJg" target="_blank" data-cms-ai="0">Neha Rungta discusses constraint-based reasoning tools in AWS Config Rules</a></li><li><a href="https://ucl-pplv.github.io/CAV21/poster_P_k15/" target="_blank" data-cms-ai="0">Serdar Tasiran CAV&#39;21 Ask Me Anything</a></li><li><a href="https://www.youtube.com/watch?v=le8h_dpqroo" target="_blank" data-cms-ai="0">LogMeIn: How LogMeIn Automates Governance and Empowers Developers at Scale</a></li></ul><h3>AWS Lectures aimed at customers and industry:</h3><ul><li><a href="https://www.youtube.com/watch?v=BbXK_-b3DTk" target="_blank" data-cms-ai="0">Automating Compliance Verification on AWS Using Provable Security</a>, lecture with AWS VP of compliance Chad Woolf, and compliance auditor Coalfire&#39;s CEO Tom McAndrew</li><li><a href="https://www.youtube.com/watch?v=UKqVY0SSbus" target="_blank" data-cms-ai="0">An AWS Approach to Higher Standards of Assurance w/ Provable Security</a>, Byron Cook</li><li><a href="https://www.youtube.com/watch?v=i5apYXya2m0" target="_blank" data-cms-ai="0">Dive Deep into IAM Access Analyze</a>, lecture by Andrew Gacek and others</li><li><a href="https://www.youtube.com/watch?v=x6wsTFnU3eY" target="_blank" data-cms-ai="0">The Evolution of automated reasoning Technology at AWS</a>, lecture with AWS VP of security Eric Brandwine</li><li><a href="https://www.youtube.com/watch?v=Wvyc-VEUOns&amp;t=2214" target="_blank" data-cms-ai="0">Lecture</a> by AWS CISO and VP of security Steve Schmidt about on the development and use of formal/constraint-based tools in AWS</li><li><a href="https://www.youtube.com/watch?v=jt-gV1YwmnI&amp;t=2975s" target="_blank" data-cms-ai="0">Re:Invent Keynote</a>, lecture by CTO Werner Vogels</li></ul><h3>AWS talks aimed at the automated-reasoning science community:</h3><ul><li><a href="https://ucl-pplv.github.io/CAV21/poster_P_215/" target="_blank" data-cms-ai="0">Debugging Network Reachability with Blocked Paths</a>, CAV&#39;21</li><li><a href="https://www.youtube.com/watch?v=Y_DeKKhbNUs" target="_blank" data-cms-ai="0">Embedded World 2021: Formally Verifying the FreeRTOS IPC Mechanism</a>, Embedded World &#39;21</li><li><a href="https://youtu.be/JfjLKBO27nw" target="_blank" data-cms-ai="0">Formal reasoning about the security of Amazon Web Services</a>, FLoC 2018 plenary lecture</li><li><a href="https://www.youtube.com/watch?v=9lPR0d2uijo" target="_blank" data-cms-ai="0">Formal reasoning about the security of Amazon Web Services</a>, OOPSLA/SPLASH 2018 keynote lecture</li><li><a href="https://ucl-pplv.github.io/CAV21/poster_facc_10/" target="_blank" data-cms-ai="0">How I learned to stop worrying and start applying automated reasoning</a>, FACC&#39;21 (other relevant talks at <a href="https://ucl-pplv.github.io/CAV21/workshop_facc/" target="_blank" data-cms-ai="0">FACC website</a>)</li><li><a href="https://ucl-pplv.github.io/CAV21/poster_facc_10/" target="_blank" data-cms-ai="0">On automated reasoning for compliance certification</a>, CAV workshop on Formal Approaches to Certifying Compliance (FACC)</li><li><a href="https://ucl-pplv.github.io/CAV21/poster_P_315/" target="_blank" data-cms-ai="0">Pre-Deployment Security Assessment for Cloud Services through Semantic Reasoning</a>, CAV&#39;21</li><li><a href="https://www.youtube.com/watch?v=bO-vfLpFI3I" target="_blank" data-cms-ai="0">Provable Security at AWS</a>, USENIX Enigma 2019</li><li>[Skip to 30mins in]: <a href="https://www.facebook.com/ze.jaloto/videos/10157040968367975/" target="_blank" data-cms-ai="0">SideTrail: Verifying Time-Balancing of Cryptosystems</a></li><li><a href="https://www.youtube.com/watch?v=TjSQ1P3tM2I" target="_blank" data-cms-ai="0">Stratified abstraction of access control policies</a>, CAV&#39;20</li><li><a href="https://ucl-pplv.github.io/CAV21/poster_P_46/" target="_blank" data-cms-ai="0">Verified Cryptographic Code for Everybody</a>, CAV&#39;21</li><li><a href="https://www.youtube.com/watch?v=sS-x_NQ-CsI" target="_blank" data-cms-ai="0">What is automated reasoning? How Is it Used at AWS?</a></li></ul><h3>AWS blog posts and informational videos:</h3><ul><li><a href="https://aws.amazon.com/blogs/security/amazon-inspector-assess-network-exposure-ec2-instances-aws-network-reachability-assessments/" target="_blank" data-cms-ai="0">A simpler way to assess the network exposure of EC2 instances: AWS releases new network reachability assessments in Amazon Inspector</a></li><li><a href="https://www.allthingsdistributed.com/2019/06/proving-security-at-scale-with-automated-reasoning.html" target="_blank" data-cms-ai="0">AWS CTO blogs about automated reasoning Group: Proving security at scale with automated reasoning</a></li><li><a href="https://www.allthingsdistributed.com/2021/04/s3-strong-consistency.html" target="_blank" data-cms-ai="0">AWS CTO discusses S3 consistency</a></li><li>AWS Podcast interview: <a href="https://aws.amazon.com/blogs/security/provable-security-podcast-automated-reasonings-past-present-and-future-with-moshe-vardi/?fbclid=IwAR1lHco10mnp7yPEDwUFMgMCpCMoKVIxKOCGLGvwEUzHoL1TAW_cWAwoD8w" target="_blank" data-cms-ai="0">Provable security podcast: Byron interviews Moshe Vardi</a></li><li>AWS Podcast interview: <a href="https://aws.amazon.com/podcasts/aws-podcast/#266" target="_blank" data-cms-ai="0">Next Generation Security with automated reasoning, an Artificial Intelligence Technology</a></li><li><a href="https://aws.amazon.com/blogs/aws/aws-config-update-new-managed-rules-to-secure-s3-buckets/" target="_blank" data-cms-ai="0">Blog post</a> about event-driven checks in <a href="https://aws.amazon.com/config/" target="_blank" data-cms-ai="0">AWS Config</a> powered by automated constraint solving techniques over IAM policies [attend <a href="https://awsnyc17.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=121651" target="_blank" data-cms-ai="0">this session at NY summit</a>] ... and <a href="https://aws.amazon.com/blogs/mt/example-scenarios-for-aws-config-continuous-monitoring-of-amazon-s3-bucket-access-controls/" target="_blank" data-cms-ai="0">more detail</a></li><li><a href="https://aws.amazon.com/blogs/aws/new-amazon-s3-encryption-security-features/" target="_blank" data-cms-ai="0">Blog post</a> on the use of constraint-based reasoning about policies in the Amazon Web Services S3 console</li><li>Blogs <a href="https://galois.com/blog/2016/09/verifying-s2n-hmac-with-saw/" target="_blank" data-cms-ai="0">1</a>, <a href="https://galois.com/blog/2016/09/specifying-hmac-in-cryptol/" target="_blank" data-cms-ai="0">2</a>, and <a href="https://galois.com/blog/2016/09/proving-program-equivalence-with-saw/" target="_blank" data-cms-ai="0">3</a> about work with <a href="https://galois.com/" target="_blank" data-cms-ai="0">Galois</a> to prove the correctness of Amazon&#39;s crypto infrastructure component <a href="https://aws.amazon.com/blogs/security/introducing-s2n-a-new-open-source-tls-implementation/" target="_blank" data-cms-ai="0">s2n</a></li><li><a href="https://aws.amazon.com/blogs/security/aws-security-profiles-chad-woolf-vp-of-aws-security/" target="_blank" data-cms-ai="0">Chad Wolff (VP of compliance at AWS) discusses his interest in using automated reasoning to simplify and raise the bar on compliance certification</a></li><li><a href="https://aws.amazon.com/blogs/security/automated-reasoning-provable-security-of-boot-code/" target="_blank" data-cms-ai="0">Daniel Schwartz-Narbonne shares how automated reasoning is helping achieve the provable security of AWS boot code</a></li><li><a href="https://aws.amazon.com/blogs/storage/how-automated-reasoning-helps-us-innovate-at-s3-scale/" target="_blank" data-cms-ai="0">How automated reasoning helps us innovate at S3 scale</a></li><li><a href="https://www.amazon.science/blog/how-automated-reasoning-improves-the-prime-video-experience" data-cms-ai="0">How automated reasoning improves Prime Vdeo experience</a></li><li><a href="https://aws.amazon.com/blogs/security/how-aws-sidetrail-verifies-key-aws-cryptography-code/" target="_blank" data-cms-ai="0">How AWS SideTrail verifies key AWS cryptography code</a></li><li><a href="https://aws.amazon.com/blogs/security/protect-sensitive-data-in-the-cloud-with-automated-reasoning-zelkova/" target="_blank" data-cms-ai="0">How AWS uses automated reasoning to help you achieve security at scale</a></li><li><a href="https://aws.amazon.com/blogs/aws/aws-iot-device-defender-now-available-keep-your-connected-devices-safe/" target="_blank" data-cms-ai="0">Jeff Barr about tools for IoT configuration verification</a></li><li><a href="https://aws.amazon.com/blogs/aws/new-vpc-insights-analyzes-reachability-and-visibility-in-vpcs/" target="_blank" data-cms-ai="0">On VPC Reachablity Analyzer</a></li><li><a href="https://aws.amazon.com/about-aws/whats-new/2018/09/aws-config-announces-new-managed-rules/" target="_blank" data-cms-ai="0">New (Zelkova-based) AWS Config rules s3-blacklisted-actions-prohibited and bucket-policy-not-more-permissive are released</a></li><li><a href="https://aws.amazon.com/blogs/security/podcast-automated-reasoning-aws-next-gen-security-ai/" target="_blank" data-cms-ai="0">Podcast: AI tech named automated reasoning provides next-gen cloud security</a></li><li>Some detail about constraint-based IAM policy analysis used in <a href="https://aws.amazon.com/macie/" target="_blank" data-cms-ai="0">Amazon Macie</a> can be found <a href="http://docs.aws.amazon.com/macie/latest/userguide/macie-research.html#s3bucketsdata" target="_blank" data-cms-ai="0">here</a></li><li><a href="https://aws.amazon.com/blogs/devops/tightening-application-security-with-amazon-codeguru/" target="_blank" data-cms-ai="0">Tightening application security with Amazon CodeGuru</a></li><li><a href="https://freertos.org/2020/12/using-formal-methods-to-validate-ota-protocol.html" target="_blank" data-cms-ai="0">Using Formal Methods to validate OTA Protocol</a></li><li><a href="https://aws.amazon.com/blogs/security/tag/automated-reasoning/" target="_blank" data-cms-ai="0">... more AWS blogs</a></li></ul><h3>Some course notes by Amazon Scholars who are also university professors:</h3><ul><li><a href="https://courses.cs.washington.edu/courses/cse507/21au/" target="_blank" data-cms-ai="0">https://courses.cs.washington.edu/courses/cse507/21au/</a></li><li><a href="http://www.cs.cmu.edu/~mheule/15816-f21/" target="_blank" data-cms-ai="0">http://www.cs.cmu.edu/~mheule/15816-f21/</a></li><li><a href="https://www.cs.cmu.edu/~mheule/15217-f21/" target="_blank" data-cms-ai="0">https://www.cs.cmu.edu/~mheule/15217-f21/</a></li></ul><h3>A fun deep track:</h3><p>Some algorithms found in the automated theorem provers we use today date as far back as 1959, when <a href="https://dl.acm.org/doi/abs/10.1147/rd.41.0002" target="_blank" data-cms-ai="0">Hao Wang used automated reasoning to prove the theorems from</a> <a href="https://dl.acm.org/doi/abs/10.1147/rd.41.0002" target="_blank" data-cms-ai="0">Principia Mathematica</a>.</p></div>
    
</div>

                            
                        </div>
                    
                </div><div>
                        
                            
    <div>
        <div>
            
                
            
            
            
                <p>
                    Byron Cook is a leader in the field of formal verification, known for his contributions to SAT, SMT, and symbolic model checking, with applications to biological systems, computer operating systems, programming languages, and security. Byron’s work on automated reasoning at Amazon has led to higher levels of assurance in the cloud as well as new customer features.
                </p>
            
        </div>
    </div>


                        
                    </div></div>
  </body>
</html>
