<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sysprog21.github.io/lkmpg/">Original</a>
    <h1>The Linux Kernel Module Programming Guide</h1>
    
    <div id="readability-page-1" class="page">  

   <div>
                                                                  

                                                                  
                                                                  

                                                                  

<h2>The Linux Kernel Module Programming Guide</h2>
</div><p><img alt="PIC" src="https://bogomolnyelad.substack.com/p/assets/cover-with-names.png"/></p>
   
   <h3 id="introduction"><span>1   </span> <a id="x1-10001"></a>Introduction</h3>
<!-- l. 65 --><p>The Linux Kernel Module Programming Guide is a free book; you may reproduce
and/or modify it under the terms of the <a href="https://opensource.org/licenses/OSL-3.0">Open Software License</a>, version
3.0.
</p><!-- l. 67 --><p>   This book is distributed in the hope that it would be useful, but without any
warranty, without even the implied warranty of merchantability or fitness for a
particular purpose.
</p><!-- l. 69 --><p>   The author encourages wide distribution of this book for personal or commercial
use, provided the above copyright notice remains intact and the method adheres to
the provisions of the <a href="https://opensource.org/licenses/OSL-3.0">Open Software License</a>. In summary, you may copy and
distribute this book free of charge or for a profit. No explicit permission is required
from the author for reproduction of this book in any medium, physical or
electronic.
                                                                  

                                                                  
</p><!-- l. 72 --><p>   Derivative works and translations of this document must be placed under the
Open Software License, and the original copyright notice must remain intact. If you
have contributed new material to this book, you must make the material and source
code available for your revisions. Please make revisions and updates available directly
to the document maintainer, Jim Huang &lt;jserv@ccns.ncku.edu.tw&gt;. This will allow
for the merging of updates and provide consistent revisions to the Linux
community.
</p><!-- l. 77 --><p>   If you publish or distribute this book commercially, donations, royalties, and/or
printed copies are greatly appreciated by the author and the <a href="https://tldp.org/">Linux Documentation
Project</a> (LDP). Contributing in this way shows your support for free software and
the LDP. If you have questions or comments, please contact the address
above.
</p><!-- l. 80 -->
   <h4 id="authorship"><span>1.1   </span> <a id="x1-20001.1"></a>Authorship</h4>
<!-- l. 83 --><p>The Linux Kernel Module Programming Guide was originally written for the 2.2
kernels by Ori Pomerantz. Eventually, Ori no longer had time to maintain the
document. After all, the Linux kernel is a fast moving target. Peter Jay Salzman took
over maintenance and updated it for the 2.4 kernels. Eventually, Peter no longer had
time to follow developments with the 2.6 kernel, so Michael Burian became a
co-maintainer to update the document for the 2.6 kernels. Bob Mottram updated the
examples for 3.8+ kernels. Jim Huang upgraded to recent kernel versions (v5.x) and
revised the LaTeX document.
</p><!-- l. 91 -->
   <h4 id="acknowledgements"><span>1.2   </span> <a id="x1-30001.2"></a>Acknowledgements</h4>
<!-- l. 94 --><p>The following people have contributed corrections or good suggestions:
</p>
<p>
 2011eric, 25077667, Arush Sharma, asas1asas200, Benno Bielmeier, Bob Lee,
Brad Baker, ccs100203, Chih-Yu Chen, Ching-Hua (Vivian) Lin,
ChinYikMing, Cyril Brulebois, Daniele Paolo Scarpazza, David Porter,
demonsome, Dimo Velev, Ekang Monyet, fennecJ, Francois Audeon,
gagachang, Gilad Reti, Horst Schirmeier, Hsin-Hsiang Peng, Ignacio Martin,
JianXing Wu, linD026, lyctw, manbing, Marconi Jiang, mengxinayan,
RinHizakura, Roman Lakeev, Stacy Prowell, Steven Lung, Tristan Lelong,
Tucker Polomik, VxTeemo, Wei-Lun Tsai, xatier, Ylowy. </p>
                                                                  

                                                                  
<!-- l. 100 -->
   <h4 id="what-is-a-kernel-module"><span>1.3   </span> <a id="x1-40001.3"></a>What Is A Kernel Module?</h4>
<!-- l. 103 --><p>So, you want to write a kernel module. You know C, you have written a few normal
programs to run as processes, and now you want to get to where the real action is, to
where a single wild pointer can wipe out your file system and a core dump means a
reboot.
</p><!-- l. 106 --><p>   What exactly is a kernel module? Modules are pieces of code that can be loaded
and unloaded into the kernel upon demand. They extend the functionality of the
kernel without the need to reboot the system. For example, one type of module is the
device driver, which allows the kernel to access hardware connected to the system.
Without modules, we would have to build monolithic kernels and add new
functionality directly into the kernel image. Besides having larger kernels, this has
the disadvantage of requiring us to rebuild and reboot the kernel every time we want
new functionality.
</p><!-- l. 113 -->
   <h4 id="kernel-module-package"><span>1.4   </span> <a id="x1-50001.4"></a>Kernel module package</h4>
<!-- l. 116 --><p>Linux distributions provide the commands
<code> <span>modprobe</span>
</code>, <code>  <span>insmod</span>
</code> and <code>  <span>depmod</span>
</code> within a package.
</p><!-- l. 118 --><p>   On Ubuntu/Debian: 
</p>
   <pre id="fancyvrb1"><a id="x1-5006r1"></a><span>1</span><span>sudo apt-get install build-essential kmod</span></pre>
<!-- l. 123 --><p>   On Arch Linux: 
</p>
   <pre id="fancyvrb2"><a id="x1-5009r1"></a><span>1</span><span>sudo pacman -S gcc kmod</span></pre>
<!-- l. 128 -->
   <h4 id="what-modules-are-in-my-kernel"><span>1.5   </span> <a id="x1-60001.5"></a>What Modules are in my Kernel?</h4>
<!-- l. 131 --><p>To discover what modules are already loaded within your current kernel use the command
<code> <span>lsmod</span>
</code>. 
                                                                  

                                                                  
</p>
   <pre id="fancyvrb3"><a id="x1-6004r1"></a><span>1</span><span>sudo lsmod</span></pre>
<!-- l. 136 --><p>   Modules are stored within the file <span><span><span>/proc/modules</span></span></span>, so you can also see them with:

</p>
   <pre id="fancyvrb4"><a id="x1-6007r1"></a><span>1</span><span>sudo cat /proc/modules</span></pre>
<!-- l. 141 --><p>   This can be a long list, and you might prefer to search for something particular.
To search for the <span><span><span>fat</span></span></span> module: 
</p>
   <pre id="fancyvrb5"><a id="x1-6010r1"></a><span>1</span><span>sudo lsmod | grep fat</span></pre>
<!-- l. 147 -->
   <h4 id="do-i-need-to-download-and-compile-the-kernel"><span>1.6   </span> <a id="x1-70001.6"></a>Do I need to download and compile the kernel?</h4>
<!-- l. 149 --><p>For the purposes of following this guide you don’t necessarily need to do that.
However, it would be wise to run the examples within a test distribution running
on a virtual machine in order to avoid any possibility of messing up your
system.
</p><!-- l. 152 -->
   <h4 id="before-we-begin"><span>1.7   </span> <a id="x1-80001.7"></a>Before We Begin</h4>
<!-- l. 154 --><p>Before we delve into code, there are a few issues we need to cover. Everyone’s system
is different and everyone has their own groove. Getting your first &#34;hello world&#34;
program to compile and load correctly can sometimes be a trick. Rest assured, after
you get over the initial hurdle of doing it for the first time, it will be smooth sailing
thereafter.
</p><!-- l. 159 --><ol>
<li id="x1-8002x1">Modversioning. A module compiled for one kernel will not load if you boot
     a different kernel unless you enable <code>  <span>CONFIG_MODVERSIONS</span>
     </code> in the kernel. We will not go into module versioning until later in this
     guide. Until we cover modversions, the examples in the guide may not
                                                                  

                                                                  
     work if you are running a kernel with modversioning turned on. However,
     most stock Linux distribution kernels come with it turned on. If you are
     having trouble loading the modules because of versioning errors, compile
     a kernel with modversioning turned off.
     </li>
<li id="x1-8005x2">
     <!-- l. 167 --><p>Using X Window System. <a id="x1-80042"></a>It is highly recommended that you extract,
     compile and load all the examples this guide discusses from a console. You
     should not be working on this stuff in X Window System.
     </p><!-- l. 172 --><p>Modules can not print to the screen like <code>  <span>printf()</span>
     </code> can, but they can log information and warnings, which ends up being
     printed on your screen, but only on a console. If you <code>  <span>insmod</span>
     </code> a module from an xterm, the information and warnings will be logged, but
     only to your systemd journal. You will not see it unless you look through
     your <code>  <span>journalctl</span>
     </code> . See <a href="#hello-world">4<!-- tex4ht:ref: sec:helloworld  --></a> for details. To have immediate access to this information, do all
     your work from the console.
     </p></li>
<li id="x1-8010x3">
     <!-- l. 177 --><p>SecureBoot. Many contemporary computers are pre-configured with UEFI
     SecureBoot enabled. It is a security standard that can make sure the
     device boots using only software that is trusted by original equipment
     manufacturer. The default Linux kernel from some distributions have also
     enabled the SecureBoot. For such distributions, the kernel module has to
     be signed with the security key or you would get the &#34;<span>ERROR: could not
     </span><span>insert module</span>&#34; when you insert your first hello world module:
     </p><!-- l. 1 -->
     <pre id="fancyvrb6"><a id="x1-8013r1"></a><span>1</span><span>insmod ./hello-1.ko</span></pre>
     <!-- l. 186 --><p>And then you can check further with
     <code>  <span>dmesg</span>
     </code> and see the following text:
     </p><!-- l. 189 --><p><span>Lockdown: insmod: unsigned module loading is restricted; see man kernel
     </span><span>lockdown.7</span>
     </p><!-- l. 191 --><p>If you got this message, the simplest way is to disable the UEFI SecureBoot
                                                                  

                                                                  
     from the PC/laptop boot menu to have your &#34;hello-1&#34; to be inserted. Of course
     you can go through complicated steps to generate keys, install keys to your
     system, and finally sign your module to make it work. However, this is not
     suitable for beginners. You could read and follow the steps in <a href="https://wiki.debian.org/SecureBoot">SecureBoot</a> if you
     are interested.</p></li></ol>
<!-- l. 197 -->
   
<!-- l. 199 --><p>Before you can build anything you’ll need to install the header files for your
kernel.
</p><!-- l. 201 --><p>   On Ubuntu/Debian: 
</p>
   <pre id="fancyvrb7"><a id="x1-9004r1"></a><span>1</span><span>sudo apt-get update</span> 
<a id="x1-9006r2"></a><span>2</span><span>apt-cache search linux-headers-</span><span id="textcolor1"><span>`</span></span><span>uname -r</span><span id="textcolor2"><span>`</span></span></pre>
<!-- l. 207 --><p>   This will tell you what kernel header files are available. Then for example: 
</p>
   <pre id="fancyvrb8"><a id="x1-9009r1"></a><span>1</span><span>sudo apt-get install kmod linux-headers-5.4.0-80-generic</span></pre>
<!-- l. 213 --><p>   On Arch Linux: 
</p>
   <pre id="fancyvrb9"><a id="x1-9012r1"></a><span>1</span><span>sudo pacman -S linux-headers</span></pre>
<!-- l. 218 -->
   <h3 id="examples"><span>3   </span> <a id="x1-100003"></a>Examples</h3>
<!-- l. 220 --><p>All the examples from this document are available within the <span><span><span>examples</span></span></span>
subdirectory.
</p><!-- l. 222 --><p>   If there are any compile errors then you might have a more recent kernel version
or need to install the corresponding kernel header files.
</p><!-- l. 224 -->
   <h3 id="hello-world"><span>4   </span> <a id="x1-110004"></a>Hello World</h3>
                                                                  

                                                                  
<!-- l. 226 -->
   <h4 id="the-simplest-module"><span>4.1   </span> <a id="x1-120004.1"></a>The Simplest Module</h4>
<!-- l. 228 --><p>Most people learning programming start out with some sort of &#34;<span>hello world</span>&#34;
example. I don’t know what happens to people who break with this tradition, but I
think it is safer not to find out. We will start with a series of hello world
programs that demonstrate the different aspects of the basics of writing a kernel
module.
</p><!-- l. 232 --><p>   Here is the simplest module possible.
</p><!-- l. 234 --><p>   Make a test directory: 
</p>
   <pre id="fancyvrb10"><a id="x1-12004r1"></a><span>1</span><span>mkdir -p ~/develop/kernel/hello-1</span> 
<a id="x1-12006r2"></a><span>2</span><span>cd ~/develop/kernel/hello-1</span></pre>
<!-- l. 240 --><p>   Paste this into your favorite editor and save it as <span><span><span>hello-1.c</span></span></span>:
</p><!-- l. 1 -->
   <pre id="fancyvrb11"><a id="x1-12008r1"></a><span>1</span><span id="textcolor3"><span>/*</span></span> 
<a id="x1-12010r2"></a><span>2</span><span id="textcolor4"><span> * hello-1.c - The simplest kernel module.</span></span> 
<a id="x1-12012r3"></a><span>3</span><span id="textcolor5"><span> */</span></span> 
<a id="x1-12014r4"></a><span>4</span><span id="textcolor6"><span>#include</span></span><span> </span><span id="textcolor7"><span>&lt;linux/module.h&gt; /* Needed by all modules */</span></span> 
<a id="x1-12016r5"></a><span>5</span><span id="textcolor8"><span>#include</span></span><span> </span><span id="textcolor9"><span>&lt;linux/printk.h&gt; /* Needed for pr_info() */</span></span> 
<a id="x1-12018r6"></a><span>6</span> 
<a id="x1-12020r7"></a><span>7</span><span id="textcolor10"><span>int</span></span><span> init_module(</span><span id="textcolor11"><span>void</span></span><span>)</span> 
<a id="x1-12022r8"></a><span>8</span><span>{</span> 
<a id="x1-12024r9"></a><span>9</span><span>    pr_info(</span><span id="textcolor12"><span>&#34;Hello world 1.</span></span><span id="textcolor13"><span>\n</span></span><span id="textcolor14"><span>&#34;</span></span><span>);</span> 
<a id="x1-12026r10"></a><span>10</span> 
<a id="x1-12028r11"></a><span>11</span><span>    </span><span id="textcolor15"><span>/* A non 0 return means init_module failed; module can</span><span>&#39;</span><span>t be loaded. */</span></span> 
<a id="x1-12030r12"></a><span>12</span><span>    </span><span id="textcolor16"><span>return</span></span><span> 0;</span> 
<a id="x1-12032r13"></a><span>13</span><span>}</span> 
<a id="x1-12034r14"></a><span>14</span> 
<a id="x1-12036r15"></a><span>15</span><span id="textcolor17"><span>void</span></span><span> cleanup_module(</span><span id="textcolor18"><span>void</span></span><span>)</span> 
<a id="x1-12038r16"></a><span>16</span><span>{</span> 
<a id="x1-12040r17"></a><span>17</span><span>    pr_info(</span><span id="textcolor19"><span>&#34;Goodbye world 1.</span></span><span id="textcolor20"><span>\n</span></span><span id="textcolor21"><span>&#34;</span></span><span>);</span> 
<a id="x1-12042r18"></a><span>18</span><span>}</span> 
<a id="x1-12044r19"></a><span>19</span> 
<a id="x1-12046r20"></a><span>20</span><span>MODULE_LICENSE(</span><span id="textcolor22"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 244 --><p>   Now you will need a <span><span><span>Makefile</span></span></span>. If you copy and paste this, change the indentation
to use <span>tabs</span>, not spaces.
</p><!-- l. 1 -->
   <pre id="fancyvrb12"><a id="x1-12057r1"></a><span>1</span><span>obj-m += hello-1.o</span> 
<a id="x1-12059r2"></a><span>2</span> 
<a id="x1-12061r3"></a><span>3</span><span>PWD := </span><span id="colorbox23"><span>$</span></span><span>(CURDIR)</span> 
<a id="x1-12063r4"></a><span>4</span> 
<a id="x1-12065r5"></a><span>5</span><span>all:</span> 
<a id="x1-12067r6"></a><span>6</span><span>    make -C /lib/modules/</span><span id="colorbox24"><span>$</span></span><span>(shell uname -r)/build M=</span><span id="colorbox25"><span>$</span></span><span>(PWD) modules</span> 
<a id="x1-12069r7"></a><span>7</span> 
<a id="x1-12071r8"></a><span>8</span><span>clean:</span> 
<a id="x1-12073r9"></a><span>9</span><span>    make -C /lib/modules/</span><span id="colorbox26"><span>$</span></span><span>(shell uname -r)/build M=</span><span id="colorbox27"><span>$</span></span><span>(PWD) clean</span></pre>
<!-- l. 258 --><p>   In <span><span><span>Makefile</span></span></span>, <span><span><span>$(CURDIR)</span></span></span> can set to the absolute pathname of the current working
directory(after all <span><span><span>-C</span></span></span> options are processed, if any). See more about <span><span><span>CURDIR</span></span></span> in <a href="https://www.gnu.org/software/make/manual/make.html">GNU
make manual</a>.
</p><!-- l. 261 --><p>   And finally, just run <span><span><span>make</span></span></span> directly.
</p><!-- l. 1 -->
   <pre id="fancyvrb13"><a id="x1-12076r1"></a><span>1</span><span>make</span></pre>
<!-- l. 267 --><p>   If there is no <span><span><span>PWD := $(CURDIR)</span></span></span> statement in Makefile, then it may not compile
correctly with <span><span><span>sudo make</span></span></span>. Because some environment variables are specified by
the security policy, they can’t be inherited. The default security policy is
<span><span><span>sudoers</span></span></span>. In the <span><span><span>sudoers</span></span></span> security policy, <span><span><span>env_reset</span></span></span> is enabled by default,
which restricts environment variables. Specifically, path variables are not
retained from the user environment, they are set to default values (For more
information see: <a href="https://www.sudo.ws/docs/man/sudoers.man/">sudoers manual</a>). You can see the environment variable settings
by:
                                                                  

                                                                  
</p>
   <pre id="verbatim-1">$ sudo -s
# sudo -V
</pre>
<!-- l. 277 --><!-- l. 279 --><p>   Here is a simple Makefile as an example to demonstrate the problem mentioned
above.
</p><!-- l. 1 -->
   <pre id="fancyvrb14"><a id="x1-12080r1"></a><span>1</span><span>all:</span> 
<a id="x1-12082r2"></a><span>2</span><span>    echo </span><span id="colorbox28"><span>$</span></span><span>(PWD)</span></pre>
<!-- l. 286 --><p>   Then, we can use <span><span><span>-p</span></span></span> flag to print out the environment variable values from the
Makefile.
                                                                  

                                                                  
</p>
   <pre id="verbatim-2">$ make -p | grep PWD
PWD = /home/ubuntu/temp
OLDPWD = /home/ubuntu
    echo $(PWD)
</pre>
<!-- l. 293 --><!-- l. 295 --><p>   The <span><span><span>PWD</span></span></span> variable won’t be inherited with <span><span><span>sudo</span></span></span>.
                                                                  

                                                                  
</p>
   <pre id="verbatim-3">$ sudo make -p | grep PWD
    echo $(PWD)
</pre>
<!-- l. 300 --><!-- l. 302 --><p>   However, there are three ways to solve this problem.
</p><!-- l. 304 --><ol>
<li id="x1-12084x1">
     <!-- l. 305 --><p> You can use the <span><span><span>-E</span></span></span> flag to temporarily preserve them.
     </p><!-- l. 1 -->
     <pre id="fancyvrb15"><a id="x1-12090r1"></a><span>1</span><span>    $ sudo -E make -p | grep PWD</span> 
<a id="x1-12092r2"></a><span>2</span><span>    PWD = /home/ubuntu/temp</span> 
<a id="x1-12094r3"></a><span>3</span><span>    OLDPWD = /home/ubuntu</span> 
<a id="x1-12096r4"></a><span>4</span><span>    echo </span><span id="textcolor29"><span>$(</span></span><span>PWD</span><span id="textcolor30"><span>)</span></span></pre>
     </li>
<li id="x1-12098x2">
     <!-- l. 316 --><p> You can set the <span><span><span>env_reset</span></span></span> disabled by editing the <span><span><span>/etc/sudoers</span></span></span> with
     root and <span><span><span>visudo</span></span></span>.
     </p><!-- l. 1 -->
     <pre id="fancyvrb16"><a id="x1-12105r1"></a><span>1</span><span>  </span><span id="textcolor31"><span>## sudoers file.</span></span> 
<a id="x1-12107r2"></a><span>2</span><span>  </span><span id="textcolor32"><span>##</span></span> 
<a id="x1-12109r3"></a><span>3</span><span>  ...</span> 
<a id="x1-12111r4"></a><span>4</span><span>  Defaults env_reset</span> 
<a id="x1-12113r5"></a><span>5</span><span>  </span><span id="textcolor33"><span>## Change env_reset to !env_reset in previous line to keep all environment variables</span></span></pre>
     <!-- l. 327 --><p>Then execute <span><span><span>env</span></span></span> and <span><span><span>sudo env</span></span></span> individually.
     </p><!-- l. 1 -->
     <pre id="fancyvrb17"><a id="x1-12121r1"></a><span>1</span><span>    </span><span id="textcolor34"><span># disable the env_reset</span></span> 
<a id="x1-12123r2"></a><span>2</span><span>    echo </span><span id="textcolor35"><span>&#34;user:&#34;</span></span><span> &gt; non-env_reset.log; env &gt;&gt; non-env_reset.log</span> 
<a id="x1-12125r3"></a><span>3</span><span>    echo </span><span id="textcolor36"><span>&#34;root:&#34;</span></span><span> &gt;&gt; non-env_reset.log; sudo env &gt;&gt; non-env_reset.log</span> 
<a id="x1-12127r4"></a><span>4</span><span>    </span><span id="textcolor37"><span># enable the env_reset</span></span> 
<a id="x1-12129r5"></a><span>5</span><span>    echo </span><span id="textcolor38"><span>&#34;user:&#34;</span></span><span> &gt; env_reset.log; env &gt;&gt; env_reset.log</span> 
<a id="x1-12131r6"></a><span>6</span><span>    echo </span><span id="textcolor39"><span>&#34;root:&#34;</span></span><span> &gt;&gt; env_reset.log; sudo env &gt;&gt; env_reset.log</span></pre>
     <!-- l. 338 --><p>You  can  view  and  compare  these  logs  to  find  differences  between
     <span><span><span>env_reset</span></span></span> and <span><span><span>!env_reset</span></span></span>.
     </p></li>
<li id="x1-12133x3">
     <!-- l. 341 --><p>You can preserve environment variables by appending them to <span><span><span>env_keep</span></span></span>
     in <span><span><span>/etc/sudoers</span></span></span>.
     </p><!-- l. 1 -->
     <pre id="fancyvrb18"><a id="x1-12136r1"></a><span>1</span><span>  Defaults env_keep += </span><span id="textcolor40"><span>&#34;PWD&#34;</span></span></pre>
     <!-- l. 347 --><p>After applying the above change, you can check the environment variable
     settings by:
                                                                  

                                                                  
</p>
     <pre id="verbatim-4">         $ sudo -s
         # sudo -V
       
</pre>
     <!-- l. 352 --></li></ol>
<!-- l. 356 --><p>   If all goes smoothly you should then find that you have a compiled <span><span><span>hello-1.ko</span></span></span>
module. You can find info on it with the command: 
</p>
   <pre id="fancyvrb19"><a id="x1-12139r1"></a><span>1</span><span>modinfo hello-1.ko</span></pre>
<!-- l. 362 --><p>   At this point the command: 
</p>
   <pre id="fancyvrb20"><a id="x1-12142r1"></a><span>1</span><span>sudo lsmod | grep hello</span></pre>
<!-- l. 367 --><p>   should return nothing. You can try loading your shiny new module with: 
</p>
   <pre id="fancyvrb21"><a id="x1-12145r1"></a><span>1</span><span>sudo insmod hello-1.ko</span></pre>
<!-- l. 373 --><p>   The dash character will get converted to an underscore, so when you again try: 
</p>
   <pre id="fancyvrb22"><a id="x1-12148r1"></a><span>1</span><span>sudo lsmod | grep hello</span></pre>
<!-- l. 378 --><p>   you should now see your loaded module. It can be removed again with: 
</p>
   <pre id="fancyvrb23"><a id="x1-12151r1"></a><span>1</span><span>sudo rmmod hello_1</span></pre>
<!-- l. 383 --><p>   Notice that the dash was replaced by an underscore. To see what just happened in
the logs: 
                                                                  

                                                                  
</p>
   <pre id="fancyvrb24"><a id="x1-12154r1"></a><span>1</span><span>sudo journalctl --since </span><span id="textcolor41"><span>&#34;1 hour ago&#34;</span></span><span> | grep kernel</span></pre>
<!-- l. 389 --><p>   You now know the basics of creating, compiling, installing and removing modules.
Now for more of a description of how this module works.
</p><!-- l. 392 --><p>   Kernel modules must have at least two functions: a &#34;start&#34; (initialization) function
called <code>  <span>init_module()</span>
</code> which is called when the module is <code>  <span>insmod</span>
</code>ed into the kernel, and an &#34;end&#34; (cleanup) function called
<code> <span>cleanup_module()</span>
</code> which is called just before it is removed from the kernel. Actually, things have
changed starting with kernel 2.3.13. You can now use whatever name you like for the
start and end functions of a module, and you will learn how to do this in Section <a href="#hello-and-goodbye">4.2<!-- tex4ht:ref: hello_n_goodbye  --></a>.
In fact, the new method is the preferred method. However, many people still use
<code> <span>init_module()</span>
</code> and <code>  <span>cleanup_module()</span>
</code> for their start and end functions.
</p><!-- l. 399 --><p>   Typically, <code>  <span>init_module()</span>
</code> either registers a handler for something with the kernel, or it replaces one of the kernel
functions with its own code (usually code to do something and then call the original function).
The <code>  <span>cleanup_module()</span>
</code> function is supposed to undo whatever
<code> <span>init_module()</span>
</code> did, so the module can be unloaded safely.
</p><!-- l. 402 --><p>   Lastly, every kernel module needs to include <span><span><span>&lt;linux/module.h&gt;</span></span></span>. We
needed to include <span><span><span>&lt;linux/printk.h&gt;</span></span></span> only for the macro expansion for the
<code> <span>pr_alert()</span>
</code> log level, which you’ll learn about in Section <a href="#x1-121662">2<!-- tex4ht:ref: sec:printk  --></a>.
</p><!-- l. 406 --><ol>
<li id="x1-12165x1">A point about coding style. Another thing which may not be immediately
     obvious  to  anyone  getting  started  with  kernel  programming  is  that
     indentation within your code should be using <span>tabs </span>and <span>not spaces</span>. It is
     one of the coding conventions of the kernel. You may not like it, but you’ll
     need to get used to it if you ever submit a patch upstream.
     </li>
<li id="x1-12167x2">Introducing print macros. <a id="x1-121662"></a>In the beginning there was <code>  <span>printk</span>
     </code>, usually followed by a priority such as <code>  <span>KERN_INFO</span>
                                                                  

                                                                  
     </code> or <code>  <span>KERN_DEBUG</span>
     </code>. More recently this can also be expressed in abbreviated form using a set of
     print macros, such as <code>  <span>pr_info</span>
     </code> and <code>  <span>pr_debug</span>
     </code>. This just saves some mindless keyboard bashing and looks a bit neater.
     They can be found within <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/printk.h">include/linux/printk.h</a>. Take time to read through
     the available priority macros.
     </li>
<li id="x1-12174x3">
     <!-- l. 420 --><p>About Compiling. Kernel modules need to be compiled a bit differently
     from  regular  userspace  apps.  Former  kernel  versions  required  us  to
     care much about these settings, which are usually stored in Makefiles.
     Although hierarchically organized, many redundant settings accumulated
     in sublevel Makefiles and made them large and rather difficult to maintain.
     Fortunately, there is a new way of doing these things, called kbuild, and
     the build process for external loadable modules is now fully integrated into
     the standard kernel build mechanism. To learn more on how to compile
     modules which are not part of the official kernel (such as all the examples
     you will find in this guide), see file <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/modules.rst">Documentation/kbuild/modules.rst</a>.
     </p><!-- l. 427 --><p>Additional  details  about  Makefiles  for  kernel  modules  are  available  in
     <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/makefiles.rst">Documentation/kbuild/makefiles.rst</a>. Be sure to read this and the related
     files before starting to hack Makefiles. It will probably save you lots of
     work.
     </p><!-- l. 429 --><blockquote>
         <!-- l. 430 --><p>Here is another exercise for the reader. See that comment above
         the return statement in <code>  <span>init_module()</span>
         </code>? Change the return value to something negative, recompile and
         load the module again. What happens?</p></blockquote>
     </li></ol>
<!-- l. 437 -->
   <h4 id="hello-and-goodbye"><span>4.2   </span> <a id="x1-130004.2"></a>Hello and Goodbye</h4>
<!-- l. 439 --><p>In early kernel versions you had to use the
                                                                  

                                                                  
<code> <span>init_module</span>
</code> and <code>  <span>cleanup_module</span>
</code> functions, as in the first hello world example, but these days you can name those anything you
want by using the <code>  <span>module_init</span>
</code> and <code>  <span>module_exit</span>
</code> macros. These macros are defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">include/linux/module.h</a>. The only requirement
is that your init and cleanup functions must be defined before calling the those
macros, otherwise you’ll get compilation errors. Here is an example of this
technique:
</p><!-- l. 1 -->
   <pre id="fancyvrb25"><a id="x1-13006r1"></a><span>1</span><span id="textcolor42"><span>/*</span></span> 
<a id="x1-13008r2"></a><span>2</span><span id="textcolor43"><span> * hello-2.c - Demonstrating the module_init() and module_exit() macros.</span></span> 
<a id="x1-13010r3"></a><span>3</span><span id="textcolor44"><span> * This is preferred over using init_module() and cleanup_module().</span></span> 
<a id="x1-13012r4"></a><span>4</span><span id="textcolor45"><span> */</span></span> 
<a id="x1-13014r5"></a><span>5</span><span id="textcolor46"><span>#include</span></span><span> </span><span id="textcolor47"><span>&lt;linux/init.h&gt; /* Needed for the macros */</span></span> 
<a id="x1-13016r6"></a><span>6</span><span id="textcolor48"><span>#include</span></span><span> </span><span id="textcolor49"><span>&lt;linux/module.h&gt; /* Needed by all modules */</span></span> 
<a id="x1-13018r7"></a><span>7</span><span id="textcolor50"><span>#include</span></span><span> </span><span id="textcolor51"><span>&lt;linux/printk.h&gt; /* Needed for pr_info() */</span></span> 
<a id="x1-13020r8"></a><span>8</span> 
<a id="x1-13022r9"></a><span>9</span><span id="textcolor52"><span>static</span></span><span> </span><span id="textcolor53"><span>int</span></span><span> __init hello_2_init(</span><span id="textcolor54"><span>void</span></span><span>)</span> 
<a id="x1-13024r10"></a><span>10</span><span>{</span> 
<a id="x1-13026r11"></a><span>11</span><span>    pr_info(</span><span id="textcolor55"><span>&#34;Hello, world 2</span></span><span id="textcolor56"><span>\n</span></span><span id="textcolor57"><span>&#34;</span></span><span>);</span> 
<a id="x1-13028r12"></a><span>12</span><span>    </span><span id="textcolor58"><span>return</span></span><span> 0;</span> 
<a id="x1-13030r13"></a><span>13</span><span>}</span> 
<a id="x1-13032r14"></a><span>14</span> 
<a id="x1-13034r15"></a><span>15</span><span id="textcolor59"><span>static</span></span><span> </span><span id="textcolor60"><span>void</span></span><span> __exit hello_2_exit(</span><span id="textcolor61"><span>void</span></span><span>)</span> 
<a id="x1-13036r16"></a><span>16</span><span>{</span> 
<a id="x1-13038r17"></a><span>17</span><span>    pr_info(</span><span id="textcolor62"><span>&#34;Goodbye, world 2</span></span><span id="textcolor63"><span>\n</span></span><span id="textcolor64"><span>&#34;</span></span><span>);</span> 
<a id="x1-13040r18"></a><span>18</span><span>}</span> 
<a id="x1-13042r19"></a><span>19</span> 
<a id="x1-13044r20"></a><span>20</span><span>module_init(hello_2_init);</span> 
<a id="x1-13046r21"></a><span>21</span><span>module_exit(hello_2_exit);</span> 
<a id="x1-13048r22"></a><span>22</span> 
<a id="x1-13050r23"></a><span>23</span><span>MODULE_LICENSE(</span><span id="textcolor65"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 446 --><p>   So now we have two real kernel modules under our belt. Adding another module
is as simple as this:
</p><!-- l. 1 -->
   <pre id="fancyvrb26"><a id="x1-13062r1"></a><span>1</span><span>obj-m += hello-1.o</span> 
<a id="x1-13064r2"></a><span>2</span><span>obj-m += hello-2.o</span> 
<a id="x1-13066r3"></a><span>3</span> 
<a id="x1-13068r4"></a><span>4</span><span>PWD := </span><span id="colorbox66"><span>$</span></span><span>(CURDIR)</span> 
<a id="x1-13070r5"></a><span>5</span> 
<a id="x1-13072r6"></a><span>6</span><span>all:</span> 
<a id="x1-13074r7"></a><span>7</span><span>    make -C /lib/modules/</span><span id="colorbox67"><span>$</span></span><span>(shell uname -r)/build M=</span><span id="colorbox68"><span>$</span></span><span>(PWD) modules</span> 
<a id="x1-13076r8"></a><span>8</span> 
<a id="x1-13078r9"></a><span>9</span><span>clean:</span> 
<a id="x1-13080r10"></a><span>10</span><span>    make -C /lib/modules/</span><span id="colorbox69"><span>$</span></span><span>(shell uname -r)/build M=</span><span id="colorbox70"><span>$</span></span><span>(PWD) clean</span></pre>
<!-- l. 461 --><p>   Now have a look at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/char/Makefile">drivers/char/Makefile</a> for a real world example. As
you can see, some things got hardwired into the kernel (<span><span><span>obj-y</span></span></span>) but where
have all those <span><span><span>obj-m</span></span></span> gone? Those familiar with shell scripts will easily be
able to spot them. For those who are not, the <span><span><span>obj-$(CONFIG_FOO)</span></span></span> entries
you see everywhere expand into <span><span><span>obj-y</span></span></span> or <span><span><span>obj-m</span></span></span>, depending on whether the
<span><span><span>CONFIG_FOO</span></span></span> variable has been set to <span><span><span>y</span></span></span> or <span><span><span>m</span></span></span>. While we are at it, those were
exactly the kind of variables that you have set in the <span><span><span>.config</span></span></span> file in the
top-level directory of Linux kernel source tree, the last time when you said
<code> <span>make menuconfig</span>
</code> or something like that.
</p><!-- l. 467 -->
   <h4 id="the-init-and-exit-macros"><span>4.3   </span> <a id="x1-140004.3"></a>The __init and __exit Macros</h4>
<!-- l. 469 --><p>The <code>  <span>__init</span>
</code> macro causes the init function to be discarded and its memory freed once the init
function finishes for built-in drivers, but not loadable modules. If you think about
when the init function is invoked, this makes perfect sense.
</p><!-- l. 472 --><p>   There is also an <code>  <span>__initdata</span>
</code> which works similarly to <code>  <span>__init</span>
</code> but for init variables rather than functions.
</p><!-- l. 474 --><p>   The <code>  <span>__exit</span>
</code> macro causes the omission of the function when the module is built into the kernel, and
like <code>  <span>__init</span>
</code>, has no effect for loadable modules. Again, if you consider when the cleanup function
runs, this makes complete sense; built-in drivers do not need a cleanup function,
                                                                  

                                                                  
while loadable modules do.
</p><!-- l. 477 --><p>   These macros are defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/init.h">include/linux/init.h</a> and serve to free up kernel
memory. When you boot your kernel and see something like Freeing unused kernel
memory: 236k freed, this is precisely what the kernel is freeing.
</p><!-- l. 1 -->
   <pre id="fancyvrb27"><a id="x1-14007r1"></a><span>1</span><span id="textcolor71"><span>/*</span></span> 
<a id="x1-14009r2"></a><span>2</span><span id="textcolor72"><span> * hello-3.c - Illustrating the __init, __initdata and __exit macros.</span></span> 
<a id="x1-14011r3"></a><span>3</span><span id="textcolor73"><span> */</span></span> 
<a id="x1-14013r4"></a><span>4</span><span id="textcolor74"><span>#include</span></span><span> </span><span id="textcolor75"><span>&lt;linux/init.h&gt; /* Needed for the macros */</span></span> 
<a id="x1-14015r5"></a><span>5</span><span id="textcolor76"><span>#include</span></span><span> </span><span id="textcolor77"><span>&lt;linux/module.h&gt; /* Needed by all modules */</span></span> 
<a id="x1-14017r6"></a><span>6</span><span id="textcolor78"><span>#include</span></span><span> </span><span id="textcolor79"><span>&lt;linux/printk.h&gt; /* Needed for pr_info() */</span></span> 
<a id="x1-14019r7"></a><span>7</span> 
<a id="x1-14021r8"></a><span>8</span><span id="textcolor80"><span>static</span></span><span> </span><span id="textcolor81"><span>int</span></span><span> hello3_data __initdata = 3;</span> 
<a id="x1-14023r9"></a><span>9</span> 
<a id="x1-14025r10"></a><span>10</span><span id="textcolor82"><span>static</span></span><span> </span><span id="textcolor83"><span>int</span></span><span> __init hello_3_init(</span><span id="textcolor84"><span>void</span></span><span>)</span> 
<a id="x1-14027r11"></a><span>11</span><span>{</span> 
<a id="x1-14029r12"></a><span>12</span><span>    pr_info(</span><span id="textcolor85"><span>&#34;Hello, world %d</span></span><span id="textcolor86"><span>\n</span></span><span id="textcolor87"><span>&#34;</span></span><span>, hello3_data);</span> 
<a id="x1-14031r13"></a><span>13</span><span>    </span><span id="textcolor88"><span>return</span></span><span> 0;</span> 
<a id="x1-14033r14"></a><span>14</span><span>}</span> 
<a id="x1-14035r15"></a><span>15</span> 
<a id="x1-14037r16"></a><span>16</span><span id="textcolor89"><span>static</span></span><span> </span><span id="textcolor90"><span>void</span></span><span> __exit hello_3_exit(</span><span id="textcolor91"><span>void</span></span><span>)</span> 
<a id="x1-14039r17"></a><span>17</span><span>{</span> 
<a id="x1-14041r18"></a><span>18</span><span>    pr_info(</span><span id="textcolor92"><span>&#34;Goodbye, world 3</span></span><span id="textcolor93"><span>\n</span></span><span id="textcolor94"><span>&#34;</span></span><span>);</span> 
<a id="x1-14043r19"></a><span>19</span><span>}</span> 
<a id="x1-14045r20"></a><span>20</span> 
<a id="x1-14047r21"></a><span>21</span><span>module_init(hello_3_init);</span> 
<a id="x1-14049r22"></a><span>22</span><span>module_exit(hello_3_exit);</span> 
<a id="x1-14051r23"></a><span>23</span> 
<a id="x1-14053r24"></a><span>24</span><span>MODULE_LICENSE(</span><span id="textcolor95"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 482 -->
   <h4 id="licensing-and-module-documentation"><span>4.4   </span> <a id="x1-150004.4"></a>Licensing and Module Documentation</h4>
<!-- l. 484 --><p>Honestly, who loads or even cares about proprietary modules? If you do then you
might have seen something like this:
                                                                  

                                                                  
</p>
   <pre id="verbatim-5">$ sudo insmod xxxxxx.ko
loading out-of-tree module taints kernel.
module license &#39;unspecified&#39; taints kernel.
</pre>
<!-- l. 490 --><!-- l. 492 --><p>   You can use a few macros to indicate the license for your module. Some examples
are &#34;GPL&#34;, &#34;GPL v2&#34;, &#34;GPL and additional rights&#34;, &#34;Dual BSD/GPL&#34;, &#34;Dual
MIT/GPL&#34;, &#34;Dual MPL/GPL&#34; and &#34;Proprietary&#34;. They are defined within
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">include/linux/module.h</a>.
</p><!-- l. 496 --><p>   To reference what license you’re using a macro is available called
<code> <span>MODULE_LICENSE</span>
</code>. This and a few other macros describing the module are illustrated in the below
example.
</p><!-- l. 1 -->
   <pre id="fancyvrb28"><a id="x1-15003r1"></a><span>1</span><span id="textcolor96"><span>/*</span></span> 
<a id="x1-15005r2"></a><span>2</span><span id="textcolor97"><span> * hello-4.c - Demonstrates module documentation.</span></span> 
<a id="x1-15007r3"></a><span>3</span><span id="textcolor98"><span> */</span></span> 
<a id="x1-15009r4"></a><span>4</span><span id="textcolor99"><span>#include</span></span><span> </span><span id="textcolor100"><span>&lt;linux/init.h&gt; /* Needed for the macros */</span></span> 
<a id="x1-15011r5"></a><span>5</span><span id="textcolor101"><span>#include</span></span><span> </span><span id="textcolor102"><span>&lt;linux/module.h&gt; /* Needed by all modules */</span></span> 
<a id="x1-15013r6"></a><span>6</span><span id="textcolor103"><span>#include</span></span><span> </span><span id="textcolor104"><span>&lt;linux/printk.h&gt; /* Needed for pr_info() */</span></span> 
<a id="x1-15015r7"></a><span>7</span> 
<a id="x1-15017r8"></a><span>8</span><span>MODULE_LICENSE(</span><span id="textcolor105"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-15019r9"></a><span>9</span><span>MODULE_AUTHOR(</span><span id="textcolor106"><span>&#34;LKMPG&#34;</span></span><span>);</span> 
<a id="x1-15021r10"></a><span>10</span><span>MODULE_DESCRIPTION(</span><span id="textcolor107"><span>&#34;A sample driver&#34;</span></span><span>);</span> 
<a id="x1-15023r11"></a><span>11</span> 
<a id="x1-15025r12"></a><span>12</span><span id="textcolor108"><span>static</span></span><span> </span><span id="textcolor109"><span>int</span></span><span> __init init_hello_4(</span><span id="textcolor110"><span>void</span></span><span>)</span> 
<a id="x1-15027r13"></a><span>13</span><span>{</span> 
<a id="x1-15029r14"></a><span>14</span><span>    pr_info(</span><span id="textcolor111"><span>&#34;Hello, world 4</span></span><span id="textcolor112"><span>\n</span></span><span id="textcolor113"><span>&#34;</span></span><span>);</span> 
<a id="x1-15031r15"></a><span>15</span><span>    </span><span id="textcolor114"><span>return</span></span><span> 0;</span> 
<a id="x1-15033r16"></a><span>16</span><span>}</span> 
<a id="x1-15035r17"></a><span>17</span> 
<a id="x1-15037r18"></a><span>18</span><span id="textcolor115"><span>static</span></span><span> </span><span id="textcolor116"><span>void</span></span><span> __exit cleanup_hello_4(</span><span id="textcolor117"><span>void</span></span><span>)</span> 
<a id="x1-15039r19"></a><span>19</span><span>{</span> 
<a id="x1-15041r20"></a><span>20</span><span>    pr_info(</span><span id="textcolor118"><span>&#34;Goodbye, world 4</span></span><span id="textcolor119"><span>\n</span></span><span id="textcolor120"><span>&#34;</span></span><span>);</span> 
<a id="x1-15043r21"></a><span>21</span><span>}</span> 
<a id="x1-15045r22"></a><span>22</span> 
<a id="x1-15047r23"></a><span>23</span><span>module_init(init_hello_4);</span> 
<a id="x1-15049r24"></a><span>24</span><span>module_exit(cleanup_hello_4);</span></pre>
<!-- l. 501 -->
   <h4 id="passing-command-line-arguments-to-a-module"><span>4.5   </span> <a id="x1-160004.5"></a>Passing Command Line Arguments to a Module</h4>
<!-- l. 503 --><p>Modules can take command line arguments, but not with the argc/argv you might be
used to.
</p><!-- l. 505 --><p>   To allow arguments to be passed to your module, declare the variables that will
take the values of the command line arguments as global and then use the
<code> <span>module_param()</span>
</code> macro, (defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/moduleparam.h">include/linux/moduleparam.h</a>) to set the mechanism up. At runtime,
<code> <span>insmod</span>
</code> will fill the variables with any command line arguments that are given, like
<code> <span>insmod mymodule.ko myvariable=5</span>
</code>. The variable declarations and macros should be placed at the beginning of the
module for clarity. The example code should clear up my admittedly lousy
explanation.
</p><!-- l. 510 --><p>   The <code>  <span>module_param()</span>
</code> macro takes 3 arguments: the name of the variable, its type and
permissions for the corresponding file in sysfs. Integer types can be signed
as usual or unsigned. If you’d like to use arrays of integers or strings see
<code> <span>module_param_array()</span>
</code> and <code>  <span>module_param_string()</span>
</code>.
</p><!-- l. 1 -->
   <pre id="fancyvrb29"><a id="x1-16010r1"></a><span>1</span><span id="textcolor121"><span>int</span></span><span> myint = 3;</span> 
<a id="x1-16012r2"></a><span>2</span><span>module_param(myint, </span><span id="textcolor122"><span>int</span></span><span>, 0);</span></pre>
<!-- l. 518 --><p>   Arrays are supported too, but things are a bit different now than they were in the
olden days. To keep track of the number of parameters you need to pass a pointer to
a count variable as third parameter. At your option, you could also ignore the count and
pass <code>  <span>NULL</span>
</code> instead. We show both possibilities here:
</p><!-- l. 1 -->
   <pre id="fancyvrb30"><a id="x1-16021r1"></a><span>1</span><span id="textcolor123"><span>int</span></span><span> myintarray[2];</span> 
<a id="x1-16023r2"></a><span>2</span><span>module_param_array(myintarray, </span><span id="textcolor124"><span>int</span></span><span>, NULL, 0); </span><span id="textcolor125"><span>/* not interested in count */</span></span> 
<a id="x1-16025r3"></a><span>3</span> 
<a id="x1-16027r4"></a><span>4</span><span id="textcolor126"><span>short</span></span><span> myshortarray[4];</span> 
<a id="x1-16029r5"></a><span>5</span><span id="textcolor127"><span>int</span></span><span> count;</span> 
<a id="x1-16031r6"></a><span>6</span><span>module_param_array(myshortarray, </span><span id="textcolor128"><span>short</span></span><span>, &amp;count, 0); </span><span id="textcolor129"><span>/* put count into &#34;count&#34; variable */</span></span></pre>
<!-- l. 531 --><p>   A good use for this is to have the module variable’s default values set, like a port
or IO address. If the variables contain the default values, then perform autodetection
(explained elsewhere). Otherwise, keep the current value. This will be made clear
later on.
</p><!-- l. 535 --><p>   Lastly, there is a macro function, <code>  <span>MODULE_PARM_DESC()</span>
</code>, that is used to document arguments that the module can take. It takes two
parameters: a variable name and a free form string describing that variable.
</p><!-- l. 1 -->
   <pre id="fancyvrb31"><a id="x1-16034r1"></a><span>1</span><span id="textcolor130"><span>/*</span></span> 
<a id="x1-16036r2"></a><span>2</span><span id="textcolor131"><span> * hello-5.c - Demonstrates command line argument passing to a module.</span></span> 
<a id="x1-16038r3"></a><span>3</span><span id="textcolor132"><span> */</span></span> 
<a id="x1-16040r4"></a><span>4</span><span id="textcolor133"><span>#include</span></span><span> </span><span id="textcolor134"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-16042r5"></a><span>5</span><span id="textcolor135"><span>#include</span></span><span> </span><span id="textcolor136"><span>&lt;linux/kernel.h&gt; /* for ARRAY_SIZE() */</span></span> 
<a id="x1-16044r6"></a><span>6</span><span id="textcolor137"><span>#include</span></span><span> </span><span id="textcolor138"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-16046r7"></a><span>7</span><span id="textcolor139"><span>#include</span></span><span> </span><span id="textcolor140"><span>&lt;linux/moduleparam.h&gt;</span></span> 
<a id="x1-16048r8"></a><span>8</span><span id="textcolor141"><span>#include</span></span><span> </span><span id="textcolor142"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-16050r9"></a><span>9</span><span id="textcolor143"><span>#include</span></span><span> </span><span id="textcolor144"><span>&lt;linux/stat.h&gt;</span></span> 
<a id="x1-16052r10"></a><span>10</span> 
<a id="x1-16054r11"></a><span>11</span><span>MODULE_LICENSE(</span><span id="textcolor145"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-16056r12"></a><span>12</span> 
<a id="x1-16058r13"></a><span>13</span><span id="textcolor146"><span>static</span></span><span> </span><span id="textcolor147"><span>short</span></span><span> </span><span id="textcolor148"><span>int</span></span><span> myshort = 1;</span> 
<a id="x1-16060r14"></a><span>14</span><span id="textcolor149"><span>static</span></span><span> </span><span id="textcolor150"><span>int</span></span><span> myint = 420;</span> 
<a id="x1-16062r15"></a><span>15</span><span id="textcolor151"><span>static</span></span><span> </span><span id="textcolor152"><span>long</span></span><span> </span><span id="textcolor153"><span>int</span></span><span> mylong = 9999;</span> 
<a id="x1-16064r16"></a><span>16</span><span id="textcolor154"><span>static</span></span><span> </span><span id="textcolor155"><span>char</span></span><span> *mystring = </span><span id="textcolor156"><span>&#34;blah&#34;</span></span><span>;</span> 
<a id="x1-16066r17"></a><span>17</span><span id="textcolor157"><span>static</span></span><span> </span><span id="textcolor158"><span>int</span></span><span> myintarray[2] = { 420, 420 };</span> 
<a id="x1-16068r18"></a><span>18</span><span id="textcolor159"><span>static</span></span><span> </span><span id="textcolor160"><span>int</span></span><span> arr_argc = 0;</span> 
<a id="x1-16070r19"></a><span>19</span> 
<a id="x1-16072r20"></a><span>20</span><span id="textcolor161"><span>/* module_param(foo, int, 0000)</span></span> 
<a id="x1-16074r21"></a><span>21</span><span id="textcolor162"><span> * The first param is the parameters name.</span></span> 
<a id="x1-16076r22"></a><span>22</span><span id="textcolor163"><span> * The second param is its data type.</span></span> 
<a id="x1-16078r23"></a><span>23</span><span id="textcolor164"><span> * The final argument is the permissions bits,</span></span> 
<a id="x1-16080r24"></a><span>24</span><span id="textcolor165"><span> * for exposing parameters in sysfs (if non-zero) at a later stage.</span></span> 
<a id="x1-16082r25"></a><span>25</span><span id="textcolor166"><span> */</span></span> 
<a id="x1-16084r26"></a><span>26</span><span>module_param(myshort, </span><span id="textcolor167"><span>short</span></span><span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);</span> 
<a id="x1-16086r27"></a><span>27</span><span>MODULE_PARM_DESC(myshort, </span><span id="textcolor168"><span>&#34;A short integer&#34;</span></span><span>);</span> 
<a id="x1-16088r28"></a><span>28</span><span>module_param(myint, </span><span id="textcolor169"><span>int</span></span><span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span> 
<a id="x1-16090r29"></a><span>29</span><span>MODULE_PARM_DESC(myint, </span><span id="textcolor170"><span>&#34;An integer&#34;</span></span><span>);</span> 
<a id="x1-16092r30"></a><span>30</span><span>module_param(mylong, </span><span id="textcolor171"><span>long</span></span><span>, S_IRUSR);</span> 
<a id="x1-16094r31"></a><span>31</span><span>MODULE_PARM_DESC(mylong, </span><span id="textcolor172"><span>&#34;A long integer&#34;</span></span><span>);</span> 
<a id="x1-16096r32"></a><span>32</span><span>module_param(mystring, charp, 0000);</span> 
<a id="x1-16098r33"></a><span>33</span><span>MODULE_PARM_DESC(mystring, </span><span id="textcolor173"><span>&#34;A character string&#34;</span></span><span>);</span> 
<a id="x1-16100r34"></a><span>34</span> 
<a id="x1-16102r35"></a><span>35</span><span id="textcolor174"><span>/* module_param_array(name, type, num, perm);</span></span> 
<a id="x1-16104r36"></a><span>36</span><span id="textcolor175"><span> * The first param is the parameter</span><span>&#39;</span><span>s (in this case the array</span><span>&#39;</span><span>s) name.</span></span> 
<a id="x1-16106r37"></a><span>37</span><span id="textcolor176"><span> * The second param is the data type of the elements of the array.</span></span> 
<a id="x1-16108r38"></a><span>38</span><span id="textcolor177"><span> * The third argument is a pointer to the variable that will store the number</span></span> 
<a id="x1-16110r39"></a><span>39</span><span id="textcolor178"><span> * of elements of the array initialized by the user at module loading time.</span></span> 
<a id="x1-16112r40"></a><span>40</span><span id="textcolor179"><span> * The fourth argument is the permission bits.</span></span> 
<a id="x1-16114r41"></a><span>41</span><span id="textcolor180"><span> */</span></span> 
<a id="x1-16116r42"></a><span>42</span><span>module_param_array(myintarray, </span><span id="textcolor181"><span>int</span></span><span>, &amp;arr_argc, 0000);</span> 
<a id="x1-16118r43"></a><span>43</span><span>MODULE_PARM_DESC(myintarray, </span><span id="textcolor182"><span>&#34;An array of integers&#34;</span></span><span>);</span> 
<a id="x1-16120r44"></a><span>44</span> 
<a id="x1-16122r45"></a><span>45</span><span id="textcolor183"><span>static</span></span><span> </span><span id="textcolor184"><span>int</span></span><span> __init hello_5_init(</span><span id="textcolor185"><span>void</span></span><span>)</span> 
<a id="x1-16124r46"></a><span>46</span><span>{</span> 
<a id="x1-16126r47"></a><span>47</span><span>    </span><span id="textcolor186"><span>int</span></span><span> i;</span> 
<a id="x1-16128r48"></a><span>48</span> 
<a id="x1-16130r49"></a><span>49</span><span>    pr_info(</span><span id="textcolor187"><span>&#34;Hello, world 5</span></span><span id="textcolor188"><span>\n</span></span><span id="textcolor189"><span>=============</span></span><span id="textcolor190"><span>\n</span></span><span id="textcolor191"><span>&#34;</span></span><span>);</span> 
<a id="x1-16132r50"></a><span>50</span><span>    pr_info(</span><span id="textcolor192"><span>&#34;myshort is a short integer: %hd</span></span><span id="textcolor193"><span>\n</span></span><span id="textcolor194"><span>&#34;</span></span><span>, myshort);</span> 
<a id="x1-16134r51"></a><span>51</span><span>    pr_info(</span><span id="textcolor195"><span>&#34;myint is an integer: %d</span></span><span id="textcolor196"><span>\n</span></span><span id="textcolor197"><span>&#34;</span></span><span>, myint);</span> 
<a id="x1-16136r52"></a><span>52</span><span>    pr_info(</span><span id="textcolor198"><span>&#34;mylong is a long integer: %ld</span></span><span id="textcolor199"><span>\n</span></span><span id="textcolor200"><span>&#34;</span></span><span>, mylong);</span> 
<a id="x1-16138r53"></a><span>53</span><span>    pr_info(</span><span id="textcolor201"><span>&#34;mystring is a string: %s</span></span><span id="textcolor202"><span>\n</span></span><span id="textcolor203"><span>&#34;</span></span><span>, mystring);</span> 
<a id="x1-16140r54"></a><span>54</span> 
<a id="x1-16142r55"></a><span>55</span><span>    </span><span id="textcolor204"><span>for</span></span><span> (i = 0; i &lt; ARRAY_SIZE(myintarray); i++)</span> 
<a id="x1-16144r56"></a><span>56</span><span>        pr_info(</span><span id="textcolor205"><span>&#34;myintarray[%d] = %d</span></span><span id="textcolor206"><span>\n</span></span><span id="textcolor207"><span>&#34;</span></span><span>, i, myintarray[i]);</span> 
<a id="x1-16146r57"></a><span>57</span> 
<a id="x1-16148r58"></a><span>58</span><span>    pr_info(</span><span id="textcolor208"><span>&#34;got %d arguments for myintarray.</span></span><span id="textcolor209"><span>\n</span></span><span id="textcolor210"><span>&#34;</span></span><span>, arr_argc);</span> 
<a id="x1-16150r59"></a><span>59</span><span>    </span><span id="textcolor211"><span>return</span></span><span> 0;</span> 
<a id="x1-16152r60"></a><span>60</span><span>}</span> 
<a id="x1-16154r61"></a><span>61</span> 
<a id="x1-16156r62"></a><span>62</span><span id="textcolor212"><span>static</span></span><span> </span><span id="textcolor213"><span>void</span></span><span> __exit hello_5_exit(</span><span id="textcolor214"><span>void</span></span><span>)</span> 
<a id="x1-16158r63"></a><span>63</span><span>{</span> 
<a id="x1-16160r64"></a><span>64</span><span>    pr_info(</span><span id="textcolor215"><span>&#34;Goodbye, world 5</span></span><span id="textcolor216"><span>\n</span></span><span id="textcolor217"><span>&#34;</span></span><span>);</span> 
<a id="x1-16162r65"></a><span>65</span><span>}</span> 
<a id="x1-16164r66"></a><span>66</span> 
<a id="x1-16166r67"></a><span>67</span><span>module_init(hello_5_init);</span> 
<a id="x1-16168r68"></a><span>68</span><span>module_exit(hello_5_exit);</span></pre>
<!-- l. 540 --><p>   I would recommend playing around with this code:
                                                                  

                                                                  
</p>
   <pre id="verbatim-6">$ sudo insmod hello-5.ko mystring=&#34;bebop&#34; myintarray=-1
$ sudo dmesg -t | tail -7
myshort is a short integer: 1
myint is an integer: 420
mylong is a long integer: 9999
mystring is a string: bebop
myintarray[0] = -1
myintarray[1] = 420
got 1 arguments for myintarray.

$ sudo rmmod hello-5
$ sudo dmesg -t | tail -1
Goodbye, world 5

$ sudo insmod hello-5.ko mystring=&#34;supercalifragilisticexpialidocious&#34; myintarray=-1,-1
$ sudo dmesg -t | tail -7
myshort is a short integer: 1
myint is an integer: 420
mylong is a long integer: 9999
mystring is a string: supercalifragilisticexpialidocious
myintarray[0] = -1
myintarray[1] = -1
got 2 arguments for myintarray.

$ sudo rmmod hello-5
$ sudo dmesg -t | tail -1
Goodbye, world 5

$ sudo insmod hello-5.ko mylong=hello
insmod: ERROR: could not insert module hello-5.ko: Invalid parameters
</pre>
<!-- l. 572 --><!-- l. 574 -->
   <h4 id="modules-spanning-multiple-files"><span>4.6   </span> <a id="x1-170004.6"></a>Modules Spanning Multiple Files</h4>
<!-- l. 576 --><p>Sometimes it makes sense to divide a kernel module between several source
files.
</p><!-- l. 578 --><p>   Here is an example of such a kernel module. 
</p>
                                                                  

                                                                  
   <pre id="fancyvrb32"><a id="x1-17002r1"></a><span>1</span><span id="textcolor218"><span>/*</span></span> 
<a id="x1-17004r2"></a><span>2</span><span id="textcolor219"><span> * start.c - Illustration of multi filed modules</span></span> 
<a id="x1-17006r3"></a><span>3</span><span id="textcolor220"><span> */</span></span> 
<a id="x1-17008r4"></a><span>4</span> 
<a id="x1-17010r5"></a><span>5</span><span id="textcolor221"><span>#include</span></span><span> </span><span id="textcolor222"><span>&lt;linux/kernel.h&gt; /* We are doing kernel work */</span></span> 
<a id="x1-17012r6"></a><span>6</span><span id="textcolor223"><span>#include</span></span><span> </span><span id="textcolor224"><span>&lt;linux/module.h&gt; /* Specifically, a module */</span></span> 
<a id="x1-17014r7"></a><span>7</span> 
<a id="x1-17016r8"></a><span>8</span><span id="textcolor225"><span>int</span></span><span> init_module(</span><span id="textcolor226"><span>void</span></span><span>)</span> 
<a id="x1-17018r9"></a><span>9</span><span>{</span> 
<a id="x1-17020r10"></a><span>10</span><span>    pr_info(</span><span id="textcolor227"><span>&#34;Hello, world - this is the kernel speaking</span></span><span id="textcolor228"><span>\n</span></span><span id="textcolor229"><span>&#34;</span></span><span>);</span> 
<a id="x1-17022r11"></a><span>11</span><span>    </span><span id="textcolor230"><span>return</span></span><span> 0;</span> 
<a id="x1-17024r12"></a><span>12</span><span>}</span> 
<a id="x1-17026r13"></a><span>13</span> 
<a id="x1-17028r14"></a><span>14</span><span>MODULE_LICENSE(</span><span id="textcolor231"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 581 --><p>   The next file: 
</p>
   <pre id="fancyvrb33"><a id="x1-17030r1"></a><span>1</span><span id="textcolor232"><span>/*</span></span> 
<a id="x1-17032r2"></a><span>2</span><span id="textcolor233"><span> * stop.c - Illustration of multi filed modules</span></span> 
<a id="x1-17034r3"></a><span>3</span><span id="textcolor234"><span> */</span></span> 
<a id="x1-17036r4"></a><span>4</span> 
<a id="x1-17038r5"></a><span>5</span><span id="textcolor235"><span>#include</span></span><span> </span><span id="textcolor236"><span>&lt;linux/kernel.h&gt; /* We are doing kernel work */</span></span> 
<a id="x1-17040r6"></a><span>6</span><span id="textcolor237"><span>#include</span></span><span> </span><span id="textcolor238"><span>&lt;linux/module.h&gt; /* Specifically, a module  */</span></span> 
<a id="x1-17042r7"></a><span>7</span> 
<a id="x1-17044r8"></a><span>8</span><span id="textcolor239"><span>void</span></span><span> cleanup_module(</span><span id="textcolor240"><span>void</span></span><span>)</span> 
<a id="x1-17046r9"></a><span>9</span><span>{</span> 
<a id="x1-17048r10"></a><span>10</span><span>    pr_info(</span><span id="textcolor241"><span>&#34;Short is the life of a kernel module</span></span><span id="textcolor242"><span>\n</span></span><span id="textcolor243"><span>&#34;</span></span><span>);</span> 
<a id="x1-17050r11"></a><span>11</span><span>}</span> 
<a id="x1-17052r12"></a><span>12</span> 
<a id="x1-17054r13"></a><span>13</span><span>MODULE_LICENSE(</span><span id="textcolor244"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 584 --><p>   And finally, the makefile:
</p><!-- l. 1 -->
   <pre id="fancyvrb34"><a id="x1-17071r1"></a><span>1</span><span>obj-m += hello-1.o</span> 
<a id="x1-17073r2"></a><span>2</span><span>obj-m += hello-2.o</span> 
<a id="x1-17075r3"></a><span>3</span><span>obj-m += hello-3.o</span> 
<a id="x1-17077r4"></a><span>4</span><span>obj-m += hello-4.o</span> 
<a id="x1-17079r5"></a><span>5</span><span>obj-m += hello-5.o</span> 
<a id="x1-17081r6"></a><span>6</span><span>obj-m += startstop.o</span> 
<a id="x1-17083r7"></a><span>7</span><span>startstop-objs := start.o stop.o</span> 
<a id="x1-17085r8"></a><span>8</span> 
<a id="x1-17087r9"></a><span>9</span><span>PWD := </span><span id="colorbox245"><span>$</span></span><span>(CURDIR)</span> 
<a id="x1-17089r10"></a><span>10</span> 
<a id="x1-17091r11"></a><span>11</span><span>all:</span> 
<a id="x1-17093r12"></a><span>12</span><span>    make -C /lib/modules/</span><span id="colorbox246"><span>$</span></span><span>(shell uname -r)/build M=</span><span id="colorbox247"><span>$</span></span><span>(PWD) modules</span> 
<a id="x1-17095r13"></a><span>13</span> 
<a id="x1-17097r14"></a><span>14</span><span>clean:</span> 
<a id="x1-17099r15"></a><span>15</span><span>    make -C /lib/modules/</span><span id="colorbox248"><span>$</span></span><span>(shell uname -r)/build M=</span><span id="colorbox249"><span>$</span></span><span>(PWD) clean</span></pre>
<!-- l. 604 --><p>   This is the complete makefile for all the examples we have seen so far. The first
five lines are nothing special, but for the last example we will need two lines.
First we invent an object name for our combined module, second we tell
<code> <span>make</span>
</code> what object files are part of that module.
</p><!-- l. 608 -->
   <h4 id="building-modules-for-a-precompiled-kernel"><span>4.7   </span> <a id="x1-180004.7"></a>Building modules for a precompiled kernel</h4>
<!-- l. 610 --><p>Obviously, we strongly suggest you to recompile your kernel, so that you can enable
a number of useful debugging features, such as forced module unloading
(<code>  <span>MODULE_FORCE_UNLOAD</span>
</code>): when this option is enabled, you can force the kernel to unload a module even when it believes
it is unsafe, via a <code>  <span>sudo rmmod -f module</span>
</code> command. This option can save you a lot of time and a number of reboots during
the development of a module. If you do not want to recompile your kernel then you
should consider running the examples within a test distribution on a virtual machine.
If you mess anything up then you can easily reboot or restore the virtual machine
(VM).
</p><!-- l. 615 --><p>   There are a number of cases in which you may want to load your module into a
precompiled running kernel, such as the ones shipped with common Linux
distributions, or a kernel you have compiled in the past. In certain circumstances you
could require to compile and insert a module into a running kernel which you are not
allowed to recompile, or on a machine that you prefer not to reboot. If you
can’t think of a case that will force you to use modules for a precompiled
kernel you might want to skip this and treat the rest of this chapter as a big
footnote.
</p><!-- l. 619 --><p>   Now, if you just install a kernel source tree, use it to compile your kernel module
and you try to insert your module into the kernel, in most cases you would obtain an
error as follows:
                                                                  

                                                                  
</p>
   <pre id="verbatim-7">insmod: ERROR: could not insert module poet.ko: Invalid module format
</pre>
<!-- l. 623 --><!-- l. 625 --><p>   Less cryptic information is logged to the systemd journal:
                                                                  

                                                                  
</p>
   <pre id="verbatim-8">kernel: poet: disagrees about version of symbol module_layout
</pre>
<!-- l. 629 --><!-- l. 631 --><p>   In other words, your kernel refuses to accept your module because version strings
(more precisely, <span>version magic</span>, see <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/vermagic.h">include/linux/vermagic.h</a>) do not match. Incidentally,
version magic strings are stored in the module object in the form of a static string, starting
with <code>  <span>vermagic:</span>
</code>. Version data are inserted in your module when it is linked against the <span><span><span>kernel/module.o</span></span></span>
file. To inspect version magics and other strings stored in a given module, issue the
command <code>  <span>modinfo module.ko</span>
</code>:
                                                                  

                                                                  
</p>
   <pre id="verbatim-9">$ modinfo hello-4.ko
description:    A sample driver
author:         LKMPG
license:        GPL
srcversion:     B2AA7FBFCC2C39AED665382
depends:
retpoline:      Y
name:           hello_4
vermagic:       5.4.0-70-generic SMP mod_unload modversions
</pre>
<!-- l. 646 --><!-- l. 648 --><p>   To overcome this problem we could resort to the <span><span><span>--force-vermagic</span></span></span> option,
but this solution is potentially unsafe, and unquestionably unacceptable
in production modules. Consequently, we want to compile our module in
an environment which was identical to the one in which our precompiled
kernel was built. How to do this, is the subject of the remainder of this
chapter.
</p><!-- l. 652 --><p>   First of all, make sure that a kernel source tree is available, having exactly the same
version as your current kernel. Then, find the configuration file which was used to
compile your precompiled kernel. Usually, this is available in your current <span><span><span>boot</span></span></span> directory,
under a name like <span><span><span>config-5.14.x</span></span></span>. You may just want to copy it to your kernel source
tree: <code>  <span>cp /boot/config-</span><span id="textcolor250"><span>`</span></span><span>uname -r</span><span id="textcolor251"><span>`</span></span><span> .config</span>
</code>.
</p><!-- l. 657 --><p>   Let’s focus again on the previous error message: a closer look at the version magic
strings suggests that, even with two configuration files which are exactly the same, a
slight difference in the version magic could be possible, and it is sufficient to prevent
insertion of the module into the kernel. That slight difference, namely the
custom string which appears in the module’s version magic and not in the
kernel’s one, is due to a modification with respect to the original, in the
makefile that some distributions include. Then, examine your <span><span><span>Makefile</span></span></span>,
and make sure that the specified version information matches exactly the
one used for your current kernel. For example, your makefile could start as
follows:
                                                                  

                                                                  
</p>
   <pre id="verbatim-10">VERSION = 5
PATCHLEVEL = 14
SUBLEVEL = 0
EXTRAVERSION = -rc2
</pre>
<!-- l. 667 --><!-- l. 669 --><p>   In this case, you need to restore the value of symbol <span>EXTRAVERSION </span>to
<span>-rc2</span>. We suggest to keep a backup copy of the makefile used to compile your kernel
available in <span><span><span>/lib/modules/5.14.0-rc2/build</span></span></span>. A simple command as following
should suffice. 
</p>
   <pre id="fancyvrb35"><a id="x1-18008r1"></a><span>1</span><span>cp /lib/modules/</span><span id="textcolor252"><span>`</span></span><span>uname -r</span><span id="textcolor253"><span>`</span></span><span>/build/Makefile linux-</span><span id="textcolor254"><span>`</span></span><span>uname -r</span><span id="textcolor255"><span>`</span></span></pre>
<!-- l. 675 --><p>Here <code>  <span>linux-</span><span id="textcolor256"><span>`</span></span><span>uname -r</span><span id="textcolor257"><span>`</span></span>
</code> is the Linux kernel source you are attempting to build.
</p><!-- l. 677 --><p>   Now, please run <code>  <span>make</span>
</code> to update configuration and version headers and objects:
                                                                  

                                                                  
</p>
   <pre id="verbatim-11">$ make
  SYNC    include/config/auto.conf.cmd
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/kconfig/conf.o
  HOSTCC  scripts/kconfig/confdata.o
  HOSTCC  scripts/kconfig/expr.o
  LEX     scripts/kconfig/lexer.lex.c
  YACC    scripts/kconfig/parser.tab.[ch]
  HOSTCC  scripts/kconfig/preprocess.o
  HOSTCC  scripts/kconfig/symbol.o
  HOSTCC  scripts/kconfig/util.o
  HOSTCC  scripts/kconfig/lexer.lex.o
  HOSTCC  scripts/kconfig/parser.tab.o
  HOSTLD  scripts/kconfig/conf
</pre>
<!-- l. 694 --><!-- l. 696 --><p>   If you do not desire to actually compile the kernel, you can interrupt the build
process (CTRL-C) just after the SPLIT line, because at that time, the files you need
are ready. Now you can turn back to the directory of your module and compile it: It
will be built exactly according to your current kernel settings, and it will load into it
without any errors.
</p><!-- l. 699 -->
   <h3 id="preliminaries"><span>5   </span> <a id="x1-190005"></a>Preliminaries</h3>
<!-- l. 700 -->
   <h4 id="how-modules-begin-and-end"><span>5.1   </span> <a id="x1-200005.1"></a>How modules begin and end</h4>
<!-- l. 702 --><p>A program usually begins with a <code>  <span>main()</span>
</code> function, executes a bunch of instructions and terminates upon completion of those
instructions. Kernel modules work a bit differently. A module always begin with either
the <code>  <span>init_module</span>
</code> or the function you specify with <code>  <span>module_init</span>
</code> call. This is the entry function for modules; it tells the kernel what functionality the
module provides and sets up the kernel to run the module’s functions when they
are needed. Once it does this, entry function returns and the module does
nothing until the kernel wants to do something with the code that the module
provides.
                                                                  

                                                                  
</p><!-- l. 707 --><p>   All modules end by calling either <code>  <span>cleanup_module</span>
</code> or the function you specify with the <code>  <span>module_exit</span>
</code> call. This is the exit function for modules; it undoes whatever entry function did. It
unregisters the functionality that the entry function registered.
</p><!-- l. 711 --><p>   Every module must have an entry function and an exit function. Since there’s
more than one way to specify entry and exit functions, I will try my best to use the
terms “entry function” and “exit function”, but if I slip and simply refer to them as
<code> <span>init_module</span>
</code> and <code>  <span>cleanup_module</span>
</code>, I think you will know what I mean.
</p><!-- l. 714 -->
   <h4 id="functions-available-to-modules"><span>5.2   </span> <a id="x1-210005.2"></a>Functions available to modules</h4>
<!-- l. 716 --><p>Programmers use functions they do not define all the time. A prime example of this
is <code>  <span>printf()</span>
</code>. You use these library functions which are provided by the standard C
library, libc. The definitions for these functions do not actually enter
your program until the linking stage, which insures that the code (for
<code> <span>printf()</span>
</code> for example) is available, and fixes the call instruction to point to that
code.
</p><!-- l. 721 --><p>   Kernel modules are different here, too. In the hello world
example, you might have noticed that we used a function,
<code> <span>pr_info()</span>
</code> but did not include a standard I/O library. That is because
modules are object files whose symbols get resolved upon running
<code> <span>insmod</span>
</code> or <code>  <span>modprobe</span>
</code>. The definition for the symbols comes from the kernel itself; the only external
functions you can use are the ones provided by the kernel. If you’re curious about
what symbols have been exported by your kernel, take a look at <span><span><span>/proc/kallsyms</span></span></span>.
</p><!-- l. 726 --><p>   One point to keep in mind is the difference between library functions and system
calls. Library functions are higher level, run completely in user space and
provide a more convenient interface for the programmer to the functions
that do the real work — system calls. System calls run in kernel mode on
the user’s behalf and are provided by the kernel itself. The library function
<code> <span>printf()</span>
</code> may look like a very general printing function, but all it really does is format the
data into strings and write the string data using the low-level system call
<code> <span>write()</span>
</code>, which then sends the data to standard output.
</p><!-- l. 730 --><p>   Would you like to see what system calls are made by
<code> <span>printf()</span>
                                                                  

                                                                  
</code>? It is easy! Compile the following program:
</p><!-- l. 1 -->
   <pre id="fancyvrb36"><a id="x1-21017r1"></a><span>1</span><span id="textcolor258"><span>#include</span></span><span> </span><span id="textcolor259"><span>&lt;stdio.h&gt;</span></span> 
<a id="x1-21019r2"></a><span>2</span> 
<a id="x1-21021r3"></a><span>3</span><span id="textcolor260"><span>int</span></span><span> main(</span><span id="textcolor261"><span>void</span></span><span>)</span> 
<a id="x1-21023r4"></a><span>4</span><span>{</span> 
<a id="x1-21025r5"></a><span>5</span><span>    printf(</span><span id="textcolor262"><span>&#34;hello&#34;</span></span><span>);</span> 
<a id="x1-21027r6"></a><span>6</span><span>    </span><span id="textcolor263"><span>return</span></span><span> 0;</span> 
<a id="x1-21029r7"></a><span>7</span><span>}</span></pre>
<!-- l. 744 --><p>   with <code>  <span>gcc -Wall -o hello hello.c</span>
</code>. Run the executable with <code>  <span>strace ./hello</span>
</code>. Are you impressed? Every line you see corresponds to a system call. <a href="https://strace.io/">strace</a> is a
handy program that gives you details about what system calls a program is
making, including which call is made, what its arguments are and what it
returns. It is an invaluable tool for figuring out things like what files a program
is trying to access. Towards the end, you will see a line which looks like
<code> <span>write(1, </span><span id="textcolor264"><span>&#34;hello&#34;</span></span><span>, 5hello)</span>
</code>. There it is. The face behind the <code>  <span>printf()</span>
</code> mask. You may not be familiar with write, since most people use library functions for file
I/O (like <code>  <span>fopen</span>
</code>, <code>  <span>fputs</span>
</code>, <code>  <span>fclose</span>
</code>). If that is the case, try looking at man 2 write. The 2nd man section is devoted to system
calls (like <code>  <span>kill()</span>
</code> and <code>  <span>read()</span>
</code>). The 3rd man section is devoted to library calls, which you would probably be more familiar
with (like <code>  <span>cosh()</span>
</code> and <code>  <span>random()</span>
</code>).
</p><!-- l. 758 --><p>   You can even write modules to replace the kernel’s system calls, which we will do
shortly. Crackers often make use of this sort of thing for backdoors or trojans, but
you can write your own modules to do more benign things, like have the kernel
write Tee hee, that tickles! every time someone tries to delete a file on your
system.
</p><!-- l. 761 -->
   <h4 id="user-space-vs-kernel-space"><span>5.3   </span> <a id="x1-220005.3"></a>User Space vs Kernel Space</h4>
<!-- l. 763 --><p>A kernel is all about access to resources, whether the resource in question happens to
be a video card, a hard drive or even memory. Programs often compete for the same
resource. As I just saved this document, updatedb started updating the locate
database. My vim session and updatedb are both using the hard drive concurrently.
The kernel needs to keep things orderly, and not give users access to resources
whenever they feel like it. To this end, a CPU can run in different modes. Each mode
gives a different level of freedom to do what you want on the system. The Intel 80386
architecture had 4 of these modes, which were called rings. Unix uses only
two rings; the highest ring (ring 0, also known as “supervisor mode” where
everything is allowed to happen) and the lowest ring, which is called “user
mode”.
                                                                  

                                                                  
</p><!-- l. 771 --><p>   Recall the discussion about library functions vs system calls. Typically, you use a
library function in user mode. The library function calls one or more system calls,
and these system calls execute on the library function’s behalf, but do so in
supervisor mode since they are part of the kernel itself. Once the system call
completes its task, it returns and execution gets transferred back to user
mode.
</p><!-- l. 776 -->
   <h4 id="name-space"><span>5.4   </span> <a id="x1-230005.4"></a>Name Space</h4>
<!-- l. 778 --><p>When you write a small C program, you use variables which are convenient and make
sense to the reader. If, on the other hand, you are writing routines which will be part
of a bigger problem, any global variables you have are part of a community of other
peoples’ global variables; some of the variable names can clash. When a program has
lots of global variables which aren’t meaningful enough to be distinguished, you get
namespace pollution. In large projects, effort must be made to remember reserved
names, and to find ways to develop a scheme for naming unique variable names and
symbols.
</p><!-- l. 783 --><p>   When writing kernel code, even the smallest module will be linked against the
entire kernel, so this is definitely an issue. The best way to deal with this is to declare
all your variables as static and to use a well-defined prefix for your symbols. By
convention, all kernel prefixes are lowercase. If you do not want to declare everything
as static, another option is to declare a symbol table and register it with the kernel.
We will get to this later.
</p><!-- l. 788 --><p>   The file <span><span><span>/proc/kallsyms</span></span></span> holds all the symbols that the kernel knows about and
which are therefore accessible to your modules since they share the kernel’s
codespace.
</p><!-- l. 790 -->
   <h4 id="code-space"><span>5.5   </span> <a id="x1-240005.5"></a>Code space</h4>
<!-- l. 792 --><p>Memory management is a very complicated subject and the majority of O’Reilly’s
<a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/">Understanding The Linux Kernel</a> exclusively covers memory management!
We are not setting out to be experts on memory managements, but we do
need to know a couple of facts to even begin worrying about writing real
modules.
</p><!-- l. 795 --><p>   If you have not thought about what a segfault really means, you may be surprised
to hear that pointers do not actually point to memory locations. Not real
ones, anyway. When a process is created, the kernel sets aside a portion of
real physical memory and hands it to the process to use for its executing
code, variables, stack, heap and other things which a computer scientist
would know about. This memory begins with 0x00000000 and extends up to
whatever it needs to be. Since the memory space for any two processes do not
                                                                  

                                                                  
overlap, every process that can access a memory address, say 0xbffff978, would
be accessing a different location in real physical memory! The processes
would be accessing an index named 0xbffff978 which points to some kind of
offset into the region of memory set aside for that particular process. For
the most part, a process like our Hello, World program can’t access the
space of another process, although there are ways which we will talk about
later.
</p><!-- l. 802 --><p>   The kernel has its own space of memory as well. Since a module is code which
can be dynamically inserted and removed in the kernel (as opposed to a
semi-autonomous object), it shares the kernel’s codespace rather than having its own.
Therefore, if your module segfaults, the kernel segfaults. And if you start writing
over data because of an off-by-one error, then you’re trampling on kernel
data (or code). This is even worse than it sounds, so try your best to be
careful.
</p><!-- l. 807 --><p>   By the way, I would like to point out that the above discussion is true for any
operating system which uses a monolithic kernel. This is not quite the same thing as
<span>&#34;building all your modules into the kernel&#34;</span>, although the idea is the same. There are
things called microkernels which have modules which get their own codespace. The
<a href="https://www.gnu.org/software/hurd/">GNU Hurd</a> and the <a href="https://fuchsia.dev/fuchsia-src/concepts/kernel">Zircon kernel</a> of Google Fuchsia are two examples of a
microkernel.
</p><!-- l. 812 -->
   <h4 id="device-drivers"><span>5.6   </span> <a id="x1-250005.6"></a>Device Drivers</h4>
<!-- l. 814 --><p>One class of module is the device driver, which provides functionality for hardware
like a serial port. On Unix, each piece of hardware is represented by a file located in
<span><span><span>/dev</span></span></span> named a device file which provides the means to communicate with the
hardware. The device driver provides the communication on behalf of a
user program. So the es1370.ko sound card device driver might connect the
<span><span><span>/dev/sound</span></span></span> device file to the Ensoniq IS1370 sound card. A userspace program like
mp3blaster can use <span><span><span>/dev/sound</span></span></span> without ever knowing what kind of sound card is
installed.
</p><!-- l. 821 --><p>   Let’s look at some device files. Here are device files which represent the first three
partitions on the primary master IDE hard drive:
                                                                  

                                                                  
</p>
   <pre id="verbatim-12">$ ls -l /dev/hda[1-3]
brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3
</pre>
<!-- l. 830 --><!-- l. 832 --><p>   Notice the column of numbers separated by a comma. The first number is called
the device’s major number. The second number is the minor number. The major
number tells you which driver is used to access the hardware. Each driver is assigned
a unique major number; all device files with the same major number are controlled
by the same driver. All the above major numbers are 3, because they’re all controlled
by the same driver.
</p><!-- l. 839 --><p>   The minor number is used by the driver to distinguish between the various
hardware it controls. Returning to the example above, although all three devices are
handled by the same driver they have unique minor numbers because the driver sees
them as being different pieces of hardware.
</p><!-- l. 842 --><p>   Devices are divided into two types: character devices and block devices. The
difference is that block devices have a buffer for requests, so they can choose the best
order in which to respond to the requests. This is important in the case of storage
devices, where it is faster to read or write sectors which are close to each
other, rather than those which are further apart. Another difference is that
block devices can only accept input and return output in blocks (whose size
can vary according to the device), whereas character devices are allowed
to use as many or as few bytes as they like. Most devices in the world are
character, because they don’t need this type of buffering, and they don’t
operate with a fixed block size. You can tell whether a device file is for a block
device or a character device by looking at the first character in the output of
<code> <span>ls -l</span>
</code>. If it is ‘b’ then it is a block device, and if it is ‘c’ then it is a character device. The
devices you see above are block devices. Here are some character devices (the serial
ports):
                                                                  

                                                                  
</p>
   <pre id="verbatim-13">crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
</pre>
<!-- l. 856 --><!-- l. 858 --><p>   If you want to see which major numbers have been assigned, you can look at
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt">Documentation/admin-guide/devices.txt</a>.
</p><!-- l. 860 --><p>   When the system was installed, all of those device files were created by the
<code> <span>mknod</span>
</code> command. To create a new char device named <span><span><span>coffee</span></span></span> with major/minor number 12 and 2,
simply do <code>  <span>mknod /dev/coffee c 12 2</span>
</code>. You do not have to put your device files into <span><span><span>/dev</span></span></span>, but it is done by convention.
Linus put his device files in <span><span><span>/dev</span></span></span>, and so should you. However, when creating a
device file for testing purposes, it is probably OK to place it in your working
directory where you compile the kernel module. Just be sure to put it in the right
place when you’re done writing the device driver.
</p><!-- l. 867 --><p>   I would like to make a few last points which are implicit from the above
discussion, but I would like to make them explicit just in case. When a device file is
accessed, the kernel uses the major number of the file to determine which driver
should be used to handle the access. This means that the kernel doesn’t really need
to use or even know about the minor number. The driver itself is the only thing that
cares about the minor number. It uses the minor number to distinguish between
different pieces of hardware.
</p><!-- l. 873 --><p>   By the way, when I say <span>&#34;hardware&#34;</span>, I mean something a bit more abstract
than a PCI card that you can hold in your hand. Look at these two device
files:
                                                                  

                                                                  
</p>
   <pre id="verbatim-14">$ ls -l /dev/sda /dev/sdb
brw-rw---- 1 root disk 8,  0 Jan  3 09:02 /dev/sda
brw-rw---- 1 root disk 8, 16 Jan  3 09:02 /dev/sdb
</pre>
<!-- l. 880 --><!-- l. 882 --><p>   By now you can look at these two device files and know instantly that they are
block devices and are handled by same driver (block major 8). Sometimes two device
files with the same major but different minor number can actually represent the same
piece of physical hardware. So just be aware that the word “hardware” in our
discussion can mean something very abstract.
</p><!-- l. 886 -->
   <h3 id="character-device-drivers"><span>6   </span> <a id="x1-260006"></a>Character Device drivers</h3>
<!-- l. 888 -->
   <h4 id="the-fileoperations-structure"><span>6.1   </span> <a id="x1-270006.1"></a>The file_operations Structure</h4>
<!-- l. 890 --><p>The <code>  <span>file_operations</span>
</code> structure is defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include/linux/fs.h</a>, and holds pointers to functions defined by
the driver that perform various operations on the device. Each field of the structure
corresponds to the address of some function defined by the driver to handle a
requested operation.
</p><!-- l. 893 --><p>   For example, every character driver needs to define a function that reads from the
device. The <code>  <span>file_operations</span>
</code> structure holds the address of the module’s function that performs that operation.
Here is what the definition looks like for kernel 5.4:
</p><!-- l. 1 -->
   <pre id="fancyvrb37"><a id="x1-27042r1"></a><span>1</span><span id="textcolor265"><span>struct</span></span><span> file_operations {</span> 
<a id="x1-27044r2"></a><span>2</span><span>    </span><span id="textcolor266"><span>struct</span></span><span> module *owner;</span> 
<a id="x1-27046r3"></a><span>3</span><span>    loff_t (*llseek) (</span><span id="textcolor267"><span>struct</span></span><span> file *, loff_t, </span><span id="textcolor268"><span>int</span></span><span>);</span> 
<a id="x1-27048r4"></a><span>4</span><span>    </span><span id="textcolor269"><span>ssize_t</span></span><span> (*read) (</span><span id="textcolor270"><span>struct</span></span><span> file *, </span><span id="textcolor271"><span>char</span></span><span> __user *, </span><span id="textcolor272"><span>size_t</span></span><span>, loff_t *);</span> 
<a id="x1-27050r5"></a><span>5</span><span>    </span><span id="textcolor273"><span>ssize_t</span></span><span> (*write) (</span><span id="textcolor274"><span>struct</span></span><span> file *, </span><span id="textcolor275"><span>const</span></span><span> </span><span id="textcolor276"><span>char</span></span><span> __user *, </span><span id="textcolor277"><span>size_t</span></span><span>, loff_t *);</span> 
<a id="x1-27052r6"></a><span>6</span><span>    </span><span id="textcolor278"><span>ssize_t</span></span><span> (*read_iter) (</span><span id="textcolor279"><span>struct</span></span><span> kiocb *, </span><span id="textcolor280"><span>struct</span></span><span> iov_iter *);</span> 
<a id="x1-27054r7"></a><span>7</span><span>    </span><span id="textcolor281"><span>ssize_t</span></span><span> (*write_iter) (</span><span id="textcolor282"><span>struct</span></span><span> kiocb *, </span><span id="textcolor283"><span>struct</span></span><span> iov_iter *);</span> 
<a id="x1-27056r8"></a><span>8</span><span>    </span><span id="textcolor284"><span>int</span></span><span> (*iopoll)(</span><span id="textcolor285"><span>struct</span></span><span> kiocb *kiocb, </span><span id="textcolor286"><span>bool</span></span><span> spin);</span> 
<a id="x1-27058r9"></a><span>9</span><span>    </span><span id="textcolor287"><span>int</span></span><span> (*iterate) (</span><span id="textcolor288"><span>struct</span></span><span> file *, </span><span id="textcolor289"><span>struct</span></span><span> dir_context *);</span> 
<a id="x1-27060r10"></a><span>10</span><span>    </span><span id="textcolor290"><span>int</span></span><span> (*iterate_shared) (</span><span id="textcolor291"><span>struct</span></span><span> file *, </span><span id="textcolor292"><span>struct</span></span><span> dir_context *);</span> 
<a id="x1-27062r11"></a><span>11</span><span>    __poll_t (*poll) (</span><span id="textcolor293"><span>struct</span></span><span> file *, </span><span id="textcolor294"><span>struct</span></span><span> poll_table_struct *);</span> 
<a id="x1-27064r12"></a><span>12</span><span>    </span><span id="textcolor295"><span>long</span></span><span> (*unlocked_ioctl) (</span><span id="textcolor296"><span>struct</span></span><span> file *, </span><span id="textcolor297"><span>unsigned</span></span><span> </span><span id="textcolor298"><span>int</span></span><span>, </span><span id="textcolor299"><span>unsigned</span></span><span> </span><span id="textcolor300"><span>long</span></span><span>);</span> 
<a id="x1-27066r13"></a><span>13</span><span>    </span><span id="textcolor301"><span>long</span></span><span> (*compat_ioctl) (</span><span id="textcolor302"><span>struct</span></span><span> file *, </span><span id="textcolor303"><span>unsigned</span></span><span> </span><span id="textcolor304"><span>int</span></span><span>, </span><span id="textcolor305"><span>unsigned</span></span><span> </span><span id="textcolor306"><span>long</span></span><span>);</span> 
<a id="x1-27068r14"></a><span>14</span><span>    </span><span id="textcolor307"><span>int</span></span><span> (*mmap) (</span><span id="textcolor308"><span>struct</span></span><span> file *, </span><span id="textcolor309"><span>struct</span></span><span> vm_area_struct *);</span> 
<a id="x1-27070r15"></a><span>15</span><span>    </span><span id="textcolor310"><span>unsigned</span></span><span> </span><span id="textcolor311"><span>long</span></span><span> mmap_supported_flags;</span> 
<a id="x1-27072r16"></a><span>16</span><span>    </span><span id="textcolor312"><span>int</span></span><span> (*open) (</span><span id="textcolor313"><span>struct</span></span><span> inode *, </span><span id="textcolor314"><span>struct</span></span><span> file *);</span> 
<a id="x1-27074r17"></a><span>17</span><span>    </span><span id="textcolor315"><span>int</span></span><span> (*flush) (</span><span id="textcolor316"><span>struct</span></span><span> file *, fl_owner_t id);</span> 
<a id="x1-27076r18"></a><span>18</span><span>    </span><span id="textcolor317"><span>int</span></span><span> (*release) (</span><span id="textcolor318"><span>struct</span></span><span> inode *, </span><span id="textcolor319"><span>struct</span></span><span> file *);</span> 
<a id="x1-27078r19"></a><span>19</span><span>    </span><span id="textcolor320"><span>int</span></span><span> (*fsync) (</span><span id="textcolor321"><span>struct</span></span><span> file *, loff_t, loff_t, </span><span id="textcolor322"><span>int</span></span><span> datasync);</span> 
<a id="x1-27080r20"></a><span>20</span><span>    </span><span id="textcolor323"><span>int</span></span><span> (*fasync) (</span><span id="textcolor324"><span>int</span></span><span>, </span><span id="textcolor325"><span>struct</span></span><span> file *, </span><span id="textcolor326"><span>int</span></span><span>);</span> 
<a id="x1-27082r21"></a><span>21</span><span>    </span><span id="textcolor327"><span>int</span></span><span> (*lock) (</span><span id="textcolor328"><span>struct</span></span><span> file *, </span><span id="textcolor329"><span>int</span></span><span>, </span><span id="textcolor330"><span>struct</span></span><span> file_lock *);</span> 
<a id="x1-27084r22"></a><span>22</span><span>    </span><span id="textcolor331"><span>ssize_t</span></span><span> (*sendpage) (</span><span id="textcolor332"><span>struct</span></span><span> file *, </span><span id="textcolor333"><span>struct</span></span><span> page *, </span><span id="textcolor334"><span>int</span></span><span>, </span><span id="textcolor335"><span>size_t</span></span><span>, loff_t *, </span><span id="textcolor336"><span>int</span></span><span>);</span> 
<a id="x1-27086r23"></a><span>23</span><span>    </span><span id="textcolor337"><span>unsigned</span></span><span> long (*get_unmapped_area)(</span><span id="textcolor338"><span>struct</span></span><span> file *, </span><span id="textcolor339"><span>unsigned</span></span><span> </span><span id="textcolor340"><span>long</span></span><span>, </span><span id="textcolor341"><span>unsigned</span></span><span> </span><span id="textcolor342"><span>long</span></span><span>, </span><span id="textcolor343"><span>unsigned</span></span><span> </span><span id="textcolor344"><span>long</span></span><span>, </span><span id="textcolor345"><span>unsigned</span></span><span> </span><span id="textcolor346"><span>long</span></span><span>);</span> 
<a id="x1-27088r24"></a><span>24</span><span>    </span><span id="textcolor347"><span>int</span></span><span> (*check_flags)(</span><span id="textcolor348"><span>int</span></span><span>);</span> 
<a id="x1-27090r25"></a><span>25</span><span>    </span><span id="textcolor349"><span>int</span></span><span> (*flock) (</span><span id="textcolor350"><span>struct</span></span><span> file *, </span><span id="textcolor351"><span>int</span></span><span>, </span><span id="textcolor352"><span>struct</span></span><span> file_lock *);</span> 
<a id="x1-27092r26"></a><span>26</span><span>    </span><span id="textcolor353"><span>ssize_t</span></span><span> (*splice_write)(</span><span id="textcolor354"><span>struct</span></span><span> pipe_inode_info *, </span><span id="textcolor355"><span>struct</span></span><span> file *, loff_t *, </span><span id="textcolor356"><span>size_t</span></span><span>, </span><span id="textcolor357"><span>unsigned</span></span><span> </span><span id="textcolor358"><span>int</span></span><span>);</span> 
<a id="x1-27094r27"></a><span>27</span><span>    </span><span id="textcolor359"><span>ssize_t</span></span><span> (*splice_read)(</span><span id="textcolor360"><span>struct</span></span><span> file *, loff_t *, </span><span id="textcolor361"><span>struct</span></span><span> pipe_inode_info *, </span><span id="textcolor362"><span>size_t</span></span><span>, </span><span id="textcolor363"><span>unsigned</span></span><span> </span><span id="textcolor364"><span>int</span></span><span>);</span> 
<a id="x1-27096r28"></a><span>28</span><span>    </span><span id="textcolor365"><span>int</span></span><span> (*setlease)(</span><span id="textcolor366"><span>struct</span></span><span> file *, </span><span id="textcolor367"><span>long</span></span><span>, </span><span id="textcolor368"><span>struct</span></span><span> file_lock **, </span><span id="textcolor369"><span>void</span></span><span> **);</span> 
<a id="x1-27098r29"></a><span>29</span><span>    </span><span id="textcolor370"><span>long</span></span><span> (*fallocate)(</span><span id="textcolor371"><span>struct</span></span><span> file *file, </span><span id="textcolor372"><span>int</span></span><span> mode, loff_t offset,</span> 
<a id="x1-27100r30"></a><span>30</span><span>        loff_t len);</span> 
<a id="x1-27102r31"></a><span>31</span><span>    </span><span id="textcolor373"><span>void</span></span><span> (*show_fdinfo)(</span><span id="textcolor374"><span>struct</span></span><span> seq_file *m, </span><span id="textcolor375"><span>struct</span></span><span> file *f);</span> 
<a id="x1-27104r32"></a><span>32</span><span>    </span><span id="textcolor376"><span>ssize_t</span></span><span> (*copy_file_range)(</span><span id="textcolor377"><span>struct</span></span><span> file *, loff_t, </span><span id="textcolor378"><span>struct</span></span><span> file *,</span> 
<a id="x1-27106r33"></a><span>33</span><span>        loff_t, </span><span id="textcolor379"><span>size_t</span></span><span>, </span><span id="textcolor380"><span>unsigned</span></span><span> </span><span id="textcolor381"><span>int</span></span><span>);</span> 
<a id="x1-27108r34"></a><span>34</span><span>    loff_t (*remap_file_range)(</span><span id="textcolor382"><span>struct</span></span><span> file *file_in, loff_t pos_in,</span> 
<a id="x1-27110r35"></a><span>35</span><span>             </span><span id="textcolor383"><span>struct</span></span><span> file *file_out, loff_t pos_out,</span> 
<a id="x1-27112r36"></a><span>36</span><span>             loff_t len, </span><span id="textcolor384"><span>unsigned</span></span><span> </span><span id="textcolor385"><span>int</span></span><span> remap_flags);</span> 
<a id="x1-27114r37"></a><span>37</span><span>    </span><span id="textcolor386"><span>int</span></span><span> (*fadvise)(</span><span id="textcolor387"><span>struct</span></span><span> file *, loff_t, loff_t, </span><span id="textcolor388"><span>int</span></span><span>);</span> 
<a id="x1-27116r38"></a><span>38</span><span>} __randomize_layout;</span></pre>
<!-- l. 938 --><p>   Some operations are not implemented by a driver. For example, a driver that handles
a video card will not need to read from a directory structure. The corresponding entries
in the <code>  <span>file_operations</span>
</code> structure should be set to <code>  <span>NULL</span>
</code>.
</p><!-- l. 942 --><p>   There is a gcc extension that makes assigning to this structure more convenient.
You will see it in modern drivers, and may catch you by surprise. This is what the
new way of assigning to the structure looks like:
</p><!-- l. 1 -->
   <pre id="fancyvrb38"><a id="x1-27126r1"></a><span>1</span><span id="textcolor389"><span>struct</span></span><span> file_operations fops = {</span> 
<a id="x1-27128r2"></a><span>2</span><span>    read: device_read,</span> 
<a id="x1-27130r3"></a><span>3</span><span>    write: device_write,</span> 
<a id="x1-27132r4"></a><span>4</span><span>    open: device_open,</span> 
<a id="x1-27134r5"></a><span>5</span><span>    release: device_release</span> 
<a id="x1-27136r6"></a><span>6</span><span>};</span></pre>
<!-- l. 955 --><p>   However, there is also a C99 way of assigning to elements of a structure,
<a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">designated initializers</a>, and this is definitely preferred over using the GNU extension.
You should use this syntax in case someone wants to port your driver. It will help
with compatibility:
</p><!-- l. 1 -->
   <pre id="fancyvrb39"><a id="x1-27144r1"></a><span>1</span><span id="textcolor390"><span>struct</span></span><span> file_operations fops = {</span> 
<a id="x1-27146r2"></a><span>2</span><span>    .read = device_read,</span> 
<a id="x1-27148r3"></a><span>3</span><span>    .write = device_write,</span> 
<a id="x1-27150r4"></a><span>4</span><span>    .open = device_open,</span> 
<a id="x1-27152r5"></a><span>5</span><span>    .release = device_release</span> 
<a id="x1-27154r6"></a><span>6</span><span>};</span></pre>
<!-- l. 968 --><p>   The meaning is clear, and you should be aware that any member of
the structure which you do not explicitly assign will be initialized to
<code> <span>NULL</span>
</code> by gcc.
</p><!-- l. 970 --><p>   An instance of <code>  <span id="textcolor391"><span>struct</span></span><span> file_operations</span>
</code> containing pointers to functions that are used to implement
<code> <span>read</span>
</code>, <code>  <span>write</span>
</code>, <code>  <span>open</span>
</code>, … system calls is commonly named <code>  <span>fops</span>
</code>.
</p><!-- l. 972 --><p>   Since Linux v3.14, the read, write and seek operations are guaranteed for thread-safe by
using the <code>  <span>f_pos</span>
</code> specific lock, which makes the file position update to become the mutual
exclusion. So, we can safely implement those operations without unnecessary
locking.
</p><!-- l. 975 --><p>   Additionally, since Linux v5.6, the <code>  <span>proc_ops</span>
</code> structure was introduced to replace the use of the
<code> <span>file_operations</span>
</code> structure when registering proc handlers. See more information in the <a href="#the-procops-structure">7.1<!-- tex4ht:ref: sec:proc_ops  --></a>
section.
</p><!-- l. 978 -->
   <h4 id="the-file-structure"><span>6.2   </span> <a id="x1-280006.2"></a>The file structure</h4>
<!-- l. 981 --><p>Each device is represented in the kernel by a file structure, which is defined
in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include/linux/fs.h</a>. Be aware that a file is a kernel level structure and
never appears in a user space program. It is not the same thing as a
<code> <span id="textcolor392"><span>FILE</span></span>
</code>, which is defined by glibc and would never appear in a kernel space
function. Also, its name is a bit misleading; it represents an abstract open
‘file’, not a file on a disk, which is represented by a structure named
<code> <span>inode</span>
</code>.
                                                                  

                                                                  
</p><!-- l. 986 --><p>   An instance of struct file is commonly named
<code> <span>filp</span>
</code>. You’ll also see it referred to as a struct file object. Resist the temptation.
</p><!-- l. 990 --><p>   Go ahead and look at the definition of file. Most of the entries you see, like struct
dentry are not used by device drivers, and you can ignore them. This is because
drivers do not fill file directly; they only use structures contained in file which are
created elsewhere.
</p><!-- l. 994 -->
   <h4 id="registering-a-device"><span>6.3   </span> <a id="x1-290006.3"></a>Registering A Device</h4>
<!-- l. 996 --><p>As discussed earlier, char devices are accessed through device files, usually located in
<span><span><span>/dev</span></span></span>. This is by convention. When writing a driver, it is OK to put the
device file in your current directory. Just make sure you place it in <span><span><span>/dev</span></span></span> for a
production driver. The major number tells you which driver handles which
device file. The minor number is used only by the driver itself to differentiate
which device it is operating on, just in case the driver handles more than one
device.
</p><!-- l. 1002 --><p>   Adding a driver to your system means registering it with the kernel. This is synonymous
with assigning it a major number during the module’s initialization. You do this by
using the <code>  <span>register_chrdev</span>
</code> function, defined by <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include/linux/fs.h</a>.
</p><!-- l. 1 -->
   <pre id="fancyvrb40"><a id="x1-29004r1"></a><span>1</span><span id="textcolor393"><span>int</span></span><span> register_chrdev(</span><span id="textcolor394"><span>unsigned</span></span><span> </span><span id="textcolor395"><span>int</span></span><span> major, </span><span id="textcolor396"><span>const</span></span><span> </span><span id="textcolor397"><span>char</span></span><span> *name, </span><span id="textcolor398"><span>struct</span></span><span> file_operations *fops);</span></pre>
<!-- l. 1010 --><p>   Where unsigned int major is the major number you want to request,
<code> <span id="textcolor399"><span>const</span></span><span> </span><span id="textcolor400"><span>char</span></span><span> *name</span>
</code> is the name of the device as it will appear in <span><span><span>/proc/devices</span></span></span> and
<code> <span id="textcolor401"><span>struct</span></span><span> file_operations *fops</span>
</code> is a pointer to the <code>  <span>file_operations</span>
</code> table for your driver. A negative return value means the
registration failed. Note that we didn’t pass the minor number to
<code> <span>register_chrdev</span>
</code>. That is because the kernel doesn’t care about the minor number; only our driver
uses it.
</p><!-- l. 1014 --><p>   Now the question is, how do you get a major number without hijacking
one that’s already in use? The easiest way would be to look through
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt">Documentation/admin-guide/devices.txt</a> and pick an unused one. That is a bad way
of doing things because you will never be sure if the number you picked will be
assigned later. The answer is that you can ask the kernel to assign you a dynamic
major number.
</p><!-- l. 1019 --><p>   If you pass a major number of 0 to <code>  <span>register_chrdev</span>
</code>, the return value will be the dynamically allocated major number. The
downside is that you can not make a device file in advance, since you do not
                                                                  

                                                                  
know what the major number will be. There are a couple of ways to do
this. First, the driver itself can print the newly assigned number and we
can make the device file by hand. Second, the newly registered device will
have an entry in <span><span><span>/proc/devices</span></span></span>, and we can either make the device file by
hand or write a shell script to read the file in and make the device file. The
third method is that we can have our driver make the device file using the
<code> <span>device_create</span>
</code> function after a successful registration and
<code> <span>device_destroy</span>
</code> during the call to <code>  <span>cleanup_module</span>
</code>.
</p><!-- l. 1026 --><p>   However, <code>  <span>register_chrdev()</span>
</code> would occupy a range of minor numbers associated with the given major. The
recommended way to reduce waste for char device registration is using cdev
interface.
</p><!-- l. 1029 --><p>   The newer interface completes the char device registration in two distinct steps.
First, we should register a range of device numbers, which can be completed with
<code> <span>register_chrdev_region</span>
</code> or <code>  <span>alloc_chrdev_region</span>
</code>.
</p><!-- l. 1 -->
   <pre id="fancyvrb41"><a id="x1-29019r1"></a><span>1</span><span id="textcolor402"><span>int</span></span><span> register_chrdev_region(</span><span id="textcolor403"><span>dev_t</span></span><span> from, </span><span id="textcolor404"><span>unsigned</span></span><span> count, </span><span id="textcolor405"><span>const</span></span><span> </span><span id="textcolor406"><span>char</span></span><span> *name);</span> 
<a id="x1-29021r2"></a><span>2</span><span id="textcolor407"><span>int</span></span><span> alloc_chrdev_region(</span><span id="textcolor408"><span>dev_t</span></span><span> *dev, </span><span id="textcolor409"><span>unsigned</span></span><span> baseminor, </span><span id="textcolor410"><span>unsigned</span></span><span> count, </span><span id="textcolor411"><span>const</span></span><span> </span><span id="textcolor412"><span>char</span></span><span> *name);</span></pre>
<!-- l. 1037 --><p>   The choice between two different functions depends on
whether you know the major numbers for your device. Using
<code> <span>register_chrdev_region</span>
</code> if you know the device major number and
<code> <span>alloc_chrdev_region</span>
</code> if you would like to allocate a dynamicly-allocated major number.
</p><!-- l. 1040 --><p>   Second, we should initialize the data structure
<code> <span id="textcolor413"><span>struct</span></span><span> cdev</span>
</code> for our char device and associate it with the device numbers. To initialize the
<code> <span id="textcolor414"><span>struct</span></span><span> cdev</span>
</code>, we can achieve by the similar sequence of the following codes.
</p><!-- l. 1 -->
   <pre id="fancyvrb42"><a id="x1-29029r1"></a><span>1</span><span id="textcolor415"><span>struct</span></span><span> cdev *my_dev = cdev_alloc();</span> 
<a id="x1-29031r2"></a><span>2</span><span>my_cdev-&gt;ops = &amp;my_fops;</span></pre>
<!-- l. 1048 --><p>   However, the common usage pattern will embed the
<code> <span id="textcolor416"><span>struct</span></span><span> cdev</span>
</code> within a device-specific structure of your own. In this case, we’ll need
<code> <span>cdev_init</span>
</code> for the initialization.
</p><!-- l. 1 -->
   <pre id="fancyvrb43"><a id="x1-29036r1"></a><span>1</span><span id="textcolor417"><span>void</span></span><span> cdev_init(</span><span id="textcolor418"><span>struct</span></span><span> cdev *cdev, </span><span id="textcolor419"><span>const</span></span><span> </span><span id="textcolor420"><span>struct</span></span><span> file_operations *fops);</span></pre>
                                                                  

                                                                  
<!-- l. 1055 --><p>   Once we finish the initialization, we can add the char device to the system by using
the <code>  <span>cdev_add</span>
</code>.
</p><!-- l. 1 -->
   <pre id="fancyvrb44"><a id="x1-29040r1"></a><span>1</span><span id="textcolor421"><span>int</span></span><span> cdev_add(</span><span id="textcolor422"><span>struct</span></span><span> cdev *p, </span><span id="textcolor423"><span>dev_t</span></span><span> dev, </span><span id="textcolor424"><span>unsigned</span></span><span> count);</span></pre>
<!-- l. 1061 --><p>   To find a example using the interface, you can see <span><span><span>ioctl.c</span></span></span> described in section
<a href="#talking-to-device-files">9<!-- tex4ht:ref: sec:device_files  --></a>.
</p><!-- l. 1063 -->
   <h4 id="unregistering-a-device"><span>6.4   </span> <a id="x1-300006.4"></a>Unregistering A Device</h4>
<!-- l. 1065 --><p>We can not allow the kernel module to be
<code> <span>rmmod</span>
</code>’ed whenever root feels like it. If the device file is opened by a process and then we
remove the kernel module, using the file would cause a call to the memory location
where the appropriate function (read/write) used to be. If we are lucky, no
other code was loaded there, and we’ll get an ugly error message. If we are
unlucky, another kernel module was loaded into the same location, which
means a jump into the middle of another function within the kernel. The
results of this would be impossible to predict, but they can not be very
positive.
</p><!-- l. 1071 --><p>   Normally, when you do not want to allow something, you return an error code
(a negative number) from the function which is supposed to do it. With
<code> <span>cleanup_module</span>
</code> that’s impossible because it is a void function. However, there is a counter
which keeps track of how many processes are using your module. You
can see what its value is by looking at the 3rd field with the command
<code> <span>cat /proc/modules</span>
</code> or <code>  <span>sudo lsmod</span>
</code>. If this number isn’t zero, <code>  <span>rmmod</span>
</code> will fail. Note that you do not have to check the counter within
<code> <span>cleanup_module</span>
</code> because the check will be performed for you by the system call
<code> <span>sys_delete_module</span>
</code>, defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/syscalls.h">include/linux/syscalls.h</a>. You should not use this counter directly, but
there are functions defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">include/linux/module.h</a> which let you increase,
decrease and display this counter:
</p>
     <ul>
     <li><code>  <span>try_module_get(THIS_MODULE)</span>
     </code>: Increment the reference count of current module.
     </li>
     <li><code>  <span>module_put(THIS_MODULE)</span>
     </code>: Decrement the reference count of current module.
     </li>
     <li><code>  <span>module_refcount(THIS_MODULE)</span>
     </code>: Return the value of reference count of current module.</li></ul>
<!-- l. 1085 --><p>   It is important to keep the counter accurate; if you ever do lose track of the
correct usage count, you will never be able to unload the module; it’s now reboot
time, boys and girls. This is bound to happen to you sooner or later during a
module’s development.
</p><!-- l. 1088 -->
   <h4 id="chardevc"><span>6.5   </span> <a id="x1-310006.5"></a>chardev.c</h4>
<!-- l. 1090 --><p>The next code sample creates a char driver named <span><span><span>chardev</span></span></span>. You can dump its device
file.
</p><!-- l. 1 -->
   <pre id="fancyvrb45"><a id="x1-31003r1"></a><span>1</span><span>cat /proc/devices</span></pre>
<!-- l. 1097 --><p>   (or open the file with a program) and the driver will put the number of times the
device file has been read from into the file. We do not support writing to the file (like
<code> <span>echo </span><span id="textcolor425"><span>&#34;hi&#34;</span></span><span> &gt; /dev/hello</span>
</code>), but catch these attempts and tell the user that the operation is not supported.
Don’t worry if you don’t see what we do with the data we read into the buffer; we
don’t do much with it. We simply read in the data and print a message
acknowledging that we received it.
</p><!-- l. 1102 --><p>   In the multiple-threaded environment, without any protection, concurrent access
to the same memory may lead to the race condition, and will not preserve the
performance. In the kernel module, this problem may happen due to multiple
instances accessing the shared resources. Therefore, a solution is to enforce the
exclusive access. We use atomic Compare-And-Swap (CAS) to maintain the states,
<code> <span>CDEV_NOT_USED</span>
</code> and <code>  <span>CDEV_EXCLUSIVE_OPEN</span>
                                                                  

                                                                  
</code>, to determine whether the file is currently opened by someone or not. CAS compares
the contents of a memory location with the expected value and, only if they are the
same, modifies the contents of that memory location to the desired value. See more
concurrency details in the <a href="#avoiding-collisions-and-deadlocks">12<!-- tex4ht:ref: sec:synchronization  --></a> section.
</p><!-- l. 1 -->
   <pre id="fancyvrb46"><a id="x1-31008r1"></a><span>1</span><span id="textcolor426"><span>/*</span></span> 
<a id="x1-31010r2"></a><span>2</span><span id="textcolor427"><span> * chardev.c: Creates a read-only char device that says how many times</span></span> 
<a id="x1-31012r3"></a><span>3</span><span id="textcolor428"><span> * you have read from the dev file</span></span> 
<a id="x1-31014r4"></a><span>4</span><span id="textcolor429"><span> */</span></span> 
<a id="x1-31016r5"></a><span>5</span> 
<a id="x1-31018r6"></a><span>6</span><span id="textcolor430"><span>#include</span></span><span> </span><span id="textcolor431"><span>&lt;linux/atomic.h&gt;</span></span> 
<a id="x1-31020r7"></a><span>7</span><span id="textcolor432"><span>#include</span></span><span> </span><span id="textcolor433"><span>&lt;linux/cdev.h&gt;</span></span> 
<a id="x1-31022r8"></a><span>8</span><span id="textcolor434"><span>#include</span></span><span> </span><span id="textcolor435"><span>&lt;linux/delay.h&gt;</span></span> 
<a id="x1-31024r9"></a><span>9</span><span id="textcolor436"><span>#include</span></span><span> </span><span id="textcolor437"><span>&lt;linux/device.h&gt;</span></span> 
<a id="x1-31026r10"></a><span>10</span><span id="textcolor438"><span>#include</span></span><span> </span><span id="textcolor439"><span>&lt;linux/fs.h&gt;</span></span> 
<a id="x1-31028r11"></a><span>11</span><span id="textcolor440"><span>#include</span></span><span> </span><span id="textcolor441"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-31030r12"></a><span>12</span><span id="textcolor442"><span>#include</span></span><span> </span><span id="textcolor443"><span>&lt;linux/kernel.h&gt; /* for sprintf() */</span></span> 
<a id="x1-31032r13"></a><span>13</span><span id="textcolor444"><span>#include</span></span><span> </span><span id="textcolor445"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-31034r14"></a><span>14</span><span id="textcolor446"><span>#include</span></span><span> </span><span id="textcolor447"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-31036r15"></a><span>15</span><span id="textcolor448"><span>#include</span></span><span> </span><span id="textcolor449"><span>&lt;linux/types.h&gt;</span></span> 
<a id="x1-31038r16"></a><span>16</span><span id="textcolor450"><span>#include</span></span><span> </span><span id="textcolor451"><span>&lt;linux/uaccess.h&gt; /* for get_user and put_user */</span></span> 
<a id="x1-31040r17"></a><span>17</span> 
<a id="x1-31042r18"></a><span>18</span><span id="textcolor452"><span>#include</span></span><span> </span><span id="textcolor453"><span>&lt;asm/errno.h&gt;</span></span> 
<a id="x1-31044r19"></a><span>19</span> 
<a id="x1-31046r20"></a><span>20</span><span id="textcolor454"><span>/*  Prototypes - this would normally go in a .h file */</span></span> 
<a id="x1-31048r21"></a><span>21</span><span id="textcolor455"><span>static</span></span><span> </span><span id="textcolor456"><span>int</span></span><span> device_open(</span><span id="textcolor457"><span>struct</span></span><span> inode *, </span><span id="textcolor458"><span>struct</span></span><span> file *);</span> 
<a id="x1-31050r22"></a><span>22</span><span id="textcolor459"><span>static</span></span><span> </span><span id="textcolor460"><span>int</span></span><span> device_release(</span><span id="textcolor461"><span>struct</span></span><span> inode *, </span><span id="textcolor462"><span>struct</span></span><span> file *);</span> 
<a id="x1-31052r23"></a><span>23</span><span id="textcolor463"><span>static</span></span><span> </span><span id="textcolor464"><span>ssize_t</span></span><span> device_read(</span><span id="textcolor465"><span>struct</span></span><span> file *, </span><span id="textcolor466"><span>char</span></span><span> __user *, </span><span id="textcolor467"><span>size_t</span></span><span>, loff_t *);</span> 
<a id="x1-31054r24"></a><span>24</span><span id="textcolor468"><span>static</span></span><span> </span><span id="textcolor469"><span>ssize_t</span></span><span> device_write(</span><span id="textcolor470"><span>struct</span></span><span> file *, </span><span id="textcolor471"><span>const</span></span><span> </span><span id="textcolor472"><span>char</span></span><span> __user *, </span><span id="textcolor473"><span>size_t</span></span><span>,</span> 
<a id="x1-31056r25"></a><span>25</span><span>                            loff_t *);</span> 
<a id="x1-31058r26"></a><span>26</span> 
<a id="x1-31060r27"></a><span>27</span><span id="textcolor474"><span>#define SUCCESS 0</span></span> 
<a id="x1-31062r28"></a><span>28</span><span id="textcolor475"><span>#define DEVICE_NAME &#34;chardev&#34; </span></span><span id="textcolor476"><span>/* Dev name as it appears in /proc/devices   */</span></span> 
<a id="x1-31064r29"></a><span>29</span><span id="textcolor477"><span>#define BUF_LEN 80 </span></span><span id="textcolor478"><span>/* Max length of the message from the device */</span></span> 
<a id="x1-31066r30"></a><span>30</span> 
<a id="x1-31068r31"></a><span>31</span><span id="textcolor479"><span>/* Global variables are declared as static, so are global within the file. */</span></span> 
<a id="x1-31070r32"></a><span>32</span> 
<a id="x1-31072r33"></a><span>33</span><span id="textcolor480"><span>static</span></span><span> </span><span id="textcolor481"><span>int</span></span><span> major; </span><span id="textcolor482"><span>/* major number assigned to our device driver */</span></span> 
<a id="x1-31074r34"></a><span>34</span> 
<a id="x1-31076r35"></a><span>35</span><span id="textcolor483"><span>enum</span></span><span> {</span> 
<a id="x1-31078r36"></a><span>36</span><span>    CDEV_NOT_USED = 0,</span> 
<a id="x1-31080r37"></a><span>37</span><span>    CDEV_EXCLUSIVE_OPEN = 1,</span> 
<a id="x1-31082r38"></a><span>38</span><span>};</span> 
<a id="x1-31084r39"></a><span>39</span> 
<a id="x1-31086r40"></a><span>40</span><span id="textcolor484"><span>/* Is device open? Used to prevent multiple access to device */</span></span> 
<a id="x1-31088r41"></a><span>41</span><span id="textcolor485"><span>static</span></span><span> atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);</span> 
<a id="x1-31090r42"></a><span>42</span> 
<a id="x1-31092r43"></a><span>43</span><span id="textcolor486"><span>static</span></span><span> </span><span id="textcolor487"><span>char</span></span><span> msg[BUF_LEN + 1]; </span><span id="textcolor488"><span>/* The msg the device will give when asked */</span></span> 
<a id="x1-31094r44"></a><span>44</span> 
<a id="x1-31096r45"></a><span>45</span><span id="textcolor489"><span>static</span></span><span> </span><span id="textcolor490"><span>struct</span></span><span> class *cls;</span> 
<a id="x1-31098r46"></a><span>46</span> 
<a id="x1-31100r47"></a><span>47</span><span id="textcolor491"><span>static</span></span><span> </span><span id="textcolor492"><span>struct</span></span><span> file_operations chardev_fops = {</span> 
<a id="x1-31102r48"></a><span>48</span><span>    .read = device_read,</span> 
<a id="x1-31104r49"></a><span>49</span><span>    .write = device_write,</span> 
<a id="x1-31106r50"></a><span>50</span><span>    .open = device_open,</span> 
<a id="x1-31108r51"></a><span>51</span><span>    .release = device_release,</span> 
<a id="x1-31110r52"></a><span>52</span><span>};</span> 
<a id="x1-31112r53"></a><span>53</span> 
<a id="x1-31114r54"></a><span>54</span><span id="textcolor493"><span>static</span></span><span> </span><span id="textcolor494"><span>int</span></span><span> __init chardev_init(</span><span id="textcolor495"><span>void</span></span><span>)</span> 
<a id="x1-31116r55"></a><span>55</span><span>{</span> 
<a id="x1-31118r56"></a><span>56</span><span>    major = register_chrdev(0, DEVICE_NAME, &amp;chardev_fops);</span> 
<a id="x1-31120r57"></a><span>57</span> 
<a id="x1-31122r58"></a><span>58</span><span>    </span><span id="textcolor496"><span>if</span></span><span> (major &lt; 0) {</span> 
<a id="x1-31124r59"></a><span>59</span><span>        pr_alert(</span><span id="textcolor497"><span>&#34;Registering char device failed with %d</span></span><span id="textcolor498"><span>\n</span></span><span id="textcolor499"><span>&#34;</span></span><span>, major);</span> 
<a id="x1-31126r60"></a><span>60</span><span>        </span><span id="textcolor500"><span>return</span></span><span> major;</span> 
<a id="x1-31128r61"></a><span>61</span><span>    }</span> 
<a id="x1-31130r62"></a><span>62</span> 
<a id="x1-31132r63"></a><span>63</span><span>    pr_info(</span><span id="textcolor501"><span>&#34;I was assigned major number %d.</span></span><span id="textcolor502"><span>\n</span></span><span id="textcolor503"><span>&#34;</span></span><span>, major);</span> 
<a id="x1-31134r64"></a><span>64</span> 
<a id="x1-31136r65"></a><span>65</span><span>    cls = class_create(THIS_MODULE, DEVICE_NAME);</span> 
<a id="x1-31138r66"></a><span>66</span><span>    device_create(cls, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);</span> 
<a id="x1-31140r67"></a><span>67</span> 
<a id="x1-31142r68"></a><span>68</span><span>    pr_info(</span><span id="textcolor504"><span>&#34;Device created on /dev/%s</span></span><span id="textcolor505"><span>\n</span></span><span id="textcolor506"><span>&#34;</span></span><span>, DEVICE_NAME);</span> 
<a id="x1-31144r69"></a><span>69</span> 
<a id="x1-31146r70"></a><span>70</span><span>    </span><span id="textcolor507"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-31148r71"></a><span>71</span><span>}</span> 
<a id="x1-31150r72"></a><span>72</span> 
<a id="x1-31152r73"></a><span>73</span><span id="textcolor508"><span>static</span></span><span> </span><span id="textcolor509"><span>void</span></span><span> __exit chardev_exit(</span><span id="textcolor510"><span>void</span></span><span>)</span> 
<a id="x1-31154r74"></a><span>74</span><span>{</span> 
<a id="x1-31156r75"></a><span>75</span><span>    device_destroy(cls, MKDEV(major, 0));</span> 
<a id="x1-31158r76"></a><span>76</span><span>    class_destroy(cls);</span> 
<a id="x1-31160r77"></a><span>77</span> 
<a id="x1-31162r78"></a><span>78</span><span>    </span><span id="textcolor511"><span>/* Unregister the device */</span></span> 
<a id="x1-31164r79"></a><span>79</span><span>    unregister_chrdev(major, DEVICE_NAME);</span> 
<a id="x1-31166r80"></a><span>80</span><span>}</span> 
<a id="x1-31168r81"></a><span>81</span> 
<a id="x1-31170r82"></a><span>82</span><span id="textcolor512"><span>/* Methods */</span></span> 
<a id="x1-31172r83"></a><span>83</span> 
<a id="x1-31174r84"></a><span>84</span><span id="textcolor513"><span>/* Called when a process tries to open the device file, like</span></span> 
<a id="x1-31176r85"></a><span>85</span><span id="textcolor514"><span> * &#34;sudo cat /dev/chardev&#34;</span></span> 
<a id="x1-31178r86"></a><span>86</span><span id="textcolor515"><span> */</span></span> 
<a id="x1-31180r87"></a><span>87</span><span id="textcolor516"><span>static</span></span><span> </span><span id="textcolor517"><span>int</span></span><span> device_open(</span><span id="textcolor518"><span>struct</span></span><span> inode *inode, </span><span id="textcolor519"><span>struct</span></span><span> file *file)</span> 
<a id="x1-31182r88"></a><span>88</span><span>{</span> 
<a id="x1-31184r89"></a><span>89</span><span>    </span><span id="textcolor520"><span>static</span></span><span> </span><span id="textcolor521"><span>int</span></span><span> counter = 0;</span> 
<a id="x1-31186r90"></a><span>90</span> 
<a id="x1-31188r91"></a><span>91</span><span>    </span><span id="textcolor522"><span>if</span></span><span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))</span> 
<a id="x1-31190r92"></a><span>92</span><span>        </span><span id="textcolor523"><span>return</span></span><span> -EBUSY;</span> 
<a id="x1-31192r93"></a><span>93</span> 
<a id="x1-31194r94"></a><span>94</span><span>    sprintf(msg, </span><span id="textcolor524"><span>&#34;I already told you %d times Hello world!</span></span><span id="textcolor525"><span>\n</span></span><span id="textcolor526"><span>&#34;</span></span><span>, counter++);</span> 
<a id="x1-31196r95"></a><span>95</span><span>    try_module_get(THIS_MODULE);</span> 
<a id="x1-31198r96"></a><span>96</span> 
<a id="x1-31200r97"></a><span>97</span><span>    </span><span id="textcolor527"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-31202r98"></a><span>98</span><span>}</span> 
<a id="x1-31204r99"></a><span>99</span> 
<a id="x1-31206r100"></a><span>100</span><span id="textcolor528"><span>/* Called when a process closes the device file. */</span></span> 
<a id="x1-31208r101"></a><span>101</span><span id="textcolor529"><span>static</span></span><span> </span><span id="textcolor530"><span>int</span></span><span> device_release(</span><span id="textcolor531"><span>struct</span></span><span> inode *inode, </span><span id="textcolor532"><span>struct</span></span><span> file *file)</span> 
<a id="x1-31210r102"></a><span>102</span><span>{</span> 
<a id="x1-31212r103"></a><span>103</span><span>    </span><span id="textcolor533"><span>/* We</span><span>&#39;</span><span>re now ready for our next caller */</span></span> 
<a id="x1-31214r104"></a><span>104</span><span>    atomic_set(&amp;already_open, CDEV_NOT_USED);</span> 
<a id="x1-31216r105"></a><span>105</span> 
<a id="x1-31218r106"></a><span>106</span><span>    </span><span id="textcolor534"><span>/* Decrement the usage count, or else once you opened the file, you will</span></span> 
<a id="x1-31220r107"></a><span>107</span><span id="textcolor535"><span>     * never get rid of the module.</span></span> 
<a id="x1-31222r108"></a><span>108</span><span id="textcolor536"><span>     */</span></span> 
<a id="x1-31224r109"></a><span>109</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-31226r110"></a><span>110</span> 
<a id="x1-31228r111"></a><span>111</span><span>    </span><span id="textcolor537"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-31230r112"></a><span>112</span><span>}</span> 
<a id="x1-31232r113"></a><span>113</span> 
<a id="x1-31234r114"></a><span>114</span><span id="textcolor538"><span>/* Called when a process, which already opened the dev file, attempts to</span></span> 
<a id="x1-31236r115"></a><span>115</span><span id="textcolor539"><span> * read from it.</span></span> 
<a id="x1-31238r116"></a><span>116</span><span id="textcolor540"><span> */</span></span> 
<a id="x1-31240r117"></a><span>117</span><span id="textcolor541"><span>static</span></span><span> </span><span id="textcolor542"><span>ssize_t</span></span><span> device_read(</span><span id="textcolor543"><span>struct</span></span><span> file *filp, </span><span id="textcolor544"><span>/* see include/linux/fs.h   */</span></span> 
<a id="x1-31242r118"></a><span>118</span><span>                           </span><span id="textcolor545"><span>char</span></span><span> __user *buffer, </span><span id="textcolor546"><span>/* buffer to fill with data */</span></span> 
<a id="x1-31244r119"></a><span>119</span><span>                           </span><span id="textcolor547"><span>size_t</span></span><span> length, </span><span id="textcolor548"><span>/* length of the buffer     */</span></span> 
<a id="x1-31246r120"></a><span>120</span><span>                           loff_t *offset)</span> 
<a id="x1-31248r121"></a><span>121</span><span>{</span> 
<a id="x1-31250r122"></a><span>122</span><span>    </span><span id="textcolor549"><span>/* Number of bytes actually written to the buffer */</span></span> 
<a id="x1-31252r123"></a><span>123</span><span>    </span><span id="textcolor550"><span>int</span></span><span> bytes_read = 0;</span> 
<a id="x1-31254r124"></a><span>124</span><span>    </span><span id="textcolor551"><span>const</span></span><span> </span><span id="textcolor552"><span>char</span></span><span> *msg_ptr = msg;</span> 
<a id="x1-31256r125"></a><span>125</span> 
<a id="x1-31258r126"></a><span>126</span><span>    </span><span id="textcolor553"><span>if</span></span><span> (!*(msg_ptr + *offset)) { </span><span id="textcolor554"><span>/* we are at the end of message */</span></span> 
<a id="x1-31260r127"></a><span>127</span><span>        *offset = 0; </span><span id="textcolor555"><span>/* reset the offset */</span></span> 
<a id="x1-31262r128"></a><span>128</span><span>        </span><span id="textcolor556"><span>return</span></span><span> 0; </span><span id="textcolor557"><span>/* signify end of file */</span></span> 
<a id="x1-31264r129"></a><span>129</span><span>    }</span> 
<a id="x1-31266r130"></a><span>130</span> 
<a id="x1-31268r131"></a><span>131</span><span>    msg_ptr += *offset;</span> 
<a id="x1-31270r132"></a><span>132</span> 
<a id="x1-31272r133"></a><span>133</span><span>    </span><span id="textcolor558"><span>/* Actually put the data into the buffer */</span></span> 
<a id="x1-31274r134"></a><span>134</span><span>    </span><span id="textcolor559"><span>while</span></span><span> (length &amp;&amp; *msg_ptr) {</span> 
<a id="x1-31276r135"></a><span>135</span><span>        </span><span id="textcolor560"><span>/* The buffer is in the user data segment, not the kernel</span></span> 
<a id="x1-31278r136"></a><span>136</span><span id="textcolor561"><span>         * segment so &#34;*&#34; assignment won</span><span>&#39;</span><span>t work.  We have to use</span></span> 
<a id="x1-31280r137"></a><span>137</span><span id="textcolor562"><span>         * put_user which copies data from the kernel data segment to</span></span> 
<a id="x1-31282r138"></a><span>138</span><span id="textcolor563"><span>         * the user data segment.</span></span> 
<a id="x1-31284r139"></a><span>139</span><span id="textcolor564"><span>         */</span></span> 
<a id="x1-31286r140"></a><span>140</span><span>        put_user(*(msg_ptr++), buffer++);</span> 
<a id="x1-31288r141"></a><span>141</span><span>        length--;</span> 
<a id="x1-31290r142"></a><span>142</span><span>        bytes_read++;</span> 
<a id="x1-31292r143"></a><span>143</span><span>    }</span> 
<a id="x1-31294r144"></a><span>144</span> 
<a id="x1-31296r145"></a><span>145</span><span>    *offset += bytes_read;</span> 
<a id="x1-31298r146"></a><span>146</span> 
<a id="x1-31300r147"></a><span>147</span><span>    </span><span id="textcolor565"><span>/* Most read functions return the number of bytes put into the buffer. */</span></span> 
<a id="x1-31302r148"></a><span>148</span><span>    </span><span id="textcolor566"><span>return</span></span><span> bytes_read;</span> 
<a id="x1-31304r149"></a><span>149</span><span>}</span> 
<a id="x1-31306r150"></a><span>150</span> 
<a id="x1-31308r151"></a><span>151</span><span id="textcolor567"><span>/* Called when a process writes to dev file: echo &#34;hi&#34; &gt; /dev/hello */</span></span> 
<a id="x1-31310r152"></a><span>152</span><span id="textcolor568"><span>static</span></span><span> </span><span id="textcolor569"><span>ssize_t</span></span><span> device_write(</span><span id="textcolor570"><span>struct</span></span><span> file *filp, </span><span id="textcolor571"><span>const</span></span><span> </span><span id="textcolor572"><span>char</span></span><span> __user *buff,</span> 
<a id="x1-31312r153"></a><span>153</span><span>                            </span><span id="textcolor573"><span>size_t</span></span><span> len, loff_t *off)</span> 
<a id="x1-31314r154"></a><span>154</span><span>{</span> 
<a id="x1-31316r155"></a><span>155</span><span>    pr_alert(</span><span id="textcolor574"><span>&#34;Sorry, this operation is not supported.</span></span><span id="textcolor575"><span>\n</span></span><span id="textcolor576"><span>&#34;</span></span><span>);</span> 
<a id="x1-31318r156"></a><span>156</span><span>    </span><span id="textcolor577"><span>return</span></span><span> -EINVAL;</span> 
<a id="x1-31320r157"></a><span>157</span><span>}</span> 
<a id="x1-31322r158"></a><span>158</span> 
<a id="x1-31324r159"></a><span>159</span><span>module_init(chardev_init);</span> 
<a id="x1-31326r160"></a><span>160</span><span>module_exit(chardev_exit);</span> 
<a id="x1-31328r161"></a><span>161</span> 
<a id="x1-31330r162"></a><span>162</span><span>MODULE_LICENSE(</span><span id="textcolor578"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1111 -->
   <h4 id="writing-modules-for-multiple-kernel-versions"><span>6.6   </span> <a id="x1-320006.6"></a>Writing Modules for Multiple Kernel Versions</h4>
<!-- l. 1113 --><p>The system calls, which are the major interface the kernel shows to the processes,
generally stay the same across versions. A new system call may be added, but
usually the old ones will behave exactly like they used to. This is necessary for
backward compatibility – a new kernel version is not supposed to break regular
processes. In most cases, the device files will also remain the same. On the other
hand, the internal interfaces within the kernel can and do change between
versions.
</p><!-- l. 1118 --><p>   There are differences between different kernel versions, and if you want
to support multiple kernel versions, you will find yourself having to code
conditional compilation directives. The way to do this to compare the macro
<code> <span>LINUX_VERSION_CODE</span>
</code> to the macro <code>  <span>KERNEL_VERSION</span>
</code>. In version <span><span><span>a.b.c</span></span></span> of the kernel, the value of this macro would be <img alt="216a+ 28b+ c  " src="https://bogomolnyelad.substack.com/p/lkmpg-for-ht0x.svg"/>.
</p><!-- l. 1122 -->
   <h3 id="the-proc-file-system"><span>7   </span> <a id="x1-330007"></a>The /proc File System</h3>
<!-- l. 1124 --><p>In Linux, there is an additional mechanism for the kernel and kernel modules to send
information to processes — the <span><span><span>/proc</span></span></span> file system. Originally designed to allow easy
access to information about processes (hence the name), it is now used by every bit
of the kernel which has something interesting to report, such as <span><span><span>/proc/modules</span></span></span>
which provides the list of modules and <span><span><span>/proc/meminfo</span></span></span> which gathers memory usage
statistics.
</p><!-- l. 1127 --><p>   The method to use the proc file system is very similar to the one used with device
drivers — a structure is created with all the information needed for the <span><span><span>/proc</span></span></span> file,
including pointers to any handler functions (in our case there is only one, the
one called when somebody attempts to read from the <span><span><span>/proc</span></span></span> file). Then,
<code> <span>init_module</span>
</code> registers the structure with the kernel and
<code> <span>cleanup_module</span>
</code> unregisters it.
                                                                  

                                                                  
</p><!-- l. 1130 --><p>   Normal file systems are located on a disk, rather than just in memory (which is
where <span><span><span>/proc</span></span></span> is), and in that case the index-node (inode for short) number
is a pointer to a disk location where the file’s inode is located. The inode
contains information about the file, for example the file’s permissions, together
with a pointer to the disk location or locations where the file’s data can be
found.
</p><!-- l. 1133 --><p>   Because we don’t get called when the file is opened or closed, there’s nowhere for
us to put <code>  <span>try_module_get</span>
</code> and <code>  <span>module_put</span>
</code> in this module, and if the file is opened and then the module is removed, there’s no
way to avoid the consequences.
</p><!-- l. 1135 --><p>   Here a simple example showing how to use a <span><span><span>/proc</span></span></span> file. This is the HelloWorld for
the <span><span><span>/proc</span></span></span> filesystem. There are three parts: create the file <span><span><span>/proc/helloworld</span></span></span> in the
function <code>  <span>init_module</span>
</code>, return a value (and a buffer) when the file <span><span><span>/proc/helloworld</span></span></span> is read in the callback
function <code>  <span>procfile_read</span>
</code>, and delete the file <span><span><span>/proc/helloworld</span></span></span> in the function
<code> <span>cleanup_module</span>
</code>.
</p><!-- l. 1139 --><p>   The <span><span><span>/proc/helloworld</span></span></span> is created when the module is loaded with the function
<code> <span>proc_create</span>
</code>. The return value is a <code>  <span id="textcolor579"><span>struct</span></span><span> proc_dir_entry</span>
</code>, and it will be used to configure the file <span><span><span>/proc/helloworld</span></span></span> (for example, the owner
of this file). A null return value means that the creation has failed.
</p><!-- l. 1143 --><p>   Every time the file <span><span><span>/proc/helloworld</span></span></span> is read, the function
<code> <span>procfile_read</span>
</code> is called. Two parameters of this function are very important: the buffer
(the second parameter) and the offset (the fourth one). The content of the
buffer will be returned to the application which read it (for example the
<code> <span>cat</span>
</code> command). The offset is the current position in the file. If the return value of the
function is not null, then this function is called again. So be careful with this
function, if it never returns zero, the read function is called endlessly.
                                                                  

                                                                  
</p>
   <pre id="verbatim-15">$ cat /proc/helloworld
HelloWorld!
</pre>
<!-- l. 1153 --><!-- l. 1 -->
   <pre id="fancyvrb47"><a id="x1-33013r1"></a><span>1</span><span id="textcolor580"><span>/*</span></span> 
<a id="x1-33015r2"></a><span>2</span><span id="textcolor581"><span> * procfs1.c</span></span> 
<a id="x1-33017r3"></a><span>3</span><span id="textcolor582"><span> */</span></span> 
<a id="x1-33019r4"></a><span>4</span> 
<a id="x1-33021r5"></a><span>5</span><span id="textcolor583"><span>#include</span></span><span> </span><span id="textcolor584"><span>&lt;linux/kernel.h&gt;</span></span> 
<a id="x1-33023r6"></a><span>6</span><span id="textcolor585"><span>#include</span></span><span> </span><span id="textcolor586"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-33025r7"></a><span>7</span><span id="textcolor587"><span>#include</span></span><span> </span><span id="textcolor588"><span>&lt;linux/proc_fs.h&gt;</span></span> 
<a id="x1-33027r8"></a><span>8</span><span id="textcolor589"><span>#include</span></span><span> </span><span id="textcolor590"><span>&lt;linux/uaccess.h&gt;</span></span> 
<a id="x1-33029r9"></a><span>9</span><span id="textcolor591"><span>#include</span></span><span> </span><span id="textcolor592"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-33031r10"></a><span>10</span> 
<a id="x1-33033r11"></a><span>11</span><span id="textcolor593"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span> 
<a id="x1-33035r12"></a><span>12</span><span id="textcolor594"><span>#define HAVE_PROC_OPS</span></span> 
<a id="x1-33037r13"></a><span>13</span><span id="textcolor595"><span>#endif</span></span> 
<a id="x1-33039r14"></a><span>14</span> 
<a id="x1-33041r15"></a><span>15</span><span id="textcolor596"><span>#define procfs_name &#34;helloworld&#34;</span></span> 
<a id="x1-33043r16"></a><span>16</span> 
<a id="x1-33045r17"></a><span>17</span><span id="textcolor597"><span>static</span></span><span> </span><span id="textcolor598"><span>struct</span></span><span> proc_dir_entry *our_proc_file;</span> 
<a id="x1-33047r18"></a><span>18</span> 
<a id="x1-33049r19"></a><span>19</span><span id="textcolor599"><span>static</span></span><span> </span><span id="textcolor600"><span>ssize_t</span></span><span> procfile_read(</span><span id="textcolor601"><span>struct</span></span><span> file *file_pointer, </span><span id="textcolor602"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-33051r20"></a><span>20</span><span>                             </span><span id="textcolor603"><span>size_t</span></span><span> buffer_length, loff_t *offset)</span> 
<a id="x1-33053r21"></a><span>21</span><span>{</span> 
<a id="x1-33055r22"></a><span>22</span><span>    </span><span id="textcolor604"><span>char</span></span><span> s[13] = </span><span id="textcolor605"><span>&#34;HelloWorld!</span></span><span id="textcolor606"><span>\n</span></span><span id="textcolor607"><span>&#34;</span></span><span>;</span> 
<a id="x1-33057r23"></a><span>23</span><span>    </span><span id="textcolor608"><span>int</span></span><span> len = </span><span id="textcolor609"><span>sizeof</span></span><span>(s);</span> 
<a id="x1-33059r24"></a><span>24</span><span>    </span><span id="textcolor610"><span>ssize_t</span></span><span> ret = len;</span> 
<a id="x1-33061r25"></a><span>25</span> 
<a id="x1-33063r26"></a><span>26</span><span>    </span><span id="textcolor611"><span>if</span></span><span> (*offset &gt;= len || copy_to_user(buffer, s, len)) {</span> 
<a id="x1-33065r27"></a><span>27</span><span>        pr_info(</span><span id="textcolor612"><span>&#34;copy_to_user failed</span></span><span id="textcolor613"><span>\n</span></span><span id="textcolor614"><span>&#34;</span></span><span>);</span> 
<a id="x1-33067r28"></a><span>28</span><span>        ret = 0;</span> 
<a id="x1-33069r29"></a><span>29</span><span>    } </span><span id="textcolor615"><span>else</span></span><span> {</span> 
<a id="x1-33071r30"></a><span>30</span><span>        pr_info(</span><span id="textcolor616"><span>&#34;procfile read %s</span></span><span id="textcolor617"><span>\n</span></span><span id="textcolor618"><span>&#34;</span></span><span>, file_pointer-&gt;f_path.dentry-&gt;d_name.name);</span> 
<a id="x1-33073r31"></a><span>31</span><span>        *offset += len;</span> 
<a id="x1-33075r32"></a><span>32</span><span>    }</span> 
<a id="x1-33077r33"></a><span>33</span> 
<a id="x1-33079r34"></a><span>34</span><span>    </span><span id="textcolor619"><span>return</span></span><span> ret;</span> 
<a id="x1-33081r35"></a><span>35</span><span>}</span> 
<a id="x1-33083r36"></a><span>36</span> 
<a id="x1-33085r37"></a><span>37</span><span id="textcolor620"><span>#ifdef HAVE_PROC_OPS</span></span> 
<a id="x1-33087r38"></a><span>38</span><span id="textcolor621"><span>static</span></span><span> </span><span id="textcolor622"><span>const</span></span><span> </span><span id="textcolor623"><span>struct</span></span><span> proc_ops proc_file_fops = {</span> 
<a id="x1-33089r39"></a><span>39</span><span>    .proc_read = procfile_read,</span> 
<a id="x1-33091r40"></a><span>40</span><span>};</span> 
<a id="x1-33093r41"></a><span>41</span><span id="textcolor624"><span>#else</span></span> 
<a id="x1-33095r42"></a><span>42</span><span id="textcolor625"><span>static</span></span><span> </span><span id="textcolor626"><span>const</span></span><span> </span><span id="textcolor627"><span>struct</span></span><span> file_operations proc_file_fops = {</span> 
<a id="x1-33097r43"></a><span>43</span><span>    .read = procfile_read,</span> 
<a id="x1-33099r44"></a><span>44</span><span>};</span> 
<a id="x1-33101r45"></a><span>45</span><span id="textcolor628"><span>#endif</span></span> 
<a id="x1-33103r46"></a><span>46</span> 
<a id="x1-33105r47"></a><span>47</span><span id="textcolor629"><span>static</span></span><span> </span><span id="textcolor630"><span>int</span></span><span> __init procfs1_init(</span><span id="textcolor631"><span>void</span></span><span>)</span> 
<a id="x1-33107r48"></a><span>48</span><span>{</span> 
<a id="x1-33109r49"></a><span>49</span><span>    our_proc_file = proc_create(procfs_name, 0644, NULL, &amp;proc_file_fops);</span> 
<a id="x1-33111r50"></a><span>50</span><span>    </span><span id="textcolor632"><span>if</span></span><span> (NULL == our_proc_file) {</span> 
<a id="x1-33113r51"></a><span>51</span><span>        proc_remove(our_proc_file);</span> 
<a id="x1-33115r52"></a><span>52</span><span>        pr_alert(</span><span id="textcolor633"><span>&#34;Error:Could not initialize /proc/%s</span></span><span id="textcolor634"><span>\n</span></span><span id="textcolor635"><span>&#34;</span></span><span>, procfs_name);</span> 
<a id="x1-33117r53"></a><span>53</span><span>        </span><span id="textcolor636"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-33119r54"></a><span>54</span><span>    }</span> 
<a id="x1-33121r55"></a><span>55</span> 
<a id="x1-33123r56"></a><span>56</span><span>    pr_info(</span><span id="textcolor637"><span>&#34;/proc/%s created</span></span><span id="textcolor638"><span>\n</span></span><span id="textcolor639"><span>&#34;</span></span><span>, procfs_name);</span> 
<a id="x1-33125r57"></a><span>57</span><span>    </span><span id="textcolor640"><span>return</span></span><span> 0;</span> 
<a id="x1-33127r58"></a><span>58</span><span>}</span> 
<a id="x1-33129r59"></a><span>59</span> 
<a id="x1-33131r60"></a><span>60</span><span id="textcolor641"><span>static</span></span><span> </span><span id="textcolor642"><span>void</span></span><span> __exit procfs1_exit(</span><span id="textcolor643"><span>void</span></span><span>)</span> 
<a id="x1-33133r61"></a><span>61</span><span>{</span> 
<a id="x1-33135r62"></a><span>62</span><span>    proc_remove(our_proc_file);</span> 
<a id="x1-33137r63"></a><span>63</span><span>    pr_info(</span><span id="textcolor644"><span>&#34;/proc/%s removed</span></span><span id="textcolor645"><span>\n</span></span><span id="textcolor646"><span>&#34;</span></span><span>, procfs_name);</span> 
<a id="x1-33139r64"></a><span>64</span><span>}</span> 
<a id="x1-33141r65"></a><span>65</span> 
<a id="x1-33143r66"></a><span>66</span><span>module_init(procfs1_init);</span> 
<a id="x1-33145r67"></a><span>67</span><span>module_exit(procfs1_exit);</span> 
<a id="x1-33147r68"></a><span>68</span> 
<a id="x1-33149r69"></a><span>69</span><span>MODULE_LICENSE(</span><span id="textcolor647"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1157 -->
   <h4 id="the-procops-structure"><span>7.1   </span> <a id="x1-340007.1"></a>The proc_ops Structure</h4>
<!-- l. 1159 --><p>The <code>  <span>proc_ops</span>
</code> structure is defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/proc_fs.h">include/linux/proc_fs.h</a> in Linux v5.6+. In older kernels, it
used <code>  <span>file_operations</span>
</code> for custom hooks in <span><span><span>/proc</span></span></span> file system, but it contains some
members that are unnecessary in VFS, and every time VFS expands
<code> <span>file_operations</span>
</code> set, <span><span><span>/proc</span></span></span> code comes bloated. On the other hand, not only the space,
but also some operations were saved by this structure to improve its
performance. For example, the file which never disappears in <span><span><span>/proc</span></span></span> can set the
<code> <span>proc_flag</span>
</code> as <code>  <span>PROC_ENTRY_PERMANENT</span>
</code> to save 2 atomic ops, 1 allocation, 1 free in per open/read/close sequence.
</p><!-- l. 1164 -->
   <h4 id="read-and-write-a-proc-file"><span>7.2   </span> <a id="x1-350007.2"></a>Read and Write a /proc File</h4>
<!-- l. 1166 --><p>We have seen a very simple example for a <span><span><span>/proc</span></span></span> file where we only read
the file <span><span><span>/proc/helloworld</span></span></span>. It is also possible to write in a <span><span><span>/proc</span></span></span> file. It
works the same way as read, a function is called when the <span><span><span>/proc</span></span></span> file
is written. But there is a little difference with read, data comes from
user, so you have to import data from user space to kernel space (with
<code> <span>copy_from_user</span>
</code> or <code>  <span>get_user</span>
</code>)
</p><!-- l. 1171 --><p>   The reason for <code>  <span>copy_from_user</span>
</code> or <code>  <span>get_user</span>
</code> is that Linux memory (on Intel architecture, it may be different under some
                                                                  

                                                                  
other processors) is segmented. This means that a pointer, by itself, does
not reference a unique location in memory, only a location in a memory
segment, and you need to know which memory segment it is to be able to use
it. There is one memory segment for the kernel, and one for each of the
processes.
</p><!-- l. 1175 --><p>   The only memory segment accessible to a process is its own, so when
writing regular programs to run as processes, there is no need to worry about
segments. When you write a kernel module, normally you want to access
the kernel memory segment, which is handled automatically by the system.
However, when the content of a memory buffer needs to be passed between
the currently running process and the kernel, the kernel function receives
a pointer to the memory buffer which is in the process segment. The
<code> <span>put_user</span>
</code> and <code>  <span>get_user</span>
</code> macros allow you to access that memory. These functions handle
only one character, you can handle several characters with
<code> <span>copy_to_user</span>
</code> and <code>  <span>copy_from_user</span>
</code>. As the buffer (in read or write function) is in kernel space, for write function you
need to import data because it comes from user space, but not for the read function
because data is already in kernel space.
</p><!-- l. 1 -->
   <pre id="fancyvrb48"><a id="x1-35010r1"></a><span>1</span><span id="textcolor648"><span>/*</span></span> 
<a id="x1-35012r2"></a><span>2</span><span id="textcolor649"><span> * procfs2.c -  create a &#34;file&#34; in /proc</span></span> 
<a id="x1-35014r3"></a><span>3</span><span id="textcolor650"><span> */</span></span> 
<a id="x1-35016r4"></a><span>4</span> 
<a id="x1-35018r5"></a><span>5</span><span id="textcolor651"><span>#include</span></span><span> </span><span id="textcolor652"><span>&lt;linux/kernel.h&gt; /* We</span><span>&#39;</span><span>re doing kernel work */</span></span> 
<a id="x1-35020r6"></a><span>6</span><span id="textcolor653"><span>#include</span></span><span> </span><span id="textcolor654"><span>&lt;linux/module.h&gt; /* Specifically, a module */</span></span> 
<a id="x1-35022r7"></a><span>7</span><span id="textcolor655"><span>#include</span></span><span> </span><span id="textcolor656"><span>&lt;linux/proc_fs.h&gt; /* Necessary because we use the proc fs */</span></span> 
<a id="x1-35024r8"></a><span>8</span><span id="textcolor657"><span>#include</span></span><span> </span><span id="textcolor658"><span>&lt;linux/uaccess.h&gt; /* for copy_from_user */</span></span> 
<a id="x1-35026r9"></a><span>9</span><span id="textcolor659"><span>#include</span></span><span> </span><span id="textcolor660"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-35028r10"></a><span>10</span> 
<a id="x1-35030r11"></a><span>11</span><span id="textcolor661"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span> 
<a id="x1-35032r12"></a><span>12</span><span id="textcolor662"><span>#define HAVE_PROC_OPS</span></span> 
<a id="x1-35034r13"></a><span>13</span><span id="textcolor663"><span>#endif</span></span> 
<a id="x1-35036r14"></a><span>14</span> 
<a id="x1-35038r15"></a><span>15</span><span id="textcolor664"><span>#define PROCFS_MAX_SIZE 1024</span></span> 
<a id="x1-35040r16"></a><span>16</span><span id="textcolor665"><span>#define PROCFS_NAME &#34;buffer1k&#34;</span></span> 
<a id="x1-35042r17"></a><span>17</span> 
<a id="x1-35044r18"></a><span>18</span><span id="textcolor666"><span>/* This structure hold information about the /proc file */</span></span> 
<a id="x1-35046r19"></a><span>19</span><span id="textcolor667"><span>static</span></span><span> </span><span id="textcolor668"><span>struct</span></span><span> proc_dir_entry *our_proc_file;</span> 
<a id="x1-35048r20"></a><span>20</span> 
<a id="x1-35050r21"></a><span>21</span><span id="textcolor669"><span>/* The buffer used to store character for this module */</span></span> 
<a id="x1-35052r22"></a><span>22</span><span id="textcolor670"><span>static</span></span><span> </span><span id="textcolor671"><span>char</span></span><span> procfs_buffer[PROCFS_MAX_SIZE];</span> 
<a id="x1-35054r23"></a><span>23</span> 
<a id="x1-35056r24"></a><span>24</span><span id="textcolor672"><span>/* The size of the buffer */</span></span> 
<a id="x1-35058r25"></a><span>25</span><span id="textcolor673"><span>static</span></span><span> </span><span id="textcolor674"><span>unsigned</span></span><span> </span><span id="textcolor675"><span>long</span></span><span> procfs_buffer_size = 0;</span> 
<a id="x1-35060r26"></a><span>26</span> 
<a id="x1-35062r27"></a><span>27</span><span id="textcolor676"><span>/* This function is called then the /proc file is read */</span></span> 
<a id="x1-35064r28"></a><span>28</span><span id="textcolor677"><span>static</span></span><span> </span><span id="textcolor678"><span>ssize_t</span></span><span> procfile_read(</span><span id="textcolor679"><span>struct</span></span><span> file *file_pointer, </span><span id="textcolor680"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-35066r29"></a><span>29</span><span>                             </span><span id="textcolor681"><span>size_t</span></span><span> buffer_length, loff_t *offset)</span> 
<a id="x1-35068r30"></a><span>30</span><span>{</span> 
<a id="x1-35070r31"></a><span>31</span><span>    </span><span id="textcolor682"><span>char</span></span><span> s[13] = </span><span id="textcolor683"><span>&#34;HelloWorld!</span></span><span id="textcolor684"><span>\n</span></span><span id="textcolor685"><span>&#34;</span></span><span>;</span> 
<a id="x1-35072r32"></a><span>32</span><span>    </span><span id="textcolor686"><span>int</span></span><span> len = </span><span id="textcolor687"><span>sizeof</span></span><span>(s);</span> 
<a id="x1-35074r33"></a><span>33</span><span>    </span><span id="textcolor688"><span>ssize_t</span></span><span> ret = len;</span> 
<a id="x1-35076r34"></a><span>34</span> 
<a id="x1-35078r35"></a><span>35</span><span>    </span><span id="textcolor689"><span>if</span></span><span> (*offset &gt;= len || copy_to_user(buffer, s, len)) {</span> 
<a id="x1-35080r36"></a><span>36</span><span>        pr_info(</span><span id="textcolor690"><span>&#34;copy_to_user failed</span></span><span id="textcolor691"><span>\n</span></span><span id="textcolor692"><span>&#34;</span></span><span>);</span> 
<a id="x1-35082r37"></a><span>37</span><span>        ret = 0;</span> 
<a id="x1-35084r38"></a><span>38</span><span>    } </span><span id="textcolor693"><span>else</span></span><span> {</span> 
<a id="x1-35086r39"></a><span>39</span><span>        pr_info(</span><span id="textcolor694"><span>&#34;procfile read %s</span></span><span id="textcolor695"><span>\n</span></span><span id="textcolor696"><span>&#34;</span></span><span>, file_pointer-&gt;f_path.dentry-&gt;d_name.name);</span> 
<a id="x1-35088r40"></a><span>40</span><span>        *offset += len;</span> 
<a id="x1-35090r41"></a><span>41</span><span>    }</span> 
<a id="x1-35092r42"></a><span>42</span> 
<a id="x1-35094r43"></a><span>43</span><span>    </span><span id="textcolor697"><span>return</span></span><span> ret;</span> 
<a id="x1-35096r44"></a><span>44</span><span>}</span> 
<a id="x1-35098r45"></a><span>45</span> 
<a id="x1-35100r46"></a><span>46</span><span id="textcolor698"><span>/* This function is called with the /proc file is written. */</span></span> 
<a id="x1-35102r47"></a><span>47</span><span id="textcolor699"><span>static</span></span><span> </span><span id="textcolor700"><span>ssize_t</span></span><span> procfile_write(</span><span id="textcolor701"><span>struct</span></span><span> file *file, </span><span id="textcolor702"><span>const</span></span><span> </span><span id="textcolor703"><span>char</span></span><span> __user *buff,</span> 
<a id="x1-35104r48"></a><span>48</span><span>                              </span><span id="textcolor704"><span>size_t</span></span><span> len, loff_t *off)</span> 
<a id="x1-35106r49"></a><span>49</span><span>{</span> 
<a id="x1-35108r50"></a><span>50</span><span>    procfs_buffer_size = len;</span> 
<a id="x1-35110r51"></a><span>51</span><span>    </span><span id="textcolor705"><span>if</span></span><span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE)</span> 
<a id="x1-35112r52"></a><span>52</span><span>        procfs_buffer_size = PROCFS_MAX_SIZE;</span> 
<a id="x1-35114r53"></a><span>53</span> 
<a id="x1-35116r54"></a><span>54</span><span>    </span><span id="textcolor706"><span>if</span></span><span> (copy_from_user(procfs_buffer, buff, procfs_buffer_size))</span> 
<a id="x1-35118r55"></a><span>55</span><span>        </span><span id="textcolor707"><span>return</span></span><span> -EFAULT;</span> 
<a id="x1-35120r56"></a><span>56</span> 
<a id="x1-35122r57"></a><span>57</span><span>    procfs_buffer[procfs_buffer_size &amp; (PROCFS_MAX_SIZE - 1)] = </span><span id="textcolor708"><span>&#39;</span><span>\0</span><span>&#39;</span></span><span>;</span> 
<a id="x1-35124r58"></a><span>58</span><span>    *off += procfs_buffer_size;</span> 
<a id="x1-35126r59"></a><span>59</span><span>    pr_info(</span><span id="textcolor709"><span>&#34;procfile write %s</span></span><span id="textcolor710"><span>\n</span></span><span id="textcolor711"><span>&#34;</span></span><span>, procfs_buffer);</span> 
<a id="x1-35128r60"></a><span>60</span> 
<a id="x1-35130r61"></a><span>61</span><span>    </span><span id="textcolor712"><span>return</span></span><span> procfs_buffer_size;</span> 
<a id="x1-35132r62"></a><span>62</span><span>}</span> 
<a id="x1-35134r63"></a><span>63</span> 
<a id="x1-35136r64"></a><span>64</span><span id="textcolor713"><span>#ifdef HAVE_PROC_OPS</span></span> 
<a id="x1-35138r65"></a><span>65</span><span id="textcolor714"><span>static</span></span><span> </span><span id="textcolor715"><span>const</span></span><span> </span><span id="textcolor716"><span>struct</span></span><span> proc_ops proc_file_fops = {</span> 
<a id="x1-35140r66"></a><span>66</span><span>    .proc_read = procfile_read,</span> 
<a id="x1-35142r67"></a><span>67</span><span>    .proc_write = procfile_write,</span> 
<a id="x1-35144r68"></a><span>68</span><span>};</span> 
<a id="x1-35146r69"></a><span>69</span><span id="textcolor717"><span>#else</span></span> 
<a id="x1-35148r70"></a><span>70</span><span id="textcolor718"><span>static</span></span><span> </span><span id="textcolor719"><span>const</span></span><span> </span><span id="textcolor720"><span>struct</span></span><span> file_operations proc_file_fops = {</span> 
<a id="x1-35150r71"></a><span>71</span><span>    .read = procfile_read,</span> 
<a id="x1-35152r72"></a><span>72</span><span>    .write = procfile_write,</span> 
<a id="x1-35154r73"></a><span>73</span><span>};</span> 
<a id="x1-35156r74"></a><span>74</span><span id="textcolor721"><span>#endif</span></span> 
<a id="x1-35158r75"></a><span>75</span> 
<a id="x1-35160r76"></a><span>76</span><span id="textcolor722"><span>static</span></span><span> </span><span id="textcolor723"><span>int</span></span><span> __init procfs2_init(</span><span id="textcolor724"><span>void</span></span><span>)</span> 
<a id="x1-35162r77"></a><span>77</span><span>{</span> 
<a id="x1-35164r78"></a><span>78</span><span>    our_proc_file = proc_create(PROCFS_NAME, 0644, NULL, &amp;proc_file_fops);</span> 
<a id="x1-35166r79"></a><span>79</span><span>    </span><span id="textcolor725"><span>if</span></span><span> (NULL == our_proc_file) {</span> 
<a id="x1-35168r80"></a><span>80</span><span>        proc_remove(our_proc_file);</span> 
<a id="x1-35170r81"></a><span>81</span><span>        pr_alert(</span><span id="textcolor726"><span>&#34;Error:Could not initialize /proc/%s</span></span><span id="textcolor727"><span>\n</span></span><span id="textcolor728"><span>&#34;</span></span><span>, PROCFS_NAME);</span> 
<a id="x1-35172r82"></a><span>82</span><span>        </span><span id="textcolor729"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-35174r83"></a><span>83</span><span>    }</span> 
<a id="x1-35176r84"></a><span>84</span> 
<a id="x1-35178r85"></a><span>85</span><span>    pr_info(</span><span id="textcolor730"><span>&#34;/proc/%s created</span></span><span id="textcolor731"><span>\n</span></span><span id="textcolor732"><span>&#34;</span></span><span>, PROCFS_NAME);</span> 
<a id="x1-35180r86"></a><span>86</span><span>    </span><span id="textcolor733"><span>return</span></span><span> 0;</span> 
<a id="x1-35182r87"></a><span>87</span><span>}</span> 
<a id="x1-35184r88"></a><span>88</span> 
<a id="x1-35186r89"></a><span>89</span><span id="textcolor734"><span>static</span></span><span> </span><span id="textcolor735"><span>void</span></span><span> __exit procfs2_exit(</span><span id="textcolor736"><span>void</span></span><span>)</span> 
<a id="x1-35188r90"></a><span>90</span><span>{</span> 
<a id="x1-35190r91"></a><span>91</span><span>    proc_remove(our_proc_file);</span> 
<a id="x1-35192r92"></a><span>92</span><span>    pr_info(</span><span id="textcolor737"><span>&#34;/proc/%s removed</span></span><span id="textcolor738"><span>\n</span></span><span id="textcolor739"><span>&#34;</span></span><span>, PROCFS_NAME);</span> 
<a id="x1-35194r93"></a><span>93</span><span>}</span> 
<a id="x1-35196r94"></a><span>94</span> 
<a id="x1-35198r95"></a><span>95</span><span>module_init(procfs2_init);</span> 
<a id="x1-35200r96"></a><span>96</span><span>module_exit(procfs2_exit);</span> 
<a id="x1-35202r97"></a><span>97</span> 
<a id="x1-35204r98"></a><span>98</span><span>MODULE_LICENSE(</span><span id="textcolor740"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1184 -->
   <h4 id="manage-proc-file-with-standard-filesystem"><span>7.3   </span> <a id="x1-360007.3"></a>Manage /proc file with standard filesystem</h4>
<!-- l. 1186 --><p>We have seen how to read and write a <span><span><span>/proc</span></span></span> file with the <span><span><span>/proc</span></span></span> interface. But it is
also possible to manage <span><span><span>/proc</span></span></span> file with inodes. The main concern is to use advanced
functions, like permissions.
</p><!-- l. 1190 --><p>   In Linux, there is a standard mechanism for file system registration.
Since every file system has to have its own functions to handle inode and file
operations, there is a special structure to hold pointers to all those functions,
<code> <span id="textcolor741"><span>struct</span></span><span> inode_operations</span>
</code>, which includes a pointer to <code>  <span id="textcolor742"><span>struct</span></span><span> proc_ops</span>
</code>.
</p><!-- l. 1193 --><p>   The difference between file and inode operations is that file operations deal with
the file itself whereas inode operations deal with ways of referencing the file, such as
creating links to it.
</p><!-- l. 1195 --><p>   In <span><span><span>/proc</span></span></span>, whenever we register a new file, we’re allowed to specify which
<code> <span id="textcolor743"><span>struct</span></span><span> inode_operations</span>
</code> will be used to access to it. This is the mechanism we use, a
<code> <span id="textcolor744"><span>struct</span></span><span> inode_operations</span>
                                                                  

                                                                  
</code> which includes a pointer to a <code>  <span id="textcolor745"><span>struct</span></span><span> proc_ops</span>
</code> which includes pointers to our <code>  <span>procf_read</span>
</code> and <code>  <span>procfs_write</span>
</code> functions.
</p><!-- l. 1198 --><p>   Another interesting point here is the
<code> <span>module_permission</span>
</code> function. This function is called whenever a process tries to do something with the
<span><span><span>/proc</span></span></span> file, and it can decide whether to allow access or not. Right now it is only
based on the operation and the uid of the current user (as available in current, a
pointer to a structure which includes information on the currently running
process), but it could be based on anything we like, such as what other
processes are doing with the same file, the time of day, or the last input we
received.
</p><!-- l. 1202 --><p>   It is important to note that the standard roles of read and write are reversed in
the kernel. Read functions are used for output, whereas write functions are used for
input. The reason for that is that read and write refer to the user’s point of view — if
a process reads something from the kernel, then the kernel needs to output it, and
if a process writes something to the kernel, then the kernel receives it as
input.
</p><!-- l. 1 -->
   <pre id="fancyvrb49"><a id="x1-36010r1"></a><span>1</span><span id="textcolor746"><span>/*</span></span> 
<a id="x1-36012r2"></a><span>2</span><span id="textcolor747"><span> * procfs3.c</span></span> 
<a id="x1-36014r3"></a><span>3</span><span id="textcolor748"><span> */</span></span> 
<a id="x1-36016r4"></a><span>4</span> 
<a id="x1-36018r5"></a><span>5</span><span id="textcolor749"><span>#include</span></span><span> </span><span id="textcolor750"><span>&lt;linux/kernel.h&gt;</span></span> 
<a id="x1-36020r6"></a><span>6</span><span id="textcolor751"><span>#include</span></span><span> </span><span id="textcolor752"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-36022r7"></a><span>7</span><span id="textcolor753"><span>#include</span></span><span> </span><span id="textcolor754"><span>&lt;linux/proc_fs.h&gt;</span></span> 
<a id="x1-36024r8"></a><span>8</span><span id="textcolor755"><span>#include</span></span><span> </span><span id="textcolor756"><span>&lt;linux/sched.h&gt;</span></span> 
<a id="x1-36026r9"></a><span>9</span><span id="textcolor757"><span>#include</span></span><span> </span><span id="textcolor758"><span>&lt;linux/uaccess.h&gt;</span></span> 
<a id="x1-36028r10"></a><span>10</span><span id="textcolor759"><span>#include</span></span><span> </span><span id="textcolor760"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-36030r11"></a><span>11</span><span id="textcolor761"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0)</span></span> 
<a id="x1-36032r12"></a><span>12</span><span id="textcolor762"><span>#include</span></span><span> </span><span id="textcolor763"><span>&lt;linux/minmax.h&gt;</span></span> 
<a id="x1-36034r13"></a><span>13</span><span id="textcolor764"><span>#endif</span></span> 
<a id="x1-36036r14"></a><span>14</span> 
<a id="x1-36038r15"></a><span>15</span><span id="textcolor765"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span> 
<a id="x1-36040r16"></a><span>16</span><span id="textcolor766"><span>#define HAVE_PROC_OPS</span></span> 
<a id="x1-36042r17"></a><span>17</span><span id="textcolor767"><span>#endif</span></span> 
<a id="x1-36044r18"></a><span>18</span> 
<a id="x1-36046r19"></a><span>19</span><span id="textcolor768"><span>#define PROCFS_MAX_SIZE 2048UL</span></span> 
<a id="x1-36048r20"></a><span>20</span><span id="textcolor769"><span>#define PROCFS_ENTRY_FILENAME &#34;buffer2k&#34;</span></span> 
<a id="x1-36050r21"></a><span>21</span> 
<a id="x1-36052r22"></a><span>22</span><span id="textcolor770"><span>static</span></span><span> </span><span id="textcolor771"><span>struct</span></span><span> proc_dir_entry *our_proc_file;</span> 
<a id="x1-36054r23"></a><span>23</span><span id="textcolor772"><span>static</span></span><span> </span><span id="textcolor773"><span>char</span></span><span> procfs_buffer[PROCFS_MAX_SIZE];</span> 
<a id="x1-36056r24"></a><span>24</span><span id="textcolor774"><span>static</span></span><span> </span><span id="textcolor775"><span>unsigned</span></span><span> </span><span id="textcolor776"><span>long</span></span><span> procfs_buffer_size = 0;</span> 
<a id="x1-36058r25"></a><span>25</span> 
<a id="x1-36060r26"></a><span>26</span><span id="textcolor777"><span>static</span></span><span> </span><span id="textcolor778"><span>ssize_t</span></span><span> procfs_read(</span><span id="textcolor779"><span>struct</span></span><span> file *filp, </span><span id="textcolor780"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-36062r27"></a><span>27</span><span>                           </span><span id="textcolor781"><span>size_t</span></span><span> length, loff_t *offset)</span> 
<a id="x1-36064r28"></a><span>28</span><span>{</span> 
<a id="x1-36066r29"></a><span>29</span><span>    </span><span id="textcolor782"><span>if</span></span><span> (*offset || procfs_buffer_size == 0) {</span> 
<a id="x1-36068r30"></a><span>30</span><span>        pr_debug(</span><span id="textcolor783"><span>&#34;procfs_read: END</span></span><span id="textcolor784"><span>\n</span></span><span id="textcolor785"><span>&#34;</span></span><span>);</span> 
<a id="x1-36070r31"></a><span>31</span><span>        *offset = 0;</span> 
<a id="x1-36072r32"></a><span>32</span><span>        </span><span id="textcolor786"><span>return</span></span><span> 0;</span> 
<a id="x1-36074r33"></a><span>33</span><span>    }</span> 
<a id="x1-36076r34"></a><span>34</span><span>    procfs_buffer_size = min(procfs_buffer_size, length);</span> 
<a id="x1-36078r35"></a><span>35</span><span>    </span><span id="textcolor787"><span>if</span></span><span> (copy_to_user(buffer, procfs_buffer, procfs_buffer_size))</span> 
<a id="x1-36080r36"></a><span>36</span><span>        </span><span id="textcolor788"><span>return</span></span><span> -EFAULT;</span> 
<a id="x1-36082r37"></a><span>37</span><span>    *offset += procfs_buffer_size;</span> 
<a id="x1-36084r38"></a><span>38</span> 
<a id="x1-36086r39"></a><span>39</span><span>    pr_debug(</span><span id="textcolor789"><span>&#34;procfs_read: read %lu bytes</span></span><span id="textcolor790"><span>\n</span></span><span id="textcolor791"><span>&#34;</span></span><span>, procfs_buffer_size);</span> 
<a id="x1-36088r40"></a><span>40</span><span>    </span><span id="textcolor792"><span>return</span></span><span> procfs_buffer_size;</span> 
<a id="x1-36090r41"></a><span>41</span><span>}</span> 
<a id="x1-36092r42"></a><span>42</span><span id="textcolor793"><span>static</span></span><span> </span><span id="textcolor794"><span>ssize_t</span></span><span> procfs_write(</span><span id="textcolor795"><span>struct</span></span><span> file *file, </span><span id="textcolor796"><span>const</span></span><span> </span><span id="textcolor797"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-36094r43"></a><span>43</span><span>                            </span><span id="textcolor798"><span>size_t</span></span><span> len, loff_t *off)</span> 
<a id="x1-36096r44"></a><span>44</span><span>{</span> 
<a id="x1-36098r45"></a><span>45</span><span>    procfs_buffer_size = min(PROCFS_MAX_SIZE, len);</span> 
<a id="x1-36100r46"></a><span>46</span><span>    </span><span id="textcolor799"><span>if</span></span><span> (copy_from_user(procfs_buffer, buffer, procfs_buffer_size))</span> 
<a id="x1-36102r47"></a><span>47</span><span>        </span><span id="textcolor800"><span>return</span></span><span> -EFAULT;</span> 
<a id="x1-36104r48"></a><span>48</span><span>    *off += procfs_buffer_size;</span> 
<a id="x1-36106r49"></a><span>49</span> 
<a id="x1-36108r50"></a><span>50</span><span>    pr_debug(</span><span id="textcolor801"><span>&#34;procfs_write: write %lu bytes</span></span><span id="textcolor802"><span>\n</span></span><span id="textcolor803"><span>&#34;</span></span><span>, procfs_buffer_size);</span> 
<a id="x1-36110r51"></a><span>51</span><span>    </span><span id="textcolor804"><span>return</span></span><span> procfs_buffer_size;</span> 
<a id="x1-36112r52"></a><span>52</span><span>}</span> 
<a id="x1-36114r53"></a><span>53</span><span id="textcolor805"><span>static</span></span><span> </span><span id="textcolor806"><span>int</span></span><span> procfs_open(</span><span id="textcolor807"><span>struct</span></span><span> inode *inode, </span><span id="textcolor808"><span>struct</span></span><span> file *file)</span> 
<a id="x1-36116r54"></a><span>54</span><span>{</span> 
<a id="x1-36118r55"></a><span>55</span><span>    try_module_get(THIS_MODULE);</span> 
<a id="x1-36120r56"></a><span>56</span><span>    </span><span id="textcolor809"><span>return</span></span><span> 0;</span> 
<a id="x1-36122r57"></a><span>57</span><span>}</span> 
<a id="x1-36124r58"></a><span>58</span><span id="textcolor810"><span>static</span></span><span> </span><span id="textcolor811"><span>int</span></span><span> procfs_close(</span><span id="textcolor812"><span>struct</span></span><span> inode *inode, </span><span id="textcolor813"><span>struct</span></span><span> file *file)</span> 
<a id="x1-36126r59"></a><span>59</span><span>{</span> 
<a id="x1-36128r60"></a><span>60</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-36130r61"></a><span>61</span><span>    </span><span id="textcolor814"><span>return</span></span><span> 0;</span> 
<a id="x1-36132r62"></a><span>62</span><span>}</span> 
<a id="x1-36134r63"></a><span>63</span> 
<a id="x1-36136r64"></a><span>64</span><span id="textcolor815"><span>#ifdef HAVE_PROC_OPS</span></span> 
<a id="x1-36138r65"></a><span>65</span><span id="textcolor816"><span>static</span></span><span> </span><span id="textcolor817"><span>struct</span></span><span> proc_ops file_ops_4_our_proc_file = {</span> 
<a id="x1-36140r66"></a><span>66</span><span>    .proc_read = procfs_read,</span> 
<a id="x1-36142r67"></a><span>67</span><span>    .proc_write = procfs_write,</span> 
<a id="x1-36144r68"></a><span>68</span><span>    .proc_open = procfs_open,</span> 
<a id="x1-36146r69"></a><span>69</span><span>    .proc_release = procfs_close,</span> 
<a id="x1-36148r70"></a><span>70</span><span>};</span> 
<a id="x1-36150r71"></a><span>71</span><span id="textcolor818"><span>#else</span></span> 
<a id="x1-36152r72"></a><span>72</span><span id="textcolor819"><span>static</span></span><span> </span><span id="textcolor820"><span>const</span></span><span> </span><span id="textcolor821"><span>struct</span></span><span> file_operations file_ops_4_our_proc_file = {</span> 
<a id="x1-36154r73"></a><span>73</span><span>    .read = procfs_read,</span> 
<a id="x1-36156r74"></a><span>74</span><span>    .write = procfs_write,</span> 
<a id="x1-36158r75"></a><span>75</span><span>    .open = procfs_open,</span> 
<a id="x1-36160r76"></a><span>76</span><span>    .release = procfs_close,</span> 
<a id="x1-36162r77"></a><span>77</span><span>};</span> 
<a id="x1-36164r78"></a><span>78</span><span id="textcolor822"><span>#endif</span></span> 
<a id="x1-36166r79"></a><span>79</span> 
<a id="x1-36168r80"></a><span>80</span><span id="textcolor823"><span>static</span></span><span> </span><span id="textcolor824"><span>int</span></span><span> __init procfs3_init(</span><span id="textcolor825"><span>void</span></span><span>)</span> 
<a id="x1-36170r81"></a><span>81</span><span>{</span> 
<a id="x1-36172r82"></a><span>82</span><span>    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, 0644, NULL,</span> 
<a id="x1-36174r83"></a><span>83</span><span>                                &amp;file_ops_4_our_proc_file);</span> 
<a id="x1-36176r84"></a><span>84</span><span>    </span><span id="textcolor826"><span>if</span></span><span> (our_proc_file == NULL) {</span> 
<a id="x1-36178r85"></a><span>85</span><span>        remove_proc_entry(PROCFS_ENTRY_FILENAME, NULL);</span> 
<a id="x1-36180r86"></a><span>86</span><span>        pr_debug(</span><span id="textcolor827"><span>&#34;Error: Could not initialize /proc/%s</span></span><span id="textcolor828"><span>\n</span></span><span id="textcolor829"><span>&#34;</span></span><span>,</span> 
<a id="x1-36182r87"></a><span>87</span><span>                 PROCFS_ENTRY_FILENAME);</span> 
<a id="x1-36184r88"></a><span>88</span><span>        </span><span id="textcolor830"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-36186r89"></a><span>89</span><span>    }</span> 
<a id="x1-36188r90"></a><span>90</span><span>    proc_set_size(our_proc_file, 80);</span> 
<a id="x1-36190r91"></a><span>91</span><span>    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);</span> 
<a id="x1-36192r92"></a><span>92</span> 
<a id="x1-36194r93"></a><span>93</span><span>    pr_debug(</span><span id="textcolor831"><span>&#34;/proc/%s created</span></span><span id="textcolor832"><span>\n</span></span><span id="textcolor833"><span>&#34;</span></span><span>, PROCFS_ENTRY_FILENAME);</span> 
<a id="x1-36196r94"></a><span>94</span><span>    </span><span id="textcolor834"><span>return</span></span><span> 0;</span> 
<a id="x1-36198r95"></a><span>95</span><span>}</span> 
<a id="x1-36200r96"></a><span>96</span> 
<a id="x1-36202r97"></a><span>97</span><span id="textcolor835"><span>static</span></span><span> </span><span id="textcolor836"><span>void</span></span><span> __exit procfs3_exit(</span><span id="textcolor837"><span>void</span></span><span>)</span> 
<a id="x1-36204r98"></a><span>98</span><span>{</span> 
<a id="x1-36206r99"></a><span>99</span><span>    remove_proc_entry(PROCFS_ENTRY_FILENAME, NULL);</span> 
<a id="x1-36208r100"></a><span>100</span><span>    pr_debug(</span><span id="textcolor838"><span>&#34;/proc/%s removed</span></span><span id="textcolor839"><span>\n</span></span><span id="textcolor840"><span>&#34;</span></span><span>, PROCFS_ENTRY_FILENAME);</span> 
<a id="x1-36210r101"></a><span>101</span><span>}</span> 
<a id="x1-36212r102"></a><span>102</span> 
<a id="x1-36214r103"></a><span>103</span><span>module_init(procfs3_init);</span> 
<a id="x1-36216r104"></a><span>104</span><span>module_exit(procfs3_exit);</span> 
<a id="x1-36218r105"></a><span>105</span> 
<a id="x1-36220r106"></a><span>106</span><span>MODULE_LICENSE(</span><span id="textcolor841"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1208 --><p>   Still hungry for procfs examples? Well, first of all keep in mind, there are rumors
around, claiming that procfs is on its way out, consider using <span><span><span>sysfs</span></span></span> instead. Consider
using this mechanism, in case you want to document something kernel related
yourself.
</p><!-- l. 1212 -->
   <h4 id="manage-proc-file-with-seqfile"><span>7.4   </span> <a id="x1-370007.4"></a>Manage /proc file with seq_file</h4>
<!-- l. 1214 --><p>As we have seen, writing a <span><span><span>/proc</span></span></span> file may be quite “complex”.
So to help people writting <span><span><span>/proc</span></span></span> file, there is an API named
<code> <span>seq_file</span>
</code> that helps formating a <span><span><span>/proc</span></span></span> file for output. It is based on sequence, which is composed of
3 functions: <code>  <span>start()</span>
</code>, <code>  <span>next()</span>
</code>, and <code>  <span>stop()</span>
</code>. The <code>  <span>seq_file</span>
</code> API starts a sequence when a user read the <span><span><span>/proc</span></span></span> file.
</p><!-- l. 1219 --><p>   A sequence begins with the call of the function
<code> <span>start()</span>
</code>. If the return is a non <code>  <span>NULL</span>
</code> value, the function <code>  <span>next()</span>
</code> is called. This function is an iterator, the goal is to go through all the data. Each
                                                                  

                                                                  
time <code>  <span>next()</span>
</code> is called, the function <code>  <span>show()</span>
</code> is also called. It writes data values in the buffer read by the user. The function
<code> <span>next()</span>
</code> is called until it returns <code>  <span>NULL</span>
</code>. The sequence ends when <code>  <span>next()</span>
</code> returns <code>  <span>NULL</span>
</code>, then the function <code>  <span>stop()</span>
</code> is called.
</p><!-- l. 1227 --><p>   BE CAREFUL: when a sequence is finished, another one starts. That means that at the end
of function <code>  <span>stop()</span>
</code>, the function <code>  <span>start()</span>
</code> is called again. This loop finishes when the function
<code> <span>start()</span>
</code> returns <code>  <span>NULL</span>
</code>. You can see a scheme of this in the Figure <a href="#ignorespaces-how-seqfile-works">1<!-- tex4ht:ref: img:seqfile  --></a>.
</p>
   <figure id="ignorespaces-how-seqfile-works"> 

                                                                  

                                                                  
<a id="x1-37020r1"></a>
                                                                  

                                                                  
<!-- l. 1234 --><p><img alt="srYrsNNYtaeenetoooertusetupstrxr((ntn))( tis)istrr teeaNreNatUaUtmLtLmeLmLen?e?ntntt  " src="https://bogomolnyelad.substack.com/p/lkmpg-for-ht1x.svg"/>
</p>
<figcaption><span>Figure 1:</span><span>How seq_file works</span></figcaption><!-- tex4ht:label?: x1-37020r1  -->
                                                                  

                                                                  
   </figure>
<!-- l. 1254 --><p>   The <code>  <span>seq_file</span>
</code> provides basic functions for <code>  <span>proc_ops</span>
</code>, such as <code>  <span>seq_read</span>
</code>, <code>  <span>seq_lseek</span>
</code>, and some others. But nothing to write in the <span><span><span>/proc</span></span></span> file. Of course, you can still use
the same way as in the previous example.
</p>
   <pre id="fancyvrb50"><a id="x1-37026r1"></a><span>1</span><span id="textcolor842"><span>/*</span></span> 
<a id="x1-37028r2"></a><span>2</span><span id="textcolor843"><span> * procfs4.c -  create a &#34;file&#34; in /proc</span></span> 
<a id="x1-37030r3"></a><span>3</span><span id="textcolor844"><span> * This program uses the seq_file library to manage the /proc file.</span></span> 
<a id="x1-37032r4"></a><span>4</span><span id="textcolor845"><span> */</span></span> 
<a id="x1-37034r5"></a><span>5</span> 
<a id="x1-37036r6"></a><span>6</span><span id="textcolor846"><span>#include</span></span><span> </span><span id="textcolor847"><span>&lt;linux/kernel.h&gt; /* We are doing kernel work */</span></span> 
<a id="x1-37038r7"></a><span>7</span><span id="textcolor848"><span>#include</span></span><span> </span><span id="textcolor849"><span>&lt;linux/module.h&gt; /* Specifically, a module */</span></span> 
<a id="x1-37040r8"></a><span>8</span><span id="textcolor850"><span>#include</span></span><span> </span><span id="textcolor851"><span>&lt;linux/proc_fs.h&gt; /* Necessary because we use proc fs */</span></span> 
<a id="x1-37042r9"></a><span>9</span><span id="textcolor852"><span>#include</span></span><span> </span><span id="textcolor853"><span>&lt;linux/seq_file.h&gt; /* for seq_file */</span></span> 
<a id="x1-37044r10"></a><span>10</span><span id="textcolor854"><span>#include</span></span><span> </span><span id="textcolor855"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-37046r11"></a><span>11</span> 
<a id="x1-37048r12"></a><span>12</span><span id="textcolor856"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span> 
<a id="x1-37050r13"></a><span>13</span><span id="textcolor857"><span>#define HAVE_PROC_OPS</span></span> 
<a id="x1-37052r14"></a><span>14</span><span id="textcolor858"><span>#endif</span></span> 
<a id="x1-37054r15"></a><span>15</span> 
<a id="x1-37056r16"></a><span>16</span><span id="textcolor859"><span>#define PROC_NAME &#34;iter&#34;</span></span> 
<a id="x1-37058r17"></a><span>17</span> 
<a id="x1-37060r18"></a><span>18</span><span id="textcolor860"><span>/* This function is called at the beginning of a sequence.</span></span> 
<a id="x1-37062r19"></a><span>19</span><span id="textcolor861"><span> * ie, when:</span></span> 
<a id="x1-37064r20"></a><span>20</span><span id="textcolor862"><span> *   - the /proc file is read (first time)</span></span> 
<a id="x1-37066r21"></a><span>21</span><span id="textcolor863"><span> *   - after the function stop (end of sequence)</span></span> 
<a id="x1-37068r22"></a><span>22</span><span id="textcolor864"><span> */</span></span> 
<a id="x1-37070r23"></a><span>23</span><span id="textcolor865"><span>static</span></span><span> </span><span id="textcolor866"><span>void</span></span><span> *my_seq_start(</span><span id="textcolor867"><span>struct</span></span><span> seq_file *s, loff_t *pos)</span> 
<a id="x1-37072r24"></a><span>24</span><span>{</span> 
<a id="x1-37074r25"></a><span>25</span><span>    </span><span id="textcolor868"><span>static</span></span><span> </span><span id="textcolor869"><span>unsigned</span></span><span> </span><span id="textcolor870"><span>long</span></span><span> counter = 0;</span> 
<a id="x1-37076r26"></a><span>26</span> 
<a id="x1-37078r27"></a><span>27</span><span>    </span><span id="textcolor871"><span>/* beginning a new sequence? */</span></span> 
<a id="x1-37080r28"></a><span>28</span><span>    </span><span id="textcolor872"><span>if</span></span><span> (*pos == 0) {</span> 
<a id="x1-37082r29"></a><span>29</span><span>        </span><span id="textcolor873"><span>/* yes =&gt; return a non null value to begin the sequence */</span></span> 
<a id="x1-37084r30"></a><span>30</span><span>        </span><span id="textcolor874"><span>return</span></span><span> &amp;counter;</span> 
<a id="x1-37086r31"></a><span>31</span><span>    }</span> 
<a id="x1-37088r32"></a><span>32</span> 
<a id="x1-37090r33"></a><span>33</span><span>    </span><span id="textcolor875"><span>/* no =&gt; it is the end of the sequence, return end to stop reading */</span></span> 
<a id="x1-37092r34"></a><span>34</span><span>    *pos = 0;</span> 
<a id="x1-37094r35"></a><span>35</span><span>    </span><span id="textcolor876"><span>return</span></span><span> NULL;</span> 
<a id="x1-37096r36"></a><span>36</span><span>}</span> 
<a id="x1-37098r37"></a><span>37</span> 
<a id="x1-37100r38"></a><span>38</span><span id="textcolor877"><span>/* This function is called after the beginning of a sequence.</span></span> 
<a id="x1-37102r39"></a><span>39</span><span id="textcolor878"><span> * It is called untill the return is NULL (this ends the sequence).</span></span> 
<a id="x1-37104r40"></a><span>40</span><span id="textcolor879"><span> */</span></span> 
<a id="x1-37106r41"></a><span>41</span><span id="textcolor880"><span>static</span></span><span> </span><span id="textcolor881"><span>void</span></span><span> *my_seq_next(</span><span id="textcolor882"><span>struct</span></span><span> seq_file *s, </span><span id="textcolor883"><span>void</span></span><span> *v, loff_t *pos)</span> 
<a id="x1-37108r42"></a><span>42</span><span>{</span> 
<a id="x1-37110r43"></a><span>43</span><span>    </span><span id="textcolor884"><span>unsigned</span></span><span> </span><span id="textcolor885"><span>long</span></span><span> *tmp_v = (</span><span id="textcolor886"><span>unsigned</span></span><span> </span><span id="textcolor887"><span>long</span></span><span> *)v;</span> 
<a id="x1-37112r44"></a><span>44</span><span>    (*tmp_v)++;</span> 
<a id="x1-37114r45"></a><span>45</span><span>    (*pos)++;</span> 
<a id="x1-37116r46"></a><span>46</span><span>    </span><span id="textcolor888"><span>return</span></span><span> NULL;</span> 
<a id="x1-37118r47"></a><span>47</span><span>}</span> 
<a id="x1-37120r48"></a><span>48</span> 
<a id="x1-37122r49"></a><span>49</span><span id="textcolor889"><span>/* This function is called at the end of a sequence. */</span></span> 
<a id="x1-37124r50"></a><span>50</span><span id="textcolor890"><span>static</span></span><span> </span><span id="textcolor891"><span>void</span></span><span> my_seq_stop(</span><span id="textcolor892"><span>struct</span></span><span> seq_file *s, </span><span id="textcolor893"><span>void</span></span><span> *v)</span> 
<a id="x1-37126r51"></a><span>51</span><span>{</span> 
<a id="x1-37128r52"></a><span>52</span><span>    </span><span id="textcolor894"><span>/* nothing to do, we use a static value in start() */</span></span> 
<a id="x1-37130r53"></a><span>53</span><span>}</span> 
<a id="x1-37132r54"></a><span>54</span> 
<a id="x1-37134r55"></a><span>55</span><span id="textcolor895"><span>/* This function is called for each &#34;step&#34; of a sequence. */</span></span> 
<a id="x1-37136r56"></a><span>56</span><span id="textcolor896"><span>static</span></span><span> </span><span id="textcolor897"><span>int</span></span><span> my_seq_show(</span><span id="textcolor898"><span>struct</span></span><span> seq_file *s, </span><span id="textcolor899"><span>void</span></span><span> *v)</span> 
<a id="x1-37138r57"></a><span>57</span><span>{</span> 
<a id="x1-37140r58"></a><span>58</span><span>    loff_t *spos = (loff_t *)v;</span> 
<a id="x1-37142r59"></a><span>59</span> 
<a id="x1-37144r60"></a><span>60</span><span>    seq_printf(s, </span><span id="textcolor900"><span>&#34;%Ld</span></span><span id="textcolor901"><span>\n</span></span><span id="textcolor902"><span>&#34;</span></span><span>, *spos);</span> 
<a id="x1-37146r61"></a><span>61</span><span>    </span><span id="textcolor903"><span>return</span></span><span> 0;</span> 
<a id="x1-37148r62"></a><span>62</span><span>}</span> 
<a id="x1-37150r63"></a><span>63</span> 
<a id="x1-37152r64"></a><span>64</span><span id="textcolor904"><span>/* This structure gather &#34;function&#34; to manage the sequence */</span></span> 
<a id="x1-37154r65"></a><span>65</span><span id="textcolor905"><span>static</span></span><span> </span><span id="textcolor906"><span>struct</span></span><span> seq_operations my_seq_ops = {</span> 
<a id="x1-37156r66"></a><span>66</span><span>    .start = my_seq_start,</span> 
<a id="x1-37158r67"></a><span>67</span><span>    .next = my_seq_next,</span> 
<a id="x1-37160r68"></a><span>68</span><span>    .stop = my_seq_stop,</span> 
<a id="x1-37162r69"></a><span>69</span><span>    .show = my_seq_show,</span> 
<a id="x1-37164r70"></a><span>70</span><span>};</span> 
<a id="x1-37166r71"></a><span>71</span> 
<a id="x1-37168r72"></a><span>72</span><span id="textcolor907"><span>/* This function is called when the /proc file is open. */</span></span> 
<a id="x1-37170r73"></a><span>73</span><span id="textcolor908"><span>static</span></span><span> </span><span id="textcolor909"><span>int</span></span><span> my_open(</span><span id="textcolor910"><span>struct</span></span><span> inode *inode, </span><span id="textcolor911"><span>struct</span></span><span> file *file)</span> 
<a id="x1-37172r74"></a><span>74</span><span>{</span> 
<a id="x1-37174r75"></a><span>75</span><span>    </span><span id="textcolor912"><span>return</span></span><span> seq_open(file, &amp;my_seq_ops);</span> 
<a id="x1-37176r76"></a><span>76</span><span>};</span> 
<a id="x1-37178r77"></a><span>77</span> 
<a id="x1-37180r78"></a><span>78</span><span id="textcolor913"><span>/* This structure gather &#34;function&#34; that manage the /proc file */</span></span> 
<a id="x1-37182r79"></a><span>79</span><span id="textcolor914"><span>#ifdef HAVE_PROC_OPS</span></span> 
<a id="x1-37184r80"></a><span>80</span><span id="textcolor915"><span>static</span></span><span> </span><span id="textcolor916"><span>const</span></span><span> </span><span id="textcolor917"><span>struct</span></span><span> proc_ops my_file_ops = {</span> 
<a id="x1-37186r81"></a><span>81</span><span>    .proc_open = my_open,</span> 
<a id="x1-37188r82"></a><span>82</span><span>    .proc_read = seq_read,</span> 
<a id="x1-37190r83"></a><span>83</span><span>    .proc_lseek = seq_lseek,</span> 
<a id="x1-37192r84"></a><span>84</span><span>    .proc_release = seq_release,</span> 
<a id="x1-37194r85"></a><span>85</span><span>};</span> 
<a id="x1-37196r86"></a><span>86</span><span id="textcolor918"><span>#else</span></span> 
<a id="x1-37198r87"></a><span>87</span><span id="textcolor919"><span>static</span></span><span> </span><span id="textcolor920"><span>const</span></span><span> </span><span id="textcolor921"><span>struct</span></span><span> file_operations my_file_ops = {</span> 
<a id="x1-37200r88"></a><span>88</span><span>    .open = my_open,</span> 
<a id="x1-37202r89"></a><span>89</span><span>    .read = seq_read,</span> 
<a id="x1-37204r90"></a><span>90</span><span>    .llseek = seq_lseek,</span> 
<a id="x1-37206r91"></a><span>91</span><span>    .release = seq_release,</span> 
<a id="x1-37208r92"></a><span>92</span><span>};</span> 
<a id="x1-37210r93"></a><span>93</span><span id="textcolor922"><span>#endif</span></span> 
<a id="x1-37212r94"></a><span>94</span> 
<a id="x1-37214r95"></a><span>95</span><span id="textcolor923"><span>static</span></span><span> </span><span id="textcolor924"><span>int</span></span><span> __init procfs4_init(</span><span id="textcolor925"><span>void</span></span><span>)</span> 
<a id="x1-37216r96"></a><span>96</span><span>{</span> 
<a id="x1-37218r97"></a><span>97</span><span>    </span><span id="textcolor926"><span>struct</span></span><span> proc_dir_entry *entry;</span> 
<a id="x1-37220r98"></a><span>98</span> 
<a id="x1-37222r99"></a><span>99</span><span>    entry = proc_create(PROC_NAME, 0, NULL, &amp;my_file_ops);</span> 
<a id="x1-37224r100"></a><span>100</span><span>    </span><span id="textcolor927"><span>if</span></span><span> (entry == NULL) {</span> 
<a id="x1-37226r101"></a><span>101</span><span>        remove_proc_entry(PROC_NAME, NULL);</span> 
<a id="x1-37228r102"></a><span>102</span><span>        pr_debug(</span><span id="textcolor928"><span>&#34;Error: Could not initialize /proc/%s</span></span><span id="textcolor929"><span>\n</span></span><span id="textcolor930"><span>&#34;</span></span><span>, PROC_NAME);</span> 
<a id="x1-37230r103"></a><span>103</span><span>        </span><span id="textcolor931"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-37232r104"></a><span>104</span><span>    }</span> 
<a id="x1-37234r105"></a><span>105</span> 
<a id="x1-37236r106"></a><span>106</span><span>    </span><span id="textcolor932"><span>return</span></span><span> 0;</span> 
<a id="x1-37238r107"></a><span>107</span><span>}</span> 
<a id="x1-37240r108"></a><span>108</span> 
<a id="x1-37242r109"></a><span>109</span><span id="textcolor933"><span>static</span></span><span> </span><span id="textcolor934"><span>void</span></span><span> __exit procfs4_exit(</span><span id="textcolor935"><span>void</span></span><span>)</span> 
<a id="x1-37244r110"></a><span>110</span><span>{</span> 
<a id="x1-37246r111"></a><span>111</span><span>    remove_proc_entry(PROC_NAME, NULL);</span> 
<a id="x1-37248r112"></a><span>112</span><span>    pr_debug(</span><span id="textcolor936"><span>&#34;/proc/%s removed</span></span><span id="textcolor937"><span>\n</span></span><span id="textcolor938"><span>&#34;</span></span><span>, PROC_NAME);</span> 
<a id="x1-37250r113"></a><span>113</span><span>}</span> 
<a id="x1-37252r114"></a><span>114</span> 
<a id="x1-37254r115"></a><span>115</span><span>module_init(procfs4_init);</span> 
<a id="x1-37256r116"></a><span>116</span><span>module_exit(procfs4_exit);</span> 
<a id="x1-37258r117"></a><span>117</span> 
<a id="x1-37260r118"></a><span>118</span><span>MODULE_LICENSE(</span><span id="textcolor939"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1260 --><p>   If you want more information, you can read this web page:
</p>
     <ul>
     <li><a href="https://lwn.net/Articles/22355/"><span>https://lwn.net/Articles/22355/</span></a>
     </li>
     <li><a href="https://kernelnewbies.org/Documents/SeqFileHowTo"><span>https://kernelnewbies.org/Documents/SeqFileHowTo</span></a></li></ul>
<!-- l. 1267 --><p>   You can also read the code of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/seq_file.c">fs/seq_file.c</a> in the linux kernel.
</p>
   <h3 id="sysfs-interacting-with-your-module"><span>8   </span> <a id="x1-380008"></a>sysfs: Interacting with your module</h3>
<!-- l. 1271 --><p><span>sysfs </span>allows you to interact with the running kernel from userspace by reading or
setting variables inside of modules. This can be useful for debugging purposes, or just
as an interface for applications or scripts. You can find sysfs directories and files
under the <span><span><span>/sys</span></span></span> directory on your system.
</p><!-- l. 1 -->
   <pre id="fancyvrb51"><a id="x1-38003r1"></a><span>1</span><span>ls -l /sys</span></pre>
<!-- l. 1279 --><p>   Attributes can be exported for kobjects in the form of regular files in the
filesystem. Sysfs forwards file I/O operations to methods defined for the attributes,
providing a means to read and write kernel attributes.
</p><!-- l. 1282 --><p>   An attribute definition in simply:
</p><!-- l. 1 -->
   <pre id="fancyvrb52"><a id="x1-38013r1"></a><span>1</span><span id="textcolor940"><span>struct</span></span><span> attribute {</span> 
<a id="x1-38015r2"></a><span>2</span><span>    </span><span id="textcolor941"><span>char</span></span><span> *name;</span> 
<a id="x1-38017r3"></a><span>3</span><span>    </span><span id="textcolor942"><span>struct</span></span><span> module *owner;</span> 
<a id="x1-38019r4"></a><span>4</span><span>    umode_t mode;</span> 
<a id="x1-38021r5"></a><span>5</span><span>};</span> 
<a id="x1-38023r6"></a><span>6</span> 
<a id="x1-38025r7"></a><span>7</span><span id="textcolor943"><span>int</span></span><span> sysfs_create_file(</span><span id="textcolor944"><span>struct</span></span><span> kobject * kobj, </span><span id="textcolor945"><span>const</span></span><span> </span><span id="textcolor946"><span>struct</span></span><span> attribute * attr);</span> 
<a id="x1-38027r8"></a><span>8</span><span id="textcolor947"><span>void</span></span><span> sysfs_remove_file(</span><span id="textcolor948"><span>struct</span></span><span> kobject * kobj, </span><span id="textcolor949"><span>const</span></span><span> </span><span id="textcolor950"><span>struct</span></span><span> attribute * attr);</span></pre>
<!-- l. 1295 --><p>   For example, the driver model defines
<code> <span id="textcolor951"><span>struct</span></span><span> device_attribute</span>
</code> like:
</p><!-- l. 1 -->
   <pre id="fancyvrb53"><a id="x1-38040r1"></a><span>1</span><span id="textcolor952"><span>struct</span></span><span> device_attribute {</span> 
<a id="x1-38042r2"></a><span>2</span><span>    </span><span id="textcolor953"><span>struct</span></span><span> attribute attr;</span> 
<a id="x1-38044r3"></a><span>3</span><span>    </span><span id="textcolor954"><span>ssize_t</span></span><span> (*show)(</span><span id="textcolor955"><span>struct</span></span><span> device *dev, </span><span id="textcolor956"><span>struct</span></span><span> device_attribute *attr,</span> 
<a id="x1-38046r4"></a><span>4</span><span>                    </span><span id="textcolor957"><span>char</span></span><span> *buf);</span> 
<a id="x1-38048r5"></a><span>5</span><span>    </span><span id="textcolor958"><span>ssize_t</span></span><span> (*store)(</span><span id="textcolor959"><span>struct</span></span><span> device *dev, </span><span id="textcolor960"><span>struct</span></span><span> device_attribute *attr,</span> 
<a id="x1-38050r6"></a><span>6</span><span>                    </span><span id="textcolor961"><span>const</span></span><span> </span><span id="textcolor962"><span>char</span></span><span> *buf, </span><span id="textcolor963"><span>size_t</span></span><span> count);</span> 
<a id="x1-38052r7"></a><span>7</span><span>};</span> 
<a id="x1-38054r8"></a><span>8</span> 
<a id="x1-38056r9"></a><span>9</span><span id="textcolor964"><span>int</span></span><span> device_create_file(</span><span id="textcolor965"><span>struct</span></span><span> device *, </span><span id="textcolor966"><span>const</span></span><span> </span><span id="textcolor967"><span>struct</span></span><span> device_attribute *);</span> 
<a id="x1-38058r10"></a><span>10</span><span id="textcolor968"><span>void</span></span><span> device_remove_file(</span><span id="textcolor969"><span>struct</span></span><span> device *, </span><span id="textcolor970"><span>const</span></span><span> </span><span id="textcolor971"><span>struct</span></span><span> device_attribute *);</span></pre>
<!-- l. 1310 --><p>   To read or write attributes, <code>  <span>show()</span>
</code> or <code>  <span>store()</span>
</code> method must be specified when declaring the attribute. For the
common cases <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sysfs.h">include/linux/sysfs.h</a> provides convenience macros
(<code>  <span>__ATTR</span>
</code>, <code>  <span>__ATTR_RO</span>
</code>, <code>  <span>__ATTR_WO</span>
</code>, etc.) to make defining attributes easier as well as making code more concise and
readable.
</p><!-- l. 1313 --><p>   An example of a hello world module which includes the creation of a variable
accessible via sysfs is given below.
</p><!-- l. 1 -->
   <pre id="fancyvrb54"><a id="x1-38065r1"></a><span>1</span><span id="textcolor972"><span>/*</span></span> 
<a id="x1-38067r2"></a><span>2</span><span id="textcolor973"><span> * hello-sysfs.c sysfs example</span></span> 
<a id="x1-38069r3"></a><span>3</span><span id="textcolor974"><span> */</span></span> 
<a id="x1-38071r4"></a><span>4</span><span id="textcolor975"><span>#include</span></span><span> </span><span id="textcolor976"><span>&lt;linux/fs.h&gt;</span></span> 
<a id="x1-38073r5"></a><span>5</span><span id="textcolor977"><span>#include</span></span><span> </span><span id="textcolor978"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-38075r6"></a><span>6</span><span id="textcolor979"><span>#include</span></span><span> </span><span id="textcolor980"><span>&lt;linux/kobject.h&gt;</span></span> 
<a id="x1-38077r7"></a><span>7</span><span id="textcolor981"><span>#include</span></span><span> </span><span id="textcolor982"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-38079r8"></a><span>8</span><span id="textcolor983"><span>#include</span></span><span> </span><span id="textcolor984"><span>&lt;linux/string.h&gt;</span></span> 
<a id="x1-38081r9"></a><span>9</span><span id="textcolor985"><span>#include</span></span><span> </span><span id="textcolor986"><span>&lt;linux/sysfs.h&gt;</span></span> 
<a id="x1-38083r10"></a><span>10</span> 
<a id="x1-38085r11"></a><span>11</span><span id="textcolor987"><span>static</span></span><span> </span><span id="textcolor988"><span>struct</span></span><span> kobject *mymodule;</span> 
<a id="x1-38087r12"></a><span>12</span> 
<a id="x1-38089r13"></a><span>13</span><span id="textcolor989"><span>/* the variable you want to be able to change */</span></span> 
<a id="x1-38091r14"></a><span>14</span><span id="textcolor990"><span>static</span></span><span> </span><span id="textcolor991"><span>int</span></span><span> myvariable = 0;</span> 
<a id="x1-38093r15"></a><span>15</span> 
<a id="x1-38095r16"></a><span>16</span><span id="textcolor992"><span>static</span></span><span> </span><span id="textcolor993"><span>ssize_t</span></span><span> myvariable_show(</span><span id="textcolor994"><span>struct</span></span><span> kobject *kobj,</span> 
<a id="x1-38097r17"></a><span>17</span><span>                               </span><span id="textcolor995"><span>struct</span></span><span> kobj_attribute *attr, </span><span id="textcolor996"><span>char</span></span><span> *buf)</span> 
<a id="x1-38099r18"></a><span>18</span><span>{</span> 
<a id="x1-38101r19"></a><span>19</span><span>    </span><span id="textcolor997"><span>return</span></span><span> sprintf(buf, </span><span id="textcolor998"><span>&#34;%d</span></span><span id="textcolor999"><span>\n</span></span><span id="textcolor1000"><span>&#34;</span></span><span>, myvariable);</span> 
<a id="x1-38103r20"></a><span>20</span><span>}</span> 
<a id="x1-38105r21"></a><span>21</span> 
<a id="x1-38107r22"></a><span>22</span><span id="textcolor1001"><span>static</span></span><span> </span><span id="textcolor1002"><span>ssize_t</span></span><span> myvariable_store(</span><span id="textcolor1003"><span>struct</span></span><span> kobject *kobj,</span> 
<a id="x1-38109r23"></a><span>23</span><span>                                </span><span id="textcolor1004"><span>struct</span></span><span> kobj_attribute *attr, </span><span id="textcolor1005"><span>char</span></span><span> *buf,</span> 
<a id="x1-38111r24"></a><span>24</span><span>                                </span><span id="textcolor1006"><span>size_t</span></span><span> count)</span> 
<a id="x1-38113r25"></a><span>25</span><span>{</span> 
<a id="x1-38115r26"></a><span>26</span><span>    sscanf(buf, </span><span id="textcolor1007"><span>&#34;%du&#34;</span></span><span>, &amp;myvariable);</span> 
<a id="x1-38117r27"></a><span>27</span><span>    </span><span id="textcolor1008"><span>return</span></span><span> count;</span> 
<a id="x1-38119r28"></a><span>28</span><span>}</span> 
<a id="x1-38121r29"></a><span>29</span> 
<a id="x1-38123r30"></a><span>30</span><span id="textcolor1009"><span>static</span></span><span> </span><span id="textcolor1010"><span>struct</span></span><span> kobj_attribute myvariable_attribute =</span> 
<a id="x1-38125r31"></a><span>31</span><span>    __ATTR(myvariable, 0660, myvariable_show, (</span><span id="textcolor1011"><span>void</span></span><span> *)myvariable_store);</span> 
<a id="x1-38127r32"></a><span>32</span> 
<a id="x1-38129r33"></a><span>33</span><span id="textcolor1012"><span>static</span></span><span> </span><span id="textcolor1013"><span>int</span></span><span> __init mymodule_init(</span><span id="textcolor1014"><span>void</span></span><span>)</span> 
<a id="x1-38131r34"></a><span>34</span><span>{</span> 
<a id="x1-38133r35"></a><span>35</span><span>    </span><span id="textcolor1015"><span>int</span></span><span> error = 0;</span> 
<a id="x1-38135r36"></a><span>36</span> 
<a id="x1-38137r37"></a><span>37</span><span>    pr_info(</span><span id="textcolor1016"><span>&#34;mymodule: initialised</span></span><span id="textcolor1017"><span>\n</span></span><span id="textcolor1018"><span>&#34;</span></span><span>);</span> 
<a id="x1-38139r38"></a><span>38</span> 
<a id="x1-38141r39"></a><span>39</span><span>    mymodule = kobject_create_and_add(</span><span id="textcolor1019"><span>&#34;mymodule&#34;</span></span><span>, kernel_kobj);</span> 
<a id="x1-38143r40"></a><span>40</span><span>    </span><span id="textcolor1020"><span>if</span></span><span> (!mymodule)</span> 
<a id="x1-38145r41"></a><span>41</span><span>        </span><span id="textcolor1021"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-38147r42"></a><span>42</span> 
<a id="x1-38149r43"></a><span>43</span><span>    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr);</span> 
<a id="x1-38151r44"></a><span>44</span><span>    </span><span id="textcolor1022"><span>if</span></span><span> (error) {</span> 
<a id="x1-38153r45"></a><span>45</span><span>        pr_info(</span><span id="textcolor1023"><span>&#34;failed to create the myvariable file &#34;</span></span> 
<a id="x1-38155r46"></a><span>46</span><span>                </span><span id="textcolor1024"><span>&#34;in /sys/kernel/mymodule</span></span><span id="textcolor1025"><span>\n</span></span><span id="textcolor1026"><span>&#34;</span></span><span>);</span> 
<a id="x1-38157r47"></a><span>47</span><span>    }</span> 
<a id="x1-38159r48"></a><span>48</span> 
<a id="x1-38161r49"></a><span>49</span><span>    </span><span id="textcolor1027"><span>return</span></span><span> error;</span> 
<a id="x1-38163r50"></a><span>50</span><span>}</span> 
<a id="x1-38165r51"></a><span>51</span> 
<a id="x1-38167r52"></a><span>52</span><span id="textcolor1028"><span>static</span></span><span> </span><span id="textcolor1029"><span>void</span></span><span> __exit mymodule_exit(</span><span id="textcolor1030"><span>void</span></span><span>)</span> 
<a id="x1-38169r53"></a><span>53</span><span>{</span> 
<a id="x1-38171r54"></a><span>54</span><span>    pr_info(</span><span id="textcolor1031"><span>&#34;mymodule: Exit success</span></span><span id="textcolor1032"><span>\n</span></span><span id="textcolor1033"><span>&#34;</span></span><span>);</span> 
<a id="x1-38173r55"></a><span>55</span><span>    kobject_put(mymodule);</span> 
<a id="x1-38175r56"></a><span>56</span><span>}</span> 
<a id="x1-38177r57"></a><span>57</span> 
<a id="x1-38179r58"></a><span>58</span><span>module_init(mymodule_init);</span> 
<a id="x1-38181r59"></a><span>59</span><span>module_exit(mymodule_exit);</span> 
<a id="x1-38183r60"></a><span>60</span> 
<a id="x1-38185r61"></a><span>61</span><span>MODULE_LICENSE(</span><span id="textcolor1034"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1317 --><p>   Make and install the module:
</p><!-- l. 1 -->
   <pre id="fancyvrb55"><a id="x1-38189r1"></a><span>1</span><span>make</span> 
<a id="x1-38191r2"></a><span>2</span><span>sudo insmod hello-sysfs.ko</span></pre>
<!-- l. 1324 --><p>   Check that it exists:
</p><!-- l. 1 -->
   <pre id="fancyvrb56"><a id="x1-38194r1"></a><span>1</span><span>sudo lsmod | grep hello_sysfs</span></pre>
<!-- l. 1330 --><p>   What is the current value of <code>  <span>myvariable</span>
</code> ?
</p><!-- l. 1 -->
   <pre id="fancyvrb57"><a id="x1-38198r1"></a><span>1</span><span>cat /sys/kernel/mymodule/myvariable</span></pre>
<!-- l. 1336 --><p>   Set the value of <code>  <span>myvariable</span>
</code> and check that it changed.
</p><!-- l. 1 -->
   <pre id="fancyvrb58"><a id="x1-38203r1"></a><span>1</span><span>echo </span><span id="textcolor1035"><span>&#34;32&#34;</span></span><span> &gt; /sys/kernel/mymodule/myvariable</span> 
<a id="x1-38205r2"></a><span>2</span><span>cat /sys/kernel/mymodule/myvariable</span></pre>
<!-- l. 1343 --><p>   Finally, remove the test module:
</p><!-- l. 1 -->
   <pre id="fancyvrb59"><a id="x1-38208r1"></a><span>1</span><span>sudo rmmod hello_sysfs</span></pre>
                                                                  

                                                                  
<!-- l. 1349 --><p>   In the above case, we use a simple kobject to create a directory under
sysfs, and communicate with its attributes. Since Linux v2.6.0, the
<code> <span>kobject</span>
</code> structure made its appearance. It was initially meant as a simple way of
unifying kernel code which manages reference counted objects. After a
bit of mission creep, it is now the glue that holds much of the device
model and its sysfs interface together. For more information about kobject
and sysfs, see <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/driver-api/driver-model/driver.rst">Documentation/driver-api/driver-model/driver.rst</a> and
<a href="https://lwn.net/Articles/51437/"><span>https://lwn.net/Articles/51437/</span></a>.
</p><!-- l. 1355 -->
   <h3 id="talking-to-device-files"><span>9   </span> <a id="x1-390009"></a>Talking To Device Files</h3>
<!-- l. 1357 --><p>Device files are supposed to represent physical devices. Most physical devices are
used for output as well as input, so there has to be some mechanism for
device drivers in the kernel to get the output to send to the device from
processes. This is done by opening the device file for output and writing to it,
just like writing to a file. In the following example, this is implemented by
<code> <span>device_write</span>
</code>.
</p><!-- l. 1362 --><p>   This is not always enough. Imagine you had a serial port connected to a modem
(even if you have an internal modem, it is still implemented from the CPU’s
perspective as a serial port connected to a modem, so you don’t have to tax
your imagination too hard). The natural thing to do would be to use the
device file to write things to the modem (either modem commands or data to
be sent through the phone line) and read things from the modem (either
responses for commands or the data received through the phone line). However,
this leaves open the question of what to do when you need to talk to the
serial port itself, for example to configure the rate at which data is sent and
received.
</p><!-- l. 1367 --><p>   The answer in Unix is to use a special function called
<code> <span>ioctl</span>
</code> (short for Input Output ConTroL). Every device can have its own
<code> <span>ioctl</span>
</code> commands, which can be read ioctl’s (to send information from a process to the
kernel), write ioctl’s (to return information to a process), both or neither. Notice
here the roles of read and write are reversed again, so in ioctl’s read is to
send information to the kernel and write is to receive information from the
kernel.
</p><!-- l. 1371 --><p>   The ioctl function is called with three parameters: the file descriptor of the
appropriate device file, the ioctl number, and a parameter, which is of type long so
you can use a cast to use it to pass anything. You will not be able to pass a structure
this way, but you will be able to pass a pointer to the structure. Here is an
example:
                                                                  

                                                                  
</p><!-- l. 1 -->
   <pre id="fancyvrb60"><a id="x1-39005r1"></a><span>1</span><span id="textcolor1036"><span>/*</span></span> 
<a id="x1-39007r2"></a><span>2</span><span id="textcolor1037"><span> * ioctl.c</span></span> 
<a id="x1-39009r3"></a><span>3</span><span id="textcolor1038"><span> */</span></span> 
<a id="x1-39011r4"></a><span>4</span><span id="textcolor1039"><span>#include</span></span><span> </span><span id="textcolor1040"><span>&lt;linux/cdev.h&gt;</span></span> 
<a id="x1-39013r5"></a><span>5</span><span id="textcolor1041"><span>#include</span></span><span> </span><span id="textcolor1042"><span>&lt;linux/fs.h&gt;</span></span> 
<a id="x1-39015r6"></a><span>6</span><span id="textcolor1043"><span>#include</span></span><span> </span><span id="textcolor1044"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-39017r7"></a><span>7</span><span id="textcolor1045"><span>#include</span></span><span> </span><span id="textcolor1046"><span>&lt;linux/ioctl.h&gt;</span></span> 
<a id="x1-39019r8"></a><span>8</span><span id="textcolor1047"><span>#include</span></span><span> </span><span id="textcolor1048"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-39021r9"></a><span>9</span><span id="textcolor1049"><span>#include</span></span><span> </span><span id="textcolor1050"><span>&lt;linux/slab.h&gt;</span></span> 
<a id="x1-39023r10"></a><span>10</span><span id="textcolor1051"><span>#include</span></span><span> </span><span id="textcolor1052"><span>&lt;linux/uaccess.h&gt;</span></span> 
<a id="x1-39025r11"></a><span>11</span> 
<a id="x1-39027r12"></a><span>12</span><span id="textcolor1053"><span>struct</span></span><span> ioctl_arg {</span> 
<a id="x1-39029r13"></a><span>13</span><span>    </span><span id="textcolor1054"><span>unsigned</span></span><span> </span><span id="textcolor1055"><span>int</span></span><span> val;</span> 
<a id="x1-39031r14"></a><span>14</span><span>};</span> 
<a id="x1-39033r15"></a><span>15</span> 
<a id="x1-39035r16"></a><span>16</span><span id="textcolor1056"><span>/* Documentation/ioctl/ioctl-number.txt */</span></span> 
<a id="x1-39037r17"></a><span>17</span><span id="textcolor1057"><span>#define IOC_MAGIC </span><span>&#39;</span><span>\x66</span><span>&#39;</span></span> 
<a id="x1-39039r18"></a><span>18</span> 
<a id="x1-39041r19"></a><span>19</span><span id="textcolor1058"><span>#define IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg)</span></span> 
<a id="x1-39043r20"></a><span>20</span><span id="textcolor1059"><span>#define IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg)</span></span> 
<a id="x1-39045r21"></a><span>21</span><span id="textcolor1060"><span>#define IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int)</span></span> 
<a id="x1-39047r22"></a><span>22</span><span id="textcolor1061"><span>#define IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int)</span></span> 
<a id="x1-39049r23"></a><span>23</span> 
<a id="x1-39051r24"></a><span>24</span><span id="textcolor1062"><span>#define IOCTL_VAL_MAXNR 3</span></span> 
<a id="x1-39053r25"></a><span>25</span><span id="textcolor1063"><span>#define DRIVER_NAME &#34;ioctltest&#34;</span></span> 
<a id="x1-39055r26"></a><span>26</span> 
<a id="x1-39057r27"></a><span>27</span><span id="textcolor1064"><span>static</span></span><span> </span><span id="textcolor1065"><span>unsigned</span></span><span> </span><span id="textcolor1066"><span>int</span></span><span> test_ioctl_major = 0;</span> 
<a id="x1-39059r28"></a><span>28</span><span id="textcolor1067"><span>static</span></span><span> </span><span id="textcolor1068"><span>unsigned</span></span><span> </span><span id="textcolor1069"><span>int</span></span><span> num_of_dev = 1;</span> 
<a id="x1-39061r29"></a><span>29</span><span id="textcolor1070"><span>static</span></span><span> </span><span id="textcolor1071"><span>struct</span></span><span> cdev test_ioctl_cdev;</span> 
<a id="x1-39063r30"></a><span>30</span><span id="textcolor1072"><span>static</span></span><span> </span><span id="textcolor1073"><span>int</span></span><span> ioctl_num = 0;</span> 
<a id="x1-39065r31"></a><span>31</span> 
<a id="x1-39067r32"></a><span>32</span><span id="textcolor1074"><span>struct</span></span><span> test_ioctl_data {</span> 
<a id="x1-39069r33"></a><span>33</span><span>    </span><span id="textcolor1075"><span>unsigned</span></span><span> </span><span id="textcolor1076"><span>char</span></span><span> val;</span> 
<a id="x1-39071r34"></a><span>34</span><span>    rwlock_t lock;</span> 
<a id="x1-39073r35"></a><span>35</span><span>};</span> 
<a id="x1-39075r36"></a><span>36</span> 
<a id="x1-39077r37"></a><span>37</span><span id="textcolor1077"><span>static</span></span><span> </span><span id="textcolor1078"><span>long</span></span><span> test_ioctl_ioctl(</span><span id="textcolor1079"><span>struct</span></span><span> file *filp, </span><span id="textcolor1080"><span>unsigned</span></span><span> </span><span id="textcolor1081"><span>int</span></span><span> cmd,</span> 
<a id="x1-39079r38"></a><span>38</span><span>                             </span><span id="textcolor1082"><span>unsigned</span></span><span> </span><span id="textcolor1083"><span>long</span></span><span> arg)</span> 
<a id="x1-39081r39"></a><span>39</span><span>{</span> 
<a id="x1-39083r40"></a><span>40</span><span>    </span><span id="textcolor1084"><span>struct</span></span><span> test_ioctl_data *ioctl_data = filp-&gt;private_data;</span> 
<a id="x1-39085r41"></a><span>41</span><span>    </span><span id="textcolor1085"><span>int</span></span><span> retval = 0;</span> 
<a id="x1-39087r42"></a><span>42</span><span>    </span><span id="textcolor1086"><span>unsigned</span></span><span> </span><span id="textcolor1087"><span>char</span></span><span> val;</span> 
<a id="x1-39089r43"></a><span>43</span><span>    </span><span id="textcolor1088"><span>struct</span></span><span> ioctl_arg data;</span> 
<a id="x1-39091r44"></a><span>44</span><span>    memset(&amp;data, 0, </span><span id="textcolor1089"><span>sizeof</span></span><span>(data));</span> 
<a id="x1-39093r45"></a><span>45</span> 
<a id="x1-39095r46"></a><span>46</span><span>    </span><span id="textcolor1090"><span>switch</span></span><span> (cmd) {</span> 
<a id="x1-39097r47"></a><span>47</span><span>    </span><span id="textcolor1091"><span>case</span></span><span> IOCTL_VALSET:</span> 
<a id="x1-39099r48"></a><span>48</span><span>        </span><span id="textcolor1092"><span>if</span></span><span> (copy_from_user(&amp;data, (</span><span id="textcolor1093"><span>int</span></span><span> __user *)arg, </span><span id="textcolor1094"><span>sizeof</span></span><span>(data))) {</span> 
<a id="x1-39101r49"></a><span>49</span><span>            retval = -EFAULT;</span> 
<a id="x1-39103r50"></a><span>50</span><span>            </span><span id="textcolor1095"><span>goto</span></span><span> done;</span> 
<a id="x1-39105r51"></a><span>51</span><span>        }</span> 
<a id="x1-39107r52"></a><span>52</span> 
<a id="x1-39109r53"></a><span>53</span><span>        pr_alert(</span><span id="textcolor1096"><span>&#34;IOCTL set val:%x .</span></span><span id="textcolor1097"><span>\n</span></span><span id="textcolor1098"><span>&#34;</span></span><span>, data.val);</span> 
<a id="x1-39111r54"></a><span>54</span><span>        write_lock(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39113r55"></a><span>55</span><span>        ioctl_data-&gt;val = data.val;</span> 
<a id="x1-39115r56"></a><span>56</span><span>        write_unlock(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39117r57"></a><span>57</span><span>        </span><span id="textcolor1099"><span>break</span></span><span>;</span> 
<a id="x1-39119r58"></a><span>58</span> 
<a id="x1-39121r59"></a><span>59</span><span>    </span><span id="textcolor1100"><span>case</span></span><span> IOCTL_VALGET:</span> 
<a id="x1-39123r60"></a><span>60</span><span>        read_lock(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39125r61"></a><span>61</span><span>        val = ioctl_data-&gt;val;</span> 
<a id="x1-39127r62"></a><span>62</span><span>        read_unlock(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39129r63"></a><span>63</span><span>        data.val = val;</span> 
<a id="x1-39131r64"></a><span>64</span> 
<a id="x1-39133r65"></a><span>65</span><span>        </span><span id="textcolor1101"><span>if</span></span><span> (copy_to_user((</span><span id="textcolor1102"><span>int</span></span><span> __user *)arg, &amp;data, </span><span id="textcolor1103"><span>sizeof</span></span><span>(data))) {</span> 
<a id="x1-39135r66"></a><span>66</span><span>            retval = -EFAULT;</span> 
<a id="x1-39137r67"></a><span>67</span><span>            </span><span id="textcolor1104"><span>goto</span></span><span> done;</span> 
<a id="x1-39139r68"></a><span>68</span><span>        }</span> 
<a id="x1-39141r69"></a><span>69</span> 
<a id="x1-39143r70"></a><span>70</span><span>        </span><span id="textcolor1105"><span>break</span></span><span>;</span> 
<a id="x1-39145r71"></a><span>71</span> 
<a id="x1-39147r72"></a><span>72</span><span>    </span><span id="textcolor1106"><span>case</span></span><span> IOCTL_VALGET_NUM:</span> 
<a id="x1-39149r73"></a><span>73</span><span>        retval = __put_user(ioctl_num, (</span><span id="textcolor1107"><span>int</span></span><span> __user *)arg);</span> 
<a id="x1-39151r74"></a><span>74</span><span>        </span><span id="textcolor1108"><span>break</span></span><span>;</span> 
<a id="x1-39153r75"></a><span>75</span> 
<a id="x1-39155r76"></a><span>76</span><span>    </span><span id="textcolor1109"><span>case</span></span><span> IOCTL_VALSET_NUM:</span> 
<a id="x1-39157r77"></a><span>77</span><span>        ioctl_num = arg;</span> 
<a id="x1-39159r78"></a><span>78</span><span>        </span><span id="textcolor1110"><span>break</span></span><span>;</span> 
<a id="x1-39161r79"></a><span>79</span> 
<a id="x1-39163r80"></a><span>80</span><span>    </span><span id="textcolor1111"><span>default</span></span><span>:</span> 
<a id="x1-39165r81"></a><span>81</span><span>        retval = -ENOTTY;</span> 
<a id="x1-39167r82"></a><span>82</span><span>    }</span> 
<a id="x1-39169r83"></a><span>83</span> 
<a id="x1-39171r84"></a><span>84</span><span>done:</span> 
<a id="x1-39173r85"></a><span>85</span><span>    </span><span id="textcolor1112"><span>return</span></span><span> retval;</span> 
<a id="x1-39175r86"></a><span>86</span><span>}</span> 
<a id="x1-39177r87"></a><span>87</span> 
<a id="x1-39179r88"></a><span>88</span><span id="textcolor1113"><span>static</span></span><span> </span><span id="textcolor1114"><span>ssize_t</span></span><span> test_ioctl_read(</span><span id="textcolor1115"><span>struct</span></span><span> file *filp, </span><span id="textcolor1116"><span>char</span></span><span> __user *buf,</span> 
<a id="x1-39181r89"></a><span>89</span><span>                               </span><span id="textcolor1117"><span>size_t</span></span><span> count, loff_t *f_pos)</span> 
<a id="x1-39183r90"></a><span>90</span><span>{</span> 
<a id="x1-39185r91"></a><span>91</span><span>    </span><span id="textcolor1118"><span>struct</span></span><span> test_ioctl_data *ioctl_data = filp-&gt;private_data;</span> 
<a id="x1-39187r92"></a><span>92</span><span>    </span><span id="textcolor1119"><span>unsigned</span></span><span> </span><span id="textcolor1120"><span>char</span></span><span> val;</span> 
<a id="x1-39189r93"></a><span>93</span><span>    </span><span id="textcolor1121"><span>int</span></span><span> retval;</span> 
<a id="x1-39191r94"></a><span>94</span><span>    </span><span id="textcolor1122"><span>int</span></span><span> i = 0;</span> 
<a id="x1-39193r95"></a><span>95</span> 
<a id="x1-39195r96"></a><span>96</span><span>    read_lock(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39197r97"></a><span>97</span><span>    val = ioctl_data-&gt;val;</span> 
<a id="x1-39199r98"></a><span>98</span><span>    read_unlock(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39201r99"></a><span>99</span> 
<a id="x1-39203r100"></a><span>100</span><span>    </span><span id="textcolor1123"><span>for</span></span><span> (; i &lt; count; i++) {</span> 
<a id="x1-39205r101"></a><span>101</span><span>        </span><span id="textcolor1124"><span>if</span></span><span> (copy_to_user(&amp;buf[i], &amp;val, 1)) {</span> 
<a id="x1-39207r102"></a><span>102</span><span>            retval = -EFAULT;</span> 
<a id="x1-39209r103"></a><span>103</span><span>            </span><span id="textcolor1125"><span>goto</span></span><span> out;</span> 
<a id="x1-39211r104"></a><span>104</span><span>        }</span> 
<a id="x1-39213r105"></a><span>105</span><span>    }</span> 
<a id="x1-39215r106"></a><span>106</span> 
<a id="x1-39217r107"></a><span>107</span><span>    retval = count;</span> 
<a id="x1-39219r108"></a><span>108</span><span>out:</span> 
<a id="x1-39221r109"></a><span>109</span><span>    </span><span id="textcolor1126"><span>return</span></span><span> retval;</span> 
<a id="x1-39223r110"></a><span>110</span><span>}</span> 
<a id="x1-39225r111"></a><span>111</span> 
<a id="x1-39227r112"></a><span>112</span><span id="textcolor1127"><span>static</span></span><span> </span><span id="textcolor1128"><span>int</span></span><span> test_ioctl_close(</span><span id="textcolor1129"><span>struct</span></span><span> inode *inode, </span><span id="textcolor1130"><span>struct</span></span><span> file *filp)</span> 
<a id="x1-39229r113"></a><span>113</span><span>{</span> 
<a id="x1-39231r114"></a><span>114</span><span>    pr_alert(</span><span id="textcolor1131"><span>&#34;%s call.</span></span><span id="textcolor1132"><span>\n</span></span><span id="textcolor1133"><span>&#34;</span></span><span>, __func__);</span> 
<a id="x1-39233r115"></a><span>115</span> 
<a id="x1-39235r116"></a><span>116</span><span>    </span><span id="textcolor1134"><span>if</span></span><span> (filp-&gt;private_data) {</span> 
<a id="x1-39237r117"></a><span>117</span><span>        kfree(filp-&gt;private_data);</span> 
<a id="x1-39239r118"></a><span>118</span><span>        filp-&gt;private_data = NULL;</span> 
<a id="x1-39241r119"></a><span>119</span><span>    }</span> 
<a id="x1-39243r120"></a><span>120</span> 
<a id="x1-39245r121"></a><span>121</span><span>    </span><span id="textcolor1135"><span>return</span></span><span> 0;</span> 
<a id="x1-39247r122"></a><span>122</span><span>}</span> 
<a id="x1-39249r123"></a><span>123</span> 
<a id="x1-39251r124"></a><span>124</span><span id="textcolor1136"><span>static</span></span><span> </span><span id="textcolor1137"><span>int</span></span><span> test_ioctl_open(</span><span id="textcolor1138"><span>struct</span></span><span> inode *inode, </span><span id="textcolor1139"><span>struct</span></span><span> file *filp)</span> 
<a id="x1-39253r125"></a><span>125</span><span>{</span> 
<a id="x1-39255r126"></a><span>126</span><span>    </span><span id="textcolor1140"><span>struct</span></span><span> test_ioctl_data *ioctl_data;</span> 
<a id="x1-39257r127"></a><span>127</span> 
<a id="x1-39259r128"></a><span>128</span><span>    pr_alert(</span><span id="textcolor1141"><span>&#34;%s call.</span></span><span id="textcolor1142"><span>\n</span></span><span id="textcolor1143"><span>&#34;</span></span><span>, __func__);</span> 
<a id="x1-39261r129"></a><span>129</span><span>    ioctl_data = kmalloc(</span><span id="textcolor1144"><span>sizeof</span></span><span>(</span><span id="textcolor1145"><span>struct</span></span><span> test_ioctl_data), GFP_KERNEL);</span> 
<a id="x1-39263r130"></a><span>130</span> 
<a id="x1-39265r131"></a><span>131</span><span>    </span><span id="textcolor1146"><span>if</span></span><span> (ioctl_data == NULL)</span> 
<a id="x1-39267r132"></a><span>132</span><span>        </span><span id="textcolor1147"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-39269r133"></a><span>133</span> 
<a id="x1-39271r134"></a><span>134</span><span>    rwlock_init(&amp;ioctl_data-&gt;lock);</span> 
<a id="x1-39273r135"></a><span>135</span><span>    ioctl_data-&gt;val = 0xFF;</span> 
<a id="x1-39275r136"></a><span>136</span><span>    filp-&gt;private_data = ioctl_data;</span> 
<a id="x1-39277r137"></a><span>137</span> 
<a id="x1-39279r138"></a><span>138</span><span>    </span><span id="textcolor1148"><span>return</span></span><span> 0;</span> 
<a id="x1-39281r139"></a><span>139</span><span>}</span> 
<a id="x1-39283r140"></a><span>140</span> 
<a id="x1-39285r141"></a><span>141</span><span id="textcolor1149"><span>static</span></span><span> </span><span id="textcolor1150"><span>struct</span></span><span> file_operations fops = {</span> 
<a id="x1-39287r142"></a><span>142</span><span>    .owner = THIS_MODULE,</span> 
<a id="x1-39289r143"></a><span>143</span><span>    .open = test_ioctl_open,</span> 
<a id="x1-39291r144"></a><span>144</span><span>    .release = test_ioctl_close,</span> 
<a id="x1-39293r145"></a><span>145</span><span>    .read = test_ioctl_read,</span> 
<a id="x1-39295r146"></a><span>146</span><span>    .unlocked_ioctl = test_ioctl_ioctl,</span> 
<a id="x1-39297r147"></a><span>147</span><span>};</span> 
<a id="x1-39299r148"></a><span>148</span> 
<a id="x1-39301r149"></a><span>149</span><span id="textcolor1151"><span>static</span></span><span> </span><span id="textcolor1152"><span>int</span></span><span> ioctl_init(</span><span id="textcolor1153"><span>void</span></span><span>)</span> 
<a id="x1-39303r150"></a><span>150</span><span>{</span> 
<a id="x1-39305r151"></a><span>151</span><span>    </span><span id="textcolor1154"><span>dev_t</span></span><span> dev;</span> 
<a id="x1-39307r152"></a><span>152</span><span>    </span><span id="textcolor1155"><span>int</span></span><span> alloc_ret = -1;</span> 
<a id="x1-39309r153"></a><span>153</span><span>    </span><span id="textcolor1156"><span>int</span></span><span> cdev_ret = -1;</span> 
<a id="x1-39311r154"></a><span>154</span><span>    alloc_ret = alloc_chrdev_region(&amp;dev, 0, num_of_dev, DRIVER_NAME);</span> 
<a id="x1-39313r155"></a><span>155</span> 
<a id="x1-39315r156"></a><span>156</span><span>    </span><span id="textcolor1157"><span>if</span></span><span> (alloc_ret)</span> 
<a id="x1-39317r157"></a><span>157</span><span>        </span><span id="textcolor1158"><span>goto</span></span><span> error;</span> 
<a id="x1-39319r158"></a><span>158</span> 
<a id="x1-39321r159"></a><span>159</span><span>    test_ioctl_major = MAJOR(dev);</span> 
<a id="x1-39323r160"></a><span>160</span><span>    cdev_init(&amp;test_ioctl_cdev, &amp;fops);</span> 
<a id="x1-39325r161"></a><span>161</span><span>    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev);</span> 
<a id="x1-39327r162"></a><span>162</span> 
<a id="x1-39329r163"></a><span>163</span><span>    </span><span id="textcolor1159"><span>if</span></span><span> (cdev_ret)</span> 
<a id="x1-39331r164"></a><span>164</span><span>        </span><span id="textcolor1160"><span>goto</span></span><span> error;</span> 
<a id="x1-39333r165"></a><span>165</span> 
<a id="x1-39335r166"></a><span>166</span><span>    pr_alert(</span><span id="textcolor1161"><span>&#34;%s driver(major: %d) installed.</span></span><span id="textcolor1162"><span>\n</span></span><span id="textcolor1163"><span>&#34;</span></span><span>, DRIVER_NAME,</span> 
<a id="x1-39337r167"></a><span>167</span><span>             test_ioctl_major);</span> 
<a id="x1-39339r168"></a><span>168</span><span>    </span><span id="textcolor1164"><span>return</span></span><span> 0;</span> 
<a id="x1-39341r169"></a><span>169</span><span>error:</span> 
<a id="x1-39343r170"></a><span>170</span><span>    </span><span id="textcolor1165"><span>if</span></span><span> (cdev_ret == 0)</span> 
<a id="x1-39345r171"></a><span>171</span><span>        cdev_del(&amp;test_ioctl_cdev);</span> 
<a id="x1-39347r172"></a><span>172</span><span>    </span><span id="textcolor1166"><span>if</span></span><span> (alloc_ret == 0)</span> 
<a id="x1-39349r173"></a><span>173</span><span>        unregister_chrdev_region(dev, num_of_dev);</span> 
<a id="x1-39351r174"></a><span>174</span><span>    </span><span id="textcolor1167"><span>return</span></span><span> -1;</span> 
<a id="x1-39353r175"></a><span>175</span><span>}</span> 
<a id="x1-39355r176"></a><span>176</span> 
<a id="x1-39357r177"></a><span>177</span><span id="textcolor1168"><span>static</span></span><span> </span><span id="textcolor1169"><span>void</span></span><span> ioctl_exit(</span><span id="textcolor1170"><span>void</span></span><span>)</span> 
<a id="x1-39359r178"></a><span>178</span><span>{</span> 
<a id="x1-39361r179"></a><span>179</span><span>    </span><span id="textcolor1171"><span>dev_t</span></span><span> dev = MKDEV(test_ioctl_major, 0);</span> 
<a id="x1-39363r180"></a><span>180</span> 
<a id="x1-39365r181"></a><span>181</span><span>    cdev_del(&amp;test_ioctl_cdev);</span> 
<a id="x1-39367r182"></a><span>182</span><span>    unregister_chrdev_region(dev, num_of_dev);</span> 
<a id="x1-39369r183"></a><span>183</span><span>    pr_alert(</span><span id="textcolor1172"><span>&#34;%s driver removed.</span></span><span id="textcolor1173"><span>\n</span></span><span id="textcolor1174"><span>&#34;</span></span><span>, DRIVER_NAME);</span> 
<a id="x1-39371r184"></a><span>184</span><span>}</span> 
<a id="x1-39373r185"></a><span>185</span> 
<a id="x1-39375r186"></a><span>186</span><span>module_init(ioctl_init);</span> 
<a id="x1-39377r187"></a><span>187</span><span>module_exit(ioctl_exit);</span> 
<a id="x1-39379r188"></a><span>188</span> 
<a id="x1-39381r189"></a><span>189</span><span>MODULE_LICENSE(</span><span id="textcolor1175"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-39383r190"></a><span>190</span><span>MODULE_DESCRIPTION(</span><span id="textcolor1176"><span>&#34;This is test_ioctl module&#34;</span></span><span>);</span></pre>
<!-- l. 1377 --><p>   You can see there is an argument called
<code> <span>cmd</span>
</code> in <code>  <span>test_ioctl_ioctl()</span>
</code> function. It is the ioctl number. The ioctl number encodes the major
device number, the type of the ioctl, the command, and the type of
the parameter. This ioctl number is usually created by a macro call
(<code>  <span>_IO</span>
</code>, <code>  <span>_IOR</span>
</code>, <code>  <span>_IOW</span>
</code> or <code>  <span>_IOWR</span>
</code> — depending on the type) in a header file. This header file should then be
included both by the programs which will use ioctl (so they can generate the
appropriate ioctl’s) and by the kernel module (so it can understand it). In the
example below, the header file is <span><span><span>chardev.h</span></span></span> and the program which uses it is
<span><span><span>userspace_ioctl.c</span></span></span>.
</p><!-- l. 1384 --><p>   If you want to use ioctls in your own kernel modules, it is best to receive an
official ioctl assignment, so if you accidentally get somebody else’s ioctls, or if they
get yours, you’ll know something is wrong. For more information, consult the kernel
source tree at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst">Documentation/userspace-api/ioctl/ioctl-number.rst</a>.
</p><!-- l. 1387 --><p>   Also, we need to be careful that concurrent access to the shared resources will
lead to the race condition. The solution is using atomic Compare-And-Swap (CAS),
which we mentioned at <a href="#chardevc">6.5<!-- tex4ht:ref: sec:chardev_c  --></a> section, to enforce the exclusive access.
</p><!-- l. 1 -->
   <pre id="fancyvrb61"><a id="x1-39391r1"></a><span>1</span><span id="textcolor1177"><span>/*</span></span> 
<a id="x1-39393r2"></a><span>2</span><span id="textcolor1178"><span> * chardev2.c - Create an input/output character device</span></span> 
<a id="x1-39395r3"></a><span>3</span><span id="textcolor1179"><span> */</span></span> 
<a id="x1-39397r4"></a><span>4</span> 
<a id="x1-39399r5"></a><span>5</span><span id="textcolor1180"><span>#include</span></span><span> </span><span id="textcolor1181"><span>&lt;linux/atomic.h&gt;</span></span> 
<a id="x1-39401r6"></a><span>6</span><span id="textcolor1182"><span>#include</span></span><span> </span><span id="textcolor1183"><span>&lt;linux/cdev.h&gt;</span></span> 
<a id="x1-39403r7"></a><span>7</span><span id="textcolor1184"><span>#include</span></span><span> </span><span id="textcolor1185"><span>&lt;linux/delay.h&gt;</span></span> 
<a id="x1-39405r8"></a><span>8</span><span id="textcolor1186"><span>#include</span></span><span> </span><span id="textcolor1187"><span>&lt;linux/device.h&gt;</span></span> 
<a id="x1-39407r9"></a><span>9</span><span id="textcolor1188"><span>#include</span></span><span> </span><span id="textcolor1189"><span>&lt;linux/fs.h&gt;</span></span> 
<a id="x1-39409r10"></a><span>10</span><span id="textcolor1190"><span>#include</span></span><span> </span><span id="textcolor1191"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-39411r11"></a><span>11</span><span id="textcolor1192"><span>#include</span></span><span> </span><span id="textcolor1193"><span>&lt;linux/module.h&gt; /* Specifically, a module */</span></span> 
<a id="x1-39413r12"></a><span>12</span><span id="textcolor1194"><span>#include</span></span><span> </span><span id="textcolor1195"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-39415r13"></a><span>13</span><span id="textcolor1196"><span>#include</span></span><span> </span><span id="textcolor1197"><span>&lt;linux/types.h&gt;</span></span> 
<a id="x1-39417r14"></a><span>14</span><span id="textcolor1198"><span>#include</span></span><span> </span><span id="textcolor1199"><span>&lt;linux/uaccess.h&gt; /* for get_user and put_user */</span></span> 
<a id="x1-39419r15"></a><span>15</span> 
<a id="x1-39421r16"></a><span>16</span><span id="textcolor1200"><span>#include</span></span><span> </span><span id="textcolor1201"><span>&lt;asm/errno.h&gt;</span></span> 
<a id="x1-39423r17"></a><span>17</span> 
<a id="x1-39425r18"></a><span>18</span><span id="textcolor1202"><span>#include</span></span><span> </span><span id="textcolor1203"><span>&#34;chardev.h&#34;</span></span> 
<a id="x1-39427r19"></a><span>19</span><span id="textcolor1204"><span>#define SUCCESS 0</span></span> 
<a id="x1-39429r20"></a><span>20</span><span id="textcolor1205"><span>#define DEVICE_NAME &#34;char_dev&#34;</span></span> 
<a id="x1-39431r21"></a><span>21</span><span id="textcolor1206"><span>#define BUF_LEN 80</span></span> 
<a id="x1-39433r22"></a><span>22</span> 
<a id="x1-39435r23"></a><span>23</span><span id="textcolor1207"><span>enum</span></span><span> {</span> 
<a id="x1-39437r24"></a><span>24</span><span>    CDEV_NOT_USED = 0,</span> 
<a id="x1-39439r25"></a><span>25</span><span>    CDEV_EXCLUSIVE_OPEN = 1,</span> 
<a id="x1-39441r26"></a><span>26</span><span>};</span> 
<a id="x1-39443r27"></a><span>27</span> 
<a id="x1-39445r28"></a><span>28</span><span id="textcolor1208"><span>/* Is the device open right now? Used to prevent concurrent access into</span></span> 
<a id="x1-39447r29"></a><span>29</span><span id="textcolor1209"><span> * the same device</span></span> 
<a id="x1-39449r30"></a><span>30</span><span id="textcolor1210"><span> */</span></span> 
<a id="x1-39451r31"></a><span>31</span><span id="textcolor1211"><span>static</span></span><span> atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);</span> 
<a id="x1-39453r32"></a><span>32</span> 
<a id="x1-39455r33"></a><span>33</span><span id="textcolor1212"><span>/* The message the device will give when asked */</span></span> 
<a id="x1-39457r34"></a><span>34</span><span id="textcolor1213"><span>static</span></span><span> </span><span id="textcolor1214"><span>char</span></span><span> message[BUF_LEN + 1];</span> 
<a id="x1-39459r35"></a><span>35</span> 
<a id="x1-39461r36"></a><span>36</span><span id="textcolor1215"><span>static</span></span><span> </span><span id="textcolor1216"><span>struct</span></span><span> class *cls;</span> 
<a id="x1-39463r37"></a><span>37</span> 
<a id="x1-39465r38"></a><span>38</span><span id="textcolor1217"><span>/* This is called whenever a process attempts to open the device file */</span></span> 
<a id="x1-39467r39"></a><span>39</span><span id="textcolor1218"><span>static</span></span><span> </span><span id="textcolor1219"><span>int</span></span><span> device_open(</span><span id="textcolor1220"><span>struct</span></span><span> inode *inode, </span><span id="textcolor1221"><span>struct</span></span><span> file *file)</span> 
<a id="x1-39469r40"></a><span>40</span><span>{</span> 
<a id="x1-39471r41"></a><span>41</span><span>    pr_info(</span><span id="textcolor1222"><span>&#34;device_open(%p)</span></span><span id="textcolor1223"><span>\n</span></span><span id="textcolor1224"><span>&#34;</span></span><span>, file);</span> 
<a id="x1-39473r42"></a><span>42</span> 
<a id="x1-39475r43"></a><span>43</span><span>    try_module_get(THIS_MODULE);</span> 
<a id="x1-39477r44"></a><span>44</span><span>    </span><span id="textcolor1225"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-39479r45"></a><span>45</span><span>}</span> 
<a id="x1-39481r46"></a><span>46</span> 
<a id="x1-39483r47"></a><span>47</span><span id="textcolor1226"><span>static</span></span><span> </span><span id="textcolor1227"><span>int</span></span><span> device_release(</span><span id="textcolor1228"><span>struct</span></span><span> inode *inode, </span><span id="textcolor1229"><span>struct</span></span><span> file *file)</span> 
<a id="x1-39485r48"></a><span>48</span><span>{</span> 
<a id="x1-39487r49"></a><span>49</span><span>    pr_info(</span><span id="textcolor1230"><span>&#34;device_release(%p,%p)</span></span><span id="textcolor1231"><span>\n</span></span><span id="textcolor1232"><span>&#34;</span></span><span>, inode, file);</span> 
<a id="x1-39489r50"></a><span>50</span> 
<a id="x1-39491r51"></a><span>51</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-39493r52"></a><span>52</span><span>    </span><span id="textcolor1233"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-39495r53"></a><span>53</span><span>}</span> 
<a id="x1-39497r54"></a><span>54</span> 
<a id="x1-39499r55"></a><span>55</span><span id="textcolor1234"><span>/* This function is called whenever a process which has already opened the</span></span> 
<a id="x1-39501r56"></a><span>56</span><span id="textcolor1235"><span> * device file attempts to read from it.</span></span> 
<a id="x1-39503r57"></a><span>57</span><span id="textcolor1236"><span> */</span></span> 
<a id="x1-39505r58"></a><span>58</span><span id="textcolor1237"><span>static</span></span><span> </span><span id="textcolor1238"><span>ssize_t</span></span><span> device_read(</span><span id="textcolor1239"><span>struct</span></span><span> file *file, </span><span id="textcolor1240"><span>/* see include/linux/fs.h   */</span></span> 
<a id="x1-39507r59"></a><span>59</span><span>                           </span><span id="textcolor1241"><span>char</span></span><span> __user *buffer, </span><span id="textcolor1242"><span>/* buffer to be filled  */</span></span> 
<a id="x1-39509r60"></a><span>60</span><span>                           </span><span id="textcolor1243"><span>size_t</span></span><span> length, </span><span id="textcolor1244"><span>/* length of the buffer     */</span></span> 
<a id="x1-39511r61"></a><span>61</span><span>                           loff_t *offset)</span> 
<a id="x1-39513r62"></a><span>62</span><span>{</span> 
<a id="x1-39515r63"></a><span>63</span><span>    </span><span id="textcolor1245"><span>/* Number of bytes actually written to the buffer */</span></span> 
<a id="x1-39517r64"></a><span>64</span><span>    </span><span id="textcolor1246"><span>int</span></span><span> bytes_read = 0;</span> 
<a id="x1-39519r65"></a><span>65</span><span>    </span><span id="textcolor1247"><span>/* How far did the process reading the message get? Useful if the message</span></span> 
<a id="x1-39521r66"></a><span>66</span><span id="textcolor1248"><span>     * is larger than the size of the buffer we get to fill in device_read.</span></span> 
<a id="x1-39523r67"></a><span>67</span><span id="textcolor1249"><span>     */</span></span> 
<a id="x1-39525r68"></a><span>68</span><span>    </span><span id="textcolor1250"><span>const</span></span><span> </span><span id="textcolor1251"><span>char</span></span><span> *message_ptr = message;</span> 
<a id="x1-39527r69"></a><span>69</span> 
<a id="x1-39529r70"></a><span>70</span><span>    </span><span id="textcolor1252"><span>if</span></span><span> (!*(message_ptr + *offset)) { </span><span id="textcolor1253"><span>/* we are at the end of message */</span></span> 
<a id="x1-39531r71"></a><span>71</span><span>        *offset = 0; </span><span id="textcolor1254"><span>/* reset the offset */</span></span> 
<a id="x1-39533r72"></a><span>72</span><span>        </span><span id="textcolor1255"><span>return</span></span><span> 0; </span><span id="textcolor1256"><span>/* signify end of file */</span></span> 
<a id="x1-39535r73"></a><span>73</span><span>    }</span> 
<a id="x1-39537r74"></a><span>74</span> 
<a id="x1-39539r75"></a><span>75</span><span>    message_ptr += *offset;</span> 
<a id="x1-39541r76"></a><span>76</span> 
<a id="x1-39543r77"></a><span>77</span><span>    </span><span id="textcolor1257"><span>/* Actually put the data into the buffer */</span></span> 
<a id="x1-39545r78"></a><span>78</span><span>    </span><span id="textcolor1258"><span>while</span></span><span> (length &amp;&amp; *message_ptr) {</span> 
<a id="x1-39547r79"></a><span>79</span><span>        </span><span id="textcolor1259"><span>/* Because the buffer is in the user data segment, not the kernel</span></span> 
<a id="x1-39549r80"></a><span>80</span><span id="textcolor1260"><span>         * data segment, assignment would not work. Instead, we have to</span></span> 
<a id="x1-39551r81"></a><span>81</span><span id="textcolor1261"><span>         * use put_user which copies data from the kernel data segment to</span></span> 
<a id="x1-39553r82"></a><span>82</span><span id="textcolor1262"><span>         * the user data segment.</span></span> 
<a id="x1-39555r83"></a><span>83</span><span id="textcolor1263"><span>         */</span></span> 
<a id="x1-39557r84"></a><span>84</span><span>        put_user(*(message_ptr++), buffer++);</span> 
<a id="x1-39559r85"></a><span>85</span><span>        length--;</span> 
<a id="x1-39561r86"></a><span>86</span><span>        bytes_read++;</span> 
<a id="x1-39563r87"></a><span>87</span><span>    }</span> 
<a id="x1-39565r88"></a><span>88</span> 
<a id="x1-39567r89"></a><span>89</span><span>    pr_info(</span><span id="textcolor1264"><span>&#34;Read %d bytes, %ld left</span></span><span id="textcolor1265"><span>\n</span></span><span id="textcolor1266"><span>&#34;</span></span><span>, bytes_read, length);</span> 
<a id="x1-39569r90"></a><span>90</span> 
<a id="x1-39571r91"></a><span>91</span><span>    *offset += bytes_read;</span> 
<a id="x1-39573r92"></a><span>92</span> 
<a id="x1-39575r93"></a><span>93</span><span>    </span><span id="textcolor1267"><span>/* Read functions are supposed to return the number of bytes actually</span></span> 
<a id="x1-39577r94"></a><span>94</span><span id="textcolor1268"><span>     * inserted into the buffer.</span></span> 
<a id="x1-39579r95"></a><span>95</span><span id="textcolor1269"><span>     */</span></span> 
<a id="x1-39581r96"></a><span>96</span><span>    </span><span id="textcolor1270"><span>return</span></span><span> bytes_read;</span> 
<a id="x1-39583r97"></a><span>97</span><span>}</span> 
<a id="x1-39585r98"></a><span>98</span> 
<a id="x1-39587r99"></a><span>99</span><span id="textcolor1271"><span>/* called when somebody tries to write into our device file. */</span></span> 
<a id="x1-39589r100"></a><span>100</span><span id="textcolor1272"><span>static</span></span><span> </span><span id="textcolor1273"><span>ssize_t</span></span><span> device_write(</span><span id="textcolor1274"><span>struct</span></span><span> file *file, </span><span id="textcolor1275"><span>const</span></span><span> </span><span id="textcolor1276"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-39591r101"></a><span>101</span><span>                            </span><span id="textcolor1277"><span>size_t</span></span><span> length, loff_t *offset)</span> 
<a id="x1-39593r102"></a><span>102</span><span>{</span> 
<a id="x1-39595r103"></a><span>103</span><span>    </span><span id="textcolor1278"><span>int</span></span><span> i;</span> 
<a id="x1-39597r104"></a><span>104</span> 
<a id="x1-39599r105"></a><span>105</span><span>    pr_info(</span><span id="textcolor1279"><span>&#34;device_write(%p,%p,%ld)&#34;</span></span><span>, file, buffer, length);</span> 
<a id="x1-39601r106"></a><span>106</span> 
<a id="x1-39603r107"></a><span>107</span><span>    </span><span id="textcolor1280"><span>for</span></span><span> (i = 0; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++)</span> 
<a id="x1-39605r108"></a><span>108</span><span>        get_user(message[i], buffer + i);</span> 
<a id="x1-39607r109"></a><span>109</span> 
<a id="x1-39609r110"></a><span>110</span><span>    </span><span id="textcolor1281"><span>/* Again, return the number of input characters used. */</span></span> 
<a id="x1-39611r111"></a><span>111</span><span>    </span><span id="textcolor1282"><span>return</span></span><span> i;</span> 
<a id="x1-39613r112"></a><span>112</span><span>}</span> 
<a id="x1-39615r113"></a><span>113</span> 
<a id="x1-39617r114"></a><span>114</span><span id="textcolor1283"><span>/* This function is called whenever a process tries to do an ioctl on our</span></span> 
<a id="x1-39619r115"></a><span>115</span><span id="textcolor1284"><span> * device file. We get two extra parameters (additional to the inode and file</span></span> 
<a id="x1-39621r116"></a><span>116</span><span id="textcolor1285"><span> * structures, which all device functions get): the number of the ioctl called</span></span> 
<a id="x1-39623r117"></a><span>117</span><span id="textcolor1286"><span> * and the parameter given to the ioctl function.</span></span> 
<a id="x1-39625r118"></a><span>118</span><span id="textcolor1287"><span> *</span></span> 
<a id="x1-39627r119"></a><span>119</span><span id="textcolor1288"><span> * If the ioctl is write or read/write (meaning output is returned to the</span></span> 
<a id="x1-39629r120"></a><span>120</span><span id="textcolor1289"><span> * calling process), the ioctl call returns the output of this function.</span></span> 
<a id="x1-39631r121"></a><span>121</span><span id="textcolor1290"><span> */</span></span> 
<a id="x1-39633r122"></a><span>122</span><span id="textcolor1291"><span>static</span></span><span> </span><span id="textcolor1292"><span>long</span></span> 
<a id="x1-39635r123"></a><span>123</span><span>device_ioctl(</span><span id="textcolor1293"><span>struct</span></span><span> file *file, </span><span id="textcolor1294"><span>/* ditto */</span></span> 
<a id="x1-39637r124"></a><span>124</span><span>             </span><span id="textcolor1295"><span>unsigned</span></span><span> </span><span id="textcolor1296"><span>int</span></span><span> ioctl_num, </span><span id="textcolor1297"><span>/* number and param for ioctl */</span></span> 
<a id="x1-39639r125"></a><span>125</span><span>             </span><span id="textcolor1298"><span>unsigned</span></span><span> </span><span id="textcolor1299"><span>long</span></span><span> ioctl_param)</span> 
<a id="x1-39641r126"></a><span>126</span><span>{</span> 
<a id="x1-39643r127"></a><span>127</span><span>    </span><span id="textcolor1300"><span>int</span></span><span> i;</span> 
<a id="x1-39645r128"></a><span>128</span><span>    </span><span id="textcolor1301"><span>long</span></span><span> ret = SUCCESS;</span> 
<a id="x1-39647r129"></a><span>129</span> 
<a id="x1-39649r130"></a><span>130</span><span>    </span><span id="textcolor1302"><span>/* We don</span><span>&#39;</span><span>t want to talk to two processes at the same time. */</span></span> 
<a id="x1-39651r131"></a><span>131</span><span>    </span><span id="textcolor1303"><span>if</span></span><span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))</span> 
<a id="x1-39653r132"></a><span>132</span><span>        </span><span id="textcolor1304"><span>return</span></span><span> -EBUSY;</span> 
<a id="x1-39655r133"></a><span>133</span> 
<a id="x1-39657r134"></a><span>134</span><span>    </span><span id="textcolor1305"><span>/* Switch according to the ioctl called */</span></span> 
<a id="x1-39659r135"></a><span>135</span><span>    </span><span id="textcolor1306"><span>switch</span></span><span> (ioctl_num) {</span> 
<a id="x1-39661r136"></a><span>136</span><span>    </span><span id="textcolor1307"><span>case</span></span><span> IOCTL_SET_MSG: {</span> 
<a id="x1-39663r137"></a><span>137</span><span>        </span><span id="textcolor1308"><span>/* Receive a pointer to a message (in user space) and set that to</span></span> 
<a id="x1-39665r138"></a><span>138</span><span id="textcolor1309"><span>         * be the device</span><span>&#39;</span><span>s message. Get the parameter given to ioctl by</span></span> 
<a id="x1-39667r139"></a><span>139</span><span id="textcolor1310"><span>         * the process.</span></span> 
<a id="x1-39669r140"></a><span>140</span><span id="textcolor1311"><span>         */</span></span> 
<a id="x1-39671r141"></a><span>141</span><span>        </span><span id="textcolor1312"><span>char</span></span><span> __user *tmp = (</span><span id="textcolor1313"><span>char</span></span><span> __user *)ioctl_param;</span> 
<a id="x1-39673r142"></a><span>142</span><span>        </span><span id="textcolor1314"><span>char</span></span><span> ch;</span> 
<a id="x1-39675r143"></a><span>143</span> 
<a id="x1-39677r144"></a><span>144</span><span>        </span><span id="textcolor1315"><span>/* Find the length of the message */</span></span> 
<a id="x1-39679r145"></a><span>145</span><span>        get_user(ch, tmp);</span> 
<a id="x1-39681r146"></a><span>146</span><span>        </span><span id="textcolor1316"><span>for</span></span><span> (i = 0; ch &amp;&amp; i &lt; BUF_LEN; i++, tmp++)</span> 
<a id="x1-39683r147"></a><span>147</span><span>            get_user(ch, tmp);</span> 
<a id="x1-39685r148"></a><span>148</span> 
<a id="x1-39687r149"></a><span>149</span><span>        device_write(file, (</span><span id="textcolor1317"><span>char</span></span><span> __user *)ioctl_param, i, NULL);</span> 
<a id="x1-39689r150"></a><span>150</span><span>        </span><span id="textcolor1318"><span>break</span></span><span>;</span> 
<a id="x1-39691r151"></a><span>151</span><span>    }</span> 
<a id="x1-39693r152"></a><span>152</span><span>    </span><span id="textcolor1319"><span>case</span></span><span> IOCTL_GET_MSG: {</span> 
<a id="x1-39695r153"></a><span>153</span><span>        loff_t offset = 0;</span> 
<a id="x1-39697r154"></a><span>154</span> 
<a id="x1-39699r155"></a><span>155</span><span>        </span><span id="textcolor1320"><span>/* Give the current message to the calling process - the parameter</span></span> 
<a id="x1-39701r156"></a><span>156</span><span id="textcolor1321"><span>         * we got is a pointer, fill it.</span></span> 
<a id="x1-39703r157"></a><span>157</span><span id="textcolor1322"><span>         */</span></span> 
<a id="x1-39705r158"></a><span>158</span><span>        i = device_read(file, (</span><span id="textcolor1323"><span>char</span></span><span> __user *)ioctl_param, 99, &amp;offset);</span> 
<a id="x1-39707r159"></a><span>159</span> 
<a id="x1-39709r160"></a><span>160</span><span>        </span><span id="textcolor1324"><span>/* Put a zero at the end of the buffer, so it will be properly</span></span> 
<a id="x1-39711r161"></a><span>161</span><span id="textcolor1325"><span>         * terminated.</span></span> 
<a id="x1-39713r162"></a><span>162</span><span id="textcolor1326"><span>         */</span></span> 
<a id="x1-39715r163"></a><span>163</span><span>        put_user(</span><span id="textcolor1327"><span>&#39;</span><span>\0</span><span>&#39;</span></span><span>, (</span><span id="textcolor1328"><span>char</span></span><span> __user *)ioctl_param + i);</span> 
<a id="x1-39717r164"></a><span>164</span><span>        </span><span id="textcolor1329"><span>break</span></span><span>;</span> 
<a id="x1-39719r165"></a><span>165</span><span>    }</span> 
<a id="x1-39721r166"></a><span>166</span><span>    </span><span id="textcolor1330"><span>case</span></span><span> IOCTL_GET_NTH_BYTE:</span> 
<a id="x1-39723r167"></a><span>167</span><span>        </span><span id="textcolor1331"><span>/* This ioctl is both input (ioctl_param) and output (the return</span></span> 
<a id="x1-39725r168"></a><span>168</span><span id="textcolor1332"><span>         * value of this function).</span></span> 
<a id="x1-39727r169"></a><span>169</span><span id="textcolor1333"><span>         */</span></span> 
<a id="x1-39729r170"></a><span>170</span><span>        ret = (</span><span id="textcolor1334"><span>long</span></span><span>)message[ioctl_param];</span> 
<a id="x1-39731r171"></a><span>171</span><span>        </span><span id="textcolor1335"><span>break</span></span><span>;</span> 
<a id="x1-39733r172"></a><span>172</span><span>    }</span> 
<a id="x1-39735r173"></a><span>173</span> 
<a id="x1-39737r174"></a><span>174</span><span>    </span><span id="textcolor1336"><span>/* We</span><span>&#39;</span><span>re now ready for our next caller */</span></span> 
<a id="x1-39739r175"></a><span>175</span><span>    atomic_set(&amp;already_open, CDEV_NOT_USED);</span> 
<a id="x1-39741r176"></a><span>176</span> 
<a id="x1-39743r177"></a><span>177</span><span>    </span><span id="textcolor1337"><span>return</span></span><span> ret;</span> 
<a id="x1-39745r178"></a><span>178</span><span>}</span> 
<a id="x1-39747r179"></a><span>179</span> 
<a id="x1-39749r180"></a><span>180</span><span id="textcolor1338"><span>/* Module Declarations */</span></span> 
<a id="x1-39751r181"></a><span>181</span> 
<a id="x1-39753r182"></a><span>182</span><span id="textcolor1339"><span>/* This structure will hold the functions to be called when a process does</span></span> 
<a id="x1-39755r183"></a><span>183</span><span id="textcolor1340"><span> * something to the device we created. Since a pointer to this structure</span></span> 
<a id="x1-39757r184"></a><span>184</span><span id="textcolor1341"><span> * is kept in the devices table, it can</span><span>&#39;</span><span>t be local to init_module. NULL is</span></span> 
<a id="x1-39759r185"></a><span>185</span><span id="textcolor1342"><span> * for unimplemented functions.</span></span> 
<a id="x1-39761r186"></a><span>186</span><span id="textcolor1343"><span> */</span></span> 
<a id="x1-39763r187"></a><span>187</span><span id="textcolor1344"><span>static</span></span><span> </span><span id="textcolor1345"><span>struct</span></span><span> file_operations fops = {</span> 
<a id="x1-39765r188"></a><span>188</span><span>    .read = device_read,</span> 
<a id="x1-39767r189"></a><span>189</span><span>    .write = device_write,</span> 
<a id="x1-39769r190"></a><span>190</span><span>    .unlocked_ioctl = device_ioctl,</span> 
<a id="x1-39771r191"></a><span>191</span><span>    .open = device_open,</span> 
<a id="x1-39773r192"></a><span>192</span><span>    .release = device_release, </span><span id="textcolor1346"><span>/* a.k.a. close */</span></span> 
<a id="x1-39775r193"></a><span>193</span><span>};</span> 
<a id="x1-39777r194"></a><span>194</span> 
<a id="x1-39779r195"></a><span>195</span><span id="textcolor1347"><span>/* Initialize the module - Register the character device */</span></span> 
<a id="x1-39781r196"></a><span>196</span><span id="textcolor1348"><span>static</span></span><span> </span><span id="textcolor1349"><span>int</span></span><span> __init chardev2_init(</span><span id="textcolor1350"><span>void</span></span><span>)</span> 
<a id="x1-39783r197"></a><span>197</span><span>{</span> 
<a id="x1-39785r198"></a><span>198</span><span>    </span><span id="textcolor1351"><span>/* Register the character device (atleast try) */</span></span> 
<a id="x1-39787r199"></a><span>199</span><span>    </span><span id="textcolor1352"><span>int</span></span><span> ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;fops);</span> 
<a id="x1-39789r200"></a><span>200</span> 
<a id="x1-39791r201"></a><span>201</span><span>    </span><span id="textcolor1353"><span>/* Negative values signify an error */</span></span> 
<a id="x1-39793r202"></a><span>202</span><span>    </span><span id="textcolor1354"><span>if</span></span><span> (ret_val &lt; 0) {</span> 
<a id="x1-39795r203"></a><span>203</span><span>        pr_alert(</span><span id="textcolor1355"><span>&#34;%s failed with %d</span></span><span id="textcolor1356"><span>\n</span></span><span id="textcolor1357"><span>&#34;</span></span><span>,</span> 
<a id="x1-39797r204"></a><span>204</span><span>                 </span><span id="textcolor1358"><span>&#34;Sorry, registering the character device &#34;</span></span><span>, ret_val);</span> 
<a id="x1-39799r205"></a><span>205</span><span>        </span><span id="textcolor1359"><span>return</span></span><span> ret_val;</span> 
<a id="x1-39801r206"></a><span>206</span><span>    }</span> 
<a id="x1-39803r207"></a><span>207</span> 
<a id="x1-39805r208"></a><span>208</span><span>    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME);</span> 
<a id="x1-39807r209"></a><span>209</span><span>    device_create(cls, NULL, MKDEV(MAJOR_NUM, 0), NULL, DEVICE_FILE_NAME);</span> 
<a id="x1-39809r210"></a><span>210</span> 
<a id="x1-39811r211"></a><span>211</span><span>    pr_info(</span><span id="textcolor1360"><span>&#34;Device created on /dev/%s</span></span><span id="textcolor1361"><span>\n</span></span><span id="textcolor1362"><span>&#34;</span></span><span>, DEVICE_FILE_NAME);</span> 
<a id="x1-39813r212"></a><span>212</span> 
<a id="x1-39815r213"></a><span>213</span><span>    </span><span id="textcolor1363"><span>return</span></span><span> 0;</span> 
<a id="x1-39817r214"></a><span>214</span><span>}</span> 
<a id="x1-39819r215"></a><span>215</span> 
<a id="x1-39821r216"></a><span>216</span><span id="textcolor1364"><span>/* Cleanup - unregister the appropriate file from /proc */</span></span> 
<a id="x1-39823r217"></a><span>217</span><span id="textcolor1365"><span>static</span></span><span> </span><span id="textcolor1366"><span>void</span></span><span> __exit chardev2_exit(</span><span id="textcolor1367"><span>void</span></span><span>)</span> 
<a id="x1-39825r218"></a><span>218</span><span>{</span> 
<a id="x1-39827r219"></a><span>219</span><span>    device_destroy(cls, MKDEV(MAJOR_NUM, 0));</span> 
<a id="x1-39829r220"></a><span>220</span><span>    class_destroy(cls);</span> 
<a id="x1-39831r221"></a><span>221</span> 
<a id="x1-39833r222"></a><span>222</span><span>    </span><span id="textcolor1368"><span>/* Unregister the device */</span></span> 
<a id="x1-39835r223"></a><span>223</span><span>    unregister_chrdev(MAJOR_NUM, DEVICE_NAME);</span> 
<a id="x1-39837r224"></a><span>224</span><span>}</span> 
<a id="x1-39839r225"></a><span>225</span> 
<a id="x1-39841r226"></a><span>226</span><span>module_init(chardev2_init);</span> 
<a id="x1-39843r227"></a><span>227</span><span>module_exit(chardev2_exit);</span> 
<a id="x1-39845r228"></a><span>228</span> 
<a id="x1-39847r229"></a><span>229</span><span>MODULE_LICENSE(</span><span id="textcolor1369"><span>&#34;GPL&#34;</span></span><span>);</span></pre>

<!-- l. 1 -->
   <pre id="fancyvrb62"><a id="x1-39849r1"></a><span>1</span><span id="textcolor1370"><span>/*</span></span> 
<a id="x1-39851r2"></a><span>2</span><span id="textcolor1371"><span> * chardev.h - the header file with the ioctl definitions.</span></span> 
<a id="x1-39853r3"></a><span>3</span><span id="textcolor1372"><span> *</span></span> 
<a id="x1-39855r4"></a><span>4</span><span id="textcolor1373"><span> * The declarations here have to be in a header file, because they need</span></span> 
<a id="x1-39857r5"></a><span>5</span><span id="textcolor1374"><span> * to be known both to the kernel module (in chardev2.c) and the process</span></span> 
<a id="x1-39859r6"></a><span>6</span><span id="textcolor1375"><span> * calling ioctl() (in userspace_ioctl.c).</span></span> 
<a id="x1-39861r7"></a><span>7</span><span id="textcolor1376"><span> */</span></span> 
<a id="x1-39863r8"></a><span>8</span> 
<a id="x1-39865r9"></a><span>9</span><span id="textcolor1377"><span>#ifndef CHARDEV_H</span></span> 
<a id="x1-39867r10"></a><span>10</span><span id="textcolor1378"><span>#define CHARDEV_H</span></span> 
<a id="x1-39869r11"></a><span>11</span> 
<a id="x1-39871r12"></a><span>12</span><span id="textcolor1379"><span>#include</span></span><span> </span><span id="textcolor1380"><span>&lt;linux/ioctl.h&gt;</span></span> 
<a id="x1-39873r13"></a><span>13</span> 
<a id="x1-39875r14"></a><span>14</span><span id="textcolor1381"><span>/* The major device number. We can not rely on dynamic registration</span></span> 
<a id="x1-39877r15"></a><span>15</span><span id="textcolor1382"><span> * any more, because ioctls need to know it.</span></span> 
<a id="x1-39879r16"></a><span>16</span><span id="textcolor1383"><span> */</span></span> 
<a id="x1-39881r17"></a><span>17</span><span id="textcolor1384"><span>#define MAJOR_NUM 100</span></span> 
<a id="x1-39883r18"></a><span>18</span> 
<a id="x1-39885r19"></a><span>19</span><span id="textcolor1385"><span>/* Set the message of the device driver */</span></span> 
<a id="x1-39887r20"></a><span>20</span><span id="textcolor1386"><span>#define IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *)</span></span> 
<a id="x1-39889r21"></a><span>21</span><span id="textcolor1387"><span>/* _IOW means that we are creating an ioctl command number for passing</span></span> 
<a id="x1-39891r22"></a><span>22</span><span id="textcolor1388"><span> * information from a user process to the kernel module.</span></span> 
<a id="x1-39893r23"></a><span>23</span><span id="textcolor1389"><span> *</span></span> 
<a id="x1-39895r24"></a><span>24</span><span id="textcolor1390"><span> * The first arguments, MAJOR_NUM, is the major device number we are using.</span></span> 
<a id="x1-39897r25"></a><span>25</span><span id="textcolor1391"><span> *</span></span> 
<a id="x1-39899r26"></a><span>26</span><span id="textcolor1392"><span> * The second argument is the number of the command (there could be several</span></span> 
<a id="x1-39901r27"></a><span>27</span><span id="textcolor1393"><span> * with different meanings).</span></span> 
<a id="x1-39903r28"></a><span>28</span><span id="textcolor1394"><span> *</span></span> 
<a id="x1-39905r29"></a><span>29</span><span id="textcolor1395"><span> * The third argument is the type we want to get from the process to the</span></span> 
<a id="x1-39907r30"></a><span>30</span><span id="textcolor1396"><span> * kernel.</span></span> 
<a id="x1-39909r31"></a><span>31</span><span id="textcolor1397"><span> */</span></span> 
<a id="x1-39911r32"></a><span>32</span> 
<a id="x1-39913r33"></a><span>33</span><span id="textcolor1398"><span>/* Get the message of the device driver */</span></span> 
<a id="x1-39915r34"></a><span>34</span><span id="textcolor1399"><span>#define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *)</span></span> 
<a id="x1-39917r35"></a><span>35</span><span id="textcolor1400"><span>/* This IOCTL is used for output, to get the message of the device driver.</span></span> 
<a id="x1-39919r36"></a><span>36</span><span id="textcolor1401"><span> * However, we still need the buffer to place the message in to be input,</span></span> 
<a id="x1-39921r37"></a><span>37</span><span id="textcolor1402"><span> * as it is allocated by the process.</span></span> 
<a id="x1-39923r38"></a><span>38</span><span id="textcolor1403"><span> */</span></span> 
<a id="x1-39925r39"></a><span>39</span> 
<a id="x1-39927r40"></a><span>40</span><span id="textcolor1404"><span>/* Get the n</span><span>&#39;</span><span>th byte of the message */</span></span> 
<a id="x1-39929r41"></a><span>41</span><span id="textcolor1405"><span>#define IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int)</span></span> 
<a id="x1-39931r42"></a><span>42</span><span id="textcolor1406"><span>/* The IOCTL is used for both input and output. It receives from the user</span></span> 
<a id="x1-39933r43"></a><span>43</span><span id="textcolor1407"><span> * a number, n, and returns message[n].</span></span> 
<a id="x1-39935r44"></a><span>44</span><span id="textcolor1408"><span> */</span></span> 
<a id="x1-39937r45"></a><span>45</span> 
<a id="x1-39939r46"></a><span>46</span><span id="textcolor1409"><span>/* The name of the device file */</span></span> 
<a id="x1-39941r47"></a><span>47</span><span id="textcolor1410"><span>#define DEVICE_FILE_NAME &#34;char_dev&#34;</span></span> 
<a id="x1-39943r48"></a><span>48</span><span id="textcolor1411"><span>#define DEVICE_PATH &#34;/dev/char_dev&#34;</span></span> 
<a id="x1-39945r49"></a><span>49</span> 
<a id="x1-39947r50"></a><span>50</span><span id="textcolor1412"><span>#endif</span></span></pre>

<!-- l. 1 -->
   <pre id="fancyvrb63"><a id="x1-39949r1"></a><span>1</span><span id="textcolor1413"><span>/*  userspace_ioctl.c - the process to use ioctl</span><span>&#39;</span><span>s to control the kernel module</span></span> 
<a id="x1-39951r2"></a><span>2</span><span id="textcolor1414"><span> *</span></span> 
<a id="x1-39953r3"></a><span>3</span><span id="textcolor1415"><span> *  Until now we could have used cat for input and output.  But now</span></span> 
<a id="x1-39955r4"></a><span>4</span><span id="textcolor1416"><span> *  we need to do ioctl</span><span>&#39;</span><span>s, which require writing our own process. </span></span> 
<a id="x1-39957r5"></a><span>5</span><span id="textcolor1417"><span> */</span></span> 
<a id="x1-39959r6"></a><span>6</span> 
<a id="x1-39961r7"></a><span>7</span><span id="textcolor1418"><span>/* device specifics, such as ioctl numbers and the </span></span> 
<a id="x1-39963r8"></a><span>8</span><span id="textcolor1419"><span> * major device file. */</span></span> 
<a id="x1-39965r9"></a><span>9</span><span id="textcolor1420"><span>#include</span></span><span> </span><span id="textcolor1421"><span>&#34;../chardev.h&#34;</span></span> 
<a id="x1-39967r10"></a><span>10</span> 
<a id="x1-39969r11"></a><span>11</span><span id="textcolor1422"><span>#include</span></span><span> </span><span id="textcolor1423"><span>&lt;stdio.h&gt; /* standard I/O */</span></span> 
<a id="x1-39971r12"></a><span>12</span><span id="textcolor1424"><span>#include</span></span><span> </span><span id="textcolor1425"><span>&lt;fcntl.h&gt; /* open */</span></span> 
<a id="x1-39973r13"></a><span>13</span><span id="textcolor1426"><span>#include</span></span><span> </span><span id="textcolor1427"><span>&lt;unistd.h&gt; /* close */</span></span> 
<a id="x1-39975r14"></a><span>14</span><span id="textcolor1428"><span>#include</span></span><span> </span><span id="textcolor1429"><span>&lt;stdlib.h&gt; /* exit */</span></span> 
<a id="x1-39977r15"></a><span>15</span><span id="textcolor1430"><span>#include</span></span><span> </span><span id="textcolor1431"><span>&lt;sys/ioctl.h&gt; /* ioctl */</span></span> 
<a id="x1-39979r16"></a><span>16</span> 
<a id="x1-39981r17"></a><span>17</span><span id="textcolor1432"><span>/* Functions for the ioctl calls */</span></span> 
<a id="x1-39983r18"></a><span>18</span> 
<a id="x1-39985r19"></a><span>19</span><span id="textcolor1433"><span>int</span></span><span> ioctl_set_msg(</span><span id="textcolor1434"><span>int</span></span><span> file_desc, </span><span id="textcolor1435"><span>char</span></span><span> *message)</span> 
<a id="x1-39987r20"></a><span>20</span><span>{</span> 
<a id="x1-39989r21"></a><span>21</span><span>    </span><span id="textcolor1436"><span>int</span></span><span> ret_val;</span> 
<a id="x1-39991r22"></a><span>22</span> 
<a id="x1-39993r23"></a><span>23</span><span>    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message);</span> 
<a id="x1-39995r24"></a><span>24</span> 
<a id="x1-39997r25"></a><span>25</span><span>    </span><span id="textcolor1437"><span>if</span></span><span> (ret_val &lt; 0) {</span> 
<a id="x1-39999r26"></a><span>26</span><span>        printf(</span><span id="textcolor1438"><span>&#34;ioctl_set_msg failed:%d</span></span><span id="textcolor1439"><span>\n</span></span><span id="textcolor1440"><span>&#34;</span></span><span>, ret_val);</span> 
<a id="x1-40001r27"></a><span>27</span><span>    }</span> 
<a id="x1-40003r28"></a><span>28</span> 
<a id="x1-40005r29"></a><span>29</span><span>    </span><span id="textcolor1441"><span>return</span></span><span> ret_val;</span> 
<a id="x1-40007r30"></a><span>30</span><span>}</span> 
<a id="x1-40009r31"></a><span>31</span> 
<a id="x1-40011r32"></a><span>32</span><span id="textcolor1442"><span>int</span></span><span> ioctl_get_msg(</span><span id="textcolor1443"><span>int</span></span><span> file_desc)</span> 
<a id="x1-40013r33"></a><span>33</span><span>{</span> 
<a id="x1-40015r34"></a><span>34</span><span>    </span><span id="textcolor1444"><span>int</span></span><span> ret_val;</span> 
<a id="x1-40017r35"></a><span>35</span><span>    </span><span id="textcolor1445"><span>char</span></span><span> message[100] = { 0 };</span> 
<a id="x1-40019r36"></a><span>36</span> 
<a id="x1-40021r37"></a><span>37</span><span>    </span><span id="textcolor1446"><span>/* Warning - this is dangerous because we don</span><span>&#39;</span><span>t tell </span></span> 
<a id="x1-40023r38"></a><span>38</span><span id="textcolor1447"><span>   * the kernel how far it</span><span>&#39;</span><span>s allowed to write, so it </span></span> 
<a id="x1-40025r39"></a><span>39</span><span id="textcolor1448"><span>   * might overflow the buffer. In a real production </span></span> 
<a id="x1-40027r40"></a><span>40</span><span id="textcolor1449"><span>   * program, we would have used two ioctls - one to tell</span></span> 
<a id="x1-40029r41"></a><span>41</span><span id="textcolor1450"><span>   * the kernel the buffer length and another to give </span></span> 
<a id="x1-40031r42"></a><span>42</span><span id="textcolor1451"><span>   * it the buffer to fill</span></span> 
<a id="x1-40033r43"></a><span>43</span><span id="textcolor1452"><span>   */</span></span> 
<a id="x1-40035r44"></a><span>44</span><span>    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message);</span> 
<a id="x1-40037r45"></a><span>45</span> 
<a id="x1-40039r46"></a><span>46</span><span>    </span><span id="textcolor1453"><span>if</span></span><span> (ret_val &lt; 0) {</span> 
<a id="x1-40041r47"></a><span>47</span><span>        printf(</span><span id="textcolor1454"><span>&#34;ioctl_get_msg failed:%d</span></span><span id="textcolor1455"><span>\n</span></span><span id="textcolor1456"><span>&#34;</span></span><span>, ret_val);</span> 
<a id="x1-40043r48"></a><span>48</span><span>    }</span> 
<a id="x1-40045r49"></a><span>49</span><span>    printf(</span><span id="textcolor1457"><span>&#34;get_msg message:%s&#34;</span></span><span>, message);</span> 
<a id="x1-40047r50"></a><span>50</span> 
<a id="x1-40049r51"></a><span>51</span><span>    </span><span id="textcolor1458"><span>return</span></span><span> ret_val;</span> 
<a id="x1-40051r52"></a><span>52</span><span>}</span> 
<a id="x1-40053r53"></a><span>53</span> 
<a id="x1-40055r54"></a><span>54</span><span id="textcolor1459"><span>int</span></span><span> ioctl_get_nth_byte(</span><span id="textcolor1460"><span>int</span></span><span> file_desc)</span> 
<a id="x1-40057r55"></a><span>55</span><span>{</span> 
<a id="x1-40059r56"></a><span>56</span><span>    </span><span id="textcolor1461"><span>int</span></span><span> i, c;</span> 
<a id="x1-40061r57"></a><span>57</span> 
<a id="x1-40063r58"></a><span>58</span><span>    printf(</span><span id="textcolor1462"><span>&#34;get_nth_byte message:&#34;</span></span><span>);</span> 
<a id="x1-40065r59"></a><span>59</span> 
<a id="x1-40067r60"></a><span>60</span><span>    i = 0;</span> 
<a id="x1-40069r61"></a><span>61</span><span>    </span><span id="textcolor1463"><span>do</span></span><span> {</span> 
<a id="x1-40071r62"></a><span>62</span><span>        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++);</span> 
<a id="x1-40073r63"></a><span>63</span> 
<a id="x1-40075r64"></a><span>64</span><span>        </span><span id="textcolor1464"><span>if</span></span><span> (c &lt; 0) {</span> 
<a id="x1-40077r65"></a><span>65</span><span>            printf(</span><span id="textcolor1465"><span>&#34;</span></span><span id="textcolor1466"><span>\n</span></span><span id="textcolor1467"><span>ioctl_get_nth_byte failed at the %d</span><span>&#39;</span><span>th byte:</span></span><span id="textcolor1468"><span>\n</span></span><span id="textcolor1469"><span>&#34;</span></span><span>, i);</span> 
<a id="x1-40079r66"></a><span>66</span><span>            </span><span id="textcolor1470"><span>return</span></span><span> c;</span> 
<a id="x1-40081r67"></a><span>67</span><span>        }</span> 
<a id="x1-40083r68"></a><span>68</span> 
<a id="x1-40085r69"></a><span>69</span><span>        putchar(c);</span> 
<a id="x1-40087r70"></a><span>70</span><span>    } </span><span id="textcolor1471"><span>while</span></span><span> (c != 0);</span> 
<a id="x1-40089r71"></a><span>71</span> 
<a id="x1-40091r72"></a><span>72</span><span>    </span><span id="textcolor1472"><span>return</span></span><span> 0;</span> 
<a id="x1-40093r73"></a><span>73</span><span>}</span> 
<a id="x1-40095r74"></a><span>74</span> 
<a id="x1-40097r75"></a><span>75</span><span id="textcolor1473"><span>/* Main - Call the ioctl functions */</span></span> 
<a id="x1-40099r76"></a><span>76</span><span id="textcolor1474"><span>int</span></span><span> main(</span><span id="textcolor1475"><span>void</span></span><span>)</span> 
<a id="x1-40101r77"></a><span>77</span><span>{</span> 
<a id="x1-40103r78"></a><span>78</span><span>    </span><span id="textcolor1476"><span>int</span></span><span> file_desc, ret_val;</span> 
<a id="x1-40105r79"></a><span>79</span><span>    </span><span id="textcolor1477"><span>char</span></span><span> *msg = </span><span id="textcolor1478"><span>&#34;Message passed by ioctl</span></span><span id="textcolor1479"><span>\n</span></span><span id="textcolor1480"><span>&#34;</span></span><span>;</span> 
<a id="x1-40107r80"></a><span>80</span> 
<a id="x1-40109r81"></a><span>81</span><span>    file_desc = open(DEVICE_PATH, O_RDWR);</span> 
<a id="x1-40111r82"></a><span>82</span><span>    </span><span id="textcolor1481"><span>if</span></span><span> (file_desc &lt; 0) {</span> 
<a id="x1-40113r83"></a><span>83</span><span>        printf(</span><span id="textcolor1482"><span>&#34;Can</span><span>&#39;</span><span>t open device file: %s, error:%d</span></span><span id="textcolor1483"><span>\n</span></span><span id="textcolor1484"><span>&#34;</span></span><span>, DEVICE_PATH,</span> 
<a id="x1-40115r84"></a><span>84</span><span>               file_desc);</span> 
<a id="x1-40117r85"></a><span>85</span><span>        exit(EXIT_FAILURE);</span> 
<a id="x1-40119r86"></a><span>86</span><span>    }</span> 
<a id="x1-40121r87"></a><span>87</span> 
<a id="x1-40123r88"></a><span>88</span><span>    ret_val = ioctl_set_msg(file_desc, msg);</span> 
<a id="x1-40125r89"></a><span>89</span><span>    </span><span id="textcolor1485"><span>if</span></span><span> (ret_val)</span> 
<a id="x1-40127r90"></a><span>90</span><span>        </span><span id="textcolor1486"><span>goto</span></span><span> error;</span> 
<a id="x1-40129r91"></a><span>91</span><span>    ret_val = ioctl_get_nth_byte(file_desc);</span> 
<a id="x1-40131r92"></a><span>92</span><span>    </span><span id="textcolor1487"><span>if</span></span><span> (ret_val)</span> 
<a id="x1-40133r93"></a><span>93</span><span>        </span><span id="textcolor1488"><span>goto</span></span><span> error;</span> 
<a id="x1-40135r94"></a><span>94</span><span>    ret_val = ioctl_get_msg(file_desc);</span> 
<a id="x1-40137r95"></a><span>95</span><span>    </span><span id="textcolor1489"><span>if</span></span><span> (ret_val)</span> 
<a id="x1-40139r96"></a><span>96</span><span>        </span><span id="textcolor1490"><span>goto</span></span><span> error;</span> 
<a id="x1-40141r97"></a><span>97</span> 
<a id="x1-40143r98"></a><span>98</span><span>    close(file_desc);</span> 
<a id="x1-40145r99"></a><span>99</span><span>    </span><span id="textcolor1491"><span>return</span></span><span> 0;</span> 
<a id="x1-40147r100"></a><span>100</span><span>error:</span> 
<a id="x1-40149r101"></a><span>101</span><span>    close(file_desc);</span> 
<a id="x1-40151r102"></a><span>102</span><span>    exit(EXIT_FAILURE);</span> 
<a id="x1-40153r103"></a><span>103</span><span>}</span></pre>
<!-- l. 1396 -->
   <h3 id="system-calls"><span>10   </span> <a id="x1-4100010"></a>System Calls</h3>
<!-- l. 1398 --><p>So far, the only thing we’ve done was to use well defined kernel mechanisms to
register <span><span><span>/proc</span></span></span> files and device handlers. This is fine if you want to do something the
kernel programmers thought you’d want, such as write a device driver. But what if
                                                                  

                                                                  
you want to do something unusual, to change the behavior of the system in some
way? Then, you are mostly on your own.
</p><!-- l. 1403 --><p>   If you are not being sensible and using a virtual machine then this is where kernel
programming can become hazardous. While writing the example below, I killed the
<code> <span>open()</span>
</code> system call. This meant I could not open any files, I could not run any
programs, and I could not shutdown the system. I had to restart the virtual
machine. No important files got annihilated, but if I was doing this on some live
mission critical system then that could have been a possible outcome. To
ensure you do not lose any files, even within a test environment, please run
<code> <span>sync</span>
</code> right before you do the <code>  <span>insmod</span>
</code> and the <code>  <span>rmmod</span>
</code>.
</p><!-- l. 1410 --><p>   Forget about <span><span><span>/proc</span></span></span> files, forget about device files. They are just minor details.
Minutiae in the vast expanse of the universe. The real process to kernel
communication mechanism, the one used by all processes, is <span>system calls</span>. When a
process requests a service from the kernel (such as opening a file, forking to a new
process, or requesting more memory), this is the mechanism used. If you want to
change the behaviour of the kernel in interesting ways, this is the place to do
it. By the way, if you want to see which system calls a program uses, run
<code> <span>strace &lt;arguments&gt;</span>
</code>.
</p><!-- l. 1418 --><p>   In general, a process is not supposed to be able to access the kernel. It can not
access kernel memory and it can’t call kernel functions. The hardware of the CPU
enforces this (that is the reason why it is called “protected mode” or “page
protection”).
</p><!-- l. 1422 --><p>   System calls are an exception to this general rule. What happens is that the
process fills the registers with the appropriate values and then calls a special
instruction which jumps to a previously defined location in the kernel (of course, that
location is readable by user processes, it is not writable by them). Under Intel CPUs,
this is done by means of interrupt 0x80. The hardware knows that once you jump to
this location, you are no longer running in restricted user mode, but as the
operating system kernel — and therefore you’re allowed to do whatever you
want.
</p><!-- l. 1427 --><p>   The location in the kernel a process can jump to is called <span><span><span>system_call</span></span></span>. The
procedure at that location checks the system call number, which tells the kernel what
service the process requested. Then, it looks at the table of system calls
(<code>  <span>sys_call_table</span>
</code>) to see the address of the kernel function to call. Then it calls the function, and after
it returns, does a few system checks and then return back to the process (or to a
different process, if the process time ran out). If you want to read this code, it is
at the source file <span><span><span>arch/$(architecture)/kernel/entry.S</span></span></span>, after the line
<code> <span>ENTRY(system_call)</span>
</code>.
</p><!-- l. 1433 --><p>   So, if we want to change the way a certain system call works, what we need to do
                                                                  

                                                                  
is to write our own function to implement it (usually by adding a bit of our own
code, and then calling the original function) and then change the pointer at
<code> <span>sys_call_table</span>
</code> to point to our function. Because we might be removed later and we
don’t want to leave the system in an unstable state, it’s important for
<code> <span>cleanup_module</span>
</code> to restore the table to its original state.
</p><!-- l. 1436 --><p>   To modify the content of <code>  <span>sys_call_table</span>
</code>, we need to consider the control register. A control register is a processor
register that changes or controls the general behavior of the CPU. For x86
architecture, the <span><span><span>cr0</span></span></span> register has various control flags that modify the basic
operation of the processor. The <span><span><span>WP</span></span></span> flag in <span><span><span>cr0</span></span></span> stands for write protection.
Once the <span><span><span>WP</span></span></span> flag is set, the processor disallows further write attempts to the
read-only sections Therefore, we must disable the <span><span><span>WP</span></span></span> flag before modifying
<code> <span>sys_call_table</span>
</code>. Since Linux v5.3, the <code>  <span>write_cr0</span>
</code> function cannot be used because of the sensitive <span><span><span>cr0</span></span></span> bits pinned by the security
issue, the attacker may write into CPU control registers to disable CPU protections
like write protection. As a result, we have to provide the custom assembly routine to
bypass it.
</p><!-- l. 1445 --><p>   However, <code>  <span>sys_call_table</span>
</code> symbol is unexported to prevent misuse. But there have few ways to get the symbol, manual
symbol lookup and <code>  <span>kallsyms_lookup_name</span>
</code>. Here we use both depend on the kernel version.
</p><!-- l. 1449 --><p>   Because of the <span>control-flow integrity</span>, which is a technique to prevent the redirect
execution code from the attacker, for making sure that the indirect calls go to the
expected addresses and the return addresses are not changed. Since Linux v5.7, the
kernel patched the series of <span>control-flow enforcement </span>(CET) for x86, and some
configurations of GCC, like GCC versions 9 and 10 in Ubuntu, will add with CET
(the <span><span><span>-fcf-protection</span></span></span> option) in the kernel by default. Using that GCC to compile
the kernel with retpoline off may result in CET being enabled in the kernel. You can
use the following command to check out the <span><span><span>-fcf-protection</span></span></span> option is enabled or
not:
                                                                  

                                                                  
</p>
   <pre id="verbatim-16">$ gcc -v -Q -O2 --help=target | grep protection
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper
...
gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
COLLECT_GCC_OPTIONS=&#39;-v&#39; &#39;-Q&#39; &#39;-O2&#39; &#39;--help=target&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39;
 /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -v ... -fcf-protection ...
 GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu)
...
</pre>
<!-- l. 1464 --><p>But CET should not be enabled in the kernel, it may break the Kprobes and bpf.
Consequently, CET is disabled since v5.11. To guarantee the manual symbol lookup
worked, we only use up to v5.4.
</p><!-- l. 1469 --><p>   Unfortunately, since Linux v5.7 <code>  <span>kallsyms_lookup_name</span>
</code> is also unexported, it needs certain trick to get the address of
<code> <span>kallsyms_lookup_name</span>
</code>. If <code>  <span>CONFIG_KPROBES</span>
</code> is enabled, we can facilitate the retrieval of function addresses by means of Kprobes
to dynamically break into the specific kernel routine. Kprobes inserts a breakpoint at
the entry of function by replacing the first bytes of the probed instruction. When a
CPU hits the breakpoint, registers are stored, and the control will pass to Kprobes. It
passes the addresses of the saved registers and the Kprobe struct to the handler
you defined, then executes it. Kprobes can be registered by symbol name
or address. Within the symbol name, the address will be handled by the
kernel.
</p><!-- l. 1477 --><p>   Otherwise, specify the address of <code>  <span>sys_call_table</span>
</code> from <span><span><span>/proc/kallsyms</span></span></span> and <span><span><span>/boot/System.map</span></span></span> into
<code> <span>sym</span>
</code> parameter. Following is the sample usage for <span><span><span>/proc/kallsyms</span></span></span>:
                                                                  

                                                                  
</p>
   <pre id="verbatim-17">$ sudo grep sys_call_table /proc/kallsyms
ffffffff82000280 R x32_sys_call_table
ffffffff820013a0 R sys_call_table
ffffffff820023e0 R ia32_sys_call_table
$ sudo insmod syscall.ko sym=0xffffffff820013a0
</pre>
<!-- l. 1485 --><!-- l. 1487 --><p>   Using the address from <span><span><span>/boot/System.map</span></span></span>, be careful about <span><span><span>KASLR</span></span></span> (Kernel
Address Space Layout Randomization). <span><span><span>KASLR</span></span></span> may randomize the address of
kernel code and data at every boot time, such as the static address listed in
<span><span><span>/boot/System.map</span></span></span> will offset by some entropy. The purpose of <span><span><span>KASLR</span></span></span> is to protect
the kernel space from the attacker. Without <span><span><span>KASLR</span></span></span>, the attacker may find the target
address in the fixed address easily. Then the attacker can use return-oriented
programming to insert some malicious codes to execute or receive the target data by
a tampered pointer. <span><span><span>KASLR</span></span></span> mitigates these kinds of attacks because the attacker
cannot immediately know the target address, but a brute-force attack can still work.
If the address of a symbol in <span><span><span>/proc/kallsyms</span></span></span> is different from the address in
<span><span><span>/boot/System.map</span></span></span>, <span><span><span>KASLR</span></span></span> is enabled with the kernel, which your system running
on.
                                                                  

                                                                  
</p>
   <pre id="verbatim-18">$ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT=&#34;quiet splash&#34;
$ sudo grep sys_call_table /boot/System.map-$(uname -r)
ffffffff82000300 R sys_call_table
$ sudo grep sys_call_table /proc/kallsyms
ffffffff820013a0 R sys_call_table
# Reboot
$ sudo grep sys_call_table /boot/System.map-$(uname -r)
ffffffff82000300 R sys_call_table
$ sudo grep sys_call_table /proc/kallsyms
ffffffff86400300 R sys_call_table
</pre>
<!-- l. 1506 --><p>If <span><span><span>KASLR</span></span></span> is enabled, we have to take care of the address from <span><span><span>/proc/kallsyms</span></span></span> each
time we reboot the machine. In order to use the address from <span><span><span>/boot/System.map</span></span></span>,
make sure that <span><span><span>KASLR</span></span></span> is disabled. You can add the <span><span><span>nokaslr</span></span></span> for disabling <span><span><span>KASLR</span></span></span> in
next booting time:
                                                                  

                                                                  
</p>
   <pre id="verbatim-19">$ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT=&#34;quiet splash&#34;
$ sudo perl -i -pe &#39;m/quiet/ and s//quiet nokaslr/&#39; /etc/default/grub
$ grep quiet /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT=&#34;quiet nokaslr splash&#34;
$ sudo update-grub
</pre>
<!-- l. 1517 --><!-- l. 1519 --><p>   For more information, check out the following:
</p>
     <ul>
     <li><a href="https://lwn.net/Articles/804849/">Cook: Security things in Linux v5.3</a>
     </li>
     <li><a href="https://lwn.net/Articles/12211/">Unexporting the system call table</a>
     </li>
     <li><a href="https://lwn.net/Articles/810077/">Control-flow integrity for the kernel</a>
     </li>
     <li><a href="https://lwn.net/Articles/813350/">Unexporting kallsyms_lookup_name()</a>
     </li>
     <li><a href="https://www.kernel.org/doc/Documentation/kprobes.txt">Kernel Probes (Kprobes)</a>
     </li>
     <li><a href="https://lwn.net/Articles/569635/">Kernel address space layout randomization</a></li></ul>
<!-- l. 1530 --><p>   The source code here is an example of such a kernel module. We want to “spy” on a certain
user, and to <code>  <span>pr_info()</span>
</code> a message whenever that user opens a file. Towards this end, we
replace the system call to open a file with our own function, called
<code> <span>our_sys_openat</span>
</code>. This function checks the uid (user’s id) of the current process, and if it is equal to the uid we
                                                                  

                                                                  
spy on, it calls <code>  <span>pr_info()</span>
</code> to display the name of the file to be opened. Then, either way, it calls the original
<code> <span>openat()</span>
</code> function with the same parameters, to actually open the file.
</p><!-- l. 1536 --><p>   The <code>  <span>init_module</span>
</code> function replaces the appropriate location in
<code> <span>sys_call_table</span>
</code> and keeps the original pointer in a variable. The
<code> <span>cleanup_module</span>
</code> function uses that variable to restore everything back to normal. This approach is
dangerous, because of the possibility of two kernel modules changing the same system
call. Imagine we have two kernel modules, A and B. A’s openat system call will be
<code> <span>A_openat</span>
</code> and B’s will be <code>  <span>B_openat</span>
</code>. Now, when A is inserted into the kernel, the system call is replaced with
<code> <span>A_openat</span>
</code>, which will call the original <code>  <span>sys_openat</span>
</code> when it is done. Next, B is inserted into the kernel, which replaces the system call
with <code>  <span>B_openat</span>
</code>, which will call what it thinks is the original system call,
<code> <span>A_openat</span>
</code>, when it’s done.
</p><!-- l. 1543 --><p>   Now, if B is removed first, everything will be well — it will simply restore the system
call to <code>  <span>A_openat</span>
</code>, which calls the original. However, if A is removed and then B is removed, the
system will crash. A’s removal will restore the system call to the original,
<code> <span>sys_openat</span>
</code>, cutting B out of the loop. Then, when B is removed, it will restore the system call to what it thinks
is the original, <code>  <span>A_openat</span>
</code>, which is no longer in memory. At first glance, it appears we could solve
this particular problem by checking if the system call is equal to our
open function and if so not changing it at all (so that B won’t change
the system call when it is removed), but that will cause an even worse
problem. When A is removed, it sees that the system call was changed to
<code> <span>B_openat</span>
</code> so that it is no longer pointing to <code>  <span>A_openat</span>
</code>, so it will not restore it to <code>  <span>sys_openat</span>
</code> before it is removed from memory. Unfortunately,
<code> <span>B_openat</span>
</code> will still try to call <code>  <span>A_openat</span>
</code> which is no longer there, so that even without removing B the system would
crash.
</p><!-- l. 1551 --><p>   Note that all the related problems make syscall stealing unfeasible for
production use. In order to keep people from doing potential harmful things
<code> <span>sys_call_table</span>
</code> is no longer exported. This means, if you want to do something more than a mere
                                                                  

                                                                  
dry run of this example, you will have to patch your current kernel in order to have
<code> <span>sys_call_table</span>
</code> exported.
</p><!-- l. 1 -->
   <pre id="fancyvrb64"><a id="x1-41044r1"></a><span>1</span><span id="textcolor1492"><span>/*</span></span> 
<a id="x1-41046r2"></a><span>2</span><span id="textcolor1493"><span> * syscall.c</span></span> 
<a id="x1-41048r3"></a><span>3</span><span id="textcolor1494"><span> *</span></span> 
<a id="x1-41050r4"></a><span>4</span><span id="textcolor1495"><span> * System call &#34;stealing&#34; sample.</span></span> 
<a id="x1-41052r5"></a><span>5</span><span id="textcolor1496"><span> *</span></span> 
<a id="x1-41054r6"></a><span>6</span><span id="textcolor1497"><span> * Disables page protection at a processor level by changing the 16th bit</span></span> 
<a id="x1-41056r7"></a><span>7</span><span id="textcolor1498"><span> * in the cr0 register (could be Intel specific).</span></span> 
<a id="x1-41058r8"></a><span>8</span><span id="textcolor1499"><span> *</span></span> 
<a id="x1-41060r9"></a><span>9</span><span id="textcolor1500"><span> * Based on example by Peter Jay Salzman and</span></span> 
<a id="x1-41062r10"></a><span>10</span><span id="textcolor1501"><span> * https://bbs.archlinux.org/viewtopic.php?id=139406</span></span> 
<a id="x1-41064r11"></a><span>11</span><span id="textcolor1502"><span> */</span></span> 
<a id="x1-41066r12"></a><span>12</span> 
<a id="x1-41068r13"></a><span>13</span><span id="textcolor1503"><span>#include</span></span><span> </span><span id="textcolor1504"><span>&lt;linux/delay.h&gt;</span></span> 
<a id="x1-41070r14"></a><span>14</span><span id="textcolor1505"><span>#include</span></span><span> </span><span id="textcolor1506"><span>&lt;linux/kernel.h&gt;</span></span> 
<a id="x1-41072r15"></a><span>15</span><span id="textcolor1507"><span>#include</span></span><span> </span><span id="textcolor1508"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-41074r16"></a><span>16</span><span id="textcolor1509"><span>#include</span></span><span> </span><span id="textcolor1510"><span>&lt;linux/moduleparam.h&gt; /* which will have params */</span></span> 
<a id="x1-41076r17"></a><span>17</span><span id="textcolor1511"><span>#include</span></span><span> </span><span id="textcolor1512"><span>&lt;linux/unistd.h&gt; /* The list of system calls */</span></span> 
<a id="x1-41078r18"></a><span>18</span><span id="textcolor1513"><span>#include</span></span><span> </span><span id="textcolor1514"><span>&lt;linux/cred.h&gt; /* For current_uid() */</span></span> 
<a id="x1-41080r19"></a><span>19</span><span id="textcolor1515"><span>#include</span></span><span> </span><span id="textcolor1516"><span>&lt;linux/uidgid.h&gt; /* For __kuid_val() */</span></span> 
<a id="x1-41082r20"></a><span>20</span><span id="textcolor1517"><span>#include</span></span><span> </span><span id="textcolor1518"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-41084r21"></a><span>21</span> 
<a id="x1-41086r22"></a><span>22</span><span id="textcolor1519"><span>/* For the current (process) structure, we need this to know who the</span></span> 
<a id="x1-41088r23"></a><span>23</span><span id="textcolor1520"><span> * current user is.</span></span> 
<a id="x1-41090r24"></a><span>24</span><span id="textcolor1521"><span> */</span></span> 
<a id="x1-41092r25"></a><span>25</span><span id="textcolor1522"><span>#include</span></span><span> </span><span id="textcolor1523"><span>&lt;linux/sched.h&gt;</span></span> 
<a id="x1-41094r26"></a><span>26</span><span id="textcolor1524"><span>#include</span></span><span> </span><span id="textcolor1525"><span>&lt;linux/uaccess.h&gt;</span></span> 
<a id="x1-41096r27"></a><span>27</span> 
<a id="x1-41098r28"></a><span>28</span><span id="textcolor1526"><span>/* The way we access &#34;sys_call_table&#34; varies as kernel internal changes.</span></span> 
<a id="x1-41100r29"></a><span>29</span><span id="textcolor1527"><span> * - Prior to v5.4 : manual symbol lookup</span></span> 
<a id="x1-41102r30"></a><span>30</span><span id="textcolor1528"><span> * - v5.5 to v5.6  : use kallsyms_lookup_name()</span></span> 
<a id="x1-41104r31"></a><span>31</span><span id="textcolor1529"><span> * - v5.7+         : Kprobes or specific kernel module parameter</span></span> 
<a id="x1-41106r32"></a><span>32</span><span id="textcolor1530"><span> */</span></span> 
<a id="x1-41108r33"></a><span>33</span> 
<a id="x1-41110r34"></a><span>34</span><span id="textcolor1531"><span>/* The in-kernel calls to the ksys_close() syscall were removed in Linux v5.11+.</span></span> 
<a id="x1-41112r35"></a><span>35</span><span id="textcolor1532"><span> */</span></span> 
<a id="x1-41114r36"></a><span>36</span><span id="textcolor1533"><span>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(5, 7, 0))</span></span> 
<a id="x1-41116r37"></a><span>37</span> 
<a id="x1-41118r38"></a><span>38</span><span id="textcolor1534"><span>#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(5, 4, 0)</span></span> 
<a id="x1-41120r39"></a><span>39</span><span id="textcolor1535"><span>#define HAVE_KSYS_CLOSE 1</span></span> 
<a id="x1-41122r40"></a><span>40</span><span id="textcolor1536"><span>#include</span></span><span> </span><span id="textcolor1537"><span>&lt;linux/syscalls.h&gt; /* For ksys_close() */</span></span> 
<a id="x1-41124r41"></a><span>41</span><span id="textcolor1538"><span>#else</span></span> 
<a id="x1-41126r42"></a><span>42</span><span id="textcolor1539"><span>#include</span></span><span> </span><span id="textcolor1540"><span>&lt;linux/kallsyms.h&gt; /* For kallsyms_lookup_name */</span></span> 
<a id="x1-41128r43"></a><span>43</span><span id="textcolor1541"><span>#endif</span></span> 
<a id="x1-41130r44"></a><span>44</span> 
<a id="x1-41132r45"></a><span>45</span><span id="textcolor1542"><span>#else</span></span> 
<a id="x1-41134r46"></a><span>46</span> 
<a id="x1-41136r47"></a><span>47</span><span id="textcolor1543"><span>#if defined(CONFIG_KPROBES)</span></span> 
<a id="x1-41138r48"></a><span>48</span><span id="textcolor1544"><span>#define HAVE_KPROBES 1</span></span> 
<a id="x1-41140r49"></a><span>49</span><span id="textcolor1545"><span>#include</span></span><span> </span><span id="textcolor1546"><span>&lt;linux/kprobes.h&gt;</span></span> 
<a id="x1-41142r50"></a><span>50</span><span id="textcolor1547"><span>#else</span></span> 
<a id="x1-41144r51"></a><span>51</span><span id="textcolor1548"><span>#define HAVE_PARAM 1</span></span> 
<a id="x1-41146r52"></a><span>52</span><span id="textcolor1549"><span>#include</span></span><span> </span><span id="textcolor1550"><span>&lt;linux/kallsyms.h&gt; /* For sprint_symbol */</span></span> 
<a id="x1-41148r53"></a><span>53</span><span id="textcolor1551"><span>/* The address of the sys_call_table, which can be obtained with looking up</span></span> 
<a id="x1-41150r54"></a><span>54</span><span id="textcolor1552"><span> * &#34;/boot/System.map&#34; or &#34;/proc/kallsyms&#34;. When the kernel version is v5.7+,</span></span> 
<a id="x1-41152r55"></a><span>55</span><span id="textcolor1553"><span> * without CONFIG_KPROBES, you can input the parameter or the module will look</span></span> 
<a id="x1-41154r56"></a><span>56</span><span id="textcolor1554"><span> * up all the memory.</span></span> 
<a id="x1-41156r57"></a><span>57</span><span id="textcolor1555"><span> */</span></span> 
<a id="x1-41158r58"></a><span>58</span><span id="textcolor1556"><span>static</span></span><span> </span><span id="textcolor1557"><span>unsigned</span></span><span> </span><span id="textcolor1558"><span>long</span></span><span> sym = 0;</span> 
<a id="x1-41160r59"></a><span>59</span><span>module_param(sym, ulong, 0644);</span> 
<a id="x1-41162r60"></a><span>60</span><span id="textcolor1559"><span>#endif </span></span><span id="textcolor1560"><span>/* CONFIG_KPROBES */</span></span> 
<a id="x1-41164r61"></a><span>61</span> 
<a id="x1-41166r62"></a><span>62</span><span id="textcolor1561"><span>#endif </span></span><span id="textcolor1562"><span>/* Version &lt; v5.7 */</span></span> 
<a id="x1-41168r63"></a><span>63</span> 
<a id="x1-41170r64"></a><span>64</span><span id="textcolor1563"><span>static</span></span><span> </span><span id="textcolor1564"><span>unsigned</span></span><span> </span><span id="textcolor1565"><span>long</span></span><span> **sys_call_table;</span> 
<a id="x1-41172r65"></a><span>65</span> 
<a id="x1-41174r66"></a><span>66</span><span id="textcolor1566"><span>/* UID we want to spy on - will be filled from the command line. */</span></span> 
<a id="x1-41176r67"></a><span>67</span><span id="textcolor1567"><span>static</span></span><span> </span><span id="textcolor1568"><span>uid_t</span></span><span> uid = -1;</span> 
<a id="x1-41178r68"></a><span>68</span><span>module_param(uid, </span><span id="textcolor1569"><span>int</span></span><span>, 0644);</span> 
<a id="x1-41180r69"></a><span>69</span> 
<a id="x1-41182r70"></a><span>70</span><span id="textcolor1570"><span>/* A pointer to the original system call. The reason we keep this, rather</span></span> 
<a id="x1-41184r71"></a><span>71</span><span id="textcolor1571"><span> * than call the original function (sys_openat), is because somebody else</span></span> 
<a id="x1-41186r72"></a><span>72</span><span id="textcolor1572"><span> * might have replaced the system call before us. Note that this is not</span></span> 
<a id="x1-41188r73"></a><span>73</span><span id="textcolor1573"><span> * 100% safe, because if another module replaced sys_openat before us,</span></span> 
<a id="x1-41190r74"></a><span>74</span><span id="textcolor1574"><span> * then when we are inserted, we will call the function in that module -</span></span> 
<a id="x1-41192r75"></a><span>75</span><span id="textcolor1575"><span> * and it might be removed before we are.</span></span> 
<a id="x1-41194r76"></a><span>76</span><span id="textcolor1576"><span> *</span></span> 
<a id="x1-41196r77"></a><span>77</span><span id="textcolor1577"><span> * Another reason for this is that we can not get sys_openat.</span></span> 
<a id="x1-41198r78"></a><span>78</span><span id="textcolor1578"><span> * It is a static variable, so it is not exported.</span></span> 
<a id="x1-41200r79"></a><span>79</span><span id="textcolor1579"><span> */</span></span> 
<a id="x1-41202r80"></a><span>80</span><span id="textcolor1580"><span>#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span> 
<a id="x1-41204r81"></a><span>81</span><span id="textcolor1581"><span>static</span></span><span> asmlinkage long (*original_call)(</span><span id="textcolor1582"><span>const</span></span><span> </span><span id="textcolor1583"><span>struct</span></span><span> pt_regs *);</span> 
<a id="x1-41206r82"></a><span>82</span><span id="textcolor1584"><span>#else</span></span> 
<a id="x1-41208r83"></a><span>83</span><span id="textcolor1585"><span>static</span></span><span> asmlinkage long (*original_call)(</span><span id="textcolor1586"><span>int</span></span><span>, </span><span id="textcolor1587"><span>const</span></span><span> </span><span id="textcolor1588"><span>char</span></span><span> __user *, </span><span id="textcolor1589"><span>int</span></span><span>, umode_t);</span> 
<a id="x1-41210r84"></a><span>84</span><span id="textcolor1590"><span>#endif</span></span> 
<a id="x1-41212r85"></a><span>85</span> 
<a id="x1-41214r86"></a><span>86</span><span id="textcolor1591"><span>/* The function we will replace sys_openat (the function called when you</span></span> 
<a id="x1-41216r87"></a><span>87</span><span id="textcolor1592"><span> * call the open system call) with. To find the exact prototype, with</span></span> 
<a id="x1-41218r88"></a><span>88</span><span id="textcolor1593"><span> * the number and type of arguments, we find the original function first</span></span> 
<a id="x1-41220r89"></a><span>89</span><span id="textcolor1594"><span> * (it is at fs/open.c).</span></span> 
<a id="x1-41222r90"></a><span>90</span><span id="textcolor1595"><span> *</span></span> 
<a id="x1-41224r91"></a><span>91</span><span id="textcolor1596"><span> * In theory, this means that we are tied to the current version of the</span></span> 
<a id="x1-41226r92"></a><span>92</span><span id="textcolor1597"><span> * kernel. In practice, the system calls almost never change (it would</span></span> 
<a id="x1-41228r93"></a><span>93</span><span id="textcolor1598"><span> * wreck havoc and require programs to be recompiled, since the system</span></span> 
<a id="x1-41230r94"></a><span>94</span><span id="textcolor1599"><span> * calls are the interface between the kernel and the processes).</span></span> 
<a id="x1-41232r95"></a><span>95</span><span id="textcolor1600"><span> */</span></span> 
<a id="x1-41234r96"></a><span>96</span><span id="textcolor1601"><span>#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span> 
<a id="x1-41236r97"></a><span>97</span><span id="textcolor1602"><span>static</span></span><span> asmlinkage </span><span id="textcolor1603"><span>long</span></span><span> our_sys_openat(</span><span id="textcolor1604"><span>const</span></span><span> </span><span id="textcolor1605"><span>struct</span></span><span> pt_regs *regs)</span> 
<a id="x1-41238r98"></a><span>98</span><span id="textcolor1606"><span>#else</span></span> 
<a id="x1-41240r99"></a><span>99</span><span id="textcolor1607"><span>static</span></span><span> asmlinkage </span><span id="textcolor1608"><span>long</span></span><span> our_sys_openat(</span><span id="textcolor1609"><span>int</span></span><span> dfd, </span><span id="textcolor1610"><span>const</span></span><span> </span><span id="textcolor1611"><span>char</span></span><span> __user *filename,</span> 
<a id="x1-41242r100"></a><span>100</span><span>                                      </span><span id="textcolor1612"><span>int</span></span><span> flags, umode_t mode)</span> 
<a id="x1-41244r101"></a><span>101</span><span id="textcolor1613"><span>#endif</span></span> 
<a id="x1-41246r102"></a><span>102</span><span>{</span> 
<a id="x1-41248r103"></a><span>103</span><span>    </span><span id="textcolor1614"><span>int</span></span><span> i = 0;</span> 
<a id="x1-41250r104"></a><span>104</span><span>    </span><span id="textcolor1615"><span>char</span></span><span> ch;</span> 
<a id="x1-41252r105"></a><span>105</span> 
<a id="x1-41254r106"></a><span>106</span><span>    </span><span id="textcolor1616"><span>if</span></span><span> (__kuid_val(current_uid()) != uid)</span> 
<a id="x1-41256r107"></a><span>107</span><span>        </span><span id="textcolor1617"><span>goto</span></span><span> orig_call;</span> 
<a id="x1-41258r108"></a><span>108</span> 
<a id="x1-41260r109"></a><span>109</span><span>    </span><span id="textcolor1618"><span>/* Report the file, if relevant */</span></span> 
<a id="x1-41262r110"></a><span>110</span><span>    pr_info(</span><span id="textcolor1619"><span>&#34;Opened file by %d: &#34;</span></span><span>, uid);</span> 
<a id="x1-41264r111"></a><span>111</span><span>    </span><span id="textcolor1620"><span>do</span></span><span> {</span> 
<a id="x1-41266r112"></a><span>112</span><span id="textcolor1621"><span>#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span> 
<a id="x1-41268r113"></a><span>113</span><span>        get_user(ch, (</span><span id="textcolor1622"><span>char</span></span><span> __user *)regs-&gt;si + i);</span> 
<a id="x1-41270r114"></a><span>114</span><span id="textcolor1623"><span>#else</span></span> 
<a id="x1-41272r115"></a><span>115</span><span>        get_user(ch, (</span><span id="textcolor1624"><span>char</span></span><span> __user *)filename + i);</span> 
<a id="x1-41274r116"></a><span>116</span><span id="textcolor1625"><span>#endif</span></span> 
<a id="x1-41276r117"></a><span>117</span><span>        i++;</span> 
<a id="x1-41278r118"></a><span>118</span><span>        pr_info(</span><span id="textcolor1626"><span>&#34;%c&#34;</span></span><span>, ch);</span> 
<a id="x1-41280r119"></a><span>119</span><span>    } </span><span id="textcolor1627"><span>while</span></span><span> (ch != 0);</span> 
<a id="x1-41282r120"></a><span>120</span><span>    pr_info(</span><span id="textcolor1628"><span>&#34;</span></span><span id="textcolor1629"><span>\n</span></span><span id="textcolor1630"><span>&#34;</span></span><span>);</span> 
<a id="x1-41284r121"></a><span>121</span> 
<a id="x1-41286r122"></a><span>122</span><span>orig_call:</span> 
<a id="x1-41288r123"></a><span>123</span><span>    </span><span id="textcolor1631"><span>/* Call the original sys_openat - otherwise, we lose the ability to</span></span> 
<a id="x1-41290r124"></a><span>124</span><span id="textcolor1632"><span>     * open files.</span></span> 
<a id="x1-41292r125"></a><span>125</span><span id="textcolor1633"><span>     */</span></span> 
<a id="x1-41294r126"></a><span>126</span><span id="textcolor1634"><span>#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span> 
<a id="x1-41296r127"></a><span>127</span><span>    </span><span id="textcolor1635"><span>return</span></span><span> original_call(regs);</span> 
<a id="x1-41298r128"></a><span>128</span><span id="textcolor1636"><span>#else</span></span> 
<a id="x1-41300r129"></a><span>129</span><span>    </span><span id="textcolor1637"><span>return</span></span><span> original_call(dfd, filename, flags, mode);</span> 
<a id="x1-41302r130"></a><span>130</span><span id="textcolor1638"><span>#endif</span></span> 
<a id="x1-41304r131"></a><span>131</span><span>}</span> 
<a id="x1-41306r132"></a><span>132</span> 
<a id="x1-41308r133"></a><span>133</span><span id="textcolor1639"><span>static</span></span><span> </span><span id="textcolor1640"><span>unsigned</span></span><span> </span><span id="textcolor1641"><span>long</span></span><span> **acquire_sys_call_table(</span><span id="textcolor1642"><span>void</span></span><span>)</span> 
<a id="x1-41310r134"></a><span>134</span><span>{</span> 
<a id="x1-41312r135"></a><span>135</span><span id="textcolor1643"><span>#ifdef HAVE_KSYS_CLOSE</span></span> 
<a id="x1-41314r136"></a><span>136</span><span>    </span><span id="textcolor1644"><span>unsigned</span></span><span> </span><span id="textcolor1645"><span>long</span></span><span> </span><span id="textcolor1646"><span>int</span></span><span> offset = PAGE_OFFSET;</span> 
<a id="x1-41316r137"></a><span>137</span><span>    </span><span id="textcolor1647"><span>unsigned</span></span><span> </span><span id="textcolor1648"><span>long</span></span><span> **sct;</span> 
<a id="x1-41318r138"></a><span>138</span> 
<a id="x1-41320r139"></a><span>139</span><span>    </span><span id="textcolor1649"><span>while</span></span><span> (offset &lt; ULLONG_MAX) {</span> 
<a id="x1-41322r140"></a><span>140</span><span>        sct = (</span><span id="textcolor1650"><span>unsigned</span></span><span> </span><span id="textcolor1651"><span>long</span></span><span> **)offset;</span> 
<a id="x1-41324r141"></a><span>141</span> 
<a id="x1-41326r142"></a><span>142</span><span>        </span><span id="textcolor1652"><span>if</span></span><span> (sct[__NR_close] == (</span><span id="textcolor1653"><span>unsigned</span></span><span> </span><span id="textcolor1654"><span>long</span></span><span> *)ksys_close)</span> 
<a id="x1-41328r143"></a><span>143</span><span>            </span><span id="textcolor1655"><span>return</span></span><span> sct;</span> 
<a id="x1-41330r144"></a><span>144</span> 
<a id="x1-41332r145"></a><span>145</span><span>        offset += </span><span id="textcolor1656"><span>sizeof</span></span><span>(</span><span id="textcolor1657"><span>void</span></span><span> *);</span> 
<a id="x1-41334r146"></a><span>146</span><span>    }</span> 
<a id="x1-41336r147"></a><span>147</span> 
<a id="x1-41338r148"></a><span>148</span><span>    </span><span id="textcolor1658"><span>return</span></span><span> NULL;</span> 
<a id="x1-41340r149"></a><span>149</span><span id="textcolor1659"><span>#endif</span></span> 
<a id="x1-41342r150"></a><span>150</span> 
<a id="x1-41344r151"></a><span>151</span><span id="textcolor1660"><span>#ifdef HAVE_PARAM</span></span> 
<a id="x1-41346r152"></a><span>152</span><span>    </span><span id="textcolor1661"><span>const</span></span><span> </span><span id="textcolor1662"><span>char</span></span><span> sct_name[15] = </span><span id="textcolor1663"><span>&#34;sys_call_table&#34;</span></span><span>;</span> 
<a id="x1-41348r153"></a><span>153</span><span>    </span><span id="textcolor1664"><span>char</span></span><span> symbol[40] = { 0 };</span> 
<a id="x1-41350r154"></a><span>154</span> 
<a id="x1-41352r155"></a><span>155</span><span>    </span><span id="textcolor1665"><span>if</span></span><span> (sym == 0) {</span> 
<a id="x1-41354r156"></a><span>156</span><span>        pr_alert(</span><span id="textcolor1666"><span>&#34;For Linux v5.7+, Kprobes is the preferable way to get &#34;</span></span> 
<a id="x1-41356r157"></a><span>157</span><span>                 </span><span id="textcolor1667"><span>&#34;symbol.</span></span><span id="textcolor1668"><span>\n</span></span><span id="textcolor1669"><span>&#34;</span></span><span>);</span> 
<a id="x1-41358r158"></a><span>158</span><span>        pr_info(</span><span id="textcolor1670"><span>&#34;If Kprobes is absent, you have to specify the address of &#34;</span></span> 
<a id="x1-41360r159"></a><span>159</span><span>                </span><span id="textcolor1671"><span>&#34;sys_call_table symbol</span></span><span id="textcolor1672"><span>\n</span></span><span id="textcolor1673"><span>&#34;</span></span><span>);</span> 
<a id="x1-41362r160"></a><span>160</span><span>        pr_info(</span><span id="textcolor1674"><span>&#34;by /boot/System.map or /proc/kallsyms, which contains all the &#34;</span></span> 
<a id="x1-41364r161"></a><span>161</span><span>                </span><span id="textcolor1675"><span>&#34;symbol addresses, into sym parameter.</span></span><span id="textcolor1676"><span>\n</span></span><span id="textcolor1677"><span>&#34;</span></span><span>);</span> 
<a id="x1-41366r162"></a><span>162</span><span>        </span><span id="textcolor1678"><span>return</span></span><span> NULL;</span> 
<a id="x1-41368r163"></a><span>163</span><span>    }</span> 
<a id="x1-41370r164"></a><span>164</span><span>    sprint_symbol(symbol, sym);</span> 
<a id="x1-41372r165"></a><span>165</span><span>    </span><span id="textcolor1679"><span>if</span></span><span> (!strncmp(sct_name, symbol, </span><span id="textcolor1680"><span>sizeof</span></span><span>(sct_name) - 1))</span> 
<a id="x1-41374r166"></a><span>166</span><span>        </span><span id="textcolor1681"><span>return</span></span><span> (</span><span id="textcolor1682"><span>unsigned</span></span><span> </span><span id="textcolor1683"><span>long</span></span><span> **)sym;</span> 
<a id="x1-41376r167"></a><span>167</span> 
<a id="x1-41378r168"></a><span>168</span><span>    </span><span id="textcolor1684"><span>return</span></span><span> NULL;</span> 
<a id="x1-41380r169"></a><span>169</span><span id="textcolor1685"><span>#endif</span></span> 
<a id="x1-41382r170"></a><span>170</span> 
<a id="x1-41384r171"></a><span>171</span><span id="textcolor1686"><span>#ifdef HAVE_KPROBES</span></span> 
<a id="x1-41386r172"></a><span>172</span><span>    </span><span id="textcolor1687"><span>unsigned</span></span><span> </span><span id="textcolor1688"><span>long</span></span><span> (*kallsyms_lookup_name)(</span><span id="textcolor1689"><span>const</span></span><span> </span><span id="textcolor1690"><span>char</span></span><span> *name);</span> 
<a id="x1-41388r173"></a><span>173</span><span>    </span><span id="textcolor1691"><span>struct</span></span><span> kprobe kp = {</span> 
<a id="x1-41390r174"></a><span>174</span><span>        .symbol_name = </span><span id="textcolor1692"><span>&#34;kallsyms_lookup_name&#34;</span></span><span>,</span> 
<a id="x1-41392r175"></a><span>175</span><span>    };</span> 
<a id="x1-41394r176"></a><span>176</span> 
<a id="x1-41396r177"></a><span>177</span><span>    </span><span id="textcolor1693"><span>if</span></span><span> (register_kprobe(&amp;kp) &lt; 0)</span> 
<a id="x1-41398r178"></a><span>178</span><span>        </span><span id="textcolor1694"><span>return</span></span><span> NULL;</span> 
<a id="x1-41400r179"></a><span>179</span><span>    kallsyms_lookup_name = (</span><span id="textcolor1695"><span>unsigned</span></span><span> </span><span id="textcolor1696"><span>long</span></span><span> (*)(</span><span id="textcolor1697"><span>const</span></span><span> </span><span id="textcolor1698"><span>char</span></span><span> *name))kp.addr;</span> 
<a id="x1-41402r180"></a><span>180</span><span>    unregister_kprobe(&amp;kp);</span> 
<a id="x1-41404r181"></a><span>181</span><span id="textcolor1699"><span>#endif</span></span> 
<a id="x1-41406r182"></a><span>182</span> 
<a id="x1-41408r183"></a><span>183</span><span>    </span><span id="textcolor1700"><span>return</span></span><span> (</span><span id="textcolor1701"><span>unsigned</span></span><span> </span><span id="textcolor1702"><span>long</span></span><span> **)kallsyms_lookup_name(</span><span id="textcolor1703"><span>&#34;sys_call_table&#34;</span></span><span>);</span> 
<a id="x1-41410r184"></a><span>184</span><span>}</span> 
<a id="x1-41412r185"></a><span>185</span> 
<a id="x1-41414r186"></a><span>186</span><span id="textcolor1704"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 3, 0)</span></span> 
<a id="x1-41416r187"></a><span>187</span><span id="textcolor1705"><span>static</span></span><span> </span><span id="textcolor1706"><span>inline</span></span><span> </span><span id="textcolor1707"><span>void</span></span><span> __write_cr0(</span><span id="textcolor1708"><span>unsigned</span></span><span> </span><span id="textcolor1709"><span>long</span></span><span> cr0)</span> 
<a id="x1-41418r188"></a><span>188</span><span>{</span> 
<a id="x1-41420r189"></a><span>189</span><span>    </span><span id="textcolor1710"><span>asm</span></span><span> </span><span id="textcolor1711"><span>volatile</span></span><span>(</span><span id="textcolor1712"><span>&#34;mov %0,%%cr0&#34;</span></span><span> : </span><span id="textcolor1713"><span>&#34;+r&#34;</span></span><span>(cr0) : : </span><span id="textcolor1714"><span>&#34;memory&#34;</span></span><span>);</span> 
<a id="x1-41422r190"></a><span>190</span><span>}</span> 
<a id="x1-41424r191"></a><span>191</span><span id="textcolor1715"><span>#else</span></span> 
<a id="x1-41426r192"></a><span>192</span><span id="textcolor1716"><span>#define __write_cr0 write_cr0</span></span> 
<a id="x1-41428r193"></a><span>193</span><span id="textcolor1717"><span>#endif</span></span> 
<a id="x1-41430r194"></a><span>194</span> 
<a id="x1-41432r195"></a><span>195</span><span id="textcolor1718"><span>static</span></span><span> </span><span id="textcolor1719"><span>void</span></span><span> enable_write_protection(</span><span id="textcolor1720"><span>void</span></span><span>)</span> 
<a id="x1-41434r196"></a><span>196</span><span>{</span> 
<a id="x1-41436r197"></a><span>197</span><span>    </span><span id="textcolor1721"><span>unsigned</span></span><span> </span><span id="textcolor1722"><span>long</span></span><span> cr0 = read_cr0();</span> 
<a id="x1-41438r198"></a><span>198</span><span>    set_bit(16, &amp;cr0);</span> 
<a id="x1-41440r199"></a><span>199</span><span>    __write_cr0(cr0);</span> 
<a id="x1-41442r200"></a><span>200</span><span>}</span> 
<a id="x1-41444r201"></a><span>201</span> 
<a id="x1-41446r202"></a><span>202</span><span id="textcolor1723"><span>static</span></span><span> </span><span id="textcolor1724"><span>void</span></span><span> disable_write_protection(</span><span id="textcolor1725"><span>void</span></span><span>)</span> 
<a id="x1-41448r203"></a><span>203</span><span>{</span> 
<a id="x1-41450r204"></a><span>204</span><span>    </span><span id="textcolor1726"><span>unsigned</span></span><span> </span><span id="textcolor1727"><span>long</span></span><span> cr0 = read_cr0();</span> 
<a id="x1-41452r205"></a><span>205</span><span>    clear_bit(16, &amp;cr0);</span> 
<a id="x1-41454r206"></a><span>206</span><span>    __write_cr0(cr0);</span> 
<a id="x1-41456r207"></a><span>207</span><span>}</span> 
<a id="x1-41458r208"></a><span>208</span> 
<a id="x1-41460r209"></a><span>209</span><span id="textcolor1728"><span>static</span></span><span> </span><span id="textcolor1729"><span>int</span></span><span> __init syscall_start(</span><span id="textcolor1730"><span>void</span></span><span>)</span> 
<a id="x1-41462r210"></a><span>210</span><span>{</span> 
<a id="x1-41464r211"></a><span>211</span><span>    </span><span id="textcolor1731"><span>if</span></span><span> (!(sys_call_table = acquire_sys_call_table()))</span> 
<a id="x1-41466r212"></a><span>212</span><span>        </span><span id="textcolor1732"><span>return</span></span><span> -1;</span> 
<a id="x1-41468r213"></a><span>213</span> 
<a id="x1-41470r214"></a><span>214</span><span>    disable_write_protection();</span> 
<a id="x1-41472r215"></a><span>215</span> 
<a id="x1-41474r216"></a><span>216</span><span>    </span><span id="textcolor1733"><span>/* keep track of the original open function */</span></span> 
<a id="x1-41476r217"></a><span>217</span><span>    original_call = (</span><span id="textcolor1734"><span>void</span></span><span> *)sys_call_table[__NR_openat];</span> 
<a id="x1-41478r218"></a><span>218</span> 
<a id="x1-41480r219"></a><span>219</span><span>    </span><span id="textcolor1735"><span>/* use our openat function instead */</span></span> 
<a id="x1-41482r220"></a><span>220</span><span>    sys_call_table[__NR_openat] = (</span><span id="textcolor1736"><span>unsigned</span></span><span> </span><span id="textcolor1737"><span>long</span></span><span> *)our_sys_openat;</span> 
<a id="x1-41484r221"></a><span>221</span> 
<a id="x1-41486r222"></a><span>222</span><span>    enable_write_protection();</span> 
<a id="x1-41488r223"></a><span>223</span> 
<a id="x1-41490r224"></a><span>224</span><span>    pr_info(</span><span id="textcolor1738"><span>&#34;Spying on UID:%d</span></span><span id="textcolor1739"><span>\n</span></span><span id="textcolor1740"><span>&#34;</span></span><span>, uid);</span> 
<a id="x1-41492r225"></a><span>225</span> 
<a id="x1-41494r226"></a><span>226</span><span>    </span><span id="textcolor1741"><span>return</span></span><span> 0;</span> 
<a id="x1-41496r227"></a><span>227</span><span>}</span> 
<a id="x1-41498r228"></a><span>228</span> 
<a id="x1-41500r229"></a><span>229</span><span id="textcolor1742"><span>static</span></span><span> </span><span id="textcolor1743"><span>void</span></span><span> __exit syscall_end(</span><span id="textcolor1744"><span>void</span></span><span>)</span> 
<a id="x1-41502r230"></a><span>230</span><span>{</span> 
<a id="x1-41504r231"></a><span>231</span><span>    </span><span id="textcolor1745"><span>if</span></span><span> (!sys_call_table)</span> 
<a id="x1-41506r232"></a><span>232</span><span>        </span><span id="textcolor1746"><span>return</span></span><span>;</span> 
<a id="x1-41508r233"></a><span>233</span> 
<a id="x1-41510r234"></a><span>234</span><span>    </span><span id="textcolor1747"><span>/* Return the system call back to normal */</span></span> 
<a id="x1-41512r235"></a><span>235</span><span>    </span><span id="textcolor1748"><span>if</span></span><span> (sys_call_table[__NR_openat] != (</span><span id="textcolor1749"><span>unsigned</span></span><span> </span><span id="textcolor1750"><span>long</span></span><span> *)our_sys_openat) {</span> 
<a id="x1-41514r236"></a><span>236</span><span>        pr_alert(</span><span id="textcolor1751"><span>&#34;Somebody else also played with the &#34;</span></span><span>);</span> 
<a id="x1-41516r237"></a><span>237</span><span>        pr_alert(</span><span id="textcolor1752"><span>&#34;open system call</span></span><span id="textcolor1753"><span>\n</span></span><span id="textcolor1754"><span>&#34;</span></span><span>);</span> 
<a id="x1-41518r238"></a><span>238</span><span>        pr_alert(</span><span id="textcolor1755"><span>&#34;The system may be left in &#34;</span></span><span>);</span> 
<a id="x1-41520r239"></a><span>239</span><span>        pr_alert(</span><span id="textcolor1756"><span>&#34;an unstable state.</span></span><span id="textcolor1757"><span>\n</span></span><span id="textcolor1758"><span>&#34;</span></span><span>);</span> 
<a id="x1-41522r240"></a><span>240</span><span>    }</span> 
<a id="x1-41524r241"></a><span>241</span> 
<a id="x1-41526r242"></a><span>242</span><span>    disable_write_protection();</span> 
<a id="x1-41528r243"></a><span>243</span><span>    sys_call_table[__NR_openat] = (</span><span id="textcolor1759"><span>unsigned</span></span><span> </span><span id="textcolor1760"><span>long</span></span><span> *)original_call;</span> 
<a id="x1-41530r244"></a><span>244</span><span>    enable_write_protection();</span> 
<a id="x1-41532r245"></a><span>245</span> 
<a id="x1-41534r246"></a><span>246</span><span>    msleep(2000);</span> 
<a id="x1-41536r247"></a><span>247</span><span>}</span> 
<a id="x1-41538r248"></a><span>248</span> 
<a id="x1-41540r249"></a><span>249</span><span>module_init(syscall_start);</span> 
<a id="x1-41542r250"></a><span>250</span><span>module_exit(syscall_end);</span> 
<a id="x1-41544r251"></a><span>251</span> 
<a id="x1-41546r252"></a><span>252</span><span>MODULE_LICENSE(</span><span id="textcolor1761"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1557 -->
   <h3 id="blocking-processes-and-threads"><span>11   </span> <a id="x1-4200011"></a>Blocking Processes and threads</h3>
<!-- l. 1559 -->
   <h4 id="sleep"><span>11.1   </span> <a id="x1-4300011.1"></a>Sleep</h4>
<!-- l. 1561 --><p>What do you do when somebody asks you for something you can not do right
away? If you are a human being and you are bothered by a human being, the
only thing you can say is: &#34;<span>Not right now, I’m busy. Go away!</span>&#34;. But if you
are a kernel module and you are bothered by a process, you have another
possibility. You can put the process to sleep until you can service it. After all,
processes are being put to sleep by the kernel and woken up all the time (that
is the way multiple processes appear to run on the same time on a single
CPU).
</p><!-- l. 1567 --><p>   This kernel module is an example of this. The file (called <span><span><span>/proc/sleep</span></span></span>) can only
be opened by a single process at a time. If the file is already open, the kernel module
calls <code>  <span>wait_event_interruptible</span>
</code>. The easiest way to keep a file open is to open it with:
</p><!-- l. 1 -->
   <pre id="fancyvrb65"><a id="x1-43004r1"></a><span>1</span><span>tail -f</span></pre>
<!-- l. 1576 --><p>   This function changes the status of the task (a task is the kernel data structure
which holds information about a process and the system call it is in, if any) to
<code> <span>TASK_INTERRUPTIBLE</span>
</code>, which means that the task will not run until it is woken up somehow, and adds it to
WaitQ, the queue of tasks waiting to access the file. Then, the function calls the
scheduler to context switch to a different process, one which has some use for the
CPU.
</p><!-- l. 1580 --><p>   When a process is done with the file, it closes it, and
<code> <span>module_close</span>
</code> is called. That function wakes up all the processes in the queue (there’s no
mechanism to only wake up one of them). It then returns and the process which just
                                                                  

                                                                  
closed the file can continue to run. In time, the scheduler decides that that
process has had enough and gives control of the CPU to another process.
Eventually, one of the processes which was in the queue will be given control
of the CPU by the scheduler. It starts at the point right after the call to
<code> <span>wait_event_interruptible</span>
</code>.
</p><!-- l. 1587 --><p>   This means that the process is still in kernel mode - as far as the process
is concerned, it issued the open system call and the system call has not
returned yet. The process does not know somebody else used the CPU for
most of the time between the moment it issued the call and the moment it
returned.
</p><!-- l. 1590 --><p>   It can then proceed to set a global variable to tell all the other processes that the
file is still open and go on with its life. When the other processes get a piece of the
CPU, they’ll see that global variable and go back to sleep.
</p><!-- l. 1593 --><p>   So we will use <code>  <span>tail -f</span>
</code> to keep the file open in the background, while trying to access it with another
process (again in the background, so that we need not switch to a different vt). As
soon as the first background process is killed with kill %1 , the second is woken up, is
able to access the file and finally terminates.
</p><!-- l. 1596 --><p>   To make our life more interesting, <code>  <span>module_close</span>
</code> does not have a monopoly on waking up the processes which wait to access the file.
A signal, such as <span>Ctrl +c </span>(<span>SIGINT</span>) can also wake up a process. This is because we
used <code>  <span>wait_event_interruptible</span>
</code>. We could have used <code>  <span>wait_event</span>
</code> instead, but that would have resulted in extremely angry users whose <span>Ctrl+c</span>’s are
ignored.
</p><!-- l. 1600 --><p>   In that case, we want to return with
<code> <span>-EINTR</span>
</code> immediately. This is important so users can, for example, kill the process before it
receives the file.
</p><!-- l. 1602 --><p>   There is one more point to remember. Some times processes don’t want to sleep, they want
either to get what they want immediately, or to be told it cannot be done. Such processes
use the <code>  <span>O_NONBLOCK</span>
</code> flag when opening the file. The kernel is supposed to respond by returning with the error
code <code>  <span>-EAGAIN</span>
</code> from operations which would otherwise block, such as opening the file in this example. The
program <code>  <span>cat_nonblock</span>
</code>, available in the <span><span><span>examples/other</span></span></span> directory, can be used to open a file with
<code> <span>O_NONBLOCK</span>
</code>.
                                                                  

                                                                  
</p>
   <pre id="verbatim-20">$ sudo insmod sleep.ko
$ cat_nonblock /proc/sleep
Last input:
$ tail -f /proc/sleep &amp;
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
tail: /proc/sleep: file truncated
[1] 6540
$ cat_nonblock /proc/sleep
Open would block
$ kill %1
[1]+  Terminated              tail -f /proc/sleep
$ cat_nonblock /proc/sleep
Last input:
$
</pre>
<!-- l. 1627 --><!-- l. 1 -->
   <pre id="fancyvrb66"><a id="x1-43018r1"></a><span>1</span><span id="textcolor1762"><span>/*</span></span> 
<a id="x1-43020r2"></a><span>2</span><span id="textcolor1763"><span> * sleep.c - create a /proc file, and if several processes try to open it</span></span> 
<a id="x1-43022r3"></a><span>3</span><span id="textcolor1764"><span> * at the same time, put all but one to sleep.</span></span> 
<a id="x1-43024r4"></a><span>4</span><span id="textcolor1765"><span> */</span></span> 
<a id="x1-43026r5"></a><span>5</span> 
<a id="x1-43028r6"></a><span>6</span><span id="textcolor1766"><span>#include</span></span><span> </span><span id="textcolor1767"><span>&lt;linux/atomic.h&gt;</span></span> 
<a id="x1-43030r7"></a><span>7</span><span id="textcolor1768"><span>#include</span></span><span> </span><span id="textcolor1769"><span>&lt;linux/fs.h&gt;</span></span> 
<a id="x1-43032r8"></a><span>8</span><span id="textcolor1770"><span>#include</span></span><span> </span><span id="textcolor1771"><span>&lt;linux/kernel.h&gt; /* for sprintf() */</span></span> 
<a id="x1-43034r9"></a><span>9</span><span id="textcolor1772"><span>#include</span></span><span> </span><span id="textcolor1773"><span>&lt;linux/module.h&gt; /* Specifically, a module */</span></span> 
<a id="x1-43036r10"></a><span>10</span><span id="textcolor1774"><span>#include</span></span><span> </span><span id="textcolor1775"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-43038r11"></a><span>11</span><span id="textcolor1776"><span>#include</span></span><span> </span><span id="textcolor1777"><span>&lt;linux/proc_fs.h&gt; /* Necessary because we use proc fs */</span></span> 
<a id="x1-43040r12"></a><span>12</span><span id="textcolor1778"><span>#include</span></span><span> </span><span id="textcolor1779"><span>&lt;linux/types.h&gt;</span></span> 
<a id="x1-43042r13"></a><span>13</span><span id="textcolor1780"><span>#include</span></span><span> </span><span id="textcolor1781"><span>&lt;linux/uaccess.h&gt; /* for get_user and put_user */</span></span> 
<a id="x1-43044r14"></a><span>14</span><span id="textcolor1782"><span>#include</span></span><span> </span><span id="textcolor1783"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-43046r15"></a><span>15</span><span id="textcolor1784"><span>#include</span></span><span> </span><span id="textcolor1785"><span>&lt;linux/wait.h&gt; /* For putting processes to sleep and</span></span> 
<a id="x1-43048r16"></a><span>16</span><span>                                   waking them up </span><span id="colorbox1786"><span>*/</span></span>  
<a id="x1-43050r17"></a><span>17</span>  
<a id="x1-43052r18"></a><span>18</span><span id="textcolor1787"><span>#include</span></span><span> </span><span id="textcolor1788"><span>&lt;asm/current.h&gt;</span></span> 
<a id="x1-43054r19"></a><span>19</span><span id="textcolor1789"><span>#include</span></span><span> </span><span id="textcolor1790"><span>&lt;asm/errno.h&gt;</span></span> 
<a id="x1-43056r20"></a><span>20</span> 
<a id="x1-43058r21"></a><span>21</span><span id="textcolor1791"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span> 
<a id="x1-43060r22"></a><span>22</span><span id="textcolor1792"><span>#define HAVE_PROC_OPS</span></span> 
<a id="x1-43062r23"></a><span>23</span><span id="textcolor1793"><span>#endif</span></span> 
<a id="x1-43064r24"></a><span>24</span> 
<a id="x1-43066r25"></a><span>25</span><span id="textcolor1794"><span>/* Here we keep the last message received, to prove that we can process our</span></span> 
<a id="x1-43068r26"></a><span>26</span><span id="textcolor1795"><span> * input.</span></span> 
<a id="x1-43070r27"></a><span>27</span><span id="textcolor1796"><span> */</span></span> 
<a id="x1-43072r28"></a><span>28</span><span id="textcolor1797"><span>#define MESSAGE_LENGTH 80</span></span> 
<a id="x1-43074r29"></a><span>29</span><span id="textcolor1798"><span>static</span></span><span> </span><span id="textcolor1799"><span>char</span></span><span> message[MESSAGE_LENGTH];</span> 
<a id="x1-43076r30"></a><span>30</span> 
<a id="x1-43078r31"></a><span>31</span><span id="textcolor1800"><span>static</span></span><span> </span><span id="textcolor1801"><span>struct</span></span><span> proc_dir_entry *our_proc_file;</span> 
<a id="x1-43080r32"></a><span>32</span><span id="textcolor1802"><span>#define PROC_ENTRY_FILENAME &#34;sleep&#34;</span></span> 
<a id="x1-43082r33"></a><span>33</span> 
<a id="x1-43084r34"></a><span>34</span><span id="textcolor1803"><span>/* Since we use the file operations struct, we can</span><span>&#39;</span><span>t use the special proc</span></span> 
<a id="x1-43086r35"></a><span>35</span><span id="textcolor1804"><span> * output provisions - we have to use a standard read function, which is this</span></span> 
<a id="x1-43088r36"></a><span>36</span><span id="textcolor1805"><span> * function.</span></span> 
<a id="x1-43090r37"></a><span>37</span><span id="textcolor1806"><span> */</span></span> 
<a id="x1-43092r38"></a><span>38</span><span id="textcolor1807"><span>static</span></span><span> </span><span id="textcolor1808"><span>ssize_t</span></span><span> module_output(</span><span id="textcolor1809"><span>struct</span></span><span> file *file, </span><span id="textcolor1810"><span>/* see include/linux/fs.h   */</span></span> 
<a id="x1-43094r39"></a><span>39</span><span>                             </span><span id="textcolor1811"><span>char</span></span><span> __user *buf, </span><span id="textcolor1812"><span>/* The buffer to put data to</span></span> 
<a id="x1-43096r40"></a><span>40</span><span id="textcolor1813"><span>                                                   (in the user segment)</span></span><span>    </span><span id="colorbox1814"><span>*/</span></span>  
<a id="x1-43098r41"></a><span>41</span><span>                             </span><span id="textcolor1815"><span>size_t</span></span><span> len, </span><span id="textcolor1816"><span>/* The length of the buffer */</span></span> 
<a id="x1-43100r42"></a><span>42</span><span>                             loff_t *offset)</span> 
<a id="x1-43102r43"></a><span>43</span><span>{</span> 
<a id="x1-43104r44"></a><span>44</span><span>    </span><span id="textcolor1817"><span>static</span></span><span> </span><span id="textcolor1818"><span>int</span></span><span> finished = 0;</span> 
<a id="x1-43106r45"></a><span>45</span><span>    </span><span id="textcolor1819"><span>int</span></span><span> i;</span> 
<a id="x1-43108r46"></a><span>46</span><span>    </span><span id="textcolor1820"><span>char</span></span><span> output_msg[MESSAGE_LENGTH + 30];</span> 
<a id="x1-43110r47"></a><span>47</span> 
<a id="x1-43112r48"></a><span>48</span><span>    </span><span id="textcolor1821"><span>/* Return 0 to signify end of file - that we have nothing more to say</span></span> 
<a id="x1-43114r49"></a><span>49</span><span id="textcolor1822"><span>     * at this point.</span></span> 
<a id="x1-43116r50"></a><span>50</span><span id="textcolor1823"><span>     */</span></span> 
<a id="x1-43118r51"></a><span>51</span><span>    </span><span id="textcolor1824"><span>if</span></span><span> (finished) {</span> 
<a id="x1-43120r52"></a><span>52</span><span>        finished = 0;</span> 
<a id="x1-43122r53"></a><span>53</span><span>        </span><span id="textcolor1825"><span>return</span></span><span> 0;</span> 
<a id="x1-43124r54"></a><span>54</span><span>    }</span> 
<a id="x1-43126r55"></a><span>55</span> 
<a id="x1-43128r56"></a><span>56</span><span>    sprintf(output_msg, </span><span id="textcolor1826"><span>&#34;Last input:%s</span></span><span id="textcolor1827"><span>\n</span></span><span id="textcolor1828"><span>&#34;</span></span><span>, message);</span> 
<a id="x1-43130r57"></a><span>57</span><span>    </span><span id="textcolor1829"><span>for</span></span><span> (i = 0; i &lt; len &amp;&amp; output_msg[i]; i++)</span> 
<a id="x1-43132r58"></a><span>58</span><span>        put_user(output_msg[i], buf + i);</span> 
<a id="x1-43134r59"></a><span>59</span> 
<a id="x1-43136r60"></a><span>60</span><span>    finished = 1;</span> 
<a id="x1-43138r61"></a><span>61</span><span>    </span><span id="textcolor1830"><span>return</span></span><span> i; </span><span id="textcolor1831"><span>/* Return the number of bytes &#34;read&#34; */</span></span> 
<a id="x1-43140r62"></a><span>62</span><span>}</span> 
<a id="x1-43142r63"></a><span>63</span> 
<a id="x1-43144r64"></a><span>64</span><span id="textcolor1832"><span>/* This function receives input from the user when the user writes to the</span></span> 
<a id="x1-43146r65"></a><span>65</span><span id="textcolor1833"><span> * /proc file.</span></span> 
<a id="x1-43148r66"></a><span>66</span><span id="textcolor1834"><span> */</span></span> 
<a id="x1-43150r67"></a><span>67</span><span id="textcolor1835"><span>static</span></span><span> </span><span id="textcolor1836"><span>ssize_t</span></span><span> module_input(</span><span id="textcolor1837"><span>struct</span></span><span> file *file, </span><span id="textcolor1838"><span>/* The file itself */</span></span> 
<a id="x1-43152r68"></a><span>68</span><span>                            </span><span id="textcolor1839"><span>const</span></span><span> </span><span id="textcolor1840"><span>char</span></span><span> __user *buf, </span><span id="textcolor1841"><span>/* The buffer with input */</span></span> 
<a id="x1-43154r69"></a><span>69</span><span>                            </span><span id="textcolor1842"><span>size_t</span></span><span> length, </span><span id="textcolor1843"><span>/* The buffer</span><span>&#39;</span><span>s length */</span></span> 
<a id="x1-43156r70"></a><span>70</span><span>                            loff_t *offset) </span><span id="textcolor1844"><span>/* offset to file - ignore */</span></span> 
<a id="x1-43158r71"></a><span>71</span><span>{</span> 
<a id="x1-43160r72"></a><span>72</span><span>    </span><span id="textcolor1845"><span>int</span></span><span> i;</span> 
<a id="x1-43162r73"></a><span>73</span> 
<a id="x1-43164r74"></a><span>74</span><span>    </span><span id="textcolor1846"><span>/* Put the input into Message, where module_output will later be able</span></span> 
<a id="x1-43166r75"></a><span>75</span><span id="textcolor1847"><span>     * to use it.</span></span> 
<a id="x1-43168r76"></a><span>76</span><span id="textcolor1848"><span>     */</span></span> 
<a id="x1-43170r77"></a><span>77</span><span>    </span><span id="textcolor1849"><span>for</span></span><span> (i = 0; i &lt; MESSAGE_LENGTH - 1 &amp;&amp; i &lt; length; i++)</span> 
<a id="x1-43172r78"></a><span>78</span><span>        get_user(message[i], buf + i);</span> 
<a id="x1-43174r79"></a><span>79</span><span>    </span><span id="textcolor1850"><span>/* we want a standard, zero terminated string */</span></span> 
<a id="x1-43176r80"></a><span>80</span><span>    message[i] = </span><span id="textcolor1851"><span>&#39;</span><span>\0</span><span>&#39;</span></span><span>;</span> 
<a id="x1-43178r81"></a><span>81</span> 
<a id="x1-43180r82"></a><span>82</span><span>    </span><span id="textcolor1852"><span>/* We need to return the number of input characters used */</span></span> 
<a id="x1-43182r83"></a><span>83</span><span>    </span><span id="textcolor1853"><span>return</span></span><span> i;</span> 
<a id="x1-43184r84"></a><span>84</span><span>}</span> 
<a id="x1-43186r85"></a><span>85</span> 
<a id="x1-43188r86"></a><span>86</span><span id="textcolor1854"><span>/* 1 if the file is currently open by somebody */</span></span> 
<a id="x1-43190r87"></a><span>87</span><span id="textcolor1855"><span>static</span></span><span> atomic_t already_open = ATOMIC_INIT(0);</span> 
<a id="x1-43192r88"></a><span>88</span> 
<a id="x1-43194r89"></a><span>89</span><span id="textcolor1856"><span>/* Queue of processes who want our file */</span></span> 
<a id="x1-43196r90"></a><span>90</span><span id="textcolor1857"><span>static</span></span><span> DECLARE_WAIT_QUEUE_HEAD(waitq);</span> 
<a id="x1-43198r91"></a><span>91</span> 
<a id="x1-43200r92"></a><span>92</span><span id="textcolor1858"><span>/* Called when the /proc file is opened */</span></span> 
<a id="x1-43202r93"></a><span>93</span><span id="textcolor1859"><span>static</span></span><span> </span><span id="textcolor1860"><span>int</span></span><span> module_open(</span><span id="textcolor1861"><span>struct</span></span><span> inode *inode, </span><span id="textcolor1862"><span>struct</span></span><span> file *file)</span> 
<a id="x1-43204r94"></a><span>94</span><span>{</span> 
<a id="x1-43206r95"></a><span>95</span><span>    </span><span id="textcolor1863"><span>/* If the file</span><span>&#39;</span><span>s flags include O_NONBLOCK, it means the process does not</span></span> 
<a id="x1-43208r96"></a><span>96</span><span id="textcolor1864"><span>     * want to wait for the file. In this case, if the file is already open,</span></span> 
<a id="x1-43210r97"></a><span>97</span><span id="textcolor1865"><span>     * we should fail with -EAGAIN, meaning &#34;you will have to try again&#34;,</span></span> 
<a id="x1-43212r98"></a><span>98</span><span id="textcolor1866"><span>     * instead of blocking a process which would rather stay awake.</span></span> 
<a id="x1-43214r99"></a><span>99</span><span id="textcolor1867"><span>     */</span></span> 
<a id="x1-43216r100"></a><span>100</span><span>    </span><span id="textcolor1868"><span>if</span></span><span> ((file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; atomic_read(&amp;already_open))</span> 
<a id="x1-43218r101"></a><span>101</span><span>        </span><span id="textcolor1869"><span>return</span></span><span> -EAGAIN;</span> 
<a id="x1-43220r102"></a><span>102</span> 
<a id="x1-43222r103"></a><span>103</span><span>    </span><span id="textcolor1870"><span>/* This is the correct place for try_module_get(THIS_MODULE) because if</span></span> 
<a id="x1-43224r104"></a><span>104</span><span id="textcolor1871"><span>     * a process is in the loop, which is within the kernel module,</span></span> 
<a id="x1-43226r105"></a><span>105</span><span id="textcolor1872"><span>     * the kernel module must not be removed.</span></span> 
<a id="x1-43228r106"></a><span>106</span><span id="textcolor1873"><span>     */</span></span> 
<a id="x1-43230r107"></a><span>107</span><span>    try_module_get(THIS_MODULE);</span> 
<a id="x1-43232r108"></a><span>108</span> 
<a id="x1-43234r109"></a><span>109</span><span>    </span><span id="textcolor1874"><span>while</span></span><span> (atomic_cmpxchg(&amp;already_open, 0, 1)) {</span> 
<a id="x1-43236r110"></a><span>110</span><span>        </span><span id="textcolor1875"><span>int</span></span><span> i, is_sig = 0;</span> 
<a id="x1-43238r111"></a><span>111</span> 
<a id="x1-43240r112"></a><span>112</span><span>        </span><span id="textcolor1876"><span>/* This function puts the current process, including any system</span></span> 
<a id="x1-43242r113"></a><span>113</span><span id="textcolor1877"><span>         * calls, such as us, to sleep.  Execution will be resumed right</span></span> 
<a id="x1-43244r114"></a><span>114</span><span id="textcolor1878"><span>         * after the function call, either because somebody called</span></span> 
<a id="x1-43246r115"></a><span>115</span><span id="textcolor1879"><span>         * wake_up(&amp;waitq) (only module_close does that, when the file</span></span> 
<a id="x1-43248r116"></a><span>116</span><span id="textcolor1880"><span>         * is closed) or when a signal, such as Ctrl-C, is sent</span></span> 
<a id="x1-43250r117"></a><span>117</span><span id="textcolor1881"><span>         * to the process</span></span> 
<a id="x1-43252r118"></a><span>118</span><span id="textcolor1882"><span>         */</span></span> 
<a id="x1-43254r119"></a><span>119</span><span>        wait_event_interruptible(waitq, !atomic_read(&amp;already_open));</span> 
<a id="x1-43256r120"></a><span>120</span> 
<a id="x1-43258r121"></a><span>121</span><span>        </span><span id="textcolor1883"><span>/* If we woke up because we got a signal we</span><span>&#39;</span><span>re not blocking,</span></span> 
<a id="x1-43260r122"></a><span>122</span><span id="textcolor1884"><span>         * return -EINTR (fail the system call).  This allows processes</span></span> 
<a id="x1-43262r123"></a><span>123</span><span id="textcolor1885"><span>         * to be killed or stopped.</span></span> 
<a id="x1-43264r124"></a><span>124</span><span id="textcolor1886"><span>         */</span></span> 
<a id="x1-43266r125"></a><span>125</span><span>        </span><span id="textcolor1887"><span>for</span></span><span> (i = 0; i &lt; _NSIG_WORDS &amp;&amp; !is_sig; i++)</span> 
<a id="x1-43268r126"></a><span>126</span><span>            is_sig = current-&gt;pending.signal.sig[i] &amp; ~current-&gt;blocked.sig[i];</span> 
<a id="x1-43270r127"></a><span>127</span> 
<a id="x1-43272r128"></a><span>128</span><span>        </span><span id="textcolor1888"><span>if</span></span><span> (is_sig) {</span> 
<a id="x1-43274r129"></a><span>129</span><span>            </span><span id="textcolor1889"><span>/* It is important to put module_put(THIS_MODULE) here, because</span></span> 
<a id="x1-43276r130"></a><span>130</span><span id="textcolor1890"><span>             * for processes where the open is interrupted there will never</span></span> 
<a id="x1-43278r131"></a><span>131</span><span id="textcolor1891"><span>             * be a corresponding close. If we do not decrement the usage</span></span> 
<a id="x1-43280r132"></a><span>132</span><span id="textcolor1892"><span>             * count here, we will be left with a positive usage count</span></span> 
<a id="x1-43282r133"></a><span>133</span><span id="textcolor1893"><span>             * which we will have no way to bring down to zero, giving us</span></span> 
<a id="x1-43284r134"></a><span>134</span><span id="textcolor1894"><span>             * an immortal module, which can only be killed by rebooting</span></span> 
<a id="x1-43286r135"></a><span>135</span><span id="textcolor1895"><span>             * the machine.</span></span> 
<a id="x1-43288r136"></a><span>136</span><span id="textcolor1896"><span>             */</span></span> 
<a id="x1-43290r137"></a><span>137</span><span>            module_put(THIS_MODULE);</span> 
<a id="x1-43292r138"></a><span>138</span><span>            </span><span id="textcolor1897"><span>return</span></span><span> -EINTR;</span> 
<a id="x1-43294r139"></a><span>139</span><span>        }</span> 
<a id="x1-43296r140"></a><span>140</span><span>    }</span> 
<a id="x1-43298r141"></a><span>141</span> 
<a id="x1-43300r142"></a><span>142</span><span>    </span><span id="textcolor1898"><span>return</span></span><span> 0; </span><span id="textcolor1899"><span>/* Allow the access */</span></span> 
<a id="x1-43302r143"></a><span>143</span><span>}</span> 
<a id="x1-43304r144"></a><span>144</span> 
<a id="x1-43306r145"></a><span>145</span><span id="textcolor1900"><span>/* Called when the /proc file is closed */</span></span> 
<a id="x1-43308r146"></a><span>146</span><span id="textcolor1901"><span>static</span></span><span> </span><span id="textcolor1902"><span>int</span></span><span> module_close(</span><span id="textcolor1903"><span>struct</span></span><span> inode *inode, </span><span id="textcolor1904"><span>struct</span></span><span> file *file)</span> 
<a id="x1-43310r147"></a><span>147</span><span>{</span> 
<a id="x1-43312r148"></a><span>148</span><span>    </span><span id="textcolor1905"><span>/* Set already_open to zero, so one of the processes in the waitq will</span></span> 
<a id="x1-43314r149"></a><span>149</span><span id="textcolor1906"><span>     * be able to set already_open back to one and to open the file. All</span></span> 
<a id="x1-43316r150"></a><span>150</span><span id="textcolor1907"><span>     * the other processes will be called when already_open is back to one,</span></span> 
<a id="x1-43318r151"></a><span>151</span><span id="textcolor1908"><span>     * so they</span><span>&#39;</span><span>ll go back to sleep.</span></span> 
<a id="x1-43320r152"></a><span>152</span><span id="textcolor1909"><span>     */</span></span> 
<a id="x1-43322r153"></a><span>153</span><span>    atomic_set(&amp;already_open, 0);</span> 
<a id="x1-43324r154"></a><span>154</span> 
<a id="x1-43326r155"></a><span>155</span><span>    </span><span id="textcolor1910"><span>/* Wake up all the processes in waitq, so if anybody is waiting for the</span></span> 
<a id="x1-43328r156"></a><span>156</span><span id="textcolor1911"><span>     * file, they can have it.</span></span> 
<a id="x1-43330r157"></a><span>157</span><span id="textcolor1912"><span>     */</span></span> 
<a id="x1-43332r158"></a><span>158</span><span>    wake_up(&amp;waitq);</span> 
<a id="x1-43334r159"></a><span>159</span> 
<a id="x1-43336r160"></a><span>160</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-43338r161"></a><span>161</span> 
<a id="x1-43340r162"></a><span>162</span><span>    </span><span id="textcolor1913"><span>return</span></span><span> 0; </span><span id="textcolor1914"><span>/* success */</span></span> 
<a id="x1-43342r163"></a><span>163</span><span>}</span> 
<a id="x1-43344r164"></a><span>164</span> 
<a id="x1-43346r165"></a><span>165</span><span id="textcolor1915"><span>/* Structures to register as the /proc file, with pointers to all the relevant</span></span> 
<a id="x1-43348r166"></a><span>166</span><span id="textcolor1916"><span> * functions.</span></span> 
<a id="x1-43350r167"></a><span>167</span><span id="textcolor1917"><span> */</span></span> 
<a id="x1-43352r168"></a><span>168</span> 
<a id="x1-43354r169"></a><span>169</span><span id="textcolor1918"><span>/* File operations for our proc file. This is where we place pointers to all</span></span> 
<a id="x1-43356r170"></a><span>170</span><span id="textcolor1919"><span> * the functions called when somebody tries to do something to our file. NULL</span></span> 
<a id="x1-43358r171"></a><span>171</span><span id="textcolor1920"><span> * means we don</span><span>&#39;</span><span>t want to deal with something.</span></span> 
<a id="x1-43360r172"></a><span>172</span><span id="textcolor1921"><span> */</span></span> 
<a id="x1-43362r173"></a><span>173</span><span id="textcolor1922"><span>#ifdef HAVE_PROC_OPS</span></span> 
<a id="x1-43364r174"></a><span>174</span><span id="textcolor1923"><span>static</span></span><span> </span><span id="textcolor1924"><span>const</span></span><span> </span><span id="textcolor1925"><span>struct</span></span><span> proc_ops file_ops_4_our_proc_file = {</span> 
<a id="x1-43366r175"></a><span>175</span><span>    .proc_read = module_output, </span><span id="textcolor1926"><span>/* &#34;read&#34; from the file */</span></span> 
<a id="x1-43368r176"></a><span>176</span><span>    .proc_write = module_input, </span><span id="textcolor1927"><span>/* &#34;write&#34; to the file */</span></span> 
<a id="x1-43370r177"></a><span>177</span><span>    .proc_open = module_open, </span><span id="textcolor1928"><span>/* called when the /proc file is opened */</span></span> 
<a id="x1-43372r178"></a><span>178</span><span>    .proc_release = module_close, </span><span id="textcolor1929"><span>/* called when it</span><span>&#39;</span><span>s closed */</span></span> 
<a id="x1-43374r179"></a><span>179</span><span>    .proc_lseek = noop_llseek, </span><span id="textcolor1930"><span>/* return file-&gt;f_pos */</span></span> 
<a id="x1-43376r180"></a><span>180</span><span>};</span> 
<a id="x1-43378r181"></a><span>181</span><span id="textcolor1931"><span>#else</span></span> 
<a id="x1-43380r182"></a><span>182</span><span id="textcolor1932"><span>static</span></span><span> </span><span id="textcolor1933"><span>const</span></span><span> </span><span id="textcolor1934"><span>struct</span></span><span> file_operations file_ops_4_our_proc_file = {</span> 
<a id="x1-43382r183"></a><span>183</span><span>    .read = module_output,</span> 
<a id="x1-43384r184"></a><span>184</span><span>    .write = module_input,</span> 
<a id="x1-43386r185"></a><span>185</span><span>    .open = module_open,</span> 
<a id="x1-43388r186"></a><span>186</span><span>    .release = module_close,</span> 
<a id="x1-43390r187"></a><span>187</span><span>    .llseek = noop_llseek,</span> 
<a id="x1-43392r188"></a><span>188</span><span>};</span> 
<a id="x1-43394r189"></a><span>189</span><span id="textcolor1935"><span>#endif</span></span> 
<a id="x1-43396r190"></a><span>190</span> 
<a id="x1-43398r191"></a><span>191</span><span id="textcolor1936"><span>/* Initialize the module - register the proc file */</span></span> 
<a id="x1-43400r192"></a><span>192</span><span id="textcolor1937"><span>static</span></span><span> </span><span id="textcolor1938"><span>int</span></span><span> __init sleep_init(</span><span id="textcolor1939"><span>void</span></span><span>)</span> 
<a id="x1-43402r193"></a><span>193</span><span>{</span> 
<a id="x1-43404r194"></a><span>194</span><span>    our_proc_file =</span> 
<a id="x1-43406r195"></a><span>195</span><span>        proc_create(PROC_ENTRY_FILENAME, 0644, NULL, &amp;file_ops_4_our_proc_file);</span> 
<a id="x1-43408r196"></a><span>196</span><span>    </span><span id="textcolor1940"><span>if</span></span><span> (our_proc_file == NULL) {</span> 
<a id="x1-43410r197"></a><span>197</span><span>        remove_proc_entry(PROC_ENTRY_FILENAME, NULL);</span> 
<a id="x1-43412r198"></a><span>198</span><span>        pr_debug(</span><span id="textcolor1941"><span>&#34;Error: Could not initialize /proc/%s</span></span><span id="textcolor1942"><span>\n</span></span><span id="textcolor1943"><span>&#34;</span></span><span>, PROC_ENTRY_FILENAME);</span> 
<a id="x1-43414r199"></a><span>199</span><span>        </span><span id="textcolor1944"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-43416r200"></a><span>200</span><span>    }</span> 
<a id="x1-43418r201"></a><span>201</span><span>    proc_set_size(our_proc_file, 80);</span> 
<a id="x1-43420r202"></a><span>202</span><span>    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);</span> 
<a id="x1-43422r203"></a><span>203</span> 
<a id="x1-43424r204"></a><span>204</span><span>    pr_info(</span><span id="textcolor1945"><span>&#34;/proc/%s created</span></span><span id="textcolor1946"><span>\n</span></span><span id="textcolor1947"><span>&#34;</span></span><span>, PROC_ENTRY_FILENAME);</span> 
<a id="x1-43426r205"></a><span>205</span> 
<a id="x1-43428r206"></a><span>206</span><span>    </span><span id="textcolor1948"><span>return</span></span><span> 0;</span> 
<a id="x1-43430r207"></a><span>207</span><span>}</span> 
<a id="x1-43432r208"></a><span>208</span> 
<a id="x1-43434r209"></a><span>209</span><span id="textcolor1949"><span>/* Cleanup - unregister our file from /proc.  This could get dangerous if</span></span> 
<a id="x1-43436r210"></a><span>210</span><span id="textcolor1950"><span> * there are still processes waiting in waitq, because they are inside our</span></span> 
<a id="x1-43438r211"></a><span>211</span><span id="textcolor1951"><span> * open function, which will get unloaded. I</span><span>&#39;</span><span>ll explain how to avoid removal</span></span> 
<a id="x1-43440r212"></a><span>212</span><span id="textcolor1952"><span> * of a kernel module in such a case in chapter 10.</span></span> 
<a id="x1-43442r213"></a><span>213</span><span id="textcolor1953"><span> */</span></span> 
<a id="x1-43444r214"></a><span>214</span><span id="textcolor1954"><span>static</span></span><span> </span><span id="textcolor1955"><span>void</span></span><span> __exit sleep_exit(</span><span id="textcolor1956"><span>void</span></span><span>)</span> 
<a id="x1-43446r215"></a><span>215</span><span>{</span> 
<a id="x1-43448r216"></a><span>216</span><span>    remove_proc_entry(PROC_ENTRY_FILENAME, NULL);</span> 
<a id="x1-43450r217"></a><span>217</span><span>    pr_debug(</span><span id="textcolor1957"><span>&#34;/proc/%s removed</span></span><span id="textcolor1958"><span>\n</span></span><span id="textcolor1959"><span>&#34;</span></span><span>, PROC_ENTRY_FILENAME);</span> 
<a id="x1-43452r218"></a><span>218</span><span>}</span> 
<a id="x1-43454r219"></a><span>219</span> 
<a id="x1-43456r220"></a><span>220</span><span>module_init(sleep_init);</span> 
<a id="x1-43458r221"></a><span>221</span><span>module_exit(sleep_exit);</span> 
<a id="x1-43460r222"></a><span>222</span> 
<a id="x1-43462r223"></a><span>223</span><span>MODULE_LICENSE(</span><span id="textcolor1960"><span>&#34;GPL&#34;</span></span><span>);</span></pre>

<!-- l. 1 -->
   <pre id="fancyvrb67"><a id="x1-43464r1"></a><span>1</span><span id="textcolor1961"><span>/*</span></span> 
<a id="x1-43466r2"></a><span>2</span><span id="textcolor1962"><span> *  cat_nonblock.c - open a file and display its contents, but exit rather than</span></span> 
<a id="x1-43468r3"></a><span>3</span><span id="textcolor1963"><span> *  wait for input.</span></span> 
<a id="x1-43470r4"></a><span>4</span><span id="textcolor1964"><span> */</span></span> 
<a id="x1-43472r5"></a><span>5</span><span id="textcolor1965"><span>#include</span></span><span> </span><span id="textcolor1966"><span>&lt;errno.h&gt; /* for errno */</span></span> 
<a id="x1-43474r6"></a><span>6</span><span id="textcolor1967"><span>#include</span></span><span> </span><span id="textcolor1968"><span>&lt;fcntl.h&gt; /* for open */</span></span> 
<a id="x1-43476r7"></a><span>7</span><span id="textcolor1969"><span>#include</span></span><span> </span><span id="textcolor1970"><span>&lt;stdio.h&gt; /* standard I/O */</span></span> 
<a id="x1-43478r8"></a><span>8</span><span id="textcolor1971"><span>#include</span></span><span> </span><span id="textcolor1972"><span>&lt;stdlib.h&gt; /* for exit */</span></span> 
<a id="x1-43480r9"></a><span>9</span><span id="textcolor1973"><span>#include</span></span><span> </span><span id="textcolor1974"><span>&lt;unistd.h&gt; /* for read */</span></span> 
<a id="x1-43482r10"></a><span>10</span> 
<a id="x1-43484r11"></a><span>11</span><span id="textcolor1975"><span>#define MAX_BYTES 1024 * 4</span></span> 
<a id="x1-43486r12"></a><span>12</span> 
<a id="x1-43488r13"></a><span>13</span><span id="textcolor1976"><span>int</span></span><span> main(</span><span id="textcolor1977"><span>int</span></span><span> argc, </span><span id="textcolor1978"><span>char</span></span><span> *argv[])</span> 
<a id="x1-43490r14"></a><span>14</span><span>{</span> 
<a id="x1-43492r15"></a><span>15</span><span>    </span><span id="textcolor1979"><span>int</span></span><span> fd; </span><span id="textcolor1980"><span>/* The file descriptor for the file to read */</span></span> 
<a id="x1-43494r16"></a><span>16</span><span>    </span><span id="textcolor1981"><span>size_t</span></span><span> bytes; </span><span id="textcolor1982"><span>/* The number of bytes read */</span></span> 
<a id="x1-43496r17"></a><span>17</span><span>    </span><span id="textcolor1983"><span>char</span></span><span> buffer[MAX_BYTES]; </span><span id="textcolor1984"><span>/* The buffer for the bytes */</span></span> 
<a id="x1-43498r18"></a><span>18</span> 
<a id="x1-43500r19"></a><span>19</span><span>    </span><span id="textcolor1985"><span>/* Usage */</span></span> 
<a id="x1-43502r20"></a><span>20</span><span>    </span><span id="textcolor1986"><span>if</span></span><span> (argc != 2) {</span> 
<a id="x1-43504r21"></a><span>21</span><span>        printf(</span><span id="textcolor1987"><span>&#34;Usage: %s &lt;filename&gt;</span></span><span id="textcolor1988"><span>\n</span></span><span id="textcolor1989"><span>&#34;</span></span><span>, argv[0]);</span> 
<a id="x1-43506r22"></a><span>22</span><span>        puts(</span><span id="textcolor1990"><span>&#34;Reads the content of a file, but doesn</span><span>&#39;</span><span>t wait for input&#34;</span></span><span>);</span> 
<a id="x1-43508r23"></a><span>23</span><span>        exit(-1);</span> 
<a id="x1-43510r24"></a><span>24</span><span>    }</span> 
<a id="x1-43512r25"></a><span>25</span> 
<a id="x1-43514r26"></a><span>26</span><span>    </span><span id="textcolor1991"><span>/* Open the file for reading in non blocking mode */</span></span> 
<a id="x1-43516r27"></a><span>27</span><span>    fd = open(argv[1], O_RDONLY | O_NONBLOCK);</span> 
<a id="x1-43518r28"></a><span>28</span> 
<a id="x1-43520r29"></a><span>29</span><span>    </span><span id="textcolor1992"><span>/* If open failed */</span></span> 
<a id="x1-43522r30"></a><span>30</span><span>    </span><span id="textcolor1993"><span>if</span></span><span> (fd == -1) {</span> 
<a id="x1-43524r31"></a><span>31</span><span>        puts(errno == EAGAIN ? </span><span id="textcolor1994"><span>&#34;Open would block&#34;</span></span><span> : </span><span id="textcolor1995"><span>&#34;Open failed&#34;</span></span><span>);</span> 
<a id="x1-43526r32"></a><span>32</span><span>        exit(-1);</span> 
<a id="x1-43528r33"></a><span>33</span><span>    }</span> 
<a id="x1-43530r34"></a><span>34</span> 
<a id="x1-43532r35"></a><span>35</span><span>    </span><span id="textcolor1996"><span>/* Read the file and output its contents */</span></span> 
<a id="x1-43534r36"></a><span>36</span><span>    </span><span id="textcolor1997"><span>do</span></span><span> {</span> 
<a id="x1-43536r37"></a><span>37</span><span>        </span><span id="textcolor1998"><span>/* Read characters from the file */</span></span> 
<a id="x1-43538r38"></a><span>38</span><span>        bytes = read(fd, buffer, MAX_BYTES);</span> 
<a id="x1-43540r39"></a><span>39</span> 
<a id="x1-43542r40"></a><span>40</span><span>        </span><span id="textcolor1999"><span>/* If there</span><span>&#39;</span><span>s an error, report it and die */</span></span> 
<a id="x1-43544r41"></a><span>41</span><span>        </span><span id="textcolor2000"><span>if</span></span><span> (bytes == -1) {</span> 
<a id="x1-43546r42"></a><span>42</span><span>            </span><span id="textcolor2001"><span>if</span></span><span> (errno == EAGAIN)</span> 
<a id="x1-43548r43"></a><span>43</span><span>                puts(</span><span id="textcolor2002"><span>&#34;Normally I</span><span>&#39;</span><span>d block, but you told me not to&#34;</span></span><span>);</span> 
<a id="x1-43550r44"></a><span>44</span><span>            </span><span id="textcolor2003"><span>else</span></span> 
<a id="x1-43552r45"></a><span>45</span><span>                puts(</span><span id="textcolor2004"><span>&#34;Another read error&#34;</span></span><span>);</span> 
<a id="x1-43554r46"></a><span>46</span><span>            exit(-1);</span> 
<a id="x1-43556r47"></a><span>47</span><span>        }</span> 
<a id="x1-43558r48"></a><span>48</span> 
<a id="x1-43560r49"></a><span>49</span><span>        </span><span id="textcolor2005"><span>/* Print the characters */</span></span> 
<a id="x1-43562r50"></a><span>50</span><span>        </span><span id="textcolor2006"><span>if</span></span><span> (bytes &gt; 0) {</span> 
<a id="x1-43564r51"></a><span>51</span><span>            </span><span id="textcolor2007"><span>for</span></span><span> (</span><span id="textcolor2008"><span>int</span></span><span> i = 0; i &lt; bytes; i++)</span> 
<a id="x1-43566r52"></a><span>52</span><span>                putchar(buffer[i]);</span> 
<a id="x1-43568r53"></a><span>53</span><span>        }</span> 
<a id="x1-43570r54"></a><span>54</span> 
<a id="x1-43572r55"></a><span>55</span><span>        </span><span id="textcolor2009"><span>/* While there are no errors and the file isn</span><span>&#39;</span><span>t over */</span></span> 
<a id="x1-43574r56"></a><span>56</span><span>    } </span><span id="textcolor2010"><span>while</span></span><span> (bytes &gt; 0);</span> 
<a id="x1-43576r57"></a><span>57</span> 
<a id="x1-43578r58"></a><span>58</span><span>    </span><span id="textcolor2011"><span>return</span></span><span> 0;</span> 
<a id="x1-43580r59"></a><span>59</span><span>}</span></pre>
<!-- l. 1633 -->
   <h4 id="completions"><span>11.2   </span> <a id="x1-4400011.2"></a>Completions</h4>
<!-- l. 1635 --><p>Sometimes one thing should happen before another within a module having multiple threads.
Rather than using <code>  <span>/bin/sleep</span>
</code> commands, the kernel has another way to do this which allows timeouts or
interrupts to also happen.
</p><!-- l. 1638 --><p>   In the following example two threads are started, but one needs to start before
another.
</p><!-- l. 1 -->
   <pre id="fancyvrb68"><a id="x1-44003r1"></a><span>1</span><span id="textcolor2012"><span>/*</span></span> 
<a id="x1-44005r2"></a><span>2</span><span id="textcolor2013"><span> * completions.c</span></span> 
<a id="x1-44007r3"></a><span>3</span><span id="textcolor2014"><span> */</span></span> 
<a id="x1-44009r4"></a><span>4</span><span id="textcolor2015"><span>#include</span></span><span> </span><span id="textcolor2016"><span>&lt;linux/completion.h&gt;</span></span> 
<a id="x1-44011r5"></a><span>5</span><span id="textcolor2017"><span>#include</span></span><span> </span><span id="textcolor2018"><span>&lt;linux/err.h&gt; /* for IS_ERR() */</span></span> 
<a id="x1-44013r6"></a><span>6</span><span id="textcolor2019"><span>#include</span></span><span> </span><span id="textcolor2020"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-44015r7"></a><span>7</span><span id="textcolor2021"><span>#include</span></span><span> </span><span id="textcolor2022"><span>&lt;linux/kthread.h&gt;</span></span> 
<a id="x1-44017r8"></a><span>8</span><span id="textcolor2023"><span>#include</span></span><span> </span><span id="textcolor2024"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-44019r9"></a><span>9</span><span id="textcolor2025"><span>#include</span></span><span> </span><span id="textcolor2026"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-44021r10"></a><span>10</span><span id="textcolor2027"><span>#include</span></span><span> </span><span id="textcolor2028"><span>&lt;linux/version.h&gt;</span></span> 
<a id="x1-44023r11"></a><span>11</span> 
<a id="x1-44025r12"></a><span>12</span><span id="textcolor2029"><span>static</span></span><span> </span><span id="textcolor2030"><span>struct</span></span><span> {</span> 
<a id="x1-44027r13"></a><span>13</span><span>    </span><span id="textcolor2031"><span>struct</span></span><span> completion crank_comp;</span> 
<a id="x1-44029r14"></a><span>14</span><span>    </span><span id="textcolor2032"><span>struct</span></span><span> completion flywheel_comp;</span> 
<a id="x1-44031r15"></a><span>15</span><span>} machine;</span> 
<a id="x1-44033r16"></a><span>16</span> 
<a id="x1-44035r17"></a><span>17</span><span id="textcolor2033"><span>static</span></span><span> </span><span id="textcolor2034"><span>int</span></span><span> machine_crank_thread(</span><span id="textcolor2035"><span>void</span></span><span> *arg)</span> 
<a id="x1-44037r18"></a><span>18</span><span>{</span> 
<a id="x1-44039r19"></a><span>19</span><span>    pr_info(</span><span id="textcolor2036"><span>&#34;Turn the crank</span></span><span id="textcolor2037"><span>\n</span></span><span id="textcolor2038"><span>&#34;</span></span><span>);</span> 
<a id="x1-44041r20"></a><span>20</span> 
<a id="x1-44043r21"></a><span>21</span><span>    complete_all(&amp;machine.crank_comp);</span> 
<a id="x1-44045r22"></a><span>22</span><span id="textcolor2039"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 17, 0)</span></span> 
<a id="x1-44047r23"></a><span>23</span><span>    kthread_complete_and_exit(&amp;machine.crank_comp, 0);</span> 
<a id="x1-44049r24"></a><span>24</span><span id="textcolor2040"><span>#else</span></span> 
<a id="x1-44051r25"></a><span>25</span><span>    complete_and_exit(&amp;machine.crank_comp, 0);</span> 
<a id="x1-44053r26"></a><span>26</span><span id="textcolor2041"><span>#endif</span></span> 
<a id="x1-44055r27"></a><span>27</span><span>}</span> 
<a id="x1-44057r28"></a><span>28</span> 
<a id="x1-44059r29"></a><span>29</span><span id="textcolor2042"><span>static</span></span><span> </span><span id="textcolor2043"><span>int</span></span><span> machine_flywheel_spinup_thread(</span><span id="textcolor2044"><span>void</span></span><span> *arg)</span> 
<a id="x1-44061r30"></a><span>30</span><span>{</span> 
<a id="x1-44063r31"></a><span>31</span><span>    wait_for_completion(&amp;machine.crank_comp);</span> 
<a id="x1-44065r32"></a><span>32</span> 
<a id="x1-44067r33"></a><span>33</span><span>    pr_info(</span><span id="textcolor2045"><span>&#34;Flywheel spins up</span></span><span id="textcolor2046"><span>\n</span></span><span id="textcolor2047"><span>&#34;</span></span><span>);</span> 
<a id="x1-44069r34"></a><span>34</span> 
<a id="x1-44071r35"></a><span>35</span><span>    complete_all(&amp;machine.flywheel_comp);</span> 
<a id="x1-44073r36"></a><span>36</span><span id="textcolor2048"><span>#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 17, 0)</span></span> 
<a id="x1-44075r37"></a><span>37</span><span>    kthread_complete_and_exit(&amp;machine.flywheel_comp, 0);</span> 
<a id="x1-44077r38"></a><span>38</span><span id="textcolor2049"><span>#else</span></span> 
<a id="x1-44079r39"></a><span>39</span><span>    complete_and_exit(&amp;machine.flywheel_comp, 0);</span> 
<a id="x1-44081r40"></a><span>40</span><span id="textcolor2050"><span>#endif</span></span> 
<a id="x1-44083r41"></a><span>41</span><span>}</span> 
<a id="x1-44085r42"></a><span>42</span> 
<a id="x1-44087r43"></a><span>43</span><span id="textcolor2051"><span>static</span></span><span> </span><span id="textcolor2052"><span>int</span></span><span> completions_init(</span><span id="textcolor2053"><span>void</span></span><span>)</span> 
<a id="x1-44089r44"></a><span>44</span><span>{</span> 
<a id="x1-44091r45"></a><span>45</span><span>    </span><span id="textcolor2054"><span>struct</span></span><span> task_struct *crank_thread;</span> 
<a id="x1-44093r46"></a><span>46</span><span>    </span><span id="textcolor2055"><span>struct</span></span><span> task_struct *flywheel_thread;</span> 
<a id="x1-44095r47"></a><span>47</span> 
<a id="x1-44097r48"></a><span>48</span><span>    pr_info(</span><span id="textcolor2056"><span>&#34;completions example</span></span><span id="textcolor2057"><span>\n</span></span><span id="textcolor2058"><span>&#34;</span></span><span>);</span> 
<a id="x1-44099r49"></a><span>49</span> 
<a id="x1-44101r50"></a><span>50</span><span>    init_completion(&amp;machine.crank_comp);</span> 
<a id="x1-44103r51"></a><span>51</span><span>    init_completion(&amp;machine.flywheel_comp);</span> 
<a id="x1-44105r52"></a><span>52</span> 
<a id="x1-44107r53"></a><span>53</span><span>    crank_thread = kthread_create(machine_crank_thread, NULL, </span><span id="textcolor2059"><span>&#34;KThread Crank&#34;</span></span><span>);</span> 
<a id="x1-44109r54"></a><span>54</span><span>    </span><span id="textcolor2060"><span>if</span></span><span> (IS_ERR(crank_thread))</span> 
<a id="x1-44111r55"></a><span>55</span><span>        </span><span id="textcolor2061"><span>goto</span></span><span> ERROR_THREAD_1;</span> 
<a id="x1-44113r56"></a><span>56</span> 
<a id="x1-44115r57"></a><span>57</span><span>    flywheel_thread = kthread_create(machine_flywheel_spinup_thread, NULL,</span> 
<a id="x1-44117r58"></a><span>58</span><span>                                     </span><span id="textcolor2062"><span>&#34;KThread Flywheel&#34;</span></span><span>);</span> 
<a id="x1-44119r59"></a><span>59</span><span>    </span><span id="textcolor2063"><span>if</span></span><span> (IS_ERR(flywheel_thread))</span> 
<a id="x1-44121r60"></a><span>60</span><span>        </span><span id="textcolor2064"><span>goto</span></span><span> ERROR_THREAD_2;</span> 
<a id="x1-44123r61"></a><span>61</span> 
<a id="x1-44125r62"></a><span>62</span><span>    wake_up_process(flywheel_thread);</span> 
<a id="x1-44127r63"></a><span>63</span><span>    wake_up_process(crank_thread);</span> 
<a id="x1-44129r64"></a><span>64</span> 
<a id="x1-44131r65"></a><span>65</span><span>    </span><span id="textcolor2065"><span>return</span></span><span> 0;</span> 
<a id="x1-44133r66"></a><span>66</span> 
<a id="x1-44135r67"></a><span>67</span><span>ERROR_THREAD_2:</span> 
<a id="x1-44137r68"></a><span>68</span><span>    kthread_stop(crank_thread);</span> 
<a id="x1-44139r69"></a><span>69</span><span>ERROR_THREAD_1:</span> 
<a id="x1-44141r70"></a><span>70</span> 
<a id="x1-44143r71"></a><span>71</span><span>    </span><span id="textcolor2066"><span>return</span></span><span> -1;</span> 
<a id="x1-44145r72"></a><span>72</span><span>}</span> 
<a id="x1-44147r73"></a><span>73</span> 
<a id="x1-44149r74"></a><span>74</span><span id="textcolor2067"><span>static</span></span><span> </span><span id="textcolor2068"><span>void</span></span><span> completions_exit(</span><span id="textcolor2069"><span>void</span></span><span>)</span> 
<a id="x1-44151r75"></a><span>75</span><span>{</span> 
<a id="x1-44153r76"></a><span>76</span><span>    wait_for_completion(&amp;machine.crank_comp);</span> 
<a id="x1-44155r77"></a><span>77</span><span>    wait_for_completion(&amp;machine.flywheel_comp);</span> 
<a id="x1-44157r78"></a><span>78</span> 
<a id="x1-44159r79"></a><span>79</span><span>    pr_info(</span><span id="textcolor2070"><span>&#34;completions exit</span></span><span id="textcolor2071"><span>\n</span></span><span id="textcolor2072"><span>&#34;</span></span><span>);</span> 
<a id="x1-44161r80"></a><span>80</span><span>}</span> 
<a id="x1-44163r81"></a><span>81</span> 
<a id="x1-44165r82"></a><span>82</span><span>module_init(completions_init);</span> 
<a id="x1-44167r83"></a><span>83</span><span>module_exit(completions_exit);</span> 
<a id="x1-44169r84"></a><span>84</span> 
<a id="x1-44171r85"></a><span>85</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2073"><span>&#34;Completions example&#34;</span></span><span>);</span> 
<a id="x1-44173r86"></a><span>86</span><span>MODULE_LICENSE(</span><span id="textcolor2074"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1642 --><p>   The <code>  <span>machine</span>
</code> structure stores the completion states for the two threads. At the exit
point of each thread the respective completion state is updated, and
<code> <span>wait_for_completion</span>
</code> is used by the flywheel thread to ensure that it does not begin prematurely.
</p><!-- l. 1645 --><p>   So even though <code>  <span>flywheel_thread</span>
</code> is started first you should notice if you load this module and run
<code> <span>dmesg</span>
</code> that turning the crank always happens first because the flywheel thread waits for it
to complete.
</p><!-- l. 1647 --><p>   There are other variations upon the
<code> <span>wait_for_completion</span>
</code> function, which include timeouts or being interrupted, but this basic mechanism is
enough for many common situations without adding a lot of complexity.
</p><!-- l. 1649 -->
   <h3 id="avoiding-collisions-and-deadlocks"><span>12   </span> <a id="x1-4500012"></a>Avoiding Collisions and Deadlocks</h3>
<!-- l. 1651 --><p>If processes running on different CPUs or in different threads try to access the same
memory, then it is possible that strange things can happen or your system can lock
up. To avoid this, various types of mutual exclusion kernel functions are available.
These indicate if a section of code is &#34;locked&#34; or &#34;unlocked&#34; so that simultaneous
attempts to run it can not happen.
</p>
   <h4 id="mutex"><span>12.1   </span> <a id="x1-4600012.1"></a>Mutex</h4>
<!-- l. 1656 --><p>You can use kernel mutexes (mutual exclusions) in much the same manner that you
might deploy them in userland. This may be all that is needed to avoid collisions in
most cases.
</p><!-- l. 1 -->
   <pre id="fancyvrb69"><a id="x1-46002r1"></a><span>1</span><span id="textcolor2075"><span>/*</span></span> 
<a id="x1-46004r2"></a><span>2</span><span id="textcolor2076"><span> * example_mutex.c</span></span> 
<a id="x1-46006r3"></a><span>3</span><span id="textcolor2077"><span> */</span></span> 
<a id="x1-46008r4"></a><span>4</span><span id="textcolor2078"><span>#include</span></span><span> </span><span id="textcolor2079"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-46010r5"></a><span>5</span><span id="textcolor2080"><span>#include</span></span><span> </span><span id="textcolor2081"><span>&lt;linux/mutex.h&gt;</span></span> 
<a id="x1-46012r6"></a><span>6</span><span id="textcolor2082"><span>#include</span></span><span> </span><span id="textcolor2083"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-46014r7"></a><span>7</span> 
<a id="x1-46016r8"></a><span>8</span><span id="textcolor2084"><span>static</span></span><span> DEFINE_MUTEX(mymutex);</span> 
<a id="x1-46018r9"></a><span>9</span> 
<a id="x1-46020r10"></a><span>10</span><span id="textcolor2085"><span>static</span></span><span> </span><span id="textcolor2086"><span>int</span></span><span> example_mutex_init(</span><span id="textcolor2087"><span>void</span></span><span>)</span> 
<a id="x1-46022r11"></a><span>11</span><span>{</span> 
<a id="x1-46024r12"></a><span>12</span><span>    </span><span id="textcolor2088"><span>int</span></span><span> ret;</span> 
<a id="x1-46026r13"></a><span>13</span> 
<a id="x1-46028r14"></a><span>14</span><span>    pr_info(</span><span id="textcolor2089"><span>&#34;example_mutex init</span></span><span id="textcolor2090"><span>\n</span></span><span id="textcolor2091"><span>&#34;</span></span><span>);</span> 
<a id="x1-46030r15"></a><span>15</span> 
<a id="x1-46032r16"></a><span>16</span><span>    ret = mutex_trylock(&amp;mymutex);</span> 
<a id="x1-46034r17"></a><span>17</span><span>    </span><span id="textcolor2092"><span>if</span></span><span> (ret != 0) {</span> 
<a id="x1-46036r18"></a><span>18</span><span>        pr_info(</span><span id="textcolor2093"><span>&#34;mutex is locked</span></span><span id="textcolor2094"><span>\n</span></span><span id="textcolor2095"><span>&#34;</span></span><span>);</span> 
<a id="x1-46038r19"></a><span>19</span> 
<a id="x1-46040r20"></a><span>20</span><span>        </span><span id="textcolor2096"><span>if</span></span><span> (mutex_is_locked(&amp;mymutex) == 0)</span> 
<a id="x1-46042r21"></a><span>21</span><span>            pr_info(</span><span id="textcolor2097"><span>&#34;The mutex failed to lock!</span></span><span id="textcolor2098"><span>\n</span></span><span id="textcolor2099"><span>&#34;</span></span><span>);</span> 
<a id="x1-46044r22"></a><span>22</span> 
<a id="x1-46046r23"></a><span>23</span><span>        mutex_unlock(&amp;mymutex);</span> 
<a id="x1-46048r24"></a><span>24</span><span>        pr_info(</span><span id="textcolor2100"><span>&#34;mutex is unlocked</span></span><span id="textcolor2101"><span>\n</span></span><span id="textcolor2102"><span>&#34;</span></span><span>);</span> 
<a id="x1-46050r25"></a><span>25</span><span>    } </span><span id="textcolor2103"><span>else</span></span> 
<a id="x1-46052r26"></a><span>26</span><span>        pr_info(</span><span id="textcolor2104"><span>&#34;Failed to lock</span></span><span id="textcolor2105"><span>\n</span></span><span id="textcolor2106"><span>&#34;</span></span><span>);</span> 
<a id="x1-46054r27"></a><span>27</span> 
<a id="x1-46056r28"></a><span>28</span><span>    </span><span id="textcolor2107"><span>return</span></span><span> 0;</span> 
<a id="x1-46058r29"></a><span>29</span><span>}</span> 
<a id="x1-46060r30"></a><span>30</span> 
<a id="x1-46062r31"></a><span>31</span><span id="textcolor2108"><span>static</span></span><span> </span><span id="textcolor2109"><span>void</span></span><span> example_mutex_exit(</span><span id="textcolor2110"><span>void</span></span><span>)</span> 
<a id="x1-46064r32"></a><span>32</span><span>{</span> 
<a id="x1-46066r33"></a><span>33</span><span>    pr_info(</span><span id="textcolor2111"><span>&#34;example_mutex exit</span></span><span id="textcolor2112"><span>\n</span></span><span id="textcolor2113"><span>&#34;</span></span><span>);</span> 
<a id="x1-46068r34"></a><span>34</span><span>}</span> 
<a id="x1-46070r35"></a><span>35</span> 
<a id="x1-46072r36"></a><span>36</span><span>module_init(example_mutex_init);</span> 
<a id="x1-46074r37"></a><span>37</span><span>module_exit(example_mutex_exit);</span> 
<a id="x1-46076r38"></a><span>38</span> 
<a id="x1-46078r39"></a><span>39</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2114"><span>&#34;Mutex example&#34;</span></span><span>);</span> 
<a id="x1-46080r40"></a><span>40</span><span>MODULE_LICENSE(</span><span id="textcolor2115"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1661 -->
   <h4 id="spinlocks"><span>12.2   </span> <a id="x1-4700012.2"></a>Spinlocks</h4>
<!-- l. 1663 --><p>As the name suggests, spinlocks lock up the CPU that the code is running on,
taking 100% of its resources. Because of this you should only use the spinlock
                                                                  

                                                                  
mechanism around code which is likely to take no more than a few milliseconds to
run and so will not noticeably slow anything down from the user’s point of
view.
</p><!-- l. 1666 --><p>   The example here is <span><span><span>&#34;irq safe&#34;</span></span></span> in that if interrupts happen during the lock then
they will not be forgotten and will activate when the unlock happens, using the
<code> <span>flags</span>
</code> variable to retain their state.
</p><!-- l. 1 -->
   <pre id="fancyvrb70"><a id="x1-47003r1"></a><span>1</span><span id="textcolor2116"><span>/*</span></span> 
<a id="x1-47005r2"></a><span>2</span><span id="textcolor2117"><span> * example_spinlock.c</span></span> 
<a id="x1-47007r3"></a><span>3</span><span id="textcolor2118"><span> */</span></span> 
<a id="x1-47009r4"></a><span>4</span><span id="textcolor2119"><span>#include</span></span><span> </span><span id="textcolor2120"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-47011r5"></a><span>5</span><span id="textcolor2121"><span>#include</span></span><span> </span><span id="textcolor2122"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-47013r6"></a><span>6</span><span id="textcolor2123"><span>#include</span></span><span> </span><span id="textcolor2124"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-47015r7"></a><span>7</span><span id="textcolor2125"><span>#include</span></span><span> </span><span id="textcolor2126"><span>&lt;linux/spinlock.h&gt;</span></span> 
<a id="x1-47017r8"></a><span>8</span> 
<a id="x1-47019r9"></a><span>9</span><span id="textcolor2127"><span>static</span></span><span> DEFINE_SPINLOCK(sl_static);</span> 
<a id="x1-47021r10"></a><span>10</span><span id="textcolor2128"><span>static</span></span><span> spinlock_t sl_dynamic;</span> 
<a id="x1-47023r11"></a><span>11</span> 
<a id="x1-47025r12"></a><span>12</span><span id="textcolor2129"><span>static</span></span><span> </span><span id="textcolor2130"><span>void</span></span><span> example_spinlock_static(</span><span id="textcolor2131"><span>void</span></span><span>)</span> 
<a id="x1-47027r13"></a><span>13</span><span>{</span> 
<a id="x1-47029r14"></a><span>14</span><span>    </span><span id="textcolor2132"><span>unsigned</span></span><span> </span><span id="textcolor2133"><span>long</span></span><span> flags;</span> 
<a id="x1-47031r15"></a><span>15</span> 
<a id="x1-47033r16"></a><span>16</span><span>    spin_lock_irqsave(&amp;sl_static, flags);</span> 
<a id="x1-47035r17"></a><span>17</span><span>    pr_info(</span><span id="textcolor2134"><span>&#34;Locked static spinlock</span></span><span id="textcolor2135"><span>\n</span></span><span id="textcolor2136"><span>&#34;</span></span><span>);</span> 
<a id="x1-47037r18"></a><span>18</span> 
<a id="x1-47039r19"></a><span>19</span><span>    </span><span id="textcolor2137"><span>/* Do something or other safely. Because this uses 100% CPU time, this</span></span> 
<a id="x1-47041r20"></a><span>20</span><span id="textcolor2138"><span>     * code should take no more than a few milliseconds to run.</span></span> 
<a id="x1-47043r21"></a><span>21</span><span id="textcolor2139"><span>     */</span></span> 
<a id="x1-47045r22"></a><span>22</span> 
<a id="x1-47047r23"></a><span>23</span><span>    spin_unlock_irqrestore(&amp;sl_static, flags);</span> 
<a id="x1-47049r24"></a><span>24</span><span>    pr_info(</span><span id="textcolor2140"><span>&#34;Unlocked static spinlock</span></span><span id="textcolor2141"><span>\n</span></span><span id="textcolor2142"><span>&#34;</span></span><span>);</span> 
<a id="x1-47051r25"></a><span>25</span><span>}</span> 
<a id="x1-47053r26"></a><span>26</span> 
<a id="x1-47055r27"></a><span>27</span><span id="textcolor2143"><span>static</span></span><span> </span><span id="textcolor2144"><span>void</span></span><span> example_spinlock_dynamic(</span><span id="textcolor2145"><span>void</span></span><span>)</span> 
<a id="x1-47057r28"></a><span>28</span><span>{</span> 
<a id="x1-47059r29"></a><span>29</span><span>    </span><span id="textcolor2146"><span>unsigned</span></span><span> </span><span id="textcolor2147"><span>long</span></span><span> flags;</span> 
<a id="x1-47061r30"></a><span>30</span> 
<a id="x1-47063r31"></a><span>31</span><span>    spin_lock_init(&amp;sl_dynamic);</span> 
<a id="x1-47065r32"></a><span>32</span><span>    spin_lock_irqsave(&amp;sl_dynamic, flags);</span> 
<a id="x1-47067r33"></a><span>33</span><span>    pr_info(</span><span id="textcolor2148"><span>&#34;Locked dynamic spinlock</span></span><span id="textcolor2149"><span>\n</span></span><span id="textcolor2150"><span>&#34;</span></span><span>);</span> 
<a id="x1-47069r34"></a><span>34</span> 
<a id="x1-47071r35"></a><span>35</span><span>    </span><span id="textcolor2151"><span>/* Do something or other safely. Because this uses 100% CPU time, this</span></span> 
<a id="x1-47073r36"></a><span>36</span><span id="textcolor2152"><span>     * code should take no more than a few milliseconds to run.</span></span> 
<a id="x1-47075r37"></a><span>37</span><span id="textcolor2153"><span>     */</span></span> 
<a id="x1-47077r38"></a><span>38</span> 
<a id="x1-47079r39"></a><span>39</span><span>    spin_unlock_irqrestore(&amp;sl_dynamic, flags);</span> 
<a id="x1-47081r40"></a><span>40</span><span>    pr_info(</span><span id="textcolor2154"><span>&#34;Unlocked dynamic spinlock</span></span><span id="textcolor2155"><span>\n</span></span><span id="textcolor2156"><span>&#34;</span></span><span>);</span> 
<a id="x1-47083r41"></a><span>41</span><span>}</span> 
<a id="x1-47085r42"></a><span>42</span> 
<a id="x1-47087r43"></a><span>43</span><span id="textcolor2157"><span>static</span></span><span> </span><span id="textcolor2158"><span>int</span></span><span> example_spinlock_init(</span><span id="textcolor2159"><span>void</span></span><span>)</span> 
<a id="x1-47089r44"></a><span>44</span><span>{</span> 
<a id="x1-47091r45"></a><span>45</span><span>    pr_info(</span><span id="textcolor2160"><span>&#34;example spinlock started</span></span><span id="textcolor2161"><span>\n</span></span><span id="textcolor2162"><span>&#34;</span></span><span>);</span> 
<a id="x1-47093r46"></a><span>46</span> 
<a id="x1-47095r47"></a><span>47</span><span>    example_spinlock_static();</span> 
<a id="x1-47097r48"></a><span>48</span><span>    example_spinlock_dynamic();</span> 
<a id="x1-47099r49"></a><span>49</span> 
<a id="x1-47101r50"></a><span>50</span><span>    </span><span id="textcolor2163"><span>return</span></span><span> 0;</span> 
<a id="x1-47103r51"></a><span>51</span><span>}</span> 
<a id="x1-47105r52"></a><span>52</span> 
<a id="x1-47107r53"></a><span>53</span><span id="textcolor2164"><span>static</span></span><span> </span><span id="textcolor2165"><span>void</span></span><span> example_spinlock_exit(</span><span id="textcolor2166"><span>void</span></span><span>)</span> 
<a id="x1-47109r54"></a><span>54</span><span>{</span> 
<a id="x1-47111r55"></a><span>55</span><span>    pr_info(</span><span id="textcolor2167"><span>&#34;example spinlock exit</span></span><span id="textcolor2168"><span>\n</span></span><span id="textcolor2169"><span>&#34;</span></span><span>);</span> 
<a id="x1-47113r56"></a><span>56</span><span>}</span> 
<a id="x1-47115r57"></a><span>57</span> 
<a id="x1-47117r58"></a><span>58</span><span>module_init(example_spinlock_init);</span> 
<a id="x1-47119r59"></a><span>59</span><span>module_exit(example_spinlock_exit);</span> 
<a id="x1-47121r60"></a><span>60</span> 
<a id="x1-47123r61"></a><span>61</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2170"><span>&#34;Spinlock example&#34;</span></span><span>);</span> 
<a id="x1-47125r62"></a><span>62</span><span>MODULE_LICENSE(</span><span id="textcolor2171"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1670 -->
   <h4 id="read-and-write-locks"><span>12.3   </span> <a id="x1-4800012.3"></a>Read and write locks</h4>
<!-- l. 1672 --><p>Read and write locks are specialised kinds of spinlocks so that you can exclusively
read from something or write to something. Like the earlier spinlocks example, the
one below shows an &#34;irq safe&#34; situation in which if other functions were triggered
from irqs which might also read and write to whatever you are concerned with
then they would not disrupt the logic. As before it is a good idea to keep
anything done within the lock as short as possible so that it does not hang up
the system and cause users to start revolting against the tyranny of your
module.
</p><!-- l. 1 -->
   <pre id="fancyvrb71"><a id="x1-48002r1"></a><span>1</span><span id="textcolor2172"><span>/*</span></span> 
<a id="x1-48004r2"></a><span>2</span><span id="textcolor2173"><span> * example_rwlock.c</span></span> 
<a id="x1-48006r3"></a><span>3</span><span id="textcolor2174"><span> */</span></span> 
<a id="x1-48008r4"></a><span>4</span><span id="textcolor2175"><span>#include</span></span><span> </span><span id="textcolor2176"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-48010r5"></a><span>5</span><span id="textcolor2177"><span>#include</span></span><span> </span><span id="textcolor2178"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-48012r6"></a><span>6</span><span id="textcolor2179"><span>#include</span></span><span> </span><span id="textcolor2180"><span>&lt;linux/rwlock.h&gt;</span></span> 
<a id="x1-48014r7"></a><span>7</span> 
<a id="x1-48016r8"></a><span>8</span><span id="textcolor2181"><span>static</span></span><span> DEFINE_RWLOCK(myrwlock);</span> 
<a id="x1-48018r9"></a><span>9</span> 
<a id="x1-48020r10"></a><span>10</span><span id="textcolor2182"><span>static</span></span><span> </span><span id="textcolor2183"><span>void</span></span><span> example_read_lock(</span><span id="textcolor2184"><span>void</span></span><span>)</span> 
<a id="x1-48022r11"></a><span>11</span><span>{</span> 
<a id="x1-48024r12"></a><span>12</span><span>    </span><span id="textcolor2185"><span>unsigned</span></span><span> </span><span id="textcolor2186"><span>long</span></span><span> flags;</span> 
<a id="x1-48026r13"></a><span>13</span> 
<a id="x1-48028r14"></a><span>14</span><span>    read_lock_irqsave(&amp;myrwlock, flags);</span> 
<a id="x1-48030r15"></a><span>15</span><span>    pr_info(</span><span id="textcolor2187"><span>&#34;Read Locked</span></span><span id="textcolor2188"><span>\n</span></span><span id="textcolor2189"><span>&#34;</span></span><span>);</span> 
<a id="x1-48032r16"></a><span>16</span> 
<a id="x1-48034r17"></a><span>17</span><span>    </span><span id="textcolor2190"><span>/* Read from something */</span></span> 
<a id="x1-48036r18"></a><span>18</span> 
<a id="x1-48038r19"></a><span>19</span><span>    read_unlock_irqrestore(&amp;myrwlock, flags);</span> 
<a id="x1-48040r20"></a><span>20</span><span>    pr_info(</span><span id="textcolor2191"><span>&#34;Read Unlocked</span></span><span id="textcolor2192"><span>\n</span></span><span id="textcolor2193"><span>&#34;</span></span><span>);</span> 
<a id="x1-48042r21"></a><span>21</span><span>}</span> 
<a id="x1-48044r22"></a><span>22</span> 
<a id="x1-48046r23"></a><span>23</span><span id="textcolor2194"><span>static</span></span><span> </span><span id="textcolor2195"><span>void</span></span><span> example_write_lock(</span><span id="textcolor2196"><span>void</span></span><span>)</span> 
<a id="x1-48048r24"></a><span>24</span><span>{</span> 
<a id="x1-48050r25"></a><span>25</span><span>    </span><span id="textcolor2197"><span>unsigned</span></span><span> </span><span id="textcolor2198"><span>long</span></span><span> flags;</span> 
<a id="x1-48052r26"></a><span>26</span> 
<a id="x1-48054r27"></a><span>27</span><span>    write_lock_irqsave(&amp;myrwlock, flags);</span> 
<a id="x1-48056r28"></a><span>28</span><span>    pr_info(</span><span id="textcolor2199"><span>&#34;Write Locked</span></span><span id="textcolor2200"><span>\n</span></span><span id="textcolor2201"><span>&#34;</span></span><span>);</span> 
<a id="x1-48058r29"></a><span>29</span> 
<a id="x1-48060r30"></a><span>30</span><span>    </span><span id="textcolor2202"><span>/* Write to something */</span></span> 
<a id="x1-48062r31"></a><span>31</span> 
<a id="x1-48064r32"></a><span>32</span><span>    write_unlock_irqrestore(&amp;myrwlock, flags);</span> 
<a id="x1-48066r33"></a><span>33</span><span>    pr_info(</span><span id="textcolor2203"><span>&#34;Write Unlocked</span></span><span id="textcolor2204"><span>\n</span></span><span id="textcolor2205"><span>&#34;</span></span><span>);</span> 
<a id="x1-48068r34"></a><span>34</span><span>}</span> 
<a id="x1-48070r35"></a><span>35</span> 
<a id="x1-48072r36"></a><span>36</span><span id="textcolor2206"><span>static</span></span><span> </span><span id="textcolor2207"><span>int</span></span><span> example_rwlock_init(</span><span id="textcolor2208"><span>void</span></span><span>)</span> 
<a id="x1-48074r37"></a><span>37</span><span>{</span> 
<a id="x1-48076r38"></a><span>38</span><span>    pr_info(</span><span id="textcolor2209"><span>&#34;example_rwlock started</span></span><span id="textcolor2210"><span>\n</span></span><span id="textcolor2211"><span>&#34;</span></span><span>);</span> 
<a id="x1-48078r39"></a><span>39</span> 
<a id="x1-48080r40"></a><span>40</span><span>    example_read_lock();</span> 
<a id="x1-48082r41"></a><span>41</span><span>    example_write_lock();</span> 
<a id="x1-48084r42"></a><span>42</span> 
<a id="x1-48086r43"></a><span>43</span><span>    </span><span id="textcolor2212"><span>return</span></span><span> 0;</span> 
<a id="x1-48088r44"></a><span>44</span><span>}</span> 
<a id="x1-48090r45"></a><span>45</span> 
<a id="x1-48092r46"></a><span>46</span><span id="textcolor2213"><span>static</span></span><span> </span><span id="textcolor2214"><span>void</span></span><span> example_rwlock_exit(</span><span id="textcolor2215"><span>void</span></span><span>)</span> 
<a id="x1-48094r47"></a><span>47</span><span>{</span> 
<a id="x1-48096r48"></a><span>48</span><span>    pr_info(</span><span id="textcolor2216"><span>&#34;example_rwlock exit</span></span><span id="textcolor2217"><span>\n</span></span><span id="textcolor2218"><span>&#34;</span></span><span>);</span> 
<a id="x1-48098r49"></a><span>49</span><span>}</span> 
<a id="x1-48100r50"></a><span>50</span> 
<a id="x1-48102r51"></a><span>51</span><span>module_init(example_rwlock_init);</span> 
<a id="x1-48104r52"></a><span>52</span><span>module_exit(example_rwlock_exit);</span> 
<a id="x1-48106r53"></a><span>53</span> 
<a id="x1-48108r54"></a><span>54</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2219"><span>&#34;Read/Write locks example&#34;</span></span><span>);</span> 
<a id="x1-48110r55"></a><span>55</span><span>MODULE_LICENSE(</span><span id="textcolor2220"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1678 --><p>   Of course, if you know for sure that there are no functions triggered by irqs
which could possibly interfere with your logic then you can use the simpler
<code> <span>read_lock(&amp;myrwlock)</span>
</code> and <code>  <span>read_unlock(&amp;myrwlock)</span>
</code> or the corresponding write functions.
</p>
   <h4 id="atomic-operations"><span>12.4   </span> <a id="x1-4900012.4"></a>Atomic operations</h4>
<!-- l. 1681 --><p>If you are doing simple arithmetic: adding, subtracting or bitwise operations, then
there is another way in the multi-CPU and multi-hyperthreaded world to stop other
parts of the system from messing with your mojo. By using atomic operations you
can be confident that your addition, subtraction or bit flip did actually happen
and was not overwritten by some other shenanigans. An example is shown
below.
</p><!-- l. 1 -->
   <pre id="fancyvrb72"><a id="x1-49002r1"></a><span>1</span><span id="textcolor2221"><span>/*</span></span> 
<a id="x1-49004r2"></a><span>2</span><span id="textcolor2222"><span> * example_atomic.c</span></span> 
<a id="x1-49006r3"></a><span>3</span><span id="textcolor2223"><span> */</span></span> 
<a id="x1-49008r4"></a><span>4</span><span id="textcolor2224"><span>#include</span></span><span> </span><span id="textcolor2225"><span>&lt;linux/atomic.h&gt;</span></span> 
<a id="x1-49010r5"></a><span>5</span><span id="textcolor2226"><span>#include</span></span><span> </span><span id="textcolor2227"><span>&lt;linux/bitops.h&gt;</span></span> 
<a id="x1-49012r6"></a><span>6</span><span id="textcolor2228"><span>#include</span></span><span> </span><span id="textcolor2229"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-49014r7"></a><span>7</span><span id="textcolor2230"><span>#include</span></span><span> </span><span id="textcolor2231"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-49016r8"></a><span>8</span> 
<a id="x1-49018r9"></a><span>9</span><span id="textcolor2232"><span>#define BYTE_TO_BINARY_PATTERN &#34;%c%c%c%c%c%c%c%c&#34;</span></span> 
<a id="x1-49020r10"></a><span>10</span><span id="textcolor2233"><span>#define BYTE_TO_BINARY(byte)                                                   \</span></span> 
<a id="x1-49022r11"></a><span>11</span><span id="textcolor2234"><span>    ((byte &amp; 0x80) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>), ((byte &amp; 0x40) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>),                  \</span></span> 
<a id="x1-49024r12"></a><span>12</span><span id="textcolor2235"><span>        ((byte &amp; 0x20) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>), ((byte &amp; 0x10) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>),              \</span></span> 
<a id="x1-49026r13"></a><span>13</span><span id="textcolor2236"><span>        ((byte &amp; 0x08) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>), ((byte &amp; 0x04) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>),              \</span></span> 
<a id="x1-49028r14"></a><span>14</span><span id="textcolor2237"><span>        ((byte &amp; 0x02) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>), ((byte &amp; 0x01) ? </span><span>&#39;</span><span>1</span><span>&#39;</span><span> : </span><span>&#39;</span><span>0</span><span>&#39;</span><span>)</span></span> 
<a id="x1-49030r15"></a><span>15</span> 
<a id="x1-49032r16"></a><span>16</span><span id="textcolor2238"><span>static</span></span><span> </span><span id="textcolor2239"><span>void</span></span><span> atomic_add_subtract(</span><span id="textcolor2240"><span>void</span></span><span>)</span> 
<a id="x1-49034r17"></a><span>17</span><span>{</span> 
<a id="x1-49036r18"></a><span>18</span><span>    atomic_t debbie;</span> 
<a id="x1-49038r19"></a><span>19</span><span>    atomic_t chris = ATOMIC_INIT(50);</span> 
<a id="x1-49040r20"></a><span>20</span> 
<a id="x1-49042r21"></a><span>21</span><span>    atomic_set(&amp;debbie, 45);</span> 
<a id="x1-49044r22"></a><span>22</span> 
<a id="x1-49046r23"></a><span>23</span><span>    </span><span id="textcolor2241"><span>/* subtract one */</span></span> 
<a id="x1-49048r24"></a><span>24</span><span>    atomic_dec(&amp;debbie);</span> 
<a id="x1-49050r25"></a><span>25</span> 
<a id="x1-49052r26"></a><span>26</span><span>    atomic_add(7, &amp;debbie);</span> 
<a id="x1-49054r27"></a><span>27</span> 
<a id="x1-49056r28"></a><span>28</span><span>    </span><span id="textcolor2242"><span>/* add one */</span></span> 
<a id="x1-49058r29"></a><span>29</span><span>    atomic_inc(&amp;debbie);</span> 
<a id="x1-49060r30"></a><span>30</span> 
<a id="x1-49062r31"></a><span>31</span><span>    pr_info(</span><span id="textcolor2243"><span>&#34;chris: %d, debbie: %d</span></span><span id="textcolor2244"><span>\n</span></span><span id="textcolor2245"><span>&#34;</span></span><span>, atomic_read(&amp;chris),</span> 
<a id="x1-49064r32"></a><span>32</span><span>            atomic_read(&amp;debbie));</span> 
<a id="x1-49066r33"></a><span>33</span><span>}</span> 
<a id="x1-49068r34"></a><span>34</span> 
<a id="x1-49070r35"></a><span>35</span><span id="textcolor2246"><span>static</span></span><span> </span><span id="textcolor2247"><span>void</span></span><span> atomic_bitwise(</span><span id="textcolor2248"><span>void</span></span><span>)</span> 
<a id="x1-49072r36"></a><span>36</span><span>{</span> 
<a id="x1-49074r37"></a><span>37</span><span>    </span><span id="textcolor2249"><span>unsigned</span></span><span> </span><span id="textcolor2250"><span>long</span></span><span> word = 0;</span> 
<a id="x1-49076r38"></a><span>38</span> 
<a id="x1-49078r39"></a><span>39</span><span>    pr_info(</span><span id="textcolor2251"><span>&#34;Bits 0: &#34;</span></span><span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span> 
<a id="x1-49080r40"></a><span>40</span><span>    set_bit(3, &amp;word);</span> 
<a id="x1-49082r41"></a><span>41</span><span>    set_bit(5, &amp;word);</span> 
<a id="x1-49084r42"></a><span>42</span><span>    pr_info(</span><span id="textcolor2252"><span>&#34;Bits 1: &#34;</span></span><span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span> 
<a id="x1-49086r43"></a><span>43</span><span>    clear_bit(5, &amp;word);</span> 
<a id="x1-49088r44"></a><span>44</span><span>    pr_info(</span><span id="textcolor2253"><span>&#34;Bits 2: &#34;</span></span><span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span> 
<a id="x1-49090r45"></a><span>45</span><span>    change_bit(3, &amp;word);</span> 
<a id="x1-49092r46"></a><span>46</span> 
<a id="x1-49094r47"></a><span>47</span><span>    pr_info(</span><span id="textcolor2254"><span>&#34;Bits 3: &#34;</span></span><span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span> 
<a id="x1-49096r48"></a><span>48</span><span>    </span><span id="textcolor2255"><span>if</span></span><span> (test_and_set_bit(3, &amp;word))</span> 
<a id="x1-49098r49"></a><span>49</span><span>        pr_info(</span><span id="textcolor2256"><span>&#34;wrong</span></span><span id="textcolor2257"><span>\n</span></span><span id="textcolor2258"><span>&#34;</span></span><span>);</span> 
<a id="x1-49100r50"></a><span>50</span><span>    pr_info(</span><span id="textcolor2259"><span>&#34;Bits 4: &#34;</span></span><span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span> 
<a id="x1-49102r51"></a><span>51</span> 
<a id="x1-49104r52"></a><span>52</span><span>    word = 255;</span> 
<a id="x1-49106r53"></a><span>53</span><span>    pr_info(</span><span id="textcolor2260"><span>&#34;Bits 5: &#34;</span></span><span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span> 
<a id="x1-49108r54"></a><span>54</span><span>}</span> 
<a id="x1-49110r55"></a><span>55</span> 
<a id="x1-49112r56"></a><span>56</span><span id="textcolor2261"><span>static</span></span><span> </span><span id="textcolor2262"><span>int</span></span><span> example_atomic_init(</span><span id="textcolor2263"><span>void</span></span><span>)</span> 
<a id="x1-49114r57"></a><span>57</span><span>{</span> 
<a id="x1-49116r58"></a><span>58</span><span>    pr_info(</span><span id="textcolor2264"><span>&#34;example_atomic started</span></span><span id="textcolor2265"><span>\n</span></span><span id="textcolor2266"><span>&#34;</span></span><span>);</span> 
<a id="x1-49118r59"></a><span>59</span> 
<a id="x1-49120r60"></a><span>60</span><span>    atomic_add_subtract();</span> 
<a id="x1-49122r61"></a><span>61</span><span>    atomic_bitwise();</span> 
<a id="x1-49124r62"></a><span>62</span> 
<a id="x1-49126r63"></a><span>63</span><span>    </span><span id="textcolor2267"><span>return</span></span><span> 0;</span> 
<a id="x1-49128r64"></a><span>64</span><span>}</span> 
<a id="x1-49130r65"></a><span>65</span> 
<a id="x1-49132r66"></a><span>66</span><span id="textcolor2268"><span>static</span></span><span> </span><span id="textcolor2269"><span>void</span></span><span> example_atomic_exit(</span><span id="textcolor2270"><span>void</span></span><span>)</span> 
<a id="x1-49134r67"></a><span>67</span><span>{</span> 
<a id="x1-49136r68"></a><span>68</span><span>    pr_info(</span><span id="textcolor2271"><span>&#34;example_atomic exit</span></span><span id="textcolor2272"><span>\n</span></span><span id="textcolor2273"><span>&#34;</span></span><span>);</span> 
<a id="x1-49138r69"></a><span>69</span><span>}</span> 
<a id="x1-49140r70"></a><span>70</span> 
<a id="x1-49142r71"></a><span>71</span><span>module_init(example_atomic_init);</span> 
<a id="x1-49144r72"></a><span>72</span><span>module_exit(example_atomic_exit);</span> 
<a id="x1-49146r73"></a><span>73</span> 
<a id="x1-49148r74"></a><span>74</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2274"><span>&#34;Atomic operations example&#34;</span></span><span>);</span> 
<a id="x1-49150r75"></a><span>75</span><span>MODULE_LICENSE(</span><span id="textcolor2275"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
                                                                  

                                                                  
<!-- l. 1687 --><p>   Before the C11 standard adopts the built-in atomic types, the kernel already
provided a small set of atomic types by using a bunch of tricky architecture-specific
codes. Implementing the atomic types by C11 atomics may allow the kernel to throw
away the architecture-specific codes and letting the kernel code be more friendly to
the people who understand the standard. But there are some problems, such as the
memory model of the kernel doesn’t match the model formed by the C11 atomics.
For further details, see: </p>
     <ul>
     <li><a href="https://www.kernel.org/doc/Documentation/atomic_t.txt">kernel documentation of atomic types</a>
     </li>
     <li><a href="https://lwn.net/Articles/691128/">Time to move to C11 atomics?</a>
     </li>
     <li><a href="https://lwn.net/Articles/698315/">Atomic usage patterns in the kernel</a></li></ul>
<!-- l. 1698 -->
   <h3 id="replacing-print-macros"><span>13   </span> <a id="x1-5000013"></a>Replacing Print Macros</h3>
<!-- l. 1700 -->
   <h4 id="replacement"><span>13.1   </span> <a id="x1-5100013.1"></a>Replacement</h4>
<!-- l. 1702 --><p>In Section <a href="#x1-80042">2<!-- tex4ht:ref: sec:using_x  --></a>, I said that X Window System and kernel module programming do not
mix. That is true for developing kernel modules. But in actual use, you want to be
able to send messages to whichever tty the command to load the module came
from.
</p><!-- l. 1706 --><p>   &#34;tty&#34; is an abbreviation of <span>teletype</span>: originally a combination keyboard-printer
used to communicate with a Unix system, and today an abstraction for the text
stream used for a Unix program, whether it is a physical terminal, an xterm on an X
display, a network connection used with ssh, etc.
</p><!-- l. 1708 --><p>   The way this is done is by using current, a pointer to the currently running task,
to get the current task’s tty structure. Then, we look inside that tty structure to find
a pointer to a string write function, which we use to write a string to the
tty.
</p><!-- l. 1 -->
   <pre id="fancyvrb73"><a id="x1-51002r1"></a><span>1</span><span id="textcolor2276"><span>/*</span></span> 
<a id="x1-51004r2"></a><span>2</span><span id="textcolor2277"><span> * print_string.c - Send output to the tty we</span><span>&#39;</span><span>re running on, regardless if</span></span> 
<a id="x1-51006r3"></a><span>3</span><span id="textcolor2278"><span> * it is through X11, telnet, etc.  We do this by printing the string to the</span></span> 
<a id="x1-51008r4"></a><span>4</span><span id="textcolor2279"><span> * tty associated with the current task.</span></span> 
<a id="x1-51010r5"></a><span>5</span><span id="textcolor2280"><span> */</span></span> 
<a id="x1-51012r6"></a><span>6</span><span id="textcolor2281"><span>#include</span></span><span> </span><span id="textcolor2282"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-51014r7"></a><span>7</span><span id="textcolor2283"><span>#include</span></span><span> </span><span id="textcolor2284"><span>&lt;linux/kernel.h&gt;</span></span> 
<a id="x1-51016r8"></a><span>8</span><span id="textcolor2285"><span>#include</span></span><span> </span><span id="textcolor2286"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-51018r9"></a><span>9</span><span id="textcolor2287"><span>#include</span></span><span> </span><span id="textcolor2288"><span>&lt;linux/sched.h&gt; /* For current */</span></span> 
<a id="x1-51020r10"></a><span>10</span><span id="textcolor2289"><span>#include</span></span><span> </span><span id="textcolor2290"><span>&lt;linux/tty.h&gt; /* For the tty declarations */</span></span> 
<a id="x1-51022r11"></a><span>11</span> 
<a id="x1-51024r12"></a><span>12</span><span id="textcolor2291"><span>static</span></span><span> </span><span id="textcolor2292"><span>void</span></span><span> print_string(</span><span id="textcolor2293"><span>char</span></span><span> *str)</span> 
<a id="x1-51026r13"></a><span>13</span><span>{</span> 
<a id="x1-51028r14"></a><span>14</span><span>    </span><span id="textcolor2294"><span>/* The tty for the current task */</span></span> 
<a id="x1-51030r15"></a><span>15</span><span>    </span><span id="textcolor2295"><span>struct</span></span><span> tty_struct *my_tty = get_current_tty();</span> 
<a id="x1-51032r16"></a><span>16</span> 
<a id="x1-51034r17"></a><span>17</span><span>    </span><span id="textcolor2296"><span>/* If my_tty is NULL, the current task has no tty you can print to (i.e.,</span></span> 
<a id="x1-51036r18"></a><span>18</span><span id="textcolor2297"><span>     * if it is a daemon). If so, there is nothing we can do.</span></span> 
<a id="x1-51038r19"></a><span>19</span><span id="textcolor2298"><span>     */</span></span> 
<a id="x1-51040r20"></a><span>20</span><span>    </span><span id="textcolor2299"><span>if</span></span><span> (my_tty) {</span> 
<a id="x1-51042r21"></a><span>21</span><span>        </span><span id="textcolor2300"><span>const</span></span><span> </span><span id="textcolor2301"><span>struct</span></span><span> tty_operations *ttyops = my_tty-&gt;driver-&gt;ops;</span> 
<a id="x1-51044r22"></a><span>22</span><span>        </span><span id="textcolor2302"><span>/* my_tty-&gt;driver is a struct which holds the tty</span><span>&#39;</span><span>s functions,</span></span> 
<a id="x1-51046r23"></a><span>23</span><span id="textcolor2303"><span>         * one of which (write) is used to write strings to the tty.</span></span> 
<a id="x1-51048r24"></a><span>24</span><span id="textcolor2304"><span>         * It can be used to take a string either from the user</span><span>&#39;</span><span>s or</span></span> 
<a id="x1-51050r25"></a><span>25</span><span id="textcolor2305"><span>         * kernel</span><span>&#39;</span><span>s memory segment.</span></span> 
<a id="x1-51052r26"></a><span>26</span><span id="textcolor2306"><span>         *</span></span> 
<a id="x1-51054r27"></a><span>27</span><span id="textcolor2307"><span>         * The function</span><span>&#39;</span><span>s 1st parameter is the tty to write to, because the</span></span> 
<a id="x1-51056r28"></a><span>28</span><span id="textcolor2308"><span>         * same function would normally be used for all tty</span><span>&#39;</span><span>s of a certain</span></span> 
<a id="x1-51058r29"></a><span>29</span><span id="textcolor2309"><span>         * type.</span></span> 
<a id="x1-51060r30"></a><span>30</span><span id="textcolor2310"><span>         * The 2nd parameter is a pointer to a string.</span></span> 
<a id="x1-51062r31"></a><span>31</span><span id="textcolor2311"><span>         * The 3rd parameter is the length of the string.</span></span> 
<a id="x1-51064r32"></a><span>32</span><span id="textcolor2312"><span>         *</span></span> 
<a id="x1-51066r33"></a><span>33</span><span id="textcolor2313"><span>         * As you will see below, sometimes it</span><span>&#39;</span><span>s necessary to use</span></span> 
<a id="x1-51068r34"></a><span>34</span><span id="textcolor2314"><span>         * preprocessor stuff to create code that works for different</span></span> 
<a id="x1-51070r35"></a><span>35</span><span id="textcolor2315"><span>         * kernel versions. The (naive) approach we</span><span>&#39;</span><span>ve taken here does not</span></span> 
<a id="x1-51072r36"></a><span>36</span><span id="textcolor2316"><span>         * scale well. The right way to deal with this is described in</span></span> 
<a id="x1-51074r37"></a><span>37</span><span id="textcolor2317"><span>         * section 2 of</span></span> 
<a id="x1-51076r38"></a><span>38</span><span id="textcolor2318"><span>         * linux/Documentation/SubmittingPatches</span></span> 
<a id="x1-51078r39"></a><span>39</span><span id="textcolor2319"><span>         */</span></span> 
<a id="x1-51080r40"></a><span>40</span><span>        (ttyops-&gt;write)(my_tty, </span><span id="textcolor2320"><span>/* The tty itself */</span></span> 
<a id="x1-51082r41"></a><span>41</span><span>                        str, </span><span id="textcolor2321"><span>/* String */</span></span> 
<a id="x1-51084r42"></a><span>42</span><span>                        strlen(str)); </span><span id="textcolor2322"><span>/* Length */</span></span> 
<a id="x1-51086r43"></a><span>43</span> 
<a id="x1-51088r44"></a><span>44</span><span>        </span><span id="textcolor2323"><span>/* ttys were originally hardware devices, which (usually) strictly</span></span> 
<a id="x1-51090r45"></a><span>45</span><span id="textcolor2324"><span>         * followed the ASCII standard. In ASCII, to move to a new line you</span></span> 
<a id="x1-51092r46"></a><span>46</span><span id="textcolor2325"><span>         * need two characters, a carriage return and a line feed. On Unix,</span></span> 
<a id="x1-51094r47"></a><span>47</span><span id="textcolor2326"><span>         * the ASCII line feed is used for both purposes - so we can not</span></span> 
<a id="x1-51096r48"></a><span>48</span><span id="textcolor2327"><span>         * just use \n, because it would not have a carriage return and the</span></span> 
<a id="x1-51098r49"></a><span>49</span><span id="textcolor2328"><span>         * next line will start at the column right after the line feed.</span></span> 
<a id="x1-51100r50"></a><span>50</span><span id="textcolor2329"><span>         *</span></span> 
<a id="x1-51102r51"></a><span>51</span><span id="textcolor2330"><span>         * This is why text files are different between Unix and MS Windows.</span></span> 
<a id="x1-51104r52"></a><span>52</span><span id="textcolor2331"><span>         * In CP/M and derivatives, like MS-DOS and MS Windows, the ASCII</span></span> 
<a id="x1-51106r53"></a><span>53</span><span id="textcolor2332"><span>         * standard was strictly adhered to, and therefore a newline requires</span></span> 
<a id="x1-51108r54"></a><span>54</span><span id="textcolor2333"><span>         * both a LF and a CR.</span></span> 
<a id="x1-51110r55"></a><span>55</span><span id="textcolor2334"><span>         */</span></span> 
<a id="x1-51112r56"></a><span>56</span><span>        (ttyops-&gt;write)(my_tty, </span><span id="textcolor2335"><span>&#34;</span></span><span id="textcolor2336"><span>\015\012</span></span><span id="textcolor2337"><span>&#34;</span></span><span>, 2);</span> 
<a id="x1-51114r57"></a><span>57</span><span>    }</span> 
<a id="x1-51116r58"></a><span>58</span><span>}</span> 
<a id="x1-51118r59"></a><span>59</span> 
<a id="x1-51120r60"></a><span>60</span><span id="textcolor2338"><span>static</span></span><span> </span><span id="textcolor2339"><span>int</span></span><span> __init print_string_init(</span><span id="textcolor2340"><span>void</span></span><span>)</span> 
<a id="x1-51122r61"></a><span>61</span><span>{</span> 
<a id="x1-51124r62"></a><span>62</span><span>    print_string(</span><span id="textcolor2341"><span>&#34;The module has been inserted.  Hello world!&#34;</span></span><span>);</span> 
<a id="x1-51126r63"></a><span>63</span><span>    </span><span id="textcolor2342"><span>return</span></span><span> 0;</span> 
<a id="x1-51128r64"></a><span>64</span><span>}</span> 
<a id="x1-51130r65"></a><span>65</span> 
<a id="x1-51132r66"></a><span>66</span><span id="textcolor2343"><span>static</span></span><span> </span><span id="textcolor2344"><span>void</span></span><span> __exit print_string_exit(</span><span id="textcolor2345"><span>void</span></span><span>)</span> 
<a id="x1-51134r67"></a><span>67</span><span>{</span> 
<a id="x1-51136r68"></a><span>68</span><span>    print_string(</span><span id="textcolor2346"><span>&#34;The module has been removed.  Farewell world!&#34;</span></span><span>);</span> 
<a id="x1-51138r69"></a><span>69</span><span>}</span> 
<a id="x1-51140r70"></a><span>70</span> 
<a id="x1-51142r71"></a><span>71</span><span>module_init(print_string_init);</span> 
<a id="x1-51144r72"></a><span>72</span><span>module_exit(print_string_exit);</span> 
<a id="x1-51146r73"></a><span>73</span> 
<a id="x1-51148r74"></a><span>74</span><span>MODULE_LICENSE(</span><span id="textcolor2347"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
                                                                  

                                                                  
<!-- l. 1713 -->
   <h4 id="flashing-keyboard-leds"><span>13.2   </span> <a id="x1-5200013.2"></a>Flashing keyboard LEDs</h4>
<!-- l. 1715 --><p>In certain conditions, you may desire a simpler and more direct way to communicate
to the external world. Flashing keyboard LEDs can be such a solution: It is an
immediate way to attract attention or to display a status condition. Keyboard LEDs
are present on every hardware, they are always visible, they do not need any setup,
and their use is rather simple and non-intrusive, compared to writing to a tty or a
file.
</p><!-- l. 1719 --><p>   From v4.14 to v4.15, the timer API made a series of changes
to improve memory safety. A buffer overflow in the area of a
<code> <span>timer_list</span>
</code> structure may be able to overwrite the
<code> <span>function</span>
</code> and <code>  <span>data</span>
</code> fields, providing the attacker with a way to use return-object programming (ROP)
to call arbitrary functions within the kernel. Also, the function prototype of the callback,
containing a <code>  <span id="textcolor2348"><span>unsigned</span></span><span> </span><span id="textcolor2349"><span>long</span></span>
</code> argument, will prevent work from any type checking. Furthermore, the function prototype
with <code>  <span id="textcolor2350"><span>unsigned</span></span><span> </span><span id="textcolor2351"><span>long</span></span>
</code> argument may be an obstacle to the forward-edge protection of <span>control-flow integrity</span>.
Thus, it is better to use a unique prototype to separate from the cluster that takes an
<code> <span id="textcolor2352"><span>unsigned</span></span><span> </span><span id="textcolor2353"><span>long</span></span>
</code> argument. The timer callback should be passed a pointer to the
<code> <span>timer_list</span>
</code> structure rather than an <code>  <span id="textcolor2354"><span>unsigned</span></span><span> </span><span id="textcolor2355"><span>long</span></span>
</code> argument. Then, it wraps all the information the callback needs, including the
<code> <span>timer_list</span>
</code> structure, into a larger structure, and it can use the
<code> <span>container_of</span>
</code> macro instead of the <code>  <span id="textcolor2356"><span>unsigned</span></span><span> </span><span id="textcolor2357"><span>long</span></span>
</code> value. For more information see: <a href="https://lwn.net/Articles/735887/">Improving the kernel timers API</a>.
</p><!-- l. 1728 --><p>   Before Linux v4.14, <code>  <span>setup_timer</span>
</code> was used to initialize the timer and the
<code> <span>timer_list</span>
</code> structure looked like: 
</p>
   <pre id="fancyvrb74"><a id="x1-52025r1"></a><span>1</span><span id="textcolor2358"><span>struct</span></span><span> timer_list {</span> 
<a id="x1-52027r2"></a><span>2</span><span>    </span><span id="textcolor2359"><span>unsigned</span></span><span> </span><span id="textcolor2360"><span>long</span></span><span> expires;</span> 
<a id="x1-52029r3"></a><span>3</span><span>    </span><span id="textcolor2361"><span>void</span></span><span> (*function)(</span><span id="textcolor2362"><span>unsigned</span></span><span> </span><span id="textcolor2363"><span>long</span></span><span>);</span> 
<a id="x1-52031r4"></a><span>4</span><span>    </span><span id="textcolor2364"><span>unsigned</span></span><span> </span><span id="textcolor2365"><span>long</span></span><span> data;</span> 
<a id="x1-52033r5"></a><span>5</span><span>    u32 flags;</span> 
<a id="x1-52035r6"></a><span>6</span><span>    </span><span id="textcolor2366"><span>/* ... */</span></span> 
<a id="x1-52037r7"></a><span>7</span><span>};</span> 
<a id="x1-52039r8"></a><span>8</span> 
<a id="x1-52041r9"></a><span>9</span><span id="textcolor2367"><span>void</span></span><span> setup_timer(</span><span id="textcolor2368"><span>struct</span></span><span> timer_list *timer, </span><span id="textcolor2369"><span>void</span></span><span> (*callback)(</span><span id="textcolor2370"><span>unsigned</span></span><span> </span><span id="textcolor2371"><span>long</span></span><span>),</span> 
<a id="x1-52043r10"></a><span>10</span><span>                 </span><span id="textcolor2372"><span>unsigned</span></span><span> </span><span id="textcolor2373"><span>long</span></span><span> data);</span></pre>
<!-- l. 1742 --><p>   Since Linux v4.14, <code>  <span>timer_setup</span>
</code> is adopted and the kernel step by step converting to
<code> <span>timer_setup</span>
</code> from <code>  <span>setup_timer</span>
</code>. One of the reasons why API was changed is it need to coexist with the old version interface.
Moreover, the <code>  <span>timer_setup</span>
                                                                  

                                                                  
</code> was implemented by <code>  <span>setup_timer</span>
</code> at first. 
</p>
   <pre id="fancyvrb75"><a id="x1-52052r1"></a><span>1</span><span id="textcolor2374"><span>void</span></span><span> timer_setup(</span><span id="textcolor2375"><span>struct</span></span><span> timer_list *timer,</span> 
<a id="x1-52054r2"></a><span>2</span><span>                 </span><span id="textcolor2376"><span>void</span></span><span> (*callback)(</span><span id="textcolor2377"><span>struct</span></span><span> timer_list *), </span><span id="textcolor2378"><span>unsigned</span></span><span> </span><span id="textcolor2379"><span>int</span></span><span> flags);</span></pre>
<!-- l. 1750 --><p>   The <code>  <span>setup_timer</span>
</code> was then removed since v4.15. As a result, the
<code> <span>timer_list</span>
</code> structure had changed to the following. 
</p>
   <pre id="fancyvrb76"><a id="x1-52064r1"></a><span>1</span><span id="textcolor2380"><span>struct</span></span><span> timer_list {</span> 
<a id="x1-52066r2"></a><span>2</span><span>    </span><span id="textcolor2381"><span>unsigned</span></span><span> </span><span id="textcolor2382"><span>long</span></span><span> expires;</span> 
<a id="x1-52068r3"></a><span>3</span><span>    </span><span id="textcolor2383"><span>void</span></span><span> (*function)(</span><span id="textcolor2384"><span>struct</span></span><span> timer_list *);</span> 
<a id="x1-52070r4"></a><span>4</span><span>    u32 flags;</span> 
<a id="x1-52072r5"></a><span>5</span><span>    </span><span id="textcolor2385"><span>/* ... */</span></span> 
<a id="x1-52074r6"></a><span>6</span><span>};</span></pre>
<!-- l. 1761 --><p>   The following source code illustrates a minimal kernel module which, when
loaded, starts blinking the keyboard LEDs until it is unloaded.
</p><!-- l. 1 -->
   <pre id="fancyvrb77"><a id="x1-52076r1"></a><span>1</span><span id="textcolor2386"><span>/*</span></span> 
<a id="x1-52078r2"></a><span>2</span><span id="textcolor2387"><span> * kbleds.c - Blink keyboard leds until the module is unloaded.</span></span> 
<a id="x1-52080r3"></a><span>3</span><span id="textcolor2388"><span> */</span></span> 
<a id="x1-52082r4"></a><span>4</span> 
<a id="x1-52084r5"></a><span>5</span><span id="textcolor2389"><span>#include</span></span><span> </span><span id="textcolor2390"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-52086r6"></a><span>6</span><span id="textcolor2391"><span>#include</span></span><span> </span><span id="textcolor2392"><span>&lt;linux/kd.h&gt; /* For KDSETLED */</span></span> 
<a id="x1-52088r7"></a><span>7</span><span id="textcolor2393"><span>#include</span></span><span> </span><span id="textcolor2394"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-52090r8"></a><span>8</span><span id="textcolor2395"><span>#include</span></span><span> </span><span id="textcolor2396"><span>&lt;linux/tty.h&gt; /* For tty_struct */</span></span> 
<a id="x1-52092r9"></a><span>9</span><span id="textcolor2397"><span>#include</span></span><span> </span><span id="textcolor2398"><span>&lt;linux/vt.h&gt; /* For MAX_NR_CONSOLES */</span></span> 
<a id="x1-52094r10"></a><span>10</span><span id="textcolor2399"><span>#include</span></span><span> </span><span id="textcolor2400"><span>&lt;linux/vt_kern.h&gt; /* for fg_console */</span></span> 
<a id="x1-52096r11"></a><span>11</span><span id="textcolor2401"><span>#include</span></span><span> </span><span id="textcolor2402"><span>&lt;linux/console_struct.h&gt; /* For vc_cons */</span></span> 
<a id="x1-52098r12"></a><span>12</span> 
<a id="x1-52100r13"></a><span>13</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2403"><span>&#34;Example module illustrating the use of Keyboard LEDs.&#34;</span></span><span>);</span> 
<a id="x1-52102r14"></a><span>14</span> 
<a id="x1-52104r15"></a><span>15</span><span id="textcolor2404"><span>static</span></span><span> </span><span id="textcolor2405"><span>struct</span></span><span> timer_list my_timer;</span> 
<a id="x1-52106r16"></a><span>16</span><span id="textcolor2406"><span>static</span></span><span> </span><span id="textcolor2407"><span>struct</span></span><span> tty_driver *my_driver;</span> 
<a id="x1-52108r17"></a><span>17</span><span id="textcolor2408"><span>static</span></span><span> </span><span id="textcolor2409"><span>unsigned</span></span><span> </span><span id="textcolor2410"><span>long</span></span><span> kbledstatus = 0;</span> 
<a id="x1-52110r18"></a><span>18</span> 
<a id="x1-52112r19"></a><span>19</span><span id="textcolor2411"><span>#define BLINK_DELAY HZ / 5</span></span> 
<a id="x1-52114r20"></a><span>20</span><span id="textcolor2412"><span>#define ALL_LEDS_ON 0x07</span></span> 
<a id="x1-52116r21"></a><span>21</span><span id="textcolor2413"><span>#define RESTORE_LEDS 0xFF</span></span> 
<a id="x1-52118r22"></a><span>22</span> 
<a id="x1-52120r23"></a><span>23</span><span id="textcolor2414"><span>/* Function my_timer_func blinks the keyboard LEDs periodically by invoking</span></span> 
<a id="x1-52122r24"></a><span>24</span><span id="textcolor2415"><span> * command KDSETLED of ioctl() on the keyboard driver. To learn more on virtual</span></span> 
<a id="x1-52124r25"></a><span>25</span><span id="textcolor2416"><span> * terminal ioctl operations, please see file:</span></span> 
<a id="x1-52126r26"></a><span>26</span><span id="textcolor2417"><span> *   drivers/tty/vt/vt_ioctl.c, function vt_ioctl().</span></span> 
<a id="x1-52128r27"></a><span>27</span><span id="textcolor2418"><span> *</span></span> 
<a id="x1-52130r28"></a><span>28</span><span id="textcolor2419"><span> * The argument to KDSETLED is alternatively set to 7 (thus causing the led</span></span> 
<a id="x1-52132r29"></a><span>29</span><span id="textcolor2420"><span> * mode to be set to LED_SHOW_IOCTL, and all the leds are lit) and to 0xFF</span></span> 
<a id="x1-52134r30"></a><span>30</span><span id="textcolor2421"><span> * (any value above 7 switches back the led mode to LED_SHOW_FLAGS, thus</span></span> 
<a id="x1-52136r31"></a><span>31</span><span id="textcolor2422"><span> * the LEDs reflect the actual keyboard status).  To learn more on this,</span></span> 
<a id="x1-52138r32"></a><span>32</span><span id="textcolor2423"><span> * please see file: drivers/tty/vt/keyboard.c, function setledstate().</span></span> 
<a id="x1-52140r33"></a><span>33</span><span id="textcolor2424"><span> */</span></span> 
<a id="x1-52142r34"></a><span>34</span><span id="textcolor2425"><span>static</span></span><span> </span><span id="textcolor2426"><span>void</span></span><span> my_timer_func(</span><span id="textcolor2427"><span>struct</span></span><span> timer_list *unused)</span> 
<a id="x1-52144r35"></a><span>35</span><span>{</span> 
<a id="x1-52146r36"></a><span>36</span><span>    </span><span id="textcolor2428"><span>struct</span></span><span> tty_struct *t = vc_cons[fg_console].d-&gt;port.tty;</span> 
<a id="x1-52148r37"></a><span>37</span> 
<a id="x1-52150r38"></a><span>38</span><span>    </span><span id="textcolor2429"><span>if</span></span><span> (kbledstatus == ALL_LEDS_ON)</span> 
<a id="x1-52152r39"></a><span>39</span><span>        kbledstatus = RESTORE_LEDS;</span> 
<a id="x1-52154r40"></a><span>40</span><span>    </span><span id="textcolor2430"><span>else</span></span> 
<a id="x1-52156r41"></a><span>41</span><span>        kbledstatus = ALL_LEDS_ON;</span> 
<a id="x1-52158r42"></a><span>42</span> 
<a id="x1-52160r43"></a><span>43</span><span>    (my_driver-&gt;ops-&gt;ioctl)(t, KDSETLED, kbledstatus);</span> 
<a id="x1-52162r44"></a><span>44</span> 
<a id="x1-52164r45"></a><span>45</span><span>    my_timer.expires = jiffies + BLINK_DELAY;</span> 
<a id="x1-52166r46"></a><span>46</span><span>    add_timer(&amp;my_timer);</span> 
<a id="x1-52168r47"></a><span>47</span><span>}</span> 
<a id="x1-52170r48"></a><span>48</span> 
<a id="x1-52172r49"></a><span>49</span><span id="textcolor2431"><span>static</span></span><span> </span><span id="textcolor2432"><span>int</span></span><span> __init kbleds_init(</span><span id="textcolor2433"><span>void</span></span><span>)</span> 
<a id="x1-52174r50"></a><span>50</span><span>{</span> 
<a id="x1-52176r51"></a><span>51</span><span>    </span><span id="textcolor2434"><span>int</span></span><span> i;</span> 
<a id="x1-52178r52"></a><span>52</span> 
<a id="x1-52180r53"></a><span>53</span><span>    pr_info(</span><span id="textcolor2435"><span>&#34;kbleds: loading</span></span><span id="textcolor2436"><span>\n</span></span><span id="textcolor2437"><span>&#34;</span></span><span>);</span> 
<a id="x1-52182r54"></a><span>54</span><span>    pr_info(</span><span id="textcolor2438"><span>&#34;kbleds: fgconsole is %x</span></span><span id="textcolor2439"><span>\n</span></span><span id="textcolor2440"><span>&#34;</span></span><span>, fg_console);</span> 
<a id="x1-52184r55"></a><span>55</span><span>    </span><span id="textcolor2441"><span>for</span></span><span> (i = 0; i &lt; MAX_NR_CONSOLES; i++) {</span> 
<a id="x1-52186r56"></a><span>56</span><span>        </span><span id="textcolor2442"><span>if</span></span><span> (!vc_cons[i].d)</span> 
<a id="x1-52188r57"></a><span>57</span><span>            </span><span id="textcolor2443"><span>break</span></span><span>;</span> 
<a id="x1-52190r58"></a><span>58</span><span>        pr_info(</span><span id="textcolor2444"><span>&#34;poet_atkm: console[%i/%i] #%i, tty %p</span></span><span id="textcolor2445"><span>\n</span></span><span id="textcolor2446"><span>&#34;</span></span><span>, i, MAX_NR_CONSOLES,</span> 
<a id="x1-52192r59"></a><span>59</span><span>                vc_cons[i].d-&gt;vc_num, (</span><span id="textcolor2447"><span>void</span></span><span> *)vc_cons[i].d-&gt;port.tty);</span> 
<a id="x1-52194r60"></a><span>60</span><span>    }</span> 
<a id="x1-52196r61"></a><span>61</span><span>    pr_info(</span><span id="textcolor2448"><span>&#34;kbleds: finished scanning consoles</span></span><span id="textcolor2449"><span>\n</span></span><span id="textcolor2450"><span>&#34;</span></span><span>);</span> 
<a id="x1-52198r62"></a><span>62</span> 
<a id="x1-52200r63"></a><span>63</span><span>    my_driver = vc_cons[fg_console].d-&gt;port.tty-&gt;driver;</span> 
<a id="x1-52202r64"></a><span>64</span><span>    pr_info(</span><span id="textcolor2451"><span>&#34;kbleds: tty driver magic %x</span></span><span id="textcolor2452"><span>\n</span></span><span id="textcolor2453"><span>&#34;</span></span><span>, my_driver-&gt;magic);</span> 
<a id="x1-52204r65"></a><span>65</span> 
<a id="x1-52206r66"></a><span>66</span><span>    </span><span id="textcolor2454"><span>/* Set up the LED blink timer the first time. */</span></span> 
<a id="x1-52208r67"></a><span>67</span><span>    timer_setup(&amp;my_timer, my_timer_func, 0);</span> 
<a id="x1-52210r68"></a><span>68</span><span>    my_timer.expires = jiffies + BLINK_DELAY;</span> 
<a id="x1-52212r69"></a><span>69</span><span>    add_timer(&amp;my_timer);</span> 
<a id="x1-52214r70"></a><span>70</span> 
<a id="x1-52216r71"></a><span>71</span><span>    </span><span id="textcolor2455"><span>return</span></span><span> 0;</span> 
<a id="x1-52218r72"></a><span>72</span><span>}</span> 
<a id="x1-52220r73"></a><span>73</span> 
<a id="x1-52222r74"></a><span>74</span><span id="textcolor2456"><span>static</span></span><span> </span><span id="textcolor2457"><span>void</span></span><span> __exit kbleds_cleanup(</span><span id="textcolor2458"><span>void</span></span><span>)</span> 
<a id="x1-52224r75"></a><span>75</span><span>{</span> 
<a id="x1-52226r76"></a><span>76</span><span>    pr_info(</span><span id="textcolor2459"><span>&#34;kbleds: unloading...</span></span><span id="textcolor2460"><span>\n</span></span><span id="textcolor2461"><span>&#34;</span></span><span>);</span> 
<a id="x1-52228r77"></a><span>77</span><span>    del_timer(&amp;my_timer);</span> 
<a id="x1-52230r78"></a><span>78</span><span>    (my_driver-&gt;ops-&gt;ioctl)(vc_cons[fg_console].d-&gt;port.tty, KDSETLED,</span> 
<a id="x1-52232r79"></a><span>79</span><span>                            RESTORE_LEDS);</span> 
<a id="x1-52234r80"></a><span>80</span><span>}</span> 
<a id="x1-52236r81"></a><span>81</span> 
<a id="x1-52238r82"></a><span>82</span><span>module_init(kbleds_init);</span> 
<a id="x1-52240r83"></a><span>83</span><span>module_exit(kbleds_cleanup);</span> 
<a id="x1-52242r84"></a><span>84</span> 
<a id="x1-52244r85"></a><span>85</span><span>MODULE_LICENSE(</span><span id="textcolor2462"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1765 --><p>   If none of the examples in this chapter fit your debugging needs,
there might yet be some other tricks to try. Ever wondered what
<code> <span>CONFIG_LL_DEBUG</span>
</code> in <code>  <span>make menuconfig</span>
</code> is good for? If you activate that you get low level access to the serial port. While this
might not sound very powerful by itself, you can patch <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/printk.c">kernel/printk.c</a> or any other
essential syscall to print ASCII characters, thus making it possible to trace virtually
everything what your code does over a serial line. If you find yourself porting the
kernel to some new and former unsupported architecture, this is usually amongst the
first things that should be implemented. Logging over a netconsole might also be
worth a try.
</p><!-- l. 1772 --><p>   While you have seen lots of stuff that can be used to aid debugging here, there are
some things to be aware of. Debugging is almost always intrusive. Adding debug code
can change the situation enough to make the bug seem to disappear. Thus, you
should keep debug code to a minimum and make sure it does not show up in
production code.
</p><!-- l. 1776 -->
   <h3 id="scheduling-tasks"><span>14   </span> <a id="x1-5300014"></a>Scheduling Tasks</h3>
<!-- l. 1778 --><p>There are two main ways of running tasks: tasklets and work queues. Tasklets are a
quick and easy way of scheduling a single function to be run. For example, when
triggered from an interrupt, whereas work queues are more complicated but also
better suited to running multiple things in a sequence.
                                                                  

                                                                  
</p><!-- l. 1782 -->
   <h4 id="tasklets"><span>14.1   </span> <a id="x1-5400014.1"></a>Tasklets</h4>
<!-- l. 1784 --><p>Here is an example tasklet module. The
<code> <span>tasklet_fn</span>
</code> function runs for a few seconds. In the meantime, execution of the
<code> <span>example_tasklet_init</span>
</code> function may continue to the exit point, depending on whether it is interrupted by
<span>softirq</span>.
</p><!-- l. 1 -->
   <pre id="fancyvrb78"><a id="x1-54004r1"></a><span>1</span><span id="textcolor2463"><span>/*</span></span> 
<a id="x1-54006r2"></a><span>2</span><span id="textcolor2464"><span> * example_tasklet.c</span></span> 
<a id="x1-54008r3"></a><span>3</span><span id="textcolor2465"><span> */</span></span> 
<a id="x1-54010r4"></a><span>4</span><span id="textcolor2466"><span>#include</span></span><span> </span><span id="textcolor2467"><span>&lt;linux/delay.h&gt;</span></span> 
<a id="x1-54012r5"></a><span>5</span><span id="textcolor2468"><span>#include</span></span><span> </span><span id="textcolor2469"><span>&lt;linux/interrupt.h&gt;</span></span> 
<a id="x1-54014r6"></a><span>6</span><span id="textcolor2470"><span>#include</span></span><span> </span><span id="textcolor2471"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-54016r7"></a><span>7</span><span id="textcolor2472"><span>#include</span></span><span> </span><span id="textcolor2473"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-54018r8"></a><span>8</span> 
<a id="x1-54020r9"></a><span>9</span><span id="textcolor2474"><span>/* Macro DECLARE_TASKLET_OLD exists for compatibility.</span></span> 
<a id="x1-54022r10"></a><span>10</span><span id="textcolor2475"><span> * See https://lwn.net/Articles/830964/</span></span> 
<a id="x1-54024r11"></a><span>11</span><span id="textcolor2476"><span> */</span></span> 
<a id="x1-54026r12"></a><span>12</span><span id="textcolor2477"><span>#ifndef DECLARE_TASKLET_OLD</span></span> 
<a id="x1-54028r13"></a><span>13</span><span id="textcolor2478"><span>#define DECLARE_TASKLET_OLD(arg1, arg2) DECLARE_TASKLET(arg1, arg2, 0L)</span></span> 
<a id="x1-54030r14"></a><span>14</span><span id="textcolor2479"><span>#endif</span></span> 
<a id="x1-54032r15"></a><span>15</span> 
<a id="x1-54034r16"></a><span>16</span><span id="textcolor2480"><span>static</span></span><span> </span><span id="textcolor2481"><span>void</span></span><span> tasklet_fn(</span><span id="textcolor2482"><span>unsigned</span></span><span> </span><span id="textcolor2483"><span>long</span></span><span> data)</span> 
<a id="x1-54036r17"></a><span>17</span><span>{</span> 
<a id="x1-54038r18"></a><span>18</span><span>    pr_info(</span><span id="textcolor2484"><span>&#34;Example tasklet starts</span></span><span id="textcolor2485"><span>\n</span></span><span id="textcolor2486"><span>&#34;</span></span><span>);</span> 
<a id="x1-54040r19"></a><span>19</span><span>    mdelay(5000);</span> 
<a id="x1-54042r20"></a><span>20</span><span>    pr_info(</span><span id="textcolor2487"><span>&#34;Example tasklet ends</span></span><span id="textcolor2488"><span>\n</span></span><span id="textcolor2489"><span>&#34;</span></span><span>);</span> 
<a id="x1-54044r21"></a><span>21</span><span>}</span> 
<a id="x1-54046r22"></a><span>22</span> 
<a id="x1-54048r23"></a><span>23</span><span id="textcolor2490"><span>static</span></span><span> DECLARE_TASKLET_OLD(mytask, tasklet_fn);</span> 
<a id="x1-54050r24"></a><span>24</span> 
<a id="x1-54052r25"></a><span>25</span><span id="textcolor2491"><span>static</span></span><span> </span><span id="textcolor2492"><span>int</span></span><span> example_tasklet_init(</span><span id="textcolor2493"><span>void</span></span><span>)</span> 
<a id="x1-54054r26"></a><span>26</span><span>{</span> 
<a id="x1-54056r27"></a><span>27</span><span>    pr_info(</span><span id="textcolor2494"><span>&#34;tasklet example init</span></span><span id="textcolor2495"><span>\n</span></span><span id="textcolor2496"><span>&#34;</span></span><span>);</span> 
<a id="x1-54058r28"></a><span>28</span><span>    tasklet_schedule(&amp;mytask);</span> 
<a id="x1-54060r29"></a><span>29</span><span>    mdelay(200);</span> 
<a id="x1-54062r30"></a><span>30</span><span>    pr_info(</span><span id="textcolor2497"><span>&#34;Example tasklet init continues...</span></span><span id="textcolor2498"><span>\n</span></span><span id="textcolor2499"><span>&#34;</span></span><span>);</span> 
<a id="x1-54064r31"></a><span>31</span><span>    </span><span id="textcolor2500"><span>return</span></span><span> 0;</span> 
<a id="x1-54066r32"></a><span>32</span><span>}</span> 
<a id="x1-54068r33"></a><span>33</span> 
<a id="x1-54070r34"></a><span>34</span><span id="textcolor2501"><span>static</span></span><span> </span><span id="textcolor2502"><span>void</span></span><span> example_tasklet_exit(</span><span id="textcolor2503"><span>void</span></span><span>)</span> 
<a id="x1-54072r35"></a><span>35</span><span>{</span> 
<a id="x1-54074r36"></a><span>36</span><span>    pr_info(</span><span id="textcolor2504"><span>&#34;tasklet example exit</span></span><span id="textcolor2505"><span>\n</span></span><span id="textcolor2506"><span>&#34;</span></span><span>);</span> 
<a id="x1-54076r37"></a><span>37</span><span>    tasklet_kill(&amp;mytask);</span> 
<a id="x1-54078r38"></a><span>38</span><span>}</span> 
<a id="x1-54080r39"></a><span>39</span> 
<a id="x1-54082r40"></a><span>40</span><span>module_init(example_tasklet_init);</span> 
<a id="x1-54084r41"></a><span>41</span><span>module_exit(example_tasklet_exit);</span> 
<a id="x1-54086r42"></a><span>42</span> 
<a id="x1-54088r43"></a><span>43</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2507"><span>&#34;Tasklet example&#34;</span></span><span>);</span> 
<a id="x1-54090r44"></a><span>44</span><span>MODULE_LICENSE(</span><span id="textcolor2508"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1790 --><p>   So with this example loaded <code>  <span>dmesg</span>
</code> should show:
                                                                  

                                                                  
</p>
   <pre id="verbatim-21">tasklet example init
Example tasklet starts
Example tasklet init continues...
Example tasklet ends
</pre>
<!-- l. 1797 --><p>Although tasklet is easy to use, it comes with several defators, and developers are
discussing about getting rid of tasklet in linux kernel. The tasklet callback
runs in atomic context, inside a software interrupt, meaning that it cannot
sleep or access user-space data, so not all work can be done in a tasklet
handler. Also, the kernel only allows one instance of any given tasklet to be
running at any given time; multiple different tasklet callbacks can run in
parallel.
</p><!-- l. 1802 --><p>   In recent kernels, tasklets can be replaced by workqueues, timers, or threaded
interrupts.<a id="x1-54092f1"></a>
While the removal of tasklets remains a longer-term goal, the current kernel contains more
than a hundred uses of tasklets. Now developers are proceeding with the API changes and
the macro <code>  <span>DECLARE_TASKLET_OLD</span>
</code> exists for compatibility. For further information, see <a href="https://lwn.net/Articles/830964/"><span>https://lwn.net/Articles/830964/</span></a>.
</p><!-- l. 1808 -->
   <h4 id="work-queues"><span>14.2   </span> <a id="x1-5500014.2"></a>Work queues</h4>
<!-- l. 1810 --><p>To add a task to the scheduler we can use a workqueue. The kernel then uses the
Completely Fair Scheduler (CFS) to execute work within the queue.
</p><!-- l. 1 -->
   <pre id="fancyvrb79"><a id="x1-55002r1"></a><span>1</span><span id="textcolor2509"><span>/*</span></span> 
<a id="x1-55004r2"></a><span>2</span><span id="textcolor2510"><span> * sched.c</span></span> 
<a id="x1-55006r3"></a><span>3</span><span id="textcolor2511"><span> */</span></span> 
<a id="x1-55008r4"></a><span>4</span><span id="textcolor2512"><span>#include</span></span><span> </span><span id="textcolor2513"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-55010r5"></a><span>5</span><span id="textcolor2514"><span>#include</span></span><span> </span><span id="textcolor2515"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-55012r6"></a><span>6</span><span id="textcolor2516"><span>#include</span></span><span> </span><span id="textcolor2517"><span>&lt;linux/workqueue.h&gt;</span></span> 
<a id="x1-55014r7"></a><span>7</span> 
<a id="x1-55016r8"></a><span>8</span><span id="textcolor2518"><span>static</span></span><span> </span><span id="textcolor2519"><span>struct</span></span><span> workqueue_struct *queue = NULL;</span> 
<a id="x1-55018r9"></a><span>9</span><span id="textcolor2520"><span>static</span></span><span> </span><span id="textcolor2521"><span>struct</span></span><span> work_struct work;</span> 
<a id="x1-55020r10"></a><span>10</span> 
<a id="x1-55022r11"></a><span>11</span><span id="textcolor2522"><span>static</span></span><span> </span><span id="textcolor2523"><span>void</span></span><span> work_handler(</span><span id="textcolor2524"><span>struct</span></span><span> work_struct *data)</span> 
<a id="x1-55024r12"></a><span>12</span><span>{</span> 
<a id="x1-55026r13"></a><span>13</span><span>    pr_info(</span><span id="textcolor2525"><span>&#34;work handler function.</span></span><span id="textcolor2526"><span>\n</span></span><span id="textcolor2527"><span>&#34;</span></span><span>);</span> 
<a id="x1-55028r14"></a><span>14</span><span>}</span> 
<a id="x1-55030r15"></a><span>15</span> 
<a id="x1-55032r16"></a><span>16</span><span id="textcolor2528"><span>static</span></span><span> </span><span id="textcolor2529"><span>int</span></span><span> __init sched_init(</span><span id="textcolor2530"><span>void</span></span><span>)</span> 
<a id="x1-55034r17"></a><span>17</span><span>{</span> 
<a id="x1-55036r18"></a><span>18</span><span>    queue = alloc_workqueue(</span><span id="textcolor2531"><span>&#34;HELLOWORLD&#34;</span></span><span>, WQ_UNBOUND, 1);</span> 
<a id="x1-55038r19"></a><span>19</span><span>    INIT_WORK(&amp;work, work_handler);</span> 
<a id="x1-55040r20"></a><span>20</span><span>    schedule_work(&amp;work);</span> 
<a id="x1-55042r21"></a><span>21</span><span>    </span><span id="textcolor2532"><span>return</span></span><span> 0;</span> 
<a id="x1-55044r22"></a><span>22</span><span>}</span> 
<a id="x1-55046r23"></a><span>23</span> 
<a id="x1-55048r24"></a><span>24</span><span id="textcolor2533"><span>static</span></span><span> </span><span id="textcolor2534"><span>void</span></span><span> __exit sched_exit(</span><span id="textcolor2535"><span>void</span></span><span>)</span> 
<a id="x1-55050r25"></a><span>25</span><span>{</span> 
<a id="x1-55052r26"></a><span>26</span><span>    destroy_workqueue(queue);</span> 
<a id="x1-55054r27"></a><span>27</span><span>}</span> 
<a id="x1-55056r28"></a><span>28</span> 
<a id="x1-55058r29"></a><span>29</span><span>module_init(sched_init);</span> 
<a id="x1-55060r30"></a><span>30</span><span>module_exit(sched_exit);</span> 
<a id="x1-55062r31"></a><span>31</span> 
<a id="x1-55064r32"></a><span>32</span><span>MODULE_LICENSE(</span><span id="textcolor2536"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-55066r33"></a><span>33</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2537"><span>&#34;Workqueue example&#34;</span></span><span>);</span></pre>
<!-- l. 1815 -->
   <h3 id="interrupt-handlers"><span>15   </span> <a id="x1-5600015"></a>Interrupt Handlers</h3>
<!-- l. 1817 -->
                                                                  

                                                                  
   <h4 id="interrupt-handlers1"><span>15.1   </span> <a id="x1-5700015.1"></a>Interrupt Handlers</h4>
<!-- l. 1819 --><p>Except for the last chapter, everything we did in the kernel so far we have done as a
response to a process asking for it, either by dealing with a special file, sending an
<code> <span>ioctl()</span>
</code>, or issuing a system call. But the job of the kernel is not just to respond to process
requests. Another job, which is every bit as important, is to speak to the hardware
connected to the machine.
</p><!-- l. 1823 --><p>   There are two types of interaction between the CPU and the rest of the
computer’s hardware. The first type is when the CPU gives orders to the hardware,
the other is when the hardware needs to tell the CPU something. The second, called
interrupts, is much harder to implement because it has to be dealt with when
convenient for the hardware, not the CPU. Hardware devices typically have a very
small amount of RAM, and if you do not read their information when available, it is
lost.
</p><!-- l. 1828 --><p>   Under Linux, hardware interrupts are called IRQ’s (Interrupt ReQuests). There
are two types of IRQ’s, short and long. A short IRQ is one which is expected to take
a very short period of time, during which the rest of the machine will be blocked and
no other interrupts will be handled. A long IRQ is one which can take longer, and
during which other interrupts may occur (but not interrupts from the same
device). If at all possible, it is better to declare an interrupt handler to be
long.
</p><!-- l. 1834 --><p>   When the CPU receives an interrupt, it stops whatever it is doing (unless it is
processing a more important interrupt, in which case it will deal with this one only
when the more important one is done), saves certain parameters on the stack and
calls the interrupt handler. This means that certain things are not allowed in the
interrupt handler itself, because the system is in an unknown state. Linux kernel
solves the problem by splitting interrupt handling into two parts. The first part
executes right away and masks the interrupt line. Hardware interrupts must be
handled quickly, and that is why we need the second part to handle the
heavy work deferred from an interrupt handler. Historically, BH (Linux
naming for <span>Bottom Halves</span>) statistically book-keeps the deferred functions.
<span>Softirq </span>and its higher level abstraction, <span>Tasklet</span>, replace BH since Linux
2.3.
</p><!-- l. 1844 --><p>   The way to implement this is to call
<code> <span>request_irq()</span>
</code> to get your interrupt handler called when the relevant IRQ is received.
</p><!-- l. 1846 --><p>   In practice IRQ handling can be a bit more complex. Hardware is often designed
in a way that chains two interrupt controllers, so that all the IRQs from
interrupt controller B are cascaded to a certain IRQ from interrupt controller A.
Of course, that requires that the kernel finds out which IRQ it really was
afterwards and that adds overhead. Other architectures offer some special,
very low overhead, so called &#34;fast IRQ&#34; or FIQs. To take advantage of them
requires handlers to be written in assembly language, so they do not really
fit into the kernel. They can be made to work similar to the others, but
after that procedure, they are no longer any faster than &#34;common&#34; IRQs.
SMP enabled kernels running on systems with more than one processor
                                                                  

                                                                  
need to solve another truckload of problems. It is not enough to know if a
certain IRQs has happened, it’s also important to know what CPU(s) it was
for. People still interested in more details, might want to refer to &#34;APIC&#34;
now.
</p><!-- l. 1855 --><p>   This function receives the IRQ number, the name of the function,
flags, a name for <span><span><span>/proc/interrupts</span></span></span> and a parameter to be passed to the
interrupt handler. Usually there is a certain number of IRQs available.
How many IRQs there are is hardware-dependent. The flags can include
<code> <span>SA_SHIRQ</span>
</code> to indicate you are willing to share the IRQ with other interrupt handlers
(usually because a number of hardware devices sit on the same IRQ) and
<code> <span>SA_INTERRUPT</span>
</code> to indicate this is a fast interrupt. This function will only succeed if there is not
already a handler on this IRQ, or if you are both willing to share.
</p><!-- l. 1861 -->
   <h4 id="detecting-button-presses"><span>15.2   </span> <a id="x1-5800015.2"></a>Detecting button presses</h4>
<!-- l. 1863 --><p>Many popular single board computers, such as Raspberry Pi or Beagleboards, have a
bunch of GPIO pins. Attaching buttons to those and then having a button press do
something is a classic case in which you might need to use interrupts, so that instead
of having the CPU waste time and battery power polling for a change in input state,
it is better for the input to trigger the CPU to then run a particular handling
function.
</p><!-- l. 1867 --><p>   Here is an example where buttons are connected to GPIO numbers 17 and 18 and
an LED is connected to GPIO 4. You can change those numbers to whatever is
appropriate for your board.
</p><!-- l. 1 -->
   <pre id="fancyvrb80"><a id="x1-58002r1"></a><span>1</span><span id="textcolor2538"><span>/*</span></span> 
<a id="x1-58004r2"></a><span>2</span><span id="textcolor2539"><span> * intrpt.c - Handling GPIO with interrupts</span></span> 
<a id="x1-58006r3"></a><span>3</span><span id="textcolor2540"><span> *</span></span> 
<a id="x1-58008r4"></a><span>4</span><span id="textcolor2541"><span> * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)</span></span> 
<a id="x1-58010r5"></a><span>5</span><span id="textcolor2542"><span> * from:</span></span> 
<a id="x1-58012r6"></a><span>6</span><span id="textcolor2543"><span> *   https://github.com/wendlers/rpi-kmod-samples</span></span> 
<a id="x1-58014r7"></a><span>7</span><span id="textcolor2544"><span> *</span></span> 
<a id="x1-58016r8"></a><span>8</span><span id="textcolor2545"><span> * Press one button to turn on a LED and another to turn it off.</span></span> 
<a id="x1-58018r9"></a><span>9</span><span id="textcolor2546"><span> */</span></span> 
<a id="x1-58020r10"></a><span>10</span> 
<a id="x1-58022r11"></a><span>11</span><span id="textcolor2547"><span>#include</span></span><span> </span><span id="textcolor2548"><span>&lt;linux/gpio.h&gt;</span></span> 
<a id="x1-58024r12"></a><span>12</span><span id="textcolor2549"><span>#include</span></span><span> </span><span id="textcolor2550"><span>&lt;linux/interrupt.h&gt;</span></span> 
<a id="x1-58026r13"></a><span>13</span><span id="textcolor2551"><span>#include</span></span><span> </span><span id="textcolor2552"><span>&lt;linux/kernel.h&gt; /* for ARRAY_SIZE() */</span></span> 
<a id="x1-58028r14"></a><span>14</span><span id="textcolor2553"><span>#include</span></span><span> </span><span id="textcolor2554"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-58030r15"></a><span>15</span><span id="textcolor2555"><span>#include</span></span><span> </span><span id="textcolor2556"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-58032r16"></a><span>16</span> 
<a id="x1-58034r17"></a><span>17</span><span id="textcolor2557"><span>static</span></span><span> </span><span id="textcolor2558"><span>int</span></span><span> button_irqs[] = { -1, -1 };</span> 
<a id="x1-58036r18"></a><span>18</span> 
<a id="x1-58038r19"></a><span>19</span><span id="textcolor2559"><span>/* Define GPIOs for LEDs.</span></span> 
<a id="x1-58040r20"></a><span>20</span><span id="textcolor2560"><span> * TODO: Change the numbers for the GPIO on your board.</span></span> 
<a id="x1-58042r21"></a><span>21</span><span id="textcolor2561"><span> */</span></span> 
<a id="x1-58044r22"></a><span>22</span><span id="textcolor2562"><span>static</span></span><span> </span><span id="textcolor2563"><span>struct</span></span><span> gpio leds[] = { { 4, GPIOF_OUT_INIT_LOW, </span><span id="textcolor2564"><span>&#34;LED 1&#34;</span></span><span> } };</span> 
<a id="x1-58046r23"></a><span>23</span> 
<a id="x1-58048r24"></a><span>24</span><span id="textcolor2565"><span>/* Define GPIOs for BUTTONS</span></span> 
<a id="x1-58050r25"></a><span>25</span><span id="textcolor2566"><span> * TODO: Change the numbers for the GPIO on your board.</span></span> 
<a id="x1-58052r26"></a><span>26</span><span id="textcolor2567"><span> */</span></span> 
<a id="x1-58054r27"></a><span>27</span><span id="textcolor2568"><span>static</span></span><span> </span><span id="textcolor2569"><span>struct</span></span><span> gpio buttons[] = { { 17, GPIOF_IN, </span><span id="textcolor2570"><span>&#34;LED 1 ON BUTTON&#34;</span></span><span> },</span> 
<a id="x1-58056r28"></a><span>28</span><span>                                 { 18, GPIOF_IN, </span><span id="textcolor2571"><span>&#34;LED 1 OFF BUTTON&#34;</span></span><span> } };</span> 
<a id="x1-58058r29"></a><span>29</span> 
<a id="x1-58060r30"></a><span>30</span><span id="textcolor2572"><span>/* interrupt function triggered when a button is pressed. */</span></span> 
<a id="x1-58062r31"></a><span>31</span><span id="textcolor2573"><span>static</span></span><span> irqreturn_t button_isr(</span><span id="textcolor2574"><span>int</span></span><span> irq, </span><span id="textcolor2575"><span>void</span></span><span> *data)</span> 
<a id="x1-58064r32"></a><span>32</span><span>{</span> 
<a id="x1-58066r33"></a><span>33</span><span>    </span><span id="textcolor2576"><span>/* first button */</span></span> 
<a id="x1-58068r34"></a><span>34</span><span>    </span><span id="textcolor2577"><span>if</span></span><span> (irq == button_irqs[0] &amp;&amp; !gpio_get_value(leds[0].gpio))</span> 
<a id="x1-58070r35"></a><span>35</span><span>        gpio_set_value(leds[0].gpio, 1);</span> 
<a id="x1-58072r36"></a><span>36</span><span>    </span><span id="textcolor2578"><span>/* second button */</span></span> 
<a id="x1-58074r37"></a><span>37</span><span>    </span><span id="textcolor2579"><span>else</span></span><span> </span><span id="textcolor2580"><span>if</span></span><span> (irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))</span> 
<a id="x1-58076r38"></a><span>38</span><span>        gpio_set_value(leds[0].gpio, 0);</span> 
<a id="x1-58078r39"></a><span>39</span> 
<a id="x1-58080r40"></a><span>40</span><span>    </span><span id="textcolor2581"><span>return</span></span><span> IRQ_HANDLED;</span> 
<a id="x1-58082r41"></a><span>41</span><span>}</span> 
<a id="x1-58084r42"></a><span>42</span> 
<a id="x1-58086r43"></a><span>43</span><span id="textcolor2582"><span>static</span></span><span> </span><span id="textcolor2583"><span>int</span></span><span> __init intrpt_init(</span><span id="textcolor2584"><span>void</span></span><span>)</span> 
<a id="x1-58088r44"></a><span>44</span><span>{</span> 
<a id="x1-58090r45"></a><span>45</span><span>    </span><span id="textcolor2585"><span>int</span></span><span> ret = 0;</span> 
<a id="x1-58092r46"></a><span>46</span> 
<a id="x1-58094r47"></a><span>47</span><span>    pr_info(</span><span id="textcolor2586"><span>&#34;%s</span></span><span id="textcolor2587"><span>\n</span></span><span id="textcolor2588"><span>&#34;</span></span><span>, __func__);</span> 
<a id="x1-58096r48"></a><span>48</span> 
<a id="x1-58098r49"></a><span>49</span><span>    </span><span id="textcolor2589"><span>/* register LED gpios */</span></span> 
<a id="x1-58100r50"></a><span>50</span><span>    ret = gpio_request_array(leds, ARRAY_SIZE(leds));</span> 
<a id="x1-58102r51"></a><span>51</span> 
<a id="x1-58104r52"></a><span>52</span><span>    </span><span id="textcolor2590"><span>if</span></span><span> (ret) {</span> 
<a id="x1-58106r53"></a><span>53</span><span>        pr_err(</span><span id="textcolor2591"><span>&#34;Unable to request GPIOs for LEDs: %d</span></span><span id="textcolor2592"><span>\n</span></span><span id="textcolor2593"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-58108r54"></a><span>54</span><span>        </span><span id="textcolor2594"><span>return</span></span><span> ret;</span> 
<a id="x1-58110r55"></a><span>55</span><span>    }</span> 
<a id="x1-58112r56"></a><span>56</span> 
<a id="x1-58114r57"></a><span>57</span><span>    </span><span id="textcolor2595"><span>/* register BUTTON gpios */</span></span> 
<a id="x1-58116r58"></a><span>58</span><span>    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));</span> 
<a id="x1-58118r59"></a><span>59</span> 
<a id="x1-58120r60"></a><span>60</span><span>    </span><span id="textcolor2596"><span>if</span></span><span> (ret) {</span> 
<a id="x1-58122r61"></a><span>61</span><span>        pr_err(</span><span id="textcolor2597"><span>&#34;Unable to request GPIOs for BUTTONs: %d</span></span><span id="textcolor2598"><span>\n</span></span><span id="textcolor2599"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-58124r62"></a><span>62</span><span>        </span><span id="textcolor2600"><span>goto</span></span><span> fail1;</span> 
<a id="x1-58126r63"></a><span>63</span><span>    }</span> 
<a id="x1-58128r64"></a><span>64</span> 
<a id="x1-58130r65"></a><span>65</span><span>    pr_info(</span><span id="textcolor2601"><span>&#34;Current button1 value: %d</span></span><span id="textcolor2602"><span>\n</span></span><span id="textcolor2603"><span>&#34;</span></span><span>, gpio_get_value(buttons[0].gpio));</span> 
<a id="x1-58132r66"></a><span>66</span> 
<a id="x1-58134r67"></a><span>67</span><span>    ret = gpio_to_irq(buttons[0].gpio);</span> 
<a id="x1-58136r68"></a><span>68</span> 
<a id="x1-58138r69"></a><span>69</span><span>    </span><span id="textcolor2604"><span>if</span></span><span> (ret &lt; 0) {</span> 
<a id="x1-58140r70"></a><span>70</span><span>        pr_err(</span><span id="textcolor2605"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2606"><span>\n</span></span><span id="textcolor2607"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-58142r71"></a><span>71</span><span>        </span><span id="textcolor2608"><span>goto</span></span><span> fail2;</span> 
<a id="x1-58144r72"></a><span>72</span><span>    }</span> 
<a id="x1-58146r73"></a><span>73</span> 
<a id="x1-58148r74"></a><span>74</span><span>    button_irqs[0] = ret;</span> 
<a id="x1-58150r75"></a><span>75</span> 
<a id="x1-58152r76"></a><span>76</span><span>    pr_info(</span><span id="textcolor2609"><span>&#34;Successfully requested BUTTON1 IRQ # %d</span></span><span id="textcolor2610"><span>\n</span></span><span id="textcolor2611"><span>&#34;</span></span><span>, button_irqs[0]);</span> 
<a id="x1-58154r77"></a><span>77</span> 
<a id="x1-58156r78"></a><span>78</span><span>    ret = request_irq(button_irqs[0], button_isr,</span> 
<a id="x1-58158r79"></a><span>79</span><span>                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span> 
<a id="x1-58160r80"></a><span>80</span><span>                      </span><span id="textcolor2612"><span>&#34;gpiomod#button1&#34;</span></span><span>, NULL);</span> 
<a id="x1-58162r81"></a><span>81</span> 
<a id="x1-58164r82"></a><span>82</span><span>    </span><span id="textcolor2613"><span>if</span></span><span> (ret) {</span> 
<a id="x1-58166r83"></a><span>83</span><span>        pr_err(</span><span id="textcolor2614"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2615"><span>\n</span></span><span id="textcolor2616"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-58168r84"></a><span>84</span><span>        </span><span id="textcolor2617"><span>goto</span></span><span> fail2;</span> 
<a id="x1-58170r85"></a><span>85</span><span>    }</span> 
<a id="x1-58172r86"></a><span>86</span> 
<a id="x1-58174r87"></a><span>87</span><span>    ret = gpio_to_irq(buttons[1].gpio);</span> 
<a id="x1-58176r88"></a><span>88</span> 
<a id="x1-58178r89"></a><span>89</span><span>    </span><span id="textcolor2618"><span>if</span></span><span> (ret &lt; 0) {</span> 
<a id="x1-58180r90"></a><span>90</span><span>        pr_err(</span><span id="textcolor2619"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2620"><span>\n</span></span><span id="textcolor2621"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-58182r91"></a><span>91</span><span>        </span><span id="textcolor2622"><span>goto</span></span><span> fail2;</span> 
<a id="x1-58184r92"></a><span>92</span><span>    }</span> 
<a id="x1-58186r93"></a><span>93</span> 
<a id="x1-58188r94"></a><span>94</span><span>    button_irqs[1] = ret;</span> 
<a id="x1-58190r95"></a><span>95</span> 
<a id="x1-58192r96"></a><span>96</span><span>    pr_info(</span><span id="textcolor2623"><span>&#34;Successfully requested BUTTON2 IRQ # %d</span></span><span id="textcolor2624"><span>\n</span></span><span id="textcolor2625"><span>&#34;</span></span><span>, button_irqs[1]);</span> 
<a id="x1-58194r97"></a><span>97</span> 
<a id="x1-58196r98"></a><span>98</span><span>    ret = request_irq(button_irqs[1], button_isr,</span> 
<a id="x1-58198r99"></a><span>99</span><span>                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span> 
<a id="x1-58200r100"></a><span>100</span><span>                      </span><span id="textcolor2626"><span>&#34;gpiomod#button2&#34;</span></span><span>, NULL);</span> 
<a id="x1-58202r101"></a><span>101</span> 
<a id="x1-58204r102"></a><span>102</span><span>    </span><span id="textcolor2627"><span>if</span></span><span> (ret) {</span> 
<a id="x1-58206r103"></a><span>103</span><span>        pr_err(</span><span id="textcolor2628"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2629"><span>\n</span></span><span id="textcolor2630"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-58208r104"></a><span>104</span><span>        </span><span id="textcolor2631"><span>goto</span></span><span> fail3;</span> 
<a id="x1-58210r105"></a><span>105</span><span>    }</span> 
<a id="x1-58212r106"></a><span>106</span> 
<a id="x1-58214r107"></a><span>107</span><span>    </span><span id="textcolor2632"><span>return</span></span><span> 0;</span> 
<a id="x1-58216r108"></a><span>108</span> 
<a id="x1-58218r109"></a><span>109</span><span id="textcolor2633"><span>/* cleanup what has been setup so far */</span></span> 
<a id="x1-58220r110"></a><span>110</span><span>fail3:</span> 
<a id="x1-58222r111"></a><span>111</span><span>    free_irq(button_irqs[0], NULL);</span> 
<a id="x1-58224r112"></a><span>112</span> 
<a id="x1-58226r113"></a><span>113</span><span>fail2:</span> 
<a id="x1-58228r114"></a><span>114</span><span>    gpio_free_array(buttons, ARRAY_SIZE(leds));</span> 
<a id="x1-58230r115"></a><span>115</span> 
<a id="x1-58232r116"></a><span>116</span><span>fail1:</span> 
<a id="x1-58234r117"></a><span>117</span><span>    gpio_free_array(leds, ARRAY_SIZE(leds));</span> 
<a id="x1-58236r118"></a><span>118</span> 
<a id="x1-58238r119"></a><span>119</span><span>    </span><span id="textcolor2634"><span>return</span></span><span> ret;</span> 
<a id="x1-58240r120"></a><span>120</span><span>}</span> 
<a id="x1-58242r121"></a><span>121</span> 
<a id="x1-58244r122"></a><span>122</span><span id="textcolor2635"><span>static</span></span><span> </span><span id="textcolor2636"><span>void</span></span><span> __exit intrpt_exit(</span><span id="textcolor2637"><span>void</span></span><span>)</span> 
<a id="x1-58246r123"></a><span>123</span><span>{</span> 
<a id="x1-58248r124"></a><span>124</span><span>    </span><span id="textcolor2638"><span>int</span></span><span> i;</span> 
<a id="x1-58250r125"></a><span>125</span> 
<a id="x1-58252r126"></a><span>126</span><span>    pr_info(</span><span id="textcolor2639"><span>&#34;%s</span></span><span id="textcolor2640"><span>\n</span></span><span id="textcolor2641"><span>&#34;</span></span><span>, __func__);</span> 
<a id="x1-58254r127"></a><span>127</span> 
<a id="x1-58256r128"></a><span>128</span><span>    </span><span id="textcolor2642"><span>/* free irqs */</span></span> 
<a id="x1-58258r129"></a><span>129</span><span>    free_irq(button_irqs[0], NULL);</span> 
<a id="x1-58260r130"></a><span>130</span><span>    free_irq(button_irqs[1], NULL);</span> 
<a id="x1-58262r131"></a><span>131</span> 
<a id="x1-58264r132"></a><span>132</span><span>    </span><span id="textcolor2643"><span>/* turn all LEDs off */</span></span> 
<a id="x1-58266r133"></a><span>133</span><span>    </span><span id="textcolor2644"><span>for</span></span><span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)</span> 
<a id="x1-58268r134"></a><span>134</span><span>        gpio_set_value(leds[i].gpio, 0);</span> 
<a id="x1-58270r135"></a><span>135</span> 
<a id="x1-58272r136"></a><span>136</span><span>    </span><span id="textcolor2645"><span>/* unregister */</span></span> 
<a id="x1-58274r137"></a><span>137</span><span>    gpio_free_array(leds, ARRAY_SIZE(leds));</span> 
<a id="x1-58276r138"></a><span>138</span><span>    gpio_free_array(buttons, ARRAY_SIZE(buttons));</span> 
<a id="x1-58278r139"></a><span>139</span><span>}</span> 
<a id="x1-58280r140"></a><span>140</span> 
<a id="x1-58282r141"></a><span>141</span><span>module_init(intrpt_init);</span> 
<a id="x1-58284r142"></a><span>142</span><span>module_exit(intrpt_exit);</span> 
<a id="x1-58286r143"></a><span>143</span> 
<a id="x1-58288r144"></a><span>144</span><span>MODULE_LICENSE(</span><span id="textcolor2646"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-58290r145"></a><span>145</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2647"><span>&#34;Handle some GPIO interrupts&#34;</span></span><span>);</span></pre>
<!-- l. 1872 -->
   <h4 id="bottom-half"><span>15.3   </span> <a id="x1-5900015.3"></a>Bottom Half</h4>
<!-- l. 1874 --><p>Suppose you want to do a bunch of stuff inside of an interrupt routine. A common
way to do that without rendering the interrupt unavailable for a significant duration
is to combine it with a tasklet. This pushes the bulk of the work off into the
scheduler.
</p><!-- l. 1878 --><p>   The example below modifies the previous example to also run an additional task
when an interrupt is triggered.
</p><!-- l. 1 -->
   <pre id="fancyvrb81"><a id="x1-59002r1"></a><span>1</span><span id="textcolor2648"><span>/*</span></span> 
<a id="x1-59004r2"></a><span>2</span><span id="textcolor2649"><span> * bottomhalf.c - Top and bottom half interrupt handling</span></span> 
<a id="x1-59006r3"></a><span>3</span><span id="textcolor2650"><span> *</span></span> 
<a id="x1-59008r4"></a><span>4</span><span id="textcolor2651"><span> * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)</span></span> 
<a id="x1-59010r5"></a><span>5</span><span id="textcolor2652"><span> * from:</span></span> 
<a id="x1-59012r6"></a><span>6</span><span id="textcolor2653"><span> *    https://github.com/wendlers/rpi-kmod-samples</span></span> 
<a id="x1-59014r7"></a><span>7</span><span id="textcolor2654"><span> *</span></span> 
<a id="x1-59016r8"></a><span>8</span><span id="textcolor2655"><span> * Press one button to turn on an LED and another to turn it off</span></span> 
<a id="x1-59018r9"></a><span>9</span><span id="textcolor2656"><span> */</span></span> 
<a id="x1-59020r10"></a><span>10</span> 
<a id="x1-59022r11"></a><span>11</span><span id="textcolor2657"><span>#include</span></span><span> </span><span id="textcolor2658"><span>&lt;linux/delay.h&gt;</span></span> 
<a id="x1-59024r12"></a><span>12</span><span id="textcolor2659"><span>#include</span></span><span> </span><span id="textcolor2660"><span>&lt;linux/gpio.h&gt;</span></span> 
<a id="x1-59026r13"></a><span>13</span><span id="textcolor2661"><span>#include</span></span><span> </span><span id="textcolor2662"><span>&lt;linux/interrupt.h&gt;</span></span> 
<a id="x1-59028r14"></a><span>14</span><span id="textcolor2663"><span>#include</span></span><span> </span><span id="textcolor2664"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-59030r15"></a><span>15</span><span id="textcolor2665"><span>#include</span></span><span> </span><span id="textcolor2666"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-59032r16"></a><span>16</span> 
<a id="x1-59034r17"></a><span>17</span><span id="textcolor2667"><span>/* Macro DECLARE_TASKLET_OLD exists for compatibiity.</span></span> 
<a id="x1-59036r18"></a><span>18</span><span id="textcolor2668"><span> * See https://lwn.net/Articles/830964/</span></span> 
<a id="x1-59038r19"></a><span>19</span><span id="textcolor2669"><span> */</span></span> 
<a id="x1-59040r20"></a><span>20</span><span id="textcolor2670"><span>#ifndef DECLARE_TASKLET_OLD</span></span> 
<a id="x1-59042r21"></a><span>21</span><span id="textcolor2671"><span>#define DECLARE_TASKLET_OLD(arg1, arg2) DECLARE_TASKLET(arg1, arg2, 0L)</span></span> 
<a id="x1-59044r22"></a><span>22</span><span id="textcolor2672"><span>#endif</span></span> 
<a id="x1-59046r23"></a><span>23</span> 
<a id="x1-59048r24"></a><span>24</span><span id="textcolor2673"><span>static</span></span><span> </span><span id="textcolor2674"><span>int</span></span><span> button_irqs[] = { -1, -1 };</span> 
<a id="x1-59050r25"></a><span>25</span> 
<a id="x1-59052r26"></a><span>26</span><span id="textcolor2675"><span>/* Define GPIOs for LEDs.</span></span> 
<a id="x1-59054r27"></a><span>27</span><span id="textcolor2676"><span> * TODO: Change the numbers for the GPIO on your board.</span></span> 
<a id="x1-59056r28"></a><span>28</span><span id="textcolor2677"><span> */</span></span> 
<a id="x1-59058r29"></a><span>29</span><span id="textcolor2678"><span>static</span></span><span> </span><span id="textcolor2679"><span>struct</span></span><span> gpio leds[] = { { 4, GPIOF_OUT_INIT_LOW, </span><span id="textcolor2680"><span>&#34;LED 1&#34;</span></span><span> } };</span> 
<a id="x1-59060r30"></a><span>30</span> 
<a id="x1-59062r31"></a><span>31</span><span id="textcolor2681"><span>/* Define GPIOs for BUTTONS</span></span> 
<a id="x1-59064r32"></a><span>32</span><span id="textcolor2682"><span> * TODO: Change the numbers for the GPIO on your board.</span></span> 
<a id="x1-59066r33"></a><span>33</span><span id="textcolor2683"><span> */</span></span> 
<a id="x1-59068r34"></a><span>34</span><span id="textcolor2684"><span>static</span></span><span> </span><span id="textcolor2685"><span>struct</span></span><span> gpio buttons[] = {</span> 
<a id="x1-59070r35"></a><span>35</span><span>    { 17, GPIOF_IN, </span><span id="textcolor2686"><span>&#34;LED 1 ON BUTTON&#34;</span></span><span> },</span> 
<a id="x1-59072r36"></a><span>36</span><span>    { 18, GPIOF_IN, </span><span id="textcolor2687"><span>&#34;LED 1 OFF BUTTON&#34;</span></span><span> },</span> 
<a id="x1-59074r37"></a><span>37</span><span>};</span> 
<a id="x1-59076r38"></a><span>38</span> 
<a id="x1-59078r39"></a><span>39</span><span id="textcolor2688"><span>/* Tasklet containing some non-trivial amount of processing */</span></span> 
<a id="x1-59080r40"></a><span>40</span><span id="textcolor2689"><span>static</span></span><span> </span><span id="textcolor2690"><span>void</span></span><span> bottomhalf_tasklet_fn(</span><span id="textcolor2691"><span>unsigned</span></span><span> </span><span id="textcolor2692"><span>long</span></span><span> data)</span> 
<a id="x1-59082r41"></a><span>41</span><span>{</span> 
<a id="x1-59084r42"></a><span>42</span><span>    pr_info(</span><span id="textcolor2693"><span>&#34;Bottom half tasklet starts</span></span><span id="textcolor2694"><span>\n</span></span><span id="textcolor2695"><span>&#34;</span></span><span>);</span> 
<a id="x1-59086r43"></a><span>43</span><span>    </span><span id="textcolor2696"><span>/* do something which takes a while */</span></span> 
<a id="x1-59088r44"></a><span>44</span><span>    mdelay(500);</span> 
<a id="x1-59090r45"></a><span>45</span><span>    pr_info(</span><span id="textcolor2697"><span>&#34;Bottom half tasklet ends</span></span><span id="textcolor2698"><span>\n</span></span><span id="textcolor2699"><span>&#34;</span></span><span>);</span> 
<a id="x1-59092r46"></a><span>46</span><span>}</span> 
<a id="x1-59094r47"></a><span>47</span> 
<a id="x1-59096r48"></a><span>48</span><span id="textcolor2700"><span>static</span></span><span> DECLARE_TASKLET_OLD(buttontask, bottomhalf_tasklet_fn);</span> 
<a id="x1-59098r49"></a><span>49</span> 
<a id="x1-59100r50"></a><span>50</span><span id="textcolor2701"><span>/* interrupt function triggered when a button is pressed */</span></span> 
<a id="x1-59102r51"></a><span>51</span><span id="textcolor2702"><span>static</span></span><span> irqreturn_t button_isr(</span><span id="textcolor2703"><span>int</span></span><span> irq, </span><span id="textcolor2704"><span>void</span></span><span> *data)</span> 
<a id="x1-59104r52"></a><span>52</span><span>{</span> 
<a id="x1-59106r53"></a><span>53</span><span>    </span><span id="textcolor2705"><span>/* Do something quickly right now */</span></span> 
<a id="x1-59108r54"></a><span>54</span><span>    </span><span id="textcolor2706"><span>if</span></span><span> (irq == button_irqs[0] &amp;&amp; !gpio_get_value(leds[0].gpio))</span> 
<a id="x1-59110r55"></a><span>55</span><span>        gpio_set_value(leds[0].gpio, 1);</span> 
<a id="x1-59112r56"></a><span>56</span><span>    </span><span id="textcolor2707"><span>else</span></span><span> </span><span id="textcolor2708"><span>if</span></span><span> (irq == button_irqs[1] &amp;&amp; gpio_get_value(leds[0].gpio))</span> 
<a id="x1-59114r57"></a><span>57</span><span>        gpio_set_value(leds[0].gpio, 0);</span> 
<a id="x1-59116r58"></a><span>58</span> 
<a id="x1-59118r59"></a><span>59</span><span>    </span><span id="textcolor2709"><span>/* Do the rest at leisure via the scheduler */</span></span> 
<a id="x1-59120r60"></a><span>60</span><span>    tasklet_schedule(&amp;buttontask);</span> 
<a id="x1-59122r61"></a><span>61</span> 
<a id="x1-59124r62"></a><span>62</span><span>    </span><span id="textcolor2710"><span>return</span></span><span> IRQ_HANDLED;</span> 
<a id="x1-59126r63"></a><span>63</span><span>}</span> 
<a id="x1-59128r64"></a><span>64</span> 
<a id="x1-59130r65"></a><span>65</span><span id="textcolor2711"><span>static</span></span><span> </span><span id="textcolor2712"><span>int</span></span><span> __init bottomhalf_init(</span><span id="textcolor2713"><span>void</span></span><span>)</span> 
<a id="x1-59132r66"></a><span>66</span><span>{</span> 
<a id="x1-59134r67"></a><span>67</span><span>    </span><span id="textcolor2714"><span>int</span></span><span> ret = 0;</span> 
<a id="x1-59136r68"></a><span>68</span> 
<a id="x1-59138r69"></a><span>69</span><span>    pr_info(</span><span id="textcolor2715"><span>&#34;%s</span></span><span id="textcolor2716"><span>\n</span></span><span id="textcolor2717"><span>&#34;</span></span><span>, __func__);</span> 
<a id="x1-59140r70"></a><span>70</span> 
<a id="x1-59142r71"></a><span>71</span><span>    </span><span id="textcolor2718"><span>/* register LED gpios */</span></span> 
<a id="x1-59144r72"></a><span>72</span><span>    ret = gpio_request_array(leds, ARRAY_SIZE(leds));</span> 
<a id="x1-59146r73"></a><span>73</span> 
<a id="x1-59148r74"></a><span>74</span><span>    </span><span id="textcolor2719"><span>if</span></span><span> (ret) {</span> 
<a id="x1-59150r75"></a><span>75</span><span>        pr_err(</span><span id="textcolor2720"><span>&#34;Unable to request GPIOs for LEDs: %d</span></span><span id="textcolor2721"><span>\n</span></span><span id="textcolor2722"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-59152r76"></a><span>76</span><span>        </span><span id="textcolor2723"><span>return</span></span><span> ret;</span> 
<a id="x1-59154r77"></a><span>77</span><span>    }</span> 
<a id="x1-59156r78"></a><span>78</span> 
<a id="x1-59158r79"></a><span>79</span><span>    </span><span id="textcolor2724"><span>/* register BUTTON gpios */</span></span> 
<a id="x1-59160r80"></a><span>80</span><span>    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));</span> 
<a id="x1-59162r81"></a><span>81</span> 
<a id="x1-59164r82"></a><span>82</span><span>    </span><span id="textcolor2725"><span>if</span></span><span> (ret) {</span> 
<a id="x1-59166r83"></a><span>83</span><span>        pr_err(</span><span id="textcolor2726"><span>&#34;Unable to request GPIOs for BUTTONs: %d</span></span><span id="textcolor2727"><span>\n</span></span><span id="textcolor2728"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-59168r84"></a><span>84</span><span>        </span><span id="textcolor2729"><span>goto</span></span><span> fail1;</span> 
<a id="x1-59170r85"></a><span>85</span><span>    }</span> 
<a id="x1-59172r86"></a><span>86</span> 
<a id="x1-59174r87"></a><span>87</span><span>    pr_info(</span><span id="textcolor2730"><span>&#34;Current button1 value: %d</span></span><span id="textcolor2731"><span>\n</span></span><span id="textcolor2732"><span>&#34;</span></span><span>, gpio_get_value(buttons[0].gpio));</span> 
<a id="x1-59176r88"></a><span>88</span> 
<a id="x1-59178r89"></a><span>89</span><span>    ret = gpio_to_irq(buttons[0].gpio);</span> 
<a id="x1-59180r90"></a><span>90</span> 
<a id="x1-59182r91"></a><span>91</span><span>    </span><span id="textcolor2733"><span>if</span></span><span> (ret &lt; 0) {</span> 
<a id="x1-59184r92"></a><span>92</span><span>        pr_err(</span><span id="textcolor2734"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2735"><span>\n</span></span><span id="textcolor2736"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-59186r93"></a><span>93</span><span>        </span><span id="textcolor2737"><span>goto</span></span><span> fail2;</span> 
<a id="x1-59188r94"></a><span>94</span><span>    }</span> 
<a id="x1-59190r95"></a><span>95</span> 
<a id="x1-59192r96"></a><span>96</span><span>    button_irqs[0] = ret;</span> 
<a id="x1-59194r97"></a><span>97</span> 
<a id="x1-59196r98"></a><span>98</span><span>    pr_info(</span><span id="textcolor2738"><span>&#34;Successfully requested BUTTON1 IRQ # %d</span></span><span id="textcolor2739"><span>\n</span></span><span id="textcolor2740"><span>&#34;</span></span><span>, button_irqs[0]);</span> 
<a id="x1-59198r99"></a><span>99</span> 
<a id="x1-59200r100"></a><span>100</span><span>    ret = request_irq(button_irqs[0], button_isr,</span> 
<a id="x1-59202r101"></a><span>101</span><span>                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span> 
<a id="x1-59204r102"></a><span>102</span><span>                      </span><span id="textcolor2741"><span>&#34;gpiomod#button1&#34;</span></span><span>, NULL);</span> 
<a id="x1-59206r103"></a><span>103</span> 
<a id="x1-59208r104"></a><span>104</span><span>    </span><span id="textcolor2742"><span>if</span></span><span> (ret) {</span> 
<a id="x1-59210r105"></a><span>105</span><span>        pr_err(</span><span id="textcolor2743"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2744"><span>\n</span></span><span id="textcolor2745"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-59212r106"></a><span>106</span><span>        </span><span id="textcolor2746"><span>goto</span></span><span> fail2;</span> 
<a id="x1-59214r107"></a><span>107</span><span>    }</span> 
<a id="x1-59216r108"></a><span>108</span> 
<a id="x1-59218r109"></a><span>109</span><span>    ret = gpio_to_irq(buttons[1].gpio);</span> 
<a id="x1-59220r110"></a><span>110</span> 
<a id="x1-59222r111"></a><span>111</span><span>    </span><span id="textcolor2747"><span>if</span></span><span> (ret &lt; 0) {</span> 
<a id="x1-59224r112"></a><span>112</span><span>        pr_err(</span><span id="textcolor2748"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2749"><span>\n</span></span><span id="textcolor2750"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-59226r113"></a><span>113</span><span>        </span><span id="textcolor2751"><span>goto</span></span><span> fail2;</span> 
<a id="x1-59228r114"></a><span>114</span><span>    }</span> 
<a id="x1-59230r115"></a><span>115</span> 
<a id="x1-59232r116"></a><span>116</span><span>    button_irqs[1] = ret;</span> 
<a id="x1-59234r117"></a><span>117</span> 
<a id="x1-59236r118"></a><span>118</span><span>    pr_info(</span><span id="textcolor2752"><span>&#34;Successfully requested BUTTON2 IRQ # %d</span></span><span id="textcolor2753"><span>\n</span></span><span id="textcolor2754"><span>&#34;</span></span><span>, button_irqs[1]);</span> 
<a id="x1-59238r119"></a><span>119</span> 
<a id="x1-59240r120"></a><span>120</span><span>    ret = request_irq(button_irqs[1], button_isr,</span> 
<a id="x1-59242r121"></a><span>121</span><span>                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span> 
<a id="x1-59244r122"></a><span>122</span><span>                      </span><span id="textcolor2755"><span>&#34;gpiomod#button2&#34;</span></span><span>, NULL);</span> 
<a id="x1-59246r123"></a><span>123</span> 
<a id="x1-59248r124"></a><span>124</span><span>    </span><span id="textcolor2756"><span>if</span></span><span> (ret) {</span> 
<a id="x1-59250r125"></a><span>125</span><span>        pr_err(</span><span id="textcolor2757"><span>&#34;Unable to request IRQ: %d</span></span><span id="textcolor2758"><span>\n</span></span><span id="textcolor2759"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-59252r126"></a><span>126</span><span>        </span><span id="textcolor2760"><span>goto</span></span><span> fail3;</span> 
<a id="x1-59254r127"></a><span>127</span><span>    }</span> 
<a id="x1-59256r128"></a><span>128</span> 
<a id="x1-59258r129"></a><span>129</span><span>    </span><span id="textcolor2761"><span>return</span></span><span> 0;</span> 
<a id="x1-59260r130"></a><span>130</span> 
<a id="x1-59262r131"></a><span>131</span><span id="textcolor2762"><span>/* cleanup what has been setup so far */</span></span> 
<a id="x1-59264r132"></a><span>132</span><span>fail3:</span> 
<a id="x1-59266r133"></a><span>133</span><span>    free_irq(button_irqs[0], NULL);</span> 
<a id="x1-59268r134"></a><span>134</span> 
<a id="x1-59270r135"></a><span>135</span><span>fail2:</span> 
<a id="x1-59272r136"></a><span>136</span><span>    gpio_free_array(buttons, ARRAY_SIZE(leds));</span> 
<a id="x1-59274r137"></a><span>137</span> 
<a id="x1-59276r138"></a><span>138</span><span>fail1:</span> 
<a id="x1-59278r139"></a><span>139</span><span>    gpio_free_array(leds, ARRAY_SIZE(leds));</span> 
<a id="x1-59280r140"></a><span>140</span> 
<a id="x1-59282r141"></a><span>141</span><span>    </span><span id="textcolor2763"><span>return</span></span><span> ret;</span> 
<a id="x1-59284r142"></a><span>142</span><span>}</span> 
<a id="x1-59286r143"></a><span>143</span> 
<a id="x1-59288r144"></a><span>144</span><span id="textcolor2764"><span>static</span></span><span> </span><span id="textcolor2765"><span>void</span></span><span> __exit bottomhalf_exit(</span><span id="textcolor2766"><span>void</span></span><span>)</span> 
<a id="x1-59290r145"></a><span>145</span><span>{</span> 
<a id="x1-59292r146"></a><span>146</span><span>    </span><span id="textcolor2767"><span>int</span></span><span> i;</span> 
<a id="x1-59294r147"></a><span>147</span> 
<a id="x1-59296r148"></a><span>148</span><span>    pr_info(</span><span id="textcolor2768"><span>&#34;%s</span></span><span id="textcolor2769"><span>\n</span></span><span id="textcolor2770"><span>&#34;</span></span><span>, __func__);</span> 
<a id="x1-59298r149"></a><span>149</span> 
<a id="x1-59300r150"></a><span>150</span><span>    </span><span id="textcolor2771"><span>/* free irqs */</span></span> 
<a id="x1-59302r151"></a><span>151</span><span>    free_irq(button_irqs[0], NULL);</span> 
<a id="x1-59304r152"></a><span>152</span><span>    free_irq(button_irqs[1], NULL);</span> 
<a id="x1-59306r153"></a><span>153</span> 
<a id="x1-59308r154"></a><span>154</span><span>    </span><span id="textcolor2772"><span>/* turn all LEDs off */</span></span> 
<a id="x1-59310r155"></a><span>155</span><span>    </span><span id="textcolor2773"><span>for</span></span><span> (i = 0; i &lt; ARRAY_SIZE(leds); i++)</span> 
<a id="x1-59312r156"></a><span>156</span><span>        gpio_set_value(leds[i].gpio, 0);</span> 
<a id="x1-59314r157"></a><span>157</span> 
<a id="x1-59316r158"></a><span>158</span><span>    </span><span id="textcolor2774"><span>/* unregister */</span></span> 
<a id="x1-59318r159"></a><span>159</span><span>    gpio_free_array(leds, ARRAY_SIZE(leds));</span> 
<a id="x1-59320r160"></a><span>160</span><span>    gpio_free_array(buttons, ARRAY_SIZE(buttons));</span> 
<a id="x1-59322r161"></a><span>161</span><span>}</span> 
<a id="x1-59324r162"></a><span>162</span> 
<a id="x1-59326r163"></a><span>163</span><span>module_init(bottomhalf_init);</span> 
<a id="x1-59328r164"></a><span>164</span><span>module_exit(bottomhalf_exit);</span> 
<a id="x1-59330r165"></a><span>165</span> 
<a id="x1-59332r166"></a><span>166</span><span>MODULE_LICENSE(</span><span id="textcolor2775"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-59334r167"></a><span>167</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2776"><span>&#34;Interrupt with top and bottom half&#34;</span></span><span>);</span></pre>
<!-- l. 1882 -->
   <h3 id="crypto"><span>16   </span> <a id="x1-6000016"></a>Crypto</h3>
<!-- l. 1884 --><p>At the dawn of the internet, everybody trusted everybody completely…but that did
not work out so well. When this guide was originally written, it was a more innocent
era in which almost nobody actually gave a damn about crypto - least of all kernel
developers. That is certainly no longer the case now. To handle crypto stuff, the
kernel has its own API enabling common methods of encryption, decryption and your
favourite hash functions.
</p><!-- l. 1889 -->
   <h4 id="hash-functions"><span>16.1   </span> <a id="x1-6100016.1"></a>Hash functions</h4>
<!-- l. 1892 --><p>Calculating and checking the hashes of things is a common operation.
Here is a demonstration of how to calculate a sha256 hash within a
kernel module. To provide the sha256 algorithm support, make sure
<code> <span>CONFIG_CRYPTO_SHA256</span>
</code> is enabled in kernel.
</p><!-- l. 1 -->
   <pre id="fancyvrb82"><a id="x1-61003r1"></a><span>1</span><span id="textcolor2777"><span>/*</span></span> 
<a id="x1-61005r2"></a><span>2</span><span id="textcolor2778"><span> * cryptosha256.c</span></span> 
<a id="x1-61007r3"></a><span>3</span><span id="textcolor2779"><span> */</span></span> 
<a id="x1-61009r4"></a><span>4</span><span id="textcolor2780"><span>#include</span></span><span> </span><span id="textcolor2781"><span>&lt;crypto/internal/hash.h&gt;</span></span> 
<a id="x1-61011r5"></a><span>5</span><span id="textcolor2782"><span>#include</span></span><span> </span><span id="textcolor2783"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-61013r6"></a><span>6</span> 
<a id="x1-61015r7"></a><span>7</span><span id="textcolor2784"><span>#define SHA256_LENGTH 32</span></span> 
<a id="x1-61017r8"></a><span>8</span> 
<a id="x1-61019r9"></a><span>9</span><span id="textcolor2785"><span>static</span></span><span> </span><span id="textcolor2786"><span>void</span></span><span> show_hash_result(</span><span id="textcolor2787"><span>char</span></span><span> *plaintext, </span><span id="textcolor2788"><span>char</span></span><span> *hash_sha256)</span> 
<a id="x1-61021r10"></a><span>10</span><span>{</span> 
<a id="x1-61023r11"></a><span>11</span><span>    </span><span id="textcolor2789"><span>int</span></span><span> i;</span> 
<a id="x1-61025r12"></a><span>12</span><span>    </span><span id="textcolor2790"><span>char</span></span><span> str[SHA256_LENGTH * 2 + 1];</span> 
<a id="x1-61027r13"></a><span>13</span> 
<a id="x1-61029r14"></a><span>14</span><span>    pr_info(</span><span id="textcolor2791"><span>&#34;sha256 test for string: </span></span><span id="textcolor2792"><span>\&#34;</span></span><span id="textcolor2793"><span>%s</span></span><span id="textcolor2794"><span>\&#34;\n</span></span><span id="textcolor2795"><span>&#34;</span></span><span>, plaintext);</span> 
<a id="x1-61031r15"></a><span>15</span><span>    </span><span id="textcolor2796"><span>for</span></span><span> (i = 0; i &lt; SHA256_LENGTH; i++)</span> 
<a id="x1-61033r16"></a><span>16</span><span>        sprintf(&amp;str[i * 2], </span><span id="textcolor2797"><span>&#34;%02x&#34;</span></span><span>, (</span><span id="textcolor2798"><span>unsigned</span></span><span> </span><span id="textcolor2799"><span>char</span></span><span>)hash_sha256[i]);</span> 
<a id="x1-61035r17"></a><span>17</span><span>    str[i * 2] = 0;</span> 
<a id="x1-61037r18"></a><span>18</span><span>    pr_info(</span><span id="textcolor2800"><span>&#34;%s</span></span><span id="textcolor2801"><span>\n</span></span><span id="textcolor2802"><span>&#34;</span></span><span>, str);</span> 
<a id="x1-61039r19"></a><span>19</span><span>}</span> 
<a id="x1-61041r20"></a><span>20</span> 
<a id="x1-61043r21"></a><span>21</span><span id="textcolor2803"><span>static</span></span><span> </span><span id="textcolor2804"><span>int</span></span><span> cryptosha256_init(</span><span id="textcolor2805"><span>void</span></span><span>)</span> 
<a id="x1-61045r22"></a><span>22</span><span>{</span> 
<a id="x1-61047r23"></a><span>23</span><span>    </span><span id="textcolor2806"><span>char</span></span><span> *plaintext = </span><span id="textcolor2807"><span>&#34;This is a test&#34;</span></span><span>;</span> 
<a id="x1-61049r24"></a><span>24</span><span>    </span><span id="textcolor2808"><span>char</span></span><span> hash_sha256[SHA256_LENGTH];</span> 
<a id="x1-61051r25"></a><span>25</span><span>    </span><span id="textcolor2809"><span>struct</span></span><span> crypto_shash *sha256;</span> 
<a id="x1-61053r26"></a><span>26</span><span>    </span><span id="textcolor2810"><span>struct</span></span><span> shash_desc *shash;</span> 
<a id="x1-61055r27"></a><span>27</span> 
<a id="x1-61057r28"></a><span>28</span><span>    sha256 = crypto_alloc_shash(</span><span id="textcolor2811"><span>&#34;sha256&#34;</span></span><span>, 0, 0);</span> 
<a id="x1-61059r29"></a><span>29</span><span>    </span><span id="textcolor2812"><span>if</span></span><span> (IS_ERR(sha256)) {</span> 
<a id="x1-61061r30"></a><span>30</span><span>        pr_err(</span> 
<a id="x1-61063r31"></a><span>31</span><span>            </span><span id="textcolor2813"><span>&#34;%s(): Failed to allocate sha256 algorithm, enable CONFIG_CRYPTO_SHA256 and try again.</span></span><span id="textcolor2814"><span>\n</span></span><span id="textcolor2815"><span>&#34;</span></span><span>,</span> 
<a id="x1-61065r32"></a><span>32</span><span>            __func__);</span> 
<a id="x1-61067r33"></a><span>33</span><span>        </span><span id="textcolor2816"><span>return</span></span><span> -1;</span> 
<a id="x1-61069r34"></a><span>34</span><span>    }</span> 
<a id="x1-61071r35"></a><span>35</span> 
<a id="x1-61073r36"></a><span>36</span><span>    shash = kmalloc(</span><span id="textcolor2817"><span>sizeof</span></span><span>(</span><span id="textcolor2818"><span>struct</span></span><span> shash_desc) + crypto_shash_descsize(sha256),</span> 
<a id="x1-61075r37"></a><span>37</span><span>                    GFP_KERNEL);</span> 
<a id="x1-61077r38"></a><span>38</span><span>    </span><span id="textcolor2819"><span>if</span></span><span> (!shash)</span> 
<a id="x1-61079r39"></a><span>39</span><span>        </span><span id="textcolor2820"><span>return</span></span><span> -ENOMEM;</span> 
<a id="x1-61081r40"></a><span>40</span> 
<a id="x1-61083r41"></a><span>41</span><span>    shash-&gt;tfm = sha256;</span> 
<a id="x1-61085r42"></a><span>42</span> 
<a id="x1-61087r43"></a><span>43</span><span>    </span><span id="textcolor2821"><span>if</span></span><span> (crypto_shash_init(shash))</span> 
<a id="x1-61089r44"></a><span>44</span><span>        </span><span id="textcolor2822"><span>return</span></span><span> -1;</span> 
<a id="x1-61091r45"></a><span>45</span> 
<a id="x1-61093r46"></a><span>46</span><span>    </span><span id="textcolor2823"><span>if</span></span><span> (crypto_shash_update(shash, plaintext, strlen(plaintext)))</span> 
<a id="x1-61095r47"></a><span>47</span><span>        </span><span id="textcolor2824"><span>return</span></span><span> -1;</span> 
<a id="x1-61097r48"></a><span>48</span> 
<a id="x1-61099r49"></a><span>49</span><span>    </span><span id="textcolor2825"><span>if</span></span><span> (crypto_shash_final(shash, hash_sha256))</span> 
<a id="x1-61101r50"></a><span>50</span><span>        </span><span id="textcolor2826"><span>return</span></span><span> -1;</span> 
<a id="x1-61103r51"></a><span>51</span> 
<a id="x1-61105r52"></a><span>52</span><span>    kfree(shash);</span> 
<a id="x1-61107r53"></a><span>53</span><span>    crypto_free_shash(sha256);</span> 
<a id="x1-61109r54"></a><span>54</span> 
<a id="x1-61111r55"></a><span>55</span><span>    show_hash_result(plaintext, hash_sha256);</span> 
<a id="x1-61113r56"></a><span>56</span> 
<a id="x1-61115r57"></a><span>57</span><span>    </span><span id="textcolor2827"><span>return</span></span><span> 0;</span> 
<a id="x1-61117r58"></a><span>58</span><span>}</span> 
<a id="x1-61119r59"></a><span>59</span> 
<a id="x1-61121r60"></a><span>60</span><span id="textcolor2828"><span>static</span></span><span> </span><span id="textcolor2829"><span>void</span></span><span> cryptosha256_exit(</span><span id="textcolor2830"><span>void</span></span><span>)</span> 
<a id="x1-61123r61"></a><span>61</span><span>{</span> 
<a id="x1-61125r62"></a><span>62</span><span>}</span> 
<a id="x1-61127r63"></a><span>63</span> 
<a id="x1-61129r64"></a><span>64</span><span>module_init(cryptosha256_init);</span> 
<a id="x1-61131r65"></a><span>65</span><span>module_exit(cryptosha256_exit);</span> 
<a id="x1-61133r66"></a><span>66</span> 
<a id="x1-61135r67"></a><span>67</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2831"><span>&#34;sha256 hash test&#34;</span></span><span>);</span> 
<a id="x1-61137r68"></a><span>68</span><span>MODULE_LICENSE(</span><span id="textcolor2832"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1898 --><p>   Install the module:
</p><!-- l. 1 -->
   <pre id="fancyvrb83"><a id="x1-61141r1"></a><span>1</span><span>sudo insmod cryptosha256.ko</span> 
<a id="x1-61143r2"></a><span>2</span><span>sudo dmesg</span></pre>
<!-- l. 1905 --><p>   And you should see that the hash was calculated for the test string.
</p><!-- l. 1907 --><p>   Finally, remove the test module:
</p><!-- l. 1 -->
   <pre id="fancyvrb84"><a id="x1-61146r1"></a><span>1</span><span>sudo rmmod cryptosha256</span></pre>
                                                                  

                                                                  
<!-- l. 1913 -->
   <h4 id="symmetric-key-encryption"><span>16.2   </span> <a id="x1-6200016.2"></a>Symmetric key encryption</h4>
<!-- l. 1915 --><p>Here is an example of symmetrically encrypting a string using the AES algorithm
and a password.
</p><!-- l. 1 -->
   <pre id="fancyvrb85"><a id="x1-62002r1"></a><span>1</span><span id="textcolor2833"><span>/*</span></span> 
<a id="x1-62004r2"></a><span>2</span><span id="textcolor2834"><span> * cryptosk.c</span></span> 
<a id="x1-62006r3"></a><span>3</span><span id="textcolor2835"><span> */</span></span> 
<a id="x1-62008r4"></a><span>4</span><span id="textcolor2836"><span>#include</span></span><span> </span><span id="textcolor2837"><span>&lt;crypto/internal/skcipher.h&gt;</span></span> 
<a id="x1-62010r5"></a><span>5</span><span id="textcolor2838"><span>#include</span></span><span> </span><span id="textcolor2839"><span>&lt;linux/crypto.h&gt;</span></span> 
<a id="x1-62012r6"></a><span>6</span><span id="textcolor2840"><span>#include</span></span><span> </span><span id="textcolor2841"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-62014r7"></a><span>7</span><span id="textcolor2842"><span>#include</span></span><span> </span><span id="textcolor2843"><span>&lt;linux/random.h&gt;</span></span> 
<a id="x1-62016r8"></a><span>8</span><span id="textcolor2844"><span>#include</span></span><span> </span><span id="textcolor2845"><span>&lt;linux/scatterlist.h&gt;</span></span> 
<a id="x1-62018r9"></a><span>9</span> 
<a id="x1-62020r10"></a><span>10</span><span id="textcolor2846"><span>#define SYMMETRIC_KEY_LENGTH 32</span></span> 
<a id="x1-62022r11"></a><span>11</span><span id="textcolor2847"><span>#define CIPHER_BLOCK_SIZE 16</span></span> 
<a id="x1-62024r12"></a><span>12</span> 
<a id="x1-62026r13"></a><span>13</span><span id="textcolor2848"><span>struct</span></span><span> tcrypt_result {</span> 
<a id="x1-62028r14"></a><span>14</span><span>    </span><span id="textcolor2849"><span>struct</span></span><span> completion completion;</span> 
<a id="x1-62030r15"></a><span>15</span><span>    </span><span id="textcolor2850"><span>int</span></span><span> err;</span> 
<a id="x1-62032r16"></a><span>16</span><span>};</span> 
<a id="x1-62034r17"></a><span>17</span> 
<a id="x1-62036r18"></a><span>18</span><span id="textcolor2851"><span>struct</span></span><span> skcipher_def {</span> 
<a id="x1-62038r19"></a><span>19</span><span>    </span><span id="textcolor2852"><span>struct</span></span><span> scatterlist sg;</span> 
<a id="x1-62040r20"></a><span>20</span><span>    </span><span id="textcolor2853"><span>struct</span></span><span> crypto_skcipher *tfm;</span> 
<a id="x1-62042r21"></a><span>21</span><span>    </span><span id="textcolor2854"><span>struct</span></span><span> skcipher_request *req;</span> 
<a id="x1-62044r22"></a><span>22</span><span>    </span><span id="textcolor2855"><span>struct</span></span><span> tcrypt_result result;</span> 
<a id="x1-62046r23"></a><span>23</span><span>    </span><span id="textcolor2856"><span>char</span></span><span> *scratchpad;</span> 
<a id="x1-62048r24"></a><span>24</span><span>    </span><span id="textcolor2857"><span>char</span></span><span> *ciphertext;</span> 
<a id="x1-62050r25"></a><span>25</span><span>    </span><span id="textcolor2858"><span>char</span></span><span> *ivdata;</span> 
<a id="x1-62052r26"></a><span>26</span><span>};</span> 
<a id="x1-62054r27"></a><span>27</span> 
<a id="x1-62056r28"></a><span>28</span><span id="textcolor2859"><span>static</span></span><span> </span><span id="textcolor2860"><span>struct</span></span><span> skcipher_def sk;</span> 
<a id="x1-62058r29"></a><span>29</span> 
<a id="x1-62060r30"></a><span>30</span><span id="textcolor2861"><span>static</span></span><span> </span><span id="textcolor2862"><span>void</span></span><span> test_skcipher_finish(</span><span id="textcolor2863"><span>struct</span></span><span> skcipher_def *sk)</span> 
<a id="x1-62062r31"></a><span>31</span><span>{</span> 
<a id="x1-62064r32"></a><span>32</span><span>    </span><span id="textcolor2864"><span>if</span></span><span> (sk-&gt;tfm)</span> 
<a id="x1-62066r33"></a><span>33</span><span>        crypto_free_skcipher(sk-&gt;tfm);</span> 
<a id="x1-62068r34"></a><span>34</span><span>    </span><span id="textcolor2865"><span>if</span></span><span> (sk-&gt;req)</span> 
<a id="x1-62070r35"></a><span>35</span><span>        skcipher_request_free(sk-&gt;req);</span> 
<a id="x1-62072r36"></a><span>36</span><span>    </span><span id="textcolor2866"><span>if</span></span><span> (sk-&gt;ivdata)</span> 
<a id="x1-62074r37"></a><span>37</span><span>        kfree(sk-&gt;ivdata);</span> 
<a id="x1-62076r38"></a><span>38</span><span>    </span><span id="textcolor2867"><span>if</span></span><span> (sk-&gt;scratchpad)</span> 
<a id="x1-62078r39"></a><span>39</span><span>        kfree(sk-&gt;scratchpad);</span> 
<a id="x1-62080r40"></a><span>40</span><span>    </span><span id="textcolor2868"><span>if</span></span><span> (sk-&gt;ciphertext)</span> 
<a id="x1-62082r41"></a><span>41</span><span>        kfree(sk-&gt;ciphertext);</span> 
<a id="x1-62084r42"></a><span>42</span><span>}</span> 
<a id="x1-62086r43"></a><span>43</span> 
<a id="x1-62088r44"></a><span>44</span><span id="textcolor2869"><span>static</span></span><span> </span><span id="textcolor2870"><span>int</span></span><span> test_skcipher_result(</span><span id="textcolor2871"><span>struct</span></span><span> skcipher_def *sk, </span><span id="textcolor2872"><span>int</span></span><span> rc)</span> 
<a id="x1-62090r45"></a><span>45</span><span>{</span> 
<a id="x1-62092r46"></a><span>46</span><span>    </span><span id="textcolor2873"><span>switch</span></span><span> (rc) {</span> 
<a id="x1-62094r47"></a><span>47</span><span>    </span><span id="textcolor2874"><span>case</span></span><span> 0:</span> 
<a id="x1-62096r48"></a><span>48</span><span>        </span><span id="textcolor2875"><span>break</span></span><span>;</span> 
<a id="x1-62098r49"></a><span>49</span><span>    </span><span id="textcolor2876"><span>case</span></span><span> -EINPROGRESS || -EBUSY:</span> 
<a id="x1-62100r50"></a><span>50</span><span>        rc = wait_for_completion_interruptible(&amp;sk-&gt;result.completion);</span> 
<a id="x1-62102r51"></a><span>51</span><span>        </span><span id="textcolor2877"><span>if</span></span><span> (!rc &amp;&amp; !sk-&gt;result.err) {</span> 
<a id="x1-62104r52"></a><span>52</span><span>            reinit_completion(&amp;sk-&gt;result.completion);</span> 
<a id="x1-62106r53"></a><span>53</span><span>            </span><span id="textcolor2878"><span>break</span></span><span>;</span> 
<a id="x1-62108r54"></a><span>54</span><span>        }</span> 
<a id="x1-62110r55"></a><span>55</span><span>        pr_info(</span><span id="textcolor2879"><span>&#34;skcipher encrypt returned with %d result %d</span></span><span id="textcolor2880"><span>\n</span></span><span id="textcolor2881"><span>&#34;</span></span><span>, rc,</span> 
<a id="x1-62112r56"></a><span>56</span><span>                sk-&gt;result.err);</span> 
<a id="x1-62114r57"></a><span>57</span><span>        </span><span id="textcolor2882"><span>break</span></span><span>;</span> 
<a id="x1-62116r58"></a><span>58</span><span>    </span><span id="textcolor2883"><span>default</span></span><span>:</span> 
<a id="x1-62118r59"></a><span>59</span><span>        pr_info(</span><span id="textcolor2884"><span>&#34;skcipher encrypt returned with %d result %d</span></span><span id="textcolor2885"><span>\n</span></span><span id="textcolor2886"><span>&#34;</span></span><span>, rc,</span> 
<a id="x1-62120r60"></a><span>60</span><span>                sk-&gt;result.err);</span> 
<a id="x1-62122r61"></a><span>61</span><span>        </span><span id="textcolor2887"><span>break</span></span><span>;</span> 
<a id="x1-62124r62"></a><span>62</span><span>    }</span> 
<a id="x1-62126r63"></a><span>63</span> 
<a id="x1-62128r64"></a><span>64</span><span>    init_completion(&amp;sk-&gt;result.completion);</span> 
<a id="x1-62130r65"></a><span>65</span> 
<a id="x1-62132r66"></a><span>66</span><span>    </span><span id="textcolor2888"><span>return</span></span><span> rc;</span> 
<a id="x1-62134r67"></a><span>67</span><span>}</span> 
<a id="x1-62136r68"></a><span>68</span> 
<a id="x1-62138r69"></a><span>69</span><span id="textcolor2889"><span>static</span></span><span> </span><span id="textcolor2890"><span>void</span></span><span> test_skcipher_callback(</span><span id="textcolor2891"><span>struct</span></span><span> crypto_async_request *req, </span><span id="textcolor2892"><span>int</span></span><span> error)</span> 
<a id="x1-62140r70"></a><span>70</span><span>{</span> 
<a id="x1-62142r71"></a><span>71</span><span>    </span><span id="textcolor2893"><span>struct</span></span><span> tcrypt_result *result = req-&gt;data;</span> 
<a id="x1-62144r72"></a><span>72</span> 
<a id="x1-62146r73"></a><span>73</span><span>    </span><span id="textcolor2894"><span>if</span></span><span> (error == -EINPROGRESS)</span> 
<a id="x1-62148r74"></a><span>74</span><span>        </span><span id="textcolor2895"><span>return</span></span><span>;</span> 
<a id="x1-62150r75"></a><span>75</span> 
<a id="x1-62152r76"></a><span>76</span><span>    result-&gt;err = error;</span> 
<a id="x1-62154r77"></a><span>77</span><span>    complete(&amp;result-&gt;completion);</span> 
<a id="x1-62156r78"></a><span>78</span><span>    pr_info(</span><span id="textcolor2896"><span>&#34;Encryption finished successfully</span></span><span id="textcolor2897"><span>\n</span></span><span id="textcolor2898"><span>&#34;</span></span><span>);</span> 
<a id="x1-62158r79"></a><span>79</span> 
<a id="x1-62160r80"></a><span>80</span><span>    </span><span id="textcolor2899"><span>/* decrypt data */</span></span> 
<a id="x1-62162r81"></a><span>81</span><span id="textcolor2900"><span>#if 0</span></span> 
<a id="x1-62164r82"></a><span>82</span><span id="textcolor2901"><span>    memset((void*)sk.scratchpad, </span><span>&#39;</span><span>-</span><span>&#39;</span><span>, CIPHER_BLOCK_SIZE);</span></span> 
<a id="x1-62166r83"></a><span>83</span><span id="textcolor2902"><span>    ret = crypto_skcipher_decrypt(sk.req);</span></span> 
<a id="x1-62168r84"></a><span>84</span><span id="textcolor2903"><span>    ret = test_skcipher_result(&amp;sk, ret);</span></span> 
<a id="x1-62170r85"></a><span>85</span><span id="textcolor2904"><span>    if (ret)</span></span> 
<a id="x1-62172r86"></a><span>86</span><span id="textcolor2905"><span>        return;</span></span> 
<a id="x1-62174r87"></a><span>87</span> 
<a id="x1-62176r88"></a><span>88</span><span id="textcolor2906"><span>    sg_copy_from_buffer(&amp;sk.sg, 1, sk.scratchpad, CIPHER_BLOCK_SIZE);</span></span> 
<a id="x1-62178r89"></a><span>89</span><span id="textcolor2907"><span>    sk.scratchpad[CIPHER_BLOCK_SIZE-1] = 0;</span></span> 
<a id="x1-62180r90"></a><span>90</span> 
<a id="x1-62182r91"></a><span>91</span><span id="textcolor2908"><span>    pr_info(&#34;Decryption request successful\n&#34;);</span></span> 
<a id="x1-62184r92"></a><span>92</span><span id="textcolor2909"><span>    pr_info(&#34;Decrypted: %s\n&#34;, sk.scratchpad);</span></span> 
<a id="x1-62186r93"></a><span>93</span><span id="textcolor2910"><span>#endif</span></span> 
<a id="x1-62188r94"></a><span>94</span><span>}</span> 
<a id="x1-62190r95"></a><span>95</span> 
<a id="x1-62192r96"></a><span>96</span><span id="textcolor2911"><span>static</span></span><span> </span><span id="textcolor2912"><span>int</span></span><span> test_skcipher_encrypt(</span><span id="textcolor2913"><span>char</span></span><span> *plaintext, </span><span id="textcolor2914"><span>char</span></span><span> *password,</span> 
<a id="x1-62194r97"></a><span>97</span><span>                                 </span><span id="textcolor2915"><span>struct</span></span><span> skcipher_def *sk)</span> 
<a id="x1-62196r98"></a><span>98</span><span>{</span> 
<a id="x1-62198r99"></a><span>99</span><span>    </span><span id="textcolor2916"><span>int</span></span><span> ret = -EFAULT;</span> 
<a id="x1-62200r100"></a><span>100</span><span>    </span><span id="textcolor2917"><span>unsigned</span></span><span> </span><span id="textcolor2918"><span>char</span></span><span> key[SYMMETRIC_KEY_LENGTH];</span> 
<a id="x1-62202r101"></a><span>101</span> 
<a id="x1-62204r102"></a><span>102</span><span>    </span><span id="textcolor2919"><span>if</span></span><span> (!sk-&gt;tfm) {</span> 
<a id="x1-62206r103"></a><span>103</span><span>        sk-&gt;tfm = crypto_alloc_skcipher(</span><span id="textcolor2920"><span>&#34;cbc-aes-aesni&#34;</span></span><span>, 0, 0);</span> 
<a id="x1-62208r104"></a><span>104</span><span>        </span><span id="textcolor2921"><span>if</span></span><span> (IS_ERR(sk-&gt;tfm)) {</span> 
<a id="x1-62210r105"></a><span>105</span><span>            pr_info(</span><span id="textcolor2922"><span>&#34;could not allocate skcipher handle</span></span><span id="textcolor2923"><span>\n</span></span><span id="textcolor2924"><span>&#34;</span></span><span>);</span> 
<a id="x1-62212r106"></a><span>106</span><span>            </span><span id="textcolor2925"><span>return</span></span><span> PTR_ERR(sk-&gt;tfm);</span> 
<a id="x1-62214r107"></a><span>107</span><span>        }</span> 
<a id="x1-62216r108"></a><span>108</span><span>    }</span> 
<a id="x1-62218r109"></a><span>109</span> 
<a id="x1-62220r110"></a><span>110</span><span>    </span><span id="textcolor2926"><span>if</span></span><span> (!sk-&gt;req) {</span> 
<a id="x1-62222r111"></a><span>111</span><span>        sk-&gt;req = skcipher_request_alloc(sk-&gt;tfm, GFP_KERNEL);</span> 
<a id="x1-62224r112"></a><span>112</span><span>        </span><span id="textcolor2927"><span>if</span></span><span> (!sk-&gt;req) {</span> 
<a id="x1-62226r113"></a><span>113</span><span>            pr_info(</span><span id="textcolor2928"><span>&#34;could not allocate skcipher request</span></span><span id="textcolor2929"><span>\n</span></span><span id="textcolor2930"><span>&#34;</span></span><span>);</span> 
<a id="x1-62228r114"></a><span>114</span><span>            ret = -ENOMEM;</span> 
<a id="x1-62230r115"></a><span>115</span><span>            </span><span id="textcolor2931"><span>goto</span></span><span> out;</span> 
<a id="x1-62232r116"></a><span>116</span><span>        }</span> 
<a id="x1-62234r117"></a><span>117</span><span>    }</span> 
<a id="x1-62236r118"></a><span>118</span> 
<a id="x1-62238r119"></a><span>119</span><span>    skcipher_request_set_callback(sk-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span> 
<a id="x1-62240r120"></a><span>120</span><span>                                  test_skcipher_callback, &amp;sk-&gt;result);</span> 
<a id="x1-62242r121"></a><span>121</span> 
<a id="x1-62244r122"></a><span>122</span><span>    </span><span id="textcolor2932"><span>/* clear the key */</span></span> 
<a id="x1-62246r123"></a><span>123</span><span>    memset((</span><span id="textcolor2933"><span>void</span></span><span> *)key, </span><span id="textcolor2934"><span>&#39;</span><span>\0</span><span>&#39;</span></span><span>, SYMMETRIC_KEY_LENGTH);</span> 
<a id="x1-62248r124"></a><span>124</span> 
<a id="x1-62250r125"></a><span>125</span><span>    </span><span id="textcolor2935"><span>/* Use the world</span><span>&#39;</span><span>s favourite password */</span></span> 
<a id="x1-62252r126"></a><span>126</span><span>    sprintf((</span><span id="textcolor2936"><span>char</span></span><span> *)key, </span><span id="textcolor2937"><span>&#34;%s&#34;</span></span><span>, password);</span> 
<a id="x1-62254r127"></a><span>127</span> 
<a id="x1-62256r128"></a><span>128</span><span>    </span><span id="textcolor2938"><span>/* AES 256 with given symmetric key */</span></span> 
<a id="x1-62258r129"></a><span>129</span><span>    </span><span id="textcolor2939"><span>if</span></span><span> (crypto_skcipher_setkey(sk-&gt;tfm, key, SYMMETRIC_KEY_LENGTH)) {</span> 
<a id="x1-62260r130"></a><span>130</span><span>        pr_info(</span><span id="textcolor2940"><span>&#34;key could not be set</span></span><span id="textcolor2941"><span>\n</span></span><span id="textcolor2942"><span>&#34;</span></span><span>);</span> 
<a id="x1-62262r131"></a><span>131</span><span>        ret = -EAGAIN;</span> 
<a id="x1-62264r132"></a><span>132</span><span>        </span><span id="textcolor2943"><span>goto</span></span><span> out;</span> 
<a id="x1-62266r133"></a><span>133</span><span>    }</span> 
<a id="x1-62268r134"></a><span>134</span><span>    pr_info(</span><span id="textcolor2944"><span>&#34;Symmetric key: %s</span></span><span id="textcolor2945"><span>\n</span></span><span id="textcolor2946"><span>&#34;</span></span><span>, key);</span> 
<a id="x1-62270r135"></a><span>135</span><span>    pr_info(</span><span id="textcolor2947"><span>&#34;Plaintext: %s</span></span><span id="textcolor2948"><span>\n</span></span><span id="textcolor2949"><span>&#34;</span></span><span>, plaintext);</span> 
<a id="x1-62272r136"></a><span>136</span> 
<a id="x1-62274r137"></a><span>137</span><span>    </span><span id="textcolor2950"><span>if</span></span><span> (!sk-&gt;ivdata) {</span> 
<a id="x1-62276r138"></a><span>138</span><span>        </span><span id="textcolor2951"><span>/* see https://en.wikipedia.org/wiki/Initialization_vector */</span></span> 
<a id="x1-62278r139"></a><span>139</span><span>        sk-&gt;ivdata = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);</span> 
<a id="x1-62280r140"></a><span>140</span><span>        </span><span id="textcolor2952"><span>if</span></span><span> (!sk-&gt;ivdata) {</span> 
<a id="x1-62282r141"></a><span>141</span><span>            pr_info(</span><span id="textcolor2953"><span>&#34;could not allocate ivdata</span></span><span id="textcolor2954"><span>\n</span></span><span id="textcolor2955"><span>&#34;</span></span><span>);</span> 
<a id="x1-62284r142"></a><span>142</span><span>            </span><span id="textcolor2956"><span>goto</span></span><span> out;</span> 
<a id="x1-62286r143"></a><span>143</span><span>        }</span> 
<a id="x1-62288r144"></a><span>144</span><span>        get_random_bytes(sk-&gt;ivdata, CIPHER_BLOCK_SIZE);</span> 
<a id="x1-62290r145"></a><span>145</span><span>    }</span> 
<a id="x1-62292r146"></a><span>146</span> 
<a id="x1-62294r147"></a><span>147</span><span>    </span><span id="textcolor2957"><span>if</span></span><span> (!sk-&gt;scratchpad) {</span> 
<a id="x1-62296r148"></a><span>148</span><span>        </span><span id="textcolor2958"><span>/* The text to be encrypted */</span></span> 
<a id="x1-62298r149"></a><span>149</span><span>        sk-&gt;scratchpad = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);</span> 
<a id="x1-62300r150"></a><span>150</span><span>        </span><span id="textcolor2959"><span>if</span></span><span> (!sk-&gt;scratchpad) {</span> 
<a id="x1-62302r151"></a><span>151</span><span>            pr_info(</span><span id="textcolor2960"><span>&#34;could not allocate scratchpad</span></span><span id="textcolor2961"><span>\n</span></span><span id="textcolor2962"><span>&#34;</span></span><span>);</span> 
<a id="x1-62304r152"></a><span>152</span><span>            </span><span id="textcolor2963"><span>goto</span></span><span> out;</span> 
<a id="x1-62306r153"></a><span>153</span><span>        }</span> 
<a id="x1-62308r154"></a><span>154</span><span>    }</span> 
<a id="x1-62310r155"></a><span>155</span><span>    sprintf((</span><span id="textcolor2964"><span>char</span></span><span> *)sk-&gt;scratchpad, </span><span id="textcolor2965"><span>&#34;%s&#34;</span></span><span>, plaintext);</span> 
<a id="x1-62312r156"></a><span>156</span> 
<a id="x1-62314r157"></a><span>157</span><span>    sg_init_one(&amp;sk-&gt;sg, sk-&gt;scratchpad, CIPHER_BLOCK_SIZE);</span> 
<a id="x1-62316r158"></a><span>158</span><span>    skcipher_request_set_crypt(sk-&gt;req, &amp;sk-&gt;sg, &amp;sk-&gt;sg, CIPHER_BLOCK_SIZE,</span> 
<a id="x1-62318r159"></a><span>159</span><span>                               sk-&gt;ivdata);</span> 
<a id="x1-62320r160"></a><span>160</span><span>    init_completion(&amp;sk-&gt;result.completion);</span> 
<a id="x1-62322r161"></a><span>161</span> 
<a id="x1-62324r162"></a><span>162</span><span>    </span><span id="textcolor2966"><span>/* encrypt data */</span></span> 
<a id="x1-62326r163"></a><span>163</span><span>    ret = crypto_skcipher_encrypt(sk-&gt;req);</span> 
<a id="x1-62328r164"></a><span>164</span><span>    ret = test_skcipher_result(sk, ret);</span> 
<a id="x1-62330r165"></a><span>165</span><span>    </span><span id="textcolor2967"><span>if</span></span><span> (ret)</span> 
<a id="x1-62332r166"></a><span>166</span><span>        </span><span id="textcolor2968"><span>goto</span></span><span> out;</span> 
<a id="x1-62334r167"></a><span>167</span> 
<a id="x1-62336r168"></a><span>168</span><span>    pr_info(</span><span id="textcolor2969"><span>&#34;Encryption request successful</span></span><span id="textcolor2970"><span>\n</span></span><span id="textcolor2971"><span>&#34;</span></span><span>);</span> 
<a id="x1-62338r169"></a><span>169</span> 
<a id="x1-62340r170"></a><span>170</span><span>out:</span> 
<a id="x1-62342r171"></a><span>171</span><span>    </span><span id="textcolor2972"><span>return</span></span><span> ret;</span> 
<a id="x1-62344r172"></a><span>172</span><span>}</span> 
<a id="x1-62346r173"></a><span>173</span> 
<a id="x1-62348r174"></a><span>174</span><span id="textcolor2973"><span>static</span></span><span> </span><span id="textcolor2974"><span>int</span></span><span> cryptoapi_init(</span><span id="textcolor2975"><span>void</span></span><span>)</span> 
<a id="x1-62350r175"></a><span>175</span><span>{</span> 
<a id="x1-62352r176"></a><span>176</span><span>    </span><span id="textcolor2976"><span>/* The world</span><span>&#39;</span><span>s favorite password */</span></span> 
<a id="x1-62354r177"></a><span>177</span><span>    </span><span id="textcolor2977"><span>char</span></span><span> *password = </span><span id="textcolor2978"><span>&#34;password123&#34;</span></span><span>;</span> 
<a id="x1-62356r178"></a><span>178</span> 
<a id="x1-62358r179"></a><span>179</span><span>    sk.tfm = NULL;</span> 
<a id="x1-62360r180"></a><span>180</span><span>    sk.req = NULL;</span> 
<a id="x1-62362r181"></a><span>181</span><span>    sk.scratchpad = NULL;</span> 
<a id="x1-62364r182"></a><span>182</span><span>    sk.ciphertext = NULL;</span> 
<a id="x1-62366r183"></a><span>183</span><span>    sk.ivdata = NULL;</span> 
<a id="x1-62368r184"></a><span>184</span> 
<a id="x1-62370r185"></a><span>185</span><span>    test_skcipher_encrypt(</span><span id="textcolor2979"><span>&#34;Testing&#34;</span></span><span>, password, &amp;sk);</span> 
<a id="x1-62372r186"></a><span>186</span><span>    </span><span id="textcolor2980"><span>return</span></span><span> 0;</span> 
<a id="x1-62374r187"></a><span>187</span><span>}</span> 
<a id="x1-62376r188"></a><span>188</span> 
<a id="x1-62378r189"></a><span>189</span><span id="textcolor2981"><span>static</span></span><span> </span><span id="textcolor2982"><span>void</span></span><span> cryptoapi_exit(</span><span id="textcolor2983"><span>void</span></span><span>)</span> 
<a id="x1-62380r190"></a><span>190</span><span>{</span> 
<a id="x1-62382r191"></a><span>191</span><span>    test_skcipher_finish(&amp;sk);</span> 
<a id="x1-62384r192"></a><span>192</span><span>}</span> 
<a id="x1-62386r193"></a><span>193</span> 
<a id="x1-62388r194"></a><span>194</span><span>module_init(cryptoapi_init);</span> 
<a id="x1-62390r195"></a><span>195</span><span>module_exit(cryptoapi_exit);</span> 
<a id="x1-62392r196"></a><span>196</span> 
<a id="x1-62394r197"></a><span>197</span><span>MODULE_DESCRIPTION(</span><span id="textcolor2984"><span>&#34;Symmetric key encryption example&#34;</span></span><span>);</span> 
<a id="x1-62396r198"></a><span>198</span><span>MODULE_LICENSE(</span><span id="textcolor2985"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
<!-- l. 1919 -->
   <h3 id="virtual-input-device-driver"><span>17   </span> <a id="x1-6300017"></a>Virtual Input Device Driver</h3>
<!-- l. 1921 --><p>The input device driver is a module that provides a way to communicate
with the interaction device via the event. For example, the keyboard
can send the press or release event to tell the kernel what we want to
do. The input device driver will allocate a new input structure with
<code> <span>input_allocate_device()</span>
</code> and sets up input bitfields, device id, version, etc. After that, registers it by calling
<code> <span>input_register_device()</span>
</code>.
</p><!-- l. 1926 --><p>   Here is an example, vinput, It is an API to allow easy
development of virtual input drivers. The drivers needs to export a
<code> <span>vinput_device()</span>
</code> that contains the virtual device name and
<code> <span>vinput_ops</span>
</code> structure that describes:
</p>
     <ul>
     <li>the init function: <code>  <span>init()</span>
     </code>
     </li>
     <li>the input event injection function: <code>  <span>send()</span>
     </code>
     </li>
     <li>the readback function: <code>  <span>read()</span>
     </code></li></ul>
<!-- l. 1936 --><p>   Then using <code>  <span>vinput_register_device()</span>
</code> and <code>  <span>vinput_unregister_device()</span>
</code> will add a new device to the list of support virtual input devices.
</p><!-- l. 1 -->
   <pre id="fancyvrb86"><a id="x1-63012r1"></a><span>1</span><span id="textcolor2986"><span>int</span></span><span> init(</span><span id="textcolor2987"><span>struct</span></span><span> vinput *);</span></pre>
<!-- l. 1942 --><p>   This function is passed a <code>  <span id="textcolor2988"><span>struct</span></span><span> vinput</span>
</code> already initialized with an allocated <code>  <span id="textcolor2989"><span>struct</span></span><span> input_dev</span>
</code>. The <code>  <span>init()</span>
</code> function is responsible for initializing the capabilities of the input device and register
it.
</p><!-- l. 1 -->
   <pre id="fancyvrb87"><a id="x1-63018r1"></a><span>1</span><span id="textcolor2990"><span>int</span></span><span> send(</span><span id="textcolor2991"><span>struct</span></span><span> vinput *, </span><span id="textcolor2992"><span>char</span></span><span> *, </span><span id="textcolor2993"><span>int</span></span><span>);</span></pre>
<!-- l. 1949 --><p>   This function will receive a user string to interpret and inject the event using the
<code> <span>input_report_XXXX</span>
</code> or <code>  <span>input_event</span>
</code> call. The string is already copied from user.
</p><!-- l. 1 -->
   <pre id="fancyvrb88"><a id="x1-63023r1"></a><span>1</span><span id="textcolor2994"><span>int</span></span><span> read(</span><span id="textcolor2995"><span>struct</span></span><span> vinput *, </span><span id="textcolor2996"><span>char</span></span><span> *, </span><span id="textcolor2997"><span>int</span></span><span>);</span></pre>
<!-- l. 1956 --><p>   This function is used for debugging and should fill the buffer parameter with the
last event sent in the virtual input device format. The buffer will then be copied to
user.
</p><!-- l. 1959 --><p>   vinput devices are created and destroyed using sysfs. And, event injection is done
through a <span><span><span>/dev</span></span></span> node. The device name will be used by the userland to export a new
virtual input device.
</p><!-- l. 1963 --><p>   The <code>  <span>class_attribute</span>
</code> structure is similar to other attribute types we talked about in section <a href="#sysfs-interacting-with-your-module">8<!-- tex4ht:ref: sec:sysfs  --></a>:
</p><!-- l. 1 -->
   <pre id="fancyvrb89"><a id="x1-63033r1"></a><span>1</span><span id="textcolor2998"><span>struct</span></span><span> class_attribute {</span> 
<a id="x1-63035r2"></a><span>2</span><span>    </span><span id="textcolor2999"><span>struct</span></span><span> attribute attr;</span> 
<a id="x1-63037r3"></a><span>3</span><span>    </span><span id="textcolor3000"><span>ssize_t</span></span><span> (*show)(</span><span id="textcolor3001"><span>struct</span></span><span> class *class, </span><span id="textcolor3002"><span>struct</span></span><span> class_attribute *attr,</span> 
<a id="x1-63039r4"></a><span>4</span><span>                    </span><span id="textcolor3003"><span>char</span></span><span> *buf);</span> 
<a id="x1-63041r5"></a><span>5</span><span>    </span><span id="textcolor3004"><span>ssize_t</span></span><span> (*store)(</span><span id="textcolor3005"><span>struct</span></span><span> class *class, </span><span id="textcolor3006"><span>struct</span></span><span> class_attribute *attr,</span> 
<a id="x1-63043r6"></a><span>6</span><span>                    </span><span id="textcolor3007"><span>const</span></span><span> </span><span id="textcolor3008"><span>char</span></span><span> *buf, </span><span id="textcolor3009"><span>size_t</span></span><span> count);</span> 
<a id="x1-63045r7"></a><span>7</span><span>};</span></pre>
<!-- l. 1975 --><p>   In <span><span><span>vinput.c</span></span></span>, the macro <code>  <span>CLASS_ATTR_WO(export/unexport)</span>
</code> defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h">include/linux/device.h</a> (in this case, <span><span><span>device.h</span></span></span> is included in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/input.h">include/linux/input.h</a>)
will generate the <code>  <span>class_attribute</span>
</code> structures which are named <span><span><span>class_attr_export/unexport</span></span></span>. Then, put them into
<code> <span>vinput_class_attrs</span>
</code> array and the macro <code>  <span>ATTRIBUTE_GROUPS(vinput_class)</span>
</code> will generate the <code>  <span id="textcolor3010"><span>struct</span></span><span> attribute_group vinput_class_group</span>
                                                                  

                                                                  
</code> that should be assigned in <code>  <span>vinput_class</span>
</code>. Finally, call <code>  <span>class_register(&amp;vinput_class)</span>
</code> to create attributes in sysfs.
</p><!-- l. 1979 --><p>   To create a <span><span><span>vinputX</span></span></span> sysfs entry and <span><span><span>/dev</span></span></span> node.
</p><!-- l. 1 -->
   <pre id="fancyvrb90"><a id="x1-63055r1"></a><span>1</span><span>echo </span><span id="textcolor3011"><span>&#34;vkbd&#34;</span></span><span> | sudo tee /sys/class/vinput/export</span></pre>
<!-- l. 1985 --><p>   To unexport the device, just echo its id in unexport:
</p><!-- l. 1 -->
   <pre id="fancyvrb91"><a id="x1-63058r1"></a><span>1</span><span>echo </span><span id="textcolor3012"><span>&#34;0&#34;</span></span><span> | sudo tee /sys/class/vinput/unexport</span></pre>

<!-- l. 1 -->
   <pre id="fancyvrb92"><a id="x1-63060r1"></a><span>1</span><span id="textcolor3013"><span>/*</span></span> 
<a id="x1-63062r2"></a><span>2</span><span id="textcolor3014"><span> * vinput.h</span></span> 
<a id="x1-63064r3"></a><span>3</span><span id="textcolor3015"><span> */</span></span> 
<a id="x1-63066r4"></a><span>4</span> 
<a id="x1-63068r5"></a><span>5</span><span id="textcolor3016"><span>#ifndef VINPUT_H</span></span> 
<a id="x1-63070r6"></a><span>6</span><span id="textcolor3017"><span>#define VINPUT_H</span></span> 
<a id="x1-63072r7"></a><span>7</span> 
<a id="x1-63074r8"></a><span>8</span><span id="textcolor3018"><span>#include</span></span><span> </span><span id="textcolor3019"><span>&lt;linux/input.h&gt;</span></span> 
<a id="x1-63076r9"></a><span>9</span><span id="textcolor3020"><span>#include</span></span><span> </span><span id="textcolor3021"><span>&lt;linux/spinlock.h&gt;</span></span> 
<a id="x1-63078r10"></a><span>10</span> 
<a id="x1-63080r11"></a><span>11</span><span id="textcolor3022"><span>#define VINPUT_MAX_LEN 128</span></span> 
<a id="x1-63082r12"></a><span>12</span><span id="textcolor3023"><span>#define MAX_VINPUT 32</span></span> 
<a id="x1-63084r13"></a><span>13</span><span id="textcolor3024"><span>#define VINPUT_MINORS MAX_VINPUT</span></span> 
<a id="x1-63086r14"></a><span>14</span> 
<a id="x1-63088r15"></a><span>15</span><span id="textcolor3025"><span>#define dev_to_vinput(dev) container_of(dev, struct vinput, dev)</span></span> 
<a id="x1-63090r16"></a><span>16</span> 
<a id="x1-63092r17"></a><span>17</span><span id="textcolor3026"><span>struct</span></span><span> vinput_device;</span> 
<a id="x1-63094r18"></a><span>18</span> 
<a id="x1-63096r19"></a><span>19</span><span id="textcolor3027"><span>struct</span></span><span> vinput {</span> 
<a id="x1-63098r20"></a><span>20</span><span>    </span><span id="textcolor3028"><span>long</span></span><span> id;</span> 
<a id="x1-63100r21"></a><span>21</span><span>    </span><span id="textcolor3029"><span>long</span></span><span> devno;</span> 
<a id="x1-63102r22"></a><span>22</span><span>    </span><span id="textcolor3030"><span>long</span></span><span> last_entry;</span> 
<a id="x1-63104r23"></a><span>23</span><span>    spinlock_t lock;</span> 
<a id="x1-63106r24"></a><span>24</span> 
<a id="x1-63108r25"></a><span>25</span><span>    </span><span id="textcolor3031"><span>void</span></span><span> *priv_data;</span> 
<a id="x1-63110r26"></a><span>26</span> 
<a id="x1-63112r27"></a><span>27</span><span>    </span><span id="textcolor3032"><span>struct</span></span><span> device dev;</span> 
<a id="x1-63114r28"></a><span>28</span><span>    </span><span id="textcolor3033"><span>struct</span></span><span> list_head list;</span> 
<a id="x1-63116r29"></a><span>29</span><span>    </span><span id="textcolor3034"><span>struct</span></span><span> input_dev *input;</span> 
<a id="x1-63118r30"></a><span>30</span><span>    </span><span id="textcolor3035"><span>struct</span></span><span> vinput_device *type;</span> 
<a id="x1-63120r31"></a><span>31</span><span>};</span> 
<a id="x1-63122r32"></a><span>32</span> 
<a id="x1-63124r33"></a><span>33</span><span id="textcolor3036"><span>struct</span></span><span> vinput_ops {</span> 
<a id="x1-63126r34"></a><span>34</span><span>    </span><span id="textcolor3037"><span>int</span></span><span> (*init)(</span><span id="textcolor3038"><span>struct</span></span><span> vinput *);</span> 
<a id="x1-63128r35"></a><span>35</span><span>    </span><span id="textcolor3039"><span>int</span></span><span> (*kill)(</span><span id="textcolor3040"><span>struct</span></span><span> vinput *);</span> 
<a id="x1-63130r36"></a><span>36</span><span>    </span><span id="textcolor3041"><span>int</span></span><span> (*send)(</span><span id="textcolor3042"><span>struct</span></span><span> vinput *, </span><span id="textcolor3043"><span>char</span></span><span> *, </span><span id="textcolor3044"><span>int</span></span><span>);</span> 
<a id="x1-63132r37"></a><span>37</span><span>    </span><span id="textcolor3045"><span>int</span></span><span> (*read)(</span><span id="textcolor3046"><span>struct</span></span><span> vinput *, </span><span id="textcolor3047"><span>char</span></span><span> *, </span><span id="textcolor3048"><span>int</span></span><span>);</span> 
<a id="x1-63134r38"></a><span>38</span><span>};</span> 
<a id="x1-63136r39"></a><span>39</span> 
<a id="x1-63138r40"></a><span>40</span><span id="textcolor3049"><span>struct</span></span><span> vinput_device {</span> 
<a id="x1-63140r41"></a><span>41</span><span>    </span><span id="textcolor3050"><span>char</span></span><span> name[16];</span> 
<a id="x1-63142r42"></a><span>42</span><span>    </span><span id="textcolor3051"><span>struct</span></span><span> list_head list;</span> 
<a id="x1-63144r43"></a><span>43</span><span>    </span><span id="textcolor3052"><span>struct</span></span><span> vinput_ops *ops;</span> 
<a id="x1-63146r44"></a><span>44</span><span>};</span> 
<a id="x1-63148r45"></a><span>45</span> 
<a id="x1-63150r46"></a><span>46</span><span id="textcolor3053"><span>int</span></span><span> vinput_register(</span><span id="textcolor3054"><span>struct</span></span><span> vinput_device *dev);</span> 
<a id="x1-63152r47"></a><span>47</span><span id="textcolor3055"><span>void</span></span><span> vinput_unregister(</span><span id="textcolor3056"><span>struct</span></span><span> vinput_device *dev);</span> 
<a id="x1-63154r48"></a><span>48</span> 
<a id="x1-63156r49"></a><span>49</span><span id="textcolor3057"><span>#endif</span></span></pre>

<!-- l. 1 -->
   <pre id="fancyvrb93"><a id="x1-63158r1"></a><span>1</span><span id="textcolor3058"><span>/*</span></span> 
<a id="x1-63160r2"></a><span>2</span><span id="textcolor3059"><span> * vinput.c</span></span> 
<a id="x1-63162r3"></a><span>3</span><span id="textcolor3060"><span> */</span></span> 
<a id="x1-63164r4"></a><span>4</span> 
<a id="x1-63166r5"></a><span>5</span><span id="textcolor3061"><span>#include</span></span><span> </span><span id="textcolor3062"><span>&lt;linux/cdev.h&gt;</span></span> 
<a id="x1-63168r6"></a><span>6</span><span id="textcolor3063"><span>#include</span></span><span> </span><span id="textcolor3064"><span>&lt;linux/input.h&gt;</span></span> 
<a id="x1-63170r7"></a><span>7</span><span id="textcolor3065"><span>#include</span></span><span> </span><span id="textcolor3066"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-63172r8"></a><span>8</span><span id="textcolor3067"><span>#include</span></span><span> </span><span id="textcolor3068"><span>&lt;linux/slab.h&gt;</span></span> 
<a id="x1-63174r9"></a><span>9</span><span id="textcolor3069"><span>#include</span></span><span> </span><span id="textcolor3070"><span>&lt;linux/spinlock.h&gt;</span></span> 
<a id="x1-63176r10"></a><span>10</span> 
<a id="x1-63178r11"></a><span>11</span><span id="textcolor3071"><span>#include</span></span><span> </span><span id="textcolor3072"><span>&lt;asm/uaccess.h&gt;</span></span> 
<a id="x1-63180r12"></a><span>12</span> 
<a id="x1-63182r13"></a><span>13</span><span id="textcolor3073"><span>#include</span></span><span> </span><span id="textcolor3074"><span>&#34;vinput.h&#34;</span></span> 
<a id="x1-63184r14"></a><span>14</span> 
<a id="x1-63186r15"></a><span>15</span><span id="textcolor3075"><span>#define DRIVER_NAME &#34;vinput&#34;</span></span> 
<a id="x1-63188r16"></a><span>16</span> 
<a id="x1-63190r17"></a><span>17</span><span id="textcolor3076"><span>#define dev_to_vinput(dev) container_of(dev, struct vinput, dev)</span></span> 
<a id="x1-63192r18"></a><span>18</span> 
<a id="x1-63194r19"></a><span>19</span><span id="textcolor3077"><span>static</span></span><span> DECLARE_BITMAP(vinput_ids, VINPUT_MINORS);</span> 
<a id="x1-63196r20"></a><span>20</span> 
<a id="x1-63198r21"></a><span>21</span><span id="textcolor3078"><span>static</span></span><span> LIST_HEAD(vinput_devices);</span> 
<a id="x1-63200r22"></a><span>22</span><span id="textcolor3079"><span>static</span></span><span> LIST_HEAD(vinput_vdevices);</span> 
<a id="x1-63202r23"></a><span>23</span> 
<a id="x1-63204r24"></a><span>24</span><span id="textcolor3080"><span>static</span></span><span> </span><span id="textcolor3081"><span>int</span></span><span> vinput_dev;</span> 
<a id="x1-63206r25"></a><span>25</span><span id="textcolor3082"><span>static</span></span><span> </span><span id="textcolor3083"><span>struct</span></span><span> spinlock vinput_lock;</span> 
<a id="x1-63208r26"></a><span>26</span><span id="textcolor3084"><span>static</span></span><span> </span><span id="textcolor3085"><span>struct</span></span><span> class vinput_class;</span> 
<a id="x1-63210r27"></a><span>27</span> 
<a id="x1-63212r28"></a><span>28</span><span id="textcolor3086"><span>/* Search the name of vinput device in the vinput_devices linked list,</span></span> 
<a id="x1-63214r29"></a><span>29</span><span id="textcolor3087"><span> * which added at vinput_register().</span></span> 
<a id="x1-63216r30"></a><span>30</span><span id="textcolor3088"><span> */</span></span> 
<a id="x1-63218r31"></a><span>31</span><span id="textcolor3089"><span>static</span></span><span> </span><span id="textcolor3090"><span>struct</span></span><span> vinput_device *vinput_get_device_by_type(</span><span id="textcolor3091"><span>const</span></span><span> </span><span id="textcolor3092"><span>char</span></span><span> *type)</span> 
<a id="x1-63220r32"></a><span>32</span><span>{</span> 
<a id="x1-63222r33"></a><span>33</span><span>    </span><span id="textcolor3093"><span>int</span></span><span> found = 0;</span> 
<a id="x1-63224r34"></a><span>34</span><span>    </span><span id="textcolor3094"><span>struct</span></span><span> vinput_device *vinput;</span> 
<a id="x1-63226r35"></a><span>35</span><span>    </span><span id="textcolor3095"><span>struct</span></span><span> list_head *curr;</span> 
<a id="x1-63228r36"></a><span>36</span> 
<a id="x1-63230r37"></a><span>37</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63232r38"></a><span>38</span><span>    list_for_each (curr, &amp;vinput_devices) {</span> 
<a id="x1-63234r39"></a><span>39</span><span>        vinput = list_entry(curr, </span><span id="textcolor3096"><span>struct</span></span><span> vinput_device, list);</span> 
<a id="x1-63236r40"></a><span>40</span><span>        </span><span id="textcolor3097"><span>if</span></span><span> (vinput &amp;&amp; strncmp(type, vinput-&gt;name, strlen(vinput-&gt;name)) == 0) {</span> 
<a id="x1-63238r41"></a><span>41</span><span>            found = 1;</span> 
<a id="x1-63240r42"></a><span>42</span><span>            </span><span id="textcolor3098"><span>break</span></span><span>;</span> 
<a id="x1-63242r43"></a><span>43</span><span>        }</span> 
<a id="x1-63244r44"></a><span>44</span><span>    }</span> 
<a id="x1-63246r45"></a><span>45</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63248r46"></a><span>46</span> 
<a id="x1-63250r47"></a><span>47</span><span>    </span><span id="textcolor3099"><span>if</span></span><span> (found)</span> 
<a id="x1-63252r48"></a><span>48</span><span>        </span><span id="textcolor3100"><span>return</span></span><span> vinput;</span> 
<a id="x1-63254r49"></a><span>49</span><span>    </span><span id="textcolor3101"><span>return</span></span><span> ERR_PTR(-ENODEV);</span> 
<a id="x1-63256r50"></a><span>50</span><span>}</span> 
<a id="x1-63258r51"></a><span>51</span> 
<a id="x1-63260r52"></a><span>52</span><span id="textcolor3102"><span>/* Search the id of virtual device in the vinput_vdevices linked list,</span></span> 
<a id="x1-63262r53"></a><span>53</span><span id="textcolor3103"><span> * which added at vinput_alloc_vdevice().</span></span> 
<a id="x1-63264r54"></a><span>54</span><span id="textcolor3104"><span> */</span></span> 
<a id="x1-63266r55"></a><span>55</span><span id="textcolor3105"><span>static</span></span><span> </span><span id="textcolor3106"><span>struct</span></span><span> vinput *vinput_get_vdevice_by_id(</span><span id="textcolor3107"><span>long</span></span><span> id)</span> 
<a id="x1-63268r56"></a><span>56</span><span>{</span> 
<a id="x1-63270r57"></a><span>57</span><span>    </span><span id="textcolor3108"><span>struct</span></span><span> vinput *vinput = NULL;</span> 
<a id="x1-63272r58"></a><span>58</span><span>    </span><span id="textcolor3109"><span>struct</span></span><span> list_head *curr;</span> 
<a id="x1-63274r59"></a><span>59</span> 
<a id="x1-63276r60"></a><span>60</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63278r61"></a><span>61</span><span>    list_for_each (curr, &amp;vinput_vdevices) {</span> 
<a id="x1-63280r62"></a><span>62</span><span>        vinput = list_entry(curr, </span><span id="textcolor3110"><span>struct</span></span><span> vinput, list);</span> 
<a id="x1-63282r63"></a><span>63</span><span>        </span><span id="textcolor3111"><span>if</span></span><span> (vinput &amp;&amp; vinput-&gt;id == id)</span> 
<a id="x1-63284r64"></a><span>64</span><span>            </span><span id="textcolor3112"><span>break</span></span><span>;</span> 
<a id="x1-63286r65"></a><span>65</span><span>    }</span> 
<a id="x1-63288r66"></a><span>66</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63290r67"></a><span>67</span> 
<a id="x1-63292r68"></a><span>68</span><span>    </span><span id="textcolor3113"><span>if</span></span><span> (vinput &amp;&amp; vinput-&gt;id == id)</span> 
<a id="x1-63294r69"></a><span>69</span><span>        </span><span id="textcolor3114"><span>return</span></span><span> vinput;</span> 
<a id="x1-63296r70"></a><span>70</span><span>    </span><span id="textcolor3115"><span>return</span></span><span> ERR_PTR(-ENODEV);</span> 
<a id="x1-63298r71"></a><span>71</span><span>}</span> 
<a id="x1-63300r72"></a><span>72</span> 
<a id="x1-63302r73"></a><span>73</span><span id="textcolor3116"><span>static</span></span><span> </span><span id="textcolor3117"><span>int</span></span><span> vinput_open(</span><span id="textcolor3118"><span>struct</span></span><span> inode *inode, </span><span id="textcolor3119"><span>struct</span></span><span> file *file)</span> 
<a id="x1-63304r74"></a><span>74</span><span>{</span> 
<a id="x1-63306r75"></a><span>75</span><span>    </span><span id="textcolor3120"><span>int</span></span><span> err = 0;</span> 
<a id="x1-63308r76"></a><span>76</span><span>    </span><span id="textcolor3121"><span>struct</span></span><span> vinput *vinput = NULL;</span> 
<a id="x1-63310r77"></a><span>77</span> 
<a id="x1-63312r78"></a><span>78</span><span>    vinput = vinput_get_vdevice_by_id(iminor(inode));</span> 
<a id="x1-63314r79"></a><span>79</span> 
<a id="x1-63316r80"></a><span>80</span><span>    </span><span id="textcolor3122"><span>if</span></span><span> (IS_ERR(vinput))</span> 
<a id="x1-63318r81"></a><span>81</span><span>        err = PTR_ERR(vinput);</span> 
<a id="x1-63320r82"></a><span>82</span><span>    </span><span id="textcolor3123"><span>else</span></span> 
<a id="x1-63322r83"></a><span>83</span><span>        file-&gt;private_data = vinput;</span> 
<a id="x1-63324r84"></a><span>84</span> 
<a id="x1-63326r85"></a><span>85</span><span>    </span><span id="textcolor3124"><span>return</span></span><span> err;</span> 
<a id="x1-63328r86"></a><span>86</span><span>}</span> 
<a id="x1-63330r87"></a><span>87</span> 
<a id="x1-63332r88"></a><span>88</span><span id="textcolor3125"><span>static</span></span><span> </span><span id="textcolor3126"><span>int</span></span><span> vinput_release(</span><span id="textcolor3127"><span>struct</span></span><span> inode *inode, </span><span id="textcolor3128"><span>struct</span></span><span> file *file)</span> 
<a id="x1-63334r89"></a><span>89</span><span>{</span> 
<a id="x1-63336r90"></a><span>90</span><span>    </span><span id="textcolor3129"><span>return</span></span><span> 0;</span> 
<a id="x1-63338r91"></a><span>91</span><span>}</span> 
<a id="x1-63340r92"></a><span>92</span> 
<a id="x1-63342r93"></a><span>93</span><span id="textcolor3130"><span>static</span></span><span> </span><span id="textcolor3131"><span>ssize_t</span></span><span> vinput_read(</span><span id="textcolor3132"><span>struct</span></span><span> file *file, </span><span id="textcolor3133"><span>char</span></span><span> __user *buffer, </span><span id="textcolor3134"><span>size_t</span></span><span> count,</span> 
<a id="x1-63344r94"></a><span>94</span><span>                           loff_t *offset)</span> 
<a id="x1-63346r95"></a><span>95</span><span>{</span> 
<a id="x1-63348r96"></a><span>96</span><span>    </span><span id="textcolor3135"><span>int</span></span><span> len;</span> 
<a id="x1-63350r97"></a><span>97</span><span>    </span><span id="textcolor3136"><span>char</span></span><span> buff[VINPUT_MAX_LEN + 1];</span> 
<a id="x1-63352r98"></a><span>98</span><span>    </span><span id="textcolor3137"><span>struct</span></span><span> vinput *vinput = file-&gt;private_data;</span> 
<a id="x1-63354r99"></a><span>99</span> 
<a id="x1-63356r100"></a><span>100</span><span>    len = vinput-&gt;type-&gt;ops-&gt;read(vinput, buff, count);</span> 
<a id="x1-63358r101"></a><span>101</span> 
<a id="x1-63360r102"></a><span>102</span><span>    </span><span id="textcolor3138"><span>if</span></span><span> (*offset &gt; len)</span> 
<a id="x1-63362r103"></a><span>103</span><span>        count = 0;</span> 
<a id="x1-63364r104"></a><span>104</span><span>    </span><span id="textcolor3139"><span>else</span></span><span> </span><span id="textcolor3140"><span>if</span></span><span> (count + *offset &gt; VINPUT_MAX_LEN)</span> 
<a id="x1-63366r105"></a><span>105</span><span>        count = len - *offset;</span> 
<a id="x1-63368r106"></a><span>106</span> 
<a id="x1-63370r107"></a><span>107</span><span>    </span><span id="textcolor3141"><span>if</span></span><span> (raw_copy_to_user(buffer, buff + *offset, count))</span> 
<a id="x1-63372r108"></a><span>108</span><span>        count = -EFAULT;</span> 
<a id="x1-63374r109"></a><span>109</span> 
<a id="x1-63376r110"></a><span>110</span><span>    *offset += count;</span> 
<a id="x1-63378r111"></a><span>111</span> 
<a id="x1-63380r112"></a><span>112</span><span>    </span><span id="textcolor3142"><span>return</span></span><span> count;</span> 
<a id="x1-63382r113"></a><span>113</span><span>}</span> 
<a id="x1-63384r114"></a><span>114</span> 
<a id="x1-63386r115"></a><span>115</span><span id="textcolor3143"><span>static</span></span><span> </span><span id="textcolor3144"><span>ssize_t</span></span><span> vinput_write(</span><span id="textcolor3145"><span>struct</span></span><span> file *file, </span><span id="textcolor3146"><span>const</span></span><span> </span><span id="textcolor3147"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-63388r116"></a><span>116</span><span>                            </span><span id="textcolor3148"><span>size_t</span></span><span> count, loff_t *offset)</span> 
<a id="x1-63390r117"></a><span>117</span><span>{</span> 
<a id="x1-63392r118"></a><span>118</span><span>    </span><span id="textcolor3149"><span>char</span></span><span> buff[VINPUT_MAX_LEN + 1];</span> 
<a id="x1-63394r119"></a><span>119</span><span>    </span><span id="textcolor3150"><span>struct</span></span><span> vinput *vinput = file-&gt;private_data;</span> 
<a id="x1-63396r120"></a><span>120</span> 
<a id="x1-63398r121"></a><span>121</span><span>    memset(buff, 0, </span><span id="textcolor3151"><span>sizeof</span></span><span>(</span><span id="textcolor3152"><span>char</span></span><span>) * (VINPUT_MAX_LEN + 1));</span> 
<a id="x1-63400r122"></a><span>122</span> 
<a id="x1-63402r123"></a><span>123</span><span>    </span><span id="textcolor3153"><span>if</span></span><span> (count &gt; VINPUT_MAX_LEN) {</span> 
<a id="x1-63404r124"></a><span>124</span><span>        dev_warn(&amp;vinput-&gt;dev, </span><span id="textcolor3154"><span>&#34;Too long. %d bytes allowed</span></span><span id="textcolor3155"><span>\n</span></span><span id="textcolor3156"><span>&#34;</span></span><span>, VINPUT_MAX_LEN);</span> 
<a id="x1-63406r125"></a><span>125</span><span>        </span><span id="textcolor3157"><span>return</span></span><span> -EINVAL;</span> 
<a id="x1-63408r126"></a><span>126</span><span>    }</span> 
<a id="x1-63410r127"></a><span>127</span> 
<a id="x1-63412r128"></a><span>128</span><span>    </span><span id="textcolor3158"><span>if</span></span><span> (raw_copy_from_user(buff, buffer, count))</span> 
<a id="x1-63414r129"></a><span>129</span><span>        </span><span id="textcolor3159"><span>return</span></span><span> -EFAULT;</span> 
<a id="x1-63416r130"></a><span>130</span> 
<a id="x1-63418r131"></a><span>131</span><span>    </span><span id="textcolor3160"><span>return</span></span><span> vinput-&gt;type-&gt;ops-&gt;send(vinput, buff, count);</span> 
<a id="x1-63420r132"></a><span>132</span><span>}</span> 
<a id="x1-63422r133"></a><span>133</span> 
<a id="x1-63424r134"></a><span>134</span><span id="textcolor3161"><span>static</span></span><span> </span><span id="textcolor3162"><span>const</span></span><span> </span><span id="textcolor3163"><span>struct</span></span><span> file_operations vinput_fops = {</span> 
<a id="x1-63426r135"></a><span>135</span><span>    .owner = THIS_MODULE,</span> 
<a id="x1-63428r136"></a><span>136</span><span>    .open = vinput_open,</span> 
<a id="x1-63430r137"></a><span>137</span><span>    .release = vinput_release,</span> 
<a id="x1-63432r138"></a><span>138</span><span>    .read = vinput_read,</span> 
<a id="x1-63434r139"></a><span>139</span><span>    .write = vinput_write,</span> 
<a id="x1-63436r140"></a><span>140</span><span>};</span> 
<a id="x1-63438r141"></a><span>141</span> 
<a id="x1-63440r142"></a><span>142</span><span id="textcolor3164"><span>static</span></span><span> </span><span id="textcolor3165"><span>void</span></span><span> vinput_unregister_vdevice(</span><span id="textcolor3166"><span>struct</span></span><span> vinput *vinput)</span> 
<a id="x1-63442r143"></a><span>143</span><span>{</span> 
<a id="x1-63444r144"></a><span>144</span><span>    input_unregister_device(vinput-&gt;input);</span> 
<a id="x1-63446r145"></a><span>145</span><span>    </span><span id="textcolor3167"><span>if</span></span><span> (vinput-&gt;type-&gt;ops-&gt;kill)</span> 
<a id="x1-63448r146"></a><span>146</span><span>        vinput-&gt;type-&gt;ops-&gt;kill(vinput);</span> 
<a id="x1-63450r147"></a><span>147</span><span>}</span> 
<a id="x1-63452r148"></a><span>148</span> 
<a id="x1-63454r149"></a><span>149</span><span id="textcolor3168"><span>static</span></span><span> </span><span id="textcolor3169"><span>void</span></span><span> vinput_destroy_vdevice(</span><span id="textcolor3170"><span>struct</span></span><span> vinput *vinput)</span> 
<a id="x1-63456r150"></a><span>150</span><span>{</span> 
<a id="x1-63458r151"></a><span>151</span><span>    </span><span id="textcolor3171"><span>/* Remove from the list first */</span></span> 
<a id="x1-63460r152"></a><span>152</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63462r153"></a><span>153</span><span>    list_del(&amp;vinput-&gt;list);</span> 
<a id="x1-63464r154"></a><span>154</span><span>    clear_bit(vinput-&gt;id, vinput_ids);</span> 
<a id="x1-63466r155"></a><span>155</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63468r156"></a><span>156</span> 
<a id="x1-63470r157"></a><span>157</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-63472r158"></a><span>158</span> 
<a id="x1-63474r159"></a><span>159</span><span>    kfree(vinput);</span> 
<a id="x1-63476r160"></a><span>160</span><span>}</span> 
<a id="x1-63478r161"></a><span>161</span> 
<a id="x1-63480r162"></a><span>162</span><span id="textcolor3172"><span>static</span></span><span> </span><span id="textcolor3173"><span>void</span></span><span> vinput_release_dev(</span><span id="textcolor3174"><span>struct</span></span><span> device *dev)</span> 
<a id="x1-63482r163"></a><span>163</span><span>{</span> 
<a id="x1-63484r164"></a><span>164</span><span>    </span><span id="textcolor3175"><span>struct</span></span><span> vinput *vinput = dev_to_vinput(dev);</span> 
<a id="x1-63486r165"></a><span>165</span><span>    </span><span id="textcolor3176"><span>int</span></span><span> id = vinput-&gt;id;</span> 
<a id="x1-63488r166"></a><span>166</span> 
<a id="x1-63490r167"></a><span>167</span><span>    vinput_destroy_vdevice(vinput);</span> 
<a id="x1-63492r168"></a><span>168</span> 
<a id="x1-63494r169"></a><span>169</span><span>    pr_debug(</span><span id="textcolor3177"><span>&#34;released vinput%d.</span></span><span id="textcolor3178"><span>\n</span></span><span id="textcolor3179"><span>&#34;</span></span><span>, id);</span> 
<a id="x1-63496r170"></a><span>170</span><span>}</span> 
<a id="x1-63498r171"></a><span>171</span> 
<a id="x1-63500r172"></a><span>172</span><span id="textcolor3180"><span>static</span></span><span> </span><span id="textcolor3181"><span>struct</span></span><span> vinput *vinput_alloc_vdevice(</span><span id="textcolor3182"><span>void</span></span><span>)</span> 
<a id="x1-63502r173"></a><span>173</span><span>{</span> 
<a id="x1-63504r174"></a><span>174</span><span>    </span><span id="textcolor3183"><span>int</span></span><span> err;</span> 
<a id="x1-63506r175"></a><span>175</span><span>    </span><span id="textcolor3184"><span>struct</span></span><span> vinput *vinput = kzalloc(</span><span id="textcolor3185"><span>sizeof</span></span><span>(</span><span id="textcolor3186"><span>struct</span></span><span> vinput), GFP_KERNEL);</span> 
<a id="x1-63508r176"></a><span>176</span> 
<a id="x1-63510r177"></a><span>177</span><span>    try_module_get(THIS_MODULE);</span> 
<a id="x1-63512r178"></a><span>178</span> 
<a id="x1-63514r179"></a><span>179</span><span>    memset(vinput, 0, </span><span id="textcolor3187"><span>sizeof</span></span><span>(</span><span id="textcolor3188"><span>struct</span></span><span> vinput));</span> 
<a id="x1-63516r180"></a><span>180</span> 
<a id="x1-63518r181"></a><span>181</span><span>    spin_lock_init(&amp;vinput-&gt;lock);</span> 
<a id="x1-63520r182"></a><span>182</span> 
<a id="x1-63522r183"></a><span>183</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63524r184"></a><span>184</span><span>    vinput-&gt;id = find_first_zero_bit(vinput_ids, VINPUT_MINORS);</span> 
<a id="x1-63526r185"></a><span>185</span><span>    </span><span id="textcolor3189"><span>if</span></span><span> (vinput-&gt;id &gt;= VINPUT_MINORS) {</span> 
<a id="x1-63528r186"></a><span>186</span><span>        err = -ENOBUFS;</span> 
<a id="x1-63530r187"></a><span>187</span><span>        </span><span id="textcolor3190"><span>goto</span></span><span> fail_id;</span> 
<a id="x1-63532r188"></a><span>188</span><span>    }</span> 
<a id="x1-63534r189"></a><span>189</span><span>    set_bit(vinput-&gt;id, vinput_ids);</span> 
<a id="x1-63536r190"></a><span>190</span><span>    list_add(&amp;vinput-&gt;list, &amp;vinput_vdevices);</span> 
<a id="x1-63538r191"></a><span>191</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63540r192"></a><span>192</span> 
<a id="x1-63542r193"></a><span>193</span><span>    </span><span id="textcolor3191"><span>/* allocate the input device */</span></span> 
<a id="x1-63544r194"></a><span>194</span><span>    vinput-&gt;input = input_allocate_device();</span> 
<a id="x1-63546r195"></a><span>195</span><span>    </span><span id="textcolor3192"><span>if</span></span><span> (vinput-&gt;input == NULL) {</span> 
<a id="x1-63548r196"></a><span>196</span><span>        pr_err(</span><span id="textcolor3193"><span>&#34;vinput: Cannot allocate vinput input device</span></span><span id="textcolor3194"><span>\n</span></span><span id="textcolor3195"><span>&#34;</span></span><span>);</span> 
<a id="x1-63550r197"></a><span>197</span><span>        err = -ENOMEM;</span> 
<a id="x1-63552r198"></a><span>198</span><span>        </span><span id="textcolor3196"><span>goto</span></span><span> fail_input_dev;</span> 
<a id="x1-63554r199"></a><span>199</span><span>    }</span> 
<a id="x1-63556r200"></a><span>200</span> 
<a id="x1-63558r201"></a><span>201</span><span>    </span><span id="textcolor3197"><span>/* initialize device */</span></span> 
<a id="x1-63560r202"></a><span>202</span><span>    vinput-&gt;dev.class = &amp;vinput_class;</span> 
<a id="x1-63562r203"></a><span>203</span><span>    vinput-&gt;dev.release = vinput_release_dev;</span> 
<a id="x1-63564r204"></a><span>204</span><span>    vinput-&gt;dev.devt = MKDEV(vinput_dev, vinput-&gt;id);</span> 
<a id="x1-63566r205"></a><span>205</span><span>    dev_set_name(&amp;vinput-&gt;dev, DRIVER_NAME </span><span id="textcolor3198"><span>&#34;%lu&#34;</span></span><span>, vinput-&gt;id);</span> 
<a id="x1-63568r206"></a><span>206</span> 
<a id="x1-63570r207"></a><span>207</span><span>    </span><span id="textcolor3199"><span>return</span></span><span> vinput;</span> 
<a id="x1-63572r208"></a><span>208</span> 
<a id="x1-63574r209"></a><span>209</span><span>fail_input_dev:</span> 
<a id="x1-63576r210"></a><span>210</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63578r211"></a><span>211</span><span>    list_del(&amp;vinput-&gt;list);</span> 
<a id="x1-63580r212"></a><span>212</span><span>fail_id:</span> 
<a id="x1-63582r213"></a><span>213</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63584r214"></a><span>214</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-63586r215"></a><span>215</span><span>    kfree(vinput);</span> 
<a id="x1-63588r216"></a><span>216</span> 
<a id="x1-63590r217"></a><span>217</span><span>    </span><span id="textcolor3200"><span>return</span></span><span> ERR_PTR(err);</span> 
<a id="x1-63592r218"></a><span>218</span><span>}</span> 
<a id="x1-63594r219"></a><span>219</span> 
<a id="x1-63596r220"></a><span>220</span><span id="textcolor3201"><span>static</span></span><span> </span><span id="textcolor3202"><span>int</span></span><span> vinput_register_vdevice(</span><span id="textcolor3203"><span>struct</span></span><span> vinput *vinput)</span> 
<a id="x1-63598r221"></a><span>221</span><span>{</span> 
<a id="x1-63600r222"></a><span>222</span><span>    </span><span id="textcolor3204"><span>int</span></span><span> err = 0;</span> 
<a id="x1-63602r223"></a><span>223</span> 
<a id="x1-63604r224"></a><span>224</span><span>    </span><span id="textcolor3205"><span>/* register the input device */</span></span> 
<a id="x1-63606r225"></a><span>225</span><span>    vinput-&gt;input-&gt;name = vinput-&gt;type-&gt;name;</span> 
<a id="x1-63608r226"></a><span>226</span><span>    vinput-&gt;input-&gt;phys = </span><span id="textcolor3206"><span>&#34;vinput&#34;</span></span><span>;</span> 
<a id="x1-63610r227"></a><span>227</span><span>    vinput-&gt;input-&gt;dev.parent = &amp;vinput-&gt;dev;</span> 
<a id="x1-63612r228"></a><span>228</span> 
<a id="x1-63614r229"></a><span>229</span><span>    vinput-&gt;input-&gt;id.bustype = BUS_VIRTUAL;</span> 
<a id="x1-63616r230"></a><span>230</span><span>    vinput-&gt;input-&gt;id.product = 0x0000;</span> 
<a id="x1-63618r231"></a><span>231</span><span>    vinput-&gt;input-&gt;id.vendor = 0x0000;</span> 
<a id="x1-63620r232"></a><span>232</span><span>    vinput-&gt;input-&gt;id.version = 0x0000;</span> 
<a id="x1-63622r233"></a><span>233</span> 
<a id="x1-63624r234"></a><span>234</span><span>    err = vinput-&gt;type-&gt;ops-&gt;init(vinput);</span> 
<a id="x1-63626r235"></a><span>235</span> 
<a id="x1-63628r236"></a><span>236</span><span>    </span><span id="textcolor3207"><span>if</span></span><span> (err == 0)</span> 
<a id="x1-63630r237"></a><span>237</span><span>        dev_info(&amp;vinput-&gt;dev, </span><span id="textcolor3208"><span>&#34;Registered virtual input %s %ld</span></span><span id="textcolor3209"><span>\n</span></span><span id="textcolor3210"><span>&#34;</span></span><span>,</span> 
<a id="x1-63632r238"></a><span>238</span><span>                 vinput-&gt;type-&gt;name, vinput-&gt;id);</span> 
<a id="x1-63634r239"></a><span>239</span> 
<a id="x1-63636r240"></a><span>240</span><span>    </span><span id="textcolor3211"><span>return</span></span><span> err;</span> 
<a id="x1-63638r241"></a><span>241</span><span>}</span> 
<a id="x1-63640r242"></a><span>242</span> 
<a id="x1-63642r243"></a><span>243</span><span id="textcolor3212"><span>static</span></span><span> </span><span id="textcolor3213"><span>ssize_t</span></span><span> export_store(</span><span id="textcolor3214"><span>struct</span></span><span> class *class, </span><span id="textcolor3215"><span>struct</span></span><span> class_attribute *attr,</span> 
<a id="x1-63644r244"></a><span>244</span><span>                            </span><span id="textcolor3216"><span>const</span></span><span> </span><span id="textcolor3217"><span>char</span></span><span> *buf, </span><span id="textcolor3218"><span>size_t</span></span><span> len)</span> 
<a id="x1-63646r245"></a><span>245</span><span>{</span> 
<a id="x1-63648r246"></a><span>246</span><span>    </span><span id="textcolor3219"><span>int</span></span><span> err;</span> 
<a id="x1-63650r247"></a><span>247</span><span>    </span><span id="textcolor3220"><span>struct</span></span><span> vinput *vinput;</span> 
<a id="x1-63652r248"></a><span>248</span><span>    </span><span id="textcolor3221"><span>struct</span></span><span> vinput_device *device;</span> 
<a id="x1-63654r249"></a><span>249</span> 
<a id="x1-63656r250"></a><span>250</span><span>    device = vinput_get_device_by_type(buf);</span> 
<a id="x1-63658r251"></a><span>251</span><span>    </span><span id="textcolor3222"><span>if</span></span><span> (IS_ERR(device)) {</span> 
<a id="x1-63660r252"></a><span>252</span><span>        pr_info(</span><span id="textcolor3223"><span>&#34;vinput: This virtual device isn</span><span>&#39;</span><span>t registered</span></span><span id="textcolor3224"><span>\n</span></span><span id="textcolor3225"><span>&#34;</span></span><span>);</span> 
<a id="x1-63662r253"></a><span>253</span><span>        err = PTR_ERR(device);</span> 
<a id="x1-63664r254"></a><span>254</span><span>        </span><span id="textcolor3226"><span>goto</span></span><span> fail;</span> 
<a id="x1-63666r255"></a><span>255</span><span>    }</span> 
<a id="x1-63668r256"></a><span>256</span> 
<a id="x1-63670r257"></a><span>257</span><span>    vinput = vinput_alloc_vdevice();</span> 
<a id="x1-63672r258"></a><span>258</span><span>    </span><span id="textcolor3227"><span>if</span></span><span> (IS_ERR(vinput)) {</span> 
<a id="x1-63674r259"></a><span>259</span><span>        err = PTR_ERR(vinput);</span> 
<a id="x1-63676r260"></a><span>260</span><span>        </span><span id="textcolor3228"><span>goto</span></span><span> fail;</span> 
<a id="x1-63678r261"></a><span>261</span><span>    }</span> 
<a id="x1-63680r262"></a><span>262</span> 
<a id="x1-63682r263"></a><span>263</span><span>    vinput-&gt;type = device;</span> 
<a id="x1-63684r264"></a><span>264</span><span>    err = device_register(&amp;vinput-&gt;dev);</span> 
<a id="x1-63686r265"></a><span>265</span><span>    </span><span id="textcolor3229"><span>if</span></span><span> (err &lt; 0)</span> 
<a id="x1-63688r266"></a><span>266</span><span>        </span><span id="textcolor3230"><span>goto</span></span><span> fail_register;</span> 
<a id="x1-63690r267"></a><span>267</span> 
<a id="x1-63692r268"></a><span>268</span><span>    err = vinput_register_vdevice(vinput);</span> 
<a id="x1-63694r269"></a><span>269</span><span>    </span><span id="textcolor3231"><span>if</span></span><span> (err &lt; 0)</span> 
<a id="x1-63696r270"></a><span>270</span><span>        </span><span id="textcolor3232"><span>goto</span></span><span> fail_register_vinput;</span> 
<a id="x1-63698r271"></a><span>271</span> 
<a id="x1-63700r272"></a><span>272</span><span>    </span><span id="textcolor3233"><span>return</span></span><span> len;</span> 
<a id="x1-63702r273"></a><span>273</span> 
<a id="x1-63704r274"></a><span>274</span><span>fail_register_vinput:</span> 
<a id="x1-63706r275"></a><span>275</span><span>    device_unregister(&amp;vinput-&gt;dev);</span> 
<a id="x1-63708r276"></a><span>276</span><span>fail_register:</span> 
<a id="x1-63710r277"></a><span>277</span><span>    vinput_destroy_vdevice(vinput);</span> 
<a id="x1-63712r278"></a><span>278</span><span>fail:</span> 
<a id="x1-63714r279"></a><span>279</span><span>    </span><span id="textcolor3234"><span>return</span></span><span> err;</span> 
<a id="x1-63716r280"></a><span>280</span><span>}</span> 
<a id="x1-63718r281"></a><span>281</span><span id="textcolor3235"><span>/* This macro generates class_attr_export structure and export_store() */</span></span> 
<a id="x1-63720r282"></a><span>282</span><span id="textcolor3236"><span>static</span></span><span> CLASS_ATTR_WO(export);</span> 
<a id="x1-63722r283"></a><span>283</span> 
<a id="x1-63724r284"></a><span>284</span><span id="textcolor3237"><span>static</span></span><span> </span><span id="textcolor3238"><span>ssize_t</span></span><span> unexport_store(</span><span id="textcolor3239"><span>struct</span></span><span> class *class, </span><span id="textcolor3240"><span>struct</span></span><span> class_attribute *attr,</span> 
<a id="x1-63726r285"></a><span>285</span><span>                              </span><span id="textcolor3241"><span>const</span></span><span> </span><span id="textcolor3242"><span>char</span></span><span> *buf, </span><span id="textcolor3243"><span>size_t</span></span><span> len)</span> 
<a id="x1-63728r286"></a><span>286</span><span>{</span> 
<a id="x1-63730r287"></a><span>287</span><span>    </span><span id="textcolor3244"><span>int</span></span><span> err;</span> 
<a id="x1-63732r288"></a><span>288</span><span>    </span><span id="textcolor3245"><span>unsigned</span></span><span> </span><span id="textcolor3246"><span>long</span></span><span> id;</span> 
<a id="x1-63734r289"></a><span>289</span><span>    </span><span id="textcolor3247"><span>struct</span></span><span> vinput *vinput;</span> 
<a id="x1-63736r290"></a><span>290</span> 
<a id="x1-63738r291"></a><span>291</span><span>    err = kstrtol(buf, 10, &amp;id);</span> 
<a id="x1-63740r292"></a><span>292</span><span>    </span><span id="textcolor3248"><span>if</span></span><span> (err) {</span> 
<a id="x1-63742r293"></a><span>293</span><span>        err = -EINVAL;</span> 
<a id="x1-63744r294"></a><span>294</span><span>        </span><span id="textcolor3249"><span>goto</span></span><span> failed;</span> 
<a id="x1-63746r295"></a><span>295</span><span>    }</span> 
<a id="x1-63748r296"></a><span>296</span> 
<a id="x1-63750r297"></a><span>297</span><span>    vinput = vinput_get_vdevice_by_id(id);</span> 
<a id="x1-63752r298"></a><span>298</span><span>    </span><span id="textcolor3250"><span>if</span></span><span> (IS_ERR(vinput)) {</span> 
<a id="x1-63754r299"></a><span>299</span><span>        pr_err(</span><span id="textcolor3251"><span>&#34;vinput: No such vinput device %ld</span></span><span id="textcolor3252"><span>\n</span></span><span id="textcolor3253"><span>&#34;</span></span><span>, id);</span> 
<a id="x1-63756r300"></a><span>300</span><span>        err = PTR_ERR(vinput);</span> 
<a id="x1-63758r301"></a><span>301</span><span>        </span><span id="textcolor3254"><span>goto</span></span><span> failed;</span> 
<a id="x1-63760r302"></a><span>302</span><span>    }</span> 
<a id="x1-63762r303"></a><span>303</span> 
<a id="x1-63764r304"></a><span>304</span><span>    vinput_unregister_vdevice(vinput);</span> 
<a id="x1-63766r305"></a><span>305</span><span>    device_unregister(&amp;vinput-&gt;dev);</span> 
<a id="x1-63768r306"></a><span>306</span> 
<a id="x1-63770r307"></a><span>307</span><span>    </span><span id="textcolor3255"><span>return</span></span><span> len;</span> 
<a id="x1-63772r308"></a><span>308</span><span>failed:</span> 
<a id="x1-63774r309"></a><span>309</span><span>    </span><span id="textcolor3256"><span>return</span></span><span> err;</span> 
<a id="x1-63776r310"></a><span>310</span><span>}</span> 
<a id="x1-63778r311"></a><span>311</span><span id="textcolor3257"><span>/* This macro generates class_attr_unexport structure and unexport_store() */</span></span> 
<a id="x1-63780r312"></a><span>312</span><span id="textcolor3258"><span>static</span></span><span> CLASS_ATTR_WO(unexport);</span> 
<a id="x1-63782r313"></a><span>313</span> 
<a id="x1-63784r314"></a><span>314</span><span id="textcolor3259"><span>static</span></span><span> </span><span id="textcolor3260"><span>struct</span></span><span> attribute *vinput_class_attrs[] = {</span> 
<a id="x1-63786r315"></a><span>315</span><span>    &amp;class_attr_export.attr,</span> 
<a id="x1-63788r316"></a><span>316</span><span>    &amp;class_attr_unexport.attr,</span> 
<a id="x1-63790r317"></a><span>317</span><span>    NULL,</span> 
<a id="x1-63792r318"></a><span>318</span><span>};</span> 
<a id="x1-63794r319"></a><span>319</span> 
<a id="x1-63796r320"></a><span>320</span><span id="textcolor3261"><span>/* This macro generates vinput_class_groups structure */</span></span> 
<a id="x1-63798r321"></a><span>321</span><span>ATTRIBUTE_GROUPS(vinput_class);</span> 
<a id="x1-63800r322"></a><span>322</span> 
<a id="x1-63802r323"></a><span>323</span><span id="textcolor3262"><span>static</span></span><span> </span><span id="textcolor3263"><span>struct</span></span><span> class vinput_class = {</span> 
<a id="x1-63804r324"></a><span>324</span><span>    .name = </span><span id="textcolor3264"><span>&#34;vinput&#34;</span></span><span>,</span> 
<a id="x1-63806r325"></a><span>325</span><span>    .owner = THIS_MODULE,</span> 
<a id="x1-63808r326"></a><span>326</span><span>    .class_groups = vinput_class_groups,</span> 
<a id="x1-63810r327"></a><span>327</span><span>};</span> 
<a id="x1-63812r328"></a><span>328</span> 
<a id="x1-63814r329"></a><span>329</span><span id="textcolor3265"><span>int</span></span><span> vinput_register(</span><span id="textcolor3266"><span>struct</span></span><span> vinput_device *dev)</span> 
<a id="x1-63816r330"></a><span>330</span><span>{</span> 
<a id="x1-63818r331"></a><span>331</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63820r332"></a><span>332</span><span>    list_add(&amp;dev-&gt;list, &amp;vinput_devices);</span> 
<a id="x1-63822r333"></a><span>333</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63824r334"></a><span>334</span> 
<a id="x1-63826r335"></a><span>335</span><span>    pr_info(</span><span id="textcolor3267"><span>&#34;vinput: registered new virtual input device </span><span>&#39;</span><span>%s</span><span>&#39;</span></span><span id="textcolor3268"><span>\n</span></span><span id="textcolor3269"><span>&#34;</span></span><span>, dev-&gt;name);</span> 
<a id="x1-63828r336"></a><span>336</span> 
<a id="x1-63830r337"></a><span>337</span><span>    </span><span id="textcolor3270"><span>return</span></span><span> 0;</span> 
<a id="x1-63832r338"></a><span>338</span><span>}</span> 
<a id="x1-63834r339"></a><span>339</span><span>EXPORT_SYMBOL(vinput_register);</span> 
<a id="x1-63836r340"></a><span>340</span> 
<a id="x1-63838r341"></a><span>341</span><span id="textcolor3271"><span>void</span></span><span> vinput_unregister(</span><span id="textcolor3272"><span>struct</span></span><span> vinput_device *dev)</span> 
<a id="x1-63840r342"></a><span>342</span><span>{</span> 
<a id="x1-63842r343"></a><span>343</span><span>    </span><span id="textcolor3273"><span>struct</span></span><span> list_head *curr, *next;</span> 
<a id="x1-63844r344"></a><span>344</span> 
<a id="x1-63846r345"></a><span>345</span><span>    </span><span id="textcolor3274"><span>/* Remove from the list first */</span></span> 
<a id="x1-63848r346"></a><span>346</span><span>    spin_lock(&amp;vinput_lock);</span> 
<a id="x1-63850r347"></a><span>347</span><span>    list_del(&amp;dev-&gt;list);</span> 
<a id="x1-63852r348"></a><span>348</span><span>    spin_unlock(&amp;vinput_lock);</span> 
<a id="x1-63854r349"></a><span>349</span> 
<a id="x1-63856r350"></a><span>350</span><span>    </span><span id="textcolor3275"><span>/* unregister all devices of this type */</span></span> 
<a id="x1-63858r351"></a><span>351</span><span>    list_for_each_safe (curr, next, &amp;vinput_vdevices) {</span> 
<a id="x1-63860r352"></a><span>352</span><span>        </span><span id="textcolor3276"><span>struct</span></span><span> vinput *vinput = list_entry(curr, </span><span id="textcolor3277"><span>struct</span></span><span> vinput, list);</span> 
<a id="x1-63862r353"></a><span>353</span><span>        </span><span id="textcolor3278"><span>if</span></span><span> (vinput &amp;&amp; vinput-&gt;type == dev) {</span> 
<a id="x1-63864r354"></a><span>354</span><span>            vinput_unregister_vdevice(vinput);</span> 
<a id="x1-63866r355"></a><span>355</span><span>            device_unregister(&amp;vinput-&gt;dev);</span> 
<a id="x1-63868r356"></a><span>356</span><span>        }</span> 
<a id="x1-63870r357"></a><span>357</span><span>    }</span> 
<a id="x1-63872r358"></a><span>358</span> 
<a id="x1-63874r359"></a><span>359</span><span>    pr_info(</span><span id="textcolor3279"><span>&#34;vinput: unregistered virtual input device </span><span>&#39;</span><span>%s</span><span>&#39;</span></span><span id="textcolor3280"><span>\n</span></span><span id="textcolor3281"><span>&#34;</span></span><span>, dev-&gt;name);</span> 
<a id="x1-63876r360"></a><span>360</span><span>}</span> 
<a id="x1-63878r361"></a><span>361</span><span>EXPORT_SYMBOL(vinput_unregister);</span> 
<a id="x1-63880r362"></a><span>362</span> 
<a id="x1-63882r363"></a><span>363</span><span id="textcolor3282"><span>static</span></span><span> </span><span id="textcolor3283"><span>int</span></span><span> __init vinput_init(</span><span id="textcolor3284"><span>void</span></span><span>)</span> 
<a id="x1-63884r364"></a><span>364</span><span>{</span> 
<a id="x1-63886r365"></a><span>365</span><span>    </span><span id="textcolor3285"><span>int</span></span><span> err = 0;</span> 
<a id="x1-63888r366"></a><span>366</span> 
<a id="x1-63890r367"></a><span>367</span><span>    pr_info(</span><span id="textcolor3286"><span>&#34;vinput: Loading virtual input driver</span></span><span id="textcolor3287"><span>\n</span></span><span id="textcolor3288"><span>&#34;</span></span><span>);</span> 
<a id="x1-63892r368"></a><span>368</span> 
<a id="x1-63894r369"></a><span>369</span><span>    vinput_dev = register_chrdev(0, DRIVER_NAME, &amp;vinput_fops);</span> 
<a id="x1-63896r370"></a><span>370</span><span>    </span><span id="textcolor3289"><span>if</span></span><span> (vinput_dev &lt; 0) {</span> 
<a id="x1-63898r371"></a><span>371</span><span>        pr_err(</span><span id="textcolor3290"><span>&#34;vinput: Unable to allocate char dev region</span></span><span id="textcolor3291"><span>\n</span></span><span id="textcolor3292"><span>&#34;</span></span><span>);</span> 
<a id="x1-63900r372"></a><span>372</span><span>        err = vinput_dev;</span> 
<a id="x1-63902r373"></a><span>373</span><span>        </span><span id="textcolor3293"><span>goto</span></span><span> failed_alloc;</span> 
<a id="x1-63904r374"></a><span>374</span><span>    }</span> 
<a id="x1-63906r375"></a><span>375</span> 
<a id="x1-63908r376"></a><span>376</span><span>    spin_lock_init(&amp;vinput_lock);</span> 
<a id="x1-63910r377"></a><span>377</span> 
<a id="x1-63912r378"></a><span>378</span><span>    err = class_register(&amp;vinput_class);</span> 
<a id="x1-63914r379"></a><span>379</span><span>    </span><span id="textcolor3294"><span>if</span></span><span> (err &lt; 0) {</span> 
<a id="x1-63916r380"></a><span>380</span><span>        pr_err(</span><span id="textcolor3295"><span>&#34;vinput: Unable to register vinput class</span></span><span id="textcolor3296"><span>\n</span></span><span id="textcolor3297"><span>&#34;</span></span><span>);</span> 
<a id="x1-63918r381"></a><span>381</span><span>        </span><span id="textcolor3298"><span>goto</span></span><span> failed_class;</span> 
<a id="x1-63920r382"></a><span>382</span><span>    }</span> 
<a id="x1-63922r383"></a><span>383</span> 
<a id="x1-63924r384"></a><span>384</span><span>    </span><span id="textcolor3299"><span>return</span></span><span> 0;</span> 
<a id="x1-63926r385"></a><span>385</span><span>failed_class:</span> 
<a id="x1-63928r386"></a><span>386</span><span>    class_unregister(&amp;vinput_class);</span> 
<a id="x1-63930r387"></a><span>387</span><span>failed_alloc:</span> 
<a id="x1-63932r388"></a><span>388</span><span>    </span><span id="textcolor3300"><span>return</span></span><span> err;</span> 
<a id="x1-63934r389"></a><span>389</span><span>}</span> 
<a id="x1-63936r390"></a><span>390</span> 
<a id="x1-63938r391"></a><span>391</span><span id="textcolor3301"><span>static</span></span><span> </span><span id="textcolor3302"><span>void</span></span><span> __exit vinput_end(</span><span id="textcolor3303"><span>void</span></span><span>)</span> 
<a id="x1-63940r392"></a><span>392</span><span>{</span> 
<a id="x1-63942r393"></a><span>393</span><span>    pr_info(</span><span id="textcolor3304"><span>&#34;vinput: Unloading virtual input driver</span></span><span id="textcolor3305"><span>\n</span></span><span id="textcolor3306"><span>&#34;</span></span><span>);</span> 
<a id="x1-63944r394"></a><span>394</span> 
<a id="x1-63946r395"></a><span>395</span><span>    unregister_chrdev(vinput_dev, DRIVER_NAME);</span> 
<a id="x1-63948r396"></a><span>396</span><span>    class_unregister(&amp;vinput_class);</span> 
<a id="x1-63950r397"></a><span>397</span><span>}</span> 
<a id="x1-63952r398"></a><span>398</span> 
<a id="x1-63954r399"></a><span>399</span><span>module_init(vinput_init);</span> 
<a id="x1-63956r400"></a><span>400</span><span>module_exit(vinput_end);</span> 
<a id="x1-63958r401"></a><span>401</span> 
<a id="x1-63960r402"></a><span>402</span><span>MODULE_LICENSE(</span><span id="textcolor3307"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-63962r403"></a><span>403</span><span>MODULE_DESCRIPTION(</span><span id="textcolor3308"><span>&#34;Emulate input events&#34;</span></span><span>);</span></pre>
<!-- l. 1994 --><p>   Here the virtual keyboard is one of example to use vinput. It supports all
<code> <span>KEY_MAX</span>
</code> keycodes. The injection format is the <code>  <span>KEY_CODE</span>
</code> such as defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/input.h">include/linux/input.h</a>. A positive value means
<code> <span>KEY_PRESS</span>
</code> while a negative value is a <code>  <span>KEY_RELEASE</span>
</code>. The keyboard supports repetition when the key stays pressed for too long. The
following demonstrates how simulation work.
</p><!-- l. 2001 --><p>   Simulate a key press on &#34;g&#34; (<code>  <span>KEY_G</span>
</code> = 34):
</p><!-- l. 1 -->
   <pre id="fancyvrb94"><a id="x1-63970r1"></a><span>1</span><span>echo </span><span id="textcolor3309"><span>&#34;+34&#34;</span></span><span> | sudo tee /dev/vinput0</span></pre>
<!-- l. 2007 --><p>   Simulate a key release on &#34;g&#34; (<code>  <span>KEY_G</span>
</code> = 34):
</p><!-- l. 1 -->
   <pre id="fancyvrb95"><a id="x1-63974r1"></a><span>1</span><span>echo </span><span id="textcolor3310"><span>&#34;-34&#34;</span></span><span> | sudo tee /dev/vinput0</span></pre>

<!-- l. 1 -->
   <pre id="fancyvrb96"><a id="x1-63976r1"></a><span>1</span><span id="textcolor3311"><span>/*</span></span> 
<a id="x1-63978r2"></a><span>2</span><span id="textcolor3312"><span> * vkbd.c</span></span> 
<a id="x1-63980r3"></a><span>3</span><span id="textcolor3313"><span> */</span></span> 
<a id="x1-63982r4"></a><span>4</span> 
<a id="x1-63984r5"></a><span>5</span><span id="textcolor3314"><span>#include</span></span><span> </span><span id="textcolor3315"><span>&lt;linux/init.h&gt;</span></span> 
<a id="x1-63986r6"></a><span>6</span><span id="textcolor3316"><span>#include</span></span><span> </span><span id="textcolor3317"><span>&lt;linux/input.h&gt;</span></span> 
<a id="x1-63988r7"></a><span>7</span><span id="textcolor3318"><span>#include</span></span><span> </span><span id="textcolor3319"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-63990r8"></a><span>8</span><span id="textcolor3320"><span>#include</span></span><span> </span><span id="textcolor3321"><span>&lt;linux/spinlock.h&gt;</span></span> 
<a id="x1-63992r9"></a><span>9</span> 
<a id="x1-63994r10"></a><span>10</span><span id="textcolor3322"><span>#include</span></span><span> </span><span id="textcolor3323"><span>&#34;vinput.h&#34;</span></span> 
<a id="x1-63996r11"></a><span>11</span> 
<a id="x1-63998r12"></a><span>12</span><span id="textcolor3324"><span>#define VINPUT_KBD &#34;vkbd&#34;</span></span> 
<a id="x1-64000r13"></a><span>13</span><span id="textcolor3325"><span>#define VINPUT_RELEASE 0</span></span> 
<a id="x1-64002r14"></a><span>14</span><span id="textcolor3326"><span>#define VINPUT_PRESS 1</span></span> 
<a id="x1-64004r15"></a><span>15</span> 
<a id="x1-64006r16"></a><span>16</span><span id="textcolor3327"><span>static</span></span><span> </span><span id="textcolor3328"><span>unsigned</span></span><span> </span><span id="textcolor3329"><span>short</span></span><span> vkeymap[KEY_MAX];</span> 
<a id="x1-64008r17"></a><span>17</span> 
<a id="x1-64010r18"></a><span>18</span><span id="textcolor3330"><span>static</span></span><span> </span><span id="textcolor3331"><span>int</span></span><span> vinput_vkbd_init(</span><span id="textcolor3332"><span>struct</span></span><span> vinput *vinput)</span> 
<a id="x1-64012r19"></a><span>19</span><span>{</span> 
<a id="x1-64014r20"></a><span>20</span><span>    </span><span id="textcolor3333"><span>int</span></span><span> i;</span> 
<a id="x1-64016r21"></a><span>21</span> 
<a id="x1-64018r22"></a><span>22</span><span>    </span><span id="textcolor3334"><span>/* Set up the input bitfield */</span></span> 
<a id="x1-64020r23"></a><span>23</span><span>    vinput-&gt;input-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span> 
<a id="x1-64022r24"></a><span>24</span><span>    vinput-&gt;input-&gt;keycodesize = </span><span id="textcolor3335"><span>sizeof</span></span><span>(</span><span id="textcolor3336"><span>unsigned</span></span><span> </span><span id="textcolor3337"><span>short</span></span><span>);</span> 
<a id="x1-64024r25"></a><span>25</span><span>    vinput-&gt;input-&gt;keycodemax = KEY_MAX;</span> 
<a id="x1-64026r26"></a><span>26</span><span>    vinput-&gt;input-&gt;keycode = vkeymap;</span> 
<a id="x1-64028r27"></a><span>27</span> 
<a id="x1-64030r28"></a><span>28</span><span>    </span><span id="textcolor3338"><span>for</span></span><span> (i = 0; i &lt; KEY_MAX; i++)</span> 
<a id="x1-64032r29"></a><span>29</span><span>        set_bit(vkeymap[i], vinput-&gt;input-&gt;keybit);</span> 
<a id="x1-64034r30"></a><span>30</span> 
<a id="x1-64036r31"></a><span>31</span><span>    </span><span id="textcolor3339"><span>/* vinput will help us allocate new input device structure via</span></span> 
<a id="x1-64038r32"></a><span>32</span><span id="textcolor3340"><span>     * input_allocate_device(). So, we can register it straightforwardly.</span></span> 
<a id="x1-64040r33"></a><span>33</span><span id="textcolor3341"><span>     */</span></span> 
<a id="x1-64042r34"></a><span>34</span><span>    </span><span id="textcolor3342"><span>return</span></span><span> input_register_device(vinput-&gt;input);</span> 
<a id="x1-64044r35"></a><span>35</span><span>}</span> 
<a id="x1-64046r36"></a><span>36</span> 
<a id="x1-64048r37"></a><span>37</span><span id="textcolor3343"><span>static</span></span><span> </span><span id="textcolor3344"><span>int</span></span><span> vinput_vkbd_read(</span><span id="textcolor3345"><span>struct</span></span><span> vinput *vinput, </span><span id="textcolor3346"><span>char</span></span><span> *buff, </span><span id="textcolor3347"><span>int</span></span><span> len)</span> 
<a id="x1-64050r38"></a><span>38</span><span>{</span> 
<a id="x1-64052r39"></a><span>39</span><span>    spin_lock(&amp;vinput-&gt;lock);</span> 
<a id="x1-64054r40"></a><span>40</span><span>    len = snprintf(buff, len, </span><span id="textcolor3348"><span>&#34;%+ld</span></span><span id="textcolor3349"><span>\n</span></span><span id="textcolor3350"><span>&#34;</span></span><span>, vinput-&gt;last_entry);</span> 
<a id="x1-64056r41"></a><span>41</span><span>    spin_unlock(&amp;vinput-&gt;lock);</span> 
<a id="x1-64058r42"></a><span>42</span> 
<a id="x1-64060r43"></a><span>43</span><span>    </span><span id="textcolor3351"><span>return</span></span><span> len;</span> 
<a id="x1-64062r44"></a><span>44</span><span>}</span> 
<a id="x1-64064r45"></a><span>45</span> 
<a id="x1-64066r46"></a><span>46</span><span id="textcolor3352"><span>static</span></span><span> </span><span id="textcolor3353"><span>int</span></span><span> vinput_vkbd_send(</span><span id="textcolor3354"><span>struct</span></span><span> vinput *vinput, </span><span id="textcolor3355"><span>char</span></span><span> *buff, </span><span id="textcolor3356"><span>int</span></span><span> len)</span> 
<a id="x1-64068r47"></a><span>47</span><span>{</span> 
<a id="x1-64070r48"></a><span>48</span><span>    </span><span id="textcolor3357"><span>int</span></span><span> ret;</span> 
<a id="x1-64072r49"></a><span>49</span><span>    </span><span id="textcolor3358"><span>long</span></span><span> key = 0;</span> 
<a id="x1-64074r50"></a><span>50</span><span>    </span><span id="textcolor3359"><span>short</span></span><span> type = VINPUT_PRESS;</span> 
<a id="x1-64076r51"></a><span>51</span> 
<a id="x1-64078r52"></a><span>52</span><span>    </span><span id="textcolor3360"><span>/* Determine which event was received (press or release)</span></span> 
<a id="x1-64080r53"></a><span>53</span><span id="textcolor3361"><span>     * and store the state.</span></span> 
<a id="x1-64082r54"></a><span>54</span><span id="textcolor3362"><span>     */</span></span> 
<a id="x1-64084r55"></a><span>55</span><span>    </span><span id="textcolor3363"><span>if</span></span><span> (buff[0] == </span><span id="textcolor3364"><span>&#39;</span><span>+</span><span>&#39;</span></span><span>)</span> 
<a id="x1-64086r56"></a><span>56</span><span>        ret = kstrtol(buff + 1, 10, &amp;key);</span> 
<a id="x1-64088r57"></a><span>57</span><span>    </span><span id="textcolor3365"><span>else</span></span> 
<a id="x1-64090r58"></a><span>58</span><span>        ret = kstrtol(buff, 10, &amp;key);</span> 
<a id="x1-64092r59"></a><span>59</span><span>    </span><span id="textcolor3366"><span>if</span></span><span> (ret)</span> 
<a id="x1-64094r60"></a><span>60</span><span>        dev_err(&amp;vinput-&gt;dev, </span><span id="textcolor3367"><span>&#34;error during kstrtol: -%d</span></span><span id="textcolor3368"><span>\n</span></span><span id="textcolor3369"><span>&#34;</span></span><span>, ret);</span> 
<a id="x1-64096r61"></a><span>61</span><span>    spin_lock(&amp;vinput-&gt;lock);</span> 
<a id="x1-64098r62"></a><span>62</span><span>    vinput-&gt;last_entry = key;</span> 
<a id="x1-64100r63"></a><span>63</span><span>    spin_unlock(&amp;vinput-&gt;lock);</span> 
<a id="x1-64102r64"></a><span>64</span> 
<a id="x1-64104r65"></a><span>65</span><span>    </span><span id="textcolor3370"><span>if</span></span><span> (key &lt; 0) {</span> 
<a id="x1-64106r66"></a><span>66</span><span>        type = VINPUT_RELEASE;</span> 
<a id="x1-64108r67"></a><span>67</span><span>        key = -key;</span> 
<a id="x1-64110r68"></a><span>68</span><span>    }</span> 
<a id="x1-64112r69"></a><span>69</span> 
<a id="x1-64114r70"></a><span>70</span><span>    dev_info(&amp;vinput-&gt;dev, </span><span id="textcolor3371"><span>&#34;Event %s code %ld</span></span><span id="textcolor3372"><span>\n</span></span><span id="textcolor3373"><span>&#34;</span></span><span>,</span> 
<a id="x1-64116r71"></a><span>71</span><span>             (type == VINPUT_RELEASE) ? </span><span id="textcolor3374"><span>&#34;VINPUT_RELEASE&#34;</span></span><span> : </span><span id="textcolor3375"><span>&#34;VINPUT_PRESS&#34;</span></span><span>, key);</span> 
<a id="x1-64118r72"></a><span>72</span> 
<a id="x1-64120r73"></a><span>73</span><span>    </span><span id="textcolor3376"><span>/* Report the state received to input subsystem. */</span></span> 
<a id="x1-64122r74"></a><span>74</span><span>    input_report_key(vinput-&gt;input, key, type);</span> 
<a id="x1-64124r75"></a><span>75</span><span>    </span><span id="textcolor3377"><span>/* Tell input subsystem that it finished the report. */</span></span> 
<a id="x1-64126r76"></a><span>76</span><span>    input_sync(vinput-&gt;input);</span> 
<a id="x1-64128r77"></a><span>77</span> 
<a id="x1-64130r78"></a><span>78</span><span>    </span><span id="textcolor3378"><span>return</span></span><span> len;</span> 
<a id="x1-64132r79"></a><span>79</span><span>}</span> 
<a id="x1-64134r80"></a><span>80</span> 
<a id="x1-64136r81"></a><span>81</span><span id="textcolor3379"><span>static</span></span><span> </span><span id="textcolor3380"><span>struct</span></span><span> vinput_ops vkbd_ops = {</span> 
<a id="x1-64138r82"></a><span>82</span><span>    .init = vinput_vkbd_init,</span> 
<a id="x1-64140r83"></a><span>83</span><span>    .send = vinput_vkbd_send,</span> 
<a id="x1-64142r84"></a><span>84</span><span>    .read = vinput_vkbd_read,</span> 
<a id="x1-64144r85"></a><span>85</span><span>};</span> 
<a id="x1-64146r86"></a><span>86</span> 
<a id="x1-64148r87"></a><span>87</span><span id="textcolor3381"><span>static</span></span><span> </span><span id="textcolor3382"><span>struct</span></span><span> vinput_device vkbd_dev = {</span> 
<a id="x1-64150r88"></a><span>88</span><span>    .name = VINPUT_KBD,</span> 
<a id="x1-64152r89"></a><span>89</span><span>    .ops = &amp;vkbd_ops,</span> 
<a id="x1-64154r90"></a><span>90</span><span>};</span> 
<a id="x1-64156r91"></a><span>91</span> 
<a id="x1-64158r92"></a><span>92</span><span id="textcolor3383"><span>static</span></span><span> </span><span id="textcolor3384"><span>int</span></span><span> __init vkbd_init(</span><span id="textcolor3385"><span>void</span></span><span>)</span> 
<a id="x1-64160r93"></a><span>93</span><span>{</span> 
<a id="x1-64162r94"></a><span>94</span><span>    </span><span id="textcolor3386"><span>int</span></span><span> i;</span> 
<a id="x1-64164r95"></a><span>95</span> 
<a id="x1-64166r96"></a><span>96</span><span>    </span><span id="textcolor3387"><span>for</span></span><span> (i = 0; i &lt; KEY_MAX; i++)</span> 
<a id="x1-64168r97"></a><span>97</span><span>        vkeymap[i] = i;</span> 
<a id="x1-64170r98"></a><span>98</span><span>    </span><span id="textcolor3388"><span>return</span></span><span> vinput_register(&amp;vkbd_dev);</span> 
<a id="x1-64172r99"></a><span>99</span><span>}</span> 
<a id="x1-64174r100"></a><span>100</span> 
<a id="x1-64176r101"></a><span>101</span><span id="textcolor3389"><span>static</span></span><span> </span><span id="textcolor3390"><span>void</span></span><span> __exit vkbd_end(</span><span id="textcolor3391"><span>void</span></span><span>)</span> 
<a id="x1-64178r102"></a><span>102</span><span>{</span> 
<a id="x1-64180r103"></a><span>103</span><span>    vinput_unregister(&amp;vkbd_dev);</span> 
<a id="x1-64182r104"></a><span>104</span><span>}</span> 
<a id="x1-64184r105"></a><span>105</span> 
<a id="x1-64186r106"></a><span>106</span><span>module_init(vkbd_init);</span> 
<a id="x1-64188r107"></a><span>107</span><span>module_exit(vkbd_end);</span> 
<a id="x1-64190r108"></a><span>108</span> 
<a id="x1-64192r109"></a><span>109</span><span>MODULE_LICENSE(</span><span id="textcolor3392"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-64194r110"></a><span>110</span><span>MODULE_DESCRIPTION(</span><span id="textcolor3393"><span>&#34;Emulate keyboard input events through /dev/vinput&#34;</span></span><span>);</span></pre>
                                                                  

                                                                  
<!-- l. 2017 -->
   <h3 id="standardizing-the-interfaces-the-device-model"><span>18   </span> <a id="x1-6500018"></a>Standardizing the interfaces: The Device Model</h3>
<!-- l. 2019 --><p>Up to this point we have seen all kinds of modules doing all kinds of things, but there
was no consistency in their interfaces with the rest of the kernel. To impose some
consistency such that there is at minimum a standardized way to start, suspend and
resume a device a device model was added. An example is shown below, and you can
use this as a template to add your own suspend, resume or other interface
functions.
</p><!-- l. 1 -->
   <pre id="fancyvrb97"><a id="x1-65002r1"></a><span>1</span><span id="textcolor3394"><span>/*</span></span> 
<a id="x1-65004r2"></a><span>2</span><span id="textcolor3395"><span> * devicemodel.c</span></span> 
<a id="x1-65006r3"></a><span>3</span><span id="textcolor3396"><span> */</span></span> 
<a id="x1-65008r4"></a><span>4</span><span id="textcolor3397"><span>#include</span></span><span> </span><span id="textcolor3398"><span>&lt;linux/kernel.h&gt;</span></span> 
<a id="x1-65010r5"></a><span>5</span><span id="textcolor3399"><span>#include</span></span><span> </span><span id="textcolor3400"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-65012r6"></a><span>6</span><span id="textcolor3401"><span>#include</span></span><span> </span><span id="textcolor3402"><span>&lt;linux/platform_device.h&gt;</span></span> 
<a id="x1-65014r7"></a><span>7</span> 
<a id="x1-65016r8"></a><span>8</span><span id="textcolor3403"><span>struct</span></span><span> devicemodel_data {</span> 
<a id="x1-65018r9"></a><span>9</span><span>    </span><span id="textcolor3404"><span>char</span></span><span> *greeting;</span> 
<a id="x1-65020r10"></a><span>10</span><span>    </span><span id="textcolor3405"><span>int</span></span><span> number;</span> 
<a id="x1-65022r11"></a><span>11</span><span>};</span> 
<a id="x1-65024r12"></a><span>12</span> 
<a id="x1-65026r13"></a><span>13</span><span id="textcolor3406"><span>static</span></span><span> </span><span id="textcolor3407"><span>int</span></span><span> devicemodel_probe(</span><span id="textcolor3408"><span>struct</span></span><span> platform_device *dev)</span> 
<a id="x1-65028r14"></a><span>14</span><span>{</span> 
<a id="x1-65030r15"></a><span>15</span><span>    </span><span id="textcolor3409"><span>struct</span></span><span> devicemodel_data *pd =</span> 
<a id="x1-65032r16"></a><span>16</span><span>        (</span><span id="textcolor3410"><span>struct</span></span><span> devicemodel_data *)(dev-&gt;dev.platform_data);</span> 
<a id="x1-65034r17"></a><span>17</span> 
<a id="x1-65036r18"></a><span>18</span><span>    pr_info(</span><span id="textcolor3411"><span>&#34;devicemodel probe</span></span><span id="textcolor3412"><span>\n</span></span><span id="textcolor3413"><span>&#34;</span></span><span>);</span> 
<a id="x1-65038r19"></a><span>19</span><span>    pr_info(</span><span id="textcolor3414"><span>&#34;devicemodel greeting: %s; %d</span></span><span id="textcolor3415"><span>\n</span></span><span id="textcolor3416"><span>&#34;</span></span><span>, pd-&gt;greeting, pd-&gt;number);</span> 
<a id="x1-65040r20"></a><span>20</span> 
<a id="x1-65042r21"></a><span>21</span><span>    </span><span id="textcolor3417"><span>/* Your device initialization code */</span></span> 
<a id="x1-65044r22"></a><span>22</span> 
<a id="x1-65046r23"></a><span>23</span><span>    </span><span id="textcolor3418"><span>return</span></span><span> 0;</span> 
<a id="x1-65048r24"></a><span>24</span><span>}</span> 
<a id="x1-65050r25"></a><span>25</span> 
<a id="x1-65052r26"></a><span>26</span><span id="textcolor3419"><span>static</span></span><span> </span><span id="textcolor3420"><span>int</span></span><span> devicemodel_remove(</span><span id="textcolor3421"><span>struct</span></span><span> platform_device *dev)</span> 
<a id="x1-65054r27"></a><span>27</span><span>{</span> 
<a id="x1-65056r28"></a><span>28</span><span>    pr_info(</span><span id="textcolor3422"><span>&#34;devicemodel example removed</span></span><span id="textcolor3423"><span>\n</span></span><span id="textcolor3424"><span>&#34;</span></span><span>);</span> 
<a id="x1-65058r29"></a><span>29</span> 
<a id="x1-65060r30"></a><span>30</span><span>    </span><span id="textcolor3425"><span>/* Your device removal code */</span></span> 
<a id="x1-65062r31"></a><span>31</span> 
<a id="x1-65064r32"></a><span>32</span><span>    </span><span id="textcolor3426"><span>return</span></span><span> 0;</span> 
<a id="x1-65066r33"></a><span>33</span><span>}</span> 
<a id="x1-65068r34"></a><span>34</span> 
<a id="x1-65070r35"></a><span>35</span><span id="textcolor3427"><span>static</span></span><span> </span><span id="textcolor3428"><span>int</span></span><span> devicemodel_suspend(</span><span id="textcolor3429"><span>struct</span></span><span> device *dev)</span> 
<a id="x1-65072r36"></a><span>36</span><span>{</span> 
<a id="x1-65074r37"></a><span>37</span><span>    pr_info(</span><span id="textcolor3430"><span>&#34;devicemodel example suspend</span></span><span id="textcolor3431"><span>\n</span></span><span id="textcolor3432"><span>&#34;</span></span><span>);</span> 
<a id="x1-65076r38"></a><span>38</span> 
<a id="x1-65078r39"></a><span>39</span><span>    </span><span id="textcolor3433"><span>/* Your device suspend code */</span></span> 
<a id="x1-65080r40"></a><span>40</span> 
<a id="x1-65082r41"></a><span>41</span><span>    </span><span id="textcolor3434"><span>return</span></span><span> 0;</span> 
<a id="x1-65084r42"></a><span>42</span><span>}</span> 
<a id="x1-65086r43"></a><span>43</span> 
<a id="x1-65088r44"></a><span>44</span><span id="textcolor3435"><span>static</span></span><span> </span><span id="textcolor3436"><span>int</span></span><span> devicemodel_resume(</span><span id="textcolor3437"><span>struct</span></span><span> device *dev)</span> 
<a id="x1-65090r45"></a><span>45</span><span>{</span> 
<a id="x1-65092r46"></a><span>46</span><span>    pr_info(</span><span id="textcolor3438"><span>&#34;devicemodel example resume</span></span><span id="textcolor3439"><span>\n</span></span><span id="textcolor3440"><span>&#34;</span></span><span>);</span> 
<a id="x1-65094r47"></a><span>47</span> 
<a id="x1-65096r48"></a><span>48</span><span>    </span><span id="textcolor3441"><span>/* Your device resume code */</span></span> 
<a id="x1-65098r49"></a><span>49</span> 
<a id="x1-65100r50"></a><span>50</span><span>    </span><span id="textcolor3442"><span>return</span></span><span> 0;</span> 
<a id="x1-65102r51"></a><span>51</span><span>}</span> 
<a id="x1-65104r52"></a><span>52</span> 
<a id="x1-65106r53"></a><span>53</span><span id="textcolor3443"><span>static</span></span><span> </span><span id="textcolor3444"><span>const</span></span><span> </span><span id="textcolor3445"><span>struct</span></span><span> dev_pm_ops devicemodel_pm_ops = {</span> 
<a id="x1-65108r54"></a><span>54</span><span>    .suspend = devicemodel_suspend,</span> 
<a id="x1-65110r55"></a><span>55</span><span>    .resume = devicemodel_resume,</span> 
<a id="x1-65112r56"></a><span>56</span><span>    .poweroff = devicemodel_suspend,</span> 
<a id="x1-65114r57"></a><span>57</span><span>    .freeze = devicemodel_suspend,</span> 
<a id="x1-65116r58"></a><span>58</span><span>    .thaw = devicemodel_resume,</span> 
<a id="x1-65118r59"></a><span>59</span><span>    .restore = devicemodel_resume,</span> 
<a id="x1-65120r60"></a><span>60</span><span>};</span> 
<a id="x1-65122r61"></a><span>61</span> 
<a id="x1-65124r62"></a><span>62</span><span id="textcolor3446"><span>static</span></span><span> </span><span id="textcolor3447"><span>struct</span></span><span> platform_driver devicemodel_driver = {</span> 
<a id="x1-65126r63"></a><span>63</span><span>    .driver =</span> 
<a id="x1-65128r64"></a><span>64</span><span>        {</span> 
<a id="x1-65130r65"></a><span>65</span><span>            .name = </span><span id="textcolor3448"><span>&#34;devicemodel_example&#34;</span></span><span>,</span> 
<a id="x1-65132r66"></a><span>66</span><span>            .pm = &amp;devicemodel_pm_ops,</span> 
<a id="x1-65134r67"></a><span>67</span><span>        },</span> 
<a id="x1-65136r68"></a><span>68</span><span>    .probe = devicemodel_probe,</span> 
<a id="x1-65138r69"></a><span>69</span><span>    .remove = devicemodel_remove,</span> 
<a id="x1-65140r70"></a><span>70</span><span>};</span> 
<a id="x1-65142r71"></a><span>71</span> 
<a id="x1-65144r72"></a><span>72</span><span id="textcolor3449"><span>static</span></span><span> </span><span id="textcolor3450"><span>int</span></span><span> devicemodel_init(</span><span id="textcolor3451"><span>void</span></span><span>)</span> 
<a id="x1-65146r73"></a><span>73</span><span>{</span> 
<a id="x1-65148r74"></a><span>74</span><span>    </span><span id="textcolor3452"><span>int</span></span><span> ret;</span> 
<a id="x1-65150r75"></a><span>75</span> 
<a id="x1-65152r76"></a><span>76</span><span>    pr_info(</span><span id="textcolor3453"><span>&#34;devicemodel init</span></span><span id="textcolor3454"><span>\n</span></span><span id="textcolor3455"><span>&#34;</span></span><span>);</span> 
<a id="x1-65154r77"></a><span>77</span> 
<a id="x1-65156r78"></a><span>78</span><span>    ret = platform_driver_register(&amp;devicemodel_driver);</span> 
<a id="x1-65158r79"></a><span>79</span> 
<a id="x1-65160r80"></a><span>80</span><span>    </span><span id="textcolor3456"><span>if</span></span><span> (ret) {</span> 
<a id="x1-65162r81"></a><span>81</span><span>        pr_err(</span><span id="textcolor3457"><span>&#34;Unable to register driver</span></span><span id="textcolor3458"><span>\n</span></span><span id="textcolor3459"><span>&#34;</span></span><span>);</span> 
<a id="x1-65164r82"></a><span>82</span><span>        </span><span id="textcolor3460"><span>return</span></span><span> ret;</span> 
<a id="x1-65166r83"></a><span>83</span><span>    }</span> 
<a id="x1-65168r84"></a><span>84</span> 
<a id="x1-65170r85"></a><span>85</span><span>    </span><span id="textcolor3461"><span>return</span></span><span> 0;</span> 
<a id="x1-65172r86"></a><span>86</span><span>}</span> 
<a id="x1-65174r87"></a><span>87</span> 
<a id="x1-65176r88"></a><span>88</span><span id="textcolor3462"><span>static</span></span><span> </span><span id="textcolor3463"><span>void</span></span><span> devicemodel_exit(</span><span id="textcolor3464"><span>void</span></span><span>)</span> 
<a id="x1-65178r89"></a><span>89</span><span>{</span> 
<a id="x1-65180r90"></a><span>90</span><span>    pr_info(</span><span id="textcolor3465"><span>&#34;devicemodel exit</span></span><span id="textcolor3466"><span>\n</span></span><span id="textcolor3467"><span>&#34;</span></span><span>);</span> 
<a id="x1-65182r91"></a><span>91</span><span>    platform_driver_unregister(&amp;devicemodel_driver);</span> 
<a id="x1-65184r92"></a><span>92</span><span>}</span> 
<a id="x1-65186r93"></a><span>93</span> 
<a id="x1-65188r94"></a><span>94</span><span>module_init(devicemodel_init);</span> 
<a id="x1-65190r95"></a><span>95</span><span>module_exit(devicemodel_exit);</span> 
<a id="x1-65192r96"></a><span>96</span> 
<a id="x1-65194r97"></a><span>97</span><span>MODULE_LICENSE(</span><span id="textcolor3468"><span>&#34;GPL&#34;</span></span><span>);</span> 
<a id="x1-65196r98"></a><span>98</span><span>MODULE_DESCRIPTION(</span><span id="textcolor3469"><span>&#34;Linux Device Model example&#34;</span></span><span>);</span></pre>
<!-- l. 2025 -->
   <h3 id="optimizations"><span>19   </span> <a id="x1-6600019"></a>Optimizations</h3>
<!-- l. 2027 -->
   <h4 id="likely-and-unlikely-conditions"><span>19.1   </span> <a id="x1-6700019.1"></a>Likely and Unlikely conditions</h4>
<!-- l. 2029 --><p>Sometimes you might want your code to run as quickly as possible,
especially if it is handling an interrupt or doing something which might
cause noticeable latency. If your code contains boolean conditions and if
you know that the conditions are almost always likely to evaluate as either
<code> <span>true</span>
</code> or <code>  <span>false</span>
</code>, then you can allow the compiler to optimize for this using the
<code> <span>likely</span>
</code> and <code>  <span>unlikely</span>
</code> macros. For example, when allocating memory you are almost always expecting this
to succeed.
</p><!-- l. 1 -->
   <pre id="fancyvrb98"><a id="x1-67012r1"></a><span>1</span><span>bvl = bvec_alloc(gfp_mask, nr_iovecs, &amp;idx);</span> 
<a id="x1-67014r2"></a><span>2</span><span id="textcolor3470"><span>if</span></span><span> (unlikely(!bvl)) {</span> 
<a id="x1-67016r3"></a><span>3</span><span>    mempool_free(bio, bio_pool);</span> 
<a id="x1-67018r4"></a><span>4</span><span>    bio = NULL;</span> 
<a id="x1-67020r5"></a><span>5</span><span>    </span><span id="textcolor3471"><span>goto</span></span><span> out;</span> 
<a id="x1-67022r6"></a><span>6</span><span>}</span></pre>
<!-- l. 2043 --><p>   When the <code>  <span>unlikely</span>
</code> macro is used, the compiler alters its machine instruction output, so that it
continues along the false branch and only jumps if the condition is true. That
avoids flushing the processor pipeline. The opposite happens if you use the
<code> <span>likely</span>
</code> macro.
                                                                  

                                                                  
</p><!-- l. 2047 -->
   <h4 id="static-keys"><span>19.2   </span> <a id="x1-6800019.2"></a>Static keys</h4>
<!-- l. 2049 --><p>Static keys allow us to enable or disable kernel code paths based on the runtime state
of key. Its APIs have been available since 2010 (most architectures are already
supported), use self-modifying code to eliminate the overhead of cache and branch
prediction. The most typical use case of static keys is for performance-sensitive kernel
code, such as tracepoints, context switching, networking, etc. These hot paths of the
kernel often contain branches and can be optimized easily using this technique.
Before we can use static keys in the kernel, we need to make sure that gcc supports
<code> <span id="textcolor3472"><span>asm</span></span><span> </span><span id="textcolor3473"><span>goto</span></span>
</code> inline assembly, and the following kernel configurations are set:
</p><!-- l. 1 -->
   <pre id="fancyvrb99"><a id="x1-68006r1"></a><span>1</span><span>CONFIG_JUMP_LABEL=y</span> 
<a id="x1-68008r2"></a><span>2</span><span>CONFIG_HAVE_ARCH_JUMP_LABEL=y</span> 
<a id="x1-68010r3"></a><span>3</span><span>CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y</span></pre>
<!-- l. 2059 --><p>   To declare a static key, we need to define a global variable using the
<code> <span>DEFINE_STATIC_KEY_FALSE</span>
</code> or <code>  <span>DEFINE_STATIC_KEY_TRUE</span>
</code> macro defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/jump_label.h">include/linux/jump_label.h</a>. This macro initializes the key with
the given initial value, which is either false or true, respectively. For example, to
declare a static key with an initial value of false, we can use the following
code:
</p><!-- l. 1 -->
   <pre id="fancyvrb100"><a id="x1-68015r1"></a><span>1</span><span>DEFINE_STATIC_KEY_FALSE(fkey);</span></pre>
<!-- l. 2066 --><p>   Once the static key has been declared, we need to add branching code to the
module that uses the static key. For example, the code includes a fastpath, where a
no-op instruction will be generated at compile time as the key is initialized to false
and the branch is unlikely to be taken.
</p><!-- l. 1 -->
   <pre id="fancyvrb101"><a id="x1-68021r1"></a><span>1</span><span>pr_info(</span><span id="textcolor3474"><span>&#34;fastpath 1</span></span><span id="textcolor3475"><span>\n</span></span><span id="textcolor3476"><span>&#34;</span></span><span>);</span> 
<a id="x1-68023r2"></a><span>2</span><span id="textcolor3477"><span>if</span></span><span> (static_branch_unlikely(&amp;fkey))</span> 
<a id="x1-68025r3"></a><span>3</span><span>    pr_alert(</span><span id="textcolor3478"><span>&#34;do unlikely thing</span></span><span id="textcolor3479"><span>\n</span></span><span id="textcolor3480"><span>&#34;</span></span><span>);</span> 
<a id="x1-68027r4"></a><span>4</span><span>pr_info(</span><span id="textcolor3481"><span>&#34;fastpath 2</span></span><span id="textcolor3482"><span>\n</span></span><span id="textcolor3483"><span>&#34;</span></span><span>);</span></pre>
<!-- l. 2076 --><p>   If the key is enabled at runtime by calling
<code> <span>static_branch_enable(&amp;fkey)</span>
</code>, the fastpath will be patched with an unconditional jump instruction to the slowpath
code <code>  <span>pr_alert</span>
</code>, so the branch will always be taken until the key is disabled again.
</p><!-- l. 2078 --><p>   The following kernel module derived from <span><span><span>chardev.c</span></span></span>, demostrates how the static
key works.
</p><!-- l. 1 -->
   <pre id="fancyvrb102"><a id="x1-68031r1"></a><span>1</span><span id="textcolor3484"><span>/*</span></span> 
<a id="x1-68033r2"></a><span>2</span><span id="textcolor3485"><span> * static_key.c</span></span> 
<a id="x1-68035r3"></a><span>3</span><span id="textcolor3486"><span> */</span></span> 
<a id="x1-68037r4"></a><span>4</span> 
<a id="x1-68039r5"></a><span>5</span><span id="textcolor3487"><span>#include</span></span><span> </span><span id="textcolor3488"><span>&lt;linux/atomic.h&gt;</span></span> 
<a id="x1-68041r6"></a><span>6</span><span id="textcolor3489"><span>#include</span></span><span> </span><span id="textcolor3490"><span>&lt;linux/device.h&gt;</span></span> 
<a id="x1-68043r7"></a><span>7</span><span id="textcolor3491"><span>#include</span></span><span> </span><span id="textcolor3492"><span>&lt;linux/fs.h&gt;</span></span> 
<a id="x1-68045r8"></a><span>8</span><span id="textcolor3493"><span>#include</span></span><span> </span><span id="textcolor3494"><span>&lt;linux/kernel.h&gt; /* for sprintf() */</span></span> 
<a id="x1-68047r9"></a><span>9</span><span id="textcolor3495"><span>#include</span></span><span> </span><span id="textcolor3496"><span>&lt;linux/module.h&gt;</span></span> 
<a id="x1-68049r10"></a><span>10</span><span id="textcolor3497"><span>#include</span></span><span> </span><span id="textcolor3498"><span>&lt;linux/printk.h&gt;</span></span> 
<a id="x1-68051r11"></a><span>11</span><span id="textcolor3499"><span>#include</span></span><span> </span><span id="textcolor3500"><span>&lt;linux/types.h&gt;</span></span> 
<a id="x1-68053r12"></a><span>12</span><span id="textcolor3501"><span>#include</span></span><span> </span><span id="textcolor3502"><span>&lt;linux/uaccess.h&gt; /* for get_user and put_user */</span></span> 
<a id="x1-68055r13"></a><span>13</span> 
<a id="x1-68057r14"></a><span>14</span><span id="textcolor3503"><span>#include</span></span><span> </span><span id="textcolor3504"><span>&lt;asm/errno.h&gt;</span></span> 
<a id="x1-68059r15"></a><span>15</span> 
<a id="x1-68061r16"></a><span>16</span><span id="textcolor3505"><span>static</span></span><span> </span><span id="textcolor3506"><span>int</span></span><span> device_open(</span><span id="textcolor3507"><span>struct</span></span><span> inode *inode, </span><span id="textcolor3508"><span>struct</span></span><span> file *file);</span> 
<a id="x1-68063r17"></a><span>17</span><span id="textcolor3509"><span>static</span></span><span> </span><span id="textcolor3510"><span>int</span></span><span> device_release(</span><span id="textcolor3511"><span>struct</span></span><span> inode *inode, </span><span id="textcolor3512"><span>struct</span></span><span> file *file);</span> 
<a id="x1-68065r18"></a><span>18</span><span id="textcolor3513"><span>static</span></span><span> </span><span id="textcolor3514"><span>ssize_t</span></span><span> device_read(</span><span id="textcolor3515"><span>struct</span></span><span> file *file, </span><span id="textcolor3516"><span>char</span></span><span> __user *buf, </span><span id="textcolor3517"><span>size_t</span></span><span> count,</span> 
<a id="x1-68067r19"></a><span>19</span><span>                           loff_t *ppos);</span> 
<a id="x1-68069r20"></a><span>20</span><span id="textcolor3518"><span>static</span></span><span> </span><span id="textcolor3519"><span>ssize_t</span></span><span> device_write(</span><span id="textcolor3520"><span>struct</span></span><span> file *file, </span><span id="textcolor3521"><span>const</span></span><span> </span><span id="textcolor3522"><span>char</span></span><span> __user *buf,</span> 
<a id="x1-68071r21"></a><span>21</span><span>                            </span><span id="textcolor3523"><span>size_t</span></span><span> count, loff_t *ppos);</span> 
<a id="x1-68073r22"></a><span>22</span> 
<a id="x1-68075r23"></a><span>23</span><span id="textcolor3524"><span>#define SUCCESS 0</span></span> 
<a id="x1-68077r24"></a><span>24</span><span id="textcolor3525"><span>#define DEVICE_NAME &#34;key_state&#34;</span></span> 
<a id="x1-68079r25"></a><span>25</span><span id="textcolor3526"><span>#define BUF_LEN 10</span></span> 
<a id="x1-68081r26"></a><span>26</span> 
<a id="x1-68083r27"></a><span>27</span><span id="textcolor3527"><span>static</span></span><span> </span><span id="textcolor3528"><span>int</span></span><span> major;</span> 
<a id="x1-68085r28"></a><span>28</span> 
<a id="x1-68087r29"></a><span>29</span><span id="textcolor3529"><span>enum</span></span><span> {</span> 
<a id="x1-68089r30"></a><span>30</span><span>    CDEV_NOT_USED = 0,</span> 
<a id="x1-68091r31"></a><span>31</span><span>    CDEV_EXCLUSIVE_OPEN = 1,</span> 
<a id="x1-68093r32"></a><span>32</span><span>};</span> 
<a id="x1-68095r33"></a><span>33</span> 
<a id="x1-68097r34"></a><span>34</span><span id="textcolor3530"><span>static</span></span><span> atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);</span> 
<a id="x1-68099r35"></a><span>35</span> 
<a id="x1-68101r36"></a><span>36</span><span id="textcolor3531"><span>static</span></span><span> </span><span id="textcolor3532"><span>char</span></span><span> msg[BUF_LEN + 1];</span> 
<a id="x1-68103r37"></a><span>37</span> 
<a id="x1-68105r38"></a><span>38</span><span id="textcolor3533"><span>static</span></span><span> </span><span id="textcolor3534"><span>struct</span></span><span> class *cls;</span> 
<a id="x1-68107r39"></a><span>39</span> 
<a id="x1-68109r40"></a><span>40</span><span id="textcolor3535"><span>static</span></span><span> DEFINE_STATIC_KEY_FALSE(fkey);</span> 
<a id="x1-68111r41"></a><span>41</span> 
<a id="x1-68113r42"></a><span>42</span><span id="textcolor3536"><span>static</span></span><span> </span><span id="textcolor3537"><span>struct</span></span><span> file_operations chardev_fops = {</span> 
<a id="x1-68115r43"></a><span>43</span><span>    .owner = THIS_MODULE,</span> 
<a id="x1-68117r44"></a><span>44</span><span>    .open = device_open,</span> 
<a id="x1-68119r45"></a><span>45</span><span>    .release = device_release,</span> 
<a id="x1-68121r46"></a><span>46</span><span>    .read = device_read,</span> 
<a id="x1-68123r47"></a><span>47</span><span>    .write = device_write,</span> 
<a id="x1-68125r48"></a><span>48</span><span>};</span> 
<a id="x1-68127r49"></a><span>49</span> 
<a id="x1-68129r50"></a><span>50</span><span id="textcolor3538"><span>static</span></span><span> </span><span id="textcolor3539"><span>int</span></span><span> __init chardev_init(</span><span id="textcolor3540"><span>void</span></span><span>)</span> 
<a id="x1-68131r51"></a><span>51</span><span>{</span> 
<a id="x1-68133r52"></a><span>52</span><span>    major = register_chrdev(0, DEVICE_NAME, &amp;chardev_fops);</span> 
<a id="x1-68135r53"></a><span>53</span><span>    </span><span id="textcolor3541"><span>if</span></span><span> (major &lt; 0) {</span> 
<a id="x1-68137r54"></a><span>54</span><span>        pr_alert(</span><span id="textcolor3542"><span>&#34;Registering char device failed with %d</span></span><span id="textcolor3543"><span>\n</span></span><span id="textcolor3544"><span>&#34;</span></span><span>, major);</span> 
<a id="x1-68139r55"></a><span>55</span><span>        </span><span id="textcolor3545"><span>return</span></span><span> major;</span> 
<a id="x1-68141r56"></a><span>56</span><span>    }</span> 
<a id="x1-68143r57"></a><span>57</span> 
<a id="x1-68145r58"></a><span>58</span><span>    pr_info(</span><span id="textcolor3546"><span>&#34;I was assigned major number %d</span></span><span id="textcolor3547"><span>\n</span></span><span id="textcolor3548"><span>&#34;</span></span><span>, major);</span> 
<a id="x1-68147r59"></a><span>59</span> 
<a id="x1-68149r60"></a><span>60</span><span>    cls = class_create(THIS_MODULE, DEVICE_NAME);</span> 
<a id="x1-68151r61"></a><span>61</span> 
<a id="x1-68153r62"></a><span>62</span><span>    device_create(cls, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);</span> 
<a id="x1-68155r63"></a><span>63</span> 
<a id="x1-68157r64"></a><span>64</span><span>    pr_info(</span><span id="textcolor3549"><span>&#34;Device created on /dev/%s</span></span><span id="textcolor3550"><span>\n</span></span><span id="textcolor3551"><span>&#34;</span></span><span>, DEVICE_NAME);</span> 
<a id="x1-68159r65"></a><span>65</span> 
<a id="x1-68161r66"></a><span>66</span><span>    </span><span id="textcolor3552"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-68163r67"></a><span>67</span><span>}</span> 
<a id="x1-68165r68"></a><span>68</span> 
<a id="x1-68167r69"></a><span>69</span><span id="textcolor3553"><span>static</span></span><span> </span><span id="textcolor3554"><span>void</span></span><span> __exit chardev_exit(</span><span id="textcolor3555"><span>void</span></span><span>)</span> 
<a id="x1-68169r70"></a><span>70</span><span>{</span> 
<a id="x1-68171r71"></a><span>71</span><span>    device_destroy(cls, MKDEV(major, 0));</span> 
<a id="x1-68173r72"></a><span>72</span><span>    class_destroy(cls);</span> 
<a id="x1-68175r73"></a><span>73</span> 
<a id="x1-68177r74"></a><span>74</span><span>    </span><span id="textcolor3556"><span>/* Unregister the device */</span></span> 
<a id="x1-68179r75"></a><span>75</span><span>    unregister_chrdev(major, DEVICE_NAME);</span> 
<a id="x1-68181r76"></a><span>76</span><span>}</span> 
<a id="x1-68183r77"></a><span>77</span> 
<a id="x1-68185r78"></a><span>78</span><span id="textcolor3557"><span>/* Methods */</span></span> 
<a id="x1-68187r79"></a><span>79</span> 
<a id="x1-68189r80"></a><span>80</span><span id="textcolor3558"><span>/**</span></span> 
<a id="x1-68191r81"></a><span>81</span><span id="textcolor3559"><span> * Called when a process tried to open the device file, like</span></span> 
<a id="x1-68193r82"></a><span>82</span><span id="textcolor3560"><span> * cat /dev/key_state</span></span> 
<a id="x1-68195r83"></a><span>83</span><span id="textcolor3561"><span> */</span></span> 
<a id="x1-68197r84"></a><span>84</span><span id="textcolor3562"><span>static</span></span><span> </span><span id="textcolor3563"><span>int</span></span><span> device_open(</span><span id="textcolor3564"><span>struct</span></span><span> inode *inode, </span><span id="textcolor3565"><span>struct</span></span><span> file *file)</span> 
<a id="x1-68199r85"></a><span>85</span><span>{</span> 
<a id="x1-68201r86"></a><span>86</span><span>    </span><span id="textcolor3566"><span>if</span></span><span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))</span> 
<a id="x1-68203r87"></a><span>87</span><span>        </span><span id="textcolor3567"><span>return</span></span><span> -EBUSY;</span> 
<a id="x1-68205r88"></a><span>88</span> 
<a id="x1-68207r89"></a><span>89</span><span>    sprintf(msg, static_key_enabled(&amp;fkey) ? </span><span id="textcolor3568"><span>&#34;enabled</span></span><span id="textcolor3569"><span>\n</span></span><span id="textcolor3570"><span>&#34;</span></span><span> : </span><span id="textcolor3571"><span>&#34;disabled</span></span><span id="textcolor3572"><span>\n</span></span><span id="textcolor3573"><span>&#34;</span></span><span>);</span> 
<a id="x1-68209r90"></a><span>90</span> 
<a id="x1-68211r91"></a><span>91</span><span>    pr_info(</span><span id="textcolor3574"><span>&#34;fastpath 1</span></span><span id="textcolor3575"><span>\n</span></span><span id="textcolor3576"><span>&#34;</span></span><span>);</span> 
<a id="x1-68213r92"></a><span>92</span><span>    </span><span id="textcolor3577"><span>if</span></span><span> (static_branch_unlikely(&amp;fkey))</span> 
<a id="x1-68215r93"></a><span>93</span><span>        pr_alert(</span><span id="textcolor3578"><span>&#34;do unlikely thing</span></span><span id="textcolor3579"><span>\n</span></span><span id="textcolor3580"><span>&#34;</span></span><span>);</span> 
<a id="x1-68217r94"></a><span>94</span><span>    pr_info(</span><span id="textcolor3581"><span>&#34;fastpath 2</span></span><span id="textcolor3582"><span>\n</span></span><span id="textcolor3583"><span>&#34;</span></span><span>);</span> 
<a id="x1-68219r95"></a><span>95</span> 
<a id="x1-68221r96"></a><span>96</span><span>    try_module_get(THIS_MODULE);</span> 
<a id="x1-68223r97"></a><span>97</span> 
<a id="x1-68225r98"></a><span>98</span><span>    </span><span id="textcolor3584"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-68227r99"></a><span>99</span><span>}</span> 
<a id="x1-68229r100"></a><span>100</span> 
<a id="x1-68231r101"></a><span>101</span><span id="textcolor3585"><span>/**</span></span> 
<a id="x1-68233r102"></a><span>102</span><span id="textcolor3586"><span> * Called when a process closes the device file</span></span> 
<a id="x1-68235r103"></a><span>103</span><span id="textcolor3587"><span> */</span></span> 
<a id="x1-68237r104"></a><span>104</span><span id="textcolor3588"><span>static</span></span><span> </span><span id="textcolor3589"><span>int</span></span><span> device_release(</span><span id="textcolor3590"><span>struct</span></span><span> inode *inode, </span><span id="textcolor3591"><span>struct</span></span><span> file *file)</span> 
<a id="x1-68239r105"></a><span>105</span><span>{</span> 
<a id="x1-68241r106"></a><span>106</span><span>    </span><span id="textcolor3592"><span>/* We are now ready for our next caller. */</span></span> 
<a id="x1-68243r107"></a><span>107</span><span>    atomic_set(&amp;already_open, CDEV_NOT_USED);</span> 
<a id="x1-68245r108"></a><span>108</span> 
<a id="x1-68247r109"></a><span>109</span><span>    </span><span id="textcolor3593"><span>/**</span></span> 
<a id="x1-68249r110"></a><span>110</span><span id="textcolor3594"><span>     * Decrement the usage count, or else once you opened the file, you will</span></span> 
<a id="x1-68251r111"></a><span>111</span><span id="textcolor3595"><span>     * never get rid of the module.</span></span> 
<a id="x1-68253r112"></a><span>112</span><span id="textcolor3596"><span>     */</span></span> 
<a id="x1-68255r113"></a><span>113</span><span>    module_put(THIS_MODULE);</span> 
<a id="x1-68257r114"></a><span>114</span> 
<a id="x1-68259r115"></a><span>115</span><span>    </span><span id="textcolor3597"><span>return</span></span><span> SUCCESS;</span> 
<a id="x1-68261r116"></a><span>116</span><span>}</span> 
<a id="x1-68263r117"></a><span>117</span> 
<a id="x1-68265r118"></a><span>118</span><span id="textcolor3598"><span>/**</span></span> 
<a id="x1-68267r119"></a><span>119</span><span id="textcolor3599"><span> * Called when a process, which already opened the dev file, attempts to</span></span> 
<a id="x1-68269r120"></a><span>120</span><span id="textcolor3600"><span> * read from it.</span></span> 
<a id="x1-68271r121"></a><span>121</span><span id="textcolor3601"><span> */</span></span> 
<a id="x1-68273r122"></a><span>122</span><span id="textcolor3602"><span>static</span></span><span> </span><span id="textcolor3603"><span>ssize_t</span></span><span> device_read(</span><span id="textcolor3604"><span>struct</span></span><span> file *filp, </span><span id="textcolor3605"><span>/* see include/linux/fs.h */</span></span> 
<a id="x1-68275r123"></a><span>123</span><span>                           </span><span id="textcolor3606"><span>char</span></span><span> __user *buffer, </span><span id="textcolor3607"><span>/* buffer to fill with data */</span></span> 
<a id="x1-68277r124"></a><span>124</span><span>                           </span><span id="textcolor3608"><span>size_t</span></span><span> length, </span><span id="textcolor3609"><span>/* length of the buffer */</span></span> 
<a id="x1-68279r125"></a><span>125</span><span>                           loff_t *offset)</span> 
<a id="x1-68281r126"></a><span>126</span><span>{</span> 
<a id="x1-68283r127"></a><span>127</span><span>    </span><span id="textcolor3610"><span>/* Number of the bytes actually written to the buffer */</span></span> 
<a id="x1-68285r128"></a><span>128</span><span>    </span><span id="textcolor3611"><span>int</span></span><span> bytes_read = 0;</span> 
<a id="x1-68287r129"></a><span>129</span><span>    </span><span id="textcolor3612"><span>const</span></span><span> </span><span id="textcolor3613"><span>char</span></span><span> *msg_ptr = msg;</span> 
<a id="x1-68289r130"></a><span>130</span> 
<a id="x1-68291r131"></a><span>131</span><span>    </span><span id="textcolor3614"><span>if</span></span><span> (!*(msg_ptr + *offset)) { </span><span id="textcolor3615"><span>/* We are at the end of the message */</span></span> 
<a id="x1-68293r132"></a><span>132</span><span>        *offset = 0; </span><span id="textcolor3616"><span>/* reset the offset */</span></span> 
<a id="x1-68295r133"></a><span>133</span><span>        </span><span id="textcolor3617"><span>return</span></span><span> 0; </span><span id="textcolor3618"><span>/* signify end of file */</span></span> 
<a id="x1-68297r134"></a><span>134</span><span>    }</span> 
<a id="x1-68299r135"></a><span>135</span> 
<a id="x1-68301r136"></a><span>136</span><span>    msg_ptr += *offset;</span> 
<a id="x1-68303r137"></a><span>137</span> 
<a id="x1-68305r138"></a><span>138</span><span>    </span><span id="textcolor3619"><span>/* Actually put the date into the buffer */</span></span> 
<a id="x1-68307r139"></a><span>139</span><span>    </span><span id="textcolor3620"><span>while</span></span><span> (length &amp;&amp; *msg_ptr) {</span> 
<a id="x1-68309r140"></a><span>140</span><span>        </span><span id="textcolor3621"><span>/**</span></span> 
<a id="x1-68311r141"></a><span>141</span><span id="textcolor3622"><span>         * The buffer is in the user data segment, not the kernel</span></span> 
<a id="x1-68313r142"></a><span>142</span><span id="textcolor3623"><span>         * segment so &#34;*&#34; assignment won</span><span>&#39;</span><span>t work. We have to use</span></span> 
<a id="x1-68315r143"></a><span>143</span><span id="textcolor3624"><span>         * put_user which copies data from the kernel data segment to</span></span> 
<a id="x1-68317r144"></a><span>144</span><span id="textcolor3625"><span>         * the user data segment.</span></span> 
<a id="x1-68319r145"></a><span>145</span><span id="textcolor3626"><span>         */</span></span> 
<a id="x1-68321r146"></a><span>146</span><span>        put_user(*(msg_ptr++), buffer++);</span> 
<a id="x1-68323r147"></a><span>147</span><span>        length--;</span> 
<a id="x1-68325r148"></a><span>148</span><span>        bytes_read++;</span> 
<a id="x1-68327r149"></a><span>149</span><span>    }</span> 
<a id="x1-68329r150"></a><span>150</span> 
<a id="x1-68331r151"></a><span>151</span><span>    *offset += bytes_read;</span> 
<a id="x1-68333r152"></a><span>152</span> 
<a id="x1-68335r153"></a><span>153</span><span>    </span><span id="textcolor3627"><span>/* Most read functions return the number of bytes put into the buffer. */</span></span> 
<a id="x1-68337r154"></a><span>154</span><span>    </span><span id="textcolor3628"><span>return</span></span><span> bytes_read;</span> 
<a id="x1-68339r155"></a><span>155</span><span>}</span> 
<a id="x1-68341r156"></a><span>156</span> 
<a id="x1-68343r157"></a><span>157</span><span id="textcolor3629"><span>/* Called when a process writes to dev file; echo &#34;enable&#34; &gt; /dev/key_state */</span></span> 
<a id="x1-68345r158"></a><span>158</span><span id="textcolor3630"><span>static</span></span><span> </span><span id="textcolor3631"><span>ssize_t</span></span><span> device_write(</span><span id="textcolor3632"><span>struct</span></span><span> file *filp, </span><span id="textcolor3633"><span>const</span></span><span> </span><span id="textcolor3634"><span>char</span></span><span> __user *buffer,</span> 
<a id="x1-68347r159"></a><span>159</span><span>                            </span><span id="textcolor3635"><span>size_t</span></span><span> length, loff_t *offset)</span> 
<a id="x1-68349r160"></a><span>160</span><span>{</span> 
<a id="x1-68351r161"></a><span>161</span><span>    </span><span id="textcolor3636"><span>char</span></span><span> command[10];</span> 
<a id="x1-68353r162"></a><span>162</span> 
<a id="x1-68355r163"></a><span>163</span><span>    </span><span id="textcolor3637"><span>if</span></span><span> (length &gt; 10) {</span> 
<a id="x1-68357r164"></a><span>164</span><span>        pr_err(</span><span id="textcolor3638"><span>&#34;command exceeded 10 char</span></span><span id="textcolor3639"><span>\n</span></span><span id="textcolor3640"><span>&#34;</span></span><span>);</span> 
<a id="x1-68359r165"></a><span>165</span><span>        </span><span id="textcolor3641"><span>return</span></span><span> -EINVAL;</span> 
<a id="x1-68361r166"></a><span>166</span><span>    }</span> 
<a id="x1-68363r167"></a><span>167</span> 
<a id="x1-68365r168"></a><span>168</span><span>    </span><span id="textcolor3642"><span>if</span></span><span> (copy_from_user(command, buffer, length))</span> 
<a id="x1-68367r169"></a><span>169</span><span>        </span><span id="textcolor3643"><span>return</span></span><span> -EFAULT;</span> 
<a id="x1-68369r170"></a><span>170</span> 
<a id="x1-68371r171"></a><span>171</span><span>    </span><span id="textcolor3644"><span>if</span></span><span> (strncmp(command, </span><span id="textcolor3645"><span>&#34;enable&#34;</span></span><span>, strlen(</span><span id="textcolor3646"><span>&#34;enable&#34;</span></span><span>)) == 0)</span> 
<a id="x1-68373r172"></a><span>172</span><span>        static_branch_enable(&amp;fkey);</span> 
<a id="x1-68375r173"></a><span>173</span><span>    </span><span id="textcolor3647"><span>else</span></span><span> </span><span id="textcolor3648"><span>if</span></span><span> (strncmp(command, </span><span id="textcolor3649"><span>&#34;disable&#34;</span></span><span>, strlen(</span><span id="textcolor3650"><span>&#34;disable&#34;</span></span><span>)) == 0)</span> 
<a id="x1-68377r174"></a><span>174</span><span>        static_branch_disable(&amp;fkey);</span> 
<a id="x1-68379r175"></a><span>175</span><span>    </span><span id="textcolor3651"><span>else</span></span><span> {</span> 
<a id="x1-68381r176"></a><span>176</span><span>        pr_err(</span><span id="textcolor3652"><span>&#34;Invalid command: %s</span></span><span id="textcolor3653"><span>\n</span></span><span id="textcolor3654"><span>&#34;</span></span><span>, command);</span> 
<a id="x1-68383r177"></a><span>177</span><span>        </span><span id="textcolor3655"><span>return</span></span><span> -EINVAL;</span> 
<a id="x1-68385r178"></a><span>178</span><span>    }</span> 
<a id="x1-68387r179"></a><span>179</span> 
<a id="x1-68389r180"></a><span>180</span><span>    </span><span id="textcolor3656"><span>/* Again, return the number of input characters used. */</span></span> 
<a id="x1-68391r181"></a><span>181</span><span>    </span><span id="textcolor3657"><span>return</span></span><span> length;</span> 
<a id="x1-68393r182"></a><span>182</span><span>}</span> 
<a id="x1-68395r183"></a><span>183</span> 
<a id="x1-68397r184"></a><span>184</span><span>module_init(chardev_init);</span> 
<a id="x1-68399r185"></a><span>185</span><span>module_exit(chardev_exit);</span> 
<a id="x1-68401r186"></a><span>186</span> 
<a id="x1-68403r187"></a><span>187</span><span>MODULE_LICENSE(</span><span id="textcolor3658"><span>&#34;GPL&#34;</span></span><span>);</span></pre>
                                                                  

                                                                  
<!-- l. 2082 --><p>   To check the state of the static key, we can use the <span><span><span>/dev/key_state</span></span></span>
interface.
</p><!-- l. 1 -->
   <pre id="fancyvrb103"><a id="x1-68406r1"></a><span>1</span><span>cat /dev/key_state</span></pre>
<!-- l. 2088 --><p>   This will display the current state of the key, which is disabled by default.
</p><!-- l. 2090 --><p>   To change the state of the static key, we can perform a write operation on the
file:
</p><!-- l. 1 -->
   <pre id="fancyvrb104"><a id="x1-68409r1"></a><span>1</span><span>echo enable &gt; /dev/key_state</span></pre>
<!-- l. 2096 --><p>   This will enable the static key, causing the code path to switch from the fastpath
to the slowpath.
</p><!-- l. 2098 --><p>   In some cases, the key is enabled or disabled at initialization and never changed,
we can declare a static key as read-only, which means that it can only be toggled in
the module init function. To declare a read-only static key, we can use the
<code> <span>DEFINE_STATIC_KEY_FALSE_RO</span>
</code> or <code>  <span>DEFINE_STATIC_KEY_TRUE_RO</span>
</code> macro instead. Attempts to change the key at runtime will result in a page fault. For
more information, see <a href="https://www.kernel.org/doc/Documentation/static-keys.txt">Static keys</a>
</p><!-- l. 2101 -->
   <h3 id="common-pitfalls"><span>20   </span> <a id="x1-6900020"></a>Common Pitfalls</h3>
<!-- l. 2104 -->
   <h4 id="using-standard-libraries"><span>20.1   </span> <a id="x1-7000020.1"></a>Using standard libraries</h4>
<!-- l. 2106 --><p>You can not do that. In a kernel module, you can only use kernel functions which are
the functions you can see in <span><span><span>/proc/kallsyms</span></span></span>.
</p><!-- l. 2109 -->
   <h4 id="disabling-interrupts"><span>20.2   </span> <a id="x1-7100020.2"></a>Disabling interrupts</h4>
<!-- l. 2111 --><p>You might need to do this for a short time and that is OK, but if you do not enable
them afterwards, your system will be stuck and you will have to power it
off.
                                                                  

                                                                  
</p><!-- l. 2113 -->
   <h3 id="where-to-go-from-here"><span>21   </span> <a id="x1-7200021"></a>Where To Go From Here?</h3>
<!-- l. 2115 --><p>For people seriously interested in kernel programming, I recommend <a href="https://kernelnewbies.org">kernelnewbies.org</a>
and the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation">Documentation</a> subdirectory within the kernel source code which is not
always easy to understand but can be a starting point for further investigation. Also,
as Linus Torvalds said, the best way to learn the kernel is to read the source code
yourself.
</p><!-- l. 2118 --><p>   If you would like to contribute to this guide or notice anything glaringly wrong,
please create an issue at <a href="https://github.com/sysprog21/lkmpg"><span>https://github.com/sysprog21/lkmpg</span></a>. Your pull requests
will be appreciated.
</p><!-- l. 2121 --><p>   Happy hacking!
</p>
   
 
 
</div>
  </body>
</html>
