<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.muppetlabs.com/~breadbox/txt/mopb.html">Original</a>
    <h1>My Own Private Binary: An Idiosyncratic Introduction to Linux Kernel Modules</h1>
    
    <div id="readability-page-1" class="page">




<hr/>

<h3>How This Began</h3>

<p>Several years ago, I spent a serious chunk of time figuring out how to
make really teensy ELF executable files. I started down this path
because I was annoyed that all of my programs, no matter how short
they were, never got smaller than 4k or so. I felt that was excessive,
for C, and so I started looking at what ELF files contained, and how
much of that actually needed to be there. (And then, after a while,
how much of it was supposed to be there but could be ripped out
anyway.) Anyway, I eventually managed to shrink an executable down to
45 bytes, and I was able to demonstrate that that was the smallest
possible size an ELF executable could be and still run, under x86
Linux at least.</p>

<p><a href="https://the.scapegoat.dev/~breadbox/software/tiny/teensy.html">I wrote up my findings</a>, and
some people found it interesting, and I got some positive feedback. A
couple of people naturally pointed out that a shell script that did
the same thing was much shorter than 45 bytes, to which my response
was always that a shell script is not an executable, and if you want
to consider scripts then you need to include the size of the
interpreter binary along with the script size.</p>

<p>But then one Internet Random Person™ pointed out that I could
have made a smaller executable if I had created an <a href="https://the.scapegoat.dev/~breadbox/software/tiny/tiny-aout.asm.txt">aout
binary</a> instead. If you
don&#39;t know what aout files are, don&#39;t worry — that just means you&#39;re
not old. (They are also called &#34;a.out files&#34;, but that can be easily
confused with just a file named &#34;a.out&#34;, so I prefer to spell the name
of the format &#34;aout&#34;.) At one time the aout format was widely used on
Linux, because it was Linux&#39;s only binary format. ELF was not
introduced to Linux until version 2.0 (or more precisely in one of the
1.x experimental kernels). aout was, and still is, a very simple
format. It sports a 32-byte header, along with a handful of other
metadata. Unfortunately the aout format has some annoying limitations
around dynamic linking, so the fact that Linux switched away from it
early on is not too surprising. ELF is a much nicer format for a
mature system. But even though aout binaries were no longer
fashionable, they still worked.</p>

<p>However, when I first tried to run the aout executable the person had
sent me, I got an &#34;Exec format error&#34; message — i.e. this file format
is not supported. It turned out that a security issue had been
uncovered at one point that involved aout core dumps. (Did you know?
Executable file formats come with their own core dump file formats to
match.) I&#39;m vague on the details, but as a result most distros started
compiling their kernels without aout support. The format was
considered to be pretty thoroughly deprecated by that time, so it
wasn&#39;t seen as a difficult call to make.</p>

<p>(Support for aout is still present in the kernel source tree, however,
and you&#39;re free to include it if you compile your own kernel. At the
time of this writing there was talk about removing it entirely, but
apparently some architectures still have a use for it. Some people
have suggested removing support just for aout core dumps, but in the
absence of a pressing issue it remains as it is. The whole
conversation is a good reminder that adding a feature to software is
often far easier than removing it.)</p>

<p>But so I did compile a kernel with aout support, and verify that the
35-byte binary did in fact work. And the whole thing got me to
wondering, <em>how many executable file formats does Linux actually
support?</em> I looked into it, and I found out that the way in which
Linux handles binary formats is a dynamic feature of the kernel. That
is to say, it&#39;s relatively straightforward to add support for a new
format, without having to recompile your kernel, or reboot your
machine even.</p>

<p>An aside: I want to clarify that I&#39;m not talking about the
&#34;miscellaneous binary format&#34; feature of the kernel. That feature
allows you to dynamically designate an interpreter to be run when the
user attempts to execute certain files. Thus, for example, running a
file ending in <code>.jar</code> can automatically invoke the JavaVM for you.
That feature is controlled via the <code>/proc/sys/fs/binfmt_misc</code> system,
so check out the <code>binfmt_misc</code> documentation if you&#39;re curious.
Interpreters are not what I&#39;m interested in here, though; I&#39;m focusing
exclusively on actual binary files.</p>


<p>What I was secretly hoping to discover was if a &#34;flat&#34; format existed
— that is, a binary file format with no metadata at all. Obviously,
such a format would allow for even smaller executables. No such format
was supported, however. But that isn&#39;t too surprising, as such a
format isn&#39;t very useful. Where there is no metadata, there are no
features, no options. A flat format is a one-size-fits-all approach,
and that&#39;s not what most people need from their binary format
standards.</p>

<p>In order to avoid confusion, I should mention here that the Linux
kernel does have support for a format that is <em>called</em> &#34;flat&#34;, but
this is just the name of the uClinux native binary format. It is
actually larger and more featureful than the aout format from which it
was derived. Presumably this format is flat along some other
dimension.</p>


<p>Despite such shortcomings, it so happens that there is a flat,
metadata-less executable file format that is well supported on another
popular OS. If you haven&#39;t already guessed, I&#39;m referring to the
<code>.com</code> file format that MS Windows supports, having inherited it from
MS-DOS, which in turn inherited it from CP/M. It is truly flat. When
you run a <code>.com</code> file, the OS loads the whole thing in memory at a
standard address and runs it. And this approach works okay on a
single-tasking system like MS-DOS. (Or rather, on the MS-DOS-like
subsystem that MS Windows presents to a running <code>.com</code> file.) In that
environment, the OS can say, &#34;Here you go, program. You have 640
kilobytes of RAM. Have fun!&#34;</p>

<p>And so naturally I asked myself, <em>what would it take to get a <code>.com</code>
file format working under Linux?</em> I mean yes it would not be terribly
useful … but it would let me make the smallest executable file ever.
Sure, I could never hope to get support for such a format added to the
actual Linux kernel. But I <em>could</em> add it to my own kernel, where at
least I would be able to use it myself. I could be living in my own
private binary.</p>

<h3>Kernel Modules</h3>

<p>Linux makes it easy to do this sort of thing via <em>loadable kernel
modules</em>. What exactly is a kernel module? Basically, a kernel module
is an object file built for the kernel that just hasn&#39;t been linked
yet. The trick is that you can link one into a running kernel without
having to stop the kernel or even pull over. (This isn&#39;t quite the
same thing as what is generally meant by &#34;dynamic linking&#34;, though it
is very similar in spirit.) Kernel modules mainly allow users to
manage support for various kinds of hardware dynamically, but they
allow you to add support for all kinds of things without having to
recompile the kernel. So let&#39;s take a moment and look at how to create
a kernel module.</p>

<p>Before we get started, we need to make sure that the kernel&#39;s header
files are present on the machine. For users on Debian-based systems,
this is typically done with the shell command:</p>

<p><code>uname(1)</code> is used to ensure that you&#39;re
getting the files that match the specific version of the kernel you&#39;re
currently running.</p>
<div><p>$ <b>sudo apt install linux-headers-$(uname -r)</b></p></div>

<p>This will install a directory under <code>/usr/src</code> corresponding to the
your current kernel version. (In fact, you may find that you already
have several directories located there, one for every version of the
kernel that you can currently boot into.) This directory contains,
among other things, all of the header files that we&#39;ll need to build
kernel modules.</p>

<p>We&#39;ll start with a very simple one, predictably named &#34;hello kernel&#34;.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>hello.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);
MODULE_AUTHOR(&#34;me&#34;);
MODULE_DESCRIPTION(&#34;hello kernel&#34;);
MODULE_VERSION(&#34;0.1&#34;);

static int __init hello_init(void)
{
    printk(KERN_INFO &#34;hello, kernel\n&#34;);
    return 0;
}

static void __exit hello_exit(void)
{
    printk(KERN_INFO &#34;goodbye, kernel\n&#34;);
}

module_init(hello_init);
module_exit(hello_exit);
</code></pre></td></tr></tbody></table>

<p>A quick rundown of what is being done here:</p>

<table><tbody><tr><td><pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
</code></pre></td><td>The header file <code>linux/module.h</code> defines the
<code>MODULE_*</code> macros, <code>linux/init.h</code> defines the <code>__init</code> and <code>__exit</code>
macros, and <code>linux/kernel.h</code> gives us the <code>printk()</code> function.</td></tr><tr><td><pre><code>MODULE_LICENSE(&#34;GPL&#34;);
MODULE_AUTHOR(&#34;me&#34;);
MODULE_DESCRIPTION(&#34;hello kernel&#34;);
MODULE_VERSION(&#34;0.1&#34;);
</code></pre></td><td>These macros just insert some metadata into
our module. You can view this information via the <code>modprobe(1)</code>
utility. Among other things, the kernel keeps track of the presence of
non-free software.<p>⋮</p></td></tr><tr><td><pre><code>module_init(hello_init);
module_exit(hello_exit);
</code></pre></td><td>And then there are two special functions,
the <em>init</em> function and the <em>exit</em> function. The <code>module_init()</code> and
<code>module_exit()</code> macros mark which function is which, so the kernel can
find them. The first one gets called at the time the module is inserted
into a running kernel, and the second one gets called when the module
is being removed from the kernel.</td></tr></tbody></table>

<p>The kernel folks have made it extremely easy to build kernel modules.
Here&#39;s the makefile:</p>

<table><tbody><tr><td></td><td rowspan="2"><i>Makefile</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>obj-m = hello.o
kver = $(shell uname -r)
all:
	make -C /lib/modules/$(kver)/build/ M=$(PWD) modules
clean:
	make -C /lib/modules/$(kver)/build M=$(PWD) clean
</code></pre></td></tr></tbody></table>

<p>All you do is put the name of your object file on the first line,
and everything else is done for you.</p>

<p>So, if we run <code>make(1)</code>, a bunch of stuff will get created:</p>



<p>There&#39;s <code>hello.o</code>, a regular object file, but we also have an object
file named <code>hello.ko</code>. This is the kernel module. We have become
kernel developers.</p>

<p>The <code>insmod(8)</code> tool can be used to load this module into the running
kernel:</p>



<p>When we type <code>lsmod(8)</code> to list the active modules, it&#39;s right there at
the top, as the most recently added module.</p>

<p>The actual effect of this module is simply to output some log
messages. We can use <code>dmesg(8)</code> to verify that our module really did
load:</p>



<p>We can then use <code>rmmod(8)</code> to remove the module from the running
kernel whenever we want:</p>



<p>So that&#39;s all there is to writing kernel modules.</p>

<p>No, of course that&#39;s not true. Writing a useful kernel module does
require some specialized knowledge. For example, kernel modules don&#39;t
have access to <code>libc</code>, since <code>libc</code> itself is mainly an abstraction
layer that sits atop the kernel. That said, much of the functionality
you&#39;re used to having easy access to as a C programmer is also present
in the kernel, though sometimes in slightly different dress.
(Filesystems, for example, are one bit of detail that we as Unix
programmers often ignore, but are obviously a major concern inside the
kernel.)</p>

<p>But don&#39;t let all that deter you. The rewards of writing kernel
modules are worth the inconveniences. There is a great deal that you
can do inside a kernel module that is simply impossible outside of it.
Remember, Linux is a monolithic kernel — which means that once you
are loaded, you have the keys to the kingdom. Your lowly, nonstandard
kernel module can do <em>anything</em>. Of course, this is a double-edged
sword, because that also means that you can <em>accidentally</em> do
anything. As it happens, a lot of bad things are actually pretty hard
to do accidentally, such as mucking up some other process&#39;s code.
You&#39;d need to jump through a few hoops just to get a pointer to
someone else&#39;s memory. But some unfortunate things are remarkably easy
to do. For example, one time while working on my kernel module, I
accidentally put <code>--i</code> instead of <code>++i</code> in the iterator of my <code>for</code>
loop. I inserted that module into my kernel to test it, and my mouse
cursor disappeared, and my music stopped playing … and then it was
time to reboot my computer.</p>

<p>But that sort of risk shouldn&#39;t scare you away. With modern journaling
file systems and the like, you&#39;re never going to be at any real risk
of losing data. (I mean, unless you&#39;re actually working on
implementing a filesystem, in which case please back up your files
regularly.) I encourage you to experiment and try out your own ideas
for kernel modules.</p>

<h3>Binary File Formats Under Linux</h3>

<p>All right, but what exactly does this have to do with making smaller
executables? Well, as I mentioned earlier, the kernel&#39;s list of
accepted binary file formats is dynamic. Specifically, this means that
there are functions inside the kernel that allow code to add and
remove binary formats from this list.</p>

<p>This is done by registering a set of callback functions, and these
callbacks get invoked when the kernel is asked to execute a binary
file. The kernel invokes the callbacks on this list, and the first one
that claims to recognize the file takes responsibility for getting it
properly loaded into memory. If nobody on the list accepts it, then as
a last resort the kernel will attempt to treat it as a shell script
without a shebang line. And if that doesn&#39;t fly, then you&#39;ll get that
&#34;Exec format error&#34; message described above. </p><p>Interesting side note:
The kernel decides whether or not to try to parse a file as a shell
script by whether or not it contains a line break in the first few
hundred bytes — specifically if it contains a line break before the
first zero byte. Thus a data file that just happens to have a &#34;<code>\n</code>&#34;
near the top can produce some odd-looking error messages if you try to
execute it.</p>


<p>So we find ourselves in possession of the following facts:</p>

<ol>
<li>The Linux kernel can dynamically introduce new binary file formats.</li>
<li>Kernel modules can be added to a running kernel.</li>
<li>Being able to run flat binaries would be really neat.</li>
</ol>

<p>Obviously, there is only one possible response to this situation.</p>

<h3>Version 0.1: Look Ma, No Metadata</h3>

<p>We wish to write a kernel module that implements a flat, metadata-less
binary file format for Linux. So, that&#39;s what I did.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>comfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;

#include &lt;linux/fs.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/mman.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/binfmts.h&gt;
#include &lt;linux/personality.h&gt;
#include &lt;linux/processor.h&gt;
#include &lt;linux/ptrace.h&gt;
#include &lt;linux/sched/task_stack.h&gt;

MODULE_DESCRIPTION(&#34;Linux command executable files&#34;);
MODULE_AUTHOR(&#34;Brian Raiter &lt;breadbox@muppetlabs.com&gt;&#34;);
MODULE_VERSION(&#34;0.1&#34;);
MODULE_LICENSE(&#34;GPL&#34;);

/* Given an address or size, round up to the next page boundary.
 */
#define pagealign(n)  (((n) + PAGE_SIZE - 1) &amp; PAGE_MASK)

static struct linux_binfmt comfile_fmt;

static int load_comfile_binary(struct linux_binprm *lbp)
{
    long const loadaddr = 0x00010000;

    char const *ext;
    loff_t filesize;
    int r;

    ext = strrchr(lbp-&gt;filename, &#39;.&#39;);
    if (!ext || strcmp(ext, &#34;.com&#34;))
        return -ENOEXEC;

    r = flush_old_exec(lbp);
    if (r)
        return r;
    set_personality(PER_LINUX);
    set_binfmt(&amp;comfile_fmt);
    setup_new_exec(lbp);

    filesize = generic_file_llseek(lbp-&gt;file, 0, SEEK_END);
    generic_file_llseek(lbp-&gt;file, 0, SEEK_SET);

    current-&gt;mm-&gt;start_code = loadaddr;
    current-&gt;mm-&gt;end_code = current-&gt;mm-&gt;start_code + filesize;

    r = setup_arg_pages(lbp, STACK_TOP, EXSTACK_DEFAULT);
    if (r)
        return r;

    r = vm_mmap(lbp-&gt;file, loadaddr, filesize,
                PROT_READ | PROT_WRITE | PROT_EXEC,
                MAP_FIXED | MAP_PRIVATE, 0);
    if (r &lt; 0)
        return r;

    install_exec_creds(lbp);
    /*finalize_exec(lbp);*/
    start_thread(current_pt_regs(), loadaddr,
                 current-&gt;mm-&gt;start_stack);
    return 0;
}

static struct linux_binfmt comfile_fmt = {
    .module = THIS_MODULE,
    .load_binary = load_comfile_binary,
    .load_shlib = NULL,
    .core_dump = NULL,
    .min_coredump = 0
};

static int __init comfile_start(void)
{
    register_binfmt(&amp;comfile_fmt);
    return 0;
}

static void __exit comfile_end(void)
{
    unregister_binfmt(&amp;comfile_fmt);
}

module_init(comfile_start);
module_exit(comfile_end);
</code></pre></td></tr></tbody></table>

<p>Unlike our first kernel module, this one is actually doing some
interesting work. So let&#39;s take the time to walk through this code and
understand what&#39;s going on.</p>

<table><tbody><tr><td><pre><code>static int __init comfile_start(void)
{
    register_binfmt(&amp;comfile_fmt);
    return 0;
}

static void __exit comfile_end(void)
{
    unregister_binfmt(&amp;comfile_fmt);
}
</code></pre></td><td>Our very-short init function just calls
<code>register_binfmt()</code>, and likewise our exit function calls
<code>unregister_binfmt()</code>. As you have probably already guessed, these are
the functions that add and remove support for a new binary format. The
argument to both functions is a pointer to a static struct of type
<code>linux_binfmt</code>.</td></tr><tr><td><pre><code>static struct linux_binfmt comfile_fmt = {
    .module = THIS_MODULE,
    .load_binary = load_comfile_binary,
    .load_shlib = NULL,
    .core_dump = NULL,
    .min_coredump = 0
};
</code></pre></td><td>The important fields of the <code>linux_binfmt</code>
struct are three function pointers. They provide callbacks for loading
an executable, loading a shared-object library, and dumping a core
file. Thankfully, those latter two features are optional, so we can
leave them unimplemented, and just provide the first callback.</td></tr><tr><td><pre><code>static int load_comfile_binary(struct linux_binprm *lbp)
</code></pre></td><td>And this function is where all the work gets
done. It will be invoked by the kernel every time someone is
attempting to execute one of our files, and its purpose is to get the
file&#39;s contents into memory and running. The function is passed a
single argument, <code>lbp</code>, which is a pointer to a struct called
<code>linux_binprm</code> that contains our actual arguments. It has a dozen or
so fields that summarize everything the kernel knows about our file.
The callback returns an <code>int</code> value, as is typical for internal kernel
functions. If all goes well, the return value is zero. When an error
occurs, the function should return a negative number that corresponds
to a negated <code>errno</code> value.</td></tr></tbody></table>

<p>Recall how a program is launched under Unix: first the <code>fork</code> system
call is used to duplicate the process, and then the <code>execve</code>
system call replaces the process&#39;s current program with a new one.
</p><p>Note that the <code>fork</code> system call is not quite the same thing as the
<code>fork()</code> function supplied by <code>libc</code>, although the latter is just a
thin wrapper around the former. Similarly, <code>libc</code> provides a family of
seven different &#34;exec&#34; functions, but they all ultimately invoke the
<code>execve</code> system call.</p>


<p>The nice thing about this system is that we never have to worry about
actually creating a process from scratch. That&#39;s done for us. Every
program&#39;s process is a copy of pid 1, duplicated through a succession
of <code>fork</code>s. Our callback will instead be invoked during the <code>execve</code>
system call. In effect, when the kernel calls us, it is asking, &#34;Hey,
I&#39;ve got a file here. The user claims it&#39;s an executable binary, but
it&#39;s not an ELF file. Do <em>you</em> want to deal with it?&#34; Every callback
function that has been registered with <code>register_binfmt()</code> gets
called, in order, going down the list, until someone takes
responsibility for the file.</p>

<p>So that&#39;s the first thing our callback function needs to do: it needs
to decide whether or not this is actually a <code>.com</code> file. Which raises
the obvious question: how do we even do that? Most binary formats
looks for a magic-number identifier in the first few bytes of metadata
— but we have no metadata. So then what?</p>

<p>Well, how does MS Windows identify <code>.com</code> files? Answer: it looks at
the filename. When you try to execute a file with a name ending in
&#34;<code>.com</code>&#34;, that&#39;s all MS Windows really cares about. &#34;Oh, you&#39;re a
<code>.com</code> file, are you? Okay: here&#39;s 640k and an interrupt table. Call
me when you&#39;re done.&#34;</p>

<table><tbody><tr><td><pre><code>    ext = strrchr(lbp-&gt;filename, &#39;.&#39;);
    if (!ext || strcmp(ext, &#34;.com&#34;))
        return -ENOEXEC;
</code></pre></td><td>So that&#39;s what we do, too. One of the
fields of the <code>linux_binprm</code> struct is the filename, so we examine it,
and if there&#39;s no &#34;<code>.com</code>&#34; extension, then we return negative
<code>ENOEXEC</code>, the <code>errno</code> equivalent to our &#34;Exec format error&#34; message.
This error normally means &#34;this is not an executable&#34;, but in this
particular context, it really means &#34;this is not one of my
executables.&#34; When the kernel gets this return value, it will just
continue trying other formats. If all the callbacks return this value,
then <code>ENOEXEC</code> will actually get returned from <code>execve</code> itself, which
<code>libc</code> will then package up and store in <code>errno</code>. But, if it does end
in &#34;<code>.com</code>&#34;, then our callback continues.</td></tr></tbody></table>

<p>All we have to do now is load and run the file. No pressure, right?
Luckily for us, the kernel provides lots of functions that will do
almost all of the heavy lifting for us. We just need to oversee the
whole process. So let&#39;s quickly run down the sequence of events.</p>

<table><tbody><tr><td><pre><code>    r = flush_old_exec(lbp);
    if (r)
        return r;
</code></pre></td><td>The very first thing we do is call
<code>flush_old_exec()</code>. Boom. Nearly everything that was specific to the
old process is now gone. The process is now an empty salt flat,
extending featurelessly to the horizon. Wait, that&#39;s a little bleak.
Instead, let&#39;s imagine it as a fallow field, ready for planting. Note
also that if a non-zero value is returned, then a failure occurred, in
which case we dutifully pass the negated <code>errno</code> value back up the
call chain.</td></tr><tr><td><pre><code>    set_personality(PER_LINUX);
</code></pre></td><td>Personality is an obscure feature that
allows certain behaviors of the kernel to vary on a per-process basis.
For whatever reason, it&#39;s not reset by the flush.</td></tr><tr><td><pre><code>    set_binfmt(&amp;comfile_fmt);
</code></pre></td><td>The <code>set_binfmt()</code> function explicitly claims
this binary as one of our own. As far as I can tell, this is only used
for debugging purposes.</td></tr><tr><td><pre><code>    setup_new_exec(lbp);
</code></pre></td><td><code>setup_new_exec()</code> initializes the process to
some basic defaults, and allows for any architecture-specific
initializations to occur.</td></tr><tr><td><pre><code>    filesize = generic_file_llseek(lbp-&gt;file, 0, SEEK_END);
    generic_file_llseek(lbp-&gt;file, 0, SEEK_SET);
</code></pre></td><td>At this point we are now cleared to start
defining our memory image, which is currently very empty. So the first
thing we want to do is determine how big the file is, since that&#39;s
also the size of program. Inside the kernel, we don&#39;t have the
familiar file descriptors. Instead, we have file objects. As you might
expect, the <code>linux_binprm</code> struct includes an already-opened file
object, and the kernel function <code>generic_file_llseek()</code> works pretty
much the same as <code>libc</code>&#39;s more familiar <code>lseek()</code> function for
retrieving the file size.</td></tr><tr><td><pre><code>    current-&gt;mm-&gt;start_code = loadaddr;
    current-&gt;mm-&gt;end_code = current-&gt;mm-&gt;start_code + filesize;
</code></pre></td><td><code>current</code> is a global variable that points
to the current task. A task is like a process or a thread, except that
instead of being a numerical identifier, it&#39;s the actual thing itself
— the noumenon, the <em>ding-an-sich</em>. It&#39;s a struct with literally
hundreds of fields. It&#39;s, like, really big. Pretty much anything you
might want to know about a process is in this thing, somewhere. One of
those things is the task&#39;s memory manager. And right now, the memory
manager is eager to know where the process&#39;s component parts are going
to be located. Since our format is so simple — all we have is a blob
of code — we mainly need to provide a valid load address. There
aren&#39;t too many requirements for this address. It just needs to be
page-aligned, well away from the stack, and not zero. I selected
<code>0x10000</code> as our load address because there wasn&#39;t a particular reason
not to.</td></tr><tr><td><pre><code>    r = setup_arg_pages(lbp, STACK_TOP, EXSTACK_DEFAULT);
    if (r)
        return r;
</code></pre></td><td>We aren&#39;t setting up anything else that
processes typically contain, because we&#39;re just so down to earth like
that, so we can go straight to calling <code>setup_arg_pages()</code>. This
function finalizes the location and access permissions of the stack.</td></tr><tr><td><pre><code>    r = vm_mmap(lbp-&gt;file, loadaddr, filesize,
                PROT_READ | PROT_WRITE | PROT_EXEC,
                MAP_FIXED | MAP_PRIVATE, 0);
    if (r &lt; 0)
        return r;
</code></pre></td><td>And now that that&#39;s official, let&#39;s
actually load something into memory. Yes folks, it&#39;s finally time to
call <code>vm_mmap()</code>. This function is basically identical to <code>libc</code>&#39;s
<code>mmap()</code>, and is the natural way to load a file into (page-aligned)
memory. Of course, normally when you call <code>mmap()</code> with a fixed load
address you need to handle the case where that address is already in
use. We don&#39;t need to worry about that here, as nothing is currently
in use. We&#39;re requesting that the memory be marked as readable,
writeable, and executable. Traditionally, programs will place their
code into non-writeable memory, and store variable data in memory that
is writeable but not executable. And that&#39;s definitely the safer way
to do things, but we can&#39;t be bothered with all that. After all, the
<code>.com</code> format hearkens back to a simpler time, when RAM was RAM, and
didn&#39;t come with geegaws like protection. Staying true to this
approach is a way of honoring our roots. Also, without metadata it&#39;s
basically impossible to know which parts of the file are code and
which are data, so we don&#39;t really have a choice, but it sounds better
if we claim it&#39;s because of our heritage.</td></tr><tr><td><pre><code>    install_exec_creds(lbp);
</code></pre></td><td>We now call <code>install_exec_creds()</code>, which
will set up the correct user ID vs effective user ID, in case it needs
to be changed.</td></tr><tr><td><pre><code>    /*finalize_exec(lbp);*/
</code></pre></td><td>The function <code>finalize_exec()</code> does something
with the stack&#39;s <code>rlimit</code> value. I&#39;m a little vague on its purpose
because it&#39;s somewhat new. In fact, it doesn&#39;t even exist on my
kernel version, which is why it&#39;s commented out in my code. If you&#39;re
running a 5.x kernel or later, feel free to restore it.</td></tr><tr><td><pre><code>    start_thread(current_pt_regs(), loadaddr,
                 current-&gt;mm-&gt;start_stack);
    return 0;
</code></pre></td><td>And then, at last, we call
<code>start_thread()</code>. This is the big one. We pass it a pointer to a
struct that contains the process&#39;s current register values, a pointer
to the top of the stack, and most importantly, the address for the
instruction pointer (which for us is the same thing as the load
address). The process is now ready to be scheduled. And, since we have
indeed made it this far, we return zero to indicate success.</td></tr></tbody></table>

<p>Phew. It&#39;s definitely not trivial, the process of setting up a
process. But as I said, all of the real work is done by other code.</p>



<p>Now in order to actually put this kernel module to the test, we&#39;ll
need a program to execute. Specifically, we need to create a binary
file in our flat, metadata-less format. One that actually does
something.</p>

<p>The down side of creating our own binary file format is that none of
our usual tools know anything about it. If we want to build a program
in this format, we&#39;re on our own here. But, our format is so utterly
simple that this shouldn&#39;t be hard. However, it does mean that we&#39;ll
need to use assembly code.</p>

<p>As is traditional, our minimal test program will be one that exits
with a status code of 42. In order to make a system call under 64-bit
Linux, we need to set <code>rax</code> to the system call number, and <code>rdi</code> to
the (first) argument, and then use the <code>syscall</code> instruction. The
<code>exit</code> system call is assigned the ID number 60, so this should be all
we need:</p>



<p>The <code>bin</code> format is <code>nasm</code>&#39;s name for its flat binary output format,
so what we get in our output file is nothing more than the assembly
code that we specified.</p>



<p>Our project has borne fruit. Behold: it works, and it&#39;s twelve bytes
in size. And we can verify that it is, in fact, our kernel module that
is actually loading and running it:</p>



<p>This delightfully unadulterated binary file is almost a quarter the
size of the smallest possible ELF executable, and less than a third
the size of the aout executable that inspired this (admittedly
ridiculous) exploration. And with zero bytes of overhead in our file
format, we can be confident that no binary using a format that
includes metadata can touch this one.</p>

<p>Although, of course, if we&#39;re going to start crowing about the size,
then we should probably go ahead and use the smallest possible
instructions.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>tiny.asm</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>BITS 64
	push	42
	pop	rdi
	mov	al, 60
	syscall
</code></pre></td></tr></tbody></table>

<p><code>rdi</code> can be initialized in only three bytes of machine code, and
<code>rax</code> can be initialized in even less, thanks to the fact that it is
pre-initialized to zero.</p>

<div><p>$ <b>nasm -f bin -o tiny.com tiny.asm</b></p></div>

<p>Seven bytes. <em>Seven!</em></p>

<p>To be clear, this is very much a nonstandard binary, and therefore it
in no way invalidates or supplants my 45-byte ELF executable (or the
aout executable). But it does make me very happy.</p>

<h3>Further Testing of the Waters</h3>

<p>We should try writing a few more programs, just to verify that our
kernel module really does work in general. Let&#39;s try a proper
hello-world program.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>hello.asm</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>BITS 64

	org	0x10000

	mov	eax, 1			; rax = 1: write system call
	mov	edi, eax		; rdi = 1: stdout file desc
	lea	rsi, [rel str]		; rsi = pointer to string
	mov	edx, strlen		; rdx = string length
	syscall				; call write(rdi, rsi, rdx)
	mov	eax, 60			; rax = 60: exit system call
	xor	edi, edi		; rdi = 0: exit code
	syscall				; call exit(rdi)

str:	db	&#39;hello, world&#39;, 10
strlen equ $ - str
</code></pre></td></tr></tbody></table>

<p>More assembly, yes, but it&#39;s very straightforward for assembly. It
compiles down to a 43-byte binary, and it does work:</p>

<div><p>$ <b>nasm -f bin -o hello.com hello.asm</b></p></div>

<p>By using shorter instructions, we could reduce this program to 35
bytes, perhaps less. I will leave that as an exercise to the
interested reader.</p>

<p>As long as our programs only use a fixed amount of data, we can
allocate space by just adding it to our binary file. If we need to
allocate space dynamically, however, then that&#39;s going to be a
problem. Why? Because our processes don&#39;t have a heap. Why not?
Because we didn&#39;t set one up in our loader. Oops.</p>

<h3>Version 0.2: On Having a Heap</h3>

<p>Let&#39;s address this oversight by going back to our kernel module and
adding a few more lines of code. It&#39;s actually pretty easy. We just
need to let the memory manager know what we want.</p>

<p>Most programs use a memory layout that looks something like this:</p>



<p>The sections are frequently broken up for the purpose of providing
different access rights. Code sections are marked executable but not
writeable, and the other sections are marked writeable and not
executable. The code and data sections have a constant size, while the
heap and the stack change in size as the program runs, with the heap
growing upwards and the stack growing downwards. (And if they meet in
the middle, then you&#39;ve run out of memory — although on a 64-bit
machine you&#39;ll run out of physical RAM long before that point.) For
historical reasons, the end of the heap is called the <em>program break</em>,
and the <code>brk</code> system call can be used to move it around. </p><p>If we&#39;re
being pedantic, we should note that access permissions are not
attached to the memory itself, but rather to the addresses. Different
address ranges can be mapped to the same physical memory but with
different permissions. This is not a distinction we need to worry
about here.</p>


<p>So let&#39;s tell the memory manager that we want our processes to enjoy
the benefits of a heap:</p>

<table><tbody><tr><td></td><td rowspan="2"><i>comfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    filesize = generic_file_llseek(lbp-&gt;file, 0, SEEK_END);</span>
<span>    generic_file_llseek(lbp-&gt;file, 0, SEEK_SET);</span>
    allocsize = PAGE_ALIGN(filesize);
<span></span>
<span>    current-&gt;mm-&gt;start_code = loadaddr;</span>
<span>    current-&gt;mm-&gt;end_code = current-&gt;mm-&gt;start_code + filesize;</span>
    current-&gt;mm-&gt;start_data = current-&gt;mm-&gt;end_code;
    current-&gt;mm-&gt;end_data = loadaddr + allocsize;
    current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;end_data;
    current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk;
<span></span>
<span>    r = setup_arg_pages(lbp, STACK_TOP, EXSTACK_DEFAULT);</span>
<span>    if (r)</span>
<span>        return r;</span>
</code></pre></td></tr></tbody></table>

<p>The only measurement we have available to us is the file size, which
we&#39;re using to determine the size of the code section. The
<code>PAGE_ALIGN</code> macro rounds a value up to the next page boundary. Since
we can&#39;t allocate a fractional number of memory pages, we can take
whatever padding we&#39;ll get at the page&#39;s end, and let that be our data
section. Our heap will then be located directly following this. It
starts off with a size of zero, which the program can then expand as
desired.</p>

<p>(There&#39;s no reason why we couldn&#39;t define a larger data section for
our binaries, by the way. We would just need to hard-code a size for
it. Perhaps, to stay true to the MS-DOS roots of our format, we should
allocate a data section of 640k. But this requires making a second
<code>vm_mmap()</code> call to allocate non-file-backed memory, so I&#39;ve chosen to
punt on that modification for the moment.)</p>

<table><tbody><tr><td></td><td rowspan="2"><i>comfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    r = vm_mmap(lbp-&gt;file, loadaddr, filesize,</span>
<span>                PROT_READ | PROT_WRITE | PROT_EXEC,</span>
<span>                MAP_FIXED | MAP_PRIVATE, 0);</span>
<span>    if (r &lt; 0)</span>
<span>        return r;</span>
    r = vm_brk(current-&gt;mm-&gt;start_brk, 0);
    if (r &lt; 0)
        return r;
</code></pre></td></tr></tbody></table>

<p>After memory has actually been allocated, we will set the process&#39;s
program break to its starting value. Our process should now have a
functional heap that the program can dynamically modify.</p>

<p>In order to test this new feature, I&#39;ve written an implementation of
<code>cat</code>, one that reads all of standard input into memory before doing
any output. It&#39;s not an interesting program beyond being a basic
demonstration of low-level heap allocation, so I won&#39;t go into it. If
you&#39;re curious, you can see the source here:
<a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb/cat.asm.txt"><code>cat.asm</code></a>. For now, we&#39;ll just note that it
succeeds at allocating memory at runtime:</p>

<p>On my machine, <code>/etc/mailcap</code> is a text file well over
64k in size.</p>
<div><p>$ <b>nasm -f bin -o cat.com cat.asm</b></p></div>

<p>This version of <code>cat</code> is not really a <code>cat</code> utility, however, as it
can only read from standard input. A proper <code>cat</code> program — and,
indeed, a majority of proper programs — will need to be able to open
files named on the command line. So how do we access the command-line
arguments?</p>

<p>Frankly, we can&#39;t, at least not as things stand. You see, when an ELF
binary runs, it has values for <code>argc</code>, <code>argv</code>, and <code>envp</code> placed at
the top of its stack. Surprise! Those values are put there by the
loader. Yes, this issue is also the responsiblity of our kernel
module.</p>

<p>So let&#39;s add support for this, too.</p>

<h3>Version 0.3: Leaving Room for Arguments</h3>

<p>To be sure, the strings that make up the command-line arguments are
present in our process&#39;s image — specifically, they&#39;re sitting in
memory just above the stack. (Which means, given that the stack is
currently empty, that the <code>rsp</code> register currently points to them.)
But this is no neat array of string pointers. It&#39;s just a lot of
strings, one after the other. A string of strings, if you will. Worse,
the environment variables come immediately after the command-line
arguments, without any indication of where one set ends and the other
begins. So they aren&#39;t really usable, as they stand.</p>

<p>At the absolute least, a program needs to know how many of the strings
are in each set. Well, it turns out that our kernel module has exactly
that information. In the <code>linux_binprm</code> struct (provided via the
argument to our callback function, remember) there are two fields
named <code>argc</code> and <code>envc</code>. These are the number of command-line
arguments and environment variables, respectively. In theory, if we
transmit these two values to the running program, that would be enough
for the code to safely access the data. Of course, if that&#39;s all we
did, then every <code>.com</code> program would need to trawl through their
string of strings, to determine where each item begins and ends. We
could just accept that as a fact of life for programmers using our
format, but since we&#39;re doing this work anyway, why not take the time
to do it right? We should provide our processes with <code>argv</code> and <code>envp</code>
arguments — neat arrays of pointers to the strings in question —
like all the cool binary formats do.</p>

<p>Since these two arrays don&#39;t currently exist, we&#39;ll need to reserve
some memory for them. It may feel intuitive to tap our newly-minted
heap, but for this it actually makes more sense to just take it off
the top of the stack. (In fact, these arrays can be seen as forming a
sort of zeroth stack frame.) The top of the stack is at the top of
memory, which is stored in the <code>linux_binprm</code> struct in the
intuitively-named field <code>p</code>. So we want to build arrays in the memory
immediately preceding this address, and then move the top of the stack
down to precede our arrays.</p>

<p>Note, however, that we cannot use familiar functions like <code>strlen()</code>
to walk through these strings. Why? Because the memory holding these
strings isn&#39;t owned by the kernel; it belongs to the process itself.
So far, we&#39;ve only been dealing with addresses in the process&#39;s
memory. We haven&#39;t tried to access that memory, except through other
functions, such as <code>vm_mmap()</code>. It can thus be easy to forget that
kernel memory and user memory exist in two different address spaces
(not to mention different permission rings). The kernel is allowed to
access user memory, of course, but it needs to be intentional about
it, and this requires some extra work.</p>

<p>Within our kernel module, we use the <code>__user</code> annotation to declare
pointers to user memory. And instead of using the <code>*</code> operator to
dereference such pointers, we have two special macros: <code>get_user()</code> to
read through a user pointer, and <code>put_user()</code> to write through one.
And the kernel provides a handful of convenient functions, like
<code>strnlen_user()</code>, that will operate on strings stored in user space.</p>

<p>Once we have gone through the strings and populated our two arrays,
we&#39;ll still need to communicate the values for <code>argc</code>, <code>argv</code>, and
<code>envp</code> to the program. The usual way to do this is to place them on
the stack, allowing the program to access them at its convenience.</p>

<p>So let&#39;s add all this to our kernel module. We&#39;ll start by defining a
separate function to handle the work of walking through the strings
and building the two arrays.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>comfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>/* Given argc + envc strings above the top of the stack, construct the
 * argv and envp arrays in the memory preceding, and then push argc,
 * argv, and envp onto the stack. Return the new stack top address.
 */
static unsigned long make_arrays(struct linux_binprm const *lbp)
{
    void* __user *sp;
    char* __user *argv;
    char* __user *envp;
    char __user *p;
    int i;

    p = (char __user *)lbp-&gt;p;
    envp = (char* __user *)ALIGN(lbp-&gt;p, sizeof *envp);
    envp = envp - (lbp-&gt;envc + 1);
    argv = envp - (lbp-&gt;argc + 1);
    sp = (void* __user *)argv - 3;

    current-&gt;mm-&gt;arg_start = (unsigned long)p;
    for (i = 0 ; i &lt; lbp-&gt;argc ; ++i) {
        put_user(p, argv + i);
        p += strnlen_user(p, MAX_ARG_STRLEN);
    }
    put_user(NULL, argv + i);
    current-&gt;mm-&gt;arg_end = (unsigned long)p;

    current-&gt;mm-&gt;env_start = (unsigned long)p;
    for (i = 0 ; i &lt; lbp-&gt;envc ; ++i) {
        put_user(p, envp + i);
        p += strnlen_user(p, MAX_ARG_STRLEN);
    }
    put_user(NULL, envp + i);
    current-&gt;mm-&gt;env_end = (unsigned long)p;

    put_user((void*)(unsigned long)lbp-&gt;argc, sp);
    put_user(argv, sp + 1);
    put_user(envp, sp + 2);

    return (unsigned long)sp;
}
</code></pre></td></tr></tbody></table>

<p>There&#39;s a fair bit of casting in this function because the kernel
tends to store user addresses as <code>unsigned long</code> values. This may
sound counterproductive, but it&#39;s somewhat natural given that kernel
code rarely dereferences such addresses. But our function wants to
work with them as pointer types, in order to take advantage of pointer
arithmetic. (We also have to cast <code>argc</code> into a pointer while we
briefly pretend that the stack is an array.)</p>

<p>With this function in our code, we just need to use it at the
appropriate time, after the stack has been created and its address has
been finalized.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>comfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    r = setup_arg_pages(lbp, STACK_TOP, EXSTACK_DEFAULT);</span>
<span>    if (r)</span>
<span>        return r;</span>
    current-&gt;mm-&gt;start_stack = make_arrays(lbp);
</code></pre></td></tr></tbody></table>

<p>In order to verify that all of these changes do in fact work, we can
write a couple more program, <a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb/echo.asm.txt"><code>echo.asm</code></a> and
<a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb/env.asm.txt"><code>env.asm</code></a>. Again, they aren&#39;t particularly
interesting in the details, so I won&#39;t dissect them here. But if
you&#39;re at all familiar with reading x86 assembly, they should be
relatively straightforward to understand.</p>

<div><p>$ <b>nasm -f bin -o echo.com echo.asm</b></p></div>

<h3>Take This Discussion of Practicality Outside</h3>

<p>At this point, we have created a binary format for the Linux kernel
that functions without metadata. Writing code for it is a bit of a
pain, though — we have to write everything in assembly, and none of
the standard tools work with our format.</p>

<p>Well, it so happens that there is something that we can do about that.
With some investment of effort, we can coax our familiar tools into
generating <code>.com</code> binaries, allowing us to use things like C compilers
once more. There&#39;s a number of steps to the whole journey, however, so
I&#39;ve decided to put the gory details in a separate appendix, and I
encourage you to peruse it if you are at all curious.</p>

<p><a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb-app.html">Click here to check out the appendix.</a></p>

<p>But for now, I don&#39;t want to be sidelined by meandering distractions
like &#34;usability&#34;. The focus of this essay, after all, is using kernel
modules to let us produce working binaries that are <em>really teensy</em>.
We have already produced a valid seven-byte executable file, and it is
undeniably a thing of beauty. But a question immediately presents
itself.</p>

<p>Could it be even smaller?</p>

<p>Well, we can&#39;t shrink the program itself down any further. It&#39;s as
small as it can get. But maybe we could get by with a simpler program,
if we changed the binary loader a little bit. Nothing too ridiculous,
mind you. But I&#39;m thinking … what if our binaries could just
automatically exit when they came to the end, instead of forcing the
programmer to use the <code>exit</code> system call? I mean, a majority of
programming languages work that way, right? If a Python program makes
it to the end of the file, it just quietly exits. Could we make our
binaries do that as well?</p>

<h3>Version 0.?: Hello, I Must Be Going</h3>

<p>We absolutely can. What we would need to do is append a few extra
bytes of machine code to the end of our file image. This code will
only be executed if the program would have crashed otherwise, so
one could argue that this is a purely beneficial modification to our
binary format.</p>

<p>However, it does mean that the code size will now be larger than the
file size. This alters the addresses of how we lay out memory, which
could mess with programmers&#39; assumptions, given that programs are
generally written in low-level assembly.</p>

<p>Rather than calling this a minor feature upgrade, I therefore feel
compelled to fork the code base at this point, and give this file
format a new name, so as not to muddy the until-now transparent ABI of
the <code>.com</code> format.</p>

<p><img src="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb/poster.jpg" alt="" width="190" height="250"/>Originally, I was planning on calling this new, extended
format &#34;dot-e-com&#34;, or &#34;dot-x-com&#34; or something equally trite.
However, after some reflection, I decided to be less boring and
instead I called it the &#34;keep-calm&#34; (and carry on) format. This name
refers naturally to the fact that you no longer have to fret about
setting up mandatory instructions for exiting. Instead you can just
carry on, right up to the end of the program.</p>

<p>However, I decided I didn&#39;t like using <code>.calm</code> as a filename
extension. It was too easy to confuse with <code>.com</code> when said aloud. So
I instead chose to adopt the Unicode character for a crown as the
extension: <code>.</code>♚. (This is U+265A, one of the Unicode chess piece
glyphs.)</p>

<p>Now I realize that some people may find it a bit controversial to use
a non-ASCII symbol in a filename extension. But hey, the Unicode
Consortium has gone to a great deal of trouble to standardize
thousands upon thousands of glyphs, and we programmers continue to
draw upon the same 100 or so characters for our symbols, keywords, and
filenames. All these others are just sitting around, neglected. We
should start using them more. I mean, why not? Heck, put emojis in
your filenames. I&#39;m not your dad. </p><p>Alan, if you&#39;re reading this: I
forbid you to put emojis in your filenames.</p>


<table><tbody><tr><td></td><td rowspan="2"><i>calmfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    ext = strrchr(lbp-&gt;filename, &#39;.&#39;);</span>
    <s>if (!ext || strcmp(ext, &#34;.com&#34;))</s>
    if (!ext || strcmp(ext, &#34;.♚&#34;))
<span>        return -ENOEXEC;</span>
</code></pre></td></tr></tbody></table>

<p>(If for whatever reason you don&#39;t trust your compiler to properly
handle Unicode characters, you can instead assume a UTF-8 environment
and write the second argument to <code>strcmp()</code> as <code>&#34;.\342\231\232&#34;</code>.)</p>

<p>Anyway. The machine code that we want to append to the program can
be squeezed into eight bytes:</p>

<table><tbody><tr><td></td><td rowspan="2"><i>epilog.lst</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>00000000 31FF           xor	edi, edi
00000002 678D473C       lea	eax, [edi + 60]
00000006 0F05           syscall
</code></pre></td></tr></tbody></table>

<p>That&#39;s convenient, as it means that we can stuff it all into a <code>long</code>
value, which can be stored in user memory with a simple <code>put_user()</code>.
The next change we need to make is to reserve an extra eight bytes in
the layout that we report to the memory manager.</p>

<table><tbody><tr><td></td><td rowspan="2"><i>calmfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    filesize = generic_file_llseek(lbp-&gt;file, 0, SEEK_END);</span>
<span>    generic_file_llseek(lbp-&gt;file, 0, SEEK_SET);</span>
    <s>allocsize = PAGE_ALIGN(filesize);</s>
    codesize = filesize + 8;
    allocsize = PAGE_ALIGN(codesize);
<span></span>
<span>    current-&gt;mm-&gt;start_code = loadaddr;</span>
    <s>current-&gt;mm-&gt;end_code = current-&gt;mm-&gt;start_code + filesize;</s>
    current-&gt;mm-&gt;end_code = current-&gt;mm-&gt;start_code + codesize;
<span>    current-&gt;mm-&gt;start_data = current-&gt;mm-&gt;end_code;</span>
<span>    current-&gt;mm-&gt;end_data = loadaddr + allocsize;</span>
<span>    current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;end_data;</span>
<span>    current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk;</span>
</code></pre></td></tr></tbody></table>

<p>We will still use <code>filesize</code> when we call <code>vm_mmap()</code>, since we can
only map what&#39;s in the file. And here we hit a subtle point. Due to
the fact that memory is always mapped in page-sized chunks, we
typically get more memory than we ask for from <code>vm_mmap()</code> — but not
always. If the binary file happens to be exactly (or nearly exactly)
page-sized, then there won&#39;t be enough memory mapped for our
eight-byte epilog. So, we need to check for this edge case, and when
it happens we need to call <code>vm_mmap()</code> a second time to reserve a page
of anonymous memory immediately following:</p>

<table><tbody><tr><td></td><td rowspan="2"><i>calmfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    r = vm_mmap(lbp-&gt;file, loadaddr, filesize,</span>
<span>                PROT_READ | PROT_WRITE | PROT_EXEC,</span>
<span>                MAP_FIXED | MAP_PRIVATE, 0);</span>
<span>    if (r &lt; 0)</span>
<span>        return r;</span>
    if (allocsize != PAGE_ALIGN(filesize)) {
        r = vm_mmap(NULL, loadaddr + PAGE_ALIGN(filesize), PAGE_SIZE,
                    PROT_READ | PROT_WRITE | PROT_EXEC,
                    MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, 0);
        if (r &lt; 0)
            return r;
    }
<span>    r = vm_brk(current-&gt;mm-&gt;start_brk, 0);</span>
<span>    if (r &lt; 0)</span>
<span>        return r;</span>

    put_user(0x050F3C478D67FF31, (long __user *)(loadaddr + filesize));
</code></pre></td></tr></tbody></table>

<p>And of course that ridiculous-looking 64-bit magic number at the
bottom is the little-endian encoding of our epilog.</p>

<p>We don&#39;t need to <code>rmmod</code> the previous module
this time, since we are defining a new binary format. The two can be
active simultaneously without interfering with each other.</p>


<p>Of the programs we&#39;ve currently written, <a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb/cat.asm.txt"><code>cat.asm</code></a>
is the best candidate to benefit from this change, having twelve
bytes&#39; worth of machine code that can be omitted with the new format:</p>

<p>To enter a Unicode glyph at the terminal, type
Ctrl-Shift-U, followed by the codepoint number, and then Enter. The
sequence for the crown symbol is thus Ctrl-Shift-U 2 6 5 A Enter.</p>


<p>The only down side of this change is that the exit status no longer
reports error values from read failures.</p>

<p>No, that&#39;s not true. The other, more signficant, down side of this
change is that this new feature can&#39;t be used to improve the size of
our seven-byte executable! That program still has to explicitly exit,
in order to exit with a non-zero status. (And the non-zero exit is how
we can be certain that the program actually ran, and wasn&#39;t, say,
mistakenly handled as a do-nothing shell script.)</p>

<p>Well, it so happens that I have the perfect answer to both of these
concerns.</p>

<h3>Version 0.??: This Is Not At All a Ridiculous Idea</h3>

<p>The way to address these issues is to modify our epilog so that
instead of always returning zero, it uses the value at the top of the
stack as the exit code. Additionally (and here&#39;s the brilliant part),
the loader will set up our stack so that it starts out with a zero
entry at the top. That way, if the program is well-behaved and pops
everything off the stack that it pushed, it will automatically exit
with a successful zero status — but it can also quit prematurely at
any time, leaving an error code on the stack that will be
automatically transmitted to the user. This is clearly an improvement
to our original idea, right? I think it makes perfect sense, and isn&#39;t
at all contrived.</p>

<p>Fortunately, this new epilog will still fit snugly into eight bytes:</p>

<table><tbody><tr><td></td><td rowspan="2"><i>epilog.lst</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code>00000000 5F             pop	rdi
00000001 B83C000000     mov	eax, 60
00000006 0F05           syscall
</code></pre></td></tr></tbody></table>

<p>This improvement requires only a three-line change to our kernel
module:</p>

<table><tbody><tr><td></td><td rowspan="2"><i>calmfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    r = vm_brk(current-&gt;mm-&gt;start_brk, 0);</span>
<span>    if (r &lt; 0)</span>
<span>        return r;</span>
<span></span>
    <s>put_user(0x050F3C478D67FF31, (long __user *)(loadaddr + filesize));</s>
    put_user(0x050F0000003CB85F, (long __user *)(loadaddr + filesize));
    current-&gt;mm-&gt;start_stack -= sizeof(void*);
    put_user(0, (long __user *)current-&gt;mm-&gt;start_stack);
<span></span>
<span>    install_exec_creds(lbp);</span>
</code></pre></td></tr></tbody></table>



<p>Once we&#39;ve verified that it builds, let&#39;s revisit our current-best
seven-byte binary. That same program should work just as well in our
new format:</p>



<p>But it should also work if we push the number 42 onto the stack
and just leave it there. In other words, if the program just
consists of the <code>push</code> instruction.</p>



<p>Two bytes. <em>Two bytes!</em> Our program is the size of a single
machine-language instruction! This is the limit! There&#39;s no way to
make a working program any smaller than that!</p>

<p>Well, I mean. I don&#39;t think there is. That is, obviously, there does
exist a number that is less than two, so <em>in theory</em> it could be
smaller, but how would that even be possible? Like, if there was a
one-byte instruction for storing an arbitrary value on the stack, then
maybe. But there isn&#39;t. The only other realistic possibility I can
think of would be if the binary file could make use of some metadata
to request a particular value to place on the stack initially, instead
of having it be a hard-coded zero value. But there is no metadata in
our file! That&#39;s the whole point of the format, right? I mean, of
course, all files have some metadata; that&#39;s just the nature of
filesystems. You could argue that the filename itself counts as
metadata. I mean, we are basically using the filename as metadata
already, I suppose. We&#39;re looking at the extension to determine the
file type. So you could in theory potentially maybe argue that, just
for example, using the character immediately preceding the extension
would also be valid metadata, and that could be defined to specify
optional behavior, like the default stack value for example …</p>

<table><tbody><tr><td></td><td rowspan="2"><i>calmfile.c</i></td><td></td></tr><tr><td></td><td></td></tr><tr><td colspan="3"><pre><code><span>    put_user(0x050F0000003CB85F, (long __user *)(loadaddr + filesize));</span>
<span>    current-&gt;mm-&gt;start_stack -= sizeof(void*);</span>
    <s>put_user(0, (long __user *)current-&gt;mm-&gt;start_stack);</s>
    put_user(ext[-1], (long __user *)current-&gt;mm-&gt;start_stack);
</code></pre></td></tr></tbody></table>

<p><code>ext</code> is the pointer to the filename&#39;s extension, that we initialized
way back at the top of the function, so <code>ext[-1]</code> is the character
directly to the left of the dot. Don&#39;t get me wrong; I fully realize
that this is indefensibly contrived — especially since, as it turns
out, the ASCII character for 42 is the asterisk. That&#39;s quite an
inconvenient character to have in a filename.</p>

<p>But having come this far, how can I <em>not</em> continue?</p>



<p>Okay.</p>



<p>Beat <strong>that</strong>, Internet Random Person™!</p>

<div><p><img src="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb/cartoon2.jpg"/></p></div>

<p><a href="https://the.scapegoat.dev/llms-are-kryptonite-for-legacy-code-but-dont-let-them-touch-it/mopb-app.html">(appendix)</a></p>

<hr/>
<small><a href="http://www.muppetlabs.com/~breadbox/txt/">Texts</a></small>
</div>
  </body>
</html>
