<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evanjones.ca/hugepages-are-a-good-idea.html">Original</a>
    <h1>Huge pages are a good idea</h1>
    
    <div id="readability-page-1" class="page"><div>

<h3>[ 2023-January-16 11:46 ]</h3>
<p>Nearly all programs are written to access <em>virtual</em> memory addresses, which the CPU must translate to <em>physical</em> addresses. These translations are usually fast because the mappings are cached in the CPU&#39;s <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">Translation Lookaside Buffer (TLB)</a>. Unfortunately, virtual memory on x86 has used a 4 kiB page size since the 386 was released in 1985, when computers had a bit less memory than they do today. Also unfortunately, TLBs are pretty small because they need to be fast. For example, <a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen_4">AMD&#39;s Zen 4 Microarchitecture</a>, which first shipped in September 2022, has a first level data TLB with 72 entries, and a second level TLB with 3072 entries. This means when an application&#39;s working set is larger than approximately 4 kiB × 3072 = 12 MiB, some memory accesses will require page table lookups, multiplying the number of memory accesses required. This is a brand-new CPU, with one of the biggest TLBs on the market, so most systems will be worse. Using larger virtual memory page sizes (aka huge pages) can reduce page mapping overhead substantially. Since RAM is so much larger than it was in 1985, a larger page size seems like obviously a good idea to me.</p>

<p>In 2021, Google published a <a href="https://www.usenix.org/conference/osdi21/presentation/hunter">paper about making their malloc implementation (TCMalloc) huge page aware (called Temeraire)</a>. They report this improved average requests-per-second throughput across their fleet by 7%, by increasing the amount of memory that is backed by huge pages. This made me curious about the &#34;best case&#34; performance benefits. I <a href="https://github.com/evanj/hugepagedemo">wrote a small program</a> that allocates 4 GiB, then randomly reads uint64 values from it. On my Intel 11th generation Core i5-1135G7 (Tiger Lake) from 2020, using 2 MiB huge pages is 2.9× faster. I also tried 1 GiB pages, which is 3.1× faster than 4 kiB pages, but only 8% faster than 2 MiB pages. My conclusion: Using madvise() to get the kernel to use huge pages seems like a relatively easy performance win for applications that use a large amount of RAM.</p>

<p>Unfortunately, using larger pages is not without its disadvantages. Notably, when the Linux kernel&#39;s transparent huge page implementation was first introduced, it was enabled by default, which caused many performance problems. See the section below for more details. Today&#39;s default to use huge pages only for applications that opt-in (aka madvise) should improve this. The kernel&#39;s policies for managing huge pages have also changed since then, and are hopefully better now. At the very least, the fact that Google uses transparent huge pages for all their applications is some evidence that this can work for a wide variety of workloads.</p>

<p>The second problem with larger page sizes is software incompatibility, since so much software is only tested on x86 with 4 kiB pages. Linux on ARM64 used to default to 64 kiB pages. However, this caused many problems (e.g. <a href="https://github.com/dotnet/runtime/issues/7404">dotnet</a>, <a href="https://github.com/golang/go/issues/10180">Go</a>, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1301788">Chrome</a>, <a href="https://github.com/jemalloc/jemalloc/issues/467">jemalloc</a>, <a href="https://github.com/AsahiLinux/docs/wiki/Broken-Software">Asahi Linux list of broken software</a>). It appears that around 2020 most distributions switched to 4 kiB pages to avoid these problems (e.g. <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1978730">RedHat RHEL9 change in 2021</a>, <a href="https://wiki.ubuntu.com/ARM64/performance">Ubuntu note about the page size change</a>).</p>


<h2>Page size historical details</h2>

<p>Other CPU architectures have made different page size choices. Notably, iOS and Mac OS X on ARM64 uses 16 kiB pages (ARM64 aka aarch64 supports 4, 16, and 64 kiB pages, although specific CPUs <a href="https://developer.arm.com/documentation/101811/0102/Translation-granule">will only support some of them</a>). Alpha and Sparc used 8 kiB pages. PowerPC on Linux uses 64 kiB pages, although <a href="https://fedoraproject.org/wiki/Changes/Power4kPageSize">Redhat/Fedora are considering switching to 4 kiB due to the same compatibility issues</a>. See <a href="https://devblogs.microsoft.com/oldnewthing/20210510-00/?p=105200">page sizes used by Windows on various processors</a>.</p>


<h2>Latency and throughput problems with transparent huge pages</h2>

<p>The Linux kernel&#39;s implementation of transparent huge pages has been the source of performance problems. When introduced, it was initially enabled for all processes and memory regions by default. This caused a large number of problems, which eventually caused the kernel&#39;s default to change to <code>madvise</code>, where programs have to opt-in to use huge pages (see <a href="https://blog.nelhage.com/post/transparent-hugepages/">Nelson Elhage&#39;s summary (2017)</a>, and <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1703742">Ubuntu bug that changed the default (2017/released 2019)</a>.</p>

<p>The performance problems are rare high latency (e.g. operations being substantially slower than normal), throughput issues due to excess CPU consumption of the kernel background tasks, or substantial increases in memory usage. Some examples are <a href="http://structureddata.org/2012/06/18/linux-6-transparent-huge-pages-and-hadoop-workloads/">Hadoop (2012)</a>, <a href="https://www.percona.com/blog/2014/07/23/why-tokudb-hates-transparent-hugepages/">TokuDB/MySQL (2014)</a>, <a href="https://www.digitalocean.com/blog/transparent-huge-pages-and-alternative-memory-allocators">Redis/jemalloc (2015)</a>, <a href="https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/">TiKV/TiDB (2020)</a>. The problems seem to fall into the following categories:</p>

<ul>
<li>Increasing memory usage by making fragmentation worse: using transparent huge pages rounds allocations up to 2 MiB. If an application allocates many separate memory regions, this can cause lots of memory to be wasted. Most of the problems have been where an application uses a large amount of memory, then frees a lot of it, leaving &#34;holes&#34; in the large pages. Sometimes the kernel&#39;s transparent page policy can decide to turn these back into huge pages, which causes the memory usage to increase. For example, see a <a href="https://github.com/golang/go/issues/8832">Go bug (2015)</a> and the <a href="https://bugzilla.kernel.org/show_bug.cgi?id=93111">corresponding kernel bug report (2015)</a>. The fix for Go was to <a href="https://go-review.googlesource.com/c/go/+/15191">only return memory on huge page granularity</a>. This also happened to <a href="https://www.digitalocean.com/blog/transparent-huge-pages-and-alternative-memory-allocators">Redis with jemalloc (2015)</a></li>

<li>malloc implementations that are not huge page aware may add more kernel CPU overhead: When returning memory to the operating system, if the memory allocator is not aware of huge pages, it may return part of a huge page. This causes the kernel to split the huge page back into separate 4 kib pages. This adds overhead, and also fragments memory, making fewer huge pages available, causing the kernel to do more work the next time it tries to allocate a huge page. This <a href="https://www.percona.com/blog/2014/07/23/why-tokudb-hates-transparent-hugepages/">article about TokuDB from 2014 suggests that it ran into this problem with jemalloc</a>. The good news is that it now seems like all major malloc implementations (jemalloc, tcmalloc, mimalloc, and glibc malloc) all have some huge page support, which should make this less bad.</li>

<li>slow memory allocations due to fragmentation (latency): When trying to allocate a huge page, the kernel may spend time moving memory around to free up a page. See a <a href="https://groups.google.com/g/mechanical-sympathy/c/sljzehnCNZU/m/s_0K3hSRAQAJ">detailed thread about impacts on the JVM (2017)</a>. The kernel&#39;s current default is to only do this for regions that have opted in with madvise. This should mean that other processes won&#39;t be penalized too much by this, but it does mean the process that called madvise could be stalled briefly when allocating new pages. One way to avoid this is to immediately touch every huge page in an allocation, to cause the cost to happen up front. This would work well for allocations that are made at program startup, such as caches.</li>


<li>fork() e.g. Redis: Calling fork marks all of the process&#39;s pages as copy-on-write. Then when a single byte on a page is modified, the page must be copied. Redis uses fork to create a read-only &#34;snapshot&#34; of memory, when writing a checkpoint to disk. Since huge pages are 512X larger than &#34;normal&#34; pages, the time to copy a page increases by 512X. It also means the memory usage is higher, since modifying a single byte causes 2 MiB to be copied, instead of only 4 kiB. Using fork() in this way with huge pages seems like a bad idea. See <a href="http://antirez.com/news/84">details about a workload that causes this behavior (2014)</a>.</li>
</ul>



<h2>References</h2>

<ul>
<li><a href="https://github.com/evanj/hugepagedemo">Huge Page Demo Evan Jones 2022-01-18</a>: My huge page demonstration program.</li>
<li><a href="https://www.sigarch.org/larger-pages/">Larger Pages: Richard Sites 2022-05-06</a>: Argues we should increase the minimum page size to 64 kiB, and maintain compatibility by using access flags on 4 kiB sub-pages.</li>
<li><a href="https://stackoverflow.com/a/50033983">Stack Overflow: Why is the page size 4 KB? Answer by Hadi Brais 2018-04-26</a>: a great look at the history of why 4 kiB pages were chosen.</li>
<li><a href="https://rigtorp.se/hugepages/">Using huge pages on Linux: Erik Rigtorp 2020-10-08</a>: A hash table benchmark in C++ with results for both transparent and explicit huge pages.</li>
<li><a href="https://rigtorp.se/hugepages/">Reliably allocating huge pages in Linux: Francesco Mazzoli 2021-11-22</a>: Includes C code describing how to verify if an address is a huge page.</li>
<li><a href="https://en.wikichip.org/wiki/intel/microarchitectures/coffee_lake">Intel Coffee Lake Microarchitecture (2017 aka Core 9th gen)</a>: L1 Data TLB: 64 entries for 4 kiB pages / 32 entries for 2 MiB pages / 4 entries for 1 GiB pages ; L2 unified TLB: 1536 for 4 kiB/2 MiB pages; 16 entries for 1 GiB pages.</li>
&gt;git</ul>

</div></div>
  </body>
</html>
