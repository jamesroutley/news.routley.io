<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/golang/go/issues/58894">Original</a>
    <h1>Add opt-in transparent telemetry to Go toolchain</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <p dir="auto">In February I posted a series of blog posts defining <a href="https://research.swtch.com/telemetry" rel="nofollow"><em>Transparent Telemetry</em></a>, and we had a lively discussion on <a data-error-text="Failed to load title" data-id="4835204" data-permission-text="Title is private" data-url="https://github.com/golang/go/discussions/58409" data-hovercard-type="discussion" data-hovercard-url="/golang/go/discussions/58409/hovercard" href="https://github.com/golang/go/discussions/58409">#58409</a>. In the original posts, the design was opt-out. Based on that discussion as well as private discussions with long-time contributors and users, I <a href="https://research.swtch.com/telemetry-opt-in" rel="nofollow">revised the design</a> to be opt-in.</p>
<p dir="auto">I propose that we add opt-in transparent telemetry to the Go toolchain as described in those posts, specifically “<a href="https://research.swtch.com/telemetry-design" rel="nofollow">The Design of Transparent Telemetry</a>.” Transparent Telemetry has the following key properties:</p>
<ul dir="auto">
<li>The decisions about what metrics to collect are made in an open, public process.</li>
<li>The collection configuration is automatically generated from the actively tracked metrics: no data is collected that isn’t needed for the metrics.</li>
<li>The collection configuration is served using a tamper-evident transparent log, making it very difficult to serve different collection configurations to different systems.</li>
<li>The collection configuration is a cacheable, proxied Go module, so any privacy-enhancing local Go proxy already in use for ordinary modules will automatically be used for collection configuration.</li>
<li>Uploaded reports only include total event counts over a full week, not any kind of time-ordered event trace.</li>
<li>Uploaded reports do not include user IDs, machine IDs, or any other kind of ID.</li>
<li>Uploaded reports only contain strings that are already known to the collection server: counter names, program names, and version strings repeated from the collection configuration, along with the names of functions in specific, unmodified Go toolchain programs for stack traces. The only types of non-string data in the reports are event counts, dates, and line numbers.</li>
<li>IP addresses exposed by the HTTP session that uploads the report are not recorded with the reports.</li>
<li>Thanks to sampling, only a constant number of uploaded reports are needed to achieve a specific accuracy target, no matter how many installations exist. Specifically, only about 16,000 reports are needed for 1% accuracy at a 99% confidence level. This means that as new systems are added to the system, each system reports less often. Exactly how often will depend on how many systems opt in.</li>
<li>The aggregate computed metrics are made public in graphical and tabular form.</li>
<li>The full raw data as collected is made public, so that project maintainers have no proprietary advantage or insights in their role as the direct data collector.</li>
<li>The system is off by default and requires an explicit opt-in.</li>
</ul>
<p dir="auto">Please note, as described in the <a href="https://research.swtch.com/telemetry-intro#why" rel="nofollow">Why Telemetry?</a> section of the intro post, that telemetry addresses a different kind of problem than bug reports and surveys. In particular, relying on bug reports is not sufficient to identify problems that don&#39;t obviously impact functionality, including performance problems, and surveys are not sufficient to identify the variety of usage and contexts where Go is used and which would inform prioritization of effort.</p>
<p dir="auto">There is <a href="https://research.swtch.com/sample" rel="nofollow">good reason to believe</a> that with even tens of thousands of users opted in, we should be able to get helpful data. It will not be as complete as the opt-out system, but it should be good enough. As described in the <a href="https://research.swtch.com/telemetry-opt-in#decide" rel="nofollow">Can We Still Make Good Decisions?</a> section of the opt-in post, there will be certain biases in the data based on who is more likely to opt in. Once we have data, it would make sense to compare “technical demographics” like operating system and editor against the annual Go survey and Stack Overflow surveys. If there is significant skew, we could look into reweighting the data as standard polls do (<a href="https://en.wikipedia.org/wiki/Iterative_proportional_fitting" rel="nofollow">https://en.wikipedia.org/wiki/Iterative_proportional_fitting</a>).</p>
<p dir="auto">For examples of the kinds of questions we&#39;d use telemetry to answer and the kinds of decisions those answers would inform (but not decide directly), see “<a href="https://research.swtch.com/telemetry-uses" rel="nofollow">Use Cases for Transparent Telemetry</a>”.</p>
      </div>
</div></div>
  </body>
</html>
