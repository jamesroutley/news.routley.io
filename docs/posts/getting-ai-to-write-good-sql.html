<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloud.google.com/blog/products/databases/techniques-for-improving-text-to-sql">Original</a>
    <h1>Getting AI to write good SQL</h1>
    
    <div id="readability-page-1" class="page"><div jsname="tx2NYc"><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb"><p><span>Organizations depend on fast and accurate data-driven insights to make decisions, and SQL is at the core of how they access that data. With Gemini, Google can generate SQL directly from natural language — a.k.a. text-to-SQL. This capability increases developer and analysts’ productivity and empowers non-technical users to interact directly with the data they need.</span></p>
<p><span>Today, you can find text-to-SQL capabilities in many Google Cloud products:</span></p>
<ul>
<li>
<p><strong>BigQuery Studio</strong><span> in the </span><a href="https://cloud.google.com/bigquery/docs/write-sql-gemini#generate_sql_from_a_comment"><span>SQL Editor</span></a><span> and </span><a href="https://cloud.google.com/bigquery/docs/write-sql-gemini#use_the_sql_generation_tool"><span>SQL Generation tool</span></a><span>, and within the </span><strong>Data Canvas</strong><span> </span><a href="https://cloud.google.com/blog/products/data-analytics/using-bigquery-data-canvas-a-deep-dive?e=48754805#:~:text=powered%20by%20Gemini-,2.%20Generate%20SQL,-You%20can%20also"><span>SQL node</span></a></p>
</li>
<li>
<p><span>&#34;Help me code&#34; functionality in </span><a href="https://cloud.google.com/sql/docs/mysql/write-sql-gemini"><strong>Cloud SQL Studio</strong></a><strong> (</strong><span>Postgres, MySQL and SQLServer), </span><strong>AlloyDB Studio</strong><span> and </span><strong>Cloud Spanner Studio</strong></p>
</li>
<li>
<p><strong>AlloyDB AI</strong><span> with its direct natural language interface to the database, currently available as a public preview</span></p>
</li>
<li>
<p><span>Through </span><strong>Vertex AI</strong><span>, which lets you access the Gemini models that are the basis for these products directly</span></p>
</li>
</ul>
<p><span>Recently, powerful large language models (LLMs) like Gemini, with their abilities to reason and synthesize, have driven remarkable advancements in the field of text-to-SQL. In this blog post, the first entry in a series, we explore the technical internals of Google Cloud&#39;s text-to-SQL agents. We will cover state-of-the-art approaches to context building and table retrieval, how to do effective evaluation of text-to-SQL quality with LLM-as-a-judge techniques, the best approaches to LLM prompting and post-processing, and how we approach techniques that allows the system to offer virtually certified correct answers.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Text-to-SQL_at_Google_Cloud.max-1800x1800.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Text-to-SQL_at_Google_Cloud.max-1800x1800.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Text-to-SQL_at_Google_Cloud.max-1800x1800.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Text-to-SQL_at_Google_Cloud.max-1800x1800.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>The ‘Help me code’ feature in Cloud SQL Studio generates SQL from a text prompt</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb"><h3><strong>The challenges of text-to-SQL technology</strong></h3>
<p><span>Current state-of-the-art LLMs like Gemini 2.5 have reasoning capabilities that make them good at translating complex questions posed in natural language to functioning SQL, complete with joins, filters, aggregations and other difficult concepts.</span></p>
<p><span>To see this in action you can do a simple test in </span><a href="https://cloud.google.com/generative-ai-studio"><span>Vertex AI Studio</span></a><span>. Given the prompt </span><span>&#34;I have a database schema that contains products and orders. Write a SQL query that shows the number of orders for shoes&#34;</span><span>, Gemini produces SQL for a hypothetical schema:</span></p></div></section><section><section><div jscontroller="vkZm2d" jsaction="rcuQ6b:npT2md" data-text-to-copy="SELECT COUNT(DISTINCT o.order_id) AS NumberOfShoeOrders FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE p.product_name LIKE &#39;%shoe%&#39;." soy-skip="" ssk="4:dXrt"><div jscontroller="M2lJBf" jsaction="rcuQ6b:npT2md" data-enable-content-editable-input-style="false" data-enable-line-wrapping="" data-read-only=""><div data-loadingmessage="Loading..." jscontroller="GFartf" jsaction="animationend:kWijWc;dyRcpb:dyRcpb" data-active="true" jsname="aZ2wEe"><p>Loading...</p><div jsname="Hxlbvc"><div><div></div><div></div><div></div></div><div><div></div><div></div><div></div></div><div><div></div><div></div><div></div></div><div><div></div><div></div><div></div></div></div></div></div></div></section></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb"><p><span>Great, this is a good looking query. But what happens when you move beyond this trivial example, and use Gemini for text-to-SQL against a real world database and on real-world user questions? It turns out that the problem is more difficult. The model needs to be complemented with methods to: </span></p>
<ol>
<li>
<p><span>provide business-specific context</span></p>
</li>
<li>
<p><span>understand user intent</span></p>
</li>
<li>
<p><span>manage differences in SQL dialects</span></p>
</li>
</ol>
<p><span>Let’s take a look at each of these challenges. </span></p>
<p><strong>Problem #1: Provide business-specific context</strong></p>
<p><span>Just like data analysts or engineers, LLMs need significant amounts of knowledge or &#34;context&#34; to generate accurate SQL. The context can be both explicit (what does the schema look like, what are the relevant columns, and what does the data itself look like?) or more implicit (what is the precise semantic meaning of a piece of data? what does it mean for the specific business case?).</span></p>
<p><span>Specialized model training, or fine tuning, is typically not a scalable solution to this problem. Training on the shape of every database or dataset, and keeping up with schema or data changes, is both difficult and cost-prohibitive. Business knowledge and semantics are often not well documented in the first place, and difficult to turn into training data.</span></p>
<p><span>For example, even the best DBA in the world would not be able to write an accurate query to track shoe sales if they didn&#39;t know that </span><code>cat_id2 = &#39;Footwear&#39;</code><span> in a </span><code>pcat_extension</code><span> table means that the product in question is a kind of shoe. The same is true for  LLMs.</span></p>
<p><strong>Problem #2: Understanding user intent</strong></p>
<p><span>Natural language is less precise than SQL. An engineer or analyst faced with an ambiguous question can detect that they need more information and go back and ask the right follow-up questions. An LLM, on the other hand, tends to try to give you an answer, and when the question is ambiguous, can be prone to hallucinating.</span></p>
<p><span>Example: Take a question like &#34;What are the best-selling shoes?&#34; Here, one obvious point of ambiguity is what &#34;best selling&#34; actually means in the context of the business or application — the most ordered shoes? The shoe brand that brought in the most money? Further, should the SQL count returned orders? And how many kinds of shoes do you want to see in the report? etc. </span></p>
<p><span>Further, different users need different kinds of answers. If the user is a technical analyst or a developer asking a vague question, giving them a reasonable, but perhaps not 100% correct SQL query is a good starting point. On the other hand, if the user is less technical and does not understand SQL, providing precise, correct SQL is more important. Being able to reply with follow-up questions to disambiguate, explaining the reasoning that went into an answer, and guiding the user to what they are looking for is key.</span></p>
<p><strong>Problem #3: Limits of LLM generation</strong></p>
<p><span>Out of the box, LLMs are particularly good at tasks like creative writing, summarizing or extracting information from documents. But some models can struggle with following precise instructions and getting details exactly right, particularly when it comes to more obscure SQL features. To be able to produce correct SQL, the LLM needs to adhere closely to what can often turn into complex specifications.</span></p>
<p><span>Example: Consider the differences between SQL dialects, which are more subtle than differences between programming languages like Python and Java. As a simple example, if you&#39;re using BigQuery SQL, the correct function for extracting a month from a timestamp column is </span><code>EXTRACT(MONTH FROM timestamp_column)</code><span>. But if you are using MySQL, you use </span><code>MONTH(timestamp_column)</code><span>.</span></p>
<h3><strong>Text-to-SQL techniques</strong></h3>
<p><span>At Google Cloud, we’re constantly evolving our text-to-SQL agents to improve their quality. To address the problems listed above, we apply a number of techniques.</span></p>
<div>
<div>
<div>
<div>
<div>
<div>
<div><table><colgroup><col/><col/></colgroup>
<tbody>
<tr>
<td>
<p><strong>Problem</strong></p>
</td>
<td>
<p><strong>Solutions</strong></p>
</td>
</tr>
<tr>
<td>
<p><span>Understanding schema, data and business concepts</span></p>
</td>
<td>
<ul>
<li>
<p><strong>Intelligent retrieval</strong><span> and ranking of datasets, tables and columns, based on semantic similarity.</span></p>
</li>
<li>
<p><strong>In-context-learning</strong><span> with business specific examples</span></p>
</li>
<li>
<p><span>Data linking and sampling</span></p>
</li>
<li>
<p><span>Semantic layer over raw data. This provides a bridge between complex data structures and the everyday language used by the customer</span></p>
</li>
<li>
<p><span>Usage pattern analysis and query history</span></p>
</li>
</ul>
</td>
</tr>
<tr>
<td>
<p><span>Understanding user intent</span></p>
</td>
<td>
<p><strong>Disambiguation using LLMs</strong></p>
<ul>
<ul>
<li>
<p><span>Entity resolution</span></p>
</li>
</ul>
</ul>
<p><strong>SQL-aware foundation models</strong></p>
</td>
</tr>
<tr>
<td>
<p><span>Limits of LLM generation</span></p>
</td>
<td>
<p><strong>Self-consistency</strong></p>
<p><strong>Validation and rewriting</strong></p>
<ul>
<li>
<p><span>Strong foundation models</span></p>
</li>
<li>
<p><span>In-context-learning with dialect specific examples</span></p>
</li>
<li>
<p><span>Model finetuning</span></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table></div>
</div>
</div>
</div>
</div>
</div>
</div></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Text-to-SQL_at_Google_Cloud.max-2200x2200.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Text-to-SQL_at_Google_Cloud.max-2200x2200.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Text-to-SQL_at_Google_Cloud.max-2200x2200.jpg" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Text-to-SQL_at_Google_Cloud.max-2200x2200.jpg" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>The text-to-SQL architecture</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb"><p><span>Let’s take a closer look at some of these techniques.</span></p>
<p><strong>SQL-aware models<br/></strong><span>Strong LLMs are the foundation of text-to-SQL solutions, and the Gemini family of models has a proven track record of high-quality code and SQL generation. Depending on the particular SQL generation task, we mix and match model versions, including some cases where we employ customized fine-tuning, for example to ensure that models provide sufficiently good SQL for certain dialects.</span></p>
<p><strong>Disambiguation using LLMs<br/></strong><span>Disambiguation involves getting the system to respond with a clarifying question when faced with a question that is not clear enough (in the example above of &#34;What is the best selling shoe?&#34; should lead to a follow-up question like &#34;Would you like to see the shoes ordered by order quantity or revenue?&#34; from the text-to-SQL agent). Here we typically orchestrate LLM calls to first try to identify if a question can actually be answered given the available schema and data, and if not, to generate the necessary follow-up questions to clarify the user&#39;s intent.</span></p>
<p><strong>Retrieval and in-context-learning<br/></strong><span>As mentioned above, providing models with the context they need to generate SQL is critical. We use a variety of indexing and retrieval techniques — first to identify relevant datasets, tables and columns, typically using vector search for multi-stage semantic matching, then to load additional useful context. Depending on the product, this may include things like user-provided schema annotations, examples of similar SQL or how to apply specific business rules, or samples of recent queries that a user has run against the same datasets. All of this data is organized into prompts then passed to the model. Gemini&#39;s support for long context windows unlocks new capabilities here by allowing the model to handle large schemas and other contextual information.</span></p>
<p><strong>Validation and reprompting<br/></strong><span>Even with a high-quality model, there is still some level of non-determinism or unpredictability involved in LLM-driven SQL generation. To address this we have found that non-AI approaches like query parsing or doing a dry run of the generated SQL complements model-based workflows well. We can get a clear, deterministic signal if the LLM has missed something crucial, which we then pass back to the model for a second pass. When provided an example of a mistake and some guidance, models can typically address what they got wrong.</span></p>
<p><strong>Self-consistency<br/></strong><span>The idea of self-consistency is to not depend on a single round of generation, but to generate multiple queries for the same user question, potentially using different prompting techniques or model variants, and picking the best one from all candidates. If several models agree that one answer looks particularly good, there is a greater chance that the final SQL query will be accurate and matches what the user is looking for.</span></p>
<h3><strong>Evaluation and measuring improvements</strong></h3>
<p><span>Improving AI-driven capabilities depends on robust evaluation. The text-to-SQL benchmarks developed in the academic community, like the popular </span><a href="https://bird-bench.github.io/" rel="noopener" target="_blank"><span>BIRD-bench</span></a><span>, have been a very useful baseline to understand model and end-to-end system performance. However, these benchmarks are often lacking when it comes to representing broad real-world schemas and workloads. To address this we have developed our own suite of synthetic benchmarks that augment the baseline in many ways.</span></p>
<p><strong>Coverage:</strong><span> We make sure to have benchmarks that cover a broad list of SQL engines and products, both dialects and engine-specific features. This includes not only queries, but also DDL, DML and other administrative needs, and questions that are representative for common usage patterns, including more complex queries and schemas.</span></p>
<p><strong>Metrics:</strong><span> We combine user metrics and offline eval metrics, and employ both human and automated evaluation, particularly using LLM-as-a-judge techniques, which reduce cost but still allow us to understand performance on ambiguous and unclear tasks.</span></p>
<p><strong>Continuous evals:</strong><span> Our engineering and research teams use evals to quickly be able to test out new models, new prompting techniques and other improvements. It can give us signals quickly to tell if an approach is showing promise and is worth pursuing.</span></p>
<p><span>Taken together, using these techniques are driving the remarkable improvements in text-to-SQL that we are witnessing in our labs, as well as in customers’ environments. As you get ready to incorporate text-to-SQL in your own environments, stay tuned for more deep dives into our text-to-SQL solutions. Try Gemini text-to-SQL in </span><a href="https://cloud.google.com/bigquery/docs/write-sql-gemini#use_the_sql_generation_tool"><span>BigQuery Studio</span></a><span>, </span><a href="https://cloud.google.com/sql/docs/mysql/write-sql-gemini"><span>CloudSQL, AlloyDB and Spanner Studio</span></a><span>, and in </span><a href="https://cloud.google.com/blog/products/databases/alloydb-ai-drives-innovation-from-the-database"><span>AlloyDB AI</span></a><span> today.</span></p></div></section><section><section><span>Posted in</span><ul><li><a href="https://cloud.google.com/blog/products/databases" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/databases" track-metadata-module="tag list" track-metadata-module_headline="posted in">Databases</a></li><li><a href="https://cloud.google.com/blog/products/ai-machine-learning" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/ai-machine-learning" track-metadata-module="tag list" track-metadata-module_headline="posted in">AI &amp; Machine Learning</a></li></ul></section></section></div></div>
  </body>
</html>
