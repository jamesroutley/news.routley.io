<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-2-commits-and-tags/">Original</a>
    <h1>Modeling Git Internals in Alloy, Part 2: Commits and Tags</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, April 10, 2023</em></p><p><a href="https://bytes.zone/posts/modeling-git-internals-in-alloy-part-1-blobs-and-trees/">Last week</a>, we started modeling Git&#39;s internals in <a href="https://bytes.zone/posts/alloy/">Alloy</a>. We added blobs (to store content) and trees (to organize it into a filesystem.) We ended up with this model:</p><pre data-lang="alloy"><code data-lang="alloy"><span>abstract sig</span><span> Object {}
</span><span>
</span><span>sig</span><span> Blob </span><span>extends</span><span> Object {}
</span><span>
</span><span>sig</span><span> Tree </span><span>extends</span><span> Object {
</span><span>  children</span><span>: set</span><span> Object
</span><span>}
</span><span>
</span><span>fact</span><span> &#34;trees cannot refer to themselves&#34; {
</span><span>  </span><span>no</span><span> t</span><span>:</span><span> Tree </span><span>|</span><span> t </span><span>in</span><span> t</span><span>.^</span><span>children
</span><span>}
</span></code></pre><p>… which produces instances that look like this:</p><p><img src="https://www.openbsd.org/images/normal-trees-and-blobs.png" alt="an Alloy instance showing a tree containing another tree and a blob. The child tree contains a second blob."/></p><p>Today, we&#39;re going to add commits and tags to this model!</p><h2 id="commits">Commits</h2><p>Going back to <a href="https://book.git-scm.com/book/en/v2/Git-Internals-Git-Objects">the <em>Git Internals - Git Objects</em> chapter of the Git book</a>, we can take a tree hash we produced in the last post and make a commit with <code>git commit-tree</code>:</p><pre><code><span>$ git commit-tree 3ee29075 -m &#39;Commit message&#39;
</span><span>8cc0d4f4ddfde6efa9a8fced667d4d51574a36ec
</span></code></pre><p>We can add more commits (and history) by repeating this command, but specifying a parent ID for each subsequent commit.</p><pre><code><span>$ git commit-tree 3ee29075 -m &#39;Second commit&#39; -p 8cc0d4
</span><span>bc8d9d27a206d0e933be3e445c82cbef09da54d1
</span><span>
</span><span>$ git commit-tree 3ee29075 -m &#39;Third commit&#39; -p bc8d9d
</span><span>844bcca25118c27b0322aacd49edb73d8fac827f
</span></code></pre><p>Then we can view the lineage of the most recent commit with <code>git log</code>:</p><pre><code><span>$ git log 844bcc
</span><span>commit 844bcca25118c27b0322aacd49edb73d8fac827f
</span><span>Author: Brian Hicks &lt;brian@brianthicks.com&gt;
</span><span>Date:   Fri Mar 3 12:36:14 2023 -0600
</span><span>
</span><span>    Third commit
</span><span>
</span><span>commit bc8d9d27a206d0e933be3e445c82cbef09da54d1
</span><span>Author: Brian Hicks &lt;brian@brianthicks.com&gt;
</span><span>Date:   Fri Mar 3 12:35:49 2023 -0600
</span><span>
</span><span>    Second commit
</span><span>
</span><span>commit 8cc0d4f4ddfde6efa9a8fced667d4d51574a36ec
</span><span>Author: Brian Hicks &lt;brian@brianthicks.com&gt;
</span><span>Date:   Fri Mar 3 12:32:37 2023 -0600
</span><span>
</span><span>    Commit message
</span></code></pre><p>But… would it work to commit a blob hash, or does it only work with tree? The book doesn&#39;t say, so I tried, and it looks like the hash you pass in as the first argument to git commit-tree must be a tree. If you try to make a commit based on a blob, git won&#39;t let you:</p><pre><code><span>$ git cat-file -p 3ee29075
</span><span>100644 blob 39528abd81b13b2731d47f86206351a61f1e6484    hello-alloy.txt
</span><span>100644 blob 9b4b40c2bca67e781930105fa190b9b90235cfe5    hello-blob.txt
</span><span>
</span><span>$ git cat-file -p 39528a
</span><span>Hello, Alloy!
</span><span>
</span><span>$ git commit-tree 39528a -m &#39;Can you commit a blob?&#39;
</span><span>fatal: 39528abd81b13b2731d47f86206351a61f1e6484 is not a valid &#39;tree&#39; object
</span></code></pre><p>So it looks like a commit has to have a tree, a message, and zero or more parents (you can have more than one; this is how merge commits work.) All this is confirmed by <code>man git-commit-tree</code>! We&#39;ll leave messages out of our model because they don&#39;t matter for any properties we might care about, but otherwise we&#39;ll add this to our model:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Commit </span><span>extends</span><span> Object {
</span><span>  parent</span><span>: set</span><span> Commit,
</span><span>  tree</span><span>: one</span><span> Tree,
</span><span>}
</span></code></pre><h3 id="finding-mismatches-between-git-s-model-and-ours">Finding mismatches between Git&#39;s model and ours</h3><p>Let&#39;s look at the instances Alloy produces and see if we think any of that feels off. To start, we get relatively normal-looking instances, such as two commits with the same tree:</p><p><img src="https://www.openbsd.org/images/two-commits-pointing-to-the-same-tree.png" alt="An Alloy instance showing two commits referencing the same tree."/></p><p>But we also get some wilder instances. For example, it looks like our model allows trees to have commits as children:</p><p><img src="https://www.openbsd.org/images/tree-with-commit-child.png" alt="An Alloy instance showing a tree with a commit as a child."/></p><p>I&#39;m not sure whether that&#39;d be allowed, but it&#39;s easy to verify by asking Git to add a commit to the staging area:</p><pre><code><span>$ git update-index --add --cacheinfo 100644 \
</span><span>  8cc0d4 commits-are-stageable.txt
</span><span>fatal: git update-index: --cacheinfo cannot add 8cc0d4
</span></code></pre><p>Nope, doesn&#39;t work. That&#39;s fine. We&#39;ll just update our definition of <code>Tree</code> to say that they can&#39;t have commits as children. Since we&#39;re dealing with sets here, we can write “all objects besides commits” as <code>Object - Commit</code>, which makes the new definition of <code>Tree</code> look like this:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Tree </span><span>extends</span><span> Object {
</span><span>  children</span><span>: set</span><span> Object </span><span>-</span><span> Commit
</span><span>}
</span></code></pre><p>That&#39;s not all the weirdness taken care of, though: we also get commits which are their own parents, or cycles of commits who are each other&#39;s parents:</p><p><img src="https://www.openbsd.org/images/commits-who-are-their-own-parents.png" alt="An Alloy instance showing a commit which has itself as a parent."/></p><p>Like last time, this is <em>technically</em> possible: if you can find just the right content for the commit messages and trees, you could conceivably get a commit to refer to itself. Like before, though, this is likely to break git in some awful ways (segfaults!) If we were modeling Git to try to find bugs or security vulnerabilities, I&#39;d say we should allow this. But, as before, we&#39;re trying to learn how this is <em>supposed</em> to work, so let&#39;s disallow it in the same way we disallowed trees being their own parent:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fact</span><span> &#34;commits can&#39;t be their own parent&#34; {
</span><span>  </span><span>no</span><span> c</span><span>:</span><span> Commit </span><span>|</span><span> c </span><span>in</span><span> c</span><span>.^</span><span>parent
</span><span>}
</span></code></pre><p>With commits done, we have only one more object type to model: the tag. Tags are like commits, but instead of pointing to a tree and parent they point to a commit, and you can move them later (as opposed to everything else we&#39;ve seen so far, which is immutable.) Here&#39;s how we&#39;d model that:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Tag </span><span>extends</span><span> Object {
</span><span>  commit</span><span>: one</span><span> Commit,
</span><span>}
</span></code></pre><p>Running the model like this shows that we&#39;ve implicitly allowed trees to contain tags (because now <code>Object - Commit</code> includes <code>Tag</code>) which we didn&#39;t mean. We <em>could</em> say <code>Object - Commit - Tag</code>, but at this point I think it&#39;d be better to rephrase <code>Tree.children</code> to contain only what we want:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Tree </span><span>extends</span><span> Object {
</span><span>  children</span><span>: set</span><span> Blob </span><span>+</span><span> Tree,
</span><span>}
</span></code></pre><p>Now we can get tags on commits. Yay!</p><p><img src="https://www.openbsd.org/images/tagged-commit.png" alt="An Alloy instance showing a tag attached to a commit."/></p><p>We&#39;ve now reached the end of the first part of our Git-modeling journey: we have all the objects! (There are also refs, though, which work like tags but aren&#39;t stored with the git objects. You can read more about those in <a href="https://book.git-scm.com/book/en/v2/Git-Internals-Git-References">the Git Internals - Git References chapter of the Git book</a>.)</p><p>Here&#39;s the model we&#39;re finishing with:</p><pre data-lang="alloy"><code data-lang="alloy"><span>abstract sig</span><span> Object {}
</span><span>
</span><span>sig</span><span> Blob </span><span>extends</span><span> Object {}
</span><span>
</span><span>sig</span><span> Tree </span><span>extends</span><span> Object {
</span><span>  children</span><span>: set</span><span> Blob </span><span>+</span><span> Tree,
</span><span>}
</span><span>
</span><span>fact</span><span> &#34;trees cannot refer to themselves&#34; {
</span><span>  </span><span>no</span><span> t</span><span>:</span><span> Tree </span><span>|</span><span> t </span><span>in</span><span> t</span><span>.^</span><span>children
</span><span>}
</span><span>
</span><span>sig</span><span> Commit </span><span>extends</span><span> Object {
</span><span>  parent</span><span>: set</span><span> Commit,
</span><span>  tree</span><span>: one</span><span> Tree,
</span><span>}
</span><span>
</span><span>fact</span><span> &#34;commits can&#39;t be their own parent&#34; {
</span><span>  </span><span>no</span><span> c</span><span>:</span><span> Commit </span><span>|</span><span> c </span><span>in</span><span> c</span><span>.^</span><span>parent
</span><span>}
</span><span>
</span><span>sig</span><span> Tag </span><span>extends</span><span> Object {
</span><span>  commit</span><span>: one</span><span> Commit,
</span><span>}
</span></code></pre><p>From here, our next step is to model the operations we can take on this model to check if the properties we wrote earlier actually hold when we use Git&#39;s commands. Stay tuned!</p></article></div>
  </body>
</html>
