<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eliot-jones.com/2025/8/pdf-parsing-xref">Original</a>
    <h1>So you want to parse a PDF?</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>Suppose you have an appetite for tilting at windmills. Let&#39;s say you love pain. Well then why not write a PDF parser today?</p>

<h2>The ideal world: how the specification should work</h2>

<p>Conceptually parsing a PDF is fairly simple:</p>

<ul>
<li>First, locate the version header comment at the start of the file</li>
<li>Next you need to locate the pointer to the cross-reference</li>
<li>Then you can find all object offsets</li>
<li>Finally you locate and build the trailer dictionary which points to the catalog dicitionary</li>
</ul>

<h3>Introduction to PDF objects</h3>

<p>A PDF object wraps some valid PDF content, numbers, strings, dictionaries, etc., in an object and generation number. The content is surrounded by the <code>obj/endobj</code> markers, for example a simple number may have its own PDF object:</p>

<pre><code>16 0 obj
620
endobj
</code></pre>

<p>This declares that object 16 with generation 0 contains the number 620.</p>

<p>A PDF file is effectively a graph of objects that may reference each other. Objects reference other objects by use of indirect references. These have the format &#34;16 0 R&#34; which indicates that the content
should be found in object 16 (generation number 0). In this case that would point to the object 16 containing the number 620. It is up to producer applications to split file content into objects as they wish, though the specification requires that certain object types be indirect.</p>

<h3>Finding the cross-reference offset</h3>

<p>To avoid the need to scan the entire file, PDFs declare a cross-reference table (xref). This is an index pointing to where each object in the file lives.</p>

<p>Each file ends with a pointer to the cross-reference file:</p>

<pre><code>&lt;&lt; %trailer &gt;&gt;
startxref
116
%%EOF
</code></pre>

<p>This tells the parser to jump to byte offset 116 to find the xref table (or stream). In theory this pointer is right at the end of the file, according to the specification:</p>

<blockquote>
  <p>Applications should read a PDF file from its end. The last line of the file contains only the end-of-file marker, <code>%%EOF</code></p>
</blockquote>

<p>Though the specification says the <code>%%EOF</code> marker should be on the last line, in practice, things are much messier. For example, Adobe Acrobat only requires it to be within the last 1024 bytes. In real files it can appear anywhere.</p>

<p>In addition files encountered in the wild lacked a linebreak before the offset declaration, or had a typo, e.g. <code>startref</code>.</p>

<p>Let&#39;s assume you&#39;re able to find the declared cross-reference offset for now.</p>

<h3>Finding all object offsets</h3>

<p>At the specified offset you should find a well-formatted xref table:</p>

<pre><code>xref
7 4
0000000000 65535 f 
0000109882 00000 n 
0000109933 00000 n 
0000140066 00000 n 
</code></pre>

<p>After the <code>xref</code> indicator appears, followed by a line break, the first object number and count of objects in the subsection are given. This means: start at object 7 and list 4 objects. Each line gives the byte offset, generation number, and status (n for in-use, f for free). From this, we know where to find objects 8-10 in the file.</p>

<p>So in the example above -- skipping the free entry for object 7 -- this xref table tells where to find the following objects:</p>

<ul>
<li>Object 8 (generation 0) at offset 109882</li>
<li>Object 9 (generation 0) at offset 109933</li>
<li>Object 10 (generation 0) at offset 140066</li>
</ul>

<p>Note: files can have multiple xref tables or streams, linked by <code>/Prev</code> entries in their trailers.</p>

<h3>Locating the trailer dictionary</h3>

<p>Finally, above the startxref marker, you&#39;ll find the trailer dictionary. This provides key metadata, most importantly, where to find the root object. Once you have that, you can follow references and begin interpreting the content.</p>

<h2>The real world: where your pain begins</h2>

<p>Assuming everything is well behaved and you have a reasonable parser for PDF objects this is fairly simple. But you cannot assume everything is well behaved. That would be very foolish, foolish indeed. You&#39;re in PDF hell
now. PDF isn&#39;t a specification, it&#39;s a social construct, it&#39;s a vibe. The more you struggle the deeper you sink. You live in the bog now, with the rest of us, far from the sight of God. If your parser expects files to obey the specification it will fail and people will think it is broken and pitiable. They will think that you are very silly.</p>

<h3>The challenges of locating the xref pointer</h3>

<p>We&#39;ve already mentioned a few unexpected ways locating the pointer to the first cross-reference can fail:</p>

<ul>
<li>It is not at the end of the file, nor within the last 1024 bytes of the file.</li>
<li>It is misspelled.</li>
<li>It is not in the format you&#39;d expect.</li>
</ul>

<p>But assuming you find a pointer, that&#39;s where the real fun begins. Because the pointer is not your friend, it is the first lie, you don&#39;t appreciate how deep the rabbit hole goes.
In screening 3977 files taken from the <a href="https://digitalcorpora.s3.amazonaws.com/s3_browser.html#corpora/files/CC-MAIN-2021-31-PDF-UNTRUNCATED/">common crawl corpus</a> at random we detected 23 files with a bad xref declaration. This works out to a roughly 0.5% failure rate in the sample set.</p>

<h3>PDF content starting at a non-zero offset</h3>

<p>In these files the <code>startxref</code> pointer is incorrect due to a non-zero PDF content start.</p>

<p>This happens when there&#39;s junk data before the <code>%PDF-</code> version header. This shifts every single byte offset in the file.
For example, the declared startxref pointer might be 960, but the actual location is at 970 because of the 10 bytes of junk data at the beginning:</p>

<pre><code>ten bytes!%PDF-1.4
%âãÏÓ
4 0 obj
(content follows)
endobj
% more content
xref
0 5
% ...
&lt;&lt; &gt;&gt;
startxref
960
%%EOF
</code></pre>

<p>In order to adjust for this you should capture the offset of the version header in your file. If the first pointer is incorrect you should also try the offset of the first pointer plus the content start offset. But you still need to check both.</p>

<p>This problem accounted for roughly 50% of errors in the sample set.</p>

<h3>The pointer is in the middle of the xref table</h3>

<p>For some files there is no content preceding the version header, however the pointer is still wrong and it points inside the xref table content at a random offset.</p>

<p>For example jumping directly to the specified offset takes you to this position:</p>

<pre><code>endobj xref
0 246
0000000000 65535 f 
0000184481 00000 n 
00000&lt;---
</code></pre>

<p>This was the case for roughly 5 files in the error set.</p>

<h3>The pointer is &#39;close&#39; to the xref</h3>

<p>Similar to the previous error, here there is no version header offset but following the pointer takes you &#39;almost&#39; to the xref. The most common cases were to be off by a single whitespace/newline, or
in the <code>endobj</code> marker of the previous object:</p>

<pre><code>endobj
--&gt; xref
0 4
</code></pre>

<p>or:</p>

<pre><code>--&gt;endobj
xref
0 7
</code></pre>

<h3>The pointer is correct but the xref offsets are incorrect</h3>

<p>Sometimes the pointer correctly jumps to the <code>xref</code> marker but if you parse the object offsets from the table they are incorrect. The table offsets can also be incorrect when the xref offset is also incorrect.</p>

<p>It can also be the case that offsets are correct for some objects in the table but wrong for others. This was the case for file 0002544.pdf in the sample set which had an initial pointer off-by-7. The locations in the xref table&#39;s first subsection were correct, then offsets that were off-by-4 bytes for subsequent subsections.</p>

<h3>The first pointer is correct but the previous offset is incorrect</h3>

<p>When a file has been modified the file&#39;s trailer (or xref stream dictionary) can contain a <code>/Prev</code> pointer. This is used to construct a chain of xref tables and streams. Several files had correct initial pointers
however when parsing the trailer&#39;s previous offset the second location was incorrect. One file contained a value of <code>0</code> for the previous pointer which indicates that it had incorrectly written the
default value, rather than an offset.</p>

<h3>The xref table is not well formatted</h3>

<p>Beyond the xref pointer issues seen in the sample set, the table structure itself can be malformed in unexpected ways.</p>

<p>The following examples were reported as Github issues for <a href="https://github.com/UglyToad/PdfPig">PdfPig</a>.</p>

<p>No linebreak after <code>xref</code>, for example:</p>

<pre><code>xref5 2
0000000000 65535 f 
0000134883 00000 n 
</code></pre>

<p>More object entries in a subsection than declared in the header, for example if only 2 objects are declared the table can contain more:</p>

<pre><code>xref
0 2
0000000000 65535 f 
0000000230 00000 n 
0000000520 00000 n 
0000001000 00000 n 
</code></pre>

<p>Garbage in the middle of the table, for example:</p>

<pre><code>xref
0 2
0000000000 65535 f
0000455.8483a a010 00000 n 
</code></pre>

<h2>Conclusion</h2>

<p>We looked at how parsing a PDF should proceed according to the specification. We then compared this with a survey of sample files where we saw a 0.5% error rate due to non-compliant files.
All tested PDF viewers (PDF.js, Adobe, Sumatra) were able to open these files because most parsers are extended to support non-compliant files.</p>

<p>This serves as a brief survey of the challenges of parsing a single part of the PDF specification (22 pages out of 1,300 total from version 1.7).</p>
    </div></div>
  </body>
</html>
