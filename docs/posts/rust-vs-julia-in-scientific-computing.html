<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mo8it.com/blog/rust-vs-julia/">Original</a>
    <h1>Rust vs. Julia in Scientific Computing</h1>
    
    <div id="readability-page-1" class="page"><article>
        <div>
            

            
    <div>
        <p><time datetime="2023-07-14">2023-07-14</time><time datetime="2023-07-20">, updated: 2023-07-20</time></p><p>
            Tags:
            <a href="https://mo8it.com/tags/rust">#rust</a><span>,</span><a href="https://mo8it.com/tags/julia">#julia</a></p>

        <p>Reading time: ~31min</p>

        <hr/>
    </div>

        </div>

        <p>One of the main objectives of Julia is <em>solving the two-language problem</em>.
This means that by using Julia, you don&#39;t have to prototype in a dynamic language like Python for flexibility and later rewrite the code in a compiled language like C/C++ for performance.</p>
<p>This goal did catch me while picking a programming language for my bachelor&#39;s thesis in physics.
But after regularly using and even teaching Julia, do I still think that Julia solves that two-language problem?</p>
<p>And why do I think that, in some cases, you should use Rust instead?</p>
<span id="continue-reading"></span><div>
    <div>
        <p>Note</p>
        <p>This blog post is the base for my tiny talk at <a href="https://scientificcomputing.rs/">Scientific Computing in Rust 2023</a>.</p>
<p>If you prefer watching a short video as a trailer, you can watch the <a href="https://youtu.be/0JkbNFpXlXc">the recorded talk</a>.
But the blog post has many more details and aspects that can not fit into 7 minutes.</p>

    </div>
</div>
<div>
    <div>
        <p>‚ö†Ô∏è Warning ‚ö†Ô∏è</p>
        <p>I have to warn you, I am in love with Rust!</p>
<p>Therefore, this post is biased towards Rust.
But I do use Julia regularly and I even spread it with pleasure at my university by teaching a vacation course about Julia.
I just think that the promises of Julia can be misleading and there are use cases where you should just use Rust over Julia.
Read more to find out why.</p>

    </div>
</div>
<p>The code examples were tested with Rust 1.71.0 and Julia 1.9.2.</p>

    <p>Landscape mode recommended on mobile devices</p>

    
        
    

<h2 id="fearless-concurrency"><a href="#fearless-concurrency">Fearless concurrency*</a></h2>
<p>Julia makes multithreading very easy.
Multithreading in Julia is a matter of adding the <code>@threads</code> macro in front of a <code>for</code> loop!</p>
<p>Although Julia makes multithreading easier, it does not make it any safer!
Let&#39;s take a look at the following known example:</p>
<pre data-lang="julia"><code data-lang="julia"><span>function </span><span>unsafe_count</span><span>()
</span><span>    counter </span><span>= </span><span>0
</span><span>
</span><span>    Threads.@threads </span><span>for</span><span> _ </span><span>in </span><span>1</span><span>:</span><span>10_000
</span><span>        counter </span><span>+= </span><span>1
</span><span>    </span><span>end
</span><span>
</span><span>    counter
</span><span>end
</span></code></pre>
<p>If you are not familiar with multithreading, you would expect that the result should be <code>10_000</code>.
But if you run it multiple times, you will get an output similar to the following:</p>
<pre><code><span>8609
</span><span>8491
</span><span>9191
</span><span>‚Ä¶
</span></code></pre>
<p>The output is random because of <strong>data-races</strong>.</p>
<p>This data-race happens because a thread reads the current value of <code>counter</code>, adds <code>1</code> to it and stores the addition result in the same variable.
If two threads read the variable at the same time and then add <code>1</code>, the addition result would be the same and they will both store that result which means that we loose one addition.</p>
<p>The following demonstrates the scenario <em>without</em> a data-race:</p>
<pre><code><span>counter | thread 1  | thread 2
</span><span>3       | read 3    |
</span><span>3       | 3 + 1 = 4 |
</span><span>4       | write 4   |
</span><span>4       |           | read 4
</span><span>4       |           | 4 + 1 = 5
</span><span>5       |           | write 5
</span></code></pre>
<p>In the case of a data-race, an addition is lost:</p>
<pre><code><span>counter | thread 1  | thread 2
</span><span>3       | read 3    |
</span><span>3       |           | read 3
</span><span>3       | 3 + 1 = 4 | 3 + 1 = 4
</span><span>4       | write 4   |
</span><span>4       |           | write 4
</span></code></pre>
<p>Let&#39;s translate the Julia code into Rust:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>rayon</span><span>::</span><span>prelude</span><span>::*</span><span>;
</span><span>
</span><span>let mut</span><span> counter </span><span>= </span><span>0</span><span>;
</span><span>
</span><span>(</span><span>0</span><span>..</span><span>10_000</span><span>)</span><span>.</span><span>into_par_iter</span><span>()</span><span>.</span><span>for_each</span><span>(|_| {
</span><span>    counter </span><span>+= </span><span>1</span><span>;
</span><span>})</span><span>;
</span></code></pre>
<p>We did use the <a href="https://docs.rs/rayon/latest/rayon/"><code>rayon</code></a> crate which offers easy multithreading using <a href="https://doc.rust-lang.org/stable/std/iter/index.html#iterator">iterators</a>.</p>
<p>Fortunately, the Rust code above will not compile! ‚ùå</p>
<p>In Rust, either you have only one mutable reference and no immutable ones <strong>or</strong> (XOR) you have any number of immutable references but no mutable ones.</p>
<p>For a data-race to happen, you need to have more than one mutable reference.
For example, in the Julia code above, every thread has its own mutable reference to the <code>counter</code> variable!
The <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">borrowing rule</a> above makes data-races <strong>impossible</strong> in Rust!</p>
<div>
    <div>
        <p>Note</p>
        <p>*: With Rust, you <em>almost</em> have fearless concurrency. Data-races are impossible, but you still have to fear <a href="https://en.wikipedia.org/wiki/Deadlock">deadlocks</a>!</p>
<p>This blog post is about <em>safe</em> Rust, which means Rust without using <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"><code>unsafe</code></a>.</p>

    </div>
</div>
<p>To make the Rust version compile, we need to either use a <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html">Mutex</a> or an <a href="https://doc.rust-lang.org/stable/std/sync/atomic/index.html">atomic</a>.
Atomics guarantee on the hardware level that their supported operations are done atomically, which means in one step!
Since atomics have better performance than a mutex, we will use <code>AtomicU64</code> (unsigned integer with 64 bits):</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> counter </span><span>= </span><span>AtomicU64</span><span>::</span><span>new(</span><span>0</span><span>)</span><span>;
</span><span>
</span><span>(</span><span>0</span><span>..</span><span>10_000</span><span>)</span><span>.</span><span>into_par_iter</span><span>()</span><span>.</span><span>for_each</span><span>(|_| {
</span><span>    counter</span><span>.</span><span>fetch_add</span><span>(</span><span>1</span><span>, </span><span>Ordering</span><span>::</span><span>SeqCst)</span><span>;
</span><span>})</span><span>;
</span></code></pre>
<p>Note that <code>counter</code> is not mutable anymore!
There is no more <code>mut</code> after <code>let</code>.
Since operations on atomic types guarantee to not introduce data-races, they take an immutable reference <code>&amp;self</code> instead of a mutable one <code>&amp;mut self</code>.
This allows us to use them on multiple threads (because it is allowed to have multiple immutable references).</p>
<p>Of course, the atomic Rust version above returns <code>10_000</code> üéâ</p>
<p>If it compiles, it is data-race free üòÉ</p>
<div>
    <div>
        <p>Note</p>
        <p>Discussing <code>Ordering::SeqCst</code> would go beyond the scope of this blog post. You can read more about atomic memory orderings <a href="https://doc.rust-lang.org/stable/std/sync/atomic/enum.Ordering.html">in the documentation</a>.</p>

    </div>
</div>
<p>The correct Julia version looks very similar to the Rust version:</p>
<pre data-lang="julia"><code data-lang="julia"><span>function </span><span>safe_count</span><span>()
</span><span>    counter </span><span>=</span><span> Threads.Atomic{UInt</span><span>64</span><span>}(</span><span>0</span><span>)
</span><span>
</span><span>    Threads.@threads </span><span>for</span><span> _ </span><span>in </span><span>1</span><span>:</span><span>10_000
</span><span>        Threads.atomic_add</span><span>!</span><span>(counter, UInt</span><span>64</span><span>(</span><span>1</span><span>))
</span><span>    </span><span>end
</span><span>
</span><span>    counter[]
</span><span>end
</span></code></pre>
<p>This means that Julia does have atomics too.
But it is not able to detect a possible data-race to recommend using them or at least just warn us.</p>
<p>Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">multithreading documentation</a> states: &#34;You are entirely responsible for ensuring that your program is data-race free [...]&#34;</p>
<p>Moore&#39;s law is almost dead, at least for single core performance. Therefore, we need a language that makes concurrency not only easy, but also <strong>correct</strong>.</p>
<h2 id="project-scalability"><a href="#project-scalability">Project scalability</a></h2>
<p>How hard is it to maintain, extend and reason about the correctness of Julia code while a project grows?</p>
<h3 id="static-analysis"><a href="#static-analysis">Static analysis</a></h3>
<p>Highly optimized Julia code can get close to the performance of Rust because of the just-in-time (JIT) compilation.</p>
<p>But producing optimized machine code is not the only purpose of compilers.
Julia misses a very important advantage of a real compiler: Static analysis!</p>
<p>Take a look at the following example in Julia:</p>
<pre data-lang="julia"><code data-lang="julia"><span>v </span><span>= </span><span>[</span><span>1.0</span><span>]
</span><span>
</span><span>println(</span><span>&#34;OK&#34;</span><span>)
</span><span>
</span><span>println(v.pop())
</span><span>
</span><span>println(</span><span>&#34;No problem!&#34;</span><span>)
</span></code></pre>
<p>Did you find any problem?
Well, Julia does not see a problem in it until it reaches the problematic line!</p>
<p>If you run the code above, you will see <code>OK</code> printed out before you get an error because we did use Rust&#39;s syntax for <code>pop</code>.
We should have used <code>pop!(v)</code> in Julia.</p>
<p>You might think that this is fine, a simple test run will find this bug.</p>
<p>But what if the buggy code is behind some condition that is dependent on the program input or which is just random like in a Monte Carlo simulation?
Here is a demonstration:</p>
<pre data-lang="julia"><code data-lang="julia"><span>v </span><span>= </span><span>[</span><span>1.0</span><span>]
</span><span>
</span><span>println(</span><span>&#34;OK&#34;</span><span>)
</span><span>
</span><span>if</span><span> rand(Bool)
</span><span>    println(v.pop())
</span><span>end
</span><span>
</span><span>println(</span><span>&#34;No problem!&#34;</span><span>)
</span></code></pre>
<p>If you run this Julia code, you should have about 50% chance of just passing by the buggy block and printing out <strong><code>No problem!</code></strong>.</p>
<p>Well, this <strong>is</strong> a problem, a <strong>big</strong> one!
Such a type bug can be prevented by a simple type system with static analysis.</p>
<p>Why am I talking about static analysis under the topic of scalability?</p>
<p>Let&#39;s say we are writing some molecular dynamics simulation.
Take a look at the following example:</p>
<pre data-lang="julia"><code data-lang="julia"><span>particles </span><span>= </span><span>[[</span><span>1.0</span><span>, </span><span>2.0</span><span>], [</span><span>2.0</span><span>, </span><span>3.0</span><span>], [</span><span>42.0</span><span>, </span><span>35.9</span><span>]]
</span><span>
</span><span>for</span><span> particle </span><span>in</span><span> particles
</span><span>    distance_to_origin </span><span>=</span><span> sqrt(particle[</span><span>1</span><span>]</span><span>^</span><span>2 </span><span>+</span><span> particle[</span><span>2</span><span>]</span><span>^</span><span>2</span><span>)
</span><span>    println(</span><span>&#34;Particle&#39;s distance to origin: </span><span>$</span><span>distance_to_origin</span><span>&#34;</span><span>)
</span><span>end
</span><span>
</span><span>center_of_mass </span><span>=</span><span> sum(particle </span><span>for</span><span> particle </span><span>in</span><span> particles) </span><span>/</span><span> length(particles)
</span><span>println(</span><span>&#34;Center of mass: </span><span>$</span><span>center_of_mass</span><span>&#34;</span><span>)
</span></code></pre>
<p>We create some particles by storing their positions in a vector.
As two placeholders for some computations, we calculate their distance to the origin and their center of mass (assuming that they all have mass <code>1</code>).</p>
<p>Let&#39;s say that, later on, we want to take the charge of particles into account for a better accuracy of our simulation.
Therefore, we create a struct called <code>Particle</code> storing the position and charge:</p>
<pre data-lang="julia"><code data-lang="julia"><span>struct </span><span>Particle
</span><span>    position</span><span>::</span><span>Vector{Float</span><span>64</span><span>}
</span><span>    charge</span><span>::</span><span>Float</span><span>64
</span><span>end
</span><span>
</span><span>particles </span><span>= </span><span>[Particle([</span><span>1.0</span><span>, </span><span>2.0</span><span>], </span><span>1.0</span><span>), Particle([</span><span>2.0</span><span>, </span><span>3.0</span><span>], </span><span>-</span><span>1.0</span><span>), Particle([</span><span>42.0</span><span>, </span><span>35.9</span><span>], </span><span>0.0</span><span>)]
</span><span>
</span><span>for</span><span> particle </span><span>in</span><span> particles
</span><span>    distance_to_origin </span><span>=</span><span> sqrt(particle[</span><span>1</span><span>]</span><span>^</span><span>2 </span><span>+</span><span> particle[</span><span>2</span><span>]</span><span>^</span><span>2</span><span>)
</span><span>    println(</span><span>&#34;Particle&#39;s distance to origin: </span><span>$</span><span>distance_to_origin</span><span>&#34;</span><span>)
</span><span>end
</span><span>
</span><span>center_of_mass </span><span>=</span><span> sum(particle </span><span>for</span><span> particle </span><span>in</span><span> particles) </span><span>/</span><span> length(particles)
</span><span>println(</span><span>&#34;Center of mass: </span><span>$</span><span>center_of_mass</span><span>&#34;</span><span>)
</span></code></pre>
<p>We did change the content of the <code>particles</code> vector from positions to instances of <code>Particle</code>.</p>
<p>We don&#39;t use the introduced charge yet. We just want to make sure that we did not break anything.</p>
<p>We run our code and get an error because we are now trying to index into the <code>Particle</code> struct instead of a position vector while calculating the distance to the origin.</p>
<p>No problem, you would think. We did just forget to adjust that line. We can just fix it and run the code again!</p>
<pre data-lang="julia"><code data-lang="julia"><span>for</span><span> particle </span><span>in</span><span> particles
</span><span>    distance_to_origin </span><span>=</span><span> sqrt(particle.position[</span><span>1</span><span>]</span><span>^</span><span>2 </span><span>+</span><span> particle.position[</span><span>2</span><span>]</span><span>^</span><span>2</span><span>)
</span><span>    println(</span><span>&#34;Particle&#39;s distance to origin: </span><span>$</span><span>distance_to_origin</span><span>&#34;</span><span>)
</span><span>end
</span></code></pre>
<p>Are we done now?
If we run it, we get another error.
We did miss one more line where the center of mass is calculated!</p>
<p>We can fix it easily like the following:</p>
<pre data-lang="julia"><code data-lang="julia"><span>center_of_mass </span><span>=</span><span> sum(particle.position </span><span>for</span><span> particle </span><span>in</span><span> particles) </span><span>/</span><span> length(particles)
</span><span>println(</span><span>&#34;Center of mass: </span><span>$</span><span>center_of_mass</span><span>&#34;</span><span>)
</span></code></pre>
<p>But how long will you stay in the cycle of running and fixing after a change in a bigger program?</p>
<p>Will you be sure that you did not miss any line after your code runs without errors?</p>
<p>Such changes that affect a relatively big part of a codebase are called <a href="https://en.wikipedia.org/wiki/Code_refactoring">refactorings</a>.</p>
<p>Refactoring in Rust is a <em>smooth compiler driven process</em>.
The compiler will throw an error for everything that you did not adjust yet.
You just work through the list of compiler errors.
After solving that puzzle, your program compiles and you can pretty much be sure that you did not forget anything!</p>
<p>No errors at runtime!</p>
<p>Of course, this does not mean that you could have forgotten something related to the logic of your program.
You should have some tests for that!</p>
<p>When you write tests in Rust, you test the logic of your program.
You should just make sure that you still get the expected output for specific inputs.
But you do not test if your code has systematic bugs or possible crashes.</p>
<p>We could build a linter for Julia, just like the many linters for Python.
Tools like linters for dynamically typed languages will not reach the power and correctness of a static analysis built on a well typed language.
It will just be like putting more cement on a fragile base just to make it a bit safer.</p>
<h3 id="error-handling"><a href="#error-handling">Error handling</a></h3>
<p>In the last section, we did discuss systematic bugs that can be detected by a static analysis.</p>
<p>What about errors that can not be directly detected at compile time?</p>
<p>Julia offers <a href="https://docs.julialang.org/en/v1/manual/control-flow/#Exception-Handling">exceptions</a> for dealing with such cases.
How about Rust?</p>
<h4 id="option-to-be-or-not-to-be-that-is-the-question"><a href="#option-to-be-or-not-to-be-that-is-the-question">Option: To be or not to be, that is the question</a></h4>
<p>What happens when you run the following code in Julia?</p>
<pre data-lang="julia"><code data-lang="julia"><span>v </span><span>= </span><span>[</span><span>1.0</span><span>]
</span><span>pop</span><span>!</span><span>(v) </span><span>*</span><span> pop</span><span>!</span><span>(v)
</span></code></pre>
<p>Well, there is only one value, therefore the second <code>pop!</code> will fail.
But how?</p>
<p>It will fail with an error at runtime üí•</p>
<p>Can Rust prevent that?
Let&#39;s take a look at the signature of <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop"><code>pop</code></a> for <code>Vec&lt;T&gt;</code> in Rust (<code>Vec</code> is a vector, <code>T</code> is a generic):</p>
<pre data-lang="rust"><code data-lang="rust"><span>pop</span><span>(</span><span>&amp;</span><span>mut </span><span>self</span><span>) </span><span>-&gt; </span><span>Option</span><span>&lt;T&gt;
</span></code></pre>
<p>It takes a mutable reference of the vector holding values of type <code>T</code> and returns an <code>Option&lt;T&gt;</code>.</p>
<p><code>Option</code> is just an <em>enum</em>, a very simple but powerful one!</p>
<p>The definition of <code>Option</code> in the standard library is the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span>enum </span><span>Option</span><span>&lt;T&gt; {
</span><span>    </span><span>None</span><span>,
</span><span>    </span><span>Some</span><span>(T)</span><span>,
</span><span>}
</span></code></pre>
<p>This means that an <code>Option&lt;T&gt;</code> can either be <code>None</code> or <code>Some</code> with <em>some</em> value of type <code>T</code>.</p>
<p>Let&#39;s see how the above Julia code would look like in Rust:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> v </span><span>= </span><span>vec!</span><span>[</span><span>1.0</span><span>]</span><span>;
</span><span>
</span><span>v</span><span>.</span><span>pop</span><span>() </span><span>*</span><span> v</span><span>.</span><span>pop</span><span>()
</span></code></pre>
<p>If you try to compile it, you will get a (normally colored) lovely error message like the following (Rust has the best error messages üòç):</p>
<pre><code><span>error[E0369]: cannot multiply `Option&lt;{float}&gt;` by `Option&lt;{float}&gt;`
</span><span>  --&gt; src/lib.rs:18:13
</span><span>   |
</span><span>18 |     v.pop() * v.pop()
</span><span>   |     ------- ^ ------- Option&lt;{float}&gt;
</span><span>   |     |
</span><span>   |     Option&lt;{float}&gt;
</span></code></pre>
<p>The easiest way to handle an <code>Option</code> is to <code>unwrap</code> it:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> v </span><span>= </span><span>vec!</span><span>[</span><span>1.0</span><span>]</span><span>;
</span><span>
</span><span>v</span><span>.</span><span>pop</span><span>()</span><span>.</span><span>unwrap</span><span>() </span><span>*</span><span> v</span><span>.</span><span>pop</span><span>()</span><span>.</span><span>unwrap</span><span>()
</span></code></pre>
<p>The behavior of unwrapping a <code>None</code> is just that of Julia: It will <em>panic</em> at runtime.</p>
<p>You might think that we at least made a possible panic explicit, right?</p>
<p>But you should not use <code>unwrap</code> in production code. In Rust, you should do proper enum handling:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> v </span><span>= </span><span>vec!</span><span>[</span><span>1.0</span><span>]</span><span>;
</span><span>
</span><span>let</span><span> v1 </span><span>= </span><span>match</span><span> v</span><span>.</span><span>pop</span><span>() {
</span><span>    </span><span>Some</span><span>(value) </span><span>=&gt;</span><span> value</span><span>,
</span><span>    </span><span>None </span><span>=&gt; </span><span>1.0</span><span>,
</span><span>}</span><span>;
</span><span>
</span><span>let</span><span> v2 </span><span>= </span><span>match</span><span> v</span><span>.</span><span>pop</span><span>() {
</span><span>    </span><span>Some</span><span>(value) </span><span>=&gt;</span><span> value</span><span>,
</span><span>    </span><span>None </span><span>=&gt; </span><span>1.0</span><span>,
</span><span>}</span><span>;
</span><span>
</span><span>v1 </span><span>*</span><span> v2
</span></code></pre>
<p>We use pattern matching to handle the <code>Option</code>.
In case the <code>Option</code> is <code>None</code>, we use <code>1</code> as the neutral element of multiplication.</p>
<p>You might think that this is a lot of boilerplate code!
You are right!
But it was only a demonstration of pattern matching to understand how handling an <code>Option</code> works.</p>
<p>The code above can be reduced to the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> v </span><span>= </span><span>vec!</span><span>[</span><span>1.0</span><span>]</span><span>;
</span><span>
</span><span>v</span><span>.</span><span>pop</span><span>()</span><span>.</span><span>unwrap_or</span><span>(</span><span>1.0</span><span>) </span><span>*</span><span> v</span><span>.</span><span>pop</span><span>()</span><span>.</span><span>unwrap_or</span><span>(</span><span>1.0</span><span>)
</span></code></pre>
<p>The implementation of <code>unwrap_or</code> for <code>Option</code> looks like the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>unwrap_or</span><span>(</span><span>self</span><span>, </span><span>default</span><span>:</span><span> T) </span><span>-&gt;</span><span> T {
</span><span>    </span><span>match </span><span>self </span><span>{
</span><span>        </span><span>Some</span><span>(x) </span><span>=&gt;</span><span> x</span><span>,
</span><span>        </span><span>None </span><span>=&gt;</span><span> default</span><span>,
</span><span>    }
</span><span>}
</span></code></pre>
<p>It is just what we have done in the long version, but <code>unwrap_or</code> is a convenient method.</p>
<p>You might think that the result <code>1</code> is not what you would expect if the vector is empty.
You can handle it differently.
But, you see, you are just thinking about how to correctly handle cases where something does not work as expected!
My mission is accomplished üòâ</p>
<h4 id="failure-is-not-an-option-it-s-a-result"><a href="#failure-is-not-an-option-it-s-a-result">Failure is not an Option, it&#39;s a Result!</a></h4>
<p>Let&#39;s say that you want to write the results of a long simulation in Julia:</p>
<pre data-lang="julia"><code data-lang="julia"><span>open(</span><span>&#34;results/energies.csv&#34;</span><span>, </span><span>&#34;w&#34;</span><span>) </span><span>do</span><span> file
</span><span>    write(file, </span><span>&#34;1,2,3&#34;</span><span>)
</span><span>end
</span></code></pre>
<p>What happens if Julia fails to open the file, for example because the directory <code>results/</code> does not exist?</p>
<p>You probably guessed it: Runtime error üí•</p>
<p>Which would mean that you loose your results and have to rerun the simulation again after fixing the cause of the error.</p>
<p>You could wrap the code above in a <code>try/catch</code> statement and maybe dump the results into <code>/tmp</code> instead and tell the user about it.</p>
<p>But first of all, Julia does not force you to handle exceptions.
The language itself does not even tell you about possible exceptions, you have to read the documentation of every function you use to find out if it could throw an exception.
What if a possible exception is not documented?
To be really safe, you could wrap everything in a <code>try/catch</code> statement.</p>
<p>Is there something better than exceptions?
Let&#39;s see the Rust version of the code above:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std</span><span>::</span><span>fs</span><span>::</span><span>OpenOptions</span><span>;
</span><span>
</span><span>match </span><span>OpenOptions</span><span>::</span><span>new()
</span><span>    </span><span>.</span><span>create</span><span>(</span><span>true</span><span>)
</span><span>    </span><span>.</span><span>write</span><span>(</span><span>true</span><span>)
</span><span>    </span><span>.</span><span>open</span><span>(</span><span>&#34;results/energies.csv&#34;</span><span>) {
</span><span>        </span><span>Ok</span><span>(</span><span>mut</span><span> file) </span><span>=&gt; </span><span>{
</span><span>            </span><span>// Ready to write
</span><span>        }
</span><span>        </span><span>Err</span><span>(error) </span><span>=&gt; </span><span>{
</span><span>            </span><span>// Handle the error
</span><span>        }
</span><span>    }</span><span>;
</span></code></pre>
<p><code>open</code> returns a <code>Result</code>. A <code>Result&lt;T, E&gt;</code> (with the generics <code>T</code> and <code>E</code>) is the second important enum in Rust:</p>
<pre data-lang="rust"><code data-lang="rust"><span>enum </span><span>Result</span><span>&lt;T, E&gt; {
</span><span>    </span><span>Ok</span><span>(T)</span><span>,
</span><span>    </span><span>Err</span><span>(E)</span><span>,
</span><span>}
</span></code></pre>
<p><code>open</code> forces you to handle a possible IO error just like <code>pop</code> forces you to handle the <code>None</code> case.</p>
<p>With exceptions, you expect some value from a function and might be surprised with an exception.
But with <code>Result</code> and <code>Option</code>, the type of the function&#39;s signature will tell you if an error could occur.
No surprises!</p>
<p>Rust will not let you miss a case.
It will not let you crash your program by mistake.</p>
<p>You can use <code>unwrap</code> on <code>Result</code> too, but then it is not a crash by mistake.
You did <em>decide</em> that you would rather want to crash.</p>
<p>Again, how many times do you rerun your Julia code until no error appears?
How does the time needed for this cycle scale with the complexity of the project?</p>
<p>How confident are you about your Julia code to not crash on some point although it did run fine when you tested it with some example input?</p>
<p>Rust can give you the confidence that your code is correct ‚úîÔ∏è</p>
<h3 id="interfaces"><a href="#interfaces">Interfaces</a></h3>
<p>Julia is very flexible with its <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a> and <a href="https://docs.julialang.org/en/v1/manual/types/">type hierarchy</a>.
But let&#39;s suppose that a library introduces an abstract type that you can implement concrete types for.</p>
<p>If a function takes that abstract type as an argument, what methods does that function expect from my concrete type to have implemented?</p>
<p>Since Julia does not have interfaces yet, you have three options to find out required methods:</p>
<ul>
<li>Just use your concrete type as the abstract type, run your code repeatedly while fixing one &#34;unimplemented&#34; error after the other and hope that you did cover all cases at the end...</li>
<li>Hope for documentation like <a href="https://docs.julialang.org/en/v1/manual/interfaces/">this from the standard library</a>.</li>
<li>Recursively read the source code and try to find out what methods are used inside the function.</li>
</ul>
<p>To be fair, interfaces are <a href="https://github.com/JuliaLang/julia/issues/6975">planned for the version 2.0 of Julia</a>.
But the fact that this was not a priority for 1.0 strengthens my opinion that Julia is mainly designed for interactive use cases, not for large projects.</p>
<div>
    <div>
        <p>Note</p>
        <p>Although there is a the <a href="https://github.com/JuliaLang/julia/milestone/23">2.0 milestone</a> for Julia on Github, Julia <a href="https://discourse.julialang.org/t/the-future-of-julia-1-6-1-7-rc1-1-8-1-9-1-10-and-2-0-and-lts/68143/4">does not plan a 2.0 release anytime soon</a>.</p>
<p>Still, I did not find a statement that indicates that a 2.0 release will <em>not</em> happen.
I am not sure how Julia&#39;s ecosystem will survive a transition to <code>2.0</code>, independent of when this happens.</p>
<p>Remember the transition from Python <code>2</code> to <code>3</code>!</p>
<p>Rust will not have a version <code>2.0</code>! It has <a href="https://doc.rust-lang.org/edition-guide/editions/index.html">editions</a> that preserve backwards compatibility.</p>

    </div>
</div>
<p>On the other hand, Rust&#39;s <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a> show you all required and optional methods!</p>
<p>The <code>Iterator</code> trait for example has <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#required-methods">one required method</a> which is <code>next</code>.
If you implement it, you get all other methods for free!
If you want to, you can implement optional methods like <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint"><code>size_hint</code></a> which is useful for avoiding allocations while collecting an iterator.</p>
<p>There is no trying out, no searching for hidden documentation that might not even exist, no reading of source code.
Rust will make sure at compile-time that you did implement all required methods.</p>
<h2 id="performance"><a href="#performance">Performance</a></h2>
<p>As mentioned above, highly optimized Julia code can get close to the performance of Rust.
But it will not reach the performance of Rust unless it does not trigger the garbage collector which Rust does not have.</p>
<p>But which language makes it easier to write the most efficient code?</p>

<p>Julia has what I call <strong>performance footguns</strong>.</p>
<p>For example, if you initialize an empty vector like <code>v = []</code>, you did already degrade the performance of your code to one similar to Python&#39;s (without <code>numpy</code>) because your vector has the type <code>Any</code>.
It can store any value!
Therefore, Julia can not optimize this vector anymore.
You either have to initialize the empty vector with a <em>concrete</em> type like <code>v = Float64[]</code> or you have to initialize it with at least one value like <code>v = [1.0]</code>.</p>
<p>Julia will not tell you about such performance killers!
Have fun profiling, using the macro <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-code-warntype"><code>@code_warntype</code></a> while interactively calling a function, etc.</p>
<h3 id="preallocation-and-undefined-behavior"><a href="#preallocation-and-undefined-behavior">Preallocation and undefined behavior</a></h3>
<p>We all know that allocations are often a bottleneck.
Julia <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">recommends</a> pre-allocation like the following:</p>
<pre data-lang="julia"><code data-lang="julia"><span>v </span><span>=</span><span> Vec{Int</span><span>64</span><span>}(</span><span>undef</span><span>, </span><span>3</span><span>)
</span></code></pre>
<p>What would happen if you forget to set an <code>undef</code> (undefined) value and read it by mistake?
One possible output of <code>v</code> is:</p>
<pre data-lang="julia"><code data-lang="julia"><span>139974349418624
</span><span>139974300721328
</span><span>2181038337
</span></code></pre>
<p>Welcome to the area of <a href="https://en.wikipedia.org/wiki/Undefined_behavior"><strong>undefined behavior</strong></a> with uninitialized memory üò±</p>
<p>With Rust, you can initialize a vector with <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity"><code>with_capacity</code></a>.
But it will be empty with length 0.</p>
<p>Capacity is not length.
Capacity is the amount of data the vector can hold without needing to reallocate again.
The length is the amount of data that the vector stores.</p>
<p>The capacity is always bigger or equal to the length.
Your goal is to avoid that the length gets bigger than the current capacity because the vector will be reallocated to have bigger capacity.</p>
<p>Julia offers the function <a href="https://docs.julialang.org/en/v1/base/collections/#Base.sizehint!"><code>sizehint!</code></a> to reserve capacity.
But it <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">recommends</a> the method with possible undefined behavior instead of this function.
Why? ü§î</p>
<div>
    <div>
        <p>Note</p>
        <p>Julia offers functions like <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.zeros"><code>zeros</code></a>, <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.ones"><code>ones</code></a> and <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.fill"><code>fill</code></a>.
But these have the overhead of overwriting the memory first.</p>
<p>You still get logic bugs with these three functions if you forget to set some values, but at least it is not undefined behavior.</p>

    </div>
</div>
<p>If you care about performance, you should <strong>not</strong> use <code>sizehint!</code> for array preallocation.
Julia recommends the method with <code>undef</code> for a &#34;good&#34; reason.
Let&#39;s take a look at the following benchmarking that compares both preallocation methods:</p>
<pre data-lang="julia"><code data-lang="julia"><span>function </span><span>benchmark_alloc</span><span>()
</span><span>    n </span><span>= </span><span>2</span><span>^</span><span>8
</span><span>    m </span><span>= </span><span>2</span><span>^</span><span>14
</span><span>
</span><span>    @btime </span><span>for</span><span> _ </span><span>in </span><span>1</span><span>:$</span><span>n
</span><span>        v </span><span>=</span><span> Int</span><span>64</span><span>[]
</span><span>        sizehint</span><span>!</span><span>(v, </span><span>$</span><span>m)
</span><span>
</span><span>        </span><span>for</span><span> i </span><span>in </span><span>1</span><span>:$</span><span>m
</span><span>            push</span><span>!</span><span>(v, i)
</span><span>        </span><span>end
</span><span>    </span><span>end
</span><span>
</span><span>    @btime </span><span>for</span><span> _ </span><span>in </span><span>1</span><span>:$</span><span>n
</span><span>        v </span><span>=</span><span> Vector{Int</span><span>64</span><span>}(</span><span>undef</span><span>, </span><span>$</span><span>m)
</span><span>
</span><span>        </span><span>for</span><span> i </span><span>in </span><span>1</span><span>:$</span><span>m
</span><span>            v[i] </span><span>=</span><span> i
</span><span>        </span><span>end
</span><span>    </span><span>end
</span><span>
</span><span>    </span><span>nothing
</span><span>end
</span></code></pre>
<div>
    <div>
        <p>Note</p>
        <p>I know that you can do what the example does much better with a range <code>1:m</code> which you can collect if you really want a vector.
But these trivial examples are only for demonstration.
You should focus on the effects.</p>

    </div>
</div>
<p>Let&#39;s run this benchmarking:</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt;</span><span> benchmark_alloc()
</span><span>  </span><span>16.949</span><span> ms (</span><span>512</span><span> allocations</span><span>: </span><span>32.03</span><span> MiB)
</span><span>  </span><span>2.866</span><span> ms (</span><span>512</span><span> allocations</span><span>: </span><span>32.01</span><span> MiB)
</span></code></pre>
<p>The version with <code>sizehint!</code> is about <strong>6 times slower</strong> than the method with <code>undef</code> ü§Ø</p>
<p>The reason is that <a href="https://github.com/JuliaLang/julia/issues/24909"><code>push!</code> always does an expensive call into C code</a>!</p>
<p>Does this mean that preallocation with uninitialized values is in general faster?
Does it mean that we have to tolerate methods with possible undefined behavior for performance?</p>
<p>Let&#39;s use the first method with capacity in Rust:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std</span><span>::</span><span>time</span><span>::</span><span>Instant</span><span>;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> n </span><span>= </span><span>2_</span><span>usize</span><span>.</span><span>pow</span><span>(</span><span>8</span><span>)</span><span>;
</span><span>    </span><span>let</span><span> m </span><span>= </span><span>2_</span><span>usize</span><span>.</span><span>pow</span><span>(</span><span>14</span><span>)</span><span>;
</span><span>
</span><span>    </span><span>let</span><span> now </span><span>= </span><span>Instant</span><span>::</span><span>now()</span><span>;
</span><span>
</span><span>    </span><span>for </span><span>_ in </span><span>0</span><span>..</span><span>n {
</span><span>        </span><span>let mut</span><span> v </span><span>= </span><span>Vec</span><span>::</span><span>with_capacity(m)</span><span>;
</span><span>
</span><span>        </span><span>for</span><span> i </span><span>in </span><span>0</span><span>..</span><span>m {
</span><span>            v</span><span>.</span><span>push</span><span>(i)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span>println!</span><span>(</span><span>&#34;Elapsed: </span><span>{:?}</span><span>&#34;</span><span>,</span><span> now</span><span>.</span><span>elapsed</span><span>())</span><span>;
</span><span>}
</span></code></pre>
<p>The output is:</p>
<pre><code><span>Elapsed: 2.518863ms
</span></code></pre>
<p>The time it takes is close to that of the method with <code>undef</code> in Julia because Rust does not abstract away the concept of capacity and manages it internally.
Without possible undefined behavior üòâ</p>
<p>Rust does not allow undefined behavior <strong>and</strong> allows you to get as low level as you want with <em>maximum</em> performance.
Just check out the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">methods of <code>Vec</code></a> as an example of what it offers.</p>
<p>If you want to write highly optimized code in Julia, you have to follow all its <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">official performance tips</a>.
You will not even get a warning if you miss some and degrade to almost the performance of plain Python (without <code>numpy</code> etc.).</p>
<p>If performance is not only &#34;nice to have&#34; for you, if every improvement can save you hours of expensive computation, you should better use Rust!</p>
<h2 id="language-server"><a href="#language-server">Language server</a></h2>
<p>Even if you are like me and use an editor instead of an IDE, you should at least use a language server.</p>
<p>Unfortunately, Julia&#39;s language server lacks a lot of features.
<a href="https://rust-analyzer.github.io/">Rust-Analyzer</a> offers many more features that make you much more productive.
Just go through the <a href="https://rust-analyzer.github.io/manual.html#features">list of features</a> and watch the GIFs.
It is just amazing!</p>
<p>One example is &#34;hovering over a variable&#34; to see its type.</p>
<p>In Julia, &#34;hovering&#34; shows you the variable&#39;s declaration üòêÔ∏è</p>
<p>In Rust on the other hand, &#34;hovering&#34; shows you the type of the variable (see <a href="https://rust-analyzer.github.io/manual.html#hover">the GIF</a>).
Seeing the type of a variable helps you with understanding what this variable actually is and how you could use it üßê</p>
<p>In Julia, you either have to read the source code that returns that variable and try to derive its type or you have to run your program while printing <code>typeof</code> ü´§</p>
<p>Maybe you can not remember the name of a specific method.
You could browse the documentation, but often it is much faster and easier to just type the variable name with a dot at the end (<code>particles.</code> for example) and then press tab.
Any further typing works as a fuzzy search!
Then you pick the method and enter the parameters while the signature is shown.</p>
<p>The language server in Julia can show you the signature, but often it is the wrong signature because of dynamic dispatch.</p>
<p>I do not even want to start talking about auto-completion and code actions in Rust.
Just try it out yourself!</p>
<p>Many of the problems are related to the dynamic typing of Julia which is supposed to be &#34;easier&#34; than static typing.
But with the assistance of Rust-Analyzer, I can flow between types and and be much more productive in the long term üí°</p>
<h2 id="documentation"><a href="#documentation">Documentation</a></h2>
<p>Take a look at Julia&#39;s official <a href="https://docs.julialang.org/en/v1/base/arrays/">API documentation</a> of arrays and their <a href="https://docs.julialang.org/en/v1/manual/arrays/">manual</a>.</p>
<p>Julia has sections in the sidebar which is nice.
But that is pretty much it for the navigation üòêÔ∏è</p>
<p>You can at least change the theme in the settings!</p>
<p>You can also search, but the search is relatively slow and there are no filtering options.</p>
<p>No wonder why some programmers are hyped about ChatGPT.
Maybe because not only writing, but also reading documentation is often a pain?</p>
<p>Now compare it with the <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html">documentation of <code>Vec</code> in Rust</a>.</p>
<p><strong>rustdoc</strong> is an underrated piece of documentation perfection!</p>
<p>You can see all methods, implemented traits and even module navigation in the sidebar.</p>
<p>The search bar gives you the hint to press <code>S</code> to search and <code>?</code> for more options.
Yes, it has keyboard shortcuts ü§©</p>
<p>If you hover over a code example, a button on the upper right is shown to run it on <a href="https://play.rust-lang.org">Rust Playground</a> which allows quick experimentation.</p>
<p>Code examples are automatically tested before publishing.
There are no examples that are not in sync after an API change!</p>
<p>You can search, filter results, search for function parameters or return types, etc.</p>
<p>The documentation of all crates is automatically published on <a href="https://docs.rs">docs.rs</a>.
You can just live there the whole day.
Just learn to navigate in rustdoc and you will not need an AI to gather snippets from here and there üòâ</p>
<p>Did I mention that you can have offline documentation if you did already download the crates?
Just run the command <code>cargo doc --open</code>.
Very useful in a train for example üöÑ</p>
<p>Oh, wait, I did not mention the official <a href="https://doc.rust-lang.org/stable/book/"><strong>Rust book</strong></a> yet?
It is very well written and available online for free!
If you want to learn Rust, just start with THE book üòç</p>
<h2 id="where-julia-shines"><a href="#where-julia-shines">Where Julia shines</a></h2>
<p>OK, enough bashing against Julia. Let&#39;s see where Julia actually shines.</p>
<h3 id="interactivity"><a href="#interactivity">Interactivity</a></h3>
<p>The second selling point of Julia on its <a href="https://julialang.org/">website</a> after performance is:</p>
<p>&#34;Julia is dynamically typed, feels like a scripting language, and has good support for <strong>interactive</strong> use.&#34;</p>
<p>This is the power of Julia!</p>
<p>Although Rust has <a href="https://github.com/evcxr/evcxr/blob/main/evcxr_repl/README.md">evcxr</a> and <a href="https://github.com/sigmaSd/IRust">irust</a>,
it will not even get close to the experience of the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">Julia REPL</a> because Rust is statically typed.</p>
<p>The Julia REPL is just fascinating! It is the best REPL I have used so far.
It is even much better than the REPLs in Python although Python is also dynamically typed!</p>
<p>You can even plot in the REPL using <a href="https://github.com/JuliaPlots/UnicodePlots.jl">UnicodePlots</a> üìà</p>
<p>I often launch it to do some quick calculations or generate some plot.</p>
<p>Rust in a notebook? There is a Jupyter kernel for Rust, but the experience is not even comparable.
It is not what Rust is designed for.</p>
<p>On the other hand, Julia is just perfect for Jupyter notebooks!
You want to do data analysis, make plots and present your results?
Julia in a Jupyter notebook is what you are looking for!</p>
<p>Many think that Jupyter notebooks where invented for Python.
But did you know that the name &#34;Jupyter&#34; is composed of <strong>Ju</strong>lia, <strong>Pyt</strong>hon and <strong>R</strong>?</p>
<p>You might ask, why not just use Python for notebooks?</p>
<p>&#34;Julia vs Python&#34; is another topic, but I will mention some points.
Julia offers much better performance than Python, makes dealing with Arrays (vectors, matrices, tensors) much easier and has an ecosystem centered around scientific computing with many unique packages (more about this later).</p>
<p>Plus, Julia is written in Julia! This makes it much easier to read and contribute to the code.
In Python, almost every package with good performance is written in C.
Have fun reading that C code!</p>
<p><a href="https://plutojl.org/">Pluto notebooks</a> take the interactivity of Julia to the next level!
If you update one cell, every other dependent cell is also updated automatically!
Without the performance of Julia, this would not be possible!</p>
<p>If you are teaching scientific programming, check out Pluto notebooks!
They are perfect for teaching!</p>
<p>In general, if you are teaching programming in a scientific context, pick Julia!
It is easier to learn and work with for most beginner&#39;s scientific use cases.</p>
<p>Maybe offer an optional course for teaching Rust for students in the scientific field that want to write large projects like long simulations.
But Rust should not be the first language to teach, unless you have students related to computer science.</p>
<p>A lot of scientific computing is about linear algebra, data analysis and plotting.
I think that Julia with its interactivity and performance is just perfect for that.</p>
<p>You don&#39;t want to wait for Rust to recompile just to see how one attribute in your plot changes, you want instant updates!</p>
<p>Although <a href="https://www.pola.rs/">Polars</a> with its dataframes offers better performance than <code>DataFrames.jl</code> (see Polars benchmarks),
I did try it and you really don&#39;t want to wait for Rust to recompile to see how your dataframe changes after changing one line.
Just use Julia with <a href="https://timholy.github.io/Revise.jl/stable/">Revise</a> for that case!</p>
<h3 id="scientific-ecosystem"><a href="#scientific-ecosystem">Scientific ecosystem</a></h3>
<p>Julia has a huge ecosystem with many scientific packages.</p>
<p>You get arrays out of the box and <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra.jl</a> is preinstalled!</p>
<p>Plotting in Julia is very fascinating with <a href="https://docs.juliaplots.org/latest/">Plots.jl</a> or even <a href="https://docs.makie.org/stable/">Makie</a>.
Makie is a whole visualization ecosystem with hardware acceleration!
Just take a look at <a href="https://blog.makie.org/blogposts/May-2023-News.html">this blog post</a> for a showcase.</p>
<p>Rust has <a href="https://github.com/plotters-rs/plotters">Plotters</a> which I really appreciate, but it has a long way to go and needs to receive more love!
Currently, it requires a lot of boilerplate code with many manual adjustments.
Julia does currently offer a <strong>much better</strong> experience for plotting.</p>
<p>Julia also has awesome packages for solving differential equations, numerical integration and even newly symbolic calculation.
Even dealing with <a href="https://github.com/PainterQubits/Unitful.jl">units</a> and <a href="https://github.com/JuliaPhysics/Measurements.jl">measurement errors</a> is a dream in Julia!</p>
<h2 id="which-language-to-use"><a href="#which-language-to-use">Which language to use?</a></h2>
<p>For scientific computing, I would recommend using <strong>Rust</strong> for projects that ‚Ä¶</p>
<ul>
<li>require non trivial concurrency</li>
<li>require the <em>maximum</em> performance</li>
<li>are going to be bigger than one script</li>
<li>are going to run for a long time and have to be reliable</li>
<li>can not afford Julia&#39;s latency (aka. time to first plot)</li>
<li>will run on a cluster</li>
</ul>
<p><strong>Julia</strong> is a much better fit for projects that ‚Ä¶</p>
<ul>
<li>require interactivity</li>
<li>teach students scientific computing</li>
<li>are time limited to about one week (a student&#39;s submission for example)</li>
<li>use plotting</li>
</ul>
<h2 id="my-personal-conclusion"><a href="#my-personal-conclusion">My personal conclusion</a></h2>
<p>To get back to the initial question: Does Julia solve the two-language problem?</p>
<p>For me, the answer is: <strong>No</strong></p>
<p>Although Julia has a just-in-time compiler that can make it very efficient, it misses the advantages of a real compiler for a statically typed language.</p>
<p>The Rust compiler is a major help for writing correct code, doing refactorings and scaling a project.
Compared to C/C++, it eliminates even more classes of bugs at compile time.
The most important ones for scientific computing are data-races, memory safety and uncaught exceptions.</p>
<p>Even if you only care about performance, for the <em>maximum</em> performance without Julia&#39;s <em>performance footguns</em>, use Rust instead of Julia!</p>
<p>Personally, I do currently use Julia for quickly testing some numerical ideas in the <em>REPL</em>, for my <em>weekly submissions</em> for lectures about numerics and for <em>plotting</em>.
For everything else including non weekly submissions and projects, I use Rust.</p>
<p>For some projects, I even use both! I export the results of my Rust program and visualize them with Julia üòÉ</p>
<p>Is the the two-language problem really a problem for developers?</p>
<p>I don&#39;t think so.
Statically and dynamically typed languages have their own strengths and use cases, especially for scientific computing.</p>
<p>I am very happy about having Julia replacing Python for scientific computing and Rust replacing C/C++ (not only in scientific computing üòâ).
It is a needed evolution of programming languages!</p>
<p>It is not a war.
The two languages should coexist.
And I will continue pushing both of them ü•∞</p>
<h2 id="appendix"><a href="#appendix">Appendix</a></h2>
<h3 id="jet-jl"><a href="#jet-jl">JET.jl</a></h3>
<p>After releasing the blog post, some people did point out that I could have used <a href="https://github.com/aviatesk/JET.jl"><code>JET.jl</code></a> which can detect the errors in my examples using a static analysis.</p>
<p>I know about JET and I think that it is an improvement.
But it will only detect <strong>some</strong> errors.</p>
<p>Julia&#39;s second selling point on its <a href="https://julialang.org/">website</a> is that it is dynamically typed which is good for interactivity and flexibility.
But a dynamically typed language can not be fully analyzed with a static analysis tool.</p>
<p>Let&#39;s take a look at the following example:</p>
<pre data-lang="julia"><code data-lang="julia"><span>function </span><span>test</span><span>()
</span><span>    v</span><span>1 </span><span>= </span><span>[] </span><span># Vector{Any}
</span><span>    v</span><span>2 </span><span>= </span><span>[</span><span>1.0</span><span>]
</span><span>    push</span><span>!</span><span>(v</span><span>1</span><span>, v</span><span>2</span><span>) </span><span># v1 is still Vector{Any}
</span><span>
</span><span>    last </span><span>=</span><span> pop</span><span>!</span><span>(v</span><span>1</span><span>) </span><span># Any
</span><span>    println(</span><span>&#34;OK&#34;</span><span>) </span><span># OK
</span><span>    println(last.pop()) </span><span># Runtime error üí•
</span><span>    println(</span><span>&#34;No problem!&#34;</span><span>) </span><span># Not reachable
</span><span>
</span><span>    </span><span>nothing
</span><span>end
</span></code></pre>
<p>As the comments show, the empty vector <code>v1</code> has the type <code>Vector{Any}</code> which is not only a <strong>performance footgun</strong> as mentioned in the post, but also a <strong>static analysis killer</strong>.</p>
<p><code>last</code> has the type <code>Any</code> because it was popped from <code>Vector{Any}</code>.
We can see in this trivial example that <code>last</code> should be <code>v2</code> which is a vector of floats.
But this knowledge can not be derived by Julia.</p>
<p><code>last</code> being <code>Any</code> means that Julia and therefore JET can not know if it supports <code>.pop()</code>.
This will only be determined at runtime which will lead to a runtime error üí•</p>
<p>Let&#39;s test the analysis of JET on our function <code>test</code>:</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt; </span><span>@report_call test()
</span><span>No errors detected
</span></code></pre>
<p><em>No errors detected</em> does not means that <em>no errors exist</em> as you can see when we run the function:</p>
<pre data-lang="julia"><code data-lang="julia"><span>julia</span><span>&gt;</span><span> test()
</span><span>OK
</span><span>ERROR</span><span>:</span><span> type Array has no field pop
</span><span>Stacktrace</span><span>:
</span><span>    ‚Ä¶
</span></code></pre>
<p>A language that offers the <a href="https://en.wikipedia.org/wiki/Top_type"><code>TOP</code></a> type (which is <code>Any</code> in Julia) can not have a full static analysis like Rust as a language with a strict type system.</p>
<p>Even JET is transparent about this in its <a href="https://github.com/aviatesk/JET.jl#detect-type-instability-with-report_opt">README</a>:</p>
<p>&#34;Note that, because JET relies on Julia&#39;s type inference, if a chain of inference is broken due to dynamic dispatch, then all downstream function calls will be unknown to the compiler, and so JET cannot analyze them.&#34;</p>
<h4 id="credits"><a href="#credits">Credits</a></h4>
<p>I want to thank the members of my lovely local Rust group for their support, feedback and corrections; especially <a href="https://www.researchgate.net/profile/Michael-Distler">Dr. Michael Distler</a>.</p>
<p>There has been a <a href="https://discourse.julialang.org/t/blog-post-rust-vs-julia-in-scientific-computing/101711">long discussion</a> about this blog post on the Julia forum.
Some corrections have been made during that discussion.
Thanks to the Julia community ‚ù§Ô∏è</p>

    </article></div>
  </body>
</html>
