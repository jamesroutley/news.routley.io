<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/francisrstokes/githublog/blob/main/2024/5/10/cordic.md">Original</a>
    <h1>Why the CORDIC algorithm lives rent-free in my head</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><em>This post is an adaptation of a <a href="https://twitter.com/fstokesman/status/1787949934123049021" rel="nofollow">twitter thread</a> I put together a few days ago.</em></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/cordic.gif"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/cordic.gif" data-animated-image=""/></a></p>
<p dir="auto">CORDIC is an algorithm for computing trig functions like <code>sin</code>, <code>cos</code>, <code>tan</code> etc on low powered hardware, without an FPU (i.e. no floating point) or expensive lookup tables. In fact, it reduces these complex functions to simple additions and bit shifts.</p>
<p dir="auto">I&#39;ll cut right to the chase and tell you <em>why</em> I love this algorithm so much, and then we&#39;ll dive into the details of exactly how it works. Essentially, the actual operations of the algorithm are incredibly simple - just shifts and adds, as I mentioned before - but it does this by combining vector math, trigonometry, convergence proofs, and some clever computer science. To me, it&#39;s what people are talking about when they describe things of this nature as &#34;elegant&#34;.</p>
<p dir="auto">Let&#39;s start with an obvious point: You don&#39;t need this if you&#39;re working on high powered hardware. This technique is applicable for embedded environments; especially less capable microcontrollers and FPGAs. Even then, it&#39;s possible that more capable hardware/peripherals will be available which would be &#34;faster&#34;, though speed is not the only measure of usefulness.</p>

<p dir="auto"><em>(if you&#39;re already familiar with fixed-point, you can safely skip this section)</em></p>
<p dir="auto">You might be wondering how are we able to avoid floating point, when functions like <code>sin(x)</code> produce values between -1.0 and 1.0? Well, floating point is not the only way of representing rational numbers. In fact, before IEEE 754 became the popular standard that it is today, <em>fixed point</em> was used all the time (go and ask any gamedev who worked on stuff between 1980 and 2000ish and they&#39;ll tell you all about it).</p>
<p dir="auto">In fact, I got nerd-sniped into this whole CORDIC investigation after listening to <a href="https://twitter.com/MicroarchClub/status/1759606520713453630" rel="nofollow">Dan Mangum&#39;s fantastic Microarch Club podcast</a>, where Philip Freidin dropped the spicy hot-take that &#34;Floating point is a crutch&#34;, and that using it might be a sign that you don&#39;t <em>really</em> understand the algorithm you&#39;re working on. Of course I should mention this was more in the context of custom ASICs rather than your run-of-the-mill webapp, but the quote really stuck with me.</p>
<p dir="auto">So how does fixed point work? Well you take an integer type like <code>int32_t</code>, and say the top 16 bits are the whole part of the number, and the bottom 16 bits are the fractional part. You could divide the number up differently (e.g. 10 bits for the whole part and 24 for the fractional), but we&#39;ll use 16/16 as an example here.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/fixed-whole-fractional.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/fixed-whole-fractional.png"/></a></p>
<p dir="auto">That gives a range of around <code>-32768.99997</code> to <code>32767.99997</code>. We&#39;ve <em>fixed</em> the radix point at the 16th bit, though again, we could have put it anywhere. Moving the point allows us to trade off for precision where it makes sense (i.e. more bits for whole numbers, or more bits for fractional representation).</p>
<p dir="auto">Something worth noting here is that the number is still an <code>int32_t</code> - we the programmers have assigned the extra meaning here (though this is also true of literally every data type in computing - there are only bits in the end!).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/fixed-point.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/fixed-point.png"/></a></p>
<p dir="auto">How do we get a number into this format? Well, we&#39;ve got 16 bits of fractional precision, so take a float like <code>42.01</code>, and scale it up by <code>(1 &lt;&lt; 16)</code>. That gives us <code>2753167</code> when cast into an <code>int32_t</code>. If we want to go from fixed point back to floating point, we just do the opposite. <code>2753167 / (1 &lt;&lt; 16)</code> gives us <code>~42.0099945</code>, which is very close to <code>42.01</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define SCALING_FACTOR (16)

static inline int32_t fixed_from_float(float a) {
  return (int32_t)(a * (float)(1 &lt;&lt; SCALING_FACTOR));
}

static inline float fixed_to_float(int32_t a) {
  return (float)a / (float)(1 &lt;&lt; SCALING_FACTOR);
}"><pre><span>#define</span> <span>SCALING_FACTOR</span> (16)

<span>static</span> <span>inline</span> <span>int32_t</span> <span>fixed_from_float</span>(<span>float</span> <span>a</span>) {
  <span>return</span> (<span>int32_t</span>)(<span>a</span> <span>*</span> (<span>float</span>)(<span>1</span> &lt;&lt; <span>SCALING_FACTOR</span>));
}

<span>static</span> <span>inline</span> <span>float</span> <span>fixed_to_float</span>(<span>int32_t</span> <span>a</span>) {
  <span>return</span> (<span>float</span>)<span>a</span> / (<span>float</span>)(<span>1</span> &lt;&lt; <span>SCALING_FACTOR</span>);
}</pre></div>
<p dir="auto">We could also forgo floating point altogether and encode a number like <code>1.5</code> manually. The whole part is just <code>1</code>, so we shift that up (<code>(1 &lt;&lt; 16)</code>), and the fractional part is the halfway point between <code>0x0000</code> and <code>0xffff</code>, so call it <code>0x7fff</code>. That gives us <code>98303</code> in decimal.</p>
<p dir="auto">Operations like addition and subtraction Just Work™ - assuming you&#39;re using the same scaling factor for whichever numbers you&#39;re operating on. It is possible to mix and match scaling factors, but it increases the complexity.</p>
<p dir="auto">Multiplication is only marginally trickier. Multiplying the two fixed point numbers together essentially scales everything up by scaling factor. This can be resolved by just shifting the result back down.</p>
<div dir="auto" data-snippet-clipboard-copy-content="static inline int32_t fixed_multiply(int32_t a, int32_t b) {
  return ((int64_t)a * (int64_t)b) &gt;&gt; SCALING_FACTOR;
}"><pre><span>static</span> <span>inline</span> <span>int32_t</span> <span>fixed_multiply</span>(<span>int32_t</span> <span>a</span>, <span>int32_t</span> <span>b</span>) {
  <span>return</span> ((<span>int64_t</span>)<span>a</span> <span>*</span> (<span>int64_t</span>)<span>b</span>) &gt;&gt; <span>SCALING_FACTOR</span>;
}</pre></div>
<p dir="auto">Division is basically the same story, except in reverse. There&#39;s a trick to squeeze out some extra precision by prescaling the dividend by the scaling factor, and then dividing by the divisor.</p>
<div dir="auto" data-snippet-clipboard-copy-content="static inline int32_t fixed_divide(int32_t a, int32_t b) {
  return ((int64_t)a &lt;&lt; SCALING_FACTOR) / (int64_t)b;
}"><pre><span>static</span> <span>inline</span> <span>int32_t</span> <span>fixed_divide</span>(<span>int32_t</span> <span>a</span>, <span>int32_t</span> <span>b</span>) {
  <span>return</span> ((<span>int64_t</span>)<span>a</span> &lt;&lt; <span>SCALING_FACTOR</span>) / (<span>int64_t</span>)<span>b</span>;
}</pre></div>
<p dir="auto">OK we can do basic operations, but what if I need something more complex, like I don&#39;t know, a trig function? This is where CORDIC comes in.</p>

<p dir="auto">CORDIC stands for &#34;co-ordinate rotation digital computer&#34;, and was cooked up back in the mid 50s (though the general algorithm has been known to mathematicians for hundreds of years). The core idea is that we can rotate a vector around a unit circle by progressively smaller and smaller angles, and the vector components will end up being the sine and cosine of the angle we&#39;re interested in.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/cordic.gif"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/cordic.gif" data-animated-image=""/></a></p>
<p dir="auto">It&#39;s sort of like a binary search:  You move towards the target angle by some large angle and check if you&#39;re ahead or behind, and then move by half that angle either clockwise or anticlockwise. This process repeats with smaller and smaller angles until the result converges.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/binary-search.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/binary-search.png"/></a></p>
<p dir="auto">If you&#39;ve worked with these kinds of operations before, you&#39;ll know that rotating a vector involves multiplying it with a matrix consisting of sines and cosines of the angle to be rotated to. That seems counter productive, since those are the functions we&#39;re trying to compute!</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
\begin{bmatrix}
x&#39; \\
y&#39;
\end{bmatrix} = \begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta) \\
\sin(\theta) &amp; \cos(\theta)
\end{bmatrix} \begin{bmatrix}
x \\
y
v\end{bmatrix}
$$</math-renderer></p>
<p dir="auto">We&#39;ll put that aside for a second, and get a big picture overview before solving this problem. Now, it&#39;s fairly obvious that rotating by say <code>22.5˚</code> is the same as rotating by <code>45˚</code> and then <code>-22.5˚</code> - i.e. we can break up a rotation into smaller parts, with both positive and negative components.</p>
<p dir="auto">Let&#39;s say that we have a maximum rotation of <code>90˚</code> (𝚷/2 radians), and we&#39;re trying to figure out <code>sin(0.7)</code> (about <code>40˚</code>). Starting with a vector <code>(1, 0)</code> and a target of <code>0.7</code> radians, we rotate <code>0.7853</code> rads (<code>45˚</code>) anti-clockwise.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/0r.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/0r.png"/></a></p>
<p dir="auto">Target now becomes <code>0.7 - 0.7853 = -0.0853</code>. Since it&#39;s negative, we now rotate clockwise by 0.3926 rads (22.5˚). Target becomes -0.0853 + 0.3926 = 0.3073, which is positive, so the next rotation will be anti-clockwise by 0.1963 rads (11.25˚).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/1r.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/1r.png"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/2r.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/2r.png"/></a></p>
<p dir="auto">If we continue this process for a total of 16 iterations, the vector lines up almost perfectly with the original target angle. The <code>y</code> value of the vector is ~= <code>sin(a)</code>, while <code>x</code> ~= <code>cos(a)</code>! This is how CORDIC works; we rotate a vector around, and the state we keep is an approximation of various trigonometric functions.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/3r.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/3r.png"/></a></p>
<p dir="auto">With some understanding in hand, we can return to the issue of, well, rotations actually requiring the functions we&#39;re trying to compute! We can use trigonometry to simplify the matrix.</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
\cos(\theta) = \frac{1}{\sqrt{1 + tan^2(\theta)}}
$$</math-renderer></p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
\sin(\theta) = \frac{\tan(\theta)}{\sqrt{1 + tan^2(\theta)}}
$$</math-renderer></p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
\begin{bmatrix}
x&#39; \\
y&#39;
\end{bmatrix} = \cos(\theta)\begin{bmatrix}
1 &amp; -\tan(\theta) \\
\tan(\theta) &amp; 1
\end{bmatrix} \begin{bmatrix}
x \\
y
\end{bmatrix}
$$</math-renderer></p>
<p dir="auto">We have a few constants ones now, but we still have the <code>tan(a)</code>, plus the <code>cos(a)</code> out front. Let&#39;s ignore the <code>cos(a)</code> and focus on getting rid of <code>tan(a)</code>. As you saw when we ran through the algorithm, we&#39;re always rotating by a total of <code>~90˚</code>: First by <code>45˚</code>, then <code>22.5˚</code>, then <code>11.25˚</code>, and so on. Since we&#39;re doing this a fixed number of times, we can just precompute those values, and put them in a table. You might be thinking: <em>&#34;You said there wouldn&#39;t be any tables!&#34;</em>. Well, no. I said there wouldn&#39;t be any <em>expensive</em> tables. This table, in our case, will only contain 16 <code>uint32_t</code>s - a whopping 64 bytes! Even the most stripped down embedded projects can <em>usually</em> afford that. (In contrast, an <em>unoptimised</em> table for <code>sin(x)</code> that contains 4096 entries covering values from -1 to 1 would need 16KiB - and that&#39;s pretty poor precision!)</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
\begin{bmatrix}
x&#39; \\
y&#39;
\end{bmatrix} = \cos(\theta)\begin{bmatrix}
1 &amp; -table[i] \\
table[i] &amp; 1
\end{bmatrix} \begin{bmatrix}
x \\
y
\end{bmatrix}
$$</math-renderer></p>
<p dir="auto">That means our rotation matrix now only contains constants! We do however still have that <code>cos(a)</code> term. In fact, every iteration brings it&#39;s own new <code>cos(a)</code> term. But because of algebra, we can simply multiply all those terms together and apply them at the end.</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
\cos(\theta_0) \cdot \cos(\theta_1) \cdot \cos(\theta_2) \cdot ... \cdot \cos(\theta_N)
$$</math-renderer></p>
<p dir="auto">Still, that&#39;s not great. But! No matter whether we take positive or negative steps, or the number of iterations, this multiplied out series of cosines actually converge to a constant value: <code>~0.6366</code>. All we need to do is to multiply out by this value after all iterations.</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
~0.6366 = \cos(\pm45˚) \cdot \cos(\pm22.5˚) \cdot \cos(\pm11.25˚) \cdot ... \cdot \cos(\pm\theta_N)
$$</math-renderer></p>
<p dir="auto">So that gives us only multiplications by constants over a number of iterations! Not bad. But didn&#39;t I say that CORDIC only used bit shifts and addition? For that, we need to go a little deeper into the rabbit hole.</p>

<p dir="auto">What the angles we plugged into <code>tan(a)</code> could instead be strategically chosen so that the result would always be an inverse power-of-2? This would be great, since multiplying or dividing by a power-of-2 is just a left or right shift for integers.</p>
<p dir="auto">Well, the <code>atan(x)</code> (arc-tangent or inverse tangent) function can do that for us. We can build a new 16-entry table, where each value is <code>atan(2**-i)</code>, for i=0 to 15. The actual rotation values for each iteration are now (<code>45˚</code>, <code>26.565˚</code>, <code>14.036˚</code>, <code>7.125˚</code>, etc).</p>
<p dir="auto">It doesn&#39;t actually half the angle each time, but as it turns out: using these angles, the process will <em>still</em> converge on the correct result! Now all those multiplications by <code>tan(a)</code> have become bit shifts by the iteration number.</p>
<p dir="auto">We still need to recompute our constant for the <code>cos(a)</code> terms. That now comes out to be around <code>0.60725</code>, which would be converted to the fixed point number <code>39796</code>.
And! It turns out there&#39;s a trick that means we don&#39;t even need to multiply by this value at the end. When we initialise the vector, we set <code>x</code> to this constant instead of 1.</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="5e937b6328392601492328bc1537dca2">$$
~0.60725 = \cos(\pm\arctan(2^{0})) \cdot \cos(\pm\arctan(2^{-1})) \cdot \cos(\pm\arctan(2^{-1})) \cdot ... \cdot \cos(\pm\arctan(2^{-N}))
$$</math-renderer></p>
<p dir="auto">So now the CORDIC algorithm looks like this:</p>
<p dir="auto">Precompute a table for <code>tan(a)</code>, where each entry is <code>atan(2**-i)</code>. These values are, of course, converted to fixed point, so: <code>atan(2**-i) * (1 &lt;&lt; 16)</code></p>
<p dir="auto">Then, when we want to compute a sine or a cosine, we take the angle (e.g. <code>0.9152</code>), convert it to fixed point: <code>0.9152 * (1 &lt;&lt; 16) = 59978</code></p>
<p dir="auto">Then setup initial parameters:</p>
<div data-snippet-clipboard-copy-content="x = 39796
y = 0
z = 59978"><pre><code>x = 39796
y = 0
z = 59978
</code></pre></div>
<p dir="auto">The <code>z</code> parameter here is not part of the vector, but rather tracks our target angle over time. The sign of this parameter determines if we rotate clockwise or anti-clockwise.</p>
<p dir="auto">With the parameters set up, each iteration looks like this (in pseudocode):</p>
<div dir="auto" data-snippet-clipboard-copy-content="if z &gt;= 0:
    x_next = x - (y &gt;&gt; i)
    y_next = y + (x &gt;&gt; i)
    z -= table[i]
else:
    x_next = x + (y &gt;&gt; i)
    y_next = y - (x &gt;&gt; i)
    z += table[i]
x = x_next
y = y_next"><pre><span>if</span> <span>z</span> <span>&gt;=</span> <span>0</span>:
    <span>x_next</span> <span>=</span> <span>x</span> <span>-</span> (<span>y</span> <span>&gt;&gt;</span> <span>i</span>)
    <span>y_next</span> <span>=</span> <span>y</span> <span>+</span> (<span>x</span> <span>&gt;&gt;</span> <span>i</span>)
    <span>z</span> <span>-=</span> <span>table</span>[<span>i</span>]
<span>else</span>:
    <span>x_next</span> <span>=</span> <span>x</span> <span>+</span> (<span>y</span> <span>&gt;&gt;</span> <span>i</span>)
    <span>y_next</span> <span>=</span> <span>y</span> <span>-</span> (<span>x</span> <span>&gt;&gt;</span> <span>i</span>)
    <span>z</span> <span>+=</span> <span>table</span>[<span>i</span>]
<span>x</span> <span>=</span> <span>x_next</span>
<span>y</span> <span>=</span> <span>y_next</span></pre></div>
<p dir="auto">Now we can follow a few iterations through, and see the algorithm converge on the correct sine and cosine values. Values in parentheses are fixed point.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/0.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/0.png"/></a></p>
<p dir="auto">During the first iteration, <code>z</code> was positive, so the vector is rotated anti-clockwise by <code>~0.785</code> rads. Note that the magnitude of the vector increased.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/1.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/1.png"/></a></p>
<p dir="auto">In the second iteration, <code>z</code> was still positive, so again the vector is rotated anti-clockwise, by <code>~0.436</code> rads, though this time it overshot the mark. The magnitude of the vector is almost one now - that&#39;s the cos(a) product term starting to converge after we set the initial <code>x</code> value!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/2.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/2.png"/></a></p>
<p dir="auto">On iteration 3, <code>z</code> was negative, so the vector is rotated clockwise by <code>~0.244</code> rads. It&#39;s clearly starting to creep up on that mark, and you can see that just a handful of iterations, we&#39;d be able to get a fairly close approximation!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/3.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/3.png"/></a></p>
<p dir="auto">On iteration 4, <code>z</code> was again negative, so clockwise rotation by <code>~0.124</code> rads. Now that the angular change is getting pretty small, and the vector is very close to the actual result, the rotations ping back and forth, getting closer and closer to the real value.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/4.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/4.png"/></a></p>
<p dir="auto">Skipping forward to the last iteration, <code>y</code> now contains a very accurate approximation for <code>sin(0.9152)</code> - with an absolute deviation of just <code>0.00000956</code>. The cosine value (in <code>x</code>) deviation is slightly higher, at <code>0.0000434</code>, but still pretty good!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/francisrstokes/githublog/blob/main/assets/cordic/16.png"><img src="https://github.com/francisrstokes/githublog/raw/main/assets/cordic/16.png"/></a></p>

<p dir="auto">There is <em>a lot</em> more to CORDIC than this, which I may cover in a future post. For instance, I didn&#39;t mention the special considerations you have to make if the angle of interest is outside of the first or fourth quadrant of the unit circle. I also didn&#39;t talk about how, with a few modifications, CORDIC can be used to compute many other functions, including <code>tan</code>, <code>atan</code>, <code>asin</code>, <code>acos</code>, <code>sinh</code>, <code>cosh</code>, <code>tanh</code>, <code>sqrt</code>, <code>ln</code>, <code>e^x</code>. Related algorithms also exist, such as <a href="https://en.wikipedia.org/wiki/BKM_algorithm" rel="nofollow">BKM</a>, designed specifically for computing logs and exponentials.</p>
<p dir="auto">I&#39;m planning on covering this in some detail on the <a href="https://www.youtube.com/@LowByteProductions?subscribe" rel="nofollow">Low Byte Productions YouTube channel</a>, so follow me there if this kind of thing is something you&#39;d like to learn more about.</p>
</article></div></section></div></div></div></div>
  </body>
</html>
