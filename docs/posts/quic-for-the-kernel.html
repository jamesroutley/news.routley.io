<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/1029851/">Original</a>
    <h1>QUIC for the kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>
The QUIC transport-layer network protocol is not exactly new; it was first
<a href="https://www.moderndescartes.com/Articles/558826/">covered here</a> in 2013.  Despite carrying a
significant part of the traffic on the Internet, QUIC has been anything but
quick when it comes to getting support into the Linux kernel.  The pace
might be picking up, though; Xin Long has posted <a href="https://www.moderndescartes.com/ml/all/cover.1751743914.git.lucien.xin@gmail.com">the first set of
patches</a> intended to provide mainline support for this protocol.
</p><p>
QUIC was created to address a number of problems that have been observed
with TCP on the modern Internet.  The three-way handshake at the core of
the TCP connection protocol adds latency to connections, causing the next
cat video to be that much slower to arrive.  TCP was not designed to
support multiple simultaneous data streams; it suffers from <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">head-of-line
blocking</a>, in which a dropped packet brings everything to a halt.  All
told, TCP does not perform as well as one might like for that all-important
web-browsing use case.
</p><p>
TCP also transmits much of its connection metadata in the clear, where any
party between the endpoints can read it.  That can result in information
leaks.  But middleboxes on the Internet also make free use of connection
information to filter out anything that does not match their idea of how a
TCP connection should work.  The result is <a href="https://www.moderndescartes.com/Articles/745590/">protocol ossification</a> — the inability to make
any changes to the TCP protocol because the result will not survive
transmission across the Internet.  Attempts to improve TCP, such as <a href="https://www.moderndescartes.com/Articles/544399/">multipath TCP</a>, have to be carefully disguised
as ordinary TCP to function at all.  TCP has become almost impossible to
improve.
</p><p>
QUIC is an attempt to address all of these problems.  A streamlined
connection-setup process eliminates the three-way handshake, making the
establishment of connections faster.  The protocol is built on top of UDP,
and is designed with multiple streams in mind; the loss of one UDP packet
will not affect any streams that did not have data in that packet.
QUIC-specific transport data is contained within the UDP packets, and is
always end-to-end encrypted, so middleboxes have no chance to inspect it.
If UDP packets can get through, anything that QUIC does can get through as well.
</p><p>
The QUIC protocol is specified in <a href="https://www.rfc-editor.org/rfc/rfc9000.html">RFC 9000</a>, with some
tweaks made in <a href="https://datatracker.ietf.org/doc/rfc9369/">RFC 9369</a>.  The
protocol is supported by a lot of software — particularly web browsers —
found on a typical Linux system and is <a href="https://blog.chromium.org/2015/04/a-quic-update-on-googles-experimental.html">said
to handle a majority of the connections</a> to Google&#39;s servers, but the
implementation is entirely in user space.  This approach was
taken to speed the development and distribution of QUIC; the people at
Google who were pushing it did not want to have to wait until
operating-system kernels with QUIC support were widely distributed.  At
this point, though, the evolution of the protocol has slowed, and minds are
naturally turning toward kernel implementations, which hold the potential
for better performance while making QUIC easily available to a wider range
of applications.
</p><p>
The patch set aims to integrate QUIC as naturally as possible into the
kernel.  There is a new protocol type — <tt>IPPROTO_QUIC</tt> — that can be
used with the <a href="https://man7.org/linux/man-pages/man2/socket.2.html"><tt>socket()</tt></a>
system call in the usual way.  Calls to <a href="https://man7.org/linux/man-pages/man2/bind.2.html"><tt>bind()</tt></a>,
<a href="https://man7.org/linux/man-pages/man2/connect.2.html"><tt>connect()</tt></a>, <a href="https://man7.org/linux/man-pages/man2/listen.2.html"><tt>listen()</tt></a>,
and <a href="https://man7.org/linux/man-pages/man2/accept.2.html"><tt>accept()</tt></a>
can be used to initiate and accept connections in much the same way as with
TCP, but then things diverge a bit.
</p><p>
Within QUIC, <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS</a> is
used to manage authentication and encryption.  Establishing a TLS session
can involve a lot of complex, policy-oriented work involving certificate
validation and more.  As with the existing <a href="https://www.moderndescartes.com/Articles/666509/">in-kernel TLS implementation</a>, QUIC pushes that
problem out to user space.  Once a connection has been made, each side must
handle the TLS handshake before the data can start flowing.  The <a href="https://man7.org/linux/man-pages/man3/sendmsg.3p.html"><tt>sendmsg()</tt></a>
and <a href="https://man7.org/linux/man-pages/man3/recvmsg.3p.html"><tt>recvmsg()</tt></a>
system calls are used to carry out that setup; the <a href="https://github.com/lxin/quic?tab=readme-ov-file#quic-in-linux-kernel">libquic library</a>
and tlshd utility (from the <a href="https://github.com/oracle/ktls-utils">ktls-utils project</a>) can be
used to handle that task.  Once TLS setup is complete, data can flow
normally between the endpoints.
</p><p>
It is worth noting that QUIC caches the results of the TLS negotiation on
both sides of the connection.  Once two systems have successfully
connected, subsequent connections can skip most of the setup work, allowing
data to be transmitted with the first packet.
</p><p>
QUIC is meant to be fast, but the benchmark results included with the patch
series do not show the proposed in-kernel implementation living up to that.
A comparison of in-kernel QUIC with in-kernel TLS shows the latter
achieving nearly three times the throughput in some tests.  A comparison
between QUIC with encryption disabled and plain TCP is even worse, with TCP
winning by more than a factor of four in some cases.  Long offers some
potential reasons for this difference, including the lack of <a href="https://docs.kernel.org/networking/segmentation-offloads.html">segmentation
offload</a> support on the QUIC side, an extra data copy in transmission
path, and the encryption required for the QUIC headers.
</p><p>
This performance gap will likely shrink over time.  One of the motivations
for getting QUIC into the kernel is to be able to take advantage of
hardware-based protocol-offload functionality; that functionality does not
really exist yet, but it seems clear that the network-interface vendors are
interested in providing it.  As QUIC gains the hardware support that TCP
benefits from, and as the in-kernel implementation is further optimized, it
should see some significant performance gains.
</p><p>
The current level of performance seemingly has not reduced interest in this
implementation, though.  There is <a href="https://gitlab.com/samba-team/samba/-/merge_requests/4019">an
outstanding pull request</a> [update: pulled on July 17] adding QUIC
support to the Samba server and 
client implementations, and interest in adding that support for the
in-kernel SMB and NFS filesystems.  There is <a href="https://github.com/moritzbuhl/curl/tree/linux_curl-wip">a repository</a>
adding kernel-based QUIC support to <tt>curl</tt>.  Once QUIC is in the
kernel, chances are that other applications will gain support as well.
</p><p>
That may take a little while, though.  The posted series adds just over 9,000
lines to the kernel, and it is only the low-level support code; another
series with the rest of the implementation is promised, but has not been
posted as of this writing.  The process of reviewing all that code has just
begun, and can be expected to take some time; consider that the <a href="https://www.moderndescartes.com/Articles/1003059/">Homa protocol implementation</a> remains unmerged
after 11 revisions posted over nine months.  QUIC may have a quicker
experience than that, but one still should not expect to see it in the
mainline before sometime in 2026 at best.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://www.moderndescartes.com/Kernel/Index">Kernel</a></td><td><a href="https://www.moderndescartes.com/Kernel/Index#Networking-Protocols">Networking/Protocols</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
