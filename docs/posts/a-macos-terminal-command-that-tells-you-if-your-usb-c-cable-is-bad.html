<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kau.sh/blog/usbi/">Original</a>
    <h1>A macOS terminal command that tells you if your USB-C cable is bad</h1>
    
    <div id="readability-page-1" class="page"><article><div data-callout-metadata="" data-callout-fold="" data-callout="fyi"><div dir="auto"><p>now includes macOS Tahoe support</p></div><p>Apple slightly altered the system command for Tahoe</p></div><p>You have a drawer full of USB cables. Half are junk that barely charge your phone. The other half transfer data at full speed. But which is which?</p><p>Android Studio solved this. Recent versions warn you when you connect a slow cable to your phone:</p><figure></figure><p>I wanted this for the command line. So I “built”<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> <a href="https://github.com/kaushikgopal/dotfiles/blob/master/bin/usbi"><code>usbi</code></a>, a script to check your USB connections.</p><p>The script parses macOS’s <code>system_profiler SPUSBHostDataType</code><sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> command, which produces a dense, hard-to-scan raw output:</p><figure><img src="https://kau.sh/images/content/uploads/2025/usbi-0.webp" alt="raw output form macos command" loading="lazy" decoding="async"/></figure><p>With a little bit of scripting, the output becomes much cleaner:</p><figure><img src="https://kau.sh/images/content/uploads/2025/usbi-1.webp" alt="usbi --speed output sample" loading="lazy" decoding="async"/></figure><p>When I connect my Pixel<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>:</p><figure><img src="https://kau.sh/images/content/uploads/2025/usbi-2.webp" alt="usbi output with pixel phone attached" loading="lazy" decoding="async"/></figure><h2 id="quick-notes-on-the-vibe-coding-experience">Quick notes on the vibe-coding experience</h2><p>The first version was a bash script I cobbled together with AI. It worked, but was a mess to maintain. Because I let AI take the wheel, even minor tweaks like changing output colors were difficult.</p><p>Second time around, I decided to vibe-code again but asked AI to rewrite the entire thing in <a href="https://go.dev/">Go</a>. I chose Go because I felt I could structure the code more legibly and tweaks would be easier to follow. Go also has the unique ability to compile a cross-platform binary, which I can run on any machine.</p><p>But perhaps the biggest reason is, it took me a grand total of 10 minutes to have AI rewrite the entire thing. I was punching through my email actively as Claude was chugging on the side.</p><p>Two years ago, I wouldn’t have bothered with the rewrite, let alone creating the script in the first place. The friction was too high. Now, small utility scripts like this are almost free to build.</p><p>That’s the real story. Not the script, but how AI changes the calculus of what’s worth our time.</p></article></div>
  </body>
</html>
