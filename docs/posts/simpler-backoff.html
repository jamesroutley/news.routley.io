<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://commaok.xyz/post/simple-backoff/">Original</a>
    <h1>Simpler Backoff</h1>
    
    <div id="readability-page-1" class="page"><article>
                <header>
                    
                    <h2>
                    May 30, 2025 
                    <br/>
                    
                    </h2>
                </header>
                <section id="post-body">
                    <p>Exponential backoff with jitter is de rigeur for making service calls. This code, or something like it, probably looks really familiar:</p>
<pre tabindex="0"><code>func do(ctx context.Context) error {
	const (
		maxAttempts = 10
		baseDelay   = 1 * time.Second
		maxDelay    = 60 * time.Second
	)

	delay := baseDelay
	for attempt := range maxAttempts {
		err := request(ctx)
		if err == nil {
			return nil
		}

		delay *= 2
		delay = min(delay, maxDelay)

		jitter := multiplyDuration(delay, rand.Float64()*0.5-0.25) // ±25%
		sleepTime := delay + jitter

		select {
		case &lt;-ctx.Done():
			return ctx.Err()
		case &lt;-time.After(sleepTime):
		}
	}

	return fmt.Errorf(&#34;failed after %d attempts&#34;, maxAttempts)
}

func multiplyDuration(d time.Duration, mul float64) time.Duration {
	return time.Duration(float64(d) * mul)
}
</code></pre><p>But we can make this much nicer with a simple <a href="https://commaok.xyz/post/lookup_tables/">lookup table</a>.</p>
<pre tabindex="0"><code>func do(ctx context.Context) error {
	delays := []time.Duration{
		1 * time.Second, 2 * time.Second,
		4 * time.Second, 8 * time.Second,
		16 * time.Second, 32 * time.Second,
		60 * time.Second, 60 * time.Second,
		60 * time.Second, 60 * time.Second,
	}

	for _, delay := range delays {
		err := request(ctx)
		if err == nil {
			return nil
		}

		delay = multiplyDuration(delay, 0.75 + rand.Float64()*0.5) // ±25%
		select {
		case &lt;-ctx.Done():
			return ctx.Err()
		case &lt;-time.After(delay):
		}
	}

	return fmt.Errorf(&#34;failed after %d attempts&#34;, len(delays))
}
</code></pre><p>This is much simpler. There are fewer variables, with smaller scope. There’s no need to reasoning about behavior across loops, and if there’s a bug in the calculations, it won’t affect subsequent iterations.</p>
<p>It is more readable. It is obvious how it will behave. It is also more editable. Changing the backoff schedule and number of attempts now feels safe and trivial.</p>
<p>Don’t write code that generates a small, fixed set of values. Use a lookup table instead.</p>

                </section>
            </article></div>
  </body>
</html>
