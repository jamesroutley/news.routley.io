<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2023/09/22/parsing-integers-quickly-with-avx-512/">Original</a>
    <h1>Parsing integers quickly with AVX-512</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>If I give a programmer a string such as <tt>&#34;9223372036854775808&#34;</tt> and I ask them to convert it to an integer, they might do the following in C++:</p>
<pre><span>std</span><span>::</span><span>string</span> s <span>=</span> <span>.</span><span>.</span><span>.</span><span>.</span>
uint64_t val<span>;</span>
<span>auto</span> <span>[</span>ptr<span>,</span> ec<span>]</span> <span>=</span>
<span>std</span><span>::</span>from_chars<span>(</span>s<span>.</span>data<span>(</span><span>)</span><span>,</span> s<span>.</span>data<span>(</span><span>)</span> <span>+</span> s<span>.</span>size<span>(</span><span>)</span><span>,</span> val<span>)</span><span>;</span>
<span>if</span> <span>(</span>ec <span>!</span><span>=</span> <span>std</span><span>::</span>errc<span>(</span><span>)</span><span>)</span> <span>{</span><span>}</span> <span>// I have an error !</span>
<span>// val holds the value</span>

</pre>
<p>It is very fast: you can parse a sequence of random 32-bit integers at about 40 cycles per integer, using about 128 instructions.</p>
<p>Can you do better?</p>
<p>The recent Intel processors have new instructions, AVX-512, that can process multiple bytes at once and do it with masking, so that you can select just a range of data.</p>
<p>I am going to assume that you know the beginning and the end of sequence of digits. The following code with AVX-512 intrinsic does the following:</p>
<ol>
<li>Computes the span in bytes (digit_count),</li>
<li>If we have more than 20 bytes, we know that the integer is too large to fit in a 64-bit integer,</li>
<li>We compute a “mask”: a 32-bit value that only the most significant digit_count bits set to 1,</li>
<li>We load an ASCII or UTF-8 string in a 256-bit register,</li>
<li>We subtract character value ‘0’ to get values between 0 and 9 (digit values),</li>
<li>We check whether some value exceeds 9, in which case we had a non-digit character.</li>
</ol>
<pre><span>size_t</span> digit_count <span>=</span> <span>size_t</span><span>(</span>end <span>-</span> start<span>)</span><span>;</span>
<span>// if (digit_count &gt; 20) { error ....}</span>
<span>const</span> simd8x32 ASCII_ZERO <span>=</span> _mm256_set1_epi8<span>(</span><span>&#39;0&#39;</span><span>)</span><span>;</span>
<span>const</span> simd8x32 NINE <span>=</span> _mm256_set1_epi8<span>(</span><span>9</span><span>)</span><span>;</span>
uint32_t mask <span>=</span> uint32_t<span>(</span><span>0xFFFFFFFF</span><span>)</span> <span>&lt;</span><span>&lt;</span> <span>(</span>start <span>-</span> end <span>+</span> <span>32</span><span>)</span><span>;</span>
<span>auto</span> in <span>=</span> _mm256_maskz_loadu_epi8<span>(</span>mask<span>,</span> end <span>-</span> <span>32</span><span>)</span><span>;</span>
<span>auto</span> base10_8bit <span>=</span> _mm256_maskz_sub_epi8<span>(</span>mask<span>,</span> in<span>,</span> ASCII_ZERO<span>)</span><span>;</span>
<span>auto</span> nondigits <span>=</span> _mm256_mask_cmpgt_epu8_mask<span>(</span>mask<span>,</span> base10_8bit<span>,</span> NINE<span>)</span><span>;</span>
<span>if</span> <span>(</span>nondigits<span>)</span> <span>{</span>
<span>// there is a non-digit</span>
<span>}</span>
</pre>
<p>This is the key step that uses the functionality of AVX-512. Afterward, we can use ‘old-school’ processing, for folks familiar with advanced Intel intrinsics on conventional x64 processors… Mostly, we just multiply by 10, by 100, by 100000 to create four 32-bit values: the first one corresponds to the least significant 8 ASCII bytes, the second one to the next most significant 8 ASCII bytes, and the their one to up to 4 most significant bytes. When the numbers has 8 digits or less, only one of these words is relevant, and when there are 16 or less, on the first two are significant. We always waste one 32-bit value that is made of zeroes. The code might look as follows:</p>
<pre> <span>auto</span> DIGIT_VALUE_BASE10_8BIT <span>=</span>
_mm256_set_epi8<span>(</span><span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span>
<span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span>
<span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span>
<span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>)</span><span>;</span>
<span>auto</span> DIGIT_VALUE_BASE10E2_8BIT <span>=</span> _mm_set_epi8<span>(</span>
<span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>,</span> <span>1</span><span>,</span> <span>100</span><span>)</span><span>;</span>
<span>auto</span> DIGIT_VALUE_BASE10E4_16BIT <span>=</span>
_mm_set_epi16<span>(</span><span>1</span><span>,</span> <span>10000</span><span>,</span> <span>1</span><span>,</span> <span>10000</span><span>,</span> <span>1</span><span>,</span> <span>10000</span><span>,</span> <span>1</span><span>,</span> <span>10000</span><span>)</span><span>;</span>
<span>auto</span> base10e2_16bit <span>=</span>
_mm256_maddubs_epi16<span>(</span>base10_8bit<span>,</span> DIGIT_VALUE_BASE10_8BIT<span>)</span><span>;</span>
<span>auto</span> base10e2_8bit <span>=</span> _mm256_cvtepi16_epi8<span>(</span>base10e2_16bit<span>)</span><span>;</span>
<span>auto</span> base10e4_16bit <span>=</span>
_mm_maddubs_epi16<span>(</span>base10e2_8bit<span>,</span> DIGIT_VALUE_BASE10E2_8BIT<span>)</span><span>;</span>
<span>auto</span> base10e8_32bit <span>=</span>
_mm_madd_epi16<span>(</span>base10e4_16bit<span>,</span> DIGIT_VALUE_BASE10E4_16BIT<span>)</span><span>;</span>

</pre>
<p><a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2023/09/22">I have implemented this function in C++</a>, and compiled it using GCC12. I run the benchmark on an Ice Lake server. I use random 32-bit integers for testing. The AVX-512 is over twice as fast as the standard approach.</p>
<table>
<tbody>
<tr>
<td>AVX-512</td>
<td>1.8 GB/s</td>
<td>57 instructions/number</td>
<td>17 cycles/number</td>
</tr>
<tr>
<td>std::from_chars</td>
<td>0.8 GB/s</td>
<td>128 instructions/number</td>
<td>39 cycles/number</td>
</tr>
</tbody>
</table>
<p>The comparison is not currently entirely fair because the AVX-512 function assumes that it knows the start and the end of the sequence of digits.</p>
<p>You can boost the performance by using an inline function, which brings it up to 2.3 GB/s, so a 30% performance boost. However, that assumes that you are parsing the numbers in sequence within a loop.</p>
<p>My original code would return fancy std::optional values, but GCC was negatively affected, so I changed my function signatures to be more conventional. Even, LLVM/clang is slightly faster in my tests, compared to GCC.</p>
<p><strong>Credit</strong>: The original code and the problem were suggested to me by John Keiser. My code is largely derivative of his code.</p>
</div></div>
  </body>
</html>
