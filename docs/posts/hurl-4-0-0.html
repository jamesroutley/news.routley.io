<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hurl.dev/blog/2023/06/30/announcing-hurl-4.0.0.html">Original</a>
    <h1>Hurl 4.0.0</h1>
    
    <div id="readability-page-1" class="page"><div>

                

                <div data-section="Blog" data-indexed="true">
                    

<p>Jun. 30, 2023</p>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.0.0">Hurl 4.0.0</a> <picture><source srcset="/assets/img/emoji-party-popper.avif" type="image/avif"/><source srcset="/assets/img/emoji-party-popper.webp" type="image/webp"/><source srcset="/assets/img/emoji-party-popper.png" type="image/png"/><img src="https://hurl.dev/assets/img/emoji-party-popper.png" width="20" height="20" alt="Partying Face"/></picture> !</p>

<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a simple plain text format:</p>

<pre><code><span><span><span><span>GET</span> <span>https://example.org/api/tests/4567</span></span>
</span><span><span></span>
<span><span>HTTP</span> <span>200</span></span>
<span></span>
<span><span>header</span> <span>&#34;x-foo&#34;</span> <span>contains</span> <span>&#34;bar&#34;</span></span>
<span><span>certificate</span> <span>&#34;Expire-Date&#34;</span> <span>daysAfterNow</span> <span>&gt;</span> <span>15</span></span>
<span><span>jsonpath</span> <span>&#34;$.status&#34;</span> <span>==</span> <span>&#34;RUNNING&#34;</span></span>    
<span><span>jsonpath</span> <span>&#34;$.tests&#34;</span> <span>count</span> <span>==</span> <span>25</span></span>      
<span><span>jsonpath</span> <span>&#34;$.id&#34;</span> <span>matches</span> <span>/\d{4}/</span></span>     </span></span></code></pre>

<p>What’s new in this release:</p>

<ul>
  <li><a href="#improved-html-report-with-request-waterfall">Improved HTML Report with Request Waterfall</a></li>
  <li><a href="#detailed-error-for-cicd">Detailed Error for CI/CD</a></li>
  <li><a href="#new-filters-decode-and-xpath">New Filters: decode and xpath</a></li>
  <li><a href="#jsonpath-change">JSONPath Change</a></li>
  <li><a href="#custom-http-methods">Custom HTTP Methods</a></li>
</ul>

<h2 id="improved-html-report-with-request-waterfall"><a href="#improved-html-report-with-request-waterfall">Improved HTML Report with Request Waterfall</a></h2>

<p>We’ve improved <a href="https://hurl.dev/docs/manual.html#report-html">Hurl HTML report</a>. The HTML report is pure HTML, without any JavaScript and with inlined CSS, so it’s should be 
easy to integrate in your favorite CI/CD solution (like <a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD</a> or <a href="https://github.com/features/actions">GitHub Actions</a> for instance). Now, each run produces:</p>

<ul>
  <li>a <strong>waterfall timeline</strong>: each request/response is displayed on a beautiful graph, with easy access to response timings (DNS, 
TCP handshake, time to first byte etc...). These timings are provided by <code>libcurl</code> and you can find an explanation of each 
indicator <a href="https://hurl.dev/docs/response.html#timings">in the documentation</a></li>
  <li>a run log with request and response headers, certificate info etc...</li>
  <li>a syntax colored source file with inline errors</li>
</ul>

<picture>
  <source srcset="/assets/img/timeline.avif" type="image/avif"/>
  <source srcset="/assets/img/timeline.webp" type="image/webp"/>
  <source srcset="/assets/img/timeline.png" type="image/png"/>
  <img src="https://hurl.dev/assets/img/timeline.png" width="100%" alt="Requests timeline"/>
</picture>

<p>The timings used to construct the requests timeline are also exposed through <a href="https://hurl.dev/docs/manual.html#json"><code>--json</code> option</a>. <code>--json</code> gives you a structured 
view of a Hurl run with errors, asserts, certificates, captures, cookies and so timings. You can even use it to produce your own report!</p>

<h3 id="once-you-see-it-you-cant-unsee-it"><a href="#once-you-see-it-you-cant-unsee-it">Once you see it, you can’t unsee it</a></h3>

<p>What’s interesting with rich visualisation is it can reveal hidden or not obvious things. For instance, you can have this
kind of gaps on some runs:</p>

<picture>
  <source srcset="/assets/img/asserts-perf.avif" type="image/avif"/>
  <source srcset="/assets/img/asserts-perf.webp" type="image/webp"/>
  <source srcset="/assets/img/asserts-perf.png" type="image/png"/>
  <img src="https://hurl.dev/assets/img/asserts-perf.png" width="734"/>
</picture>

<p>After analysis, the gap between requests in this sample test is caused by a huge numbers of assertions on the HTTP response. We have, as of Hurl 4.0.0, a naive
approach of asserts computation: each asserts of the same response is independent, and we parse and recompute every assert from scratch.
Until we see these edge cases, we were very proud of Hurl speed (due to the combination of <code>libcurl</code> and
Rust). Now, we know that we have to improve assert performance for the next release <picture><source srcset="/assets/img/emoji-sad-pensive-face.avif" type="image/avif"/><source srcset="/assets/img/emoji-sad-pensive-face.webp" type="image/webp"/><source srcset="/assets/img/emoji-sad-pensive-face.png" type="image/png"/><img src="https://hurl.dev/assets/img/emoji-sad-pensive-face.png" width="20" height="20" alt="Sad Pensive Face Emoji"/></picture> !</p>

<h2 id="detailed-error-for-cicd"><a href="#detailed-error-for-cicd">Detailed Error for CI/CD</a></h2>

<p>When you’ve error in some test, the analysis can be difficult because you don’t have a lot of information apart of the expected
values:</p>

<pre><code><span>$ </span>hurl --test test.hurl
<span>test.hurl</span>: <span>Running</span> [1/1]
<span>error</span>: <span>Assert failure</span>
  <span>--&gt;</span> test.hurl:4:0
   <span>|</span>
<span> 4</span> <span>|</span> header &#34;Control-Security-Policy&#34; contains &#34;default-src &#39;self&#39;&#34; 
   <span>|</span>   <span>actual:   none</span>
   <span>|</span>   <span>expected: contains string &lt;default-src &#39;self&#39;&gt;</span>
   <span>|</span>

<span>test.hurl</span>: <span>Failure</span> (1 request(s) in 128 ms)
--------------------------------------------------------------------------------
Executed files:  1
Succeeded files: 0 (0.0%)
Failed files:    1 (100.0%)
Duration:        130 ms</code></pre>

<p>With the new <a href="https://hurl.dev/docs/manual.html#error-format"><code>--error-format</code> option</a>, you can opt in for a longer error description. In this mode, the response header and the response
body are automatically logged:</p>

<pre><code><span>$ </span>hurl --error-format long --test test.hurl
<span>test.hurl</span>: <span>Running</span> [1/1]
<span>HTTP/2 200
</span><span>date</span>: Thu, 29 Jun 2023 16:06:58 GMT
<span>content-type</span>: text/html
<span>content-length</span>: 58941
<span>last-modified</span>: Thu, 29 Jun 2023 14:37:22 GMT
<span>etag</span>: &#34;649d9722-e63d&#34;
<span>strict-transport-security</span>: max-age=31536000; includeSubDomains
<span>content-security-policy</span>: default-src &#39;self&#39;; script-src &#39;self&#39; &#39;unsafe-eval&#39; &#39;wasm-unsafe-eval&#39;
<span>x-frame-options</span>: SAMEORIGIN
<span>x-content-type-options</span>: nosniff
<span>accept-ranges</span>: bytes

&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
    &lt;head&gt;
        &lt;meta charset=&#34;utf-8&#34; /&gt;
&lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34; /&gt;
&lt;link rel=&#34;apple-touch-icon&#34; href=&#34;/assets/img/hurl-icon-120.png&#34; /&gt;
...
...
...
    &lt;/body&gt;
&lt;/html&gt;

<span>error</span>: <span>Assert failure</span>
  <span>--&gt;</span> test.hurl:4:0
   <span>|</span>
<span> 4</span> <span>|</span> header &#34;Control-Security-Policy&#34; contains &#34;default-src &#39;self&#39;&#34; 
   <span>|</span>   <span>actual:   none</span>
   <span>|</span>   <span>expected: contains string &lt;default-src &#39;self&#39;&gt;</span>
   <span>|</span>

<span>test.hurl</span>: <span>Failure</span> (1 request(s) in 146 ms)
--------------------------------------------------------------------------------
Executed files:  1
Succeeded files: 0 (0.0%)
Failed files:    1 (100.0%)
Duration:        148 ms</code></pre>

<p>In this example, we can see that there is actually a <code>Content-Security-Policy</code> whereas we’re querying a <code>Control-Security-Policy</code>
header. The bug is now really simple to solve because the response headers and body are logged.</p>

<p>This option is really useful in CI/CD where you want to have all the available context to debug your session, without 
re-running your tests. Beware that, as the body response is logged, the log can be <em>really</em> long.</p>

<h2 id="new-filters-decode-and-xpath"><a href="#new-filters-decode-and-xpath">New Filters: decode and xpath</a></h2>

<p>Textual asserts in Hurl work by automatically decoding the response body bytes, based on the <code>Content-Type</code> response header.
That way, if we have a Latin 1 encoded HTML or an UFT-8 encoded HTML we can write the same assert without any encoding concern:</p>

<pre><code><span><span><span></span>
<span><span>GET</span> <span>https://example.org/charset/utf8</span></span>
</span><span><span><span>HTTP</span> <span>200</span></span>
<span><span>Content-Type</span>: <span>text/html; charset=utf-8</span></span>
<span></span>
<span><span>body</span> <span>==</span> <span>&#34;&lt;p&gt;café&lt;/p&gt;&#34;</span></span>
</span></span><span><span><span></span>
<span></span>
<span><span>GET</span> <span>https://example.org/charset/latin1</span></span>
</span><span><span><span>HTTP</span> <span>200</span></span>
<span><span>Content-Type</span>: <span>text/html; charset=latin1</span></span>
<span></span>
<span><span>body</span> <span>==</span> <span>&#34;&lt;p&gt;café&lt;/p&gt;&#34;</span></span></span></span></code></pre>

<p>To decode a response from bytes to text, Hurl uses <code>charset</code> hint from <code>Content-Type</code> response header. But sometimes the <code>Content-Type</code>
response header doesn’t specify any encoding. Or the encoding is indicated inside the HTML document through <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv"><code>&lt;meta&gt;</code> tag</a>:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html; charset=gb2312&#39;&gt;
    &lt;/head&gt;
    &lt;body&gt;你好世界&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>In this case, a <a href="https://hurl.dev/docs/filters.html#decode"><code>decode</code> filter</a> can now be used to explicitly decodes bytes to text and do checks:</p>

<pre><code><span><span><span><span>GET</span> <span>https://example.com/hello_gb231</span></span>
</span><span><span><span>HTTP</span> <span>200</span></span>
<span></span>
<span><span>header</span> <span>&#34;Content-Type&#34;</span> <span>==</span> <span>&#34;text/html&#34;</span></span>
<span><span>bytes</span> <span>contains</span> hex,<span>c4e3bac3cac0bde7</span>;</span> 
<span><span>bytes</span> <span>decode</span> <span>&#34;gb2312&#34;</span> <span>xpath</span> <span>&#34;string(//body)&#34;</span> <span>==</span> <span>&#34;你好世界&#34;</span></span></span></span></code></pre>

<p>As hinted in the previous Hurl snippet, you can now evaluate XPath expression on response part with a <a href="https://hurl.dev/docs/filters.html#xpath"><code>xpath</code> filter</a>.</p>

<h2 id="jsonpath-change"><a href="#jsonpath-change">JSONPath Change</a></h2>

<p>In Hurl 4.0.0, we’ve slightly changed the evaluation of <a href="https://goessner.net/articles/JsonPath/">JSONPath</a> query. There is no proper specifications for JSONPath.
The de-facto one, that Hurl tries to follow as closely as possible, is still <a href="https://goessner.net/articles/JsonPath/">https://goessner.net/articles/JsonPath/</a>.
There are a few edge cases for which several implementations differ. For instance, standard JSONPath always returns a collection, 
which most of the time is not meaningful, and harder to test. Some implementations (such as the Java library <a href="https://github.com/json-path/JsonPath">https://github.com/json-path/JsonPath</a>)
also distinguish between node value (definite path) and collection (indefinite path).</p>

<p>Basically, in Hurl 4.0.0, the only selectors returning a value are:</p>

<ul>
  <li>array index selector (<code>$.store.book[2]</code>)</li>
  <li>object key selector (<code>$.store.bicycle.color/$.store.bicycle[&#39;color&#39;]</code>)</li>
</ul>

<p>Other selectors, that use filters (for instance <code>?(@.price &gt;= 10)</code> or <code>$[*].id</code>) will return a collection. You can then use 
<a href="https://hurl.dev/docs/filters.html#nth"><code>nth</code> filter</a> to extract a value from this collection.</p>

<pre><code><span><span><span><span>GET</span> <span>https://example.com/books</span></span>
</span><span><span><span>HTTP</span> <span>200</span></span>
<span></span>
<span><span>jsonpath</span> <span>&#34;$.store.book[0].title&#34;</span> <span>==</span> <span>&#34;Dune&#34;</span></span>
<span><span>jsonpath</span> <span>&#34;$.store.book[*].title&#34;</span> <span>nth</span> <span>0</span> <span>==</span> <span>&#34;Dune&#34;</span></span></span></span></code></pre>

<h2 id="custom-http-methods"><a href="#custom-http-methods">Custom HTTP methods</a></h2>

<p>Hurl 4.0.0 supports now any custom HTTP method. The only constraint is to write the method in uppercase. You can right-away
experiment the <a href="https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html">incoming new <code>QUERY</code> method</a>:</p>

<pre><code><span><span><span><span>QUERY</span> <span>https://example.org/contacts</span></span>
<span><span>Content-Type</span>: <span>example/query</span></span>
<span><span>Accept</span>: <span>text/csv</span></span>
</span><span><span><span>HTTP</span> <span>200</span></span>
<span><span>Content-Type</span>: <span>text/csv</span></span>
<span><span>```</span>
<span>surname, givenname, email</span>
<span>Smith, John, john.smith@example.org</span>
<span>Jones, Sally, sally.jones@example.com</span>
<span>Dubois, Camille, camille.dubois@example.net</span>
<span>```</span></span></span></span></code></pre>

<h2 id="others"><a href="#others">Others</a></h2>

<p>There are other improvements and bug fixes, you can check a complete list <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.0.0">in our release note</a>.
If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>

<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>


                </div>
                
            </div></div>
  </body>
</html>
