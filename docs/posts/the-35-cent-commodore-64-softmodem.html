<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://oldvcr.blogspot.com/2025/01/the-35-cent-commodore-64-softmodem.html">Original</a>
    <h1>The &#34;35-cent&#34; Commodore 64 softmodem</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-9090638096945805573" itemprop="description articleBody"><p>
Rockwell famously used 6502-based cores in modems for many years, but that doesn&#39;t mean other 6502s couldn&#39;t be used. If only there were a way to connect a Commodore 64&#39;s audio output directly to an RJ-11 plug ...

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEicgJ_P_l9jrlam8vXtLDPVRy1I3wywiukwyeekLYH9F5X9pKuxOg10Aw961UNP1OdpVi3RNowJERah5zfhgZsJUiH8Yj0KCdeLtxxfYAceW5Plzz_SJnbf_f2mn4i1oKmOyTkALM6HZa_HevarRz4QPkFpizcRFPK_CMixHuAPXuS2Q9-5ZnOr7d-Zq1g/s4080/PXL_20241214_012101837.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEicgJ_P_l9jrlam8vXtLDPVRy1I3wywiukwyeekLYH9F5X9pKuxOg10Aw961UNP1OdpVi3RNowJERah5zfhgZsJUiH8Yj0KCdeLtxxfYAceW5Plzz_SJnbf_f2mn4i1oKmOyTkALM6HZa_HevarRz4QPkFpizcRFPK_CMixHuAPXuS2Q9-5ZnOr7d-Zq1g/s320/PXL_20241214_012101837.jpg" width="320"/></a></p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjEBvNUksDTdYSiG6-Z6Afj_UwLKUS7azVQ_P6W6N5_cnOattQ_m1-w8CFtPgqColprtT0QtRqjOCRTKm3D1t3Caq6iK_B_0guANQpKCCibdFhuEMHRef4fszqQS-TIMllfP3U42Ijgxg3xj6zhFEoKtUht5HqgN27w0MLuzvyQajp8oWHzhS2bi2qAmRM/s4080/PXL_20241214_055807058.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjEBvNUksDTdYSiG6-Z6Afj_UwLKUS7azVQ_P6W6N5_cnOattQ_m1-w8CFtPgqColprtT0QtRqjOCRTKm3D1t3Caq6iK_B_0guANQpKCCibdFhuEMHRef4fszqQS-TIMllfP3U42Ijgxg3xj6zhFEoKtUht5HqgN27w0MLuzvyQajp8oWHzhS2bi2qAmRM/s320/PXL_20241214_055807058.jpg" width="320"/></a></p><p>

Of the many interesting posts from Usenet&#39;s more golden days, one of my favourites was John Iannetta&#39;s &#34;35-cent modem,&#34; where the SID chip provides one-way data modulation to a receiving modem connected via the C64&#39;s sound output. While I remember him posting it back in 1998, I never actually tried it at the time.
</p><p>
Wouldn&#39;t you know it, but it came to mind the other day when I was looking at a recent haul of <a href="http://oldvcr.blogspot.com/2024/09/programming-convergent-workslates.html">Convergent WorkSlate stuff</a> I&#39;ve got to catalogue. Officially the WorkSlate&#39;s only means of telecommunications is its 300 baud internal modem. While we have a 9600bps way of wiring up a Workslate to a modern computer, it&#39;s always nice to have a simpler alternative, and I figured this would be a great challenge to see if John&#39;s old program could let my Commodore SX-64 talk to my WorkSlate. Spoiler alert: <em>it works!</em>
</p><p>
<a name="more"></a>

I don&#39;t know precisely what happened to John; regrettably I know little of his personal history. For a period of time he was a very prolific poster on <tt>comp.sys.cbm</tt>, but his last post there was July 19, 2000, in which he replied to someone&#39;s question about the relationship between sound frequencies and SID register values. (We&#39;ll actually talk about this in a bit.) His last post I can find in any Commodore newsgroup of the era is dated the next day, July 20, though he posted through CompuServe and it&#39;s possible may have made later posts there. Among his many contributions, including this one, are the Spyne self-extracting file archive utility, a .d64 downloader patch for Common Sense, an in-place PETSCII to ASCII text file converter, a user port-based audio A/D converter and player, and a custom track-by-track floppy disk formatting tool. He issued them all freely for anyone to use for any purpose. While he and I briefly corresponded over snail mail, I can&#39;t find the letter he sent me and I don&#39;t remember his exact location, and I never heard from him again. Sadly, although I hope I&#39;m wrong, from his handwriting I knew he wasn&#39;t a young man and I&#39;m all but certain he has since passed away. Rootsweb lists a John J. Iannetta who died in April 2001 at the age of 82. (If you know for sure, post in the comments, or E-mail me privately at ckaiser at floodgap dawt com.)
</p><p>
The &#34;35-cent modem&#34; was first posted on October 27, 1998. John estimated the 35 cent cost based on the then-purchase price of an RCA jack (&#34;listed in my Jameco catalog at 35 cents each&#34;), though this didn&#39;t include the phone cable, or about 68 cents in 2025 dollars. Looking in their online catalogue now, you could even go cheaper, since Jameco (not affiliated, not sponsored, just using for comparison) now sells <a href="https://www.jameco.com/z/KLPX-0848A-2-R-Kycon-RCA-Phono-Jack-Connector-Red-PCB-Right-Angle_2328943.html">a through-hole right-angle RCA jack</a> for $0.29 — in 1998 dollars, that would have been a mere 15 cents. If you don&#39;t have a landline phone cable anymore, the lowest Jameco price for a compatible connector I could find was <a href="https://www.jameco.com/z/8102-66107-Jameco-ValuePro-Modular-Phone-Cable-6P6C-7-Flat-Silver-RJ12-RJ11-_2309383.html">a 6P6C modular cable</a> for $1.49. Such a cable is <em>technically</em> a RJ-25, but it or an RJ-14 (6P4C) will do just fine. This project is a very easy build job, so let&#39;s do it.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi_4eUBERlWMqJVgwjW-bOAwz5Oeaubt5_7cPQAzH8WFEBkkfpXQ_ftaPOpD05NAv5-SN4Dbdi9e6uB9uBvXH-4KBwn87zV9ykayCuhv15fYDt57t5w6c_F8JZeI9O_Ss_4miO-Za1GGSEZeNjuiN9aHNNSxzz0E8ndoptIhjPkQ0SwdIbr_Ag716Kq1RU/s4080/PXL_20241226_044626191.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi_4eUBERlWMqJVgwjW-bOAwz5Oeaubt5_7cPQAzH8WFEBkkfpXQ_ftaPOpD05NAv5-SN4Dbdi9e6uB9uBvXH-4KBwn87zV9ykayCuhv15fYDt57t5w6c_F8JZeI9O_Ss_4miO-Za1GGSEZeNjuiN9aHNNSxzz0E8ndoptIhjPkQ0SwdIbr_Ag716Kq1RU/s320/PXL_20241226_044626191.jpg" width="320"/></a></p><p>

The key notion is that we&#39;re replacing the telephone tip and ring connection (carried on the innermost centre conductors of the RJ-11 cable) with an RCA phono jack that we can directly connect to the 64&#39;s audio line output. We last talked about tip-and-ring when we discussed <a href="http://oldvcr.blogspot.com/2022/05/so-long-home-t1-line-hello-hacking-t1.html">how T1 lines work</a>. On old exchanges like this one (used in rural New South Wales, Australia), phone lines were carried by literal tip-and-ring connectors plugged into the switchboard to connect calls, which is where the name comes from. Telco guys call a combination of tip and ring a &#34;pair.&#34; Each phone line uses one pair.
</p><p>
Although it likely makes little difference for this application, there is a polarity to the connection which should be observed, i.e., tip is positive and ring is negative. The cable I used is a real USOC RJ-11C with a 6P2C connector and thus has only two wires for a single pair. The tip wire for this first pair on typical North American RJ-11 installations can be green, or white with a blue stripe (in other countries <a href="https://en.wikipedia.org/wiki/Registered_jack#RJ11">it may be any number of other colours</a>); the ring wire can be red, blue, or blue with a white stripe. Thus, after stripping back the wires — sometimes easier said than done on a sticky old cable — connect ring to the phono jack&#39;s ground/sheath and tip to the phono jack&#39;s centre. Make it pretty and you&#39;re done.
</p><p>
An important warning before we continue: from the telephone company side the line pair carries voltage used to power the phone and ringer, so <em>never</em> plug this cable into a wall jack — doing so could potentially send up to 48 volts to the computer, with likely undesirable and even fiery results. A cable like this should only ever be directly connected to another modem.
</p><p>
The software part has to do with how data from the Commodore 64 is modulated to send to the other system&#39;s modem. For that, we turn to John&#39;s program, as he posted it (in separate versions for NTSC and PAL Commodores for reasons I&#39;ll explain as we analyse the disassembly). It was presented as a type-in program in BASIC, short enough to type in by hand, with an embedded machine language section loaded from DATA statements. Here&#39;s a couple videos showing what it looked like in practice. The modulated audio is played through the speaker, so don&#39;t have it up too high.
</p>
<p>
After the machine code is transferred to memory, a continuous tone starts playing and the program enters a basic terminal mode. As we type on the keyboard, we hear the tone &#34;warble&#34; as each bit of the character&#39;s ASCII value is modulated and played to the other end.
</p>
<p>
If you press F1, it will then give you the opportunity to send a file. This file is sent using Xmodem-CRC so the remote side can reliably detect errors, but since the transmission is one-direction the 64 side simply pretends everything succeeds, pauses briefly to let the other end send its acknowledge byte, and then goes onto the next block. You can hear the file itself being modulated in the audio also; around 1&#39;10&#34; the last block is sent, which is padded with ^Z and thus has a characteristic repeated sound (plus a single &#34;blip&#34; after it for the end-of-text character ^D). When the transmission is complete, the program ends.
</p><p>
The modulation scheme itself is very simple, and the phone dweebs reading this have already guessed what it is just from the audio.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiDm3OdXZ8Y4dfIwS52TDjvFbiUQP4ryzPSIFqu3KjdpVgDLefCX_rOhA3pJ2F4Ef59tu23gzpyX9usAwVjjG6px7UczAr10puepdctaOkJz7J0PpecwYRcHTF2laR02hBRlt8_fAltmmCyBCkmV_DK5cK6o-F0bfCq15Wr1WjjPBo5q6oPjWiihxeP/s1800/serial.png"><img alt="" data-original-height="600" data-original-width="1800" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiDm3OdXZ8Y4dfIwS52TDjvFbiUQP4ryzPSIFqu3KjdpVgDLefCX_rOhA3pJ2F4Ef59tu23gzpyX9usAwVjjG6px7UczAr10puepdctaOkJz7J0PpecwYRcHTF2laR02hBRlt8_fAltmmCyBCkmV_DK5cK6o-F0bfCq15Wr1WjjPBo5q6oPjWiihxeP/s320/serial.png" width="320"/></a></p><p>

Recall from earlier discussions, such as when we wrote a bitbanged serial transmission routine <a href="http://oldvcr.blogspot.com/2023/05/the-kim-1-that-sounds-like-stephen.html">so the KIM-1 could speak through a DECtalk</a>, that the transmission of a byte or character of data is divided into more or less distinct phases. The default state is mark (one). At the beginning of transmission comes a start bit (always space, or zero), followed by the data (seven or eight bits). After the data comes an optional parity bit, then back to the stop bit for at least one and sometimes two or more bit times. The most common transmission type is 8N1, which is eight data bits, no parity bit, and one stop bit (i.e., characters must be separated by no <em>less</em> than one stop bit, though it can be more).

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9j7bAp1i37oznt0LZML1N35PSDKloRRYAwB1F8CTiBIMPBRimaaaL8jvk7z0gceAv7QoJC12vAavYToTjimnlB3M3xv3JxcAArRR3BnekIC0z8ss4gu-WGxIaMGsl48-cFaF44gy3N8exy5uySX2ZUXw2Y5Y62OkUTNMkyO5zbWGqhvlDOQ9TO6CDeYc/s3360/Screenshot%202025-01-15%20at%208.09.21%E2%80%AFPM.png"><img alt="" data-original-height="2100" data-original-width="3360" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9j7bAp1i37oznt0LZML1N35PSDKloRRYAwB1F8CTiBIMPBRimaaaL8jvk7z0gceAv7QoJC12vAavYToTjimnlB3M3xv3JxcAArRR3BnekIC0z8ss4gu-WGxIaMGsl48-cFaF44gy3N8exy5uySX2ZUXw2Y5Y62OkUTNMkyO5zbWGqhvlDOQ9TO6CDeYc/s320/Screenshot%202025-01-15%20at%208.09.21%E2%80%AFPM.png" width="320"/></a></p><p>

If we load the audio up into an acoustic analysis program like <a href="https://www.fon.hum.uva.nl/praat/">Praat</a>, we see a sine wave of varying wavelength. In the spectrogram at the bottom we can pick out two distinct frequencies being used to encode a character, as shown on the dark black band. This is the hallmark of audio frequency-shift keying (AFSK), or often just called FSK.
</p><p>
For this spectrogram I&#39;ve typed the letter &#34;U&#34; which in binary is 01010101. That&#39;s the &#34;wiggle&#34; in the middle. John&#39;s program sends 8-N-1, so since we know the byte is framed by stop bits, which are marks/ones, we can deduce the initial frequency is used to transmit a one. Serial communications send the bits in little endian order, i.e., from least significant to most significant, meaning the wiggle is actually the start bit (space/zero), followed by 10, 10, 10, 10, then a stop bit (mark/one) and finally the normal mark state between bytes, which in this plot is indistinguishable from the stop bit.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgL3ohlj3HlOaD674DyqHf26qFiKDjou0nkGIszB-fnXN_EtezS_zA2Go6lwZ7aEqyZrCPsTtLH5XJk3_Lg8n5PD6-2eWL2vYr3Cye-j5HMi_nM0I9ARk-gaBHXBc-_8jSmVDSwhjBqprk-aOge_rsuUoLosOjMLwSIPbNCU4L7GYxQqYmhO1OUeB2zYQg/s3360/Screenshot%202025-01-15%20at%208.07.23%E2%80%AFPM.png"><img alt="" data-original-height="2100" data-original-width="3360" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgL3ohlj3HlOaD674DyqHf26qFiKDjou0nkGIszB-fnXN_EtezS_zA2Go6lwZ7aEqyZrCPsTtLH5XJk3_Lg8n5PD6-2eWL2vYr3Cye-j5HMi_nM0I9ARk-gaBHXBc-_8jSmVDSwhjBqprk-aOge_rsuUoLosOjMLwSIPbNCU4L7GYxQqYmhO1OUeB2zYQg/s320/Screenshot%202025-01-15%20at%208.07.23%E2%80%AFPM.png" width="320"/></a></p><p>

By zooming in on the spectrogram we can quantify the frequencies more precisely. Eyeballing the centre of the black band during the stop bit, we get ~2226Hz.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiuKrAKs_j-jUTC6-6MXb7L4fEGRkuUKn0ZXtqsjSuuO1kNgV2l74WndPhWxSHmJrsI9QsTCdppIrb-43d3z-k_h_T6v469OXNURlKKn8DTp43LDvqGT1AGJ7U3JH0k1gtmHXAEMewED6__AXZuwyEcTnaGWNgDZ31Sf54GeBJPARLJjZg3qiq4XiNoYu8/s3360/Screenshot%202025-01-15%20at%208.08.05%E2%80%AFPM.png"><img alt="" data-original-height="2100" data-original-width="3360" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiuKrAKs_j-jUTC6-6MXb7L4fEGRkuUKn0ZXtqsjSuuO1kNgV2l74WndPhWxSHmJrsI9QsTCdppIrb-43d3z-k_h_T6v469OXNURlKKn8DTp43LDvqGT1AGJ7U3JH0k1gtmHXAEMewED6__AXZuwyEcTnaGWNgDZ31Sf54GeBJPARLJjZg3qiq4XiNoYu8/s320/Screenshot%202025-01-15%20at%208.08.05%E2%80%AFPM.png" width="320"/></a></p><p>

Similarly, the centre of the black band during the start bit looks around 2054Hz. In fact, the frequencies are officially 2225Hz and 2025Hz, exactly 200 cycles apart, allowing easy distinguishability on an acoustic coupler or analogue phone lines of even poor quality. (Note that the band&#39;s thickness in these images can vary based on the analysis time slice used to compute the spectrogram.) These two frequencies represent the answer side of a Bell 101 or 103-compatible modulation scheme.
</p><p>
The Bell 101 was the first commercial modem (then called a &#34;data set&#34;), developed by AT&amp;T in 1958 for the U.S. military&#39;s Semi-Automatic Ground Environment (SAGE) environment. SAGE integrated data from multiple radar sites into a common wide-area view used as part of NORAD&#39;s nuclear response capability and was at least in part the inspiration for <i>Dr. Strangelove</i>. It remained in operation well into the 1980s; even as just a giant coincidence there are many suspicious similarities between the concept and <i>WarGames</i>&#39; WOPR. The 101 ran at 110 baud over regular telephone lines and became available for commercial sale in 1959. On the wire it uses separate sets of frequencies for each side of the conversation: 1070Hz and 1270Hz (space, mark) for the modem <em>originating</em> the call, and 2025Hz and 2225Hz (space, mark) for the modem <em>answering</em> the call.
</p><p>
In 1962 AT&amp;T introduced the Bell 103, which used the same frequencies but ran over twice as fast at 300 baud. It quickly became very popular and almost completely replaced the 101 in commercial use. Even after the 1976 Bell 202 introduced 1200 baud operation (with different frequencies and duplex modes), it remained compatible with the 103 in 300 baud mode, and virtually every third-party 300 baud modem was compatible as well (many were also compatible with ITU-T V.21, which uses the same basic communication scheme but different frequency sets). The Originate-Answer switch on 300 baud modems like the Commodore 1600 VICMODEM and Commodore 1660 &#34;Modem/300&#34; selects which two frequencies the modem will send bits with, using the other two frequencies for receiving. Since any 300bps modem can speak Bell 103, that&#39;s why John chose it, and since we&#39;re &#34;responding&#34; to the other side that &#34;initiated&#34; the &#34;call&#34; this code uses answerer frequencies.
</p><p>
The software came in both NTSC and PAL versions because obviously something like this is highly timing-dependent, and PAL Commodore 64s run slightly slower (0.985250MHz) than NTSC systems (1.022730MHz). The variance is because each video standard uses a different master crystal from which all other clocks are obtained by dividing down, including the colourburst frequency needed for correct display, and also the clock speed of the CPU. This speed additionally affects the 6581 SID sound chip, since each of its three oscillators are incremented by the given audio value (0-65535) every clock cycle, so we need different values for the mark and space frequencies on PAL and NTSC systems. John&#39;s last known post in <tt>comp.sys.cbm</tt>, using slightly different processor speeds, explains the math (shown as written):
</p><div><pre>It might be a good idea if you ask specific questions, since we don&#39;t
know what info you already have. Regarding the low/high values for frequency
(for registers 0/1, 7/8, and 14/15), together they defines a 16-bit word:

Word = low_value + 256 * high_value

The frequency of the tone is proportional to that value:

Frequency = Word * F / 2^24

where F = system clock frequwency (1.022727 MHz for NTSC and 0.985249 MHz for
PAL). So we get:

Frequency = Word / A

where A = 16.4044 for NTSC and 17.0284 for PAL.
</pre></div>
<p>
Using this relationship, we can then solve for &#34;word&#34; to get the proper value for the SID frequency register based on the detected video standard. SID&#39;s three voices are thus able to generate tones up to ~3848Hz on PAL machines and ~3995Hz on NTSC machines, well in excess of the necessary range. Because SID generates audio asynchronously, we can just tell it to use infinite sustain (to infinitely prolong the note until we gate it off), play the mark frequency, and then leave the note playing while we go do something else, keeping the line open. Since the specification requires a sinusoidal wave, the code uses the SID&#39;s triangle waveform which is the closest approximation. The result is, in fact, the very tone you hear at the beginning of the videos.
</p><p>
However, there&#39;s one other reason we need separate NTSC and PAL versions, and that&#39;s because of how John set up the baudrate. Here&#39;s how the BASIC loader starts (from the NTSC version):
</p><div><pre>10 poke55,.:poke56,160:clr:c=49152:b=1
20 ready$:print&#34;reading line&#34;;b;&#34;of 20&#34;
30 fork=1to2:a$=mid$(y$,j*2+k)
40 a=asc(a$)-48:ifa&gt;9thena=a-7
50 e=a+16*e:next:ife=256then90
60 pokej+i+c,e:n=n+e:j=j+1:e=0
70 ifj=15thenj=0:i=i+15:b=b+1:goto20
80 goto30
90 s=54272:ifn=38107then110
100 print&#34;data statement error&#34;:end
110 d=56320:fori=stos+24:pokei,.:next
120 e=56576:pokee+4,80:z=d+13:pokez,127
130 pokee+5,13:pokee+13,127:pokee+15,8
140 pokes+6,240:pokes,148:pokes+1,142
150 pokes+24,6:pokee+11,.:pokee+14,1
160 poked+15,8:poked+11,.:pokes+4,17
170 sys49152:pokez,129:ifpeek(2)then190
180 end
</pre></div>
<p>
After reading the hex-encoded DATA statements into memory, at line 110 John&#39;s code starts initializing both the SID and the two CIA chips, though he primarily uses CIA #2. To determine bit times, rather than having the CPU manually count off a specific number of clock cycles, this code has the CIA do it. A critical point is that while the CIA chips can be set to issue IRQs or not, their interrupt control registers will still indicate when they <em>would have</em> fired one, even if that individual interrupt condition is technically disabled. John turns off all interrupts on both CIAs so they won&#39;t fire and upset system timing, including the usual Timer A IRQ on CIA #1 used for keyscan, then sets Timer A on CIA #2 to repeatedly count down $0d50 (3408) clock cycles. If we divide 1022730 by 3408, we get ... 300.09, almost exactly our baud rate. (It&#39;s okay to be a bit faster as long as you&#39;re never slower.) A smaller value is used for PAL systems.
</p><p>
With the CIAs (and audio) set up, we then go into the mini-terminal, which is loaded into memory and started from the usual location for such routines at 49152 ($c000). We disassemble that next.
</p><div><pre>lc000   jsr $e518     ; Kernal cint without PAL/NTSC detect
lc003   lda $dc0d     ; wait until Timer A interrupt time
        beq lc003
lc008   jsr $ea87     ; Kernal scnkey
        lda $c6
        beq lc003     ; no key, go back to waiting
lc00f   jsr $f142     ; Kernal getin but always keyboard
        cmp #$85      ; F1
        beq lc024
lc016   cmp #$88      ; F7
        beq lc022
lc01a   jsr $e716     ; Kernal chrout to screen
        jsr lc027     ; modulate the character
        bcc lc003     ; go again
lc022   lda #$00
lc024   sta $02
        rts
</pre></div>
<p>
John chose to call direct into the Kernal for these routines to short-circuit code he didn&#39;t need. With thousands of cycles available to send each single bit, the full-fat routines would have been fine, but why bother with work you don&#39;t need to do? After initializing the screen editor, the code waits for the next Timer A interval to fire and scans the keyboard manually (since the IRQ isn&#39;t running anymore), then fetches the next key, if there is one. Assuming it&#39;s not F1 (send a file) or F7 (quit the terminal), the code then goes on to send a character using this subroutine at $c027:
</p><div><pre>lc027   sta $b0       ; stash registers
        stx $b1
        sty $b2
        ldx $dd0d     ; clear ICR on CIA #2
lc030   ldx $dd0d     ; wait for Timer A CIA #2
        beq lc030
</pre></div>
<p>
Each access on the interrupt control register clears any conditions that were set. This apparent &#34;double-wait&#34; on entering the routine isn&#39;t an error: it ensures not only that everything&#39;s in a known state, but that also at least one stop bit&#39;s interval has elapsed between the prior character and this one. Once that has occurred, we clock out the start bit, then eight data bits least significant first, and finally leave back at the stop bit frequency. Each time, except for the very end, we wait for another trigger on CIA #2&#39;s ICR before we proceed.
</p><div><pre>lc035   ldx #$81
        stx $d401
        ldx #$c3
        stx $d400     ; start bit = 0 = 2025 Hz
        ldy #$08
lc041   ldx $dd0d     ; wait for next interval
        beq lc041
        ; shift bits out
lc046   lsr
        bcs lc058
lc049   ldx #$81
        stx $d401
        ldx #$c3
        stx $d400     ; 0 bit = 2025 Hz
        dey
        bne lc041
lc056   beq lc065
lc058   ldx #$8e
        stx $d401
        ldx #$94
        stx $d400     ; 1 bit = 2225 Hz
        dey
        bne lc041
lc065   ldx $dd0d     ; wait one bit time on last bit
        beq lc065
lc06a   ldx #$8e
        stx $d401
        ldx #$94
        stx $d400     ; stop bit = 1 = 2225 Hz
        lda $b0
        ldx $b1
        ldy $b2       ; restore registers
        clc           ; jorb well done
        rts
</pre></div>
<p>
When F1 or F7 is pressed, the mini-terminal sets location $2 to non-zero or zero respectively (above, after the call at $c00f) and returns to BASIC. BASIC then turns back on the Timer A IRQ on CIA #1, and if $2 is non-zero, it proceeds to ask for a device number and filename. This is a fun routine on its own, but you&#39;ve seen enough of the code to understand the basics of how it works, so let&#39;s get out the WorkSlate now and try it with a real device.
</p><p>
For the Commodore side, we&#39;re going to use one of my portable <a href="http://oldvcr.blogspot.com/2020/12/unboxing-best-gift-of-1983-commodore-sx.html">SX-64</a> systems. A warning about the SX-64 specifically: <em>never</em> plug in a video cable — more specifically, never connect the audio output — with the computer&#39;s power on. Doing so runs you a decent chance of frying the SID, something I actually did many years ago and is a well-known problem. This goes likewise for connecting our mutant phone cable to the SX-64, since we necessarily have to use the computer&#39;s video port for the audio signal.
</p><p>
The WorkSlate has a built-in terminal desk accessory which can be activated from the Phone menu and selecting Terminal. However, simply selecting the Terminal is not enough. The trick with the WorkSlate is to have the speakerphone line open (Phone, SpkPhone) <em>first</em>, and <em>then</em> try to answer with the Terminal. This is supported by the device; it assumes in this case that you&#39;ve manually dialed a number somehow (say, from an attached phone handset) and the computer on the other end has answered. We already have the answer stop bit tone playing, so the WorkSlate&#39;s modem immediately hears it and tries to go on-line.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBwmCwE3lNLpIucSgt8Jf9iUJc3kffQ-1v0rt4_B6nOUKh0wEoXbB05qkDbV8e7vmlE6rm9bUPiFDTh2TTIkTuYW5Tb97ljzpisKSYuOdvdtRyHIkDSbCsjtl_UxI7LcE2Vy21OuVQI4N1IcQ4bY3ziH-u_RLiodPGcEdj89nwAZf5QGN30zNu5ZZ6PME/s4080/PXL_20241214_045255477.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBwmCwE3lNLpIucSgt8Jf9iUJc3kffQ-1v0rt4_B6nOUKh0wEoXbB05qkDbV8e7vmlE6rm9bUPiFDTh2TTIkTuYW5Tb97ljzpisKSYuOdvdtRyHIkDSbCsjtl_UxI7LcE2Vy21OuVQI4N1IcQ4bY3ziH-u_RLiodPGcEdj89nwAZf5QGN30zNu5ZZ6PME/s320/PXL_20241214_045255477.jpg" width="320"/></a></p><p>

And here we are! John&#39;s code indeed works as written and what we type on the SX-64 appears on the WorkSlate. The initial call to Kernal CINT resets the Commodore to uppercase/graphics mode, so we don&#39;t need a PETSCII-to-ASCII conversion step because unshifted letters we type on the Commodore come out as uppercase on both sides. If you were doing this with a Hayes-compatible modem connected to the C64, a command like </p><tt>ATX1D</tt><p> sets up a &#34;blind dial&#34; so that the 64&#39;s answer signal is also immediately recognized.
</p><p>
The interesting part is comparing how the speakerphone operated between the three WorkSlates I now have. On the most recent one I acquired and on my &#34;tester&#34; unit that I soldered jumper probes to (both with serial numbers starting with CCA8415), I could hear the &#34;call&#34; and what the SX-64 was sending when the WorkSlate was in speakerphone mode, as expected. However, on my regular unit (a later machine with a CCA8417 serial number), I could hear <em>both</em> ends of the conversation through the <em>SX-64&#39;s</em> speaker, including the Workslate&#39;s dial tones and originate frequencies — and <em>nothing</em> on the WorkSlate&#39;s speaker. I&#39;m not sure if this is due to different internal wiring, changes in the tape gate array or both. Again, this is a good reminder that the SID in the SX-64 is unusually vulnerable to stray voltages: if there were proper isolation I shouldn&#39;t have been able to hear <em>incoming</em> audio through the speaker output. In fairness, Commodore probably didn&#39;t think people would be wiring phone lines to SID audio either.
</p><p>
But let&#39;s embroider the situation a little more. Some modems may listen for a dial tone first before they attempt to do anything, especially if you need to actually dial a phony (narf narf narf) telephone number, since they reasonably expect there&#39;s a real POTS &#34;plain old telephone service&#34; line on the other side.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgzMbUuc2IodT6aw6BHMyyp8toCVNCM6VywB0D4LX0hLkAzw8YwzR8liGMd-vIruJcPlBPnObEV2vbcGl1nJVEIjCYiUpe2zvBmGmChaEMARmauZ39TJez7nXysxSXqDgZA3mwbDCHdIlUZF8Zf9RGyPR1esy0-WuvmPtngx7wQrbFAncJet8vyTrBDpYc/s4080/PXL_20241214_050441231.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgzMbUuc2IodT6aw6BHMyyp8toCVNCM6VywB0D4LX0hLkAzw8YwzR8liGMd-vIruJcPlBPnObEV2vbcGl1nJVEIjCYiUpe2zvBmGmChaEMARmauZ39TJez7nXysxSXqDgZA3mwbDCHdIlUZF8Zf9RGyPR1esy0-WuvmPtngx7wQrbFAncJet8vyTrBDpYc/s320/PXL_20241214_050441231.jpg" width="320"/></a></p><p>

Indeed, if you try to manually dial a number on the WorkSlate ...

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg3yYNLPruX0SMycX2SU8V2GmF108HHsBZqXNttMBVE8D9yxLV7ougmYsGroas26lXf9LyVNGJYgMa1q3GLg0xcs-Q8V-NquboV6QTk4ZDgMGNmbWtf16Ot7dpbuN9MkUc9RT7pKULfU2yQ23D2wCRdhXCbrn4irxC4fYQWsSYl8f_mud4aEsngMh3HiGA/s4080/PXL_20241214_050628121.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg3yYNLPruX0SMycX2SU8V2GmF108HHsBZqXNttMBVE8D9yxLV7ougmYsGroas26lXf9LyVNGJYgMa1q3GLg0xcs-Q8V-NquboV6QTk4ZDgMGNmbWtf16Ot7dpbuN9MkUc9RT7pKULfU2yQ23D2wCRdhXCbrn4irxC4fYQWsSYl8f_mud4aEsngMh3HiGA/s320/PXL_20241214_050628121.jpg" width="320"/></a></p><p>

... there&#39;s no dial tone, so it fails, and the connection is dropped.
</p><p>
Fortunately, the SID is perfectly capable of synthesizing other in-band telephony signals. For example, the Modem/300 came with cables that hooked up to the SID&#39;s audio output, and instead of the modem sending out DTMF touch tones to dial numbers, the <em>computer</em> did. Programs like Common Sense could be provided a phone number and dial it by playing tones like music. (Interestingly, the VIC-20 does not seem to be capable of precise enough frequency control to generate DTMF; Commodore even warns against it in the Modem/300 manual.)
</p><p>
Dialtones and other call-progress tones are often multi-frequency tones similar to DTMF, but they&#39;re specified separately by each region&#39;s telephone system. In the North American Bell System&#39;s Precise Tone Plan, dialtone is a combination of 350Hz and 440Hz at -13dBm, also played using a sine wave. If we use the formulas above and solve for the SID register values using those frequencies, these statements in BASIC will make a sufficient approximation of a dialtone on SID voices 1 and 2 (NTSC):
</p><div><pre>fori=54272to54296:pokei,0:next
poke54272,49:poke54273,28
poke54279,109:poke54280,22
poke54278,240:poke54285,240
poke54276,17:poke54283,17
poke54296,6
</pre></div>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7ATUc2iRl42ovyU5Rj5YcoQKqLm_UPltwn2ZfilMKArVaHjXJlXx3Nm4E8Yf5lhJR0E9bslTBzVS2o4_ZS8QdYTVk3C4hLXxKWifX_3AQd-pO7w7wndjk7e6DpYo6jAWxvcqbXqqGTYaBLjFOjo7UvmTK-8fWNx4lX1ZxbUnsMQWPA8fJTxMg3vtjlOI/s4080/PXL_20241214_051926732.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7ATUc2iRl42ovyU5Rj5YcoQKqLm_UPltwn2ZfilMKArVaHjXJlXx3Nm4E8Yf5lhJR0E9bslTBzVS2o4_ZS8QdYTVk3C4hLXxKWifX_3AQd-pO7w7wndjk7e6DpYo6jAWxvcqbXqqGTYaBLjFOjo7UvmTK-8fWNx4lX1ZxbUnsMQWPA8fJTxMg3vtjlOI/s320/PXL_20241214_051926732.jpg" width="320"/></a></p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhkFX3F05-t0xUx88N4eAu3YCsl5PRQx03dM2dLZZk4541asIcNKcl9abCTgGJyLoDASz8VjCWGGx7t9y6gSpriWgj4UaJpByuGTytxwkL5bAHWt1jZRmHq-8ayx7tIwFUPJ7MY3xY9u1OkmkfWwd0SEZ_LiWiLGvQKAx8q3Y_KtSTxYnW98qc8XUbqshY/s4080/PXL_20241214_051938327.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhkFX3F05-t0xUx88N4eAu3YCsl5PRQx03dM2dLZZk4541asIcNKcl9abCTgGJyLoDASz8VjCWGGx7t9y6gSpriWgj4UaJpByuGTytxwkL5bAHWt1jZRmHq-8ayx7tIwFUPJ7MY3xY9u1OkmkfWwd0SEZ_LiWiLGvQKAx8q3Y_KtSTxYnW98qc8XUbqshY/s320/PXL_20241214_051938327.jpg" width="320"/></a></p><p>

With the dial tone playing, the dial function will treat the line as a true phone line and try to dial out through it. On the WorkSlate this drops us cleanly into the speakerphone and should offer a working alternative for virtually any modem.
</p><p>
The last thing to do is tie this all together. While John&#39;s original program was written as a quick, type-in-able means to get files transferred one way from a Commodore 64 to a larger system, here we&#39;re using it more as an experimental way to allow the Commmodore to talk to a <em>smaller</em> system, so let&#39;s make it a little friendlier. I removed the BASIC portion and wrote up a new menu system in pure assembly, incorporating and converting John&#39;s original code, and merging the PAL and NTSC versions together. It LOADs and RUNs like a BASIC program but is fully machine language.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjDbX4klLABKysmHZ9sPOenCu9psG2APMvdxmOQyRMug3qjvYvuXx9BpNKsYV3fRzy6qX7sb5k0ilCrwnzwhkUVeVD7VMBBe-_YMbEUj4Pkrb9XYBTWOx_TimiGOVIxEb7QGw33t6jg75YZasouqICXbCV8LFKLQjDeHZQUJ0bKYezyWA5batJAaIGTAq8/s4080/PXL_20241215_024232760.jpg"><img alt="" data-original-height="4080" data-original-width="3072" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjDbX4klLABKysmHZ9sPOenCu9psG2APMvdxmOQyRMug3qjvYvuXx9BpNKsYV3fRzy6qX7sb5k0ilCrwnzwhkUVeVD7VMBBe-_YMbEUj4Pkrb9XYBTWOx_TimiGOVIxEb7QGw33t6jg75YZasouqICXbCV8LFKLQjDeHZQUJ0bKYezyWA5batJAaIGTAq8/s320/PXL_20241215_024232760.jpg"/></a></p><p>

This version can synthesize both a dial tone and the answer frequency, and I also added an ASCII translation table so that you send true ASCII in the mini-terminal.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjT0qJhkV0f0MjEDcP6KrqLBY4caGRcldbyvMgUJIcpKQ8uegiZ1BER74F6tsFq2v_Koff24pLAe37Xn542v__1R9ZKpPmRApwAMG-L1Tj8gfWHM9zqyVZUkJt1bnfYhNKKrtN2KebEfMw4otAR6ldUiFHp9XNUbOhh6GCpmB8QjUKW27mdfjIXC6YZkDM/s4080/PXL_20241215_024249889.jpg"><img alt="" data-original-height="4080" data-original-width="3072" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjT0qJhkV0f0MjEDcP6KrqLBY4caGRcldbyvMgUJIcpKQ8uegiZ1BER74F6tsFq2v_Koff24pLAe37Xn542v__1R9ZKpPmRApwAMG-L1Tj8gfWHM9zqyVZUkJt1bnfYhNKKrtN2KebEfMw4otAR6ldUiFHp9XNUbOhh6GCpmB8QjUKW27mdfjIXC6YZkDM/s320/PXL_20241215_024249889.jpg"/></a></p><p>

I also kept John&#39;s Xmodem-CRC code and added a simple transmit routine that sends a file straight up with no protocol, since the WorkSlate doesn&#39;t speak any file transfer protocols internally. Vanilla Xmodem, written by <a href="http://oldvcr.blogspot.com/2024/10/ward-christensen-dies.html">Ward Christensen</a>, uses a fixed 128 data bytes per block and a simple checksum with known deficiencies, so John opted for the more complex version with a cyclic redundancy check to ensure errors could be promptly detected. Most terminal programs support this mode. We previously encountered a variant of Xmodem-CRC when we were figuring out <a href="http://oldvcr.blogspot.com/2023/03/printing-real-headline-news-on.html">how The Newsroom&#39;s Wire Service operated</a>. From that article, the CRC-16-CCITT used in Xmodem-CRC is transmitted using this algorithm, rendered in K&amp;R C:
</p><div><pre>/*
 * This	function calculates the	CRC used by the	XMODEM/CRC Protocol
 * The first argument is a pointer to the message block.
 * The second argument is the number of	bytes in the message block.
 * The function	returns	an integer which contains the CRC.
 * The low order 16 bits are the coefficients of the CRC.
 */
int calcrc(ptr,	count)
char *ptr;
int count;
{
    int	crc, i;

    crc	= 0;
    while (--count &gt;= 0) {
	   crc = crc ^ (int)*ptr++ &lt;&lt; 8;
	   for (i = 0; i &lt; 8; ++i)
           if (crc &amp; 0x8000)
               crc = crc &lt;&lt; 1 ^ 0x1021;
           else
               crc = crc &lt;&lt; 1;
	}
    return (crc &amp; 0xFFFF);
}
</pre></div>
<p>
Many implementations of this algorithm use a lookup table for computation, but not John, who instead was optimizing for code size. Here&#39;s how John&#39;s routine sends an Xmodem-CRC packet (we&#39;ll assume that a file has already been opened by the Kernal and set up for reading).
</p><div><pre>        lda #$01
        sta $96       ; number of current packet
        ; start sending the current Xmodem packet
lc08a   lda #$00
        sta $02
        lda #$01
        jsr lc027     ; send Xmodem SOH $01
        lda $96
        jsr lc027     ; send packet number
        eor #$ff
        jsr lc027     ; send inverse of packet number
        ldy #$03
        jsr $ffa5     ; Kernal acptr, read next byte from file
        sta $8b       ; store in high byte of CRC
        jsr lc027     ; transmit it
        inc $02
        ldx $90       ; EOF?
        beq lc0b3
lc0ad   lda #$1a      ; yes, handle final packet, store a ^Z
        sta $8c
        bne lc115
lc0b3   jsr $ffa5     ; read again
        sta $8c       ; store in low byte of CRC
        jsr lc027     ; transmit again
        ldx $90
        bne lc115     ; check EOF again
lc0bf   inc $02
</pre></div>
<p>
The routine keeps a running tally of the number of data bytes in the current Xmodem block in location $2, the current packet number (0-255) in $96, and the running CRC-16 in $8b/$8c. Notably, John maintains this value <em>big</em>-endian, unlike the usual 6502 little-endian convention, and exploits the fact that most transmitted blocks will have at least two data bytes. The routine starts each block by clearing the count, then with the modulation routine at $c027 above it sends the standard Xmodem start-of-header (^A) character, the packet number and inverse of packet number, then (checking for EOF each time) reads two characters into the high byte and low byte of the running CRC-16 and transmits them. If the status word at $90 shows an EOF, this condition remains until the file is closed.
</p><p>
For each byte after that to complete the block, another one is read and stored into $8d, then shifted into $8b and $8c:
</p><div><pre>lc0c1   jsr $ffa5     ; read again
lc0c4   jsr lc027     ; transmit again
lc0c7   sta $8d       ; hold this byte
        ; for eight bits, compute crc, rolling newest byte in
        ldx #$08
lc0cb   asl $8d
        rol $8c
        rol $8b       ; &lt;&lt; 1
        bcc lc0df     ; if (crc &amp; 0x8000)
lc0d3   lda $8b       ; crc ^= 0x1021
        eor #$10
        sta $8b
        lda $8c
        eor #$21
        sta $8c
lc0df   dex
        bne lc0cb
</pre></div>
<p>
When a high bit is rolled out of the rolling CRC-16, this is detected as carry being set (no need for a bitmask) and the rolling CRC-16 bytes are exclusive-ORed with the required polynomial value ($1021, 4129). This is a very efficient translation of the algorithm.
</p><p>
The code then continues to run to complete the block of 128 bytes.
</p><div><pre>lc0e2   lda $90
        bne lc115     ; check EOF again
lc0e6   inc $02
        bpl lc0c1     ; if not 128 bytes, get some more
        ; packet&#39;s done
lc0ea   txa           ; x is zero, so zero accumulator
        dey           ; flush the header as zeroes into CRC
        bne lc0c7
lc0ee   inc $96       ; increment packet number
        lda $8b       ; send CRC high byte first
        jsr lc027
        lda $8c
        jsr lc027
        ; delay briefly to wait for the ACK $06 to go by
lc0fa   inx
        txa
        pha
        pla
        tax
        bne lc0fa
lc101   iny
        bne lc0fa
        ; pretend it worked
lc104   lda $90
        beq lc08a     ; if not EOF, go back and do another packet
</pre></div>
<p>
After the last byte is read from the file and shifted in, we need to incorporate three zero bytes into the CRC-16 to represent the header we sent. We then send that value and &#34;wait&#34; to pretend it worked, then go back for the next block. The weird delay routine allowed John to fit the entire loop into the maximum 7-bit displacement of a relative branch instruction. In fact, when I added code to flash the border on each block, I had to insert an absolute jump instead since those three extra bytes upset the apple cart.
</p><p>
At the very end of the file, any block in progress is padded with EOT (^Z), and then Xmodem EOF (^D) is sent to terminate the transmission:
</p><div><pre>        ; EOF, send EOT
lc108   lda #$04
        jsr lc027       ; send Xmodem EOT $04
        lda #$81
        sta $dc0d       ; turn CIA #1 interrupts back on
        jmp $ffcc       ; Kernal clrchn and exit back to BASIC
        ; handle end of file
        ; basically fill the last packet up with ^Z
lc115   inc $02
        bmi lc0ea       ; it&#39;s full
lc119   lda #$1a
        bne lc0c4       ; it&#39;s not, send and stuff ^Z
</pre></div>
<p>
Note that the branch at $c11b will always be taken since we just loaded a non-zero immediate into the accumulator. Again, another nice way of increasing code density and reducing type-in size. Should the file have ended in the first two bytes used to prime the CRC-16, John&#39;s code just stuffs ^Zs into it manually.
</p>
<p>
This video shows the unified, enhanced version in action. When it starts up, it detects the correct video standard (or you can force it), and allows you to send a dialtone or go directly to an answer tone. Once the &#34;softmodem&#34; has answered, you can then enter the terminal or upload files. You can enter and exit the terminal or file transfer as desired, or simply &#34;hang up&#34; when you&#39;re done, which turns off the SID&#39;s output and causes any connected modem to perceive loss of carrier and terminate the link.
</p><p>
I&#39;ve put <a href="https://github.com/classilla/35cent/blob/main/post.txt">John&#39;s original post</a> containing the type-in versions (you can cut and paste these into VICE, if you like), plus <a href="https://github.com/classilla/35cent">the assembly source for this unified version</a> and <a href="https://github.com/classilla/35cent/releases">a pre-built binary</a>, on Github. As John never asserted copyright to his programs and explicitly intended them to be freely distributable so that others could use and learn from them, I&#39;ve placed this version into the public domain (to the extent available in your jurisdiction). You can assemble it using <a href="http://www.floodgap.com/retrotech/xa/"><tt>xa65</tt></a>.
</p><p>
John was a good guy with a clever programming style and it was nice to see his code running again (and working, though that was a given). Plus, this is a great use for a Commodore to support your other systems, and a roadmap for doing something similar on other machines with sufficiently capable sound hardware. In future articles I think we&#39;ll explore <a href="http://oldvcr.blogspot.com/search/label/iannetta">a few other things he wrote</a>, including that audio digitizer. I think he would have enjoyed it.
</p>
</div></div>
  </body>
</html>
