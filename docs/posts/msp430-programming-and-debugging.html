<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://miccah.io/posts/msp430-programming-and-debugging.html">Original</a>
    <h1>MSP430 Programming and Debugging</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>(on linux)</p>

<p>The <a href="https://en.wikipedia.org/wiki/TI_MSP430">MSP430</a> launchpad is a
low cost, low power microcontroller that can be used in a variety of
embedded applications. This post documents how to program and flash
the device on linux without TI’s IDE.</p>

<p>Note: the specific MSP430 device I’m using is <code>msp430g2553</code>.</p>

<h2 id="tools-used">Tools used</h2>
<p>In addition to GNU Make, I installed these packages to cross compile,
flash, and debug.</p>

<ul>
  <li><a href="https://aur.archlinux.org/packages/mspgcc-ti/">mspgcc-ti</a></li>
  <li><a href="https://aur.archlinux.org/packages/msp430-elf-gcc/">msp430-elf-gcc</a></li>
  <li><a href="https://aur.archlinux.org/packages/mspdebug/">mspdebug</a></li>
  <li><a href="https://aur.archlinux.org/packages/srecord/">srecord</a></li>
</ul>

<h2 id="udev">udev</h2>
<p>This is optional, but if you want to program your microcontroller without
<code>sudo</code> permissions, it would be a good idea to add a udev rule that will
put the device in a group you are apart of. I chose <code>wheel</code> but you can
use your own username or create a whole new group.</p>

<p><strong>/etc/udev/rules.d/91-ti-launchpad.rules</strong></p>
<div><div><pre><code>SUBSYSTEMS==&#34;usb&#34;, ATTRS{idVendor}==&#34;0451&#34;, ATTRS{idProduct}==&#34;f432&#34;, \
GROUP=&#34;wheel&#34;, MODE=&#34;0660&#34;
</code></pre></div></div>

<p><strong>Note:</strong> the <code>idVendor</code> and <code>idProduct</code> values can be found via
<code>lsusb</code> (from the <code>core/usbutils</code> package on Arch) in the form <code>ID
idVendor:idProduct</code>, but the values here should match all MSP430 IDs.</p>

<p>To reload your new rule, you can run:</p>
<div><div><pre><code>sudo udevadm control --reload
</code></pre></div></div>

<h2 id="makefile">Makefile</h2>
<p>I copied <a href="https://gist.github.com/chanil1218/2632048">this Makefile
example</a> and made some
modifications to use the tools we are using. Things to note are
<code>MCU</code>, <code>SOURCES</code>, <code>INCLUDES</code>.</p>

<div><div><pre><code><span>#
# Makefile for msp430
#
# &#39;make&#39; builds everything
# &#39;make clean&#39; deletes everything except source files and Makefile
# You need to set TARGET, MCU and SOURCES for your project.
# TARGET is the name of the executable file to be produced
# $(TARGET).elf $(TARGET).hex and $(TARGET).txt and $(TARGET).map are all generated.
# The TXT file is used for BSL loading, the ELF can be used for JTAG use
#
</span><span>TARGET</span>     <span>=</span> blinky
<span>MCU</span>        <span>=</span> msp430g2553
<span># List all the source files here
# eg if you have a source file foo.c then list it here
</span><span>SOURCES</span> <span>=</span> blinky.c
<span># Include are located in the Include directory
</span><span>INCLUDES</span> <span>=</span> <span>-I</span>/opt/ti/mspgcc/include <span>-L</span>/opt/ti/mspgcc/include
<span># Add or subtract whatever MSPGCC flags you want. There are plenty more
#######################################################################################
</span><span>DEBUG</span>    <span>=</span> <span>-g3</span> <span>-ggdb</span> <span>-gdwarf-2</span>
<span>CFLAGS</span>   <span>=</span> <span>-mmcu</span><span>=</span><span>$(MCU)</span> <span>-Os</span> <span>-Wall</span> <span>-Wunused</span> <span>$(INCLUDES)</span> <span>$(DEBUG)</span>
<span>ASFLAGS</span>  <span>=</span> <span>-mmcu</span><span>=</span><span>$(MCU)</span> <span>-x</span> assembler-with-cpp <span>-Wa</span>,-gstabs
<span>LDFLAGS</span>  <span>=</span> <span>-mmcu</span><span>=</span><span>$(MCU)</span> <span>-Wl</span>,-Map<span>=</span><span>$(TARGET)</span>.map
<span>########################################################################################
</span><span>CC</span>       <span>=</span> msp430-elf-gcc
<span>LD</span>       <span>=</span> msp430-elf-ld
<span>AR</span>       <span>=</span> msp430-elf-ar
<span>AS</span>       <span>=</span> msp430-elf-gcc
<span>GASP</span>     <span>=</span> msp430-elf-gasp
<span>NM</span>       <span>=</span> msp430-elf-nm
<span>OBJCOPY</span>  <span>=</span> msp430-elf-objcopy
<span>RANLIB</span>   <span>=</span> msp430-elf-ranlib
<span>STRIP</span>    <span>=</span> msp430-elf-strip
<span>SIZE</span>     <span>=</span> msp430-elf-size
<span>READELF</span>  <span>=</span> msp430-elf-readelf
<span>MAKETXT</span>  <span>=</span> srec_cat
<span>CP</span>       <span>=</span> <span>cp</span> <span>-p</span>
<span>RM</span>       <span>=</span> <span>rm</span> <span>-f</span>
<span>MV</span>       <span>=</span> <span>mv</span>
<span>########################################################################################
# the file which will include dependencies
</span><span>DEPEND</span> <span>=</span> <span>$(SOURCES:.c=.d)</span>
<span># all the object files
</span><span>OBJECTS</span> <span>=</span> <span>$(SOURCES:.c=.o)</span>
<span>all</span><span>:</span> <span>$(TARGET).elf $(TARGET).hex $(TARGET).txt</span>
<span>$(TARGET).elf</span><span>:</span> <span>$(OBJECTS)</span>
	<span>echo</span> <span>&#34;Linking </span><span>$@</span><span>&#34;</span>
	<span>$(CC)</span> <span>$(OBJECTS)</span> <span>$(LDFLAGS)</span> <span>$(LIBS)</span> <span>-o</span> <span>$@</span>
	<span>echo</span>
	<span>echo</span> <span>&#34;&gt;&gt;&gt;&gt; Size of Firmware &lt;&lt;&lt;&lt;&#34;</span>
	<span>$(SIZE)</span> <span>$(TARGET)</span>.elf
	<span>echo</span>
<span>%.hex</span><span>:</span> <span>%.elf</span>
	<span>$(OBJCOPY)</span> <span>-O</span> ihex <span>$&lt;</span> <span>$@</span>
<span>%.txt</span><span>:</span> <span>%.hex</span>
	<span>$(MAKETXT)</span> <span>-O</span> <span>$@</span> <span>-TITXT</span> <span>$&lt;</span> <span>-I</span>
<span>%.o</span><span>:</span> <span>%.c</span>
	<span>echo</span> <span>&#34;Compiling </span><span>$&lt;</span><span>&#34;</span>
	<span>$(CC)</span> <span>-c</span> <span>$(CFLAGS)</span> <span>-o</span> <span>$@</span> <span>$&lt;</span>
<span># rule for making assembler source listing, to see the code
</span><span>%.lst</span><span>:</span> <span>%.c</span>
	<span>$(CC)</span> <span>-c</span> <span>$(CFLAGS)</span> <span>-Wa</span>,-anlhd <span>$&lt;</span> <span>&gt;</span> <span>$@</span>
<span># include the dependencies unless we&#39;re going to clean, then forget about them.
</span><span>ifneq</span> <span>($(MAKECMDGOALS), clean)</span>
<span>-include</span><span> $(DEPEND)</span>
<span>endif</span>
<span># dependencies file
# includes also considered, since some of these are our own
# (otherwise use -MM instead of -M)
</span><span>%.d</span><span>:</span> <span>%.c</span>
	<span>echo</span> <span>&#34;Generating dependencies </span><span>$@</span><span> from </span><span>$&lt;</span><span>&#34;</span>
	<span>$(CC)</span> <span>-M</span> <span>${CFLAGS}</span> <span>$&lt;</span> <span>&gt;</span><span>$@</span>
<span>.SILENT</span><span>:</span>
<span>.PHONY</span><span>:</span>	<span>clean</span>
<span>clean</span><span>:</span>
	<span>-</span><span>$(RM)</span> <span>$(OBJECTS)</span>
	<span>-</span><span>$(RM)</span> <span>$(TARGET)</span>.map
	<span>-</span><span>$(RM)</span> <span>$(TARGET)</span>.elf <span>$(TARGET)</span>.hex <span>$(TARGET)</span>.txt
	<span>-</span><span>$(RM)</span> <span>$(TARGET)</span>.lst
	<span>-</span><span>$(RM)</span> <span>$(SOURCES:.c=.lst)</span>
	<span>-</span><span>$(RM)</span> <span>$(DEPEND)</span>

<span>.PHONY</span><span>:</span> <span>flash</span>
<span>flash</span><span>:</span> <span>$(TARGET).hex</span>
	mspdebug rf2500 <span>&#39;prog $&lt;&#39;</span>

<span>.PHONY</span><span>:</span> <span>debug</span>
<span>debug</span><span>:</span> <span>$(TARGET).elf</span>
	mspdebug rf2500 <span>&#39;gdb&#39;</span> <span>&gt;</span>/dev/null 2&gt;&amp;1 &amp;
	msp430-gdb <span>$&lt;</span> <span>-ex</span> <span>&#39;target remote :2000&#39;</span>
</code></pre></div></div>

<h2 id="c-sources">C sources</h2>
<p>Here’s my “hello world” blinky program. The first step to embedded
development is to usually disable the watchdog timer, which is essentially
a timer that will reset the board after a fairly short time. We then need
to configure the GPIO port and pin to be an output, and finally we can
control the state of the LED by writing to <code>P1OUT</code>.</p>

<div><div><pre><code><span>#include &#34;msp430.h&#34;
</span><span>/* #include &#34;msp430g2553.h&#34; */</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>// disable watchdog timer</span>
    <span>WDTCTL</span> <span>=</span> <span>WDTPW</span> <span>|</span> <span>WDTHOLD</span><span>;</span>
    <span>// set P1.0 to be an output</span>
    <span>P1DIR</span> <span>|=</span> <span>0x1</span><span>;</span>

    <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>// toggle P1.0</span>
        <span>P1OUT</span> <span>^=</span> <span>0x1</span><span>;</span>

        <span>// software delay</span>
        <span>for</span> <span>(</span><span>volatile</span> <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>20000</span><span>;</span> <span>i</span><span>++</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p><strong>Note:</strong> I develop in vim with
<a href="https://github.com/dense-analysis/ale">ALE</a>, so to tell ALE where to
find the includes I added the following to my <code>.vimrc</code> (matching the
Makefile). This is just for the linter; compiling works regardless.</p>

<pre><code>let g:ale_c_cc_options=&#34;-I/opt/ti/mspgcc/include&#34;
</code></pre>

<h2 id="gdb">GDB</h2>
<p>The above Makefile includes a <code>debug</code> recipe which spawns <code>mspedubg</code>
in GDB mode, then starts GDB and automatically connects to the default
listen port of 2000. It’s important to compile our program with debug
symbols (<code>-g3</code>, <code>-ggdb</code>, <code>-gdwarf-2</code>) to get a rich debug environment.</p>

<p>It should be noted that the debugger (included in the MSP430 launchpad)
is running on the actual hardware, which means we can examine and
modify registers directly through GDB interactively! For example the
following commands will configure the second LED pin (which is on P1.6)
and toggle it.</p>

<div><div><pre><code>(gdb) set P1DIR |= (1 &lt;&lt; 6)
(gdb) set P1OUT ^= (1 &lt;&lt; 6)
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>These steps document how to build and flash an MSP430 board using
available open source tools. Future posts will cover more in depth
features of the MSP430.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
