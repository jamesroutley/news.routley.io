<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arxiv.org/abs/2302.12353">Original</a>
    <h1>Autonomous restructuring of asteroids into rotating space stations</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><strong>Comprehensions</strong> are a fantastic language feature in Python. They are an elegant alternative to manually constructing and populating data structures. Comprehensions are <strong>declarative</strong> – they just say what they are, as opposed to the implicit logic of manual looping. When it comes to simple object creation, <strong>comprehension should be used whenever possible</strong>. This goes not just for lists, but also for dictionaries and sets.</p>

<p>However, a widely perceived <strong>drawback</strong> to comprehensions is that they are <strong>harder to debug</strong>. When something goes wrong with a manual loop, the first thing to do is to print out the iterated values as they turn up. But the values of a list comprehension can’t be accessed, so <strong>print-debugging</strong> isn’t possible. To deal with this, it’s common to <strong>unravel the comprehension</strong> into a manual loop. Manual loops are uglier and more complicated and more error-prone than comprehensions, but that’s the price that must be paid for <strong>debuggability</strong>.</p>

<p>That’s the perception at least, but it’s wrong. In fact, <strong>print-debugging comprehensions is easy</strong>. The key fact to understand is that <strong><code>print</code> is a function, and it can occur anywhere that a function can occur</strong>. In particular, <code>print</code> can occur in a <strong>comprehension filter</strong>.</p>

<p>As an example, here’s some code that deals with graphs:</p>

<figure><pre><code data-lang="python"><span>Node</span> <span>=</span> <span>int</span>
<span>Graph</span> <span>=</span> <span>dict</span><span>[</span><span>Node</span><span>,</span> <span>tuple</span><span>[</span><span>Node</span> <span>|</span> <span>None</span><span>,</span> <span>...]]</span>

<span>def</span> <span>exit_points</span><span>(</span><span>graph</span><span>:</span> <span>Graph</span><span>)</span> <span>-&gt;</span> <span>dict</span><span>[</span><span>Node</span><span>,</span> <span>set</span><span>[</span><span>Node</span><span>]]:</span>
    <span>return</span> <span>{</span>
        <span>node</span><span>:</span> <span>set</span><span>(</span>
            <span>conn</span>
            <span>for</span> <span>conn</span> <span>in</span> <span>connections</span>
            <span>if</span> <span>conn</span> <span>is</span> <span>not</span> <span>None</span>
        <span>)</span>
        <span>for</span> <span>node</span><span>,</span> <span>connections</span> <span>in</span> <span>graph</span><span>.</span><span>items</span><span>()</span>
    <span>}</span></code></pre></figure>

<p>Notice the <strong>nested comprehensions</strong>: the dictionary comprehension contains set comprehensions as its values. Unraveling this into a manual loop would be <strong>just awful</strong>, but perhaps necessary to print the values as they show up:</p>

<figure><pre><code data-lang="python"><span>def</span> <span>exit_points_unraveled</span><span>(</span><span>graph</span><span>:</span> <span>Graph</span><span>)</span> <span>-&gt;</span> <span>dict</span><span>[</span><span>Node</span><span>,</span> <span>set</span><span>[</span><span>Node</span><span>]]:</span>
    <span>ret</span> <span>=</span> <span>{}</span>

    <span>for</span> <span>node</span><span>,</span> <span>connections</span> <span>in</span> <span>graph</span><span>.</span><span>items</span><span>():</span>
        <span>print</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>node</span><span>=</span><span>}</span><span>: </span><span>{</span><span>connections</span><span>=</span><span>}</span><span>&#39;</span><span>)</span>  <span># &lt;-- print values
</span>
        <span>val</span> <span>=</span> <span>set</span><span>()</span>

        <span>for</span> <span>conn</span> <span>in</span> <span>connections</span><span>:</span>
            <span>if</span> <span>conn</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
                <span>print</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>conn</span><span>=</span><span>}</span><span>&#39;</span><span>)</span>  <span># &lt;-- print values
</span>                <span>val</span><span>.</span><span>add</span><span>(</span><span>conn</span><span>)</span>

        <span>ret</span><span>[</span><span>node</span><span>]</span> <span>=</span> <span>val</span>

    <span>return</span> <span>ret</span></code></pre></figure>

<p>(As a side note, statements like <code>ret = {}</code> are a <strong>code smell</strong> and often an indication that a comprehension could be used instead.)</p>

<p>Rather than go through the hassle of unraveling the comprehensions, we can simply print the values as part of the comprehension filter. The <code>print</code> function always returns <code>None</code>, so it’s just a matter of creating a <strong>vacuously true filter</strong> that touches every iterated value but doesn’t discard any of them:</p>

<figure><pre><code data-lang="python"><span>def</span> <span>exit_points</span><span>(</span><span>graph</span><span>:</span> <span>Graph</span><span>)</span> <span>-&gt;</span> <span>dict</span><span>[</span><span>Node</span><span>,</span> <span>set</span><span>[</span><span>Node</span><span>]]:</span>
    <span>return</span> <span>{</span>
        <span>node</span><span>:</span> <span>set</span><span>(</span>
            <span>conn</span>
            <span>for</span> <span>conn</span> <span>in</span> <span>connections</span>
            <span>if</span> <span>conn</span> <span>is</span> <span>not</span> <span>None</span> <span>and</span> <span>print</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>conn</span><span>=</span><span>}</span><span>&#39;</span><span>)</span> <span>is</span> <span>None</span>  <span># extra condition is vacuously true
</span>        <span>)</span>
        <span>for</span> <span>node</span><span>,</span> <span>connections</span> <span>in</span> <span>graph</span><span>.</span><span>items</span><span>()</span>
        <span>if</span> <span>print</span><span>(</span><span>f</span><span>&#39;</span><span>{</span><span>node</span><span>=</span><span>}</span><span>: </span><span>{</span><span>connections</span><span>=</span><span>}</span><span>&#39;</span><span>)</span> <span>is</span> <span>None</span>  <span># vacuously true
</span>    <span>}</span></code></pre></figure>

<p><strong>It isn’t pretty. But then again, neither is print-debugging.</strong></p>

<p>This technique can be used in other places where debugging might be considered difficult, like in a <strong>chain of boolean checks</strong>:</p>

<figure><pre><code data-lang="python"><span>for</span> <span>item</span> <span>in</span> <span>sequence</span><span>:</span>
    <span>if</span> <span>(</span><span>test_condition_1</span><span>(</span><span>item</span><span>)</span>
            <span>or</span> <span>test_condition_2</span><span>(</span><span>item</span><span>)</span>
            <span>or</span> <span>test_condition_3</span><span>(</span><span>item</span><span>)):</span>
        <span>return</span> <span>None</span>

    <span>do_stuff</span><span>(</span><span>item</span><span>)</span></code></pre></figure>

<p>It might happen that all the items in the sequence are failing the test conditions, and so none of them make it to <code>do_stuff</code>. To see where they are being caught, <code>print</code> calls can be added <strong>between the conditions</strong>:</p>

<figure><pre><code data-lang="python"><span>for</span> <span>item</span> <span>in</span> <span>sequence</span><span>:</span>
    <span>if</span> <span>(</span><span>test_condition_1</span><span>(</span><span>item</span><span>)</span>
            <span>or</span> <span>print</span><span>(</span><span>&#39;passed check 1&#39;</span><span>)</span>  <span># vacuously false
</span>            <span>or</span> <span>test_condition_2</span><span>(</span><span>item</span><span>)</span>
            <span>or</span> <span>print</span><span>(</span><span>&#39;passed check 2&#39;</span><span>)</span>  <span># vacuously false
</span>            <span>or</span> <span>test_condition_3</span><span>(</span><span>item</span><span>)):</span>
        <span>return</span> <span>None</span>

    <span>do_stuff</span><span>(</span><span>item</span><span>)</span></code></pre></figure>

<p>(Note that this example uses an <code>or</code>-chain, and so the dummy <code>print</code> conditions need to be <strong>vacuously false</strong> rather than true.)</p>

<p>Again, this technique is possible because <code>print</code> is a function. In older versions of Python, <code>print</code> was a <strong>statement</strong>. That was a bad idea, and fortunately it was rectified. In general, statements are clunkier and less flexible than values. Python continues to improve with the addition of <strong>value-oriented</strong> language features like the <strong><a href="https://nickdrozd.github.io/2022/12/14/walrus-while.html">walrus operator</a></strong>.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
