<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dayvster.com/blog/in-defense-of-cpp/">Original</a>
    <h1>In Defense of C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><article> <div> <div>  <!-- Responsive flex: row on md+, column on mobile --> <div>  <div> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2v4"></path><path d="M16 2v4"></path><rect width="18" height="18" x="3" y="4" rx="2"></rect><path d="M3 10h18"></path></svg> <p><span>Tuesday, September 9, 2025</span> </p></div> </div>  <p> Why C++ remains a powerful and relevant programming language in today&#39;s tech landscape. </p> <hr/> </div>  <h2 id="the-reputation-of-c">The Reputation of C++<a aria-hidden="true" tabindex="-1" href="#the-reputation-of-c"><span></span></a></h2>
<p>C++ has often and frequently been criticized for its complexity, steep learning curve, and most of all for its ability to allow the developers using it to not only shoot themselves in the foot, but to blow off their whole leg in the process. But do these criticisms hold up under scrutiny?</p>
<p>Well, in this blog post, I aim to tackle some of the most common criticisms of C++ and provide a balanced perspective on its strengths and weaknesses.</p>
<h2 id="c-is-complex">C++ is “Complex”<a aria-hidden="true" tabindex="-1" href="#c-is-complex"><span></span></a></h2>
<p>C++ is indeed a complex language, with a vast array of features and capabilities. For any one thing you wish to achieve in C++, there are about a dozen different ways to do it, each with its own trade-offs and implications. So, as a developer, how are you to know which approach is the best one for your specific use case? Surely you have to have a deep understanding of the language to make these decisions, right?</p>
<p><strong>Not really…</strong> I mean, don’t get me wrong, it helps, but it’s not a hard requirement. Premature optimization is the root of all evil, and in C++, you can write perfectly fine code without ever needing to worry about the more complex features of the language. You can write simple, readable, and maintainable code in C++ without ever needing to use templates, operator overloading, or any of the other more advanced features of the language.</p>
<p>There’s this idea that for everything you want to do in any programming language, you need to use the most efficient and correct approach possible. Python has this with their pythonic way of doing things, Java has this, C# has this, and Go has this. Heck, even something as simple as painting HTML onto a browser needs to be reinvented every couple of years and argued about ad nauseam. Here’s the thing, though, in most cases, there is no one right way to do something. The hallowed “best approach” is often just a matter of personal or team preference. The idea that if you just write your code in the “best” and correct way, you’ll never need to worry about maintaining it is just plain wrong.</p>
<p>Don’t worry so much about using the “best” approach; worry more about writing code that is easy to read and understand. If you do that, you’ll be fine.</p>
<h2 id="c-is-outdated">C++ is “Outdated”<a aria-hidden="true" tabindex="-1" href="#c-is-outdated"><span></span></a></h2>
<p>C++ is very old, in fact, it came out in 1985, to put it into perspective, that’s 4 years before the first version of Windows was released, and 6 years before the first version of Linux came out, or to drive the point even further home, back when the last 8-bit computer was released. So yes, C++ is quite old by any standard. But does that make it outdated?</p>
<p><strong>Hell no</strong> it’s not like C++ has just been sitting around unchanged from its 1985 release. C++ has been actively developed and improved upon for over 40 years now, with new features and capabilities being added all the time. The most recent version of the C++ standard, C++20, was released in 2020 and introduced a number of new features and improvements to the language. C++23 has introduced significant enhancements, particularly in the standard library and constexpr capabilities. Notably, concepts, ranges, and coroutines have been expanded, bringing modern programming paradigms to C++ and making the language more powerful and expressive th
an ever before.</p>
<p><strong>But Dave, what we mean by outdated is that other languages have surpassed C++ and provide a better developer experience.</strong></p>
<p>Matter of personal taste, I guess, C++ is still one of the most widely used programming languages with a huge ecosystem of libraries and tools. It’s used in a wide range of applications, from game development to high-performance computing to embedded systems. Many of the most popular and widely used software applications in the world are written in C++.</p>
<p>I don’t think C++ is outdated by any stretch of the imagination; you have to bend the definition of outdated quite a bit to make that claim.</p>
<h2 id="c-is-unsafe">C++ is “Unsafe”<a aria-hidden="true" tabindex="-1" href="#c-is-unsafe"><span></span></a></h2>
<p>Ah, finally, we get to the big one, and yes, I will draw comparisons to Rust as it’s the “memory safe” language that a lot of people claim will or should replace C++.</p>
<p><strong>In fact, let’s get the main point out of the way right now.</strong></p>
<h3 id="rewrites-of-c-codebases-to-rust-always-yield-more-memory-safe-results-than-before">Rewrites of C++ codebases to Rust always yield more memory-safe results than before.<a aria-hidden="true" tabindex="-1" href="#rewrites-of-c-codebases-to-rust-always-yield-more-memory-safe-results-than-before"><span></span></a></h3>
<p>Countless companies have cited how they improved their security or the amount of reported bugs or memory leaks by simply rewriting their C++ codebases in Rust.</p>
<p><strong>Now is that because of Rust?</strong> I’d argue in some small part, yes. However, I think the biggest factor is that any rewrite of an existing codebase is going to yield better results than the original codebase.</p>
<p>When you rewrite a codebase, you have the opportunity to rethink and redesign the architecture, fix bugs, and improve the overall quality of the code. You get to leverage all the lessons learned from the previous implementation, all the issues that were found and fixed, and you already know about. All the headaches that would be too much of a pain to fix in the existing codebase, you can just fix them in the new one.</p>
<p>Imagine if you will that you’ve built a shed, it was a bit wobbly, and you didn’t really understand proper wood joinery when you first built it, so it has a few other issues, like structural integrity and a leaky roof. After a few years, you build a new one, and this time you know all the mistakes you made the first time around, so you build it better, stronger, and more weatherproof. In the process, you decide to replace the materials you’ve previously used, say for example, instead of using maple, you opt for oak. Is it correct to say that the new shed is better only because you used oak instead of maple? Or is that a really small part of the overall improvement?</p>
<p>That’s how I feel when I see these companies claim that rewriting their C++ codebases in Rust has made them more memory safe. It’s not because of Rust, it’s because they took the time to rethink and redesign their codebase and implemented all the lessons learned from the previous implementation.</p>
<h3 id="but-that-does-not-deny-the-fact-that-c-is-unsafe">But that does not deny the fact that C++ is unsafe.<a aria-hidden="true" tabindex="-1" href="#but-that-does-not-deny-the-fact-that-c-is-unsafe"><span></span></a></h3>
<p>Yes, C++ can be unsafe if you don’t know what you’re doing. But here’s the thing: all programming languages are unsafe if you don’t know what you’re doing. You can write unsafe code in Rust, you can write unsafe code in Python, you can write unsafe code in JavaScript.</p>
<p>Memory safety is just one aspect of safety in programming languages; you can still write unsafe code in memory-safe programming languages. Just using Rust will not magically make your application safe; it will just make it a lot harder to have memory leaks or safety issues.</p>
<p>The term “unsafe” is a bit too vague in this context, and I think it’s being used as a catch-all term, which to me reeks of marketing speak.</p>
<h3 id="can-c-be-made-safer">Can C++ be made safer?<a aria-hidden="true" tabindex="-1" href="#can-c-be-made-safer"><span></span></a></h3>
<p>Yes, C++ can be made safer; in fact, it can even be made memory safe. There are a number of libraries and tools available that can help make C++ code safer, such as smart pointers, static analysis tools, and memory sanitizers. Heck, if you wish, you can even add a garbage collector to C++ if you really want to(please don’t).</p>
<p>But the easiest and most straightforward way to make C++ safer is to simply learn about smart pointers and use them wherever necessary. Smart pointers are a way to manage memory in C++ without having to manually allocate and deallocate memory. They automatically handle the memory management for you, making it much harder to have memory leaks or dangling pointers. This is the main criticism of C++ in the first place.</p>
<h2 id="c-is-hard-to-read">C++ is Hard to Read<a aria-hidden="true" tabindex="-1" href="#c-is-hard-to-read"><span></span></a></h2>
<p>Then don’t write it that way. C++ is a multi-paradigm programming language; you can write procedural code, object-oriented code, functional code, or a mix of all three. You can write simple and readable code in C++ if you want to. You can also write complex and unreadable code in C++ if you want to. It’s all about personal or team preference.</p>
<p>Here’s a rule of thumb I like to follow for C++: make it look as much like C as you possibly can, and avoid using too many advanced features of the language unless you really need to. Use smart pointers, avoid raw pointers, and use the standard library wherever possible.</p>
<p>You can do a heck of a lot of programming by just using C++ as you would C and introducing complexity only when you really need to.</p>
<h3 id="but-doesnt-that-defeat-the-whole-purpose-of-c-why-not-just-use-c-then">But doesn’t that defeat the whole purpose of C++? Why not just use C then?<a aria-hidden="true" tabindex="-1" href="#but-doesnt-that-defeat-the-whole-purpose-of-c-why-not-just-use-c-then"><span></span></a></h3>
<p>C++ is a superset of C you can write C code in C++, and it will work just fine. C++ adds a lot of features and capabilities to C. If you were to start with C, then you are locked with C, and that’s fine for a lot of cases, don’t get me wrong, but C++ gives you the option to use more advanced features of the language when you need them. You can start with C and then gradually introduce C++ features as you need them. You don’t have to use all the features of C++ if you don’t want to.</p>
<p>Again, going back to my shed analogy, if you build a shed out of wood, you can always add a metal roof later if you need to. You don’t have to build the whole shed out of metal if you don’t want to.</p>
<h2 id="c-has-a-confusing-ecosystem">C++ has a confusing ecosystem<a aria-hidden="true" tabindex="-1" href="#c-has-a-confusing-ecosystem"><span></span></a></h2>
<p>C++ has a large ecosystem built over the span of 40 years or so, with a lot of different libraries and tools available. This can make it difficult to know which libraries and tools to use for a specific task. But this is not unique to C++; every programming language has this problem.</p>
<p>Again, the simple rule of thumb is to use the standard library wherever possible; it’s well-maintained and has a lot of useful features. For other tasks like networking or GUI development, there are a number of well-known libraries that are widely used and well-maintained. Do some research and find out which libraries are best suited for your specific use case.</p>
<p><strong>Avoid boost like the plague.</strong> Boost is a large collection of libraries that are widely used in the C++ community. However, many of the libraries in boost are outdated and no longer maintained. They also tend to be quite complex and difficult to use. If you can avoid using boost, do so.</p>
<p>Unless you are writing a large and complex application that requires the specific features provided by Boost, you are better off using other libraries that are more modern and easier to use. Do not add the performance overhead and binary size bloat of Boost to your application unless you really need to.</p>
<h2 id="c-is-not-a-good-choice-for-beginners">C++ is not a good choice for beginners<a aria-hidden="true" tabindex="-1" href="#c-is-not-a-good-choice-for-beginners"><span></span></a></h2>
<p>Programming is not a good choice for beginners, woodworking is not a good choice for beginners, and car mechanics is not a good choice for beginners. Programming is hard; it takes time and effort to learn, as all things do. There is no general language that is really good for beginners; everything has its trade-offs.</p>
<p>Fact is, if you wanna get into something like <strong>systems programming or game development</strong> then starting with Python or JavaScript won’t really help you much. You will eventually need to learn C or C++.</p>
<p>If your goal is to become a web developer or data scientist, then start with Python or JavaScript.</p>
<p>If you just want a job in the programming industry, I don’t know, learn Java or C#, both great languages that get a lot of undeserved hate, but offer a lot of job opportunities.</p>
<p>Look, here’s the thing: if you’re just starting out in programming, yeah, it’s gonna be hard no matter what language you choose. I’d actually argue that starting with C or C++ is far better than starting with something that obscures a lot of the underlying concepts of programming, I’d argue further that by starting with Python or Javascript you are doing yourself a disservice in the long run and trading off the pain of learning something when your understanding of a topic is still fresh and malleable for the pain of learning something later when you have a lot more invested in your current understanding of programming.</p>
<p>But hey, that’s just my opinion.</p>
<h2 id="c-vs-rust-friends-or-rivals">C++ vs Rust: Friends or Rivals?<a aria-hidden="true" tabindex="-1" href="#c-vs-rust-friends-or-rivals"><span></span></a></h2>
<p>Rust has earned a lot of love in recent years, and for good reason. It takes memory safety seriously, and its borrow checker enforces discipline that C++ often leaves to the programmer. That said, Rust is still building its ecosystem, and the learning curve can feel just as steep — just in different ways. C++ may not prevent you from shooting yourself in the foot, but it gives you decades of battle-tested tooling, compilers, and libraries that power everything from Chrome to Unreal Engine. In practice, many teams use Rust and C++ together rather than treating them as enemies. Rust shines in new projects where safety is the priority, while C++ continues to dominate legacy systems and performance-critical domains.</p>
<h2 id="is-c-still-used-in-2025">Is C++ Still Used in 2025?<a aria-hidden="true" tabindex="-1" href="#is-c-still-used-in-2025"><span></span></a></h2>
<p>The short answer: absolutely. Despite the constant chatter that it’s outdated, C++ remains one of the most widely used languages in the world. Major browsers like Chrome and Firefox are still written in it. Game engines like Unreal run on it. Automotive systems, financial trading platforms, and even AI frameworks lean heavily on C++ for performance and control. New standards (C++20, C++23) keep modernizing the language, ensuring it stays competitive with younger alternatives. If you peel back the layers of most large-scale systems we rely on daily, you’ll almost always find C++ humming away under the hood.</p>
<h2 id="conclusion">Conclusion<a aria-hidden="true" tabindex="-1" href="#conclusion"><span></span></a></h2>
<p>C++ is a powerful and versatile programming language that has stood the test of time. While it does have its complexities and challenges, it remains a relevant and widely used language in today’s tech landscape.
With the right approach and mindset, C++ can be a joy to work with and can yield high-performance and efficient applications. So next time you hear someone criticize C++, take a moment to consider the strengths and capabilities of this venerable language before dismissing it outright.</p>
<p>Hope you enjoyed this blog post. If you did, please consider sharing it with your friends and colleagues. If you have any questions or comments, please feel free to reach out to me on <a href="https://twitter.com/dayvster">Twitter</a>.</p>    </div> </article></div>
  </body>
</html>
