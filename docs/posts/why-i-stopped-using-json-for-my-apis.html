<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aloisdeniel.com/blog/better-than-json">Original</a>
    <h1>Why I stopped using JSON for my APIs</h1>
    
    <div id="readability-page-1" class="page"><div><!--[--><!----><p>Or why I stopped using JSON for my APIs</p>
<p>If you develop or use an API, there’s a 99% chance it exchanges data encoded in <strong>JSON</strong>. It has become the de facto standard for the modern web. And yet, for almost ten years, whenever I develop servers—whether for personal or professional projects—I do <strong>not</strong> use JSON.</p>
<p>And I find it surprising that JSON is so omnipresent when there are <strong>far more efficient alternatives</strong>, sometimes better suited to a truly modern development experience. Among them: <strong>Protocol Buffers</strong>, or Protobuf.</p>
<p>In this article, I’d like to explain why.</p>

<p>Before going any further, let’s put the topic back into context.</p>
<p>An <strong>API</strong> (Application Programming Interface) is a set of rules that allow two systems to communicate. In the web world, <strong>REST</strong> APIs—those using the HTTP protocol and its methods (GET, POST, PUT, DELETE…)—are by far the most widespread.</p>
<p>When a client sends a request to a server, it transmits a message containing:</p>
<ul>
<li><strong>headers</strong>, including the well-known <code>Content-Type</code>, which indicates the message format (JSON, XML, Protobuf, etc.);</li>
<li>a <strong>body</strong> (payload), which contains the data itself;</li>
<li>a <strong>response status</strong>.</li>
</ul>
<p><strong>Serialization</strong> is the process of turning a data structure into a sequence of bytes that can be transmitted. JSON, for example, serializes data as human-readable text.</p>

<p>There are many reasons for its popularity:</p>
<h3>Human-readable</h3>
<p>JSON is easy to understand, even for non-developers.
A simple <code>console.log()</code> is often enough to inspect most data.</p>
<h3>Perfectly integrated into the web</h3>
<p>It was propelled by JavaScript, then massively adopted by backend frameworks.</p>
<h3>Flexible</h3>
<p>You can add a field, remove one, or change a type “on the fly.”
Useful… sometimes too much.</p>
<h3>Tools everywhere</h3>
<p>Need to inspect JSON? Any text editor will do.
Need to send a request? Curl is enough.
Result: massive adoption, rich ecosystem.</p>
<hr/>
<p>However, despite these advantages, another format offers me better efficiency—<strong>for both developers and end users</strong>.</p>

<p>There’s a strong chance you’ve never really worked with <strong>Protobuf</strong>.
Yet this format was created as early as <strong>2001</strong> at Google and made public in <strong>2008</strong>.</p>
<p>It’s heavily used inside Google and in many modern infrastructures—especially for inter-service communication in microservice architectures.</p>
<p>So why is it so discreet in public API development?</p>
<p>Perhaps because Protobuf is often associated with <strong>gRPC</strong>, and developers think they must use both together (<em>which is false</em>). Maybe also because it’s a binary format, making it feel less “comfortable” at first glance.</p>
<p>But here’s why I personally use it almost everywhere.</p>

<p>With JSON, you often send ambiguous or non-guaranteed data.
You may encounter:</p>
<ul>
<li>a missing field,</li>
<li>an incorrect type,</li>
<li>a typo in a key,</li>
<li>or simply an undocumented structure.</li>
</ul>
<p>With Protobuf, that’s impossible.
Everything starts with a <strong><code>.proto</code> file</strong> that defines the structure of messages precisely.</p>
<h2>Example of a Proto3 file</h2>
<pre><code>syntax = <span>&#34;proto3&#34;</span>;

<span>message </span><span>User</span> {
  <span>int32</span> id = <span>1</span>;
  <span>string</span> name = <span>2</span>;
  <span>string</span> email = <span>3</span>;
  <span>bool</span> isActive = <span>4</span>;
}
</code></pre><p>Each field has:</p>
<ul>
<li>a <strong>strict type</strong> (<code>string</code>, <code>int32</code>, <code>bool</code>…)</li>
<li>a <strong>numeric identifier</strong> (1, 2, 3…)</li>
<li>a <strong>stable name</strong> (<code>name</code>, <code>email</code>…)</li>
</ul>
<p>This file is then used to automatically generate code in your preferred language.</p>
<h2>Code generation</h2>
<p>You use <code>protoc</code>:</p>
<pre><code>protoc --dart_out=lib user.proto
</code></pre><p>and you automatically get the following in your Dart code:</p>
<pre><code><span>final</span> user = User()
  ..id = <span>42</span>
  ..name = <span>&#34;Alice&#34;</span>
  ..email = <span>&#34;alice@example.com&#34;</span>
  ..isActive = <span>true</span>;

<span>final</span> bytes = user.writeToBuffer();       
<span>final</span> sameUser = User.fromBuffer(bytes);  
</code></pre><p>No manual validation.
No JSON parsing.
No risk of type errors.</p>
<p>And this mechanism works with:</p>
<ul>
<li>Dart</li>
<li>TypeScript</li>
<li>Kotlin</li>
<li>Swift</li>
<li>C#</li>
<li>Go</li>
<li>Rust</li>
<li>and many more…</li>
</ul>
<p>It represents a <strong>huge</strong> time saver and brings exceptional maintainability comfort.</p>

<p>Another major strength of Protobuf:
<strong>it’s a binary format</strong>, designed to be compact and fast.</p>
<p>Let’s compare with JSON.</p>
<h3>Example JSON message</h3>
<pre><code><span>{</span>
  <span>&#34;id&#34;</span><span>:</span> <span>42</span><span>,</span>
  <span>&#34;name&#34;</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span>
  <span>&#34;email&#34;</span><span>:</span> <span>&#34;alice@example.com&#34;</span><span>,</span>
  <span>&#34;isActive&#34;</span><span>:</span> <span><span>true</span></span>
<span>}</span>
</code></pre><p>Size: 78 bytes (depending on whitespace).</p>
<h3>The same message in Protobuf binary</h3>
<p>→ About <strong>23 bytes</strong>.
Roughly <strong>3× more compact</strong>, and often much more depending on structure.</p>
<p>Why?
Because Protobuf uses:</p>
<ul>
<li>compact “varint” encoding for numbers</li>
<li>no textual keys (they’re replaced by numeric tags)</li>
<li>no spaces, no JSON overhead</li>
<li>optimized optional fields</li>
<li>a very efficient internal structure</li>
</ul>
<p>Results:</p>
<ul>
<li>less bandwidth</li>
<li>faster response times</li>
<li>savings on mobile data</li>
<li>direct impact on user experience</li>
</ul>

<p>To make things more concrete, let’s build a <strong>minimal HTTP server in Dart</strong> using the <code>shelf</code> package, and return our <code>User</code> object serialized as <strong>Protobuf</strong>, with the correct <code>Content-Type</code>.</p>
<p>We’ll assume you already have the previously generated code for the <code>User</code> type.</p>
<h2>Create a simple Shelf server</h2>
<p>Create a file <code>bin/server.dart</code>:</p>
<pre><code><span>import</span> <span>&#39;dart:io&#39;</span>;

<span>import</span> <span>&#39;package:shelf/shelf.dart&#39;</span>;
<span>import</span> <span>&#39;package:shelf/shelf_io.dart&#39;</span> <span>as</span> shelf_io;
<span>import</span> <span>&#39;package:shelf_router/shelf_router.dart&#39;</span>;

<span>import</span> <span>&#39;package:your_package_name/user.pb.dart&#39;</span>; 

<span>void</span> main(<span>List</span>&lt;<span>String</span>&gt; args) <span>async</span> {
  <span>final</span> router = Router()
    ..<span>get</span>(<span>&#39;/user&#39;</span>, _getUserHandler);

  <span>final</span> handler = <span>const</span> Pipeline()
      .addMiddleware(logRequests())
      .addHandler(router);

  <span>final</span> server = <span>await</span> shelf_io.serve(handler, InternetAddress.anyIPv4, <span>8080</span>);
  <span>print</span>(<span>&#39;Server listening on http://<span>${server.address.host}</span>:<span>${server.port}</span>&#39;</span>);
}

Response _getUserHandler(Request request) {
  <span>final</span> user = User()
    ..id = <span>42</span>
    ..name = <span>&#39;Alice&#39;</span>
    ..email = <span>&#39;alice@example.com&#39;</span>
    ..isActive = <span>true</span>;

  <span>final</span> bytes = user.writeToBuffer();

  <span>return</span> Response.ok(
    bytes,
    headers: {
      <span>&#39;content-type&#39;</span>: <span>&#39;application/protobuf&#39;</span>,
    },
  );
}
</code></pre><p>Key points:</p>
<ul>
<li><code>User()</code> comes from the generated Protobuf code.</li>
<li><code>writeToBuffer()</code> serializes the object into Protobuf binary.</li>
<li>The <code>Content-Type</code> header is set to <code>application/protobuf</code>, allowing clients to know they must decode Protobuf instead of JSON.</li>
</ul>
<h2>Calling the Protobuf API from Dart (using <code>http</code>)</h2>
<p>Once your server returns a Protobuf-encoded <code>User</code>, you can retrieve and decode it directly from Dart.
All you need is:</p>
<ul>
<li>the <code>http</code> package</li>
<li>the generated Protobuf classes (<code>user.pb.dart</code>)</li>
</ul>
<p>Create a Dart file (e.g. <code>bin/client.dart</code>):</p>
<pre><code><span>import</span> <span>&#39;package:http/http.dart&#39;</span> <span>as</span> http;

<span>import</span> <span>&#39;package:your_package_name/user.pb.dart&#39;</span>; 

Future&lt;<span>void</span>&gt; main() <span>async</span> {
  <span>final</span> uri = <span>Uri</span>.parse(<span>&#39;http://localhost:8080/user&#39;</span>);

  <span>final</span> response = <span>await</span> http.<span>get</span>(
    uri,
    headers: {
      <span>&#39;Accept&#39;</span>: <span>&#39;application/protobuf&#39;</span>,
    },
  );

  <span>if</span> (response.statusCode == <span>200</span>) {
    
    <span>final</span> user = User.fromBuffer(response.bodyBytes);

    <span>print</span>(<span>&#39;User received:&#39;</span>);
    <span>print</span>(<span>&#39;  id       : <span>${user.id}</span>&#39;</span>);
    <span>print</span>(<span>&#39;  name     : <span>${user.name}</span>&#39;</span>);
    <span>print</span>(<span>&#39;  email    : <span>${user.email}</span>&#39;</span>);
    <span>print</span>(<span>&#39;  isActive : <span>${user.isActive}</span>&#39;</span>);
  } <span>else</span> {
    <span>print</span>(<span>&#39;Request failed: <span>${response.statusCode}</span>&#39;</span>);
  }
}
</code></pre><p>With this setup, both the server and the client rely on <strong>the same Protobuf definition</strong>, ensuring that data structures stay perfectly aligned without manual validation or JSON parsing. The same <code>.proto</code> file generates strongly typed code on both sides, making it impossible for the client and server to “disagree” about the shape or type of the data.</p>
<p>And this is not limited to Dart: the exact same approach works seamlessly if your server is written in <strong>Go</strong>, <strong>Rust</strong>, <strong>Kotlin</strong>, <strong>Swift</strong>, <strong>C#</strong>, <strong>TypeScript</strong>, or any language supported by the Protobuf compiler. Protobuf acts as a shared contract, giving you end-to-end type safety and consistent, compact data serialization across your entire stack.</p>

<p>You <em>can</em> decode Protobuf messages, of course—but unlike JSON, you don’t see human-readable field names. Instead, you see numeric field identifiers and wire types. The data is meaningful, but without the corresponding <code>.proto</code> schema you can only interpret it at a structural level, not semantically. You can see the fields, but you don’t know what they <em>represent</em>.</p>
<h3>Human-friendly debugging</h3>
<p>JSON can be read and understood immediately.</p>
<pre><code><span>{</span>
  <span>&#34;id&#34;</span><span>:</span> <span>42</span><span>,</span>
  <span>&#34;name&#34;</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span>
  <span>&#34;email&#34;</span><span>:</span> <span>&#34;alice@example.com&#34;</span><span>,</span>
  <span>&#34;isActive&#34;</span><span>:</span> <span><span>true</span></span>
<span>}</span>
</code></pre><p>A Protobuf payload, being binary, can’t be interpreted in a meaningful, human-readable way without knowing the schema behind it.</p>
<pre><code>1: 42
2: &#34;Alice&#34;
3: &#34;alice@example.com&#34;
4: true
</code></pre><p>This doesn’t prevent you from working with Protobuf, but it does add some complexity:</p>
<ul>
<li>requires specialized tooling</li>
<li>schemas must be maintained and versioned</li>
<li>decoding tools are essential</li>
</ul>
<p>For me, the trade-off is well worth it given the performance and efficiency benefits Protobuf provides.</p>

<p>I hope this article makes you want to try Protobuf. It’s an incredibly mature, extremely performant tool, but still too invisible in the world of public APIs.</p>
<p>And even though Protobuf is often associated with <strong>gRPC</strong>, nothing forces you to use both. Protobuf can work independently, on any traditional HTTP API.</p>
<p>If you’re looking for:</p>
<ul>
<li>more performance,</li>
<li>more robustness,</li>
<li>fewer errors,</li>
<li>and a genuinely enjoyable development experience,</li>
</ul>
<p>then I strongly encourage you to try Protobuf on your next project.</p>
<!----><!--]--></div></div>
  </body>
</html>
