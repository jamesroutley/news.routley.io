<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://olivernguyen.io/w/namespace.error/">Original</a>
    <h1>How We Centralized and Structured Error Handling in Golang</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><p><em>Handling errors in Go is simple and flexible ‚Äì yet no structure!</em></p><p><em>It‚Äôs supposed to be simple, right? Just return an <code>error</code> , wrapped with a message, and move on. Well, that simplicity quickly turns into chaotic as our codebase grows with more packages, more developers, and more ‚Äúquick fixes‚Äù that stay there forever. Over time, the logs are full of ‚Äúfailed to do this‚Äù and ‚Äúunexpected that‚Äù, and nobody knows if it‚Äôs the user‚Äôs fault, the server‚Äôs fault, buggy code, or it‚Äôs just a misalignment of the stars!</em></p><p><em>Errors are created with inconsistent messages. Each package has it own set of styles, constants, or custom error types. Error codes are added arbitrarily. No easy way to tell which errors may be returned from which function without digging into its implementation!</em></p><p><em>So, I took the challenge of creating a new error framework. We decided to go with a structured, centralized system using namespace codes to make errors meaningful, traceable, and ‚Äì most importantly ‚Äì give us peace of mind!</em></p><p><em>This is the story of how we started with a simple error handling approach, got thoroughly frustrated as the problems grew, and eventually built our own error framework. The design decisions, how it‚Äôs implemented, the lessons learned, and why it transformed our approach to managing errors. I hope that it will bring some ideas for you too!</em></p><hr/><h2 id="go-errors-are-just-values">Go errors are just values</h2><p>Go has a straightforward way to handle errors: errors are just values. An error is just a value that implements the <code>error</code> interface with a single method <code>Error() string</code>. Instead of throwing an exception and disrupting the current execution flow, Go functions return an <code>error</code> value alongside other results. The caller can then decide how to handle it: check its value to make decision, wrap with new messages and context, or simply return the error, leaving the handling logic for parent callers.</p><p>We can make any type an <code>error</code> by adding the <code>Error() string</code> method on it. This flexibility allows each package to define its own error-handling strategy, and choose whatever works best for them. This also integrates well with Go‚Äôs philosophy of composability, making it easy to wrap, extend, or customize errors as required.</p><h2 id="every-package-needs-to-deal-with-errors">Every package needs to deal with errors</h2><p>The common practice is to return an error value that implements the <code>error</code> interface and lets the caller decide what to do next. Here‚Äôs a typical example:</p><div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>loadCredentials</span><span>()</span> <span>(</span><span>Credentials</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
    <span>data</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>&#34;cred.json&#34;</span><span>)</span>
    <span>if</span> <span>errors</span><span>.</span><span>Is</span><span>(</span><span>err</span><span>,</span> <span>os</span><span>.</span><span>ErrNotExist</span><span>)</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;file not found: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
    <span>}</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;failed to read file: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
    <span>}</span>
    <span>cred</span><span>,</span> <span>err</span> <span>:=</span> <span>verifyCredentials</span><span>(</span><span>cred</span><span>);</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;invalid credentials: %w&#34;</span><span>,</span> <span>err</span><span>)</span>
    <span>}</span>
    <span>return</span> <span>cred</span><span>,</span> <span>nil</span>
<span>}</span>
</code></pre></div><p><strong>Go provides a handful of utilities for working with errors:</strong></p><ul><li><strong>Creating errors:</strong> <code>errors.New()</code> and <code>fmt.Errorf()</code> for generating simple errors.</li><li><strong>Wrapping errors:</strong> Wrap errors with additional context using <code>fmt.Errorf()</code> and the <code>%w</code> verb.</li><li><strong>Combining errors:</strong> <code>errors.Join()</code> merges multiple errors into a single one.</li><li><strong>Checking and handling errors:</strong> <code>errors.Is()</code> matches an error with a specific value, <code>errors.As()</code> matches an error to a specific type, and <code>errors.Unwrap()</code> retrieves the underlying error.</li></ul><p><strong>In practice, we usually see these patterns:</strong></p><ul><li><strong>Using standard packages:</strong> Returning simple errors with <code>errors.New()</code> or <code>fmt.Errorf()</code>.</li><li><strong>Exporting constants or variables:</strong> For instance, <a href="https://github.com/redis/go-redis/blob/master/internal/pool/pool.go">go-redis</a> and <a href="https://github.com/go-gorm/gorm/blob/master/errors.go">gorm.io</a> define reusable error variables.</li><li><strong>Custom error types:</strong> Libraries like <a href="https://github.com/lib/pq/blob/master/error.go">lib/pq</a> or <a href="https://github.com/grpc/grpc-go/blob/master/internal/status/status.go#L207">grpc/status.Error</a> create specialized error types, often with associated codes for additional context.</li><li><strong>Error interfaces with implementations:</strong> The <a href="https://github.com/aws/aws-sdk-go/blob/main/aws/awserr/error.go">aws-sdk-go</a> uses an interface-based approach to define error types with various implementations.</li><li><strong>Or multiple interfaces:</strong> Like <a href="https://github.com/SUSE/docker/blob/master/errdefs/defs.go">Docker‚Äôs errdefs</a>, which defines multiple interfaces to classify and manage errors.</li></ul><hr/><h2 id="we-started-with-a-common-approach">We started with a common approach</h2><p>In the early days, like many Go developers, we followed Go‚Äôs common practices and kept error handling minimal yet functional. It worked well enough for a couple of years.</p><ul><li>Include stacktrace using <a href="https://github.com/pkg/errors">pkg/errors</a>, a popular package at that time.</li><li>Export constants or variables for package-specific errors.</li><li>Use <code>errors.Is()</code> to check for specific errors.</li><li>Wrap errors with a new messages and context.</li><li>For API errors, we define error types and codes with Protobuf enum.</li></ul><p><strong>Including stacktrace with <code>pkg/errors</code></strong></p><p>We used <a href="https://github.com/pkg/errors">pkg/errors</a>, a popular error-handling package at the time, to include stacktrace in our errors. This was particularly helpful for debugging, as it allowed us to trace the origin of errors across different parts of the application.</p><p>To create, wrap, and propagate errors with stacktrace, we implemented functions like <code>Newf()</code>, <code>NewValuef()</code>, and <code>Wrapf()</code>. Here‚Äôs an example of our early implementation:</p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>xError</span> <span>struct</span> <span>{</span>
    <span>msg</span> <span>message</span><span>,</span>
    <span>stack</span><span>:</span> <span>callers</span><span>(),</span>
<span>}</span>

<span>func</span> <span>Newf</span><span>(</span><span>msg</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>error</span> <span>{</span>
    <span>return</span> <span>&amp;</span><span>xError</span><span>{</span>  
        <span>msg</span><span>:</span>   <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>msg</span><span>,</span> <span>args</span><span>...</span><span>),</span>  
        <span>stack</span><span>:</span> <span>callers</span><span>(),</span>  <span>// üëà stacktrace
</span><span></span>    <span>}</span>
<span>}</span>
<span>func</span> <span>NewValuef</span><span>(</span><span>msg</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>error</span> <span>{</span>
    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>msg</span><span>,</span> <span>args</span><span>...</span><span>)</span>  <span>// üëà no stacktrace
</span><span></span><span>}</span>
<span>func</span> <span>Wrapf</span><span>(</span><span>err</span> <span>error</span><span>,</span> <span>msg</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>error</span> <span>{</span>
    <span>if</span> <span>err</span> <span>==</span> <span>nil</span> <span>{</span> <span>return</span> <span>nil</span> <span>}</span>
    <span>stack</span> <span>:=</span> <span>getStack</span><span>(</span><span>err</span><span>)</span>
    <span>if</span> <span>stack</span> <span>==</span> <span>nil</span> <span>{</span> <span>stack</span> <span>=</span> <span>callers</span><span>()</span> <span>}</span>
    <span>return</span> <span>&amp;</span><span>xError</span><span>{</span>
        <span>msg</span><span>:</span>   <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>msg</span><span>,</span> <span>args</span><span>...</span><span>),</span>
        <span>stack</span><span>:</span> <span>stack</span><span>,</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p><strong>Exporting error variables</strong></p><p>Each package in our codebase defined its own error variables, often with inconsistent styles.</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>database</span>

<span>var</span> <span>ErrNotFound</span> <span>=</span> <span>errors</span><span>.</span><span>NewValue</span><span>(</span><span>&#34;record not found&#34;</span><span>)</span>
<span>var</span> <span>ErrMultipleFound</span> <span>=</span> <span>errors</span><span>.</span><span>NewValue</span><span>(</span><span>&#34;multiple records found&#34;</span><span>)</span>    
<span>var</span> <span>ErrTimeout</span> <span>=</span> <span>errors</span><span>.</span><span>NewValue</span><span>(</span><span>&#34;request timeout&#34;</span><span>)</span>
</code></pre></div><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>profile</span>

<span>var</span> <span>ErrUserNotFound</span> <span>=</span> <span>errors</span><span>.</span><span>NewValue</span><span>(</span><span>&#34;user not found&#34;</span><span>)</span>
<span>var</span> <span>ErrBusinessNotFound</span> <span>=</span> <span>errors</span><span>.</span><span>NewValue</span><span>(</span><span>&#34;business not found&#34;</span><span>)</span>     
<span>var</span> <span>ErrContextCancel</span> <span>=</span> <span>errors</span><span>.</span><span>NewValue</span><span>(</span><span>&#34;context canceled&#34;</span><span>)</span>
</code></pre></div><p><strong>Checking errors with <code>errors.Is()</code> and wrapping with additional context</strong></p><div><pre tabindex="0"><code data-lang="go"><span>res</span><span>,</span> <span>err</span> <span>:=</span> <span>repo</span><span>.</span><span>QueryUser</span><span>(</span><span>ctx</span><span>,</span> <span>req</span><span>)</span>
<span>switch</span> <span>{</span>
    <span>case</span> <span>err</span> <span>==</span> <span>nil</span><span>:</span>
        <span>// continue
</span><span></span>    <span>case</span> <span>errors</span><span>.</span><span>Is</span><span>(</span><span>database</span><span>.</span><span>NotFound</span><span>):</span>
        <span>return</span> <span>nil</span><span>,</span> <span>errors</span><span>.</span><span>Wrapf</span><span>(</span><span>ErrUserNotFound</span><span>,</span> <span>&#34;user not found (id=%v)&#34;</span><span>,</span> <span>req</span><span>.</span><span>UserID</span><span>)</span>    
    <span>default</span><span>:</span>
        <span>return</span> <span>nil</span><span>,</span> <span>errors</span><span>.</span><span>Wrapf</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;failed to query user (id=%v)&#34;</span><span>,</span> <span>req</span><span>.</span><span>UserID</span><span>)</span>
<span>}</span>
</code></pre></div><p>This helped propagate errors with more detail but often resulted in verbosity, duplication, and less clarity in logs:</p><div><pre tabindex="0"><code data-lang="text">internal server error: failed to query user: user not found (id=52a0a433-3922-48bd-a7ac-35dd8972dfe5): record not found: not found    
</code></pre></div><p><strong><b id="protobuf-code">Defining external errors with Protobuf</b></strong></p><p>For external-facing APIs, we adopted a Protobuf-based error model inspired by <a href="https://developers.facebook.com/docs/graph-api/guides/error-handling#receiving-errorcodes">Meta‚Äôs Graph API</a>:</p><div><pre tabindex="0"><code data-lang="protobuf"><span>message</span> <span>Error</span> <span>{</span><span>
</span><span></span>    <span>string</span> <span>message</span> <span>=</span> <span>1</span><span>;</span><span>
</span><span></span>    <span>ErrorType</span> <span>type</span> <span>=</span> <span>2</span><span>;</span><span>
</span><span></span>    <span>ErrorCode</span> <span>code</span> <span>=</span> <span>3</span><span>;</span><span>
</span><span>
</span><span></span>    <span>string</span> <span>user_title</span>   <span>=</span> <span>4</span><span>;</span><span>
</span><span></span>    <span>string</span> <span>user_message</span> <span>=</span> <span>5</span><span>;</span><span>
</span><span></span>    <span>string</span> <span>trace_id</span>     <span>=</span> <span>6</span><span>;</span><span>
</span><span></span>    <span>
</span><span></span>    <span>map</span><span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>&gt;</span> <span>details</span> <span>=</span> <span>7</span><span>;</span><span>
</span><span></span><span>}</span><span>
</span><span></span><span>enum</span> <span>ErrorType</span> <span>{</span><span>
</span><span></span>    <span>ERROR_TYPE_UNSPECIFIED</span> <span>=</span> <span>1</span><span>;</span><span>
</span><span></span>    <span>ERROR_TYPE_AUTHENTICATION</span> <span>=</span> <span>2</span><span>;</span><span>
</span><span></span>    <span>ERROR_TYPE_INVALID_REQUEST</span> <span>=</span> <span>3</span><span>;</span><span>
</span><span></span>    <span>ERROR_TYPE_RATE_LIMIT</span> <span>=</span> <span>4</span><span>;</span><span>
</span><span></span>    <span>ERROR_TYPE_BUSINESS_LIMIT</span> <span>=</span> <span>5</span><span>;</span><span>
</span><span></span>    <span>ERROR_TYPE_WEBHOOK_DELIVERY</span> <span>=</span> <span>6</span><span>;</span><span>
</span><span></span><span>}</span><span>
</span><span></span><span>enum</span> <span>ErrorCode</span> <span>{</span><span>
</span><span></span>    <span>ERROR_CODE_UNSPECIFIED</span> <span>=</span> <span>1</span> <span>[(</span><span>error_type</span> <span>=</span> <span>UNSPECIFIED</span><span>)];</span><span>
</span><span></span>    <span>ERROR_CODE_UNAUTHENTICATED</span> <span>=</span> <span>2</span> <span>[(</span><span>error_type</span> <span>=</span> <span>AUTHENTICATION</span><span>)];</span><span>
</span><span></span>    <span>ERROR_CODE_CAMPAIGN_NOT_FOUND</span> <span>=</span> <span>3</span> <span>[(</span><span>error_type</span> <span>=</span> <span>NOT_FOUND</span><span>)];</span><span>
</span><span></span>    <span>ERROR_CODE_META_CHOSE_NOT_TO_DELIVER</span> <span>=</span> <span>4</span> <span>/* ... */</span><span>;</span><span>
</span><span></span>    <span>ERROR_CODE_MESSAGE_WABA_TEMPLATE_CAN_ONLY_EDIT_ONCE_IN_24_HOURS</span> <span>=</span> <span>5</span><span>;</span>    <span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>This approach helped structure errors, but over time, error types and codes were added without a clear plan, leading to inconsistencies and duplication.</p><hr/><h2 id="and-problems-grew-over-time">And problems grew over time</h2><p><strong>Errors were declared everywhere</strong></p><ul><li>Each package defined its own error constants with no centralized system.</li><li>Constants and messages were scattered across the codebase, making it unclear which errors a function might return ‚Äì ugh, is it <code>gorm.ErrRecordNotFound</code> or <code>user.ErrNotFound</code> or both?</li></ul><p><strong>Random error wrapping led to inconsistent and arbitrary logs</strong></p><ul><li>Many functions wrapped errors with arbitrary, inconsistent messages without declaring their own error types.</li><li>Logs were verbose, redundant, and difficult to search or monitor.</li><li>Error messages were generic and often didn‚Äôt explain what went wrong or how it happened. Also brittle and prone to unnoticed changes.</li></ul><div><pre tabindex="0"><code data-lang="text">unexpected gorm error: failed to find business channel: error received when invoking API: unexpected: context canceled    
</code></pre></div><p><strong>No standardization led to improper error handling</strong></p><ul><li>Each package handled errors differently, making it hard to know if a function returned, wrapped, or transformed errors.</li><li>Context was often lost as errors propagated.</li><li>Upper layers received vague <em>500 Internal Server Errors</em> without clear root causes.</li></ul><p><strong>No categorization made monitoring impossible</strong></p><ul><li>Errors weren‚Äôt classified by severity or behavior: A <code>context.Canceled</code> error may be a normal behavior when the user closes the browser tab, but it‚Äôs important if the request is canceled because that query is randomly slow.</li><li>Important issues were buried under noisy logs, making them hard to identify.</li><li>Without categorization, it was impossible to monitor error frequency, severity, or impact effectively.</li></ul><hr/><h2 id="its-time-to-centralize-error-handling">It‚Äôs time to centralize error handling</h2><h3 id="back-to-the-drawing-board">Back to the drawing board</h3><p>To address the growing challenges, we decided to build a better error strategy around the core idea of <strong>centralized and structured error codes</strong>.</p><ul><li>Errors are declared everywhere ‚Üí <em>Centralize error declaration in a single place for better organization and traceability.</em></li><li>Inconsistent and arbitrary logs ‚Üí <em>Structured error codes with clear and consistent formatting.</em></li><li>Improper error handling ‚Üí <em>Standardize error creation and checking on the new <code>Error</code> type with a comprehensive set of helpers.</em></li><li>No categorization ‚Üí <em>Categorize error codes with tags for effective monitoring through logs and metrics.</em></li></ul><h3 id="design-decisions">Design decisions</h3><p><strong>All error codes are defined at a centralized place with namespace structure.</strong></p><p>Use namespaces to create clear, meaningful, and extendable error codes. Example:</p><ul><li><code>PRFL.USR.NOT_FOUND</code> for ‚ÄúUser not found.‚Äù</li><li><code>FLD.NOT_FOUND</code> for ‚ÄúFlow document not found.‚Äù</li><li>Both can share an underlying base code <code>DEPS.PG.NOT_FOUND</code>, meaning ‚ÄúRecord not found in PostgreSQL.‚Äù</li></ul><p><strong>Each layer of service or library must only return its own namespace codes</strong>.</p><ul><li>Each layer of service, repository, or library declares its own set of error codes.</li><li>When a layer receives an error from a dependency, it must wrap it with its own namespace code before returning it.</li><li>For example: When receiving an error <code>gorm.ErrRecordNotFound</code> from a dependency, the ‚Äúdatabase‚Äù package must wrap it as <code>DEPS.PG.NOT_FOUND</code>. Later, the ‚Äúprofile/user‚Äù service must wrap it again as <code>PRFL.USR.NOT_FOUND</code>.</li></ul><p><strong>All errors must implement the <code>Error</code> interface.</strong></p><ul><li>This creates a clear boundary between errors from third-party libraries (<code>error</code>) and our internal <code>Error</code>s.</li><li>This also helps for migration progress, to separate between migrated packages and not-yet-migrated ones.</li></ul><p><strong>An error can wrap one or multiple errors. Together, they form a tree.</strong></p><div><pre tabindex="0"><code data-lang="text">[FLD.INVALID_ARGUMENT] invalid argument
 ‚Üí [TPL.INVALID_PARAMS] invalid input params
  1. [TPL.PARAM.EMPTY] name can not be empty
  2. [TPL.PARAM.MALFORM] invalid format for param[2]    
</code></pre></div><p><strong>Always require <code>context.Context</code>. Can attach context to the error.</strong></p><ul><li>Many times we saw logs with standalone errors with no context, no <code>trace_id</code>, and have no idea where it comes from.</li><li>Can attach additional key/value to errors, which can be used in logs or monitoring.</li></ul><p><strong>When errors are sent across service boundary, only the top-level error code is exposed.</strong></p><ul><li>The callers do not need to see the internal implementation details of that service.</li></ul><p><strong>For external errors, keep using the current Protobuf ErrorCode and ErrorType.</strong></p><ul><li>This ensures backward compatibility, so our clients don‚Äôt need to rewrite their code.</li></ul><p><strong>Automap namespace error codes to Protobuf codes, HTTP status codes, and tags.</strong></p><ul><li>Engineers define the mapping in the centralized place, and the framework will map each error code to the corresponding Protobuf <code>ErrorCode</code>, <code>ErrorType</code>, gRPC status, HTTP status, and tags for logging/metrics.</li><li>This ensures consistency and reduces duplication.</li></ul><hr/><h2 id="the-namespace-error-framework">The namespace error framework</h2><h3 id="core-packages-and-types">Core packages and types</h3><p>There are a few core packages that form the foundation of our new error-handling framework.</p><p><code>connectly.ai/go/pkgs/</code></p><ul><li><strong><code>errors</code></strong>: The main package that defines the <code>Error</code> type and codes.</li><li><strong><code>errors/api</code></strong>: For sending errors to the front-end or external API.</li><li><strong><code>errors/E</code></strong>: Helper package intended to be used with dot import.</li><li><strong><code>testing</code></strong>: Testing utilities for working with namespace errors.</li></ul><p><strong><code>Error</code> and <code>Code</code></strong></p><p>The <code>Error</code> interface is an extension of the standard <code>error</code> interface, with additional methods to return a <code>Code</code>. A <code>Code</code> is implemented as an <code>uint16</code>.</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>errors</span> <span>// import &#34;connectly.ai/go/pkgs/errors&#34;
</span><span></span>
<span>type</span> <span>Error</span> <span>interface</span> <span>{</span>
    <span>error</span>
    <span>Code</span><span>()</span> <span>Code</span>
<span>}</span>
<span>type</span> <span>Code</span> <span>struct</span> <span>{</span>
    <span>code</span> <span>uint16</span>
<span>}</span>
<span>type</span> <span>CodeI</span> <span>interface</span> <span>{</span>
    <span>CodeDesc</span><span>()</span> <span>CodeDesc</span>
<span>}</span>
<span>type</span> <span>GroupI</span> <span>interface</span> <span>{</span> <span>/* ... */</span> <span>}</span>
<span>type</span> <span>CodeDesc</span> <span>struct</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre></div><p><strong>Package <code>errors/E</code> exports all error codes and common types</strong></p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>E</span> <span>// import &#34;connectly.ai/go/pkgs/errors/E&#34;
</span><span></span>
<span>import</span> <span>&#34;connectly.ai/go/pkgs/errors&#34;</span>

<span>type</span> <span>Error</span> <span>=</span> <span>errors</span><span>.</span><span>Error</span>

<span>var</span> <span>(</span>
    <span>DEPS</span> <span>=</span> <span>errors</span><span>.</span><span>DEPS</span>
    <span>PRFL</span> <span>=</span> <span>errors</span><span>.</span><span>PRFL</span>
<span>)</span>

<span>func</span> <span>MapError</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>err</span> <span>error</span><span>)</span> <span>errors</span><span>.</span><span>Mapper</span> <span>{</span> <span>/* ... */</span> <span>}</span>    
<span>func</span> <span>IsErrorCode</span><span>(</span><span>err</span> <span>error</span><span>,</span> <span>codes</span> <span>...</span><span>errors</span><span>.</span><span>CodeI</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>
<span>func</span> <span>IsErrorGroup</span><span>(</span><span>err</span> <span>error</span><span>,</span> <span>groups</span> <span>...</span><span>errors</span><span>.</span><span>GroupI</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre></div><h3 id="example-usage">Example usage</h3><p>Example error codes:</p><div><pre tabindex="0"><code data-lang="go"><span>// dependencies ‚Üí postgres
</span><span></span><span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span>
<span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>UNEXPECTED</span>

<span>// sdk ‚Üí hash
</span><span></span><span>SDK</span><span>.</span><span>HASH</span><span>.</span><span>UNEXPECTED</span>

<span>// profile ‚Üí user
</span><span></span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span>
<span>PFRL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span>

<span>// profile ‚Üí user ‚Üí repository
</span><span></span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>NOT_FOUND</span>
<span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>UNKNOWN</span>

<span>// profile ‚Üí auth
</span><span></span><span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNAUTHENTICATED</span>
<span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNKNOWN</span>
<span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNEXPECTED</span>
</code></pre></div><p>Package <code>database</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>database</span> <span>// import &#34;connectly.ai/go/pkgs/database&#34;
</span><span></span>
<span>import</span> <span>&#34;gorm.io/gorm&#34;</span>
<span>import</span> <span>.</span> <span>&#34;connectly.ai/go/pkgs/errors/E&#34;</span>

<span>type</span> <span>DB</span> <span>struct</span> <span>{</span> <span>gorm</span><span>:</span> <span>gorm</span><span>.</span><span>DB</span> <span>}</span>

<span>func</span> <span>(</span><span>d</span> <span>*</span><span>DB</span><span>)</span> <span>Exec</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>sql</span> <span>string</span><span>,</span> <span>params</span> <span>...</span><span>any</span><span>)</span> <span>*</span><span>DB</span> <span>{</span>
    <span>tx</span> <span>:=</span> <span>d</span><span>.</span><span>gorm</span><span>.</span><span>WithContext</span><span>(</span><span>ctx</span><span>).</span><span>Exec</span><span>(</span><span>sql</span><span>,</span> <span>params</span><span>...</span><span>)</span>
    <span>return</span> <span>wrapTx</span><span>(</span><span>tx</span><span>)</span>
<span>}</span>
<span>func</span> <span>(</span><span>x</span> <span>*</span><span>DB</span><span>)</span> <span>Error</span><span>(</span><span>msgArgs</span> <span>...</span><span>any</span><span>)</span> <span>Error</span> <span>{</span>
    <span>return</span> <span>wrapError</span><span>(</span><span>tx</span><span>.</span><span>Error</span><span>())</span>  <span>// üëà convert gorm error to &#39;Error&#39;
</span><span></span><span>}</span>
<span>func</span> <span>(</span><span>x</span> <span>*</span><span>DB</span><span>)</span> <span>SingleRowError</span><span>(</span><span>msgArgs</span> <span>...</span><span>any</span><span>)</span> <span>Error</span> <span>{</span>
    <span>if</span> <span>err</span> <span>:=</span> <span>x</span><span>.</span><span>Error</span><span>();</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span> <span>return</span> <span>err</span> <span>}</span>
    <span>switch</span> <span>{</span>
    <span>case</span> <span>x</span><span>.</span><span>RowsAffected</span> <span>==</span> <span>1</span><span>:</span> <span>return</span> <span>nil</span>
    <span>case</span> <span>x</span><span>.</span><span>RowsAffected</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>CallerSkip</span><span>(</span><span>1</span><span>).</span>
            <span>New</span><span>(</span><span>x</span><span>.</span><span>Context</span><span>(),</span> <span>formatMsgArgs</span><span>(</span><span>msgArgs</span><span>))</span>
    <span>default</span><span>:</span>
        <span>return</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>UNEXPECTED</span><span>.</span><span>CallerSkip</span><span>(</span><span>1</span><span>).</span>
            <span>New</span><span>(</span><span>x</span><span>.</span><span>Context</span><span>(),</span> <span>formatMsgArgs</span><span>(</span><span>msgArgs</span><span>))</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>Package <code>pb/services/profile</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>profile</span> <span>// import &#34;connectly.ai/pb/services/profile&#34;
</span><span></span>
<span>// these types are generated from services/profile.proto
</span><span></span><span>type</span> <span>QueryUserRequest</span> <span>struct</span> <span>{</span>
    <span>BusinessId</span> <span>string</span>
    <span>UserId</span>     <span>string</span>
<span>}</span>
<span>type</span> <span>LoginRequest</span> <span>struct</span> <span>{</span>
    <span>Username</span> <span>string</span>
    <span>Password</span> <span>string</span>
<span>}</span>
</code></pre></div><p>Package <code>service/profile</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>profile</span>

<span>import</span> <span>uuid</span> <span>&#34;github.com/google/uuid&#34;</span>
<span>import</span> <span>.</span> <span>&#34;connectly.ai/go/pkgs/errors/E&#34;</span>
<span>import</span> <span>l</span> <span>&#34;connectly.ai/go/pkgs/logging/l&#34;</span>
<span>import</span> <span>profilepb</span> <span>&#34;connectly.ai/pb/services/profile&#34;</span>

<span>// repository requests
</span><span></span><span>type</span> <span>QueryUserByUsernameRequest</span> <span>struct</span> <span>{</span>
    <span>Username</span> <span>string</span>
<span>}</span>

<span>// repository layer ‚Üí query user
</span><span></span><span>func</span> <span>(</span><span>r</span> <span>*</span><span>UserRepository</span><span>)</span> <span>QueryUserByUsernameAuth</span><span>(</span>
    <span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>req</span> <span>*</span><span>QueryUserByUsernameRequest</span><span>,</span>
<span>)</span> <span>(</span><span>*</span><span>User</span><span>,</span> <span>Error</span><span>)</span> <span>{</span>
    <span>if</span> <span>req</span><span>.</span><span>Username</span> <span>==</span> <span>&#34;&#34;</span> <span>{</span>
        <span>return</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>INVALID_ARGUMENT</span><span>.</span><span>New</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;empty request&#34;</span><span>)</span>
    <span>}</span>

    <span>var</span> <span>user</span> <span>User</span>
    <span>sqlQuery</span> <span>:=</span> <span>`SELECT * FROM &#34;user&#34; WHERE username = ? LIMIT 1`</span>
    <span>tx</span> <span>:=</span> <span>r</span><span>.</span><span>db</span><span>.</span><span>Exec</span><span>(</span><span>ctx</span><span>,</span> <span>sqlQuery</span><span>,</span> <span>req</span><span>.</span><span>Username</span><span>).</span><span>Scan</span><span>(</span><span>&amp;</span><span>user</span><span>)</span>     
    
    <span>err</span> <span>:=</span> <span>tx</span><span>.</span><span>SingleRowError</span><span>()</span>
    <span>switch</span> <span>{</span>
    <span>case</span> <span>err</span> <span>==</span> <span>nil</span><span>:</span>
        <span>return</span> <span>&amp;</span><span>user</span><span>,</span> <span>nil</span>
        
    <span>case</span> <span>IsErrorCode</span><span>(</span><span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>):</span>
        <span>return</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>USER_NOT_FOUND</span><span>.</span>
            <span>With</span><span>(</span><span>l</span><span>.</span><span>String</span><span>(</span><span>&#34;username&#34;</span><span>,</span> <span>req</span><span>.</span><span>Username</span><span>))</span>
            <span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;user not found&#34;</span><span>)</span>
        
    <span>default</span><span>:</span>
        <span>return</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>UNKNOWN</span><span>.</span>
            <span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;failed to query user&#34;</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>// user service layer ‚Üí query user
</span><span></span><span>func</span> <span>(</span><span>u</span> <span>*</span><span>UserService</span><span>)</span> <span>QueryUser</span><span>(</span>
    <span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>req</span> <span>*</span><span>profilepb</span><span>.</span><span>QueryUserRequest</span><span>,</span>
<span>)</span> <span>(</span><span>*</span><span>profilepb</span><span>.</span><span>QueryUserResponse</span><span>,</span> <span>Error</span><span>)</span> <span>{</span>
    <span>// ...
</span><span></span>    <span>rr</span> <span>:=</span> <span>QueryUserByUsernameRequest</span><span>{</span> <span>Username</span><span>:</span> <span>req</span><span>.</span><span>Username</span> <span>}</span>
    <span>err</span> <span>:=</span> <span>u</span><span>.</span><span>repo</span><span>.</span><span>QueryUserByUsername</span><span>(</span><span>ctx</span><span>,</span> <span>rr</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>MapError</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>).</span>
            <span>Map</span><span>(</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>NOT_FOUND</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>,</span> 
                <span>&#34;the user %q cannot be found&#34;</span><span>,</span> <span>req</span><span>.</span><span>UserName</span><span>,</span>
                <span>api</span><span>.</span><span>UserTitle</span><span>(</span><span>&#34;User Not Found&#34;</span><span>),</span>
                <span>api</span><span>.</span><span>UserMsg</span><span>(</span><span>&#34;The requested user id %q can not be found&#34;</span><span>,</span> <span>req</span><span>.</span><span>UserId</span><span>)).</span>    
            <span>KeepGroup</span><span>(</span><span>PRFL</span><span>.</span><span>USR</span><span>).</span>    
            <span>Default</span><span>(</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span><span>,</span> <span>&#34;failed to query user&#34;</span><span>)</span>
    <span>}</span>
    <span>// ...
</span><span></span>    <span>return</span> <span>resp</span><span>,</span> <span>nil</span>
<span>}</span>

<span>// auth service layer ‚Üí login user
</span><span></span><span>func</span> <span>(</span><span>a</span> <span>*</span><span>AuthService</span><span>)</span> <span>Login</span><span>(</span>
    <span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>req</span> <span>*</span><span>profilepb</span><span>.</span><span>LoginRequest</span><span>,</span>
<span>)</span> <span>(</span><span>*</span><span>profilepb</span><span>.</span><span>LoginResponse</span><span>,</span> <span>*</span><span>profilepb</span><span>.</span><span>LoginResponse</span><span>,</span> <span>Error</span><span>)</span> <span>{</span>    

    <span>vl</span> <span>:=</span> <span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>INVALID_ARGUMENT</span><span>.</span><span>WithMsg</span><span>(</span><span>&#34;invalid request&#34;</span><span>)</span>
    <span>vl</span><span>.</span><span>Vl</span><span>(</span><span>req</span><span>.</span><span>Username</span> <span>!=</span> <span>&#34;&#34;</span><span>,</span> <span>&#34;no username&#34;</span><span>,</span> <span>api</span><span>.</span><span>Detail</span><span>(</span><span>&#34;username is required&#34;</span><span>))</span>
    <span>vl</span><span>.</span><span>Vl</span><span>(</span><span>req</span><span>.</span><span>Password</span> <span>!=</span> <span>&#34;&#34;</span><span>,</span> <span>&#34;no password&#34;</span><span>,</span> <span>api</span><span>.</span><span>Detail</span><span>(</span><span>&#34;password is required&#34;</span><span>))</span>
    <span>if</span> <span>err</span> <span>:=</span> <span>vl</span><span>.</span><span>ToError</span><span>(</span><span>ctx</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>err</span>
    <span>}</span>

    <span>hashpwd</span><span>,</span> <span>err</span> <span>:=</span> <span>hash</span><span>.</span><span>Hash</span><span>(</span><span>req</span><span>.</span><span>Password</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNEXPECTED</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;failed to calc hash&#34;</span><span>)</span>    
    <span>}</span>

    <span>usrReq</span> <span>:=</span> <span>profilepb</span><span>.</span><span>QueryUserByUsernameRequest</span><span>{</span><span>/*...*/</span><span>}</span>
    <span>usrRes</span><span>,</span> <span>err</span> <span>:=</span> <span>a</span><span>.</span><span>userServiceClient</span><span>.</span><span>QueryUserByUsername</span><span>(</span><span>ctx</span><span>,</span> <span>usrReq</span><span>)</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> <span>MapError</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>).</span>
            <span>Map</span><span>(</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>,</span> <span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNAUTHENTICATED</span><span>,</span> <span>&#34;unauthenticated&#34;</span><span>).</span>
            <span>Default</span><span>(</span><span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNKNOWN</span><span>,</span> <span>&#34;failed to query by username&#34;</span><span>)</span>
    <span>}</span>
    <span>// ...
</span><span></span><span>}</span>
</code></pre></div><p>Well, there are a lot of new functions and concepts in the above code. Let‚Äôs go through them step by step.</p><h3 id="creating-and-wrapping-errors">Creating and wrapping errors</h3><p><strong>First, import package <code>errors/E</code> using dot import</strong></p><p>This will allow you to directly use common types like <code>Error</code> instead of <code>errors.Error</code> and access to codes by <code>PRFL.USR.NOT_FOUND</code> instead of <code>errors.PRFL.USR.NOT_FOUND</code>.</p><div><pre tabindex="0"><code data-lang="go"><span>import</span> <span>.</span> <span>&#34;connectly.ai/go/pkgs/errors/E&#34;</span>
</code></pre></div><p><strong>Create new errors using <code>CODE.New()</code></strong></p><p>Suppose you get an invalid request, you can create a new error by:</p><div><pre tabindex="0"><code data-lang="go"><span>err</span> <span>:=</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>INVALID_ARGUMENT</span><span>.</span><span>New</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;invalid request&#34;</span><span>)</span>
</code></pre></div><ul><li><code>PRFL.USR.INVALID_ARGUMENT</code> is a <code>Code</code>.</li><li>A <code>Code</code> exposes methods like <code>New()</code> or <code>Wrap()</code> for creating a new error.</li><li>The <code>New()</code> function receives <code>context.Context</code> as the first argument, followed by message and optional arguments.</li></ul><p>Print it with <code>fmt.Print(err)</code>:</p><div><pre tabindex="0"><code data-lang="text">[PRFL.USR.INVALID_ARGUMENT] invalid request
</code></pre></div><p>or with <code>fmt.Printf(&#34;%+v&#34;)</code> to see more details:</p><div><pre tabindex="0"><code data-lang="go"><span>[</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>INVALID_ARGUMENT</span><span>]</span> <span>invalid</span> <span>request</span>

<span>connectly</span><span>.</span><span>ai</span><span>/</span><span>go</span><span>/</span><span>services</span><span>/</span><span>profile</span><span>.(</span><span>*</span><span>UserService</span><span>).</span><span>QueryUser</span>
    <span>/</span><span>usr</span><span>/</span><span>i</span><span>/</span><span>src</span><span>/</span><span>go</span><span>/</span><span>services</span><span>/</span><span>profile</span><span>/</span><span>user</span><span>.</span><span>go</span><span>:</span><span>1234</span>
<span>connectly</span><span>.</span><span>ai</span><span>/</span><span>go</span><span>/</span><span>services</span><span>/</span><span>profile</span><span>.(</span><span>*</span><span>UserRepository</span><span>).</span><span>QueryUser</span>
    <span>/</span><span>usr</span><span>/</span><span>i</span><span>/</span><span>src</span><span>/</span><span>go</span><span>/</span><span>services</span><span>/</span><span>profile</span><span>/</span><span>repo</span><span>/</span><span>user</span><span>.</span><span>go</span><span>:</span><span>2341</span>
</code></pre></div><p><strong>Wrap an error within a new error using <code>CODE.Wrap()</code></strong></p><div><pre tabindex="0"><code data-lang="go"><span>dbErr</span> <span>:=</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>gorm</span><span>.</span><span>ErrRecordNotFound</span><span>,</span> <span>&#34;not found&#34;</span><span>)</span>
<span>usrErr</span> <span>:=</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>dbErr</span><span>,</span> <span>&#34;user not found&#34;</span><span>)</span>
</code></pre></div><p>will produce this output with <code>fmt.Print(usrErr)</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>[</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>]</span> <span>user</span> <span>not</span> <span>found</span> <span>‚Üí</span> <span>[</span><span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>]</span> <span>not</span> <span>found</span> <span>‚Üí</span> <span>record</span> <span>not</span> <span>found</span>
</code></pre></div><p>or with <code>fmt.Printf(&#34;%+v&#34;, usrErr)</code></p><div><pre tabindex="0"><code data-lang="go"><span>[</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>]</span> <span>user</span> <span>not</span> <span>found</span>
  <span>‚Üí</span> <span>[</span><span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>]</span> <span>not</span> <span>found</span>
      <span>‚Üí</span> <span>record</span> <span>not</span> <span>found</span>

<span>connectly</span><span>.</span><span>ai</span><span>/</span><span>go</span><span>/</span><span>services</span><span>/</span><span>profile</span><span>.(</span><span>*</span><span>UserService</span><span>).</span><span>QueryUser</span>
    <span>/</span><span>usr</span><span>/</span><span>i</span><span>/</span><span>src</span><span>/</span><span>go</span><span>/</span><span>services</span><span>/</span><span>profile</span><span>/</span><span>user</span><span>.</span><span>go</span><span>:</span><span>1234</span>
</code></pre></div><p>The stacktrace will come from the innermost <code>Error</code>. If you are writing a helper function, you can use <code>CallerSkip(skip)</code> to skip frames:</p><div><pre tabindex="0"><code data-lang="go"><span>func</span> <span>mapUserError</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>err</span> <span>error</span><span>)</span> <span>Error</span> <span>{</span>
    <span>switch</span> <span>{</span>
    <span>case</span> <span>IsErrorCode</span><span>(</span><span>err</span><span>,</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>):</span>
        <span>return</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>CallerSkip</span><span>(</span><span>1</span><span>).</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;...&#34;</span><span>)</span>
    <span>default</span><span>:</span>
        <span>return</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span><span>.</span><span>CallerSkip</span><span>(</span><span>1</span><span>).</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;...&#34;</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h3 id="adding-context-to-errors">Adding context to errors</h3><p><strong>Add context to an error using <code>With()</code></strong></p><ul><li>You can add additional key/value pairs to errors by <code>.With(l.String(...))</code>.</li><li><code>logging/l</code> is a helper package to export sugar functions for logging.</li><li><code>l.String(&#34;flag&#34;, flag)</code> return a <code>Tag{String: flag}</code> and <code>l.UUID(&#34;user_id, userID)</code> return <code>Tag{Stringer: userID}</code>.</li></ul><div><pre tabindex="0"><code data-lang="go"><span>import</span> <span>l</span> <span>&#34;connectly.ai/go/pkgs/logging/l&#34;</span>

<span>usrErr</span> <span>:=</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>.</span>
    <span>With</span><span>(</span><span>l</span><span>.</span><span>UUID</span><span>(</span><span>&#34;user_id&#34;</span><span>,</span> <span>req</span><span>.</span><span>UserID</span><span>),</span> <span>l</span><span>.</span><span>String</span><span>(</span><span>&#34;flag&#34;</span><span>,</span> <span>flag</span><span>)).</span>
    <span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>dbErr</span><span>,</span> <span>&#34;user not found&#34;</span><span>)</span>
</code></pre></div><p>The tags can be output with <code>fmt.Printf(&#34;%+v&#34;, usrErr)</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>[</span><span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>]</span> <span>user</span> <span>not</span> <span>found</span>
<span>{</span><span>&#34;user_id&#34;</span><span>:</span> <span>&#34;81febc07-5c06-4e01-8f9d-995bdc2e0a9a&#34;</span><span>,</span> <span>&#34;flag&#34;</span><span>:</span> <span>&#34;ABRW&#34;</span><span>}</span>
  <span>‚Üí</span> <span>[</span><span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>]</span> <span>not</span> <span>found</span>
    <span>{</span><span>&#34;a number&#34;</span><span>:</span> <span>42</span><span>}</span>
      <span>‚Üí</span> <span>record</span> <span>not</span> <span>found</span>
</code></pre></div><p><strong>Add context to errors directly inside <code>New()</code>, <code>Wrap()</code>, or <code>MapError()</code>:</strong></p><p>By leverage <code>l.String()</code> function and its family, <code>New()</code> and similar functions can smartly detect tags among formatting arguments. No need to introduce different functions.</p><div><pre tabindex="0"><code data-lang="go"><span>err</span> <span>:=</span> <span>INF</span><span>.</span><span>HEALTH</span><span>.</span><span>NOT_READY</span><span>.</span><span>New</span><span>(</span><span>ctx</span><span>,</span> 
    <span>&#34;service %q is not ready (retried %v times)&#34;</span><span>,</span> 
    <span>req</span><span>.</span><span>ServiceName</span><span>,</span> 
    <span>l</span><span>.</span><span>String</span><span>(</span><span>&#34;flag&#34;</span><span>,</span> <span>flag</span><span>)</span>
    <span>countRetries</span><span>,</span>
    <span>l</span><span>.</span><span>Number</span><span>(</span><span>&#34;count&#34;</span><span>,</span> <span>countRetries</span><span>),</span>
<span>)</span>
</code></pre></div><p>will output:</p><div><pre tabindex="0"><code data-lang="go"><span>[</span><span>INF</span><span>.</span><span>HEALTH</span><span>.</span><span>NOT_READY</span><span>]</span> <span>service</span> <span>&#34;magic&#34;</span> <span>is</span> <span>not</span> <span>ready</span> <span>(</span><span>retried</span> <span>2</span> <span>times</span><span>)</span>    
<span>{</span><span>&#34;flag&#34;</span><span>:</span> <span>&#34;ABRW&#34;</span><span>,</span> <span>&#34;count&#34;</span><span>:</span> <span>2</span><span>}</span>
</code></pre></div><h3 id="different-types-error0-vlerror-apierror">Different types: <code>Error0</code>, <code>VlError</code>, <code>ApiError</code></h3><p>Currently, there are 3 types that implements the <code>Error</code> interfaces. You can add more types if necessary. Each one can have different structure, with custom methods for specific needs.</p><p><strong><code>Error</code> is an extension of Go‚Äôs standard <code>error</code> interface</strong></p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Error</span> <span>interface</span> <span>{</span>
    <span>error</span>
    <span>Code</span><span>()</span>
    <span>Message</span><span>()</span>
    <span>Fields</span><span>()</span> <span>[]</span><span>tags</span><span>.</span><span>Field</span>
    <span>StackTrace</span><span>()</span> <span>stacktrace</span><span>.</span><span>StackTrace</span>

    <span>_base</span><span>()</span> <span>*</span><span>base</span> <span>// a private method
</span><span></span><span>}</span>
</code></pre></div><p>It contains a private method to ensure that we don‚Äôt accidentally implement new <code>Error</code> types outside of the <code>errors</code> package. We may (or may not) lift that restriction in the future when we experience with more usage patterns.</p><p><strong>Why don‚Äôt we just use the standard <code>error</code> interface and use type assertion?</strong></p><p>Because we want to separate between third-party errors and our internal errors. All layers and packages in our internal codes must always return <code>Error</code>. This way we can safely know when we have to convert third-party errors, and when we only need to deal with our internal error codes.</p><p>It also creates a boundary between migrated packages and not-yet-migrated packages. <em>Back to reality, we cannot just declare a new type, wave a magic wand, whisper a <del>spell</del> prompt, and then all millions lines of code are magically converted and work seamlessly with no bugs!</em> No, that future is not here yet. It may come someday, but for now, we still have to migrate our packages one by one.</p><p><strong><code>Error0</code> is the default <code>Error</code> type</strong></p><p>Most error codes will produce an <code>Error0</code> value. It contains a <code>base</code> and an optional sub-error. You can use <code>NewX()</code> to return a concrete <code>*Error0</code> struct instead of an <code>Error</code> interface, but you need to <a href="https://go.dev/doc/faq#nil_error">be careful</a>.</p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Error0</span> <span>struct</span> <span>{</span>
    <span>base</span>  
    <span>err</span> <span>error</span>
<span>}</span>

<span>var</span> <span>errA</span><span>:</span>  <span>Error</span>  <span>=</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>New</span> <span>(</span><span>ctx</span><span>,</span> <span>&#34;not found&#34;</span><span>)</span>
<span>var</span> <span>errB</span><span>:</span> <span>*</span><span>Error0</span> <span>=</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>NewX</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;not found&#34;</span><span>)</span>
</code></pre></div><p><code>base</code> is the common structure shared by all <code>Error</code> implementation to provide common functionality: <code>Code()</code>, <code>Message()</code>, <code>StackTrace()</code>, <code>Fields()</code>, and more.</p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>base</span> <span>struct</span> <span>{</span>
    <span>code</span>  <span>Code</span>
    <span>msg</span>   <span>string</span>
    <span>kv</span>    <span>[]</span><span>tags</span><span>.</span><span>Field</span>
    <span>stack</span> <span>stacktrace</span><span>.</span><span>StackTrace</span>
<span>}</span>
</code></pre></div><p><strong><code>VlError</code> is for validation errors</strong></p><p>It can contain multiple sub-errors, and provide nice methods to work with validation helpers.</p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>VlError</span> <span>struct</span> <span>{</span>
    <span>base</span>
    <span>errs</span> <span>[]</span><span>error</span>
<span>}</span>
</code></pre></div><p>You can create a <code>VlError</code> similar to other <code>Error</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>err</span> <span>:=</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>INVALID_ARGUMENT</span><span>.</span><span>New</span><span>(</span><span>ctx</span><span>,</span> <span>&#34;invalid request&#34;</span><span>)</span>
</code></pre></div><p>Or make a <code>VlBuilder</code>, add errors to it, then convert it to a <code>VlError</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>userID</span><span>,</span> <span>err0</span> <span>:=</span> <span>parseUUID</span><span>(</span><span>req</span><span>.</span><span>UserId</span><span>)</span>
<span>err1</span> <span>:=</span> <span>validatePassword</span><span>(</span><span>req</span><span>.</span><span>Password</span><span>)</span>

<span>vl</span> <span>:=</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>INVALID_ARGUMENT</span><span>.</span><span>WithMsg</span><span>(</span><span>&#34;invalid request&#34;</span><span>)</span>
<span>vl</span><span>.</span><span>Add</span><span>(</span><span>err0</span><span>,</span> <span>err1</span><span>)</span>
<span>vlErr</span> <span>:=</span> <span>vl</span><span>.</span><span>ToError</span><span>(</span><span>ctx</span><span>)</span>
</code></pre></div><p>And include key/value pairs as usual:</p><div><pre tabindex="0"><code data-lang="go"><span>vl</span> <span>:=</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>INVALID_ARGUMENT</span><span>.</span>
    <span>With</span><span>(</span><span>l</span><span>.</span><span>Bool</span><span>(</span><span>&#34;testingenv&#34;</span><span>,</span> <span>true</span><span>)).</span>
    <span>WithMsg</span><span>(</span><span>&#34;invalid request&#34;</span><span>)</span>
<span>userID</span><span>,</span> <span>err0</span> <span>:=</span> <span>parseUUID</span><span>(</span><span>req</span><span>.</span><span>UserId</span><span>)</span>
<span>err1</span> <span>:=</span> <span>validatePassword</span><span>(</span><span>req</span><span>.</span><span>Password</span><span>)</span>

<span>vl</span><span>.</span><span>Add</span><span>(</span><span>err0</span><span>,</span> <span>err1</span><span>)</span>
<span>vlErr</span> <span>:=</span> <span>vl</span><span>.</span><span>ToError</span><span>(</span><span>ctx</span><span>,</span> <span>l</span><span>.</span><span>String</span><span>(</span><span>&#34;user_id&#34;</span><span>,</span> <span>req</span><span>.</span><span>UserId</span><span>))</span>
</code></pre></div><p>Using <code>fmt.Printf(&#34;%+v&#34;, vlErr)</code> will output:</p><div><pre tabindex="0"><code data-lang="text">[PRFL.USR.INVALID_ARGUMENT] invalid request
{&#34;testingenv&#34;: true, &#34;user_id&#34;: &#34;A1234567890&#34;}
</code></pre></div><p><strong><code>ApiError</code> is an adapter for migrating API errors</strong></p><p>Previously, we used a separate <code>api.Error</code> struct for returning API errors to the front-end and external clients. It includes <code>ErrorType</code> as <code>ErrorCode</code> as <a href="#protobuf-code">mentioned before</a>.</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>api</span>
<span>import</span> <span>errorpb</span> <span>&#34;connectly.ai/pb/models/error&#34;</span>

<span>// Deprecated
</span><span></span><span>type</span> <span>Error</span> <span>struct</span> <span>{</span>
    <span>pbType</span> <span>errorpb</span><span>.</span><span>ErrorType</span>
    <span>pbCode</span> <span>errorpb</span><span>.</span><span>ErrorCode</span>

    <span>cause</span>    <span>error</span>
    <span>msg</span>      <span>string</span>
    <span>usrMsg</span>   <span>string</span>
    <span>usrTitle</span> <span>string</span>
    <span>// ...
</span><span></span><span>}</span>
</code></pre></div><p>This type is now deprecated. Instead, we will declare all the mapping (<code>ErrorType</code>, <code>ErrorCode</code>, gRPC code, HTTP code) in a centralize place, and convert them at corresponding boundaries. I will discuss about code declaration in <a href="#declaring-new-error-codes">the next section</a>.</p><p>To do the migration to the new namespace error framework, we added <em>a temporary namespace</em> <code>ZZZ.API_TODO</code>. Every <code>ErrorCode</code> becomes a <code>ZZZ.API_TODO</code> code.</p><div><pre tabindex="0"><code data-lang="go"><span>ZZZ</span><span>.</span><span>API_TODO</span><span>.</span><span>UNEXPECTED</span>
<span>ZZZ</span><span>.</span><span>API_TODO</span><span>.</span><span>INVALID_REQUEST</span>
<span>ZZZ</span><span>.</span><span>API_TODO</span><span>.</span><span>USERNAME_</span>
<span>ZZZ</span><span>.</span><span>API_TODO</span><span>.</span><span>META_CHOSE_NOT_TO_DELIVER</span>
<span>ZZZ</span><span>.</span><span>API_TODO</span><span>.</span><span>MESSAGE_WABA_TEMPLATE_CAN_ONLY_EDIT_ONCE_IN_24_HOURS</span>
</code></pre></div><p>And <code>ApiError</code> is created as an adapter. All functions that previously return <code>*api.Error</code> were changed to return <code>Error</code> (implemented by <code>*ApiError</code>) instead.</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>api</span>
<span>import</span> <span>.</span> <span>&#34;connectly.ai/go/pkgs/errors/E&#34;</span>

<span>// previous
</span><span></span><span>func</span> <span>FailPreconditionf</span><span>(</span><span>err</span> <span>error</span><span>,</span> <span>msg</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>*</span><span>Error</span> <span>{</span>
    <span>return</span> <span>&amp;</span><span>Error</span><span>{</span>
        <span>pbType</span><span>:</span> <span>ERROR_TYPE_FAILED_PRECONDITION</span><span>,</span>
        <span>pbCode</span><span>:</span> <span>ERROR_CODE_MESSAGE_WABA_TEMPLATE_CAN_ONLY_EDIT_ONCE_IN_24_HOURS</span><span>,</span>    
        <span>cause</span><span>:</span> <span>err</span><span>,</span>
        <span>msg</span><span>:</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>msg</span><span>,</span> <span>args</span><span>...</span><span>)</span>
    <span>}</span>
<span>}</span> 

<span>// current: this is deprecated, and serves and an adapter
</span><span></span><span>func</span> <span>FailPreconditionf</span><span>(</span><span>err</span> <span>error</span><span>,</span> <span>msg</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>*</span><span>Error</span> <span>{</span>
    <span>ctx</span> <span>:=</span> <span>context</span><span>.</span><span>TODO</span><span>()</span>
    <span>return</span> <span>ZZZ</span><span>.</span><span>API_TODO</span><span>.</span><span>MESSAGE_WABA_TEMPLATE_CAN_ONLY_EDIT_ONCE_IN_24_HOURS</span><span>.</span>
        <span>CallerSkip</span><span>(</span><span>1</span><span>).</span>   <span>// correct the stacktrace by 1 frame
</span><span></span>        <span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>msg</span><span>,</span> <span>args</span><span>...</span><span>)</span>
<span>}</span>
</code></pre></div><p>When all the migration is done, the previous usage:</p><div><pre tabindex="0"><code data-lang="go"><span>wabaErr</span> <span>:=</span> <span>verifyWabaTemplateStatus</span><span>(</span><span>tpl</span><span>)</span>
<span>apiErr</span> <span>:=</span> <span>api</span><span>.</span><span>FailPreconditionf</span><span>(</span><span>wabaErr</span><span>,</span> <span>&#34;template cannot be edited&#34;</span><span>).</span>
    <span>WithErrorCode</span><span>(</span><span>ERROR_CODE_MESSAGE_WABA_TEMPLATE_CAN_ONLY_EDIT_ONCE_IN_24_HOURS</span><span>).</span>    
    <span>WithUserMsg</span><span>(</span><span>&#34;According to WhatsApp, the message template can be only edited once in 24 hours. Consider creating a new message template instead.&#34;</span><span>).</span>
    <span>ErrorOrNil</span><span>()</span>
</code></pre></div><p>should become:</p><div><pre tabindex="0"><code data-lang="go"><span>CPG</span><span>.</span><span>TPL</span><span>.</span><span>EDIT_ONCE_IN_24_HOURS</span><span>.</span><span>Wrap</span><span>(</span>
    <span>wabaErr</span><span>,</span> <span>&#34;template cannot be edited&#34;</span><span>,</span>
    <span>api</span><span>.</span><span>UserMsg</span><span>(</span><span>&#34;According to WhatsApp, the message template can be only edited once in 24 hours. Consider creating a new message template instead.&#34;</span><span>))</span>
</code></pre></div><p>Notice that the <code>ErrorCode</code> is implicitly derived from the internal namespace code. No need to explicitly assign it every time. But how to declare the relationship between codes? It will be explained in the next section.</p><h3 id="declaring-new-error-codes">Declaring new error codes</h3><p>At this point, you already know how to create new errors from existing codes. It‚Äôs time to explain about codes and how to add a new one.</p><p><strong>A <code>Code</code> is implemented as an <code>uint16</code> value, which has a corresponding string presentation.</strong></p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Code</span> <span>struct</span> <span>{</span> <span>code</span><span>:</span> <span>uint16</span> <span>}</span>

<span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%q&#34;</span><span>,</span> <span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>)</span>
<span>// &#34;DEPS.PG.NOT_FOUND&#34;
</span></code></pre></div><p>To store those strings, there is an array of all available <code>CodeDesc</code>:</p><div><pre tabindex="0"><code data-lang="go"><span>const</span> <span>MaxCode</span> <span>=</span> <span>321</span> <span>// üëà this value is generated
</span><span></span><span>var</span>   <span>allCodes</span> <span>[</span><span>MaxCode</span><span>]</span><span>CodeDesc</span>

<span>type</span> <span>CodeDesc</span> <span>{</span>
    <span>c</span>    <span>int</span>     <span>// 42
</span><span></span>    <span>code</span> <span>string</span>  <span>// DEPS.PG.NOT_FOUND
</span><span></span>    <span>api</span> <span>APICodeDesc</span>
<span>}</span>
<span>type</span> <span>APICodeDesc</span> <span>{</span>
    <span>ErrorType</span>   <span>errorpb</span><span>.</span><span>ErrorType</span>
    <span>ErrorCode</span>   <span>errorpb</span><span>.</span><span>ErrorCode</span>
    <span>HttpCode</span>    <span>int</span>
    <span>DefMessage</span>  <span>string</span>
    <span>UserMessage</span> <span>string</span>
    <span>UserTitle</span>   <span>string</span>
<span>}</span>
</code></pre></div><p><strong>Here‚Äôs how codes are declared:</strong></p><div><pre tabindex="0"><code data-lang="go"><span>var</span> <span>DEPS</span> <span>deps</span>  <span>// dependencies
</span><span></span><span>var</span> <span>PRFL</span> <span>prfl</span>  <span>// profile
</span><span></span><span>var</span> <span>FLD</span>  <span>fld</span>   <span>// flow document
</span><span></span>
<span>type</span> <span>deps</span> <span>struct</span> <span>{</span>
    <span>PG</span> <span>pg</span>      <span>// postgres
</span><span></span>    <span>RD</span> <span>rd</span>      <span>// redis
</span><span></span><span>}</span>
<span>// tag:postgres
</span><span></span><span>type</span> <span>pg</span> <span>struct</span> <span>{</span>
    <span>NOT_FOUND</span>   <span>Code0</span> <span>// record not found
</span><span></span>    <span>CONFLICT</span>    <span>Code0</span> <span>// record already exist
</span><span></span>    <span>MALFORM_SQL</span> <span>Code0</span>
<span>}</span>
<span>// tag:profile
</span><span></span><span>type</span> <span>PRFL</span> <span>struct</span> <span>{</span>
    <span>REPO</span> <span>prfl_repo</span>
    <span>USR</span>  <span>usr</span>
    <span>AUTH</span> <span>auth</span>
<span>}</span>
<span>// tag:profile
</span><span></span><span>type</span> <span>prfl_repo</span> <span>struct</span> <span>{</span>
    <span>NOT_FOUND</span>        <span>Code0</span>  <span>// internal error code
</span><span></span>    <span>INVALID_ARGUMENT</span> <span>VlCode</span> <span>// internal error code
</span><span></span><span>}</span>
<span>// tag:usr
</span><span></span><span>type</span> <span>usr</span> <span>struct</span> <span>{</span>
    <span>NOT_FOUND</span>        <span>Code0</span>  <span>`api-code:&#34;USER_NOT_FOUND&#34;`</span>
    <span>INVALID_ARGUMENT</span> <span>VlCode</span> <span>`api-code:&#34;INVALID_ARGUMENT&#34;`</span>
    <span>DISABlED_ACCOUNT</span> <span>Code0</span>  <span>`api-code:&#34;DISABLED_ACCOUNT&#34;`</span>
<span>}</span>
<span>// tag:auth
</span><span></span><span>type</span> <span>auth</span> <span>struct</span> <span>{</span>
    <span>UNAUTHENTICATED</span>   <span>Code0</span> <span>`api-code:&#34;UNAUTHENTICATED&#34;`</span>
    <span>PERMISSION_DENIED</span> <span>Code0</span> <span>`api-code:&#34;PERMISSION_DENIED&#34;`</span>
<span>}</span>
</code></pre></div><p>After declaring new codes, you need to <a href="https://olivernguyen.io/w/direnv.run">run</a> the generation script:</p><p>The generated code will look like this:</p><div><pre tabindex="0"><code data-lang="go"><span>// Code generated by error-codes. DO NOT EDIT.
</span><span></span>
<span>func</span> <span>init</span><span>()</span> <span>{</span>
    <span>// ...
</span><span></span>    <span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>UNAUTHENTICATED</span> <span>=</span> <span>Code0</span><span>{</span><span>Code</span><span>{</span><span>code</span><span>:</span> <span>143</span><span>}}</span>  
    <span>PRFL</span><span>.</span><span>AUTH</span><span>.</span><span>PERMISSION_DENIED</span> <span>=</span> <span>Code0</span><span>{</span><span>Code</span><span>{</span><span>code</span><span>:</span> <span>144</span><span>}}</span>
    
    <span>// ...
</span><span></span>    <span>allCodes</span><span>[</span><span>143</span><span>]</span> <span>=</span> <span>CodeDesc</span><span>{</span>
        <span>c</span><span>:</span> <span>143</span><span>,</span> <span>code</span><span>:</span> <span>&#34;PRFL.AUTH.UNAUTHENTICATED&#34;</span><span>,</span>
        <span>tags</span><span>:</span> <span>[]</span><span>string</span><span>{</span><span>&#34;auth&#34;</span><span>,</span> <span>&#34;profile&#34;</span><span>},</span>  
        <span>api</span><span>:</span> <span>APICodeDesc</span><span>{</span>  
          <span>ErrorType</span><span>:</span>      <span>ERROR_TYPE_UNAUTHENTICATED</span><span>,</span>  
          <span>ErrorCode</span><span>:</span>      <span>ERROR_CODE_UNAUTHENTICATED</span><span>,</span>              
          <span>HTTPCode</span><span>:</span>       <span>401</span><span>,</span>  
          <span>DefMessage</span><span>:</span>     <span>&#34;Unauthenticated error&#34;</span><span>,</span>        
          <span>UserMessage</span><span>:</span>    <span>&#34;You are not authenticated.&#34;</span><span>,</span>   
          <span>UserTitle</span><span>:</span>      <span>&#34;Unauthenticated error&#34;</span><span>,</span>        
       <span>}))</span>
<span>}</span>
</code></pre></div><p><strong>Each <code>Error</code> type has a corresponding <code>Code</code> type</strong></p><p>Ever wonder how <code>PRFL.USR.NOT_FOUND.New()</code> creates an <code>*Error0</code> while <code>PRFL.USR.INVALID_ARGUMENTS.New()</code> creates an <code>*VlError</code>? It‚Äôs because they use different code types.</p><p>And each <code>Code</code> type returns different <code>Error</code> type, each can have its own extra methods:</p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>Code0</span>  <span>struct</span> <span>{</span> <span>Code</span> <span>}</span>
<span>type</span> <span>VlCode</span> <span>struct</span> <span>{</span> <span>Code</span> <span>}</span>

<span>func</span> <span>(</span><span>c</span> <span>Code0</span><span>)</span> <span>New</span><span>(</span><span>/*...*/</span><span>)</span> <span>Error</span> <span>{</span>
    <span>return</span> <span>&amp;</span><span>Error0</span><span>{</span><span>/*...*/</span><span>}</span>
<span>}</span>
<span>func</span> <span>(</span><span>c</span> <span>VlCode</span><span>)</span> <span>New</span><span>(</span><span>/*...*/</span><span>)</span> <span>Error</span> <span>{</span>
    <span>return</span> <span>&amp;</span><span>VlError</span><span>{</span><span>/*...*/</span><span>}</span>
<span>}</span>

<span>// extra methods on VlCode to create VlBuilder
</span><span></span><span>func</span> <span>(</span><span>c</span> <span>VlCode</span><span>)</span> <span>WithMsg</span><span>(</span><span>msg</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>*</span><span>VlBuilder</span> <span>{</span><span>/*...*/</span><span>}</span>    

<span>type</span> <span>VlBuilder</span> <span>struct</span> <span>{</span>
    <span>code</span> <span>VlCode</span>
    <span>msg</span>  <span>string</span>
    <span>args</span> <span>[]</span><span>any</span>
<span>}</span>
<span>func</span> <span>(</span><span>b</span> <span>*</span><span>VlBuilder</span><span>)</span> <span>ToError</span><span>(</span><span>/*...*/</span><span>)</span> <span>Error</span> <span>{</span>
    <span>return</span> <span>&amp;</span><span>VlError</span><span>{</span><span>Code</span><span>:</span> <span>code</span><span>,</span> <span>/*...*/</span> <span>}</span>
<span>}</span>
</code></pre></div><p><strong>Use <code>api-code</code> to mark the codes available for external API</strong></p><ul><li>The namespace error code should be used internally.</li><li>To make a code available for returning in external HTTP API, you need to mark it with <code>api-code</code>. The value is the corresponding <code>errorpb.ErrorCode</code>.</li><li>If an error code is not marked with <code>api-code</code>, it‚Äôs internal code and will be shown as a generic <code>Internal Server Error</code>.</li><li>Notice that <code>PRFL.USR.NOT_FOUND</code> is external code, while <code>PRFL.USR.REPO.NOT_FOUND</code> is internal code.</li></ul><p><strong>Declare mapping between <code>ErrorCode</code>, <code>ErrorType</code>, and gRPC/HTTP codes in protobuf using enum option:</strong></p><div><pre tabindex="0"><code data-lang="protobuf"><span>// error/type.proto
</span><span></span><span>ERROR_TYPE_PERMISSION_DENIED</span> <span>=</span> <span>707</span> <span>[(</span><span>error_type_detail_option</span><span>)</span> <span>=</span> <span>{</span>  <span>
</span><span></span>    <span>type</span><span>:</span> <span>&#34;PermissionDeniedError&#34;</span><span>,</span>  <span>
</span><span></span>    <span>grpc_code</span><span>:</span> <span>PERMISSION_DENIED</span><span>,</span>  <span>
</span><span></span>    <span>http_code</span><span>:</span> <span>403</span><span>,</span>  <span>// Forbidden  
</span><span></span>    <span>message</span><span>:</span> <span>&#34;permission denied&#34;</span><span>,</span>  <span>
</span><span></span>    <span>user_title</span><span>:</span> <span>&#34;Permission denied&#34;</span><span>,</span>  <span>
</span><span></span>    <span>user_message</span><span>:</span> <span>&#34;The caller does not have permission to execute the specified operation.&#34;</span><span>,</span>  <span>
</span><span></span><span>}];</span><span>
</span><span>
</span><span></span><span>// error/code.proto
</span><span></span><span>ERROR_CODE_DISABlED_ACCOUNT</span> <span>=</span> <span>70020</span> <span>[(</span><span>error_code_detail_option</span><span>)</span> <span>=</span> <span>{</span><span>
</span><span></span>    <span>error_type</span><span>:</span> <span>ERROR_TYPE_DISABlED_ACCOUNT</span><span>,</span><span>
</span><span></span>    <span>grpc_code</span><span>:</span> <span>PERMISSION_DENIED</span><span>,</span><span>
</span><span></span>    <span>http_code</span><span>:</span> <span>403</span><span>,</span>  <span>// Forbidden
</span><span></span>    <span>message</span><span>:</span> <span>&#34;account is disabled&#34;</span><span>,</span>  <span>
</span><span></span>    <span>user_title</span><span>:</span> <span>&#34;Account is disabled&#34;</span><span>,</span>  <span>
</span><span></span>    <span>user_message</span><span>:</span> <span>&#34;Your account is disabled. Please contact support for more information.&#34;</span><span>,</span>  <span>
</span><span></span><span>}];</span><span>
</span></code></pre></div><p><strong><code>UNEXPECTED</code> and <code>UNKNOWN</code> codes</strong></p><p>Each layer usually has 2 generic codes <code>UNEXPECTED</code> and <code>UNKNOWN</code>. They serve slightly different purposes:</p><ul><li><code>UNEXPECTED</code> code is used for errors that should never happen.</li><li><code>UNKNOWN</code> code is used for errors that are not explicitly handled.</li></ul><h3 id="mapping-errors-to-new-code">Mapping errors to new code</h3><p>When receiving an error returned from a function, you need to handle it: convert third-party errors to internal namespace errors and map error codes from inner layers to outer layers.</p><p><strong>Convert third-party errors to internal namespace errors</strong></p><p>How you handle errors depends on: what the third-party package returns and what your application needs. For example, when handling database or external API errors:</p><div><pre tabindex="0"><code data-lang="go"><span>switch</span> <span>{</span>
<span>case</span> <span>errors</span><span>.</span><span>Is</span><span>(</span><span>err</span><span>,</span> <span>sql</span><span>.</span><span>ErrNoRows</span><span>):</span>
    <span>// map a database &#34;no rows&#34; error to an internal &#34;not found&#34; error   
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;user not found&#34;</span><span>)</span>

<span>case</span> <span>errors</span><span>.</span><span>Is</span><span>(</span><span>err</span><span>,</span> <span>context</span><span>.</span><span>DeadlineExceeded</span><span>):</span>
    <span>// map a context deadline exceeded error to a timeout error
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>TIMEOUT</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;query timeout&#34;</span><span>)</span>

<span>default</span><span>:</span>
    <span>// wrap any other error as unknown
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;unexpected error&#34;</span><span>)</span>
<span>}</span>
</code></pre></div><p><strong>Using helpers for internal namespace errors</strong></p><ul><li><code>IsErrorCode(err, CODES...)</code>: Checks if the error contains any of the specified codes.</li><li><code>IsErrorGroup(err, GROUP)</code>: Return true if the error belongs to the input group.</li></ul><p>Typical usage pattern:</p><div><pre tabindex="0"><code data-lang="go"><span>user</span><span>,</span> <span>err</span> <span>:=</span> <span>queryUser</span><span>(</span><span>ctx</span><span>,</span> <span>userReq</span><span>)</span>
<span>switch</span> <span>{</span>
<span>case</span> <span>err</span> <span>==</span> <span>nil</span><span>:</span>
    <span>// continue
</span><span></span>
<span>case</span> <span>IsErrorCode</span><span>(</span><span>PRL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>NOT_FOUND</span><span>):</span>    
    <span>// check for specific error code and convert to external code
</span><span></span>    <span>// and return as HTTP 400 Not Found
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;user not found&#34;</span><span>)</span>

<span>case</span> <span>IsGroup</span><span>(</span><span>PRL</span><span>.</span><span>USR</span><span>):</span>
    <span>// errors belong to the PRFL.USR group are returned as is
</span><span></span>    <span>return</span> <span>nil</span><span>,</span> <span>err</span>

<span>default</span><span>:</span>
    <span>return</span> <span>nil</span><span>,</span> <span>PRL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span><span>.</span><span>Wrap</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>,</span> <span>&#34;failed to query user&#34;</span><span>)</span>   
<span>}</span>
</code></pre></div><p><strong><code>MapError()</code> for writing mapping code easier:</strong></p><p>Since mapping error codes is a common pattern, there is a <code>MapError()</code> helper to make writing code faster. The above code can be rewritten as:</p><div><pre tabindex="0"><code data-lang="go"><span>user</span><span>,</span> <span>err</span> <span>:=</span> <span>queryUser</span><span>(</span><span>ctx</span><span>,</span> <span>userReq</span><span>)</span>
<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>return</span> <span>nil</span><span>,</span> <span>MapError</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>).</span>
        <span>Map</span><span>(</span><span>PRL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>NOT_FOUND</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>,</span> <span>&#34;user not found&#34;</span><span>).</span>    
        <span>KeepGroup</span><span>(</span><span>PRF</span><span>.</span><span>USR</span><span>).</span>
        <span>Default</span><span>(</span><span>PRL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span><span>,</span> <span>&#34;failed to query user&#34;</span><span>)</span>
<span>}</span>
</code></pre></div><p>You can format arguments and add key/value pairs as usual:</p><div><pre tabindex="0"><code data-lang="go"><span>return</span> <span>nil</span><span>,</span> <span>MapError</span><span>(</span><span>ctx</span><span>,</span> <span>err</span><span>).</span>
    <span>Map</span><span>(</span><span>PRL</span><span>.</span><span>USR</span><span>.</span><span>REPO</span><span>.</span><span>NOT_FOUND</span><span>,</span> <span>PRFL</span><span>.</span><span>USR</span><span>.</span><span>NOT_FOUND</span><span>,</span> 
        <span>&#34;user %v not found&#34;</span><span>,</span> <span>username</span><span>,</span> 
        <span>l</span><span>.</span><span>String</span><span>(</span><span>&#34;flag&#34;</span><span>,</span> <span>flag</span><span>)).</span>    
    <span>KeepGroup</span><span>(</span><span>PRF</span><span>.</span><span>USR</span><span>).</span>
    <span>Default</span><span>(</span><span>PRL</span><span>.</span><span>USR</span><span>.</span><span>UNKNOWN</span><span>,</span> <span>&#34;failed to query user&#34;</span><span>,</span> 
        <span>l</span><span>.</span><span>Any</span><span>(</span><span>&#34;retries&#34;</span><span>,</span> <span>retryCount</span><span>))</span>
</code></pre></div><h3 id="testing-with-namespace-errors">Testing with namespace <code>Error</code>s</h3><p>Testing is critical for any serious code base. The framework provides specialized helpers like <code>Œ©xError()</code> to make writing and asserting error conditions in tests easier and more expressive.</p><div><pre tabindex="0"><code data-lang="go"><span>// üëâ return true if the error contains the message
</span><span></span><span>Œ©xError</span><span>(</span><span>err</span><span>).</span><span>Contains</span><span>(</span><span>&#34;not found&#34;</span><span>)</span>

<span>// üëâ return true if the error does not contain the message
</span><span></span><span>Œ©xError</span><span>(</span><span>err</span><span>).</span><span>NOT</span><span>().</span><span>Contains</span><span>(</span><span>&#34;not found&#34;</span><span>)</span>
</code></pre></div><p>There are many more methods, and you can chain them too:</p><div><pre tabindex="0"><code data-lang="go"><span>Œ©xError</span><span>(</span><span>err</span><span>).</span>
    <span>MatchCode</span><span>(</span><span>DEPS</span><span>.</span><span>PG</span><span>.</span><span>NOT_FOUND</span><span>).</span>  <span>// match any code in top or wrapped errors
</span><span></span>    <span>TopErrorMatchCode</span><span>(</span><span>PRFL</span><span>.</span><span>TPL</span><span>.</span><span>NOT_FOUND</span><span>)</span> <span>// only match code from the top error
</span><span></span>    <span>MatchAPICode</span><span>(</span><span>API_CODE</span><span>.</span><span>WABA_TEMPLATE_NOTE_FOUND</span><span>).</span> <span>// match errorpb.ErrorCode
</span><span></span>    <span>MatchExact</span><span>(</span><span>&#34;exact message to match&#34;</span><span>)</span>
</code></pre></div><p><strong>Why use methods instead of <code>Œ©(err).To(testing.MatchCode())</code>?</strong></p><p>Because methods are more discoverable. When you‚Äôre faced with dozens of functions like <code>testing.MatchValues()</code>, it‚Äôs hard to know which ones will work with <code>Error</code>s and which will not. With methods, you can simply type a dot <code>.</code>, and your IDE will list all available methods specifically designed for asserting <code>Error</code>s.</p><hr/><h2 id="migration">Migration</h2><p>The framework is just half of the story. Writing the code? That‚Äôs the easy part. The real challenge starts when you have to bring it into a massive, living codebase where dozens of engineers are pushing changes daily, customers expect everything to work perfectly, and the system just can‚Äôt stop running.</p><p>Migration comes with responsibility. It‚Äôs about carefully splitting <del>hair</del> tiny bits of code, making tiny changes at a time, breaking a ton of tests in the process. Then manually inspecting and fixing them one by one, merging into the main branch, deploying to production, watching the logs and alerts. Repeating it over and over‚Ä¶</p><p>Here are some tips for migration that we learned along the way:</p><p><strong>Start with search and replace:</strong> Begin by replacing old patterns with the new framework. Fix any compilation issues that arise from this process.</p><p>For example, replace all <code>error</code> in this package with <code>Error</code>.</p><div><pre tabindex="0"><code data-lang="go"><span>type</span> <span>ProfileController</span> <span>interface</span> <span>{</span>
    <span>LoginUser</span><span>(</span><span>req</span> <span>*</span><span>LoginRequest</span><span>)</span> <span>(</span><span>*</span><span>LoginResponse</span><span>,</span> <span>error</span><span>)</span>
    <span>QueryUser</span><span>(</span><span>req</span> <span>*</span><span>QueryUserRequest</span><span>)</span> <span>(</span><span>*</span><span>QueryUserResponse</span><span>,</span> <span>error</span><span>)</span>
<span>}</span>
</code></pre></div><p>The new code will look like this:</p><div><pre tabindex="0"><code data-lang="go"><span>import</span> <span>.</span> <span>&#34;connectly.ai/go/pkgs/errors&#34;</span>

<span>type</span> <span>ProfileController</span> <span>interface</span> <span>{</span>
    <span>LoginUser</span><span>(</span><span>req</span> <span>*</span><span>LoginRequest</span><span>)</span> <span>(</span><span>*</span><span>LoginResponse</span><span>,</span> <span>Error</span><span>)</span>
    <span>QueryUser</span><span>(</span><span>req</span> <span>*</span><span>QueryUserRequest</span><span>)</span> <span>(</span><span>*</span><span>QueryUserResponse</span><span>,</span> <span>Error</span><span>)</span>
<span>}</span>
</code></pre></div><p><strong>Migrate one package at a time:</strong> Start with the lowest-level packages and work your way up. This way, you can ensure that the lower-level packages are fully migrated before moving on to the higher-level ones.</p><p><strong>Add missing unit tests:</strong> If parts of the codebase lack tests, add them. If you are not confident in your changes, add more tests. They are helpful to make sure that your changes don‚Äôt break existing functionality.</p><p><strong>If your package depends on calling higher-level packages:</strong> Consider changing the related functions to DEPRECATED then add new functions with the new <code>Error</code> type.</p><p>Assume that you are migrating the database package, which has the <code>Transaction()</code> method:</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>database</span>

<span>func</span> <span>(</span><span>db</span> <span>*</span><span>DB</span><span>)</span> <span>Transaction</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> 
    <span>fn</span> <span>func</span><span>(</span><span>tx</span> <span>*</span><span>gorm</span><span>.</span><span>DB</span><span>)</span> <span>error</span><span>)</span> <span>error</span> <span>{</span>
        <span>return</span> <span>db</span><span>.</span><span>gorm</span><span>.</span><span>Transaction</span><span>(</span><span>func</span><span>(</span><span>tx</span> <span>*</span><span>gorm</span><span>.</span><span>DB</span><span>)</span> <span>error</span> <span>{</span>
            <span>return</span> <span>fn</span><span>(</span><span>tx</span><span>)</span>
        <span>})</span>
<span>}</span>
</code></pre></div><p>And it is used in the user service package:</p><div><pre tabindex="0"><code data-lang="go"><span>err</span> <span>=</span> <span>s</span><span>.</span><span>DB</span><span>(</span><span>ctx</span><span>).</span><span>Transaction</span><span>(</span><span>func</span><span>(</span><span>tx</span> <span>*</span><span>database</span><span>.</span><span>DB</span><span>)</span> <span>error</span> <span>{</span>
    <span>user</span><span>,</span> <span>usrErr</span> <span>:=</span> <span>s</span><span>.</span><span>repo</span><span>.</span><span>CreateUser</span><span>(</span><span>ctx</span><span>,</span> <span>tx</span><span>,</span> <span>user</span><span>)</span>
    <span>if</span> <span>usrErr</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>usrErr</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>Since you are migrating the <code>database</code> package first, leaving the <code>user</code> and dozens of other packages as it. The <code>s.repo.CreateUser()</code> call still returns the old <code>error</code> type while the <code>Transaction()</code> method needs to return the new <code>Error</code> type. You can change the <code>Transaction()</code> method to <code>DEPRECATED</code> and add a new <code>TransactionV2()</code> method:</p><div><pre tabindex="0"><code data-lang="go"><span>package</span> <span>database</span>

<span>// DEPRECATED: use TransactionV2 instead
</span><span></span><span>func</span> <span>(</span><span>db</span> <span>*</span><span>DB</span><span>)</span> <span>Transaction_DEPRECATED</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> 
    <span>fn</span> <span>func</span><span>(</span><span>tx</span> <span>*</span><span>gorm</span><span>.</span><span>DB</span><span>)</span> <span>error</span><span>)</span> <span>error</span> <span>{</span>
        <span>return</span> <span>db</span><span>.</span><span>gorm</span><span>.</span><span>Transaction</span><span>(</span><span>func</span><span>(</span><span>tx</span> <span>*</span><span>gorm</span><span>.</span><span>DB</span><span>)</span> <span>error</span> <span>{</span>
            <span>return</span> <span>fn</span><span>(</span><span>tx</span><span>)</span>
        <span>})</span>
<span>}</span>

<span>func</span> <span>(</span><span>db</span> <span>*</span><span>DB</span><span>)</span> <span>TransactionV2</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> 
    <span>fn</span> <span>func</span><span>(</span><span>tx</span> <span>*</span><span>gorm</span><span>.</span><span>DB</span><span>)</span> <span>error</span><span>)</span> <span>Error</span> <span>{</span>
        <span>err</span> <span>:=</span> <span>db</span><span>.</span><span>gorm</span><span>.</span><span>Transaction</span><span>(</span><span>func</span><span>(</span><span>tx</span> <span>*</span><span>gorm</span><span>.</span><span>DB</span><span>)</span> <span>error</span> <span>{</span>
            <span>return</span> <span>fn</span><span>(</span><span>tx</span><span>)</span>
        <span>})</span>
	    <span>return</span> <span>adaptToErrorV2</span><span>(</span><span>err</span><span>)</span>
<span>}</span>
</code></pre></div><p><strong>Add new error codes as you go</strong>: When you encounter an error that doesn‚Äôt fit into the existing ones, add a new code. This will help you build a comprehensive set of error codes over time. Codes from other packages are always available as references.</p><hr/><h2 id="conclusion">Conclusion</h2><p>Error handling in Go can feel simple at first‚Äîjust return an <code>error</code> and move on. But as our codebase grew, that simplicity turned into a tangled mess of vague logs, inconsistent handling, and endless debugging sessions.</p><p>By stepping back and rethinking how we handle errors, we‚Äôve built a system that works for us, not against us. Centralized and structured namespace codes give us clarity, while tools for mapping, wrapping, and testing errors make our lives easier. Instead of swimming through sea of logs, we now have meaningful, traceable errors that tell us what‚Äôs wrong and where to look.</p><p>This framework isn‚Äôt just about making our code cleaner; it‚Äôs about saving time, reducing frustration, and helping us prepare for the unknown. It‚Äôs just the beginning of a journey ‚Äî we are still discovering more patterns ‚Äî but the result is a system that can somehow bring peace of mind to error handling. Hopefully, it can spark some ideas for your projects too! üòä</p><hr/><h3 id="subscribe">Let&#39;s stay connected!</h3><p>If you like the post, subscribe to <a href="https://olivernguyen.substack.com/">my newsletter</a> to get latest updates:</p><p>I&#39;m Oliver Nguyen. A software maker working mostly in Go and JavaScript. I enjoy learning and seeing a better version of myself each day. Occasionally spin off new open source projects. Share knowledge and thoughts during my journey. <span>Connect with me on <a target="_blank" rel="noopener" href="https://github.com/iOliverNguyen"><i></i> </a>, <a target="_blank" rel="noopener" href="https://linkedin.com/in/iOliverNguyen"><i></i> </a>, <a target="_blank" rel="noopener" href="https://x.com/_OliverNguyen"><i></i> </a>, <a target="_blank" rel="noopener" href="https://iOliverNguyen.medium.com"><i></i> </a>, <a target="_blank" rel="noopener" href="mailto:iOliverNguyen@gmail.com"><i></i> </a>or <a href="https://olivernguyen.substack.com">subscribe to my posts</a>.</span></p></div></div>
  </body>
</html>
