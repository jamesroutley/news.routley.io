<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fi-le.net/byzantine/">Original</a>
    <h1>Why Does Claude Speak Byzantine Music Notation?</h1>
    
    <div id="readability-page-1" class="page">

<section>

<p>31st of March 2025</p>

<p><span>A</span> <a href="https://en.wikipedia.org/wiki/Caesar_cipher">Caesar cipher</a> is a reasonable transformation for a transformer to learn in its weights, given that a specific cipher offset occurs often enough in its training data. There will be some hidden representation of the input tokens&#39; spelling, and this representation could be used to shift letters onto other letters in even a single attention head. Most frontier models can fluently read and write a Caesar cipher on ASCII text, with offsets that presumably occur in their training data, like 1, -1, 2, 3, etc.</p>

<p>As we will shortly see, they can also infer the correct offset on the fly given a short sentence, which is already quite impressive for a single forward pass.</p>

<p>It is also natural that this effect does not generalize to uncommon offsets, because numerical algorithms implemented in the weights are restricted to values in the training distribution.</p>

<p>We now test this in frontier models by having them decode the cipher without allowing any test time thinking tokens, as a function of the offset. We add the offset to each Unicode encoding of the message, then translate back to a character. Unlike the regular Caesar cipher, we do not perform modulo.</p>

<p>To illustrate, the message &#34;i am somewhat of a researcher myself&#34; will land on &#34;𝁩𝀠𝁡𝁭𝀠𝁳𝁯𝁭𝁥𝁷𝁨𝁡𝁴𝀠𝁯𝁦𝀠𝁡𝀠𝁲𝁥𝁳𝁥𝁡𝁲𝁣𝁨𝁥𝁲𝀠𝁭𝁹𝁳𝁥𝁬𝁦&#34;.</p>

<p>The success rate of decoding 6 different messages per cipher offset is shown below. We disallow chain-of-thought, and just consider an immediate decoding: &#34;Decode the following message: {message}. Only respond with the decoded message, absolutely nothing else.&#34;
<img src="https://fi-le.net/byzantine/images/claude1.png"/>
</p>


<p>We see that Claude-3.7-Sonnet can infer an offset in the first forward pass (a process that would be interesting to understand mechanistically) and then apply the deciphering correctly. However, the success rate gets progressively worse as the offsets get further from zero. All roughly as expected.</p>

<p>This was my understanding at least, until reading <a href="https://arxiv.org/abs/2503.00224">Erziev (2025)</a>, a description of a phenomenon where many models including Claude and gpt-4o fluently read and write hidden messages in high Unicode ranges, such as the <a>href=&#34;https://en.wikipedia.org/wiki/Byzantine_Musical_Symbols&#34;&gt;Byzantine music notation Unicode block</a>.</p>

<p>For the specific case of the Byzantine music Unicode block, we can understand the transformation as a Caesar-like cipher in Unicode space, with offset 118784. Using it in the Caesar-like Unicode cipher leads to near-perfect decoding accuracy.<img src="https://fi-le.net/byzantine/images/claude2.png"/></p>



<p>The reason that this has any chance of working is the following. At least in most public tokenizers like o200k, addition in certain Unicode ranges commutes with addition in token space. For instance, if we define \(\tau:\Sigma^*\rightarrow\hat{\Sigma}^*\) as the o200k tokenizer, then in a subset of the Byzantine music notation range (\(\texttt{U+118784}-\texttt{U+119029}\)), a linearity property holds.</p>

<p>\(\tau([\texttt{U+118881}+k])=[43120,223,94+k],k\in\{0,\ldots,29\}\setminus\{12\},\)</p>

<p>so all but one of these symbols is mapped to three tokens each, where the first two are the same and can be easily ignored by an attention head, and the third token increments exactly with the Unicode.</p>

<p>The first of those tokens, (token 94 of the o200k tokenizer), is the first binary token of its vocabulary, and along with the following 93 tokens represents the binary strings b&#39;\xa1&#39; to b&#39;\xff&#39;.</p>

<p>This makes it possible in theory for a circuit to exist that implements a shifting cipher on these characters. What remains is the explanation for why this cipher was learned in practice.</p>

<p>The special offset 118784 lands the character &#34;a&#34; on \(\texttt{U+118881}\), which is the first in the series of characters that get tokenized in the above arithmetic series. In particular, it is interesting that an offset that is one or two larger does not work. This means that the model has learned a map specifically from the binary range b&#39;\xa1&#39;−b&#39;\xba&#39; to the lowercase ASCII range 97-122. I would believe it if someone told me that this somehow occurs often in the training data, but I cannot think of how exactly.</p>

<p>However, gpt-4o retains some deciphering capability even with an offset one larger, which is weak confirmation that commutativity of addition in the Unicode-token spaces is part of the story. Since Claude handles the deciphering well, we could conclude that its secret tokenizer also handles binary strings with arithmetic increments, like o200k.
<img src="https://fi-le.net/byzantine/images/4o.png"/>
</p>


<p>It is odd that this unusual shifting algorithm works across multiple model families, and even more consistently than a regular Caesar cipher, which is supposedly very common in the training data. This could suggest that the algorithm uses circuits from other tasks, or that there is a more fundamental reason why this specific ability is useful in next-token prediction.</p>
</section>


</div>
  </body>
</html>
