<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the-nerve-blog.ghost.io/baking-the-y-combinator-from-scratch-part-1/">Original</a>
    <h1>Baking the Y Combinator from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

            <div>
                <div>
                    <p><time datetime="2025-04-08">08 Apr 2025</time>
                            <span><span>â€”</span> 19 min read</span>
                    </p>
                </div>
            </div>

            <!--  -->
            <!--     <a class="gh-article-tag" href="https://the-nerve-blog.ghost.io/tag/learning/">learning</a> -->
            <!--  -->
            

        </header>

        <section>
           
            <p>It&#39;s a pedagogical pet peeve of mine when technical concepts are simply listed in their fully developed state, with little in the way of motivation, derivation, or historical context. This, I think, is like publishing a cookbook filled with beautiful pictures of cakes, but no recipes.</p><p>My aim with the &#34;Baking &lt;x&gt; from scratch&#34; series is to describe not only <em>what</em>, but <em>how</em> and <em>why</em>, with the hope that this will lead to a richer and more durable understanding.</p><hr/><h3 id="the-famous-y-combinator">The Famous Y combinator</h3><p>This post is about the Y combinator. Not Y Combinator the accelerator, but the mathematical construct that it&#39;s named after - <em>the</em> Y combinator.</p><p>The Y combinator looks like this:</p><p>$$ Y = \lambda f. \enspace (\lambda x. \enspace f(x \enspace x)) \enspace (\lambda x. \enspace f(x \enspace x)) $$</p><p>Confronted with this definition, you might ask yourself:</p>
<ol>
<li>Why does it look like that?</li>
<li>What is it used for?</li>
<li>Why do people still talk about it?</li>
<li>(What the heck is a combinator?)</li>
</ol>
<p>The one-line answer to all of these is: &#34;the Y combinator implements recursion in functional languages that don&#39;t allow for explicit self-reference&#34;, but it&#39;s worth going a little deeper than that. In my opinion, the easiest way to understand what the Y combinator <em>is</em>, at a fundamental level, is to focus on how it produces fixed points. The easiest way to understand why it&#39;s <em>important</em> is to focus on how it can be used to implement recursion. In Part 1 we&#39;ll do the former (answering 1. and half of 2. in the process) and in Part 2 we&#39;ll do the latter (answering 3. and the other half of 2.)</p>
<p>(We&#39;ll answer bonus question 4 later in this article!)</p>
<p>The Y combinator was devised by Haskell Curry, an influential logician who has the unique distinction of lending his name to both a <a href="https://en.wikipedia.org/wiki/Currying?ref=the-nerve-blog.ghost.io" rel="noreferrer">programming technique</a> and a <a href="https://www.haskell.org/?ref=the-nerve-blog.ghost.io" rel="noreferrer">programming language</a>. It is also known as the &#34;Fixpoint Combinator&#34; (for reasons we&#39;ll soon discuss) and the &#34;Paradoxical Combinator&#34; (for reasons we&#39;ll investigate in the second half of this post.)</p><hr/><h3 id="the-lambda-calculus">The Lambda Calculus</h3><p>This post presumes that you&#39;re at least familiar with the lambda calculus - you don&#39;t have to be an expert, but if it&#39;s completely new to you you may have some trouble knowing what&#39;s going on. <a href="https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf?ref=the-nerve-blog.ghost.io" rel="noreferrer">This</a> is a good introduction if you need it (this article only draws on the material in Section 1.)</p><p>Two things about the lambda calculus that you should understand before reading this:</p><p>1) <em>everything </em>in the lambda calculus is a function (I&#39;ll also call these functions &#39;terms&#39;.) When you &#34;run&#34; a program in the lambda calculus, you&#39;re basically plugging functions into other functions over and over until you can&#39;t do it anymore. This may seem like it severely limits the expressive power of the lambda calculus, but consider that we can encode different kinds of data and operators in the lambda calculus by representing them using suitable functions (the linked paper shows how to represent booleans and natural numbers in the lambda calculus, and demonstrates how to do arithmetic and some boolean algebra.) The lambda calculus is Turing Complete, so using this type of encoding you can replicate the behavior of any program written in any language. </p><p>2) There are no names besides variable names in the lambda calculus. You can&#39;t assign a name to a function and you can&#39;t call any functions by name. For the sake of readability I&#39;ll sometimes cheat and give a name to a function just to make it easier to explain. For example, I might write </p><p>$$id = \lambda x. x$$</p><p>and then later:</p><p>$$myCoolTerm = \lambda x. x \enspace id(x)$$</p><p>Just remember that you technically can&#39;t do \(name = term\) or \(name(argument)\) in the real lambda calculus; you have to write everything out. For example, \(myCoolTerm\) can only legally be written as:</p><p>$$ \lambda x. x \enspace ((\lambda x. x) (x)) $$</p><hr/><h3 id="ythe-fixpoint-combinator">Y - the Fixpoint Combinator</h3><p>A fixed point (or fixpoint) of a function \(f\) is a point that doesn&#39;t change when you apply \(f\) to it. In other words, \(x\) is a fixpoint of \(f\) if and only if</p><p>$$f(x) = x$$</p><p>Y is a <em>fixpoint</em> <em>combinator</em> (notice I didn&#39;t say <em>the</em> fixpoint combinator - the Y combinator is one of the oldest and simplest fixpoint combinators, but there are many others!) A fixpoint combinator takes a (one-argument) function and returns some fixpoint of that function (some functions have more than one fixpoint - consider, for example, that every<em> </em>value returned by an idempotent function is a fixpoint! If the function has <em>no</em> fixpoints \(Y(f)\) doesn&#39;t terminate.) So we know Y must satisfy: </p><p>$$ f(Y(f)) = Y(f)$$</p><p>but that also means:</p><p>$$Y(f) = f(Y(f))$$</p><p>From a computational perspective, this second equation says that the action of \(Y\) is to take a function and <em>nest itself</em> in a call to that function. </p><p>Because the two equations above are equivalent, finding a \(Y(f)\) that satisfies the second equation means that - <em>by definition</em> - \(Y(f)\) is a fixed point of \(f\). </p><blockquote>Now is a good time to remember that everything in the lambda calculus is a function. So \(Y\) is a function that takes another function \(f\) and returns a fixed-point, which is also a function itself.</blockquote><p>At first glance \(Y\) looks trivially easy to implement. Can&#39;t we just say that</p><p>$$Y = \lambda f. f \enspace (Y\enspace f)$$</p><p>? Well, if we were using another language, we could, but in the lambda calculus we can&#39;t refer to \(Y\) by name. Remember, functions technically don&#39;t have names at all in the lambda calculus; the formal calculus uses only lambdas and variables. So, if we want \(Y\) to be a valid term, we have to write everything out. Let&#39;s substitute that occurrence of \(Y\) in the function body with its explicit definition:</p><p>$$Y = \lambda f. f \enspace (Y\enspace f)$$</p><p>$$Y = \lambda f. f \enspace (\lambda f. f \enspace (Y \enspace f)\enspace f)$$</p><p>Hmm....let&#39;s try again:</p><p>$$Y = \lambda f. f \enspace (\lambda f. f \enspace (\lambda f. f \enspace (Y\enspace f) \enspace f)\enspace f)$$</p><p>Okay, it&#39;s becoming clear we can&#39;t write out \(Y\) explicitly: this process will continue forever, and terms in the lambda calculus are not allowed to be infinitely large.</p><p>Since we can&#39;t get away with having \(Y\) refer to itself in its own definition, we need it to be somehow <em>self-replicating</em>. \(Y(f)\) must manufacture a copy of itself at runtime and then wrap that copy in another \(f\). But now we have a nasty chicken-and-egg problem: it&#39;s not clear how to replicate \(Y(f)\) without knowing its structure, and we won&#39;t know its structure until we figure out how to do the replication!</p><p>Let&#39;s forget about the outer \(f\) for now and consider how we could make the simplest possible self-replicating term (call it \(R\)). The first thing to notice is that we want something that <em>reduces</em> - an \(R\) that just sits there will always be trivially equal to itself, but that&#39;s not interesting or useful to us. We want a term that changes, but somehow ends up right back where it started. To make any progress, we need to make <em>some</em> claim about the structure of \(R\) (even if it ends up being wrong.) Let&#39;s start with the simplest structure that will reduce - a single function application:</p><p>$$R = M N$$</p><p>Let&#39;s see if we can make this work. We need to figure out what \(M\) and \(N\) should be. We&#39;re trying to replicate \(R\) by applying \(M\) to \(N\), so if \(R\) is a single function application, the inner structure of \(M\) should probably be a single application too. In other words, \(M\) should look something like:</p><p>$$M = \lambda x. ((f_1\space x) (f_2\space x))$$</p><p>where \(f_1\) and \(f_2\) are...something. What should they be? What should \(N\) be, for that matter? </p><p>We&#39;re ready to try and crack the nut of the problem. At this point you should try Messing Around for a while and see what you come up with; experiment with different terms for \(f_1\), \(f_2\), and \(N\) and see what the results are. Remember that <em>everything</em> in the lambda calculus is a function - there are no other types of values! When you&#39;ve figured it out (or you&#39;re just ready to move on), keep reading.</p><hr/><p>The key to this one is noticing that \(f_1\space x\) <em>must</em> equal \(M\) if we want \(MN\) to reduce to itself. We can&#39;t set \(f_1\) itself to \(M\); we&#39;ll end up with the infinite nesting we saw earlier and we&#39;ll never be able to write \(M\) down at all. Our other option is to pass \(M\) in as an argument, i.e. \(x = M\), which means \(N = M\), which means \(f_1\) and \(f_2\) are simply the identity functions (which means we can omit them altogether.) Put this all together and you get:</p><p>$$M = N = \lambda x.(x  x)$$</p><p>$$R = \lambda x.(x  x)\enspace\lambda x.(x x)$$</p><p>This works! It only takes a single step for \(R\) to replicate (you can do it in your head if you want - just substitute for \(x\) on the left-hand side.)</p><p>We have rediscovered the <em>Omega combinator</em>, or \(\Omega\), which is one of the simplest terms that can reproduce itself like this (you&#39;ll notice that it will keep reducing forever!)</p><p>Looking back at how we derived the Omega combinator, we can see what the trick to self-replication is. We got things working with \(\Omega\) because we passed a copy of M in as an <em>argument</em>, instead of directly nesting it inside of its own definition. This may just seem like semantics, but it allows us to do the nesting one step at a time during reduction instead of having to write down everything at once - which means we don&#39;t end up with infinitely large terms!</p><p>Time to put the pieces together. Let&#39;s tweak our Omega combinator to turn it into the Y combinator.</p><hr/><p>Last time, we structured \(M\) based on the structural assumptions we made about \(\Omega\). The only different between \(\Omega\) and \(Y f\) is that \(\Omega\) turns into \(\Omega\), and we want \(Y(f)\) to turn into \(f(Y(f))\). So we&#39;ll update the structure of \(M\) - instead of a single function application, it&#39;ll be a single function application <em>wrapped in an \(f()\)</em>:</p><p>$$ M = \lambda x.f (x x) $$ </p><p>Setting \(M = N\) as before, we get:</p><p>$$ Y(f) = M N = \lambda x.f (x x) \enspace \lambda x.f (x x) $$</p><p>$$ Y = \lambda f. \enspace (\lambda x. \enspace f(x  x)) \enspace (\lambda x. \enspace f(x  x)) $$</p><p>Does this work? Let&#39;s see:</p><p>$$ Y(f) = \lambda x.f (x x) \enspace \lambda x.f (x x) $$</p><p>$$ Y(f) = f (\lambda x.f (x x) \enspace \lambda x.f (x x))$$</p><p>Yes! It works. In a single substitution step, \(Y(f)\) nests itself inside of \(f\). That bizarre structure we saw at at the beginning of this post is indeed a fixpoint combinator! </p><hr/><h3 id="ythe-paradoxical-combinator">Y - the Paradoxical Combinator</h3><p>So far we&#39;ve learned what the Y combinator does, and we&#39;ve <em>kind of</em> learned why it&#39;s useful, but perhaps not in a very convincing way. So the Y combinator self-replicates without referring to itself by name...why do we care? What do we get by prohibiting self-reference, or by writing programs in such an unwieldy style? Isn&#39;t this all a bit abstruse (and while we&#39;re at it, how on earth is the Y combinator &#34;paradoxical&#34;?) I can give you a more satisfying answer, but you&#39;ll have to allow me a brief detour into the history of math.</p><p>The lambda calculus was created in the early 20th century, when mathematics was re-orienting itself around the idea of <em>formalism</em>. Formalism, in a nutshell, is a philosophy that says mathematics is &#34;just&#34; the act of manipulating symbols according to well-defined rules. This may seem tautological, but it&#39;s not - it represented a significant shift in attention towards the symbols and rules themselves and away from the things mathematics is &#34;about&#34; (numbers, shapes, functions, etc.)</p><p>This new formalist perspective led to a proliferation of <em>formal systems.</em> At its most basic, a formal system is a set of symbols that can be arranged into formulas, a set of rules for manipulating symbols to make new formulas, and a set of <em>axioms</em> - formulas that are assumed to be true. You&#39;re probably familiar with a couple of formal systems already, such as the predicate calculus, set theory, or Peano arithmetic.</p><p>Formal systems featured prominently in 20th century mathematics, and new ones are still being created today. A well-constructed formal system can serve a wide variety of purposes. For example:</p><ul>
<li>Many formal systems have been proposed as potential <em>foundations of mathematics</em> - systems in which every area of mathematics can, in theory, be re-derived. A suitable foundational system a) unifies separate areas of mathematics, making it easier to port insights and techniques between them, and b) provides a rock-solid underpinning for concepts that may have been accepted as true without being fully understood. Today it is widely accepted that Zermelo-Frankel set theory is the most suitable foundation for mainstream mathematics, but other systems could potentially work as foundations as well, such as (some variants of) category theory, and even (some variants of) the lambda calculus!</li>
<li>Formal systems can be used to learn things about a particular style of reasoning, deduction, or calculation (a formal system might be proposed simply so that mathematicians can study its capabilities and limitations - not because it&#39;s ever intended to be used in practice.)</li>
<li>On the flip side, some formal systems <em>are</em> just easier to do mathematics in (this is a matter of taste, of course.) For example, many proponents of category theory maintain that certain results are much more natural to derive categorically than in other systems.</li>
<li>As computer science matured into its own field of inquiry, there was a lot of work done on <em>functional</em> programming languages (functional languages you may have heard of include LISP, Haskell, and OCaml.) While an imperative program is (loosely) a series of instructions, a functional program is (loosely) a collection of terms and a set of rules for turning terms into other terms. Existing formal systems like the lambda calculus provided a natural jumping-off point for the designers of these new functional languages.</li>
</ul>
<p>(Some systems are referred to as formal systems and others are referred to as formal systems <em>of logic</em> (or formal logics, for short), but the criteria that distinguish these are blurry and a point of contention among some mathematicians. They also aren&#39;t relevant to the aims of this article, so for now we&#39;ll treat both of these terms as equivalent.)</p><p>All of this is to say that Haskell Curry was (probably!) thinking about the lambda calculus as it was first presented - that is, as a formal system, and not as a programming language. </p><p>A few other things that are important to understand about the lambda calculus before we move on:</p><ol><li>it was created to be <em>small</em>. It has variables, abstraction, application, and two reduction rules. That&#39;s <em>it</em> - that is the complete language. This minimality serves an aesthetic goal (to capture the &#34;essence&#34; of computation), but it also makes the lambda calculus easy to reason about (take, for example, the Church-Rosser Theorem, which says that regardless of the order in which you reduce terms in an expression you&#39;ll always end up with the same value at the end. You would not want to try and prove this fact about a more complicated language.) </li><li>it was first described Church in 1930, more than six years before Alan Turing (Church&#39;s doctoral student at the time) would publish his work on Turing machines. At the time there was a broad and ongoing investigation into the nature of computation, but there were no physical computers to speak of and certainly no programming languages. The closest analogues to Church&#39;s system were systems of formal logic - it&#39;s doubtful anyone imagined or assumed that the lambda calculus itself would be directly used to give instructions to a computer.</li><li>A big theme in 20th century computer science is that computation and formal logic are two sides of the same coin, in a few important ways (we&#39;ll look at this more in a bit.)</li></ol><p>That said - whence the Y combinator? Well, Curry needed it in order to create a <em>paradox </em>within the lambda calculus.</p><p>In the parlance of formal logic, a paradox is a proof that doesn&#39;t break any rules, but still ends in a contradiction (i.e. it proves a proposition and its opposite at the same time.) You may be familiar with the famous Russel paradox; the informal version goes like this: &#34;there is a barber who shaves all those, and those only, who do not shave themselves. Does this barber shave himself?&#34; On the one hand, the barber <em>must </em>shave himself - if he didn&#39;t, he&#39;d fit the criteria for people he shaves, so he&#39;d end up shaving himself anyway. On the other hand, the barber <em>cannot</em> shave himself - if he did, he would no longer fit his own criteria, and would be unable to take himself on as a customer.</p><p>Proving a contradiction is usually a knife through the heart for a system of logic. If you can prove a proposition and its opposite are both true, you can often find a way to prove <em>any</em> statement - and a system that can prove anything is not very useful (logicians refer to this kind of system as <em>trivial.</em>) You&#39;re only supposed to be able to prove things that are actually true!</p><p>Paradoxes are important tools to probe the flaws and limitations of formal systems. The discovery of Russel&#39;s Paradox, for example, led to many augmented systems of logic containing various mechanisms to ensure the paradox could no longer occur (fun fact: among these efforts were the first incarnations of type theory!) In particular, since Russel&#39;s Paradox has negation at its core (the barber shaves people who <em>don&#39;t</em> shave themselves), many logicians hoped they could dodge it by constructing systems that had a modified concept of negation, or no concept of negation at all.</p><p>Curry&#39;s Paradox shot those hopes down. It&#39;s a variant of Russel&#39;s Paradox that doesn&#39;t depend on negation. Curry constructed his paradox to prove the triviality of a bunch of different logics - among them, the famous lambda calculus and Moses SchÃ¶nfinkel&#39;s <a href="https://en.wikipedia.org/wiki/Combinatory_logic?ref=the-nerve-blog.ghost.io" rel="noreferrer">combinatory logic</a>.</p><blockquote>
<p>Combinatory logic was invented by Moses SchÃ¶nfinkel in a 1924 paper (it was one of the two papers he published in his whole life.) SchÃ¶nfinkel&#39;s goal was to create a form of logic that did not include the notion of a variable. Instead, it uses a fixed set of <em>combinators</em> - which are functions that take other combinators and apply them to each other in various ways. Just as everything in the lambda calculus is a function, an expression in combinatory logic <em>only</em> consists of combinators - it&#39;s combinators all the way down. </p>
</blockquote>
<p>Anyway, enough preamble - let&#39;s examine Curry&#39;s Paradox in all its glory.</p><p>Take a look at this:</p><p>&#34;If this sentence - the very one I&#39;m speaking now - is true, then all birds are government spies.&#34;</p><p>It turns out that using this sentence alone you can prove the fact that all birds are government spies - or anything else you wish to prove, including a contradiction like &#34;1 = 1 and also 1 = 0&#34;. This paradox is not quite as intuitive as Russel&#39;s Paradox, so we probably need to look at it more formally before it starts to make sense.</p><p>Consider the following statement:</p><p>\(S\): If statement \(S\) is true, proposition \(P\) is true.</p><ul>
<li>The standard way to prove an implication \(X =&gt; Y\) is to assume that the first part is true and then deduce that the second part must be true, given that the first part is. So, let&#39;s take &#34;\(S\) is true&#34; as a hypothesis.</li>
<li>\(S\) is true, so \(S =&gt; P\) is true, since \(S\) states directly that \(S =&gt; P\). </li>
<li>\(S\) is true by hypothesis, and \(S\) says \(S =&gt; P\) is true. Taken together, this means \(P\) must be true.</li>
<li>We just proved that if you assume \(S\) is true, \(P\) must be true as well. In other words, we proved \(S =&gt; P\).</li>
<li>\(S\) states directly that \(S =&gt; P\), and we just proved that \(S =&gt; P\) is true. So, \(S\) is true as well!</li>
<li>Finally, since \(S\) is true and \(S =&gt; P\) is true, \(P\) is true as well - <strong>no matter what \(P\) is</strong>. Paradox!!</li>
</ul>
<p>As mentioned, the key here is thay \(S =&gt; P\) refers to itself via its own antecedent, \(S\). As we saw before, we&#39;ll need the Y combinator to make this happen in systems that don&#39;t permit explicit self-reference.</p><hr/><h3 id="currys-paradox-in-the-lambda-calculus">Curry&#39;s Paradox in the Lambda Calculus</h3><p>In this section we&#39;re going to put together everything we&#39;ve learned so far to implement Curry&#39;s Paradox in the lambda calculus. This might seem nonsensical to you - what does it mean to <em>implement</em> a paradox? How could a logical paradox be put into a system of computation?</p><p>In the last section we learned about the concept of a <em>formal system,</em> and I gave a few examples. Some of these are logical systems, in which you manipulate symbols to make logical deductions, and some are computational systems, in which you manipulate symbols to perform computations and come up with a result. Using a computational system to prove things or do logical deduction doesn&#39;t seem to make any sense - it wasn&#39;t built for that, right?</p><p>The Curry-Howard Correspondence was a slow-motion realization by Haskell Curry and the logician William Alvin Howard (and a few other mathematicians, at various times) that these two &#34;types&#34; of systems are actually, in a deep and important sense, intertwined! In other words, we <em>are</em> writing proofs when we write programs - they&#39;re just <em>constructive</em> proofs. </p><blockquote>
<p>The term &#34;constructive proof&#34; takes its name from constructivism, which, like formalism, is a philosophy of mathematics that was the topic of some debate in the early 20th century. There&#39;s a lot to say about constructivism, but the part that&#39;s relevant to us is the belief that the only way to prove a certain class of mathematical objects exists is to construct an example and present it. </p>
</blockquote>
<p>To understand what it means for a program to represent a constructive proof, consider the value &#34;hello&#34;. This is a value of type \(String\), which means it is an example of a \(String\), which means it is a <em>constructive proof that at least one value of type \(String\) exists</em>. </p><p>Now consider the following (pseudocode) function:</p><p>$$ firstChar(myString: String) = myString[0] $$</p><p>This accepts a \(String\) and returns a \(Char\). In other words, it accepts a constructive proof that a \(String\) exists and returns a constructive proof that a \(Char\) exists. In other words, it is a constructive proof that says &#34;if at least one value of type \(String\) exists, at least one value of type \(Char\) exists&#34;<em>.</em></p><p>This extends to higher order functions as well. For example, this function:</p><p>$$ firstDigit(firstChar: (String) =&gt; Char, toString: (Number) =&gt; String, num: Number) = firstChar(toString(num))$$ </p><p>is a constructive proof that says &#34;if the existence of a \(String\) implies the existence of a \(Char\), and the existence of a \(Number\) implies the existence of a \(String\), and at least one \(Number\) exists, then at least one \(Char\) exists&#34;.</p><p>For typed languages, the Curry-Howard correspondence implies that types can be seen as propositions, and terms of a particular type can be seen as proofs of the proposition that type represents. This is often referred to as the &#34;propositions as types&#34; perspective.</p><p>(The &#34;proofs&#34; embodied by a lot of business software are usually not very interesting - e.g. &#34;if we have a proof that a list of numbers exists, we can prove that a list of strings exists&#34;, etc.  People can and do write full, mathematically useful proofs using programs, but these programs generally look very different than the ones written by professional software developers.)</p><p>The full statement and context of the Curry-Howard Correspondence is more technical than this, but this is the general idea, and enough of a start for us to work with.</p><hr/><p>Now let&#39;s think of another term - a number that is both odd and even at the same time. We&#39;ll refer to this kind of number as an \(Evil\) number, i.e. our number is a term of type \(Evil\). This term functions as a constructive proof that there exists at least one \(Evil\) number (which, of course, we know isn&#39;t true!) We&#39;ll refer to this term as \(evil\) - and since it proves something that isn&#39;t true, it can&#39;t be constructed directly. But is there a way to express it nonetheless? (spoiler: in the naive lambda calculus, there is)</p><p>We can&#39;t create \(evil\) directly, but we <em>could</em> return it from a function, if the function had some way to get an \(evil\) from its arguments. It doesn&#39;t make sense to directly accept \(evil\) as an argument (how would the caller construct it?) but we could accept a <em>function</em> that returns it. But what should <em>that</em> function accept? Well...<em>another</em> function that also returns \(evil\)! The naive lambda calculus doesn&#39;t have types, but if it did, the type of our new function would (informally) look like:</p><p>$$ createEvil: createEvil \rightarrow Evil $$</p><p>To get \(evil\) from \(createEvil\), we supply it with a function that creates \(evil\) - and our only option is \(createEvil\) itself. The non-lambda-calculus version of this looks like:</p><p>$$ createEvil(f) = f(f) $$</p><p>and we call it like so:</p><p>$$ evil = createEvil(createEvil) $$</p><p>(Note that what we&#39;ve done is to <em>express</em> a term that represents \(evil\). Were we to actually try to run this function, it would run forever. This is not unexpected - paradoxes and nontermination are two sides of the same &#34;things are breaking&#34; phenomenon.)</p><p>Let&#39;s stop and consider for a second. If you screw up your eyes a little you can see that this weird function is analogous to Curry&#39;s Paradox. Consider:</p><ul><li>a function that takes a proof object for \(A\) and turns it into a proof object for \(B\) is a constructive proof of \(A \Rightarrow B\)</li><li>a function that takes <em>that</em> function and turns it into \(evil\) is a constructive proof of \((A \Rightarrow B) \Rightarrow evil\)</li><li>consider a function that takes <em>itself</em> and turns it into \(evil\). If we refer to the proposition this function proves as \(S\), it directly follows that this function <em>also</em> proves \(S \Rightarrow evil\)</li></ul><p>This should look familiar to you - it&#39;s exactly the structure that caused so much trouble in our earlier example! Let&#39;s go through the rest of the paradox to see how it lines up with \(createEvil\)</p><table>
<thead>
<tr>
<th>Logic World</th>
<th>Program World</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consider \(S = (S \Rightarrow evil\))</td>
<td>Consider \(createEvil\)</td>
</tr>
<tr>
<td>First, we must prove \(S \Rightarrow evil\)</td>
<td>First, we must implement \(createEvil\)</td>
</tr>
<tr>
<td>Assume \(S\) is true, as a hypothesis. Since \(S\) is true, \(S \Rightarrow evil\) is true, because \(S\) states directly that \(S \Rightarrow evil\)</td>
<td>\(createEvil\) takes \(createEvil\) as a parameter, so as we implement \(createEvil\) we can assume we have an instance of \(createEvil\) available to us - i.e. we have a constructive proof of \(createEvil \Rightarrow evil\)</td>
</tr>
<tr>
<td>Since we have assumed \(S\) is true and shown \(S \Rightarrow evil\) to be true as a consequence, that proves \(evil\) is true if \(S\) is true - i.e. we have proven \(S \Rightarrow evil\)</td>
<td>Since we have an instance of \(createEvil\) available to us, we can simply pass it to itself to produce an instance of \(evil\). We have implemented \(createEvil\) and completed our constructive proof of \(createEvil \Rightarrow evil\)</td>
</tr>
<tr>
<td>We have proved \(S \Rightarrow evil\), which also means we have proved \(S\). By combining \(S \Rightarrow evil\) and \(S\), we can deduce \(evil\) is true as well. Paradox!!</td>
<td>\(createEvil\) is a constructive proof of both \(createEvil\) and \(createEvil \Rightarrow evil\). Now that we have implemented \(createEvil\), we can simply write \(createEvil(createEvil)\) to (in theory) produce an instance of the inconstructable \(evil\). Paradox!!</td>
</tr>
</tbody>
</table>
<p>Hopefully now it&#39;s clear that \(createEvil\) is the computational manifestation of Curry&#39;s Paradox. We&#39;re exploiting self-reference here to produce a function that &#34;proves&#34; \(evil\) exists (it can also prove that any other value exists, just like the &#34;regular&#34; version of Curry&#39;s paradox can prove any \(P\).) Yet, since this function never terminates, running it will break your program, just as proving a contradiction will break your logical system.</p><p>Now for the coup de grace - let&#39;s rewrite \(createEvil\) in the lambda calculus. Remember, we can&#39;t do \(createEvil = createEvil(createEvil)\) directly because the lambda calculus technically doesn&#39;t allow for named functions. We need some way to pass \(createEvil\) to itself at runtime. This is where the Y combinator (finally) enters the picture. Recall that:</p><p>$$ Y(f) = f(Y(f)) $$</p><p>if we let \(f = \lambda x. (x x)\), we get:</p><p>$$ Y(f) = f(Y(f))$$</p><p>$$ Y(f) = (\lambda x.(x x)) \space Y(f) $$</p><p>$$ Y(f) = Y(f) \space Y(f) $$</p><p>We can see that if we let \(createEvil = Y \enspace \lambda x. (x x)\), we end up with \(createEvil = createEvil \space createEvil\), like we wanted. Thus, the final form of \(createEvil\), fully written out in the lambda calculus, is:</p><p>$$  (\lambda f. \enspace (\lambda x. \enspace f(x  x)) \enspace (\lambda x. \enspace f(x  x))) (\lambda x. \enspace (x x)) $$</p><hr/><p>What does it mean that we&#39;ve implemented Curry&#39;s Paradox in the lambda calculus? It means that the (naive) lambda calculus has some pretty notable issues as a formal system. How do we deal with that? By adding types, thus upgrading the naive lambda calculus to the simply typed lambda calculus. We&#39;ll cover this topic more in Part 2!</p>
        </section>

    </article>


</div></div>
  </body>
</html>
