<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/videogame">Original</a>
    <h1>Leveraging Rust and the GPU to render user interfaces at 120 FPS</h1>
    
    <div id="readability-page-1" class="page"><div><p>A modern display&#39;s refresh rate ranges from 60 to 120 frames per second, which means an application only has 8.33ms per frame to push pixels to screen. This includes updating the application state, laying out UI elements, and finally writing data into the frame buffer.</p>
<p>It&#39;s a tight deadline, and if you&#39;ve ever built an application with Electron, it&#39;s a deadline that may feel impossible to consistently meet. Working on Atom, this is exactly how we felt: no matter how hard we tried, there was always something in the way of delivering frames on time. A random pause due to garbage collection and we missed a frame. An expensive DOM relayout and we missed another frame. The frame rate was never consistent, and many of the causes were beyond our control.</p>
<p>Yet while we struggled to micro-optimize Atom&#39;s rendering pipeline consisting of simple boxes and glyphs, we stared in awe of computer games rendering beautiful, complex geometry at a constant rate of 120 frames per second. How could it be that rendering a few <code>&lt;div&gt;</code>s was so much slower than drawing a three-dimensional, photorealistic character?</p>
<p>When we set out to build Zed, we were determined to create a code editor so responsive it almost disappeared. Inspired by the gaming world, we realized that the only way to achieve the performance we needed was to build our own UI framework: GPUI.</p>
<p><figure><video loop="" muted="" controls="" playsinline=""><source src="/video/built-like-a-videogame.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/video/built-like-a-videogame.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video><figcaption>Zed is rendered like a videogame, which lets us explode all layers in the user interface and simulate a 3D camera rotating around them.</figcaption></figure></p>
<h2 id="gpui-rendering">GPUI: Rendering</h2>
<p>When we started building Zed, arbitrary 2D graphics rendering on the GPU was still very much a research project. We experimented with Patrick Walton&#39;s <a href="https://github.com/servo/pathfinder">Pathfinder</a> crate, but it wasn&#39;t fast enough to achieve our performance goals.</p>
<p>So we took a step back, and reconsidered the problem we were trying to solve. While a library capable of rendering arbitrary graphics may have been nice, the truth was that we didn&#39;t really need it for Zed. In practice, most 2D graphical interfaces break down into a few basic elements: rectangles, shadows, text, icons, and images.</p>
<p>Instead of worrying about a general purpose graphics library, we decided to focus on writing a custom shader for each specific graphical primitive we knew we&#39;d need to render Zed&#39;s UI. By describing the properties of each primitive in a data-driven way on the CPU, we could delegate all of the heavy-lifting to the GPU where UI elements could be drawn in parallel.</p>
<p>In the following sections, I am going to illustrate the techniques used in GPUI to draw each primitive.</p>
<h3 id="drawing-rectangles">Drawing rectangles</h3>
<p>The humble rectangle is a fundamental building block of graphical UIs.</p>
<p>To understand how drawing rectangles works in GPUI, we first need to take a detour into the concept of Signed Distance Functions (SDFs for short). As implied by the name, an SDF is a function that, given an input position, returns the distance to the edge of some mathematically-defined object. The distance approaches zero as the position gets closer to the object, and becomes negative when stepping inside its boundaries.</p>
<div><figure><figcaption>Signed distance function of a circle.</figcaption></figure></div>
<p>The list of known SDFs is extensive, mostly thanks to Inigo Quilez&#39;s <a href="https://iquilezles.org/articles/distfunctions">seminal work</a> on the subject. On his website, you can also find a never-ending series of techniques that allow distortion, composition and repetition of SDFs to generate the most complex and realistic 3D scenes. Seriously, <a href="https://iquilezles.org">check it out</a>. It&#39;s pretty amazing.</p>
<p>Back to rectangles: let&#39;s derive a SDF for them. We can simplify the problem by centering the rectangle we want to draw at the origin. From here, it&#39;s relatively straightforward to see the problem is symmetric. In other words, calculating the distance for a point lying in one of the four quadrants is equivalent to calculating the distance for the mirror image of that point in any of the other three quadrants.</p>
<div><figure><figcaption>Drawing the rectangle at the origin lets us use the absolute value and only worry about the positive quadrant.</figcaption></figure></div>
<p>This means we only need to worry about the top-right portion of the rectangle. Taking the corner as a reference, we can distinguish three cases:</p>
<ul>
<li>Case 1), the point is both above and to the left of the corner. In this case, the shortest distance between the point and the rectangle is given by the vertical distance from the point to the top edge.</li>
<li>Case 2), the point is both below and to the right of the corner. In this case, the shortest distance between the point and the rectangle is given by the horizontal distance from point to the right edge.</li>
<li>Case 3), the point is above and to the right of the corner. In this case, we can use the Pythagorean theorem to determine the distance between the corner and the point.</li>
</ul>
<p>Case 3 can be generalized to cover the other two if we forbid the distance vector to assume negative components.</p>
<div><figure><figcaption>A combination of the Pythagorean theorem and the max function lets us determine the shortest distance from the point to the rectangle.</figcaption></figure></div>
<p>The rules we just sketched out are sufficient to draw a simple rectangle and, later in this post, we will describe how that translates to GPU code. Before we get to that though, we can make a simple observation that allows extending those rules to calculate the SDF of rounded rectangles too!</p>
<p>Notice how in case 3) above, there are infinitely many points located at the same distance from the corner. In fact, those aren&#39;t just random points, they are the points that describe a circle originating at the corner and having a radius equal to the distance.</p>
<p>Borders start to get smoother as we move away from the straight rectangle. That&#39;s the key insight to drawing rounded corners: given a desired corner radius, we can shrink the original rectangle by it, calculate the distance to the point and subtract the corner radius from the computed distance.</p>

<p>Porting the rectangle SDF to the GPU is very intuitive. As a quick recap, the classic GPU pipeline consists of a vertex and a fragment shader.</p>
<p>The vertex shader is responsible for mapping arbitrary input data into points in 3-dimensional space, with each set of three points defining a triangle that we want to draw on screen. Then, for every pixel inside the triangles generated by the vertex shader, the GPU invokes the fragment shader, which is responsible for assigning a color to the given pixel.</p>
<p>In our case, we use the vertex shader to define the bounding box of the shape we want to draw on screen using two triangles. We won&#39;t necessarily fill every pixel inside this box. That is left to the fragment shader, which we&#39;ll discuss next.</p>
<p>The following code is in Metal Shader Language, and is designed to be used with <a href="https://metalbyexample.com/instanced-rendering/">instanced rendering</a> to draw multiple rectangles to the screen in a single draw call:</p>
<div><pre><code><span><span>struct</span> <span>RectangleFragmentInput</span> {</span>
    float4 position [[position]];
    float2 origin [[flat]];
    float2 size [[flat]];
    float4 background_color [[flat]];
    <span>float</span> corner_radius [[flat]];
};

vertex RectangleFragmentInput <span>rect_vertex</span><span>(
    uint unit_vertex_id [[vertex_id]],
    uint rect_id [[instance_id]],
    constant float2 *unit_vertices [[buffer(GPUIRectInputIndexVertices)]],
    constant GPUIRect *rects [[buffer(GPUIRectInputIndexRects)]],
    constant GPUIUniforms *uniforms [[buffer(GPUIRectInputIndexUniforms)]]
)</span> {
    float2 position = unit_vertex * rect.size + rect.origin;
    
    float4 device_position = to_device_position(position, viewport_size);
    <span>return</span> RectangleFragmentInput {
      device_position,
      rect.origin,
      rect.size,
      rect.background_color,
      rect.corner_radius
    };
}
</code></pre></div>
<p>To determine the color to assign to each pixel within this bounding box, the fragment shader calculates the distance from the pixel to the rectangle and fills the pixel only when it lies inside the boundaries (i.e., when the distance is zero):</p>
<div><pre><code><span>float</span> <span>rect_sdf</span><span>(
    float2 absolute_pixel_position,
    float2 origin,
    float2 size,
    <span>float</span> corner_radius
)</span> {
    float2 half_size = size / <span>2.</span>;
    float2 rect_center = origin + half_size;

    
    
    float2 pixel_position = <span>abs</span>(absolute_pixel_position - rect_center);

    
    float2 shrunk_corner_position = half_size - corner_radius;

    
    
    float2 pixel_to_shrunk_corner = max(float2(<span>0.</span>, <span>0.</span>), pixel_position - shrunk_corner_position);

    <span>float</span> distance_to_shrunk_corner = length(pixel_to_shrunk_corner);

    
    
    <span>float</span> distance = distance_to_shrunk_corner - corner_radius;

    <span>return</span> distance;
}

fragment float4 <span>rect_fragment</span><span>(RectangleFragmentInput input [[stage_in]])</span> {
    <span>float</span> distance = rect_sdf(
        input.position.xy,
        input.origin,
        input.size,
        input.corner_radius,
    );
    <span>if</span> (distance &gt; <span>0.0</span>) {
        <span>return</span> float4(<span>0.</span>, <span>0.</span>, <span>0.</span>, <span>0.</span>);
    } <span>else</span> {
        <span>return</span> input.background_color;
    }
}
</code></pre></div>
<h3 id="drop-shadows">Drop shadows</h3>
<p>To render drop shadows in GPUI, we adopted a <a href="https://madebyevan.com/shaders/fast-rounded-rectangle-shadows/">technique</a> developed by Evan Wallace, co-founder of Figma. For completeness, I will summarize the contents of the blog post here, but it&#39;s definitely worth reading the original article.</p>
<p>Typically, drop shadows in applications are rendered using a Gaussian blur. For every output pixel, the Gaussian blur is the result of a weighted average of all the surrounding input pixels, with the weight assigned to each pixel decreasing for farther pixels in a way that follows a Gaussian curve.</p>
<p><figure><video loop="" muted="" controls="" playsinline=""><source src="/img/post/videogame/gaussian.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/videogame/gaussian.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video><figcaption>Applying a Gaussian blur to the Zed logo.</figcaption></figure></p>
<p>If we move to the continuous realm, we can think of the process above as the convolution of an input signal (in the discrete case, the pixels of an image) with a <a href="https://en.wikipedia.org/wiki/Gaussian_function">Gaussian function</a> (in the discrete case, a matrix representing the values of a Gaussian probability distribution). Convolution is a special mathematical operator that produces a new function by taking the integral of the product of two functions, where one of the functions (it doesn&#39;t matter which) is mirrored about the y axis. On an intuitive level, it works as if we are sliding the Gaussian curve all over the image, calculating for every pixel a moving, weighted average that samples from the Gaussian curve to determine the weight of the surrounding pixels.</p>
<p>One interesting aspect of Gaussian blurs is that they are separable. That is, the blur can be applied separately along the x and y axes and the resulting output pixel is the same as applying a single blur in two dimensions.</p>
<p>In the case of a rectangle, there exists a closed-form solution to draw its blurred version without sampling neighboring pixels. This is because rectangles are also separable, and can be expressed as the intersection of two <a href="https://en.wikipedia.org/wiki/Boxcar_function">Boxcar functions</a>, one for each dimension:</p>
<div><figure><figcaption>Intersecting two Boxcar functions produces a rectangle.</figcaption></figure></div>
<p>The convolution of a Gaussian with a step function is equivalent to the integral of the Gaussian, which yields the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> (also called <code>erf</code>). Therefore, generating a blurred straight rectangle is the same as blurring each dimension separately and then intersecting the two results:</p>
<div><pre><code><span>float</span> <span>rect_shadow</span><span>(float2 pixel_position, float2 origin, float2 size, <span>float</span> sigma)</span> {
    float2 bottom_right = origin + size;
    float2 x_distance = float2(pixel_position.x - origin.x, pixel_position.x - bottom_right.x);
    float2 y_distance = float2(pixel_position.y - origin.y, pixel_position.y - bottom_right.y);
    float2 integral_x = <span>0.5</span> + <span>0.5</span> * erf(x_distance * (<span>sqrt</span>(<span>0.5</span>) / sigma));
    float2 integral_y = <span>0.5</span> + <span>0.5</span> * erf(y_distance * (<span>sqrt</span>(<span>0.5</span>) / sigma));
    <span>return</span> (integral_x.x - integral_x.y) * (integral_y.x - integral_y.y);
}
</code></pre></div>
<p>A closed-form solution like the one above, however, doesn&#39;t exist for the 2D convolution of a rounded rectangle with a Gaussian, because the formula for a rounded rectangle is not separable. The cleverness of Evan Wallace&#39;s approximation comes from performing a closed-form, exact convolution along one axis, and then manually sliding the Gaussian along the opposite axis a finite amount of times:</p>
<div><pre><code><span>float</span> <span>blur_along_x</span><span>(<span>float</span> x, <span>float</span> y, <span>float</span> sigma, <span>float</span> corner, float2 half_size)</span> {
    <span>float</span> delta = min(half_size.y - corner - <span>abs</span>(y), <span>0.</span>);
    <span>float</span> curved = half_size.x - corner + <span>sqrt</span>(max(<span>0.</span>, corner * corner - delta * delta));
    float2 integral = <span>0.5</span> + <span>0.5</span> * erf((x + float2(-curved, curved)) * (<span>sqrt</span>(<span>0.5</span>) / sigma));
    <span>return</span> integral.y - integral.x;
}

<span>float</span> <span>shadow_rounded</span><span>(float2 pixel_position, float2 origin, float2 size, <span>float</span> corner_radius, <span>float</span> sigma)</span> {
    float2 half_size = size / <span>2.</span>;
    float2 center = origin + half_size;
    float2 point = pixel_position - center;

    <span>float</span> low = point.y - half_size.y;
    <span>float</span> high = point.y + half_size.y;
    <span>float</span> start = clamp(<span>-3.</span> * sigma, low, high);
    <span>float</span> end = clamp(<span>3.</span> * sigma, low, high);

    <span>float</span> step = (end - start) / <span>4.</span>;
    <span>float</span> y = start + step * <span>0.5</span>;
    <span>float</span> alpha = <span>0.</span>;
    <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>4</span>; i++) {
        alpha += blur_along_x(point.x, point.y - y, sigma, corner_radius, half_size) * gaussian(y, sigma) * step;
        y += step;
    }

    <span>return</span> alpha;
}
</code></pre></div>
<h3 id="text-rendering">Text Rendering</h3>
<p>Rendering glyphs efficiently is crucial for a text-intensive application like Zed. At the same time, it is equally important to produce text that matches the look and feel of the target operating system. To understand how we solved both problems in GPUI, we need to understand how text shaping and font rasterization work.</p>
<p><a href="https://fonts.google.com/knowledge/glossary/shaping">Text shaping</a> refers to the process of determining which glyphs should be rendered and where they should be positioned given some sequence of characters and a font. There are <a href="https://github.com/harfbuzz/harfbuzz">several</a> <a href="https://github.com/yeslogic/allsorts">open-source</a> <a href="https://github.com/RazrFalcon/rustybuzz">shaping</a> <a href="https://github.com/dfrg/swash">engines</a>, and operating systems usually provide similar APIs out of the box (e.g., CoreText on macOS). Shaping is generally regarded as quite expensive, even more so when dealing with languages that are <a href="https://en.wikipedia.org/wiki/Complex_text_layout">inherently harder</a> to typeset, such as Arabic or Devanagari.</p>
<p>One key observation about the problem is that text normally doesn&#39;t change much across frames. For example, editing a line of code doesn&#39;t affect the surrounding lines, so it would be unnecessarily expensive to shape those again.</p>
<p>As such, GPUI uses the operating system&#39;s APIs to perform shaping (this guarantees that text looks consistent with other native applications) and maintains a cache of text-font pairs to shaped glyphs. When some piece of text is shaped for the first time, it gets inserted into the cache. If the subsequent frame contains the same text-font pair, the shaped glyphs get reused. Vice versa, if a text-font pair disappears from the subsequent frame, it gets deleted from the cache. This amortizes the cost of shaping and limits it only to text that changes from one frame to the other.</p>
<p><a href="https://en.wikipedia.org/wiki/Font_rasterization">Font rasterization</a>, on the other hand, refers to the process of converting a glyph&#39;s vector representation into pixels. There are several ways to implement a rasterizer, with classic CPU rasterizers such as the one provided by the operating system (e.g., CoreText on macOS) or <a href="https://freetype.org">FreeType</a>, and with some more recent research projects doing so mostly on the GPU using <a href="https://www.khronos.org/opengl/wiki/Compute_Shader">compute shaders</a> (e.g., <a href="https://github.com/servo/pathfinder">Pathfinder</a>, <a href="https://github.com/google/forma">Forma</a>, or <a href="https://github.com/linebender/vello">Vello</a>).</p>
<p>As mentioned before, however, our hypothesis with GPUI was that we could achieve maximal performance by writing shaders for specific primitives as opposed to having a single engine capable of rendering arbitrary vector graphics. For text specifically, our goal was to render largely static content without interactive transformations that matched the platform&#39;s native visual style. Moreover, the set of glyphs that needs to be rendered is finite and can be cached quite effectively, so rendering on the CPU doesn&#39;t really become a bottleneck.</p>
<div><figure><img src="https://zed.dev/img/post/videogame/texture-atlas.png" alt="A screenshot of a glyph atlas produced by Zed."/><figcaption>A screenshot of a glyph atlas produced by Zed.</figcaption></figure></div>
<p>Just like with text shaping, we let the operating system handle glyph rasterization so that text perfectly matches other native applications. In particular, we rasterize only the alpha component (the opacity) of the glyph: we&#39;ll get into why in a little bit. We actually render up to 16 different variants of each individual glyph to account for sub-pixel positioning, since CoreText subtly adjusts antialiasing of glyphs to give them the visual appearance of being shifted slightly in the X and Y direction.</p>
<p>The resulting pixels are then cached into an <a href="https://en.wikipedia.org/wiki/Texture_atlas">atlas</a>, a long-lived texture stored on the GPU. The location of each glyph in the atlas is stored on the CPU, and glyphs are accurately positioned in the atlas to use as little space as possible using the bin-packing algorithm provided by <a href="https://github.com/nical/etagere">etagere</a>.</p>
<p>Finally, using the previously-computed shaping information, those glyphs are assembled together to form the original piece of text that the application wanted to render.</p>
<p>The above is done in a single, instanced draw call that describes the target location of the glyph along with its position in the atlas:</p>
<div><pre><code><span>typedef</span> <span><span>struct</span> {</span>
  float2 target_origin;
  float2 atlas_origin;
  float2 size;
  float4 color;
} GPUIGlyph;
</code></pre></div>
<p>Notice how <code>GPUIGlyph</code> allows specifying a color for the glyph. This is the reason why we previously rasterized the glyph using only its alpha channel. By only storing the glyph&#39;s opacity, we can fill it with any color we want using a simple multiplication and avoid storing one copy of the glyph in the atlas for each color used.</p>
<div><pre><code><span><span>struct</span> <span>GlyphFragmentInput</span> {</span>
    float4 position [[position]];
    float2 atlas_position;
    float4 color [[flat]];
};

vertex GlyphFragmentInput <span>glyph_vertex</span><span>(
    uint unit_vertex_id [[vertex_id]],
    uint glyph_id [[instance_id]],
    constant float2 *unit_vertices [[buffer(GPUIGlyphVertexInputIndexVertices)]],
    constant GPUIGlyph *glyphs [[buffer(GPUIGlyphVertexInputIndexGlyphs)]],
    constant GPUIUniforms *uniforms [[buffer(GPUIGlyphInputIndexUniforms)]]
)</span> {
    float2 unit_vertex = unit_vertices[unit_vertex_id];
    GPUIGlyph glyph = glyphs[glyph_id];
    float2 position = unit_vertex * glyph.size + glyph.origin;
    float4 device_position = to_device_position(position, uniforms-&gt;viewport_size);
    float2 atlas_position = (unit_vertex * glyph.size + glyph.atlas_origin) / uniforms-&gt;atlas_size;

    <span>return</span> GlyphFragmentInput {
        device_position,
        atlas_position,
        glyph.color,
    };
}

fragment float4 <span>glyph_fragment</span><span>(
    GlyphFragmentInput input [[stage_in]],
    texture2d&lt;<span>float</span>&gt; atlas [[ texture(GPUIGlyphFragmentInputIndexAtlas) ]]
)</span> {
    constexpr sampler <span>atlas_sampler</span><span>(mag_filter::linear, min_filter::linear)</span>;
    float4 color = input.color;
    float4 sample = atlas.sample(atlas_sampler, input.atlas_position);
    color.a *= sample.a;
    <span>return</span> color;
}
</code></pre></div>
<p>It&#39;s interesting to note how the performance of composing text using the glyph atlas approximates the bandwidth of the GPU, as we are literally copying bytes from one texture to the other and performing a multiplication along the way. It doesn&#39;t get any faster than that.</p>
<h3 id="icons-and-images">Icons and Images</h3>
<p>Rendering icons and images in GPUI follows a similar technique as the one described in text rendering, so we won&#39;t be spending too much time covering that here. Exactly like text, SVG icons are parsed and then rasterized into pixels on the CPU using only their alpha channel, so that they can be tinted. On the other hand, images don&#39;t need tinting and so they are uploaded on a separate texture while preserving their color.</p>
<p>Icons and images are finally assembled back into their target position using a shader similar to the glyph one illustrated above.</p>
<h2 id="gpui-the-element-trait">GPUI: the <code>Element</code> trait</h2>
<p>So far we&#39;ve discussed the low-level details of how rendering is implemented. That concern, however, is completely abstracted away when creating an application with GPUI. Instead, users of the framework interact with the <code>Element</code> trait when they need to create new graphical affordances that can&#39;t be already expressed as a composition of existing elements:</p>
<div><pre><code><span>pub</span> <span>trait</span> <span>Element</span> {
    <span>fn</span> <span>layout</span>(&amp;<span>mut</span> <span>self</span>, constraint: SizeConstraint) <span>-&gt;</span> Size;
    <span>fn</span> <span>paint</span>(&amp;<span>mut</span> <span>self</span>, origin: (<span>f32</span>, <span>f32</span>), size: Size, scene: &amp;<span>mut</span> Scene);
}
</code></pre></div>
<p>Layout in GPUI was heavily inspired by <a href="https://flutter.dev">Flutter</a>. Specifically, elements nest into a tree structure where constraints flow down and sizes flow up. A constraint specifies the minimum and maximum size a given element can take:</p>
<div><pre><code><span>pub</span> <span>struct</span> <span>SizeConstraint</span> {
    <span>pub</span> min: Size,
    <span>pub</span> max: Size,
}

<span>pub</span> <span>struct</span> <span>Size</span> {
    <span>pub</span> width: <span>f32</span>,
    <span>pub</span> height: <span>f32</span>,
}
</code></pre></div>
<p>Depending on the nature of an element, the <code>layout</code> method can decide to produce a new set of constraints for its children to account for any extra visual details that the element is adding. For example, if an element wants to draw a 1px border around its child, it should shrink the <code>max.width</code> and <code>max.height</code> supplied by the parent by 1px and supply the shrunk constraint to its child:</p>
<div><pre><code><span>pub</span> <span>struct</span> <span>Border</span> {
    child: <span>Box</span>&lt;<span>dyn</span> Element&gt;,
    thickness: <span>f32</span>,
    color: Color,
}

<span>impl</span> <span>Element</span> <span>for</span> <span>Border</span> {
    <span>fn</span> <span>layout</span>(&amp;<span>mut</span> <span>self</span>, <span>mut</span> constraint: SizeConstraint) <span>-&gt;</span> Size {
        constraint.max.x -= <span>self</span>.thickness;
        constraint.max.y -= <span>self</span>.thickness;
        <span>let</span> (width, height) = <span>self</span>.child.<span>layout</span>(constraint);
        Size {
            width: width + <span>self</span>.thickness,
            height: height + <span>self</span>.thickness,
        }
    }

    <span>fn</span> <span>paint</span>(&amp;<span>mut</span> <span>self</span>, origin: (<span>f32</span>, <span>f32</span>), size: Size, scene: &amp;<span>mut</span> Scene) {
        
    }
}
</code></pre></div>
<p>Once the size of elements has been established, the element tree can be finally painted. Painting consists of positioning an element&#39;s children according to the layout as well as drawing visual affordances belonging to the element itself. At the end of this process, all the elements will have pushed their own graphical components to a platform-neutral <code>Scene</code> struct, a collection of the primitives described in the rendering section above:</p>
<div><pre><code><span>pub</span> <span>struct</span> <span>Scene</span> {
    layers: <span>Vec</span>&lt;Layer&gt;
}

<span>struct</span> <span>Layer</span> {
    shadows: <span>Vec</span>&lt;Shadow&gt;,
    rectangles: <span>Vec</span>&lt;Rectangle&gt;,
    glyphs: <span>Vec</span>&lt;Glyph&gt;,
    icons: <span>Vec</span>&lt;Icon&gt;,
    image: <span>Vec</span>&lt;Image&gt;
}
</code></pre></div>
<p>The renderer follows a specific order when drawing primitives. It starts by drawing all shadows, followed by all rectangles, then all glyphs, and so on. This prevents some primitives from being painted in front of others: for example, a rectangle could never be rendered on top of a glyph.</p>
<p>There are cases, however, where that behavior is not desirable. For instance, an application may want to paint a tooltip element in front of a button, and so the background of the tooltip needs to be rendered on top of the button&#39;s text. To address this, elements can push a <code>Layer</code> to the scene, which ensures their graphical elements will be rendered on top of their parent.</p>
<p>GPUI also supports creating new stacking contexts, which allows for arbitrary z-index positioning in a way that closely resembles the <a href="https://en.wikipedia.org/wiki/Painter&#39;s_algorithm">painter&#39;s algorithm</a>.</p>
<p>Continuing the example of the border above, the <code>paint</code> method should first push a <code>Rectangle</code> containing the border it wants to draw and then position the child to not overlap with the newly-drawn border:</p>
<div><pre><code><span>impl</span> <span>Element</span> <span>for</span> <span>Border</span> {
    <span>fn</span> <span>layout</span>(&amp;<span>mut</span> <span>self</span>, <span>mut</span> constraint: SizeConstraint) <span>-&gt;</span> Size {
        
    }

    <span>fn</span> <span>paint</span>(&amp;<span>mut</span> <span>self</span>, origin: (<span>f32</span>, <span>f32</span>), <span>mut</span> size: Size, scene: &amp;<span>mut</span> Scene) {
        scene.<span>push_rectangle</span>(Rectangle {
            origin,
            size,
            border_color: <span>self</span>.color,
            border_thickness: <span>self</span>.thickness,
        });

        <span>let</span> (<span>mut</span> child_x, <span>mut</span> child_y) = origin;
        child_x += <span>self</span>.thickness;
        child_y += <span>self</span>.thickness;

        <span>let</span> <span>mut </span><span>child_size</span> = size;
        child_size.width -= <span>self</span>.thickness;
        child_size.height -= <span>self</span>.thickness;

        <span>self</span>.child.<span>paint</span>((child_x, child_y), child_size, scene);
    }
}
</code></pre></div>
<p>GPUI offers several elements out of the box to produce a rich visual experience. Some elements only change the position and size of their children (e.g., <code>Flex</code> which implements the flex-box model), whereas other elements add new graphical affordances (e.g., <code>Label</code> which renders a piece of text with the given style).</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post was a whirlwind tour of GPUI&#39;s rendering engine and how it gets packaged into an API that allows encapsulation of layout and painting. Another big role GPUI serves is reacting to user events, maintaining application state, and translating that state into elements.</p>
<p>We are looking forward to talking about that in a future post, so stay tuned to hear more about it soon!</p></div></div>
  </body>
</html>
