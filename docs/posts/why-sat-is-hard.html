<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/02/21/why-SAT-is-hard.html">Original</a>
    <h1>Why SAT Is Hard</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>

    
<p>An introductory post about complexity theory today!
It is relatively well-known that there exist so-called NP-complete problems — particularly hard problems, such that, if you solve one of them efficiently, you can solve <em>all</em> of them efficiently.
I think I’ve learned relatively early that, e.g., SAT is such a hard problem.
I’ve similarly learned a bunch of specific examples of equally hard problems, where solving one solves the other.
However, why SAT is harder than <em>any</em> NP problem remained a mystery for a rather long time to me.
It is a shame — this fact is rather intuitive and easy to understand.
This post is my attempt at an explanation.
It assumes <em>some</em> familiarity with the space, but it’s not going to be too technical or thorough.</p>
<section id="Summary">

    <h2>
    <a href="#Summary">Summary </a>
    </h2>
<p>Let’s say you are solving some search problem, like “find a path that visits every vertex in a graph once”.
It is often possible to write a naive algorithm for it, where we exhaustively check every possible prospective solution:</p>

<figure>


<pre><code>for every possible path:</code>
<code>    if path visits every vertex once:</code>
<code>        return path</code>
<code>else:</code>
<code>    return &#34;no solution&#34;</code></pre>

</figure>
<p>Although <em>checking</em> each specific candidate is pretty fast, the whole algorithm is exponential, because there are too many (exponent of) candidates.
Turns out, it is possible to write “check if solution fits” part as a SAT formula!
And, if you have a magic algorithm which solves SAT, you can use that to find a candidate solution which would work instead of enumerating all solutions!</p>
<p>In other words, solving SAT removes “search” from “search and check”.</p>
<p>That’s more or less everything I wanted to say today, but let’s make this a tiny bit more formal.</p>
</section>
<section id="Background">

    <h2>
    <a href="#Background">Background </a>
    </h2>
<p>We will be discussing algorithms and their runtime.
Big-O notation is a standard instrument for describing performance of algorithms, as it erases small differences which depend on a particular implementation of the algorithm.
Both 2N + 1000 and 100N are O(N), linear.</p>
<p>In this post we will be even <em>less</em> precise.
We will talk about <dfn>polynomial time</dfn> — an algorithm is polynomial if it is O(N<sup>k</sup>) for some k.
For example, N<sup>100</sup> is polynomial, while 2<sup>N</sup> is not.</p>
<p>We will also be thinking about Turing machines (<dfn>TM</dfn>s) as our implementation device.
Programming algorithms directly on Turing machines is cumbersome, but TMs have two advantages for our use case:</p>
<ul>
<li>
it’s natural to define runtime of TM
</li>
<li>
it’s easy to simulate a TM as a part of some larger algorithm (an interpreter for a TM is a small program)
</li>
</ul>
<p>Finally, we will only think about problems with binary answers (<dfn>decision problem</dfn>).
“Is there a solution to this formula?” rather than “what is the solution to this formula?”.
“Is there a path in the graph of length at least N?” rather than “what is the longest path in this graph?”.</p>
</section>
<section id="Definitions">

    <h2>
    <a href="#Definitions">Definitions </a>
    </h2>
<p>Intuitively, a problem is NP if it’s easy to check that a solution is valid (even if <em>finding</em> the solution might be hard).
This intuition doesn’t exactly work for yes/no problems we are considering.
To fix this, we will also provide a “hint” for the checker.
For example, if the problem is “is there a path of length N in a given graph?” the hint will be a path.</p>
<p>A decision problem is <dfn>NP</dfn>, if there’s an algorithm that can verify a “yes” answer in polynomial time, given a suitable hint.</p>
<p>That is, for every input where the answer is “yes” (and only for those inputs) there should be a hint that makes our verifying algorithm answer “yes”.</p>
<p>Boolean satisfiability, or <dfn>SAT</dfn> is a decision problem where an input is a boolean formula like</p>

<figure>


<pre><code>(A and B and !C) or</code>
<code>(C and D) or</code>
<code>!B</code></pre>

</figure>
<p>and the answer is “yes” if the formula evaluates to true for some variable assignment.</p>
<p>It’s easy to see that SAT is NP: the hint is variable assignment which satisfies the formula, and verifier evaluates the formula.</p>
</section>
<section id="Sketch-of-a-Proof">

    <h2>
    <a href="#Sketch-of-a-Proof">Sketch of a Proof </a>
    </h2>
<p>Turns out, there is the “hardest” problem in NP — solving just that single problem in polynomial time automatically solves every other NP problem in polynomial time (we call such problems <dfn>NP-complete</dfn>).
Moreover, there’s actually a bunch of such problems, and SAT is one of them.
Let’s see why!</p>
<p>First, let’s define a (somewhat artificial) problem which is trivially NP-complete.</p>
<p>Let’s start with this one: “Given a Turing machine and an input for it of length N, will the machine output “yes” after N<sup>k</sup> steps?”
(here k is a fixed parameter; pedantically, I describe a family of problems, one for each k)</p>
<p>This is <em>very</em> similar to a halting problem, but also much easier.
We explicitly bound the runtime of the Turing machine by a polynomial, so we don’t need to worry about “looping forever” case — that would be a “no” for us.
The naive algorithm here works: we just run the given machine on a given input for a given amount of steps and look at the answer.</p>
<p>Now, if we formulate the problem as “<em>Is</em> there an input <strong><strong>I</strong></strong> for a given Turing machine <strong><strong>M</strong></strong> such that <strong><strong>M(I)</strong></strong> answers “yes” after N<sup>k</sup> steps?” we get our NP-complete problem.
It’s trivially NP — the hint is the input that makes the machine answer “yes”, and the verifier just runs our TM with this input for N<sup>k</sup> steps.
It can also be used to efficiently solve any other NP problem (e.g. SAT).
Indeed, we can use the verifying TM as <strong><strong>M</strong></strong>, and that way find if there’s any hint that makes it answer “yes”.</p>
<p>This is a bit circular and hard to wrap ones head around, but, at the same time, trivial.
We essentially just carefully stare at the definition of an NP problem, specifically produce an algorithm that can solve any NP problem by directly using the definition, and notice that the resulting algorithm is also NP.
Now there’s no surprise that there exists the hardest NP problem — we essentially <em>defined</em> NP such that this is the case.</p>
<p>What is still a bit mysterious is why non-weird problems like SAT also turn out to be NP-complete?
This is because SAT is powerful enough to encode a Turing machine!</p>
<p><em>First</em>, note that we can encode a state of a Turing machine as a set of boolean variables.
We’ll need a boolean variable T<sub>i</sub> for each position on a tape.
The tape is in general infinite, but all our Turing machines run for polynomial (finite) time, so they use only a finite amount of cells, and it’s enough to create variables only for those cells.
Position of the head can also be described by a set of booleans variables.
For example, we can have a P<sub>i</sub> “is the head at a cell <code>i</code>” variable for each cell.
Similarly, we can encode finite number of states our machine can be in as set of S<sub>i</sub> variables (is the machine in state <code>i</code>?).</p>
<p><em>Second</em>, we can write a set of boolean equations which describe a single transition of our Turing machine.
For example value of cell i at the second step T2<sub>i</sub> will depend on the value on the previous step T1<sub>i</sub>, whether the head was at <code>i</code> (P1<sub>i</sub>) and the rules of our specific states.
For example, if machine flips bits in state <code>0</code> and keeps then in state <code>1</code>, the formula we get for each sell is</p>

<figure>


<pre><code>T2_i &lt;=&gt;</code>
<code>  (!P1_i and T1_i) # head is not on our cell, it can&#39;t change</code>
<code>or (P1_i and (</code>
<code>    S1_0 and !T1_i # flip case</code>
<code>or  S1_1 and T1_i  # keep case</code>
<code>))</code></pre>

</figure>
<p>We can write similar formulas for changes of P and S families of variables.</p>
<p><em>Third</em>, after we wrote transition formula for a single step, we can stack several such formulas on top of each other to get a formula for N steps.</p>
<p>Now let’s come back to our universal problem: “is there an input which makes a given Turing machine answer “yes” in N<sup>k</sup> steps?”.
At this point, it’s clear that we can replace a “Turing machine with N<sup>k</sup> steps” with our transition formula duplicated N<sup>k</sup> times.
So, the question of existence of an input for a Turing machine reduces to the question of existence of a solution to a (big, but still polynomial) SAT formula.</p>
<p>And this concludes the sketch!</p>
</section>
<section id="Summary-Again">

    <h2>
    <a href="#Summary-Again">Summary, Again </a>
    </h2>
<p>SAT is hard, because it allows encoding Turing machine transitions.
We can’t encode loops in SAT, but we can encode “N steps of a Turing machine” by repeating the same formula N times with small variations.
So, if we know that a particular Turing machine runs in polynomial time, we <em>can</em> encode it by a polynomially-sized formula.
(see also <a href="https://mochiro.moe/posts/09-meson-raytracer/">pure meson ray-tracer</a> for a significantly more practical application of a similar idea).</p>
<p>And that means every problem that can be solved by a brute-force search over all solutions can be reduced to a SAT instance, by encoding the body of the search loop as a SAT formula!</p>
</section>
</article>
  </div></div>
  </body>
</html>
