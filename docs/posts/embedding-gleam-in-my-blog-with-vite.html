<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/gleam-vite">Original</a>
    <h1>Embedding Gleam in my blog with Vite</h1>
    
    <div id="readability-page-1" class="page"><section id="Embedding-Gleam-in-my-blog-with-Vite">

<p>My interest in <a href="https://lustre.build/">Gleam</a> came primarily from the idea of having Erlang with Static types. Gleam is able to transpile to Javascript, so I wanted to try embedding it in my blog. I might want to add interactive explanations to my blog in the future, and it would be neat to be able to write them in Gleam.</p>
<section id="Step-1-Create-Lustre-Project">
<h2>Step 1: Create Lustre Project</h2>
<p><a href="https://lustre.build/">Lustre</a> is a frontend web framework for Gleam. It has an Elm-inspired runtime that makes it easy to create dynamic components with Gleam.<label for="fn1"></label><span><span>Lustre can also be used on the <a href="https://lustre.build/docs/quickstart/#on-the-server">server side</a> as a HTML templating DSL.</span></span></p>
<p>I can create a new Gleam project with the CLI:</p>
<pre><code>gleam new shiny_counter
</code></pre>
<p>I can then enter the newly created project folder and add Lustre:</p>
<pre><code>cd shiny_counter
gleam add lustre
</code></pre>
<p>Now I can start building my Lustre application.</p>
<p>A <a href="https://lustre.build/api/lustre/#simple">simple</a> Lustre application consists of an initialization function, an update function, and a view function.</p>
<section id="Init">
<h3>Init</h3>
<p>The initialization function is responsible for setting the initial state of the Lustre model.</p>
<p>In my <code>shiny_counter</code> it looks like this:</p>
<pre><code>type Model =
  Int

fn init(_) -&gt; Model {
  0
}
</code></pre>
<p>Here, I define the <code>Model</code> to be just an integer, and initialize that integer to 0.</p>
</section>
<section id="Update">
<h3>Update</h3>
<p>The update function takes a model and a message as arguments and returns an updated model based on the contents of that message.</p>
<p>In the case of <code>shiny_counter</code> I only need an increment and decrement message:<label for="fn2"></label><span><span>Since the model of <code>shiny_counter</code> is an Integer, it’s signed, so if I send a <code>Decrement</code> message enough times, I will get a negative number. If I wanted a model where I couldn’t produce a negative number, I would want to add extra cases into my update function.</span></span></p>
<pre><code>pub type Msg {
  Increment
  Decrement
}

fn update(model: Model, msg: Msg) -&gt; Model {
  case msg {
    Increment -&gt; model + 1
    Decrement -&gt; model - 1
  }
}
</code></pre>
</section>
<section id="View">
<h3>View</h3>
<p>The view function takes a model and returns a Lustre Element constructor that handles both communicating with the update function as well as rendering the contents of the view to HTML.</p>
<p>In the case of <code>shiny_counter</code>, I convert the current state of the model to a string, then I render that count as well as provide two buttons which send defined messages to update the model:</p>
<pre><code>view(model: Model) -&gt; Element(Msg) {
  let count = int.to_string(model)

  html.div(
    [],
    [
      html.p([], [element.text(count)]),
      html.p(
        [],
        [
          html.button([event.on_click(Decrement)], [element.text(&#34;-&#34;)]),
          html.button([event.on_click(Increment)], [element.text(&#34;+&#34;)]),
        ],
      ),
    ],
  )
}
</code></pre>
<p>From here, I can add <a href="https://lustre.build/api/lustre/attribute/#style">styling</a> to make it live up to its <code>shiny_counter</code> name. Here, I’ve added styling to center the text and added the all important ✨ emoji:</p>
<pre><code>fn view(model: Model) -&gt; Element(Msg) {
  let count = int.to_string(model)

  html.div(
    [],
    [
      html.p(
        [attribute.style([#(&#34;text-align&#34;, &#34;center&#34;)])],
        [element.text(count &lt;&gt; &#34; ✨&#34;)],
      ),
      html.p(
        [attribute.style([#(&#34;text-align&#34;, &#34;center&#34;)])],
        [
          html.button([event.on_click(Decrement)], [element.text(&#34;-&#34;)]),
          html.button([event.on_click(Increment)], [element.text(&#34;+&#34;)]),
        ],
      ),
    ],
  )
}
</code></pre>
</section>
<section id="Start-the-application">
<h3>Start the application</h3>
<p>Now that I’ve defined the key parts of a simple Lustre application, I need to combine them into an application. I do that with <a href="https://lustre.build/api/lustre/attribute/#style"><code>lustre.simple</code></a> in this case, since <code>shiny_counter</code> doesn’t have complex interactive behavior. Once I have the application, I can simply start it:</p>
<pre><code>pub fn main() {
  let app = lustre.simple(init, update, view)
  let assert Ok(dispatch) = lustre.start(app, &#34;[gleam_example]&#34;, Nil)

  dispatch
}
</code></pre>
<p><a href="https://lustre.build/api/lustre/#start"><code>lustre.start</code></a> starts an application anchored on an HTML element specified by a CSS selector. In this case <code>[gleam_example]</code> finds an element that has the <code>gleam_example</code> attribute:</p>
<pre><code>&lt;div gleam_example&gt;
&lt;/div&gt;
</code></pre>
<p>Lustre will replace the selected element entirely with the running application after it loads.<label for="fn3"></label><span><span>When I initially tried Lustre, the example I borrowed from used <code>&#34;body&#34;</code> as the CSS selector, and completely wiped out the template of my blog, making it awfully hard to write this article.</span><span>I could tell that I misconfigured Lustre, because my blog was briefly visible until the Javascript loaded. This blog post is about embedding Gleam in my blog, not replacing my blog with Gleam.</span></span> In this case, I chose an attribute since it’s unlikely that I’ll have anything else on the page with that custom attribute.</p>
<p>Now that I have a Lustre application that does what I want,
I need to embed it in my blog.</p>
<p>While Gleam does transpile to Javascript it generates a number of different modules that are tedious to use in my static site generator. Enter Vite as a way to bundle the Javascript into a single file:</p>
</section>
</section>
<section id="Step-2-Install-and-configure-Vite">
<h2>Step 2: Install and configure Vite</h2>
<p><a href="https://vitejs.dev/">Vite</a> is a Javascript bundling tool, it’s explicitly designed to transform Node libraries or other Javascript modules and make them easy to use in a browser.<label for="fn4"></label><span><span>Here’s a <a href="https://paste.sr.ht/~erikareads/71002a37b32ecb211ecc6a375107cdf179f6e4ec">link</a> to the <code>shell.nix</code> that I used for this project.</span></span></p>
<p>I can install Vite with <a href="https://www.npmjs.com/"><code>npm</code></a>:</p>
<pre><code>npm install vite
</code></pre>
<p>Vite is designed for Javascript and not for Gleam, and so I need to rely on a plugin to show Vite where Gleam’s transpiled Javascript is. I can add that plugin with <code>npm</code>:<label for="fn5"></label><span><span>Thanks to a member of the Gleam community for creating the <a href="https://github.com/Enderchief/gleam-tools/tree/master/packages/vite-gleam"><code>vite-gleam</code></a> plugin.</span></span></p>
<pre><code>npm add vite-gleam
</code></pre>
<p>Now that I’ve added <code>vite-gleam</code> I can create a config file to use it:<label for="fn6"></label><span><span>The <a href="https://rollupjs.org/configuration-options/#input"><code>rollupOptions.input</code></a> setting allows me to change the entry file for Vite. By default this is <code>index.html</code>, but since I’m going to be using the bundled Javascript in this blog post, I don’t need a generated <code>index.html</code> file. This setting is described in the <a href="https://vitejs.dev/guide/backend-integration.html">Backend Integration</a> instructions for Vite.</span></span><label for="fn7"></label><span><span>The <a href="https://rollupjs.org/configuration-options/#output-entryfilenames"><code>output.entryFileNames</code></a> setting allows me to precisely specify the name of the generated Javascript file. By default, the generated Javascript has a randomly generated name suitable for cache busting. Since I’m copying the generated Javascript file from my Gleam project into my static site generator, I wanted a specific filename to reference in the embedded <code>&lt;script&gt;</code> tag.</span></span></p>
<pre><code>import gleam from &#34;vite-gleam&#34;;

export default {
  plugins: [gleam()],
  build: {
    rollupOptions: {
      input: &#39;main.js&#39;,
      output: {
        dir: &#39;./dist&#39;,
        entryFileNames: &#39;assets/gleam_vite_example.js&#39;,
      }
    }
  }
}
</code></pre>
<p>Then I create a file called <code>main.js</code> to act as the entry point for Vite:</p>
<pre><code>import { main } from &#39;./src/shiny_counter.gleam&#39;

document.addEventListener(&#34;DOMContentLoaded&#34;, () =&gt; {
  const dispatch = main({});
});
</code></pre>
<p>Now I can finally call <code>vite build</code><label for="fn8"></label><span><span>By default, Gleam transpiles to Erlang, but <code>vite-gleam</code> will use <code>--target javascript</code> to generate the Javascript code before bundling.</span><span>If you would like to transpile to Javascript without Vite, then set <code>target = &#34;javascript&#34;</code> in the project’s <code>Gleam.toml</code>.</span></span>, this will use the <code>vite-gleam</code> plugin to first transpile the Gleam code to Javascript, then it will use the <code>main.js</code> entry point to bundle all of the modules into a single file named <code>gleam_vite_example.js</code>.</p>
</section>
<section id="Step-3-Use-the-bundled-Javascript-in-my-Static-Site">
<h2>Step 3: Use the bundled Javascript in my Static Site</h2>
<p>Now I can copy the Javascript from my Gleam project into my static site generator. Once there, I can add markup to my site to use it.</p>
<p><a href="https://www.broadcom.com/notes/djot">Djot</a>, the markup language that I use for my blog allows me to do an HTML passthrough block:</p>
<pre><code>```=html
&lt;div style=&#34;border: 1px solid&#34;&gt;
  &lt;div gleam_example&gt;
    &lt;script type=&#34;module&#34; src=&#34;/assets/gleam_vite_example.js&#34;&gt;&lt;/script&gt;
  &lt;/div&gt;
&lt;/div&gt;
```
</code></pre>
<p>Here, I’ve specified a <code>&lt;div&gt;</code> tag with the <code>gleam_example</code> attribute, added a script tag to use the bundled Gleam Javascript, and then wrapped both in a stylized div.</p>
<p>As mentioned in Step 1, Lustre will replace the attributed div with the running Lustre application after it starts up, leaving me with an embedded interactive component.</p>
</section>
<section id="Step-4-Publish">
<h2>Step 4: Publish</h2>
<div>
  
</div>
<p>It works!<label for="fn9"></label><span><span>You can see the source code for <code>shiny_counter</code> <a href="https://git.sr.ht/~erikareads/shiny_counter">here</a>.</span></span></p>
<p>It’s really neat that I can take Gleam and embed it directly into my blog posts. Thank you to everyone in the Gleam discord for helping me figure all of this out.</p>
</section>
</section></div>
  </body>
</html>
