<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dbpro.app/blog/sqlite-json-virtual-columns-indexing">Original</a>
    <h1>SQLite JSON at Full Index Speed Using Generated Columns</h1>
    
    <div id="readability-page-1" class="page"><div><p>We absolutely love <a href="https://sqlite.org" target="_blank" rel="noopener noreferrer">SQLite</a> here at DB Pro. You&#39;d be hard-pressed to find anyone who actively dislikes it. Sure, it has limitations, and I do mean limitations, not weaknesses. SQLite can absolutely be used in production when it&#39;s deployed properly and tuned with care.</p>
<p>SQLite has also seen something of a resurgence over the past few years. From being forked into projects like libSQL and Turso, to powering popular backend frameworks such as PocketBase, it’s clearly having a moment again.</p>
<p>As I said though, we love it. It even powers the local database inside DB Pro itself. For our use case, there really isn’t a better alternative.</p>
<p>Because we’ve been using SQLite in anger over the past three months, we’ve learnt a huge amount about it, including plenty of things we didn’t know before.</p>
<p>So I’m planning to write a short series of blog posts covering some of the cooler, more interesting features and nuances of SQLite that we’ve discovered along the way. This is the first of those posts.</p>
<p>First of all. Did you know SQLite has JSON functions and operators? I didn&#39;t until recently! I came across <a href="https://news.ycombinator.com/item?id=37083561" target="_blank" rel="noopener noreferrer">this Hacker News comment when researching SQLite&#39;s JSON operators</a>.</p>

<p><img src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExdWhzOXd6cjViMHcwaXpiYnAzYjU0aWlpNjQ0bWtzYTl3MXQ2azVyOSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/huh7lUqEG4irK/giphy.gif" alt="SQLite GIF"/></p>
<p>I read that, then read it again, then again until I understood what bambax was saying. I was sort of in disbelief.</p>
<p>So I had to give it a try to see if it works. We&#39;ve got an embedded SQLite-in-the-browser component on our blog and so I wanted to throw together some working examples for you guys (but mostly for me).</p>
<p>Let&#39;s break down what bambax is saying:</p>
<ol>
<li>Store the JSON document raw</li>
<li>Create virtual generated columns using <code>json_extract</code></li>
<li>Add indexes to those generated columns</li>
<li>Query JSON at full B-tree index speed</li>
</ol>
<p>This means you never have to choose your indexing strategy up front. If you later realise you need to query on a new JSON field, you simply add another generated column, add an index, and you&#39;re done.</p>
<p>No data migration. No schema rewrite. No ETL. Just pure flexibility.</p>
<h2>1. Store Raw JSON</h2>
<p>First, create a simple table with a JSON column:</p>
<div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div><div><p>⚡</p><p><span>Loading SQL environment...</span></p></div></div><!--/$--></div>
<p>Your JSON documents are stored naturally, exactly as they arrive. No schema gymnastics required either!</p>
<h2>2. Add Virtual Generated Columns</h2>
<p>Here&#39;s where bambax is saying the magic happens. Let&#39;s add virtual generated columns. Generated columns compute values on demand. They don&#39;t actually store data:</p>
<div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div><div><p>⚡</p><p><span>Loading SQL environment...</span></p></div></div><!--/$--></div>
<p>I believe that no writes occur. There&#39;s no backfilling. It&#39;s instant. The virtual columns are computed on-the-fly from your JSON data whenever you query them.</p>
<h2>3. Add Indexes for Full Performance</h2>
<p>Now is the icing on the cake. We add indexes to make these virtual columns blazing fast:</p>
<div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div><div><p>⚡</p><p><span>Loading SQL environment...</span></p></div></div><!--/$--></div>
<p>Suddenly your JSON behaves like normal relational columns with full index support.</p>
<h2>4. Query at Full Speed</h2>
<p>Now your queries are blazing fast. So let&#39;s give it a go with some examples:</p>
<div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div><div><p>⚡</p><p><span>Loading SQL environment...</span></p></div></div><!--/$--></div>
<h2>5. Need a New Query Pattern Later?</h2>
<p>I believe this is one of the strongest points to this pattern. If at a later date your JSON shape changes (expected), you can just add another column and create another index.</p>
<p>For example, you realise you need to query by <code>user_id</code>:</p>

<p><img src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExcjFwamNpcWx6dnVlajN4cWQxejZ3NHpxa2oxczZ5MGwydzZiMTd0ciZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/dbd6jN0Atb9i8/giphy.gif" alt="gif"/></p>
<p>Boom. optimised without touching existing rows.</p>
<h2>Why This Pattern is So Powerful</h2>
<p>This pattern completely changed how I think about working with JSON in SQLite. You get the flexibility of schemaless data, combined with the performance and ergonomics of a relational database, without committing yourself too early or painting yourself into a corner.</p>
<p>So, thanks bambax!</p>
<p>There are plenty more of these little SQLite superpowers hiding in plain sight. This is just the first one I wanted to share.</p>
<p>Thanks for reading!</p>
<p>Jay</p>
<hr/>
</div></div>
  </body>
</html>
