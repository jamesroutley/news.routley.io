<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.prizrak.me/post/landlock/">Original</a>
    <h1>Landlock-Ing Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
      <h3 id="landlock-what-is-it">Landlock: What Is It?</h3>
<p>Landlock is a Linux API that lets applications explicitly declare which resources they are allowed to access. Its philosophy is similar to OpenBSD’s <code>unveil()</code> and (less so) <code>pledge()</code>: programs can make a contract with the kernel stating, “I only need these files or resources — deny me everything else if I’m compromised.”</p>
<p>It provides a simple, developer-friendly way to add defense-in-depth to applications. Compared to traditional Linux security mechanisms, Landlock is vastly easier to understand and integrate.</p>
<p>This post is meant to be an accessible introduction, and hopefully persuade you to give Landlock a try.</p>
<hr/>
<h3 id="how-does-it-work">How Does It Work?</h3>
<p>Landlock is a Linux Security Module (LSM) available since Linux 5.13. Unlike MAC frameworks such as SELinux or AppArmor, Landlock applies <em>transient</em> restrictions: policies are created at runtime, enforced on the current thread and its future descendants, and disappear when the process exits.</p>
<p>You don’t tag files with labels or extended attributes. Instead, applications create policies dynamically.</p>
<p>A Landlock policy consists of two pieces:</p>
<ol>
<li><strong>Handled accesses</strong> — the categories of operations you want to restrict (e.g., filesystem read/write).</li>
<li><strong>Access grants</strong> — an explicit allowlist of which objects are permitted for those operations.</li>
</ol>
<p>For example, you could create a policy that handles all filesystem reads/writes and network binds, and grants:</p>
<ul>
<li>read-only access to <code>/home/user</code></li>
<li>read/write access to <code>/tmp</code></li>
<li>permission to bind to port <code>2222</code></li>
</ul>
<p>The application then calls <code>landlock_restrict_self()</code> to enter the restricted domain. From that point on, that thread’s child threads and child processes are permanently constrained. Restrictions cannot be revoked.</p>
<p>Policies can be layered (up to 16 layers). A child layer may further <em>reduce</em> access, but cannot reintroduce permissions the parent layer removed. For example, a child thread may add a layer to this policy to restrict itself to only reading <code>/home/user</code>, but it cannot regain permission to bind to port <code>2222</code> once a layer omits this grant.</p>
<p>Landlock is unprivileged — any application can sandbox itself. It also uses ABI versioning, allowing programs to apply best-effort sandboxing even on older kernels lacking newer features.</p>
<p>It’s also a stackable LSM, meaning you can combine it with selinux or apparmor in a supplemental layer.</p>
<hr/>
<h3 id="why-should-you-use-it">Why Should You Use It?</h3>
<p>Landlock shines when an application has a predictable set of files or directories it needs. For example, a web server could restrict itself to accessing only <code>/var/www/html</code> and <code>/tmp</code>.</p>
<p>Unlike SELinux or AppArmor, Landlock policies don’t require administrator involvement or system-wide configuration. Developers can embed policies directly in application code, making sandboxing a natural part of the development process.</p>
<p>Because Landlock requires <em>no privileges</em> to use, adding it to most programs is straightforward.</p>
<p>Bindings exist for languages such as Rust, Go, and Haskell, and several projects provide user-friendly <code>unveil</code>-style wrappers.</p>
<p>A official c library doesn’t exist yet unfortunately, but there’s several out there you can try.</p>
<p>Here’s a quick rust example:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> landlock::{
</span></span><span><span>    <span>ABI</span>, Access, AccessFs, Ruleset, RulesetAttr, RulesetCreatedAttr, RulesetStatus, RulesetError,
</span></span><span><span>    path_beneath_rules,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>restrict_thread</span>() -&gt; Result<span>&lt;</span>(), RulesetError<span>&gt;</span> {
</span></span><span><span>    <span>let</span> abi <span>=</span> <span>ABI</span>::V1;
</span></span><span><span>    <span>let</span> status <span>=</span> Ruleset::default()
</span></span><span><span>        .handle_access(AccessFs::from_all(abi))<span>?</span>
</span></span><span><span>        .create()<span>?</span>
</span></span><span><span>        <span>// Read-only access to /usr, /etc and /dev.
</span></span></span><span><span><span></span>        .add_rules(path_beneath_rules(<span>&amp;</span>[<span>&#34;/usr&#34;</span>, <span>&#34;/etc&#34;</span>, <span>&#34;/dev&#34;</span>], AccessFs::from_read(abi)))<span>?</span>
</span></span><span><span>        <span>// Read-write access to /home and /tmp.
</span></span></span><span><span><span></span>        .add_rules(path_beneath_rules(<span>&amp;</span>[<span>&#34;/home&#34;</span>, <span>&#34;/tmp&#34;</span>], AccessFs::from_all(abi)))<span>?</span>
</span></span><span><span>        .restrict_self()<span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>match</span> status.ruleset {
</span></span><span><span>        RulesetStatus::FullyEnforced <span>=&gt;</span> <span>println!</span>(<span>&#34;Fully sandboxed.&#34;</span>),
</span></span><span><span>        RulesetStatus::PartiallyEnforced <span>=&gt;</span> <span>println!</span>(<span>&#34;Partially sandboxed.&#34;</span>),
</span></span><span><span>        RulesetStatus::NotEnforced <span>=&gt;</span> <span>println!</span>(<span>&#34;Not sandboxed! Please update your kernel.&#34;</span>),
</span></span><span><span>    }
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><hr/>
<h3 id="the-state-of-linux-sandboxing-why-this-matters">The State of Linux Sandboxing: Why This Matters</h3>
<p>As Linux adoption grows, so does the amount of malware targeting desktop users. While Linux has historically enjoyed relative safety, this is largely due to smaller market share and higher technical barriers compared to Windows — not because Linux is inherently safer.</p>
<p>Linux is not a security panacea. For example, on most major distributions:</p>
<ul>
<li>Users can download and execute untrusted binaries with no warnings.</li>
<li>Shell scripts can be piped from the internet and executed blindly.</li>
<li>Many users run passwordless sudo, giving them root access on demand.</li>
<li>Unprivileged applications can typically:
<ul>
<li>Read <code>~/.ssh</code>, <code>~/.bashrc</code>, browser cookies, and anything else in <code>$HOME</code></li>
<li>Modify environment variables and <code>$PATH</code></li>
<li>Create systemd user services</li>
<li>(on X11) log keystrokes and read input devices</li>
<li>Bind to arbitrary network ports</li>
</ul>
</li>
</ul>
<p>Several tools try to improve the state of security on linux, but each has significant drawbacks:</p>
<h4 id="containerization-docker-podman">Containerization (docker, podman)</h4>
<ul>
<li>Designed for service isolation, not desktop apps.</li>
<li>Managing home directory access is clunky.</li>
<li>Many users break isolation by using <code>--privileged</code> or <code>--network host</code>.</li>
</ul>
<h4 id="flatpak--snap">Flatpak / Snap</h4>
<ul>
<li>Great for graphical applications (Flatpak especially).</li>
<li>Often require overly broad permissions.</li>
<li>Less suitable for CLI tools.</li>
</ul>
<h4 id="firejail">Firejail</h4>
<ul>
<li>Requires per-application profiles.</li>
<li>Must be explicitly invoked each time, or you need a wrapper script.</li>
</ul>
<p>From the developer side:</p>
<h4 id="seccomp">seccomp</h4>
<ul>
<li>Powerful syscall filtering.</li>
<li>Tedious and error-prone to configure.</li>
<li>Blacklists are fragile; new syscalls can break things.</li>
<li>Argument filtering is difficult and full of TOCTOU hazards.</li>
</ul>
<h4 id="selinux">SELinux</h4>
<ul>
<li>Extremely powerful, but difficult to understand.</li>
<li>Requires system-wide policies and admin involvement.</li>
<li>Many users disable it due to complexity.</li>
<li>Not enabled on most distributions by default. (used a lot in android)</li>
</ul>
<h4 id="apparmor">AppArmor</h4>
<ul>
<li>Easier than SELinux, but still requires admin-defined profiles.</li>
<li>Applies system-wide and lacks per-process namespacing.</li>
<li>Gets disabled by many distributions, but is more commonly used in the desktop.</li>
</ul>
<h4 id="landlock">Landlock</h4>
<ul>
<li>Unprivileged</li>
<li>Application-centric</li>
<li>Easy to integrate</li>
<li>Deny-by-default</li>
<li>Widely supported since 5.13</li>
<li>Backward and forward compatibility mechanisms.</li>
</ul>
<p>Landlock isn’t perfect, but it fills a major gap: a simple, self-contained unprivileged sandboxing tool.</p>
<h3 id="what-landlock-could-bring-to-the-table">What landlock could bring to the table:</h3>
<p>Long-running system daemons that run with elevated privileges could benefit from landlock restrictions.</p>
<p>Desktop applications dealing with binary formats, like pdf readers, image viewers web browsers, and word processors can be
restricted to accessing the files they originally opened.</p>
<p>FTP and HTTP servers can be bound to the files they need. Even if nginx is running as root, if an attacker gets a
full reverse shell, they won’t be able to see access files outside the policy.</p>
<p>If the supervisor proposal gets added, we could bring an android-like permissions system to the linux desktop. Flatpak does a
decent job at this, but imagine if every process in your desktop would need to explicitly ask (at least once) before accessing
sensitive files or resources.</p>
<p>Pair that with an accessible GUI and a system for handling updates and saving permission grants, and we have potential for
a safer, more secure linux user experience on the desktop.</p>
<hr/>
<h3 id="ongoing-work-in-landlock">Ongoing Work in Landlock</h3>
<p>Several promising features are under active development:</p>
<ul>
<li>
<p><a href="https://marc.info/?l=linux-fsdevel&amp;m=174105064226536&amp;w=2"><strong>Supervise Mode</strong></a></p>
</li>
<li>
<p><a href="https://github.com/landlock-lsm/linux/issues/6"><strong>Socket Restrictions</strong></a>
Fine-grained control over which types of sockets or ports processes may use.</p>
</li>
<li>
<p><a href="https://lore.kernel.org/all/20250221184417.27954-2-gnoack3000@gmail.com/"><strong>LANDLOCK_RESTRICT_SELF_TSYNC</strong></a>
Ensures restrictions propagate to all threads in a process.</p>
</li>
<li>
<p><a href="https://lore.kernel.org/linux-security-module/cover.1763931318.git.m@maowtm.org/T/#t"><strong>LANDLOCK_ADD_RULE_QUIET</strong></a>
Allows suppressing audit messages for certain objects.</p>
</li>
<li>
<p><a href="https://lore.kernel.org/linux-security-module/20251126122039.3832162-1-utilityemal77@gmail.com/T/#t"><strong>LANDLOCK_ADD_RULE_NO_INHERIT</strong> <em>(disclosure: this is my patch series)</em></a>
Prevents rules from unintentionally inheriting permissions from parent directories, giving finer-grained filesystem control.</p>
</li>
</ul>
<hr/>
<h3 id="tldr">TL;DR</h3>
<p>Landlock is a simple, unprivileged, deny-by-default sandboxing mechanism for Linux.</p>
<p>Give it a try in your application.</p>

    </div></div>
  </body>
</html>
