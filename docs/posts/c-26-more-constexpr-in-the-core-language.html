<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sandordargo.com/blog/2025/04/23/cpp26-constexpr-language-changes">Original</a>
    <h1>C&#43;&#43;26: more constexpr in the core language</h1>
    
    <div id="readability-page-1" class="page"><div><p>Since <code>constexpr</code> was added to the language in C++11, its scope has been gradually expanded. In the beginning, we couldn’t even use <code>if</code>, <code>else</code> or loops, which were changed in C++14. C++17 added support for <code>constexpr</code> lambdas. C++20 added the ability to use allocation and use <code>std::vector</code> and <code>std::string</code> in constant expressions. In this article, let’s see how constexpr evolves with C++26. To be more punctual, let’s see what language features become more <code>constexpr</code>-friendly. We’ll discuss library changes in a separate article, as well as <code>constexpr</code> exceptions, which need both language and library changes.</p><h2 id="p2738r1-constexpr-cast-from-void"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf">P2738R1</a>: <code>constexpr</code> cast from <code>void*</code></h2><p>Thanks to the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf">P2738R1</a>, starting from C++26, one can cast from <code>void*</code> to a pointer of type <code>T</code> in constant expressions, if the type of the object at that adress is exactly the type of <code>T</code>.</p><p>Note that conversions to interconvertible - including pointers to base classes - or not related types are not permitted.</p><p>The motivation behind this change is to make several standard library functions or types work at compile time. To name a few examples: <em>std::format</em>, <em>std::function</em>, <em>std::function_ref</em>, <em>std::any</em>. The reason why this change will allow many more for more <code>constexpr</code> in the standard library is that storing <code>void*</code> is a commonly used compilation firewall technique to reduce template instantiations and the number of symbols in compiled binaries.</p><h2 id="p2747r2-constexpr-placement-new"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2747r2.html">P2747R2</a>: <code>constexpr</code> placement new</h2><p>As <code>std::construct_at</code> is a limited tool that only allows to perform value initialization but not others such as default or list initialization, there has been a need to make placement new usable in constant expressions.</p><p>At the same time, placement new is a very, maybe even too flexible tool and to use it in a safe way requires casting to <code>void*</code> and then back to <code>T*</code>. This faced some issues, but the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2738r1.pdf">P2738R1</a> and the ability of casting from <code>void*</code> in constant expressions made the impossible possible.</p><p>If you are looking for more details, check <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2747r2.html">P2747R2</a>.</p><h2 id="p2686r5-constexpr-structured-bindings-and-references-to-constexpr-variables"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2686r5.pdf">P2686R5</a>: constexpr structured bindings and references to constexpr variables</h2><p>This is a rather long (20 pages) proposal and I found it not particularly easy to read. That’s not the fault of the authors, the problem is hard to address. The paper which is based on another, went through 5 revisions, discusses various solutions, and lists the wording changes on more than 10 pages.</p><p>Long story short, you’ll be able to declare structured bindings <code>constexpr</code>.</p><p>As structured bindings behave like references, the same restrictions apply as to <code>constexpr</code> references. Those restrictions become more relaxed. Before, a <code>constexpr</code> reference had to bind to a variable with static storage duration, so that the address doesn’t change from one evaluation to another. With C++26, in addition, variables with automatic storage duration are also accepted if and only if the address is constant relative to the stack frame in which the reference or the structured binding lives.</p><p>In practice, this means that you cannot have a <code>constexpr</code> reference in a lambda to bind to an enclosing function. The reason is that in order to access that variable, the expression is something like <code>this-&gt;__x</code> where <code>__x</code> represents the captured address of <code>x</code>. As we don’t know at compile time what object <code>this</code> points to, it’s not a constant expression.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed how <code>constexpr</code> evolves in the C++26 core language. We are getting <code>constexpr</code> cast from <code>void*</code>, placement <code>new</code>, structured bindings and even exceptions (not discussed today). In the next article, we’ll see how the standard library’s constexpr support evolves.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,</li><li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></li><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</li></ul><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a></p></div></div>
  </body>
</html>
