<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/kevinlawler/kerf1">Original</a>
    <h1>Kerf Time Series Lang and Columnar DB Open Sourced</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/kevinlawler/kerf1/raw/master/repl-header.png"><img src="https://github.com/kevinlawler/kerf1/raw/master/repl-header.png" alt="REPL"/></a></p>
<h2 dir="auto"><a id="user-content-source" aria-hidden="true" href="#source"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source</h2>
<p dir="auto">kerf1: <a href="https://github.com/kevinlawler/kerf1/tree/master/src">https://github.com/kevinlawler/kerf1/tree/master/src</a></p>
<p dir="auto">kerf2 (kerf): <a href="https://github.com/kevinlawler/kerf/">https://github.com/kevinlawler/kerf/</a></p>
<h2 dir="auto"><a id="user-content-what-is-kerf" aria-hidden="true" href="#what-is-kerf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What is Kerf?</h2>
<p dir="auto">Kerf is a columnar tick database and time-series language for Linux/OSX/BSD/iOS/Android. It is written in C and natively speaks JSON and SQL. Kerf can be used for trading platforms, feedhandlers, low-latency networking, high-volume analysis of realtime and historical data, logfile processing, and more.</p>
<p dir="auto"><strong>Manual</strong></p>
<p dir="auto">The manual, currently in progress, is here:</p>
<p dir="auto"><a href="https://github.com/kevinlawler/kerf/tree/master/manual">https://github.com/kevinlawler/kerf/tree/master/manual</a></p>
<p dir="auto">The manual covers much more than the whirlwind guide below.</p>
<p dir="auto"><strong>Guides</strong></p>
<p dir="auto">Kerf Screencast - Stock Basics <a href="https://youtu.be/CcJP8TX7CVc" rel="nofollow">https://youtu.be/CcJP8TX7CVc</a></p>
<p dir="auto">Time Bars - <a href="https://getkerf.wordpress.com/2016/06/21/time-bars/" rel="nofollow">https://getkerf.wordpress.com/2016/06/21/time-bars/</a></p>
<h2 dir="auto"><a id="user-content-whirlwind-language-guide" aria-hidden="true" href="#whirlwind-language-guide"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Whirlwind Language Guide:</h2>
<p dir="auto"><strong>TYPES</strong></p>
<div data-snippet-clipboard-copy-content="  CHAR 
         &#34;abc&#34; or &#39;abc&#39;
  
  INT  
          1
  
  FLOAT
          2.0 or 1e6 or 1.2E+01
  
  STAMP
          2015.03.31 or 01:23:45.877 or 2015.03.31T01:23:45.123
  
  NULL
          null
  
  ARRAY 
          [5, 6, 7, 8]
  
  MAP  
          {b:2, c:3, d:4}
  
  TABLE   
         {{b:2, c:3, d:4}}"><pre><code>  CHAR 
         &#34;abc&#34; or &#39;abc&#39;
  
  INT  
          1
  
  FLOAT
          2.0 or 1e6 or 1.2E+01
  
  STAMP
          2015.03.31 or 01:23:45.877 or 2015.03.31T01:23:45.123
  
  NULL
          null
  
  ARRAY 
          [5, 6, 7, 8]
  
  MAP  
          {b:2, c:3, d:4}
  
  TABLE   
         {{b:2, c:3, d:4}}
</code></pre></div>
<p dir="auto">There are a few other types which we&#39;ll skip discussing for now.</p>
<p dir="auto"><strong>OPERATIONS</strong></p>
<p dir="auto">Let&#39;s look at some good ways to make arrays. &#39;Range&#39; comes directly from Python
and accepts 1, 2, or 3 arguments:</p>
<div data-snippet-clipboard-copy-content="range(4)
  [0, 1, 2, 3]

range(2, 6)
  [2, 3, 4, 5]

range(0, 20, 3)
  [0, 3, 6, 9, 12, 15, 18]"><pre><code>range(4)
  [0, 1, 2, 3]

range(2, 6)
  [2, 3, 4, 5]

range(0, 20, 3)
  [0, 3, 6, 9, 12, 15, 18]
</code></pre></div>
<p dir="auto">&#39;Rand&#39; accepts 0, 1, or 2 arguments:</p>
<div data-snippet-clipboard-copy-content="rand()       //FLOAT from [0,1)
  0.164771

rand(5)      //INT
  2

rand(9.0)    //FLOAT
  8.86153

rand(4, 3.0) //4x FLOAT
  [2.44598, 2.87178, 1.14531, 0.676305]

rand(4, [11, 22]) //from a list
  [22, 11, 11, 22]"><pre><code>rand()       //FLOAT from [0,1)
  0.164771

rand(5)      //INT
  2

rand(9.0)    //FLOAT
  8.86153

rand(4, 3.0) //4x FLOAT
  [2.44598, 2.87178, 1.14531, 0.676305]

rand(4, [11, 22]) //from a list
  [22, 11, 11, 22]
</code></pre></div>
<p dir="auto">Rand may return different values for you.</p>
<p dir="auto">Now let&#39;s look ahead:</p>
<p dir="auto">The exponentiation operator ** comes from Ruby and Python.</p>
<div data-snippet-clipboard-copy-content="range(10**6) //a big list

timing true
sum(range(10**6))  //sum first million numbers
  499999500000"><pre><code>range(10**6) //a big list

timing true
sum(range(10**6))  //sum first million numbers
  499999500000
</code></pre></div>
<p dir="auto">Now back to basic arithmetic:</p>
<div data-snippet-clipboard-copy-content="+ - * / ** plus minus times divide pow
        //wait, which is the operation and which is the name?
2 + 2
plus(2, 2)
        //I guess they both work
2 plus 2
        //and that works too"><pre><code>+ - * / ** plus minus times divide pow
        //wait, which is the operation and which is the name?
2 + 2
plus(2, 2)
        //I guess they both work
2 plus 2
        //and that works too
</code></pre></div>
<p dir="auto">This is nice because parenthesized prefix notation disambiguates dyadic/binary infix operations.</p>

<p dir="auto">Then the ambiguous-appearing</p>

<p dir="auto">becomes</p>
<div data-snippet-clipboard-copy-content="times(1/2, x**2) 
        //well that&#39;s not so bad
        //
        //actually, I like that better... I wonder why?"><pre><code>times(1/2, x**2) 
        //well that&#39;s not so bad
        //
        //actually, I like that better... I wonder why?
</code></pre></div>
<p dir="auto">Or, emphasizing the center operation:</p>
<div data-snippet-clipboard-copy-content="(divide(1, 2) * pow(x,2))"><pre><code>(divide(1, 2) * pow(x,2))
</code></pre></div>
<p dir="auto">Neither of these are ambiguous. Of course, you can always fall back to parentheses:</p>

<p dir="auto">Format code as if order-of-operations does not exist.</p>
<p dir="auto">I find the &#34;functional&#34; notation for arithmetic also helps when the arguments are arrays or maps instead of scalars. This can cue the reader that something heavier-duty is happening.</p>
<p dir="auto">Other common operators are present. The exclamation point &#39;!&#39; is not,
the percent sign &#39;%&#39; is modulo, and so on.</p>
<div data-snippet-clipboard-copy-content="!0
 1
not 0
 1

-33 % 4
  3  //mathematical definition
-33 mod 4
  3

.Math.TAU / 2
  3.14159"><pre><code>!0
 1
not 0
 1

-33 % 4
  3  //mathematical definition
-33 mod 4
  3

.Math.TAU / 2
  3.14159
</code></pre></div>
<p dir="auto"><strong>JSON</strong></p>
<p dir="auto">Kerf speaks JSON:</p>
<div data-snippet-clipboard-copy-content="eval(&#39;1+1&#39;)
  2

a: [[1, 2, 3], {a:&#34;alpha&#34;, b:&#34;bravo&#34;, c:&#34;3pO&#34;}, null]
match(a, eval(json_from_kerf(a)))
  1"><pre><code>eval(&#39;1+1&#39;)
  2

a: [[1, 2, 3], {a:&#34;alpha&#34;, b:&#34;bravo&#34;, c:&#34;3pO&#34;}, null]
match(a, eval(json_from_kerf(a)))
  1
</code></pre></div>
<p dir="auto"><strong>ASSIGNMENT</strong></p>
<p dir="auto">Assignment is &#39;:&#39;, the colon character. It&#39;s colon and
not &#39;=&#39; because:</p>
<ol dir="auto">
<li>JSON uses : for assignment, as in {a:1}</li>
<li>SQL  uses = for comparison, as in WHERE user_id=456</li>
<li>Kerf is a superset of both JSON and SQL.</li>
</ol>
<p dir="auto">Which looks like</p>
<div data-snippet-clipboard-copy-content="a: [11, 22, 33, 44]
a[2]
    33"><pre><code>a: [11, 22, 33, 44]
a[2]
    33
</code></pre></div>
<p dir="auto">We could force assignment to be &#39;=&#39; but I don&#39;t think it improves
the language.</p>

<p dir="auto">Indexing into maps:</p>
<div data-snippet-clipboard-copy-content="a: {b:2, c:3}
a[&#39;c&#39;]
  3
{b:2, c:3}[&#39;c&#39;]
  3"><pre><code>a: {b:2, c:3}
a[&#39;c&#39;]
  3
{b:2, c:3}[&#39;c&#39;]
  3
</code></pre></div>
<p dir="auto"><strong>VECTOR OPERATIONS</strong></p>
<p dir="auto">Arrays vectorize automatically. This means CHAR, INT, FLOAT, and STAMP types are fast and efficient in lists of the same kind. Arrays also mostly keep track of when they&#39;re sorted. This means Kerf will invisibly use binary search or interpolation search if it appears advantageous.</p>
<p dir="auto">The following notion of conformability comes from K:</p>
<p dir="auto">Adding a single value to a longer list applies it like so:
<code>100  + [0, 10, 20]</code>
gives
<code> [100, 110, 120]</code></p>
<p dir="auto">Kerf extends this notion to work with lists of length 1 as well:</p>

<p dir="auto">gives</p>

<p dir="auto">This also works piecewise:</p>
<div data-snippet-clipboard-copy-content="  [100, 110, 120] + [40, 50, 60]"><pre><code>  [100, 110, 120] + [40, 50, 60]
</code></pre></div>
<p dir="auto">gives</p>

<p dir="auto">Conformability extends all the way down. This</p>
<div data-snippet-clipboard-copy-content="[[1], [1,1,1]] + [[2], [2, 2, 2]]"><pre><code>[[1], [1,1,1]] + [[2], [2, 2, 2]]
</code></pre></div>
<p dir="auto">gives</p>

<p dir="auto">Flatten? Sure</p>
<div data-snippet-clipboard-copy-content="flatten [[3], [3, 3, 3]]
  [3, 3, 3, 3]"><pre><code>flatten [[3], [3, 3, 3]]
  [3, 3, 3, 3]
</code></pre></div>
<p dir="auto">Works with maps and tables, too.</p>
<div data-snippet-clipboard-copy-content="{a:2, b:20} + {a:3, b:30, c:100}
  {a:5, b:50, c:100}"><pre><code>{a:2, b:20} + {a:3, b:30, c:100}
  {a:5, b:50, c:100}
</code></pre></div>
<p dir="auto">Some operations yield array-wise results.</p>
<div data-snippet-clipboard-copy-content="![0, 1, 0]
  [1, 0, 1]

[2, 3, 4, 4, 4] &lt;= [3, 3, 3, 3, 3]
  [1, 1, 0, 0, 0]"><pre><code>![0, 1, 0]
  [1, 0, 1]

[2, 3, 4, 4, 4] &lt;= [3, 3, 3, 3, 3]
  [1, 1, 0, 0, 0]
</code></pre></div>
<p dir="auto">Operations are optimized for vectors</p>
<div data-snippet-clipboard-copy-content="timing 1
a: range(10**6)
sum(a)
a+a
min(a)"><pre><code>timing 1
a: range(10**6)
sum(a)
a+a
min(a)
</code></pre></div>
<p dir="auto"><strong>TABLES</strong></p>
<p dir="auto">Kerf extends JSON to include the concept of tables. Tables are created just like maps except you use double curly-braces. The names of the keys in that case are instead the names of the columns. So <code>{{a:1, b:2}}</code> is a table and <code>{a:1, b:2}</code> is a map. The convenience constructor <code>{{a,b,c}}</code> also creates a table. This table will have empty arrays for columns. Table columns are always arrays. If you pass something that isn&#39;t an array it will be coerced into an array.</p>
<p dir="auto">The following are all equivalent ways to make a table:</p>
<div data-snippet-clipboard-copy-content="  {{id:1, time:now(), brightness:48.6}}
is the same as 
  {{id:[1], time:[now()], brightness:[48.6]}}
is the same as 
  INSERT INTO {{id, time, brightness}} VALUES [[1], [now()], [48.6]] //bulk insert/append
is the same as
  INSERT INTO {{id, time, brightness}} VALUES {id:1, time:now(), brightness:48.6}   //insert map
is the same as
  INSERT INTO {{id, time, brightness}} VALUES {{id:1, time:now(), brightness:48.6}} //append table
is the same as
  INSERT INTO {{}} VALUES {id:1, time:now(), brightness:48.6} //empty tables are special
is the same as
  a:{{}}
  INSERT INTO a VALUES {id:1, time:now(), brightness:48.6}
is the same as
  id:[1]
  time:[now()]
  brightness:[48.6]
  {{id:id, time:time, brightness:brightness}}"><pre><code>  {{id:1, time:now(), brightness:48.6}}
is the same as 
  {{id:[1], time:[now()], brightness:[48.6]}}
is the same as 
  INSERT INTO {{id, time, brightness}} VALUES [[1], [now()], [48.6]] //bulk insert/append
is the same as
  INSERT INTO {{id, time, brightness}} VALUES {id:1, time:now(), brightness:48.6}   //insert map
is the same as
  INSERT INTO {{id, time, brightness}} VALUES {{id:1, time:now(), brightness:48.6}} //append table
is the same as
  INSERT INTO {{}} VALUES {id:1, time:now(), brightness:48.6} //empty tables are special
is the same as
  a:{{}}
  INSERT INTO a VALUES {id:1, time:now(), brightness:48.6}
is the same as
  id:[1]
  time:[now()]
  brightness:[48.6]
  {{id:id, time:time, brightness:brightness}}
</code></pre></div>
<p dir="auto">They are all printed as</p>
<div data-snippet-clipboard-copy-content="┌──┬───────────────────────┬──────────┐
│id│time                   │brightness│
├──┼───────────────────────┼──────────┤
│ 1│2015.07.06T16:23:50.509│      48.6│
└──┴───────────────────────┴──────────┘"><pre><code>┌──┬───────────────────────┬──────────┐
│id│time                   │brightness│
├──┼───────────────────────┼──────────┤
│ 1│2015.07.06T16:23:50.509│      48.6│
└──┴───────────────────────┴──────────┘
</code></pre></div>
<p dir="auto">SQL inserts and updates are forms of assignment: they are always &#34;saved&#34;. Bulk inserts are much faster than single inserts. The columns id, time, and brightness are vectorized as INT, STAMP, and FLOAT vectors respectively. The preceding tables all exist in-memory only.</p>
<p dir="auto"><strong>READS/WRITES</strong></p>
<p dir="auto">You can read and write arbitrary objects, including in-memory tables, using the following functions. These are not really designed for transactional reads and writes, more like per-session reads and writes.</p>
<div data-snippet-clipboard-copy-content="  read_from_path(&#39;path.to.file&#39;)
  write_to_path(&#39;path.to.file&#39;, object);"><pre><code>  read_from_path(&#39;path.to.file&#39;)
  write_to_path(&#39;path.to.file&#39;, object);
</code></pre></div>
<p dir="auto">For an on-disk table that handles transactional writes, you&#39;ll want a mapped object. On Linux, OSX, BSD and other systems, the virtual memory limit for mapped objects is slightly less than 47-bits, or 128T, which for most people is effectively unlimited.</p>
<p dir="auto">Apple&#39;s iOS operating system restricts <em>virtual</em> memory allocations to something less than 2G in size, <em>even on</em> devices with 64-bit pointers. So mapping very large tables will not get far around the memory limitations of the mobile device. Apple really should look into raising it: it may be a legacy restriction from some now-outdated concerns. On OS X the virtual memory limit is effectively unrestricted.</p>
<p dir="auto">You can open tables on disk via the <code>open_table(filepath)</code> call. Here it is via the Objective-C API:</p>
<div data-snippet-clipboard-copy-content="NSString *path = [[kerf suggestedTableDirectoryPath] stringByAppendingPathComponent:@&#34;my.table&#34;];
[kerf jsonObjectFromCall:@&#34;a: open_table($1)&#34; withArgumentArray:@[path]]
[kerf jsonObjectFromCall:@&#34;insert into a values {{id: 4}}&#34;]);
[kerf jsonObjectFromCall:@&#34;a&#34;]"><pre><code>NSString *path = [[kerf suggestedTableDirectoryPath] stringByAppendingPathComponent:@&#34;my.table&#34;];
[kerf jsonObjectFromCall:@&#34;a: open_table($1)&#34; withArgumentArray:@[path]]
[kerf jsonObjectFromCall:@&#34;insert into a values {{id: 4}}&#34;]);
[kerf jsonObjectFromCall:@&#34;a&#34;]
</code></pre></div>
<p dir="auto">Modifications to the variable cause the inserts to persist to the disk. They will be there the next time you open the table. Most variables in Kerf use reference counting or copy-on-write to ensure uniqueness. Mapped values like opened tables are different: all reference the same open item. Changes to one affect the other.</p>
<p dir="auto"><strong>CSV/TSV/ETC LOADING</strong></p>
<p dir="auto">Loading CSVs into tables should be easy. The function for reading a CSV into an in-memory table is <code>read_table_from_csv</code>, and it is used in this way:</p>
<div data-snippet-clipboard-copy-content="read_table_from_csv(csv_file, fields, header_rows)"><pre><code>read_table_from_csv(csv_file, fields, header_rows)
</code></pre></div>
<p dir="auto">so that</p>
<div data-snippet-clipboard-copy-content="csv_file: &#39;my_logs01.csv&#39;
fields: &#39;SFI&#39;
header_rows: 1
table: read_table_from_csv(csv_file, fields, header_rows)"><pre><code>csv_file: &#39;my_logs01.csv&#39;
fields: &#39;SFI&#39;
header_rows: 1
table: read_table_from_csv(csv_file, fields, header_rows)
</code></pre></div>
<p dir="auto">will load a file that looks like:</p>
<div data-snippet-clipboard-copy-content="Racer, Max Speed, Wins
Mario, 30.01, 10
Luigi, 28.02, 12
Toad,  25.00,  7"><pre><code>Racer, Max Speed, Wins
Mario, 30.01, 10
Luigi, 28.02, 12
Toad,  25.00,  7
</code></pre></div>
<p dir="auto">as so:</p>
<div data-snippet-clipboard-copy-content="KeRF&gt; t: read_table_from_csv(&#39;my_logs01.csv&#39;, &#39;SFI&#39;, 1)
┌─────┬─────────┬────┐
│Racer│Max Speed│Wins│
├─────┼─────────┼────┤
│Mario│    30.01│  10│
│Luigi│    28.02│  12│
│ Toad│     25.0│   7│
└─────┴─────────┴────┘"><pre><code>KeRF&gt; t: read_table_from_csv(&#39;my_logs01.csv&#39;, &#39;SFI&#39;, 1)
┌─────┬─────────┬────┐
│Racer│Max Speed│Wins│
├─────┼─────────┼────┤
│Mario│    30.01│  10│
│Luigi│    28.02│  12│
│ Toad│     25.0│   7│
└─────┴─────────┴────┘
</code></pre></div>
<p dir="auto">The currently supported list of field identifiers is &#34;IFSEGNZz*&#34; integers floats strings enumerated-strings guids/uuids ips custom-datetime custom-datetime2 skipped-field. IP addresses are converted to integers using inet_pton. The custom datetime parser format is set like this</p>
<div data-snippet-clipboard-copy-content=".Parse.strptime_format: &#39;%d-%b-%y %H:%M:%S&#39;  //format for &#39;Z&#39;
.Parse.strptime_format2:&#39;%d-%b-%y %H:%M:%S&#39;  //format for &#39;z&#39;"><pre><code>.Parse.strptime_format: &#39;%d-%b-%y %H:%M:%S&#39;  //format for &#39;Z&#39;
.Parse.strptime_format2:&#39;%d-%b-%y %H:%M:%S&#39;  //format for &#39;z&#39;
</code></pre></div>
<p dir="auto">and relies directly on the system <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html" rel="nofollow">strptime format</a>.</p>
<p dir="auto">Similar functions exist for TSVs and for arbitrary character-delimited files (e.g., pipe-delimited):</p>
<div data-snippet-clipboard-copy-content="read_table_from_tsv(&#39;prices.tsv&#39;, &#34;SFFF&#34;, 1)
read_table_from_delimited_file(&#39;\t&#39;, &#39;prices.tsv&#39;, &#34;SFFF&#34;, 1)
read_table_from_delimited_file(&#39;|&#39;,  &#39;prices.psv&#39;, &#34;SFFF&#34;, 1)

┌─────────┬──────┬──────┬──────┐
│id       │rent_1│rent_2│rent_3│
├─────────┼──────┼──────┼──────┤
│E01004236│1100.0│1275.0│1500.0│
│E01004237│1150.0│1550.0│1725.0│
│E01004234│1050.0│1375.0│1650.0│
│E01004235│1025.0│1300.0│1500.0│
│E01004232│ 975.0│1300.0│2025.0│
│E01004233│1050.0│1425.0│1800.0│
│E01004230│1125.0│1300.0│2025.0│
│E01004231│1175.0│1550.0│1725.0│
│       ..│    ..│    ..│    ..│
└─────────┴──────┴──────┴──────┘"><pre><code>read_table_from_tsv(&#39;prices.tsv&#39;, &#34;SFFF&#34;, 1)
read_table_from_delimited_file(&#39;\t&#39;, &#39;prices.tsv&#39;, &#34;SFFF&#34;, 1)
read_table_from_delimited_file(&#39;|&#39;,  &#39;prices.psv&#39;, &#34;SFFF&#34;, 1)

┌─────────┬──────┬──────┬──────┐
│id       │rent_1│rent_2│rent_3│
├─────────┼──────┼──────┼──────┤
│E01004236│1100.0│1275.0│1500.0│
│E01004237│1150.0│1550.0│1725.0│
│E01004234│1050.0│1375.0│1650.0│
│E01004235│1025.0│1300.0│1500.0│
│E01004232│ 975.0│1300.0│2025.0│
│E01004233│1050.0│1425.0│1800.0│
│E01004230│1125.0│1300.0│2025.0│
│E01004231│1175.0│1550.0│1725.0│
│       ..│    ..│    ..│    ..│
└─────────┴──────┴──────┴──────┘
</code></pre></div>
<p dir="auto">Once you&#39;ve stored such a table in a variable in memory, you can write it to disk for later use using <code>write_to_path</code>:</p>
<div data-snippet-clipboard-copy-content=" t: read_table_from_csv(&#39;prices.csv&#39;, &#39;SFF&#39;, 1)
 write_to_path(&#39;prices.table&#39;, t);"><pre><code> t: read_table_from_csv(&#39;prices.csv&#39;, &#39;SFF&#39;, 1)
 write_to_path(&#39;prices.table&#39;, t);
</code></pre></div>
<p dir="auto">To open such a table later call</p>
<div data-snippet-clipboard-copy-content="t: read_from_path(&#39;prices.table&#39;)  //in-memory only version table
or
t: open_table(&#39;prices.table&#39;)      //on-disk memory-mapped version of table"><pre><code>t: read_from_path(&#39;prices.table&#39;)  //in-memory only version table
or
t: open_table(&#39;prices.table&#39;)      //on-disk memory-mapped version of table
</code></pre></div>
<p dir="auto"><strong>CSV/TSV/ETC WRITING</strong></p>
<p dir="auto">There are two methods for writing delimited files. The first is a convenience method for CSVs:</p>
<div data-snippet-clipboard-copy-content="write_csv_from_table

path: &#39;my_logs01.csv&#39;
table: my_table
write_csv_from_table(path, table)"><pre><code>write_csv_from_table

path: &#39;my_logs01.csv&#39;
table: my_table
write_csv_from_table(path, table)
</code></pre></div>
<p dir="auto">The second is the generalized method that lets you specify the delimiter:</p>
<div data-snippet-clipboard-copy-content="write_delimited_file_from_table

path: &#39;my_logs01.csv&#39;
table: my_table
write_delimited_file_from_table(&#34;\t&#34;, path, table) //for TSV

write_delimited_file_from_table(&#34;|&#34;,  path, table) //for PSV"><pre><code>write_delimited_file_from_table

path: &#39;my_logs01.csv&#39;
table: my_table
write_delimited_file_from_table(&#34;\t&#34;, path, table) //for TSV

write_delimited_file_from_table(&#34;|&#34;,  path, table) //for PSV
</code></pre></div>
<p dir="auto">All of these methods require your data to be collected in a table before writing. This simplifies the output process considerably.</p>
<p dir="auto"><strong>FIXED-WIDTH FILE LOADING</strong></p>
<p dir="auto">Kerf supports fixed-width file loading. The motivating use-case for this is the NYSE TAQ fixed-width format. Perhaps the best way to understand how this works is to look at the <a href="https://github.com/kevinlawler/kerf/blob/master/scripts/taq.kerf">NYSE TAQ loading example script</a>. In addition to the fields supported by the CSV-style readers, the fixed-width reader supports the fields &#34;QR&#34;, representing NYSE&#39;s strange timestamp format, and an enumerated NYSE dot-delimited symbol column.</p>
<p dir="auto">To invoke the fixed-width field reader, use:</p>
<div data-snippet-clipboard-copy-content="file:&#39;path/to/file.ext&#39;
attributes: {fields: &#39;Q*R*IF******&#39;,  widths: 9 1 16 4 9 11 1 2 16 1 1 2}
read_table_from_fixed_file(file, attributes)"><pre><code>file:&#39;path/to/file.ext&#39;
attributes: {fields: &#39;Q*R*IF******&#39;,  widths: 9 1 16 4 9 11 1 2 16 1 1 2}
read_table_from_fixed_file(file, attributes)
</code></pre></div>
<p dir="auto">The &#34;attibutes&#34; argument is map. Relevant keys are &#34;fields widths titles header_rows line_limit&#34;. &#34;Titles&#34; are column titles. Some keys, such as &#34;line_limit&#34; are not required.</p>
<p dir="auto"><strong>SCRIPTS</strong></p>
<p dir="auto">Kerf code can be stored in scripts. The suggested extension is <code>.kerf</code> for Kerf scriptfiles. You can load scripts from the console using <code>load</code>, so that if a file <code>myscript.kerf</code> contains the code</p>

<p dir="auto">Then a terminal session that loads the script might look as follows:</p>
<div data-snippet-clipboard-copy-content="KeRF&gt; load &#39;myscript.kerf&#39;
KeRF&gt; c
  33"><pre><code>KeRF&gt; load &#39;myscript.kerf&#39;
KeRF&gt; c
  33
</code></pre></div>
<p dir="auto">Scripts following the binary&#39;s name on the command line will be executed in order.</p>
<div data-snippet-clipboard-copy-content="$ ./kerf myscript.kerf b.kerf c.kerf"><pre><code>$ ./kerf myscript.kerf b.kerf c.kerf
</code></pre></div>
<p dir="auto">If a script named &#34;startup.kerf&#34; is present in Kerf&#39;s working directory, then it will be executed at startup, before any other command-line scripts. Scripts may be loaded from other scripts.</p>
<p dir="auto"><strong>FLAGS</strong></p>
<p dir="auto">The <code>-x</code> flag executes and prints its argument. The <code>-e</code> flag executes its argument without printing.</p>
<div data-snippet-clipboard-copy-content="$ ./kerf -x &#39;1+1&#39;
2
$ ./kerf -e &#39;1+1&#39;"><pre><code>$ ./kerf -x &#39;1+1&#39;
2
$ ./kerf -e &#39;1+1&#39;
</code></pre></div>
<p dir="auto">The <code>-q</code> or quiet flag starts Kerf without a banner. It has no arugment. The <code>-p</code> flag opens an IPC port on its argument.</p>
<p dir="auto">Logging is enabled using the <code>-l</code> flag. Currently this logs all incoming network requests to the file <code>kerf.log</code> for possible future replay.</p>
<p dir="auto"><strong>EXITING</strong></p>
<p dir="auto">From the console, pressing <code>ctrl+d</code> will exit the process. (This sends an end-of-transmission control character.) The Kerf function <code>exit()</code> will end the process via code execution. If you like, you can optionally pass an argument to <code>exit</code> that will be returned by the Kerf process to the shell.</p>

<p dir="auto"><strong>TIME MATH</strong></p>
<p dir="auto">We previously saw absolute time stamps of the form</p>
<div data-snippet-clipboard-copy-content="2015.04.01 or 2015.03.31T01:23:45.877"><pre><code>2015.04.01 or 2015.03.31T01:23:45.877
</code></pre></div>
<p dir="auto">We can compare them</p>
<div data-snippet-clipboard-copy-content="2015.04.02 &lt; 2015.05.01 
  1"><pre><code>2015.04.02 &lt; 2015.05.01 
  1
</code></pre></div>
<p dir="auto">We can modify them using relative times of the form <code>1y</code> or <code>1y3d</code> or <code>4h55i06s</code> and so on. So</p>
<div data-snippet-clipboard-copy-content="2015.04.01 + 1y1m1d
  2016.05.02"><pre><code>2015.04.01 + 1y1m1d
  2016.05.02
</code></pre></div>
<p dir="auto">Or alternatively as</p>
<div data-snippet-clipboard-copy-content="  2015.04.01 + 1y + 1m + 1d
    2016.05.02"><pre><code>  2015.04.01 + 1y + 1m + 1d
    2016.05.02
</code></pre></div>
<p dir="auto">And <code>2015.04.01 + 1h2i3s</code> gives <code>2015.04.01T01:02:03.000</code>.</p>
<div data-snippet-clipboard-copy-content="now_date() + 1d
  2015.04.02

now_time()
  21:36:00.762

minus(now_time(), 25 * 1h)
  20:36:02.005"><pre><code>now_date() + 1d
  2015.04.02

now_time()
  21:36:00.762

minus(now_time(), 25 * 1h)
  20:36:02.005
</code></pre></div>
<p dir="auto">The current list of possibilities is: <code>ymdhis</code> year month day hour minute second.</p>
<p dir="auto">Note that while <code>minus</code> could be perfectly well defined as an operation on absolute STAMPs (for a given reduced form, it could return a relative stamp), at least for the time being in Kerf it throws a type error. This is easy to get around, do</p>
<div data-snippet-clipboard-copy-content="  2015.04.07 + 1d &lt;= 2015.04.08"><pre><code>  2015.04.07 + 1d &lt;= 2015.04.08
</code></pre></div>
<p dir="auto">instead of</p>
<div data-snippet-clipboard-copy-content="  (2015.04.08 - 2015.04.07) &lt;= 1d "><pre><code>  (2015.04.08 - 2015.04.07) &lt;= 1d 
</code></pre></div>
<p dir="auto">The reason you might want to avoid producing relative times is that the full range of useful relative dates and times exceeds a 64-bit width and so is not vectorized.</p>
<p dir="auto">Timestamps are nanosecond granularity. By default only millisecond precision is displayed. But this is cosmetic.</p>
<div data-snippet-clipboard-copy-content="  2001.01.01T01:01:01.012345678[&#39;nanosecond&#39;]
12345678"><pre><code>  2001.01.01T01:01:01.012345678[&#39;nanosecond&#39;]
12345678
</code></pre></div>
<p dir="auto">To extract individual parts from times, use</p>
<div data-snippet-clipboard-copy-content="a: 2015.03.16T04:05:06.7890123456
a: [a, a] //optional, to see how it works in vector form

a[&#39;date&#39;]   //stamp
a[&#39;time&#39;]   //stamp
a[&#39;year&#39;]   //int
a[&#39;month&#39;] 
a[&#39;day&#39;]
a[&#39;hour&#39;]
a[&#39;minute&#39;]
a[&#39;second&#39;]
a[&#39;millisecond&#39;]
a[&#39;nanosecond&#39;] "><pre><code>a: 2015.03.16T04:05:06.7890123456
a: [a, a] //optional, to see how it works in vector form

a[&#39;date&#39;]   //stamp
a[&#39;time&#39;]   //stamp
a[&#39;year&#39;]   //int
a[&#39;month&#39;] 
a[&#39;day&#39;]
a[&#39;hour&#39;]
a[&#39;minute&#39;]
a[&#39;second&#39;]
a[&#39;millisecond&#39;]
a[&#39;nanosecond&#39;] 
</code></pre></div>
<p dir="auto"><strong>SQL (SELECT)</strong></p>
<p dir="auto">Kerf is a superset of SQL. This means Kerf speaks SQL, and you can write SQL anywhere inside of Kerf code. Let&#39;s start by building a suitable table.</p>
<div data-snippet-clipboard-copy-content="n: 10**4
ids: range(1, n+1)
stamps: plus(NOW(), 1s + mapright range(n))
heartrates: 80 + rand(n, 100.0)  
labels: range(6)
lanes: take(n, join(labels, reverse labels))
running: {{id: ids, stamp: stamps, heartrate: heartrates, lane: lanes}} 


┌──┬───────────────────────┬─────────┬────┐
│id│stamp                  │heartrate│lane│
├──┼───────────────────────┼─────────┼────┤
│ 1│2015.07.06T16:24:55.543│  96.4771│   0│
│ 2│2015.07.06T16:24:56.543│  107.397│   1│
│ 3│2015.07.06T16:24:57.543│  108.356│   2│
│ 4│2015.07.06T16:24:58.543│  92.2126│   3│
│ 5│2015.07.06T16:24:59.543│  125.115│   4│
│ 6│2015.07.06T16:25:00.543│  161.533│   5│
│ 7│2015.07.06T16:25:01.543│  175.726│   5│
│ 8│2015.07.06T16:25:02.543│  118.177│   4│
│..│                     ..│      .. │  ..│
└──┴───────────────────────┴─────────┴────┘"><pre><code>n: 10**4
ids: range(1, n+1)
stamps: plus(NOW(), 1s + mapright range(n))
heartrates: 80 + rand(n, 100.0)  
labels: range(6)
lanes: take(n, join(labels, reverse labels))
running: {{id: ids, stamp: stamps, heartrate: heartrates, lane: lanes}} 


┌──┬───────────────────────┬─────────┬────┐
│id│stamp                  │heartrate│lane│
├──┼───────────────────────┼─────────┼────┤
│ 1│2015.07.06T16:24:55.543│  96.4771│   0│
│ 2│2015.07.06T16:24:56.543│  107.397│   1│
│ 3│2015.07.06T16:24:57.543│  108.356│   2│
│ 4│2015.07.06T16:24:58.543│  92.2126│   3│
│ 5│2015.07.06T16:24:59.543│  125.115│   4│
│ 6│2015.07.06T16:25:00.543│  161.533│   5│
│ 7│2015.07.06T16:25:01.543│  175.726│   5│
│ 8│2015.07.06T16:25:02.543│  118.177│   4│
│..│                     ..│      .. │  ..│
└──┴───────────────────────┴─────────┴────┘
</code></pre></div>
<p dir="auto">Someone is running a zigzag across a six-lane track with a random heartbeat. This is not exactly realistic data but let&#39;s go with it. We can count the number of rows in the table:</p>
<div data-snippet-clipboard-copy-content="select count(*) as rows from running
┌─────┐
│rows │
├─────┤
│10000│
└─────┘"><pre><code>select count(*) as rows from running
┌─────┐
│rows │
├─────┤
│10000│
└─────┘
</code></pre></div>
<p dir="auto">And there&#39;s no reason we can&#39;t run SQL inside of JSON:</p>
<div data-snippet-clipboard-copy-content="[{a:1, b: select count(*) from running}, select count(*) from running]"><pre><code>[{a:1, b: select count(*) from running}, select count(*) from running]
</code></pre></div>
<p dir="auto">Let&#39;s verify the count of the table:</p>

<p dir="auto">Peek at the first 3 rows:</p>
<div data-snippet-clipboard-copy-content="first(3, running)
┌──┬───────────────────────┬─────────┬────┐
│id│stamp                  │heartrate│lane│
├──┼───────────────────────┼─────────┼────┤
│ 1│2015.07.06T16:24:55.543│  96.4771│   0│
│ 2│2015.07.06T16:24:56.543│  107.397│   1│
│ 3│2015.07.06T16:24:57.543│  108.356│   2│
└──┴───────────────────────┴─────────┴────┘"><pre><code>first(3, running)
┌──┬───────────────────────┬─────────┬────┐
│id│stamp                  │heartrate│lane│
├──┼───────────────────────┼─────────┼────┤
│ 1│2015.07.06T16:24:55.543│  96.4771│   0│
│ 2│2015.07.06T16:24:56.543│  107.397│   1│
│ 3│2015.07.06T16:24:57.543│  108.356│   2│
└──┴───────────────────────┴─────────┴────┘
</code></pre></div>
<p dir="auto">Get the bounds on the time:</p>
<div data-snippet-clipboard-copy-content="select first(stamp), last(stamp) from running
┌───────────────────────┬───────────────────────┐
│stamp                  │stamp1                 │
├───────────────────────┼───────────────────────┤
│2015.07.06T16:24:55.543│2015.07.06T19:11:34.543│
└───────────────────────┴───────────────────────┘"><pre><code>select first(stamp), last(stamp) from running
┌───────────────────────┬───────────────────────┐
│stamp                  │stamp1                 │
├───────────────────────┼───────────────────────┤
│2015.07.06T16:24:55.543│2015.07.06T19:11:34.543│
└───────────────────────┴───────────────────────┘
</code></pre></div>
<p dir="auto">Alternatively</p>
<div data-snippet-clipboard-copy-content="[first(running.stamp), last(running.stamp)]
[2015.04.01T19:13:33.917, 2015.04.01T22:00:12.917]"><pre><code>[first(running.stamp), last(running.stamp)]
[2015.04.01T19:13:33.917, 2015.04.01T22:00:12.917]
</code></pre></div>
<p dir="auto">And perform GROUP BY and WHERE queries:</p>
<div data-snippet-clipboard-copy-content="select avg(heartrate) from running where heartrate &gt; 100 group by lane
┌────┬─────────┐
│lane│heartrate│
├────┼─────────┤
│   1│  139.192│
│   2│  140.283│
│   4│  139.772│
│   5│   140.24│
│   3│  140.167│
│   0│  138.541│
└────┴─────────┘"><pre><code>select avg(heartrate) from running where heartrate &gt; 100 group by lane
┌────┬─────────┐
│lane│heartrate│
├────┼─────────┤
│   1│  139.192│
│   2│  140.283│
│   4│  139.772│
│   5│   140.24│
│   3│  140.167│
│   0│  138.541│
└────┴─────────┘
</code></pre></div>
<p dir="auto">Nested subqueries:</p>
<div data-snippet-clipboard-copy-content="select * from (select avg(heartrate) from running where heartrate &gt; 100 group by lane) where heartrate = max(heartrate)
┌────┬─────────┐
│lane│heartrate│
├────┼─────────┤
│   2│  140.283│
└────┴─────────┘"><pre><code>select * from (select avg(heartrate) from running where heartrate &gt; 100 group by lane) where heartrate = max(heartrate)
┌────┬─────────┐
│lane│heartrate│
├────┼─────────┤
│   2│  140.283│
└────┴─────────┘
</code></pre></div>
<p dir="auto">We can store the results of queries in other variables.</p>
<div data-snippet-clipboard-copy-content="b: select max(heartrate) from running where lane = 2
┌─────────┐
│heartrate│
├─────────┤
│  179.976│
└─────────┘"><pre><code>b: select max(heartrate) from running where lane = 2
┌─────────┐
│heartrate│
├─────────┤
│  179.976│
└─────────┘
</code></pre></div>
<p dir="auto">And retrieve the cell value only like so:</p>
<div data-snippet-clipboard-copy-content="first(b.heartrate)
  179.952"><pre><code>first(b.heartrate)
  179.952
</code></pre></div>
<p dir="auto">The supported SQL WHERE comparison methods currently are:</p>

<p dir="auto">Conjunction in a WHERE clause is indicated using commas, e.g.:</p>
<div data-snippet-clipboard-copy-content="select from running where lane = 2, heartrate = 108.356

┌──┬───────────────────────┬─────────┬────┐
│id│stamp                  │heartrate│lane│
├──┼───────────────────────┼─────────┼────|
│ 3│2015.07.06T16:24:57.543│  108.356│   2│
└──┴───────────────────────┴─────────┴────┘"><pre><code>select from running where lane = 2, heartrate = 108.356

┌──┬───────────────────────┬─────────┬────┐
│id│stamp                  │heartrate│lane│
├──┼───────────────────────┼─────────┼────|
│ 3│2015.07.06T16:24:57.543│  108.356│   2│
└──┴───────────────────────┴─────────┴────┘
</code></pre></div>
<p dir="auto">In Kerf &#34;and&#34; and &#34;or&#34; have different meanings and will operate on the columns prior to serving them up for consideration as indices. When using &#34;or&#34; or &#34;and&#34;, be sure to parenthesize the subexpressions. So</p>
<div data-snippet-clipboard-copy-content="select from running where (lane = 2) or (heartrate = 108.356)"><pre><code>select from running where (lane = 2) or (heartrate = 108.356)
</code></pre></div>
<p dir="auto">The following also works:</p>
<div data-snippet-clipboard-copy-content="select from running where or(lane = 2, heartrate = 108.356)"><pre><code>select from running where or(lane = 2, heartrate = 108.356)
</code></pre></div>
<p dir="auto">The supported SQL GROUP BY aggregation methods currently are:</p>
<div data-snippet-clipboard-copy-content="  min max sum count first last avg std var"><pre><code>  min max sum count first last avg std var
</code></pre></div>
<p dir="auto">Kerf can use our nicely sorted ID range to perform fast lookups even without an index. Table traits are undocumented at this point.</p>
<p dir="auto"><strong>LEFT JOIN</strong></p>
<p dir="auto">A basic left join can be accomplished with the <code>left_join</code> function.</p>
<div data-snippet-clipboard-copy-content="t:{{a:1 2 2 3, b:10 20 30 40}}
u:{{a:2 3, c:1.5 3}}
left_join(t,u,&#34;a&#34;)

┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│1.5│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘"><pre><code>t:{{a:1 2 2 3, b:10 20 30 40}}
u:{{a:2 3, c:1.5 3}}
left_join(t,u,&#34;a&#34;)

┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│1.5│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘
</code></pre></div>
<p dir="auto">The third argument indicates the key or keys to match on. The argument is a string or an array of strings.</p>
<div data-snippet-clipboard-copy-content="u:{{a:2 3, b:30 40, c:1.5 3}}
left_join(t,u,[&#34;a&#34;,&#34;b&#34;])

┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│nan│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘"><pre><code>u:{{a:2 3, b:30 40, c:1.5 3}}
left_join(t,u,[&#34;a&#34;,&#34;b&#34;])

┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│nan│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘
</code></pre></div>
<p dir="auto">If your tables don&#39;t match on column names, no sweat, use a map.</p>
<div data-snippet-clipboard-copy-content="t:{{a:1 2 2 3, b:10 20 30 40}}
u:{{z:2 3, c:1.5 3}}
left_join(t, u, {&#39;a&#39;:&#39;z&#39;})

┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│1.5│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘"><pre><code>t:{{a:1 2 2 3, b:10 20 30 40}}
u:{{z:2 3, c:1.5 3}}
left_join(t, u, {&#39;a&#39;:&#39;z&#39;})

┌─┬──┬───┐
│a│b │c  │
├─┼──┼───┤
│1│10│nan│
│2│20│1.5│
│2│30│1.5│
│3│40│3.0│
└─┴──┴───┘
</code></pre></div>
<p dir="auto"><strong>ASOF JOIN</strong></p>
<p dir="auto">One useful time-series operation is the asof join, which is predictably called using the <code>asof_join</code> function. The function accepts four arguments. The first three are the same as in the case of left join, and operate similarly. The third argument indicates columns whose items must match exactly. The fourth argument is a string or array of strings indicating column names. Typically these refer to time columns, though that is not required.</p>
<p dir="auto">If the columns in the third argument require &#34;exact&#34; matches, then the columns in the fourth argument accept &#34;fuzzy&#34;  matches: they&#39;ll match on any value up to and including the time in question. Perhaps this is best illustrated with an example. This style of matching is useful for seeing what the latest value at a specific time was, when in reality the last update may have occured some time in the past.</p>
<div data-snippet-clipboard-copy-content="//Example taken from timestored.com
KeRF&gt; trades: {{time: 07:00 08:30 09:59 10:00 12:00 16:00, sym:enum[&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;], price: .9 1.5 1.9 2 9 10, size: 100 700 200 400 500 800}}

┌────────────┬───┬─────┬────┐
│time        │sym│price│size│
├────────────┼───┼─────┼────┤
│07:00:00.000│  a│  0.9│ 100│
│08:30:00.000│  a│  1.5│ 700│
│09:59:00.000│  a│  1.9│ 200│
│10:00:00.000│  a│  2.0│ 400│
│12:00:00.000│  b│  9.0│ 500│
│16:00:00.000│  a│ 10.0│ 800│
└────────────┴───┴─────┴────┘

KeRF&gt; quotes: {{time: 08:00 09:00 10:00 11:00 12:00 13:00 14:00 15:00, sym:enum[&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;], bid: 1 9 2 8 8.5 3 7 4}}

┌────────────┬───┬───┐
│time        │sym│bid│
├────────────┼───┼───┤
│08:00:00.000│  a│1.0│
│09:00:00.000│  b│9.0│
│10:00:00.000│  a│2.0│
│11:00:00.000│  b│8.0│
│12:00:00.000│  b│8.5│
│13:00:00.000│  a│3.0│
│14:00:00.000│  b│7.0│
│15:00:00.000│  a│4.0│
└────────────┴───┴───┘

KeRF&gt; asof_join(trades, quotes, [&#39;sym&#39;], [&#39;time&#39;])                                                                                            
┌────────────┬───┬─────┬────┬───┐
│time        │sym│price│size│bid│
├────────────┼───┼─────┼────┼───┤
│07:00:00.000│  a│  0.9│ 100│nan│
│08:30:00.000│  a│  1.5│ 700│1.0│
│09:59:00.000│  a│  1.9│ 200│1.0│
│10:00:00.000│  a│  2.0│ 400│2.0│
│12:00:00.000│  b│  9.0│ 500│8.5│
│16:00:00.000│  a│ 10.0│ 800│4.0│
└────────────┴───┴─────┴────┴───┘"><pre><code>//Example taken from timestored.com
KeRF&gt; trades: {{time: 07:00 08:30 09:59 10:00 12:00 16:00, sym:enum[&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;], price: .9 1.5 1.9 2 9 10, size: 100 700 200 400 500 800}}

┌────────────┬───┬─────┬────┐
│time        │sym│price│size│
├────────────┼───┼─────┼────┤
│07:00:00.000│  a│  0.9│ 100│
│08:30:00.000│  a│  1.5│ 700│
│09:59:00.000│  a│  1.9│ 200│
│10:00:00.000│  a│  2.0│ 400│
│12:00:00.000│  b│  9.0│ 500│
│16:00:00.000│  a│ 10.0│ 800│
└────────────┴───┴─────┴────┘

KeRF&gt; quotes: {{time: 08:00 09:00 10:00 11:00 12:00 13:00 14:00 15:00, sym:enum[&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;], bid: 1 9 2 8 8.5 3 7 4}}

┌────────────┬───┬───┐
│time        │sym│bid│
├────────────┼───┼───┤
│08:00:00.000│  a│1.0│
│09:00:00.000│  b│9.0│
│10:00:00.000│  a│2.0│
│11:00:00.000│  b│8.0│
│12:00:00.000│  b│8.5│
│13:00:00.000│  a│3.0│
│14:00:00.000│  b│7.0│
│15:00:00.000│  a│4.0│
└────────────┴───┴───┘

KeRF&gt; asof_join(trades, quotes, [&#39;sym&#39;], [&#39;time&#39;])                                                                                            
┌────────────┬───┬─────┬────┬───┐
│time        │sym│price│size│bid│
├────────────┼───┼─────┼────┼───┤
│07:00:00.000│  a│  0.9│ 100│nan│
│08:30:00.000│  a│  1.5│ 700│1.0│
│09:59:00.000│  a│  1.9│ 200│1.0│
│10:00:00.000│  a│  2.0│ 400│2.0│
│12:00:00.000│  b│  9.0│ 500│8.5│
│16:00:00.000│  a│ 10.0│ 800│4.0│
└────────────┴───┴─────┴────┴───┘
</code></pre></div>
<p dir="auto">Time-series events are necessarily logged at discrete times. Asof Join is a tool that lets us treat a discrete series as if it were continuous.</p>
<p dir="auto"><strong>SQL (DELETE)</strong></p>
<p dir="auto">The major tradeoff in using columnar storage is that deletes take O(n) time. For millions of rows in memory, this will take in the milliseconds, and so doesn&#39;t matter. For on-disk storage, you may want to avoid an architecture that incorporates repeated deletes.</p>
<div data-snippet-clipboard-copy-content="KeRF&gt; n:10**6; t:{{a:range(n), b:rand(n,100.0)}}

┌─┬───────┐
│a│b      │
├─┼───────┤
│0│16.4771│
│1│27.3974│
│2│28.3558│
│3│12.2126│
│4│45.1148│
│5│81.5326│
│6│ 95.726│
│7│38.1769│
│.│     ..│
└─┴───────┘

    14 ms

KeRF&gt; count t
  1000000

KeRF&gt; delete from t where b between [0,50]
  &#34;t&#34;

KeRF&gt; count t
  499326"><pre><code>KeRF&gt; n:10**6; t:{{a:range(n), b:rand(n,100.0)}}

┌─┬───────┐
│a│b      │
├─┼───────┤
│0│16.4771│
│1│27.3974│
│2│28.3558│
│3│12.2126│
│4│45.1148│
│5│81.5326│
│6│ 95.726│
│7│38.1769│
│.│     ..│
└─┴───────┘

    14 ms

KeRF&gt; count t
  1000000

KeRF&gt; delete from t where b between [0,50]
  &#34;t&#34;

KeRF&gt; count t
  499326
</code></pre></div>
<p dir="auto"><strong>ADVANCED TYPES</strong></p>
<p dir="auto">There are two advanced types which we can use for specialized columns:</p>
<div data-snippet-clipboard-copy-content="ENUM (HASH)
              enum [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;]  or hash [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;]
INDEX (SORT)
              index [1, 2, 3]"><pre><code>ENUM (HASH)
              enum [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;]  or hash [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;]
INDEX (SORT)
              index [1, 2, 3]
</code></pre></div>
<p dir="auto">Both are variations on ARRAYs or VECTORs. An <code>enum</code> is like a &#34;local&#34; string interning object. It keeps only one reference to each object and stores appearances as fixed-width indices. It is useful for storing repetitions of strings and lists, which cannot otherwise efficiently be stored as vectors. In all other respects an <code>enum</code> appears to be an array.</p>
<p dir="auto">An <code>index</code> is like an array except with an attached b-tree. This can make lookups and range queries more efficient. (The storage format of the index will be breaking after the alpha.) Don&#39;t use an <code>index</code> for data you can guarantee will always be sorted ascending, such as autoincrementing primary keys: Kerf will track sorted arrays and doesn&#39;t need a special index.</p>
<p dir="auto">Lambdas are also a type which can be stored.</p>
<p dir="auto">There is another hypothetical advanced type called an <code>ATLAS</code>, which is the schemaless NoSQL equivalent of a table. Atlases are automatically indexed in such a way that all key-queries are indexed.</p>
<p dir="auto"><strong>INTERPROCESS COMMUNICATION</strong></p>
<p dir="auto">Kerf instances are designed to be networked. The data structures serialize directly without any intermediate conversion.</p>
<p dir="auto">To start a Kerf server on port 1234 execute the command:</p>

<p dir="auto">You can communicate with this instance either via a Kerf client or via the Kerf SDK/API from another program (e.g., Python or Java or Objective-C).</p>
<p dir="auto">A client can be a plain old Kerf instance:</p>

<p dir="auto">Note: the server and the client should be separate instances. In the client paste each of the lines individually:</p>
<div data-snippet-clipboard-copy-content="socket: open_socket(&#34;localhost&#34;,&#34;1234&#34;)

send_async(socket, &#34;table: {{sym:hash[], time:[], price:[]}}&#34;)

do(100) {send_async(socket, &#34;insert into table values {sym:$1, time:$2, price:$3}&#34;, [rand([&#34;AAPL&#34;,&#34;MSFT&#34;,&#34;IBM&#34;]), now(),  20.0 + rand(10.0) ])}"><pre><code>socket: open_socket(&#34;localhost&#34;,&#34;1234&#34;)

send_async(socket, &#34;table: {{sym:hash[], time:[], price:[]}}&#34;)

do(100) {send_async(socket, &#34;insert into table values {sym:$1, time:$2, price:$3}&#34;, [rand([&#34;AAPL&#34;,&#34;MSFT&#34;,&#34;IBM&#34;]), now(),  20.0 + rand(10.0) ])}
</code></pre></div>
<p dir="auto">Then in the server execute:</p>
<div data-snippet-clipboard-copy-content="root

table

select avg(price) from table group by sym"><pre><code>root

table

select avg(price) from table group by sym
</code></pre></div>
<p dir="auto">Then in the client execute</p>

<p dir="auto">Currently IPC requires the user to store the socket handle. Probably what will happen is we will remove this and have all IPC calls use the server and port. It would be simple for Kerf to manage a hashtable of hosts and ports pointing to socket handles, and to keep or refresh them as necessary, and so we should probably do that.</p>
<p dir="auto">See a longer exposition of this topic on TimeStored: <a href="http://www.timestored.com/time-series-data/kerf-database" rel="nofollow">http://www.timestored.com/time-series-data/kerf-database</a></p>
<p dir="auto">As you might guess, <code>send_sync</code> is also available. The difference from <code>send_async</code> is that <code>send_sync</code> blocks and returns the evaluated reponse from the remote server.</p>
<div data-snippet-clipboard-copy-content="KeRF&gt; socket: open_socket(&#34;localhost&#34;,&#34;1234&#34;)
KeRF&gt; send_sync(socket,&#34;1+11&#34;,[])
12"><pre><code>KeRF&gt; socket: open_socket(&#34;localhost&#34;,&#34;1234&#34;)
KeRF&gt; send_sync(socket,&#34;1+11&#34;,[])
12
</code></pre></div>
<p dir="auto">Some IPC-related variables:</p>
<div data-snippet-clipboard-copy-content=".Net.client - current integer handle of the now-processing client
.Net.on_close - one-argument function called on the integer handle of the closing client"><pre><code>.Net.client - current integer handle of the now-processing client
.Net.on_close - one-argument function called on the integer handle of the closing client
</code></pre></div>
<p dir="auto">Examples:</p>
<div data-snippet-clipboard-copy-content=".Net.on_close: {[x] out &#39;client closed: &#39; join (string x) join &#39;\n&#39;}

send_async(socket, &#34;a:2; display .Net.client; out &#39; is the client\n&#39;&#34;)"><pre><code>.Net.on_close: {[x] out &#39;client closed: &#39; join (string x) join &#39;\n&#39;}

send_async(socket, &#34;a:2; display .Net.client; out &#39; is the client\n&#39;&#34;)
</code></pre></div>
<p dir="auto"><strong>CONTROL FLOW</strong></p>
<p dir="auto">Control flow is designed to be as generic as possible. You probably don&#39;t need it yet, but Kerf uses:</p>
<div data-snippet-clipboard-copy-content="if(b){x} else if(c){y} else{z} 
do(n){x} 
while(b){x}
for(a;b;c){x} 
def myfunc(arg1, arg2) {x}
function myfunc(arg1, arg2) {x}"><pre><code>if(b){x} else if(c){y} else{z} 
do(n){x} 
while(b){x}
for(a;b;c){x} 
def myfunc(arg1, arg2) {x}
function myfunc(arg1, arg2) {x}
</code></pre></div>
<p dir="auto">All portions must be properly (parenthesized) and {curly-braced}: no skipping. Lambdas are: <code>{[arg1, arg2] arg1+arg2}</code>. Lambda function recursion is <code>self</code> or <code>this</code>. Early return is <code>return</code>, otherwise return the final eval. Note: ending the final eval with a semicolon causes null to be returned. Commas <code>,</code> and semicolons <code>;</code> are usually interchangeable. Comments are <code>//</code>.</p>
<p dir="auto"><strong>MISC CODE SAMPLES</strong></p>
<p dir="auto">Examples for average, standard deviation, and variance (avg, std, var).</p>
<div data-snippet-clipboard-copy-content="a: [12, 2.4, 8]   //assign an array to &#39;a&#39; using JSON notation
a: range(6)       //integers [0, 1, 2, 3, 4, 5]
a: rand(8, 100.0) //eight random floats from the interval [0.0, 100.0)

REPL or API (Cheating):
  avg(a)
  std(a)
  var(a)

REPL or API (Simplified):
  (sum a)/count a              
  sqrt var a                   
  (sum (a - avg a)**2)/count a 

REPL or API (Traditional):
  sum(a)/count(a)               
  sqrt(var(a))                  
  sum((a - avg(a))**2)/count(a)

API Argument Passing, each with 1 argument (Traditional):
  sum($1)/count($1)               
  sqrt(var($1))                  
  sum(($1 - avg($1))**2)/count($1)

Function Definition (Traditional):
  def my_func_avg(a) {sum(a)/count(a)}
  def my_func_std(a) {sqrt(var(a))}
  def my_func_var(a) {sum((a - avg(a))**2)/count(a)}

Lambdas (Traditional):
  {[a] sum(a)/count(a)}
  {[a] sqrt(var(a))}
  {[a] sum((a - avg(a))**2)/count(a)}

REPL or API (Variant Takes)
  (plus fold a)/len(a)
  sum((a minus avg(a)) pow 2) divide count(a)
  pow(std a, 2) "><pre><code>a: [12, 2.4, 8]   //assign an array to &#39;a&#39; using JSON notation
a: range(6)       //integers [0, 1, 2, 3, 4, 5]
a: rand(8, 100.0) //eight random floats from the interval [0.0, 100.0)

REPL or API (Cheating):
  avg(a)
  std(a)
  var(a)

REPL or API (Simplified):
  (sum a)/count a              
  sqrt var a                   
  (sum (a - avg a)**2)/count a 

REPL or API (Traditional):
  sum(a)/count(a)               
  sqrt(var(a))                  
  sum((a - avg(a))**2)/count(a)

API Argument Passing, each with 1 argument (Traditional):
  sum($1)/count($1)               
  sqrt(var($1))                  
  sum(($1 - avg($1))**2)/count($1)

Function Definition (Traditional):
  def my_func_avg(a) {sum(a)/count(a)}
  def my_func_std(a) {sqrt(var(a))}
  def my_func_var(a) {sum((a - avg(a))**2)/count(a)}

Lambdas (Traditional):
  {[a] sum(a)/count(a)}
  {[a] sqrt(var(a))}
  {[a] sum((a - avg(a))**2)/count(a)}

REPL or API (Variant Takes)
  (plus fold a)/len(a)
  sum((a minus avg(a)) pow 2) divide count(a)
  pow(std a, 2) 
</code></pre></div>
<p dir="auto"><strong>LEGAL</strong></p>
<p dir="auto"><strong>MISC LANGUAGE SPECS</strong></p>
<p dir="auto">Kerf is written in C. Kerf is a superset of both JSON and SQL. Kerf compiles
to Kerf bytecode. Memory management is automatic and invisible to the user.
Internally, Kerf uses reference counting. Kerf does not garbage collect. Kerf
uses copy-on-write. Kerf uses a memory pool, so warmed operations are faster.
Kerf does not expose pointers. It does not use globally interned strings.
Certain objects will intern strings locally. Kerf data structures use
optimized hash tables and b-trees. All Kerf objects serialize automatically
and use the same [decompressed] representation in-memory, on-disk, and over
the network. IPC is compressed when it would lower transfer times.
By default the PRNG is initialized with a nondeterministic seed. By default
times are UTC.</p>
</article>
          </div></div>
  </body>
</html>
