<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://alok.github.io/2026/01/07/leanbench-runtime-profiler/">Original</a>
    <h1>Quick Take: Bridging Compile-Time and Runtime Performance in Lean 4</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>LeanBench can now correlate compilation metrics with actual runtime performance data from your profiler of choice.</p>

<p>The new Runtime module supports importing data from:</p>
<ul>
  <li><strong>Linux perf</strong> (script/stat output)</li>
  <li><strong>macOS Instruments</strong> (Time Profiler, Metal GPU traces)</li>
  <li><strong>NVIDIA NSight</strong> (CUDA kernel profiling)</li>
  <li><strong>Tracy</strong> (frame-by-frame analysis)</li>
  <li><strong>DTrace/SystemTap</strong> (kernel-level tracing)</li>
</ul>

<p>All of these feed into a vendor-neutral JSON schema that captures CPU samples, GPU kernel executions, memory events, and FFI call timings. The schema is designed to map profiler symbols back to Lean declarations through demangling heuristics.</p>

<p>The key insight: a function thatâ€™s fast to compile might be slow at runtime (and vice versa). By aggregating both metrics by file/declaration, you can identify where to invest optimization effort. A file that takes 10 seconds to elaborate but runs in microseconds is probably fine. A file that compiles instantly but dominates your runtime profile deserves attention.</p>

<p>Schema and collectors: <a href="https://github.com/alok/LeanBench/tree/gpu-metrics/LeanBench/Runtime">github.com/alok/LeanBench/tree/gpu-metrics/LeanBench/Runtime</a></p>

</article></div>
  </body>
</html>
