<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/FastVM/minivm">Original</a>
    <h1>MiniVM: A zero-dependency cross-language runtime on par with LuaJIT and C</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/FastVM/minivm/blob/main/MiniVM.svg"><img src="https://github.com/FastVM/minivm/raw/main/MiniVM.svg" alt="The MiniVM Logo, looks like a brick according to some, some catfood according to others"/></a></p>

<p dir="auto"><a href="https://discord.gg/UyvxuC5W5q" rel="nofollow"><img src="https://camo.githubusercontent.com/0af67951c7d28369dd9b2202a764350faed62e0576517ac0f64f4f28a2d7c4be/68747470733a2f2f696d672e736869656c64732e696f2f646973636f72642f3831343835353831343531343733373135323f6c6f676f3d646973636f726426636f6c6f723d353836354632" alt="Link to Discord" data-canonical-src="https://img.shields.io/discord/814855814514737152?logo=discord&amp;color=5865F2"/></a></p>
<p dir="auto"><strong>MiniVM is a small and fast cross-language Virtual Machine (VM) written in good ol&#39; C</strong>, meaning it can compile and run just about anywhere. Here are a few reasons why MiniVM is pretty neat:</p>
<ul dir="auto">
<li>Built on a register-based ISA that beats luajit—<em>with the JIT on</em>—in some benchmarks. (See the <a href="#benchmarks">benchmarks</a> section below).</li>
<li>Has an efficient GC that can handle large amounts of allocations and deallocations efficiently. (Again, check the benchmarks).</li>
<li>Supports a flexible data model with a number of optimizations to minimize memory usage.</li>
<li>Leverages Cosmopolitan libc + WebAssembly for easy cross platform portability.</li>
<li>... check out the <a href="#some-sweet-deets">details</a> section for more!</li>
</ul>
<p dir="auto">MiniVM is small and flexible enough to run just about any language under the sun (given you&#39;ve taken the time to write a compiler for it). Front ends we&#39;ve experimented with include Lua, Scheme, Paka, and others. You can try out the <a href="https://fastvm.github.io/xori" rel="nofollow">Paka frontend to MiniVM online</a>!</p>
<h2 dir="auto"><a id="user-content-history" aria-hidden="true" href="#history"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>History</h2>
<p dir="auto">This project started as an exploration into what it takes to build a fast interpreter. The first version was blocked out during a single Discord call, and ran a small lisp-like language.</p>
<p dir="auto">This original implementation was a plain stack machine, which, for whatever reason, was a tad faster than it should&#39;ve been. Leveraging this tiny 1,000 LoC base, MiniVM matured into something a bit bigger, but only slightly. It now runs a language close to ASM, and has got quite faster over time. MiniVM&#39;s speed is in no small part due to its architecture. It&#39;s a register/stack machine with carefully-selected opcodes that are designed to work well with common data-access patterns.</p>
<p dir="auto">Above all else, MiniVM is constantly improving every day. We hope you find the journey to be as interesting as the final destination. If you&#39;re interested as to where the project is headed next, ping Shaw (<code>@4984#4984</code>) on <a href="https://discord.gg/UyvxuC5W5q" rel="nofollow">the Discord Server</a>.</p>
<h2 dir="auto"><a id="user-content-some-sweet-deets" aria-hidden="true" href="#some-sweet-deets"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Some Sweet Deets</h2>
<p dir="auto">Below is a small discussion of the architecture of MiniVM, and the emergent properties because of these decisions.</p>
<h3 dir="auto"><a id="user-content-a-register-based-vm" aria-hidden="true" href="#a-register-based-vm"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A Register-Based VM</h3>
<p dir="auto">First and foremost, MiniVM is a register-based VM. This means that instructions are larger and operate on <em>registers</em>, as opposed to the <em>stack</em>. Because of this property, register-based VMs play nicely with modern hardware, and result in less instructions per unit of work done. Consider the following:</p>
<div data-snippet-clipboard-copy-content="while x &lt; 1000 {
  x = x + 1
}"><pre><code>while x &lt; 1000 {
  x = x + 1
}
</code></pre></div>
<p dir="auto">A stack-based VM would have to emit a single instruction for every single little thing done in the loop above. You&#39;d probably end up with something like:</p>
<div data-snippet-clipboard-copy-content="head_of_loop:
  load_var x
  push_int 1000
  less_than
  jump_if_false :end_of_loop
  load_var x
  increment
  store_var x
end_of_loop:"><pre><code>head_of_loop:
  load_var x
  push_int 1000
  less_than
  jump_if_false :end_of_loop
  load_var x
  increment
  store_var x
end_of_loop:
</code></pre></div>
<p dir="auto">This is all well and good, but compare it to what a register-based machine does:</p>
<div data-snippet-clipboard-copy-content="// r0 is where x lives
head_of_loop:
  jump_if_reg_less_than_number r0 1000 :end_of_loop
  increment_reg r0 1
  jump :head_of_loop
end_of_loop:"><pre><code>// r0 is where x lives
head_of_loop:
  jump_if_reg_less_than_number r0 1000 :end_of_loop
  increment_reg r0 1
  jump :head_of_loop
end_of_loop:
</code></pre></div>
<p dir="auto">Although each instruction is a bit more complex, there are way fewer instructions. And this per-instruction complexity isn&#39;t necessarily a bad thing: making instructions more complex offloads work to the host language (C, in this case), which means that the runtime can compile common complex instructions to efficient native code.</p>
<h3 dir="auto"><a id="user-content-on-malloc-and-putchar" aria-hidden="true" href="#on-malloc-and-putchar"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>On <code>malloc</code> and <code>putchar</code></h3>
<p dir="auto">MiniVM&#39;s only dependencies are <a href="https://github.com/FastVM/minivm/blob/main/vm/libc.h">9 functions</a> in <code>libc</code>:</p>
<div data-snippet-clipboard-copy-content="fmod, putchar, malloc, realloc, free, fopen, fclose, fwrite, fread"><pre><code>fmod, putchar, malloc, realloc, free, fopen, fclose, fwrite, fread
</code></pre></div>
<p dir="auto">Only <code>malloc</code> and <code>putchar</code> are relied on heavily, though:</p>
<blockquote>
<p dir="auto"><code>putchar</code> is the function all IO boils down to eventually.
<code>malloc</code> is required for memory allocations as of recent.</p>
<p dir="auto">— Shaw</p>
</blockquote>
<p dir="auto">The entire codebase is highly configurable, allowing users of MiniVM to choose the optimal feature set that supports their application.</p>
<h3 dir="auto"><a id="user-content-types" aria-hidden="true" href="#types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Types</h3>
<p dir="auto">Minivm has a select set of core types.</p>
<ul dir="auto">
<li>none
<ul dir="auto">
<li>the lack of a value</li>
</ul>
</li>
<li>boolean
<ul dir="auto">
<li>true or false</li>
</ul>
</li>
<li>number
<ul dir="auto">
<li>configurable to be C&#39;s <code>int32_t num: 30;</code> or C&#39;s <code>double num;</code></li>
</ul>
</li>
<li>array
<ul dir="auto">
<li>unchanging in length</li>
<li>mutable by default</li>
</ul>
</li>
</ul>
<p dir="auto">Because MiniVM is a register-based machine, it employs clever instructions to leverage common type layouts for better performance. For instance, to emulate closures arrays can be called as functions if the first item in that array is a function.</p>
<h2 dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<p dir="auto">Building from source is pretty simple:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/shawsumma/minivm
cd minivm
make"><pre><code>git clone https://github.com/shawsumma/minivm
cd minivm
make
</code></pre></div>
<p dir="auto">One can also use the artifacts from github actions.</p>
<p dir="auto"><a href="https://github.com/FastVM/minivm/actions">MiniVM Binaries</a> for Linux, MacOS and Windows can be found here. Click the text next to a green check mark and download the linux-opt, macos-opt or windows-opt single file binary.</p>
<h2 dir="auto"><a id="user-content-getting-started" aria-hidden="true" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting Started</h2>
<p dir="auto">MiniVM has a growing and fairly unstable API.
The best way to get familiar with MiniVM and its opcodes is to read through the headers in the <code>vm/</code> directory.</p>
<p dir="auto">The top of the bytecode file is the usual entry point. MiniVM can be built as a library with <code>make VM_MAIN=</code>.</p>
<p dir="auto">The most common way to get code running on MiniVM is to use <a href="https://github.com/fastvm/paka">Paka</a>. For those looking to try paka and minivm online use <a href="https://fastvm.github.io/xori" rel="nofollow">XorI</a>.</p>
<h2 dir="auto"><a id="user-content-benchmarks" aria-hidden="true" href="#benchmarks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Benchmarks</h2>
<p dir="auto">Taking benchmarks is hard. Benchmarks are fraught with peril and don&#39;t always tell the full story: if you want to know how your application will perform in a language, no benchmarks will be a substitute for that. We tried to be fair, methodical, and thorough in our benchmarking; despite this, remember to take these results with a grain of salt.</p>
<p dir="auto">All benchmarks were run in hyperfine on a <code>2020 MacBook Air M1</code> with <code>8GB RAM</code> running <code>Big Sur 11.2.3</code>. The implementations we benchmarked are idiomatic and consistent between target benchmark languages. All benchmarks may be found in the <a href="https://github.com/FastVM/paka/tree/main/bench">Paka repository</a> if you&#39;d like to run them on your machine.</p>
<h3 dir="auto"><a id="user-content-binary-trees-allocations-and-gc" aria-hidden="true" href="#binary-trees-allocations-and-gc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Binary Trees: Allocations and GC</h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/FastVM/minivm/blob/main/tree.png"><img src="https://github.com/FastVM/minivm/raw/main/tree.png" alt="Binary Trees Graph"/></a></p>
<p dir="auto">As you can see, MiniVM (no JIT) beats luajit with the JIT on in this benchmark. MiniVM has a custom-built allocator and GC, which beats out luajit&#39;s slower modified version of <code>malloc</code>. MiniVM also is a hair faster that C for tree sizes above 13 (C is compiled ahead-of time, using <code>clang</code> with the <code>-Ofast</code> flag for best performance). For tree sizes less that 13, beats Node JS due to having a faster startup time. Overall, MiniVM&#39;s performance is about on par with JIT&#39;d and compiled languages on this benchmark.</p>
<p dir="auto">The binary tree benchmark measures the time it takes to create a balanced binary tree of a given depth and sum the values in each node to produce a total for the tree. This measures how well the language runtime handles a large number of repeated allocations and deallocations (no memory pooling is used or allowed).</p>
<h3 dir="auto"><a id="user-content-recursive-fibonacci-functions-and-math" aria-hidden="true" href="#recursive-fibonacci-functions-and-math"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Recursive Fibonacci: Functions and Math</h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/FastVM/minivm/blob/main/fib.png"><img src="https://github.com/FastVM/minivm/raw/main/fib.png" alt="Fibonacci Runtime"/></a></p>
<p dir="auto">As you can see, <code>minivm</code> (no JIT) is a hair slower than Node JS (JIT) but beats <code>luajit --joff</code> by a fair margin (no JIT).</p>
<p dir="auto">The recursive fibonacci benchmark computes <code>fib(35)</code> in a recursive manner (not memoized). This mostly measures the performance of basic mathematical operations and the overhead of function calls. The code for <code>fib</code> in Paka (a minivm frontend) is:</p>
<div data-snippet-clipboard-copy-content="def fib(n) {
    if n &lt; 2 {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}"><pre><code>def fib(n) {
    if n &lt; 2 {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}
</code></pre></div>
<p dir="auto">We compile this Paka straight to minivm bytecode, there isn&#39;t any subsequent optimization of the bytecode by hand.</p>
<h2 dir="auto"><a id="user-content-roadmap" aria-hidden="true" href="#roadmap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Roadmap</h2>
<ul dir="auto">
<li>Write assembler for minivm bytecode.</li>
<li>Reduce dependencies to <code>libc</code> functions.</li>
<li>Add types.</li>
<li>Improve performance.</li>
</ul>
<blockquote>
<p dir="auto">Note: MiniVM is wholly developed by <a href="https://github.com/ShawSumma">Shaw</a> (4984); this README was written by a <a href="https://github.com/slightknack">friend</a> of his who thinks he can be a bit too modest at times.</p>
</blockquote>
</article>
        </div></div>
  </body>
</html>
