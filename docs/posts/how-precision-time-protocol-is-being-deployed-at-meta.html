<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2022/11/21/production-engineering/precision-time-protocol-at-meta/">Original</a>
    <h1>How Precision Time Protocol is being deployed at Meta</h1>
    
    <div id="readability-page-1" class="page"><div>

		<p><span>Implementing Precision Time Protocol (PTP) at Meta allows us to synchronize the systems that drive our products and services down to nanosecond precision. PTP’s predecessor, <a href="https://engineering.fb.com/2020/03/18/production-engineering/ntp-service/" target="_blank" rel="noopener">Network Time Protocol (NTP)</a>, provided us with millisecond precision, but as we scale to more advanced systems on our way to building the next computing platform, the metaverse and AI, we need to ensure that our servers are keeping time as accurately and precisely as possible. With PTP in place, we’ll be able to enhance Meta’s technologies and programs — from communications and productivity to entertainment, privacy, and security — for everyone, across time zones and around the world.</span></p>
<p><span>The journey to PTP has been years long, as we’ve had to rethink how both the timekeeping hardware and software operate within our servers and data centers. </span></p>
<p><span>We are sharing a deep technical dive into our PTP migration and our innovations that have made it possible</span></p>

<h2 id="case;"><span>The case for PTP</span></h2>
<p><span>Before we dive into the PTP architecture, let’s explore a simple use case for extremely accurate timing, for the sake of illustration.</span></p>
<p><span>Imagine a situation in which a client writes data and immediately tries to read it. In large distributed systems, chances are high that the write and the read will land on different back-end nodes.</span></p>
<p><span>If the read is hitting a remote replica that doesn’t yet have the latest update, there is a chance the user will not see their own write:</span></p>
<figure id="attachment_19691" aria-describedby="caption-attachment-19691"><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="532" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?resize=916,476 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?resize=768,399 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?resize=1024,532 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?resize=1536,798 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?resize=96,50 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-2.jpg?resize=192,100 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19691">Schematic representation of read returning outdated information</figcaption></figure>
<p><span>This is annoying at the very least, but more important is that this is violating a </span><i><span>linearizability</span></i><span> guarantee that allows for interaction with a distributed system in the same way as with a single server.</span></p>
<p><span>The typical way to solve this is to issue multiple reads to different replicas and wait for a quorum decision. This not only consumes extra resources but also significantly delays the read because of the long network round-trip delay.</span></p>
<p><span>Adding precise and reliable timestamps on a back end and replicas allows us to simply wait until the replica catches up with the read timestamp:</span></p>
<figure id="attachment_19690" aria-describedby="caption-attachment-19690"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="532" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?resize=916,476 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?resize=768,399 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?resize=1024,532 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?resize=1536,798 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?resize=96,50 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-1-1.jpg?resize=192,100 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19690">Schematic representation of a commit-wait ensuring consistency guarantee (linearizability).</figcaption></figure>
<p><span>This not only speeds up the read but also saves tons of compute power.</span></p>
<p><span>A very important condition for this design to work is that all clocks be in sync or that the offset between a clock and the source of time be known. The offset, however, changes because of constant correction, drifting, or simple temperature variations. For that purpose, we use the notion of a Window of Uncertainty (WOU), where we can say with a high probability where the offset is. In this particular example, the read should be blocked until the </span><i><span>read timestamp</span></i><span> plus WOU.</span></p>
<p><span>One could argue that we don’t really need PTP for that. NTP will do just fine. Well, we thought that too. But experiments we ran comparing our </span><a href="https://engineering.fb.com/2020/03/18/production-engineering/ntp-service/" target="_blank" rel="noopener"><span>state-of-the-art NTP</span></a><span> implementation and an early version of PTP showed a roughly 100x performance difference:</span></p>
<figure id="attachment_19692" aria-describedby="caption-attachment-19692"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="624" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?resize=916,558 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?resize=768,468 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?resize=1024,624 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?resize=1536,936 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?resize=96,59 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-2.jpg?resize=192,117 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19692">Commit-wait reads issued against PTP- and NTP-backed clusters.</figcaption></figure>
<p><span>There are several additional use cases, including event tracing, cache invalidation, privacy violation detection improvements, latency compensation in the metaverse, and simultaneous execution in AI, many of which will greatly reduce hardware capacity requirements. This will keep us busy for years ahead.</span></p>
<p><span>Now that we are on the same page, let’s see how we deployed PTP at Meta scale.</span></p>
<h2 id="architecture"><span>The PTP architecture</span></h2>
<figure id="attachment_19693" aria-describedby="caption-attachment-19693"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="722" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?resize=916,645 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?resize=768,541 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?resize=1024,722 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?resize=1536,1082 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?resize=96,68 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-3.jpg?resize=192,135 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19693">Regional PTP architecture.</figcaption></figure>
<p><span>After several reliability and operational reviews, we landed on a design that can be split into three main components: the PTP rack, the network, and the client.</span></p>
<p><span>Buckle up — we are going for a deep dive.</span></p>
<h2 id="rack"><span>The PTP rack</span></h2>
<p><span>This houses the hardware and software that serves time to clients; the rack consists of multiple critical components, each of which has been carefully selected and tested.</span></p>
<h3><span>The antenna</span></h3>
<p><span>The GNSS antenna is easily one of the least appreciated components. But this is the place where </span><i><span>time </span></i><span>originates, at least on Earth. </span></p>
<p><span>We’re striving for nanosecond accuracy. And if the GNSS receiver can’t accurately determine the position, it will not be able to calculate time. We have to strongly consider the signal-to-noise ratio (SNR). A low-quality antenna or obstruction to the open sky can result in a high 3D location standard deviation error. For time to be determined extremely accurately, GNSS receivers should enter a so-called time mode, which typically requires a &lt;10m 3D error.</span></p>
<p><span>It’s absolutely essential to ensure an open sky and install a solid stationary antenna. We also get to enjoy some beautiful views:</span></p>
<figure id="attachment_19705" aria-describedby="caption-attachment-19705"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="589" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg 1999w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?resize=916,527 916w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?resize=768,441 768w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?resize=1024,589 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?resize=1536,883 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?resize=96,55 96w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-Antenna.jpg?resize=192,110 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19705">GNSS antenna in a Meta data center location.</figcaption></figure>
<p><span>While we were testing different antenna solutions, a relatively new GNSS-over-fiber technology got our attention. It’s free from almost all disadvantages — it doesn’t conduct electricity because it’s powered by a laser via optical fiber, and the signal can travel several kilometers without amplifiers. </span></p>
<p><span>Inside the building, it can use pre-existing structured fiber and LC patch panels, which significantly simplifies the distribution of the signal. In addition, the signal delays for optical fiber are well defined at approximately 4.9ns per meter. The only thing left is the delay introduced by the direct RF to laser modulation and the optical splitters, which are around 45ns per box.</span></p>
<figure id="attachment_19706" aria-describedby="caption-attachment-19706"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?w=1024" alt="PTP" width="1024" height="405" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg 1994w, https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?resize=916,362 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?resize=768,304 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?resize=1024,405 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?resize=1536,608 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?resize=96,38 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Huber-Suhner-GNSS-e1668636395434.jpg?resize=192,76 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19706">Huber-Suhner GNSS-over-fiber technology tested in Meta’s Dublin office.</figcaption></figure>
<p><span>By conducting tests, we confirmed that the end-to-end antenna delay is deterministic (typically about a few hundred nanoseconds) and can easily be compensated on the Time Appliance side.</span></p>
<h3><span>Time Appliance</span></h3>
<p><span>The Time Appliance is the heart of the timing infrastructure. This is where time originates from the data center infrastructure point of view. In 2021, we </span><a href="https://engineering.fb.com/2021/08/11/open-source/time-appliance/" target="_blank" rel="noopener"><span>published an article</span></a><span> explaining why we developed a new Time Appliance and why existing solutions wouldn’t cut it.</span></p>
<p><span>But this was mostly in the context of NTP. PTP, on the other hand, brings even higher requirements and tighter constraints. Most importantly, we made a commitment to reliably support up to 1 million clients per appliance without hurting accuracy and precision. To achieve this, we took a critical look at many of the traditional components of the Time Appliance and thought really hard about their reliability and diversity.</span></p>
<h4><span>The Time Card</span></h4>
<figure id="attachment_19707" aria-describedby="caption-attachment-19707"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?w=1024" alt="PTP Time Card" width="1024" height="768" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png 1999w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?resize=916,687 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?resize=768,576 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?resize=1024,768 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?resize=1536,1153 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?resize=96,72 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card.png?resize=192,144 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19707">Time Card.</figcaption></figure>
<p><span>To protect our infrastructure from a critical bug or a malicious attack,we decided to start diversification from the source of time — the Time Card. Last time, we spoke a lot about the </span><a href="https://engineering.fb.com/2021/08/11/open-source/time-appliance/" target="_blank" rel="noopener"><span>Time Card design</span></a><span> and the advantages of an FPGA-based solution. Under the Open Compute Project (OCP), we are collaborating with vendors such as </span><a href="https://www.orolia.com/about-the-atomic-reference-time-card-art-card/" target="_blank" rel="noopener"><span>Orolia</span></a><span>, Meinberg, Nvidia, Intel, Broadcom, and ADVA, which are all implementing their own time cards, matching the OCP specification.</span></p>
<h5><span>Oscillatord</span></h5>
<p><span>The Time Card is a critical component that requires special configuration and monitoring. For this purpose, we worked with Orolia to develop a </span><a href="https://github.com/Orolia2s/oscillatord/" target="_blank" rel="noopener"><span>disciplining software</span></a><span>, called oscillatord, for different flavors of the Time Cards. This has become the default tool for:</span></p>
<ul>
<li aria-level="1"><b>GNSS receiver configuration: </b><span>setting the default config, and adjusting special parameters like antenna delay compensation. It also allows the disabling of any number of GNSS constellations to simulate a holdover scenario.</span></li>
<li aria-level="1"><b>GNSS receiver monitoring:</b><span> reporting number of satellites, GNSS quality, availability of different constellations, antenna status, </span><a href="https://engineering.fb.com/2022/07/25/production-engineering/its-time-to-leave-the-leap-second-in-the-past/" target="_blank" rel="noopener"><span>leap second</span></a><span>, etc.</span></li>
<li aria-level="1"><b>Atomic clock configuration:</b><span> Different atomic clocks require different configuration and sequence of events. For example, it supports SA53 TAU configuration for fast disciplining, and with mRO-50, it supports a temperature-to-frequency relation table.</span></li>
<li aria-level="1"><b>Atomic clock monitoring:</b><span> Parameters such as a laser temperature and lock have to be monitored thoroughly, and fast decisions must be made when the values are outside of operational range.</span></li>
</ul>
<p><span>Effectively, the data exported from </span><span>oscillatord</span><span> allows us to decide whether the Time Appliance should take traffic or should be drained.</span></p>
<h4><span>Network card</span></h4>
<p><span>Our ultimate goal is to make protocols such as PTP propagate over the packet network. And if the Time Card is the beating heart of the Time Appliance, the network card is the face. Every time-sensitive PTP packet gets hardware timestamped by the NIC. This means the PTP Hardware Clock (PHC) of the NIC must be accurately disciplined.</span></p>
<p><span>If we simply copy the clock values from Time Card to the NIC, using the </span><span>phc2sys</span><span> or a similar tool, the accuracy will not be nearly enough. In fact, our experiments show that we would easily lose ~1–2 microseconds while going through PCIe, CPU, NUMA, etc. The performance of synchronization over PCIe bus will dramatically improve with the emerging </span><a href="https://www.intel.com/content/www/us/en/docs/programmable/683140/21-4-4-0-0/precision-time-measurement-ptm-58323.html" target="_blank" rel="noopener"><span>Precision Time Measurement</span></a><span> (PTM) technology, as the development and support for various peripherals with this capability is in progress.</span></p>
<p><span>For our application, since we use NICs with PPS-in capabilities, we employed </span><span><span>ts2phc</span>,</span><span> which copies clock values at first and then aligns the clock edges based on a pulse per second (PPS) signal. This requires an additional cable between the PPS output of the Time Card and the PPS input of the NIC, as shown in the picture below.</span></p>
<figure id="attachment_19708" aria-describedby="caption-attachment-19708"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?w=1024" alt="PTP" width="1024" height="768" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png 1999w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?resize=916,687 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?resize=768,576 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?resize=1024,768 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?resize=1536,1153 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?resize=96,72 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Time-Card-PPS-in-out.png?resize=192,144 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19708">Short cable between PPS-out of the Time Card and PPS-in of the NIC.</figcaption></figure>
<p><span>We constantly monitor offset and make sure it never goes out of a ±50ns window between the Time Card and the NIC:</span></p>
<figure id="attachment_19694" aria-describedby="caption-attachment-19694"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="563" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?resize=916,504 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?resize=768,422 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?resize=1024,563 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?resize=1536,845 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?resize=96,53 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-8.jpg?resize=192,106 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19694">Offset between the Time Card and the Network Card PHC.</figcaption></figure>
<p><span>We also monitor the PPS-out interface of the NIC to act as a fail-safe and ensure that we actually know what’s going on with the PHC on the NIC.</span></p>
<h4><span>ptp4u</span></h4>
<p><span>While evaluating different preexisting PTP server implementations, we experienced scalability issues with both open source and closed proprietary solutions, including the FPGA-accelerated PTP servers we evaluated. At best, we could get around 50K clients per server. At our scale, this means we would have to deploy many racks full of these devices.</span></p>
<p><span>Since PTP’s secret sauce is the use of hardware timestamps, the server implementation doesn’t have to be a highly optimized C program or even an FPGA-accelerated appliance.</span></p>
<p><span>We implemented a scalable PTPv2 unicast PTP server in Go, which we named </span><a href="https://ptp4u.com" target="_blank" rel="noopener"><span>ptp4u</span></a><span>, and open-sourced it on GitHub. With some minor optimizations, we were able to support over 1 million concurrent clients per device, which was independently verified by an IEEE 1588v2 certified device.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?w=1024" alt="" width="1024" height="559" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png 1999w, https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?resize=916,500 916w, https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?resize=768,420 768w, https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?resize=1024,559 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?resize=1536,839 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?resize=96,52 96w, https://engineering.fb.com/wp-content/uploads/2022/11/ptp4u.png?resize=192,105 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>This was possible through the simple but elegant use of channels in Go that allowed us to pass subscriptions around between multiple powerful workers.</span></p>
<p><span>Because </span><span>ptp4u</span><span> runs as a process on a Linux machine, we automatically get all the benefits, like IPv6 support, firewall, etc., for free.</span></p>
<h4><span>c4u</span></h4>
<p>The <span>ptp4u</span> server has many configuration options, allowing it to pass dynamically changing parameters such as <strong>PTP Clock Accuracy</strong>, <strong>PTP Clock Class,</strong> and a <strong>UTC offset</strong> — that is currently set to 37 seconds (<a href="https://engineering.fb.com/2022/07/25/production-engineering/its-time-to-leave-the-leap-second-in-the-past/" target="_blank" rel="noopener">we’re  looking forward this becoming a constant</a>) — down to clients.</p>
<p><span>In order to frequently generate these parameters, we implemented a separate service called </span><span>c4u</span><span>, which constantly monitors several sources of information and compiles the active config for <span>ptp4u</span>:</span></p>
<figure><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="519" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?resize=916,465 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?resize=768,390 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?resize=1024,519 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?resize=1536,779 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?resize=96,49 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-10.jpg?resize=192,97 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption>Schematic representation of the c4u architecture.</figcaption></figure>
<p><span>This gives us flexibility and reactivity if the environment changes. For example, if we lose the GNSS signal on one of the Time Appliances, we will switch the </span><b>ClockClass</b><span> to HOLDOVER and clients will immediately migrate away from it. It is also calculating </span><b>ClockAccuracy</b><span> from many different sources, such as </span><span>ts2phc</span><span> synchronization quality, atomic clock status, and so on.</span></p>
<p><span>We calculate the UTC offset value based on the content of the </span><span>tzdata</span><span> package because we pass International Atomic Time (TAI) down to the clients.</span></p>
<h3><span>Calnex Sentinel</span></h3>
<p><span>We wanted to make sure our Time Appliances are constantly and independently assessed by a well-established certified monitoring device. Luckily, we’ve already made a lot of progress in the </span><a href="https://engineering.fb.com/2020/03/18/production-engineering/ntp-service/" target="_blank" rel="noopener"><span>NTP space</span></a><span> with </span><a href="https://info.calnexsol.com/acton/attachment/28343/f-e48ddd90-0ee7-4646-b5b3-cc26f9dca22d/1/-/-/-/-/CX9037v1.0%20-%20Sentinel%20Case%20Study-Facebook.pdf" target="_blank" rel="noopener"><span>Calnex</span></a><span>, and we were in a position to apply a similar approach to  PTP.</span></p>
<p><span>We collaborated with Calnex to take their field device and repurpose it for data center use, which involved changing the physical form factor and adding support for features such as IPv6.</span></p>
<figure id="attachment_19710" aria-describedby="caption-attachment-19710"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?w=1024" alt="PTP" width="1024" height="266" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png 1742w, https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?resize=916,238 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?resize=768,199 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?resize=1024,266 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?resize=1536,399 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?resize=96,25 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Calnex-Sentinel-20.png?resize=192,50 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19710">Calnex Sentinel 2.0 installed in the PTP rack.</figcaption></figure>
<p><span>We connect the Time Appliance NIC PPS-out to the Calnex Sentinel, which allows us to monitor the PHC of the NIC with nanosecond accuracy.</span><span><br/>
</span></p>
<p><span>We will explore monitoring in great detail in “How we monitor the PTP architecture,” below. </span></p>
<h2 id="network"><span>The PTP network</span></h2>
<h3><span>PTP protocol</span></h3>
<p><span>The PTP protocol supports the use of both unicast and multicast modes for the transmission of PTP messages. For large data center deployments, unicast is preferred over multicast because it significantly simplifies network design and software requirements.</span></p>
<p><span>Let’s take a look at a typical PTP unicast flow:</span></p>
<p><span>A client starts the negotiation (requesting unicast transmission). Therefore, it must send: </span></p>
<ul>
<li aria-level="1"><span>A </span><b>Sync Grant Request</b><span> (“Hey server, please send me </span><i><span>N</span></i> <b>Sync</b><span> and </span><b>Follow-Up</b><span> messages per second with the current time for the next </span><i><span>M</span></i><span> minutes”)</span></li>
<li aria-level="1"><span>An </span><b>Announce Grant Request</b><span> (“Hey server, please send me </span><i><span>X</span></i> <b>Announce</b><span> messages per second with your status for the next </span><i><span>Y</span></i><span> minutes”)</span></li>
<li aria-level="1"><span>A </span><b>Delay Response Grant Request</b><span> (“Hey server, I am going to send you </span><b>Delay Requests</b><span> — please respond with </span><b>Delay Response</b><span> packets for the next </span><i><span>Z</span></i><span> minutes”)</span></li>
</ul>
<ol start="2">
<li><span> The server needs to grant these requests and send grant responses. </span></li>
<li><span> Then the server needs to start executing subscriptions and sending PTP messages. </span></li>
</ol>
<ul>
<li aria-level="1"><span>All subscriptions are independent of one another.</span></li>
<li aria-level="1"><span>It’s on the server to obey the send interval and terminate the subscription when it expires. (PTP was originally multicast only, and one can clearly see the multicast origin in this design).</span></li>
<li aria-level="1"><span>In two-step configuration, when the server sends Sync messages, it has to read the TX hardware timestamp and send a Follow-Up message containing that timestamp.</span></li>
</ul>
<ol start="4">
<li><span> The client will send Delay Requests within the agreed-upon interval to determine the path delay. The server needs to read the RX hardware timestamp and return it to the client.</span></li>
<li><span> The client needs to periodically refresh the grant, and the process repeats.</span></li>
</ol>
<p><span>Schematically (just for the illustration), it will look like this:</span></p>
<figure id="attachment_19696" aria-describedby="caption-attachment-19696"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="563" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?resize=916,503 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?resize=768,422 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?resize=1024,563 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?resize=1536,844 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?resize=96,53 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-12.jpg?resize=192,106 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19696">Schematic representation of the two-step PTP exchange.</figcaption></figure>
<h3><span>Transparent clocks</span></h3>
<p><span>We initially considered leveraging boundary clocks in our design. However, boundary clocks come with several disadvantages and complications:</span></p>
<ul>
<li aria-level="1"><span>You need network equipment or some special servers to act as a boundary clock. </span></li>
<li aria-level="1"><span>A boundary clock acts as a time server, creating greater demand for short-term stability and holdover performance.</span></li>
<li aria-level="1"><span>Since the information has to pass through the boundary clocks f</span><span>rom the time servers down to the clients, we would have to implement special support for this. </span></li>
</ul>
<p><span>To avoid this additional complexity, we decided to rely solely on PTP transparent clocks.</span></p>
<p><span>Transparent clocks (TCs) enable clients to account for variations in network latency, ensuring a much more precise estimation of clock offset. Each data center switch in the path between client and time server reports the time each PTP packet spends transiting the switch by updating a field in the packet payload, the aptly named Correction Field (CF).</span></p>
<p><span>PTP clients (also referred to as ordinary clocks, or OCs) calculate network mean path delay and clock offsets to the time servers (grandmaster clocks, or GMs) using four timestamps (T1, T2, T3, and T4) and two correction field values (CFa and CFb), as shown in the diagram below:</span></p>
<figure><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="651" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?resize=916,583 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?resize=768,488 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?resize=1024,651 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?resize=1536,977 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?resize=96,61 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-13.jpg?resize=192,122 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption>Schematic representation of the transparent clock and correction field.</figcaption></figure>
<ul>
<li aria-level="1"><span>T1 is the hardware timestamp when the SYNC packet is sent by the Time Server.</span></li>
<li aria-level="1"><span>T2 is the hardware timestamp when the OC receives the SYNC packet.</span></li>
<li aria-level="1"><span>CFa is the sum of the switch delays recorded by each switch (TC) in the path from time server to the client (for SYNC packet).</span></li>
<li aria-level="1"><span>T3 is the hardware timestamp the delay request is sent by the Client.</span></li>
<li aria-level="1"><span>T4 is the hardware timestamp when the time server receives the delay request.</span></li>
<li aria-level="1"><span>CFb is the sum of the switch delays recorded by each switch in the path from the Client to the time server (for Delay Request packet).</span></li>
</ul>
<p><span>To understand the impact of just one disabled transparent clock on the way between client and a server, we can examine the logs:</span></p>

<p><span>We can see the path delay explodes, sometimes even becoming negative which shouldn’t happen during normal operations. This has a dramatic impact on the offset, moving it from ±100 nanoseconds to -400 microseconds (over 4000 times difference). And the worst thing of all, this offset will not even be accurate, because the mean path delay calculations are incorrect.</span></p>
<p><span>According to our experiments, modern switches with large buffers can delay packets for up to a couple of milliseconds which will result in hundreds of microseconds of a path delay calculation error. This will drive the offset spikes and will be clearly visible on the graphs:</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?w=1024" alt="" width="1024" height="687" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?resize=916,614 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?resize=768,515 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?resize=1024,687 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?resize=1536,1030 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?resize=96,64 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-14.jpg?resize=192,129 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>The bottom line is that running PTP in datacenters in the absence of TCs leads to unpredictable and unaccountable asymmetry in the roundtrip time. And the worst of all – there will be no simple way to detect this. 500 microseconds may not sound like a lot, but when customers expect a WOU to be several microseconds, this may lead to an SLA violation.</span></p>
<h2 id="client"><span>The PTP Client</span></h2>
<h3><span>Timestamps</span></h3>
<p><span>Timestamping the incoming packet is a relatively old feature supported by the Linux kernel for decades. For example software (kernel) timestamps have been used by </span><a href="https://engineering.fb.com/2020/03/18/production-engineering/ntp-service/" target="_blank" rel="noopener"><span>NTP daemons for years</span></a><span>. It’s important to understand that timestamps are not included into the packet payload by default and if required, must be placed there by the user application.</span></p>
<p><span>Reading RX timestamp from the user space is a relatively simple operation. When packet arrives, the network card (or a kernel) will timestamp this event and include the timestamp into the </span><a href="https://github.com/facebook/time/blob/96b6a006d4c6244c71932e1b26064347deb614ce/timestamp/timestamp_linux.go#L50" target="_blank" rel="noopener"><span>socket control message</span></a><span>, which is easy to get along with the packet itself by </span><a href="https://github.com/facebook/time/blob/5a5e9af8c7c00dd72a640c0392dd85e50f92eb7d/timestamp/timestamp_linux.go#L187" target="_blank" rel="noopener"><span>calling</span></a><span> a </span><span>recvmsg</span><span> syscall with </span><span>MSG_ERRQUEUE</span><span> flag set.</span></p>
<table>
<caption>A very rough representation of a socket control message containing timestamps.</caption>
<tbody>
<tr>
<td><b>128 bits</b></td>
<td><b>64 bits</b></td>
<td><b>64 bits</b></td>
<td><b>64 bits</b></td>
</tr>
<tr>
<td><span>Socket control message header</span></td>
<td><span>Software Timestamp</span></td>
<td><span>Legacy Timestamp</span></td>
<td><span>Hardware Timestamp</span></td>
</tr>
</tbody>
</table>
<p><span>For the TX Hardware timestamp it’s a little more complicated. When </span><span>sendto</span><span> syscall is executed it doesn’t lead to an immediate packet departure and neither to a TX timestamp generation. In this case the user has to </span><a href="https://github.com/facebook/time/blob/5a5e9af8c7c00dd72a640c0392dd85e50f92eb7d/timestamp/timestamp_linux.go#L173" target="_blank" rel="noopener"><span>poll the socket</span></a><span> until the timestamp is accurately placed by the kernel. Often we have to wait for several milliseconds which naturally limits the send rate.</span></p>
<p><span>Hardware timestamps are the secret sauce that makes PTP so precise. Most of the modern NICs already have hardware timestamps support where the network card driver populates the corresponding section. </span></p>
<p><span>It’s very easy to verify the support by running the </span><span>ethtool</span><span> command:</span></p>
<pre><code>$ ethtool -T eth0
Time stamping parameters for eth0:
Capabilities:
	hardware-transmit
	hardware-receive
	hardware-raw-clock
PTP Hardware Clock: 0
Hardware Transmit Timestamp Modes:
	off
	on
Hardware Receive Filter Modes:
	none
	All
</code></pre>
<p><span>It’s still possible to use PTP with software (kernel) timestamps, but there won’t be any strong guarantees on their quality, precision, and accuracy.</span></p>
<p><span>We evaluated this possibility as well and even considered implementing a change in the kernel for “faking” the hardware timestamps with software where hardware timestamps are unavailable. However, on a very busy host we observed the precision of software timestamps jumped to hundreds of microseconds and we had to abandon this idea.</span></p>
<h3><span>ptp4l</span></h3>
<p><span>ptp4l</span><span> is an open source software capable of acting as both a PTP client and a PTP server. While we had to implement our own PTP server solution for performance reasons, we decided to stick with </span><span>ptp4l</span><span> for the client use case.</span></p>
<p><span>Initial tests in the lab revealed that </span><span>ptp4l</span><span> can provide excellent synchronization quality out of the box and align time on the PHCs in the local network down to tens of nanoseconds.</span></p>
<p><span>However, as we started to scale up our setup some issues started to arise.</span></p>
<h4><span>Edge cases</span></h4>
<p><span>In one particular example we started to notice occasional “spikes” in the offset. After a deep dive we identified fundamental hardware limitations of one of the most popular NICs on the market:</span></p>
<ul>
<li aria-level="1"><span>The NIC has only a timestamp buffer for 128 packets.</span></li>
<li aria-level="1"><span>The NIC is unable to distinguish between PTP packets (which need a hardware timestamp) and other packets which don’t.</span></li>
</ul>
<p><span>This ultimately led to the legitimate timestamps being displaced by timestamps coming from other packets. But what made things a lot worse – the NIC driver tried to be overly clever and placed the software timestamps in the hardware timestamp section of the socket control message without telling anyone.</span></p>
<p><span>It’s a fundamental hardware limitation affecting a large portion of the fleet which is impossible to fix.</span></p>
<p><span>We had to implement an </span><i><span>offset outliers filter</span></i><span>, which changed the behavior of PI servo and made it stateful. It resulted in occasional outliers being discarded and the mean frequency set during the micro-holdover:</span></p>

<p><span>If not for this filter, ptp4l would have steered PHC frequency really high, which would result in several seconds of oscillation and bad quality in the Window of Uncertainty we generate from it.</span></p>
<p><span>Another issue arose from the design of BMCA. The purpose of this algorithm is to select the best Time Appliance when there  are several to choose from in the </span><span>ptp4l.conf</span><span>. It does by comparing  several attributes supplied by Time Servers in Announce messages:</span></p>
<ol>
<li aria-level="1"><span>Priority 1</span></li>
<li aria-level="1"><span>Clock Class</span></li>
<li aria-level="1"><span>Clock Accuracy</span></li>
<li aria-level="1"><span>Clock Variance</span></li>
<li aria-level="1"><span>Priority 2</span></li>
<li aria-level="1"><span>MAC Address</span></li>
</ol>
<p><span>The problem manifests itself when all aforementioned attributes are the same. BMCA uses Time ApplianceMAC address as the tiebreaker which means under normal operating conditions one Time Server will attract all client traffic.</span></p>
<p><span>To combat this, we introduced a so-called “sharding” with different PTP clients being allocated to different sub-groups of Time Appliances from the entire pool.</span></p>
<figure id="attachment_19699" aria-describedby="caption-attachment-19699"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="351" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?resize=916,314 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?resize=768,264 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?resize=1024,351 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?resize=1536,527 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?resize=96,33 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-15.jpg?resize=192,66 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19699">Schematic representation of sharding.</figcaption></figure>
<p><span>This only partially addressed the issue with one server in each subgroup taking the entire load for that grouping. The solution was to enable clients to express a preference, and so we introduced </span><b>Priority3</b><span> into the selection criteria just above the MAC address tiebreaker.  This means that clients configured to use the same Time Appliances can prefer different servers.</span></p>
<p><span>Client 1:</span></p>
<p><span>[unicast_master_table]</span></p>
<p><span>UDPv6 time_server1 1</span></p>
<p><span>UDPv6 time_server2 2</span></p>
<p><span>UDPv6 time_server3 3</span></p>
<p><span>Client 2:</span></p>
<p><span>[unicast_master_table]</span></p>
<p><span>UDPv6 time_server2 1</span></p>
<p><span>UDPv6 time_server3 2</span></p>
<p><span>UDPv6 time_server1 3</span></p>
<p><span>This ensures we can distribute load evenly across all Time Appliances under normal operating conditions.</span></p>
<p><span>Another major challenge we faced was ensuring PTP worked with </span><a href="https://engineering.fb.com/2016/03/09/data-center-engineering/facebook-s-new-front-end-server-design-delivers-on-performance-without-sucking-up-power/" target="_blank" rel="noopener"><span>multi-host NICs</span></a><span> – multiple hosts sharing the same physical network interface and therefore a single PHC. However, </span><span>ptp4l</span><span> has no knowledge of this and tries to discipline the PHC like there are no other neighbors.</span></p>
<p><span>Some NIC manufacturers developed a so-called “free running” mode where </span><span>ptp4l</span><span> is just  disciplining the formula inside the kernel driver. The actual PHC is not affected and keeps running free. This mode results in a slightly worse precision, but it’s completely transparent to </span><span>ptp4l</span><span>. </span></p>
<p><span>Other NIC manufacturers only support a “real time clock” mode, when the first host to grab the lock actually disciplines the PHC. The advantage here is a more precise calibration and higher quality holdover, but it leads to a separate issue with </span><span>ptp4l</span><span> running on the other hosts using the same NIC as attempts to tune PHC frequency have no impact, leading to inaccurate clock offset and frequency calculations.</span></p>
<h4><span>PTP profile</span></h4>
<p><span>To describe the datacenter configuration, we’ve developed and </span><a href="https://github.com/opencomputeproject/Time-Appliance-Project/tree/master/DC-PTP-Profile" target="_blank" rel="noopener"><span>published</span></a><span> a PTP profile, which reflects the aforementioned edge cases and many more.</span></p>
<h4><span>Alternative PTP clients</span></h4>
<p><span>We are evaluating the possibility of using an alternative PTP client. Our main criteria are:</span></p>
<ul>
<li aria-level="1"><span>Support our PTP profile</span></li>
<li aria-level="1"><span>Meets our synchronization quality requirements</span></li>
<li aria-level="1"><span>Open source</span></li>
</ul>
<p><span>We are evaluating the </span><a href="https://timebeat.app/" target="_blank" rel="noopener"><span>Timebeat</span></a><span> PTP client and, so far, it looks very promising.</span></p>
<h4><span>Continuously incrementing counter</span></h4>
<p><span>In the PTP protocol, it doesn’t really matter what time we propagate as long as we pass a UTC offset down to the clients. In our case, it’s International Atomic Time (TAI), but some people may choose UTC. We like to think about the time we provide as a continuously incrementing counter.</span></p>
<p><span>At this point we are not disciplining the system clock and </span><span>ptp4l</span><span> is solely used to discipline the NIC’s PHC.</span></p>
<h3><span>fbclock</span></h3>
<p><span>Synchronizing PHCs across the fleet of servers is good, but it’s of no benefit unless there is a way to read and manipulate these numbers on the client.</span></p>
<p><span>For this purpose, we developed a simple and lightweight API called </span><a href="https://github.com/facebook/time/tree/main/fbclock" target="_blank" rel="noopener"><span>fbclock</span></a><span> that gathers information from PHC and </span><span>ptp4l</span><span> and exposes easy digestible </span><b>Window Of Uncertainty</b><span> information:</span></p>
<figure><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png?w=1024" alt="" width="1024" height="551" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png 1296w, https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png?resize=916,493 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png?resize=768,413 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png?resize=1024,551 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png?resize=96,52 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Fbclock-architecture.png?resize=192,103 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption>Fbclock architecture</figcaption></figure>

<p><span>Through a very efficient </span><span><span>ioctl</span> <span>PTP_SYS_OFFSET_EXTENDED</span></span><span>, </span><span>fbclock</span><span> gets a current timestamps from the PHC, latest data from </span><span>ptp4l</span><span> and then applies math formula to calculate the Window Of Uncertainty (WOU):</span></p>
<pre><code>$ ptpcheck fbclock
{&#34;earliest_ns&#34;:1654191885711023134,&#34;latest_ns&#34;:1654191885711023828,&#34;wou_ns&#34;:694}
</code></pre>
<p><span>As you may see, the API doesn’t return the current time (aka </span><span><span>time.Now()</span>)</span><span>. Instead, it returns a </span><i><span>window of time</span></i><span> which contains the actual time with a very high degree of probability In this particular example, we know our Window Of Uncertainty is 694 nanoseconds and the time is between </span><span>(TAI) Thursday June 02 2022 17:44:08:711023134</span><span> and </span><span>Thursday June 02 2022 17:44:08:711023828.</span></p>
<p><span>This approach allows customers to wait until the interval is passed to ensure exact transaction ordering.</span></p>
<h4><span>Error bound measurement</span></h4>
<p><span>Measuring the precision of the time or (Window Of Uncertainty) means that alongside the delivered time value, a window (a plus/minus value) is presented that is guaranteed to include the </span><i><span>true time</span></i><span> to a high level of certainty. </span></p>
<p><span>How certain we need to be is determined by how critical it is that the time be correct and this is driven by the specific application.</span></p>
<p><span>In our case, this certainty needs to be better than 99.9999% (6-9s). At this level of reliability you can expect less than 1 error in 1,000,000 measurements.</span></p>
<p><span>The error rate estimation uses observation of the history of the data (histogram) to fit a probability distribution function (PDF). From the probability distribution function one can calculate the variance (take a root square and get the standard deviation) and from there it will be simple multiplication to get to the estimation of the distribution based on its value.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="320" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?resize=916,286 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?resize=768,240 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?resize=1024,320 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?resize=1536,480 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?resize=96,30 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-17.jpg?resize=192,60 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>Below is a histogram taken from the offset measurement from </span><span>ptp4l</span><span> running on the ordinary clock.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png?w=1024" alt="" width="1024" height="600" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png 1242w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png?resize=916,537 916w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png?resize=768,450 768w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png?resize=1024,600 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png?resize=96,56 96w, https://engineering.fb.com/wp-content/uploads/2022/11/PTP-histogram.png?resize=192,113 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>To estimate the total variance (E2E) it is necessary to know the variance of the time error accumulated by the time server all the way to the end node NIC. This includes GNSS, atomic clock, and Time Card PHC to NIC PHC (</span><span>ts2phc</span><span>). The manufacturer provides the GNSS error variance. In the case of the UBX-F9T it is about 12 nanoseconds. For the atomic clock the value depends on the disciplining threshold that we’ve set. The tighter the disciplining threshold, the smaller offset variance but lower holdover performance. At the time of running this experiment, the error variance of the atomic clock has been measured to 43ns (standard deviation, std). Finally, the tool ts2phc increases the variance by 30ns (std) resulting in a total variance of 52ns.</span></p>
<p><span>The observed results matches the calculated variance obtained by the “Sum of Variance Law.”</span></p>
<p><img decoding="async" src="https://latex.codecogs.com/gif.latex?%5Clarge%20%5Ctext%7BVar%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cchi%20_%7Bi%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Ctext%7BVar%7D%28%5Cchi%20_%7Bi%7D%29"/></p>
<p><span>According to the sum of variance law, all we need to do is to add all the variance. In our case, we know that the total observer E2E error (measured via the Calnex Sentinel) is about 92ns.</span></p>
<p><span>On the other hands for our estimation, we can have the following:</span></p>
<p><span>Estimated E2E Variance = [GNSS Variance + MAC Variance + ts2phc Variance] + [PTP4L Offset Variance] = [Time Server Variance] + [Ordinary Clock Variance]</span></p>
<p><span>Plugging in the values:</span></p>
<p><span>Estimated E2E Variance = (12ns <sup>2</sup>) + (43ns<sup>2</sup>) + (52ns<sup>2</sup>) + (61ns<sup>2</sup>) = 8418, which corresponds to 91.7ns</span></p>
<p><span>These results show that by propagating the error variance down the clock tree, the E2E error variance can be estimated with a good accuracy. The E2E error variance can be used to calculate the Window Of Uncertainty (WOU) based on the following table.</span></p>
<p><span>Simply, by multiplying the estimated E2E error variance in 4.745 we can estimate the Window Of Uncertainty for the probability of 6-9s.</span></p>
<p><span>For our given system the probability of 6-9s is about 92ns x 4.745 = 436ns</span></p>
<p><span>This means that given a reported time by PTP, considering a window size of 436ns around value guarantees to include the true time by a confidence of over 99.9999%.</span></p>
<h4><span>Compensation for holdover</span></h4>
<p><span>While all the above looks logical and great, there is a big assumption there. The assumption is that the connection to the open time server (OTS) is available, and everything is in normal operation mode. A lot of things can go wrong such as the OTS going down, switch going down, Sync messages not behaving as they are supposed to, something in between decides to wake up the on-calls etc. In such a situation the error bound calculation should enter the holdover mode. The same things apply to the OTS when GNSS is down. In such a situation the system will increase the Window Of Uncertainty based on a compound rate. The rate will be estimated based on the stability of the oscillator (scrolling variance) during normal operations. On the OTS the compound rate gets adjusted by the accurate telemetry monitoring of the system (Temperature, Vibration, etc). There is a fair amount of work in terms of calibrating coefficients here and getting to the best outcome and we are still working on those fine tunings. </span></p>
<p><span>During the periods of network synchronization availability, the servo is constantly adjusting the frequency of the local clock on the client side (assuming the initial stepping resulted in convergence). A break in the network synchronization (from losing connection to the time server or the time server itself going down) will leave the servo with a last frequency correction value. As a result, such value is not aimed to be an estimation of precision of the local clock but instead a temporary frequency adjustment to reduce the time error (offset) measured between the cline and the time server.</span></p>
<p><span>Therefore, it is necessary to first account for synchronization loss periods and use the best estimation of frequency correction (usually, the scrolling average of previous correction values) and second, account for the error bound increase by looking at the last correction value and comparing it with the scrolling average of previous correction values.</span></p>
<h2 id="monitor"><span>How we monitor the PTP architecture</span></h2>
<p><span>Monitoring is one of the most important parts of the PTP architecture. Due to the nature and impact of the service, we’ve spent quite a bit of time working on the tooling.</span></p>
<h3><span>Calnex</span></h3>
<p><span>We worked with the Calnex team to create the Sentinel HTTP API, which allows us to manage, configure, and export data from the device. At Meta, we created and </span><a href="https://github.com/facebook/time/tree/main/calnex" target="_blank" rel="noopener"><span>open-sourced</span></a><span> an API command line tool allowing human and script friendly interactions.</span></p>
<p><span>Using Calnex Sentinel 2.0 we are able to monitor three main metrics per time appliance — NTP, PTP, and PPS.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="633" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?resize=916,566 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?resize=768,474 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?resize=1024,633 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?resize=1536,949 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?resize=96,59 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-19.jpg?resize=192,119 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>This allows us to notify engineers about any issue with the appliances and precisely detect where the problem is. </span></p>
<p><span>For example, in this case both PTP and PPS monitoring resorts in a roughly less than 100 nanosecond variation over 24 hours when NTP stays within 8 microseconds.</span></p>
<h3><span>ptpcheck</span></h3>
<p><span>In order to monitor our setup, we implemented and </span><a href="https://github.com/facebook/time" target="_blank" rel="noopener"><span>open-sourced</span></a><span> a tool called </span><span>ptpcheck</span><span>. It has many different subcommands, but the most interesting are the following:</span></p>
<h4><span>diag</span></h4>
<p><span>Client subcommand provides an overall status of a ptp client. It reports the time of receipt of last Sync message, clock offset to the selected time server, mean path delay, and other helpful information:</span></p>
<pre><code>$ ptpcheck diag
[ OK ] GM is present
[ OK ] Period since last ingress is 972.752664ms, we expect it to be within 1s
[ OK ] GM offset is 67ns, we expect it to be within 250µs
[ OK ] GM mean path delay is 3.495µs, we expect it to be within 100ms
[ OK ] Sync timeout count is 1, we expect it to be within 100
[ OK ] Announce timeout count is 0, we expect it to be within 100
[ OK ] Sync mismatch count is 0, we expect it to be within 100
[ OK ] FollowUp mismatch count is 0, we expect it to be within 100
</code></pre>
<h4><span>fbclock</span></h4>
<p><span>Client subcommand that allows querying of an fbclock API and getting a current Window of Uncertainty:</span></p>
<pre><code>$ ptpcheck fbclock
{&#34;earliest_ns&#34;:1654191885711023134,&#34;latest_ns&#34;:1654191885711023828,&#34;wou_ns&#34;:694}
</code></pre>
<h4><span>sources</span></h4>
<p><span>Chrony-style client monitoring, allows to see all Time Servers configured in the client configuration file, their status, and quality of time.</span></p>
<pre><code>$ ptpcheck sources
+----------+----------------------+--------------------------+-----------+--------+----------+---------+------------+-----------+--------------+
| SELECTED |       IDENTITY       |         ADDRESS          |   STATE   | CLOCK  | VARIANCE |  P1:P2  | OFFSET(NS) | DELAY(NS) |  LAST SYNC   |
+----------+----------------------+--------------------------+-----------+--------+----------+---------+------------+-----------+--------------+
| true     | abcdef.fffe.111111-1 | time01.example.com.      | HAVE_SYDY | 6:0x22 | 0x59e0   | 128:128 |         27 |      3341 | 868.729197ms |
| false    | abcdef.fffe.222222-1 | time02.example.com.      | HAVE_ANN  | 6:0x22 | 0x59e0   | 128:128 |            |           |              |
| false    | abcdef.fffe.333333-1 | time03.example.com.      | HAVE_ANN  | 6:0x22 | 0x59e0   | 128:128 |            |           |              |
+----------+----------------------+--------------------------+-----------+--------+----------+---------+------------+-----------+--------------+
</code></pre>
<h4><span>oscillatord</span></h4>
<p><span><span>Server subcommand, allows to read a summary from the </span><a href="https://engineering.fb.com/2021/08/11/open-source/time-appliance/" target="_blank" rel="noopener"><span>Time Card</span></a><span>.</span></span></p>
<pre><code>$ ptpcheck oscillatord
Oscillator:
	model: sa5x
	fine_ctrl: 328
	coarse_ctrl: 10000
	lock: true
	temperature: 45.33C
GNSS:
	fix: Time (3)
	fixOk: true
	antenna_power: ON (1)
	antenna_status: OK (2)
	leap_second_change: NO WARNING (0)
	leap_seconds: 18
	satellites_count: 28
	survey_in_position_error: 1
Clock:
	class: Lock (6)
	offset: 1
</code></pre>
<p><span>For example, we can see that the last correction on the Time Card was just 1 nanosecond.</span></p>
<h4><span>phcdiff</span></h4>
<p><span>This subcommand allows us to get a difference between any two PHCs:</span></p>
<pre><code>$ ptpcheck phcdiff -a /dev/ptp0 -b /dev/ptp2
PHC offset: -15ns
Delay for PHC1: 358ns
Delay for PHC2: 2.588µs</code></pre>
<p><span>In this particular case the difference between Time Card and a NIC on a server is -15 nanoseconds.</span></p>
<h3><span>Client API</span></h3>
<p><span>It’s good to trigger monitoring periodically or on-demand, but we want to go even further. We want to know what the client is actually experiencing. To this end, we embedded several buckets right inside of the </span><span>fbclock</span><span> API based on atomic counters, which increment every time the client makes a call to an API:</span></p>
<figure id="attachment_19702" aria-describedby="caption-attachment-19702"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="530" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?resize=916,474 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?resize=768,398 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?resize=1024,530 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?resize=1536,795 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?resize=96,50 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-20.jpg?resize=192,99 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19702">Schematic representation of fbclock API monitoring.</figcaption></figure>
<p><span>This allows us to clearly see when the client experiences an issue — and often before the client even notices it.</span></p>
<h3><span>Linearizability checks</span></h3>
<p><span>PTP protocol (and </span><span>ptp4l</span><span> in particular) don’t have a quorum selection process (unlike NTP and </span><span>chrony</span><span>). This means the client picks and trusts the Time Server based on the information provided via </span><i><span>Announce</span></i><span> messages. This is true even if the Time Server itself is wrong.</span></p>
<p><span>For such situations, we have implemented a last line of defense called a linearizability check.</span></p>
<p><span>Imagine a situation in which a client is configured to use three time servers and the client is subscribed to a faulty Time Server (e.g., Time Server 2):</span></p>
<figure id="attachment_19704" aria-describedby="caption-attachment-19704"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="431" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?resize=916,385 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?resize=768,323 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?resize=1024,431 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?resize=1536,646 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?resize=96,40 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-2.jpg?resize=192,81 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19704">Client following Time Server 2.</figcaption></figure>
<p><span>In this situation, the PTP client will think everything is fine, but the information it provides to the application consuming time will be incorrect, as the Window of Uncertainty will be shifted and therefore inaccurate. </span></p>
<p><span>To combat this, in parallel, the </span><span>fbclock</span><span> establishes communication with the remaining time servers and compares the results. If the majority of the offsets are high, this means the server our client follows is the outlier and the client is not linearizable, even if synchronization between Time Server 2 and the client is perfect.</span></p>
<figure id="attachment_19703" aria-describedby="caption-attachment-19703"><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?w=1024" alt="Precision Time Protocol" width="1024" height="431" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg 1920w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?resize=916,385 916w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?resize=768,323 768w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?resize=1024,431 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?resize=1536,646 1536w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?resize=96,40 96w, https://engineering.fb.com/wp-content/uploads/2022/11/CD22-717-Eng-PTP-DeepDive-visual-21-1.jpg?resize=192,81 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19703">Schematic representation of linearizability check.</figcaption></figure>
<h2><span>PTP is for today and the future</span></h2>
<p><span>We believe PTP will become the standard for keeping time in computer networks in the coming decades. That’s why we’re deploying it on an unprecedented scale. We’ve had to take a critical look at our entire infrastructure stack — from the GNSS antenna down to the client API — and in many cases we’ve even rebuilt things from scratch.</span></p>
<p><span>As we continue our rollout of PTP, we hope more vendors who produce networking equipment will take advantage of our work to help bring new equipment that supports PTP to the industry. We’ve open-sourced most of our work, from our source code to our hardware, and we hope the industry will join us in bringing PTP to the world. All this has all been done in the name of boosting the performance and reliability of the existing solutions, but also with an eye toward opening up new products, services, and solutions in the future. </span></p>
<p><span>We want to thank everyone involved in this endeavor, from Meta’s internal teams to vendors and manufacturers collaborating with us. Special thanks goes to Andrei Lukovenko, who connected time enthusiasts.</span></p>
<p><span>This journey is just one percent finished.</span></p>

		
	</div></div>
  </body>
</html>
