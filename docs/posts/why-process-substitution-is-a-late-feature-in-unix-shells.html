<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ProcessSubstitutionWhyLate">Original</a>
    <h1>Why “process substitution” is a late feature in Unix shells</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Why &#34;process substitution&#34; is a late feature in Unix shells</h2>

	<p><small>January  2, 2022</small></p>
</div><div><p>A while ago, I read Julia Evans&#39; <a href="https://jvns.ca/blog/2021/09/20/teaching-by-filling-in-knowledge-gaps/">Teaching by filling in knowledge
gaps</a>
and hit the section using Evans&#39; shell brackets cheat sheet as an
example. One of the uses of brackets in Bash and other shells is
<a href="https://tldp.org/LDP/abs/html/process-sub.html">&#34;process substitution&#34;</a>
(also <a href="https://en.wikipedia.org/wiki/Process_substitution">Wikipedia</a>),
where you can use a redirection with a process instead of a file
as an argument to commands:</p>


<blockquote><pre>diff &lt;(rpm -qa) &lt;(ssh server2 &#34;rpm -qa&#34;)
</pre>
</blockquote>

<p>Process substitution is a great little feature and it feels very
Unixy, but it took a surprisingly long time to appear in Unix and
in shells. This is because it needed a crucial innovation, namely
<strong>names in the filesystem for file descriptors</strong>, names that you
can <code>open()</code> to be connected to the file descriptor.</p>

<p>Standard input, standard output, and so on are <em>file descriptors</em>,
which (from the view of Unix processes) are small integers that refer
to open files, pipes, network connections, and other things that
fall inside the Unix IO model. File descriptors are specific to each
process and are an <a href="https://en.wikipedia.org/wiki/API">API</a> between
processes and the kernel, where the process tells the kernel that it
wants to read from (eg) file descriptor zero and the kernel provides
it whatever is there. Conventionally, Unix processes are started with
three file descriptors already open, those being standard input (fd 0),
standard output (fd 1), and standard error (fd 2). However, you can
start processes with more file descriptors already open and connected to
something if you want to.</p>

<p>Normal Unix programs don&#39;t expect to be passed any extra file
descriptors and there&#39;s no standard approach in Unix for telling them
that hey have been given extra file descriptors and they should read or
write to them for some purpose. Instead, famously, Unix programs like
<code>diff</code> expect to be provided <em>file names</em> as arguments, and then they
open the file names themselves. Some programs accept a special file name
(often &#39;<code>-</code>&#39;, a single dash) to mean that they should read from standard
input or write to standard output, but this is only a convention; there&#39;s
no actual &#39;<code>-</code>&#39; filename that you can open yourself.</p>

<p>To implement process substitution, the shell needs to bridge these
two different worlds. The process substitution commands will write
to their standard output, but the overall command must be given
file names as input. There are two ways to implement this, the
inefficient one that&#39;s been possible since the beginning of Unix,
and the efficient one that became possible later. The inefficient
way is to write the output of the commands to a file, turning the
whole thing into something like this:</p>

<blockquote><pre>rpm -qa &gt;/tmp/file-a.$$
ssh server2 &#34;rpm -qa&#34; &gt;/tmp/file-b.$$
diff /tmp/file-a.$$ /tmp/file-b.$$
rm /tmp/file-a.$$ /tmp/file-b.$$
</pre>
</blockquote>

<p>I believe that some Unix shells may have implemented this, but it
was never very popular for various reasons (especially since this
was back in the days when <code>/tmp</code> was generally on a slow hard disk).
Once <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkfifo.html">named FIFO</a>s
were available on Unixes, you could use them instead of actual
files, which improved the efficiency but still had some issues.</p>

<p>The best way is to have filesystem names for file descriptors, so
that when you open the filename, you&#39;re connected to the file
descriptor (you may or may not get that file descriptor returned
by the kernel from <code>open()</code>). Then the shell can start the <code>diff</code>
process with some extra file descriptors open that are the input
sides of the pipes that the two process substitution commands are
writing their output too, and it can provide the filesystem names
for these file descriptors as command line arguments to <code>diff</code>.
Diff thinks it&#39;s operating on files (although odd ones, since they&#39;re
not seekable among other issues), and generally it will be happy.
Everything is automatically cleaned up when things exit and it&#39;s
about as efficient as you could ask for. The conventional modern
filesystem name for file descriptors is <code>/dev/fd/N</code> (for file
descriptor N).</p>

<p>I think every modern Unix has a <code>/dev/fd</code> of some sort (although the
implementations vary), but coming up with the idea of <code>/dev/fd</code>, having
it implemented, and then having it spread widely enough that shells
could reliably use it took a while. My impression is that process
substitution in shells didn&#39;t start to be common until then, and even
today isn&#39;t necessarily in wide use.</p>

<p>(Unfortunately I&#39;m not sure where /dev/fd was first invented and
introduced. It&#39;s possible that it comes from later versions of
<a href="https://en.wikipedia.org/wiki/Research_Unix">Research Unix</a>, since
the V10 version of <code>rc</code> apparently had this and I can&#39;t imagine the
Bell Labs people implementing it with named FIFOs. /dev/fd itself
took some Unix innovations after <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/V7WhyItMattersSoMuch">V7</a>, but
that&#39;s for another entry.)</p>

<p>PS: Considering that Bash apparently had process substitution no
later than 1994, my standards for a &#39;late shell feature&#39; may be a
bit off from many people&#39;s. However, I think process substitution
is still not in the shell section of <a href="https://pubs.opengroup.org/onlinepubs/9699919799/">the current version of POSIX</a>, although named
FIFOs are.</p>
</div></div>
  </body>
</html>
