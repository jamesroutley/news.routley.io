<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/chrisdavies/dbench">Original</a>
    <h1>An unscientific benchmark of SQLite vs. the file system (btrfs)</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<p dir="auto">Basic benchmarks for SQLite vs file system (btrfs on a 2020 Dell XPS SSD).</p>
<h2 dir="auto"><a id="user-content-linear-writes" aria-hidden="true" href="#linear-writes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Linear writes</h2>
<p dir="auto">10k inserts, written in a tight loop.</p>
<div data-snippet-clipboard-copy-content="SQLite      647ms, 809ms, 708ms
BTRFS       393ms, 371ms, 382ms"><pre><code>SQLite      647ms, 809ms, 708ms
BTRFS       393ms, 371ms, 382ms
</code></pre></div>
<p dir="auto">For sequential writes, the file system is 1.8x faster.</p>
<h2 dir="auto"><a id="user-content-concurrent-writes" aria-hidden="true" href="#concurrent-writes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Concurrent writes</h2>
<p dir="auto">Here, we&#39;re going to crank up the concurrency and have 100 concurrent writers, each writing 1K records. SQLite will serialize these under the hood. The file system will do whatever it does.</p>
<div data-snippet-clipboard-copy-content="SQLite        8.2s, 8.1s, 8.5s
BTRFS         3.1s, 3.4s, 3.4s"><pre><code>SQLite        8.2s, 8.1s, 8.5s
BTRFS         3.1s, 3.4s, 3.4s
</code></pre></div>
<p dir="auto">For concurrent writes, the file system is 2.4x faster.</p>
<p dir="auto">This is not terribly surprising, as SQLite does not handle concurrent writes. To be honest the performance gap here is smaller than I&#39;d have guessed.</p>
<ul dir="auto">
<li>SQLite can write around 12K inserts per second</li>
<li>BTRFS can write around 30K files per second</li>
</ul>
<h2 dir="auto"><a id="user-content-a-more-realistic-test" aria-hidden="true" href="#a-more-realistic-test"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A more realistic test</h2>
<p dir="auto">The real-world application I&#39;ll be writing would have a bit more structure and more indices. So, I think the next test will be to run N tasks from start to finish: insert, update status, update progress, delete.</p>
<p dir="auto">For this, we&#39;ll want to index by status, and in the real world, I&#39;d <em>probably</em> also index by <code>scheduled_at</code> so that we can handle job scheduling efficiently. If I were to use the file system for this, I&#39;d keep the queues and schedules in memory, and rebuild it when the application starts. I&#39;ve tested the in-memory approach, and it&#39;s blisteringly fast (millions of ops per second, given proper care).</p>
<p dir="auto">Concurrency: 100, each running a simulation of 100 tasks (create, change status, update &#34;output&#34; 10 times, delete):</p>
<div data-snippet-clipboard-copy-content="SQLite      11.5s, 10.3s, 7.8
BTRFS       3.3s, 3.2s, 2.4s"><pre><code>SQLite      11.5s, 10.3s, 7.8
BTRFS       3.3s, 3.2s, 2.4s
</code></pre></div>
<p dir="auto">In this test, the file system was 3.3x faster than SQLite. This surprises me, since we&#39;re writing the <em>entire</em> file each time vs SQLite presumably being able to do more optimal, in-place updates (though a variety of things may mean that&#39;s not actually happening).</p>
<p dir="auto">Let&#39;s try again. This time, we&#39;ll do proper file writes (write to a tmp file, rename to overwrite the current file). This should be a <em>bit</em> more crash-resistant, though for my use case, it probably doesn&#39;t matter a whole lot if one or two tasks fail due to crashes once or twice a year.</p>
<h2 dir="auto"><a id="user-content-more-resilient-file-writes" aria-hidden="true" href="#more-resilient-file-writes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>More resilient file writes</h2>
<p dir="auto">Interesting. This time, I modified my file simulation to write to a tmp file first, then rename it to overwrite the existing file. This tweak caused the file simulation to be a bit slower than SQLite:</p>
<div data-snippet-clipboard-copy-content="SQLite      9.6s, 9.6s, 7.9s
BTRFS       13.5s, 13.3s, 10.2s"><pre><code>SQLite      9.6s, 9.6s, 7.9s
BTRFS       13.5s, 13.3s, 10.2s
</code></pre></div>
<p dir="auto">This makes me think that <em>probably</em> my initial file tests weren&#39;t waiting for fsync, but the rename forces the application to wait. I&#39;m not sure.</p>
<p dir="auto">Another interesting thing I&#39;ve noticed is that SQLite seems to speed up a bit as it goes along.</p>
<p dir="auto">Here&#39;s another run, just with SQLite:</p>
<div data-snippet-clipboard-copy-content="SQLite ran 10k tasks in  10.83936393s
SQLite ran 10k tasks in  10.27817409s
SQLite ran 10k tasks in  8.891015857s
SQLite ran 10k tasks in  6.528546715s
SQLite ran 10k tasks in  6.738008705s
SQLite ran 10k tasks in  6.917476809s"><pre><code>SQLite ran 10k tasks in  10.83936393s
SQLite ran 10k tasks in  10.27817409s
SQLite ran 10k tasks in  8.891015857s
SQLite ran 10k tasks in  6.528546715s
SQLite ran 10k tasks in  6.738008705s
SQLite ran 10k tasks in  6.917476809s
</code></pre></div>
<p dir="auto">It seems to have a warm up phase or something. Eeeenterestink.</p>
<h2 dir="auto"><a id="user-content-conclusion" aria-hidden="true" href="#conclusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conclusion</h2>
<p dir="auto">For a my real(ish) world scenario, SQLite-- once warmed up-- is <em>roughly</em> twice as fast as the file system.</p>
<p dir="auto">I&#39;m not sure which I&#39;ll end up going with, but I think it&#39;ll be SQLite. The devops part of me has a slight preference for using the file system, as I can use basic tools (grep, ls, etc) to check on things. The dev part of me definitely pefers SQLite, as I can let it take care of loads of things for me that I&#39;d otherwise have to do myself, and I can trivially query for stats, etc.</p>
<h2 dir="auto"><a id="user-content-ext4" aria-hidden="true" href="#ext4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>EXT4</h2>
<p dir="auto">Someone on Hacker News suggested I try a faster file system. Here&#39;s what a $5 Linode running Ubuntu Server and EXT4 got me (running 10K simulations, which is 1 insert, 11 updates, and 1 delete):</p>
<div data-snippet-clipboard-copy-content="SQLite      8.7s, 8.0s, 8.2s, 8.3s, 8.0s, 8.5s
EXT4        18.3s, 17.3s, 16.6s, 15.7s, 16.1s"><pre>SQLite      8.7s, 8.0s, 8.2s, 8.3s, 8.0s, 8.5s
EXT4        18.3s, 17.3s, 16.6s, 15.7s, 16.1s</pre></div>
<p dir="auto">So. Same conclusion.</p>
<h2 dir="auto"><a id="user-content-footnotes" aria-hidden="true" href="#footnotes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Footnotes</h2>
<ul dir="auto">
<li>I used <a href="https://github.com/mattn/go-sqlite3">mattn/go-sqlite3</a>
<ul dir="auto">
<li>These were the settings: <code>./tmp.db?_timeout=5000&amp;_journal=WAL&amp;_sync=1</code></li>
</ul>
</li>
<li>The project is <a href="https://github.com/chrisdavies/dbench">here</a></li>
<li>In a separate project, I ran tests vs Postgres and found the performance was roughly the same as SQLite&#39;s worst performance when Postgres is hosted on the same machine.</li>
</ul>
</article>
        </div></div>
  </body>
</html>
