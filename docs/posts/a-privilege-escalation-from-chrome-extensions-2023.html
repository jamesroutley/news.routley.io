<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0x44.xyz/blog/cve-2023-4369/">Original</a>
    <h1>A privilege escalation from Chrome extensions (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        
        <p>
          What&#39;s the worst thing a Chrome extension could do to you? Well, it
          could
          <a href="https://chromium.googlesource.com/chromium/src/+/main/extensions/docs/security_faq.md#I_ve-found-written-an-extension-that-can-access-sensitive-user-data_like-passwords-and-emails_Is-this-a-security-bug-in-Chromium">steal
            your passwords and cookies</a>, or it could continuously close your tabs. Obviously, these are
          bad and annoying, but there are limitations to the power of
          extensions.
        </p>
        <p>
          Can they run exe files? Not really. They can download files at any time, but
          <a href="https://developer.chrome.com/docs/extensions/reference/downloads/#method-open">opening those
            downloads</a>
          requires a special permission and a user gesture.
        </p>
        <p>
          Can they change your settings? Generally, no. The general design
          idea for Chrome extensions is that they shouldn&#39;t be able to make
          permanent changes that persist after they&#39;re uninstalled.
        </p>
        <p>
          Alright then, what about editing or reading local files? The rules
          are a little convoluted when it comes to this:
        </p>
        <ul>
          <li>Extensions shouldn&#39;t be able to read local files</li>
          <li>
            That is, unless the &#34;allow access to file URLs&#34; switch is turned
            on in the extension&#39;s options
          </li>
          <li>
            Chrome apps--like the
            <a href="https://chrome.google.com/webstore/detail/text/mmfbcljfglbokpmkimbfghdkjmjhdgbg">Text app</a>--are
            sometimes sometimes able to
            <a href="https://developer.chrome.com/docs/extensions/reference/fileSystem/">edit local files</a>, but only
            when those files are explicitly opened by the user
          </li>
        </ul>
        <p>
          Of course, these limitations have their occasional bypasses. For
          example, Google awarded $10,000 to a
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1385343">bug report</a>
          which showed that extensions could read local files by
          screenshotting them. But there are more dangerous things than file
          reads.
        </p>
      </div>
      <div>
        
        <p>
          It&#39;s generally agreed upon that a full &#34;sandbox escape&#34; for an
          extension is when the extension runs an executable file without user
          interaction. Then the attack moves out of the browser as the
          executable starts attacking the user&#39;s operating system using other
          bugs.
        </p>
        <p>
          The way these attacks almost always work--or at least in theory--is
          that the extension abuses a bug to run code on a page more
          privileged than itself. Specifically, on
          <code>chrome://</code> URLs: privileged WebUI pages which sometimes
          have permission to open downloads and change settings. Normally,
          extensions should only be able to run code on http(s) URLs, but
          every once in a while, bypasses are found using powerful but rare
          permissions like <code>debugger</code>, <code>devtools</code>, and
          <code>input</code>.
        </p>
        <p>
          A good example of a sandbox escape is
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1059577">this bug reported by David Erceg</a>,
          where insufficiently validated functions in
          <code>chrome.debugger</code> were abused to run code on
          <code>chrome://downloads</code> and open an exe on Windows.
        </p>
      </div>
      <div>
        
        <p>
          The only other option for running code within a privileged page is to
          find some kind of XSS bug where it unsafely renders untrusted text as HTML
          capable of running JS scripts. This is very rare in <code>chrome://</code> pages, but it has
          happened before; for example, Rob Wu found an
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=668653">XSS in the downloads page</a>
          where the extension&#39;s name was unsafely injected as HTML. The
          <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content-Security-Policy (CSP)</a>
          of the page was also bypassed in order to run Javascript that opened
          an exe file.
        </p>
        <p>
          But this was in 2016! The
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=797525">latest Chrome URL XSS</a>
          was in Chrome 65. Nowadays, CSPs are much better at stopping
          Javascript execution from HTML injections, and
          <code>chrome://</code> pages don&#39;t use
          <code>innerHTML</code> anyway.
        </p>
        <p>
          In Chrome 102, there was a
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1332881">very surprising bug</a>
          where <code>chrome://settings</code> displayed extensions&#39; names as
          HTML. But even with this, there was nothing to be done except inject
          a fake phishing link. Real code execution is simply dead in these
          pages because of their strong CSPs and the
          <a href="https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/">introduction of
            trusted types.</a>
        </p>
      </div>
      <div>
        
        <p>
          A quick notice: this blog post talks about ChromeOS 115, before the
          widespread introduction of
          <a href="https://chromeunboxed.com/how-to-enable-lacros-chrome-browser-chromebook-chrome-os/">Lacros</a>,
          which aims to seperate ChromeOS from the browser.
        </p>
        <p>
          So far, we&#39;ve been talking about Windows. The goal on Windows (and
          most other operating systems) is to download and run an executable
          file. But what about ChromeOS, the all-Google operating system?
        </p>
        <ul>
          <li>There are no executable files</li>
          <li>But you can do more things from the browser</li>
        </ul>
        <p>
          What do I mean by this? In ChromeOS, the browser and the operating
          system are coupled. The device settings are hosted on
          <code>chrome://os-settings</code>. All your files are hosted on
          <code>chrome://file-manager</code>. Your device terminal is hosted
          on <code>chrome-untrusted://crosh</code>.
        </p>
        <p>
          Therefore, an extension running code on a <code>chrome://</code> URL
          in ChromeOS can do literally everything that you can do, which is
          insane if you think about it for a second. Depending on the
          <code>chrome://</code> page, it could modify your network settings,
          install certificates, edit your files, or run code in your terminal.
          But an exploit would be needed for that to happen.
        </p>
        <p>Now, time to talk about the bug I found!</p>
      </div>
      <div>
        
        <p>
          In July, I was poking around in
          <code>chrome://file-manager</code>, ChromeOS&#39;s file manager, when I
          saw an interesting URL in <code>localStorage</code>:
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/localStorage.png"/></p><p>
          Abesntmindedly, I tried to open the URL in my browser, and, surprisingly, it
          showed my downloads folder. Apparently, every downloaded file can be
          opened in this way. As it turns out, the two following URLs have
          exactly the same content:
        </p>
        <p><code>file:///home/chronos/u-878f28a3486b11359f7db348414fed3b5a15e573/MyFiles/file.txt</code>
        <code>filesystem:chrome://file-manager/external/Downloads-878f28a3486b11359f7db348414fed3b5a15e573/file.txt</code></p><p>
          Wait a minute. <code>file://</code> URLs have tons of restrictions,
          but that second weird-looking URL is hosted on
          <code>chrome://file-manager</code>.
          So I decided to try using this new URL to open an
          HTML file simply containing the following code:
        </p>
        <p><code>&lt;script&gt;
            <span>alert(1)</span>
          &lt;/script&gt;
        </code></p><p>
          I was almost certain that it wouldn&#39;t work.
          Either the CSP would block it, or it would just display as a text
          file, or it wouldn&#39;t be hosted on the Chrome domain. But, to my
          surprise:
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/alert.png"/></p><p>
          Wow, it worked! I knew instantly that this had to be a massive bug.
          It seemed that this page didn&#39;t have any CSP, and the origin
          appeared to be
          <code>chrome://file-manager</code>. So I opened up the devtools console
          and started to check what would work and what wouldn&#39;t.
        </p>
        <p>
          The first thing I noticed was that <code>Mojo</code> existed. This
          is an inter-process communication (IPC) library that&#39;s not normally
          exposed to websites because it can
          <a href="https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html">lead to
            memory corruption in the browser process.</a>
          <code>chrome.send()</code>--another messaging
          function--existed too, although it seemed to be unconfigured.
        </p>
        <p>
          The second thing I noticed was that I was able to read the source
          code of other Chrome pages. For example, I could fetch
          <code>chrome://prefs-internals</code> using
          <code>XMLHttpRequest</code> to get some sensitive info about the
          device:
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/xhr.png"/></p><p>
          I was also able to use <code>XMLHttpRequest</code> to read downloaded
          files with relative paths like <code>./file.html</code>.
        </p>
        <p>
          Okay, so
          now we know that an HTML file can be rendered with extra permissions
          and read sensitive pages, including the user&#39;s files. But is this
          exploitable? Can anything actually set up this attack?
        </p>
        <p>
          My idea was to have a Chrome extension download a malicious HTML
          file and open that file with the special
          <code>filesystem:chrome://file-manager</code> path, leading to XSS.
          But there was one issue. If you recall, that URL has a seemingly
          random jumble of characters. In my case, that was:
        </p>
        <p><code>878f28a3486b11359f7db348414fed3b5a15e573</code></p><p>
          This is actually a ChromeOS user hash; each user has a unique one.
          And for this exploit to work, the malicious extension would have to
          be able to figure out what it was. Luckily, a number of functions in
          the <code>chrome.downloads</code> extension API return the full path of the file,
          including the user hash.
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/userHash.png"/></p><p>So I started building the exploit:</p>
        <ul>
          <li>Extension downloads a malicious HTML file</li>
          <li>
            Extension gets the user hash from the
            <code>filename</code> property
          </li>
          <li>
            Extension opens the
            <code>filesystem:chrome://file-manager</code> version of that file
          </li>
          <li>The code in the HTML file is run on the File Manager origin</li>
          <li>
            The code reads other files and sends the data back to the
            extension
          </li>
        </ul>
        <p>
          And it worked. Convinced that I had found a pretty severe infoleak,
          I
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1464456">submitted the bug.</a>
        </p>
      </div>
      <div>
        
        <p>
          After submitting, I realized that there might be more to explore
          with this bug. Specifically, the real files app at
          <code>chrome://file-manager</code> had access to the
          <code>chrome.fileManagerPrivate</code> API, but the
          <code>filesystem:</code> URL with the vulnerability didn&#39;t.
        </p>
        <p>
          Since the <code>chrome.fileManagerPrivate</code> API is extremely
          cool--and I&#39;ll elaborate on this later--I made it my goal to go from
          code execution on this URL:
        </p>
        <p><code>filesystem:chrome://file-manager/external/Downloads...</code></p><p>...to code execution on this URL:</p>
        <p><code>chrome://file-manager</code></p><p>
          These URLs both have the origin of
          <code>chrome://file-manager</code>, so in theory there should be no
          problem with one accessing the other. The only thing that throws a
          wrench in those plans is the fact that the File Manager opens as an
          app. When we try to open it with <code>window.open()</code> from the
          <code>filesystem:</code> tab, the browser closes the newly created
          tab and instead loads the page in an app-like window, leaving us
          with a dangling reference to a nonexistent page:
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/windowOpen.png"/></p><p>
          <code>chrome://</code> pages can&#39;t be embedded in any way, so that
          isn&#39;t an option. Trying to redirect a tab using JS doesn&#39;t work
          either. That&#39;s why I initially thought it would be impossible to get
          a reference to the <code>chrome.fileManagerPrivate</code> API.
        </p>
        <p>
          But, as it turns out, it&#39;s actually possible--but only with the help of the
          malicious extension. First, the <code>filesystem:</code> page has to
          run the following:
        </p>
        <p><code>let fmWindow = <span>window.open</span>(<span>&#34;javascript:0&#34;</span>);</code></p><p>
          The reason a JS URL is used is because it creates an uninitialized
          renderer. Basically, that tab hasn&#39;t commited to displaying anything
          yet.
        </p>
        <p>
          Then the extension can use <code>chrome.tabs.update()</code> to
          redirect the new tab to
          <code>view-source:chrome://file-manager</code>, a tricky URL that
          has access to the private API and loads as a tab. The extension
          doesn&#39;t have permission to access this tab, but the
          <code>filesystem:</code> page still has a valid, same-origin reference to it:
        </p>
        <p><code><span>fmWindow.chrome.fileManagerPrivate</span></code></p><p>
          With this reference, the extension can run scripts under the domain of the real
          File Manager. Of course, I updated the bug report with this new detail.
        </p>
      </div>
      <div>
        
        <p>
          Wow! Now our code is running on an actual <code>chrome://</code> page,
          not some weird <code>filesystem:</code> URL. But what does this
          mean?
        </p>
        <ul>
          <li>
            First of all, we have the first <code>chrome://</code> URL XSS in
            50 versions of Chrome, which is insane! That&#39;s 7 years!
          </li>
          <li>
            We can use the user&#39;s camera and microphone without permission:
            see &#34;chrome:// is too powerful...&#34; in
            <a href="https://source.chromium.org/chromium/chromium/src/+/main:docs/chrome_untrusted.md;drc=a894942393f81b45e795f5e201ff875ef62f65dd">this
              Chromium doc</a>
          </li>
        </ul>
        <p>
          Anyway, I&#39;ve mentioned the <code>fileManagerPrivate</code> API a few
          times. But what can we actually do with it? Well, it has 85 functions,
          including ones that allow for:
        </p>
        <ul>
          <li>Reading downloaded files</li>
          <li>Writing to downloaded files</li>
        </ul>
        <p>
          One possibility that came to mind was ransomware, considering how
          easy it is for an extension to encrypt a user&#39;s files. Of course,
          the access--and modification--of local files is a huge privacy issue in itself.
        </p>
        <p>
          But there&#39;s one other very interesting capability of the
          <code>fileManagerPrivate</code> API: it can mess with
          <a href="https://chromeos.dev/en/linux">Crostini, a Linux terminal built into ChromeOS.</a>
          In fact, our extension can:
        </p>
        <ul>
          <li>Set up Crostini</li>
          <li>
            Put malicious code into the Crostini <code>.bashrc</code> file,
            which runs every time the terminal is loaded
          </li>
          <li>
            Open
            <code>chrome-untrusted://terminal</code>--which is
            <a href="https://chromium.googlesource.com/chromium/src/+/main/extensions/docs/security_faq.md#Why-do-we-not-allow-extensions-to-open-or-close-chrome_untrusted_scheme-pages">normally
              forbidden</a>--with <code>fileManagerPrivate.openURL()</code>,
            thus running our code
          </li>
        </ul>
        <p>
          With this, we can run and permanently store and execute code in a container with
          access to some Android and networking features. Keep in mind that we
          got here from a Chrome extension, a small add-on designed for tweaking
          webpages. That&#39;s pretty cool!
        </p>
      </div>
      <div>
        
        <p>
          Three days later, I found something else in the File Manager source
          code:
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/imageLoader.png"/></p><p>
          Woah, what? A <code>filesystem:</code> URL on a built-in Chrome extension?
          And after a bit of poking around, I managed to open the following URL:
        </p>
        <p><code>filesystem:chrome-extension://pmfjbimdmchhbnneeidfognadeopoehp/external/Downloads-878f28a3486b11359f7db348414fed3b5a15e573/Downloads/file.html</code></p><p>
          And it actually loaded my script, again! But what is this URL,
          anyway? This is another <code>filesystem:</code> URL belonging to
          the &#34;Image Loader&#34; extension, which is a
          <a href="https://chromium.googlesource.com/chromium/src/+/main/extensions/docs/component_extensions.md">component
            extension</a>--a privileged Google-made extension built into the browser--only present on
          ChromeOS.
        </p>
        <p>
          This extension also has access to <code>fileManagerPrivate</code>.
          However, it seems like its access to the file system is read-only, and
          therefore isn&#39;t as dangerous.
        </p>
        <p>
          It&#39;s worth noting that the Image Loader extension is also given
          access to
          <code>chrome://resources</code> for the purpose of importing its
          scripts, but this inadvertently gives the extension permission to run code on
          that origin:
        </p>
        <p><code><span>chrome.tabs.create</span>({ url: <span>&#34;chrome://resources/js/cr.m.js&#34;</span> }, (tab) =&gt; {
            <span>chrome.tabs.executeScript</span>(tab.id, { code: <span>&#34;alert(origin)&#34;</span> })
          })
        </code></p><p>
          Which gives us our second Chrome XSS! The biggest difference with this one is that
          downloaded files can&#39;t be edited. While somewhat similar to the first bug, I decided to
          <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1465203">submit it seperately.</a>
        </p>
      </div>
      <div>
        
        <p>
          As I&#39;ll discuss in the final section, the most severe part of the
          File Manager bug was only in stable ChromeOS for around 25 days. I
          wasn&#39;t able to find a ChromeOS recovery image for any version within
          that range, and I don&#39;t have the resources to build one from
          scratch, so the only videos I have of that exploit are the ones from
          the bug report.
        </p>
        <p>Here&#39;s a recording of the File Manager bug in action:</p>
        <video controls="">
          <source src="/blog/cve-2023-4369/fileManager.mp4" type="video/mp4"/>
        </video>
        <p>And here&#39;s the video for the Image Loader one:</p>
        <video controls="">
          <source src="/blog/cve-2023-4369/imageLoader.mp4" type="video/mp4"/>
        </video>
        <p>
          And to abuse these bugs, the only permission needed would be
          <code>downloads</code>, which normally only allows an extension to
          download and search for user files, not read or write to them. The attack
          could also be modified to take place quicker, and the Chrome window
          with the XSS could be loaded in the background, hiding it from the
          victim. There is no user interaction involved in the exploit.
        </p>
        <p>
          I&#39;ve also written
          <a href="https://0x44.xyz/blog/cve-2023-4369/poc.js">some more concise proof-of-concept code</a> in
          case anyone wants it.
        </p>
        <p>
          Again, a quick reminder: this issue doesn&#39;t allow for extensions to read or write to
          every file on a Chromebook; the browser just can&#39;t do that. Only files in
          the user directory--like Downloads, Photos, etc--can be accessed with this
          vulnerability.
        </p>
      </div>
      <div>
        
        <p>
          So far, I haven&#39;t really gone into why these bugs work. What&#39;s the
          difference between a <code>filesystem:</code> and
          <code>file:</code> URL? Why do the Image Loader extension and the File
          Manager app have these URLs? I&#39;ll try to answer some of
          these questions in this section.
        </p>
        <p>
          The <code>filesystem:</code> protocol is not something you come
          across very often on the web. It&#39;s a very, very old (2011-ish)
          Chrome feature that allows websites to permanently store
          <code>File</code> and <code>Blob</code> objects in a virtual
          filesystem with directories and folders. TL;DR: it&#39;s like the
          <code>blob:</code> protocol, but more stable and organized.
        </p>
        <p>
          As a side effect, every file is also hosted on a URL like the
          following:
        </p>
        <p><code>filesystem:https://google.com/temporary/file.html</code></p><p>
          Back in 2011,
          <a href="https://developer.chrome.com/blog/debugging-the-filesystem-api/">a page could apparently open</a>
          its files in the <code>filesystem:</code> protocol. Spoiler alert:
          that is no longer the case, which is why you might&#39;ve never seen
          this type of URL in your life.
        </p>
        <p>
          You might have noticed that the <code>filesystem:</code> URL above
          contains the <code>/temporary</code> directory. This path is
          actually a required part of the URL; it can be one of
          <a href="https://source.chromium.org/chromium/chromium/src/+/main:storage/common/file_system/file_system_util.cc;drc=b999986ff24699b81ecd3f45254a4bdf0332698a;l=23">four
            possibilities:</a>
        </p>
        <ul>
          <li><code>/temporary</code></li>
          <li><code>/persistent</code> (self-explanatory)</li>
          <li>
            <code>/isolated</code> (used to temporarily
            store uploaded files, can&#39;t be rendered)
          </li>
          <li>
            <code>/external</code>
          </li>
        </ul>
        <p>
          In case you were wondering, <code>/external</code> is not controlled
          by the website at all. Rather, it&#39;s a ChromeOS-only folder identical
          to the user&#39;s <code>MyFiles</code> path. This obscure feature only exists
          <a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/ash/fileapi/file_system_backend.cc;drc=9d2024940f3a7e31f54ec58bf8a43c75bdc34d27;l=247">on
            the File Manager and Image Loader origins.</a>
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/source.png"/></p><p>
          Which means... oh, of course. ChromeOS still uses an outdated and obsolete
          JavaScript API to power its primary File Manager app. Classic.
        </p>
        <p>
          When you think about it, it makes some sense. The ChromeOS
          developers wanted an easy way for their Javascript-powered app--which
          is really just a glorified website--to access files safely.
          Therefore, they decided to expand the legacy File System API--which, keep in mind,
          was the only good JS option back then--with a new <code>/external</code> path on
          the <code>chrome://file-manager</code> origin, so that the app could
          carry out read and write operations with existing APIs.
        </p>
        <p>
          And this is, under the hood, how the File Manager app works on
          ChromeOS. Whenever you create a file, the app uses the undocumented
          <code>webkitResolveLocalFileSystemURL()</code> function--which is, fun fact, the
          longest-named global function in Chrome--to get a
          <code>FileSystemEntry</code> object from a URL like the following:
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/resolve.png"/></p><p>
          Then it uses pure Javascript to
          <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileEntry/createWriter">create a
            writer</a>
          on the directory and write a blank <code>Blob</code> into a new
          file. In fact, <code>fileSystemPrivate</code> doesn&#39;t actually have
          any functions that directly write to files: it only returns entry
          objects which have to be handled with JS.
        </p>
        <p>
          It&#39;s kind of funny, really, that the main files app uses 2011
          Javascript APIs to do literally everything. But hey, this is
          ChromeOS!
        </p>
        <p>
          Anyway, when this system was designed, I suppose someone forgot that
          the <code>filesystem:</code> URLs they were using could be rendered
          in the browser, which meant that an extension could simply open them
          for XSS. I think this type of bug is really interesting because it
          shows that vulnerabilities don&#39;t always come from simple mistakes;
          sometimes, decade-long design choices in massive and complex
          projects like Chrome/ChromeOS can be exploited in creative ways.
        </p>
      </div>
      <div>
        
        <p>
          Remember how I said in the last paragraph that bugs don&#39;t always
          come from simple mistakes? Well, after reporting, I found out that
          this one partially did. A Google employee confirmed that
          <a href="https://chromium-review.googlesource.com/c/chromium/src/+/4503585">the introduction of
            <code>WebUIConfig</code></a>
          for determining the origins of <code>chrome://</code> pages
          partially led to the exploit.
        </p>
        <p>
          Before this change, <code>blob:chrome://</code> and
          <code>filesystem:chrome://</code> URLs would not be considered
          &#34;real&#34; Chrome URLs; they would have no access to
          <code>chrome.send()</code> or <code>Mojo</code>, and they couldn&#39;t
          get a window reference to a page with those permissions. Indeed,
          when I tried the <code>window.open()</code> part of the exploit on
          earlier versions of ChromeOS, the browser crashed both pages.
        </p>
        <p><img src="https://0x44.xyz/blog/cve-2023-4369/crash.png"/></p><p>
          But with the new code, this URL case was never handled.
        </p>
        <p>
          It&#39;s pure chance that I managed to find this bug--the main part of
          which had been lying undetected for years--only a month or so after
          the introduction of new code that made it even more critical. In the
          end, that part of the bug only existed in stable versions of
          ChromeOS from 115.0.5790.98 to 115.0.5790.170, which was a gap of
          less than one month. The basic XSS and capability to read downloaded
          files worked in older versions, though.
        </p>
        <p>
          The Image Loader bug wasn&#39;t new at all, however, and I could verify
          that it worked on versions as old as ChromeOS 99.
        </p>
        <p>
          Anyway, both bug reports were marked as fixed on August 8th.
          <a href="https://chromium-review.googlesource.com/c/chromium/src/+/4686653">The first fix</a>
          updated <code>WebUIConfig</code>--the new buggy code--to correctly
          handle <code>filesystem:chrome://</code> and
          <code>blob:chrome://</code> URLs.
          <a href="https://chromium-review.googlesource.com/c/chromium/src/+/4705137">The second fix</a>
          blocked <code>/external</code> files from being rendered in the
          browser, wiping out this type of bug for good.
        </p>
        <p>
          I was rewarded a total of $10,000 for the two bugs! The File Manager
          bug was given the CVE number 2023-4369 and was mentioned in the
          <a href="https://chromereleases.googleblog.com/2023/08/stable-channel-update-for-chromeos_25.html">ChromeOS
            116.0.5845.120 release notes.</a>
          Unfortunately, the Image Loader bug report has been dormant since
          its patch; as of the time of writing, it hasn&#39;t been given a CVE number
          or mentioned in uany update logs.
        </p>
        <p>
          Looking back at it all, I think this is my favorite find
          yet. Chrome extensions have always been interesting attack vectors
          for me, and I&#39;m a big fan of privilege escalation bugs, especially
          ones that don&#39;t require memory corruption. I hope you found this bug
          as cool as I did; thanks for reading!
        </p>
      </div>
    </div></div>
  </body>
</html>
