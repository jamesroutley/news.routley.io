<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/writing/imp-heterogenous-types/">Original</a>
    <h1>Imp: heterogenous types</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>This is a part of a series - start at the <a href="https://blog.benjojo.co.uk/writing/imp-intro/">beginning</a>.</em></p><p>Unlike sql, the denotational semantics for imp are carefully written to allow a set to contain rows of different lengths. The reason for that is that we can use such sets to model structs, tagged unions, first-class modules etc.</p><pre data-lang="imp"><code data-lang="imp"><span>// defining a module
</span><span>my_module:
</span><span>| &#34;inclinations&#34;, (
</span><span>    | &#34;alice&#34;, &#34;reasonable&#34;
</span><span>    | &#34;bob&#34;, &#34;silent&#34;
</span><span>    | &#34;eve&#34;, &#34;evil&#34;
</span><span>)
</span><span>| &#34;exprs&#34;, (
</span><span>    // tagged unions
</span><span>    | 0, &#34;constant&#34;, &#34;bob&#34;
</span><span>    | 1, &#34;constant&#34;, &#34;alice&#34;
</span><span>    | 2, &#34;union&#34;, 0, 1
</span><span>| &#34;plus_one&#34;, ?a a+1;
</span><span>
</span><span>// usage
</span><span>
</span><span>my_module &#34;inclinations&#34; &#34;eve&#34;
</span><span>// = &#34;evil&#34;
</span><span>
</span><span>my_module &#34;exprs&#34; 0 &#34;constant&#34;
</span><span>// = &#34;bob&#34;
</span><span>
</span><span>my_module &#34;exprs&#34; 2 &#34;constant&#34;
</span><span>// = none
</span><span>
</span><span>my_module &#34;plus_one&#34; 2
</span><span>// = 3
</span></code></pre><p>The type system doesn&#39;t currently allow this, because one of the goals for imp is to have the type system catch silly mistakes. Accidentally mixing rows of different lengths is a mistake I make often. So I want to find some way to allow intentional uses of mixed row lengths and types, but still catch as many accidental uses as possible.</p><h2 id="take-1">Take 1</h2><p>My original plan was to have special syntax that desugared to the code above but would be treated specially by the type system:</p><pre data-lang="imp"><code data-lang="imp"><span>// defining a module
</span><span>my_module: (
</span><span>  inclinations:
</span><span>    | &#34;alice&#34;, &#34;reasonable&#34;
</span><span>    | &#34;bob&#34;, &#34;silent&#34;
</span><span>    | &#34;eve&#34;, &#34;evil&#34;
</span><span>  exprs:
</span><span>    // tagged unions
</span><span>    | 0, (constant: &#34;bob&#34;)
</span><span>    | 1, (constant: &#34;alice&#34;)
</span><span>    | 2, (union: 0, 1)
</span><span>)
</span><span>// =
</span><span>// | &#34;inclinations&#34;, &#34;alice&#34;, &#34;reasonable&#34;
</span><span>// | &#34;inclinations&#34;, &#34;bob&#34;, &#34;silent&#34;
</span><span>// | &#34;inclinations&#34;, &#34;eve&#34;, &#34;evil&#34;
</span><span>// | &#34;exprs&#34;, 0, &#34;constant&#34;, &#34;bob&#34;
</span><span>// | &#34;exprs&#34;, 1, &#34;constant&#34;, &#34;alice&#34;
</span><span>// | &#34;exprs&#34;, 2, &#34;union&#34;, 0, 1
</span><span>//
</span><span>// has type:
</span><span>// (
</span><span>//   inclinations: text, text
</span><span>//   exprs: number, (
</span><span>//     constant: text 
</span><span>//     union: number, number
</span><span>//   ) 
</span><span>// )
</span><span>
</span><span>// usage 
</span><span>
</span><span>my_module :inclinations &#34;eve&#34;
</span><span>// = &#34;evil&#34;
</span><span>
</span><span>my_module :exprs 0 :constant
</span><span>// = &#34;bob&#34;
</span><span>
</span><span>my_module :exprs 2 :constant
</span><span>// = none
</span><span>
</span><span>my_module :plus_one 2
</span><span>// = 3
</span></code></pre><p>I like that this syntax piggybacks on the existing def syntax and that there is a nice visual symmetry between creating heterogenous values and unpacking them.</p><p>Having separate syntax for dealing with heterogenous values vs homogenous values also makes it much easier to catch mistakes at compile-time because there is a clear indication of intent. <code>&#34;foo&#34;, 1 | &#34;bar&#34;, &#34;quux&#34;</code> will produce a type error but <code>foo: 1; bar: &#34;quux&#34;</code> will produce a heterogenous value, even though the denotational semantics for both are the same.</p><p>In this version the syntax for dereferencing is <code>expr :name</code> - the code <code>:plus_one</code> by itself isn&#39;t a valid expression. This works fine, but it means that if we want to write code that is generic over it&#39;s input then the keys are just string and there is nothing for the type-checker to specialize on.</p><p>But the biggest problem is that the types here are determined by syntax rather than by the values. That&#39;s fine in a programming language, but in imp I have a database which can sync changes between peers. With this design if I hand you an arbitrary database over the wire then there isn&#39;t an obvious way to assign a type to it, because it&#39;s just a pile of strings.</p><p>I could require the database to also have an attached schema, but then I have to deal with syncing incompatible schema changes between different peers. Depending on how flexible the schema language is, there might not even be a compatible schema eg if Alice adds <code>(foo: 42)</code> and Bob adds <code>(foo: &#34;yo&#34;)</code> then there is no way to express the result in the type system above. I also think it&#39;s really powerful to be able to write type-checked queries over arbitrary input data without having to first define a schema for it. So compulsory schemas are definitely not an attractive solution.</p><h2 id="take-2">Take 2</h2><p><a href="https://www.relational.ai/">Rel</a> has a different approach to this. First, it allows arbitrary type unions. Second, the syntax <code>:foo</code> produces a value with type <code>:foo</code>, exactly like <a href="https://docs.julialang.org/en/v1/manual/types/#%22Value-types%22">Julia&#39;s value types</a>. Rel calls these RelNames, but in the imp code they&#39;re currently called tags.</p><p>If imp worked this way the example above would look like:</p><pre data-lang="imp"><code data-lang="imp"><span>my_module:
</span><span>  | :inclinations, (
</span><span>    | &#34;alice&#34;, &#34;reasonable&#34;
</span><span>    | &#34;bob&#34;, &#34;silent&#34;
</span><span>    | &#34;eve&#34;, &#34;evil&#34;
</span><span>  )
</span><span>  | :exprs, (
</span><span>    | 0, :constant, &#34;bob&#34;
</span><span>    | 1, :constant, &#34;alice&#34;
</span><span>    | 2, :union, 0, 1
</span><span>  )
</span><span>)
</span><span>// =
</span><span>// | :inclinations, &#34;alice&#34;, &#34;reasonable&#34;
</span><span>// | :inclinations, &#34;bob&#34;, &#34;silent&#34;
</span><span>// | :inclinations, &#34;eve&#34;, &#34;evil&#34;
</span><span>// | :exprs, 0, :constant, &#34;bob&#34;
</span><span>// | :exprs, 1, :constant, &#34;alice&#34;
</span><span>// | :exprs, 2, :union, 0, 1
</span><span>//
</span><span>// has type:
</span><span>// | :inclinations, text, text
</span><span>// | :exprs, number, :constant, text
</span><span>// | :exprs, number, :union, number, number
</span><span>
</span><span>my_module :inclinations &#34;eve&#34;
</span><span>// = &#34;evil&#34;
</span><span>
</span><span>my_module :exprs 0 :constant
</span><span>// = &#34;bob&#34;
</span><span>
</span><span>my_module :exprs 2 :constant
</span><span>// = none
</span><span>
</span><span>my_module :plus_one 2
</span><span>// = 3
</span></code></pre><p>(We could still keep the special syntax for both definitions and types, but I wrote it without in these examples for maximum clarity.)</p><p>This solves both of the problems in take 1. The compiler can specialize generic code on the type of the tags, and we can assign a type to any arbitary set by just unioning the types of each row.</p><p>But now catching mistakes becomes very hard. Rel does very little static checking at the moment, likely because it&#39;s hard to discern whether a type mismatch is intentional or a mistake. Here are some examples translated into imp:</p><pre data-lang="imp"><code data-lang="imp"><span>db:
</span><span>  | :foo, 42
</span><span>  | :bar, &#34;yo&#34;;
</span><span>inc: ?a a+1;
</span><span>inc_foo: ?k ?v
</span><span>  k :foo then :foo, v+1 else
</span><span>  k :bar then :bar, v;
</span><span>
</span><span>inc &#34;foo&#34;
</span><span>// = none
</span><span>// Can infer at compile time that this will never produce output.
</span><span>// This code is almost certainly a mistake.
</span><span>
</span><span>inc (1 | &#34;foo&#34;)
</span><span>// = 2
</span><span>// Can infer at compile time that the string input will be discarded, but that the number might be used.
</span><span>// This code is probably a mistake.
</span><span>
</span><span>inc_foo db
</span><span>// = :foo, 43 | :bar, &#34;yo&#34;
</span><span>// `inc_foo` is specialized separately for :foo and :bar.
</span><span>// In the :foo specialization can infer at compile time that the `k :bar` branch will never produce output.
</span><span>// In the :bar specialization can infer at compile time that the `k :foo` branch will never produce output.
</span><span>// This code is probably intentional.
</span><span>
</span><span>inc_foo (db | :foo, &#34;foo&#34;)
</span><span>// = :foo, 43 | :bar, &#34;yo&#34;
</span><span>// As above, but...
</span><span>// In the :foo,text specialization can infer at compile time that the `v+1` will never produce output.
</span><span>// This code is probably a mistake.
</span><span>
</span><span>inc_foo (db | :quux)
</span><span>// = :foo, 43 | :bar, &#34;yo&#34;
</span><span>// As above, but...
</span><span>// In the :quux specialization can infer at compile time that inc_foo will never produce output.
</span><span>// This might be a mistake, or we might be deliberately discarding the :quux rows.
</span><span>
</span><span>db :foo
</span><span>// = 42
</span><span>// Can infer at compile time that the :bar part of db will be discarded, but that the :foo part of db will be returned.
</span><span>// This code is almost certainly intentional.
</span><span>
</span><span>db :quux
</span><span>// = none
</span><span>// Can infer at compile time that this will never produce output.
</span><span>// Might be a mistake, or might just be that the :quux rows in db haven&#39;t yet been inserted, or have all been recently deleted.
</span></code></pre><p>I implemented this and played around with it for a while. The flexibility is great, but I find it easy to make mistakes and very hard to debug them.</p><p>The problem is that some of the intention has been lost. Narrowing a type might be deliberate or might be an oversight. A expression that never produces output might a mistake or might just be a branch that isn&#39;t taken in this specialization or with the current database.</p><h2 id="think">Think</h2><p>I thrashed around on this for a full week and tried a lot of different mechanisms. It&#39;s easy to get focused on one set of problems, get excited about a mechanism that solves those particular problems and then forget to check that it solves all the others.</p><p>So let&#39;s actually write down all the constraints:</p><ol><li>We want to be able to work with arbitrary sets of rows without requiring an upfront schema.</li><li>We want a guarantee that if two peers individually make valid changes to their dbs and then sync their changes, the combined change is also valid. This strongly limits what kinds of validation we can have at this layer. (See <a href="https://arxiv.org/pdf/1402.2237.pdf">I-confluence</a>).</li><li>We want to support short-lived interactive usage with minimal programmer overhead.</li><li>We want to be able to catch as many errors as possible in long-lived code.</li><li>From the point of view of the type-checker, it&#39;s hard to distinguish correct code from mistakes without additional information about intent.</li></ol><p>This implies that a good solution would:</p><ul><li>Be able to give a type to any valid data (1).</li><li>Allow arbitrary type unions, so that we can at least refer to and correct conflicts (2).</li><li>Only emit errors when the program is completely unrunnable (3).</li><li>Emit warnings for any code that looks remotely suspicious (4).</li><li>Allow adding additional information about intent to silence warnings (4 and 5).</li></ul><h2 id="take-42">Take 42</h2><p>This is where I ended up.</p><p>We start with the bare bones of take 2:</p><ul><li>The type of any expression is a union of row types eg <code>:constant, text | :union, number, number</code>.</li><li>The type of a tag is its value eg the type of <code>:foo</code> is <code>:foo</code>.</li></ul><p>We only produce errors for code that we cannot execute eg testing the equality of two maybe-infinite sets.</p><p>We produce warnings if:</p><ul><li>The type of an <code>=</code> or <code>&amp;</code> is empty and neither input had empty type.</li><li>In an apply expression: <ul><li>The left input type is finite and non-empty, the right input type is finite and non-empty and the result type is empty</li><li>The left input type is finite, the right type is non-finite and one of the row types in the left type has no matching type in the right type.</li><li>The right input type is finite, the left type is non-finite and one of the row types in the right type has no matching type in the left type.</li></ul></li><li>The condition of a <code>then</code> expression has a row type with length &gt; 0.</li><li>The input types to native functions (eg <code>+</code>) have the wrong types.</li></ul><p>Of the examples above, only <code>db :foo</code> doesn&#39;t produce warnings under these rules. The other examples are all suspicious.</p><p>To quell the compilers suspicions we can add extra information using some new syntax:</p><ul><li><code>a is? b</code> tests whether <code>a</code> is a subset of <code>b</code>. It returns <code>(a &amp; b) = a</code> but can often be inferred to be <code>none</code> at compile time. It never produces warnings. This is useful for branching on type.</li><li><code>a is! b</code> asserts that <code>a</code> ia a subset of <code>b</code>. It returns the value of <code>a</code> but produces a runtime error if <code>a</code> is not a subset of <code>b</code>. Produces a compile-time warning if the inferred type of <code>a</code> is not a subset of the inferred type of <code>b</code>. This is useful for the programmer to sanity-check their expectations.</li><li><code>a as b</code> returns <code>a &amp; b</code> but has the inferred type of <code>b</code>. This is useful for taking typed views of the database so that downstream code will not be broken by changes to the inferred schema over time.</li></ul><p>To express types we also add some new infinite sets: <code>number</code> and <code>text</code>.</p><p>Let&#39;s see how we can rewrite some of the examples above to silence the warnings:</p><pre data-lang="imp"><code data-lang="imp"><span>db:
</span><span>  | :foo, 42
</span><span>  | :bar, &#34;yo&#34;;
</span><span>inc: ?a a+1;
</span><span>inc_foo: ?k ?v
</span><span>  // use `is?` to test type
</span><span>  k is? :foo then :foo, v+1 else
</span><span>  k is? :bar then :bar, v;
</span><span>  
</span><span>inc ((1 | &#34;foo&#34;) as number)
</span><span>// = 2
</span><span>// Used `as number` to explicitly discard the text row, so no warning.
</span><span>
</span><span>inc_foo db
</span><span>// = :foo, 43 | :bar, &#34;yo&#34;
</span><span>// has type: :foo, number | :bar, text
</span><span>// The type test using `is` does not produce warnings
</span><span>
</span><span>inc_foo (:foo, 42)
</span><span>// = :foo, 43
</span><span>// has type: :foo, number
</span><span>// Correctly infers that the :bar branch of inc_foo can&#39;t be reached with this input
</span><span>
</span><span>inc_foo ((db | :foo, &#34;foo&#34;) as (:foo, number | :bar, text)
</span><span>// = :foo, 43 | :bar, &#34;yo&#34;
</span><span>// The `as` filters out the `:foo, &#34;foo&#34;` row.
</span><span>
</span><span>inc_foo ((db | :quux) as (:foo, number | :bar, text)
</span><span>// = :foo, 43 | :bar, &#34;yo&#34;
</span><span>// The `as` filters out the `:quux` row.
</span><span>
</span><span>inc_foo db is! (:foo, number)
</span><span>// Produces a runtime error because `:bar, &#34;yo&#34;` is not contained in `:foo, number`
</span><span>// Produces a compile time warning, because the inferred type of `inc_foo db` is `:foo, number | :bar, text`
</span><span>
</span><span>db: db as (:foo, number | :bar, text | :quux, number, text);
</span><span>db :quux
</span><span>// = none
</span><span>// has type: number, text
</span><span>// Uses `as` to tell the compiler that we expect that db might contain rows of type `:quux, number, text` in the future
</span></code></pre><p>I&#39;m really excited with how this turned out. We get a schemaless relational database with sound type inference, accurate warnings in interactive usage and gradual typing for long-lived code. Plus an expressive query language that can emulate strongly typed first-class modules and algebraic types but can still easily work with unstructured data.</p><p>As a bonus, I also allow tags to be numbers. This is useful for referring to columns eg:</p><pre><code><span>db:
</span><span>| :foo, 42
</span><span>| :bar, &#34;yo&#34;;
</span><span>
</span><span>db@ columns (:1, :0)@
</span><span>// = 
</span><span>// | 42, :foo
</span><span>// | &#34;yo&#34;, :bar
</span><span>//
</span><span>// has type: 
</span><span>// | number, :foo
</span><span>// | text, :bar
</span><span>
</span><span>db@ columns (:1 | :0)@
</span><span>// = 
</span><span>// | :foo
</span><span>// | :bar
</span><span>// | 42
</span><span>// | &#34;yo&#34;
</span><span>//
</span><span>// has type: 
</span><span>// | :foo
</span><span>// | :bar
</span><span>// | number
</span><span>// | text
</span><span>
</span><span>db@ pivot
</span><span>// (type number, row number, column number, value)
</span><span>// =
</span><span>// | :0, 0, :0, :foo
</span><span>// | :0, 0, :1, 42
</span><span>// | :1, 0, :0, :bar
</span><span>// | :1, 0, :1, &#34;yo&#34;
</span><span>// 
</span><span>// has type:
</span><span>// | :0, number, :0, :foo
</span><span>// | :0, number, :1, number
</span><span>// | :1, number, :0, :bar
</span><span>// | :1, number, :1, text
</span></code></pre></article></div>
  </body>
</html>
