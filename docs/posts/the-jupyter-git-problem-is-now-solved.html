<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fast.ai/2022/08/25/jupyter-git/">Original</a>
    <h1>The Jupyter&#43;Git problem is now solved</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>

<p><span>Written: 25 Aug 2022 by <i>Jeremy Howard</i></span></p><blockquote>
<p>Jupyter notebooks don’t work with git by default. With <a href="https://nbdev.fast.ai/">nbdev2</a>, the Jupyter+git problem has been totally solved. It provides a set of hooks which provide clean git diffs, solve most git conflicts automatically, and ensure that any remaining conflicts can be resolved entirely within the standard Jupyter notebook environment. To get started, follow the directions on <a href="https://nbdev.fast.ai/01_Tutorials/02_git_friendly_jupyter.html">Git-friendly Jupyter</a>.</p>
</blockquote>
<h3 id="contents">Contents</h3>
<ul id="markdown-toc">
<li><a href="#the-jupytergit-problem" id="markdown-toc-the-jupytergit-problem">The Jupyter+git problem</a></li>
<li><a href="#the-solution" id="markdown-toc-the-solution">The solution</a> <ul>
<li><a href="#the-nbdev2-git-merge-driver" id="markdown-toc-the-nbdev2-git-merge-driver">The nbdev2 git merge driver</a></li>
<li><a href="#the-nbdev2-jupyter-save-hook" id="markdown-toc-the-nbdev2-jupyter-save-hook">The nbdev2 Jupyter save hook</a></li>
</ul>
</li>
<li><a href="#background" id="markdown-toc-background">Background</a></li>
<li><a href="#the-result" id="markdown-toc-the-result">The result</a></li>
<li><a href="#postscript-other-jupytergit-tools" id="markdown-toc-postscript-other-jupytergit-tools">Postscript: other Jupyter+git tools</a> <ul>
<li><a href="#reviewnb" id="markdown-toc-reviewnb">ReviewNB</a></li>
<li><a href="#an-alternative-solution-jupytext" id="markdown-toc-an-alternative-solution-jupytext">An alternative solution: Jupytext</a></li>
<li><a href="#nbdime" id="markdown-toc-nbdime">nbdime</a></li>
</ul>
</li>
</ul>
<h2 id="the-jupytergit-problem">The Jupyter+git problem</h2>
<p><a href="https://Jupyter.org/">Jupyter notebooks</a> are a powerful tool for scientists, engineers, technical writers, students, teachers, and more. They provide an ideal <a href="https://en.wikipedia.org/wiki/Lab_notebook">notebook</a> environment for interactively exploring data and code, writing programs, and documenting the results as dashboards, books, or blogs.</p>
<p>But when collaborating with others, this ideal environment goes up in smoke. That’s because tools such as git, which are the most popular approaches for asynchronous collaboration, makes notebooks unusable. Literally. Here’s what it looks like if you and a colleague both modify a notebook cell (including, in many cases, simply executing a cell withuout changing it), and then try to open that notebook later:</p>
<figure>
<img srcset="/images/unreadable-notebook.png 2w" sizes="1px" src="https://www.fast.ai/images/unreadable-notebook.png"/>
</figure>
<p>The reason for this stems from a fundamental incompatibility between the format Jupyter notebooks use (JSON) and the format that git conflict markers assume by default (plain lines of text). This is what it looks like when git adds its conflict markers to a notebook:</p>
<div><div><pre><code>   &#34;source&#34;: [
&lt;&lt;&lt;&lt;&lt;&lt; HEAD
    &#34;z=3\n&#34;,
======
    &#34;z=2\n&#34;,
&gt;&gt;&gt;&gt;&gt;&gt; a7ec1b0bfb8e23b05fd0a2e6cafcb41cd0fb1c35
    &#34;z&#34;
   ]
</code></pre></div></div>
<p>That’s not valid JSON, and therefore Jupyter can’t open it. Conflicts are particularly common in notebooks, because Jupyter changes the following every time you run a notebook:</p>
<ul>
<li>Every cell includes a number indicating what order it was run in. If you and a colleague run the cells in different orders, you’ll have a conflict in every single cell! This would take a very long time to fix manually</li>
<li>For every figure, such as a plot, Jupyter includes not only the image itself in the notebook, but also a plain text description that includes the <code>id</code> (like a memory address) of the object, such as <code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fbc113dbe90&gt;</code>. This changes every time you execute a notebook, and therefore will create a conflict every time two people execute this cell</li>
<li>Some outputs may be non-deterministic, such as a notebook that uses random numbers, or that interacts with a service that provides different outputs over time (such as a weather service)</li>
<li>Jupyter adds metadata to the notebook describing the environment it was last run in, such as the name of the kernel. This often varies across installations, and therefore two people saving a notebook (even without and other changes) will often end up with a conflict in the metadata.</li>
</ul>
<p>All these changes to notebook files also make git diffs of notebooks very verbose. This can make code reviews a challenge, and make git repos more bulky than necessary.</p>
<p>The result of these problems is that many Jupyter users feel that collaborating with notebooks is a clunky, error-prone, and frustrating experience. (We’ve even seen people on social media describe Jupyter’s notebook format as “stupid” or “terrible”, despite otherwise professing their love for the software!)</p>
<p>It turns out, however, that Jupyter and git can work together extremely well, with none of the above problems at all. All that’s needed is a bit of special software…</p>
<h2 id="the-solution">The solution</h2>
<p>Jupyter and git are both well-designed software systems that provide many powerful extensibility mechanisms. It turns out that we can use these to fully and automatically solve the Jupyter+git problem. We identified two categories of problems in the previous section:</p>
<ol>
<li>git conflicts lead to broken notebooks</li>
<li>Unnecessary conflicts due to metadata and outputs.</li>
</ol>
<p>In our newly released <a href="https://nbdev.fast.ai/">nbdev2</a>, an open source Jupyter-based development platform, we’ve solve each of the problems:</p>
<ol>
<li>A new <em>merge driver</em> for git provides “notebook-native” conflict markers, resulting in notebooks that can be opened directly in Jupyter, even when there are git conflicts</li>
<li>A new <em>save hook</em> for Jupyter automatically removes all unnecessary metadata and non-deterministic cell output.</li>
</ol>
<p>Here’s what a conflict looks like in Jupyter with nbdev’s merge driver:</p>
<figure>
<img srcset="/images/friendly-conflict.png 2w" sizes="1px" src="https://www.fast.ai/images/friendly-conflict.png"/>
</figure>
<p>As you see, the local and remote change are each clearly displayed as separate cells in the notebook, allowing you to simply delete the version you don’t want to keep, or combine the two cells as needed.</p>
<p>The techniques used to make the merge driver work are quite fascinating – let’s dive into the details!</p>
<h3 id="the-nbdev2-git-merge-driver">The nbdev2 git merge driver</h3>
<p>We provide here a summary of the git merge driver – for full details and source code see the <a href="https://nbdev.fast.ai/merge.html"><code>nbdev.merge</code> docs</a>. Amazingly enough, the entire implementation is just 58 lines of code!</p>
<p>The basic idea is to first “undo” the original git merge which created the conflict, and then “redo” it at a cell level (instead of a line level) and looking only at cell source (not outputs or metadata). The “undoing” is straightforward: just create two copies of the conflicted file (representing the local and remove versions of the file), go through each git conflict marker, and replace the conflict section with either the local or remote version of the code.</p>
<p>Now that we’ve got the original local and remote notebooks, we can load the json using <a href="https://fastai.github.io/execnb/nbio.html"><code>execnb.nbio</code></a>, which will then give us an array of cells for each notebook. Now we’re up to the interesting bit – creating cell-level diffs based only on the cell source.</p>
<p>The Python standard library contains a very flexible and effective implementation of a diff algorithm in the <code>difflib</code> module. In particular, the <a href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher"><code>SequenceMatcher</code></a> class provides the fundamental building blocks for implementing your own conflict resolution system. We pass the two sets of cells (remote and local) to <code>SequenceMatcher(...).get_matching_blocks()</code>, and it returns a list of each section of cells that match (i.e. have no conflicts/differences). We can then go through each matching section and copy them into the final notebook, and through each non-matching section and copy in each of the remote and local cells (add cells between them to mark the conflicts).</p>
<p>Making <code>SequenceMatcher</code> work with notebook cells (represented in nbdev by the <code>NbCell</code> class) requires only adding <code>__hash__</code> and <code>__eq__</code> methods to <code>NbCell</code>. In each case, these methods are defined to look only at the actual source code, and not at any metadata or outputs. As a result, <code>SequenceMatcher</code> will only show differences in source code, and will ignore differences in everything else.</p>
<p>With a single line of configuration, we can ask git to call our python script, instead of its default line-based implementation, any time it is merging changes. <code>nbdev_install_hooks</code> sets up this configuration automatically, so after running it, git conflicts become much less common, and never result in broken notebooks.</p>
<h3 id="the-nbdev2-jupyter-save-hook">The nbdev2 Jupyter save hook</h3>
<p>Solving git merges locally is extremely helpful, but we need to solve them remotely as well. For instance, if a contributor submits a pull request (PR), and then someone else commits to the same notebook before the PR is merged, the PR might now have a conflict like this:</p>
<div><div><pre><code>   &#34;outputs&#34;: [
    {
&lt;&lt;&lt;&lt;&lt;&lt; HEAD
     &#34;execution_count&#34;: 7,
======
     &#34;execution_count&#34;: 5,
&gt;&gt;&gt;&gt;&gt;&gt; a7ec1b0bfb8e23b05fd0a2e6cafcb41cd0fb1c35
     &#34;metadata&#34;: {},
</code></pre></div></div>
<p>This conflict shows that the two contributors have run cells in different orders (or perhaps one added a couple of cells above in the notebook), so their commits have conflicting execution counts. GitHub will refuse to allow this PR to be merged until this conflict is fixed.</p>
<p>But of course we don’t really care about the conflict at all – it doesn’t matter what, if any, execution count is stored in the notebook. So we’d really prefer to ignore this difference entirely!</p>
<p>Thankfully, Jupyter provides a “pre-save” hook which allows code to be run every time a notebook is saved. nbdev uses this to set up a hook which removes all unnecessary metadata (including <code>execution_count</code>) on saving. That means there’s no pointless conflicts like the one above, because no commits will have this information stored in the first place.</p>
<h2 id="background">Background</h2>
<p>Here at fast.ai we use Jupyter for everything. All our tests, documentation, and module source code for all of our many libraries is entirely developed in notebooks (using nbdev, of course!) And we use git for all our libraries too. Some of our repositories have many hundreds of contributors. Therefore solving the Jupyter+git problem has been critical for us. The solution presented here is the result of years of work by many people.</p>
<p>Our first approach, developed by Stas Bekman and me, was to use git <a href="https://bignerdranch.com/blog/git-smudge-and-clean-filters-making-changes-so-you-dont-have-to/">“smudge” and “clean” filters</a> that automatically rewrote all notebook json to remove unneeded metadata when committing. This helped a bit, but git quite often ended up in an odd state where it was impossible to merge.</p>
<p>In nbdev v1 Sylvain Gugger created an amazing tool called <code>nbdev_fix_merge</code> which used very clever custom logic to manually fix merge conflicts in notebooks, to ensure that they could opened in Jupyter. For nbdev v2 I did a from-scratch rewrite of every part of the library, and I realised that we could replace the custom logic with the <code>SequenceMatcher</code> approach described above.</p>
<p>None of these steps fully resolved the Jupyter+git problem, since we were getting frequent merge errors caused by the smudge/clean git filters, and conflicts required manually running <code>nbdev_fix_merge</code>. Wasim Lorgat realised that we could resolve the smudge/clean issue by moving that logic into an nbdev save hook, and avoid the manual fix step by moving that logic into a git merge driver. This resolved the final remaining issues! (I was actually quite stunned that Wasim went from our first discussion of the outstanding problems, to figuring out how to solve all of them, in the space of about two days…)</p>
<h2 id="the-result">The result</h2>
<p>The new tools in nbdev2, which we’ve been using internally for the last few months, have been transformational to our workflow. <strong>The Jupyter+git problem has been totally solved.</strong> I’ve seen no unnecessary conflicts, cell-level merges have worked like magic, and on the few occassions where I’ve changed the source in the same cell as a collaborator, fixing the conflict in Jupyter has been straightforward and convenient.</p>
<h2 id="postscript-other-jupytergit-tools">Postscript: other Jupyter+git tools</h2>
<h3 id="reviewnb">ReviewNB</h3>
<p>There is one other tool which we’ve found very helpful in using Jupyter with git, which is <a href="https://www.reviewnb.com/">ReviewNB</a>. ReviewNB solves the problem of doing pull requests with notebooks. GitHub’s code review GUI only works well for line-based file formats, such as plain python scripts. This works fine with the Python modules that nbdev exports, and I often do reviews directly on the Python files, instead of the source notebooks.</p>
<p>However, much of the time I’d rather do reviews on the source notebooks, because:</p>
<ul>
<li>I want to review the documentation and tests, not just the implementation</li>
<li>I want to see the changes to cell outputs, such as charts and tables, not just the code.</li>
</ul>
<p>For this purpose, ReviewNB is perfect. Just like nbdev makes git merges and commits Jupyter-friendly, ReviewNB makes code reviews Jupyter-friendly. A picture is worth a thousand words, so rather than trying to explain, I’ll just show this picture from the ReviewNB website of what PRs look like in their interface:</p>
<p><img src="https://uploads-ssl.webflow.com/5ba4ebe021cb91ae35dbf88c/61f800c83d99ed2f1810b6e4_visual_diff_2.png" alt=""/></p>
<h3 id="an-alternative-solution-jupytext">An alternative solution: Jupytext</h3>
<p>Another potential solution to the Jupyter+git problem might be to use <a href="https://jupytext.readthedocs.io/en/latest/index.html">Jupytext</a>. Jupytext saves notebooks in a line-based format, instead of in JSON. This means that all the usual git machinery, such as merges and PRs, works fine. Jupytext can even use <a href="https://quarto.org/">Quarto’s</a> format, <code>qmd</code>, as a format for saving notebooks, which then can be used to generate a website.</p>
<p>Jupytext can be a bit tricky to manage when you want to save your cell outputs (which I generally want to do, since many of my notebooks take a long time to run – e.g training deep learning models.) Whilst Jupytext can save outputs in a linked <code>ipynb</code> file, managing this linkage gets complex, and ends up with the Jupyter+git problem all over again! If you don’t need to save outputs, then you might find Jupytext sufficient – although of course you’ll miss out on the cell-based code reviews of ReviewNB and your users won’t be able to read your notebooks properly when they’re browsing GitHub.</p>
<h3 id="nbdime">nbdime</h3>
<p>There’s also an interesting project called <a href="https://nbdime.readthedocs.io/en/latest/">nbdime</a> which has its own git drivers and filters. Since they’re not really compatible with nbdev (partly because they tackle some of the same problems in different ways) I haven’t used them much, so haven’t got an informed opinion about them. However I do use nbdime’s Jupyter extension sometimes, which provides a view similar to ReviewNB, but for local changes instead of PRs.</p>
<p>If you want to try to yourself, follow the directions on <a href="https://nbdev.fast.ai/01_Tutorials/02_git_friendly_jupyter.html">Git-friendly Jupyter</a> to get started.</p>
</div>

</div></div>
  </body>
</html>
