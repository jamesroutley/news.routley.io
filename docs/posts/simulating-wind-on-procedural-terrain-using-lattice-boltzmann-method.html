<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickmcd.me/2022/10/01/procedural-wind-and-clouds-using-gpu-accelerated-lattice-boltzmann-method/">Original</a>
    <h1>Simulating Wind on Procedural Terrain Using Lattice Boltzmann Method</h1>
    
    <div id="readability-page-1" class="page"><div>

				
<p><strong>Note:</strong> The full source code for this article can be found <a href="https://github.com/weigert/TinyEngine/tree/examples/examples/20_LBM3D">here</a> (summarized version). Individual sections contain references to specific code snippets below.</p>



<p>For a long time I have been working on generating terrain by simulating geomorphological processes. This primarily includes various forms of erosion, i.e. hydraulic, thermal and wind erosion processes. I believe that in order to generate interesting terrain, you have to simulate processes which are often as complex as they are subtle.</p>



<p>I have always been intrigued by the fact that the atmosphere is a major driving force behind geomorphological processes.</p>



<p>From climatological patterns, to wind-shadow effects and the coupling to vegetation and erosion, the movement of mass and energy through wind is an important contributor.</p>



<p>Initially, I was motivated by the idea of simulating cloud patterns with realistic coupling to the terrain. While highly complex, it always seemed like a fascinating goal.</p>



<p>While I made some previous attempts at simulating clouds, climate and wind patterns, these were all in 2.5D, which I found insufficient to simulate a real micro-climate.</p>



<p><strong>Note:</strong> May interesting atmospheric phenomena, such as updrafts, require a 3D or layered atmospheric model. Some of my previous attempts included Finite Volume Methods, Cellular Automata.</p>



<p>I decided to overcome this by stepping into 3D simulation of wind on terrain using the <strong>Lattice Boltzmann Method</strong>. I chose to focus on wind simulation first, because a good wind model can act as the base for future atmospheric simulation.</p>



<p>In this article, I want to give context to the relation between the physical and mathematical modelling of fluid flow problems and explain the <strong>Lattice Boltzmann Method</strong>.</p>



<p>Then I will show how I apply this method to <strong>wind on terrain</strong>, and present an implementation (with code samples) in <strong>GPU accelerated</strong> form using compute shaders in OpenGL4 / C++.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/LBM3D_Terrain-2022-10-08_16.36.02.mp4"></video><figcaption>Real-Time Wind on Terrain Visualization. The terrain was generated using my SimpleHydrology system (<a href="https://github.com/weigert/SimpleHydrology">code</a>, <a href="https://nickmcd.me/2020/04/15/procedural-hydrology/">article</a>).</figcaption></figure>







<h2>Wind as a Fluid Flow Problem</h2>



<p><strong>Note:</strong> This section assumes familiarity with calculus of integrals and derivatives, in order to relate mathematical and physical models. Feel free to skip it if you are familiar with computational fluid dynamics or are only interested in the implementation.<br/></p>



<h3>What is a Fluid?</h3>



<p>While we know intuitively that <em>water is a fluid</em>, it surprised me to learn in my first fluid mechanics lecture that the definition of a fluid has nothing to do with gaseous or liquid states of matter. In fact the definition is much more precise.</p>



<p><strong>So what is a fluid?</strong><br/></p>



<p><a href="https://en.wikipedia.org/wiki/Fluid">According to Wikipedia</a>, a fluid is a medium which cannot resist any shear stress applied to it. This means that it does not resist deformation by an external force.</p>



<p>In contrast, a solid resists “deformation” (e.g. by generating an elastic restoring force proportional to the shear force), while a fluid does not and simply deforms.</p>



<p><strong>Note:</strong> In general, <a href="https://en.wikipedia.org/wiki/Viscosity#Newtonian_and_non-Newtonian_fluids">different types of medium</a> (fluid, solid, viscoelastic fluid, non-newtonian etc.) can be classified by the relation between applied shear-force and internal rate of deformation (a.k.a. “strain”)!</p>



<figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Viscous_regimes_chart.png/589px-Viscous_regimes_chart.png?20170321235735" alt="File:Viscous regimes chart.png"/><figcaption>A chart showing the relationship between shear stress and strain for various mediums. A newtonian fluid has a linear relationship, while a non-newtonian fluid like Ooblek is shear thickening. In this graph, a solid would be represented by a vertical line from the origin.</figcaption></figure>



<p>By this definition, <strong>air is a fluid</strong>, since it behaves like a fluid as defined by its deformation behavior, and thus we can apply the laws of fluid mechanics to it.</p>



<h3>Discrete and Continuous Mechanics</h3>



<p>While <a href="https://en.wikipedia.org/wiki/Classical_mechanics">Classical Mechanics</a> models how discrete particles with mass behave under the application of different forces, <a href="https://en.wikipedia.org/wiki/Continuum_mechanics">Continuum Mechanics</a> applies the same principles to a mass where properties change continuously in space.</p>



<p>One well-known result from classical mechanics is the <a href="https://en.wikipedia.org/wiki/Elastic_collision">elastic collision</a>, which results from the application of the <strong>conservation of mass, momentum and energy</strong> to discrete, colliding masses.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/2DBallCollision-2022-10-08_20.19.04.mp4"></video><figcaption>A GPU implementation of N-Ball elastic collisions with boundary conditions. Note that each particle has discrete properties, such as velocity. Applying a constant right-ward body force to all particles gives the appearance of flow around the cylinders. NParticles = 20’000</figcaption></figure>



<p>Similarly, a well-known result from fluid mechanics are the <strong><a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes Equations</a></strong>, which fundamentally encode the principles of <strong>conservation of mass, momentum and energy</strong> (“<strong><a href="https://en.wikipedia.org/wiki/Conservation_law">conservation laws</a></strong>“); as applied to a continuum.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/LBM2D-2022-10-08_15.56.56.mp4"></video><figcaption>A similar simulation, where flow around cylinders is shown. Note that we compute a continuous velocity field over the entire domain, instead of at specific locations. This is implemented as a 2D Lattice Boltzmann simulation on the GPU.</figcaption></figure>



<p><strong>Note:</strong> The Navier-Stokes Equations (for newtonian fluids) are derived by combining the <strong>differential forms of the conservation laws</strong> with a linear relationship for the shear-stress strain relationship, proportional to the fluid viscosity.</p>



<p>The mathematical tool we use to express conservation laws “continuously” are <strong>partial differential equations</strong> (PDE).</p>



<p><strong>Note:</strong> Fluid mechanics is a discipline of continuum mechanics. Continuum mechanics also apply to solid mechanics.  The Navier-Stokes equations are partial differential equations.</p>



<h3>The (Differential) Conservation Law</h3>



<p>A <a href="https://en.wikipedia.org/wiki/Partial_differential_equation">partial differential equation</a> relates the <strong>partial derivatives</strong> of an <strong>unknown multivariable function</strong> to each other, thereby describing its behavior in various dimensions (commonly space, time) and implicitly defining the function.</p>



<p>A PDE can be interpreted as a <strong>constraint</strong>, and solving a PDE means finding functions which satisfy the constraint.</p>



<p><strong>Note:</strong> A function which satisfies a given PDE is generally not known, and is generally not guaranteed to exist or be unique, e.g. a PDE can be satisfied by a family of functions.</p>



<p>A <a href="https://en.wikipedia.org/wiki/Conservation_law">differential conservation law</a> is a PDE which describes the behavior of a continuous function of a <strong>conserved quantity</strong>. We construct the differential conservation law in such a way that it <strong>enforces conservation as a constraint</strong> (see below).</p>



<p>Writing any physically conserved quantity as a function of time and space, this function must satisfy the differential conservation law PDE constraint in order to be conserved.</p>



<p>How can we express a conservation law as a PDE?</p>



<p><strong>Note:</strong> There are different types of PDE, and conservation laws are typically “<strong>hyperbolic</strong>“. This implies that disturbances in time and space move with finite speed. The other types of PDE are elliptic and parabolic, and exhibit different properties.</p>



<h4>The Advection-Diffusion Equation</h4>



<p>One of the most basic <strong>differential conservation laws</strong> is the “<strong><a href="https://en.wikipedia.org/wiki/Convection%E2%80%93diffusion_equation">Advection-Diffusion Equation</a></strong>“, which describes how mass is conserved for a diffusing, dilute solute in a moving fluid.</p>


<p><span> (1) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-94c23abe61e3b575f391b118364c779f_l3.png" height="54" width="340" alt="\begin{equation*} \frac{\partial c }{\partial t} = \nabla \cdot (D\nabla c) - \nabla \cdot ( v c ) + R \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>This states that <em>the derivative of the solute concentration in time (at a fixed location) is given by the sum of three terms: The diffusion term, the advection term and the source term</em>.</p>



<p><strong>Note:</strong> The diffusion term derives from <a href="https://en.wikipedia.org/wiki/Fick%27s_laws_of_diffusion">Fick’s Law</a>, which states that solute <strong>flux</strong> is proportional to the concentration gradient. The advective <strong>flux</strong> is proportional to the concentration times the fluid velocity. Taking the <strong>gradient of the flux</strong> then yields the <strong>accumulation</strong>, equivalent to (<em>what goes in</em>) – (<em>what goes out</em>). The source term <strong>R</strong> is the only “non-conservative” term, and describes the generation or destruction of <strong>c</strong> in the volume.</p>



<p>Setting the source <strong>R</strong> to 0 means that the only way for mass to enter or leave a volume is by diffusion or advecting across the differential volume boundary, thus <strong>conserving mass</strong>.</p>



<p>More generally, conservation laws express the constraint:</p>



<p><strong>what goes in minus what goes out is what accumulates inside</strong></p>



<p>For mass, this means mass is never generated anywhere, but has to come from across the boundary (i.e. somewhere else).</p>



<figure><img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/GaussianUpwind2D.gif?20161127062043" alt=""/><figcaption>Example of the Advection-Diffusion-Equation acting on a 2D function. As the PDE evolves the function time, the integral of the function (i.e. mass / volume) is conserved. Source: <a href="https://commons.wikimedia.org/wiki/User:Shiyu_Ji">Shiyu Ji</a>, <a href="https://commons.wikimedia.org/wiki/File:GaussianUpwind2D.gif">Wikimedia Commons</a></figcaption></figure>



<h3>Numerical Solution of PDEs</h3>



<p>Given a PDE and sufficient boundary and initial conditions (<strong>BC</strong>, <strong>IC</strong>), we wish to find a function which satisfies the PDE.</p>



<p>Integrating PDEs <strong>analytically</strong>, and in particular the Navier-Stokes Equations, is typically only possible for a small number of well-known problem statements with simple boundary and initial conditions (e.g. <a href="https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation">Hagen-Poiseuille-Flow</a>).</p>



<p>Solving problems with more complex initial- and boundary- conditions requires making approximations in the form of <strong>numerical methods</strong>. </p>



<p>Even with numerical methods, solution of PDEs for various problem statements defies a one-size-fits-all approach. </p>



<p>This has spawned a large ecosystem of methods and tools for the solution of PDEs, but most of them involve some form of <strong>discretization</strong> and subsequent <strong>numerical</strong> <strong>integration</strong> of the continuous equations. Each method makes different assumptions and approximations, resulting in varying efficiency, accuracy and stability. </p>



<p>Computational Fluid Dynamics (<strong>CFD</strong>) therefore concerns itself with the <strong>numerical</strong> solution of fluid flow problems, and a large area of research is focused on improving the speed, accuracy and stability of these methods for solving PDEs.</p>



<p>One such method is the Lattice-Boltzmann Method. While the Boltzmann Equation is generally more difficult to solve analytically, it has computational advantages as we will see.<br/></p>



<p><strong>Note:</strong> The three most common “direct” solution methods for the NSE are the Finite Difference (FD), Finite Volume (FV) and Finite Element (FE) methods. Each uses a different approach to discretising, integrating and boundary condition handling.</p>



<h2>The Lattice Boltzmann Method</h2>



<p><strong>Note:</strong> The main source for the following description is the book “<strong>The Lattice Boltzmann Method, Principles and Practice”</strong> (2017) by Timm Krueger. I recommend reading it for details.</p>



<p>The <a href="https://en.wikipedia.org/wiki/Lattice_Boltzmann_methods">Lattice Boltzmann Method</a> (<strong>LBM</strong>) is a <strong>numerical method for fluid flow simulation</strong>, which similar to other methods aims to satisfy the fundamental conservation laws.</p>



<p>The key difference is that the Lattice Boltzmann Method does not solve for the macroscopic properties of the fluid (density, energy, momentum) directly, but uses a different variable (the <strong>Particle Distribution Function</strong>) and differential conservation law PDE (the <strong>Boltzmann Equation</strong>), which together indirectly satisfy the conservation constraints.</p>



<p>Computationally, this change of problem framing represents a new trade-off between <strong>parallelism vs. memory efficiency</strong> of the problem, which lends itself to GPU acceleration.</p>



<p>In the following chapter, I will present the <strong>Boltzmann Equation</strong>, its variable the <strong>Particle Distribution Function</strong>, and how these two concepts relate to our differential conservation laws. </p>



<p>Finally, I will show how the Boltzmann Equation is solved numerically on a lattice as the LBM, and how we can exploit the parallelism of LBM for efficient <strong>GPU acceleration</strong>.</p>



<h3>The Particle Distribution Function</h3>



<p>While the <strong>Navier-Stokes Equations</strong> (NSE) explicitly model the evolution of macroscopic properties (density, energy, momentum) through <strong>partial differential equations</strong> (PDE), the <strong>Boltzmann-Equation</strong> is a single PDE which models the evolution of the particle distribution function <strong>f</strong>, from which these macroscopic properties can be derived.</p>



<p>The particle distribution function <strong>f</strong> is a probability density, which gives the probability of finding a particle with position <strong>x</strong> and velocity <strong>v</strong> at time <strong>t</strong>.<br/></p>


<p><span> (2) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-ace5ed0ad0a7ab07e882c722c71a0365_l3.png" height="26" width="91" alt="\begin{equation*} f(x,v,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>In 2D and 3D, the particle distribution function is a function of 5 and 7 parameters respectively.</p>



<p><strong>Note:</strong> One can therefore say that the LBM models the evolution and interaction of a group of particles as described by <strong>f</strong>.</p>



<h4>Deriving Macroscopic Properties</h4>



<p>The particle distribution function allows us to derive the original, locally conserved macroscopic fluid properties. In fact, the macroscopic fluid properties can be derived as the<strong> <a href="https://en.wikipedia.org/wiki/Moment_(mathematics)">moments</a> of the particle distribution function.</strong></p>



<p>The <strong>macroscopic density</strong> is given by the zeroth moment of <strong>f</strong> in <strong>v</strong>, given by the integral of <strong>f</strong> over the space of velocities:</p>


<p><span> (3) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-8c9809f3eb1212ee40ef8c43d2a450a0_l3.png" height="57" width="176" alt="\begin{equation*} \rho(x,t) = \int f\,dv \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>Similarly, the <strong>macroscopic momentum density</strong> is given by the first order moment of <strong>f</strong> in <strong>v</strong>:</p>


<p><span> (4) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-bbb48f3d6592e5d79c291fd6b308cbda_l3.png" height="57" width="258" alt="\begin{equation*} \rho(x,t)u(x,t) = \int vf\,dv \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>and the <strong>macroscopic total energy density</strong> is given by the second order moment of <strong>f</strong> in <strong>v</strong>, expressed as:</p>


<p><span> (5) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-917c7e8e4084c6e2387f389a63f285a1_l3.png" height="57" width="310" alt="\begin{equation*} \rho(x,t)E(x,t) = \frac{1}{2}\int |v|^2f\,dv \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p><strong>Note:</strong> The quantities shown here are macroscopic densities. Dividing by the density (i.e. zeroth moment or cardinality), gives us our normalized macroscopic quantities.<br/></p>



<p>For a given <strong>particle distribution function</strong> over space, time and velocity we can thus compute the following quantities:</p>



<ol><li>macroscopic density</li><li>macroscopic momentum (from 1)</li><li>macroscopic total energy (from 1)</li><li>macroscopic bulk velocity (from 1, 2)</li><li>macroscopic internal energy (from 4)</li><li>temperature, pressure (from 5)</li></ol>



<p><strong>Note:</strong> The <strong>macroscopic total energy density</strong> includes contributions from the <strong>internal energy</strong> and <strong>bulk motion</strong>. We isolate the internal energy by computing the second moment with the relative velocity (i.e. subtract the bulk velocity).</p>



<h3>The Boltzmann Equation</h3>



<p>The <strong>Boltzmann-Equation</strong> is a <strong>partial differential equation</strong> which describes the evolution of the particle distribution function <strong>f</strong>. Taking the <strong><a href="https://en.wikipedia.org/wiki/Total_derivative">total derivative</a></strong> of <strong>f</strong> wrt. time we get:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-3cbed02e69f81fa0763bd26a71983b3d_l3.png" height="62" width="480" alt="\begin{equation*} \frac{df}{dt} = \bigg(\frac{\partial f}{\partial t}\bigg)\frac{dt}{dt} + \bigg(\frac{\partial f}{\partial x_\beta}\bigg)\frac{dx_\beta}{dt} + \bigg(\frac{\partial f}{\partial v_\beta}\bigg)\frac{dv_\beta}{dt} \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>which can be simplified to the <strong>Boltzmann Equation</strong>:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-3505da9d8588b07ca11e8e7bf2413dd7_l3.png" height="61" width="397" alt="\begin{equation*} \frac{df}{dt} = \frac{\partial f}{\partial t} + v_\beta \frac{\partial f}{\partial x_\beta} + \frac{F_\beta}{\rho}\frac{\partial f}{\partial v_\beta} = \Omega(f) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>by expressing the change of position as proportional to velocity and change of velocity as proportional to force.</p>



<p><strong>Note:</strong> The <a href="https://en.wikipedia.org/wiki/Total_derivative">total derivative</a> of a function wrt. to its arguments captures all contributing terms to the change of a quantity.</p>



<p>This resembles a differential conservation law similar to the advection-diffusion equation. The first two terms relate the change of the distribution at a position due to advection of the distribution with velocity <strong>v</strong>. The third term represents changes in the distribution due to some force <strong>F</strong>. </p>



<p>Finally, the entire equation is equal to a <strong>source term</strong> Ω, which represents the redistribution of <strong>f</strong> in time due to particle collisions, and is thus known as the <strong>collision operator</strong>.</p>



<p>Choosing the <strong>collision operator</strong> such that the conservation law constraints are fulfilled is what allows the <strong>Boltzmann-Equation</strong> to model the <strong>macroscopic behavior</strong> of a fluid and thus the <strong>Navier-Stokes Equations</strong>.</p>



<p><strong>Note:</strong> The Boltzmann-Equation provides a second order accurate approximation of the Navier-Stokes Equations. For a detailed derivation on how and to what accuracy the <strong>Boltzmann-Equation</strong> approximates the <strong>NSE</strong>, I refer you to the book “The Lattice Boltzmann Method – Principles and Practice” by Tim Krüger or <a href="https://en.wikipedia.org/wiki/Chapman–Enskog_theory"><strong>Chapman-Enskog theory</strong></a>.</p>



<h3>The Collision Operator</h3>



<p>A valid collision operator should enforce the conservation of <strong>mass</strong>, <strong>momentum</strong> and <strong>energy</strong> as well as the relaxation of the distribution to equilibrium. How do we enforce this?</p>



<p>We know that the <strong>collision operator</strong> Ω is equal to the total derivative of our particle distribution function <strong>f</strong>:<br/></p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-af88c9ba0779afbe4cd34236363a3efc_l3.png" height="53" width="112" alt="\begin{equation*} \frac{df}{dt} = \Omega(f) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>Using the fact that the total derivative of our conserved macroscopic quantities is zero, we can apply the expressions for these quantities as the moments of <strong>f</strong> to directly enforce the conservation constraints on Ω.</p>



<p>For <strong>mass </strong>conservation, we can write:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-6ed96cbce269e57b0167e970a2894a5e_l3.png" height="58" width="451" alt="\begin{equation*} \frac{d\rho}{dt} = \frac{d}{dt}\int f\,dv = \int \frac{df}{dt}\,dv = \int \Omega\,dv = 0 \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>and similarly for <strong>momentum</strong> and <strong>energy</strong> conservation:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-4f822b04ea37e518bb521ccc50780dd2_l3.png" height="57" width="140" alt="\begin{equation*} \int v\,\Omega\,dv = 0 \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-7de2ec2d1cc28249afdbe5f11002c44a_l3.png" height="57" width="166" alt="\begin{equation*} \int |v|^2\,\Omega\,dv = 0 \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>respectively.</p>



<p>The simplest <strong>collision operator</strong> which satisfies the stated constraints is the <strong>BGK</strong> collision operator, named after Bhatnagar, Gross and Krook. Others include the two-relaxation-time or multi-relaxation time operators.</p>



<h4>The BGK Collision Operator</h4>



<p>The <strong><a href="https://en.wikipedia.org/wiki/Bhatnagar–Gross–Krook_operator">BGK collision operator</a></strong> explicitly forces the relaxation of the distribution towards its equilibrium distribution:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-03127d24573132094f276fb6c6b88245_l3.png" height="52" width="201" alt="\begin{equation*} \Omega(f) = \frac{1}{\tau}(f - f_{eq}) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>where <strong>tau</strong> represents the relaxation time.</p>



<p>Finally, the equilibrium distribution is given by the well-known <strong><a href="https://en.wikipedia.org/wiki/Maxwell–Boltzmann_distribution">Maxwell-Boltzmann Distribution</a></strong>, which describes the speeds of particles for an idealised gas, given by:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-04e8d98ff4e2c65dae66467cb4e33ca9_l3.png" height="67" width="337" alt="\begin{equation*} f_{eq} = \rho\bigg(\frac{1}{2\pi RT}\bigg)^{3/2}e^{-|v|^2/(2RT)} \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>The choice of relaxation time and time-step results in the kinematic viscosity being given by:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-d370e00f24414ed6ba2b4a078523b6bd_l3.png" height="53" width="167" alt="\begin{equation*} \nu = c_s^2(\tau - \frac{\Delta t}{2}) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>where <strong>cs</strong> is the speed of sound.</p>



<p><strong>Note:</strong> It appears that the relation between our choice of collision operator with the relaxation time and the definition of our equilibrium distribution constrains the kinematic viscosity to this expression, which can be derived via Chapman-Enskog Theory. I’m sorry for not deriving the equilibrium distribution for you, but I am sure you can find more qualified explanations!<br/></p>



<h3>The Lattice Boltzmann Equation</h3>



<p>“Solving” the Boltzmann-Equation means finding a function <strong>f</strong> which satisfies this differential relation for our collision operator Ω and appropriate initial and boundary conditions.</p>



<p>To solve the Boltzmann-Equation <strong>numerically</strong>, we need to discretize the particle distribution function in its arguments: <strong>space</strong>, <strong>time </strong>and in particular <strong>velocity</strong>, and finally integrate.</p>



<p>The resulting equation is the <strong>Lattice-Boltzmann-Equation</strong>.<br/></p>



<p>We can utilize the common method of having discrete time-steps on a <strong>lattice</strong> / grid for our space and time discretization. Discretizing velocity space is a unique feature of the Lattice-Boltzmann method, and is described below.</p>



<h4>Discretizing Velocity Space</h4>



<p>Instead of modeling a distribution <strong>f</strong> of particles over all possible velocities in 2D or 3D, we choose a discrete set of “base velocities” <strong>v_i</strong> and assume that all particles in the system can only move with one of these velocities.</p>



<p>With this assumption, we can rewrite <strong>f</strong> as a distribution in time and space for each individual velocity component:</p>


<p><span> (6) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-30c824e88dbe087ab54684c6251ecf07_l3.png" height="26" width="207" alt="\begin{equation*} f(x,v_i,t) = f_i(x,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>A natural choice of <strong>velocity set</strong> is a set of velocities where after one time-step <strong>dt</strong>, a particle moves exactly to the position of a neighboring lattice element. </p>



<p>Thus the velocity set is fully defined by choice of “neighborhood” and dimension of the problem. In LBM, the velocity sets are therefore commonly named <strong>DdQq</strong>, where <strong>d</strong> is the dimension of space and <strong>q</strong> is the size of neighborhood.</p>



<p>This discretization of the velocity space is what is most commonly associated with the Lattice-Boltzmann method and yields the iconic “velocity set distribution” graphics.</p>



<div><figure><img src="https://www.mdpi.com/energies/energies-12-03319/article_deploy/html/images/energies-12-03319-g004.png" alt="Energies | Free Full-Text | Study on Flow and Heat Transfer Characteristics  of Porous Media in Engine Particulate Filters Based on Lattice Boltzmann  Method | HTML" width="380" height="377"/><figcaption>The D2Q9 LBM unit velocity set.</figcaption></figure></div>



<p>For 2D problems, a common choice is the D2Q9 velocity set, while for 3D problems a common choice is the D3Q19 set.</p>



<p>In practical terms, the velocity discretization means:</p>



<p>We must store an array of values of <strong>f</strong> at every position in space <strong>x_i</strong>, for every element of the velocity set <strong>v_i</strong> at every time-step <strong>t_i</strong>.</p>



<p>This is why the LBM is associated with a larger memory footprint than direct macroscopic property solvers.</p>



<h4>Deriving Macroscopic Properties</h4>



<p>Using our newly discretized velocity space, the integral expressions for our macroscopic properties as moments of the particle distribution function simplify to summations:</p>


<p><span> (7) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-43390f798e15d7141f5c17127a253932_l3.png" height="54" width="215" alt="\begin{equation*} \rho(x,t) = \sum_if_i(x,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>


<p><span> (8) </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-5d600cf646ea0bfe06a9fa66f49387b3_l3.png" height="54" width="304" alt="\begin{equation*} \rho(x,t)u(x,t) = \sum_iv_if_i(x,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p><strong>Note:</strong> In an implementation, <strong>f_i</strong> is strictly only defined at discrete time-steps and lattice locations.</p>



<h3>Solving the Lattice-Boltzmann Equation</h3>



<p>To solve the Lattice-Boltzmann Equation, we can discretize the Boltzmann-Equation in space, time and velocity space:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-262dfa3d60a657cd9c749270c4883e8d_l3.png" height="26" width="434" alt="\begin{equation*} f_i(x + v_i \Delta t, t + \Delta t) = f_i(x, t) + \Omega_i(x,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>where our new discretized <strong>collision operator</strong> is given by:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-7f42433df337643852a11c3455ac8877_l3.png" height="55" width="254" alt="\begin{equation*} \Omega_i(x,t) = - \frac{f_i - f_i^{eq}}{\tau}\Delta t \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>and our new discretized equilibrium distribution is given by:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-51c5549002fc844bb0795a1654f842d4_l3.png" height="63" width="450" alt="\begin{equation*} f_i^{eq}(x,t) = w_i\rho\bigg(1+\frac{uv_i}{c_s^2}+\frac{(uv_i)^2}{2c_s^4}+\frac{u^2}{2c_s^2}\bigg) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p><strong>Solving this equation sequentially in time is very straightforward!</strong></p>



<p>We can iteratively compute the next time-step using the so-called <strong>collision</strong> and <strong>streaming</strong> steps.</p>



<p><strong>Note:</strong> While the Lattice-Boltzmann Equation has a larger memory footprint, it is easy to solve and parallelize because it is a <strong>hyperbolic differential equation</strong>, which is easy to time-step and which only depends on local values.</p>



<h4>The Collision Step</h4>



<p>The collision (or relaxation step) is an intermediary step which consists of computing the distribution function after collisions, but before particles have moved:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-3a3d4c369bfd75058d512de0225f7d8f_l3.png" height="53" width="468" alt="\begin{equation*} f_i^{*}(x,t) = f_i(x,t) - \frac{\Delta t}{\tau}(f_i(x,t) - f_i^{eq}(x,t)) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<h4>The Streaming Step</h4>



<p>The streaming step consists of moving our intermediate values to their next locations on the lattice. This can either be by “pushing” or “pulling” depending on implementation:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-a7799836cde9eb875335d25518734697_l3.png" height="27" width="329" alt="\begin{equation*} f_i(x + v_i\Delta t,t + \Delta t) = f_i^{*}(x,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<h4>Boundary Conditions</h4>



<p>Finally, to conclude our theoretical background on the Lattice-Boltzmann Method, we will take a look at how we can introduce basic boundary conditions into a simulation.</p>



<p><strong>Note:</strong> For our situation, we will only consider straight boundary conditions which align with the borders between lattice nodes.</p>



<p>Boundary conditions for the LBM are not applied to the macroscopic properties, but are instead applied to the population distribution function <strong>f</strong>.</p>



<p>The simplest “link-wise” boundary condition is the so-called <strong>bounce-back</strong> (<strong>BB</strong>) boundary condition. The idea is that when a particle meets a rigid boundary, it is reflected back to its original location with its velocity reversed.</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-23094984f9a5198f706efd7391a562af_l3.png" height="32" width="199" alt="\begin{equation*} f_\hat{i}(x_B,t + \Delta t) = f_i^{*}(x_B,t) \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>where the hat notation <strong>^</strong> refers to the reverse direction:</p>


<p><span>   </span><span>   </span><img src="https://nickmcd.me/wp-content/ql-cache/quicklatex.com-59c2be4e8f5d900413e214c5cd15c47e_l3.png" height="22" width="65" alt="\begin{equation*} v_\hat{i} = -v_i \end{equation*}" title="Rendered by QuickLaTeX.com"/></p>



<p>and the <strong>B</strong> subscript refers to any node with at least one boundary connecting to a “solid” node.</p>



<figure><img src="https://nickmcd.me/wp-content/uploads/2022/10/bbscheme.png" alt=""/><figcaption>The <strong>BB</strong> boundary condition effectively implements a stable macroscopic no-slip boundary condition for a resting wall. It also guarantees strict mass conservation and is very straightforward to implement. </figcaption></figure>



<p><strong>Note:</strong> An alternative commonly used boundary condition are the so-called <strong>wet-node</strong> schemes, which instead explicitly define the populations <strong>f</strong> at the boundary nodes. The key difference is that <strong>link-wise</strong> schemes consider the boundary to be between nodes, while the <strong>wet-node</strong> schemes considers the boundary to be on the nodes.</p>



<h2>GPU Accelerated Implementation</h2>



<p>The key steps to solve the Lattice-Boltzmann Equation are:</p>



<ol><li>Define the <strong>lattice</strong> and the <strong>velocity set</strong></li><li>Define the <strong>initial</strong> and <strong>boundary conditions</strong></li><li>Compute the local <strong>macroscopic fluid properties</strong></li><li>Perform the <strong>collision step</strong></li><li>Perform the <strong>streaming step</strong></li><li>Apply the boundary conditions and any forces</li><li>Start next time-step from step 3</li></ol>



<p>This algorithm was implemented in C++ with TinyEngine as the base for implementing the GPU acceleration code. The provided implementation uses OpenGL4 compute shaders operating on shader storage buffer objects (SSBOs).</p>



<p>The entire code is implemented using 4 compute shaders: <strong>lbm.cs</strong>,<strong> init.cs</strong>, <strong>collide.cs</strong>, <strong>stream.cs</strong>, with <strong>lbm.cs</strong> acting as an “include” shader for shared definitions. In the following section, I will detail implementations for both <strong>2D</strong> and <strong>3D</strong>.</p>



<h3>Memory Layout and Allocation</h3>



<p>After defining the size of our domain (i.e. <strong>NX</strong>, <strong>NY</strong> and <strong>NZ</strong>), we choose a velocity set depending on the dimensionality. A common choice for 2D is <strong>D2Q9</strong>, and a common choice for <strong>3D</strong> is <strong>D3Q19</strong>. This defines the full GPU memory footprint.</p>



<p>Our main GPU storage buffers are the particle distribution function array, a propagation array, macroscopic quantities which we store for efficiency and our boundary condition.</p>



<p>Note that for every lattice node in our domain, we have <strong>1</strong> value for each macroscopic property, but <strong>Q</strong> values of the particle distribution function (one for each velocity comp.).</p>



<p>The particle distribution function and propagation buffers therefore have size <strong>N^d*Q</strong>, while the macroscopic quantities and boundary conditions have size <strong>N^d</strong>.</p>



<p>For our implementation, we simply declare or buffers with the correct size on the CPU. Note that we index these buffers with a flattened index in the shader code.</p>



<pre><code>// Initialize our Arrays (NX*NY*Q)

Buffer f(NX*NY*Q, (float*)NULL);      //Raw F Buffer
Buffer fprop(NX*NY*Q, (float*)NULL);  //Raw FProp Buffer

// Computed Quantities (For Efficiency, NX*NY)

Buffer rho(NX*NY, (float*)NULL);
Buffer v(NX*NY, (glm::vec4*)NULL);

// Boundary Condition (NX*NY)

Buffer b(NX*NY, (float*)NULL);        //Boundary Condition</code></pre>



<p>We then bind these buffers as SSBOs to our main shaders:</p>



<pre><code>// main.cpp
// Initialization Compute Shader

Compute init(&#34;shader/init.cs&#34;, {&#34;f&#34;, &#34;fprop&#34;, &#34;b&#34;, &#34;rho&#34;, &#34;v&#34;});
init.bind&lt;float&gt;(&#34;f&#34;, &amp;f);
init.bind&lt;float&gt;(&#34;fprop&#34;, &amp;fprop);
init.bind&lt;float&gt;(&#34;b&#34;, &amp;b);
init.bind&lt;float&gt;(&#34;rho&#34;, &amp;rho);
init.bind&lt;glm::vec4&gt;(&#34;v&#34;, &amp;dirbuf);

// Collision and Streaming Compute Shaders

Compute collide(&#34;shader/collide.cs&#34;, {&#34;f&#34;, &#34;fprop&#34;, &#34;b&#34;, &#34;rho&#34;, &#34;v&#34;});
collide.bind&lt;float&gt;(&#34;f&#34;, &amp;f);
collide.bind&lt;float&gt;(&#34;fprop&#34;, &amp;fprop);
collide.bind&lt;float&gt;(&#34;b&#34;, &amp;b);
collide.bind&lt;float&gt;(&#34;rho&#34;, &amp;rho);
collide.bind&lt;glm::vec4&gt;(&#34;v&#34;, &amp;dirbuf);

Compute stream(&#34;shader/stream.cs&#34;, {&#34;f&#34;, &#34;fprop&#34;, &#34;b&#34;});
stream.bind&lt;float&gt;(&#34;f&#34;, &amp;f);
stream.bind&lt;float&gt;(&#34;fprop&#34;, &amp;fprop);
stream.bind&lt;float&gt;(&#34;b&#34;, &amp;b);</code></pre>



<p><strong>Note:</strong> Because of the <a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout">GLSL std430 storage layout specifier specification</a>, the velocity vector has to be bound bound as a vector of <strong>vec4</strong> in the 3D case.</p>



<p>and access them in the shader using:</p>



<pre><code>//lbm.cs
// Main Buffers and Parameters

layout (std430, binding = 0) buffer f {
  float F[];
};

layout (std430, binding = 1) buffer fprop {
  float FPROP[];
};

layout (std430, binding = 2) buffer b {
  float B[];
};</code></pre>



<pre><code>//init.cs, collide.cs
#version 460 core

layout(local_size_x = 16, local_size_y = 1, local_size_z = 16) in;

#include lbm.cs

layout (std430, binding = 3) buffer rho {
  float RHO[];
};

layout (std430, binding = 4) buffer v {
  vec4 V[];
};</code></pre>



<pre><code>//stream.cs
#version 460 core

layout(local_size_x = 16, local_size_y = 1, local_size_z = 16) in;

#include lbm.cs

layout (std430, binding = 3) buffer rho {
  float RHO[];
};</code></pre>



<p><strong>Note:</strong> Not every shader needs access to every buffer.</p>



<h3>2D and 3D Velocity Sets</h3>



<p>It is convenient to define our velocity set, directions and weights in a small shader code for use throughout in <strong>lbm.cs</strong>.</p>



<h4>D2Q9 Velocity Set Shader Code</h4>



<pre><code>//lbm.cs
// 2D LBM

uniform int NX = 256;
uniform int NY = 128;
const int Q = 9;

// Velocity Set

// Weights
const float w[Q] = {4.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/9.0, 1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0};

// Complementary Direction Index
const int cp[Q] = {0, 3, 4, 1, 2, 7, 8, 5, 6};

// Directions
const ivec2 c[Q] = {
  ivec2(0, 0),
  ivec2(1, 0),
  ivec2(0, 1),
  ivec2(-1, 0),
  ivec2(0, -1),
  ivec2(1, 1),
  ivec2(-1, 1),
  ivec2(-1, -1),
  ivec2(1, -1)
};</code></pre>



<h4>D3Q19 Velocity Set Shader Code</h4>



<pre><code>//lbm.cs
// 3D LBM

uniform int NX = 64;
uniform int NY = 64;
uniform int NZ = 64;
const int Q = 19;

const float w[Q] = {
  1.0/3.0,
  1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0,
  1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0,
  1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0
};

const ivec3 c[Q] = {
  ivec3( 0,  0,  0),
  ivec3( 1,  0,  0), ivec3(-1,  0,  0),
  ivec3( 0,  1,  0), ivec3( 0, -1,  0),
  ivec3( 0,  0,  1), ivec3( 0,  0, -1),
  ivec3( 1,  1,  0), ivec3(-1, -1,  0),
  ivec3( 1,  0,  1), ivec3(-1,  0, -1),
  ivec3( 0,  1,  1), ivec3( 0, -1, -1),
  ivec3( 1, -1,  0), ivec3(-1,  1,  0),
  ivec3( 1,  0, -1), ivec3(-1,  0,  1),
  ivec3( 0,  1, -1), ivec3( 0, -1,  1)
};

const int cp[Q] = {
  0,
  2, 1, 4, 3, 6, 5,
  8, 7, 10, 9, 12, 11,
  14, 13, 16, 15, 18, 17
};</code></pre>



<h3>Equilibrium and Macroscopic Quantities</h3>



<p>Using our velocity set, we can define an equilibrium function and functions to compute the macroscopic velocities and densities for a given lattice node.</p>



<pre><code>//lbm.cs
const float cs = 1.0/sqrt(3.0);
const float cs2 = 1.0/cs/cs;
const float cs4 = 1.0/cs/cs/cs/cs;

// Parameters

const vec2 init_velocity = vec2(0.0, 0);
const float init_density = 1.0;

// Compute the Equilibrium Boltzmann Distribution

float equilibrium(int q, float rho, vec2 v){

  float eq = w[q]*rho;
  eq += w[q]*rho*(dot(v, c[q]))*cs2;
  eq += w[q]*rho*(dot(v, c[q])*dot(v, c[q]))*0.5*cs4;
  eq -= w[q]*rho*(dot(v, v))*0.5*cs2;
  return eq;

}

// Compute the Density at a Position

float getRho(uint ind){
  float rho = 0.0;
  for(int q = 0; q &lt; 9; q++)
    rho += F[q*NX*NY + ind];
  return rho;
}

// Compute the Momentum at a Position

vec2 getV(uint ind){

  vec2 v = vec2(0);
  for(int q = 0; q &lt; 9; q++)
    v += F[q*NX*NY + ind]*c[q];
  return v;

}</code></pre>



<h3>The Collision Step</h3>



<p>The collision step begins by computing our macroscopic density and velocity and storing these values in their respective buffers. It then  writes the propagated values / post collision values of the particle  distribution function to <strong>fprop</strong> for each node using the <strong>BGK</strong> collision operator.</p>



<pre><code>//collision.cs
const float tau = 0.6;
const float dt = 1.0;

void main(){

  const uint ind = gl_GlobalInvocationID.x*NY + gl_GlobalInvocationID.y;

  // Macroscopic Quantities

  const float _rho = getRho(ind);
  const vec2 _v = getV(ind)/_rho;

  RHO[ind] = _rho;
  V[ind] = _v;

  // BGK Method: Compute next Distribution Values!

  for(int q = 0; q &lt; Q; q++){
    FPROP[q*NX*NY + ind] = (1.0 - dt/tau)*F[q*NX*NY + ind] + dt/tau*equilibrium(q, _rho, _v);
  }

}</code></pre>



<h3>The Streaming Step</h3>



<p>The streaming step subsequently checks the boundary condition, bounces back if it encounters a wall, and otherwise uses a <strong>push scheme</strong> to propagate the particle distribution function values along their velocity direction.</p>



<pre><code>//stream.cs
void main(){

  const uint ind = gl_GlobalInvocationID.x*NY + gl_GlobalInvocationID.y;

  for(int q = 0; q &lt; Q; q++){

    // Stream-To Position (Push Scheme)

    ivec2 n = ivec2(gl_GlobalInvocationID.xy) + c[q];
    if(n.x &lt; 0 || n.x &gt;= NX) continue;
    if(n.y &lt; 0 || n.y &gt;= NY) continue;

    const int nind = n.x*NY + n.y;

    // Bounce-Back or Push

    if(B[nind] == 0.0)
      F[q*NX*NY+nind] = FPROP[q*NX*NY+ind];
    else
      F[cp[q]*NX*NY+ind] = FPROP[q*NX*NY+ind];

  }

 
}</code></pre>



<h3>Initial and Force Boundary Conditions</h3>



<p>We can use this equilibrium distribution function to initialize our particle distribution function directly in a shader <strong>init.cs</strong>. This shader is dispatched once at the beginning.</p>



<pre><code>// init.cs
#version 460 core

layout(local_size_x = 32, local_size_y = 32) in;

#include lbm.cs

void main(){

  uint ind = gl_GlobalInvocationID.x*NY + gl_GlobalInvocationID.y;

  // Initialize the Boltzmann Distribution

  for(int q = 0; q &lt; Q; q++)
    F[q*NX*NY + ind] = equilibrium(q, init_density, init_velocity);

}</code></pre>



<p>Additionally, a Dirichlet-style force boundary condition can be imposed by setting the particle distribution function as equal to the equilibrium distribution that satisfies the BC.</p>



<pre><code> // Optional: Force Boundary Condition

  vec2 force = 0.2f*vec2(1, 0);

  if(
    gl_GlobalInvocationID.x == 0
  ||  gl_GlobalInvocationID.x == NX-1
  ||  gl_GlobalInvocationID.y == 0
  ||  gl_GlobalInvocationID.y == NY-1
  )
    for(int q = 0; q &lt; Q; q++)
      F[q*NX*NY + ind] = equilibrium(q, 1.0, force);
</code></pre>



<h2>Results</h2>



<p>With proper initialization and alternating between collision and streaming steps, our computed and stored macroscopic quantities can be used by other shaders directly to generate visualizations of the fluid simulation in real time.</p>



<h3>2D Lattice Boltzmann Method</h3>



<p>The first test I implemented to check the implementation is to check if vortex shedding occurs in 2D. Here, I am visualizing the x and y components of the velocity as RG.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/2DLBM-2022-10-08_22.30.25.mp4"></video></figure>



<p>The implementation successfully worked for more complex but arbitrary boundary conditions.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/2DLBM-2022-10-08_21.10.35.mp4"></video></figure>



<p>We can also visualize the flow’s vorticity:</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/2DLBM-2022-10-08_22.34.25.mp4"></video></figure>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/2DLBM-2022-10-08_22.38.37.mp4"></video></figure>



<h3>3D Lattice-Boltzmann Method</h3>



<p>In the 2D version, an image is a natural choice for visualizing the macroscopic properties. Visualizing the 3D method is less straight forward.</p>



<p>I found an acceptable method to be using short streamlines, which can visualize velocity by their direction and length.</p>



<p>Here is a visualization of flow around a sphere, with the stream lines colored using their velocity vectors, and transparency added to stream lines with a direction close to the equilibrium velocity.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/3DLBM-2022-10-08_22.58.53.mp4"></video></figure>



<p>Take care when implementing stream lines to make sure that vertex positions are updated correctly. If you update each vertex position for every stream line at each time-step, then your streamline is only valid for <strong> a static velocity</strong> <strong>field</strong>. </p>



<p>Once your velocity field changes, the entire stream-line has to be recomputed to be consistent with the velocity field.</p>



<p><strong>Note: </strong>This is because for a given line <strong>x_i</strong> at time-step <strong>t_0</strong>, we know that  <strong>x_1 = x_0 + dt*v(x_0)</strong> and <strong>x_2 = x_1 + dt*v(x_1)</strong>. If we move <strong>x_0</strong> to <strong>x_1</strong> and <strong>x_1</strong> to <strong>x_2</strong>, then at time-step <strong>t_1</strong> we won’t have <strong>x_2 = x_1 + dt*v(x_1)</strong> because the velocity changed.</p>



<p>Therefore, I found that the best method for implementing stream lines was using geometry shaders. A particle swarm can move through the velocity field, each spawning a stream line generated from the velocity field at each time step.</p>



<h3>Terrain as Boundary Condition</h3>



<p>Finally, implementing terrain as a boundary condition is as simple as generating a heightmap with your tool of choice, and then determining which lattice nodes are considered boundary nodes and which ones aren’t.</p>



<p>This creates very nice visualizations in 3D:</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/output_lbm.mp4"></video><figcaption>Note: This video was sped up 4x because otherwise the video file would be too large. </figcaption></figure>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/output_lbm-1.mp4"></video><figcaption>Here is the same method implemented on top of SoilMachine, my unified geomorphology simulator. This video is sped up 4x as well.</figcaption></figure>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/3DLBMTerrain-2022-10-08_23.53.38.mp4"></video><figcaption>A video of wind blowing over dunes in real time, simulated in SoilMachine.</figcaption></figure>



<h2>Final Words</h2>



<p>It took me a very long time to publish this article, because I got very distracted and writing it took a lot of time, but I am glad that it is finally out!</p>



<p>There are many other aspects which I would have liked to explore, like transport systems (for moving humidity and temperature), but I couldn’t get sufficient results to make it worthwhile showcasing in this article (which is already long).</p>



<p>As always, if you have any questions about the system or the code, feel free to reach out to me.</p>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/3DLBMTerrain-2022-10-09_00.07.13.mp4"></video></figure>



<figure><video controls="" src="https://nickmcd.me/wp-content/uploads/2022/10/3DLBMTerrain-2022-10-09_00.07.49.mp4"></video></figure>

			</div></div>
  </body>
</html>
