<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/the-junior-code-monkey-in-the-age-of-llms/">Original</a>
    <h1>The junior code monkey in the age of LLMs</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>In response to <a href="https://indeedably.com/schooled/">schooled</a>, which says:</p>
<blockquote>
<p>The days of the junior code monkey are over. The creative aspects of development will shift towards correctly understanding and articulating the requirements. Refining designs. But feature very little hacking of code.</p>
</blockquote>
<p>I disagree. I think you do need to be just as precise a coder as you need to be today to do a proper articulation of requirements, as well as guide the LLM towards a well architected, resilient and effective solution.</p>
<blockquote>
<p>So I stepped back. Decomposed the big problem into smaller bite-sized chunks. Repeated the iterative prompt generation exercise. Then fed the prompt for the first component into the AI.</p>
</blockquote>
<p>I think that the comparison &#34;the AI generates better code than a junior developer&#34; forgets that the AI has nothing in common with a junior developer. While a junior developer might not write code with the apparent consistency and level of quality of the LLM (nor do I, to be honest), they have a very different set of capabilities (they have a human brain, not a bunch of code running on GPUs), and to use a loaded word, intelligence. Current LLMs might fail at decomposition, but they actually also often fail generating simple yet correct code, despite being very consistent in their style, variable-naming, function scope and providing clear and plausible explanations. I think that&#39;s a plateau with our current approaches (I do think it&#39;s actually a strength, but I have a huge ass draft about that in my drawer).</p>
<p>A junior will become senior and will become so in a way LLMs can&#39;t, because human brains are infinitely malleable and surprising and ever-learning. To do a crude analogy, comparing the coding capabilities of a LLM is like comparing the capability of a junior developer to generate the right method calls when autocomplete does so much better.</p>
<p>Also, and I think that&#39;s a very common pattern, we as seniors tend to forget that juniors (as in, younger people) are clever af and learn oh so fast, and an LLM plays right into that feedback loop. Remember how senior developers might tell you you had to do certain things in x,y,z because that&#39;s how they learned, and you were like &#34;lol&#34; and installed your linux distribution?</p>
<p>We might talk a big game about properly gathering requirements and carefully perusing the output of an LLM. Kids will just be &#34;yeah whatever, prompt prompt run run build build goodbye&#34; and quickly overshadow our capabilities at verifying LLM output, because they have to solve actual issues so much more often. I certainly didn&#39;t learn testing because I carefully wrote TDD, I learned testing by building systems that wouldn&#39;t work correctly unless I became good at testing.</p>
<p>I don&#39;t see the &#34;code monkeying&#34; period disappearing, it will just be oh so much shorter, the same way we rarely tweak assembly by hand, but to become a proficient system developer you might spend 3 months of coding some barebones OS by hand to actually know what we&#39;re doing when we&#39;re welding our rust files together with the acetylene torch of our compiler. In fact, I think every developer should spend a fair amount of time code monkeying their way around because that&#39;s how you stay sharp.</p>
</div></div>
  </body>
</html>
