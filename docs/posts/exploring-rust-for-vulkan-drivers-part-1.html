<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.collabora.com/news-and-blog/blog/2023/02/02/exploring-rust-for-vulkan-drivers-part-1/">Original</a>
    <h1>Exploring Rust for Vulkan drivers, part 1</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Today, all of the Vulkan drivers in Mesa are written in C. Some use C++ for their back-end shader compiler or other components, but all of the Vulkan API entrypoints are implemented in straight C. While C has historically been the language of choice for Linux kernel and driver code, that doesn&#39;t mean it&#39;s the optimal language for writing graphics drivers. It has long had a reputation for software bugs and security vulnerabilities. Error handling and concurrency have been a constant source of hard-to-diagnose bugs. Recently, we even had one bug which was caused by accidentally truncating a 64-bit unsigned integer to 32 bits deep inside the common Vulkan synchronization code.</p>
<p>Over the course of the last decade, Rust has emerged as a new programming language for writing safe low-level code. The language itself is built from the ground up with code safety and security in mind. Not only does it have multi-threading primitives built in but they&#39;re designed in such a way to make it difficult to write code which forgets to take locks or deadlocks. It doesn&#39;t have implicit type casting so accidental sign promotion or integer truncation doesn&#39;t happen. I&#39;ve been contemplating the idea of using it in Mesa for a few years now. Specifically, I&#39;d like to know if it&#39;s practical to write a Vulkan driver mostly in Rust and if doing so would bring enough benefit to be worth the effort. This blog post is intended to be the first in a series exploring the area of using Rust to write Mesa Vulkan drivers.</p>
<p>I don&#39;t expect to see any actual Mesa Vulkan drivers in Rust for a few years yet. My current goal is merely to explore the possibility. When the time comes that someone does choose to write a Vulkan driver in Rust, I want us to be ready. This exploration may also be useful for informing the Rust community about language features which would make the task easier. Converting existing Vulkan drivers to Rust is an explicit non-goal at this time.</p>
<h3>Why Rust?</h3>
<p>The first response I&#39;ve heard from many developers when I suggest using Rust is that C++ is already there, already in use in Mesa, and has many of the same features as Rust. There&#39;s no particularly significant reason why C++ couldn&#39;t be used for implementing Vulkan API entrypoints, but so far none of the driver teams in the Mesa community have chosen to use it for the API portion of their driver. The VkOn12 driver used C++ initially because it made working with D3D12 easier but switched to C before it was merged into Mesa.</p>
<p>While modern C++ has many features which can help with these issues if applied correctly, they&#39;re all opt-in and it&#39;s still easy to write C-like code with all the same bugs. Using these features incorrectly or mixing C and C++ patterns for things like error handling can make bugs even subtler and harder to find and fix. Unlike C++, Rust&#39;s safety features are built in to the language from day one and they intentionally make the unsafe C patterns hard while making the safe patterns easy. Rust also takes a very different approach, eschewing the object-oriented programming model in favor of its traits system. When used effectively, Rust traits provide a powerful programming model while avoiding unnecessary heap allocation and virtual function tables in most cases. In Android, <a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html" target="_blank" rel="nofollow noreferrer noopener">a recent Google blog post</a> showed that using Rust has reduced the number of memory safety vulnerabilities vs. the preexisting C and C++ code.</p>
<p dir="auto" data-sourcepos="64:1-71:47">While Rust&#39;s track record certainly is impressive, that doesn&#39;t automatically make it the right choice for graphics drivers or for a project like Mesa. Adding another language like Rust increases the mental overhead for developers as they have to switch between languages as they move through the code-base. Unlike C++ which is mostly an extension of C and tries to use similar syntax when possible, Rust is a very different language from either C or C++. The core principals are all there but the syntax and many of the paradigms are different.</p>
<p>Rust is also much harder than C++ to integrate into a large pre-existing C or C++ code-base like Mesa because Rust code must be compiled into a separate static library from the C/C++ code. Every code boundary between C/C++ code and Rust has to go through a sanitized C interface, like you would between shared libraries. Often this involves an extra build step of generating the Rust half of the interface with <a href="https://rust-lang.github.io/rust-bindgen/" target="_blank" rel="nofollow noreferrer noopener">bindgen</a>. Each code boundary also introduces mental overhead as Rust concepts have no direct mapping to C/C++, and so every call to a C function from Rust must happen within an <code>unsafe</code> block. If you&#39;re not careful it&#39;s easy for these interface mismatches to leak everywhere and for your Rust code to be littered with <code>unsafe</code> blocks. This is fairly easy for for a self-contained portion of the project, such as a back-end shader compiler, as the interfaces can be made quite small. For an actual driver, however, which has to tightly integrate with the pre-existing C code, it&#39;s substantially more difficult.</p>
<p>Last year, <a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/15439" target="_blank" rel="nofollow noreferrer noopener">rusticl</a> merged into Mesa which is a new OpenCL state tracker written in Rust. In many ways, rusticl was the ideal first Rust project for Mesa because it&#39;s fairly small and isolated within the code-base. Writing a Vulkan driver in Rust will be more difficult because it needs to integrate tightly with the shared Vulkan runtime component in Mesa which is all written in C. With the right abstractions, however, I think writing a Rust Vulkan driver should be possible and bring with it all the safety and convenience benefits of Rust.</p>
<h3>Goals</h3>
<p>Before getting into specifics, we should layout a few goals or guiding principals for our Rust wrappers.</p>
<h4>1. Rust idiomatic</h4>
<p>While aesthetics is always subjective, we want our wrappers to be as clean and as Rust-like as possible. Rust is a beautiful language that makes coding fun and we don&#39;t want to lose that due to bad abstractions. It&#39;s tempting to diverge from common patterns when developing new abstractions because of certain details of your use-case. While it may seem like a good idea at the time, these little divergences often make it harder to use the abstractions than necessary.</p>
<p>Keeping in line with Rust&#39;s idioms also enhances our ability to take advantage of Rust&#39;s safety features. The entire goal of using Rust is to make the language&#39;s safety features work for you and let the compiler prove your error and concurrency handling correct. The last thing we want is for a Rust-based driver to have <code>unsafe</code> blocks scattered throughout. That would defeat most of the point of using Rust in the first place.</p>
<h4>2. Track mutability and lifetimes</h4>
<p>This sounds obvious when talking about Rust but it&#39;s a significant divergence from our C interfaces. The <code>const</code> keyword in C and C++ is fraught with issues and many C developers consider it to be mostly useless. As such, we use <code>const</code> sparingly in most of Mesa. C and C++ have no real concept of object lifetimes and certainly can&#39;t enforce anything. Rust&#39;s concepts of mutability and lifetimes, on the other hand, are core to the language and essential for its memory and concurrency safety features. If we want Rust to work for us, we need to accurately map the documented constraints and invariants of the C API onto those concepts.</p>
<p>Fortunately, Vulkan already has similar concepts and they map fairly well to Rust. Whenever a Vulkan object is created or destroyed, the parent object is passed to both the create and destroy functions. This ensures that the lifetime of the child object is contained within the lifetime of the parent object. In Rust terms, this means it&#39;s safe for the child object to contain a non-mutable reference to the parent object. Vulkan also defines which entrypoint parameters must be <em>externally synchronized</em> by the client. Externally synchronized objects follow the same rules as mutable references in Rust.</p>
<h4>3. Use Vulkan allocators whenever possible</h4>
<p>Each time a new Vulkan object is created, the client can optionally provide an allocator object which is a set of callbacks and a data pointer. This allows the application to provide arena allocators which may be faster than the native thread-safe allocator used by the driver. Also, when working with certain threading frameworks popular with game engines, there may be restrictions on heap allocation. The engine&#39;s arena allocators are aware of these restrictions while the system allocator may not be.</p>
<p>Unfortunately, Rust does not currently have a concept of using other allocators. Rust <a href="https://github.com/rust-lang/rfcs/pull/1398" target="_blank" rel="nofollow noreferrer noopener">RFC #1398</a> has an initial implementation that exists in Rust nightly builds and there is a <a href="https://github.com/rust-lang/wg-allocators/issues" target="_blank" rel="nofollow noreferrer noopener">working group</a> which is actively discussing the feature. However, the working group has been active for almost three years now, so it will probably be a while before the feature becomes stable.</p>
<h3>Building an abstraction</h3>
<p>A few weeks ago I finally started turning some of the ideas in my brain into code and posted a <a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/20298" target="_blank" rel="nofollow noreferrer noopener">draft merge request</a> which proposes some initial Rust wrappers for Vulkan in Mesa. So far, I&#39;ve mostly focused on allocating Vulkan objects and integrating them with the Mesa Vulkan runtime&#39;s object model.</p>
<h4>Allocation</h4>
<p>The first problem to solve is allocation. Technically, we could use Rust&#39;s built-in containers and ignore the Vulkan allocators entirely. However, that would lead to all sorts of CTS warnings and is generally not kind to applications. To allow for Vulkan allocators, I wrote a new <code>VkBox</code> type which takes a Vulkan allocator and memory scope. It&#39;s not an exact drop-in replacement for <code>std::boxed::Box</code> but it should be close enough that any mismatches should be manageable.</p>
<h4>Subclassing Vulkan runtime base objects</h4>
<p>The more difficult problem is deriving from the base object structs in the shared Vulkan runtime in Mesa. This is required to take advantage of the wealth of shared Vulkan code in Mesa.</p>
<p>Embedding the parent structure in a Rust struct is easy enough. As long as the struct is declared <code>#[repr(C)]</code> and the base struct is the first member, the pointers will line up just like in C. What&#39;s more difficult is getting initialization right. The typical initialization pattern in C looks something like this:</p>
<pre><strong>struct</strong> <span><strong>nvk_image</strong></span> {
   <strong>struct</strong> <span><strong>vk_image</strong></span> vk;

   <span><em>/* NVK-specific fields */</em></span>
};

VKAPI_ATTR VkResult VKAPI_CALL
nvk_CreateImage(VkDevice _device,
                <strong>const</strong> VkImageCreateInfo *pCreateInfo,
                <strong>const</strong> VkAllocationCallbacks *pAllocator,
                VkImage *pImage)
{
   VK_FROM_HANDLE(nvk_device, device, _device);
   <strong>struct</strong> <span><strong>nvk_image</strong></span> *image;
   VkResult result;

   image = vk_zalloc2(<strong>&amp;</strong>device<strong>-&gt;</strong>vk.alloc, pAllocator, <strong>sizeof</strong>(*image), 8,
                      VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
   if (!image)
      return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);

   result = vk_image_init(<strong>&amp;</strong>device<strong>-&gt;</strong>vk, <strong>&amp;</strong>image<strong>-&gt;</strong>vk, pCreateInfo);
   <strong>if</strong> (result <strong>!=</strong> VK_SUCCESS) {
      vk_free2(<strong>&amp;</strong>device<strong>-&gt;</strong>vk.alloc, pAllocator, image);
      <strong>return</strong> result;
   }

   <span><em>/* Set NVK-specific fields */</em></span>

   *pImage = nvk_image_to_handle(image);

   <strong>return</strong> VK_SUCCESS;
}
</pre>
<p>This doesn&#39;t work in Rust because Rust requires all memory to have defined contents at all times and as such doesn&#39;t allow for partial initialization of structures. One option would be to implement <code>new()</code> for each base object something like this:</p>
<pre><strong>impl</strong> vk_image {
    <strong>pub</strong> <strong>fn</strong> <strong>new</strong>(
        dev: <strong>&amp;</strong>vk_device,
        pCreateInfo: <strong>*const</strong> VkImageCreateInfo,
    ) <strong>-&gt;</strong> <span>Result</span><strong>&lt;</strong>vk_image<strong>&gt;</strong>, VkResult<strong>&gt;</strong> {
        <strong>unsafe</strong> {
            <strong>let</strong> <strong>mut</strong> image = std::mem::zeroed::<strong>&lt;</strong>vk_image<strong>&gt;</strong>();
            <strong>match</strong> <span><strong>vk_image_init</strong></span>(dev, <strong>&amp;mut</strong> image, pCreateInfo) {
                VK_SUCCESS <strong>=&gt;</strong> <span><strong>Ok</strong></span>(image),
                err <strong>=&gt;</strong> <span><strong>Err</strong></span>(err),
            }
        }
    }
}
</pre>
<p>Unfortunately, many of our <code>vk_foo</code> base objects don&#39;t support moving via <code>mem::replace()</code>. This is usually due to our liberal use of intrusive linked lists in Mesa. In Rust terminology, this is equivalent to not supporting the Unpin trait. Instead, we have to allocate memory for the object, call <code>vk_foo_init()</code>, and then never move that object. This entirely rules out the usual Rust assignment pattern for object initialization.</p>
<p>To work around this, the <code>VkBox</code> struct has an in-place initialization constructor which takes a callback:</p>
<pre><strong>pub</strong> <strong>unsafe</strong> <strong>fn</strong> new_cb&lt;F: <span><strong>FnOnce</strong></span>(NonNull<strong>&lt;</strong>T<strong>&gt;</strong>) -&gt; VkResult<strong>&gt;</strong>(
    alloc: <strong>&amp;</strong>VkAllocationCallbacks,
    scope: VkSystemAllocationScope,
    f: F,
) <strong>-&gt;</strong> <span>Result</span><strong>&lt;</strong>VkBox<strong>&lt;</strong>T<strong>&gt;&gt;</strong>;
</pre>
<p>and a <code>VkBox&lt;vk_image&gt;</code> can be created as follows:</p>
<pre><strong>let</strong> image = <strong>unsafe</strong> {
    VkBox::<span><strong>new_cb</strong></span>(alloc, scope, |ptr| {
        <span><strong>vk_image_init</strong></span>(<strong>&amp;</strong>dev.vk, ptr, pCreateInfo)
    })
}<strong>?</strong>;
</pre>
<p>If the init callback returns <code>VK_SUCCESS</code>, an <code>Ok(VkBox)</code> will be returned. Otherwise, the backing memory for the <code>VkBox</code> will be freed and Err(err) will be returned. We can use the Rust <code>?</code> operator to neatly handle the error condition.</p>
<p>Unfortunately, this doesn&#39;t fully solve the problem. Most driver Vulkan objects are going to be more than just the <code>vk_foo</code> base struct. There will be other member data as well. Also, there is a <code>vk_image_finish</code> function which must be called on drop.</p>
<p>To handle both of these problems, I&#39;ve implemented two more variations on <code>Box</code>: <code>VkObjBox</code> and <code>VkBaseObjBox</code>, both of which are generalized on two type parameters: the base type and the driver type. Semantically, the <code>VkBaseObjBox</code> looks like <code>VkBox&lt;vk_foo&gt;</code> with an extra bit for handling drop properly. The <code>VkObjBox</code> struct looks like a box that contains two things: the <code>vk_foo</code> base struct and the driver&#39;s <code>Foo</code> struct. The base struct is initialized with a callback similarly to what we did above while the driver <code>Foo</code> struct is initialized via the usual Rust paradigms. The final pattern looks something like this:</p>
<pre><strong>struct</strong> Image {
    <span><em>/* Driver image fields */</em></span>
}

<strong>fn</strong> <span><strong>create_image</strong></span>(
    dev: <strong>&amp;</strong>VkObj&lt;vk_device, Device<strong>&gt;</strong>,
    info: <strong>*const</strong> VkImageCreateInfo,
    alloc: <strong>*const</strong> VkAllocationCallbacks,
) <strong>-&gt;</strong> <span>Result</span>&lt;VkObjBox<strong>&lt;</strong>vk_image, Image<strong>&gt;&gt;</strong> {
    <strong>let</strong> vk = <strong>unsafe</strong> {
        VkObjBaseBox::<span><strong>new2_cb</strong></span>(
            <strong>&amp;</strong>dev<span><strong>.vk</strong></span>().alloc,
            alloc,
            vk_image_finish,
            <strong>&amp;</strong>|vk: NonNull| {
                <span><strong>vk_image_init</strong></span>(dev<span><strong>.vk_ptr</strong></span>(), vk<span><strong>.as_ptr</strong></span>(), info)
            },
        )
    }<strong>?</strong>;

    <span><em>/* Stuff which may use vk */</em></span>

    <span><strong>Ok</strong></span>(VkObjBox::<span><strong>new</strong></span>(vk, Image {
        <span><em>/* Driver image fields */</em></span>
    }))
}
</pre>
<p>While a bit clunky, it&#39;s not really any worse than 10 lines of C code we have to type every time to do the same thing. Once you&#39;ve constructed the initial <code>VkBaseObjBox</code> inside the unsafe block, the remaining code is safe from there, including creating the <code>VkObjBox</code>. If an error is encountered, the drop handler on <code>VkBaseObjBox</code> will properly tear down the partially initialized image object by calling <code>vk_image_finish</code>. Once the <code>VkObjBox</code> is created, both halves of the image object are fully initialized and can be used safely.</p>
<p>The intention is that we&#39;ll eventually auto-generate a wrapper function for <code>vkCreateImage()</code> that looks something like this:</p>
<pre>unsafe extern <span>&#34;C&#34;</span> fn <span><strong>drv_CreateImage</strong></span>(
    device: VkDevice,
    pCreateInfo: <strong>*const</strong> VkImageCreateInfo,
    pAllocator: <strong>*const</strong> VkAllocationCallbacks,
    pImage: <strong>*mut</strong> VkImage,
) <strong>-&gt;</strong> VkResult {
    <strong>let</strong> device = VkObj::&lt;vk_device, Device&gt;::<span><strong>ref_for_handle</strong></span>(device);

    <strong>match</strong> <span><strong>create_image</strong></span>(device, pCreateInfo, pAllocator) {
       <span><strong>Ok</strong></span>(image) =&gt; <strong>unsafe</strong> {
            *pImage = VkObjBox::<span><strong>into_handle</strong></span>(image);
            VK_SUCCESS
        }
        <span><strong>Err</strong></span>(err) =&gt; err,
    }
}

<strong>unsafe extern</strong> <span>&#34;C&#34;</span> fn <span><strong>drv_DestroyImage</strong></span>(
    device: VkDevice,
    image: VkImage,
    pAllocator: <strong>*const</strong> VkAllocationCallbacks,
) {
    <strong>unsafe</strong> { VkObjBox::&lt;vk_image, Image&gt;::<span><strong>from_handle</strong></span>(image, pAllocator) };
}
</pre>
<h3>Conclusion:</h3>
<p>What I&#39;ve done so far barely scratches the surface of what we need to do to fully wrap the Mesa Vulkan runtime into something Rust-friendly. As I have time, I hope to do further experiments and write more blog posts about my findings. So far, for the problems I&#39;ve looked at, I&#39;ve been able to find solutions which will keep the majority of the driver code ergonomic and, most importantly, safe.</p>


</div></div>
  </body>
</html>
