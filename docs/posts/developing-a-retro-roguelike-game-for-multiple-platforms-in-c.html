<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retrogamecoders.com/roguelike-multiplatform/">Original</a>
    <h1>Developing a Retro-Roguelike Game for Multiple Platforms in C</h1>
    
    <div id="readability-page-1" class="page"><div><div><main id="genesis-content"> <span><span><a href="https://retrogamecoders.com/">Home</a></span> » <span><a href="https://retrogamecoders.com/blog/">Retro Game Coders Blog</a></span> » <span><a href="https://retrogamecoders.com/tag/atarist/">Atari ST</a></span></span><article aria-label="Developing a Retro-Roguelike Game for Multiple Platforms in C"><div><figure><img width="940" height="788" src="https://retrogamecoders.com/wp-content/uploads/2025/06/multiplatform-roguelike-dungeon-in-c-Facebook-Post.png" alt="" decoding="async" srcset="https://retrogamecoders.com/wp-content/uploads/2025/06/multiplatform-roguelike-dungeon-in-c-Facebook-Post-300x251.png 300w, https://retrogamecoders.com/wp-content/uploads/2025/06/multiplatform-roguelike-dungeon-in-c-Facebook-Post-768x644.png 768w, https://retrogamecoders.com/wp-content/uploads/2025/06/multiplatform-roguelike-dungeon-in-c-Facebook-Post.png 940w" sizes="(max-width:599px) 599px, (min-width:600px) and (max-width: 799px) 799px, (min-width:800px) and (max-width: 999px) 999px, (min-width:1000px) 1200px"/></figure><div><p>Creating a game that runs smoothly across different vintage and modern computers is a complex and ambitious challenge. Can I achieve it?</p> <p>Let me tell you the story so far; the process, obstacles, and solutions involved in making a roguelike dungeon crawler playable on systems like the Commodore 64, Commodore PET, and even more constrained machines.</p><h2 id="h-watch-on-youtube">Watch on <a href="https://www.youtube.com/@RetroGameCoders?sub_confirmation=1">YouTube</a></h2><figure><div><p><iframe id="_ytid_38461" width="800" height="450" data-origwidth="800" data-origheight="450" src="https://www.youtube.com/embed/aBeXh24_W-I?enablejsapi=1&amp;autoplay=0&amp;cc_load_policy=1&amp;cc_lang_pref=en&amp;iv_load_policy=1&amp;loop=0&amp;rel=1&amp;fs=1&amp;playsinline=0&amp;autohide=2&amp;hl=en_US&amp;theme=dark&amp;color=red&amp;controls=1&amp;" title="Programming a Retro multi-platform Roguelike Dungeon Game, Coding in C" allow="fullscreen; accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" data-no-lazy="1" data-skipgform_ajax_framebjll=""></iframe></p></div></figure><h2 id="h-why-build-games-for-multiple-platforms">Why Build Games for Multiple Platforms?</h2><p>Many enthusiasts collect old computers just for their nostalgic value. However, having these hardware collections provide playable experiences affords fresh ways to enjoy and preserve their unique quirks and capabilities.</p><p>My goal was to develop a game that can run on, if not <em>all, </em>then at least across numerous systems, utilising each machine’s features while managing constraints like memory, graphics, and input methods. </p><h2 id="h-first-approach-using-trse-to-compile-for-multiple-target-systems">First Approach: Using TRSE to Compile for Multiple Target Systems</h2><p>The journey began with <a href="https://retrogamecoders.com/wp-content/uploads/2021/04/getting-started-with-trse.jpg">TRSE</a>, a development environment supporting a huge number of vintage computer systems. My plan was to develop a text-based roguelike that could run on various hardware by compiling code for each target. </p><h3 id="h-problems">Problems</h3><ul><li>TRSE is broadly based on Pascal, unfamiliar territory for me, especially when I take long breaks from the environment.</li><li>Many older computers had incomplete or inconsistent text support in TRSE libraries as most people in the community generally develop for each systems <em>graphics</em> hardware.</li><li>Differences in hardware standards like ASCII character mapping caused compatibility headaches, especially on pre-1980s machines. </li></ul><h3 id="h-lessons-learned">Lessons Learned</h3><ul><li>Multiplatform development on vintage hardware is additionally complicated compared to today because system standards and capabilities vary widely, even from the same company, using the same processor.</li><li>Support libraries are not always fully fleshed out in ways that match your vision, or might need adaptation for different systems.</li><li>TRSE is an amazing and pretty recent voluntary project so support for certain machines needs to come from the community.</li></ul><h2 id="h-transitioning-to-c-for-greater-opportunity">Transitioning to C for Greater Opportunity</h2><p>Realising my limitations from choosing TRSE, I shifted towards programming in C. Since C compilers exist for a broad array of hardware, from calculators to mainframes, my hope was to create a universal codebase. </p><h3 id="h-anticipated-benefits-of-c"><strong>Anticipated benefits of C:</strong></h3><ul><li>Wide availability of cross-compiler support.</li><li>I had experience writing portable code adaptable to multiple hardware environments.</li><li>Features for control over low-level hardware interactions when required. </li></ul><h3 id="h-reality-check">Reality Check</h3><ul><li>Despite C’s portability, a fair amount of conditional code must be used to accommodate different system architectures.</li><li>Variations in compilers (e.g., CC65, Z88DK) and variable adherence to standards (C89, C99) introduce added complexity.</li></ul><h2 id="h-managing-platform-differences-through-conditional-compilation">Managing Platform Differences Through Conditional Compilation</h2><p>One of the key techniques I used was <em>conditional compilation</em>. This process involves including or excluding parts of the code depending on the target system. </p><p><strong>Example:</strong></p><div><pre title="">#ifdef C64
// Specific code for Commodore 64
#endif
#ifdef PET
// Specific code for Commodore PET
#endif
</pre></div><p>However, this approach becomes demanding because:</p><ul><li>Different compilers have varying syntax and features.</li><li>Each system’s memory and graphics capabilities differ.</li><li>Code can become bloated and hard to maintain. </li></ul><p>My focus shifted from <em>balancing the effort needed to support many platforms versus focusing on one.</em></p><h2 id="h-the-challenge-of-hardware-limitations">The Challenge of Hardware Limitations</h2><p>Supporting multiple machines means accounting for:</p><ul><li><strong>Memory constraints:</strong> e.g., I currently have a minimum 48K RAM limit, though I would love to address this for my beloved Vic 20 by utilising RAM upgrade cartridge support.</li><li><strong>Graphics and character sets:</strong> Some systems have custom character graphics, others don’t.</li><li><strong>Input controls:</strong> Many vintage machines used keyboards, not all had native joystick support.</li><li><strong>Loading mechanisms:</strong> From tapes to disks, resource management varies.</li></ul><p>All this complexity led to a strategy of focusing on systems with similar capabilities , mainly those with <strong>64K RAM or more</strong>, such as:</p><ul><li>Commodore 64, PET, Plus+4, Atari 800, BBC Micro</li><li>CP/M-based systems such as IMSAI and Altair</li><li>Linux, Mac, Windows (via terminal and a graphical version using Raylib) </li></ul><h2 id="h-developing-the-core-game-levels-map-generation-and-graphics">Developing the Core Game: Levels, Map Generation, and Graphics</h2><h3 id="h-hand-crafted-dungeons-to-random-map-generation">Hand-Crafted Dungeons to Random Map Generation</h3><p>A big win was creating a <strong>procedurally generated map</strong> to make each gameplay experience unique and to save me having the added task of hand drawing maps in a level editor. The main downside is the ram this process takes up versus loading a complete map on level change. Fortunately, the delay for generating the map is not as long as I feared so it is not a very noticeable pause in action.</p><p>This map generator produces random but walkable layouts, and based on guard-rails in the logic, adds the baddies and collectibles throughout the level.</p><p>That meant at this point the game included:</p><ul><li>Basic player movement</li><li>Collectible items (power-ups, health)</li><li>Enemies with their own movement and attack profiles, like rats and goblins</li><li>Simple combat and item interactions</li></ul><h3 id="h-transition-to-user-defined-character-graphics">Transition to User Defined Character Graphics</h3><p>Initially, as is traditional in the roguelike dungeon genre, the game was text-based, but even so there are variations between machines and even versions of the same machine. For example, the PET can have 40 or 80 text columns.</p><p><strong>Adding graphics involves:</strong></p><ul><li>Defining the user defined graphics in a copy of the C64 default.</li><li>Loading the definitions into memory banks.</li><li>Changing character sets to the loaded custom user-defined characters.</li><li>Translating the usual character/object/bad-guy character code for the substitutes</li></ul><h2 id="h-change-in-strategy-focusing-on-a-single-platform-first">Change in Strategy: Focusing on a Single Platform First</h2><p>Given the complexity, I have shifted now towards<strong> prioritising the Commodore 64</strong> as the main target platform because:</p><ul><li>Probably still the most popular target retro computer in 2025.</li><li>It has great graphics and sound support.</li><li>Easier to cross-develop and test.</li><li>Core code can be deployed to other systems later.</li></ul><p>Once the game becomes polished on the C64, I can adapt it to other systems with different capabilities, reducing the risk of distracting rabbit holes, code bloating, and hard to find bugs. </p><h2 id="h-practical-tips-for-multi-platform-development">Practical Tips for Multi-Platform Development</h2><ol><li><strong>Start small and focus:</strong> Develop a functional version for one platform before expanding.</li><li><strong>Use conditional compilation wisely:</strong> Limit branches by focusing on only the most common features.</li><li><strong>Prioritise core gameplay mechanics:</strong> Enable obstacles, basic movement and interaction first.</li><li><strong>Design flexible resources:</strong> For example, load graphics and data from external files when possible.</li><li><strong>Use emulators with CLI parameters for testing:</strong> They need to not only display how your game would perform on target systems but also not require lots of clicks and waiting before you see results.</li><li><strong>Research hardware quirks:</strong> Knowledge of each system’s specs helps optimise code even when cross-platform libraries and compilers exist.</li></ol><h2 id="h-bottom-line-balancing-ambition-with-pragmatism">Bottom Line: Balancing ambition with pragmatism</h2><p>Creating games that work across many historical and modern systems involves managing a fine balance. While aiming for broad compatibility is appealing, the technical realities of diverse hardware makes it more realistic to carve out a manageable scope, starting with a single, well-supported platform like the Commodore 64 or the PET.</p><p>Focus on delivering a fun experience, learn platform-specific nuances, and then gradually adapt or port to other systems. By keeping an eye out of control code complexity, and incrementally developing, it IS possible to create engaging retro-styled games that honour the spirit of vintage computing while using modern programming tools!</p><h4 id="h-as-always-if-you-would-like-to-know-more-just-hit-me-up-on-youtube-or-the-socials">As always, if you would like to know more, just hit me up on <a href="https://www.youtube.com/@RetroGameCoders?sub_confirmation=1">YouTube</a> or the <a href="https://bsky.app/profile/chrisg.com">socials</a></h4> </div></div></article></main></div></div></div>
  </body>
</html>
