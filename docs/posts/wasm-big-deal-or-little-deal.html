<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.theregister.com/2023/09/01/web_assembly_wasm_column/">Original</a>
    <h1>WASM: Big deal or little deal?</h1>
    
    <div id="readability-page-1" class="page"><div id="body">
<p><span>Opinion</span> Beginning in 1995 and for decades after, JavaScript was the only game worth playing when it came to web-based scripting. While incredibly versatile, JavaScript had its limitations, especially regarding performance-intensive tasks. As the web evolved, so did the demand for more power, speed, and flexibility in web applications. Enter WebAssembly (WASM).</p>
<p>Recognizing the need for a more efficient way to run code in web browsers, the World Wide Web Consortium (W3C) and major browser vendors began working on a new binary format. This format aimed to be fast, efficient, and secure, allowing developers to run code at near-native speed. Thus, in 2015, <a target="_blank" href="https://webassembly.org/">WASM</a> was introduced as a low-level virtual machine that runs bytecode, which is translated from high-level languages.</p>
<p>Now, WASM is not a programming language per se. Instead it&#39;s a compact binary instruction format. Unlike JavaScript, which is interpreted, WASM is a low-level bytecode that runs in a sandboxed environment within the browser, ensuring both speed and security.</p>

    

<p>Developers love it because they can write code in languages they already know, such as C, C++, and Rust. Web developers were also pleased with it because they didn&#39;t need to replace their JavaScript programs. Instead they could <a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/" rel="nofollow">call WASM functions from JavaScript and vice versa</a>, allowing for a seamless integration between the two.</p>

        


        

<p>At first, WASM was a pure web play. Then things changed. In 2019, Mozilla introduced its <a target="_blank" href="https://www.theregister.com/2019/03/29/mozilla_wasi_spec/">WebAssembly System Interface</a> (WASI) to access operating system resources. This <a target="_blank" href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">broke WebAssembly out of the browser</a>.</p>
<p>Once out of the browser box, it became, as WASM expert and Fastly Director of Engineering Lin Clark put it, &#34;a fast, scalable, secure way to run the same code across all machines.&#34;</p>

        

<p>Does that sound familiar? It should, you could use that same description for containers.  But you don&#39;t need to believe me. As Solomon Hykes, Docker co-founder, <a target="_blank" href="https://twitter.com/solomonstre/status/1111004913222324225">tweeted</a> at the time: &#34;If WASM+WASI existed in 2008, we wouldn&#39;t have needed to create Docker. That&#39;s how important it is. WebAssembly on the server is the future of computing. A standardized system interface was the missing link.&#34;</p>
<p>More recently, in 2023, the Cloud Native Computing Foundation&#39;s (<a target="_blank" href="https://cncf.io/?utm_content=inline-mention">CNCF</a>) head of ecosystem, Taylor Dolezal, said: &#34;WebAssembly is the future because it is increasingly used for serverless, containerization and plug-in technologies and is expected to significantly impact web, serverless, gaming and containerization applications.&#34;</p>
<p>Strong words. So is WASM &#34;the future of computing?&#34;</p>

        

<p>Personally, I&#39;ve been a cynic about it. While programs such as WASI and competing runtimes such as <a target="_blank" href="https://wasmedge.org/">WasmEdge</a> have made it much easier to run WASM optimized code on the edge and the backend, it strikes me that there&#39;s still a lot of work to be done. And I&#39;m not the only one who sees this problem.</p>
<p>As Torsten Volk, Enterprise Management Associates analyst, <a target="_blank" href="https://thenewstack.io/is-webassembly-really-the-future/">has said</a>: &#34;There is a lot of ground to cover in terms of reliably and efficiently supporting production use cases.&#34; Exactly. </p>
<ul>

<li><a href="https://www.theregister.com/2023/08/18/opinion_column/">A license to trust: Can you rely on &#39;open source&#39; companies?</a></li>

<li><a href="https://www.theregister.com/2023/08/04/linux_desktop_cloud_desktops/">Soon the most popular &#39;real&#39; desktop will be the Linux desktop</a></li>

<li><a href="https://www.theregister.com/2023/07/21/llama_is_not_open_source/">Meta can call Llama 2 open source as much as it likes, but that doesn&#39;t mean it is</a></li>

<li><a href="https://www.theregister.com/2023/07/07/red_hat_open_source/">Red Hat&#39;s open source rot took root when IBM walked in</a></li>
</ul>
<p>For example, Python has become the quick, easy way for people to work with machine learning programs – thank you, <a target="_blank" href="https://pytorch.org/">PyTorch</a>. But you can&#39;t simply drop these programs into WASM in a runtime and expect them to work. The problem is that you also need many third-party dependencies, which aren&#39;t there yet.</p>
<p>If WASM continues to rise in popularity, companies and open source groups will do the hard work of building these nuts and bolts.</p>
<p>But, wait, you say – isn&#39;t Kubernetes the future? Well, yes, but as Adobe pointed out recently, WASM and Kubernetes can work hand-in-hand. They worked out a way to make a &#34;<a target="_blank" href="https://www.cncf.io/blog/2022/11/17/better-together-a-kubernetes-and-wasm-case-study/">full microservice</a>, currently running in Kubernetes, and make it run in WASM.&#34;</p>
<p>Why? It gave them a more lightweight model that could be almost instantly scaled as traffic rose, giving more scheduling flexibility than a coarse-grained container, while still using Kubernetes to orchestrate everything. With this, Adobe could &#34;securely enable high performance and efficiency, while still being compatible with Kubernetes.&#34; It was, for Adobe, the best of both worlds.</p>
<p>Adobe had more resources than most companies to throw at their problems. Looking ahead, though, WASM may become easier for smaller businesses to use on the backend.</p>
<p>That&#39;s because of the <a target="_blank" href="https://www.fermyon.com/blog/webassembly-component-model">WebAssembly Component Model</a> (WACM) and <a target="_blank" href="https://github.com/bytecodealliance/preview2-prototyping">WASI-Preview 2</a>.</p>
<p>The former project will <a target="_blank" href="https://github.com/WebAssembly/component-model/blob/main/design/high-level/Goals.md">incrementally define a component model</a>. This will provide a portable, load and runtime-efficient binary format for separately compiled components built from WASM core modules that enable portable, cross-language composition. It will also provide better support for virtualizable, statically analyzable, capability-safe, language-agnostic interfaces.</p>
<p>The latter is the next version of <a target="_blank" href="https://wasi.dev/">WASI</a>. This will expand WASI&#39;s APIs beyond POSIX to WASI filesystem, HTTP, cloud, and network sockets. It will also provide better bindings for non-C-like languages.</p>
<p>Put it all together, and I think WASM may well finally live up to its potential. Still, there&#39;s many a slip between developers&#39; ideas and production code. But the bricks to build practical WASI backend designs are now being fired. By 2025, we&#39;ll know if WASM will indeed prove to be the future of backend software development. ®</p>                                
                    </div></div>
  </body>
</html>
