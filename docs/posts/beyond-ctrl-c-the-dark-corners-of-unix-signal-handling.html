<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sunshowers.io/posts/beyond-ctrl-c-signals/">Original</a>
    <h1>Beyond Ctrl-C: The dark corners of Unix signal handling</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><em><a href="https://rustconf.com/">RustConf 2024</a> is next week, so I thought I’d put up a written version of my RustConf 2023 talk about signals in time for that. I’ve tried to retain the feel of it being a talk, while editing it heavily to make it readable as a blog entry. Some links:</em></p><ul><li><em><a href="https://www.youtube.com/watch?v=zhbkp_Fzqoo">Video of the talk</a> on YouTube.</em></li><li><em><a href="https://docs.google.com/presentation/d/e/2PACX-1vQuV0pYyWQulFbnRHfgvtHqQ_ZVyrnkmfQxT0eQfjEpVjnptUIG8uMx9FuUDz3wxtWqVN5QA9C4biZT/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.p">Slides</a> on Google Slides.</em></li><li><em><a href="https://github.com/sunshowers/rustconf-2023-signals">Demo repository</a> on GitHub.</em></li></ul><p><iframe src="https://www.youtube.com/embed/zhbkp_Fzqoo" allowfullscreen="" title="YouTube Video"></iframe></p><h2 id="1-introduction">1. Introduction<a href="#1-introduction" arialabel="Anchor">#</a></h2><p>Imagine you’re in the middle of a conversation, when suddenly, a tap on the shoulder interrupts your train of thought. You turn to face the interloper, only to find a dear friend with an urgent message. In that moment, you’re faced with a choice: do you ignore the interruption and continue your conversation, or do you pause to address your friend’s needs?</p><p>In the world of computing, this tap on the shoulder is akin to a <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">signal</a>: a way for the operating system to interject and communicate with a running process. Just as you might choose to ignore or respond to your friend’s interruption, a process must decide how to handle the signals it receives.</p><p>Let’s start with a couple of questions:</p><ol><li>Have you ever hit Ctrl-C while running a command-line program?</li><li>Have you ever encountered data corruption because you hit Ctrl-C at the wrong time?</li></ol><p>If you’ve answered yes to the second question, then there’s a chance your program isn’t handling signals correctly. Much like a conversation that’s interrupted at an inopportune moment, a process that’s interrupted by a signal can be left in a state of disarray.</p><p>In this post, we’ll explore the world of Unix signals, delving into their history and their surprising complexity. We’ll learn how to handle these interruptions gracefully. And we’ll discover how async Rust can help us tame the chaos of signal handling, making it easier than ever to write robust software.</p><p>Most of this knowledge comes from my work on <a href="https://nexte.st/">cargo-nextest</a>, a next-generation test runner for Rust that is up to thrice as fast as <code>cargo test</code>. One of the things that sets nextest apart is how it carefully, rigorously handles any signals that come its way. Be sure to try it out if you haven’t already!</p><h3 id="why-signals">Why signals?<a href="#why-signals" arialabel="Anchor">#</a></h3><p>If you’re an experienced engineer, you’re probably used to asking questions like <em>why</em>, <em>when</em>, and <em>how much</em> you should care about something.</p><p>So: Why bother with signal handling at all? When should you care about signals?</p><figure><img src="https://sunshowers.io/images/kubernetes-sigterm.png" alt="A screenshot of Kubernetes documentation with: 3 - SIGTERM signal is sent to the pod. At this point, Kubernetes will send a SIGTERM signal to the containers in the pod. This signal lets the containers know that they are going to be shut down soon. Your code should listen for this event and start shutting down cleanly at this point. This may include stopping any long-lived connections (like a database connection or WebSocket stream), saving the current state, or anything like that..."/><figcaption>Kubernetes on SIGTERM (<a href="https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-terminating-with-grace">source</a>).</figcaption></figure><ul><li><p>You should care about signals if you’re developing a <strong>service</strong>. You’re likely going to be running under a service manager like Kubernetes, and the lifecycle generally involves signals.</p><p>This screenshot shows Kubernetes documentation explaining that when your service is shutting down, it will receive a <code>SIGTERM</code>. Docker works the same way with <code>docker stop</code>.</p><p>Note how the documentation advises that your code should “listen for this event and start shutting down cleanly at this point”.</p></li><li><p>You should also care about signals if you’re developing a <strong>command-line tool</strong>. That’s because your users are impatient and if they perceive your operation as being slow for any reason, they will hit Ctrl-C and send a signal to your process.</p></li></ul><p>How much do you need to care about signals?</p><ul><li><p>If you’re a command like <code>ls</code> or <code>cat</code> and all you’re doing is <strong>reading data</strong>, you probably don’t need to care much about signals. You’re not making any changes to the system so there’s little that can go wrong if your process dies.</p></li><li><p>If you’re <strong>writing data</strong>, it’s definitely worth thinking about signal handling.</p><p>There are ways to arrange for your code to be resilient to sudden termination, such as <a href="https://crates.io/crates/atomicwrites">writing files atomically</a>, or using a database like <a href="https://www.sqlite.org/">SQLite</a>. But even if your code doesn’t depend on correct signal handling, you can likely provide a better user experience if you do handle them.</p></li><li><p>Where you need to care most about signals is if you’re <strong>orchestrating an operation</strong> in a distributed system. In those cases, if the process receives a signal locally, it may wish to send out cancellation messages over the wire.</p><p>Again, it’s a good idea to make your system fault-tolerant and resilient to sudden termination—for example, by serializing state in a persistent store—but at the very least, signals give you the opportunity to perform cleanup that can otherwise be difficult to do.</p></li></ul><p><strong>Before we move on:</strong> In this post, we’re going to focus on Unix, not Windows. We’re also going to focus on <strong>portable</strong> signal handling, which means mechanisms that work on every Unix. Some Unix platforms offer alternative ways to handle signals<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, but this post will not be discussing them.</p><h3 id="a-basic-example">A basic example<a href="#a-basic-example" arialabel="Anchor">#</a></h3><p>Let’s look at a simple example of a signal being sent to a process:</p><figure><img src="https://sunshowers.io/images/signal-crime-scene.png" alt="A screenshot of a terminal where `cargo build` was run, and Ctrl-C was pressed within a couple of seconds after. The last line shows &#34;Building 225/305: object, regex-automata, syn,&#34;."/></figure><p>What happened here?</p><ol><li>I ran <code>cargo build</code>.</li><li>Then, a few seconds after, I hit Ctrl-C in my terminal.</li><li>The terminal sent a signal called <code>SIGINT</code> (where <code>INT</code> means “interrupt”) to the Cargo process.</li><li>The <code>SIGINT</code> signal caused the Cargo process, as well as all the Rust compiler processes underneath it, to be interrupted and terminated.</li></ol><p>This example shows the two uses of signals. One is as a standardized, widely understood way for the kernel to interrupt a process. The other is as a basic, limited way to perform <em>interprocess communication</em>, or <em>IPC</em>.</p><h3 id="sending-signals-via-kill">Sending signals via <code>kill</code><a href="#sending-signals-via-kill" arialabel="Anchor">#</a></h3><p>Besides Ctrl-C and other shortcuts, the main way you’d be sending signals to processes on the command line is via <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html">the <code>kill</code> command</a>.</p><ul><li>To send <code>SIGINT</code> or Ctrl-C, you can use <code>kill -INT &lt;pid&gt;</code>, where <code>&lt;pid&gt;</code> is the numeric process ID.</li><li>Each signal also has an associated number. For <code>SIGINT</code> the number is always 2, so another way of saying this is <code>kill -2 &lt;pid&gt;</code>.</li><li>If you don’t specify a signal and just say <code>kill &lt;pid&gt;</code>, it sends SIGTERM by default.</li></ul><p>Within a programmatic context, libc has <a href="https://man7.org/linux/man-pages/man2/kill.2.html">a <code>kill</code> function</a> you can call which does the same thing.</p><h3 id="signal-names-and-numbers">Signal names and numbers<a href="#signal-names-and-numbers" arialabel="Anchor">#</a></h3><p>As mentioned above, each signal has a name and number associated with it. Some of those numbers are standardized across Unix platforms, while others aren’t.</p><p>On Linux, if you type in <code>man 7 signal</code>, you’ll see <a href="https://man7.org/linux/man-pages/man7/signal.7.html">a long list</a> of signals. Some of them are:</p><table><thead><tr><th>Name</th><th>Number</th><th>Default action</th></tr></thead><tbody><tr><td><code>SIGINT</code></td><td>2</td><td>Terminate</td></tr><tr><td><code>SIGTERM</code></td><td>15</td><td>Terminate</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td>Terminate, can’t customize</td></tr><tr><td><code>SIGSEGV</code></td><td>11</td><td>Terminate and core dump</td></tr><tr><td><code>SIGTSTP</code></td><td>Varies</td><td>Stop process</td></tr><tr><td><code>SIGCONT</code></td><td>Varies</td><td>Resume process</td></tr></tbody></table><p>In this table:</p><ul><li><p><code>SIGKILL</code> is also known as <code>kill -9</code>, and it’s a special signal used to kill a process. What sets <code>SIGKILL</code> apart is that unlike almost all other signals, its behavior can’t be customized in any way.</p></li><li><p><code>SIGSEGV</code> might be familiar to you if you’ve ever encountered a core dump. Somewhat surprisingly, the behavior of <code>SIGSEGV</code> <em>can</em> be customized. For example, the Rust standard library customizes <code>SIGSEGV</code>’s behavior to detect <a href="https://sunshowers.io/posts/rustc-segfault-illumos/">call stack exhaustion</a><sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p></li><li><p><code>SIGTSTP</code> and <code>SIGCONT</code> are used for what is called “<a href="https://en.wikipedia.org/wiki/Job_control_(Unix)">job control</a>”. If you’ve ever used Ctrl-Z in <code>vim</code>, or the commands <code>fg</code> or <code>bg</code>, then they uses these signals<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p></li></ul><p>In general, all signals have a default action. Almost all of them also let you customize the default behavior, using what is called a <em>signal handler</em>.</p><h3 id="signal-handlers">Signal handlers<a href="#signal-handlers" arialabel="Anchor">#</a></h3><p>A signal handler is a custom function that is used to intercept specific signals. Once a signal handler is set up, the kernel no longer follows the default action, calling the handler instead. In that sense, it’s a <em>reverse system call</em>, also known as an <em>upcall</em>.</p><p>For example, if you’re writing or reading data, you use a <em>system call</em> or <em>syscall</em> to perform that action—in that case, you’re calling the kernel. With an upcall, instead, the kernel calls you. (It’s an “upcall” because the call goes “up”, not “down”).</p><p>Importantly, signal upcalls can happen at <em>almost any time</em>. And this is where we start running into issues.</p><h2 id="2-an-example">2. An example<a href="#2-an-example" arialabel="Anchor">#</a></h2><p>To see the sorts of issues that signal handlers can create, let’s walk through a specific example: that of a download manager.</p><figure><img src="https://sunshowers.io/images/download-manager.png" alt="Screenshot of a download manager on Windows XP. There are two windows visible, one in the background and one in the foreground. The background window is titled &#34;Internet Download Manager 5.11&#34; and has a list of partially and completely downloaded files in it. The foreground window says &#34;85% mult.avi&#34; and shows a download in progress."/><figcaption>Screenshot of a download manager on Windows XP.</figcaption></figure><p>Back in the 2000s, these programs were a lifesaver. I grew up with pretty terrible internet back then, and the download managers had several features that really helped. The most important feature was their ability to resume downloads, something that browsers didn’t support back then.</p><p>For this post, we’re going to work with a really simple download manager. Let’s say you provide a bunch of URLs to a tool, which then downloads them in parallel and maintains their status in a database.</p><p>Now, let’s say we want to handle <code>SIGINT</code>. If the user hits Ctrl-C, we may want to follow a small set of sensible steps:</p><ul><li>Cancel all running downloads.</li><li>Flush any data to disk.</li><li>In the database, mark the state of these downloads as interrupted.</li></ul><p>Your first idea might be, “let’s just put all this logic in a signal handler”. Can you do that? The answer turns out to be that <strong>no, you can’t do that.</strong> And <em>why</em> you can’t do that is helpful at illustrating many of the pitfalls of signal handlers.</p><h3 id="why-are-signal-handlers-limited">Why are signal handlers limited?<a href="#why-are-signal-handlers-limited" arialabel="Anchor">#</a></h3><p>Earlier, I mentioned that signal handlers can be called <em>at any time</em>. It turns out that the ability to call a piece of code at any time is fraught with peril like little else in computing. This property of signal handlers is at the root of so many of the problems with them.</p><ul><li><p>For example, consider what happens if a signal handler is called while you’re holding a mutex or other lock. In general, trying to acquire the same lock again will result in a deadlock<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. So you can’t call functions that try to acquire a lock.</p><p>Well, which functions acquire locks? Even something as basic as <a href="https://man7.org/linux/man-pages/man3/malloc.3.html">allocating memory via <code>malloc</code></a> requires a lock, because it pokes at global structures. This means that you cannot allocate memory in a signal handler. This alone shuts off a large percentage of the things you can do in a signal handler.</p></li><li><p>Another joy of signal handling is that while a handler is running, your process can receive a different signal and invoke a second signal handler. As you might imagine, this is just very hard to reason about in practice.</p></li></ul><p>These aren’t just theoretical concerns! You might have heard of <a href="https://cve.mitre.org/">the CVE database</a>, where security vulnerabilities are filed and listed. The CVE database has a lesser-known cousin called <a href="https://cwe.mitre.org/">the CWE database</a>, which lists out “common weaknesses” that result in security vulnerabilities. Within this database, there are no fewer than <em>four</em> weaknesses related to incorrect signal handlers:</p><ol><li><a href="https://cwe.mitre.org/data/definitions/364.html">CWE-364</a>: Signal Handler Race Condition</li><li><a href="https://cwe.mitre.org/data/definitions/432.html">CWE-432</a>: Dangerous Signal Handler not Disabled During Sensitive Operations</li><li><a href="https://cwe.mitre.org/data/definitions/479.html">CWE-479</a>: Signal Handler Use of a Non-reentrant Function</li><li><a href="https://cwe.mitre.org/data/definitions/828.html">CWE-828</a>: Signal Handler with Functionality that is not Asynchronous-Safe</li></ol><p>On Linux, <a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">the man page on <code>signal-safety</code></a> lists functions described by POSIX as okay to call in signal handlers, and it is pretty short. You can write to a file descriptor, but <code>malloc</code> is not allowed. You also can’t open or seek a file.</p><p>The functions okay to call in signal handlers are called <strong>async-signal-safe functions</strong>. The term is a bit confusing! “async” here has nothing to do with async Rust. (In many ways it’s the opposite of async Rust, because the defining characteristic of async Rust is that you <em>cannot</em> just be interrupted or preempted at any time. You can only be interrupted at await points.)</p><h3 id="the-self-pipe-trick">The self-pipe trick<a href="#the-self-pipe-trick" arialabel="Anchor">#</a></h3><figure><img src="https://sunshowers.io/images/tips-and-tricks-piping.png" alt="A photo of the needle of a sewing machine working on a pipe in the context of a garment, with the label &#34;Tips &amp; tricks for piping perfectionists&#34;."/><figcaption>It’s important to get your piping right (<a href="https://straight-grain.com/archives/13447">source</a>).</figcaption></figure><p>So how do most modern programs handle signals? To understand that, we briefly need to introduce the concept of <a href="https://www.sitepoint.com/the-self-pipe-trick-explained/">the <em>self-pipe trick</em></a>. The trick uses a Unix feature called self-pipes, which have been described in the same breath as both “wonderful” and “cursed”: a high honor!</p><p>You might be familiar with pipes from having used them in shells via the namesake pipe (<code>|</code>) operator. For example, consider a typical <code>find | xargs</code> command.</p><ul><li>When this command is run, the shell creates a <em>pipe</em>.</li><li>Each pipe has a <em>write end</em> and a <em>read end</em>.</li><li>In the case of <code>find | xargs</code>, the write end is held by <code>find</code>, and the read end by <code>xargs</code>.</li></ul><p>A self-pipe is just a kind of pipe where the write and read ends are held by the same process.</p><p>Now, you might ask, “what’s the point of this?” And you’d be right to do so! Most of the time they don’t add any value. But they do add value in the specific context of signal handlers, because they let programs write signal handlers that are as simple as possible.</p><ul><li>The program starts by creating a self-pipe.</li><li>It then hands the write end of the pipe to a signal handler, and holds on to the read end.</li><li>Then, the signal handler writes to that self-pipe. This is safe to do, because a pipe is a file descriptor, and writing to a file descriptor is async-signal-safe.</li><li>Then, the program reads from the self-pipe elsewhere.</li></ul><p>Most C programs do this by hand, but in Rust you don’t have to write this delicate pattern manually. There are several crates which implement this pattern, <a href="https://docs.rs/signal-hook/">like <code>signal-hook</code></a>, and most people just use one of them.</p><h3 id="now-what">Now what?<a href="#now-what" arialabel="Anchor">#</a></h3><p>Going back to the download manager example: Let’s say you write to a pipe, indicating that Ctrl-C has been pressed. How do you handle the read side of the pipe? Once you’ve received a signal, how do you handle it?</p><ol><li><p>One option is to set some kind of <strong>global flag</strong>, and check whether you’ve received a signal at every iteration of a loop–or maybe every Nth iteration of a loop.</p><p>This works fine for small programs that are CPU-bound, but isn’t really scalable to large programs because those tend to have lots of loops in them (are you really going to add checks to every loop?)</p><p>Large programs are I/O bound anyway, and it’s a bit hard to check for signals while you’re waiting for some network operation to complete.</p></li><li><p>Another potential solution: Store all the state behind a mutex, and <strong>wrest control of the program</strong> by locking out all the workers. This is a solution that some programs use, but it is really difficult to coordinate state between the workers and the signal handler. I really wouldn’t recommend following this approach.</p></li><li><p>The most reasonable approach for I/O-bound programs is to use <strong>message passing</strong>, where the parts of a program that deal with signals are notified that a signal has occurred.</p><p>This is possible to do in a synchronous model, but, as I’ve documented in my previous post about <a href="https://sunshowers.io/posts/nextest-and-tokio/">how nextest uses Tokio</a>, it adds a great deal of unbounded complexity. What happens in practice is that you inevitably create a nest of threads whose only responsibility is to pass messages around.</p></li></ol><p>The good news is that dealing with messages is much, much simpler with async Rust.</p><h3 id="why-async-rust">Why async Rust?<a href="#why-async-rust" arialabel="Anchor">#</a></h3><p>At this point you might ask: “I’m just a simple downloader tool, why would I need async for this?”</p><p>Async Rust is presented as being for massively concurrent web or backend servers, but a secret about it is that that is just marketing. The scope of problems async Rust solves is much broader, and it happens to be incredibly well suited to signal handling for most programs. This is because async Rust provides some very expressive ways to perform advanced control flow, making such code readable without sacrificing performance.</p><p>To see how, we’re going to use Tokio’s signal handling functionality, which under the hood uses the same self-pipe trick mentioned above<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>. Here’s what a very simple example of Ctrl-C looks like under async Rust:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> tokio::signal::unix::{signal, SignalKind};
</span></span><span><span>
</span></span><span><span><span>let</span> <span>mut</span> ctrl_c_stream <span>=</span> signal(SignalKind::interrupt())<span>?</span>;
</span></span><span><span><span>loop</span> {
</span></span><span><span>    ctrl_c_stream.recv().<span>await</span>;
</span></span><span><span>    println!(<span>&#34;got SIGINT&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>In this example:</p><ul><li>The code sets up a stream of <a href="https://docs.rs/tokio/1/tokio/signal/unix/struct.SignalKind.html#method.interrupt"><code>SignalKind::interrupt</code></a> or Ctrl-C signals, then <code>await</code>ing the <code>recv</code> method.</li><li>The <code>recv</code> method resolves each time the process receives Ctrl-C.</li></ul><p>Now, this isn’t very special by itself; you can easily implement this with synchronous code. But this model really shines in more complex code paths, because of async Rust’s ability to perform <strong>heterogenous selects</strong> <a href="https://docs.rs/tokio/1/tokio/macro.select.html">via <code>tokio::select!</code></a>.</p><p>For a detailed discussion of heterogenous selects, see <a href="https://sunshowers.io/posts/nextest-and-tokio/#what-are-heterogenous-selects">my earlier post</a> about them. But a quick summary is that <code>tokio::select!</code> is a powerful control flow tool that waits for a set of futures to be ready concurrently, and resolves as soon as one of them completes.</p><p>What makes <code>tokio::select</code> really special is it doesn’t just work against specific kinds of asynchronicity, but against any arbitrary, <em>heterogenous</em> source of asynchronicity: signals, timers, any async function–you name it. As a result, <code>tokio::select!</code> is a great fit for signal handling<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>.</p><h3 id="implementing-signal-handling-using-tokioselect">Implementing signal handling using <code>tokio::select!</code><a href="#implementing-signal-handling-using-tokioselect" arialabel="Anchor">#</a></h3><p>Going back to our download manager example, let’s try using <code>tokio::select!</code>. There are a few ways to organize this, but here’s one way.</p><p>We’re going to briefly introduce two constructs that make our life simpler:</p><ol><li><a href="https://docs.rs/tokio/1/tokio/task/struct.JoinSet.html">The <code>JoinSet</code> type</a>, which stands for a set of worker <em>tasks</em> (not threads!) that are running in parallel.</li><li><a href="https://docs.rs/tokio/1/tokio/sync/broadcast/index.html">Broadcast channels</a>, which allows a single producer to send messages to multiple consumers. The idea here is that the main task will receive signals, and then broadcast them to workers.</li></ol><hr/><p>Here’s how the main function works:</p><ol><li>Create a <code>JoinSet</code> and a broadcast channel.</li><li>Spin up a stream of <code>SIGINT</code> signals, as before.</li><li>Spawn a task for each worker on the <code>JoinSet</code>, and pass in a receiver for broadcast messages.</li></ol><details><summary>Click to expand code sample</summary><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>let</span> to_download <span>=</span> <span>/* ... */</span>;
</span></span><span><span>    <span>// Make a JoinSet.
</span></span></span><span><span><span></span>    <span>let</span> <span>mut</span> join_set <span>=</span> JoinSet::new();
</span></span><span><span>    <span>// Also make a broadcast channel.
</span></span></span><span><span><span></span>    <span>let</span> (sender, receiver) <span>=</span> broadcast::channel(<span>16</span>);
</span></span><span><span>
</span></span><span><span>    <span>// Spin up a stream of SIGINT signals.
</span></span></span><span><span><span></span>    <span>let</span> <span>mut</span> ctrl_c_stream <span>=</span> signal(SignalKind::interrupt()).unwrap();
</span></span><span><span>
</span></span><span><span>    <span>// Spawn a task for each worker, passing in a broadcast receiver.
</span></span></span><span><span><span></span>    <span>for</span> args <span>in</span> to_download {
</span></span><span><span>        <span>let</span> receiver <span>=</span> sender.subscribe();
</span></span><span><span>        join_set.spawn(worker_fn(args, receiver));
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// ... continued below
</span></span></span><span><span><span></span>}
</span></span></code></pre></div></details><p>Next, the main function needs to wait for results from all the workers. How would we do it if we weren’t handling signals? Well, in that case we would loop and wait for each worker task to finish until they’re all done, handling errors along the way.</p><details><summary>Click to expand code sample</summary><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// continued from above...
</span></span></span><span><span><span></span><span>loop</span> {
</span></span><span><span>    <span>let</span> v <span>=</span> join_set.join_next().<span>await</span>;
</span></span><span><span>    <span>if</span> <span>let</span> Some(result) <span>=</span> v {
</span></span><span><span>        <span>// Handle result...
</span></span></span><span><span><span></span>    } <span>else</span> {
</span></span><span><span>        <span>// No more downloads left
</span></span></span><span><span><span></span>        <span>break</span>;
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div></details><p>To handle signals, we use a <code>tokio::select!</code> with two branches from which items are fetched in parallel:</p><ol><li>The first branch waits for worker tasks to be done with the same code as above</li><li>The second branch awaits a Ctrl-C message from the stream.</li></ol><details><summary>Click to expand code sample</summary><div><pre tabindex="0"><code data-lang="rust"><span><span><span>enum</span> <span>CancelKind</span> {
</span></span><span><span>    Interrupt,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>loop</span> {
</span></span><span><span>    tokio::select! {
</span></span><span><span>        v <span>=</span> join_set.join_next() <span>=&gt;</span> {
</span></span><span><span>            <span>if</span> <span>let</span> Some(result) <span>=</span> v {
</span></span><span><span>                <span>// Handle result...
</span></span></span><span><span><span></span>            } <span>else</span> {
</span></span><span><span>                <span>// No more downloads left
</span></span></span><span><span><span></span>                <span>break</span>;
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>        Some(_) <span>=</span> ctrl_c_stream.recv() <span>=&gt;</span> {
</span></span><span><span>            sender.send(CancelKind::Interrupt);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div></details><hr/><p>Now let’s look at the worker function. We first write our download function within an async block:</p><details><summary>Click to expand code sample</summary><div><pre tabindex="0"><code data-lang="rust"><span><span><span>async</span> <span>fn</span> <span>worker_fn</span>(args: <span>Args</span>, receiver: <span>Receiver</span><span>&lt;</span>CancelKind<span>&gt;</span>) -&gt; Result<span>&lt;</span>()<span>&gt;</span> {
</span></span><span><span>    <span>let</span> <span>mut</span> op <span>=</span> <span>async</span> {
</span></span><span><span>        args.db.update_state(<span>&amp;</span>args.url, Downloading).<span>await</span><span>?</span>;
</span></span><span><span>        download_url_to(<span>&amp;</span>args.url, <span>&amp;</span>args.file).<span>await</span><span>?</span>;
</span></span><span><span>        args.db.update_state(<span>&amp;</span>args.url, Completed).<span>await</span><span>?</span>;
</span></span><span><span>        Ok(())
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span></code></pre></div></details><p>Then, just like earlier, we write a loop with a <code>tokio::select!</code> over two options:</p><ol><li>The first branch drives the operation forward.</li><li>The second branch waits for cancellation messages over the broadcast channel.</li></ol><details><summary>Click to expand code sample</summary><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span> {
</span></span><span><span>    tokio::select! {
</span></span><span><span>        <span>// 1. Drive the operation forward.
</span></span></span><span><span><span></span>        res <span>=</span> <span>&amp;</span><span>mut</span> op <span>=&gt;</span> <span>return</span> res,
</span></span><span><span>
</span></span><span><span>        <span>// 2. Wait for cancellation messages over the broadcast channel.
</span></span></span><span><span><span></span>        Ok(message) <span>=</span> receiver.recv() <span>=&gt;</span> {
</span></span><span><span>            <span>// Handle the cancellation message received.
</span></span></span><span><span><span></span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div></details><hr/><p>What makes this model tick is how well it scales up to additional complexity. Two specific examples that are handled well by this model:</p><ol><li>First, you’ll likely want to handle other signals like <code>SIGTERM</code>, since <code>SIGINT</code> isn’t the only signal you’d receive.</li><li>Another common extension is to use what is sometimes called a <em>double Ctrl-C pattern</em>. The first time the user hits Ctrl-C, you attempt to shut down the database cleanly, but the second time you encounter it, you give up and exit immediately.</li></ol><p>A fully working example of the download manager described above is <a href="https://github.com/sunshowers/rustconf-2023-signals">in the demo repository</a>. These two extensions are marked as exercises for you to complete; try solving them!</p><h2 id="3-going-deeper">3. Going deeper<a href="#3-going-deeper" arialabel="Anchor">#</a></h2><p>If all you’re doing is orchestrating an external operation like downloading files, then this is most of what you need to know. But a lot of the really interesting details about signals lie when you’re spawning processes—such as if you’re a shell, or a test runner like nextest. There is far too much to talk about here, but we’re going to go deeper into one particular example.</p><h3 id="process-groups">Process groups<a href="#process-groups" arialabel="Anchor">#</a></h3><p>In part 1, I mentioned that if you press Ctrl-C, the shell sends <code>SIGINT</code> to the process you’re running. That isn’t quite correct; I fibbed a little! The truth is that the shell actually sends the signal to what is called a <strong>process group</strong>.</p><p>What is a process group? In Unix, processes can be organized into groups, each with its own unique identifier. Process groups allow a set of processes to be sent a signal at once. The shell creates a new process group for the command and its children, assigning them a unique group ID. This allows the shell to manage the processes as a unit, sending signals to the entire group at once.</p><p>On Linux, you can print process groups with a command like <code>ps fo pid,pgid,comm</code>. (Other Unix platforms have their own <code>ps</code> flags to display similar output.) For example, if you run this command while <code>cargo build</code> is running in another terminal, you might get some output that looks like this:</p><div><pre tabindex="0"><code data-lang="console"><span><span>$ ps fo pid,pgid,comm
</span></span><span><span>   PID    PGID  COMMAND
</span></span><span><span>  1528    1528  zsh
</span></span><span><span>  4100    4100   \_ cargo
</span></span><span><span>  4261    4100       \_ rustc
</span></span><span><span>  4587    4100       \_ rustc
</span></span><span><span>  4640    4100       \_ rustc
</span></span></code></pre></div><p>In this case:</p><ul><li>The <code>zsh</code> shell created a <code>cargo</code> process numbered <code>4100</code>.</li><li>When <code>zsh</code> did that, it also created a corresponding process group with the same number.</li><li>When <code>cargo build</code> ran <code>rustc</code>, those process groups were inherited.</li></ul><p>Recall from earlier that if you want to send <code>SIGINT</code> to a process via the <code>kill</code> command, you’d use <code>kill -INT &lt;pid&gt;</code>.</p><ul><li>If you want to send <code>SIGINT</code> to a process <em>group</em>, in very typical Unix fashion you have to use a negative number.</li><li>For example, if you run <code>kill -INT -4100</code>, the <code>SIGINT</code> signal gets sent atomically to the whole process group numbered <code>4100</code>: the process, its children, grandchildren, everything.</li></ul><p>And that’s what really happens when you hit Ctrl-C: both the <code>cargo</code> process itself and all the child <code>rustc</code> processes are terminated by this signal sent to the process group.</p><h3 id="making-your-own-process-groups">Making your own process groups<a href="#making-your-own-process-groups" arialabel="Anchor">#</a></h3><p>Let’s say that you’re a test runner like nextest. What if you want to join the party? For example, it’s common for tests to spin up servers in another process to communicate with. A test runner that terminates a test likely also wants to kill off any processes created by that test.</p><figure><img src="https://sunshowers.io/images/pgroup.png" alt="A screenshot of part of Rust&#39;s `std::os::unix::process::CommandExt`, with one method selected: fn process_group(&amp;mut self, pgroup: i32) -&gt; &amp;mut Command."/></figure><p>To set the process group for a process, Unix provides a function called <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/setpgid.html"><code>setpgid</code></a>. In Rust, access to this is provided via the <code>CommandExt</code> extension trait’s <a href="https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.process_group"><code>process_group</code> method</a>.</p><p>Most of the time, you’ll want to pass in <code>-1</code> for the process group, which means that the kernel will create a new process group for you with the same number as the process ID.</p><h3 id="forwarding-signals-to-child-process-groups">Forwarding signals to child process groups<a href="#forwarding-signals-to-child-process-groups" arialabel="Anchor">#</a></h3><p>Let’s say you’re a command-line process that is using process groups to manage its children. What happens if the user hits Ctrl-C?</p><p>You might assume that process groups form some sort of tree. Just like with the notion of a tree of processes with parent and child processes, you might imagine that process groups follow a similar pattern.</p><p>In reality: no, <strong>process groups don’t form a tree</strong>. Each process group is its own island.</p><p>This means that as a <em>boundary process</em> which manages process groups of your own, it is your responsibility to forward signals to child process groups.</p><p>(This is quite easy to fit into our async Rust model: the worker tasks, on receiving a broadcast message, send the corresponding signal to the process groups that they’re responsible for.)</p><p>Most programs would want to behave as similarly as possible to the world where they didn’t set up process groups. To achieve that you’ll want to at least forward these signals:</p><p><strong>To match behavior,</strong> for signals that are typically sent to process groups:</p><ul><li><p><code>SIGINT</code> (Ctrl-C).</p></li><li><p><code>SIGQUIT</code> (Ctrl-\).</p></li><li><p><code>SIGTSTP</code> (Ctrl-Z), and <code>SIGCONT</code> (<code>fg</code> or <code>bg</code>).</p><p>These two signals are interesting to handle in nextest: if you have timers running for your processes, for example if you want to timeout and kill process groups, you can combine <code>SIGTSTP</code> and <code>SIGCONT</code> with async Rust to pause and resume those timers. (There is also a deep story about an issue in POSIX lurking here, which I’ll cover in a sequel to this post.)</p></li></ul><p><strong>Also consider</strong>, to meet user expectations, forwarding <code>SIGTERM</code> and other signals. These signals are not always sent to process groups, but it would make sense to forward them.</p><h2 id="4-conclusion-echoes-of-the-past">4. Conclusion: echoes of the past<a href="#4-conclusion-echoes-of-the-past" arialabel="Anchor">#</a></h2><figure><img src="https://sunshowers.io/images/signal-tower.jpg" alt="A photo of an abandoned microwave tower with graffiti all over its decaying sides. The tower is surrounded by a barbed wire fence, semiotically acting as both a beacon and a warning to stay away."/><figcaption>An abandoned microwave tower in the Santa Monica Mountains, California (<a href="https://www.wired.com/2015/03/spencer-harding-the-long-lines/">source</a>).</figcaption></figure><p>Signals are a fundamental part of the computing landscape, a legacy of design decisions made decades ago. They are a reminder that the systems we build today are shaped by the choices of the past, and that even the most well-intentioned innovations can have unintended consequences.</p><p>In <a href="https://www.tuhs.org/pipermail/tuhs/2015-September/007509.html">the words of Doug McIlroy</a>, creator of Unix pipes:</p><blockquote><p><code>Signal()</code> was there first and foremost to support <code>SIGKILL</code>; it
did not purport to provide a sound basis for asynchronous IPC.
The complexity of <code>sigaction()</code> is evidence that asynchrony remains
untamed 40 years on.</p></blockquote><p>Signals, for all their utility, were never meant to be the foundation of interprocess communication that they have become today. Yet we have found ways to adapt and evolve them to our needs, working around their limitations and turning them into opportunities.</p><p>Indeed, this is the essence of computing, and of technology itself: a story of creativity in the face of constraint, and of building upon the foundations of the past to create something new and beautiful.</p><p><em>I hope this post has shed some light on the fascinating world of Unix signals, and perhaps even inspired you to think closely about the systems you build. If you’ll be at RustConf in Montreal, come find me: I’d love to chat more about this and hear your own stories about signals, or of other intricate systems with long-forgotten design decisions. See you there!</em></p><p><em>Thanks to <a href="https://infosec.exchange/@munin">Fiona</a> for reviewing a draft of this post.</em></p></div></div></div></div>
  </body>
</html>
