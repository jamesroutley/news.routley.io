<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scattered-thoughts.net/writing/sql-needed-structure/">Original</a>
    <h1>SQL needed structure</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>Here are two pages from the <a href="https://www.imdb.com/">internet movie database</a>:</p>
<p><img src="https://www.agweb.com/writing/sql-needed-structure/imdb.png" alt=""/></p>
<p>There are two things to note about these pages.</p>
<ol>
<li>
<p>The data on the page is presented in a hierarchichal structure. The movie page contains a director, a list of genres, a list of actors, and each actor in the list contains a list of characters they played in the movie. You can&#39;t sensibly fit all of this into a single flat structure like a relation.</p>
</li>
<li>
<p>The order of the hierarchy isn&#39;t the same on both pages. On one page we have movie-&gt;actors and on the other page we have actor-&gt;movies. So you can&#39;t just directly store the hierarchy in your database - you need to be able to traverse relationships in both directions.</p>
</li>
</ol>
<p>So we store all our data in a relational database in flat tables and then whenever we need to render some UI we transform the flat data into whatever hierarchy we need.</p>
<p>Doing this transformation by hand is tedious and error-prone. We call this tedium &#34;the object-relational mismatch&#34; but it isn&#39;t really about objects or relations. The fundamental problem is that <strong>fitting complex relationships to human vision usually requires constructing some visual hierarchy</strong>, but <strong>different tasks require different hierarchies</strong>.</p>
<p>Whatever database and programming language you use, you will have to deal with this. But it&#39;s particularly painful in sql because sql wasn&#39;t designed to produce hierarchical data.</p>
<h2 id="sql-wasn-t-built-to-yield-structure">sql wasn&#39;t built to yield structure</h2>
<p>Let&#39;s grab the <a href="https://developer.imdb.com/non-commercial-datasets/">imdb public dataset</a> and try to reproduce the source data for that movie page (or at least a subset of it, because I didn&#39;t bother importing all the tables). We want to see an output that looks like this:</p>
<pre data-lang="json"><code data-lang="json"><span>{
</span><span>  </span><span>&#34;title&#34;</span><span>: </span><span>&#34;Baby Driver&#34;</span><span>,
</span><span>  </span><span>&#34;director&#34;</span><span>: </span><span>[</span><span>&#34;Edgar Wright&#34;</span><span>]</span><span>,
</span><span>  </span><span>&#34;writer&#34;</span><span>: </span><span>[</span><span>&#34;Edgar Wright&#34;</span><span>]
</span><span>  </span><span>&#34;genres&#34;</span><span>: </span><span>[</span><span>&#34;Action&#34;</span><span>, </span><span>&#34;Crime&#34;</span><span>, </span><span>&#34;Drama&#34;</span><span>]</span><span>,
</span><span>  </span><span>&#34;actors&#34;</span><span>: </span><span>[
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Ansel Elgort&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Baby&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Jon Bernthal&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Griff&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Jon Hamm&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Buddy&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Eiza Gonz√°lez&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Darling&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Micah Howard&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Barista&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Lily James&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Debora&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Morgan Brown&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Street Preacher&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Kevin Spacey&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Doc&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;Morse Diggs&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Morse Diggs&#34;</span><span>]}</span><span>,
</span><span>    {</span><span>&#34;name&#34;</span><span>: </span><span>&#34;CJ Jones&#34;</span><span>, </span><span>&#34;characters&#34;</span><span>: </span><span>[</span><span>&#34;Joseph&#34;</span><span>]}
</span><span>  ]</span><span>,
</span><span>}
</span></code></pre>
<p>Let&#39;s grab the title first:</p>
<pre><code><span>postgres=# select primaryTitle from title where tconst = &#39;tt3890160&#39;;
</span><span> primarytitle
</span><span>--------------
</span><span> Baby Driver
</span></code></pre>
<p>And now we need the director:</p>
<pre><code><span>postgres=# select primaryTitle, person.primaryName 
</span><span>from title, principal, person
</span><span>where title.tconst = &#39;tt3890160&#39; 
</span><span>and title.tconst = principal.tconst 
</span><span>and principal.nconst = person.nconst 
</span><span>and principal.category = &#39;director&#39;;
</span><span>
</span><span> primarytitle | primaryname  
</span><span>--------------+--------------
</span><span> Baby Driver  | Edgar Wright
</span></code></pre>
<p>And the writer:</p>
<pre><code><span>postgres=# select 
</span><span>  primaryTitle, 
</span><span>  director.primaryName as director,
</span><span>  writer.primaryName as writer
</span><span>from title, 
</span><span>principal as principal_director, person as director, 
</span><span>principal as principal_writer, person as writer
</span><span>where title.tconst = &#39;tt3890160&#39; 
</span><span>and title.tconst = principal_director.tconst 
</span><span>and principal_director.nconst = director.nconst 
</span><span>and principal_director.category = &#39;director&#39;
</span><span>and title.tconst = principal_writer.tconst 
</span><span>and principal_writer.nconst = writer.nconst 
</span><span>and principal_writer.category = &#39;writer&#39;;
</span><span>
</span><span> primarytitle |   director   |    writer    
</span><span>--------------+--------------+--------------
</span><span> Baby Driver  | Edgar Wright | Edgar Wright
</span></code></pre>
<p>We&#39;re already in trouble. If this movie had 2 directors and 2 writers, this query would return 4 rows:</p>
<pre><code><span> primarytitle |   director   |    writer    
</span><span>--------------+--------------+--------------
</span><span> Baby Driver  | Edgar Wright | Edgar Wright
</span><span> Baby Driver  | Edgar Wright | A. Writer
</span><span> Baby Driver  | A. Director  | Edgar Wright
</span><span> Baby Driver  | A. Director  | A. Writer
</span></code></pre>
<p>If there was no director in the database then this query would return 0 rows, no matter how many writers there were. Now we don&#39;t even know what the movie is called.</p>
<pre><code><span> primarytitle |   director   |    writer    
</span><span>--------------+--------------+--------------
</span></code></pre>
<p>We can&#39;t sensibly fit the data we want into a single relation, and we can&#39;t return more than one relation per query. So we have to issue multiple queries:</p>
<pre><code><span>postgres=# select primaryTitle from title where tconst = &#39;tt3890160&#39;;
</span><span> primarytitle
</span><span>--------------
</span><span> Baby Driver
</span><span>
</span><span>postgres=# select person.primaryName 
</span><span>from title, principal, person
</span><span>where title.tconst = &#39;tt3890160&#39; 
</span><span>and title.tconst = principal.tconst 
</span><span>and principal.nconst = person.nconst 
</span><span>and principal.category = &#39;director&#39;;
</span><span>
</span><span> primaryname  
</span><span>--------------
</span><span> Edgar Wright
</span><span>
</span><span>postgres=# select person.primaryName 
</span><span>from title, principal, person
</span><span>where title.tconst = &#39;tt3890160&#39; 
</span><span>and title.tconst = principal.tconst 
</span><span>and principal.nconst = person.nconst 
</span><span>and principal.category = &#39;writer&#39;;
</span><span>
</span><span> primaryname  
</span><span>--------------
</span><span> Edgar Wright
</span><span>
</span><span>postgres=# select person.nconst, person.primaryName
</span><span>from title, principal, person
</span><span>where title.tconst = &#39;tt3890160&#39; 
</span><span>and title.tconst = principal.tconst 
</span><span>and principal.nconst = person.nconst 
</span><span>and principal.category = &#39;actor&#39;
</span><span>limit 10;
</span><span>
</span><span>  nconst   |  primaryname  
</span><span>-----------+---------------
</span><span> nm5052065 | Ansel Elgort
</span><span> nm1256532 | Jon Bernthal
</span><span> nm0358316 | Jon Hamm
</span><span> nm2555462 | Eiza Gonz√°lez
</span><span> nm8328714 | Micah Howard
</span><span> nm4141252 | Lily James
</span><span> nm3231814 | Morgan Brown
</span><span> nm0000228 | Kevin Spacey
</span><span> nm1065096 | Morse Diggs
</span><span> nm1471085 | CJ Jones
</span><span>
</span><span>postgres=# select principal_character.nconst, principal_character.character
</span><span>from title, principal, principal_character
</span><span>where title.tconst = &#39;tt3890160&#39; 
</span><span>and title.tconst = principal.tconst 
</span><span>and principal.nconst = person.nconst 
</span><span>and principal.category = &#39;actor&#39;
</span><span>and principal_character.tconst = principal.tconst
</span><span>and principal_character.nconst = principal.nconst;
</span><span>
</span><span>  nconst   |     character      
</span><span>-----------+---------------------
</span><span> nm5052065 | Baby
</span><span> nm8328714 | Barista
</span><span> nm0358316 | Buddy
</span><span> nm2555462 | Darling
</span><span> nm4141252 | Debora
</span><span> nm0000228 | Doc
</span><span> nm1256532 | Griff
</span><span> nm1471085 | Joseph
</span><span> nm1065096 | Morse Diggs
</span><span> nm3231814 | Street Preacher
</span></code></pre>
<p>Through the magic of joins we have retrieved all the data we need and it only required holding a transaction open for 4 network roundtrips.</p>
<p>All that&#39;s left to do now is... the same joins, but inside the backend web server. Because we have to re-assemble these flat outputs into the structure of the page.</p>
<p>Also note that fully half of the data returned is the <code>nconst</code> column which we didn&#39;t even want in the output. We only returned it because we need it as a key so we can repeat the joins that we already did in the database. The more paths you traverse, the more useless join keys you need to send to the backend web server.</p>
<p>All of this is pretty tedious so we invented ORMs to automate it. But:</p>
<ul>
<li>Almost all ORMs end up sending multiple queries for the output that we want. If you have a good ORM and you use it carefully it&#39;ll send one query per path in the output, like the raw sql above. If you&#39;re <a href="https://dev.to/truptihosmani/n1-queries-problem-in-rails-3mag">less careful</a> you might get one query per actor in the film.</li>
<li>Many ORMs also <a href="http://www.bailis.org/papers/feral-sigmod2015.pdf">make a mess of consistency</a> by lazily loading data in separate transactions. So we might generate a page where different parts of the data come from different points in time, which is confusing for users.</li>
<li>Using an ORM locks you into only using one specific programming language. What if you need to query your data from a different language? You&#39;ll probably end up talking to the same ORM through a microservice.</li>
</ul>
<h2 id="old-dogs-can-sort-of-learn-new-tricks">old dogs can sort of learn new tricks</h2>
<p>These days sql actually can produce structured data from queries.</p>
<p>A lot of people are mad about this. Whenever I talk about it they reflexively yell things like &#34;structured data doesn&#39;t belong in the database&#34; as if there was a universal system of morality that uniquely determined the locations of various data processing tasks.</p>
<p>But I can&#39;t help but note again that <strong>the structure has to happen somewhere</strong> because that&#39;s what the output page looks like and that <strong>doing it outside the database isn&#39;t working very well</strong>.</p>
<p>Whenever we&#39;re building a UI for humans, whether on the web or native, <strong>the main use of the query language is to turn relational data into structured data</strong> for the client to render. So it would be really nice if the query language was actually able to produce structured data.</p>
<p>Like this:</p>
<pre><code><span>select jsonb_agg(result) from ( 
</span><span>  select 
</span><span>    primaryTitle as title, 
</span><span>    genres,
</span><span>    (
</span><span>      select jsonb_agg(actor) from (
</span><span>        select
</span><span>          (select primaryName from person where person.nconst = principal.nconst) as name, 
</span><span>          (
</span><span>              select jsonb_agg(character)
</span><span>              from principal_character
</span><span>              where principal_character.tconst = principal.tconst
</span><span>              and principal_character.nconst = principal.nconst
</span><span>          ) as characters
</span><span>        from principal
</span><span>        where principal.tconst = title.tconst 
</span><span>        and category = &#39;actor&#39;
</span><span>        order by ordering 
</span><span>        limit 10
</span><span>      ) as actor
</span><span>    ) as actors,
</span><span>    (
</span><span>      select jsonb_agg(primaryName)
</span><span>      from principal, person
</span><span>      where principal.tconst = title.tconst
</span><span>      and person.nconst = principal.nconst
</span><span>      and category = &#39;director&#39;
</span><span>    ) as director,
</span><span>    (
</span><span>      select jsonb_agg(primaryName)
</span><span>      from principal, person
</span><span>      where principal.tconst = title.tconst
</span><span>      and person.nconst = principal.nconst
</span><span>      and category = &#39;writer&#39;
</span><span>    ) as writer
</span><span>  from title
</span><span>  where tconst = $1
</span><span>) as result;
</span></code></pre>
<p>It&#39;s not perfect. You can definitely see the duct tape, and the query plan often suffers from the lack of <a href="https://www.agweb.com/writing/materialize-decorrelation/">decorrelation</a>. But we can grab all the data needed for the entire page in a single query, with one network roundtrip. Whether you use these features directly or as the output of your ORM, this is a sizable improvement for one of the main usecases of relational databases!</p>
<p>It doesn&#39;t matter that this isn&#39;t the way things have always worked. <a href="https://www.agweb.com/writing/unexplanations-sql-is-syntactic-sugar-for-relational-algebra/">Sql is not relational algebra</a> and <a href="https://www.agweb.com/writing/unexplanations-relational-algebra-is-math/">relational algebra is not math</a>, and neither was carved into stone tablets handed down from Codd.</p>
<p>We make tools to serve our purposes, and our purposes have changed a hell of a lot since the 70s, when the main client of a database was a human typing sql character by character into an interactive transaction on a teletype connected to a mainframe with 500kb of RAM, almost 20 years before the invention of the world wide web.</p>
<p>Maybe it&#39;s ok for our tools to evolve to meet new demands. And we can evolve with them.</p>

</article></div>
  </body>
</html>
