<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/llms-will-fundamentally-change-software-engineering/">Original</a>
    <h1>LLMs will fundamentally change software engineering</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p><img alt="an AI drawing of a weird cyborg kid in front of an egg shaped computer, in black and white ink. It&#39;s very scifi and quite melancholic in some way. The egg computer is also a tree." src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/manuel-1679490599-0.png"/></p>
<p>Heard about Large Language Models like ChatGPT4, Bing, GPT3? I&#39;m sure you have.</p>
<p>There is one side of the hype around these technologies that I come across pretty often, which is that these technologies are bad for some <code>$reason</code> (&#34;they are stochastic parrots&#34;, &#34;they create bullshit&#34;, &#34;they can&#39;t reason&#34;, &#34;they make up facts&#34;, &#34;they might replace junior developers, but they will not replace senior developers&#34;), which, while technically true, is missing a much bigger point: if you are in the business of writing software, these things work.</p>
<p>In fact, they work so well that I think we are on track to see a fundamental shift in how software is built. This is going to have a drastic impact on pretty much everything. The irony of the situation is that programming is probably one of the jobs that can most easily be replaced by these technologies. This article is mostly directed at programmers among my readers: <strong>we are at a pivotal moment where we programmers need to understand and appropriate these technologies, on our own terms, before capitalism does it for us.</strong></p>
<p>I have written about <a href="https://the.scapegoat.dev/llms-a-paradigm-shift-for-the-pragmatic-programmer/">how I am convinced that LLMs are a paradigm shift for the pragmatic programmer</a> and started giving more detailed insight into what I have been using these models and the applications around them for. I have also written about my budding <a href="https://the.scapegoat.dev/thoughts-about-the-ethics-of-large-language-models/">ethical stance</a> around this technology, and won&#39;t get into that aspect in this post.<sup id="fnref-1"><a href="#fn-1">1</a></sup></p>
<p>I think that we are at ground zero of a tremendous revolution in the way we build software. We don&#39;t know how to work with these tools yet: we just discovered alien tractor technology. Many critics try to use it as if it was a plain old gardening rake, dismissing it because it plowed through their flowerbed.</p>
<p>I hope to share some of the insights I&#39;ve gained into what programming with LLMs actually does for me. I have discovered that <a href="https://the.scapegoat.dev/having-a-creative-practice-as-a-programmer/">developing a practice</a>, a methodology, a workflow is key to intellectual work, be it software or writing or music. Because programming is closely intertwined with productive teamwork (especially in our capitalist context), this practice has to be shared. Programming is about coordinating the work of individuals to create common artifacts, and success is determined by how well we coordinate.</p>
<p><strong>I think that programming with LLMs is about to create a radical shift in software architecture, system architecture, programming practices, communication patterns and organizational structures.</strong> These are exciting times, because we are the people who are in position to shape what programming is going to be like in the future.</p>
<h2 id="my-background-is-in-system-programming">My background is in system programming</h2>
<p>I consider myself a programmer first. I&#39;ve wanted to press buttons to make machines do things since <a href="https://dev.to/wesen/how-i-got-into-computers-thomson-mo5-my-first-love-3hg1">I was 5</a>, and one of my <a href="https://the.scapegoat.dev/autistic-people-cant-acknowledge-when-they-are-wrong/">autistic interests</a> has been computers ever since. Even my music, drawing, writing is inextricably bound to these machines of wonder. I have written millions of line<sup id="fnref-2"><a href="#fn-2">2</a></sup> of code and barely a day passes by when I don&#39;t push a few commits. All that to say that I&#39;m intensely interested in things that work, and that I have tried many many things. <strong>I care enough about coding that if LLMs weren&#39;t useful, I wouldn&#39;t be using them every day</strong>.<sup id="fnref-3"><a href="#fn-3">3</a></sup></p>
<p>I have been programming heavily with Copilot since it was in beta, and have been using chatgpt for every real-world problem I could think of, beginning the week after it was accessible to the public. I write mostly &#34;<a href="https://dev.to/wesen/i-am-a-dumb-programmer-thats-why-i-am-good-at-my-job-beh">boring</a> <a href="https://dev.to/wesen/90-of-software-engineering-is-integrating-janky-apis-and-i-love-it-4k41">glue code</a>,&#34; and have done so in what I call &#34;systems programming,&#34;, i.e. building systems (operating systems, embedded systems, distributed systems, logistics, supply chain). Another definition could be &#34;writing memcpy in many different complicated ways.&#34; <sup id="fnref-4"><a href="#fn-4">4</a></sup></p>
<h2 id="copilot-my-uncanny-autocomplete">Copilot my uncanny autocomplete</h2>
<p>I love &#34;rustic&#34; programming languages: my favourites are <a href="https://dev.to/wesen/why-i-love-php-and-javascript-2li2">PHP and Javascript</a>, Java, Go, (and, for reasons that are beyond the scope of this article: Common Lisp<sup id="fnref-5"><a href="#fn-5">5</a></sup>). For me, &#34;rustic&#34; means that what you see is what the author intended, without necessarily a lot of polish: languages that make their context explicit. It&#39;s the dinner table built by your grandfather, upgraded by your mother and you now inherit: it is a bit clunky and the paintjob is flaking off, but it has been doing its job for nearly a century without failing. These are languages that Copilot does a superb job with. The patterns it should use are often very &#34;flat,&#34; and are often present in the code around it. A symbol&#39;s meaning is not influenced by hidden characteristics, abstractions, or module systems. It is not that it is the &#34;complexity&#34; or abstraction-level of the language that makes for inferior results, it&#39;s that it is more difficult to infer from the training corpus what the completion of your code should look like.</p>
<p>This is what allows Copilot to do a superb job (while I tried to use it for Haskell and Rust in the summer of 2022, I haven&#39;t tried since. Copilot has made some impressive progress since, so my take here might already be completely out of date. I have grown used to Copilot uncannily inferring what I am trying to do after writing the first couple of words. In fact, I have noticed how my physical muscle memory has changed during the programming process. If my internet is down and I—god beware!—have to type in code myself, I have to undergo a mental switch. At first I&#39;ll write 3 words and expect 10 lines of code to be scaffolded out. It takes me a few seconds to realize my magical friend <a href="https://wakeupdonnie.fandom.com/wiki/Frank">Frank the copilot</a> has gone AWOL.</p>
<h2 id="stochastic-parrots-valid-code">Stochastic parrots, valid code?</h2>
<p>One of the common criticisms of Large Language Models is that they often output wrong code. Which is true (ChatGPT4 significantly ups the bar, but it&#39;s not too difficult to get it to output wrong code)! Leaving it at that is, however, I think not looking carefully enough. <strong>Quickly written wrong code that can be easily corrected is just another name for good code</strong>.</p>
<p>Much of my programming consists of writing trivial ideas in longform. I will start with &#34;I need to copy this data from here to here&#34; (which is why I refer to it as &#34;memcpy programming&#34;), and then spell it out in HTTP call this, promise that, SQS event here, batch job there. Just writing the comment <code>call the HTTP api /api/products and send the result to our SNS topic /products</code> is enough for Copilot to basically complete the entire thing.</p>
<p>Because I am not a rocket scientist, the methods are going to be something like (in fake Javascript):</p>
<div><pre><span></span><span>http</span><span>.</span><span>GET</span><span>(</span><span>&#34;/api/products&#34;</span><span>).</span>
<span>   </span><span>then</span><span>((</span><span>products</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>if</span><span> </span><span>(</span><span>validateProducts</span><span>(</span><span>products</span><span>))</span><span> </span><span>{</span><span> </span>
<span>      </span><span>this</span><span>.</span><span>sns</span><span>.</span><span>enqueue</span><span>()</span><span> </span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span>
<span>      </span><span>fail</span><span>(</span><span>&#34;invalid products&#34;</span><span>)</span>
<span>    </span><span>})</span>
</pre></div>

<p>If you autocomplete copilot after writing the comment above, it might very well come up with:</p>
<div><pre><span></span><span>http</span><span>.</span><span>GET</span><span>(</span><span>&#34;/api/products&#34;</span><span>).</span>
<span>   </span><span>then</span><span>((</span><span>products</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>if</span><span> </span><span>(</span><span>validator</span><span>.</span><span>checkProducts</span><span>(</span><span>products</span><span>))</span><span> </span><span>{</span><span> </span>
<span>      </span><span>const</span><span> </span><span>sns</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>SNS</span><span>(</span><span>this</span><span>.</span><span>topic</span><span>)</span>
<span>      </span><span>sns</span><span>.</span><span>enqueue</span><span>(</span><span>products</span><span>)</span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span>
<span>      </span><span>throw</span><span> </span><span>Exception</span><span>(</span><span>&#34;invalid products&#34;</span><span>)</span>
<span>    </span><span>})</span>
</pre></div>

<p>Getting hung up on the fact that it used <code>validateProducts</code> and not <code>validator.checkProducts</code> is I think missing the point. The actual working benefit is that I now usually spend 10 minutes on something that would have taken me 2 h.</p>
<p>I think the implications of that fact stretch much further than &#34;Well, now we have just replaced code monkeys.&#34; I think that being able to write tedious code at that speed closes so many feedback loops that it leads to emergent effects that change the way we build software.</p>
<h2 id="aside-1-helping-copilot-output-valid-code">Aside #1: Helping Copilot output valid code</h2>
<p>Although Copilot is very eager to discover your codebase, it needs to see what style you like. It needs to see what APIs and helper methods you already have at your disposal, and which packages to import.</p>
<p>The solution, if you would like to tab-complete 90ish% of the code you intend to write? Visit a couple of files you want Copilot to &#34;learn&#34;, or write one example of what it should generate. <strong>If you want Copilot to be fluent at using an obscure library, just go browse its source code, visit a few examples, then go back to frantically tab-complete your way to a working application.</strong></p>
<p>The same technique works for ChatGPT. You want to have a decent output for ChatGPT? Just copy paste a ton of example code upfront. Copy paste your class definitions, the comments to your class definition, maybe some DDL, some example CSV. Paste it often, paste it every time it diverges. Take its code, correct it, paste it back. Paste the documentation page. Paste the entire StackOverflow thread. Paste paste paste, context context context is what is needed here.</p>
<h2 id="methodology-shift-1-writing-documentation">Methodology shift #1: writing documentation</h2>
<p>This is the first change in methodology we have encountered. More than API documentation for humans, we need to write code (and tools!) that make the API discoverable and &#34;understandable&#34; for LLMs. In most cases, the two come hand in hand. Writing clear and concise comments is what gives the LLM the context it has seen in its training set, thus helping it to infer the correct answer. <strong>Clear and concise APIs, with meaningful names, allow us to efficiently (the fewer tokens the better) convey our intent to our tools.</strong></p>
<p>I think we will start seeing practices that will expose documentation as both human readable, and easily &#34;machine parseable&#34; (short, concise, with few-shot examples for concrete tasks). <strong>Instead of formal languages such as UML, ODL, SOAP, Swagger, JSON Schema, we will go back to simple, no-nonsense READMEs that give a short overview and a couple of usage examples.</strong> This will work not because simple is better (there is a reason we keep reinventing the wheel with these things). It works because the README encodes our &#34;human&#34; intent very well, and the source code embodies what we intend the system to do in excruciating detail, and an LLM can combine the two to generate either more &#34;formal&#34; code for the machine to interpret, or less detailed text for humans to interpret.</p>
<p><strong>I don&#39;t think we have realized that the most effective way to communicate with humans is now also an efficient way to communicate with machines.</strong></p>
<p>This of course works both ways. <strong>Large Language Models are uncannily effective at transforming crappy comments into well-written, articulate paragraphs.</strong> They can generate 5 interesting examples in the time it takes me to say &#34;please.&#34; They can update the existing documentation to match the updated API after refactoring in a matter of seconds (and it is only cumbersome because it currently requires copy-pasting to and from ChatGPT). Copilot Labs is experimenting with &#34;brushes&#34;, but since I use Intellij and not Copilot, I haven&#39;t really used them much).</p>
<p><strong>They can update code to match documentation changes in the same way, or generate valid code out of concise, well-written documentation.</strong> Heck, you can literally curl a few endpoints in your terminal, paste the entire thing without any editing into ChatGPT. You can then ask it to create an API library with mocks, unit tests, examples and documentation. This will more often than not output something better than I would have written.</p>
<p>I don&#39;t bother manually writing any of this data munching / API wrapping / result validating code anymore. I had to build a server-to-server integration with Google Tag Manager recently. I literally copy pasted the <a href="https://github.com/go-go-golems/geppetto/blob/main/examples/gtmgen/1-add_payment_info.md">webpage</a> into a simple <a href="https://github.com/go-go-golems/geppetto/blob/main/cmd/pinocchio/prompts/examples/code/gtmgen.yaml">3 line prompt</a> and can now generate PHP classes, typescript interfaces, event log parsers, SQL serialization with a simple <a href="https://github.com/go-go-golems/geppetto/tree/main/cmd/pinocchio">shell command</a>.</p>
<p><strong>What do we do now that well-written documentation is both fundamental and almost free? Do <a href="https://the.scapegoat.dev/writing-made-me-a-better-engineer/">we become writers</a>? Do we become editors?</strong></p>
<p>Personally, I think so. There is no excuse to not write stellar documentation (or tab-complete your way to it), documentation style and documentation quality will become just as automatable and lintable as how many spaces we put in front of our curly braces, and code comments will never be out of date again (why wouldn&#39;t your IDE flag documentation that doesn&#39;t match the behaviour of the code?).<sup id="fnref-6"><a href="#fn-6">6</a></sup></p>
<p>And if we become editors, does that mean that learning to work as a programmer is now, from the get go, about learning to read, criticize and correct code? These are the skills that we have painfully turned into practice over the last 30 or 40 years since the explosion of professional software engineering, and are often reserved to the &#34;senior&#34; caste, juniors being busy banging their heads against the compiler or something. <strong>But now being a junior means de facto becoming a critical reader. Code reviewing is the new programming.</strong> <sup id="fnref-7"><a href="#fn-7">7</a></sup></p>
<h2 id="methodology-shift-2-whiteboarding-and-rubberducking">Methodology shift #2: Whiteboarding and rubberducking</h2>
<p><strong>One thing using LLMs teaches you is that software architecture is about pattern matching, and those patterns are fairly simple.</strong> The thing is that by default, ChatGPT for example is akin to a &#34;design interview bullshitter.&#34; It will confidently use a lot of clever words, draw the right diagrams on the whiteboard, and be utterly incompetent at making an actually worthwhile point. Asking ChatGPT how to design a certain application will result in eerily similar heaps of teflon-coated, reality-proof platitudes (ChatGPT4 already sets the bar much higher here...).</p>
<p>It is easy to say the right things, it is easy to look up what an effective event-driven architecture looks like, but it is much more difficult to figure out what exactly needs to be done, what is easy, what is difficult, what works well, and what fails in a real-world scenario. But, using the technique shown above, once you start asking ChatGPT how to build out a concrete application by sketching out potential APIs, fleshing out an infrastructure, deciding which protocols to use, you often get a lot of plausible looking, concrete code.</p>
<p>I find generating &#34;plausible&#34; code useful on its own. I don&#39;t need to trust the code to be correct—the overall structure and vibe gives me a sense of how this thing will work, what is problematic, and what is clever. It has a tremendous amount of quality code to rely upon to find interesting patterns and well-named classes; I can guide it when I think of something. I basically have a pretty &#34;intelligent&#34; rubber duck at my disposal.<sup id="fnref-8"><a href="#fn-8">8</a></sup> <strong>Brainstorming with ChatGPT feels very much like sitting in front of the whiteboard with a colleague and just imagining things, except that you often end up with reasonably close to working code by the end.</strong> While I have never done a &#34;three-way&#34; whiteboarding/rubberduck session with a human and ChatGPT, I think that this will become a regular practice for some.</p>
<h2 id="methodology-shift-3-build-more-prototypes">Methodology shift #3: Build more prototypes</h2>
<p>ChatGPT is great for generating prototypes, big and small. Ask it about a topic and it will not only answer, but usually provide a fully runnable example in the language of your choice. It might or might not execute, but that&#39;s a heck of a lot of really boring nonsense that I don&#39;t have to type. Once the LLM has typed out a toy example, I can remodel that simple example into many more things:</p>
<ul>
<li>A full command-line application</li>
<li>A unit test suite</li>
<li>A fuzzing harness</li>
<li>An example of documentation.</li>
<li>A stress-test tool</li>
<li>A simple web UI (&#34;write HTML for a field that posts to /api/product and display the resulting JSON as a table. Then, write CSS to style it like a geocities page.&#34; is how you do it...)</li>
<li>A Docker container to use in CICD</li>
<li>...</li>
</ul>
<p><strong>LLMs lower the cost of exploration to almost nil.</strong></p>
<p>I recently wanted to write a plugin for OBS that would stop the recording if I didn&#39;t close a modal within 1 minute. I had never programmed OBS before, but in three hours I was able to do the following:</p>
<ul>
<li>Build a Python script that looks very promising</li>
<li>Fight with OBS until I realized that trying to get arm64 python working was too frustrating (1h lost...)</li>
<li>Rewrite the script in LUA and get it working</li>
<li>Realized that what I thought was a weird hallucination was actually the best possible way to do something like a modal in LUA. Decided it sucked.</li>
<li>Write a Go CLI application that controls recording over a websocket.</li>
<li>Write a cross platform UI in Go that shows me the modal and various other buttons to control recording</li>
</ul>
<p>I was able to try two dead-ends (through no fault of the LLM&#39;s own, honestly) and end up with a robust running tool that I will continue expanding. I hate writing UIs, I hate fighting obscure APIs I don&#39;t know. I used to only write tools when something was getting so humongously irritating that I just couldn&#39;t take it anymore. I have a problematic habit I am actively trying to fight: building personal tools as if they were meant for production at-scale (meaning: after 3 days doing &#34;professional&#34; software engineering, I burn out and the tool ends up in the ditch, full of promise yet unfinished.)</p>
<p>What this means for professional programming is that you can now write code, write a lot of code, write an insane amount of code, and just throw it away. No one will fault you for having a conversation with ChatGPT that generates 5000 lines of code, and then closing the tab. But, the fact is, you wrote 5000 lines of code and decided they were not worth it. When was the last time you did that?</p>
<p>What if it became standard practice to draw up a concise, well-written description of the problem at hand (see the previous section), and then ask the LLM for a microservice architecture sketch in go, a synchronous multithread sketch in rust, a typescript deno version, potentially a lambda. What if you had it generate Terraform for AWS, but also for Azure and GCP? What if an architecture proposal now only gets to the review stage if you try at least A, B, C, D before settling on one, instead of endlessly debating with your colleagues about A vs B? We all know we have biases. We all hold strong opinions that can only be supported by evidence with an n of 1. I am usually more convinced when I see an actual code sketch.</p>
<p><strong>We used to deride &#34;writing code at the speed of mouth,&#34; but that is now a reality.</strong></p>

<p>Which brings me to the next practice that I think will be incredibly beneficial. We all know that tools are important, that effective tools are challenging to create, and that management doesn&#39;t care or understand the need for tools. LLMs allow us to build tools at the said &#34;speed of mouth.&#34; I know that I can now spend 30 to 45 minutes talking to ChatGPT and get a pretty solid tool done. This would probably have taken me 4 to 5 h programming previously, which means that it would have to be split over 2-3 work days (factoring in meetings, code review, lunch breaks, interruptions). Which usually means that the tool won&#39;t get built.</p>
<p>A list of tools I built in the last 3 months:</p>
<ul>
<li><a href="https://github.com/go-go-golems/sqleton">sqleton</a> - a tool to run SQL queries as command line applications</li>
<li><a href="https://github.com/go-go-golems/escuse-me">escuse-me</a> - the same for elasticsearch</li>
<li><a href="https://github.com/go-go-golems/geppetto">geppetto</a> - the same for the GPT APIs</li>
<li><a href="https://github.com/go-go-golems/biberon">biberon</a> - the same for bibtex (very rudimentary, it got one job done)</li>
<li><a href="https://github.com/go-go-golems/majuscule">majuscule</a> - a twitter hashtag segmentation prototype, but with dynamic HTML debug UI</li>
<li>a script to stop OBS recording if I am away from my computer</li>
<li>many utilities for work:<ul>
<li>Convert arbitrary documentation to code (see Google Tag Manager example above).</li>
<li>Parse and analyze search logs.</li>
<li>A SQL builder for said search logs.</li>
<li>A full-featured GTM server-side implementation.</li>
<li>Tools for managing banners and their assets.</li>
<li>An application that runs invoices through OCR, cleans it up with GPT, searches ElasticSearch for SKUs, and renders out a cleaned up invoice matching our inventory</li>
<li>Report generators for every single datalake debugging I had to do</li>
<li>Documentation generator for Google Tag Manager JSON exports</li>
</ul>
</li>
</ul>
<p><strong>I can&#39;t express how fundamentally different programming feels now that I can build 2 quality tools per day, for every single itch I want to scratch.</strong></p>
<h2 id="aside-2-fundamentals-will-probably-be-just-as-critical">Aside #2: Fundamentals will probably be just as critical</h2>
<p>I believe that <a href="https://the.scapegoat.dev/learning-and-practicing-abstraction/">abstraction</a> is primarily learnt by having seen and played with enough concrete use cases that higher structures get formed. Abstractions are a two-edged sword, as an ill-fitting abstraction will cause constant friction. While LLMs allow us to work at a &#34;fuzzy abstraction&#34; level (the abstraction is not ready to be formalized, but it is forming and shaping the words used to describe a problem) as well as quickly explore concrete implementations, <strong>&#34;controlling&#34; an LLM is best done by having a solid understanding of the problem in mind.</strong></p>
<p>One very real downside I have experienced with conversational LLMs is the temptation to keep chatting and hacking at a problem in the hopes that the model will &#34;get it&#34; at some point. This is exacerbated when you don&#39;t have a proper grasp of the problem you are trying to solve. Your focus shifts from having a productive conversation to stumbling over hallucinations that lead you on wild goose chases. In those cases, I found myself closing my internet connection altogether. Instead, I stuck  with offline documentation and a book until I got a better sense of what I was dealing with.</p>
<p>With &#34;real&#34; knowledge in hand, asking the right questions of the LLM leads to a much more productive session. <strong>Anybody deriding &#34;prompt engineering&#34; as a ridiculous discipline hasn&#39;t spent enough time trying to write effective prompts.</strong></p>
<p>Aside #3: Avoid unproductive chat sessions</p>
<p>I hope that future conversational agents will be able to flag when these unproductive spirals happen. Currently, ChatGPT will just continue to engage, but I could see it at some point stopping, and pointing to proper tutorials and resources. Another option would be to ask for more details. The progress that ChatGPT4 seems to have made (I have only used it seriously for 2 days, so I can&#39;t really form a proper opinion) is quite impressive. One thing this field has taught me is not to make assumptions about the capabilities of the next generation. It might have the same fundamental issues the current models have, but it might just become &#34;good enough&#34; that for all intents and purposes, it doesn&#39;t matter.</p>
<h2 id="methodology-shift-5-continuous-code-review">Methodology shift #5: Continuous code review</h2>
<p>I think that a major focus of tooling is going to be on &#34;continuous code review.&#34; A model can watch you build your software, infer your intents and the structure of your thinking, and provide feedback on your approach. It can flag typos, security mistakes, and non-idiomatic uses of APIs. I was impressed by ChatGPT4 correcting my code and doing some pretty effective factoring of the problem into interfaces and functions by itself. In fact, I would say that in the small, ChatGPT4 is a much better programmer than I am. It knows many more idioms, it doesn&#39;t forget security issues, and it can spit out unit tests at the speed of token sampling.</p>
<p>People who think that these models will lead to a proliferation of bottom of the barrel stackoverflow code riddled with security mistakes are missing how quickly these models have become better at what they do. I think it is because it is easy to forget just how much good code can now be found online. Great code is bound to be more widely disseminated in its training corpus, and said corpus is most certainly closely scrutinized and tweaked. The jump from ChatGPT3.5 to ChatGPT4 in terms of software architecture &#34;rhetoric&#34; makes that abundantly clear.</p>
<p>I use a series of prompts that ask the model to give its feedback regarding security issues, edge cases I&#39;ve missed, documentation that is unclear. As of now, I have to manually copy and paste this into chatgpt, provide missing context, and refine its answers. This is however a matter of engineering. The model itself already does an impressive job. This is infinitely better than most code reviews I&#39;ve received over my career, and it is instantaneous, along with examples to reproduce the issues found and fix suggestions.</p>
<p>It is now basically easier to write complex, fuzzy linters that can check for domain-specific, codebase-specific patterns, because such prompts consist of a couple of (well-informed) human language prompts. It is probably faster to instruct the LLM-linter to &#34;check that singletons are only used when dealing with customer data&#34; than to properly configure curly-brace behaviour in editorconfig. It won&#39;t catch every usecase, but it will catch enough to be worth its while.</p>
<h2 id="methodology-shift-6-cognitive-impact-of-using-llms">Methodology shift #6: Cognitive impact of using LLMs</h2>
<p>This might be the most subtle shift, but I believe it&#39;s also the most profound change that using LLMs has brought to me. After a day of being focused on getting &#34;the tedious stuff&#34; right (using the right API, checking the right errors, properly calling API X, implementing the unit tests and mocks for Y, writing an API wrapper for Z), my brain would be entirely gone, consumed by the minutiae and intensity required to not slip up. I would spend the evening playing video games or watching Netflix to recover.</p>
<p><strong>Since extensively using Copilot and ChatGPT, this cognitive exhaustion is pretty much gone.</strong> 6pm strikes and I feel like I spent the day chatting with a buddy, yet 5 PRs have been merged, the unit tests have been written, two tools have been improved and the code has shipped.</p>
<p>This allows me to make significant progress on my open-source projects. I know that I&#39;ll be able to get one non-trivial thing done before dinner, and maybe one or two more after. Where I would previously spend 3 h on Saturday trying to get an AWS lambda running, wondering &#34;why the hell am I spending my Saturday this way&#34;, I will now happily close one or two tickets, and spend the rest of the day with my family and doing chores.</p>
<h3 id="doing-more-high-level-thinking">Doing more &#34;high-level&#34; thinking</h3>
<p>I am a firm believer in letting things rest, and doing &#34;shower-thought-driven&#34; software engineering. I believe it is necessary to think deeply about something, try to build a few prototypes, and then let it settle. The real insights (and bug solving) happen when taking a walk, when my brain is well-rested, after exercising or in the proverbial shower. Whereas I would previously maybe be able to 30 minutes to 1h of this &#34;free&#34; time per day, if at all, by being able to fold the tedious stuff that used to take 4h into 1 or 2h (I am averaging here, but writing something like an API wrapper legitimately costs me 10 minutes instead of 2 days nowadays), I now have 3 to 4h of &#34;free&#34; thinking time per day.</p>
<p>This means that I can think about what needs to be done and what doesn&#39;t. It means I can spend some time trying out alternative approaches (build more prototypes, as detailed above). I can spend more time talking to stakeholders and figuring out exactly what we need. I can think about the tools that <a href="https://the.scapegoat.dev/you-the-developer-are-a-user-too/">the team itself</a> needs. I can work on pedagogical material. I can make reports pretty. It is not that these things couldn&#39;t be done before, but they have become so insanely cheap that there is no good reason not to do them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I wish more senior developers had spent the time to properly assess these technologies, with an open mind instead of reacting defensively with knee-jerk reactions. These technologies are scary, because they make it clear that programmers are going to be the first in-line to be replaced by machines.</p>
<p>All the &#34;improvements&#34; listed above are going to be exploited by the way our industry is structured (corporations are already AIs, in some way) to squeeze even more soul-crushing productivity to the benefit of a very few individuals. We have an opportunity right now to reckon with how we deal with these emerging powers. I am trying to work out which direction I want to take, besides writing about what I think is valuable engineering insight: taking these technologies out of the moat of Silicon Valley companies; using the &#34;improved&#34; productivity before companies catch up to figure out how to organize; leveraging LLMs to build better open-source; using these technologies to build tools for people, not business.</p>
<section>
<ol>
<li id="fn-1"><p>Furthermore, while I might slip and anthromorphize LLMs, I do so in the way that I would say that &#34;the compiler thinks.&#34; As far as I am concerned, LLMs are relatively straightforward pieces of code trained on a shitton of data, and ChatGPT is not more alive or reasoning or feeling than <code>/bin/ls</code> and my S3 bucket of production logs. It doesn&#39;t know, it doesn&#39;t remember, it has no intent, it has no interactions with the world. I want us to talk about LLMs as what they are: probabilistic models of language that predict the next token based on a given context, after having been trained on exactly that. The fact that this formulation has led to such things as ChatGPT blows my mind, but I&#39;m not interested in discussing irrefutable speculation. I just want to write code, man...<a href="#fnref-1">↩</a></p></li>
<li id="fn-2"><p>There&#39;s a whole thing about programming vs software engineering that I never fully understood. Surely software engineering is about building good software, and programming is, well, building good software too. When I draw diagrams I am programming. When I write documents I am programming. When I talk with colleagues in front of a whiteboard we are programming. When I read and write a lot of software, mindfully, I do a lot of software engineering, because I want my software to work today, tomorrow, in ten years (which means measuring, testing, benchmarking, breaking, stress-testing, documenting). I want it to work even when 30 people work on it under the pressure of deadlines (which means designing, refactoring, testing, building development workflows, writing documentation, communicating, understanding team structures and business goals and legacy and individual cognitive styles). I call it programming because the only tangible result that we can actually all agree on is the resulting artifacts (source code and documentation). I love working on and reading legacy codebases, and you can read most of the &#34;more abstract&#34; things in the source code itself (on the easier side: team dysfunction, badly aligned goals, insufficient communication; on the harder side: good onboarding, individual contributor growth, great business alignment). That&#39;s why I tend to bring up coding so much. You can talk beautifully about all kinds of concepts, but what really matters is the code that comes out. To me, good code is synonymous with good engineering (good code can be: code that solves a business problem, where often no code is actually the best code; code that is elegant (some programmers like making elegant things, most like using elegant things); code that is fun; etc...).<a href="#fnref-2">↩</a></p></li>
<li id="fn-3"><p>If this comes across as braggy, one thing I learned about the last year after discovering I&#39;m autistic is to not care too much about how I come across. I think I am a pretty terrible, careless coder; I love sharing everything I know: I want everybody to find the love I do when I use computers. I am disappointed that I will never get to be a jack of all trades, because there is just too much cool stuff out there. I will leave mastery to people who have a more focused curiosity.<a href="#fnref-3">↩</a></p></li>
<li id="fn-4"><p>This seems to be another loaded term where people fight over definitions. I am grouping embedded, some web, distributed, operating systems and some database development under the systems programming umbrella. It seems like a very broad umbrella, but from a programming perspective, I see it as the programming of queues, resource ownership, resource initialization and teardown, concurrency, locking; the programming of protocols, data serialization, storage, bandwidth, throughput, latency; the programming of state machines, coroutines, schedulers, threads, drivers and APIs. When we define &#34;systems programming&#34; from the programming perspective (what code we write), we discover many parallels which are &#34;generative,&#34; i.e. they generate insight and ideas through the use of code. This is in contrast to defining &#34;systems programming&#34; as say, the programming of operating systems. This shuts down insight. It causes generations of web developers to reinvent the wheel each time they want to manage minified assets instead of using a resource pool. It leads generations of embedded developers to reject better tooling and effective testing and deployment practices. It leads to a smorgasbord of poorly designed embedded UIs and slow web applications and unpleasant concurrency abstractions and operating systems that think everything is an integer.<a href="#fnref-4">↩</a></p></li>
<li id="fn-5"><p>You might wonder why I group Common Lisp along with PHP. What makes Common Lisp special as a language is that it allows you to build your own language whenever you need to, however you need to. You can refine it interactively. If your goal is to write code with a clear structure and explicit context, Common Lisp is an excellent tool. Instead of shoe-horning your communication into a ready-made, rigid framework, you build the structure to fit your communication. As we will see, this is what allows LLMs to do a good job. Also, take a look at the Common Lisp spec and tell me it&#39;s not... clunky with a flaky paintjob.<a href="#fnref-5">↩</a></p></li>
<li id="fn-6"><p>You might realize by browsing <a href="https://github.com/go-go-golems/geppetto">geppetto&#39;s repository</a> that it&#39;s just as easy to... not write documentation. Entirely free it is not, that is for sure. Another reason here is that I don&#39;t want people using this tool just yet. I have put significantly more effort into <a href="https://github.com/go-go-golems/glazed">glazed&#39;s</a> documentation, including building an entire <a href="https://github.com/go-go-golems/glazed/blob/main/cmd/glaze/doc/topics/01-help-system.md">HelpSystem</a> inspired by <a href="https://wolfram.com">Mathematica&#39;s</a> stellar documentation.<a href="#fnref-6">↩</a></p></li>
<li id="fn-7"><p>I think people worried about junior programmers becoming obsolete should rather be worried about junior programmers replacing seniors. It&#39;s easy to believe that your mind stays younger as you grow older. However, hanging around discord with passionate 15 year olds quickly shows me how calcified I have become. I might think that my elegant take on frontend frameworks and component-based CSS, my ideally crafted git workflow and observability practices are the embodiment of craft. In the meantime, the kids think I could just as well write COBOL while they merge their 30th pull request of the day. This will enable their fully automated CICD to deploy the newly created artifacts. Every random repository that gets shared on Tiktok gets 300 (3000? 30000?) stars within a few days. While me writing opensource back in 1998 meant maybe getting a single patch merged because I knew someone on IRC who cared, today, it means growing up fast AF and becoming an agile tech lead quickly.<a href="#fnref-7">↩</a></p></li>
<li id="fn-8"><p>As someone who needs to ramble and ramble and ramble at somebody in order to clarify my thoughts, this is genuine magic. One downside is that the tool&#39;s &#34;personality&#34; changes over time. It latches onto novel concepts, and heavily redacts or tones down more opinionated statements, often in response to prompting attacks and in order to reduce the amount of hallucinations and other side-effects. This is the inverse of what you want when brainstorming, where far-out ideas are what spark joy. As a work-around, I often prompt the worst models and paste their confabulations into the more reasonable big brother, in order to disrupt the process.<a href="#fnref-8">↩</a></p></li>
</ol>
</section>
</div>
</div></div>
  </body>
</html>
