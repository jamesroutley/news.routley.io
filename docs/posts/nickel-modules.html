<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tweag.io/blog/2024-06-20-nickel-modules/">Original</a>
    <h1>Nickel Modules</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>One of the key features of <a href="https://nickel-lang.org/">Nickel</a> is the <a href="https://nickel-lang.org/user-manual/merging/">merge system</a>, which is a clever way of combining records, and allows defining complex configurations in a modular way.
This system is inspired by (amongst others) the <a href="https://edolstra.github.io/pubs/nixos-jfp-final.pdf#page=17">NixOS module system</a>, which are the magic bits that tie together NixOS configurations and gives NixOS its insane flexibility.
Nickel merging and NixOS modules work slightly differently under the hood, and target slightly different use-cases:</p>
<ul>
<li>Nickel merge is designed to combine several pieces of configurations which all respect the same contract. This allows an application developer to define the interface of its configuration, and have the user write it in a modular way.</li>
<li>NixOS modules, on the other hand, are designed to combine pieces which not only define a part of the final configuration, but also a part of the contract. This is a must-have for big systems like NixOS, where defining the whole schema in one place isn’t possible.</li>
</ul>
<p>Even in Nickel, it would be sometimes desirable to get the full modularity of NixOS modules. For instance, <a href="https://github.com/nickel-lang/organist">Organist</a> is based on this idea of having individual pieces, each defining both a part of the final schema and a part of the configuration — the <a href="https://github.com/nickel-lang/organist/blob/main/doc/filegen.md">files</a> module will define the interface for declaring custom config files, and hook into the base Nix system to declare a flake app based on it, the <a href="https://github.com/nickel-lang/organist/blob/main/lib/editorconfig.ncl">editorconfig</a> module declares an interface for managing the <code>.editorconfig</code> file, and hooks into the <code>files</code> interface for the actual generation of the file, etc.</p>
<p>Fortunately, it is actually trivial to implement an equivalent of the NixOS module system in Nickel by leveraging the merge system.
Not only that, but this will only be a very light abstraction over built-in features. This means that it will come with the joy of being understood by the LSP, giving nice auto-completion, quick and relevant error messages, and so on. Also, the lightness of the abstraction makes it very flexible, allowing to easily build variants of the system.</p>
<p>Before explaining how that works, let’s define a bit more precisely what we want with a module system.</p>
<h2 id="module-systems"><a href="#module-systems" aria-label="module systems permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Module systems</h2>
<p>A “module system”, in the NixOS sense, is a programming paradigm which allows exploding a complex configuration into individual components.
Each component (a “module”) can define both a piece of the schema for the overall configuration, and a piece of the configuration.
The schemas of all the modules are combined to form the final schema, and the same goes for configurations.
The only constraint is that the final configuration matches the final schema.</p>
<p>For instance, here is an instantiation of a (very) simplified version of the NixOS module system, written in Nix:</p>
<div data-language="nix"><pre><code>mergeModules <span>{</span>
   module1 <span>=</span> <span>{</span><span>.</span><span>.</span><span>.</span><span>}</span><span>:</span> <span>{</span>
     options<span>.</span>foo <span>=</span> mkOption <span>{</span> type <span>=</span> int<span>;</span> <span>}</span><span>;</span>
     options<span>.</span>bar <span>=</span> mkOption <span>{</span> type <span>=</span> string<span>;</span> <span>}</span><span>;</span>
     config<span>.</span>bar <span>=</span> <span>&#34;world&#34;</span><span>;</span>
   <span>}</span><span>;</span>
   module2 <span>=</span> <span>{</span>config<span>,</span> <span>.</span><span>.</span><span>.</span><span>}</span><span>:</span> <span>{</span>
      options<span>.</span>baz <span>=</span> mkOption <span>{</span> type <span>=</span> string<span>;</span> <span>}</span><span>;</span>
      config<span>.</span>foo <span>=</span> <span>3</span><span>;</span>
      config<span>.</span>baz <span>=</span> <span>&#34;Hello &#34;</span> <span>+</span> config<span>.</span>bar<span>;</span>
    <span>}</span><span>;</span>
 <span>}</span>


<span>=</span><span>&gt;</span> <span>{</span>
  foo <span>=</span> <span>3</span><span>;</span>              
  bar <span>=</span> <span>&#34;world&#34;</span><span>;</span>        
  baz <span>=</span> <span>&#34;Hello world&#34;</span><span>;</span>  
<span>}</span></code></pre></div>
<p>We can see that each module defines both a piece of the final schema (the <code>options</code> field) and a piece of the final config (the <code>config</code> field).
They have the ability to set and refer to options defined in another module.</p>
<p>Assigning a value of the wrong type to an option gives an error. For instance, changing <code>config.foo = 3</code> to <code>config.foo = &#34;3&#34;</code> yields:</p>
<div data-language="nix"><pre><code>error<span>:</span>
       … while evaluating the attribute &#39;value&#39;
         at <span>/nix/store/axfhzzkixwwdmxlrma7k8f65214acvml-source/lib/modules.nix:809:9:</span>
          <span>808</span>|     <span>in</span> warnDeprecation opt <span>//</span>
          <span>809</span>|       <span>{</span> value <span>=</span> <span>builtins</span><span>.</span>addErrorContext <span>&#34;while evaluating the option `<span><span>$</span><span>{</span>showOption loc<span>}</span></span>&#39;:&#34;</span> value<span>;</span>
             |         ^
          <span>810</span>|         <span>inherit</span> <span>(</span>res<span>.</span>defsFinal&#39;<span>)</span> highestPrio<span>;</span>

       … while evaluating the option `foo&#39;<span>:</span>

       … while evaluating the attribute &#39;mergedValue&#39;
         at <span>/nix/store/axfhzzkixwwdmxlrma7k8f65214acvml-source/lib/modules.nix:844:5:</span>
          <span>843</span>|     
          <span>844</span>|     mergedValue <span>=</span>
             |     ^
          <span>845</span>|       <span>if</span> isDefined <span>then</span>

       <span>(</span>stack <span>trace</span> truncated<span>;</span> use &#39;<span>-</span><span>-</span>show<span>-</span><span>trace</span>&#39; to show the full<span>,</span> detailed <span>trace</span><span>)</span>

       error<span>:</span> A definition for option `foo&#39; is not of type `signed integer&#39;<span>.</span> Definition values<span>:</span>
       <span>-</span> In `<span>&lt;</span>unknown<span>-</span>file<span>&gt;</span>&#39;<span>:</span> <span>&#34;foo&#34;</span></code></pre></div>
<h3 id="shortcomings-of-the-nixos-module-system"><a href="#shortcomings-of-the-nixos-module-system" aria-label="shortcomings of the nixos module system permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shortcomings of the NixOS module system</h3>
<p>This system is incredibly powerful, and rightfully serves not only the whole of NixOS, but also a number of other projects in the Nix world, such as <a href="https://github.com/nix-community/home-manager/">home-manager</a>, <a href="https://github.com/LnL7/nix-darwin/tree/master">nix-darwin</a>, <a href="https://flake.parts/">flake parts</a> and <a href="https://terranix.org/">terranix</a>.</p>
<p>However, it suffers from some limitations, mostly due to it being a pure library-side encoding instead of a Nix built-in.</p>
<ul>
<li>The error messages can get quite daunting (just look at the example above). Great effort has been put to improve the Nix error messages (and it shows), but the situation is still far from ideal.</li>
<li>Because it has nearly zero support from the language side, no LSP server is truly able to understand it, meaning that things like autocompletion or in-editor error messages are very much best-effort, if they exist at all.</li>
<li>Finally, it is often too dynamic for its own good. The fact that it only cares about global consistency makes it nearly impossible to reason about a module individually. The only way, for instance, to know whether a given module is correct is to evaluate the whole module system to know whether all the options it refers to are defined somewhere. Likewise, it is absolutely impossible to know the exact consequences of flipping an option somewhere as it might have an impact on any other module.</li>
</ul>
<h2 id="implementing-a-better-module-system-in-nickel"><a href="#implementing-a-better-module-system-in-nickel" aria-label="implementing a better module system in nickel permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing a (better) module system in Nickel</h2>
<p>Given the usefulness of this module system, and its weaknesses, it would be great if we could have the same thing in Nickel – and even better if we could fix the shortcomings on the way.</p>
<p>It turns out that we can, and in a whooping <em>one</em> line of code:</p>
<div data-language="nickel"><pre><code><span>{</span><span> </span><span>Module</span><span> </span><span>=</span><span> </span><span>{</span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span> </span><span>|</span><span> </span><span>not_exported</span><span> </span><span>=</span><span> </span><span>{</span><span>}</span><span>,</span><span> </span><span>c</span><span>o</span><span>n</span><span>f</span><span>i</span><span>g</span><span> </span><span>|</span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span> </span><span>}</span><span> </span><span>}</span></code></pre></div>
<p>This probably needs some explanation, so let’s look at how it works, and how it can be used.</p>
<p>Before anything else, let’s be honest: the simplicity of that line is rather deceptive since it hides the big heavy lifting done by the runtime, in particular the merge and contract systems.</p>
<p>This defines a contract called <code>Module</code> that represents values with:</p>
<ul>
<li>A <code>Schema</code> field, which is a <a href="https://nickel-lang.org/user-manual/contracts/#records">record contract</a>;</li>
<li>A <code>config</code> field, matching the contract defined by <code>Schema</code>.</li>
</ul>
<p>We can use it as such:</p>
<div data-language="nickel"><pre><code><span>let</span><span> </span><span>Module</span><span> </span><span>=</span><span> </span><span>{</span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span> </span><span>|</span><span> </span><span>not_exported</span><span> </span><span>=</span><span> </span><span>{</span><span>}</span><span>,</span><span> </span><span>c</span><span>o</span><span>n</span><span>f</span><span>i</span><span>g</span><span> </span><span>|</span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span> </span><span>}</span><span> </span><span>in</span>

<span>{</span>
<span> </span><span> </span><span>module1</span><span> </span><span>=</span><span> </span><span>{</span>
<span> </span><span> </span><span> </span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span>.</span><span>f</span><span>o</span><span>o</span><span> </span><span>|</span><span> </span><span>Number</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span>.</span><span>b</span><span>a</span><span>r</span><span> </span><span>|</span><span> </span><span>String</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>config.bar</span><span> </span><span>=</span><span> </span><span>&#34;world&#34;</span><span>,</span>
<span> </span><span> </span><span>}</span><span>,</span>
<span> </span><span> </span><span>module2</span><span> </span><span>=</span><span> </span><span>{</span>
<span> </span><span> </span><span> </span><span> </span><span>S</span><span>c</span><span>h</span><span>e</span><span>m</span><span>a</span><span>.</span><span>b</span><span>a</span><span>z</span><span> </span><span>|</span><span> </span><span>String</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>c</span><span>o</span><span>n</span><span>f</span><span>i</span><span>g</span><span>.</span><span>b</span><span>a</span><span>r</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>config.foo</span><span> </span><span>=</span><span> </span><span>3</span><span>,</span>
<span> </span><span> </span><span> </span><span> </span><span>config.baz</span><span> </span><span>=</span><span> </span><span>&#34;Hello &#34;</span><span> </span><span>+</span><span>+</span><span> </span><span>c</span><span>o</span><span>n</span><span>f</span><span>i</span><span>g</span><span>.</span><span>b</span><span>a</span><span>r</span><span>,</span>
<span> </span><span> </span><span>}</span><span>,</span>

<span> </span><span> </span><span>m</span><span>o</span><span>d</span><span>u</span><span>l</span><span>e</span><span>3</span><span> </span><span>|</span><span> </span><span>Module</span><span> </span><span>=</span><span> </span><span>m</span><span>o</span><span>d</span><span>u</span><span>l</span><span>e</span><span>1</span><span> </span><span>&amp;</span><span> </span><span>m</span><span>o</span><span>d</span><span>u</span><span>l</span><span>e</span><span>2</span><span>,</span>
<span>}</span><span>.</span><span>m</span><span>o</span><span>d</span><span>u</span><span>l</span><span>e</span><span>3</span><span>.</span><span>c</span><span>o</span><span>n</span><span>f</span><span>i</span><span>g</span>

<span></span>
<span>=</span><span>&gt;</span><span> </span><span>{</span>
<span> </span><span> </span><span>&#34;bar&#34;</span><span>:</span><span> </span><span>&#34;world&#34;</span><span>,</span>
<span> </span><span> </span><span>&#34;baz&#34;</span><span>:</span><span> </span><span>&#34;Hello world&#34;</span><span>,</span>
<span> </span><span> </span><span>&#34;foo&#34;</span><span>:</span><span> </span><span>3</span>
<span>}</span></code></pre></div>
<p>This is very similar to the Nix example above. What happens if we make a mistake on one of the fields, say replace <code>config.foo = 1</code> with <code>config.foo = &#34;x&#34;</code>?</p>
<div data-language="console"><pre><code>$ nickel export main.ncl
error: contract broken by the value of `foo`
   ┌─ /tmp/tmp.U0m6Ro8Vvo/main.ncl:13:18
   │
 5 │     Schema.foo | Number,
   │                  ------ expected type
   ·
13 │     config.foo = &#34;x&#34;,
   │                  ^^^ applied to this expression
   │
   ┌─ &lt;unknown&gt; (generated by evaluation):1:1
   │
 1 │ &#34;x&#34;
   │ --- evaluated to this value</code></pre></div>
<p>So the contract system is aware of what we want to check, and reports us an error accordingly.
Better, it points to the right place in the code.
Even better, the LSP server is aware of the error, and can point right at it:</p>
<p><span>
      <a href="https://www.tweag.io/static/bc9ed45c512cf5bd35df9646a0e4f0b0/8d68c/lsp-error-invalid-type.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="lsp error invalid type" title="lsp error invalid type" src="https://www.tweag.io/static/bc9ed45c512cf5bd35df9646a0e4f0b0/fcda8/lsp-error-invalid-type.png" srcset="/static/bc9ed45c512cf5bd35df9646a0e4f0b0/12f09/lsp-error-invalid-type.png 148w,
/static/bc9ed45c512cf5bd35df9646a0e4f0b0/e4a3f/lsp-error-invalid-type.png 295w,
/static/bc9ed45c512cf5bd35df9646a0e4f0b0/fcda8/lsp-error-invalid-type.png 590w,
/static/bc9ed45c512cf5bd35df9646a0e4f0b0/efc66/lsp-error-invalid-type.png 885w,
/static/bc9ed45c512cf5bd35df9646a0e4f0b0/c83ae/lsp-error-invalid-type.png 1180w,
/static/bc9ed45c512cf5bd35df9646a0e4f0b0/8d68c/lsp-error-invalid-type.png 1234w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h3 id="global-vs-local-consistency"><a href="#global-vs-local-consistency" aria-label="global vs local consistency permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Global vs local consistency</h3>
<p>This is definitely great, and solves the LSP integration issue, as well as part of the error messages one.
What it doesn’t do is alleviate the lack of local consistency: <code>module1</code> and <code>module2</code> are still implicitly depending on each other, and the only way to know that is to see that — for instance — <code>module2</code> sets <code>bar</code>, which is declared in <code>module1</code>.</p>
<p>We can, however, enforce something stricter:
In our example, we only require <code>module1 &amp; module2</code> to be a valid module.
But we could require each of them to be individually consistent by enforcing that their <code>config</code> field matches their <code>Schema</code> field:</p>
<div data-language="diff"><pre><code><span>--- a/main.ncl</span>
<span>+++ b/main.ncl</span>
@@ -4,11 +4,13 @@ let Module = { Schema | not_exported = {}, config | Schema } in
<span><span> </span>  module1 = {
<span> </span>    Schema.foo | Number,
<span> </span>    Schema.bar | String,
</span><span><span>+</span>    config | Schema,
</span><span><span> </span>    config.bar = &#34;world&#34;,
<span> </span>  },
<span> </span>  module2 = {
<span> </span>    Schema.baz | String,
</span>
<span><span>+</span>    config | Schema,
</span><span><span> </span>    config.bar,
<span> </span>    config.foo = 3,
<span> </span>    config.baz = &#34;Hello &#34; ++ config.bar,</span></code></pre></div>
<p>Doing so will yield an error:</p>
<div data-language="console"><pre><code>$ nickel export main.ncl
error: contract broken by the value of `config`
       extra fields `bar`, `foo`
   ┌─ /tmp/tmp.U0m6Ro8Vvo/main.ncl:13:14
   │
13 │     config | Schema,
   │              ------ expected type
   │
   ┌─ &lt;unknown&gt; (generated by evaluation):1:1
   │
 1 │ { bar, baz = %&lt;closure@0x55fa68e718c8&gt;, foo = 3, }
   │ -------------------------------------------------- evaluated to this value
   │
   = Have you misspelled a field?
   = The record contract might also be too strict. By default, record contracts exclude any field which is not listed.
     Append `, ..` at the end of the record contract, as in `{some_field | SomeContract, ..}`, to make it accept extra fields.</code></pre></div>
<p>Indeed, <code>module2</code> isn’t consistent. It is using <code>foo</code> and <code>bar</code>, but doesn’t know about them as they are declared in <code>module1</code>.
But we can fix that by making it explicitly depend on <code>module1</code>:</p>
<div data-language="diff"><pre><code><span>--- a/main.ncl</span>
<span>+++ b/main.ncl</span>
@@ -7,7 +7,7 @@ let Module = { Schema | not_exported = {}, config | Schema } in
<span><span> </span>    config | Schema,
<span> </span>    config.bar = &#34;world&#34;,
<span> </span>  },
</span><span><span>-</span>  module2 = {
</span><span><span>+</span>  module2 = module1 &amp; {
</span><span><span> </span>    Schema.baz | String,
</span>
<span><span> </span>    config | Schema,</span></code></pre></div>
<p>And now everything gets completely consistent, and we can confidently write a fully modular configuration, with the assurance that the language will have our back and give us early warnings in case anything goes wrong.</p>
<p>Besides, since the language really knows about everything that’s going on, the LSP can do its magic and help us with autocompletion.
Let’s add a new option to <code>module1</code>:</p>
<div data-language="diff"><pre><code><span>--- a/main.ncl</span>
<span>+++ b/main.ncl</span>
@@ -4,6 +4,12 @@ let Module = { Schema | not_exported = {}, config | Schema } in
<span><span> </span>  module1 = {
<span> </span>    Schema.foo | Number,
<span> </span>    Schema.bar | String,
</span><span><span>+</span>    Schema.my_option
<span>+</span>      | { _ : String }
<span>+</span>      | doc m%&#34;
<span>+</span>          The set of things that will wobble up when
<span>+</span>          stuff wiggles down and bubbles sideways
<span>+</span>        &#34;%,
</span><span><span> </span>    config | Schema,
<span> </span>    config.bar = &#34;world&#34;,
<span> </span>  },</span></code></pre></div>
<p>We can now refer to it from <code>module2</code>, and have our editor tell us everything we want to know:</p>
<p><span>
      <a href="https://www.tweag.io/static/3c7b630df1b9d1bd1c5fe48a55a2a550/d5f92/lsp-completion.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="lsp completion" title="lsp completion" src="https://www.tweag.io/static/3c7b630df1b9d1bd1c5fe48a55a2a550/fcda8/lsp-completion.png" srcset="/static/3c7b630df1b9d1bd1c5fe48a55a2a550/12f09/lsp-completion.png 148w,
/static/3c7b630df1b9d1bd1c5fe48a55a2a550/e4a3f/lsp-completion.png 295w,
/static/3c7b630df1b9d1bd1c5fe48a55a2a550/fcda8/lsp-completion.png 590w,
/static/3c7b630df1b9d1bd1c5fe48a55a2a550/efc66/lsp-completion.png 885w,
/static/3c7b630df1b9d1bd1c5fe48a55a2a550/c83ae/lsp-completion.png 1180w,
/static/3c7b630df1b9d1bd1c5fe48a55a2a550/d5f92/lsp-completion.png 2150w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<h2 id="conclusion"><a href="#conclusion" aria-label="conclusion permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>We’ve seen how we can easily implement an equivalent of the NixOS module system on top of Nickel.
We’ve also seen how this maps nicely to the semantics of the language and gives us access to all the benefits of good error messages and editor integration.</p>
<p>This is obviously just scratching the surface, and there’s a ton of extra features of NixOS modules that haven’t been covered here. Some would be trivial to implement, like <a href="https://nixos.org/manual/nixos/stable/#section-option-types-submodule">submodules</a> (left as an exercise to the reader). Others would require more work, or even <a href="https://github.com/tweag/nickel/blob/master/rfcs/001-overriding.md#custom-merge-functions">changes to the underlying language</a> like <a href="https://nixos.org/manual/nixos/stable/#sec-option-types-custom">custom types with custom merge functions</a>.
However, even this simple formalization is already tremendously powerful. It is used in <a href="https://github.com/nickel-lang/organist/pull/205">an experimental branch of Organist</a> to provide a principled way of combining different, independent, but related pieces of functionality.</p>
<p>A great possible follow-up work would be to hook that up with existing NixOS modules (maybe using a mixture of <a href="https://docs.clan.lol/blog/2024/05/25/jsonschema-converter/">jsonschema-converter</a> and <a href="https://github.com/nickel-lang/json-schema-to-nickel">json-schema-to-nickel</a>) to allow writing one’s NixOS configuration directly in Nickel… maybe soon?</p></div></div></div></div>
  </body>
</html>
