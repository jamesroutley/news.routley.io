<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kuzudb.com/blog/wcoj.html">Original</a>
    <h1>Graph DBMSs need new join algorithms: Story of worst-case optimal joins</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content" role="main"> <p> <a href="https://github.com/kuzudb/kuzu"><img src="https://kuzudb.com/kuzu-logo.png" width="300"/></a> </p> <p> <a href="https://github.com/kuzudb/kuzu">View it on GitHub</a> <a href="https://join.slack.com/t/kuzudb/shared_invite/zt-1n67h736q-E3AFGSI4w~ljlFMYr3_Sjg">Join our Slack workspace</a> </p> <p>by Semih Salihoğlu, Feb 22nd, 2023</p>  <p>Joins of a sets of records is objectively the most expensive operation in DBMSs. In my previous post on <a href="https://kuzudb.com/blog/factorization.html">factorization</a>, I said that in the field of databases, once in a while you run into a very simple idea that deviates from the norm that gets you very excited. Today, I will discuss another such idea, worst-case optimal join (wcoj) algorithms. Wcoj algorithms and the theory around it in one sentence says this:</p> <ul> <li>Queries involving complex “cyclic joins” over many-to-many relationships should be evaluated column at a time instead of table at a time, which is the norm. Wcoj algorithms find their best applications when finding cyclic patterns on graphs, such as cliques or cycles, which is common in the workloads of fraud detection and recommendation applications. As such, they should be integrated into every graph DBMS (and possibly to RDBMSs) and I am convinced that they eventually will.</li> </ul> <blockquote> <p><strong>Tldr: The key takeaways are:</strong></p> <ul> <li><strong>History of Wcoj Algorithms:</strong> Research on wcoj algorithms started with a solution to open question about the maximum sizes of join queries. This result made researchers realize this: the traditional “binary join plans” paradigm of generating query plans that join 2 tables a time until all of the tables in the query are joined is provably suboptimal for some queries. Specifically, when join queries are cyclic, which in graph terms means when the searched graph pattern has cycles in it, and the relationships between records are many-to-many, then this paradigm can generate unnecessarily large amounts of intermediate results.</li> <li><strong>Core Algorithmic Step of Wcoj Algorithms:</strong> Wcoj algorithms fix this sub-optimality by performing the joins one column at a time (instead of 2 tables at a time) using multiway intersections.</li> <li><strong>How Kùzu Integrates Wcoj Algorithms:</strong> Kùzu generates plans that seamlessly mix binary joins and wcoj-style multiway intersections. Multiway intersections are performed by an operator called “multiway HashJoin”, which has one or more build phases that creates one or more hash tables that stores sorted adjacency lists; and a probe phase that performs multi-way intersections using the sorted lists.</li> <li><strong>Yes, the Term “Worst-case Optimal” Is Confusing Even to Don Knuth:</strong> I know, Don Knuth also found the term “worst-case optimal” a bit confusing. See my <a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal">anecdote on this</a>. It basically means that the worst-case runtimes of these algorithms are asymptotically optimal.</li> </ul> </blockquote> <h2 id="joins-running-example--traditional-table-at-a-time-joins"> <a href="#joins-running-example--traditional-table-at-a-time-joins" aria-labelledby="joins-running-example--traditional-table-at-a-time-joins"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Joins, Running Example &amp; Traditional Table-at-a-time Joins </h2> <p>Joins are objectively the most expensive and powerful operation in DBMSs. In SQL, you indicate them in the FROM clause by listing a set of table names, in Cypher in the MATCH clause, where you draw a graph pattern to describe how to join node records with each other. As a running example, consider a simple social network of users and followers, whose node-link diagram is shown below. I am also showing the table that contains these records in a <code>User</code> (ignore the <code>name</code> property for now) and <code>Follows</code> tables.</p> <p> <img src="https://kuzudb.com/img/wcoj-running-ex-data.png" width="800"/> </p> <p>Consider finding triangles, which is one of the simplest forms of cycles and cliques, in this network. The SQL and Cypher versions of this query are shown below.</p> <div><div><pre><code>SQL:
SELECT *
FROM  Follows f1, Follows f2, Follows f3
WHERE f1.dst=f2.src AND f2.dst=f3.src AND
      f3.dst = f1.src

Cypher:
MATCH (a:User)-[f1:Follows]-&gt;(b:User)-[f2:Follows]-&gt;(c:User)-[f3:Follows]-&gt;(a)
RETURN  *
</code></pre></div></div> <p>That long MATCH clause “draws” a triangle and for our case here, this is equivalent to joining three copies of the Follows table.</p> <p>Now ever since the System R days and <a href="https://courses.cs.duke.edu/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf">Patricia Selinger’s 1979 seminal paper</a> that described how System R compiled and optimized SQL queries, there has been an unchallenged dogma in DBMSs that the joins specified in the query would be evaluated pairwise, table at a time. Here’s a blurb from Selinger’s paper, where one can see this assumption: “<em>In System R a user need not know how the tuples are physically stored … Nor does a user specify in what order joins are to be performed. The System R optimizer chooses both join order and …</em>” To this day, this is the norm. DBMSs pick a “join order” which is the order in which the tables should be joined iteratively 2 at a time. In the above example, for example there are three possible join orders. One way to represent these orders is by writing different parenthesization of the joins:</p> <ul> <li>(i) $((F1 \bowtie F2) \bowtie F3)$; (ii) $(F1 \bowtie (F2 \bowtie F3))$; and (iii) $((F1 \bowtie F3) \bowtie F2)$.</li> </ul> <p>The optimization problem for a system is of course more complex than just ordering tables because the system also has to choose which binary join algorithm to use when joining each pair of tables, e.g., hash joins vs merge joins. But take any system you want, and they will all follow the same paradigm of joining 2 base or intermediate tables iteratively, until all tables are joined: hence the term <em>binary joins</em> to describe the plans of existing systems.</p> <h2 id="a-math-puzzle-that-started-it-all"> <a href="#a-math-puzzle-that-started-it-all" aria-labelledby="a-math-puzzle-that-started-it-all"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> A Math Puzzle That Started it All </h2> <p>So, what’s the problem with binary join plans? When join queries are cyclic and the relationships are many-to-many, they can generate provably large amounts of (so unnecessary in a formal sense) intermediate results. First, cyclicity for join queries has formal (and a bit intimidating) definitions but if you think of graph patterns, it simply means that the searched pattern’s undirected version has cycles. Why do binary joins generate unnecessarily large intermediate results? I’ll get to this below but first a bit of history on the origins of this insight. The whole topic of “worst-case optimal joins” started with 2 papers, a <a href="https://arxiv.org/abs/1711.04506">2007 SODA</a> and a <a href="https://arxiv.org/abs/1711.03860">2008 FOCS</a> paper, which are top venues in algorithms and theory. In these papers, several theoreticians solved a fundamental open question about join queries. Suppose I give you:</p> <ol> <li>An arbitrary natural join query, say of $m$ relations. In DBMS literature we denote such queries as $Q=R1(a_{11}, …, a_{r1}) \bowtie … \bowtie Rm(a_{m1}, …, a_{rm})$.</li> <li>Sizes of R1, …, Rm, e.g., for simplicity assume they all have $IN$ many tuples.</li> </ol> <p>“Natural” here means that the join predicates are equality predicates on identical column names. You, as the second person in this puzzle, are allowed to set the values inside these relations. <strong>The open question was: how large can you make the final output?</strong> So for example, if I told you that there are $IN$ many tuples in the <code>Follows</code> tables, what is the maximum number of triangle outputs there can be?<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> Even more concretely for the triangle query, the question is: out of all possible graphs with $IN$ many edges, what is the maximum number of triangles they contain?</p> <p> <img src="https://kuzudb.com/img/wcoj-edge-covers.png" width="800"/> </p> <p>It still surprises me that the answer to this question was not known until 2008. It just looks like a fundamental question someone in databases must have answered before. Now excuse me for bombarding your brains with some necessary math definitions. These two papers showed that the answer is: $IN^{\rho^*}$, where $\rho^*$ is a property of $Q$ called the <em>fractional edge cover number</em> of $Q$. This is the solution to an optimization problem and best explained by thinking about the “join query graph”, which, for our purposes, is the triangle graph pattern (ignoring the edge directions), shown in Fig 2a and 2b.</p> <p>The optimization problem is this: put a weight between [0, 1] to each “query edge” such that each “query node” is “covered”, i.e., the sum of the query edges touching each query node is &gt; 1. Each such solution is called an edge cover. The problem is to find the edge cover whose total weight is the minimum. That is called the fractional edge cover number of the query. For the triangle query, one edge cover, shown in Fig 2a, is [1, 1, 0], which has a total weight of 1 + 1 + 0 = 2. The minimum weight edge cover is [1/2, 1/2, 1/2], shown in Fig 2b, with a total weight of 1.5. Therefore, the fractional edge cover number $\rho^*$ of the triangle query is 1.5. In general, each edge cover is an upper bound but the FOCS paper showed that the fractional edge cover number is the tight upper bound. So the maximum number of triangles there can be on a graph with $IN$ edges is $\Theta(IN^{1.5})$ and this is tight, i.e., there are such graphs. Nice scientific progress! Nowadays, the quantity $IN^{\rho^*}$ is known as the <code>AGM bound</code> of a query, after the first letters of the last names of the authors of the FOCS paper.</p> <h2 id="problem-with-table-at-a-timebinary-joins"> <a href="#problem-with-table-at-a-timebinary-joins" aria-labelledby="problem-with-table-at-a-timebinary-joins"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Problem With Table-at-a-time/Binary Joins </h2> <p>Now this immediately made the same researchers realize that binary join plans are provably sub-optimal because they can generate polynomially more intermediate results than the AGM bound of the query. This happens because on cyclic queries, the strategy of joining tables 2 at a time may lead to unnecesarily computing some acyclic sub-joins. For example, in the triangle query, the plan $((F1 \bowtie F2) \bowtie F3)$ first computes $(F1 \bowtie F2)$ sub-join, which in graph terms computes the 2-paths in the graph. This is a problem because often there can be many more of these acyclic sub-joins than there can be outputs for the cyclic join. For this plan, there can be $IN^2$ many 2-paths (which is the AGM bound of 2-paths), which is polynomially larger than $IN^{1.5}$. For example in our running example, there are 1000*1000 = 1M many 2 paths, but on a graph with 2001 edges there can be at most 89.5K triangles (well ours has only 3 triangles (because the triangle query we are using is symmetric the sole triangle would generate 3 outputs for 3 rotations of it)).</p> <p>Any other plan in this case would have generated $IN^2$ many 2-paths, so there is no good binary join plan here. I want to emphasize that this sub-optimality does not occur when the queries are acyclic or when the dataset does not have many-to-many relationships. If the joins were primary-foreign key non-growing joins, then binary join plans will work just fine.</p> <h2 id="solution-column-at-a-time-worst-case-optimal-join-algorithms"> <a href="#solution-column-at-a-time-worst-case-optimal-join-algorithms" aria-labelledby="solution-column-at-a-time-worst-case-optimal-join-algorithms"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Solution: Column-at-a-time “Worst-case Optimal” Join Algorithms </h2> <p>So the immediate next question is: are there algorithms whose runtimes can be bounded by $O(IN^{1.5})$? If so, how are they different? The answer to this question is a bit anti-climactic. The core idea existed in the 2007 SODA and 2008 FOCS papers, though it was refined more ~4 years later in some theoretical papers by <a href="https://hung-q-ngo.github.io/">Hung Ngo</a>, <a href="https://u.cs.biu.ac.il/~porat/">Ely Porat</a>, <a href="https://cs.stanford.edu/~chrismre/">Chris Ré</a>, and <a href="https://cse.buffalo.edu/faculty/atri/">Atri Rudra</a> in the database fields <a href="https://dl.acm.org/doi/10.1145/2213556.2213565">PODS</a> and <a href="https://dl.acm.org/doi/10.1145/2590989.2590991">SIGMOD Record</a>. The answer is simply to perform the join column at a time, using multiway intersections. “Intersections of what?” you should be asking. For joins over arbtrary relations, we need special indices but I want to skip this detail. In the context of GDBMSs, GDBMSs already have join indices (aka adjacency list indices) and for the common joins they perform, this will be enough for our purposes.</p> <p>I will next demonstrate a wcoj algorithm known as “Generic Join” from the <a href="https://dl.acm.org/doi/10.1145/2590989.2590991">SIGMOD Record paper</a>. It can be seen as the simplest of all wcoj algorithms. As “join order”, we will pick a “column order” instead of Selinger-style table order. So in our triangle query, the order could be a,b,c. Then we will build indices over each relation that is consistent with this order. In our case there are conceptually three (identical) relations: <code>Follows1(a, b)</code>, <code>Follows2(b, c)</code>, <code>Follows3(c, a)</code>. For <code>Follows1</code>, we need to be able to read all <code>b</code> values for a given <code>a</code> value (e.g., <code>a=5</code>). In graph terms, this just means that we need “forward join index”. For <code>Follows3</code>, because <code>a</code> comes earlier than <code>c</code>, we will want an index that gives us <code>c</code> values for a given <code>a</code> value. This is equivalent to a “backward join index”. In graphs, because joins happen through the relationship records, which can, for the purpose of the joins, be taught of as a binary relation (src, dst), 2 indices is enough for our purposes. On general relations, one may need many more indices.</p> <p> <img src="https://kuzudb.com/img/wcoj-gj-simulation.png" width="600"/> </p> <p>We will iteratively find: (i) all <code>a</code> values that can be in the final triangles; (ii) all <code>ab</code>’s that be in the final triangles; and (iii) all <code>abc</code>’s, which are the triangles. Let’s simulate the computation:</p> <ul> <li>Step 1: Find all <code>a</code>’s. Here we will just take all nodes as possible a values. This is shown under “Step 1” in the above figure.</li> <li>Step 2: For each a value, e.g., a=1, we extend it to find all <code>ab</code>’s that can be part of triangles: Here we use the forward index to look up all <code>b</code> values for node with ID 1. So on and so forth. This will generate the second intermediate relation.</li> <li>Step 3: For each <code>ab</code> value, e.g., the tuple (a=1 b=0), we will intersect all <code>c</code>’s with <code>a</code>=1, and all <code>c</code>’s with <code>b</code>=0. That is, we will intersect the backward adjacency list of the node with ID 1, and forward adjacency list of the node with ID 0. If the intersection is non-empty, we produce some triangles. In this case, we will produce the triangle (<code>a</code>=1, <code>b</code>=0, <code>c</code>=1001) The result of this computation will produce the third and final output table in the figure.</li> </ul> <p><img src="https://kuzudb.com/img/wcoj-4-clique.png"/> Note that this process did not produce the 2-paths as an intermediate step, which is how wcoj algorithms fix for the sub-optimality of binary join algorithms. If your query was more complex then a wcoj algorithm can do k-way intersections where k &gt; 2. For example on the 4-clique query shown on the right, suppose the column order is abcd, then given abc triangles, we would do a 3-way intersection of forward index of a’s, backward index of b’s, and forward index of c’s, to complete the triangles to joins. This type of multiway intersections is the necessary algorithmic step to be efficient on cyclic queries.</p> <h2 id="how-kùzu-performs-worst-case-optimal-join-algorithms"> <a href="#how-kùzu-performs-worst-case-optimal-join-algorithms" aria-labelledby="how-kùzu-performs-worst-case-optimal-join-algorithms"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How Kùzu Performs Worst-case Optimal Join Algorithms: </h2> <p>Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf">CIDR paper</a> describes this in detail, so I will be brief here. First, Kùzu mixes binary joins and wcoj-like multiway intersections following some principles that my PhD student <a href="http://amine.io/">Amine Mhedhbi</a> had worked quite hard on early in his PhD. I recommend these two papers, one by <a href="https://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf">Amine and me</a> and one by the <a href="https://db.in.tum.de/~freitag/papers/p1891-freitag.pdf">Umbra group</a> on several different ways people have proposed for mixing binary and wcoj algorithms in query plans. Overall message of these studies is that, wcoj are critical when the query has a very cyclic component and multiway intersections can help. If the query does not have this property, systems should just use binary joins. So wcoj-like computations should be seen as complementing binary join plans.</p> <p> <img src="https://kuzudb.com/img/wcoj-kuzu-multiway-hash-join.png" width="600"/> </p> <p>Second, Kùzu performs multiway intersections in a <em>Multiway HashJoin</em> operator. In our CIDR paper we call this operator Multiway ASPJoin. It can be thought of a modified hash-join operator where we use multiple hash tables and do an intersection to produce outputs as I will simulate. Let me change the query a little and add a filter on <code>a.name = Noura</code>, where <code>name</code> is the primary key of <code>User</code> records. You can see from Fig 1a that Noura is the primary key of node with ID 1. In my simulation, the Multiway HashJoin operator will take <code>ab</code> tuples and extend them to <code>abc</code> tuples through a 2-way intersection. In general multiway HashJoin has 3 phases: 1 accumulate phase, build phases to build k-2 hash tables, and a probe phase. Here are the steps.</p> <ul> <li>Step 1 - Accumulate Phase: The operator receives the <code>ab</code> tuples which will be extended to triangles. This allows the system to see exactly the forward/backward lists of which nodes will be intersected. Then, the operator passes this information sideways to only scan those lists. In this case, because there is a primary key filter on Noura, the only <code>ab</code> tuple that will be read is (a=1,b=0). This is stored in a temporary buffer that we call “Factorized Table” in the system.</li> <li>Step 2 - Build Phase 1: In the first build step, Multway HashJoin will pass a nodeID filter to the <code>Scan Follows (a)&lt;-(c)</code> operator with only 1=true for node ID 1, and 0 for every other node ID. The operator can do this because at this stage the operator knows exactly which backward adjacency lists will be needed when we extend the tuple (in this case only node with ID 1’s backward list is needed). The Scan operator uses this node ID filter to scan only this backward list, {1001}, and avoids scanning the rest of the file that stores the backwards Follows edges. This list is first sorted based on the IDs of the neighbor IDs and stored in a hash table, denoted as “Hash Table (a)&lt;-(c)” in the figure.</li> <li>Step 3 - Build Phase 2: This is similar to Build phase 1. Using a semijoin filter with node 0’s ID, we scan only node 2’s forward <code>Follows</code> list {1001, 1002, …, 2000}, sort it, and then store in a hash table “Hash Table (b)-&gt;(c)”.</li> <li>Step 4 - Probe: We re-scan the accumulated <code>ab</code> tuples from the factorized table. For each tuple, we first probe “Hash Table (a)&lt;-(c)” and then “Hash Table (b)-&gt;(c)” to fetch two lists, intersect them, and produce outputs. In this case there is only one tuple (a=1, b=0), so we will fetch a=1’s backward list and b=0’s forwrad list, intersect these lists, and produce the triangle (a=1, b=0, c=1001).</li> </ul> <p>This performs quite well. Our <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf">CIDR paper</a> has some performance numbers comparing against other types of WCO joins implementations (see the experiments in Table 3). Since I did not cover other ways to implement wco join algorithms inside DBMSs, these experiments would be difficult to explain here. Instead, let me just demonstrate some simple comparisons between using binary joins and wco joins in Kùzu on a simple triangle query. On larger cyclic queries, e.g., 4- or 5- cliques, the differences are much larger and often binary join plans do not finish on time. You can try this experiment too.</p> <p>Here is the configuration. The dataset I’m using is a popular web graph that is used in academic papers called <a href="https://snap.stanford.edu/data/web-BerkStan.html">web-BerkStan</a>. It has 685K nodes and 7.6M edges. I modeled these as a simple <code>Page</code> nodes and <code>Links</code> edges.</p> <p>I start Kùzu on my own laptop, which is a Macbook Air 2020 with Apple M1 chip, 16G memory, and 512GB SSD, and run the following two queries (by default, Kùzu uses all thread available, which is 8 in this case):</p> <div><div><pre><code>- Q1: Kùzu-WCO
MATCH (a:Page)-[e1:Links]-&gt;(b:Page)-[e2:Links]-&gt;(c:Page)-[e3:Links]-&gt;(a)
RETURN count(*)
</code></pre></div></div> <p>This will compile plan that uses a wco Multiway HashJoin operator. I will refer to this plan as Kùzu-WCO below. I am also running the following query:</p> <div><div><pre><code>- Q2: Kùzu-BJ
MATCH (a:Page)-[e1:Links]-&gt;(b:Page)
WITH *
MATCH (b:Page)-[e2:Links]-&gt;(c:Page)
WIH *
MATCH (c)-[e3:Links]-&gt;(a)
RETURN count(*)
</code></pre></div></div> <p>Currently Kùzu compiles each MATCH/WITH block separately so this is hack to force the system to use binary join plan. The plan will join <code>e1</code> <code>Links</code> with <code>e2</code> <code>Links</code> and then join the result of that with <code>e3</code> <code>Links</code>, all using binary HashJoin operator. I will refer to this as Kùzu-BJ. Here are the results:</p> <div><table> <thead> <tr> <th>Configuration</th> <th>Time</th> </tr> </thead> <tbody> <tr> <td>Kùzu-WCO</td> <td>1.62s</td> </tr> <tr> <td>Kùzu-BJ</td> <td>51.17s</td> </tr> </tbody> </table></div> <p>There are ~41M triangles in the output. We see <strong>31.6x</strong> performance improvement in this simple query. In larger densely cyclic queries, binary join plans just don’t work.</p> <p>To try this locally, you can download our prepared CSV files from <a href="https://github.com/kuzudb/kuzudb.github.io/tree/main/data/web-berkstan">here</a>, and compile from our <a href="https://github.com/kuzudb/kuzu">latest master</a><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup> (<code>make clean &amp;&amp; make release NUM_THREADS=8</code>). Then start Kùzu’s shell, and load data into Kùzu:</p> <div><div><pre><code>./build/release/tools/shell/kuzu_shell -i web.db
kuzu&gt; CREATE NODE TABLE Page (id INT64, PRIMARY KEY(INT64));
kuzu&gt; CREATE REL TABLE Links (FROM Page TO Page, MANY_MANY);
kuzu&gt; COPY Page FROM &#39;web-node.csv&#39;;
kuzu&gt; COPY Links FROM &#39;web-edge.csv&#39;;
</code></pre></div></div> <p>Now, run those two queries (Kùzu-WCO and Kùzu-BJ) to see the difference!</p> <h2 id="a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal"> <a href="#a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal" aria-labelledby="a-thank-you--an-anecdote-about-knuths-reaction-to-the-term-worst-case-optimal"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> A Thank You &amp; an Anecdote About Knuth’s Reaction to the Term “Worst-case Optimal” </h2> <p>Before wrapping up, I want to say thank you to <a href="https://cs.stanford.edu/~chrismre/">Chris Ré</a>, who is a co-inventor of earliest wcoj algorithms. In the 5th year of my PhD, Chris had introduced me to this area and we had written a paper together on the topic in the context of evaluating joins in distributed systems, such as MapReduce and Spark. I ended up working on these algorithms and trying to make them performant in actual systems for many more years than I initially predicted. I also want to say thank you to <a href="https://hung-q-ngo.github.io/">Hung Ngo</a> and <a href="https://cse.buffalo.edu/faculty/atri/">Atri Rudra</a>, with whom I have had several conversations during those years on these algorithms.</p> <p>Finally, let me end with a fun story about the term “worst-case optimal”: Several years ago <a href="https://uwaterloo.ca/computer-science/events/dls-donald-knuth-all-questions-answered">Don Knuth</a> was visiting UWaterloo to give a Distinguished Lecture Seminar, which is our department’s most prestigious lecture series. A colleague of mine and I had a 1-1 meeting with him. Knuth must be known to anyone with a CS degree but importantly he is credited for founding the field of algorithm analysis (e.g., for popularizing the big-oh notation for analyzing algorithms’ performances). In our meeting, he asked me what I was working on and I told him about these new algorithms called “worst-case optimal join algorithms”. The term was so confusing to him and his immediate interpretation was: “Are they so good that they are optimal even in their worst-case performances?”</p> <p>The term actually means that the worst-case runtime of these algorithms meets a known lower bound for the worst-case runtime of any join algorithm, which is $\Omega(IN^{\rho^*})$. Probably a more standard term would be to call them “asymptotically optimal”, just like people call sort merge an asymptotically optimal sorting algorithm under the comparison model.</p> <h2 id="final-words"> <a href="#final-words" aria-labelledby="final-words"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Final Words </h2> <p>What other fundamental algorithmic developments have been made in the field on join processing? It is surprising but there are still main gaps in the field’s understanding of how fast joins can be processed. There has been some very interesting work in an area called <em>beyond worst-case optimal join algorithms</em>. These papers ask very fundamental questions about joins, such as how can we prove that a join algorithm is correct, i.e., it produces the correct output given its input? The high-level answer is that each join algorithm must be producing a proof that its output is correct, through the comparison operations it makes. The goal of this line of research is to design practical algorithms whose implicit proofs are optimal, i.e., as small as possible. This is probably the most ambitious level of optimality one can go for in algorithm design. There are already some algorithms, e.g., an algorithm called <a href="https://dl.acm.org/doi/pdf/10.1145/2967101">Tetris</a>. The area is fascinating and has deep connections to computational geometry. I advised a <a href="https://arxiv.org/abs/1909.12102">Master’s thesis</a> on the topic once and learned quite a bit about computational geometry that I never thought could be relevant to my work. The current beyond worst-case optimal join algorithms however are currently not practical. Some brave souls need to get into the space and think hard about whether practical versions of these algorithms can be developed. That would be very exciting.</p> <p>This completes my 3-part blog on the contents of our CIDR paper and 2 core techniques: <a href="https://kuzudb.com/blog/factorization.html">factorization</a> and worst-case optimal join algorithms that we have integrated into Kùzu to optimize for many-to-many joins. My goal in these blog posts was to explain these ideas to a general CS/software engineering audience and I hope these posts have made this material more approachable. My other goal was to show the role of theory in advancing systems. Both of these ideas emerged from pen-and-paper theory papers that theoreticians wrote but gave clear advice to DBMS developers. As I said many times, I’m convinced that among many other techniques, these two techniques need to be integral to any GDBMS that wants to be competitive in performance, because queries with many-to-many joins are first-class-citizens in the workloads of these systems.</p> <p>We will keep writing more blog posts in the later months about our new releases, and other technical topics. If there are things you’d like us to write about, please reach out to us! Also please give Kùzu a try, prototype applications with it, break it, let us know of your performance or other bugs, so we can continue improving it. Give us a <a href="https://github.com/kuzudb/kuzu">GitHub star</a> too and take care until the next posts!</p>  </div></div>
  </body>
</html>
