<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/dispatches/near-miss/">Original</a>
    <h1>A Cryptographic Near Miss</h1>
    
    <div id="readability-page-1" class="page"><article>
        <span>
            <time datetime="2023-04-11">11 Apr 2023</time>
        </span>
        
        <section>
            <!--kg-card-begin: markdown--><p>Go 1.20.2 <a href="https://groups.google.com/g/golang-announce/c/3-TpUx48iQY?ref=words.filippo.io">fixed</a> a small vulnerability in the <code>crypto/elliptic</code> package. The impact was minor, to the point that I don‚Äôt think any application was impacted, but the issue was interesting to look at as a near-miss, and to learn from.</p>
<p>Fundamentally, a scalar multiplication function was returning the wrong value for a very specific input because of a combination of the pre-existing complexity and unsafety of some optimized assembly, of undocumented assumptions, and of the neverending state of flux of open source code.</p>
<p>Let‚Äôs start from some necessary building blocks, look at how the vulnerability happened, and talk about what we can learn from it.</p>
<h2 id="background">Background</h2>
<p>‚ÄúScalar multiplication‚Äù is a fancy way of saying multiplication by repeated additions. Elliptic curves only have a point addition operation, so to multiply a point by 5 we do P + P + P + P + P. Sort of.</p>
<p>Since the ‚Äúscalar‚Äù is very large (and because we want to do this in constant time), we use a trick where we execute a sequence of additions and doublings (which are just a special case of additions). <a href="https://www.youtube.com/watch?v=zPj5tTFDql0&amp;ref=words.filippo.io">I gave an explanation of this technique in my Black Hat 2018 talk</a>, where I presented a <em>different</em> attack against this same code.</p>
<p>The idea is that to multiply P by 44 (<code>0b101100</code>) we do the following operations</p>
<pre><code>Q = 0 + P = 0b1 * P
Q = Q * 2 = 0b10 * P
Q = Q * 2 = 0b100 * P
Q = Q + P = 0b101 * P
Q = Q * 2 = 0b1010 * P
Q = Q + P = 0b1011 * P
Q = Q * 2 = 0b10110 * P
Q = Q * 2 = 0b101100 * P üéâ
</code></pre>
<p>To make it constant time we actually always do the addition after every doubling, and then throw away the result if we weren‚Äôt supposed to do it, but anyway you get the gist.</p>
<p>To make it faster we actually don‚Äôt move one bit at a time, and instead multiply e.g. five times and then add between 1 * P and 31 * P, which we precomputed into a table before starting. To make it even faster, we use <a href="https://web.archive.org/web/20180716222422/http://bwrcs.eecs.berkeley.edu/Classes/icdesign/ee241_s00/PAPERS/archive/booth51.pdf">Booth encoding</a> from 1950 (!!!) so we actually add <em>or subtract</em> up to 16 * P, reducing the table size, but at this point I am just boring you with unnecessary details.</p>
<p>The important thing to note is that there is nothing in this algorithm that needs the scalar to have a specific size or lie in a specific range.</p>
<p>Scalars, when applied to a specific curve, do have a ‚Äúorder‚Äù though, in the same way that hours on a clock have order 12. If you pass the order values wrap around, so if the order is Q and you multiply by Q + 30 (<em>foreshadowing</em>), then it‚Äôs the same as multiplying by 30. Keep this in mind, too.</p>
<p>Finally, there‚Äôs something you need to know about that addition operation. <a href="https://eprint.iacr.org/2015/1060?ref=words.filippo.io">Until 2015</a>, we had to use separate formulas for adding two different points and for doubling a point. If you tried to use the addition formula on two equivalent points, stuff would break. That was a major selling point of Edwards curves like Curve25519 over the NIST curves, since we knew ‚Äúcomplete‚Äù addition formulas for the former. We now know complete formulas for the NIST curves as well, but certain ‚Äúsafe curves‚Äù comparisons as well as some implementations haven‚Äôt been updated in ten years.</p>
<h2 id="history">History</h2>
<p>With all that background out of the way, we can move on to history. Normally, history is part of the background, but this time the history is pretty much the root cause of the bug.</p>
<p>crypto/elliptic started out with <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20.2:src/crypto/elliptic/params.go;l=297-305?ref=words.filippo.io">a very generic, extremely not constant time implementation of a double-and-add chain</a>. Being variable time, it had no qualms doing <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20.2:src/crypto/elliptic/params.go;l=170-172?ref=words.filippo.io">a conditional check on point equality</a>, switching to the doubling formula. In that sense, it was ‚Äúcomplete‚Äù even if the formulas were not. It accepted scalars of any size, because why not I guess, scalars are just a string of bits.</p>
<p>That wasn‚Äôt very fast (or secure) though! So at some point large amounts of (constant-time) assembly were added, written specifically to speed up the P-256 curve. This assembly does windowed double-and-add, Booth encoding, the works. The scalar multiplication loop was optimized specifically for 256-bit scalars, since that‚Äôs the length of the order of P-256 scalars, and you can expect scalars in protocols like ECDH and ECDSA to be reduced modulo the order. If the input was higher (or shorter) than the order of the curve, it was reduced using the variable-time math/big, which was <em>fine</em> because it wouldn‚Äôt happen in actual high-level protocols, I guess. This assembly code also implemented raw incomplete formulas. That was fine because if the scalar doesn‚Äôt overflow the order of the curve, we can show that the left-hand side of the additions in the loop can never match a value from the addend table. Ok.</p>
<p>Finally, over the past few years I‚Äôve been engaging in a large refactor of the crypto/elliptic and crypto/rsa backends to remove its dependency on math/big. <a href="https://words.filippo.io/dispatches/go-1-20-cryptography/#cryptoecdh">We‚Äôve talked about it before.</a> For <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20.2:src/crypto/internal/nistec/p256.go;l=357-383?ref=words.filippo.io">the new scalar multiplication loops</a> I‚Äôve implemented a simple windowed scalar multiplication using complete formulas and formally-verified generated code. It‚Äôs pretty neat, I think. However, the P-256 assembly is still faster, so I pulled it into the new API, along with its special scalar multiplication loop.</p>
<p>Since that loop assumes the scalar is 256 bits, I introduced a requirement in the new API that the scalar size match the curve order size. I didn‚Äôt require the scalar to be actually reduced modulo the order because it felt like an unfair requirement: the consumer of this API doesn‚Äôt necessarily have a constant-time big integer library to do the reduction or even check the condition! Requiring that felt like a way to force the caller to re-introduce the variable-time code I was trying to excise, and anyway, there‚Äôs nothing that requires the scalar to be reduced, it just needs to be the right number of bits for the loop‚Ä¶ right?</p>
<h2 id="bug">Bug!</h2>
<p>The bug is sitting in the section above, in plain sight, but I don‚Äôt blame you if you didn‚Äôt spot it. I didn‚Äôt! <a href="https://github.com/golang/go/issues/58647?ref=words.filippo.io">Guido Vranken reported</a> that trying to multiply a point‚Äîany P-256 point, really‚Äîby Q + 30 returns the wrong result. As far as I can tell, it‚Äôs literally only that one value. I kinda wonder how he found it, I guess he tested low values vs. low values added to the order. <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20.2:src/crypto/internal/nistec/nistec_test.go;l=233-239?ref=words.filippo.io">That‚Äôs how we are testing for it now, at least.</a></p>
<p>So what happened? Well, while neither the old generic nor the new scalar multiplication loops have any requirement on the value of the scalar, the P-256 loop assumed the scalar is reduced modulo the order of the curve. Otherwise, the intermediate value can overflow during the computation and end up equal to the precomputed value it‚Äôs being added to, and the incomplete formulas can‚Äôt handle that. Before my refactor, this was not a problem because the scalar was reduced with math/big as a way to implement the old API. The addition function even returned a bit to let the caller know if the points were equal, but it was ignored in the scalar multiplication loop (<a href="https://cs.opensource.google/go/go/+/master:src/crypto/internal/nistec/p256_asm.go;l=391?ref=words.filippo.io">as opposed to the general Add function</a>) because presumably they knew they could rely on the scalar to be reduced. Unfortunately, when the new API removed the API-level requirement for a reduction, I didn‚Äôt know that it was also load-bearing for this other, undocumented assumption.</p>
<p>The good news is that as we said, there‚Äôs no reason to expect scalars involved in ECDH or ECDSA to be unreduced, since they are private keys or hash outputs, not arbitrary attacker-controlled values, so the security impact is minimal, and <a href="https://go.dev/cl/471255?ref=words.filippo.io">we fixed this</a> as a <a href="https://go.dev/security/policy?ref=words.filippo.io#tracks">PUBLIC</a>-level vulnerability. I opted to fix it by doing a conditional reduction for P-256 specifically, since the other curves are fine as-is. I also released a new version of the filippo.io/nistec module, which exports the new internal standard-library API. In the stdlib this bug is only reachable through the <a href="https://github.com/golang/go/issues/52221?ref=words.filippo.io">deprecated</a> crypto/elliptic API.</p>
<h2 id="lessons">Lessons?</h2>
<p>We could arguably call this a near-miss, but it‚Äôs important to learn from it nonetheless.</p>
<p>The first, maybe facile lesson is that safer APIs are a good idea. Other curves were unaffected because even if I didn‚Äôt consider this issue while implementing them, I used complete formulas that despite a small performance disadvantage have no hidden assumptions.</p>
<p>The second, more interesting lesson is that while assumptions might be valid <em>now</em>, they aren‚Äôt guaranteed to be valid in the future, after the code is refactored or reused over the years. It‚Äôs important to minimize assumptions and clearly document the remaining ones, as much as possible into the API or type system, and otherwise in high-level comments. Apropos of this, I like this quote from Russ Cox:</p>
<blockquote>
<p>Software engineering is what happens to programming when you add time and other programmers.</p>
</blockquote>
<p>In conclusion, at some point I am likely to sacrifice a little performance and cut up the assembly implementation into field arithmetic functions, to use with the complete formulas I use everywhere else. In the meantime <a href="https://go.dev/cl/471256?ref=words.filippo.io">I refactored the P-256 assembly driver</a> to document all the assumptions I could find. I actually found a broken assumption, but thankfully ‚Äúundefined behavior‚Äù actually meant ‚Äúreturns the infinity‚Äù and things happened to work out. Still, feels like <a href="https://avherald.com/h?article=5059befc&amp;opt=0&amp;ref=words.filippo.io">resolving a TCAS RA</a> and calling it a good day.</p>
<h2 id="the-picture">The picture</h2>
<p>This year&#39;s Real World Crypto was in Japan. It&#39;s April. That means cherry blossoms! üå∏</p>
<p><img src="https://words.filippo.io/content/images/2023/04/disp---1--1-.jpeg" alt="Blossoming cherry trees cover most of the picture from the sides of a shallow canal. The canal is lined and lit by traditional Japanese lamps, that reflect a pink glow on the water." loading="lazy"/></p>
<p>My awesome clients‚Äî<a href="https://www.sigsum.org/?ref=words.filippo.io">Sigsum</a>, <a href="https://protocol.ai/?ref=words.filippo.io">Protocol Labs</a>, <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a>, <a href="https://interchain.io/?ref=words.filippo.io">Interchain</a>, <a href="https://smallstep.com/?ref=words.filippo.io">Smallstep</a>, and <a href="https://tailscale.com/?ref=words.filippo.io">Tailscale</a>‚Äîare funding all this work and through our retainer contracts they get face time about its direction, as well as unlimited access to advice.</p>
<p>Here are a few words from some of them!</p>
<p>Protocol Labs ‚Äî Protocol Labs presented their new practical Timelock Encryption scheme at Real World Crypto in Tokyo this week! A recording of the talk can be found <a href="https://youtu.be/Xh849Ij3lhU?ref=words.filippo.io">here</a>. Additionally, we ran the Randomness Summit 2023 alongside Real World Crypto. You can find, amongst others, Filippo‚Äòs talk on &#34;Randomness from the Sky&#34; in <a href="https://youtube.com/playlist?list=PLhuBigpl7lqtE883Z3I6FCrtjmVOJ7A9c&amp;ref=words.filippo.io">this YouTube playlist</a>.</p>
<p>Latacora ‚Äî <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a> bootstraps security practices for startups. Instead of wasting your time trying to hire a security person who is good at everything from Android security to AWS IAM strategies to SOC2 and apparently has the time to answer all your security questionnaires plus never gets sick or takes a day off, you hire us. We provide a crack team of professionals prepped with processes and power tools, coupling individual security capabilities with strategic program management and tactical project management.</p>
<p>Smallstep ‚Äî The Smallstep platform builds on standards-based, open-source technologies to help organizations of all sizes prevent outages, automate compliance, and manage certificates at scale. The identification, sophisticated analysis, and quick remediation of a complex software issue in this dispatch‚Äîrequiring cross-disciplinary depth of knowledge in mathematics, cryptography, and computer science‚Äîis a testament to the power of the open source community and the enormous value that open source contributors bring to the world. We&#39;re committed to sustainable open source, and proud supporters of Filippo&#39;s work.</p>


<!--kg-card-end: markdown-->
        </section>
    </article></div>
  </body>
</html>
