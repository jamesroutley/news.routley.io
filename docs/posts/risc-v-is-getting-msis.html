<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.stephenmarz.com/2022/06/30/msi/">Original</a>
    <h1>RISC-V is getting MSIs</h1>
    
    <div id="readability-page-1" class="page"><div>
								
								<div>
									
<h2>Contents</h2>



<ol><li><a href="#overview">Overview</a></li><li><a href="#repo">Repository</a></li><li><a href="#msi">Message Signaled Interrupts (MSI)</a></li><li><a href="#imsic">Incoming MSI Controller (IMSIC)</a></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#next">What’s Next</a></li></ol>



<hr/>



<h2 id="overview">Overview</h2>



<p>Message signaled interrupts or MSIs describe a way to signal an interrupt without a dedicated interrupt request pin (IRQ). One of the most prevalent uses for MSIs is the PCI bus, and the PCI specification defines the MSI and MSI-X standards. The potential benefits may include: (1) reduced number of direct wires from the device to the CPU or interrupt controller, (2) improve signaling performance–mainly by forcing in-band signals by design, and (3) improving guest/host signaling for virtualized environments.</p>



<p>Wikipedia’s article on MSIs can be found here: <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">https://en.wikipedia.org/wiki/Message_Signaled_Interrupts</a></p>



<hr/>



<h2 id="repo">Repository</h2>



<p>All of the code for this post can be found here: <a href="https://github.com/sgmarz/riscv_msi">https://github.com/sgmarz/riscv_msi</a>. Use tag “msi”.</p>



<p>The code is written for RV32I in Rust. I originally wrote it for RV64GC, but everything else I wrote is also for RV64GC, so I figured I should branch out and broaden my horizons.</p>



<p>The AIA manual can be found here: <a href="https://github.com/riscv/riscv-aia">https://github.com/riscv/riscv-aia</a>.</p>



<hr/>



<h2 id="msi">Message Signaled Interrupts (MSI)</h2>



<p>An MSI is triggered by a “message”, which is a fancy term for a “memory write”. In fact, we can trigger a message by simply dereferencing an MMIO pointer.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">let message = 0xdeadbeef;
// QEMU&#39;s &#39;virt&#39; machine attaches the M-mode IMSIC for HART 0 to 0x2400_0000
write_volatile(0x2400_0000 as *mut u32, message);</pre>



<h3>Memory Mapped IO Addresses for Interrupt Files</h3>



<p>The code above writes to the MMIO address 0x2400_0000, which is where QEMU’s virt machine connects the M-mode IMSIC for HART 0. The S-mode IMSIC for HART 0 is connected to 0x2800_0000. Each HART is a page away from each other, meaning the M-mode IMSIC for HART 1 is at 0x2400_1000, and the S-mode IMSIC for HART 1 is 0x2800_1000. </p>



<p>For many embedded systems, these values would come from a specification or from an open firmware (OF) package that contained a flattened device tree (FDT) that specifies an MMIO address and what’s connected to it. Here’s an example of QEMU’s virt FDT as plain text. For the repo, I hard coded the MMIO addresses instead of reading a device tree.</p>



<pre><code>imsics@24000000 {
   phandle = &lt;0x09&gt;;
   riscv,ipi-id = &lt;0x01&gt;;
   riscv,num-ids = &lt;0xff&gt;;
   reg = &lt;0x00 0x24000000 0x00 0x4000&gt;;
   interrupts-extended = &lt;0x08 0x0b 0x06 0x0b 0x04 0x0b 0x02 0x0b&gt;;
   msi-controller;
   interrupt-controller;
   compatible = &#34;riscv,imsics&#34;;
};</code></pre>



<p>The organization that standardizes device tree formats can be found here: <a href="https://www.devicetree.org/">https://www.devicetree.org/</a></p>



<p>More information about device trees in Linux can be found here: <a href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html">https://www.kernel.org/doc/html/latest/devicetree/usage-model.html</a></p>



<p>IMSICs were added to QEMU’s virt machine fairly recently, so you may need to clone and build your own QEMU. QEMU’s repository can be found here: <a href="https://github.com/qemu">https://github.com/qemu</a>.</p>



<h3>Triggering an Interrupt by Sending a Message</h3>



<p>After a device writes a word to a specific MMIO address, the interrupt is triggered. This means that devices do not need a wire connecting it to an IRQ controller, such as RISC-V’s platform-level interrupt controller, or PLIC. Instead, as long as the device can make a memory write, it can trigger an interrupt.</p>



<p>Even though triggering a message is that simple, we need a mechanism to enable and prioritize these messages. There might be some circumstances where we don’t want to hear certain messages. This is where the incoming MSI controller or IMSIC comes into play.</p>



<hr/>



<h2 id="imsic">Incoming MSI Controller (IMSIC)</h2>



<p>To be able to support MSIs, some device needs to be able to take memory writes and turn them into interrupts. Furthermore, the device needs to provide a mechanism to enable/disable and to prioritize interrupts just like a regular interrupt controller. This is done by the incoming MSI controller (IMSIC) device.</p>



<p><strong>WARNING: </strong>The <a href="https://github.com/riscv/riscv-aia">Advanced Interrupt Architecture (AIA)</a> manual is still a work-in-progress, and already, there have been major changes that removed or added CSRs or other pertinent information. So, some of the code and tables might be outdated.</p>



<p>The register mechanism for the IMSIC consists of several control and status registers (CSRs) as well as internal registers accessibly through a selection mechanism.</p>



<h3>Newly Added Registers</h3>



<p>The AIA defines several new CSRs separated between the machine and supervisor modes.</p>



<figure><table><thead><tr><th>Register Name</th><th>Register Number</th><th>Description</th></tr></thead><tbody><tr><td>MISELECT</td><td>0x350</td><td>Machine register select</td></tr><tr><td>SISELECT</td><td>0x150</td><td>Supervisor register select</td></tr><tr><td>MIREG</td><td>0x351</td><td>A R/W view of the selected register in MISELECT</td></tr><tr><td>SIREG</td><td>0x151</td><td>A R/W view of the selected register in SISELECT</td></tr><tr><td>MTOPI</td><td>0xFB0</td><td>Machine top-level interrupt</td></tr><tr><td>STOPI</td><td>0xDB0</td><td>Supervisor top-level interrupt</td></tr><tr><td>MTOPEI</td><td>0x35C</td><td>Machine top-level external interrupt (requires IMSIC)</td></tr><tr><td>STOPEI</td><td>0x15C</td><td>Supervisor top-level external interrupt (requires IMSIC)</td></tr></tbody></table><figcaption>New CSRs defined for the AIA.</figcaption></figure>



<p>The registers MISELECT and MIREG allow us to select a register by writing its number into the MISELECT register. Then the MIREG will represent the selected register. For example, if we read from MIREG, we read from the selected register, and if we write to MIREG, we write to the selected register.</p>



<p>There are four selectable registers. There are machine and supervisor versions of these registers. For example, if we write to SISELECT, we will view the supervisor version of the register.</p>



<figure><table><thead><tr><th>Register Name</th><th>MISELECT/SISELECT</th><th>Description</th></tr></thead><tbody><tr><td>EIDELIVERY</td><td>0x70</td><td>External Interrupt Delivery Register</td></tr><tr><td>EITHRESHOLD</td><td>0x72</td><td>External Interrupt Threshold Register</td></tr><tr><td>EIP0 through EIP63</td><td>0x80 through 0xBF</td><td>External Interrupt Pending Registers</td></tr><tr><td>EIE0 through EIE63</td><td>0xC0 through 0xFF</td><td>External Interrupt Enable Registers</td></tr></tbody></table><figcaption>Registers selectable by MISELECT/SISELECT and readable/writeable via MIREG/SIREG.</figcaption></figure>



<p>The first thing we need to do is enable the IMSIC itself. This is done through a register called EIDELIVERY for “enable interrupt delivery” register. This register may contain one of three values:</p>



<figure><table><thead><tr><th>Value</th><th data-align="left">Description</th></tr></thead><tbody><tr><td>0</td><td data-align="left">Interrupt delivery is disabled</td></tr><tr><td>1</td><td data-align="left">Interrupt delivery is enabled</td></tr><tr><td>0x4000_0000</td><td data-align="left">Optional interrupt delivery via a PLIC or APLIC</td></tr></tbody></table><figcaption>Value written to EIDELIVERY register</figcaption></figure>



<h3>Enabling the IMSIC</h3>



<p>So, we need to write 1 (Interrupt delivery is enabled) into the EIDELIVERY register:</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// First, enable the interrupt file
// 0 = disabled
// 1 = enabled
// 0x4000_0000 = use PLIC instead
imsic_write(MISELECT, EIDELIVERY);
imsic_write(MIREG, 1);</pre>



<p>The EITHRESHOLD register creates a threshold that interrupt priorities must be before it can be heard. If an interrupt has a priority less than the value in EITHRESHOLD, it will be “heard” or unmasked. Otherwise, it will be masked and will not be heard. For example, an EITHRESHOLD of 5 would only permit messages 1, 2, 3, and 4 to be heard. The message 0 is reserved to mean “no message”. </p>



<p>Since a higher threshold opens more messages, messages with a <em>lower</em> number have a <em>higher</em> priority.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Set the interrupt threshold.
// 0 = enable all interrupts
// P = enable &lt; P only
imsic_write(MISELECT, EITHRESHOLD);
// Only hear 1, 2, 3, and 4
imsic_write(MIREG, 5);</pre>



<h3>Interrupt Priorities</h3>



<p>The AIA documentation uses the message itself as the priority. So, a message of 1 has a priority of 1, whereas a message of 1234 has a priority of 1234. This is more convenient since we can control messages directly. However, since each message number has associated enable and pending bits, there is a limit to the highest numbered interrupt. The specification has a maximum of \(32\times64 – 1 = 2,047\) total messages (we subtract one to remove 0 as a valid message).</p>



<h3>Enabling Messages</h3>



<p>The EIE register controls whether a message is enabled or disabled. For RV64, these registers are 64-bits wide, but still take up two adjacent register numbers. So, for RV64, only even numbered registers are selectable (e.g., EIE0, EIE2, EIE4, …, EIE62). If you try to select an odd numbered EIE, you will get an invalid instruction trap. This took me many hours to figure out even though the documentation states this is the desired behavior. For RV32, the EIE registers are only 32-bits, and EIE0 through EIE63 are all selectable.</p>



<p>The EIE register is a bitset. If the bit for a corresponding message is 1, then it is unmasked and enabled, otherwise it is masked and is disabled. For RV64, messages 0 through 63 are all in EIE0[63:0]. The bit is the message. We can use the following formulas to determine which register to select for RV64:</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Enable a message number for machine mode (RV64)
fn imsic_m_enable(which: usize) {
    let eiebyte = EIE0 + 2 * which / 64;
    let bit = which % 64;

    imsic_write(MISELECT, eiebyte);
    let reg = imsic_read(MIREG);
    imsic_write(MIREG, reg | 1 &lt;&lt; bit);
}</pre>



<p>RV32 behaves much the same, except we don’t have to scale it by 2.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Enable a message number for machine mode (RV32)
fn imsic_m_enable(which: usize) {
    let eiebyte = EIE0 + which / 32;
    let bit = which % 32;

    imsic_write(MISELECT, eiebyte);
    let reg = imsic_read(MIREG);
    imsic_write(MIREG, reg | 1 &lt;&lt; bit);
}</pre>



<p>With the code above, we can now enable the messages we want to hear. The following example enables messages 2, 4, and 10.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">imsic_m_enable(2);
imsic_m_enable(4);
imsic_m_enable(10);</pre>



<h3>Pending Messages</h3>



<p>The EIP registers behave in the exact same way as the EIE registers except that a bit of 1 means that that particular message is pending, meaning a write to the IMSIC with that message number was sent. The EIP register is read/write. If we read from it, we can determine which messages are pending. If we write to it, we can manually trigger an interrupt message by writing a 1 to the corresponding message bit.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Trigger a message by writing to EIP for Machine mode in RV64
fn imsic_m_trigger(which: usize) {
    let eipbyte = EIP0 + 2 * which / 64;
    let bit = which % 64;

    imsic_write(MISELECT, eipbyte);
    let reg = imsic_read(MIREG);
    imsic_write(MIREG, reg | 1 &lt;&lt; bit);
}</pre>



<h3>Testing</h3>



<p>Now that we can enable the delivery as well as indiviual messages, we can trigger them one of two ways: (1) write the message directly to the MMIO address or (2) set the interrupt pending bit of the corresponding message to 1.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">unsafe {
    // We are required to write only 32 bits.
    // Write the message directly to MMIO to trigger
    write_volatile(0x2400_0000 as *mut u32, 2);
}
// Set the EIP bit to trigger
imsic_m_trigger(2);</pre>



<h3>Message Traps</h3>



<p>Whenever an unmasked message is sent to an enabled IMSIC, it will come to the specified HART as an external interrupt. For the machine-mode IMSIC, this will come as asynchronous cause 11, and for the supervisor-mode IMSIC, this will come as asynchronous cause 9.</p>



<p>When we receive an interrupt due to a message being delivered, we will need to “pop” off the top level pending interrupt by reading from the MTOPEI or STOPEI registers depending on the privilege mode. This will give us a value where bits 26:16 contain the message number and bits 10:0 contain the interrupt priority. Yes, the message number and message priority are the same number, so we can choose either.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Pop the top pending message
fn imsic_m_pop() -&gt; u32 {
    let ret: u32;
    unsafe {
        // 0x35C is the MTOPEI CSR.
        asm!(&#34;csrrw {retval}, 0x35C, zero&#34;, retval = out(reg) ret),
    }
    // Message number starts at bit 16
    ret &gt;&gt; 16
}</pre>



<p>My compiler does not support the names of the CSRs in this specification, so I used the CSR number instead. That is why you see 0x35C instead of mtopei, but they mean the same thing.</p>



<p>When we read from the MTOPEI register (0x35C), it will give us the message number of the highest priority message. The instruction csrrw in the code snippet above will atomically read the value of the CSR into the return register and then store the value zero into the CSR.</p>



<p>When we write zero into the MTOPEI register (0x35C), we are telling the IMSIC that we are “claiming” that we are handling the topmost message, which clears the EIP bit for the corresponding message number.</p>



<pre data-enlighter-language="rust" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">/// Handle an IMSIC trap. Called from `trap::rust_trap`
pub fn imsic_m_handle() {
    let msgnum = imsic_m_pop();
    match msgnum {
        0 =&gt; println!(&#34;Spurious message (MTOPEI returned 0)&#34;),
        2 =&gt; println!(&#34;First test triggered by MMIO write successful!&#34;),
        4 =&gt; println!(&#34;Second test triggered by EIP successful!&#34;),
        _ =&gt; println!(&#34;Unknown msi #{}&#34;, v),
    }
}</pre>



<p>Message 0 is not a valid message since when we pop from the MTOPEI, a 0 signals “no interrupt”.</p>



<h2>Example Output</h2>



<p>If you run the repo with a new QEMU, you should see the following after a successful test.</p>


<div>
<figure><img width="1024" height="160" src="https://blog.stephenmarz.com/wp-content/uploads/2022/06/image-1024x160.png" alt="" srcset="https://blog.stephenmarz.com/wp-content/uploads/2022/06/image-1024x160.png 1024w, https://blog.stephenmarz.com/wp-content/uploads/2022/06/image-300x47.png 300w, https://blog.stephenmarz.com/wp-content/uploads/2022/06/image-768x120.png 768w, https://blog.stephenmarz.com/wp-content/uploads/2022/06/image-1536x241.png 1536w, https://blog.stephenmarz.com/wp-content/uploads/2022/06/image-2048x321.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure></div>


<hr/>



<h2 id="conclusion">Conclusion</h2>



<p>In this post, we saw the new registers added to support the incoming MSI controller (IMSIC) for RISC-V. We also enabled the IMSIC delivery, the individual messages, and handled two ways of sending a message: via MMIO directly or by setting the corresponding EIP bit. Finally, we handled the interrupt from the trap.</p>



<hr/>



<h2 id="next">What’s Next?</h2>



<p>The second part of the AIA manual includes the new Advanced Platform-Level Interrupt Controller or APLIC. We will examine this system as well as write drivers to start looking at how this new APLIC can signal using wires or messages.</p>



<p>After the APLIC, we will write a driver for a PCI device and use it to send MSI-X messages.</p>
								</div>
							</div></div>
  </body>
</html>
