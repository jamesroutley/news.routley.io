<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/the-slotted-counter-pattern">Original</a>
    <h1>The Slotted Counter Pattern</h1>
    
    <div id="readability-page-1" class="page"><div><p>It is a common database pattern to increment an <code>INT</code> column when an event happens, such as a download or page view.</p>
<p>You can go far with this pattern until bursts of these types of events happen in parallel and you experience contention on a single row. When multiple transactions are trying to update the counter, you are essentially forcing these transactions to run serially, which is bad for concurrency and can cause deadlocks. You can also see dramatic increases in query time when a bursts like this occur.</p>
<p>You can check if you are experiencing contention by running the following:</p>

<p>In the output, you&#39;ll see some information about granting a lock:</p>

<p>You can see that this transaction has been waiting a significant amount of time to acquire a lock to increment the counter on this single row. It is clashing with other competing transactions.</p>
<p>MySQL is the main database for <code>GitHub.com</code>, and back in the day, when a number of PlanetScale folks worked there, we had to do this kind of counting differently. We decided on using a separate table with a schema similar to this:</p>

<ul>
<li><code>record_type</code> — The type of counter (allows us to keep the table generic)</li>
<li><code>record_id</code> — Identifies whatever we are counting, it could map to a repository id for example</li>
<li><code>slot</code> — The slot we are going to increment</li>
<li><code>count</code> —  The count for each slot</li>
</ul>
<p>A typical increment query would look like:</p>

<p>The idea here is that instead of incrementing a single row for a counter, we are now picking a slot and incrementing the count in that slot. This means instead of hammering a single row, we are spreading the updates across 100 rows and reducing the potential for contention.</p>
<p>Once we have run the above <code>INSERT</code> a few times, we can see the counter rows:</p>

<p>Getting the count for <code>record_id</code> 456 is as simple as this <code>SELECT</code> query:</p>

<p>Now we can have requests executing counter increments in parallel without causing contention and effecting concurrency.</p>
<p>There are a few different ways you can implement this pattern, but it comes down to the architecture of your app. One way would be to query the <code>slotted_counters</code> table to roll up the data and update a column stored with the rest of the data.</p></div></div>
  </body>
</html>
