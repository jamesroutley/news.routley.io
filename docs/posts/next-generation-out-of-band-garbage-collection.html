<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://railsatscale.com/2024-10-23-next-generation-oob-gc/">Original</a>
    <h1>Next Generation Out of Band Garbage Collection</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>In 2023, <a href="https://shopify.engineering/adventures-in-garbage-collection">I wrote about how we’ve tuned Ruby’s garbage collector for Shopify’s monolith</a>,
including how we implemented out-of-band garbage collection to reduce the impact of major collection on latency.</p>

<p>While the latency improvements were massive, we weren’t entirely satisfied with the heuristics used to trigger out-of-band
garbage collection. It was purely based on averages, so we had to trade latency for capacity.
More importantly, it didn’t fully eliminate major collection from request cycles, it only made it very rare.</p>

<p>But <a href="https://github.com/rails/rails/issues/50449#issuecomment-1870515141">in December 2023, while discussing with Koichi Sasada, we came up with a new idea</a>.</p>

<h2 id="disabling-major-gc-entirely">Disabling Major GC Entirely</h2>

<p>If we want major GC to never trigger during a request cycle, why not disable it entirely?</p>

<p>In March 2024, during our annual Ruby Infrastructure team gathering, we fleshed out the details of the new feature we wanted,
and Matthew Valentine-House started working on a proof of concept, which we then deployed to a small percentage of our production servers to see how effective it could be.</p>

<p>First, we needed a way to entirely prevent the Garbage Collector from automatically performing a major collection, but
also to stop promoting objects to the old generation. Ideally in a web application, aside from some in-memory caches, no object allocated as part of a request should survive longer than the request itself.
Any object that does is probably something that should be eagerly loaded during boot, or some state that is leaking between requests.
As such, any object promoted to the old generation during a request cycle is very unlikely to be immortal, so promoting it is wasteful.</p>

<p>We also needed a way to ask the GC whether it would have run a major collection so that we could manually trigger it outside
of the request cycle, and only exactly as much as needed.</p>

<p><a href="https://bugs.ruby-lang.org/issues/20443">The initial proposal was for three new methods, <code>GC.disable_major</code>, <code>GC.enable_major</code> and <code>GC.needs_major?</code></a>.</p>

<p>After some back and forth with other Ruby committers, it became a single new method: <code>GC.config(rgengc_allow_full_mark: true/false)</code>.
We also exposed a new key in <code>GC.latest_gc_info</code>, <code>:needs_major_by</code>, for use in checking whether a major GC needs to run: <code>GC.latest_gc_info(:needs_major_by)</code>.</p>

<p>This new feature was released as part of Ruby <code>3.4.0-preview2</code>.</p>

<h2 id="effectiveness">Effectiveness</h2>

<p>Since Shopify monolith runs on Ruby’s master branch, we don’t have to wait for the December release to use these new features,
so recently I went to work on enabling the new out-of-band GC implementation on 50% of production servers, and the results are amazing on all metrics.</p>

<p>First, as we anticipated, the time spent in GC during request cycles at the very tail end (p95/p99/p99.99) dropped very significantly.</p>

<p>However, more surprisingly, it also improved median latency:</p>

<p><img src="https://railsatscale.com/2024-10-23-next-generation-oob-gc/images/oobgc-gctime-speedup.png" alt=""/></p>

<p><img src="https://railsatscale.com/2024-10-23-next-generation-oob-gc/images/oobgc-gctime.png" alt=""/></p>

<p>The overall impact on service latency is of course more modest, but still very nice with a 5% reduction of average latency and a 10% reduction of p99 latency:</p>

<p><img src="https://railsatscale.com/2024-10-23-next-generation-oob-gc/images/oobgc-latency-impact.png" alt=""/></p>

<p>The impact on capacity, however, is less significant than we had hoped for. During the day, when there are frequent deploys, this doesn’t make much of a difference.
However when deploys pause for a few hours, the new out-of-band collector runs much less often than the old implementation:</p>

<p><img src="https://railsatscale.com/2024-10-23-next-generation-oob-gc/images/oobgc-count.png" alt=""/></p>

<h2 id="implementation">Implementation</h2>

<p>In addition, to be more effective, this new implementation is also radically simple, thanks to the hooks provided by <a href="https://github.com/Shopify/pitchfork">Pitchfork</a></p>

<div><div><pre><code><span># pitchfork.conf.rb</span>

<span>after_worker_fork</span> <span>do</span> <span>|</span><span>_server</span><span>,</span> <span>_worker</span><span>|</span>
  <span>GC</span><span>.</span><span>config</span><span>(</span><span>rgengc_allow_full_mark: </span><span>false</span><span>)</span>
<span>end</span>

<span>after_request_complete</span> <span>do</span> <span>|</span><span>_server</span><span>,</span> <span>_worker</span><span>,</span> <span>_rack_env</span><span>|</span>
  <span>if</span> <span>GC</span><span>.</span><span>latest_gc_info</span><span>(</span><span>:need_major_by</span><span>)</span>
    <span>GC</span><span>.</span><span>start</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<h2 id="next-steps">Next Steps?</h2>

<p>Now that the major collection is out of the picture, the next step is to look at the minor collections.</p>

<p>We can’t disable minor collection, as otherwise large requests that allocate a lot would run out of memory. However, we could try to
additionally use heuristics from <code>GC.stat</code> to eagerly trigger minor garbage collection out-of-band, so that the majority of requests don’t have
to spend any time at all in GC.</p>

<p>But the potential gains are much smaller because minor collection is quite fast even on our monolith.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
