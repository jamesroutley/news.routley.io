<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.julik.nl/2025/03/a-tiny-undo-stack">Original</a>
    <h1>Writing a tiny undo/redo stack in JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div>

	<article>

    
		

<small>
  
    
   · <time datetime="2025-03-22T00:00:00+00:00">22 Mar 2025</time>
</small>

    <p>I’ve needed this before - a couple of times. Third time I figured I needed something small, nimble - yet complete. And - at the same time - wondering about how to do it in a very simple manner. I think it worked out great, so let’s dig in.</p>

<!-- more -->

<h2 id="undo-histories-and-managers">Undo histories and managers</h2>

<p>Most UIs will have some form of undo functionality. Now, there are generally two forms of it: <em>undo stacks</em> and <em>version histories</em>. A “version history” is what Photoshop history gives you - the ability to “paint through” to a previous state of the system. You can add five paint strokes, and then reveal a stroke you have made 4 steps back.</p>

<p>But most apps won’t need that. What you will need is an <em>undo stack,</em> which can be specced out as follows:</p>

<ul>
  <li>An undoable action gets performed and gets pushed onto the stack.</li>
  <li>If undo is requested, the stack is popped and the rollback action gets applied for the popped action.</li>
  <li>If an action was undone, you can redo that action. If you have undone 2 actions, you can redo 2 actions.</li>
  <li>If you push an undoable action onto the stack in presence of actions that can be redone, they get discarded - there is no branching, remember?</li>
</ul>

<p>If you are curious how “the big guys” used to do it - check out the <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UndoArchitecture/Articles/RegisteringUndo.html#//apple_ref/doc/uid/20000206-SW2">NSUndoManager documentation</a></p>

<p>So, as I usually like to do, I want to understand the API that would be optimal. For this use case - drawing - I had the following workflow:</p>

<ul>
  <li>When you draw a stroke the input points get added to <code>currentStroke</code></li>
  <li>When you release the pen the <code>currentStroke</code> gets appended to <code>strokes</code> and reset for the next stroke.</li>
</ul>

<p>I wanted something like this:</p>

<div><div><pre><code><span>let</span> <span>addStroke</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>strokes</span><span>.</span><span>push</span><span>(</span><span>currentPaintStroke</span><span>);</span>
<span>let</span> <span>removeStroke</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>strokes</span><span>.</span><span>pop</span><span>();</span>
<span>undoThing</span><span>.</span><span>push</span><span>(</span><span>addStroke</span><span>,</span> <span>removeStroke</span><span>);</span>

<span>// then, on user action</span>
<span>undoThing</span><span>.</span><span>undo</span><span>();</span> <span>// calls removeStroke()</span>
<span>undoThing</span><span>.</span><span>redo</span><span>();</span> <span>// calls strokes.push(...) again</span>
</code></pre></div></div>

<h2 id="the-perils-of-stack-pointers">The perils of stack pointers</h2>

<p>Simplest thing in the world. Now, if you look at most recommended (and some existing!) implementations of an undo stack, you will find they usually make use of a stack with a pointer. Like <a href="https://www.npmjs.com/package/undo-manager?activeTab=code">here</a> and <a href="https://medium.com/fbbd/intro-to-writing-undo-redo-systems-in-javascript-af17148a852b">here</a> - you would have a stack, usually represented as a JS array, and some kind of <code>pointer</code> or an <code>index</code> that you would use to index into it.</p>

<p>And while it is workable <em>and</em> standard, it just didn’t jive with me well. See, using an index into an array usually makes JS code susceptible to two things, which bite me every single time:</p>

<ul>
  <li>Indexing into a nonexistent index - hello <code>undefined</code> checks</li>
  <li>Mistakes in offsets when calling <code>Array.slice</code> and <code>Array.splice</code>. Oh, and confusing <code>slice</code> and <code>splice</code>, of course.</li>
</ul>

<p>The fact that Ruby and JS have different semantics for <code>slice</code> - one uses the index bounds, the other uses two offsets - doesn’t help things. And what happens if an API uses offsets into a vector? Exactly: confusion whether those offsets are inclusive or exclusive. Oh, and the offsets change after you mutate the array, which makes it even more painful.</p>

<h2 id="could-we-not-index">Could we not index?</h2>

<p>So what came to mind was this: we effectively have two stacks, not one. We have an <code>undoStack</code> (things that can be rolled back) and a <code>redoStack</code> - things that can be rolled forward. All the things we do with our undo-redo actions actually do not change the <em>pointer</em> - they <em>move</em> things from one stack to another. And rules change between these two stacks! We erase the redoable actions when we add a new undoable action, remember? So while an undoable stack will rarely get “nullified”, the redoable stack likely will be nullified frequently.</p>

<p>Once this became clear, the implementation practically wrote itself:</p>

<div><div><pre><code><span>function</span> <span>createUndoStack</span><span>()</span> <span>{</span>
  <span>let</span> <span>past</span> <span>=</span> <span>[];</span>
  <span>let</span> <span>future</span> <span>=</span> <span>[];</span>

  <span>return</span> <span>{</span>
    <span>push</span><span>(</span><span>doFn</span><span>,</span> <span>undoFn</span><span>)</span> <span>{</span>
      <span>doFn</span><span>();</span>
      <span>past</span><span>.</span><span>push</span><span>({</span><span>doFn</span><span>,</span> <span>undoFn</span><span>});</span>
      <span>// Adding a new action wipes the redoable steps</span>
      <span>future</span><span>.</span><span>length</span> <span>=</span> <span>0</span><span>;</span>
    <span>},</span>
    <span>undo</span><span>()</span> <span>{</span>
     <span>let</span> <span>action</span> <span>=</span> <span>past</span><span>.</span><span>pop</span><span>();</span>
     <span>if </span><span>(</span><span>action</span><span>)</span> <span>{</span>
       <span>action</span><span>.</span><span>undoFn</span><span>();</span>
       <span>future</span><span>.</span><span>unshift</span><span>(</span><span>action</span><span>);</span>
     <span>}</span>
    <span>},</span>
    <span>redo</span><span>()</span> <span>{</span>
      <span>let</span> <span>action</span> <span>=</span> <span>future</span><span>.</span><span>unshift</span><span>();</span>
      <span>if </span><span>(</span><span>action</span><span>)</span> <span>{</span>
        <span>action</span><span>.</span><span>doFn</span><span>();</span>
        <span>past</span><span>.</span><span>push</span><span>(</span><span>action</span><span>);</span>
      <span>}</span>
    <span>}</span>
  <span>};</span>
<span>}</span>
</code></pre></div></div>

<p>So instead of trying to save resources by having just one array (and miserably failing with off-by-one index errors), we can embrace dynamically sized arrays and just forget indices altogether. Neat!</p>

<p>Let’s add a couple more methods to display our UI:</p>

<div><div><pre><code>  <span>get</span> <span>canUndo</span><span>()</span> <span>{</span>
    <span>return</span> <span>past</span><span>.</span><span>length</span> <span>&gt;</span> <span>0</span><span>;</span>
  <span>},</span>
  <span>get</span> <span>canRedo</span><span>()</span> <span>{</span>
    <span>return</span> <span>future</span><span>.</span><span>length</span> <span>&gt;</span> <span>0</span><span>;</span>
  <span>}</span>
</code></pre></div></div>

<h2 id="the-pass-by-reference-problem">The pass-by-reference problem</h2>

<p>There is a catch with our implementation though. JS is pass-by-reference for pretty much all of its types. This means, that when we create a closure over a value - <code>currentStroke</code> in this case - the closure will keep addressing whatever is stored in <code>currentStroke</code> <em>right now.</em> And these <code>doFn</code> and <code>undoFn</code> are very particular in a specific behavioral trait: they must be idempotent. No matter how many times you call them, they should lead to the same result.</p>

<p>If we just do this:</p>

<div><div><pre><code><span>let</span> <span>doFn</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>strokes</span><span>.</span><span>push</span><span>(</span><span>currentStroke</span><span>)</span>
</code></pre></div></div>

<p>each time we call <code>doFn</code> - whatever is <code>currentStroke</code> in the calling scope will end up getting pushed onto the <code>strokes</code> stack. That’s not what we want - we want the <code>doFn</code> to use a cloned copy of the <code>currentStroke</code>, and we want it to do so always. Same for the <code>undoFnx</code> - although in this case there is no need for it to know what’s stored in <code>strokes</code> nor what the <code>currentStroke</code> used to be, as we are not going to resume drawing that <code>currentStroke</code>. Modern JS has a thing for this called <code>structuredClone()</code>, which is perfect for the occasion:</p>

<div><div><pre><code>  <span>push</span><span>(</span><span>doFn</span><span>,</span> <span>undoFn</span><span>,</span> <span>...</span><span>withArgumentsToClone</span><span>)</span> <span>{</span>
    <span>const</span> <span>clonedArgs</span> <span>=</span> <span>structuredClone</span><span>(</span><span>withArgumentsToClone</span><span>);</span>
    <span>const</span> <span>action</span> <span>=</span> <span>{</span>
      <span>doWithData</span><span>()</span> <span>{</span>
        <span>doFn</span><span>(...</span><span>clonedArgs</span><span>);</span>
      <span>},</span>
      <span>undoWithData</span><span>()</span> <span>{</span>
        <span>undoFn</span><span>(...</span><span>clonedArgs</span><span>);</span>
      <span>},</span>
    <span>};</span>
    <span>action</span><span>.</span><span>doWithData</span><span>();</span>
  
    <span>// Adding a new action wipes the redoable steps</span>
    <span>past</span><span>.</span><span>push</span><span>(</span><span>action</span><span>);</span>
    <span>future</span><span>.</span><span>length</span> <span>=</span> <span>0</span><span>;</span>
  <span>}</span>
</code></pre></div></div>

<p>and we’ll amend our functions accordingly. Instead of closuring over <code>currentStroke</code> we’ll make it an argument:</p>

<div><div><pre><code>let appendStroke = strokes.push.bind(strokes);
undoStack.push(appendStroke, () =&gt; strokes.pop(), currentStroke);
</code></pre></div></div>

<p>with the <code>push()</code> of our <code>undoStack</code> taking care of making a deep clone for us. Nice!</p>

<p>The complete definition then becomes:</p>

<div><div><pre><code><span>function</span> <span>createUndoStack</span><span>()</span> <span>{</span>
  <span>const</span> <span>past</span> <span>=</span> <span>[];</span>
  <span>const</span> <span>future</span> <span>=</span> <span>[];</span>
  <span>return</span> <span>{</span>
    <span>push</span><span>(</span><span>doFn</span><span>,</span> <span>undoFn</span><span>,</span> <span>...</span><span>withArgumentsToClone</span><span>)</span> <span>{</span>
      <span>const</span> <span>clonedArgs</span> <span>=</span> <span>structuredClone</span><span>(</span><span>withArgumentsToClone</span><span>);</span>
      <span>const</span> <span>action</span> <span>=</span> <span>{</span>
        <span>doWithData</span><span>()</span> <span>{</span>
          <span>doFn</span><span>(...</span><span>clonedArgs</span><span>);</span>
        <span>},</span>
        <span>undoWithData</span><span>()</span> <span>{</span>
          <span>undoFn</span><span>(...</span><span>clonedArgs</span><span>);</span>
        <span>},</span>
      <span>};</span>
      <span>action</span><span>.</span><span>doWithData</span><span>();</span>

      <span>// Adding a new action wipes the redoable steps</span>
      <span>past</span><span>.</span><span>push</span><span>(</span><span>action</span><span>);</span>
      <span>future</span><span>.</span><span>length</span> <span>=</span> <span>0</span><span>;</span>
    <span>},</span>
    <span>undo</span><span>()</span> <span>{</span>
      <span>let</span> <span>action</span> <span>=</span> <span>past</span><span>.</span><span>pop</span><span>();</span>
      <span>if </span><span>(</span><span>action</span><span>)</span> <span>{</span>
        <span>action</span><span>.</span><span>undoWithData</span><span>();</span>
        <span>future</span><span>.</span><span>unshift</span><span>(</span><span>action</span><span>);</span>
      <span>}</span>
    <span>},</span>
    <span>redo</span><span>()</span> <span>{</span>
      <span>let</span> <span>action</span> <span>=</span> <span>future</span><span>.</span><span>shift</span><span>();</span>
      <span>if </span><span>(</span><span>action</span><span>)</span> <span>{</span>
        <span>action</span><span>.</span><span>doWithData</span><span>();</span>
        <span>past</span><span>.</span><span>push</span><span>(</span><span>action</span><span>);</span>
      <span>}</span>
    <span>},</span>
    <span>get</span> <span>undoAvailable</span><span>()</span> <span>{</span>
      <span>return</span> <span>past</span><span>.</span><span>length</span> <span>&gt;</span> <span>0</span><span>;</span>
    <span>},</span>
    <span>get</span> <span>redoAvailable</span><span>()</span> <span>{</span>
      <span>return</span> <span>future</span><span>.</span><span>length</span> <span>&gt;</span> <span>0</span><span>;</span>
    <span>},</span>
    <span>clear</span><span>()</span> <span>{</span>
      <span>past</span><span>.</span><span>length</span> <span>=</span> <span>0</span><span>;</span>
      <span>future</span><span>.</span><span>length</span> <span>=</span> <span>0</span><span>;</span>
      <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>{</span><span>createUndoStack</span><span>};</span>
</code></pre></div></div>

<p>Robust, small, and no indexing errors. My jam.</p>


  </article>

</div></div>
  </body>
</html>
