<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://depot.dev/blog/uncovering-disk-io-bottlenecks-github-actions-ci">Original</a>
    <h1>Disk I/O bottlenecks in GitHub Actions</h1>
    
    <div id="readability-page-1" class="page"><div><p>Disk I/O bottlenecks are easy to overlook when analyzing CI pipeline performance, but tools like <a href="https://linux.die.net/man/1/iostat">iostat</a> and <a href="https://github.com/axboe/fio">fio</a> can help shed a light on what might be slowing down your pipelines more than you know.</p>
<p>GitHub offers different hosted-runners with a range of specs, but for this test we are using the default <code>ubuntu-22.04</code> runner in a private repository, which does give us an additional 2 vCPUs but does not alter the disk performance.</p>
<h2 id="how-to-monitor-disk-performance"><a aria-hidden="true" tabindex="-1" href="#how-to-monitor-disk-performance"><span></span></a>How to monitor disk performance</h2>
<p>Getting a baseline benchmark from a tool like <code>fio</code> is useful for comparing the relative disk performance of different runners. However, to investigate if you are hitting disk I/O bottlenecks in your CI pipeline, it is more useful to monitor disk performance during the pipeline execution.</p>
<p>We can use a tool like <code>iostat</code> to monitor the disk while installing dependencies from the cache to see how much we are saturating the disk.</p>
<div><pre tabindex="0" data-rehype="true" rel="nofollow" itemscope="" itemtype="https://schema.org/SoftwareSourceCode"><code><span><span>- </span><span>name</span><span>: </span><span>Start IOPS Monitoring</span></span>
<span><span>  run</span><span>: </span><span>|</span></span>
<span><span>    echo &#34;Starting IOPS monitoring&#34;</span></span>
<span><span>    # Start iostat in the background, logging IOPS every second to iostat.log</span></span>
<span><span>    nohup iostat -dx 1 &gt; iostat.log 2&gt;&amp;1 &amp;</span></span>
<span><span>    echo $! &gt; iostat_pid.txt  # Save the iostat process ID to stop it later</span></span>
<span></span>
<span><span>- </span><span>uses</span><span>: </span><span>actions/cache@v4</span></span>
<span><span>  timeout-minutes</span><span>: </span><span>5</span></span>
<span><span>  id</span><span>: </span><span>cache-pnpm-store</span></span>
<span><span>  with</span><span>:</span></span>
<span><span>    path</span><span>: </span><span>${{ steps.get-store-path.outputs.STORE_PATH }}</span></span>
<span><span>    key</span><span>: </span><span>pnpm-store-${{ hashFiles(&#39;pnpm-lock.yaml&#39;) }}</span></span>
<span><span>    restore-keys</span><span>: </span><span>|</span></span>
<span><span>      pnpm-store-</span></span>
<span><span>      pnpm-store-${{ hashFiles(&#39;pnpm-lock.yaml&#39;) }}</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Stop IOPS Monitoring</span></span>
<span><span>  run</span><span>: </span><span>|</span></span>
<span><span>    echo &#34;Stopping IOPS monitoring&#34;</span></span>
<span><span>    kill $(cat iostat_pid.txt)</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Save IOPS Data</span></span>
<span><span>  uses</span><span>: </span><span>actions/upload-artifact@v4</span></span>
<span><span>  with</span><span>:</span></span>
<span><span>    name</span><span>: </span><span>iops-log</span></span>
<span><span>    path</span><span>: </span><span>iostat.log</span></span></code></pre></div>
<h3 id="monitoring-disk-during-untar-of-nextjs-dependencies"><a aria-hidden="true" tabindex="-1" href="#monitoring-disk-during-untar-of-nextjs-dependencies"><span></span></a>Monitoring disk during untar of Next.js dependencies</h3>
<p>In the above test, we used <code>iostat</code> to monitor disk performance while the cache action downloaded and untarred the dependencies for <code>vercel/next.js</code>:</p>
<div><pre tabindex="0" data-rehype="true" rel="nofollow" itemscope="" itemtype="https://schema.org/SoftwareSourceCode"><code><span><span>Received</span><span> 96468992</span><span> of</span><span> 343934082</span><span> (28.0%), 91.1 MBs/sec</span></span>
<span><span>Received</span><span> 281018368</span><span> of</span><span> 343934082</span><span> (81.7%), 133.1 MBs/sec</span></span>
<span><span>Cache</span><span> Size:</span><span> ~328</span><span> MB</span><span> (343934082 </span><span>B</span><span>)</span></span>
<span><span>/usr/bin/tar</span><span> -xf</span><span> /home/</span><span>&lt;</span><span>pat</span><span>h</span><span>&gt;</span><span>/cache.tzst</span><span> -P</span><span> -C</span><span> /home/</span><span>&lt;</span><span>pat</span><span>h</span><span>&gt;</span><span>/gha-disk-benchmark</span><span> --use-compress-program</span><span> unzstd</span></span>
<span><span>Received</span><span> 343934082</span><span> of</span><span> 343934082</span><span> (100.0%), 108.8 MBs/sec</span></span>
<span><span>Cache</span><span> restored</span><span> successfully</span></span></code></pre></div>
<p>The full step took 12s to complete, and we can estimate the download took around 3s, leaving 9s for the untar operation.</p>
<p>The compressed tarball is only about 328MB, but after extraction, the total amount of data written to the disk is about 1.6GB. That smaller size got our cache across the network plenty fast, and most CPUs can handle decompression fast enough, meaning higher compression is often favorable. Once download and decompression are no longer the bottleneck, that leaves writing to disk.</p>
<p>Reading from a tarball is a fairly efficient process as it&#39;s mostly sequential reads, however, we then need to write each file to disk. This is where we can hit disk I/O bottlenecks, especially with a large number of small files.</p>

<p>It’s important to note that this is just a single run, not an average. Running multiple tests over time will give you a much clearer picture of the overall performance. Variance between runs can be quite high, so an individual bad run doesn’t necessarily indicate a problem.</p>
<p>What this run suggests is a possible throughput bottleneck. We’re seeing spikes in the maximum total throughput, with most hovering around ~220MB/s. This is likely the maximum throughput we are able to achieve to this disk, we&#39;ll verify this next. We should continue to monitor this and compare it to other runners to see if we can find an ideal runner for our workflow. We&#39;ll use <code>fio</code> to double-check if we are hitting the disk&#39;s maximum throughput.</p>
<p>An interesting aside before we move on, we can see from this side-by-side how relatively low read operations to writes there are. Since we’re reading from a tarball, most reads are sequential, which tends to be more efficient. That read data is likely going into a buffer before being written to the disk in a more random pattern as it creates a copy of each file. This is why we see a higher write IOPS than read IOPS.</p>
<h3 id="maximum-disk-throughput"><a aria-hidden="true" tabindex="-1" href="#maximum-disk-throughput"><span></span></a>Maximum disk throughput</h3>
<p>One of the first optimizations developers usually make to their CI pipelines is caching dependencies. Even though the cache still gets uploaded and downloaded with each run, it speeds things up by packaging all your dependencies into one compressed file. This skips the hassle of resolving dependencies, avoids multiple potentially slow downloads, and cuts down on network delays.</p>
<p>But as we saw above, network speed isn&#39;t usually our bottleneck when downloading the cache.</p>
<table><thead><tr><th>Test Type</th><th>Block Size</th><th>Bandwidth</th></tr></thead><tbody><tr><td><strong>Read Throughput</strong></td><td>1024KiB</td><td>~209MB/s</td></tr><tr><td><strong>Write Throughput</strong></td><td>1024KiB</td><td>~209MB/s</td></tr></tbody></table>
<p>Using <code>fio</code> to test our throughput, notice that both &#34;read&#34; and &#34;write&#34; throughput are both capped at the same value. This is a fairly telling sign that the limitation here is not actually the disk physically, but rather a bandwidth limit imposed by GitHub. This is a standard practice to divide up resources among multiple users who may be accessing the same physical disk from their virtual machines. It isn&#39;t always documented, but most providers will have higher bandwidth limits on higher tier runners.</p>
<p>What we measured here aligns fairly closely with the 220MB/s we saw in the untar test, giving us another hint that we are likely being slowed down during our dependency installation, not by the network or CPU, but by the disk.</p>
<p>Regardless of how fast our download speed is, we won&#39;t be able to write to disk any faster than our max throughput to the disk.</p>
<div><div><p><label for="cache-size">Uncompressed Cache Size</label></p><p><label for="bandwidth-limit">Disk Bandwidth</label></p></div><p><span>Estimated time to write to disk:<!-- --> </span><span>Select a cache payload and throughput speed</span></p></div>
<p>Realistically, your disk performance will vary greatly depending on your specific cache size, the number of files, and just general build-to-build variance. That&#39;s why it&#39;s a good idea to monitor your CI runners for a consistent baseline, and we&#39;ll talk about testing your workflow on multiple runners for comparison.</p>
<h3 id="maximum-iops-inputoutput-operations-per-second"><a aria-hidden="true" tabindex="-1" href="#maximum-iops-inputoutput-operations-per-second"><span></span></a>Maximum IOPS (Input/Output Operations Per Second)</h3>
<p>After downloading the cache tarball, it needs to be extracted. Depending on the compression level it could be a CPU-intensive operation but this isn&#39;t usually a problem. When untar-ing the dependencies, we are performing a lot of small read and write operations, which is where we can hit disk I/O bottlenecks.</p>
<table><thead><tr><th>Test Type</th><th>Block Size</th><th>IOPS</th></tr></thead><tbody><tr><td><strong>Read IOPS</strong></td><td>4096B</td><td>~51K</td></tr><tr><td><strong>Write IOPS</strong></td><td>4096B</td><td>~57K</td></tr><tr><td><strong>Random Read IOPS</strong></td><td>4096B</td><td>~9370</td></tr><tr><td><strong>Random Write IOPS</strong></td><td>4096B</td><td>~3290</td></tr></tbody></table>
<p>IOPS is a measure of how many read/write operations can be performed in a second. When we have a lot of small files, like especially with a <code>node_modules</code> directory, it is possible to saturate the IOPS limit of the disk (or the imposed limit) and become a different kind of IO bottleneck.</p>
<p>Similarly to how we can&#39;t write to the disk any faster than the bandwidth limit, there is a limit to how many IOPS we can perform on the disk.</p>
<h2 id="running-benchmarks-on-different-runners"><a aria-hidden="true" tabindex="-1" href="#running-benchmarks-on-different-runners"><span></span></a>Running benchmarks on different runners</h2>
<p>If you are seeing bottlenecks in your CI pipeline, of any kind, we want to try to optimize for those issues with strategies like caching and parallelizing where possible. But we also need to know if we are hitting the limits of the runner we are using. It&#39;s easy enough to add a matrix strategy to your workflow to test on multiple runners for a quick comparison of speed of the same steps on different hardware.</p>
<div><pre tabindex="0" data-rehype="true" rel="nofollow" itemscope="" itemtype="https://schema.org/SoftwareSourceCode"><code><span><span>jobs</span><span>:</span></span>
<span><span>  build</span><span>:</span></span>
<span><span>    runs-on</span><span>: </span><span>${{ matrix.runner }}</span></span>
<span><span>    strategy</span><span>:</span></span>
<span><span>      matrix</span><span>:</span></span>
<span><span>        runner</span><span>: [</span><span>ubuntu-22.04</span><span>, </span><span>depot-ubuntu-22.04</span><span>]</span></span></code></pre></div>
<p>To get a more detailed look at the specific disk performance of each runner, you can use the <code>fio</code> benchmarking tool we mentioned earlier. This will give you a better idea of the disk performance of each runner, and a reference point for checking for bottlenecks in your CI pipeline.</p>
<div><pre tabindex="0" data-rehype="true" rel="nofollow" itemscope="" itemtype="https://schema.org/SoftwareSourceCode"><code><span><span>- </span><span>name</span><span>: </span><span>Random Read Throughput Test</span></span>
<span><span>  run</span><span>: </span><span>|</span></span>
<span><span>    fio --ioengine=sync --bs=4k --rw=randread --name=random_read_throughput \</span></span>
<span><span>    --direct=1 --filename=$HOME/fio_test/file --time_based --runtime=10s \</span></span>
<span><span>    --size=250m --output=random_read_throughput_result-${{ matrix.runner }}.txt</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Clean up Test Directory</span></span>
<span><span>  run</span><span>: </span><span>rm -rf $HOME/fio_test/*</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Random Write Throughput Test</span></span>
<span><span>  run</span><span>: </span><span>|</span></span>
<span><span>    fio --ioengine=sync --bs=4k --rw=randwrite --name=random_write_throughput \</span></span>
<span><span>    --direct=1 --filename=$HOME/fio_test/file --time_based --runtime=10s \</span></span>
<span><span>    --size=250m --output=random_write_throughput_result-${{ matrix.runner }}.txt</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Clean up Test Directory</span></span>
<span><span>  run</span><span>: </span><span>rm -rf $HOME/fio_test/*</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Random Read IOPS Test</span></span>
<span><span>  run</span><span>: </span><span>|</span></span>
<span><span>    fio --name=random_read_iops --directory=$HOME/fio_test --size=5G \</span></span>
<span><span>    --time_based --runtime=60s --ramp_time=2s --ioengine=libaio --direct=1 \</span></span>
<span><span>    --verify=0 --bs=4K --iodepth=256 --rw=randread --group_reporting=1 \</span></span>
<span><span>    --iodepth_batch_submit=256 --iodepth_batch_complete_max=256 \</span></span>
<span><span>    --output=random_read_iops_result-${{ matrix.runner }}.txt</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Clean up Test Directory</span></span>
<span><span>  run</span><span>: </span><span>rm -rf $HOME/fio_test/*</span></span>
<span></span>
<span><span>- </span><span>name</span><span>: </span><span>Random Write IOPS Test</span></span>
<span><span>  run</span><span>: </span><span>|</span></span>
<span><span>    fio --name=random_write_iops --directory=$HOME/fio_test --size=5G \</span></span>
<span><span>    --time_based --runtime=60s --ramp_time=2s --ioengine=libaio --direct=1 \</span></span>
<span><span>    --verify=0 --bs=4K --iodepth=256 --rw=randwrite --group_reporting=1 \</span></span>
<span><span>    --iodepth_batch_submit=256 --iodepth_batch_complete_max=256 \</span></span>
<span><span>    --output=random_write_iops_result-${{ matrix.runner }}.txt</span></span></code></pre></div>
<h2 id="ultra-fast-disk-io-with-depot-ultra-runner"><a aria-hidden="true" tabindex="-1" href="#ultra-fast-disk-io-with-depot-ultra-runner"><span></span></a>Ultra-fast disk I/O with Depot Ultra Runner</h2>
<p>Depot is launching a new runner type with ultra-fast disk I/O, the Depot Ultra Runner. The Ultra Runner utilizes a large RAM disk cache and higher-powered CPUs to maximize performance in both high IOPS and high throughput scenarios.</p>
<p>Want to be notified when the Depot Ultra Runner is available? Subscribe to our <a href="https://k-monk.org/changelog">changelog</a> for all major updates.</p>
<p>Try comparing your current workflow on a Depot runner. Sign up for our <a href="https://depot.dev/sign-up">7-day free trial</a> and compare your CI pipeline performance on <a href="https://depot.dev/docs/github-actions/runner-types">Depot Runners</a> with a matrix job.</p><div><div><picture><source srcset="/authors/kyletryon.avif" type="image/avif"/><source srcset="/authors/kyletryon.webp" type="image/webp"/><img src="https://k-monk.org/authors/kyletryon.jpeg" alt="kyletryon" width="350" height="350" decoding="async" loading="lazy"/></picture></div></div></div></div>
  </body>
</html>
