<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://transitivebullsh.it/gaming-cs-interviews">Original</a>
    <h1>Gaming CS Interviews</h1>
    
    <div id="readability-page-1" class="page"><article><blockquote><em>A guide to CS interviews aimed at self-taught engineers.</em></blockquote><h2 data-id="e9b215c795754adf8ba439bd33d57392"><span><a href="#e9b215c795754adf8ba439bd33d57392" title="Intro"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span>Intro</span></span></h2><p>Many companies in the tech industry have started <a target="_blank" rel="noopener noreferrer" href="https://techcrunch.com/2013/06/22/the-technical-interview-is-dead/">moving away</a> from <a target="_blank" rel="noopener noreferrer" href="https://github.com/poteto/hiring-without-whiteboards">traditional, technical whiteboard interviews</a>, because they tend to bare little relevance to an employee’s day-to-day work. Most companies are better off focusing on testing <a target="_blank" rel="noopener noreferrer" href="https://hired.com/blog/employers/whiteboard-interview-alternatives/">practical skills and the ability to deliver</a> as opposed to algorithmic, computer science questions, and that’s coming from someone who genuinely loves these types of questions..</p><p>With that being said, the most esteemed tech companies like <b>Google, Facebook, Amazon, Microsoft</b>, etc. all still employ very similar technical interview loops that <em>tend to greatly favor candidates with standard computer science backgrounds over candidates who are either self-taught</em> or who prefer to focus on software engineering over computer science.</p><p>Regardless of your views on whether or not this process is fair or optimal, I know a lot of engineers who scoff at the idea of interviewing with one of these bigger players, even though I know from experience that they would fit in just fine. So I decided to share some no-bullshit advice I’ve accumulated over the years on how to approach dealing with them.</p><blockquote>I believe that most developers who are proficient at developing code in their language of choice are capable of passing a FAANG-style interview loop by adopting the right mindset and studying a few key topics and question archetypes ahead of time.</blockquote><p>So, with that goal in mind, let’s dive into that whiteboard…</p><figure><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271000%27%20height=%27666%27/%3e"/></span><img alt="notion image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></figure><h2 data-id="23a032cb3884498c9318e7dd6763597b"><span><a href="#23a032cb3884498c9318e7dd6763597b" title="General Tips"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>General Tips</b></span></span></h2><p>When given a programming problem, never start coding right away. Always talk through the problem, by first verifying that your assumptions and thought processes are on the right track.</p><p>I highly recommend trying to get comfortable verbalizing your thought process at all times but especially when you’re not sure how to proceed. Oftentimes, the interviewer cares more about your thought process than the solution and/or will give you guidance according to your thoughts. Guidance is expected; a great interview should be more of a conversation than a one-sided question and one-sided answer.</p><p>Generally start out with the most naive, straight-forward approach to a problem you can think of, even if you think it’s really inefficient. Verbalize your thought process in doing so, and either the interviewer will say that&#39;s great and you can start coding, or you’ll get confirmation that they want to dig deeper into a more optimal solution which generally leads to a conversation about where the most inefficient part of the algorithm is (like the innermost loop) and how you could potentially mitigate its runtime.</p><p>Always use the programming language you’re most comfortable with; never use a “harder” language because you think it will make you look more legit.</p><p>At the end of the interview, your assessment will be highly subjective, so keep that in mind and try to have some fun and cold read the interviewer to play off of his or her interests. Almost always asking them early on about what they do at company X will help you understand the type of person they are and also helps to put them in a good mood because people love to talk about themselves. For instance, I recently interviewed with a developer who works on a compiler team at company X which adjusted the way I approached certain parts of the conversation to be more low-level and joke at one point about something all compiler peeps can relate to. If they like you as a person, they’ll be more lenient in their assessment whether they’re aware of it or not; that’s just human nature.</p><figure></figure><h2 data-id="0e142bf6edd34f3db9e494b7a645293c"><span><a href="#0e142bf6edd34f3db9e494b7a645293c" title="Interview Topics"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Interview Topics</b></span></span></h2><p>There are some very common archetypes in algorithmic interviews that tend to account for the vast majority of questions you’ll encounter. If you understand these core question types and can solve some example problems from each of them, you’ll have a much better eye for solving similar problems during a real interview and subsequently solving real problems on the job.</p><h4 data-id="abfb72a0741848ada53b7f09988d365e"><span><a href="#abfb72a0741848ada53b7f09988d365e" title="Algorithmic Complexity"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Algorithmic Complexity</b></span></span></h4><p>This topic boils down to understanding <a target="_blank" rel="noopener noreferrer" href="http://bigocheatsheet.com/"><b>big-O notation</b></a>. Even though there are other, more rare measures of complexity (like little-o, theta…) and topics like NP completeness, <em>I</em> <em>would recommend skimming them</em>, as they’re unlikely to appear in a typical technical interview.</p><p>For almost every problem you’re asked to solve in an interview, you’ll either be asked explicitly about the big-O runtime of a proposed solution or be implicitly expected to bring it up during your discussion.</p><p>This part can definitely be gamed somewhat by just practicing a bit on a representative set of problems ahead of time. You’ll both get the hang of it and also generally be able to fairly easily say that problem X looks like problem Y so they’re likely to have similar runtimes.</p><figure><div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27480%27%20height=%27198%27/%3e"/></span><img alt="I love how they portray algorithms in movies, don’t you? (Credit: The Winter Soldier, 2014)" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p><figcaption>I love how they portray algorithms in movies, don’t you? (Credit: <a target="_blank" rel="noopener noreferrer" href="https://www.imdb.com/title/tt1843866/">The Winter Soldier</a>, 2014)</figcaption></div></figure><p>Note that with big-O complexity, it’s most common to think about the problem in terms of runtime, but it can also come into play in terms of space storage. For example, a sorting algorithm may take <code>O(n log(n))</code> runtime which is pretty common but be able to operate on an array in-place, only requiring <code>O(n)</code> storage. Sometimes this can be an important factor when considering between alternative approaches or an interviewer will add that you are memory-bound or something.</p><p>I recommend reviewing and understanding the big-O runtime of the most common data structure operations, such as:</p><ul><li>add / remove / get / find from an <b>array</b></li></ul><ul><li>add / remove / find from a <b>linked list</b></li></ul><ul><li>add / remove / peek from a <b>stack</b></li></ul><ul><li>add / remove / peek from a <b>queue</b></li></ul><ul><li>add / remove / get from a <b>hashmap</b></li></ul><ul><li>add / remove / get from a <b>balanced binary tree</b></li></ul><ul><li>add / remove / get from a <b>heap</b> (though heaps are less common…)</li></ul><p>You should be intimately familiar with the runtime of each of these operations, since many algorithms will use these as building blocks. It is extremely worth it to not only <a target="_blank" rel="noopener noreferrer" href="http://bigocheatsheet.com/">memorize these runtimes</a>, but to have a solid understanding of how they are derived.</p><p>This topic can be difficult to grasp under different circumstances for even the most qualified candidates, so don’t worry if you’re able to come up with a solution but have trouble fleshing out its runtime. Also note that this is one of the easiest topics to “game” by practicing on examples ahead of time.</p><div><p><span role="img" aria-label="👉">👉</span></p><p>Understanding Big-O complexity will affect your ability to answer interview questions on all of the following topics, which is why it is the single most important base topic to focus on before proceeding.</p></div><p>One common subtopic I would recommend having a basic familiarity with is <em>amortized </em>big-O, aka <em>expected </em>big-O, whereby you use some neat probability theory to say that the <em>expected value</em> of an operation is, for instance, <code>O(1)</code> even though sometimes it may be <code>O(n)</code> for individual calls. The most common examples of amortized / expected big-O in practice are hashmap lookups being amortized <code>O(1)</code> and quicksort being amortized <code>O(n log(n))</code>. In Javascript, for instance, all object lookups such as <code>myObject.foo</code> or <code>window.document</code> are amortized <code>O(1)</code> hashmap lookups (aside from special cases where the compiler is able to optimize these operations under the hood).</p><h3 data-id="0f9731f8ef724f46952dd4418918f9db"><span><a href="#0f9731f8ef724f46952dd4418918f9db" title="Graphs and Trees"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Graphs and Trees</b></span></span></h3><figure><div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27256%27%20height=%27214%27/%3e"/></span><img alt="Example graph composed of nodes and edges." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p><figcaption>Example graph composed of nodes and edges.</figcaption></div></figure><p>Graphs are one area where there is a <em>lot</em> of potential complexity and bullshit to wade through, but at the end of the day, almost all graph-related interview questions are really pretty simple once you understand the basics. <em>It can just be overwhelming sometimes when you’re not sure what “the basics” are,</em> and you’re trying to understand something like Dijkstra&#39;s algorithm which is definitely beyond the scope of what most interviews will delve into.</p><h4 data-id="a8e09d447e2d46578e6a7c5f316dd1da"><span><a href="#a8e09d447e2d46578e6a7c5f316dd1da" title="Terminology"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Terminology</b></span></span></h4><ul><li><span>A graph is a set of nodes and edges between some of those nodes</span>. Nodes and edges often have payloads like a label or weight associated with them.</li></ul><ul><li>The most common graph distinction is between undirected vs directed graphs. E.g., when you have an edge between two nodes, is it a directed, one-way street, or is an undirected, two-way street where you can go in both directions when going from node to node.</li></ul><ul><li>A tree is a very common type of graph with some interesting constraints, so anything you learn about graphs in general also applies to trees like binary search trees and the DOM.</li></ul><ul><li>Traversing a graph is the process of visiting nodes in a graph, usually starting from a root node and expanding out from there <em>recursively</em> based on each node’s neighbors.</li></ul><ul><li>The two main algorithms to understand w.r.t. graphs that <b>95% of graph questions boil down to, </b><span><b>are breadth-first-search (BFS), and depth-first-search (DFS)</b></span>, visualized briefly below.</li></ul><figure></figure><h4 data-id="a090f4a9fa68423da07e7190a36a67b8"><span><a href="#a090f4a9fa68423da07e7190a36a67b8" title="Advice"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Advice</b></span></span></h4><p>When working with graphs, it can be especially useful to visualize them by drawing examples on a whiteboard, which is one of the only good uses I can think of for a whiteboard during a generic technical interview...</p><p>There are lots of different types of graphs and specializations that you may come across during studying, but their distinctions are rarely important for interviews.</p><figure><div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27850%27%20height=%27678%27/%3e"/></span><img alt="The Document Object Model (DOM) is an important example of a common graph used by many frontend developers." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p><figcaption>The <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">Document Object Model</a> (DOM) is an important example of a common graph used by many frontend developers.</figcaption></div></figure><p>You should be very comfortable coding BFS and DFS from scratch. Even if the question isn’t directly “code BFS”, lots of questions will indirectly involve you traversing a graph starting from a given node of interest and making sure you’re not visiting nodes multiple times which is exactly what BFS/DFS excel at.</p><p>Notice how interchangeably I use BFS/DFS; they are very slight variations on each other and most of the time it doesn’t matter if you use BFS or DFS, but you should still understand the difference between the two and be able to draw example traversals on a whiteboard.</p><p>BFS and DFS can both be implemented iteratively or recursively (any so-called “tail-recursive” function can be rewritten iteratively). The recursive mindset is much more powerful so I’d focus your efforts there first.</p><p>Most of the time, it’s totally up to you in terms of how you define the graph you’ll be working with. For example, here is a very succinct way of representing a graph by defining a single <code>Node</code>:</p><pre><code>class Node {
  string value
  Array&lt;Node&gt; neighbors
}</code></pre><figcaption>Node-centric example graph representation.</figcaption><p>A common distinction with graphs is whether the data structure you use is “node-centric” or “graph-centric”. The previous Node definition is node-centric because each node is smart and encapsulates information about its adjacent edges. Here’s an alternative graph-centric example, where we also use integers to represent nodes:</p><pre><code>class Graph { 
  Array&lt;int&gt; nodes;
  Array&lt;[ int, int ]&gt; edges
}</code></pre><figcaption>Graph-centric example graph representation.</figcaption><p><em>Example question:</em></p><blockquote>Given a graph where nodes represent major US cities and edges represent flights between those cities, write a function that takes in two cities and returns a valid flight path between those two cities or null if no such flight path exists.</blockquote><ul><li>The most direct solution to this problem uses DFS.</li></ul><ul><li>A harder variant of this type of question would be to find the <em>shortest</em> path if each edge (flight) had a number associated with it that represented distance, which is where Djikstra’s algorithm would come into play.</li></ul><figure><div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27700%27%20height=%27394%27/%3e"/></span><img alt="Graph visualization of flights between major US cities (credit: databricks)." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p><figcaption>Graph visualization of flights between major US cities (credit: <a target="_blank" rel="noopener noreferrer" href="https://databricks.com/blog/2016/03/16/on-time-flight-performance-with-graphframes-for-apache-spark.html">databricks</a>).</figcaption></div></figure><h3 data-id="083392b655d342aa8c85e34f86294e4b"><span><a href="#083392b655d342aa8c85e34f86294e4b" title="Sorting"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Sorting</b></span></span></h3><p>Sorting numbers, strings, etc. is a very common sub-problem in solving many interview questions. You generally won&#39;t be asked to write mergesort or quicksort or any other type of sort, but it will be quite common to either have to sort some part of your input as a piece of the puzzle or have the solution very closely resemble a widely-known sorting algorithm. For this reason, it’s useful to <a target="_blank" rel="noopener noreferrer" href="https://www.toptal.com/developers/sorting-algorithms">review</a> and be able to code the most common ones.</p><pre><code>/**
 * Sorts an array by ignoring it and then printing out a new, 
 * sorted array with its own &#34;Alternative Values.&#34;
 */

let input = [ 6, 8, 3, 9, 5, 4, 1, 7, 0, 2 ]

function conwaySort () {
  return [ 15, 16, 17, 18, 19, 20 ]
}</code></pre><figcaption>Note: please don’t take this algorithm seriously. (Credit: Reddit)</figcaption><h4 data-id="afae0c7cb2db4f67829b8b9601dd4640"><span><a href="#afae0c7cb2db4f67829b8b9601dd4640" title="Common Sorting Algorithms"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Common Sorting Algorithms</b></span></span></h4><ul><li><span><b>Mergesort</b></span>; in particular, its recursive “divide &amp; conquer” approach comes up often. <code>O(n log(n))</code></li></ul><ul><li><span><b>Quicksort</b></span>; generally considered the most robust, general-purpose sorting algorithm. generally amortized <code>O(n log(n))</code></li></ul><ul><li><span><b>Radixsort</b></span>; only works on numbers using bit hacks but is significantly more efficient. <code>O(n)</code></li></ul><p>Radix sort is too advanced to implement in any interview that’s not from Hell, so don’t worry about its internals, but it can come in handy knowing that it exists and being able to make use of it.</p><p><em>Example question:</em></p><blockquote>Given an array of integers, write a function that will remove all duplicates. (be sure to add the obligatory followup, what is its runtime?)</blockquote><ul><li>The “aha” moment here comes if you realize that by sorting the input, you can just walk along the array with all duplicates being next to each other, resulting in an efficient solution.</li></ul><h3 data-id="cabb114992444c55bc7cc88adb8d4671"><span><a href="#cabb114992444c55bc7cc88adb8d4671" title="Strings"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Strings</b></span></span></h3><p>Review string primitive operations in your preferred language. Eg., for Javascript, <code>slice</code>, <code>substr</code>, <code>substring</code>, <code>toLowerCase</code>, <code>toUpperCase</code>, <code>charAt</code>, and very basic regex stuff using <code>match</code>.</p><figure><div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27200%27%20height=%27252%27/%3e"/></span><img alt="Luckily, most interview questions focus on ascii." src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p><figcaption>Luckily, most interview questions focus on ascii.</figcaption></div></figure><h4 data-id="60c12f453c2b43b6aed871d8cda9eb55"><span><a href="#60c12f453c2b43b6aed871d8cda9eb55" title="Notes"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Notes</b></span></span></h4><ul><li><span>Strings are just arrays of characters</span>, so any algorithms you learn for arrays also applies to strings.</li></ul><ul><li>A very common type of string problem involves finding all possible substrings of a given input string.</li></ul><p><em>Example question:</em></p><blockquote>Given a password string of length n as input and a mapping from all 26 lowercase characters to possible alternates (like “e” maps to [ “e”, “E”, “3” ]), implement a function that returns all possible password combinations you could generate of length n.</blockquote><ul><li>For example, “haxor” could be “Haxor”, “hax0r”, “HAX0r”, etc.</li></ul><h3 data-id="b38d6a013fdb45c6850ff5c81e1013fd"><span><a href="#b38d6a013fdb45c6850ff5c81e1013fd" title="Recursion"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Recursion</b></span></span></h3><p>Writing recursive functions should flow like bread &amp; butter and has a lot of overlap with all the other topics listed here.</p><figure><div><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27460%27%20height=%27431%27/%3e"/></span><img alt="Credit: The Internets" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p><figcaption>Credit: The Internets</figcaption></div></figure><p><em>Example question:</em></p><blockquote>Implement a function that will return the nth number in the fibonacci sequence (1, 1, 2, 3, 5, 8, 13, …).</blockquote><ul><li>A common follow-up is that the straight-forward solution is typically pretty inefficient, so how could you optimize the recursion?</li></ul><p><em>Example question:</em></p><blockquote>Given a binary tree, implement a “visitor” pattern function that takes in a node and visits all children. Implement prefix, infix, and postfix traversals.</blockquote><ul><li>The difference in the traversal order is just moving the order you visit the “current” node around, either before the children, after the left child, or after the right child.</li></ul><p><em>Example question:</em></p><blockquote>Given a simplified DOM node defined as: class Node { string className; Array&lt;Node&gt; children; }, write a function that takes in a Node along with a target css class and returns a list of all subnodes which match that CSS class.</blockquote><ul><li>Aside from the traversal, which you’ll likely do recursively, the logic to visit each node needs to take into account the fact that DOM nodes can have multiple classnames, so it’s not enough just to do a direct comparison between the target CSS class and a Node’s <code>className</code>.</li></ul><ul><li>This is exactly what the built-in function <code>getElementsByClassName</code> does.</li></ul><h3 data-id="bb6fd64d4e1a4ec08dd6614b118ad5a2"><span><a href="#bb6fd64d4e1a4ec08dd6614b118ad5a2" title="Brainteasers (Abstract Shit)"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Brainteasers (Abstract Shit)</b></span></span></h3><p>Brainteasers aren’t as common as they used to be, and these types of questions are more common for PMs (project / program managers), but they still come up occasionally in developer interviews as well.</p><p>They typically involve asking you to solve some impossible or outlandishly difficult problem, epitomizing the mantra that your thought process is more important than the solution you come up with.</p><p>One of the most famous examples comes from Google back in the day asking candidates “How would you move Mt. Fuji?”</p><h4 data-id="2eb726c7b03c472fbc0abbdb24f350fc"><span><a href="#2eb726c7b03c472fbc0abbdb24f350fc" title="Advice"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Advice</b></span></span></h4><ul><li><span>Realize that the goal isn’t to come up with the best possible solution, but rather a reasonable, viable solution that is backed by reasoning.</span></li></ul><ul><li>Ask clarifying questions; “Where are we moving Mt. Fuji to?”, “What resources do we have to accomplish the task?”, etc.</li></ul><ul><li>One common subset of brainteasers is to ask “How many X exist?” such as “How many gas stations are there in the US?”</li></ul><ul><li>The goal here is to be able to <span>guesstimate</span> some numbers that give an idea of the order of magnitude of the response, so if we estimate that there are 10 gas stations per town and 2000 towns per state and 50 states, … which should be more than enough to get the ball rolling.</li></ul><h3 data-id="2e1cd500562f477986676511a7c7f541"><span><a href="#2e1cd500562f477986676511a7c7f541" title="Less Common Topics"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Less Common Topics</b></span></span></h3><p>These topics aren’t as common as the core algorithm and data structure topics above, but depending on the position you’re applying for, it’s still a good idea to understand the high-level categories and be able to recognize a certain type of question when you encounter it.</p><ul><li>Concurrency</li></ul><ul><li>Databases</li></ul><ul><li>More generic data structures</li></ul><ul><li>Dynamic programming</li></ul><ul><li>Architecture</li></ul><ul><li>And sooooo many more…</li></ul><figure></figure><h2 data-id="c0c6a0ab51ca4df68064be6fd9a5fe23"><span><a href="#c0c6a0ab51ca4df68064be6fd9a5fe23" title="Where To Go From Here?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span><b>Where To Go From Here?</b></span></span></h2><p>The purpose of this post is to serve as a jumping off point to focus your interview prep on a few, core topics. Once you’re ready to dive into more detail, here are some great resources that’ll help you flesh out a better understanding of these core concepts with a focus on practical interview training.</p><p><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/jwasham/coding-interview-university#graphs">Coding Interview University</a></span> is one of the most starred repos on Github and for good reason. It aggregates articles, classes, videos, and other learning resources across a large number of topics relevant to CS interviews. My only word of warning is that it is pretty overwhelming and covers a lot more areas than are really necessary for standard technical interviews. Nonetheless, this is the first place I would recommend going to learn or review any of the topics I’ve outlined in this post.</p><p><span><a target="_blank" rel="noopener noreferrer" href="https://www.hiredintech.com/">Hired in Tech</a></span> is an amazing, well-organized resource which covers a lot of useful high-level techniques as well as specific examples. I would thoroughly recommend checking it out.</p><p>The <span><a target="_blank" rel="noopener noreferrer" href="https://github.com/yangshun/tech-interview-handbook">Tech Interview Handbook</a></span> is a great resource that, in addition to covering a lot of CS material itself, also gives more practical tips for what to expect and how to approach technical interview loops.</p><p>Once you’re comfortable with the core CS concepts I’ve outlined here, I’d recommend spending most of your prep time practicing online coding problems. Just remember while practicing to consider how you’d verbalize your thought process in a real interview setting and remember to consider things like big-O in addition to solving the problems themselves. Here are some of my favorite resources for finding quality practice interview questions:</p><ul><li><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/donnemartin/interactive-coding-challenges">Interactive Coding Challenges</a></span><span> </span>— Lists a large number of interactive practice questions, many of which come with solutions and explanations.</li></ul><ul><li><span><a target="_blank" rel="noopener noreferrer" href="https://www.interviewcake.com/google-interview-questions">Google Interview Questions</a></span><span> </span>— Great list of interview questions previously used by Google provided by Interview Cake.</li></ul><ul><li><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/jwasham/coding-interview-university#coding-exerciseschallenges">Coding Interview University</a></span> — Their section on coding exercises / challenges is a great meta-list of additional resources to find practice questions.</li></ul><p>Finally, <span>the best way to get more comfortable with interviewing is actually interviewing</span>. I know this sounds obvious, but one concrete piece of advice I can give is to apply anywhere and everywhere, even to companies you wouldn’t necessarily consider working for, with the tacit goal of gaining valuable experience in real-world interviews and the added benefit of possibly finding opportunities you didn’t know existed beforehand.</p><p>For example, if you’re interested in working for Google / Facebook / Twitter / etc, but you wouldn’t be too keen on working for Oracle &amp; IBM (strictly for example purposes…), I’d encourage you to still apply to them in order to gain practical experience and get more comfortable with interviewing. This is the absolute best way I know of to hone your skills in real-world settings that are going to be fairly comparable to interview loops at the more prestigious tech companies.</p><p>❤️ Travis</p><div><div><p><span role="img" aria-label="👉">👉</span></p><p>Follow me on twitter for more awesome stuff like this <span><a target="_blank" rel="noopener noreferrer" href="https://twitter.com/transitive_bs">@transitive_bs</a></span></p></div></div></article></div>
  </body>
</html>
