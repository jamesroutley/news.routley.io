<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fanael.github.io/is-x86-risc-internally.html">Original</a>
    <h1>The legend of “x86 CPUs decode instructions into RISC form internally”</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><article><header><p>Published on the <time datetime="2020-06-30">30th of June 2020</time></p><p>Topics: <a href="https://fanael.github.io/archives/topic-microarchitectural-musings.html">microarchitectural-musings</a>, <a href="https://fanael.github.io/archives/topic-mythbusting.html">mythbusting</a></p></header><p>There is a widespread idea that modern high-performance x86 processors work by decoding the &#34;complex&#34; x86 instructions into &#34;simple&#34; RISC-like instructions that the rest of the pipeline then operates on. But how close is this idea to how the processors <em>actually</em> work internally?</p><p>To answer this question, let&#39;s analyze how different x86 processors, ranging from the first &#34;modern&#34; Intel microarchitecture, P6, to their current designs, handle the following simple loop (the code is 32-bit just to allow us to discuss very old x86 processors):</p><pre><span>x86 assembly</span>
<code><span><span>.loop:
</span></span><span><span>    <span>add</span> [<span>edx</span>], <span>eax</span>
</span></span><span><span>    <span>add</span> <span>edx</span>, <span>4</span>
</span></span><span><span>    <span>sub</span> <span>eax</span>, <span>1</span>
</span></span><span><span>    <span>jnz</span> .loop
</span></span></code></pre><nav aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#setting-the-stage">RISC-V: setting the stage</a></li><li><a href="#p6-long-long-ago">P6: long, long ago</a></li><li><a href="#pentium-m-micro-fusion">Pentium M: introduction of micro-fusion</a></li><li><a href="#core-improved-fusion">Core: improved micro-fusion</a></li><li><a href="#sandy-bridge-branch-fusion">Sandy Bridge: (improved) branch fusion</a></li><li><a href="#what-about-others">What about AMD processors and Intel Atoms? Or NetBurst (shudders)?</a></li><li><a href="#final-verdict">Final verdict</a></li></ol></nav><section id="setting-the-stage"><h2><a href="#setting-the-stage"><span>RISC-V: setting the stage</span><span aria-hidden="true"> §</span></a></h2><p>First things first, though: what would that code look like on a RISC architecture? We need this to establish a target to compare to. There are many different RISC architectures in the wild, so let&#39;s just arbitrarily choose <a href="https://riscv.org/">RISC-V</a>, because it&#39;s free and open:</p><pre><span>RISC-V assembly</span>
<code><span><span>.loop:
</span></span><span><span>    lw a2, 0(a0)
</span></span><span><span>    add a2, a2, a1
</span></span><span><span>    sw a2, 0(a0)
</span></span><span><span>    addi a1, a1, -1
</span></span><span><span>    addi a0, a0, 4
</span></span><span><span>    bnez a1, .loop
</span></span></code></pre><p>This is pretty much what we&#39;d expect on any architecture that closely follows RISC principles: the &#34;complex&#34; operation of adding a register to a memory location is split into three instructions, namely a memory load to a temporary register, then integer addition that operates entirely on registers, and finally a memory store. The other three x86 instructions: addition of a constant to a register, subtraction of a constant, and a conditional branch are already simple enough and are therefore almost identical in RISC-V.</p><p>There&#39;s a difference in the branch between RISC-V and x86 here: x86 provides conditional branches based on flag bits set by arithmetic operations, like <code>sub</code> in our example, whereas RISC-V&#39;s branches work by directly comparing the values of two registers, here <code>a1</code> and the always-zero <code>x0</code>. This difference doesn&#39;t matter much in this case, because we&#39;re comparing the result of an arithmetic operation against zero, so the difference comes out to needing to tell RISC-V what register to compare to zero, while on x86 what&#39;s tested against zero is implied to be the result of the preceding arithmetic operation.</p></section><section id="p6-long-long-ago"><h2><a href="#p6-long-long-ago"><span>P6: long, long ago</span><span aria-hidden="true"> §</span></a></h2><p>Introduced in 1995 with the Pentium Pro, P6 was the first out-of-order x86 microarchitecture. It was later used with minor changes in the Pentium II and III, and is a direct ancestor of Intel&#39;s modern high-performance microarchitectures. How does it handle our loop?</p><p>The first instruction, <code>add [edx], eax</code>, is decoded into the following <strong>four</strong> micro-operations:</p><ol><li>Load a 32-bit value from the address contained in <code>edx</code> into a temporary unnamed register.</li><li>Add the value in <code>eax</code> to the value loaded by the first micro-operation, affecting flags.</li><li>Send the <em>result of the addition</em> to the memory store unit. Note that the <em>address</em> of the store is not used here!</li><li>Send the <em>address</em> contained in <code>edx</code> to the memory store unit.</li></ol><p>The following three instructions are all simple, decoding directly into one micro-operation each.</p><p>We end up with <em>seven</em> micro-operations total. That&#39;s actually one more than our RISC-V code has instructions, because the memory store is split into two! The reason behind splitting the memory store into micro-operations is a design quirk: each micro-operation in P6 can have up to two inputs. The x86 architecture supports addressing modes of the form <code>register + register * scale + constant</code>, which have two register inputs. The data to store to memory is another input, bringing us to three… which is one more than we can encode. Therefore, stores are split into a &#34;store data&#34; micro-operation with one input, and &#34;store address&#34; with two.</p><p>Verdict: the legend is absolutely true for P6, the micro-operations are very RISC-like, arguably more than an actual RISC architecture due to an implementation quirk.</p></section><section id="pentium-m-micro-fusion"><h2><a href="#pentium-m-micro-fusion"><span>Pentium M: introduction of micro-fusion</span><span aria-hidden="true"> §</span></a></h2><p>The successor of P6 was Pentium M, where the &#34;M&#34; likely stood for &#34;mobile&#34;. It was used primarily in laptops, where the contemporary NetBurst wasn&#39;t feasible due to its excessive power consumption and thermal requirements. There were a few Pentium M-based server processors, and there were socket adapters that let one use these processors in standard desktop socket 478 motherboards, but weren&#39;t very common.</p><p>Pentium M introduced <dfn>micro-operation fusion</dfn>, or micro-fusion for short, where some pairs of micro-operations decoded from the same instructions could be joined together. These fused pairs were kept together in as much of the pipeline as possible: they were generated as as one by the instruction decoders, they were treated as one micro-operation by the register renaming mechanism, they were using a single entry in the reorder buffer, and they were treated as one in retirement stations. Just about the only place where they weren&#39;t treated as one micro-operation was in the execution units themselves, as for example the memory load unit wouldn&#39;t know what to do with integer addition, so it never received that portion of the micro-fused pair. Therefore, arguably, micro-fused pairs <em>were single micro-operations</em> for all intents and purposes, splitting was just an implementation detail of the execution units.</p><p>The only instruction that was decoded into multiple micro-operations in P6 was the addition to a memory location. Can it benefit from micro-fusion in Pentium M? Indeed, it can, it&#39;s now decoded into three micro-operations that pretty much <em>exactly</em> match how our RISC-V code does the same operation:</p><ol><li>Load a 32-bit value from the address contained in <code>edx</code> into a temporary unnamed register.</li><li>Add the value in <code>eax</code> to the value loaded by the first micro-operation, affecting flags.</li><li>Send the <em>result of the addition <strong>and</strong> the address</em> to the memory store unit.</li></ol><p>The addition, the subtraction and the conditional branch all remain single micro-operations in Pentium M.</p><p>Verdict: we have a <em>perfect match</em> between our RISC-V code and Pentium M micro-operations in this particular case.</p></section><section id="core-improved-fusion"><h2><a href="#core-improved-fusion"><span>Core: improved micro-fusion</span><span aria-hidden="true"> §</span></a></h2><p>The immensely successful Core architecture was first released in 2006, when Intel finally realized that NetBurst was a dead-end, and took their mobile-focused Pentium M, which was derived from P6, and improved it further, giving us the legendary Core 2 Solo/Duo/Quad processors.</p><p>The improvements over Pentium M were many, such as AMD64 support, an additional instruction decoder and proper 128-bit vector execution units, but the one we&#39;re interested is improved micro-fusion.</p><p>In Pentium M, there were two cases where micro-fusion applied: the two parts of a store could be fused together, and memory loads could be fused together with common arithmetic operations in instructions like <code>add eax, [edx]</code>. Unfortunately, when the memory location was the <em>destination</em> operand, Pentium M could only fuse the two parts of a store. Core, however, lifted this restriction, allowing it do perform both kinds of micro-fusion at once. Thus on Core the first instruction of our loop is decoded into just <strong>two</strong> micro-operations:</p><ol><li>Load a 32-bit value from the address contained in <code>edx</code> into a temporary register, <em><strong>and</strong></em> add the value in <code>eax</code> to it, affecting flags.</li><li>Send the <em>result of the addition <strong>and</strong> the address in <code>edx</code></em> to the memory store unit.</li></ol><p>As before, the remaining three instructions were just decoded into one micro-operation each.</p><p>Verdict: things are getting murky here: &#34;add the value from a memory location to a register&#34; is not really a very RISC-like operation.</p></section><section id="sandy-bridge-branch-fusion"><h2><a href="#sandy-bridge-branch-fusion"><span>Sandy Bridge: (improved) branch fusion</span><span aria-hidden="true"> §</span></a></h2><p>2011&#39;s Sandy Bridge was the first P6-derived design based on a physical register file, finally solving the problem of permanent register read stalls that plagued P6 and its descendants up to this point. In many other ways, it was a significant yet merely evolutionary improvement over the preceding Core and Nehalem microarchitectures.</p><p>What&#39;s important to us here though is the improvements to branch fusion that Sandy Bridge introduced over its predecessors.</p><p><dfn>Branch fusion</dfn>, often called using the general term <dfn>macro-fusion</dfn> — but in all currently existing x86 processors it&#39;s restricted to branches, so I&#39;ll stick with the more precise term — is the act of fusing together a branch and a preceding arithmetic instruction, typically a comparison. In x86 it was actually first introduced in Core, but it was restricted to fusing <code>cmp</code> and <code>test</code> instructions with the immediately following conditional branch in certain cases. What we have is a regular subtraction, so Core wasn&#39;t able to fuse it.</p><p>Sandy Bridge, however, recognizes more patterns as eligible for branch fusion. Our pattern, a subtraction of an immediate from a register followed by a jump if the result was not zero, <em>is among these new patterns</em>. On Sandy Bridge and newer processors our entire loop thus decodes to <strong>four</strong> micro-operations:</p><ol><li>Load a 32-bit value from the address contained in <code>edx</code> into a temporary register, and add the value in <code>eax</code> to it, affecting flags.</li><li>Send the result of the addition and the address in <code>edx</code> to the memory store unit.</li><li>Add 4 to <code>edx</code>, affecting flags.</li><li>Subtract 1 from <code>eax</code>, affecting flags, jumping back to the start of the loop if the result is not zero.</li></ol><p>In fact, on Sandy Bridge and newer <code>sub</code> with register destination can be fused with a following branch even if the second operand is a memory location, meaning the sequence <code>sub eax, [rdx]</code> followed by <code>jz .foo</code> can be fused into a single micro-operation!</p><p>Verdict: on Sandy Bridge, and newer high-performance Intel processors, the correspondence between micro-operations and RISC instructions is completely lost. In fact, we have as many micro-operations as the &#34;complex&#34; x86 instructions we started with.</p></section><section id="what-about-others"><h2><a href="#what-about-others"><span>What about AMD processors and Intel Atoms? Or NetBurst (shudders)?</span><span aria-hidden="true"> §</span></a></h2><p>So far, this article focused entirely on P6-derived microarchitectures, but there are several other out-of-order x86 microarchitecture families enjoying, or having enjoyed, significant use: NetBurst (which was atrocious), the Intel Atom family, AMD K7/K8/K10, AMD Bobcat/Jaguar/Puma, AMD&#39;s Bulldozer family (which was as bad as NetBurst, but in different ways), and last but definitely not least AMD Zen (which I consider amazing).</p><p>Let&#39;s focus on everything on that list but NetBurst first. The reason for this grouping is simple: none of these microarchitectures ever split instructions like <code>add [edx], eax</code> into multiple micro-operations. And none of them are capable of branch-fusing a branch with a preceding subtraction — the Bulldozer and Zen families can perform branch fusion, but only <code>cmp</code> and <code>test</code> instructions are eligible. We feed all of these processor our loop of four instructions, they&#39;re going to decode it into four micro-operations, each corresponding directly to the original instruction.</p><p>As for NetBurst, it behaved very much like P6 in this regard, with the exception that stores which used addressing modes with only one input register were kept as one micro-operation, only complex addressing modes required splitting into store-data and store-address; our example loop was thus decoded to six micro-operations corresponding directly to the RISC-V code.</p></section><section id="final-verdict"><h2><a href="#final-verdict"><span>Final verdict</span><span aria-hidden="true"> §</span></a></h2><p>There is some truth to the story that x86 processors decode instructions into RISC-like form internally. This was, in fact, pretty much how P6 worked, later improvements however made the correspondence tortuous at best. Some microarchitecture families, on the other hand, never did anything of the sort, meaning it was never anywhere near a true statement for them.</p></section></article></div></div>
  </body>
</html>
