<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.rastrian.dev/post/why-reliability-demands-functional-programming-adts-safety-and-critical-infrastructure">Original</a>
    <h1>Functional programming and reliability: ADTs, safety, critical infrastructure</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote>
<p>In banking, telecom, and payments, reliability is not a nice to have. It is table stakes. The most reliable systems I have worked on reduce entire classes of bugs before the code even runs. Functional programming and Algebraic Data Types (ADTs) let you push correctness into the type system, so illegal states cannot be constructed in the first place.</p>
</blockquote>
<p><strong>What you will learn</strong></p>
<ul>
<li>How invalid states show up in real systems and why they cause costly incidents</li>
<li>How ADTs encode business rules so the compiler enforces them</li>
<li>How pattern matching and exhaustiveness checks turn refactors into safe edits</li>
<li>Practical modeling patterns for banking and telecom domains in TypeScript and OCaml</li>
<li>A migration playbook that juniors and mid-levels can apply today</li>
</ul>
<p><strong>References</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Functional_programming">Functional programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic data type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tagged_union">Tagged union or sum type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Product_type">Product type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pattern_matching">Pattern matching</a></li>
<li><a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable object</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pure_function">Pure function</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_availability">High availability</a></li>
</ul>
<hr/>
<h2>1) Reliability starts at the type system</h2>
<p>Most production incidents are not due to complex algorithms. They are due to the code entering a state that should never have been possible. If you have been on call, you have seen variants of these:</p>
<ul>
<li>Magic strings: <code>&#34;paypal&#34;</code> sneaks into a system that only supports <code>Cash</code>, <code>Card</code>, <code>Pix</code></li>
<li>Nulls: a function expects an email and receives <code>null</code> in a path you forgot to guard</li>
<li>Conflicting booleans: an account is both <code>isActive = true</code> and <code>isSuspended = true</code></li>
<li>Incomplete lifecycles: a transaction is marked <code>Pending</code> and then jumps to <code>Reversed</code> without an associated <code>Settled</code> record</li>
</ul>
<p>Functional programming helps by modeling the domain with types that make invalid states unrepresentable. Pure functions and immutability keep behavior predictable and testable.</p>
<p><img width="3840" height="2656" alt="Examples of invalid state patterns and their type-safe replacements" src="https://github.com/user-attachments/assets/7ae9252f-d4eb-47ba-9f4d-626de8a42b5b"/></p><hr/>
<h2>2) ADTs in practice: sums and products</h2>
<p>Product types combine fields, think &#34;and&#34;. Sum types choose one of several cases, think &#34;or&#34;. Together they model your domain rules.</p>
<h3>Product type example</h3>
<pre><code>(* OCaml *)
type user = {
  id    : int;
  name  : string;
  email : string option;  (* Some &#34;<a href="https://blog.rastrian.dev/cdn-cgi/l/email-protection" data-cfemail="7a1b3a1854191517">[email protected]</a>&#34; or None *)
}
</code></pre>
<pre><code>// TypeScript
type User = Readonly&lt;{
  id: number;
  name: string;
  email?: string; // we will improve this with Option next
}&gt;;
</code></pre>
<h3>Sum type example</h3>
<pre><code>(* OCaml *)
type payment =
  | Cash
  | Card of string   (* last 4 digits *)
  | Pix  of string
</code></pre>
<pre><code>// TypeScript discriminated union
type Payment =
  | { kind: &#34;cash&#34; }
  | { kind: &#34;card&#34;; last4: string }
  | { kind: &#34;pix&#34;; key: string };
</code></pre>
<p>With this shape, <code>&#34;paypal&#34;</code> cannot exist as a <code>Payment</code>. The compiler refuses the value.</p>
<p><img width="3840" height="3164" alt="Product types combine fields; sum types choose one of several variants" src="https://github.com/user-attachments/assets/2f91448d-fda6-4468-b6af-7b71dc4e1ce7"/></p><hr/>
<h2>3) Pattern matching and exhaustiveness</h2>
<p>When you pattern match on a sum type, the compiler can force you to handle every variant. If you later add a new case, every non exhaustive match becomes a compilation error or warning. This is how refactors become safe by default.</p>
<pre><code>(* OCaml *)
let describe_payment = function
  | Cash -&gt; &#34;Paid in cash&#34;
  | Card last4 -&gt; &#34;Card ••••&#34; ^ last4
  | Pix key -&gt; &#34;Pix &#34; ^ key
</code></pre>
<pre><code>// TypeScript
const assertNever = (x: never): never =&gt; { throw new Error(`Unhandled variant: ${JSON.stringify(x)}`) }

function describePayment(p: Payment): string {
  switch (p.kind) {
    case &#34;cash&#34;:  return &#34;Paid in cash&#34;
    case &#34;card&#34;:  return `Card ••••${p.last4}`
    case &#34;pix&#34;:   return `Pix ${p.key}`
    default:      return assertNever(p)
  }
}
</code></pre>
<p>Add a new <code>Crypto</code> method and both code bases will point out every place you must update.</p>
<hr/>
<h2>4) Failure scenarios and their type driven fixes</h2>
<h3>4.1 Banking example: double settlement and reconciliation drift</h3>
<p><strong>Incident story</strong></p>
<p><strong>Why it happened</strong></p>
<p><img width="3551" height="3840" alt="Allowed transitions for a transaction from Pending to Settled, Failed, or Reversed." src="https://github.com/user-attachments/assets/50e6b573-632b-49b9-8b45-cb3006db5926"/></p><p><strong>Fix with ADTs</strong></p>
<pre><code>(* OCaml *)
type failure_reason =
  | InsufficientFunds
  | ComplianceHold
  | NetworkError of string

type txn_state =
  | Pending
  | Settled  of string       (* ledger_id *)
  | Failed   of failure_reason
  | Reversed of string       (* original_ledger_id *)

type txn = {
  id           : string;
  amount_cents : int;
  state        : txn_state;
}
</code></pre>
<pre><code>// TypeScript
type FailureReason =
  | { kind: &#34;insufficientFunds&#34; }
  | { kind: &#34;complianceHold&#34; }
  | { kind: &#34;networkError&#34;; message: string }

type TxnState =
  | { kind: &#34;pending&#34; }
  | { kind: &#34;settled&#34;; ledgerId: string }
  | { kind: &#34;failed&#34;; reason: FailureReason }
  | { kind: &#34;reversed&#34;; originalLedgerId: string }

type Txn = Readonly&lt;{
  id: string
  amountCents: number
  state: TxnState
}&gt;
</code></pre>
<p>Transitions become total functions. You can return a <code>Result</code> when a transition is not allowed.</p>
<pre><code>(* OCaml *)
type &#39;a result = Ok of &#39;a | Error of string

let settle (t: txn) (ledger_id: string) : txn result =
  match t.state with
  | Pending -&gt; Ok { t with state = Settled ledger_id }
  | Settled _ -&gt; Error &#34;already settled&#34;
  | Failed _ -&gt; Error &#34;cannot settle a failed transaction&#34;
  | Reversed _ -&gt; Error &#34;cannot settle a reversed transaction&#34;
</code></pre>
<pre><code>// TypeScript
type Ok&lt;T&gt;  = { _tag: &#34;Ok&#34;; value: T }
type Err&lt;E&gt; = { _tag: &#34;Err&#34;; error: E }
type Result&lt;T, E&gt; = Ok&lt;T&gt; | Err&lt;E&gt;
const Ok = &lt;T&gt;(value: T): Result&lt;T, never&gt; =&gt; ({ _tag: &#34;Ok&#34;, value })
const Err = &lt;E&gt;(error: E): Result&lt;never, E&gt; =&gt; ({ _tag: &#34;Err&#34;, error })

function settle(t: Txn, ledgerId: string): Result&lt;Txn, string&gt; {
  switch (t.state.kind) {
    case &#34;pending&#34;:  return Ok({ ...t, state: { kind: &#34;settled&#34;, ledgerId } })
    case &#34;settled&#34;:  return Err(&#34;already settled&#34;)
    case &#34;failed&#34;:   return Err(&#34;cannot settle a failed transaction&#34;)
    case &#34;reversed&#34;: return Err(&#34;cannot settle a reversed transaction&#34;)
  }
}
</code></pre>
<p>Now the illegal transitions are blocked by construction. Test coverage still matters, but the shape of the model prevents a class of bugs.</p>
<p><strong>Refactor safety</strong></p>
<pre><code>type TxnState =
  | { kind: &#34;pending&#34; }
  | { kind: &#34;settled&#34;; ledgerId: string }
  | { kind: &#34;failed&#34;; reason: FailureReason }
  | { kind: &#34;reversed&#34;; originalLedgerId: string }
  | { kind: &#34;chargeback&#34;; networkRef: string } // new
</code></pre>
<p>Every <code>switch</code> on <code>TxnState</code> now requires a <code>chargeback</code> branch. This is free guidance from the compiler.</p>
<hr/>
<h3>4.2 Telecom example: ghost billing and incomplete sessions</h3>
<p><strong>Incident story</strong></p>
<p><strong>Why it happened</strong></p>
<p><img width="2823" height="3840" alt="Call session lifecycle; only Completed produces a billable duration" src="https://github.com/user-attachments/assets/11b13d23-b793-483c-abcc-2ee9f96e6913"/></p><p><strong>Fix with ADTs</strong></p>
<pre><code>(* OCaml *)
type drop_reason = Network | Busy | Timeout

type call =
  | Dialing   of int                   (* at_ms *)
  | Connected of int                   (* started_ms *)
  | Dropped   of drop_reason * int     (* reason, at_ms *)
  | Completed of int * int             (* started_ms, ended_ms *)

let billable_seconds = function
  | Completed (start_ms, end_ms) -&gt; max 0 (end_ms - start_ms) / 1000
  | _ -&gt; 0
</code></pre>
<pre><code>// TypeScript
type DropReason = &#34;network&#34; | &#34;busy&#34; | &#34;timeout&#34;

type Call =
  | { kind: &#34;dialing&#34;;   atMs: number }
  | { kind: &#34;connected&#34;; startedMs: number }
  | { kind: &#34;dropped&#34;;   reason: DropReason; atMs: number }
  | { kind: &#34;completed&#34;; startedMs: number; endedMs: number }

const billableSeconds = (c: Call): number =&gt; {
  switch (c.kind) {
    case &#34;completed&#34;: return Math.max(0, (c.endedMs - c.startedMs) / 1000)
    default:          return 0
  }
}
</code></pre>
<p>Now a connected but never completed call cannot produce a billable duration. The shape forbids the bug.</p>
<hr/>
<h3>4.3 Config parsing example: hidden NaN and partial failures</h3>
<p><strong>Incident story</strong></p>
<p><strong>Fix with Result types</strong></p>
<pre><code>(* OCaml *)
type &#39;a result = Ok of &#39;a | Error of string

let parse_int (s: string) : int result =
  try Ok (int_of_string s) with _ -&gt; Error &#34;invalid int&#34;

let load_ttl () : int option =
  match Sys.getenv_opt &#34;CACHE_TTL_SECS&#34; with
  | None -&gt; None
  | Some s -&gt;
    match parse_int s with
    | Ok n -&gt; Some n
    | Error _ -&gt; None  (* or propagate the error *)
</code></pre>
<pre><code>// TypeScript
const parseIntR = (s: string): Result&lt;number, &#34;invalid-int&#34;&gt; =&gt;
  /^-?\d+$/.test(s) ? Ok(Number(s)) : Err(&#34;invalid-int&#34;)

function loadTtl(): Option&lt;number&gt; {
  const raw = process.env.CACHE_TTL_SECS
  if (!raw) return None
  const parsed = parseIntR(raw)
  return parsed._tag === &#34;Ok&#34; ? Some(parsed.value) : None
}
</code></pre>
<p>The ambiguity disappears. The code must handle absence and parse errors explicitly.</p>
<hr/>
<h2>5) Options and Results as first class tools</h2>
<p>Do not use <code>null</code> to mean &#34;maybe&#34;. Do not throw exceptions for expected errors.</p>
<p><img width="2810" height="3840" alt="Control flow using Option and Result instead of nulls or thrown errors" src="https://github.com/user-attachments/assets/553fbcc7-434a-42bd-9bfd-0def7d464570"/></p><h3>Option or Maybe</h3>
<pre><code>(* OCaml *)
type user = { id: int; email: string option }

let send_mail (u: user) =
  match u.email with
  | Some e -&gt; (* send e *) ()
  | None   -&gt; ()
</code></pre>
<pre><code>// TypeScript
type None = { _tag: &#34;None&#34; }
type Some&lt;T&gt; = { _tag: &#34;Some&#34;; value: T }
type Option&lt;T&gt; = None | Some&lt;T&gt;
const None: None = { _tag: &#34;None&#34; }
const Some = &lt;T&gt;(value: T): Option&lt;T&gt; =&gt; ({ _tag: &#34;Some&#34;, value })

const map = &lt;A, B&gt;(o: Option&lt;A&gt;, f: (a: A) =&gt; B): Option&lt;B&gt; =&gt;
  o._tag === &#34;Some&#34; ? Some(f(o.value)) : None
</code></pre>
<h3>Result or Either</h3>
<pre><code>(* OCaml *)
let result_map f = function
  | Ok x -&gt; Ok (f x)
  | Error e -&gt; Error e
</code></pre>
<pre><code>// TypeScript
type Ok&lt;T&gt;  = { _tag: &#34;Ok&#34;; value: T }
type Err&lt;E&gt; = { _tag: &#34;Err&#34;; error: E }
type Result&lt;T, E&gt; = Ok&lt;T&gt; | Err&lt;E&gt;
const Ok  = &lt;T&gt;(value: T): Result&lt;T, never&gt; =&gt; ({ _tag: &#34;Ok&#34;, value })
const Err = &lt;E&gt;(error: E): Result&lt;never, E&gt; =&gt; ({ _tag: &#34;Err&#34;, error })
</code></pre>
<p>These types make the happy path and the error path equally explicit.</p>
<hr/>
<h2>6) Immutability and why it simplifies reasoning</h2>
<p>Mutable shared state is a common source of heisenbugs under concurrency. Prefer immutable data and pure functions. When you need to update, create a new value.</p>
<pre><code>(* OCaml *)
let set_email (u: user) (e: string option) : user =
  { u with email = e }
</code></pre>
<pre><code>// TypeScript
type User = Readonly&lt;{ id: number; name: string; email: Option&lt;string&gt; }&gt;

const setEmail = (u: User, email: Option&lt;string&gt;): User =&gt;
  ({ ...u, email })
</code></pre>
<p>Your tests become simple. Given the same inputs, the function returns the same output.</p>
<hr/>
<h2>7) Smart constructors and newtypes to protect units and invariants</h2>
<p>Numbers are not self describing. Create types that carry meaning.</p>
<p><img width="3840" height="2990" alt="Branded types prevent mixing incompatible numeric units" src="https://github.com/user-attachments/assets/527ccd47-66a2-45fb-9377-a848fd5e4d9f"/></p><pre><code>(* OCaml *)
module Cents : sig
  type t
  val make : int -&gt; t            (* reject negatives *)
  val add  : t -&gt; t -&gt; t
end = struct
  type t = Cents of int
  let make x = if x &lt; 0 then invalid_arg &#34;negative cents&#34; else Cents x
  let add (Cents a) (Cents b) = Cents (a + b)
end
</code></pre>
<pre><code>// TypeScript
type Brand&lt;K, T&gt; = K &amp; { __brand: T }

type Cents = Brand&lt;number, &#34;Cents&#34;&gt;
const Cents = (n: number): Cents =&gt; {
  if (!Number.isInteger(n) || n &lt; 0) throw new Error(&#34;invalid cents&#34;)
  return n as Cents
}

type Millis = Brand&lt;number, &#34;Millis&#34;&gt;
const Millis = (n: number): Millis =&gt; n as Millis

const price: Cents = Cents(500)
// const wrong: Cents = Millis(500)  // type error
</code></pre>
<p>You stop mixing milliseconds with seconds or dollars with cents by accident.</p>
<hr/>
<h2>8) Pure core, effectful shell</h2>
<p>Keep the domain logic pure and push IO to the edges. This makes unit tests cheap and fast.</p>
<p><img width="3840" height="1676" alt="Layered architecture diagram showing Shell IO nodes DB, HTTP, Queue flowing into Ports Adapters impure, then into Core Pure Domain with authorize_payment a b to bool and txn_state to Result, arrows left to right." src="https://github.com/user-attachments/assets/01d898e0-fa23-442c-8529-7d2a662fe50f"/></p><pre><code>(* OCaml, pure core *)
let authorize_payment (amount: Cents.t) (balance: Cents.t) : bool =
  amount &lt;= balance  (* assume a comparison helper inside the module *)

(* impure shell *)
let run () =
  let amount = Cents.make 500 in
  let balance = Cents.make 1200 in
  if authorize_payment amount balance then
    (* call database and payment gateway here *) ()
</code></pre>
<pre><code>// TypeScript, pure core
const authorizePayment = (amount: Cents, balance: Cents): boolean =&gt; {
  return (amount as unknown as number) &lt;= (balance as unknown as number)
}

// effectful shell
async function run() {
  const amount = Cents(500)
  const balance = Cents(1200)
  if (authorizePayment(amount, balance)) {
    // perform DB writes or API calls here
  }
}
</code></pre>
<hr/>
<h2>9) Migration playbook</h2>
<p>Start small and make continuous progress. Here is a practical order for a team new to these ideas.</p>
<ol>
<li>
<p>Replace pairs of booleans with a sum type</p>
<ul>
<li>Before: <code>{ isActive: boolean; isSuspended: boolean }</code></li>
<li>After: <code>type AccountState = { kind: &#34;active&#34; } | { kind: &#34;suspended&#34; } | { kind: &#34;closed&#34; }</code></li>
</ul>
</li>
<li>
<p>Replace string enums with discriminated unions</p>
<ul>
<li>Avoid free form strings like <code>&#34;pending&#34; | &#34;settled&#34; | &#34;failed&#34; | string</code></li>
</ul>
</li>
<li>
<p>Replace nullable fields with Option</p>
<ul>
<li>OCaml <code>string option</code></li>
<li>TypeScript <code>Option&lt;string&gt;</code> or a stricter domain specific union</li>
</ul>
</li>
<li>
<p>Replace thrown control flow with Result</p>
<ul>
<li>Reserve exceptions for truly unexpected situations</li>
</ul>
</li>
<li>
<p>Introduce newtypes or branded types for units and ids</p>
<ul>
<li>Prevent mixing <code>Millis</code> with <code>Seconds</code>, <code>Cents</code> with <code>Dollars</code></li>
</ul>
</li>
<li>
<p>Enforce exhaustiveness</p>
<ul>
<li>OCaml already warns</li>
<li>TypeScript: discriminated unions, <code>assertNever</code>, <code>strictNullChecks</code>, <code>noImplicitReturns</code></li>
</ul>
</li>
<li>
<p>Add guard rails in CI</p>
<ul>
<li>Treat TypeScript non exhaustive switches and OCaml warnings as errors</li>
</ul>
</li>
</ol>
<p><strong>Smells to look for</strong></p>
<ul>
<li>Multiple booleans that can be true at the same time</li>
<li>Strings that travel far before being validated</li>
<li>Functions that sometimes return a value and sometimes throw</li>
<li>Types that carry numbers without units</li>
</ul>
<p><img width="3043" height="3840" alt="Numbered flowchart checklist for migration from strings and nulls to ADTs Option Result with six steps from booleans to union through enforcing exhaustiveness" src="https://github.com/user-attachments/assets/c6fea9cb-e223-41af-85ed-188f300a0b1d"/></p><hr/>
<h2>10) Performance and ergonomics</h2>
<p>Pattern matching compiles to simple branches. Discriminated unions in TypeScript are just plain objects. The main cost you will feel is validation at the boundaries in smart constructors. This is a trade worth making. The compiler then protects the interior of the system.</p>
<hr/>
<h2>Conclusion</h2>
<p>Reliability is designed. With Algebraic Data Types, pattern matching, Option and Result, immutability, and smart constructors, you encode domain rules directly in your types. Illegal states cannot compile. This is why industries that cannot afford failure, such as banking and telecom, gravitate to functional ideas.</p>
<p>If you work on code that touches money, minutes, or public availability, adopt these patterns now.</p>
<ul>
<li>Model workflows with sum types, not conflicting flags</li>
<li>Use Option and Result instead of nullable and throwable APIs</li>
<li>Keep a pure core with effects at the edges</li>
<li>Brand units and identifiers</li>
<li>Enforce exhaustiveness during code review and in CI</li>
</ul>
<p>Your on call shifts will be quieter, and your users will notice the difference.</p>
<hr/>
<h2>Further reading</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Functional_programming">Functional programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic data type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tagged_union">Tagged union or sum type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Product_type">Product type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pattern_matching">Pattern matching</a></li>
<li><a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable object</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pure_function">Pure function</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_availability">High availability</a></li>
</ul>
<hr/>
<h3>Appendix: paste ready helpers</h3>
<pre><code>// TypeScript Option and Result
export type None = { _tag: &#34;None&#34; }
export type Some&lt;T&gt; = { _tag: &#34;Some&#34;; value: T }
export type Option&lt;T&gt; = None | Some&lt;T&gt;
export const None: None = { _tag: &#34;None&#34; }
export const Some = &lt;T&gt;(value: T): Option&lt;T&gt; =&gt; ({ _tag: &#34;Some&#34;, value })

export type Ok&lt;T&gt;  = { _tag: &#34;Ok&#34;; value: T }
export type Err&lt;E&gt; = { _tag: &#34;Err&#34;; error: E }
export type Result&lt;T, E&gt; = Ok&lt;T&gt; | Err&lt;E&gt;
export const Ok  = &lt;T&gt;(value: T): Result&lt;T, never&gt; =&gt; ({ _tag: &#34;Ok&#34;, value })
export const Err = &lt;E&gt;(error: E): Result&lt;never, E&gt; =&gt; ({ _tag: &#34;Err&#34;, error })

export const assertNever = (x: never): never =&gt; { throw new Error(`Unhandled variant: ${JSON.stringify(x)}`) }
</code></pre>
<pre><code>(* OCaml Option and Result helpers *)
let option_map f = function
  | None -&gt; None
  | Some x -&gt; Some (f x)

let option_value ~default = function
  | None -&gt; default
  | Some x -&gt; x

let result_map f = function
  | Ok x -&gt; Ok (f x)
  | Error e -&gt; Error e
</code></pre>
</div></div>
  </body>
</html>
