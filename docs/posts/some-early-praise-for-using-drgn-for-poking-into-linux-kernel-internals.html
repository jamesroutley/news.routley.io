<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/linux/DrgnKernelPokingPraise">Original</a>
    <h1>Some early praise for using drgn for poking into Linux kernel internals</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Some early praise for using drgn for poking into Linux kernel internals</h2>

	<p><small>May  5, 2023</small></p>
</div><div><p>I&#39;ve been keeping my eyes on <a href="https://drgn.readthedocs.io/en/latest/index.html">drgn</a> (<a href="https://github.com/osandov/drgn">repository</a>, <a href="https://lwn.net/Articles/789641/">2019 LWN article</a>) for some time, because it held
promise for being a better way to poke around your Linux kernel
than the venerable <a href="https://man7.org/linux/man-pages/man8/crash.8.html">crash(8)</a> program (which
I&#39;ve actually used in anger, and it was a lot of work). Today, for
the first time, I got around to using drgn and the experience was
broadly positive.</p>

<p>I used drgn on an Ubuntu 22.04 <a href="https://utcc.utoronto.ca/~cks/space/blog/linux/ZFSFileserverSetupIII">test NFS server</a>,
by creating a Python 3 venv, installing drgn into the venv, and
then running it from there (after installing the necessary kernel
debugging information from Ubuntu); this worked fine and &#39;drgn&#39;
gave me a nice interactive Python environment where with minimal
knowledge of drgn itself I could poke around the kernel. Specifically,
<a href="https://mastodon.social/@cks/110316823642495251">I could poke into the various data structures maintained by the
kernel NFS NLM system</a>,
with the goal of being able to see which NFS client owned each NFS
lock on the server (or in this case, a lock, since it was a test
server and I established only a single lock to it for simplicity).</p>

<p>Drgn in interactive mode works quite well for this sort of exploration
for a number of reasons. To start with it does a remarkably good
job of pretty-printing structures (and arrays) with type and content
information of all of the fields. Simply being able to see the
contents of various things (and type information for pointers) led
me to make some useful discoveries. However, sometimes you&#39;ll be
confronted with things like this:</p>

<blockquote><pre>&gt;&gt;&gt; prog[&#39;nlm_files&#39;]
(struct hlist_head [128]){
[...]
  {
    .first = (struct hlist_node *)0xffff8974099ae600,
  },
</pre>
</blockquote>

<p>This is a message from drgn to you that you&#39;re going to be reading
some kernel source code and kernel headers in order to figure out
your next step. The good news is that drgn supports all of the
kernel&#39;s normal ways of traversing these sorts of data structures,
in a way that&#39;s very similar to the kernel&#39;s own code for it, to
the point where an outsider like me can translate back and forth.
For instance, if you have kernel code that looks like:</p>

<blockquote><pre>hlist_for_each_entry_safe(file, next, &amp;nlm_files[i], f_list) {
</pre>
</blockquote>

<p>Then the drgn equivalent you want (hard-coding the index by
experimentation because this is exploration):</p>

<blockquote><pre>&gt;&gt;&gt; r = list( hlist_for_each_entry(&#39;struct nlm_file&#39;, prog[&#39;nlm_files&#39;][6].address_of_(), &#39;f_list&#39;) )
&gt;&gt;&gt; r
[Object(prog, &#39;struct nlm_file *&#39;, value=0xffff8974099ae600)]
</pre>
</blockquote>

<p>(We use <code>list()</code> for the usual Python reason that drgn&#39;s helper
function returns a Python generator, and we want to poke at the
actual results in a simple way. Also, technically these are in
drgn.helpers.linux, which you may want to import specifically so
you can read the help text for. Or see <a href="https://drgn.readthedocs.io/en/latest/user_guide.html">the user guide</a> and <a href="https://drgn.readthedocs.io/en/latest/helpers.html">the
section on helpers</a>.)</p>

<p>You&#39;ll also need to read kernel source code and kernel headers in
order to <a href="https://mastodon.social/@cks/110317019840335032">dig your way through the kernel data structures to what
you want</a>. Drgn
won&#39;t (and can&#39;t) tell you how NLM data structures are linked
together and how you can go from, for example, the global &#39;<code>nlm_files</code>&#39;
to the &#39;<code>struct nlm_host</code>&#39; that tells you the NFS client that got
a particular lock. The path can be quite convoluted (<a href="https://mastodon.social/@cks/110317495214509757">cf</a>).</p>

<p>The good news is that if the kernel can do it, drgn probably can
do it too, although it may take you quite a bit of digging and
persistence to get there. The further good news is that if you can
do it in drgn&#39;s interactive mode, even painfully and with many
mis-steps, you can probably turn your worked out process into Python
code that uses drgn. Although <a href="https://mastodon.social/@cks/110317899106692511">I (temporarily) turned to other
tools for now</a>,
being able to explore and test ideas with drgn was essential to
getting there. Now that I&#39;ve used drgn for this, I&#39;ll likely to be
turning to it for similar explorations and information extraction
in the future.</p>

<p>In addition to needing to know Python and be able to read kernel
code and headers, drgn&#39;s other drawback is that you need kernel
debugging information, and on most Linuxes these days that&#39;s not
installed by default. Installing it may be a bit annoying and it&#39;s
generally rather big; <a href="https://drgn.readthedocs.io/en/latest/getting_debugging_symbols.html">drgn&#39;s documentation has a guide</a>.
This means that drgn doesn&#39;t work out of the box the way tools like
bpftrace do.</p>

<p>(It would be great if drgn could use the kernel&#39;s <a href="https://www.kernel.org/doc/html/latest/bpf/btf.html">BPT Type Format
(BTF)</a>
information, which bpftrace and other eBPF tools already use, but
apparently there are various obstacles. I believe that drgn is
tracking this in <a href="https://github.com/osandov/drgn/issues/176">DWARFless Debugging #176</a>.)</p>
</div></div>
  </body>
</html>
