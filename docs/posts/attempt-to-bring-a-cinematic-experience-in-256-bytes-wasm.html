<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ilmenit/sizecoding/blob/main/Encounter/Encounter.md">Original</a>
    <h1>Show HN: Attempt to bring a cinematic experience in 256 bytes (WASM)</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text">

<p dir="auto">Attempt to bring a cinematic experience in 256 bytes.</p>

<p dir="auto">You can watch it on YouTube (recommended to select 720p60 quality)</p>
<p dir="auto"><a href="https://www.youtube.com/watch?v=4QY9WqbS61g" rel="nofollow"><img src="https://camo.githubusercontent.com/9bc889feac1f761da8144266b214b7a084783d51a6931b916cc7ae76b9363f70/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f34515939577162533631672f6d617872657364656661756c742e6a7067" alt="Watch the video" data-canonical-src="https://img.youtube.com/vi/4QY9WqbS61g/maxresdefault.jpg"/></a></p>
<p dir="auto">or click the following link if you have the FireFox browser (Chrome’s implementation of WebAssembly has much worse performance). Mobile Firefox should also work well on relatively new mobile phones. The 256 bytes are encoded in the URL:</p>
<p dir="auto"><a href="https://exoticorn.github.io/microw8/v0.2.2/#AgMvvqs+jH95brXMAYjUjZwn1apTrm62ncvO+qq+kAesx0vh5NB3sa3YEg8JasHVk0OOFeN09Qi/yWyEuuIHweJv5+qt4lQhS0q/exKHo4rtSsnqkY7oWUwXXgbWfGEwKrTto4wxOG4JXZck7ehBB9YHmyanOZxFZeCkpib2M/JXhCmCfPb3mF6tq++ZG2Mm73NopaaKwUFHm2KjpEjYFMEzCZsu98uZmvhD5GzCUXSw8G5Z1V8nfv9uiIQ1+5N+rcjpFezbIXG5/haUR7Lnre3xZVJcp+I6rXkboKqK6SoG5h92w/jndB3sdZyT4G9Lq872lkEkUIM7ciqdsyYJMg==" rel="nofollow">https://exoticorn.github.io/microw8/v0.2.2/#AgMvvqs+jH95brXMAYjUjZwn1apTrm62ncvO+qq+kAesx0vh5NB3sa3YEg8JasHVk0OOFeN09Qi/yWyEuuIHweJv5+qt4lQhS0q/exKHo4rtSsnqkY7oWUwXXgbWfGEwKrTto4wxOG4JXZck7ehBB9YHmyanOZxFZeCkpib2M/JXhCmCfPb3mF6tq++ZG2Mm73NopaaKwUFHm2KjpEjYFMEzCZsu98uZmvhD5GzCUXSw8G5Z1V8nfv9uiIQ1+5N+rcjpFezbIXG5/haUR7Lnre3xZVJcp+I6rXkboKqK6SoG5h92w/jndB3sdZyT4G9Lq872lkEkUIM7ciqdsyYJMg==</a></p>
<p dir="auto">I personally love seeing creative process of the others (“making of”) and If you are interested in the steps I went through to create this intro, check the following recording:</p>
<p dir="auto"><a href="https://youtu.be/X-g7d5NUV2s" rel="nofollow"><img src="https://camo.githubusercontent.com/805d6a6fd65543c60d261a3b37f6337f48af1ccc8f850133abee374b7c3f7949/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f582d673764354e555632732f6d7164656661756c742e6a7067" alt="Watch the video" data-canonical-src="https://img.youtube.com/vi/X-g7d5NUV2s/mqdefault.jpg"/></a></p>

<p dir="auto">I love intellectual challenges, art, computer science and in May 2024 there was another <a href="https://outlinedemoparty.nl" rel="nofollow">Outline demoscene party</a> with size-coding competition. I did some 256 byte intros in the past (like drawing <strong><a href="https://www.pouet.net/prod.php?which=62917" rel="nofollow">Mona Lisa</a></strong> for 6502 8bit Atari, ported to a <a href="https://codegolf.stackexchange.com/questions/126738/lets-draw-mona-lisa" rel="nofollow">crazy number of platforms</a> or <strong><a href="https://www.pouet.net/prod.php?which=91578" rel="nofollow">Thrive</a></strong> for TIC-80 showing a <a href="https://youtu.be/qU5EGLvFXd8" rel="nofollow">growing tree through the seasons</a>), so I decided to join the competition once again.</p>
<p dir="auto">If you don’t know what a demoscene is, it’s a computer subculture with roots in Europe <a href="https://en.wikipedia.org/wiki/Demoscene" rel="nofollow">https://en.wikipedia.org/wiki/Demoscene</a> similar to <a href="https://hackaday.com/2022/06/06/outline-2022-everyone-should-go-to-a-demo-party/" rel="nofollow">Hacker Camps</a>.</p>
<p dir="auto">A large collection of demoscene productions you can find on <a href="https://demozoo.org/" rel="nofollow">https://demozoo.org</a> or <a href="https://www.pouet.net/" rel="nofollow">https://www.pouet.net</a></p>

<p dir="auto">The intro is done for <a href="https://exoticorn.github.io/microw8" rel="nofollow">MicroW8</a> platform, which is a <a href="https://en.wikipedia.org/wiki/Fantasy_video_game_console" rel="nofollow">Fantasy Console</a> similar to <a href="https://www.lexaloffle.com/pico-8.php" rel="nofollow">PICO-8</a>, <a href="https://tic80.com/" rel="nofollow">TIC-80</a> or <a href="https://wasm4.org" rel="nofollow">WASM-4</a>.</p>
<p dir="auto">MicroW8 has capabilities close to DOS-era machines (16 bit real-mode x86 with FPU and VGA):</p>
<ul dir="auto">
<li>Screen: 320x240, 256 colors, 60Hz, customizable palette.</li>
<li>Memory: 256KB</li>
</ul>
<p dir="auto">but with a MUCH faster CPU powered by WebAssembly (therefore more like running nowadays <a href="https://www.freedos.org" rel="nofollow">FreeDOS</a> on a modern PC).</p>
<p dir="auto">Important note: the compiled “virtual cartridge” is compressed, therefore 256 bytes is not equal to 256 bytes of WASM code. The WASM code needs to be interconnected with the MicroW8 platform and the compression negates this overhead, leading to (according to sizecoding gurus) “code density” in 256 bytes similar to uncompressed x86/FPU code. The compression brings more benefits the bigger the code/data is, however in x86 you can also make tiny code decompressors, that you cannot do easily in WebAssembly due to executable code space separation, therefore for size-constrained programming DOS with x86 and <a href="http://www.sizecoding.org/wiki/DOS" rel="nofollow">all the tricks it offers</a> can still be the king.</p>

<p dir="auto">WebAssembly is a stack-based virtual machine, which makes it easy to represent as an Abstract Syntax Tree or… in infix syntax. That’s the idea behind <a href="https://github.com/exoticorn/curlywas">CurlyWAS language</a>, that compiles Rust-like syntax into a WASM code.</p>
<p dir="auto">CurlyWAS has ability to use keywords like “inline” (expression is evaluated every time, works similarly to C’s #define), or “lazy” (which uses the local.tee instruction which combines local.set and local.get and therefore saves on bytes).</p>
<p dir="auto">In WebAssembly the 32bit integers are encoded in <a href="https://en.wikipedia.org/wiki/LEB128" rel="nofollow">LEB128 format</a> and CurlyWAS has sugar syntax of adding _f to a constant to convert integer to 32bit float:</p>
<p dir="auto">(320_f) is equal to (320 as f32)</p>
<div data-snippet-clipboard-copy-content="include &#34;include/microw8-api.cwa&#34;

export fn upd() {

  let fx: f32;
  let prev_wave_height: f32;
  let inline t: f32 = time();

  let inline screen_width = 320_f;
  let inline screen_height = 240_f; // 256_f shorter but bit slower

  loop xloop {
  
    let fy: f32 = 0_f;      
    loop yloop {

      // define the vanishing point coordinates
      let inline vp_x: f32 = 160_f; // center of the screen
      let inline vp_y: f32 = 120.5; // horizon, +0.5 to avoid div by 0

      // define the distance
      let inline d: f32 = 160_f; 

      // calculate the distance from the center
      let inline cx: f32 = vp_x - fx; 
      let inline cy: f32 = vp_y - fy; 
    
      // calculate the angle mapping
      let inline nx: f32 = cx / 2_f / cy; 
      let inline ny: f32 =  d * 2_f / cy;
    
      // A variable to store the total height
      let wave_height = cos(fx*fy)*max(0_f,t-80_f); // matrix-like effect at the end
    
      // Calculate the height of the superposition of waves at a given position and time
      let i: f32=0_f;
    
      // select either water or sky
      let inline iterations: f32 = select(fy&lt;120_f,4_f,16_f);
    
      loop wave_iterations {    
      
        let inline amplitude = i/40_f;
        let inline frequency = 2_f+cos(i);
        let inline phase = cos(i*i);
        // dx and dy are the components of the direction of the wave
        let inline dx = sin(i*i); // serves as PRNG
        let inline dy = cos(i*i*i); // serves as PRNG
        let inline time_shift = t/14_f*iterations;
    
        wave_height -= amplitude * (abs(sin(frequency * (ny * dy + nx * dx) + time_shift + phase)));        
    
        branch_if (i := i + 1_f) &lt; iterations: wave_iterations; 
      }
      let inline dist = sqrt(cx*cx + cy*cy);    
      
      // how big are waves in time
      let inline wave_scale = min(2_f*t,40_f);        
      let inline perspective_height = wave_height * wave_scale * cy / d;   
    
      // minimalistic water reflection+refraction
      let inline h_color: f32 = 1_f-abs(perspective_height-prev_wave_height)/6_f;      
    
      // alien blob/ship
      let inline radius = min(2_f*t-70_f,50_f); 
      let inline blob_color = dist/radius;
      let inline color: f32 = select(dist&lt;radius,blob_color,h_color);
      
      // add cinematic vignette effect (dist) with a bit of fresnel effect (cy)
      let inline p_color = max(0_f,color+(cy-dist)/512_f);
    
      // draw lines also for blob to imitate reflection
      line(fx, fy + perspective_height, fx, fy + prev_wave_height, (255_f*p_color) as i32);
      prev_wave_height = perspective_height;
    
      branch_if (fy := fy + 1_f) &lt; screen_height: yloop;
    }   
    
    // set ocean palette with a bit of yellow tint
    let inline index = (fx as i32) % 128;
    let inline i = 4*index;
    i!0x13000 =  0x030200*(index/4);
    i!0x13200 =  0x020304*(index/2)+0x604000;
    
    branch_if (fx := fx + 1_f) &lt; screen_width: xloop;   
  } 
}"><pre><code>include &#34;include/microw8-api.cwa&#34;

export fn upd() {

  let fx: f32;
  let prev_wave_height: f32;
  let inline t: f32 = time();

  let inline screen_width = 320_f;
  let inline screen_height = 240_f; // 256_f shorter but bit slower

  loop xloop {
  
    let fy: f32 = 0_f;      
    loop yloop {

      // define the vanishing point coordinates
      let inline vp_x: f32 = 160_f; // center of the screen
      let inline vp_y: f32 = 120.5; // horizon, +0.5 to avoid div by 0

      // define the distance
      let inline d: f32 = 160_f; 

      // calculate the distance from the center
      let inline cx: f32 = vp_x - fx; 
      let inline cy: f32 = vp_y - fy; 
    
      // calculate the angle mapping
      let inline nx: f32 = cx / 2_f / cy; 
      let inline ny: f32 =  d * 2_f / cy;
    
      // A variable to store the total height
      let wave_height = cos(fx*fy)*max(0_f,t-80_f); // matrix-like effect at the end
    
      // Calculate the height of the superposition of waves at a given position and time
      let i: f32=0_f;
    
      // select either water or sky
      let inline iterations: f32 = select(fy&lt;120_f,4_f,16_f);
    
      loop wave_iterations {    
      
        let inline amplitude = i/40_f;
        let inline frequency = 2_f+cos(i);
        let inline phase = cos(i*i);
        // dx and dy are the components of the direction of the wave
        let inline dx = sin(i*i); // serves as PRNG
        let inline dy = cos(i*i*i); // serves as PRNG
        let inline time_shift = t/14_f*iterations;
    
        wave_height -= amplitude * (abs(sin(frequency * (ny * dy + nx * dx) + time_shift + phase)));        
    
        branch_if (i := i + 1_f) &lt; iterations: wave_iterations; 
      }
      let inline dist = sqrt(cx*cx + cy*cy);    
      
      // how big are waves in time
      let inline wave_scale = min(2_f*t,40_f);        
      let inline perspective_height = wave_height * wave_scale * cy / d;   
    
      // minimalistic water reflection+refraction
      let inline h_color: f32 = 1_f-abs(perspective_height-prev_wave_height)/6_f;      
    
      // alien blob/ship
      let inline radius = min(2_f*t-70_f,50_f); 
      let inline blob_color = dist/radius;
      let inline color: f32 = select(dist&lt;radius,blob_color,h_color);
      
      // add cinematic vignette effect (dist) with a bit of fresnel effect (cy)
      let inline p_color = max(0_f,color+(cy-dist)/512_f);
    
      // draw lines also for blob to imitate reflection
      line(fx, fy + perspective_height, fx, fy + prev_wave_height, (255_f*p_color) as i32);
      prev_wave_height = perspective_height;
    
      branch_if (fy := fy + 1_f) &lt; screen_height: yloop;
    }   
    
    // set ocean palette with a bit of yellow tint
    let inline index = (fx as i32) % 128;
    let inline i = 4*index;
    i!0x13000 =  0x030200*(index/4);
    i!0x13200 =  0x020304*(index/2)+0x604000;
    
    branch_if (fx := fx + 1_f) &lt; screen_width: xloop;   
  } 
}
</code></pre></div>
</article></div></section></div></div></div></div>
  </body>
</html>
