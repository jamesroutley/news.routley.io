<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eugeneyan.com/writing/recsys-llm/">Original</a>
    <h1>Improving recommendation systems and search in the age of LLMs</h1>
    
    <div id="readability-page-1" class="page"><div>
            



<!--https://docs.mathjax.org/en/latest/input/tex/delimiters.html-->

<p>Recommendation systems and search have historically drawn inspiration from language modeling. For example, the adoption of <a href="https://arxiv.org/abs/2009.12192" target="_blank">Word2vec</a> to learn item embeddings (for embedding-based retrieval), and using <a href="https://arxiv.org/abs/1511.06939" target="_blank">GRUs</a>, <a href="https://arxiv.org/abs/1905.06874" target="_blank">Transformer</a>, and <a href="https://arxiv.org/abs/1904.06690" target="_blank">BERT</a> to predict the next best item (for ranking). The current paradigm of large language models is no different.</p>

<p>Here, we’ll discuss how industrial search and recommendation systems have evolved over the past year or so and cover model architectures, data generation, training paradigms, and unified frameworks:</p>
<ul>
  <li><a href="#llmmultimodality-augmented-model-architecture">LLM/multimodality-augmented model architecture</a></li>
  <li><a href="#llm-assisted-data-generation-and-analysis">LLM-assisted data generation and analysis</a></li>
  <li><a href="#scaling-laws-transfer-learning-distillation-loras">Scaling Laws, transfer learning, distillation, LoRAs, etc.</a></li>
  <li><a href="#unified-architectures-for-search-and-recommendations">Unified architectures for search and recommendations</a></li>
</ul>

<h2 id="llmmultimodality-augmented-model-architecture">LLM/multimodality-augmented model architecture</h2>

<p>Recommendation models are increasingly adopting language models and multimodal content to overcome traditional limitations of ID-based approaches. These hybrid architectures include content understanding alongside the strengths of behavioral modeling, addressing the common challenges of cold-start and long-tail item recommendations.</p>

<p><strong><a href="https://arxiv.org/abs/2306.08121" target="_blank">Semantic IDs (YouTube)</a> explores content-derived features as substitutes for traditional hash-based IDs.</strong> This approach targets difficulties in predicting user preferences for new and infrequently interacted items. Their solution involves a two-stage framework.</p>

<p>In the first stage, a transformer-based video encoder (similar to Video-BERT) generates dense content embeddings. These embeddings are then compressed into discrete Semantic IDs through a Residual Quantization Variational AutoEncoder (RQ-VAE). Representing user histories with these compact semantic IDs—a few integers rather than high-dimensional embeddings—significantly improves efficiency. Once trained, the RQ-VAE is frozen and used to generate Semantic IDs for the second stage to train a production-scale ranking model.</p>

<p>The RQ-VAE itself is a single-layer encoder-decoder structure with a 256-dimensional latent space. It has eight quantization levels with a codebook of 2048 entries per level. The encoder maps content embeddings to a latent vector, while a residual quantizer discretizes this vector, and the decoder reconstructs the original embedding. The initial embeddings originate from a transformer with a VideoBERT backbone, producing detailed, 2048-dimensional representations that capture the topical content in video.</p>

<p><img src="https://jamiepalatnik.com/assets/semantic-ids-fig1.jpg" loading="lazy" title="Semantic IDs" alt="Semantic IDs"/></p>

<p>To integrate Semantic IDs into ranking models, the authors propose two techniques: an N-gram-based approach, which groups fixed-length sequences, and a SentencePiece Model (SPM)-based method that adaptively learns variable-length subwords. The ranking model is a multi-task production ranking model that recommends the next video to watch given the current video and user history.</p>

<p><strong>Results:</strong> Directly using the dense content embeddings performed worse than using random hash IDs. The authors hypothesize that ranking models heavily rely on memorization from the ID-based embedding tables—replacing these with <em>fixed</em> dense content embeddings led to poorer CTR. However, both N-gram and SPM methods did better than random hashing, especially in cold-start scenarios. Ablation tests revealed that while N-gram approaches had a slight advantage when embedding table sizes were limited (e.g., $8 \times K$ or $4 \times K^2$), SPM methods offered superior generalization and efficiency with larger embedding tables.</p>

<p><img src="https://jamiepalatnik.com/assets/semantic-ids-fig2.jpg" loading="lazy" title="Semantic IDs" alt="Semantic IDs"/></p>
<p>Dense content embeddings (dashed lines) perform worse than random hashing (solid orange).</p>

<p>Similarly, <strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688098" target="_blank">M3CSR (Kuaishou)</a> introduces multimodal content embeddings (visual, textual, audio) clustered via K-means into trainable category IDs.</strong> This transforms static content embeddings into adaptable, behavior-aligned representations.</p>

<p>The M3CSR framework has a dual-tower architecture, splitting user-side and item-side towers to optimize for online inference efficiency where user and item embeddings can be pre-computed and indexed via approximate nearest neighbor indices. Item embeddings are derived from multimodal pretrained models—ResNet for visual, Sentence-BERT for text, and VGGish for audio—and concatenated into a single embedding vector. These vectors are then clustered using K-means (with approximately 1,000 clusters from over 10 million videos).</p>

<p><img src="https://jamiepalatnik.com/assets/m3csr-fig2.jpg" loading="lazy" title="M3CSR" alt="M3CSR"/></p>

<p>Next, cluster IDs are embedded through a Modal Encoder, a dense network translating content features into behaviorally aligned spaces and assigning trainable embeddings. The Modal Encoder uses a dense network to learn the mapping from content-space to behavior space and a cluster ID lookup to assign a trainable cluster ID embedding.</p>

<p><img src="https://jamiepalatnik.com/assets/m3csr-fig3.jpg" loading="lazy" title="M3CSR" alt="M3CSR"/></p>

<p>On the user side, M3CSR learns on user behavior sequences to train sequential models that capture user preferences. In addition, to accurately model user modality preferences, the framework concatenates general behavioral interests with modality-specific interests. These modality-specific interests are derived by converting item IDs back into their multimodal embeddings using the same Modal Encoder.</p>

<p><strong>Results:</strong> M3CSR outperformed several multimodal baselines such as VBPR, MMGCN, and LATTICE. Ablation studies highlighted the importance of modeling modality-specific user interests and demonstrated consistent superiority of multimodal features over single-modal features across datasets (Amazon, TikTok, Allrecipes). A/B testing measured that clicks increased by 3.4%, likes by 3.0%, and follows by 3.1%. In cold-start scenarios, M3CSR also showed improved performance, achieving a 1.2% boost in cold-start velocity and a 3.6% increase in cold-start video coverage.</p>

<p><strong><a href="https://arxiv.org/abs/2310.19453" target="_blank">FLIP (Huawei)</a> shows how to align ID-based recommendation models with LLMs by jointly learning from masked tabular and language data.</strong> The core idea is to reconstruct masked features from one modality (user and item IDs) using information from another modality (text tokens), ensuring tight cross-modal alignment.</p>

<p>FLIP operates in three stages: modality transformation, modality alignment pretraining, and adaptive finetuning. First, tabular data is translated into text using structured prompt templates. Then, joint masked language/tabular modeling is conducted to achieve fine-grained alignment between modalities. During pretraining, textual data undergoes field-level masking (replacing entire fields with <code>[MASK]</code> tokens), while corresponding tabular features are masked by substituting feature IDs with <code>[MASK]</code>.</p>

<p>FLIP trains two parallel models with three objectives: (i) Masked Language Modeling (MLM) predicts masked text tokens using complete tabular context; (ii) Masked Tabular Modeling (MTM) predicts masked feature IDs leveraging textual data; and (iii) Instance-level Contrastive Learning (ICL) aligns global representations across modalities.</p>

<p><img src="https://jamiepalatnik.com/assets/flip-fig1.jpg" loading="lazy" title="FLIP" alt="FLIP"/></p>

<p>Finally, the aligned models—TinyBERT as the LLM and DCNv2 as the ID-based model—are finetuned on the downstream click-through rate (CTR) prediction task. To do this, FLIP adds randomly initialized output layers on both models to estimate click probabilities. The final prediction is a weighted sum of both models’ outputs, where the weights are learned adaptively during training.</p>

<p><img src="https://jamiepalatnik.com/assets/flip-fig2.jpg" loading="lazy" title="FLIP" alt="FLIP"/></p>

<p><strong>Results:</strong> FLIP outperforms the baselines of ID-only, LLM-only, and ID+LLM models. Ablation studies show that (i) both MLM and MTM objectives improve performance, (ii) field-level masking is more effective than random token masking, and (iii) joint reconstruction between modalities is key.</p>

<p>Similarly, <strong><a href="https://dl.acm.org/doi/10.1145/3523227.3551482" target="_blank">beeFormer</a> demonstrates how to train language-only Transformers on user-item interaction data enriched with textual information.</strong> The goal is to bridge the gap between semantic similarity (from textual data) and interaction-based similarity (from user behavior).</p>

<p>beeFormer combines a sentence Transformer encoder for item embeddings with an <a href="https://dl.acm.org/doi/10.1145/3523227.3551482" target="_blank">ELSA (scalabl<strong>E</strong> <strong>L</strong>inear <strong>S</strong>hallow <strong>A</strong>utoencoder)</a>-based decoder that captures patterns from user-item interactions. First, item embeddings are generated through a Transformer trained on textual data. These embeddings are then used to compute user recommendations via ELSA’s low-rank approximation of item-to-item weight. The key here is to backpropagate the gradients from the recommendation loss through the Transformer model. As a result, weight updates capture interaction patterns rather than just semantic similarity.</p>

<p><img src="https://jamiepalatnik.com/assets/beeformer-fig1.jpg" loading="lazy" title="beeFormer" alt="beeFormer"/></p>

<p>To make training computationally feasible on large catalogs, beeFormer applies gradient checkpointing to manage memory usage, gradient accumulation for larger effective batch sizes, and negative sampling to focus training efficiently on relevant items.</p>

<p><strong>Results:</strong> Offline evaluations show that beeFormer surpasses baseline models like mpnet-base-v2 and bge-m3. However, the comparison is limited (and IMHO unfair) since the baselines weren’t finetuned on the training dataset. Interestingly, models trained across multiple domains (movies + books) performed better than domain-specific ones, suggesting that there was transfer learning across domains.</p>

<p><strong><a href="https://arxiv.org/abs/2405.02429" target="_blank">CALRec (Google)</a> introduces a two-stage framework that finetunes a pretrained LLM (PaLM-2 XXS) for sequential recommendations.</strong> Both user interactions and model predictions are represented entirely through text.</p>

<p>First, all input (e.g., user-item interactions) is converted into text sequences by concatenating meaningful attributes (title, category, brand, price) into structured textual prompts. Attributes are formatted in the style of “Attribute name: Attribute description” and concatenated. At the end of the user history sequence, they append the item prefix, thus prompting the LLM to predict the user’s next purchase as a sentence completion task.</p>

<p><img src="https://jamiepalatnik.com/assets/calrec-fig2.jpg" loading="lazy" title="CALRec" alt="CALRec"/></p>

<p>CALRec has a two-stage finetuning approach. The first stage involves multi-category training to adapt the model to sequential recommendation patterns in a category-agnostic way. The second stage refines the model within specific item categories. The training objective combines next-item generation tasks (predicting textual descriptions of items) with auxiliary contrastive alignment. The former aims to generate the text description of the target item given the user’s history; the latter applies contrastive loss on the output of the separate user and item towers to align user history to target item representations.</p>

<p><img src="https://jamiepalatnik.com/assets/calrec-fig1.jpg" loading="lazy" title="CALRec" alt="CALRec"/></p>

<p>During inference, the model is prompted to generate multiple candidates via temperature sampling. They remove duplicates, sort by the output’s log probabilities in descending order, and keep the top k candidates. Then, these textual predictions are matched to catalog items via BM25 and sorted by the matching scores.</p>

<p><strong>Results:</strong> On the Amazon Review Dataset 2018, CALRec outperforms ID-based and text-based baselines (e.g., SASRec, BERT4Rec, FDSA, UniSRec). While the evaluation dataset is limited, CalRec beating the baselines is promising. Ablations demonstrate the necessity of both training stages, especially highlighting transfer learning benefits from multi-category training and incremental gains (0.8 - 1.7%) from contrastive alignment.</p>

<p><strong><a href="https://arxiv.org/abs/2405.11441" target="_blank">EmbSum (Meta)</a> presents a content-based recommendation approach using precomputed textual summaries of user interests and candidate items</strong> to capture interactions within the user engagement history.</p>

<p>EmbSum uses T5-small (61M parameters) to encode user interactions and candidate content, managing long user histories by partitioning them into sessions for encoding. Then, Mixtral-8x22B-Instruct generates the interpretable user interest summaries from user histories. These summaries are then fed into the T5’s encoder to derive final embeddings.</p>

<p><img src="https://jamiepalatnik.com/assets/embsum-fig1.jpg" loading="lazy" title="EmbSum" alt="EmbSum"/></p>

<p>Key to this architecture are User Poly-Embeddings (UPE) and Content Poly-Embeddings (CPE). To get a global representation for UPE, they take the last token of the decoder output (<code>[EOS]</code>) and concatenate it with the representation vectors from the session encoder. This combined representation passes through a poly-attention layer which distills nuanced user interests into multiple embeddings. EmbSum training combines noisy contrastive estimation loss and summarization loss, ensuring high-quality user embeddings.</p>

<p><strong>Results:</strong> EmbSum beats several state-of-the-art content-based recommenders. <em>Nonetheless, direct comparisons with behavioral recommenders were glaringly absent.</em> Ablation studies show that CPE contributes most to performance, followed by session-based grouping and encoding, user poly-embeddings, and summarization losses. Additionally, GPT-4 evaluations indicate strong interpretability and quality of generated user interest summaries.</p>

<p>• • •</p>

<h2 id="llm-assisted-data-generation-and-analysis">LLM-assisted data generation and analysis</h2>

<p>Another common theme is using LLMs to enrich data. Several papers share about using LLMs to tackle data scarcity and enhance the quality of search and recommendations. Examples include generating webpage metadata at Bing, creating synthetic training data to identify poor job matches at Indeed, adding semantic labels for query understanding at Yelp, crafting exploratory search queries at Spotify, and enriching music playlist metadata at Amazon.</p>

<p><strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688062" target="_blank">Recommendation Quality Improvement (Bing)</a> shares how Bing improved webpage recommendations by using LLMs to generate high-quality metadata</strong> and training an LLM to predict clicks and quality.</p>

<p>Previously, Bing’s webpage representations relied on extractive summaries, which often caused query classification failures. To address this, they used GPT-4 to generate high-quality titles and snippets from full webpage content for two million pages. Then, for efficient large-scale deployment, they finetuned a Mistral-7B model using this GPT-4-generated data.</p>

<p>To improve webpage-to-webpage recommendation rankings, they finetuned a multitask MiniLM-based cross-encoder on both pairwise click predictions <em>and</em> quality classification tasks. The resulting quality scores were then linearly combined with click predictions from an existing LightGBM ranker.</p>

<p><img src="https://jamiepalatnik.com/assets/bing-fig2.jpg" loading="lazy" title="Recommendation Quality Improvement" alt="Recommendation Quality Improvement"/></p>
<p>The MiniLM (right) is ensembled with the LightGBM ranker (left).</p>

<p>To better understand user preferences, they defined 16 distinct recommendation scenarios reflecting common user patterns. Using high-precision prompts, they classified each webpage-to-webpage recommendation, incorporating the enhanced title and snippets from Mistral-7B, into these scenarios. Then, by monitoring the distribution changes of each scenario, they quantified the improvements in webpage recommendation quality.</p>

<p><img src="https://jamiepalatnik.com/assets/bing-table4.jpg" loading="lazy" title="Recommendation Quality Improvement" alt="Recommendation Quality Improvement"/></p>

<p><strong>Results:</strong> The enhanced system reduced clickbait by 31%, low-authority content by 35%, and duplicate content by 76%. At the same time, higher authority content increased by 18%, cross-medium recommendations rose by 48%, and recommendations with greater specificity improved by 20%. This is despite lower-quality content (e.g., clickbait) historically showing higher CTR, demonstrating the effectiveness of the quality-focused cross-encoder.</p>

<p>(👉 Recommended read) <strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688043" target="_blank">Expected Bad Match (Indeed)</a> shares how they used LLM-generated labels to filter poor job matches.</strong> Specifically, they finetuned LLMs to evaluate recommendation quality and generate labels for a post-processing classifier.</p>

<p>They started with building an evaluation set by cross-reviewing 250 matches, narrowing it down to 147 high confidence labeled examples. Then, they prompted various LLMs, such as Llama2 and Mistral-7B, using expert recruitment guidelines to evaluate match quality across dimensions like job descriptions, resumes, and user interactions. However, these models struggled with detailed prompts, producing generalized assessments that didn’t consider detailed job and job seeker information. On the other hand, GPT-4 performed better but was prohibitively expensive.</p>

<p>To balance cost and effectiveness, the team finetuned GPT-3.5 on a curated dataset of over 200 human-reviewed GPT-4 responses. This finetuned GPT-3.5 matched GPT-4’s performance at just a quarter of the cost and latency. But despite the improvements, its inference latency of 6.7 seconds remained too high for online use. Thus, they trained a lightweight classifier, eBadMatch, using LLM-generated labels and categorical features from job descriptions, resumes, and user activity. In production, a daily pipeline samples job matches, engineers features, anonymizes data, generates LLM labels, and retrains the model. This classifier acts as a post-processing filter to remove low-quality matches.</p>

<p><strong>Results:</strong> The eBadMatch classifier achieved an AUC-ROC of 0.86 against LLM labels, with latency suitable for real-time filtering. Online experiments demonstrated that applying a 20% threshold filter on invitation-to-apply emails reduced batch matches by 17.68%, lowered unsubscribe rates by 4.97%, and increased application rates by 4.13%. Similar improvements were observed in homepage recommendation feeds.</p>

<p><img src="https://jamiepalatnik.com/assets/ebadmatch-table2.jpg" loading="lazy" title="Expected Bad Match" alt="Expected Bad Match"/></p>

<p>(👉 Recommended read) <strong><a href="https://engineeringblog.yelp.com/2025/02/search-query-understanding-with-LLMs.html" target="_blank">Query Understanding (Yelp)</a> shows how they integrated LLMs into their query understanding pipeline</strong> to improve query segmentation and review highlights.</p>

<p>Query segmentation identifies meaningful parts of user queries—such as topic, name, time, location, and question—and tags them accordingly. Along the way, they learned that spelling correction and segmentation could be done together and thus added a meta tag to mark spell-corrected sections and combined both tasks into a single prompt. Retrieval-augmented generation (RAG) further improved segmentation accuracy by incorporating business names and categories as context that disambiguated user intent. For evaluation, they compared LLM-identified segments against human-labeled datasets of name match and location intent.</p>

<p>Review highlights selects key snippets from reviews to highlight in search results. They used LLMs to generate synonymous phrases suitable for highlights. Curated examples prompted LLMs to replicate human reasoning in phrase expansion. RAG further enhanced relevance by augmenting the input with relevant business categories to guide phrase generation. Offline evaluation was done via human annotators before online A/B testing of the new highlight phrases. To scale efficiently and cover 95% of traffic, Yelp pre-computed snippet expansions using batch calls to OpenAI and stored them in key-value stores to reduce latency.</p>

<p><img src="https://jamiepalatnik.com/assets/yelp-fig3.jpg" loading="lazy" title="Review highlights" alt="Review highlights"/></p>

<p>The team shared their approach—from initial formulation and proof of concept (POC) to scaling up. Initially, they assessed LLM suitability and defined the project’s scope. During POC, they leveraged the power-law distribution of queries, caching pre-computed LLM responses for common queries covering most traffic. To scale, they created golden datasets using GPT-4 outputs and finetuned smaller, cost-effective models like GPT-4o-mini. Additionally, real-time models like BERT and T5 addressed less frequent, long-tail queries.</p>

<p><strong>Results:</strong> Yelp’s query segmentation significantly improved location intent detection, while enhanced review highlights increased both session and search click-through rates (CTR), especially benefiting long-tail queries.</p>

<p><strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688035" target="_blank">Query Recommendations (Spotify)</a> details how they built a hybrid query recommendation system to suggest exploratory search queries</strong> alongside direct results. This approach was necessary to support Spotify’s expansion beyond music to podcasts, audiobooks, and diverse content types by helping users explore those content.</p>

<p><img src="https://jamiepalatnik.com/assets/query-recs-fig1.jpg" loading="lazy" title="Query Recommendations" alt="Query Recommendations"/></p>

<p>Spotify generated query suggestions by (i) extracting from catalog titles, playlist names, and podcasts, (ii) mining suggestions from search logs, (iii) leveraging users’ recent searches, (iv) applying metadata and expansion rules (e.g., “artist name” + “covers”), and (v) generating synthetic natural language queries via LLMs. To generate synthetic queries, techniques such as Doc2query and InPars were used to broaden query variations, enhancing exploratory searches and mitigating retrievability bias.</p>

<p>The query suggestions were then combined with regular results and ranked by a point-wise ranker optimized for downstream user actions like streaming or adding content to playlists. The ranker use features such as lexical matching, query statistics, retrieval scores, and user consumption patterns. For personalization, they relied on vector representations of users and query suggestion candidates.</p>

<p><strong>Results:</strong> Spotify saw a 9% increase in exploratory intent queries, a 30% rise in maximum query length per user, and a 10% increase in average query length—this suggests the query recommendation updates helped users express more complex intents. An online ablation showed the ranker’s removal caused a 20% decline in clicks on recommendations, underscoring its importance.</p>

<p><strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688047" target="_blank">Playlist Search (Amazon)</a> discusses Amazon’s integration of LLMs into playlist search pipelines to tackle challenges</strong> like data scarcity, metadata enrichment, and scalable evaluation while reducing reliance on manual annotation.</p>

<p>To enrich metadata, they used LLMs (LLM curator) to create detailed descriptions for community playlists based on their initial 15 tracks, capturing themes, genres, activities, and artists. (These community playlists typically only had a playlist title.) This addressed data scarcity in community-generated content. Then, Flan-T5-XL was finetuned to scale this inference process.</p>

<p>They also applied LLMs to generate synthetic queries paired with playlists (and associated metadata) to create training data for bi-encoder models. These pairs were generated and scored by an LLM (LLM labeler) to maintain balanced positive and negative examples. Lastly, they used an LLM (LLM judge), guided by human annotations and careful prompting to ensure alignment, to streamline evaluations.</p>

<p><img src="https://jamiepalatnik.com/assets/playlist-fig1.jpg" loading="lazy" title="Playlist Search" alt="Playlist Search"/></p>

<p><strong>Results:</strong> Integrating LLMs led to substantial double-digit recall improvements across benchmarks, SEO, and paraphrasing datasets. Overall, the use of LLMs helped overcome the challenges of data scarcity and evaluation scalability without extensive manual effort.</p>

<p>• • •</p>

<h2 id="scaling-laws-transfer-learning-distillation-loras">Scaling Laws, transfer learning, distillation, LoRAs</h2>

<p>Another trend is the adoption of training approaches from large language models (LLMs) and computer vision into recommender systems. This includes exploring scaling laws (how model size and data quantity affect performance), using knowledge distillation to transfer insights from large models to smaller, efficient ones, applying cross-domain transfer learning to handle limited data, and parameter-efficient fine-tuning techniques such as LoRAs.</p>

<p>(👉 Recommended read) <strong><a href="https://arxiv.org/abs/2311.11351" target="_blank">Scaling Laws</a> investigates how the performance of ID-based sequential recommender models improve as their model size and data scale increase.</strong> The authors uncovered a predictable power-law relationship where performance consistently improves as the size of both models and datasets expands.</p>

<p>They adopt a decoder-only transformer architecture, experimenting with models ranging from 98.3K to 0.8B parameters. They evaluated these models on the MovieLens-20M and Amazon-2018 datasets. For the Amazon dataset, interaction records from 29 domains were combined, sorted chronologically, and simplified to include only item IDs without additional metadata. The datasets were then formatted into fixed-length sequences of 50 items each; shorter sequences were padded and longer ones were truncated. The model is then optimized to predict the next item at time step $t + 1$ conditioned on the previous $t$ items.</p>

<p><img src="https://jamiepalatnik.com/assets/scaling-fig1.jpg" loading="lazy" title="Scaling Laws" alt="Scaling Laws"/></p>

<p>To tackle instability in training larger models, the authors introduced two key improvements. First, they implemented layer-wise adaptive dropout, applying higher dropout rates in lower layers and lower dropout rates in upper layers. The intuition is that lower layers process direct input from data and are more prone to overfitting. Conversely, higher layers build more abstract representations and thus benefit from less dropout to reduce information loss that could lead to underfitting.</p>

<p>The second improvement was dynamically switching optimizers during training—starting with Adam before switching to stochastic gradient descent (SGD) at a predefined point. This approach is motivated by the observation that Adam quickly reduces loss in early training phases but ultimately SGD achieves better convergence.</p>

<p><strong>Results:</strong> Unsurprisingly, increased model capacity (excluding embedding parameters) consistently reduced cross-entropy loss. They modeled this with a power-law curve and accurately predicted performance for larger models (75.5M and 0.8B params). Similarly, they observed that larger models could achieve lower losses even with smaller datasets, whereas smaller models needed more data to reach comparable performance. For example, a smaller 98.3K-parameter model required twice the data (18.5M interactions) compared to a larger 75.5M-parameter model (9.2M interactions) to attain similar performance.</p>

<p><img src="https://jamiepalatnik.com/assets/scaling-fig2.jpg" loading="lazy" title="Scaling Laws" alt="Scaling Laws"/></p>

<p>Regarding data repetition, models of sizes 75.5M and 98.3K parameters continued improving beyond a single training epoch, with notable gains observed from two to five epochs. Surprisingly, changing model shape had minimal impact on performance. Ablation studies showed that layer-wise adaptive dropout and optimizer switching substantially enhanced performance in larger models (24 layers), though smaller models (2 layers) remained largely unaffected. Further ablations on five challenging recommendation tasks highlighted the advantage of larger models, particularly for long-tail items and cold-start users.</p>

<p><strong><a href="https://arxiv.org/abs/2401.01497" target="_blank">PrepRec</a> shows how pretraining can be adapted to recommender systems, enabling cross-domain, zero-shot recommendations.</strong> The key innovation is leveraging item popularity dynamics derived solely from user interactions, without relying on item metadata.</p>

<p>PrepRec uses popularity statistics calculated over coarse (monthly) and fine (weekly) timescales. These popularity metrics are converted into percentiles and then encoded into vector representations. In addition, the model incorporates relative time intervals between user interactions and uses a fixed positional encoding for each interaction in a user’s sequence. (IMHO, while the approach is effective, it relies on several specialized techniques—coarse vs. fine-grained periods, relative time intervals, and positional encodings—which might limit its generalizability.)</p>

<p><img src="https://jamiepalatnik.com/assets/preprec-fig2.jpg" loading="lazy" title="PrepRec" alt="PrepRec"/></p>

<p>For training, PrepRec has binary cross-entropy as the objective and uses Adam for optimization. The model and baselines have consistent settings: embedding dimension of 50, max sequence length of 200, and batch size of 128. During inference, PrepRec calculates item popularity dynamics from the target domain before generating recommendations via inference on the pretrained model.</p>

<p><strong>Results:</strong> PrepRec achieves promising zero-shot performance, with only a minor reduction (2-6% recall@10) compared to models like SasREC and BERT4Rec which were specifically trained on the target domains. When trained from scratch on the target domains, PrepRec matches or slightly surpasses these models in regular sequential recommendations despite using just 1-5% of their parameters, thanks to not having item-specific embeddings. Ablations showed that modeling relative time intervals significantly boosted performance, and capturing both coarse and fine-grained popularity trends was essential for tracking evolving user interests.</p>

<p><strong><a href="https://arxiv.org/abs/2408.16238" target="_blank">E-CDCTR (Meituan)</a> demonstrates the potential of transfer learning by using organic item data to improve click-through rate (CTR) predictions in advertising</strong>, tackling the challenge of sparse ad data.</p>

<p>E-CDCTR has three components: the tiny pretraining model (TPM), complete pretraining model (CPM), and advertising CTR model (A-CTR). The TPM, a lightweight model with just embedding and MLP layers, trains monthly on six months of organic impressions and clicks. It captures long-term collaborative filtering signals via historical user and item embeddings. Features include user and item IDs, category IDs, etc.</p>

<p><img src="https://jamiepalatnik.com/assets/e-cdctr-fig2.jpg" loading="lazy" title="E-CDCTR" alt="E-CDCTR"/></p>

<p>Next, the CPM pretrains a CTR model weekly using the most recent month’s organic data and using the user and item embeddings learned by TPM. Finally, the A-CTR model is initialized from the CPM and finetuned daily on advertising-specific data. A-CTR also uses user and item embeddings from the TPM. A-CTR also uses richer features such as user behavior sequences, user context, item metadata, and feature interactions, resulting in a more sophisticated model architecture that includes sequential input, feature crosses, and a larger MLP layer.</p>

<p>For online inference, E-CDCTR employs user and item embeddings generated by TPM from the past three months. The A-CTR model then uses these embeddings to predict the advertising CTR. (The authors mention using self-attention to combine embeddings but provide limited details on training it.)</p>

<p><strong>Results:</strong> E-CDCTR outperforms cross-domain baselines such as KEEP, CoNet, DARec, and MMoE. Ablation studies confirm the value of both TPM and CPM, with CPM having a more substantial impact. In addition, extending historical embeddings from one to three months further enhanced performance, whereas simply merging advertising data with organic data did not yield improvements.</p>

<p><strong><a href="https://arxiv.org/abs/2408.14678" target="_blank">Bridging the Gap (YouTube)</a> shares insights on applying knowledge distillation in large-scale personalized video recommendations at YouTube.</strong></p>

<p>Their recommenders are multi-objective pointwise models for ranking videos. These models simultaneously optimizing short-term objectives like video CTR and long-term objectives like the estimated long-value value of a user. Their models typically feature a teacher-student setup, with the teacher and student models sharing similar architectures though the teacher model is 2 - 4x larger than the student model.</p>

<p>However, distribution shifts between teacher and student can cause biases. To address this, the authors propose an auxiliary distillation strategy—instead of directly using the teacher’s predictions (soft labels), they decouple the hard labels from the soft teacher predictions via separate task logits. This enables the student model to effectively learn from the teacher without inheriting unwanted biases.</p>

<p><img src="https://jamiepalatnik.com/assets/bridge-fig2.jpg" loading="lazy" title="Bridging the gap" alt="Bridging the gap"/></p>

<p>To amortize the cost of training the large teacher model, they have a single teacher improve multiple student models. As a result, a single teacher model can provide distilled knowledge to various specialized recommendation tasks, reducing redundancy and computational overhead. Teacher labels are stored in a columnar database that prioritizes read performance for the students during training.</p>

<p><img src="https://jamiepalatnik.com/assets/bridge-fig3.jpg" loading="lazy" title="Bridging the gap" alt="Bridging the gap"/></p>

<p><strong>Results:</strong> The auxiliary distillation strategy delivered a 0.4% improvement in E(LTV) prediction compared to direct distillation methods, which performed similarly to models without distillation. This confirms the auxiliary distillation approach’s effectiveness in reducing teacher noise. In ablation studies on teacher size, even a modest teacher (2x the student’s size) led to meaningful improvements (+0.42% engagement, +0.34% satisfaction) while a 4x teacher led to +0.43% engagement and +0.46% satisfaction.</p>

<p>Similarly, <strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688041" target="_blank">Self-Auxiliary Distillation (Google)</a> introduces a distillation framework aimed at improving sample efficiency for large-scale recommendation models.</strong></p>

<p>The core idea is to prioritize training on high-quality labels while improving the resolution of lower-quality labels. The intuition is that positive labels provide more signal than negative labels when predicting CTR, thus it makes sense to prioritize them. On the other hand, negative labels are closer to weak positives than an absolute zero—thus, representing them with an estimated CTR value offers better training signal.</p>

<p>The model has a shared bottom tower with two heads: the main head (teacher) is trained directly on ground-truth labels, serving as the primary inference model and generating calibrated soft labels. Calibration is maintained by ensuring the mean prediction matches the mean of actual labels. The auxiliary head (student) learns from a mixture of these soft teacher labels and original labels, helping stabilize the training process. Specifically, the auxiliary head has a bilateral branch where one branch distills knowledge from the teacher’s soft labels and the other learns from the hard ground-truth label. A selector merges the labels from both branches using functions such as $max(y, y’)$.</p>

<p><img src="https://jamiepalatnik.com/assets/selfaux-fig1.jpg" loading="lazy" title="Self-auxiliary distillation" alt="Self-auxiliary distillation"/></p>

<p><strong>Results:</strong> Self-attention distillation consistently improved recommendation quality across multiple domains including apps, commerce, and video recommendations. Ablations show that training on original ground-truth labels primarily drives performance gains, while the distillation component significantly stabilizes and aligns the model’s predictions. Training exclusively on ground-truth labels showed inconsistent results while training on the distillation labels only didn’t lead to improvements.</p>

<p><strong><a href="https://arxiv.org/abs/2405.00338" target="_blank">DLLM2Rec</a> shows how to distill recommendation knowledge from LLMs into lightweight, conventional sequential recommendation models</strong>, making deployment more practical. The paper identifies three main challenges: (i) unreliable teacher knowledge/labels, (ii) the capability gap between teacher and student models, and (iii) semantic divergence between the teacher’s and student’s embedding spaces.</p>

<p>To tackle these issues, DLLM2Rec adopts two key strategies: importance-aware ranking distillation and collaborative embedding distillation. Importance-aware ranking distillation focuses on selecting reliable instances for training via importance weights. These weights consider factors like ranking position (prioritizing items ranked higher by the teacher), teacher confidence (evaluated through content similarity between generated descriptions and actual items), and the consistency between the teacher’s and student’s recommendations. Meanwhile, collaborative embedding distillation involves using a learnable MLP to effectively translate embeddings from the teacher’s semantic space into the student’s space.</p>

<p><img src="https://jamiepalatnik.com/assets/dllm2rec-fig1.jpg" loading="lazy" title="DLLM2Rec" alt="DLLM2Rec"/></p>

<p>In their experiments, they use BIGRec (built on Llama2-7B) as the teacher and three popular sequential models (GRU4Rec, SASRec, and DROS) as students.</p>

<p><strong>Results:</strong> DLLM2Rec boosts the performance of student models, showing an average improvement of 47.97% across three datasets (Amazon Video Games, MovieLens-10M, and Amazon Toys and Games) when evaluating hit rate@k and NDCG@k (see Table 5 in the paper). Additionally, inference time dropped significantly, from 3-6 hours with the teacher model down to just 1.6-1.8 seconds with DLLM2Rec.</p>

<p><strong><a href="https://arxiv.org/abs/2408.08913" target="_blank">MLoRA (Alibaba)</a> describes using domain-specific LoRAs (low-rank adapters) to enhance multi-domain CTR prediction models.</strong> It addresses two common problems: data sparsity (limited data per domain) and domain diversity (variations across domains) that typically arise when training either separate models or a single combined model respectively.</p>

<p>They adopt a two-step training process. First, they pretrained a shared backbone network on extensive, multi-domain data to learn generalizable patterns across domains. Then, they freeze the backbone and finetune domain-specific LoRAs on each domain’s unique data. A key challenge was adapting LoRA ranks layer-by-layer due to varying dimensions in CTR model layers. (Recommender models have different dimentions per layer unlike language models which typically have uniform dimensions.) In their experiments, all models had hidden layers of 256, 128, and 64 dimensions.</p>

<p><img src="https://jamiepalatnik.com/assets/mlora-fig3.jpg" loading="lazy" title="MLoRA" alt="MLoRA"/></p>

<p>To get a sense of data distribution differences between pretraining and finetuning: During their A/B test, the pretrained backbone used 13 billion samples spanning 90 days from 10 domains, whereas finetuning involved 3.2 billion samples from just 21 days.</p>

<p><strong>Results:</strong> MLoRA increased AUC by 0.5% across datasets such as Taobao-10, Amazon-6, and MovieLens. Ablation studies showed that domains with smaller datasets and higher inter-domain differences benefited more. They also found that simpler models (like MLP) performed best with lower LoRA ranks (32), while more complex models (like DeepFM) benefited from higher ranks (64 - 128). A/B testing showed substantial business gains—a 1.49% lift in CTR, a 3.37% boost in conversions, and a 2.71% increase in paid buyers—with only a modest 1.76% rise in model complexity due to the use of LoRAs.</p>

<p><strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688053" target="_blank">Taming One-Epoch (Pinterest)</a> highlights the challenge of models overfitting after just one training epoch</strong>, primarily due to the long-tail nature of recommendation data. (Perhaps the Scaling Laws paper above, which showed gains beyond one epoch, used datasets (i.e., Amazon and MovieLens) that had the long-tail filtered out.) This overfitting arises because tail entries have far more degrees of freedom compared to the limited training examples available.</p>

<p>Here’s more context on the “one-epoch problem”: In online experiments, they saw that deep CTR models without ID embeddings typically require multiple epochs to converge. However, introducing ID embeddings often causes performance to peak after just one epoch, leading to worse results compared to multi-epoch training without ID embeddings.</p>

<p>Their solution involves two distinct stages. In the first stage, they pretrain foundational ID embeddings using a minimal dot-product model combined with contrastive loss, utilizing in-batch and uniformly random negatives. This contrastive approach reduces the effective dimensionality of tail entries, minimizing overfitting. Moreover, because the pretraining step is relatively lightweight, they can use a much larger dataset—around ten times the engagement data compared to the downstream recommendation model.</p>

<p>In the second stage, the pretrained embeddings are finetuned in task-specific models for multiple epochs. By separating embedding pretraining from downstream finetuning, they mitigate overfitting and get better results compared to merely freezing the embeddings.</p>

<p><img src="https://jamiepalatnik.com/assets/one-epoch-fig1.jpg" loading="lazy" title="Taming One-Epoch" alt="Taming One-Epoch"/></p>

<p><strong>Results:</strong> In Figure 2 above, the typical binary cross-entropy (BCE) loss tends to overfit after the first epoch, whereas the contrastive loss remains stable. Ablation studies revealed that a single-stage training method underperformed relative to baseline models due to severe overfitting (−3.347% for Homefeed and −1.907% for Related Pins). Conversely, the two-stage training consistently yielded superior results (+1.323% Homefeed, +2.187% Related Pins), and in online A/B tests, led to a significant overall engagement lift of 2.2%.</p>

<p><strong><a href="https://arxiv.org/abs/2409.14517" target="_blank">Sliding Window Training (Netflix)</a> describes their method for efficiently training on long user history sequences</strong> without incurring the memory and latency costs associated with large input sizes. One workaround is to truncate user historical interactions—however, this comes at the cost of not using valuable information from the entire user journey.</p>

<p>Their solution is elegantly simple. Assuming a baseline model that only handles sequences of up to 100 items, they introduce a sliding window sampler during training. This sampler selects different segments of user history in each training epoch, allowing the model to learn on long-term user patterns. Additionally, they experimented with mixing epochs—some focused exclusively on sliding windows, while others emphasized only the latest 100 interactions—to balance between recent user behavior and historical preferences.</p>

<p><img src="https://jamiepalatnik.com/assets/sliding-window-fig2.jpg" loading="lazy" title="Sliding Window Training" alt="Sliding Window Training"/></p>

<p><strong>Results:</strong> Offline evaluations showed the sliding window method consistently outperformed models trained solely on the most recent 100 interactions. Specifically, a pure sliding window variant slightly reduced Mean Reciprocal Rank (MRR) by 1.2%, but improved Mean Average Precision (MAP) by 1.5% and recall significantly by 7.01%. Hybrid approaches combining sliding windows with recent interactions, and extending input sequence lengths to 500 or even 1000 items, delivered the best overall performance. However, these extended approaches had slightly worse perplexity, indicating a trade-off between predictive confidence and actual recommendation performance.</p>

<p>• • •</p>

<h2 id="unified-architectures-for-search-and-recommendations">Unified architectures for search and recommendations</h2>

<p>The final theme highlights a growing shift toward unified system architectures that blend search and recommendations, drawing inspiration from foundation models. Instead of deploying multiple single-task models, recent papers present unified frameworks capable of handling diverse retrieval and ranking tasks within a shared infrastructure. For example, LinkedIn’s 360Brew and Netflix’s UniCoRn show how unified models trained on multiple tasks can outperform specialized, single-task counterparts.</p>

<p><strong><a href="https://arxiv.org/abs/2410.16823" target="_blank">Bridging Search &amp; Recommendations (Spotify)</a> demonstrates the advantages of training a unified generative retrieval model</strong> on both search and recommendation data, rather than separately, and how it can outperform task-specific models.</p>

<p>In their approach, a generative recommender predicts item IDs based on a user’s past interactions, while a generative search retriever predicts item IDs from tokenized search queries. The underlying model builds upon Flan-T5-base, extending the vocabulary to include all item IDs with one additional token per item. These models are trained auto-regressively using teacher forcing and cross-entropy loss, aiming to accurately predict the next relevant item ID. During inference, item IDs are generated directly from either a user’s interaction history (for recommendations) or a text query (for search).</p>

<p><img src="https://jamiepalatnik.com/assets/bridging-spotify-table1.jpg" loading="lazy" title="Bridging search and recsys" alt="Bridging search aand recsys"/></p>

<p>Evaluation is done via standard recall metrics (recall@10 for simulated datasets, recall@30 for real-world datasets) against common baselines like BM25, SASRec, and BERT4Rec.</p>

<p><strong>Results:</strong> Jointly trained multi-task models outperformed their single-task counterparts, achieving an average increase of 16% in recall@30. On the Podcasts dataset, the unified model significantly improved performance by +33% across both tasks, especially for torso items (those outside the top 1%), showing gains of 262% for recommendations and 855% for search.</p>

<p>While the research wasn’t focused on replacing conventional models, the comparisons against behavioral baselines were insightful. Across three datasets, generative models consistently lagged behind specialized recommendation baselines (SASRec, BERT4Rec) significantly (green below). Similarly, for search, traditional baselines (BM25, Bi-encoder) were still superior (green below). This indicates that generative retrieval models are still far from fully replacing conventional methods.</p>

<p><img src="https://jamiepalatnik.com/assets/bridging-spotify-table5.jpg" loading="lazy" title="Bridging search and recsys" alt="Bridging search aand recsys"/></p>

<p>(👉 Recommended read)  <strong><a href="https://arxiv.org/abs/2501.16450" target="_blank">360Brew (LinkedIn)</a> consolidates several ID-based ranking models into a single large 150B decoder-only model</strong> equipped with a natural language interface, effectively replacing traditional feature engineering with prompt engineering.</p>

<p><img src="https://jamiepalatnik.com/assets/360brew-table1.jpg" loading="lazy" title="360Brew" alt="360Brew"/></p>

<p>360Brew builds upon the Mixtral-8x22B pretrained Mixture-of-Experts model. Its fine-tuning dataset includes 3-6 months of interactions from roughly 45 million monthly active users in the US, encompassing member profiles, job descriptions, posts, and various interaction logs—all transformed into a text-based format.</p>

<p>Training involves three key stages. First, continuous pretraining (CPT) is done with a maximum context length of 16K tokens with packing techniques. Next, instruction fine-tuning (IFT) is performed using a mix of open-source datasets (such as UltraChat) and internally generated instruction-following data. Finally, supervised fine-tuning (SFT) applies multi-turn chat templates designed to enhance the model’s understanding of member-entity interactions, improving its predictive capabilities across specific user interfaces.</p>

<p>The model was trained on 256-512 H100 GPUs using FSDP, and production deployment adopts vLLM and inference-time RoPE scaling. 360Brew focuses on binary prediction tasks, such as whether a user will like a posts, and uses token logits to assign scores.</p>

<p><strong>Results:</strong> The unified model supports over 30 different ranking tasks across LinkedIn’s platforms, matching or surpassing specialized production models while reducing complexity and maintenance overhead. The researchers also found that the unified model improved substantially with more data—while initial iterations performed poorly, tripling the dataset resulted in performance exceeding specialized models (Figure 2 below). Additionally, larger models consistently outperformed smaller versions (8x22B &gt; 8x7B &gt; 7B). Also, 360Brew delivered strong performance for cold-start users, outperforming traditional models by a wider margin when user interaction data was limited.</p>

<p><img src="https://jamiepalatnik.com/assets/360brew-fig2.jpg" loading="lazy" title="360Brew" alt="360Brew"/></p>

<p>Similarly, <strong><a href="https://arxiv.org/abs/2408.10394" target="_blank">UniCoRn (Netflix)</a> introduces a unified contextual ranker designed to serve both search and recommendation tasks</strong> through a shared contextual framework. This unified model achieves comparable or better performance than multiple specialized models, thus reducing operational complexity.</p>

<p>The UniCoRn model uses contextual information such as user ID, search queries, country, source entity ID, and task type, predicting the probability of positive engagement with a target entity (e.g., a movie). Since not all contexts are always available, heuristics are used to impute missing data. For example, missing source entity IDs in search tasks are imputed as null, and missing query contexts in recommendation tasks use the entity’s display names.</p>

<p>UniCoRn incorporates two broad feature categories: context-specific features (like query length and source entity embeddings) and combined context-target features (such as click counts for a target entity in response to a query). The architecture includes embedding layers for categorical features, enhanced with residual connections and feature crossing.</p>

<p><img src="https://jamiepalatnik.com/assets/unicorn-fig1.jpg" loading="lazy" title="Unicorn" alt="Unicorn"/></p>

<p>Training uses binary cross-entropy loss and the Adam optimizer. Netflix incrementally increased personalization: starting from a semi-personalized model using user clusters, progressing to including outputs from other recommendation models, and finally incorporating pretrained and fine-tuned user and item embeddings.</p>

<p><strong>Results:</strong> UniCoRn consistently matched or exceeded specialized models. Personalization boosted outcomes, delivering a 10% improvement in recommendations and a 7% lift in search. Ablation studies showed the importance of explicitly including the task type as context, imputing missing features to maximize feature coverage, and applying feature crossing to enhance multi-task learning effectiveness.</p>

<p>(👉 Recommended read) <strong><a href="https://arxiv.org/abs/2306.04833" target="_blank">Unified Embeddings (Etsy)</a> shares how they unified transformer-based, term-based, and graph-based embeddings within a two-tower model</strong> architecture. This goal was to address common gaps such as mismatches between search queries and product vocabulary (lexical matching) and the poor performance of neural embeddings due to limited user context.</p>

<p><img src="https://jamiepalatnik.com/assets/unifiedemb-fig2.jpg" loading="lazy" title="Unified Embeddings" alt="Unified Embeddings"/></p>

<p>Their model adopts a classic two-tower structure, consisting of a product encoder and a joint query-user encoder. The product encoder combines transformer-based embeddings, bipartite graph embeddings (trained using a full year of query-product interaction data), product title embeddings, and location information. Interestingly, direct finetuning of transformer-based models like distilBERT and T5 did not yield significant offline metric improvements. Instead, inspired by docT5query, they pretrained a T5-small model specifically designed to predict historically purchased queries based on product descriptions. The query-user encoder combines query text embeddings, location, and historical engagement data. Both query/title and location embeddings are shared across the two towers for consistency.</p>

<p>They emphasize the effectiveness of negative sampling, sharing multiple approaches such as hard in-batch negatives (positives from other queries within the batch), uniform negatives (randomly selected from the entire product corpus), and dynamic hard negatives (random samples narrowed down by the model to identify the most challenging examples). The goal here is to find the most similar negatives to help the model learn on the hardest samples.</p>

<p>To balance relevance with product quality, they integrated quality boosting into their embeddings via an approximate nearest neighbor (ANN) index. Product embeddings are augmented with query-independent quality scores reflecting attributes such as product ratings, freshness, and conversion rates—factors proven to increase engagement independently from query relevance. Given the original product embeddings, they concatenate it with the quality score vectors; the respective query embedding is concatenated with a constant vector. The final score of the product, for a query, is the dot product of the updated product and query embedding.</p>

<p><img src="https://jamiepalatnik.com/assets/unifiedemb-fig3.jpg" loading="lazy" title="Unified Embeddings" alt="Unified Embeddings"/></p>

<p>The system operates through two main stages: offline indexing and online serving. Offline, embeddings and quality scores are generated and pre-indexed into an ANN system (using FAISS with a 4-bit product quantizer). This approach, combined with a re-ranking step, achieves a recall loss below 4% while keeping latency under 20ms@p99. At the online stage, incoming queries are embedded in real time to retrieve products from the ANN index. They also shared how they applied caching while handling in-session personalization features.</p>

<p><strong>Results:</strong> In A/B testing, the unified embedding model drove a site-wide conversion lift of 2.63% and boosted organic search purchases by 5.58%. Offline tests showed that Unified Embeddings consistently outperformed traditional baselines for both head and tail queries. Ablation studies revealed the strongest contributions came from graph embeddings (+15% recall@100), followed by description embeddings (+6.3%) and attributes (+3.9%). Additionally, location embeddings significantly improved purchase recall@100 (+8%) for US users by minimizing geographic mismatches. Removing hard negatives resulted in a noticeable 7% drop in performance, underscoring their importance.</p>

<p><strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688039" target="_blank">Embedding Long Tail (Best Buy)</a> shared how they optimize semantic product search to better address long-tail queries</strong> which typically suffer from sparse user interaction data.</p>

<p>To create a high-quality dataset, they collected user engagement data from product pages and applied a two-stage filtering process, reducing data volume (by 10x) while maintaining quality and balanced coverage across product categories. First, they retained interactions observed from at least two unique visitors, then performed stratified sampling across categories to mitigate popularity bias. To further augment this data, they prompted a Llama-13B model to generate ten synthetic search queries per product using the product’s title, category, description, and specifications, thus ensuring comprehensive catalog coverage.</p>

<p>Their model follows a two-tower architecture based on Best Buy’s internally developed BERT variant, an adaptation of RoBERTa finetuned through masked language modeling on search queries and product information. They used the first five layers of this BERT model to initialize both the search and product encoders. Training involved using in-batch negatives with multi-class cross-entropy loss. For deployment, Solr functions as both the inverted index and vector database, with a caching layer added to minimize redundant requests to the embedding service.</p>

<p><strong>Results:</strong> Adding semantic retrieval to the existing lexical search improved conversion rates by 3% in online A/B tests. Offline experiments demonstrated incremental improvements through various enhancements: two-stage data filtering (+0.24% recall@200), synthetic positive queries (+0.7%), additional product features (+1.15%), query-to-query followed by query-to-product fine-tuning (+2.44%), and model weight merging (+4.67%). Notably, their final model outperformed the baseline (all-mpnet-base-v2) while using only half the parameters at 50M vs 110M. (Nonetheless, it may not have been a fair comparison given the baseline was not finetuned.)</p>

<p><strong><a href="https://dl.acm.org/doi/10.1145/3640457.3688030" target="_blank">User Behavioral Service (YouTube)</a> presented an innovative approach for serving large user sequence models efficiently while sidestepping latency challenges.</strong></p>

<p><img src="https://jamiepalatnik.com/assets/ubs-fig1.jpg" loading="lazy" title="User Behavioral Service" alt="User Behavioral Service"/></p>

<p>The intuition behind User Behavior Service (UBS) is decoupling the serving of the user sequence model from the main recommendation model. This design allows independent control over user embedding computation. Although both models are co-trained, they are exported and served separately. The user model computes embeddings asynchronously, storing them in a high-speed key-value cache that’s regularly updated. If a requested embedding isn’t available, an empty embedding is returned while an asynchronous refresh is triggered. This setup enables experimentation with significantly larger models without latency constraints—a concept similar to what I described as “Just-in-time infrastructure” in my <a href="https://jamiepalatnik.com/speaking/recsys2022-keynote/" target="_blank">RecSys 2022 keynote</a>.</p>

<p><strong>Results:</strong> In A/B tests, UBS improved performance across six different ranking tasks while limiting the increase in cost. For example, a User Model with a sequence length of 1,000 showed a 0.38% improvement in online metrics compared to a baseline model using a sequence length of 20, with offline accuracy gains ranging from 0.01% to 0.40% across multiple tasks. Directly serving a large user sequence model would have increased costs by 28.7% but the UBS approach limited this increase to just 2.8%.</p>

<p>(👉 Recommended read) <strong><a href="https://arxiv.org/abs/2409.02856" target="_blank">Modern Ranking Platform (Zalando)</a> details their real-time platform designed for both search and browsing scenarios.</strong> The paper discusses their system design, candidate generation, retrieval methods, and ranking policies.</p>

<p><img src="https://jamiepalatnik.com/assets/zalando-fig2.jpg" loading="lazy" title="Modern Ranking Platform" alt="Modern Ranking Platform"/></p>

<p>Their platform is built around a few key principles:</p>

<ul>
  <li><strong>Composability:</strong> Models can be combined vertically (layered ranking) or horizontally by integrating outputs from various models or candidate generators.</li>
  <li><strong>Scalability:</strong> To manage computational costs, the platform first uses efficient but less precise candidate generators. These initial candidates are then refined by more accurate but computationally intensive rankers, a <a href="https://jamiepalatnik.com/writing/system-design-for-discovery/" target="_blank">standard design for recsys</a>.</li>
  <li><strong>Shared Infrastructure:</strong> Whenever possible, training datasets, embeddings, feature stores, and serving infrastructure are reused to simplify operations.</li>
  <li><strong>Steerable Ranking:</strong> The platform allows external adjustments through a policy layer, making it easy to align rankings with business objectives.</li>
</ul>

<p><img src="https://jamiepalatnik.com/assets/zalando-fig3.jpg" loading="lazy" title="Modern Ranking Platform" alt="Modern Ranking Platform"/></p>

<p>Their candidate generator uses a classic two-tower model. The customer tower updates embeddings based on a customer’s recent actions and current context whenever the customer visits the site, ensuring embeddings remain fresh. The item tower precomputes item embeddings and stores them in a vector database for rapid retrieval. These embeddings are matched via dot product. To create customer embeddings, a Transformer encoder is trained on historical customer behavior and contextual data, predicting the next likely interaction.</p>

<p><img src="https://jamiepalatnik.com/assets/zalando-fig4.jpg" loading="lazy" title="Modern Ranking Platform" alt="Modern Ranking Platform"/></p>

<p>The ranker is a multi-task model that predicts the likelihood of different customer actions, such as clicks, adding items to wishlist or cart, and purchases. Each action has its own prediction head, with all contributing equally to training loss. During serving, each action type’s importance can be dynamically adjusted. Overall, the ranker outputs personalized scores for each candidate item across multiple potential customer interactions.</p>

<p>Finally, the policy layer ensures the system aligns with broader business goals. For instance, it can encourage exploration by promoting new products through heuristics like epsilon-greedy strategies. It also applies other business rules, such as reducing the visibility of previously purchased items and ensuring item diversity by preventing items from the same brand from appearing back-to-back.</p>

<p><strong>Results:</strong> The unified architecture demonstrated strong performance across four A/B tests, achieving a combined engagement increase of +15% and a revenue uplift of +2.2%. Iterative improvements further illustrate the effectiveness of each system component: introducing trainable embeddings in candidate generation boosted engagement by +4.48% and revenue by +0.18%; adding advanced ranking and policy layers delivered an additional +4.04% engagement and +0.86% revenue; and using contextual data provided a further lift of +2.40% in engagement and +0.60% in revenue.</p>

<p>• • •</p>

<p>Although early research in 2023—that applied LLMs to recommendations and search—often fell short, these recent efforts show more promise, especially since they’re backed by industry results. It suggests that there are tangible benefits from exploring the augmentation of recsys and search systems with LLMs, increasing performance while reducing cost and effort.</p>

<h2 id="references">References</h2>

<p>Chamberlain, Benjamin P., et al. “Tuning Word2vec for Large Scale Recommendation Systems.” <em>Fourteenth ACM Conference on Recommender Systems</em>, 2020, pp. 732–37. <em>arXiv.org</em>, <a href="https://doi.org/10.1145/3383313.3418486">https://doi.org/10.1145/3383313.3418486</a>.</p>

<p>Hidasi, Balázs, et al. <em>Session-Based Recommendations with Recurrent Neural Networks</em>. arXiv:1511.06939, arXiv, 29 Mar. 2016. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.1511.06939">https://doi.org/10.48550/arXiv.1511.06939</a>.</p>

<p>Chen, Qiwei, et al. <em>Behavior Sequence Transformer for E-Commerce Recommendation in Alibaba</em>. arXiv:1905.06874, arXiv, 15 May 2019. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.1905.06874">https://doi.org/10.48550/arXiv.1905.06874</a>.</p>

<p>Sun, Fei, et al. <em>BERT4Rec: Sequential Recommendation with Bidirectional Encoder Representations from Transformer</em>. arXiv:1904.06690, arXiv, 21 Aug. 2019. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.1904.06690">https://doi.org/10.48550/arXiv.1904.06690</a>.</p>

<p>Singh, Anima, et al. <em>Better Generalization with Semantic IDs: A Case Study in Ranking for Recommendations</em>. arXiv:2306.08121, arXiv, 30 May 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2306.08121">https://doi.org/10.48550/arXiv.2306.08121</a>.</p>

<p>Chen, Gaode, et al. “A Multi-Modal Modeling Framework for Cold-Start Short-Video Recommendation.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 391–400. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688098">https://doi.org/10.1145/3640457.3688098</a>.</p>

<p>Wang, Hangyu, et al. <em>FLIP: Fine-Grained Alignment between ID-Based Models and Pretrained Language Models for CTR Prediction</em>. arXiv:2310.19453, arXiv, 30 Oct. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2310.19453">https://doi.org/10.48550/arXiv.2310.19453</a>.</p>

<p>Vančura, Vojtěch, et al. “beeFormer: Bridging the Gap Between Semantic and Interaction Similarity in Recommender Systems.” <em>18th ACM Conference on Recommender Systems</em>, 2024, pp. 1102–07. <em>arXiv.org</em>, <a href="https://doi.org/10.1145/3640457.3691707">https://doi.org/10.1145/3640457.3691707</a>.</p>

<p>Li, Yaoyiran, et al. <em>CALRec: Contrastive Alignment of Generative LLMs for Sequential Recommendation</em>. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2405.02429">https://doi.org/10.48550/arXiv.2405.02429</a>.</p>

<p>Zhang, Chiyu, et al. <em>EmbSum: Leveraging the Summarization Capabilities of Large Language Models for Content-Based Recommendations</em>. arXiv:2405.11441, arXiv, 19 Aug. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2405.11441">https://doi.org/10.48550/arXiv.2405.11441</a>.</p>

<p>Shah, Jaidev, et al. “Analyzing User Preferences and Quality Improvement on Bing’s WebPage Recommendation Experience with Large Language Models.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 751–54. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688062">https://doi.org/10.1145/3640457.3688062</a>.</p>

<p>Pei, Yingchi, et al. “Leveraging LLM Generated Labels to Reduce Bad Matches in Job Recommendations.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 796–99. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688043">https://doi.org/10.1145/3640457.3688043</a>.</p>

<p><em>Search Query Understanding with LLMs: From Ideation to Production</em>. <a href="https://engineeringblog.yelp.com/2025/02/search-query-understanding-with-LLMs.html">https://engineeringblog.yelp.com/2025/02/search-query-understanding-with-LLMs.html</a>. Accessed 5 Mar. 2025.</p>

<p>Lindstrom, Henrik, et al. “Encouraging Exploration in Spotify Search through Query Recommendations.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 775–77. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688035">https://doi.org/10.1145/3640457.3688035</a>.</p>

<p>Aluri, Geetha Sai, et al. “Playlist Search Reinvented: LLMs Behind the Curtain.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 813–15. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688047">https://doi.org/10.1145/3640457.3688047</a>.</p>

<p>Zhang, Gaowei, et al. <em>Scaling Law of Large Sequential Recommendation Models</em>. arXiv:2311.11351, arXiv, 19 Nov. 2023. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2311.11351">https://doi.org/10.48550/arXiv.2311.11351</a>.</p>

<p>Wang, Junting, et al. “A Pre-Trained Sequential Recommendation Framework: Popularity Dynamics for Zero-Shot Transfer.” <em>18th ACM Conference on Recommender Systems</em>, 2024, pp. 433–43. <em>arXiv.org</em>, <a href="https://doi.org/10.1145/3640457.3688145">https://doi.org/10.1145/3640457.3688145</a>.</p>

<p>Liu, Qi, et al. <em>Efficient Transfer Learning Framework for Cross-Domain Click-Through Rate Prediction</em>. arXiv:2408.16238, arXiv, 29 Aug. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2408.16238">https://doi.org/10.48550/arXiv.2408.16238</a>.</p>

<p>Khani, Nikhil, et al. <em>Bridging the Gap: Unpacking the Hidden Challenges in Knowledge Distillation for Online Ranking Systems</em>. arXiv:2408.14678, arXiv, 26 Aug. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2408.14678">https://doi.org/10.48550/arXiv.2408.14678</a>.</p>

<p>Zhang, Yin, et al. “Self-Auxiliary Distillation for Sample Efficient Learning in Google-Scale Recommenders.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 829–31. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688041">https://doi.org/10.1145/3640457.3688041</a>.</p>

<p>Cui, Yu, et al. “Distillation Matters: Empowering Sequential Recommenders to Match the Performance of Large Language Model.” <em>18th ACM Conference on Recommender Systems</em>, 2024, pp. 507–17. <em>arXiv.org</em>, <a href="https://doi.org/10.1145/3640457.3688118">https://doi.org/10.1145/3640457.3688118</a>.</p>

<p>Yang, Zhiming, et al. <em>MLoRA: Multi-Domain Low-Rank Adaptive Network for CTR Prediction</em>. arXiv:2408.08913, arXiv, 14 Aug. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2408.08913">https://doi.org/10.48550/arXiv.2408.08913</a>.</p>

<p>Hsu, Yi-Ping, et al. “Taming the One-Epoch Phenomenon in Online Recommendation System by Two-Stage Contrastive ID Pre-Training.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 838–40. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688053">https://doi.org/10.1145/3640457.3688053</a>.</p>

<p>Joshi, Swanand, et al. “Sliding Window Training - Utilizing Historical Recommender Systems Data for Foundation Models.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 835–37. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688051">https://doi.org/10.1145/3640457.3688051</a>.</p>

<p>Penha, Gustavo, et al. <em>Bridging Search and Recommendation in Generative Retrieval: Does One Task Help the Other?</em> arXiv:2410.16823, arXiv, 22 Oct. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2410.16823">https://doi.org/10.48550/arXiv.2410.16823</a>.</p>

<p>Firooz, Hamed, et al. <em>360Brew: A Decoder-Only Foundation Model for Personalized Ranking and Recommendation</em>. arXiv:2501.16450, arXiv, 27 Jan. 2025. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2501.16450">https://doi.org/10.48550/arXiv.2501.16450</a>.</p>

<p>Bhattacharya, Moumita, et al. <em>Joint Modeling of Search and Recommendations Via an Unified Contextual Recommender (UniCoRn)</em>. arXiv:2408.10394, arXiv, 19 Aug. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2408.10394">https://doi.org/10.48550/arXiv.2408.10394</a>.</p>

<p>Jha, Rishikesh, et al. <em>Unified Embedding Based Personalized Retrieval in Etsy Search</em>. arXiv:2306.04833, arXiv, 25 Sept. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2306.04833">https://doi.org/10.48550/arXiv.2306.04833</a>.</p>

<p>Kekuda, Akshay, Yuyang Zhang, and Arun Udayashankar. “Embedding based retrieval for long tail search queries in ecommerce.” Proceedings of the 18th ACM Conference on Recommender Systems. 2024. <a href="https://dl.acm.org/doi/10.1145/3640457.3688039">https://dl.acm.org/doi/10.1145/3640457.3688039</a>.</p>

<p>Li, Yuening, et al. “Short-Form Video Needs Long-Term Interests: An Industrial Solution for Serving Large User Sequence Models.” <em>Proceedings of the 18th ACM Conference on Recommender Systems</em>, Association for Computing Machinery, 2024, pp. 832–34. <em>ACM Digital Library</em>, <a href="https://doi.org/10.1145/3640457.3688030">https://doi.org/10.1145/3640457.3688030</a>.</p>

<p>Celikik, Marjan, et al. <em>Building a Scalable, Effective, and Steerable Search and Ranking Platform</em>. 1, arXiv:2409.02856, arXiv, 4 Sept. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2409.02856">https://doi.org/10.48550/arXiv.2409.02856</a>.</p>


            
            </div></div>
  </body>
</html>
