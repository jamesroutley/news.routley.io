<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://parametric.press/issue-01/unraveling-the-jpeg/">Original</a>
    <h1>Unraveling the JPEG (2019)</h1>
    
    <div id="readability-page-1" class="page"><div id="idyll-mount"><div data-reactroot=""><div><div><p><a href="https://parametric.press/"><img src="https://parametric.press/issue-01/static/images/logo-nav.png"/></a></p></div><div><div title="Unraveling,the JPEG" date="May 1, 2019" dek="JPEG images are everywhere in our digital lives, but behind the veil of familiarity lie algorithms that remove details that are imperceptible to the human eye. This produces the highest visual quality with the smallest file size—but what does that look like? Let&#39;s see what our eyes can&#39;t see!" authors="[object Object]" doi="https://doi.org/10.5281/zenodo.2655041" archive="https://parametric-press-archives.s3.amazonaws.com/issue-01/unraveling-the-jpeg.warc.gz" source="https://github.com/ParametricPress/01-unraveling-the-jpeg"><p>JPEG images are everywhere in our digital lives, but behind the veil of familiarity lie algorithms that remove details that are imperceptible to the human eye. This produces the highest visual quality with the smallest file size—but what does that look like? Let&#39;s see what our eyes can&#39;t see!</p></div></div><div><p>It’s easy to take for granted that you can send a picture to a friend without worrying about what device, browser, or operating system they’re using, but things weren’t always this way. By the early 1980s, computers could store and display digital images, but there were many competing ideas about how best to do that. You couldn’t just send an image from one computer to another and expect it to work.</p><p>To solve this problem, the Joint Photographic Experts Group (JPEG), a committee of experts from all over the world, was established in 1986 as a joint effort by the ISO (International Organization for Standardization) and the IEC (International Electrotechnical Commission)—two international standards organizations headquartered in Geneva, Switzerland.</p><p>JPEG, the group of people, created JPEG, a standard for digital image compression, in 1992. Anyone who’s ever used the internet has probably seen a JPEG-encoded image. It is by far the most ubiquitous way of encoding, sending and storing images. From web pages to email to social media, JPEG is used billions of times a day—almost every time we view or send images online. Without JPEG, the web would be a little less colorful, a lot slower, and probably have far fewer cat pictures!</p><p>This article is about how to decode a JPEG image. In other words, it’s about what it takes to convert the compressed data stored on your computer to the image that appears on the screen. It’s worth learning about not just because it’s important to understand the technology we all use everyday, but also because, as we unravel the layers of compression, we learn a bit about perception and vision, and about what details our eyes are most sensitive to.</p><p>It’s also just a lot of fun to play with images this way.</p><br/></div><p><img src="https://parametric.press/issue-01/unraveling-the-jpeg/static/images/glitchy-cat.gif" idyll="[object Object]"/></p><div><div><p><em>Hint: try scrolling down and removing a few chunks. Don’t worry, you can always reset the image back to the original<!-- -->!</em><br/></p></div><p>There’s a lot you can learn just from playing around with this editor. For example, can you figure out the order the pixels are stored in?</p><p>Something strange in the example above is that changing some numbers doesn’t seem to impact the image at all, while <span>setting the 17 on line one to 0</span> completely ruins the image! Other actions, like <span>setting the 7 on line 1988 to 254</span> change the color, but only for subsequent pixels.</p><div><div><div><hr/><div><p><img src="https://parametric.press/issue-01/static/images/diamond.png"/></p><p>More from the Parametric Press</p></div><hr/></div></div></div><p>Perhaps what’s most peculiar is that some numbers change not just the color but the shape of the image as well. Change the <span>70 in line 12 to 2</span> and look at the top row of the image to see what I mean. No matter what JPEG image you’re using, you’ll always find these mysterious checkerboard patterns when editing the bytes.</p><p>It’s hard to decipher how the image can be reconstructed from these bytes by playing around like this, because JPEG compression is actually composed of three different compression techniques, which are applied in successive layers. We’ll look at each of these layers of compression separately to unravel this mysterious behavior we’re seeing.</p><div><h3>The three layers of JPEG compression</h3><ol><li>Chrominance Subsampling</li><li>Discrete Cosine Transform &amp; Quantization</li><li>Run-Length, Delta &amp; Huffman Encoding</li></ol></div><p>To give you an idea of the scale of this compression, notice that the image above is represented using exactly 79,819 numbers, which makes it about 79 kilobytes. If it were stored with no compression, three numbers would be needed for each pixel—one for each of the red, green and blue components. That would mean a total of 917,700 numbers, or about 917 kilobytes. With JPEG compression, the resulting file is over <strong>ten times smaller</strong>!</p><p>In fact, this image can be squeezed into far fewer bytes. Below is the image next to a version of it that was compressed down to just 16 kilobytes, which makes it <strong>fifty-seven times smaller</strong> than the uncompressed version would be!</p><p><img src="https://parametric.press/issue-01/unraveling-the-jpeg/static/images/compression-compare.png"/></p></div><div><div><p><em>Hint: Notice that removing one number ruins all the colors. But removing exactly <!-- -->6<!-- -->, or any multiple of <!-- -->6<!-- -->, has a minimal effect on the image.</em><br/></p></div><p>It’s a little more straightforward to decipher now. It’s almost a simple list of colors, where each byte changes exactly one pixel, and yet it’s already almost twice as small as the uncompressed image (which would be around 300 kb for this smaller size). Can you guess why?</p><p>You can tell that these numbers don’t represent the standard red, green and blue components because <span>replacing all the numbers with 0</span> turns the image green (as opposed to black).</p><p>This is because these bytes represent the <span>Y</span> (brightness), <span>Cb</span> (relative blueness), and <span>Cr</span> (relative redness) of the image.</p><p>Why not just use RGB? After all, that’s how most modern screens work. Your monitor can display any color by turning on red, green and blue lights at various intensities for each pixel. White is displayed by turning on all three colors at full brightness, while black is displayed by turning them all off.</p></div><div><div><p>
Hint: Try clicking on any pixel in the image to see the line in the editor that represents it. Try removing numbers from the end, or adding a few zeros to any individual number to make its effect more obvious.</p></div><p>At first glance, this seems like very poor compression. There are 100,000 pixels in this image, and yet it takes 102,400 numbers to represent the luminance of each pixel—that’s worse than not compressing it at all!</p><p>But notice that most of these values are 0. In fact, <span>all of these trailing zeros can be removed</span> with no change to the image. This leaves only about 26,000 numbers, which makes it about four times smaller!</p><p>In this layer lies the secret to the checkerboard patterns. Unlike the other effects we’ve seen, the appearance of these patterns is not a glitch. They are in fact the building blocks of the entire image. Every line in the editor above contains exactly 64 numbers, known as the Discrete Cosine Transform (DCT) coefficients, which correspond to intensities of 64 unique patterns.</p><p>These patterns are formed out of cosine waves. Here’s what a few of them look like:</p><p><img src="https://parametric.press/issue-01/unraveling-the-jpeg/static/images/dct_coefficients.png"/></p><p>
    These are 8 of the 64 discrete cosine transform coefficients. Credit: <a href="http://www.jezzamon.com/fourier/index.html">Jez Swanson</a>.
  </p><p>Below is an image that shows all 64 of them individually.</p></div><div><p>These patterns are special because they form a basis for 8x8 images. If you’re not familiar with linear algebra, what that means is that any 8x8 image, anything at all that you can imagine, can be made out of these specific 64 patterns. The Discrete Cosine Transform is the process of breaking up the image into 8x8 blocks and converting each block into a combination of these 64 coefficients. Here’s <span>how you would form a circle</span> by combining these patterns, or <span>the cat’s face</span>. You can <span>click here to go back to the grid of 64 patterns</span>.</p><p>It seems like magic to say that any image can be represented using 64 specific patterns. But this is the same thing as saying any location on the Earth can be represented using only two numbers: longitude and latitude. We often treat the surface of the Earth as two-dimensional, so only two numbers are needed. An 8x8 image is sixty-four-dimensional, so we need sixty-four numbers.</p><p>In terms of compression, it’s not obvious how this helps us. If we need sixty-four numbers to represent an 8x8 image, why is this better than storing the sixty-four luminance components? We do it for the same reason we converted from the three numbers of RGB to the three numbers of YCbCr: it allows us to remove detail that’s less noticeable.</p><p>It’s hard to see exactly what the details that are removed in this compression step look like because JPEG only applies the Discrete Cosine Transform to blocks of 8x8 pixels at a time. However, there’s no reason we can’t apply it to the whole image. Here’s what it looks like to apply the DCT to the Y component of the entire image:</p></div><div><p>We can <span>remove over 60,000 numbers</span> from the end with almost no noticeable change. But notice that if <span>we set just the first five numbers to zero</span> (ignoring the first because it just makes the image darker) there’s already an obvious difference.</p><div><div><div><hr/><div><p>Get updates from the Parametric Press</p></div><hr/></div></div></div><p>The numbers at the beginning represent the lower frequency changes in the image, which our eyes are better at detecting. The numbers towards the end represent the higher frequency changes, which are harder for us to see, so we don’t notice when they’re gone. To see “what our eyes can’t see”, we can isolate these high frequency details by setting the <span>first 5,000 numbers to zero</span>.</p><p>What you’re looking at here is all the areas of the image that have the greatest change from one pixel to the next. The cat’s eyes, whiskers, fuzzy blanket and shadows in the bottom left corner all stand out. This can be taken even further, to setting the first <span>10,000 numbers to zero</span>; <span>20,000</span>; <span>40,000</span> or <span>60,000</span>.</p><p>These high frequency details are what JPEG removes during this compression step. Converting the colors to the DCT coefficients is not a lossy operation. It’s the quantization step that’s lossy, where values that are high frequency, close to zero, or both, are removed. When you select a lower quality setting when creating a JPEG image, it increases the threshold for how many of these values are removed, which leads to a smaller file size but a blockier image. This is why the version of the image in the first section that was 57 times smaller looked blocky. Each 8x8 block was represented by far fewer DCT coefficients compared to the higher quality version.</p><div><p>
One really cool thing you can do with this technique is progressively stream pictures. Imagine seeing a blurry version of the whole image and slowly seeing it become more and more detailed as the download progresses and more DCT coefficients are available. This is actually possible to do with JPEG, but not as commonly used.</p></div><p>Just for fun, here’s what it looks like using just <span>24,000 numbers</span>, or just <span>5000 numbers</span>. Pretty blurry, but almost recognizable!</p><h2>3<!-- -->. Run-Length, Delta &amp; Huffman Encoding</h2><p>All the compression steps so far have been lossy. This last layer, by contrast, is lossless. It doesn’t remove any information, but it does make the file size significantly smaller.</p><p>How do you compress something without throwing away any information? Think about how you would represent a simple solid black image.</p></div><div><p>JPEG uses about 5,000 numbers to represent this, but we can do much better. Can you think of an encoding scheme to represent this image using as few bytes as possible?</p><p>The smallest I could think of was four bytes: three to specify the color and one to specify how many pixels have this color. The idea of expressing all repeated values concisely this way is called <strong>run-length encoding</strong>. It’s lossless because we can recover the encoded data exactly as it was before.</p><p>The file size of the solid black JPEG image is much bigger than four bytes because remember that in the DCT layer, the compression is applied to 8x8 blocks at a time. So at minimum we’ll need one DCT coefficient for each 64 pixel block. We only need one because instead of storing one DCT coefficient followed by 63 zeros for this image, run-length encoding allows us to just store one number and say “the rest are zero”.</p><p><strong>Delta-encoding</strong> is the technique of storing each byte as a relative value compared to something before it instead of storing its absolute value. This is the reason editing certain bytes will change the color for all subsequent pixels. For example, instead of storing:</p><pre><code>12 13 14 14 14 13 13 14</code></pre><p>You would start with 12, and from there, just store how much you need to add or subtract to get the next number. So once delta-encoded the sequence above becomes:</p><pre><code>12 1 1 0 0 -1 0 1</code></pre><p>Once again, the transformed data is not any smaller than the original, but it is more compressible. Applying delta encoding before run-length can help a lot, while still remaining a completely lossless compression step.</p><p>Delta encoding is one of the few techniques that is applied outside the 8x8 blocks. Out of the 64 DCT coefficients, the first one is just a constant wave function (you see it as a solid color). It represents the average brightness of each block for the luminance components, or the average blueness for the Cb components etc. This first value in each DCT block is called the DC value, and each DC value is delta-encoded relative to the ones before it. So changing the brightness of the very first block will affect all blocks in the image.</p><p>This all leaves just one final mystery: how can changing just a single number completely wreck the image? This was not a property of any of compression layers so far. The answer lies in the JPEG header. It’s the first 500 or so bytes that contain metadata about the image, like its width and height, and has been omitted from all the byte editors so far.</p><p>Below is the original image with the header included.</p></div><div><p>Without the header, it’s practically impossible (or at least very difficult) to decode the JPEG image. It would be as if I was trying to describe a painting to you, and I started to invent words to communicate what I saw. It’s probably going to be a very concise description, since I can define the words to mean exactly what I want to communicate, but it would be meaningless to anyone other than me.</p><p>This may sound ridiculous, but this is exactly what’s going on here. Every single JPEG image is compressed with a code that’s  specific to this particular image. These codes are defined in a dictionary stored in the header. This technique is called <strong>Huffman encoding</strong>, and the dictionary is called a Huffman table. This table is marked in the header by two bytes: 255 followed by 196. Each color component may have its own Huffman table.</p><p>Changes to these Huffman tables will have the most dramatic effects on any image. Changing <span>the second 1 to 12 on line 15</span> is a good example. Changing anything after the 125 on that line works too.</p><p>The Huffman tables have such a dramatic effect on the image because they tell us how to read the individual bits. So far we’ve just been dealing with the binary numbers in decimal. This hides the fact that if you want to store the number <i>1</i> in a byte, it would look like <em>0<!-- -->0<!-- -->0<!-- -->0<!-- -->0<!-- -->0<!-- -->0<!-- -->1</em>, because each byte must have exactly eight bits even if it only needs one bit.</p><p>This is potentially a huge waste of storage if you have a lot of small numbers. Huffman encoding is a technique that allows us to relax this requirement that each number must occupy eight bits. That means if you see the two bytes:</p><pre><code>234 115</code></pre><p>Based on the Huffman table, these could actually be three values. To extract them, you’ll need to first break them into their individual bits:</p><pre><code>11101010 01110011</code></pre><div><div><p>
  One neat trick you can do with this knowledge is strip out the header from a JPEG image and save it separately. You’re effectively making it so only you can read it. <a href="https://code.fb.com/android/the-technology-behind-preview-photos/" target="_blank">Facebook actually does this</a> to make JPEG images even smaller.</p><p>Another thing you can do is change the Huffman table just slightly. To anyone else, it looks like a corrupted image. But only you would know the magic edit needed to fix it.</p></div></div><p>Then follow the table to figure out how to group them. For example, it could be the first six bits (111010) which is 58 in decimal, followed by another five bits (10011) which is 19 and finally the last four bits (0011), which is three.</p><p>This is why it’s very difficult to make sense of the bytes at this layer of compression. The bytes don’t actually represent what they seem to represent. I won’t go into the details of how to extract the Huffman table and translate the bits in this article, but there are <span><span data-tip="true" data-for="parametric-reference-1" data-event="click focus">many good resources on this if you’re curious</span></span>.</p><hr/><p>So to summarize, what all does it take to decode a JPEG image? You need to:</p><ol><li>Extract the Huffman table(s) from the header and decode the bits.</li><li>Extract the Discrete Cosine Transform coefficients for each color<!-- -->/luminance component, for each <!-- -->8<!-- -->x<!-- -->8<!-- --> block, by undoing the run-length and delta encodings.</li><li>Combine the cosine waves based on the coefficients to get back the pixel values for each <!-- -->8<!-- -->x<!-- -->8<!-- --> block (this is known as the inverse Discrete Cosine Transform).</li><li>Scale up the chrominance components if they were subsampled (the header has this information).</li><li>Convert the resulting YCbCr of each pixel to RGB.</li><li>Display the image<!-- -->!</li></ol><p>
That’s a lot of work to view a simple cat picture! But what I love about this is that you can see how JPEG is a very human-centric technology. It relies on the quirks of our perception to achieve compression rates far greater than is possible with general purpose techniques. And now that you understand how JPEG works, you can imagine how many of these techniques can be extended to other domains. For example, applying delta-encoding in video can produce a huge file size reduction since there are often areas that don’t change at all between frames (such as the background).</p><p>All the code for this article is <a href="https://github.com/ParametricPress/01-unraveling-the-jpeg">open source</a> and includes instructions on replacing the images in these byte editors with your own.</p><div><p><b><a href="https://omarshehata.me/">Omar Shehata</a></b> is a graphics programmer at Cesium working on open source, web-based 3D maps. He grew up in Alexandria, Egypt and currently lives in Philadelphia, PA.</p><p>Edited by Matthew Conlen and Victoria Uren.</p></div></div></div></div></div></div>
  </body>
</html>
