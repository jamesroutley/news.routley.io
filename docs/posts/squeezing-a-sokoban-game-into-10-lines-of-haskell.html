<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cole-k.com/2023/02/21/tiny-games-hs/">Original</a>
    <h1>Squeezing a Sokoban game into 10 lines of Haskell</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">
            

            <div id="container">


<div>
    <article itemscope="" itemtype="http://schema.org/BlogPosting">
        


        <div itemprop="articleBody">
    

    <p>If you’re only interested in seeing or playing the game, you can find it <a href="https://github.com/cole-k/call-by-push-block">on my
GitHub</a>.</p>

<p>The <a href="https://github.com/haskell-game/tiny-games-hs">Haskell Tiny Game Jam</a> is a
game jam which challenges participants to write a video game in Haskell using 10
lines of 80 characters. I happen to love Haskell and code golf (abusing a
programming language to produce disgustingly short code for fun) so I decided to
enter the Feb ‘23 jam.</p>

<p>My game is called
<a href="https://github.com/cole-k/call-by-push-block">Call-by-push-block</a>. It’s a
<a href="https://en.wikipedia.org/wiki/Sokoban">Sokoban</a>, or block-pushing game, where
you take a lambda code golfing (“golfing” here is meant a little more
literally).</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/9fc7249304622e8f211b1be7a38db820fc845557/9a2b9/img/call-by-push-block-demo.gif" alt="A gif of the first level of Call-by-push-block"/></p><p>I started with an initial game that had player movement, pushing a single block,
and a single test level. I already had employed a few code golfing tricks, but
the code stood at 40 lines and was reasonably legible.</p>
<p>Many ugly hacks later, I ended up with a game that also included a level and
score counter, undoing, resetting, pushing arbitrarily many blocks, 14 levels,
and some other features to be discovered by the player. It stands at exactly 10
lines of 80 characters. It is disgusting and I’m fiercely proud of it.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>n</span><span>=</span><span>&#34;噞㋪㛃䚬摣ۜ㝜ቲ㜑昫⫛㍋勓ㅋ⩞䤤㱪㳃䊩㓛⤤㳝ᙪ㛅Ⳝ㩛㚙㛦䥢㔬㜞㋖⛍㣛戛㙉ኛ㙎ኛ孶抭安Ჭ㱉㚛㛛ᰛ⯙瞎㤅⛛牶䢯㛛㣠⭤㳳㑌䜜㚿㛛䜓缣㛚≣㶳ㅬ㛜㛛䛚㛛暛㛣⛛䤤䣤&#34;</span>
</span></span><span><span><span>e</span><span>(</span><span>&#39;λ&#39;</span><span>:</span><span>c</span><span>)</span><span>|</span><span>(</span><span>a</span><span>,</span><span>b</span><span>)</span><span>&lt;-</span><span>span</span><span>(</span><span>&gt;</span><span>&#39;n&#39;</span><span>)</span><span>c</span><span>=</span><span>u</span><span>(</span><span>u</span> <span>a</span><span>#</span><span>m</span> <span>1</span> <span>b</span><span>)</span><span>%</span><span>e</span><span>(</span><span>y</span> <span>b</span><span>);</span><span>e</span><span>(</span><span>c</span><span>:</span><span>d</span><span>)</span><span>=</span><span>c</span><span>:</span><span>e</span> <span>d</span><span>;</span><span>e</span> <span>l</span><span>=</span><span>l</span><span>;</span><span>k</span><span>=</span><span>&#34;λ.&#34;</span><span>;</span><span>m</span><span>=</span><span>take</span>
</span></span><span><span><span>v</span><span>(</span><span>x</span><span>:</span><span>_</span><span>)</span><span>=</span><span>c</span> <span>x</span><span>`</span><span>mod</span><span>`</span><span>7</span><span>;</span><span>v</span> <span>_</span><span>=</span><span>0</span><span>;</span><span>l</span><span>=</span><span>print</span><span>;</span><span>s</span><span>=</span><span>[]:</span><span>s</span><span>;</span><span>c</span><span>=</span><span>fromEnum</span><span>;</span><span>i</span><span>=</span><span>&#34;</span><span>\n</span><span>o .#_λ+&#34;</span><span>;</span><span>y</span><span>=</span><span>drop</span> <span>1</span><span>;(</span><span>%</span><span>)</span><span>=</span><span>(</span><span>++</span><span>)</span>
</span></span><span><span><span>e</span><span>&amp;</span><span>0</span><span>=</span><span>u</span><span>.</span><span>t</span><span>;</span><span>f</span><span>&amp;</span><span>_</span><span>=</span><span>f</span><span>;</span><span>p</span><span>=</span><span>putStr</span><span>;(</span><span>1</span><span>?</span><span>f</span><span>)</span><span>x</span><span>=</span><span>z</span> <span>x</span><span>;(</span><span>5</span><span>?</span><span>f</span><span>)</span><span>x</span><span>=</span><span>y</span> <span>x</span><span>%</span><span>z</span> <span>x</span><span>%</span><span>z</span> <span>x</span><span>;(</span><span>i</span><span>?</span><span>f</span><span>)</span><span>x</span><span>=</span><span>(</span><span>f</span><span>&amp;</span><span>i</span><span>$</span><span>r</span> <span>e</span><span>$</span><span>f</span><span>$</span><span>head</span> <span>x</span><span>)</span><span>:</span><span>x</span>
</span></span><span><span><span>r</span><span>=</span><span>map</span><span>;</span><span>main</span><span>=</span><span>print</span><span>=&lt;&lt;</span><span>(</span><span>mapM</span> <span>g</span><span>.</span><span>zip</span><span>[</span><span>1</span><span>..</span><span>]</span><span>.</span><span>r</span><span>(</span><span>pure</span><span>.</span><span>words</span><span>)</span><span>.</span><span>lines</span><span>$</span><span>r</span><span>(</span><span>i</span><span>!!</span><span>)</span><span>.</span><span>m</span> <span>5</span><span>.</span><span>w</span><span>=&lt;&lt;</span><span>r</span> <span>c</span><span>(</span><span>n</span><span>%</span><span>x</span><span>))</span>
</span></span><span><span><span>g</span><span>(</span><span>k</span><span>,</span><span>o</span><span>)</span><span>|</span><span>any</span><span>(</span><span>elem</span> <span>&#39;_&#39;</span><span>)</span><span>$</span><span>head</span> <span>o</span><span>=</span><span>do</span><span>{</span><span>k</span><span>!</span><span>o</span><span>;</span><span>p</span> <span>b</span><span>;</span><span>i</span><span>&lt;-</span><span>v</span><span>&lt;$&gt;</span><span>d</span><span>;</span><span>g</span><span>(</span><span>k</span><span>,</span><span>i</span><span>?</span><span>([</span><span>t</span><span>.</span><span>u</span><span>,</span><span>t</span><span>,</span><span>id</span><span>,</span><span>t</span><span>,</span><span>t</span><span>,</span><span>t</span><span>,</span><span>r</span> <span>u</span><span>]</span><span>!!</span><span>i</span><span>)</span><span>$</span>
</span></span><span><span><span>o</span><span>)};</span><span>g</span><span>(</span><span>k</span><span>,</span><span>x</span><span>)</span><span>=</span><span>a</span> <span>x</span><span>&lt;$</span><span>k</span><span>!</span><span>x</span><span>&lt;*</span><span>p</span><span>&#34;↩&#34;</span><span>&lt;*</span><span>d</span><span>;</span><span>t</span><span>=</span><span>foldr</span><span>(</span><span>zipWith</span><span>(</span><span>:</span><span>))</span><span>s</span><span>;</span><span>z</span><span>=</span><span>m</span> <span>1</span><span>.</span><span>u</span><span>;</span><span>w</span> <span>n</span><span>=</span><span>n</span><span>`</span><span>mod</span><span>`</span><span>8</span><span>:</span><span>w</span><span>(</span><span>n</span><span>`</span><span>div</span><span>`</span><span>8</span><span>)</span>
</span></span><span><span><span>n</span><span>!</span><span>x</span><span>@</span><span>(</span><span>s</span><span>:</span><span>_</span><span>)</span><span>=</span><span>p</span><span>&#34;</span><span>\^[</span><span>cLvl &#34;</span><span>*&gt;</span><span>l</span> <span>n</span><span>*&gt;</span><span>l</span><span>(</span><span>a</span> <span>x</span><span>)</span><span>*&gt;</span><span>p</span><span>(</span><span>unlines</span> <span>s</span><span>);</span><span>d</span><span>=</span><span>getLine</span><span>;(</span><span>_</span><span>:</span><span>r</span><span>)</span><span>#</span><span>&#34;&#34;</span><span>=</span><span>r</span><span>%</span><span>k</span><span>;</span><span>_</span><span>#</span><span>&#34;&#34;</span><span>=</span><span>&#34;.&#34;</span>
</span></span><span><span><span>n</span><span>#</span><span>&#34;.&#34;</span><span>=</span><span>n</span><span>%</span><span>k</span><span>;(</span><span>_</span><span>:</span><span>r</span><span>)</span><span>#</span><span>&#34;+&#34;</span><span>=</span><span>&#39;.&#39;</span><span>:</span><span>r</span><span>%</span><span>k</span><span>;</span><span>_</span><span>#</span><span>&#34;+&#34;</span><span>=</span><span>&#34;..&#34;</span><span>;(</span><span>&#39;o&#39;</span><span>:</span><span>r</span><span>)</span><span>#</span><span>&#34;_&#34;</span><span>=</span><span>&#39;O&#39;</span><span>:</span><span>r</span><span>%</span><span>k</span><span>;</span><span>l</span><span>#</span><span>x</span><span>=</span><span>x</span><span>%</span><span>l</span><span>%</span><span>&#34;λ&#34;</span><span>;</span><span>u</span><span>=</span><span>reverse</span>
</span></span><span><span><span>a</span><span>=</span><span>length</span><span>;</span><span>b</span><span>=</span><span>&#34;λ:wasd 🔄:x 🔙:u</span><span>\n</span><span>&#34;</span><span>;</span><span>x</span><span>=</span><span>&#34;ᴔ翉䕿䤤䜣㛚㣛㢛䛳۳四⛛竛⛛笛⛛禣✤ባ⦉档✌䡣✌ቴ✙䤣✴㛛ۣ廛⛟盻⟛㛛⛛䌜⣡㞛⛳㣣✜幜⣏㛜ࣛ&#34;</span>
</span></span></code></pre></div><p>In this post, I’ll give you several tips that you can use to reduce your own
Sokoban game to a mess of letters and operators like the one above.</p>

<p>Do you like descriptive function names?</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>resolveMove</span> <span>index</span> <span>modifyGrid</span> <span>=</span> <span>undoMove</span> <span>modifyGrid</span> <span>index</span> <span>.</span> <span>map</span> <span>move</span> <span>.</span> <span>head</span> <span>$</span> <span>gameGrid</span>
</span></span></code></pre></div><p>Too bad, it’s too many characters.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>r</span> <span>i</span> <span>f</span> <span>=</span> <span>u</span> <span>f</span> <span>i</span> <span>.</span> <span>o</span> <span>m</span> <span>.</span> <span>head</span> <span>$</span> <span>x</span>
</span></span></code></pre></div><p>Think Haskell has too many arcane operators? Sorry, it’s shorter.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>i</span><span>?</span><span>f</span> <span>=</span> <span>(</span><span>f</span><span>&amp;</span><span>i</span><span>)</span> <span>.</span> <span>o</span> <span>m</span> <span>.</span> <span>head</span> <span>$</span> <span>x</span>
</span></span></code></pre></div><p>Does this disgust you yet? It should, because we have to put parens around <code>i&amp;f</code>
to prevent GHC from getting confused by operator precedence. And someone left in
spaces!!</p>
<p>Much better. Now slap a semicolon on it and jam it in somewhere.</p>
<p>(My challenge to you for this tip and the other ones that have code: see if you
can find the actual source code corresponding to its example. Just like with the
Tiny Game Jam, there is no prize other than your self-satisfaction.)</p>

<p>My game has 6 controls: <code>wasd</code> for directional movement, <code>x</code> for resetting, and
<code>u</code> for undoing. The way I would properly approach handling inputs would be
something like</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>data</span> <span>Input</span> <span>=</span> <span>Up</span> <span>|</span> <span>Left</span> <span>-- ...</span>
</span></span><span><span>
</span></span><span><span><span>charToInput</span> <span>c</span> <span>=</span> <span>case</span> <span>c</span> <span>of</span>
</span></span><span><span>  <span>&#39;w&#39;</span> <span>-&gt;</span> <span>Up</span>
</span></span><span><span>  <span>&#39;a&#39;</span> <span>-&gt;</span> <span>Left</span>
</span></span><span><span>  <span>-- ...</span>
</span></span><span><span>  <span>&#39;u&#39;</span> <span>-&gt;</span> <span>Undo</span>
</span></span><span><span>
</span></span><span><span><span>gameLoop</span> <span>gameGrid</span> <span>=</span> <span>do</span>
</span></span><span><span>  <span>c</span> <span>&lt;-</span> <span>getChar</span>
</span></span><span><span>  <span>handleInput</span> <span>(</span><span>charToInput</span> <span>c</span><span>)</span> <span>gameGrid</span>
</span></span></code></pre></div><p>We’re already over 10 lines and I’m trying to be terse in my example. Not only
that, the <code>case</code> keyword and each <code>-&gt;</code> takes up so much space.</p>
<p>Instead, we can think like C programmers and use the
<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#t:Enum"><code>Enum</code></a>
instance for <code>Char</code>, for which <code>fromEnum</code> produces a char code. Then we just
need to find a modulus where <code>wasdxu</code> are unique and we can use <code>fromEnum c</code> in
that modulus to index into a list of commands. Luckily for us, 7 gives unique
values.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>charToInput</span> <span>c</span> <span>=</span> <span>fromEnum</span> <span>c</span> <span>`</span><span>mod</span><span>`</span> <span>7</span>
</span></span><span><span>
</span></span><span><span><span>gameLoop</span> <span>gameGrid</span> <span>=</span> <span>do</span>
</span></span><span><span>  <span>c</span> <span>&lt;-</span> <span>getChar</span>
</span></span><span><span>  <span>let</span> <span>command</span> <span>=</span> <span>[</span><span>moveRight</span><span>,</span> <span>moveLeft</span><span>,</span> <span>...</span><span>]</span> <span>!!</span> <span>charToInput</span> <span>c</span>
</span></span><span><span>  <span>command</span> <span>gameGrid</span>
</span></span></code></pre></div><p>“Hold on,” you might stop me, “What about the other index mod 7 that none of
<code>wasdxu</code> map to?” Good question, just put the smallest variable you can get to
type check there. All keys will do something, but we will only tell the
players what 6 of them do.</p>

<p>There are 610 characters used across all the levels in Call-by-push-block. A
careful reader will observe that there are not 610 characters worth of strings
in my code. So where do they live? In the horrifying Unicode strings on the
first and last lines.</p>
<p>I need 8 unique characters for my levels: 6 for tiles and 2 for separators. A
limited tileset like this allows you to smush 5<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> tiles into a single Unicode
character. The relevant loophole here is that the judges count characters, not
bytes<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, so this cuts the levels’ footprint by a factor of 5.</p>
<p>Here’s how you can encode your levels. Start with the characters list. First,
map each tile to a number between 0 and 7. Now you have a list of digits in
base 8. Next, take 5 digits at a time, interpret them as a number in base 8, and
convert to decimal. Now you have a list of decimal numbers that is 1/5 the size
of the original. Interpret the decimal numbers as Unicode characters and you’re
done.</p>
<p>One small wrinkle: GHC doesn’t allow raw strings and requires strings to contain
printable Unicode. To work around this, I simply iterated over every possible
permutation of digits to assign my tiles, encoded my levels, and checked the
characters in each encoding against
<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Unicode.html#v:isPrint"><code>GHC.Unicode.isPrint</code></a>.
There were a bunch of printable encodings so I picked one that had funny emoji
in it.</p>
<p>With this trick, you can go from half of a single level</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>x</span><span>=</span><span>&#34;oλoo.... ooλλ_____ oλooλ____ λooooλ... .........&#34;</span>
</span></span></code></pre></div><p>to a little over two much bigger levels</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>x</span><span>=</span><span>&#34;ᴔ翉䕿䤤䜣㛚㣛㢛䛳۳四⛛竛⛛笛⛛禣✤ባ⦉档✌䡣✌ቴ✙䤣✴㛛ۣ廛⛟盻⟛㛛⛛䌜⣡㞛⛳㣣✜幜⣏㛜ࣛ&#34;</span>
</span></span></code></pre></div><p>Even though it doesn’t look it, the latter is fewer characters, too.</p>
<p>If this tip would actually be helptful to your own tiny game, then you can check
out <a href="https://github.com/cole-k/call-by-push-block/blob/main/encode-levels/Encode.hs">the code I wrote for
it</a>
(warning: it is gross and uncommented) and refer to the decoding function in my
golfed code, which of writing is named <code>w</code> (I shouldn’t need to warn you about this one).</p>

<p>A Haskell file is basically just a bunch of variable declarations. The same is
true for a very golfed one, it’s just harder to make them out. I count about 30
variables in my game.</p>
<p>Often when golfing you can reduce the overall character count by moving around
some logic, resulting in one line being 2 characters over and another 5 under,
for a net gain of 3 characters.</p>
<p>What do you do after this? Rearrange the variables so that all of the lines are
within the character limit.</p>
<p>Sound hard? That’s because it’s NP-Hard.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> It’s an instance of the <a href="https://en.wikipedia.org/wiki/Bin_packing_problem">Bin
packing problem</a> where the
items are variables, sizes are their lengths, and bins are each of the 10 lines.
Have fun and don’t forget that you need semicolons to separate your
variables!<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>

<p>The grid of tiles in my game is just a list of of list of <code>Char</code>s. An
unfortunate downside of Haskell lists being linked lists is that it is much
harder to move vertically in the grid than it is to move horizontally. Should
you encode your grid the same way, there is good news! All you need to do is
write code that moves the player to the right.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>moveRight</span> <span>::</span> <span>[[</span><span>Char</span><span>]]</span> <span>-&gt;</span> <span>[[</span><span>Char</span><span>]]</span>
</span></span></code></pre></div><p>Need to move to the left? Reverse all of the rows first, move right, then
unreverse them.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>moveLeft</span> <span>=</span> <span>map</span> <span>reverse</span> <span>.</span> <span>moveRight</span> <span>.</span> <span>map</span> <span>reverse</span>
</span></span></code></pre></div><p>Need to move down? Transpose the grid, move right, then untranspose it.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>moveDown</span> <span>=</span> <span>transpose</span> <span>.</span> <span>moveRight</span> <span>.</span> <span>transpose</span>
</span></span></code></pre></div><p>Barring moving up (which I have conveniently omitted), we can abstract a pattern
out:</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>move</span> <span>dir</span> <span>=</span> <span>transformation</span> <span>.</span> <span>moveRight</span> <span>.</span> <span>transformation</span>
</span></span><span><span>  <span>where</span>
</span></span><span><span>    <span>-- 0 = right, 1 = left, 2 = down, 3 = up??? &gt;:(</span>
</span></span><span><span>    <span>transformation</span> <span>=</span> <span>[</span><span>id</span><span>,</span> <span>map</span> <span>reverse</span><span>,</span> <span>transpose</span><span>,</span> <span>undefined</span><span>]</span> <span>!!</span> <span>dir</span>
</span></span></code></pre></div><p>Maybe smart math people can figure out a way to do upward movement that doesn’t
require annoying special casing. If you figure it out, don’t tell me since it
means I’ll have to make more levels. With the special casing for moving up,
you’ll end up with something like</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>move</span> <span>dir</span> <span>=</span> <span>undo</span> <span>dir</span> <span>transformation</span> <span>.</span> <span>moveRight</span> <span>.</span> <span>transformation</span>
</span></span><span><span>  <span>where</span>
</span></span><span><span>    <span>-- 0 = right, 1 = left, 2 = down, 3 = up</span>
</span></span><span><span>    <span>transformation</span> <span>=</span> <span>[</span><span>id</span><span>,</span> <span>map</span> <span>reverse</span><span>,</span> <span>transpose</span><span>,</span> <span>transpose</span> <span>.</span> <span>reverse</span><span>]</span> <span>!!</span> <span>dir</span>
</span></span><span><span>
</span></span><span><span><span>undo</span> <span>3</span> <span>_</span> <span>=</span> <span>reverse</span> <span>.</span> <span>transpose</span> <span>-- special case for undoing &#39;transpose . reverse&#39;</span>
</span></span><span><span><span>undo</span> <span>_</span> <span>f</span> <span>=</span> <span>f</span>                   <span>-- everything else undoes itself</span>
</span></span></code></pre></div>
<p>The <a href="https://github.com/haskell/haskell-language-server">Haskell Language
Server</a> is a helpful tool
for doing proper Haskell development. It can also help with improper development
if it’s not busy freaking out about all of your missing type signatures.</p>
<p>Throughout the course of golfing, you might end up with code like</p>
<p>Spot the mistake? You don’t need to! HLS will helpfully report</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>Redundant $ found,
</span></span><span><span>  Found: (l !! x) $ y
</span></span><span><span>  Why not: (l !! x) y
</span></span></code></pre></div><p>Make sure to ignore the spaces in its suggestions though, those are for proper
developers.</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/fe907df08a9e8364ba763b8da9303542fc9cb5ca/1c40b/img/tiny-games-hs-hls.png" alt="HLS trying to insert type definitions on the side of my code"/></p><p>Look how hard at work HLS is. Does proper code even need type signatures?</p>

<p>It’s often said that authors have difficulty finding flaws in their own works
because they know them so well. Empty your mind and let inscrutable code be your
superpower.</p>
<p>Ignore all but the single function you need to update. Once it’s done and your
code now has a bug, you’ll likely find spots you missed as you mentally trace
the haphazard path your code follows when it executes. These spots might be
things like</p>
<ul>
<li>A short alias for a function that in fact makes your code longer</li>
<li>A completely unused function (I guess HLS was too busy trying to fill in type
signatures to inform me)</li>
<li>Two of the same function written with different names</li>
</ul>
<p>Proof that the method works: I shaved three characters off while trying to
understand code I refer to in this blog post.</p>

<p>Originally, my game did not have an undo. Adding undo was the number
two request<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> from my playtesters. I also wanted to
add a move counter to give some replayability since my game didn’t utilize
randomness.</p>
<p>I initially dismissed my playtesters’ requests as unreasonable and my own as
unnecessary. Then I forgot how to solve a level I was pretty sure was solvable
and decided adding an undo was a good idea. Unfortunately I was already at the
character cap. What allowed me to add both undoing and move tracking was
refactoring how I reset the game grid.</p>
<p>My game loop took a tuple containing the current grid and the initial grid.
Resetting replaced the grid with the initial grid.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>,</span> <span>initialGrid</span><span>)</span> <span>Reset</span> <span>=</span> <span>(</span><span>initialGrid</span><span>,</span> <span>initialGrid</span><span>)</span>
</span></span><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>,</span> <span>initialGrid</span><span>)</span> <span>input</span> <span>=</span> <span>(</span><span>move</span> <span>grid</span> <span>input</span><span>,</span> <span>initialGrid</span><span>)</span>
</span></span></code></pre></div><p>Let’s forget about resetting for a second and change this to just support
undoing. Instead of keeping track of the <code>initialGrid</code>, we can keep a list of
every past grid. Then if we want to undo, we just replace the current grid with
the grid that came before it. When we make any other move, we now we have to
add the current grid to the list of past grids.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>,</span> <span>(</span><span>pastGrid</span><span>:</span><span>olderGrids</span><span>))</span> <span>Undo</span> <span>=</span> <span>(</span><span>pastGrids</span><span>,</span> <span>olderGrids</span><span>)</span>
</span></span><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>,</span> <span>pastGrids</span><span>)</span> <span>input</span>            <span>=</span> <span>(</span><span>move</span> <span>grid</span> <span>input</span><span>,</span> <span>grid</span><span>:</span><span>pastGrids</span><span>)</span>
</span></span></code></pre></div><p>This works well, but there’s way too many parens and other stuff going on. It’s
fewer characters if we put the current grid onto the front of the list.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>:</span><span>pastGrids</span><span>)</span> <span>Undo</span>  <span>=</span> <span>pastGrids</span>
</span></span><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>:</span><span>pastGrids</span><span>)</span> <span>input</span> <span>=</span> <span>move</span> <span>grid</span> <span>input</span> <span>:</span> <span>grid</span> <span>:</span> <span>grids</span>
</span></span></code></pre></div><p>Now for resetting. The cruel game dev would just say “reset = undo many times.”
I like to think I’m not that cruel. Fortunately, we can reset without too much
trouble by removing everything except the last element.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>grids</span> <span>Reset</span> <span>=</span> <span>[</span><span>last</span> <span>grids</span><span>]</span>
</span></span></code></pre></div><p>Remember how I said I wanted to add a move counter? Before, this would require
threading the counter through my game loop, which would take a bunch more
characters. Now with the new list-based format, the number of moves is just the
length of <code>grids</code>. Well, technically the length of <code>grids</code> minus one since the
initial grid doesn’t count toward a move.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></p>
<p>The astute reader will observe that there are few issues with this
implementation. The first is that this function is partial and will crash the
game if you try to undo from the initial state. The second is that the <del>move</del>
score counter doesn’t count undos because undoing decreases the length of the
list. We can fix both of these by just throwing some copies<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> of the initial grid
onto the end of the <code>grids</code> list whenever we undo.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>grids</span> <span>Undo</span>     <span>=</span> <span>tail</span> <span>grids</span> <span>++</span> <span>initialGrid</span> <span>grids</span> <span>++</span> <span>initialGrid</span> <span>grids</span>
</span></span><span><span><span>handleInput</span> <span>grids</span> <span>Reset</span>    <span>=</span> <span>initialGrid</span> <span>grids</span>
</span></span><span><span><span>handleInput</span> <span>(</span><span>grid</span><span>:</span><span>pastGrids</span><span>)</span> <span>input</span> <span>=</span> <span>move</span> <span>grid</span> <span>input</span> <span>:</span> <span>grid</span> <span>:</span> <span>grids</span>
</span></span><span><span>
</span></span><span><span><span>initialGrid</span> <span>grids</span> <span>=</span> <span>[</span><span>last</span> <span>grids</span><span>]</span>
</span></span></code></pre></div><p>It’s still technically partial but who cares other than HLS?</p>

<p>I spent a lot of time staring at the garbled mess that is 809 characters of the
tersest possible Haskell you can write using Prelude. It takes willpower to keep
searching for more ways to cut another characters off. Here are three possible
motivations.</p>
<h3 id="create-levels-with-reckless-abandon">Create levels with reckless abandon</h3>
<p>A thoughtful tiny game jam developer might design levels with a character count
in mind. I just sort of made levels until I felt I couldn’t come up with any
more interesting ideas. At that point, I ended up about 20 characters in the
red. So I golfed 20 characters off.</p>
<h3 id="the-tile-calculus">The tile calculus</h3>
<p>I’m used to golfing 30-character programs where removing a single character is a
pretty big accomplishment. In an 809-character program, the value of a single
character can be harder to appreciate. That is, until I implemented tile
compression.</p>
<p>If you compress your tiles, suddenly the two ’e’s in the word “Level” represent
a quarter of a level. The four characters you save by replacing “Reset” with
“🔄” are another half.</p>
<p>With this mindset, even a cutting a single character could result in a small
level that teaches how a new mechanic works.</p>
<h3 id="rick-roll-the-judges">Rick Roll the judges</h3>
<p>Did you happen to read the first column of my game’s source?</p>
<p>As I was writing up this post, I noticed that almost every single line began
with a variable. At a first glance, “never gonna” wouldn’t work because
variables need to be unique. I realized, however, that I was <em>very</em> close to
being able to rearrange some infix function definitions so that the variable
bound was at the beginning of the line. This would allow me to shadow an
existing variable and therefore duplicate a letter.</p>
<p>To do this would require me rearranging lines and golfing at least one character
off of an infix function. So, well, I set out to do that and in the process I
actually discovered some more tricks to cut off three characters total.</p>
<p>Never underestimate the creativity born out of desire to make a stupid joke.</p>

<p>Although code golfing is an ultimately frivilous endeavor, I had a lot of fun
trying to fit as much as I could into my game and I’m pleased with how it turned
out. I especially enjoyed asking my friends, “Hey, do you want to play this game
I made?” and just sending them 10 lines of nonsense that somehow spits out a
video game when fed into GHC. While I don’t expect you to ever make (serious)
use of these tips, I hope you liked them.</p>
<p>Call-by-push-block can be found as a submission on the Feb ‘23 <a href="https://github.com/haskell-game/tiny-games-hs">Haskell Tiny
Game Jam</a>. And if you enjoyed
this content, be sure to check out the other tiny games there too!</p>
<p>Detailed instructions on running Call-by-push-block (including in your browser)
can be found <a href="https://github.com/cole-k/call-by-push-block">on my GitHub</a>.</p>

<h2 id="being-able-to-undo-past-resets">Being able to undo past resets</h2>
<p><a href="https://lobste.rs/s/griauf/squeezing_sokoban_game_into_10_lines_code#c_akuc1z">In a comment on
Lobste.rs</a>,
hwayne suggested making undos work across resets. For example, reset then undo
should bring you back to the state you were in originally. <a href="https://lobste.rs/s/griauf/squeezing_sokoban_game_into_10_lines_code#c_eu6twu">I replied
</a>
with a 2 character change to my code to support it. In that reply, I challenge
you to find where I made the change, but here I’ll explain what the change is.</p>
<p>I described in <a href="#kill-many-birds-with-one-stone">Kill many birds with one stone</a>
how resetting replaces the grid list with the initial grid.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>grids</span> <span>Reset</span> <span>=</span> <span>[</span><span>last</span> <span>grids</span><span>]</span>
</span></span></code></pre></div><p>In order to support undos across resets, we can instead put the initial grid at
the front of the list.</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>handleInput</span> <span>grids</span> <span>Reset</span> <span>=</span> <span>last</span> <span>grids</span> <span>:</span> <span>grids</span>
</span></span></code></pre></div><p>It’s really that easy.</p>
<p>Unfortunately, it does have a cost: resets no longer reset the score. Instead,
they’re counted the same as any other move. This goes against my game developer
philosophy, but I might end up changing my mind and implementing this feature in
my submission. Thanks, hwayne!</p>

<p>My website is janky and doesn’t support commenting (sorry!). If you’d like to
leave a comment, feel free to do so on
<a href="https://reddit.com/r/haskell/comments/11953ov/squeezing_a_sokoban_game_into_10_lines_of_code/">Reddit</a>
or
<a href="https://lobste.rs/s/griauf/squeezing_sokoban_game_into_10_lines_code">Lobste.rs</a>.</p>


</div>

        

        
    </article>
</div>

            </div>
        </div></div>
  </body>
</html>
