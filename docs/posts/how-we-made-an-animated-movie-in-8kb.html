<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ctrl-alt-test.fr/2024/how-we-made-an-animated-movie-in-8kb">Original</a>
    <h1>How we made an animated movie in 8kB</h1>
    
    <div id="readability-page-1" class="page"><div>
			
<p>In November 2022, we set ourselves a challenge: make a real-time animation that looks like a standard short animated movie, with the constraint that it should fit in 8 kilobytes. The goal was to have decent graphics, animations, direction and camera work, and the matching music… Yes, 8 kilobytes, less than half of this post, for everything. It wasn’t clear how much was actually feasible, so we had to try it.</p>



<p>In April 2023, after months of work, we finally released <a href="https://www.ctrl-alt-test.fr/the-sheep-and-the-flower/">The Sheep and the Flower</a>. You can run it by yourself (<a href="https://aduprat.com/pub/The_Sheep_and_the_Flower.zip">download link</a>), or see a YouTube capture of the program running:</p>



<figure><p>
<iframe title="The Sheep and the Flower - Razor 1911 &amp; Ctrl-Alt-Test (8kB demo)" width="625" height="352" src="https://www.youtube.com/embed/-dNqYrP3QHU?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</p></figure>



<p>Many people asked how we were able to create something like this. This article will explain the technical details and design constraints behind this production. We’ve also made the <a href="https://github.com/ctrl-alt-test/mouton">source code public on GitHub</a>.</p>



<h2>Overview</h2>



<p>The result is a Windows executable file. It’s a single .exe file that generates everything. It requires no resource file, no external depency, except for Windows and up-to-date drivers. </p>



<p>Here’s the quick summary of what we used. We’ll explain the details in the rest of the post.</p>



<ul>
<li>All the visuals are computed in real-time on the GPU, using GLSL shaders. This includes the timeline information, camera setup, etc.</li>



<li>The rendering is done with raymarching.</li>



<li>The shaders are minified using my own tool, <a href="https://github.com/laurentlb/shader_Minifier">Shader Minifier</a>.</li>



<li>The music was composed using <a href="https://openmpt.org/">OpenMPT</a> and the <a href="https://github.com/hzdgopher/4klang">4klang</a> synthesizer, which generates an assembly file able to replay the music. The instruments are described procedurally, while the list of notes is simply compressed.</li>



<li>The code was written in C++ using Visual Studio 2022.</li>



<li>To get started with the compiler flags and initialization, we used the <a href="https://github.com/armak/Leviathan-2.0/">Leviathan</a> framework.</li>



<li>The final output was compressed using <a href="https://github.com/runestubbe/Crinkler">Crinkler</a>.</li>
</ul>



<h2>Genesis</h2>



<p>One day, I saw a message from a former colleague, who shared a video he made a long time ago, called <a href="https://www.youtube.com/watch?v=khWXdkryBE4">Capoda</a>. I immediately loved the concept. The content is simple, yet it manages to tell a story efficiently.</p>



<p>I shared the link with some friends and thought it could be a good example of a story suitable for size coding. I was about to add this concept to the list of cool things I’ll probably never do, when Anatole replied:</p>



<blockquote>
<p><em>Looks like a perfect fit for 8kb ! Will you do it? I have always dreamed of making a prod like this, but I’m waiting for the “good and original idea”.</em></p>
</blockquote>



<p>I was excited by the project because I wanted to do more <a href="https://en.wikipedia.org/wiki/Demoscene">demos</a> with story-telling and animations. At the same time, I was intrigued by the challenges of making something in 8kB: I usually <a href="https://64k-scene.github.io/">target 64kB</a>, which is a completely different world, with a different set of rules and challenges. For the music, I knew I could count on my old friend CyborgJeff. Anatole had a lot of experience with 4kB. With him, the project was much more likely to be successful. And that’s how we started working together. I was not certain it would be feasible to fit everything in 8kB, but there’s only one way to know, right?</p>



<blockquote>
<p>Why specifically 8kB? In the demoscene, there are multiple size categories, with 4kB and 64kB being very common. I’ve always enjoyed the techniques used in 4kB intros (an intro is a demo with a tight size limitation), but it always feels too limited for proper storytelling. Revision, the biggest demoparty in the world, added an 8kB competition a few years ago, so it was a good opportunity to try it.</p>
</blockquote>



<h2>Rendering Worlds with Two Triangles</h2>



<p>People familiar with the demoscene already know it, as this is <a href="https://iquilezles.org/articles/nvscene2008/rwwtt.pdf">a standard approach</a> since 2008: we draw a rectangle (so, two triangles) to cover the full screen. Then, we run a GPU program (called a shader) on the rectangle using the GLSL language. The program will compute a color for each pixel and each frame. All we need is a function that takes coordinates (and time) as input, and returns a color. Simple, right?</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/iQtWmNMHz0rgSV0z-HMtrOHo8vhG1GKz_DNnKAgqdyFf3p2rLQfUQC4YmTBGTAapBcxCEJ7l7-KBbYvWcjh7gsS5Z0aXvR_OOF1r9QJIAoWg5kIZe0gj67bBcwTkx2z4P7Li3ulRo6pe8Y0yOPNgGUc" alt=""/><figcaption></figcaption></figure>



<p>Of course, the big question is: how do we write a function that draws a sheep?</p>



<p>Let’s split the problem in two parts:</p>



<ol>
<li>Represent the scene as a signed distance field.</li>



<li>Use raymarching to convert the distance fields into pixels.</li>
</ol>



<h3>Signed Distance Fields (SDF)</h3>



<p>A distance field is a function that computes the distance between a point in space to the nearest object. For every point in space, we want to know how far the point is to the object. If a point is one the object’s surface, the function should return 0. This is a “signed” function, meaning that it will return a negative number for points inside the object.</p>



<p>In the most basic cases, the function is simple to write. For example, the distance between a point and a sphere is trivial to compute. For a cube, you can also do it in a couple of lines (see <a href="https://www.youtube.com/watch?v=62-pRVZuS5c">The SDF of a Box</a> for explanations). Lots of other building blocks have been documented. Inigo Quilez has a <a href="https://iquilezles.org/articles/distfunctions/">nice collection of simple reusable shapes</a> and the Mercury demo group also <a href="https://mercury.sexy/hg_sdf/">provides a great library</a>.</p>



<p>The true power of distance fields emerges when you combine them. To get the union of two objects, you can simply pick the minimum of the two distances, while the maximum gives the intersection. When crafting organic shapes, mathematical unions may appear coarse, but alternative formulas like the <a href="https://iquilezles.org/articles/smin/">smooth unions</a> can create more organic looks.</p>



<p>Once you have a toolset with building blocks, it feels like playing with legos to create an object or a scene. Thus we made our sheep by assembling simple shapes (for example a cone, a sphere) and merging them, while the body and wool consist of a 3D noise function.</p>



<p>The next task will be to actually render the distance function to the screen.</p>



<h3>Raymarching</h3>



<p>To draw the 3D scene on the screen, we use raymarching. Raymarching is a rendering technique that leverages SDFs to trace rays through a 3D scene. Unlike traditional ray tracing, which mathematically computes the intersection point, raymarching works by marching along the ray’s path. The SDF tells us how far we can walk without colliding with the scene. We can then move the ray origin and compute the new distance. We repeat the operation until the distance is 0 (or close to it).</p>



<p>In the image below, imagine that the ray origin is the camera. It is looking in a certain direction. After multiple iterations, we find the intersection point with the right wall.</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/iaS66-fRMghoTXo-4spMNYhZl4iXq8mtt1lnNlSojpy_Ut-KCLIEZd5tiMBcBU7yp5ySH47Z_HJhJ2rH9N8sR8fydb43aa5J0hSrPVNZCLCjL0kqQoTZydu3ovgq91QbNtUS8FnGCjUfIt7Usfn1QKU" alt=""/><figcaption>For more information, see <a href="https://en.wikipedia.org/wiki/Ray_marching#Sphere_tracing">https://en.wikipedia.org/wiki/Ray_marching#Sphere_tracing</a>.</figcaption></figure>



<p>Once we have the intersection point, we know if the current pixel should be a part of the sheep, the sky, or any other object. For the lighting, we need to know at least the surface normal, which we can <a href="https://iquilezles.org/articles/normalsSDF/">estimate by computing the gradient in the same area</a>. To compute shadows, we can send another ray for the point to the sun and find if an object is in between. Many techniques exist to improve the rendering quality beyond this basic idea.</p>



<p>To better understand the technical details, the tutorial “<a href="https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/">Ray Marching and Signed Distance Functions</a>” is a good start. If you have more time, the video <a href="https://www.youtube.com/watch?v=-pdSjBPH3zM">Live Coding “Greek Temple”</a> is a wonderful in-depth example with detailed explanations.</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/5a2r0IZxVgs4yLDfSoqmE56uIf0RIKD9Zubweu_PCWaPBgF9JdfopuYMYhhvUI1F6M0Weorsh42mnRF_GdDPTD3qqwLdN0wbJN6pAtC8Maj94oLBbS9u4e6wj-Xgn8ggP5PkAn20MuPIwctLyggvIZs" alt=""/><figcaption>Early rendering</figcaption></figure>



<h2>Direction</h2>



<p>Imagine that you have to tell a story, but there is only one character, with no voice or written text, and that character is barely animated. It can only walk (but not turn!), move the head and the eyes. With only this, how would you tell a story and convey emotions?</p>



<p>When creating a demo with such a small size limit, it’s critical to know what is important. We avoided anything that didn’t serve that story. For example, we originally imagined the sheep walking in a desert. It wouldn’t be hard to generate dunes and a sky, but the story didn’t actually need it. We decided to keep the pure white background. We also skipped the textures, except for a few that convey a meaning (like the signs and the eyes).</p>



<p>Keeping the scope of the work relatively small allowed us to focus on things that might not be obvious at first: the details and the polish, the camera work, the editing, and the synchronization. Each shot was manually crafted, each animation was adjusted and went through many iterations to make sure the flow feels right. Not only did we need to make sure the flow felt right (adjusting the length of the shots and the sequencing), but it had to match the music.</p>



<p>To ensure that the narrative resonates with the audience, we employed a number of storytelling techniques, often with redundancy for emphasis. For example, to show the sheep’s excitement, we used cartoonish 2D effects, accelerated the walking pace, accentuated tail movements, exaggerated head swings, and added a dramatic shift in the music. This approach allowed us to convey a spectrum of emotions throughout the story.</p>



<p>The camera itself is also a storytelling tool. We used a wide shot to evoke a sense of solitude when the sheep wanders for hours; an extreme closeup on its eyes to capture the moment of realization when it notices the sign; and a slow zoom on the head to intensify the focus when the sheep stares at a sign.</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/_jompACpAOizuHB2jEm7xIxqBx42TzshyggyYVHMv-lh4uqNDRZfsCcXcbmHyrqVP2md7scB-HLOwym-TZUJ2BpPwiqf4gKo3eDsF5ZGa2C2Kbvcu5LYkYk8MJakX8Ln2S92EaDHSco7EoBKbF0frxo" alt=""/><figcaption>A 2D animated background was used to communicate the appeal of the flower.</figcaption></figure>







<h2>Development process</h2>



<p>You may notice that the source code contains a large number of hard-coded constants. The challenge was to determine these values — how large should the sheep’s eyes be? How fast should the camera move? How long should each shot last? What colors should the flower have?</p>



<p>Given this uncertainty, each constant went through numerous iterations. To iterate quickly and have a short feedback loop, shaders come in handy: we recompile them at runtime to update the graphics within a second.</p>



<p>The other requirement was to have a player: something that allows us to control the time with pause and replay commands. This proved to be invaluable when working on animations and camera control, as we could see the result instantly after a live-reload of the shader. Additionally, music support was a must, so that we can perfectly synchronize the animations to the music.</p>



<h2>Music</h2>



<p>Music is a critical component for storytelling. To fit the story, the music needed multiple parts, with different moods and transitions at specific points in time. We decided to use the same tools as we would in a 4kB intro, while allocating more space to allow a more intricate composition.</p>



<p>To compose the music, I asked my Cyborgjeff, a friend familiar with demoscene techniques, whose musical style resonated with our vision. His tool of choice was the <a href="https://github.com/hzdgopher/4klang">4klang synthesizer</a>, an impressive piece of software developed by Gopher. 4klang comes with a plugin usable from any music software and it has an export button that generates an assembly file. This file is then compiled and linked with the demo. When the demo runs, the synth will run in a separate thread, procedurally generate the wave sound, and send it to the soundcard.</p>



<p>Creating a small music comes with a lot of constraints. The first version of the music was bigger than expected. Imagine telling a musician “Your music is too big, can you reduce it by 500 bytes?” Well, that’s just normal in the demoscene.</p>



<p>We studied the output of 4klang to understand how it packs the data. With advice from Gopher, Cyborgjeff was able to iterate on the music to make it smaller. We made multiple adjustments:</p>



<ul>
<li>The number of instruments was reduced from 16 to 13.</li>



<li>The ending theme was recomposed to align with the tempo of the overall music.</li>



<li>The composition used more repetitions so it compresses better. For example, adjusting the length of a note in the background may be imperceptible to the ear while improving the compression ratio.</li>
</ul>



<p>This allowed us to save some space on the music, while keeping its overall structure, with a minimal loss in terms of quality. For more information on the music, Cyborgjeff wrote a blog post: <a href="https://www.studio-quena.be/cyborgjeff/blog/2023/04/11/8000-octets-un-mouton-et-une-fleur/">8000 octets, un mouton et une fleur</a>.</p>



<h2>Animation &amp; Synchronization</h2>



<p>Everything in the demo is re-evaluated at each frame as nothing is precomputed or cached. While this is really bad for the performance, this is a blessing for animations: anything can depend on the time and vary through the demo.</p>



<p>The demo consists of around 25 manually crafted camera shots. When creating a shot, we describe how each of <a href="https://github.com/ctrl-alt-test/mouton/blob/main/Intro/src/shaders/mouton.vert#L5-L22">18 parameters</a> varies over time, such as the position of each object, the state of the sheep, the position of the camera, the focal, what the camera is looking at, etc.</p>



<p>For example, a single line of code describes the camera during the shot:</p>



<pre><code>camPos = vec3(22., 2., time*0.6-10.);</code></pre>



<p>And we get a linear translation. Here “time” represents the time since the beginning of the shot so that we can easily insert, remove or adjust a shot without affecting the rest of the demo. Absolute times are avoided for code maintenance.</p>



<p>A note of caution on linear interpolations: while functional, they often look poor or robotic. In many cases, we apply the <a href="https://en.wikipedia.org/wiki/Smoothstep">smoothstep</a> function, which leads to a smoother, more natural animation. Smoothstep is an S-shaped smooth interpolation that helps avoid sharp edges and sudden movement changes.</p>



<h2>Textures &amp; Materials</h2>



<p>In a traditional renderer, textures are 2D images that are applied on a 3D model. One difficulty with the textures is how to compute the texture coordinates and map each pixel in the texture to the 3D surface. With our raymarching approach, we can’t easily compute texture coordinates. Instead, we compute on the fly 3D textures. Once the raymarcher finds the 3D position of the point to render, we pass the 3D coordinates to the corresponding texture function.</p>


<div>
<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/PMwY_GEUekURSgaZZKRVz-cVoSNUckN6wYXdq7LhZlXLabKU89zj-Rl1gC3-Ed5dxLlmrq57c0oo_bmbCI_kJP_fCPyBZ3mUrWpWSfoLJy5ZuKEcs6gUiVFmhaI6S6K7pebMJm5RRqfc6YLWxtVGFOc" alt=""/></figure></div>


<p>Let’s take a look at the traffic signs. They use some math to compute a triangle or a square to serve as a border, then the inner content of the sign is achieved by <a href="https://github.com/ctrl-alt-test/mouton/blob/main/Intro/src/shaders/mouton.frag#L624">combining multiple functions</a>. For example, the restaurant symbol is created with 4 black oval-like shapes, and 2 white shapes are added to create the dents.</p>



<p>To make the visuals more interesting, we wanted to have not just textures, but also different materials. Parameters of the lighting equation depend on the material. For example, the sheep hooves have a different reflection (using <a href="https://en.wikipedia.org/wiki/Fresnel_equations">fresnel coefficients</a>).</p>






<div>
<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/6OnCIvQ8M6ONMZRRomTCB2pSDJnxt9zeO4Is3oXyVNMuulGoQUQ7KKMT6B-xTnMDDgh0zv93Avi9IhlRMkND7tu91mTol28XbK9AXt2N3c7Kqo4JxCfbtHWPGmM5cSmBSGQsu2__9o1NyCcwVcOQfHA" alt=""/></figure></div>


<h2>Eyes</h2>



<p>For a long time during the development, the eyes looked dull and lifeless. I believe eyes are a big part of the character design. This was one of the first things that we animated, and it was very important as a tool for story-telling. Eyes help show feelings and they enable many transitions.</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/QGyZLSEmC5EVpGPhOyH1W17dZBkbGqI106q_RYkEOPZsIEhp3IuSI5k1ILwOUqzjx68DswWkgaFM3geC_fsQpluilmWmGbYIGi_vfHYPsKdR8wNKBZY-2sY6ERgVMfNR6cYT83w2pxdLGqDK6EX-yDc" alt=""/><figcaption>Early rendering</figcaption></figure>



<p>After searching for reference images on the Internet, I found that most of the cartoon characters have an iris, but the iris doesn’t seem to be strictly required.  I’ve also noticed that the pupil is always big. If there’s an iris, the pupil will be big compared to the iris.</p>



<p>But the important part to get sparkling eyes is to have some reflections of the light in the eyes. With the standard lighting equations we used, we couldn’t get a reflection (unless the sun and the camera were at very specific positions). An input of the lighting equations is the normal vector of the surface. Our trick was to modify the vector to increase the probability of getting some reflections from the sun.</p>



<p>On top of that, we created an <a href="https://en.wikipedia.org/wiki/Reflection_mapping">environment mapping</a>. This technique is commonly used in video games: instead of computing perfect reflections in the scene in real time, we can look up in a texture (that simulates the environment). Usually, people use environment mapping to optimize the code as the texture can be a simplification of the real environment. We did the opposite: our environment world is actually a perfect white, but we used a texture to fake and add details.</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/beQPbrggllClDp6K168goj9fwyz_WQKed1Gc2cZBWC1lZfNCPj904WZ1xrMRg2BZayoZIGDGdrOD63gcfuci6c-nNATQ-wIiS4VdyD5dmbJkF-CQy_6gc4JMIPpdBmpdyzW_QD8UK2Au0YzKdnOH8Hk" alt=""/><figcaption>Final result</figcaption></figure>



<p>The reflections in the eyes (both the white and the pupils) are much more complex than they should be in an empty world. There are multiple fake sources of lights, as well as a gradient (to mimic a darker ground and a blue-ish sky).</p>



<h2>Post-processing</h2>



<p>Once everything is done, the final visual touch defining the mood is the post-processing.</p>



<p>Despite being subtle, it helps have a good image quality and set the tone for the story.  We used:</p>



<ul>
<li>color grading;</li>



<li>gamma correction;</li>



<li>a bit of vignetting;</li>



<li>finally, a two-pass FXAA filter to avoid aliasing (but you won’t notice it if you only watched the YouTube capture)</li>
</ul>



<p>We also implemented some of the effects in the post-processing step, such as the stars in the eyes or the ending screen effect. Those are made as pure 2D and don’t exist in the 3D world.</p>



<p>Finally, we experimented with other alternative styles. At some point, we tried to give an old-cartoon look, and we implemented contour detection to simulate a hand-drawn image, with a monochrome rendering, grain, and noise. The result looked like this:</p>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/l8g7w28ukmvnB9lO6UauAk76tzbtbgv_uwRjEiAouIcA4KDgwCeVYhTeVeAcsjSXK7FN6kJVtA7r3Ka7dPMJGeY3zB4Xvg4z1WGnPovluXJZ9D9iC1QLW5mp8DXywamC2zHaJv_T_RAnILcbDoFXRbg" alt=""/></figure>



<figure><img decoding="async" src="https://lh7-us.googleusercontent.com/bG6HYJcungIAKm9LFHBNJCIYlCtGCL1zI2pOLX2Hfc7IP0mUOst90cRbXCZQABuAUXKyxZrpbSILNHwzMIaUoqXOGISLV-rafoX2SMHDrN0se6gCpouoR7JFuctXRo66zRr-LvK1nZP--NqESc9OKIQ" alt=""/></figure>



<p>After discussions, we decided to give up on this experiment and focus on the cleaner, modern look.</p>



<h2>Compression</h2>



<p>So far, we’ve seen how we made most of the demo. The main idea is to avoid storing data, instead we use code to describe how to generate the data. For the music, we store a list of notes to play, as well as a list of instructions for each instrument. All of this is relatively small, but does it really fit in 8kB?</p>



<p>Part of the magic comes from <a href="https://github.com/runestubbe/Crinkler">Crinkler</a>, a compression tool specifically designed for the demoscene and intros between 1kB and 8kB. As the executable needs to be self-extractible, Crinkler includes some very small and clever assembly code that can decompress the rest of the executable. It’s optimized for size at the expense of other things: the compression algorithm takes a while, the decompression is relatively slow and uses a lot of RAM (hundreds of megabytes).</p>



<p>Crinkler is an impressive tool, but it doesn’t do everything. We have a total of <a href="https://github.com/ctrl-alt-test/mouton/tree/main/Intro/src/shaders">42kB of shader source code</a> and we need one last ingredient to fit it in the binary.</p>



<h2>Minification</h2>



<p>As the shader source code is included in the final binary, we have to make it as small as possible. It would be possible to minify the code by hand, but then it would cause maintenance issues. It was critical for the success of our project to be able to iterate quickly, without worrying about low-level size optimizations. So we needed a tool to minify the shader.</p>



<p>I have written such a tool, <a href="https://github.com/laurentlb/Shader_Minifier/">Shader Minifier</a>, which has been a side project of mine since 2011. It removes unneeded spaces and comments, it renames variables and can do more. It has been the most popular shader minification tool in the demoscene for many years, but this was not sufficient for us: an 8kB intro contains much more code than a 4kB does, and new problems arise from the larger code size.</p>



<p>I stopped working on the demo for one month to implement all the missing features we needed from Shader Minifier. While it’s easy to write a simple minifier, you need to write a compiler if you want to get good minification — a source-to-source compiler, similar to what Closure Compiler does.</p>



<p>The full <a href="https://github.com/laurentlb/Shader_Minifier/?tab=readme-ov-file#transformations">list of transformations</a> supported by Shader Minifier is getting quite long, but here are a few:</p>



<ul>
<li>Renaming of variables and functions</li>



<li>Inlining of variables</li>



<li>Evaluation of constant arithmetic</li>



<li>Inlining of functions</li>



<li>Dead code elimination</li>



<li>Merging of declarations</li>
</ul>



<p>These transformations reduce the size of the output, but it’s not enough. We need to make sure that the output is compression-friendly. This is a hard problem: it can happen that a transformation reduces the size of the code, while increasing the size of the compressed code. So we constantly need to monitor the compressed size, as we iterate on the demo.</p>



<p>New improvements to Shader Minifier have saved around 600 bytes on the compressed binary. To help review and monitor what exactly goes in the final binary, we store <a href="https://github.com/ctrl-alt-test/mouton/blob/main/Intro/src/shaders/shaders.inl">the minified output</a> in the repository. This proved useful to identify new optimization opportunities. At the end, once minified and compressed, the 42kB of shader code fits in about 5kB, which gives just enough space for the music and the C++ code.</p>



<p>Anyway… you could say that I had to write a compiler in order to make this demo. :)</p>



<h2>The War Between the Sheep and the Flowers</h2>



<blockquote>
<p>It’s not important, the war between the sheep and the flowers? […] Suppose I happen to know a unique flower, one that exists nowhere in the world except on my planet, one that a little sheep can wipe out in a single bite one morning, just like that, without even realizing what he’d doing – that isn’t important? If someone loves a flower of which just one example exists among all the millions and millions of stars, that’s enough to make him happy when he looks at the stars. He tells himself ‘My flower’s up there somewhere…’ But <strong>if the sheep eats the flower, then for him it’s as if, suddenly, all the stars went out</strong>. And that isn’t important?”</p>



<p>— Antoine de Saint-Exupéry, The Little Prince</p>
</blockquote>



<h2>Conclusion</h2>



<p>As you’ve seen, there are lots of advanced and fascinating techniques needed to make this kind of demo. But we didn’t invent everything. We’re building on top of what other people did. The amount of work and research that was done by other people is incredible, from the raymarching techniques, to the music generation software and the compression algorithms. Hopefully the new features added to Shader Minifier will help other people create better demos in the future. The 8kB category is fun and offers more possibilities than the 4kB category; let’s hope it will become more popular.</p>



<p>P.S. For comparison, the text of this article contains around 21,000 characters, so it would take 21kB.</p>
					</div></div>
  </body>
</html>
