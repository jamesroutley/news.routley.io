<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20251104-00/?p=111758">Original</a>
    <h1>The Microsoft SoftCard for the Apple II: Getting two processors to share memory</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-111758">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>The <a href="https://en.wikipedia.org/wiki/Z-80_SoftCard"> Microsoft Z-80 SoftCard</a> was a plug-in expansion card for the Apple II that added the ability to run CP/M software. According to Wikipedia, it was Microsoft’s first hardware product and in 1980 was the single largest revenue source for the company.</p>
<p>CP/M runs on an 8080 processor, but the Apple II has a 6502 processor. So how can you run CP/M on an Apple II? Answer: The card comes with its own 8080-compatible processor, the Zilog Z80, which was arguable better than the 8080 for <a href="https://en.wikipedia.org/wiki/Zilog_Z80"> a bunch of reasons given on its Wikipedia page</a>.¹</p>
<p>Great, you now have a processor. But what happens to the old 6502 processor? Ideally, you would just shut it off, but you can’t go cold turkey because some things still had to be handled by the 6502.² <a title="Nicole gets a real computer! The Microsoft Z80 SoftCard!" href="https://nicole.express/2020/nicole-gets-a-real-computer.html"> Nicole Branagan digs deeper into the story of how the two processors coexist</a>. The idea is that the SoftCard tells the 6502 that it’s doing DMA, so the 6502 pauses and waits for the DMA to complete. However, you can’t leave the 6502 paused for too long or its internal registers degrade and lose their values.</p>
<p>The solution is to take advantage of the Z80’s REFRESH line, which the processor uses to signal that it’s not accessing memory right now (because it’s <a title="Dynamic RAM Design &amp; Interfacing - THE Z80 CPU : TIMING" href="http://www.piclist.com/techref/mem/dram/slide4.html"> decoding an instruction</a>). This tells external memory refresh circuitry that it can run and keep the RAM values refreshed so that <i>they</i> don’t degrade and lose their values.</p>
<p>On the Apple II, memory refreshing is done by the video circuitry, so there is need for a dedicated REFRESH signal. The SoftCard uses this signal to allow the 6502 to execute a tiny little bit. (Presumably it is sitting in a spin loop waiting to be woken.) This keeps the 6502’s registers refreshed.</p>
<p>When the SoftCard needs the 6502 to do actual work, it can update some memory to tell the 6502, “Break out of your spin loop and do something for me, then let me know the answer and go back to the spin loop.” The Z80 then goes to sleep until it gets an answer from the 6502.</p>
<p>Another wrinkle in the way that the 6502 and Z80 shared memory is in the memory map. Both the Z80 and 6502 consider the first 256 bytes of memory to be special and want to use it for different things. Furthermore, CP/M programs expect to be loaded at $0100, but the 6502 hard-codes its CPU stack to live in the range $0100–$01FF. There are other obstacles in the low part of the Apple II memory map: The Apple II system monitor uses $0200–$02FF as its keyboard input buffer, the bytes in the range $03F0–$03FF are used to hold interrupt vectors, and the text video frame buffer goes from $0400–$07FF. (There is a second text video frame buffer from $0800–$0BFF, but almost nobody uses it.) Other big obstacles are the memory range from $C000–$CFFF, which is used by peripheral devices, and the memory range from $D000–$FFFF, which holds the Apple II monitor ROM, but can be replaced by RAM if you have the Language Card (a 16KB memory expansion card), except that the last few bytes $FFFA–$FFFF are used by the CPU as interrupt vectors.</p>
<p>The solution is to remap the memory by putting address translation circuitry on the SoftCard, so that when the Z80 asks for memory address $0000, say, it actually gets physical memory $1000. The remapping is carefully arranged so that all of the Apple II’s special reserved addresses get shuffled to the end of the Z80 memory map, and all of the Apple II’s normal RAM occupies contiguous address space in the Z80 memory map starting at $0000.³</p>
<table>
<tbody>
<tr>
<td> </td>
<td>6502</td>
<td> </td>
<td>Physical</td>
<td> </td>
<td>Z80</td>
</tr>
<tr>
<td>Special use</td>
<td>$0000–$0FFF</td>
<td>↘</td>
<td>$1000–$1FFF</td>
<td> </td>
<td>$0000–$0FFF</td>
<td rowspan="11">normal RAM</td>
</tr>
<tr>
<td rowspan="11">normal RAM</td>
<td>$1000–$1FFF</td>
<td rowspan="11">↗</td>
<td>$2000–$2FFF</td>
<td> </td>
<td>$1000–$1FFF</td>
</tr>
<tr>
<td>$2000–$2FFF</td>
<td>$3000–$3FFF</td>
<td> </td>
<td>$2000–$2FFF</td>
</tr>
<tr>
<td>$3000–$3FFF</td>
<td>$4000–$4FFF</td>
<td> </td>
<td>$3000–$3FFF</td>
</tr>
<tr>
<td>$4000–$4FFF</td>
<td>$5000–$5FFF</td>
<td> </td>
<td>$4000–$4FFF</td>
</tr>
<tr>
<td>$5000–$5FFF</td>
<td>$6000–$6FFF</td>
<td> </td>
<td>$5000–$5FFF</td>
</tr>
<tr>
<td>$6000–$6FFF</td>
<td>$7000–$7FFF</td>
<td> </td>
<td>$6000–$6FFF</td>
</tr>
<tr>
<td>$7000–$7FFF</td>
<td>$8000–$8FFF</td>
<td> </td>
<td>$7000–$7FFF</td>
</tr>
<tr>
<td>$8000–$8FFF</td>
<td>$9000–$9FFF</td>
<td> </td>
<td>$8000–$8FFF</td>
</tr>
<tr>
<td>$9000–$9FFF</td>
<td>$A000–$AFFF</td>
<td> </td>
<td>$9000–$9FFF</td>
</tr>
<tr>
<td>$A000–$AFFF</td>
<td>$B000–$BFFF</td>
<td> </td>
<td>$A000–$AFFF</td>
</tr>
<tr>
<td>$B000–$BFFF</td>
<td>$D000–$DFFF</td>
<td> </td>
<td>$B000–$BFFF</td>
<td rowspan="3">expansion RAM</td>
</tr>
<tr>
<td>I/O space</td>
<td>$C000–$CFFF</td>
<td>↘</td>
<td>$E000–$EFFF</td>
<td> </td>
<td>$C000–$CFFF</td>
</tr>
<tr>
<td rowspan="3">expansion RAM</td>
<td>$D000–$DFFF</td>
<td rowspan="3">↗</td>
<td>$F000–$FFFF</td>
<td> </td>
<td>$D000–$DFFF</td>
</tr>
<tr>
<td>$E000–$EFFF</td>
<td>$C000–$CFFF</td>
<td> </td>
<td>$E000–$EFFF</td>
<td>I/O space</td>
</tr>
<tr>
<td>$F000–$FFFF</td>
<td>$0000–$0FFF</td>
<td> </td>
<td>$F000–$FFFF</td>
<td>Special use</td>
</tr>
</tbody>
</table>
<p>The SoftCard manual contained lots of details on how to write code for it. For example, it included <a href="https://archive.org/details/mscard_software_hardware_details/page/n25/mode/2up"> instructions on how to call into a 6502 subroutine from Z80</a> and had <a href="https://archive.org/details/mscard_software_hardware_details/page/n5/mode/2up"> a chart showing how the memory was remapped for the Z80</a>. It even included the Z80 processor reference manual, listing all the instructions. This will come in handy in a future story.</p>
<p>¹ I don’t know where the hyphen in <i>Z-80</i> came from.</p>
<p>² In many places, I/O was handled by timing loops, so if you wanted to access, say, the game paddles, you had to let the 6502 do the I/O with its precise software timing loops.</p>
<p>³ There were also two high resolution graphics frame buffers, one at $2000–$3FFF, and another at $4000–$5FFF. These were right in the middle of the Z80 memory map, but in practice it wasn’t a problem because CP/M was a text-mode operating system, so the programs you were running didn’t try to do graphics anyway.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
