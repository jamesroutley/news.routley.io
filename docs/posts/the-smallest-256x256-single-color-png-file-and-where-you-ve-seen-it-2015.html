<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mjt.me.uk/posts/smallest-png/">Original</a>
    <h1>The smallest 256x256 single-color PNG file, and where you&#39;ve seen it (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Do you recognise these images? There&#39;s a good chance you&#39;ve seen some of them before now, probably several times. Here&#39;s a hint: They all depict the same thing.</p>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/openstreetmap.png" alt="Blue square"/>
  <figcaption>103 bytes</figcaption>
</figure>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/bing-maps.png" alt="Blue square"/>
  <figcaption>156 bytes</figcaption>
</figure>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/google-maps.png" alt="Blue square"/>
  <figcaption>178 bytes</figcaption>
</figure>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/skobbler-maps.png" alt="Blue square"/>
  <figcaption>379 bytes</figcaption>
</figure>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/tomtom-redirected.png" alt="Blue square"/>
  <figcaption>921 bytes</figcaption>
</figure>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/here-maps-256px.png" alt="Blue square"/>
  <figcaption>1,189 bytes</figcaption>
</figure>

<p>They all look pretty similar - so why the size difference?</p>

<h3 id="a-quick-intro-to-png">A quick intro to PNG</h3>



<p>The basic PNG file is comprised of recurring chunks. Each chunk is comprised of four parts:</p>

<ul>
<li>  <span>Length of the data block (four bytes)</span></li>
<li>  <span>Chunk type (four bytes)</span></li>
<li>  <span>Data</span></li>
<li>  <span>CRC (four bytes)</span></li>
</ul>

<p>Here&#39;s the hex content of the smallest PNG shown above - the 103 byte file:</p>

<pre>89 50 4E 47  0D 0A 1A 0A  <span>00 00 00 0D</span>  <span>49 48 44 52</span> | .PNG........<span>IHDR</span>
<span>00 00 01 00  00 00 01 00  01 03 00 00  00</span> <span>66 BC 3A</span> | .............f¼:
<span>25</span> <span>00 00 00  03</span> <span>50 4C 54  45</span> <span>B5 D0 D0</span>  <span>63 04 16 EA</span> | %....<span>PLTE</span>µÐÐc..ê
<span>00 00 00 1F</span>  <span>49 44 41 54</span>  <span>68 81 ED C1  01 0D 00 00</span> | ....<span>IDAT</span>h.íÁ....
<span>00 C2 A0 F7  4F 6D 0E 37  A0 00 00 00  00 00 00 00</span> | .Â ÷Om.7 .......
<span>00 BE 0D 21  00 00 01</span> <span>9A  60 E1 D5</span> <span>00  00 00 00</span> <span>49</span> | .¾.!....`áÕ....<span>I</span>
<span>45 4E 44</span> <span>AE  42 60 82</span>                              | <span>END</span>®B`.         
</pre>

<p>The <strong>IHDR</strong> section - <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html">further specification here</a> - marks this as a 256x256 pixel image (00 00 01 00  00 00 01 00), 1 bit depth (01), with each pixel represented as an index into a palette (03). The image uses the default deflate compression (00), basic filtering (00) and no interlacing (00).</p>

<p>The <strong>PLTE</strong> section is mandatory for paleted images (PNG also supports true color images, where it isn&#39;t required) - it can contain up to 256 entries, but this one only contains a single entry - <span>B5 D0 D0</span> - as only a single color is needed. This is also an example of a &#34;truncated palette&#34; - the one-bit depth selected in the IHDR section allows 2 colors, but as only one color is used, only one is included in the palette.</p>

<p>The <strong>IDAT</strong> section is the actual image data. It&#39;s 31 bytes long, compressed with the <a href="https://en.wikipedia.org/wiki/DEFLATE">DEFLATE</a> algorithm. If you <a href="https://gist.github.com/michaeltandy/c051db2243e679e78a37">inflate the data in this example</a>, you get 8448 bytes of zeros. Why 8448? Well, 8192 bytes correspond to the pixels at one bit per pixel ( 256*256/8 = 8192 ) and 256 correspond to one byte for each line of the image, specifying a <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html">filter to apply</a>. In our case, the filter byte is always 0 which corresponds to no filtering being performed.</p>

<p>The <strong>IEND</strong> section marks the end of the image.</p>

<h3 id="why-the-differences-in-size-between-the-images-above">Why the differences in size between the images above?</h3>



<table><thead>
<tr>
<th>Size</th>
<th>Explanation</th>
</tr>
</thead><tbody>
<tr>
<td>103 bytes</td>
<td>Palettised, 1 bit per pixel, 3 byte PLTE, 31 byte IDAT</td>
</tr>
<tr>
<td>156 bytes</td>
<td>Palettised, 8 bits per pixel, 3 byte PLTE, 84 byte IDAT</td>
</tr>
<tr>
<td>178 bytes</td>
<td>Palettised, 8 bits per pixel, 3 byte PLTE, 85 byte IDAT, <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.pHYs">pHYs section</a> (physical pixel dimensions)</td>
</tr>
<tr>
<td>379 bytes</td>
<td>Palettised, 8 bits per pixel, 3 byte PLTE, 307 byte IDAT (The IDAT has the same all-zeros content as the two images previously - just a less effective compression algorithm?)</td>
</tr>
<tr>
<td>921 bytes</td>
<td>Palettised, 8 bits per pixel, 768 byte PLTE (with padding in all but the first three bytes), 84 byte IDAT</td>
</tr>
<tr>
<td>1,189 bytes</td>
<td>Palettised, 8 bits per pixel, 768 byte PLTE (with padding in all but the first three bytes), 84 byte IDAT, 256 byte <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html">tRNS section</a> (transparency data for palette entries, padding in all but the first byte)</td>
</tr>
</tbody></table>

<p>(The last one is actually served by redirecting to a cached resource, so it doesn&#39;t work out that bad compared to the others)</p>

<h3 id="why-would-it-take-84-bytes-to-represent-data-that-was-all-zeros-haven-39-t-these-people-heard-of-run-length-encoding">Why would it take 84 bytes to represent data that was all zeros? Haven&#39;t these people heard of run length encoding?</h3>

<p>The deflate algorithm is used to compress the IDAT section of PNGs, and it does support run length encoding - but the run length is represented as an 8-bit huffman-encoded number; the <a href="http://www.zlib.net/zlib_tech.html">theoretical maximumn compression ratio for deflate is about 1030.3 : 1</a> </p>

<p>We don&#39;t achieve that theoretical maximum in practice (there are fixed overheads for things like defining the dictionary). The compression ratios we see include 264.2:1 for the 103 byte file and 780.1:1 for the 156 byte file.</p>

<h3 id="so-who-needs-these-micro-optimisations">So who needs these micro-optimisations?</h3>

<p>Here&#39;s the 103 byte image in a more familiar context:</p>









<p>Map tiles representing the sea!</p>

<p>Slippy maps traditionally serve fixed size &#39;map tiles&#39; in a grid at a given zoom level - for example http://b.tile.openstreetmap.org/6/29/20.png would be zoom level 6, the 29th column, and the 20th row; http://a.tile.openstreetmap.org/19/516664/319949.png would be zoom level 19, column 516664, row 319949. The higher the zoom level, the more tiles are needed to show the entire planet - and there&#39;s a whole lot of sea within that data. Depending on the size of your monitor, you might have downloaded 10 or more all-sea tiles just to render that map above, and that&#39;s before you&#39;ve zoomed in or scrolled around.</p>

<p>Servers could send a redirect to a cached resource - some maps do exactly that! But when you can send a tile in just 103 bytes, sending the tile is as simple as sending the redirect. </p>

<table><thead>
<tr>
<th>Size</th>
<th>Map provider</th>
<th>Source</th>
</tr>
</thead><tbody>
<tr>
<td>103 bytes</td>
<td><a href="https://openstreetmap.org">OpenStreetMap</a></td>
<td><a href="https://b.tile.openstreetmap.org/12/4025/2501.png">Example</a></td>
</tr>
<tr>
<td>156 bytes</td>
<td><a href="https://www.bing.com/maps/">Bing Maps</a></td>
<td><a href="https://t3.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/031213202023?mkt=en-gb&amp;it=G,VE,BX,L,LA&amp;shading=hill&amp;og=104&amp;n=z">Example</a></td>
</tr>
<tr>
<td>178 bytes</td>
<td>Google Maps (classic)</td>
<td><a href="https://mts1.googleapis.com/vt?pb=!1m5!1m4!1i8!2i131!3i79!4i256!2m3!1e0!2sm!3i325000000!3m9!2sen-GB!3sUS!5e18!12m1!1e47!12m3!1e37!2m1!1ssmartmaps!4e0">Example</a></td>
</tr>
<tr>
<td>379 bytes</td>
<td><a href="http://maps.skobbler.com">Skobbler Maps</a></td>
<td><a href="http://tiles3-bc7b4da77e971c12cb0e069bffcf2771.skobblermaps.com/TileService/tiles/2.0/01021113210/7/6/32/46.png">Example</a></td>
</tr>
<tr>
<td>921 bytes</td>
<td><a href="http://routes.tomtom.com">TomTom</a></td>
<td><a href="http://c.api.internal.tomtom.com/lbs/map/3/basic/1/7/42/56.png?key=dvbfcb88hkrje9ur2fs84uxn">Example</a> (actually a redirect - so the size of the initial image doesn&#39;t matter that much)</td>
</tr>
<tr>
<td>1,189 bytes</td>
<td><a href="https://www.here.com/">here.com</a> (Navteq)</td>
<td><a href="https://1.base.maps.api.here.com/maptile/2.1/maptile/cda3b29e40/normal.day/9/260/159/256/png8?app_id=xWVIueSv6JL0aJ5xqTxb&amp;app_code=djPZyynKsbTjIUDOBcHZ2g&amp;lg=eng&amp;ppi=72">Example</a></td>
</tr>
</tbody></table>

<h3 id="got-any-other-tricks-up-your-sleeve">Got any other tricks up your sleeve?</h3>

<figure>
  <img src="https://www.mjt.me.uk/assets/images/smallest-png/rgb-1px.png" width="256px" height="256px" alt="Blue square"/>
  <figcaption>69 bytes - if all your clients support scaling</figcaption>
</figure>

<p>Instead of serving a 256x256px image, you can serve a 1px image and tell the browser to scale it up. Of course, if you have to put width= &#34;256px&#34; height= &#34;256px&#34; into your HTML that adds 30 bytes to your HTML! But if you&#39;re inserting the DOM nodes programmatically using javascript (such as for a slippy map) this isn&#39;t a problem.</p>

<p>When you make a very small image it&#39;s actually more efficient to use a true color image instead of a palettised image, as each extra segment in the PNG file adds 12 bytes of length, header and CRC information. But that benefit quickly diminishes as image size increases; converting the 103 byte file to true color increases its size to 567 bytes.</p>

<p>Some slippy maps use larger tiles; a 512px tile, taking up 126 bytes, can replace four 256px tiles taking up 412 bytes between them as well as overhead for http headers. But in areas where tiles show more data, you&#39;ll use relatively more bandwidth on things outside the viewport, which won&#39;t be shown unless the user scrolls. Some versions of Google Maps use 512px tiles, as does here.com.</p>

<p>TomTom doesn&#39;t serve the 921 byte tile repeatedly - instead users get a HTTP 302 redirect with header &#34;Location: http://s3.amazonaws.com/mascoma-renderer-static-san-prod/rialto/water.png&#34; which is an 84-byte header - but it means users only have to retrieve the generic water tile once; thereafter it&#39;s served from the browser cache. The gains can be even greater if you want something more complicated than a single-color image!</p>

<p>Of course, no matter how small you get your PNG you&#39;ll still have to send 400+ bytes of HTTP headers in each direction!</p>

<h3 id="conclusion">Conclusion</h3>

<p>You can make a PNG pretty small if you want to, and different software and settings can produce files that vary in size quite a bit.</p>

<p>If you&#39;re doing something that involves moving lots of small PNGs around, a hex editor is all you need to check you&#39;re using the minimum number of bits per pixel, your palette is truncated, and you don&#39;t have any data segments you don&#39;t absolutely need.</p>

<p>The compression in PNG files isn&#39;t as good as the <a href="https://en.wikipedia.org/wiki/Shannon&#39;s_source_coding_theorem">source coding theorem</a> would hope for, and large blocks of identical data don&#39;t compress down to nothing as completely as you might hope for.</p>

    </div></div>
  </body>
</html>
