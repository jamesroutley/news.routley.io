<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/899420/1f0179b2d946d7b7/">Original</a>
    <h1>An Ubuntu kernel bug causes container crashes</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>

<p>Some system administrators running Ubuntu 20.04 had a rough time on
June 8, when Ubuntu published kernel packages containing a <a href="https://bugs.launchpad.net/ubuntu/+source/linux-aws-5.13/+bug/1977919">particularly
nasty bug</a> that was caused by an <a href="https://kernel.ubuntu.com/git/ubuntu/ubuntu-impish.git/commit/?id=9680f5f6d8f93a82abfcc5e2c66faada3d4f2ef5">Ubuntu-specific
patch to the kernel</a>.  The bug led to a kernel panic whenever a Docker container
was started. Fixed packages were made available on June 10, but there
are questions about what went wrong
with handling the patch; in particular, it is surprising that kernel 5.13,
which has been beyond its end-of-life
for months, made it onto machines running Ubuntu 20.04, which is supposed
to be a long-term support release. </p>

<h4>Ubuntu&#39;s kernel release lifecycle</h4>

<p>Unless it is following a rolling-release model, a Linux distribution project
will often pick a kernel branch and stick with it for the lifetime of a distribution
release. For example, a release that ships with a 5.4 kernel, as
Ubuntu 20.04 did, might receive updates to later 5.4.x kernels,
but is unlikely to 
be upgraded to 5.15 until the next major release of the distribution.  For
this reason, such projects often prefer or even require a branch that
has been designated as a long-term maintenance branch by the stable kernel
team.  It&#39;s easier for 
a distribution maintainer to sleep at night knowing that the version of the
software they are shipping is supported upstream.  </p>

<p>Debian <strike>and Red Hat</strike> both adhere to these rules when picking kernels for
their releases; Ubuntu claims to do so as well, at least for its LTS
(long-term support) releases. Those releases are made every two years, and
supported for five. They ship with a long-term stable kernel; Ubuntu provides
updates to that for the lifetime of the release.  </p>

<p>Ubuntu also makes non-LTS releases at six month intervals in between
the LTS releases. In contrast to the LTS releases, these releases are only
supported for about six months, and are declared end-of-life (EOL) a month after
a newer release is made available. Because of their relatively short
shelf-life, Ubuntu does not restrict itself to long-term kernels for these
releases. The most recent non-LTS release, Ubuntu 21.10, shipped with
Linux 5.13, which is not a long-term branch. In fact, the <a href="https://lwn.net/ml/linux-kernel/16319668996036%40kroah.com/">5.13
branch was declared EOL</a> on September 18, 2021, almost a month before
Ubuntu 21.10 was released on October 14.  </p>

<p>Users who prioritize stability highly value the long window of support
that comes with an LTS release, but five years is a relative eternity in
the world of hardware, particularly in fast-moving areas like graphics.  In
order to support newer hardware, Ubuntu periodically publishes new hardware
enablement (HWE) stacks for its LTS releases. These are comprised of packages
backported from the latest (possibly non-LTS) release. The HWE stack
includes updated kernel packages, and may also include updated Xorg and
Mesa packages.  </p>

<p><a href="https://wiki.ubuntu.com/Kernel/LTSEnablementStack">According to
Ubuntu</a>, the HWE stack is enabled by default for new desktop installs of
Ubuntu, but needs to be explicitly chosen for server installs. This opt-in
policy also seems to only apply to users 
installing from the ISO image; the default Ubuntu 20.04 images on Amazon AWS,
Azure, and Google Cloud all come with the HWE kernel pre-installed. 
Many
system administrators (including me) choose the HWE stack for their
servers as well, either out of a desire for features only available in
newer kernels or out of a need for a kernel that works with
their hardware.   </p>

<p>When considered independently from each other, the decision to bypass
long-term kernels for non-LTS releases and the decision to publish HWE
kernels to extend the hardware support of LTS releases both seem
reasonable. In combination, though, these two decisions can lead to a
somewhat surprising situation; users running a &#34;long-term support&#34;
distribution can end up running a version of Linux which is considered
end-of-life by the kernel developers.
</p>

<p>
As of this writing, users running the HWE kernel on Ubuntu 20.04 will
get a 5.13 kernel backported
from 21.10. Ubuntu 22.04, which is the next LTS release, includes the 5.15
kernel, which is a long-term stable branch. This is currently available
to 20.04 users under the name &#34;<tt>hwe-20.04-edge</tt>&#34;. It
will presumably replace the kernel from 21.10 as <tt>hwe-20.04</tt>
sometime before July 14, when Ubuntu 21.10 is itself EOL. For now,
though, and for the past few months, anyone running the HWE kernel on 20.04
is running a kernel based on 5.13. Since the HWE kernel is the default
kernel on all three major clouds, problems with it can affect a large slice
of Ubuntu&#39;s users.  </p>

<h4>A tale of four filesystems</h4>

<p>The HWE kernel allows using newer hardware and kernel features with
Ubuntu LTS, but it seems that this may come with some cost to
stability. The root cause of the kernel crash lies at the intersection between 
no less than four different filesystems, although none of them are
filesystems in the traditional sense of something that writes data to
persistent storage.  </p>

<p>The first is <a href="https://lwn.net/Articles/542707/">overlayfs</a>.  As the name might
suggest, overlayfs allows overlaying the files in one directory (the
&#34;upper&#34; directory, in overlayfs parlance) on top of the files in another
(the &#34;lower&#34; directory.) This results in a mount point that contains all of
the files in both the upper and the lower directories; if both directories
contain a file with the same name, overlayfs presents the version present
in the upper directory. Any changes made to an overlayfs mount are
reflected in the upper directory.  The functionality provided by overlayfs
is particularly valuable to container runtimes such as Docker that store
container images as a series of layers; overlayfs provides an efficient way
of constructing a container&#39;s root directory from these layers. It has been
a part of the kernel since version 3.18 in 2014.  </p>

<p>The second filesystem involved is <a href="https://en.wikipedia.org/wiki/Aufs">AUFS</a>, which does everything that
overlayfs does, and a lot more, but its 
implementation is significantly more complex. AUFS weighs in at
about 35,000 lines of code, whereas overlayfs is about 12,000. 
AUFS was
first submitted for inclusion into the kernel in 2008, but was never
merged; since then, it has continued to be maintained out-of-tree.
Ubuntu included AUFS in its kernels through version 20.10, but dropped
it in 21.04.
</p>

<p>The third filesystem is <a href="https://lwn.net/Articles/757650/">shiftfs</a>, which was originally
created by James Bottomley in 2018 to allow remapping the user and
group IDs in
a mounted filesystem, and while it has never been merged upstream, it has
been included in Ubuntu&#39;s tree since the 5.0 kernel series.  Canonical&#39;s <a href="https://linuxcontainers.org/lxd">LXD 
project</a> can use shiftfs to speed up the creation of unprivileged
containers, where the root user inside the container is mapped to a user
other than root outside of it; otherwise, filesystems would
need to have their user and group IDs changed to be used in that way. It is
unlikely that shiftfs will ever land in Linus Torvalds&#39;s tree, 
though, as its functionality is entirely duplicated by the <a href="https://lwn.net/Articles/896255/">ID-mapped mounts</a> that were
added to the kernel in version 5.12. LXD has <a href="https://github.com/lxc/lxd/pull/8778">since been updated</a> to use
ID-mapped mounts when available.  </p>

<p>The fourth and final filesystem in our story is <a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">procfs</a>.
As is generally known, each process running on a Linux
system has a corresponding directory in <tt>/proc</tt>. Among a great many
other things, each of these directories contains a subdirectory named
<tt>map_files</tt>, which has a collection of symbolic links.
Each link corresponds to a range of addresses in the process&#39;s address
space that has been mapped to a file; the name of each link indicates the
range of addresses that are mapped, and the destination is
the file that is mapped to that range. For example: </p>

<pre>    $ ls -l /proc/$$/map_files/
    total 0
    lr-------- 1 jordan everybody 64 Jun 22 16:21 55e0cc120000-55e0cc14d000 -&gt; /usr/bin/bash
    lr-------- 1 jordan everybody 64 Jun 22 16:21 55e0cc14d000-55e0cc1fe000 -&gt; /usr/bin/bash
    ...
</pre>

<p>The most prominent user of the <tt>map_files</tt> subdirectory is
perhaps the <a href="https://criu.org/Main_Page">Checkpoint/Restore In
Userspace</a> (CRIU) tool, which
allows for &#34;checkpointing&#34; a process by serializing its entire state to
disk, and later &#34;restoring&#34; it by recreating the process from its
serialized state.  </p>

<h4>What does the patch do?</h4>

<p>The patch that caused the kernel panic when creating Docker containers
was intended to correct a problem when using overlayfs and shiftfs
together. If a process mapped a file from such a mount, the symbolic link
in <tt>map_files</tt> would point to the original &#34;unshifted&#34; version of
the file, instead of the path inside the shiftfs mount. This broke
checkpointing and restoring Docker containers, because the files the
symbolic links in <tt>map_files</tt> were pointing to were in filesystems
that weren&#39;t mounted inside the container.  </p>

<p>This problem was discovered
early in 2020, and fixed shortly after the release of Ubuntu 20.04. At the
time, AUFS was included in Ubuntu&#39;s kernel. The developers of AUFS had also
faced challenges related to 
differentiating between the real name of a file and its alias inside of an
AUFS mount. To address this, the AUFS patch introduces an
additional field called <tt>vm_prfile</tt> to the kernel&#39;s
<tt>vm_area_struct</tt>, which is populated with AUFS&#39;s name for the file.
To fix the problem with overlayfs and shiftfs,
Ubuntu&#39;s developers needed to keep track of a file&#39;s alias inside of a
synthetic mount, and, since AUFS had already added <tt>vm_prfile</tt> for a
similar purpose, they chose to reuse it instead of introducing another
 field. Knowing that their fix was dependent on AUFS being
enabled, they also chose to guard it in an <tt>#ifdef</tt> block — if AUFS
was not configured into the kernel, then the patch became a no-op.
</p>

<h4>How things went wrong</h4>

<p>When Ubuntu&#39;s developers ported the shiftfs-related patches from
their 5.8 kernel branch to their 5.13 and 5.15 kernels, the
patch that corrected the problem with <tt>map_files</tt> and shiftfs was
left out, because it depended on AUFS, which had been dropped from Ubuntu&#39;s
kernel. When those kernels were backported to Ubuntu 20.04, where AUFS
continues to be supported, the missing patch was noticed, and it was
applied to Ubuntu&#39;s 5.13 and 5.15 trees as well.
</p>

<p>
Unfortunately,
the internals of overlayfs changed over time in a way that eventually
caused the patch to be incorrect. As a result, when a file on an overlayfs is mapped into
memory, the function added by the patch attempts to release a reference to
a <tt>struct file</tt> using <tt>fput()</tt>, but the structure had
already been freed due to an earlier <tt>fput()</tt> call. That causes the kernel to 
panic.
</p>

<p>On Ubuntu 21.10, where 5.13 is the default kernel, this didn&#39;t cause any
problems. Since AUFS is not enabled, the <tt>#ifdef</tt> block around the
code introduced by the patch prevented it from being compiled into the
kernel. The problem occurred when 5.13 and 5.15 were rebuilt for Ubuntu
20.04. Since an HWE kernel needs to support all of the features that are
supported by the kernel it is replacing, AUFS was enabled in these builds,
and the code containing the extraneous <tt>fput()</tt> was compiled in.  </p>

<p>The problem was <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1967924/comments/8">noticed
in May</a>, almost immediately after the patch was added back in. However,
it appears that 5.13 was overlooked; the patch was reverted in
Ubuntu&#39;s 5.15 branch and replaced with a version that did not call
<tt>fput()</tt>, 
but the incorrect version remained in the 5.13 branch and made it into
the 5.13 HWE kernel.  </p> 

<p>According to the changelog, the problematic kernel package was built on
June 3, although it may not have been published to Ubuntu&#39;s package
repositories for some time afterward. The problem was reported on
June 8. Until updated packages were made available on June 10, the
only recourse 
available to affected users was to manually roll back to a previous kernel.
</p>

<h4>Conclusion</h4>

<p>Maintaining an out-of-tree kernel patch for any length of time is an
arduous task. As much as Linux has an iron-clad guarantee of user-space
compatibility, it provides zero assurances about the stability of internal
kernel interfaces between versions. Things that do not get merged often
quickly fall by the wayside, due to the sheer level of effort required to
keep up with changes elsewhere in the kernel.  </p>

<p>When Ubuntu ships out-of-tree patches with its LTS releases, it is
signing its kernel developers up for the task of maintaining
them for at least five years, often across multiple branches of the kernel
simultaneously. Sometimes these bets pay off; Ubuntu included overlayfs in
its kernel before it was merged, and now it is maintained upstream. On
the other hand, even though Ubuntu dropped support for AUFS in 2021,
because the distribution shipped it in 20.04, they are on the hook for supporting it
until 2025. Their latest LTS release, 22.04, still contains support for
shiftfs; those patches will be hanging around in Ubuntu&#39;s tree until at
least 2027. As the problem with the patch demonstrates, keeping these
patches up-to-date is no simple task; changes in other parts of the kernel can
and will cause problems, which requires careful attention.  </p>

<p>Based on those timelines, it doesn&#39;t seem like things are set to get any
easier for Ubuntu&#39;s kernel developers anytime soon. Indeed, things may
actually be destined to become harder; as the kernel now provides
equivalent functionality, interest in these out-of-tree alternatives is
likely to wane, which will place the burden of maintenance even more
squarely upon Ubuntu&#39;s shoulders. The bets that don&#39;t pay off turn into
debt, with compound interest.  </p>

<p>In the end, it appears that Ubuntu fell victim to at least some level of
self-inflicted complexity. Ubuntu&#39;s developers quickly caught and fixed the
problem, but only in one of the affected branches. Unfortunately, the
branch that was missed is the one that was shipped to users.  </p></div></div>
  </body>
</html>
