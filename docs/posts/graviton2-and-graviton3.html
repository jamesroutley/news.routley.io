<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://muratbuffalo.blogspot.com/2021/12/graviton2-and-graviton3.html">Original</a>
    <h1>Graviton2 and Graviton3</h1>
    
    <div id="readability-page-1" class="page"><div>

<main id="main" role="main" tabindex="-1">
<div id="page_body" name="Page Body">
<div data-version="2" id="Blog1">
<div>
<article>
<div>
<div>

<h3>
 Graviton2 and Graviton3
</h3>


<div id="post-body-8939732237797912897">
<p>What do modern cloud workloads look like? And what does that have to do with new chip designs?</p><h2>Graviton2</h2><p><a href="https://youtu.be/AaYNwOh90Pg?t=2475">This part is from the ReInvent2020 talk from Peter DeSantis.</a></p><p>Graviton2 is the best performing general purpose processor in our cloud by a wide margin. It also offers significantly lower cost. And it&#39;s also the most power efficient processor we&#39;ve ever deployed.</p><p><a href="https://lh3.googleusercontent.com/-QrlvEyX-ruE/YavgkvAMPaI/AAAAAAAAJ7c/mz2N-gGkaPsNHz4lWHlpLeXuNmqSGrWNACNcBGAsYHQ/Screen%2BShot%2B2021-12-04%2Bat%2B4.11.27%2BPM.png"><img alt="" data-original-height="976" data-original-width="2508" src="https://lh3.googleusercontent.com/-QrlvEyX-ruE/YavgkvAMPaI/AAAAAAAAJ7c/mz2N-gGkaPsNHz4lWHlpLeXuNmqSGrWNACNcBGAsYHQ/s16000/Screen%2BShot%2B2021-12-04%2Bat%2B4.11.27%2BPM.png"/></a></p></div>

</div>
</div>

</article>
</div>
</div><div data-version="2" id="PopularPosts1">
<h3>
Popular posts from this blog
</h3>
<div>
<div role="feed">
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/02/foundational-distributed-systems-papers.html"> Foundational distributed systems papers</a></h3>

<div>
<div>
<p>
I talked about the importance of reading foundational papers  last week. To followup, here is my compilation of foundational papers in the distributed systems area. (I focused on the core distributed systems area, and did not cover networking, security, distributed ledgers, verification work etc. I even left out distributed transactions, I hope to cover them at a later date.)  I classified the papers by subject, and listed them in chronological order. I also listed expository papers and blog posts at the end of each section. Time and State in Distributed Systems Time, Clocks, and the Ordering of Events in a Distributed System.  Leslie Lamport, Commn. of the ACM,  1978. Distributed Snapshots: Determining Global States of a Distributed System.  K. Mani Chandy Leslie Lamport, ACM Transactions on Computer Systems, 1985. Virtual Time and Global States of Distributed Systems.  Mattern, F. 1988. Expository papers and blog posts There is No Now . Justin Sheehy, ACM Queue 2015 Why Logical Clock
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/03/your-attitude-determines-your-success.html">Your attitude determines your success </a></h3>

<div>
<div>
<p>
This may sound like a cliche your dad used to tell, but after many years of going through new areas, ventures, and careers, I find this to be the most underrated career advice. This is the number one advice I would like my kids to internalize as they grow up. This is the most important idea I would like every one undertaking a new venture to know.  If you think you are not good enough, it becomes a self-fulfilling prophecy. If you think you are not enjoying something, you start to hate it.  I gave examples of this several times before. Let&#39;s suffice with this one : In graduate school, I had read &#34;Hackers: Heroes of the Computer Revolution&#34; from Steven Levy and enjoyed it a lot. (I still keep the dog eared paper copy with affection.) So, I should have read Steven Levy&#39;s Crypto book a long time ago. But for some reason, I didn&#39;t...even though I was aware of the book. I guess that was due to a stupid quirk of mine; I had some aversion to the security/cryptography res
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/08/progress-beats-perfect.html">Progress beats perfect</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2021/08/progress-beats-perfect.html">
<img alt="Image" sizes="72px" src="https://lh3.googleusercontent.com/--05YdBT8K8E/YQ30CG_MrBI/AAAAAAAAJzY/y5QAUdGtegE97sxsw8UN6cduYadXN41mACLcBGAsYHQ/w640-h640/0800.png" srcset="https://lh3.googleusercontent.com/--05YdBT8K8E/YQ30CG_MrBI/AAAAAAAAJzY/y5QAUdGtegE97sxsw8UN6cduYadXN41mACLcBGAsYHQ/w72-h72-p-k-no-nu/0800.png 72w, https://lh3.googleusercontent.com/--05YdBT8K8E/YQ30CG_MrBI/AAAAAAAAJzY/y5QAUdGtegE97sxsw8UN6cduYadXN41mACLcBGAsYHQ/w144-h144-p-k-no-nu/0800.png 144w"/>
</a>
</p>
<div>
<p>
This is a favorite saying of mine. I use it to motivate myself when I feel disheartened about how much I have to learn and improve. If I do a little every day or every week, I will get there. If I get one percent better each day for one year, I&#39;ll end up thirty-seven times better by the end of the year.   $1.01^{365}=37.78$ Years ago I had read this idea in one of John Ousterhouts life lessons, and it stuck with me.  &#34;A little bit of slope makes up for a lot of y-intercept&#34; Recently I noticed another advantage of progress over perfect. The emotional  advantage. Progress is better because it makes you feel better as you see improvement. You are getting there, you are making ... progress. Progress is growth mindset . You have an opportunity ahead of you. Perfect feels bad.. It puts you on defense. You have to defend the perfect, you have to keep the appearances. You can only go downwards from perfect, or maintain status quo. Progress gives you momentum. As long as you manag
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/06/cores-that-dont-count.html"> Cores that don&#39;t count</a></h3>

<div>
<div>
<p>
This paper is from Google and appeared at HotOS 2021 . There is also a very nice 10 minute video presentation for it. So Google found fail-silent Corruption Execution Errors (CEEs) at CPU/cores. This is interesting because we thought tested CPUs do not have logic errors, and if they had an error it would be a fail-stop or at least fail-noisy hardware errors triggering machine checks. Previously we had known about fail-silent storage and network errors due to bit flips, but the CEEs are new because they are computation errors. While it is easy to detect data corruption due to bit flips, it is hard to detect CEEs because they are rare and require expensive methods to detect/correct in real-time.  What are the causes of CEEs? This is mostly due to ever-smaller feature sizes that push closer to the limits of CMOS scaling, coupled with ever-increasing complexity in architectural design. Together, these create new challenges for the verification methods that chip makers use to detect diverse
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/06/silent-data-corruptions-at-scale.html"> Silent data corruptions at scale</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2021/06/silent-data-corruptions-at-scale.html">
<img alt="Image" sizes="72px" src="https://lh3.googleusercontent.com/-edGtrSlmRro/YMTEafT3J9I/AAAAAAAAJv4/_DWwt5c8mSs0FrQ1Gd1YYpp8zHNsxtacACLcBGAsYHQ/w640-h418/Screen%2BShot%2B2021-06-12%2Bat%2B10.27.50%2BAM.png" srcset="https://lh3.googleusercontent.com/-edGtrSlmRro/YMTEafT3J9I/AAAAAAAAJv4/_DWwt5c8mSs0FrQ1Gd1YYpp8zHNsxtacACLcBGAsYHQ/w72-h72-p-k-no-nu/Screen%2BShot%2B2021-06-12%2Bat%2B10.27.50%2BAM.png 72w, https://lh3.googleusercontent.com/-edGtrSlmRro/YMTEafT3J9I/AAAAAAAAJv4/_DWwt5c8mSs0FrQ1Gd1YYpp8zHNsxtacACLcBGAsYHQ/w144-h144-p-k-no-nu/Screen%2BShot%2B2021-06-12%2Bat%2B10.27.50%2BAM.png 144w"/>
</a>
</p>
<div>
<p>
This paper from Facebook (Arxiv Feb 2021)  is referred in the Google fail-silent Corruption Execution Errors (CEEs) paper  as the most related work. Both papers discuss the same phenomenon, and say that we need to update our belief about quality-tested CPUs not having logic errors, and that if they had an error it would be a fail-stop or at least fail-noisy hardware errors triggering machine checks. This paper provides an account of how Facebook have observed CEEs over several years. After running a wide range of silent error test scenarios across 100K  machines, they found that 100s of CPUs are identified as having these errors, showing that CEEs are a systemic issue across generations. This paper, as the Google paper, does not name specific vendor or chipset types. Also the ~1/1000 ratio reported here matches the ~1/1000 mercurial core ratio that the Google paper reports. The paper claims that silent data corruptions can occur due to device characteristics and are repeatable at scale
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2020/06/learning-about-distributed-systems.html"> Learning about distributed systems: where to start?</a></h3>

<div>
<div>
<p>
This is definitely not a &#34;learn distributed systems in 21 days&#34; post. I recommend a principled, from the foundations-up, studying of distributed systems, which will take a good three months in the first pass, and many more months to build competence after that.   If you are practical and coding oriented you may not like my advice much. You may object saying, &#34;Shouldn&#39;t I learn distributed systems with coding and hands on? Why can I not get started by deploying a Hadoop cluster, or studying the Raft code.&#34; I think that is the wrong way to go about learning distributed systems, because seeing similar code and programming language constructs will make you think this is familiar territory, and will give you a false sense of security. But, nothing can be further from the truth.   Distributed systems need radically different software than centralized systems do.    --A. Tannenbaum  This quotation is literally the first sentence in my distributed systems syllabus. Inst
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/02/read-papers-not-too-much-mostly.html">Read papers, Not too much, Mostly foundational ones</a></h3>

<div>
<div>
<p>
Here is my advice to people who want to develop competence and expertise in their fields. Read papers By papers, I mean technical research papers, not white papers or blog posts.  By read, I mean read rigorously and critically .  Not too much If you read rigorously and critically, you cannot read too many papers.  Moreover, learning by doing is the only way to internalize and grok a concept. If you read papers all day, you don&#39;t have time to try things yourself.  If you are a PhD student, maybe read two or three papers a week (but, remember, rigorously and actively). If you are not in academia, maybe read one paper a week or two.    Mostly foundational ones While there are exceptions, it is better to prioritize: seminal work over incremental work, general principled work over point-solutions, work introducing techniques/tools over work applying techniques A big exception is good expository papers. Unfortunately, the academia treats them as something the cat dragged in, because they
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/03/sundial-fault-tolerant-clock.html">Sundial: Fault-tolerant Clock Synchronization for Datacenters</a></h3>

<div>
<p><a href="http://muratbuffalo.blogspot.com/2021/03/sundial-fault-tolerant-clock.html">
<img alt="Image" sizes="72px" src="https://lh3.googleusercontent.com/-4Hbj1xn4VU0/YFdnMhJgCOI/AAAAAAAAJo4/0fr339MrVtsvvQl4qN-Flg5FYaSfczh5gCLcBGAsYHQ/w400-h154/Screen%2BShot%2B2021-03-21%2Bat%2B11.33.00%2BAM.png" srcset="https://lh3.googleusercontent.com/-4Hbj1xn4VU0/YFdnMhJgCOI/AAAAAAAAJo4/0fr339MrVtsvvQl4qN-Flg5FYaSfczh5gCLcBGAsYHQ/w72-h72-p-k-no-nu/Screen%2BShot%2B2021-03-21%2Bat%2B11.33.00%2BAM.png 72w, https://lh3.googleusercontent.com/-4Hbj1xn4VU0/YFdnMhJgCOI/AAAAAAAAJo4/0fr339MrVtsvvQl4qN-Flg5FYaSfczh5gCLcBGAsYHQ/w144-h144-p-k-no-nu/Screen%2BShot%2B2021-03-21%2Bat%2B11.33.00%2BAM.png 144w"/>
</a>
</p>
<div>
<p>
This paper appeared recently in OSDI 2020 . This paper is about clock synchronization in the data center. I presented this paper for our distributed systems zoom meeting group . I took a wider view of the problem by explaining time synchronization challenges and fundamental techniques to achieve precise time synchronization. I will take the same path in this post as well. It is a bit circuitous road, but it gives a scenic pleasurable journey. So let&#39;s get going. The benefits of better time synchronization For any distributed system, timestamping and ordering of events is a very important thing. Processes in a distributed system run concurrently without knowing what the other processes are doing at the moment.  Processes learn about each other&#39;s states only by sending and receiving messages and this information by definition come from the past state of the nodes. The process needs to compose the coherent view of the system from these messages and all the while the system is movi
</p>
</div>

</div>
</article>
<article role="article">
<h3><a href="http://muratbuffalo.blogspot.com/2021/10/linearizability.html"> Linearizability</a></h3>

<div>
<div>
<p>
Distributed/networked systems employ data replication to achieve availability and scalability. Consistency  is concerned with the question of what should happen if a client modifies some data items and concurrently another client reads or modifies the same items possibly at a different replica. Linearizability is a strong form of consistency. (That is why it is also called as strong-consistency.) For a system to satisfy linearizability,  each operation must appear (from client perspective) to occur at an instantaneous point between its start time (when the client submits it) and finish time (when the client receives the response), and  execution at these instantaneous points should form a valid sequential execution (i.e., it should be as if operations are executed one at a time ---without concurrency, like they are being executed by a single node)  Let&#39;s simplify things further. In practice, consistency is often defined for systems that have two very specific operations: read and w
</p>
</div>

</div>
</article>
</div>
</div>
</div></div>
</main>
</div></div>
  </body>
</html>
