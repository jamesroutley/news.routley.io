<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://educatedguesswork.org/posts/memory-management-5/">Original</a>
    <h1>Understanding Memory Management, Part 5: Fighting with Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
          <main>
            
<div>
  <div>
    <article>
        
        

        <figure>
<p><img src="https://educatedguesswork.org/img/lifetime-annotations.jpg" alt="Lifetime annotations everywhere"/></p>
</figure>
<p>This is the fifth post in my planned multipart series on memory
management. You will probably want to go back and read Part
<a href="https://educatedguesswork.org/posts/memory-management-1">I</a>, which covers C, parts
<a href="https://educatedguesswork.org/posts/memory-management-2">II</a> and
<a href="https://educatedguesswork.org/posts/memory-management-3">III</a>, which cover C++, and part
<a href="https://educatedguesswork.org/posts/memory-management-4">IV</a>, which introduces Rust memory
management.  In part IV, we got through the basics of Rust memory
management up through smart pointers. In this post I want
to look at some of the gymnastics you need to engage in to do
serious work in Rust.</p>
<h2 id="unexpected-moves">Unexpected Moves <a href="#unexpected-moves">#</a></h2>
<p>Consider the following simple Rust code:</p>
<pre><code><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span></code></pre>
<p>This is straightforward: we create a vector containing the values
<code>[1, 2]</code>, then iterate over it and print each element, and then
finally print out the length of the vector. This is the kind of
code people write every day. Let&#39;s see what happens when we compile
it.</p>
<pre><code>Error[E0382]: borrow of moved value: `x`</code></pre>
<p>No joy! The error message is reasonably helpful, though:</p>
<pre><code>note: `into_iter` takes ownership of the receiver `self`, which moves `x`</code></pre>
<p>At a high level, here is what is happening.</p>
<ul>
<li>The <code>for y in x</code> syntax tells Rust you want an iterator</li>
<li>In order to produce that iterator, Rust calls <code>x.into_iter()</code>, defined
by the trait <a href="https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html">IntoIterator</a>
which results in an iterator over <code>i32</code>.</li>
<li>The iterator <em>takes ownership</em> of the input vector <code>x</code>.</li>
</ul>
<p>In the spirit of this series, though, let&#39;s dig one level deeper. You can ignore
the rest of this section if you don&#39;t really care about Rust details, but this
took me a little while to work out, so it&#39;s going up on the Internet.</p>
<p>The <code>for y in x</code> expression in Rust is <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html#iterator-loops">syntactic
sugar</a>
for creating an iterator. The <code>x</code> value must implement the
<a href="https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
trait, which has the method <code>into_iter()</code>:</p>
<pre><code><span>pub</span> <span>trait</span> <span>IntoIterator</span> <span>{</span></code></pre>
<p><code>.into_iter()</code> returns an
<a href="https://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html"><code>Iterator</code></a>
object which exposes a <code>.next()</code> method that returns the next value
in the iterator. You can loop over the iterator by calling <code>.next()</code>
until it returns <code>None</code> (see
<a href="https://educatedguesswork.org/posts/text-type-safety/#union-types">here</a>
for some background on union types in Rust). For reference, here&#39;s what
the Rust reference says is the equivalent code to <code>for ...</code>:</p>
<pre><code><span>{</span></code></pre>
<p>As the code above says, Rust implicitly calls <code>IntoIterator::into_iter(x)</code>,
which is to say it calls the <code>.into_iter()</code> method call for <code>x</code> (in this
case of type <code>Vec&lt;i32&gt;</code>, i.e., <code>x.into_iter()</code>). The <code>IntoIterator::into_iter()</code> syntax is
needed in case <code>x</code> implements more than one trait that has an <code>into_iter()</code>
method because we need to tell the Rust compiler which method to choose
(see below).</p>
<p>This syntactic sugar is all internal compiler magic, but from here on in the rest is normal
(though a bit arcane) Rust.</p>
<h3 id="function-overloads">Function Overloads <a href="#function-overloads">#</a></h3>
<p>So why does this result in a move and why does replacing <code>x</code> with <code>&amp;x</code> fix it?
If you&#39;ve done any Rust programming, you know that you can call a method that
takes any kind of <code>self</code> parameter (i.e., a moved object, a reference, or a mutable
reference) as <code>self.foo</code> and Rust will automatically produce the right kind of parameter
assuming your object is compatible in terms of mutability.</p>
<p>For instance:</p>

<p><code>x</code> is actually a mutable object, but as you can see, when we call the
<code>ref_method</code>, it gets an immutable reference and the <code>mut_ref_method</code>
it gets an immutable reference, so the compiler just handles this.
Note that if we try to call <code>x.move_method()</code>
twice, we get an error about the use of a moved value, just as we expect
(that&#39;s why I called this method last).</p>
<pre><code>error[E0382]: use of moved value: `x`</code></pre>
<p>Similarly I can create a new <code>X</code> named <code>y</code> and a reference to it called <code>yref</code> and
call most of the methods via it. Note that you can&#39;t call <code>move_method()</code> because
you&#39;re not allowed to move things via references that way:</p>
<pre><code>error[E0507]: cannot move out of `*yref` which is behind a mutable reference</code></pre>
<p>I can even do the same thing without the temporary and just say <code>(&amp;y).ref_method()</code>.</p>
<p>So, if <code>x</code> and <code>&amp;x</code> are (mostly) interchangeable in method calls,
why do we have a problem and why does <code>&amp;x</code> fix it. The answer lies
in the fact that we&#39;re not calling a normal method but rather an
implementation of a trait (in this case <code>IntoIterator</code>). Because
traits are disconnected, it&#39;s possible for two traits to have
the same methods, like so:</p>
<pre><code><span>struct</span> <span>Hat</span> <span>{</span></code></pre>
<p>Both <code>Metric</code> and <code>Imperial</code> have <code>size()</code> functions, so if we make
a <code>Hat</code> and call <code>.size()</code>, what will happen? The answer is a compilation
error:</p>
<pre><code>error[E0034]: multiple applicable items in scope</code></pre>
<p>What&#39;s going on here is that the compiler has no way of knowing which
version of <code>size()</code> we want to call, because there are two equally
valid versions. In order to fix this, we need to disambiguate them,
and the compiler helpfully tells us how:</p>
<pre><code>help: disambiguate the method for candidate #1</code></pre>
<p>You can get pretty far with Rust by just doing what the compiler
says, and if we do that, things work as expected:</p>

<p>If you look closely, though, you&#39;ll notice something that we
had to pass a reference to <code>size()</code>, as in <code>Metric::size(&amp;hat)</code>;
if we just change this to <code>Metric::size(hat)</code> you get a compilation
error:</p>
<pre><code>  --&gt; trait-overload2.rs:28:18</code></pre>
<p>That&#39;s interesting: when we invoked a method with <code>.size()</code>
it didn&#39;t matter whether we explicitly provided a reference
or an object, everything worked great. But when we invoke it
this way, we actually have to provide an argument that will
match the <code>self</code> parameter, whether that&#39;s a value,
a reference, or a mutable reference, because we don&#39;t get
the magic behavior associated with <code>.</code>.</p>
<h3 id="implementations-of-intoiterator">Implementations of <code>IntoIterator</code> <a href="#implementations-of-intoiterator">#</a></h3>
<p>We&#39;re now in a position to understand what&#39;s happening here.
When we do <code>IntoIterator::to_iter(x)</code> this tells Rust to
expect a version of <code>to_iter()</code> that takes a value argument
(i.e., <code>Vec&lt;i32&gt;</code>)
which means we have to move <code>x</code> into the function, so we
can&#39;t reuse it.</p>
<p>It&#39;s a short step from there to understand why doing <code>for y in &amp;x</code>
works: there is also a version of <code>IntoIterator</code> for <code>&amp;Vec&lt;i32&gt;</code>, so
if we call <code>IntoIterator::to_iter(&amp;x)</code> then that version gets invoked
(at this point, these are just totally different types from Rust&#39;s
perspective). Because that version just borrows <code>x</code>, things work
fine with no double move.</p>

<p>You might ask at this point why Rust doesn&#39;t instead just do <code>.into_iter()</code>?
I can&#39;t find an explanation in the Rust documentation but I expect the
reason is that someone could implement another trait that provides
<code>.into_iter()</code> on whatever the <code>x</code> is in <code>for y in x</code>, thus resulting
in a compiler error because there would be two candidate implementations.</p>
<h2 id="method-calls">Method Calls <a href="#method-calls">#</a></h2>
<p>The next thing I want to look at is the impact of method calls.
This section uses the following (over)simplified model of a photo album
module to walk through the relevant issues:</p>
<pre><code><span>#[derive(Debug, Clone)]</span></code></pre>
<p>This should be easy to follow if you know any C-like language, even if you
don&#39;t know Rust, but just to orient you:</p>
<ul>
<li>
<p>A <code>Photo</code> is a structure containing a label and some bytes that represent
the image (<code>content</code>) (recall that I said this was oversimplified).</p>
</li>
<li>
<p>An <code>Album</code> is a collection of photos.</p>
</li>
</ul>
<p>Obviously, these &#34;photos&#34; are vacuous, in that they&#39;re just bytes, but
we&#39;re not going to be displaying them. Moreover, in
a real program, the album constructor (<code>init</code>) would load the photos
from a directory, but in this case it just makes up 5 empty <code>Photos</code>;
this is all fake, but the point here is just to have some scaffolding to
motivate/demonstrate the relevant issues.</p>
<p>Now, consider this simple program:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>Obviously, this does the following:</p>
<ul>
<li>First, we create the photo album (again, this is supposed to be
loading photos from the disk).</li>
<li>Make a new photo that is a scaled down version of the first photo.</li>
<li>Add the new photo to the album.</li>
<li>List the photos.</li>
</ul>
<p>This program compiles and runs just fine, like so:</p>
<pre><code>Photos [&#34;Image 0&#34;, &#34;Image 1&#34;, &#34;Image 2&#34;, &#34;Image 3&#34;, &#34;Image 4&#34;, &#34;Image 0-copy&#34;]<br/></code></pre>
<p>So far so good. Now, let&#39;s make a trivial modification where we also
add a bigger photo. No problem, we&#39;ll just do some copy-and-paste
<a href="https://en.wikipedia.org/w/index.php?title=Don%27t_repeat_yourself&amp;oldid=1284247935">DRY</a>
be damned:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>Unfortunately, this totally doesn&#39;t work. Instead, we get the following
error.</p>
<pre><code>error[E0502]: cannot borrow `album` as mutable because it is also borrowed as immutable</code></pre>
<p>LOLWAT?</p>
<p>The error message here is pretty good, but it&#39;s worth going through
what&#39;s happening:</p>
<ol>
<li>
<p>When we called <code>album.get_photo()</code> the return value was
a reference to an individual photo in <code>album</code>. In order to effectuate
this, Rust takes an immutable reference to <code>album</code>, even though
it&#39;s actually just returning a reference to one of the photos.</p>
</li>
<li>
<p>When we now go to call <code>album.add_photo()</code> we need to take
a mutable reference to <code>album</code> in order to provide it as the
<code>&amp;mut self</code> argument to <code>album.add_photo()</code>. However, because
we already have an immutable reference to <code>album</code>, this is a double
borrow and the compiler generates an error.</p>
</li>
</ol>
<p>But wait, you say, I&#39;m doing exactly this in the first program, and
indeed you are. Let&#39;s look at these side by side:</p>
<div>
<div>
<h4 id="working">Working <a href="#working">#</a></h4>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
</div>
<div>
<h4 id="broken">Broken <a href="#broken">#</a></h4>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
</div>
</div>
<p>Sure enough, the offending line is the <em>first</em> call to <code>add_photo()</code> which
was in the original code, not in the new code we added after. How can later
code break earlier code?</p>
<figure>
<p><img src="https://educatedguesswork.org/img/malcolm-tucker.jpg" alt="Malcolm Tucker"/></p>
</figure>
<p>The answer here is—surprise!—the borrow checker. What&#39;s
going on is that in the original code the last time we use <code>first_photo</code>
is in the call to <code>.scale()</code>, so even though it&#39;s <em>in scope</em> when
we call <code>.add_photo()</code> the borrow checker knows we&#39;re not going
to use it and so decides that it&#39;s not really live at the earlier
point, and so we don&#39;t have a double borrow. What causes the problem in the new code is that
we use <code>first_photo</code> in the second call to <code>scale()</code>, which means that
it has to be still be live when we call <code>add_photo()</code>, resulting in
the double borrow error.</p>
<p>OK, so we know the problem. How can we fix it? There are a number
of options.</p>
<h3 id="drop-and-re-borrow">Drop and Re-borrow <a href="#drop-and-re-borrow">#</a></h3>
<p>The easiest thing to do is to invalidate <code>first_photo</code>
by dropping <code>first_photo</code> and reacquiring it after
we call <code>.add_photo()</code>, as shown below:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>I&#39;ve done the Rust idiomatic thing here and reused the name
<code>first_photo</code>, thus <em>shadowing</em> the original variable, and you might
think that that&#39;s important, but this actually isn&#39;t necessary because
the Rust compiler can infer when a variable is being used, as we saw
before.  It works just as well if you name the new variable
<code>first_photo2</code>.</p>
<p>Re-acquiring <code>first_photo</code> is a reasonable approach in this
case because finding the photo is just a matter of looking up
the first value in the <code>.photos</code> vector in <code>album</code> and vector
lookups are fast. However, imagine that instead we had to
do some expensive operation that involved examining all
the photos in the album. Imagine there was an API that
asked for the photo of the cutest cat. Clearly we wouldn&#39;t want to do
that computation again!</p>
<h3 id="store-a-handle">Store a Handle <a href="#store-a-handle">#</a></h3>
<p>If we were using some expensive API to find the photo, then we
need to find some way to avoid paying that cost for each photo
we want to transform. One way to handle that is to have that
API return a <em>handle</em> to the photo rather than the photo itself.
The obvious thing to do here is to have the handle just be
the index in the array, like so:</p>
<pre><code><span>fn</span> <span>get_cutest_cat</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>usize</span><span>;</span></code></pre>
<p>You could then store the index and call <code>get_photo()</code> repeatedly,
as in the previous example, thus amortizing the expensive operation
and repeating the cheap one.</p>
<p>This will work as long as <code>add_photo()</code> doesn&#39;t invalidate
the handle. In this case, it doesn&#39;t because we add photos
to the end of the vector, but if we inserted them at
the front, then it would shift our photo up by one,
invalidating the handle. Note that this isn&#39;t something
that would be caught by the compiler; it just causes
a correctness error because the second time through we
try to resize the previous photo rather than the one
we intended. Deleting a photo would have a similar
problem. Note that no matter how badly you screw up,
this won&#39;t cause a memory error because Rust won&#39;t let
you index outside of the array; it&#39;s just a correctness
issue, but that doesn&#39;t mean it&#39;s not serious.</p>
<h3 id="make-a-copy">Make a Copy <a href="#make-a-copy">#</a></h3>
<p>Alternatively, we can make a copy of the photo. Fortunately,
<code>Photo</code> implements <code>Clone</code>, so this is straightforward:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>The obvious problem here is that the <code>.clone()</code> is actually moderately
expensive: we need to allocate enough space for a new copy of the image
and then copy the image data over. That&#39;s a lot of work to solve a
simple problem. Worse yet, this solution isn&#39;t always available,
as we might be working with a type that didn&#39;t implement <code>Clone</code>
or that wasn&#39;t in principle cloneable, for instance because it
was holding some external resource like a file. Nevertheless, this
is a common approach.</p>
<h3 id="restructure-the-code">Restructure the Code <a href="#restructure-the-code">#</a></h3>
<p>The final approach available to us is to restructure the code a bit
so that the lifetime of <code>first_photo</code> doesn&#39;t overlap the calls
to <code>.add_photo()</code>. In this case, this is a fairly simple matter
of computing both <code>smaller_photo</code> and <code>bigger_photo</code> and then adding
them both, like so:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>This is probably the most idiomatic thing to do in this specific case in that
it doesn&#39;t have the negative performance effects of the previous
options and doesn&#39;t require any changes to the API as the last
two options potentially do (making <code>Photo</code> <code>Clone</code> or adding
a handle API). However, it&#39;s also a lot more disruptive to the
logic of the code.  Suppose that you wanted
to use a loop to generate images of various size, like so:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>Now we have to aggregate <em>all</em> of the modified versions of
the original photo and then add them all at once, like so:</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>At one level, this is just irritating, in that we have to restructure
the code. But because we&#39;re having to store the transformed
photos in memory we&#39;re potentially increasing the memory footprint
of the program significantly. That&#39;s not the case here because
<code>add_photo()</code> just moves a photo from the temporary vector to the vector
in <code>album</code>,
but if <code>Album</code> stored photos on disk, we could run out
of memory in the first loop whereas if we stored photos right
away that wouldn&#39;t happen. In this situation you would have
to use one of the other approaches.</p>
<h4 id="non-lexical-lifetimes">Non-Lexical Lifetimes <a href="#non-lexical-lifetimes">#</a></h4>
<p>I said above that Rust could infer that <code>first_photo</code>
wasn&#39;t in use and therefore it didn&#39;t count as a reference
for the purposes of the borrowing rules. This didn&#39;t used
to be true. In older versions of Rust, the fact that
the variable existed was enough to keep the reference
alive, whether it was subsequently used or not. So,
for instance, if we go back to our original code,
we would have a double-borrow problem because <code>first_photo</code>
is still in scope through the end of the function. Instead,
you would have had to do something like this:</p>
<pre><code>    <span>let</span> <span>mut</span> album <span>=</span> <span>Album</span><span>::</span><span>init</span><span>(</span><span>&amp;</span><span>&#34;directory&#34;</span><span>)</span><span>;</span></code></pre>
<p>Putting <code>first_photo</code> in a braced block like this causes it to be
explicitly dropped so that when <code>add_photo</code> needs to borrow <code>&amp;mut self</code> it&#39;s not a double borrow. This was obviously a pain in the ass
and Rust eventually added a feature called <a href="https://blog.rust-lang.org/2022/08/05/nll-by-default.html">non-lexical
lifetimes</a>
which made the compiler smarter about knowing when references were
really live.</p>
<p>One thing to notice is that the original code was <em>always</em>
safe, it&#39;s just that the compiler didn&#39;t realize it.
Rust&#39;s borrow checker is <em>conservative</em> in that it will only
accept code it can prove is safe, but it will also reject
code which is actually safe but the borrow checker can&#39;t prove
is safe. This leaves room for improvements in the language
as the borrow checker gets smarter and constructs which would
previously have been errors—but were actually safe—become
allowed.</p>
<h3 id="why%2C-oh-why%3F">Why, oh why? <a href="#why%2C-oh-why%3F">#</a></h3>
<p>At this point, you might want to ask why Rust is torturing you
like this? Why can&#39;t I just do what I want to, like in good ol&#39; C++? And at first glance,
it looks like the original double borrow code is safe. After all, we&#39;re not <em>using</em>
<code>first_photo</code> simultaneously with <code>album.add_photo()</code>, it&#39;s just
sitting there waiting for us to use it again.</p>
<p>But actually what&#39;s happening here is the same problem we saw
in the <a href="https://educatedguesswork.org/posts/memory-management-4/#mutable-and-immutable-references">previous post</a>:
<code>first_photo</code> is a reference (a pointer) to an element in the
array, as shown below:</p>
<figure>
<p><img src="https://educatedguesswork.org/img/photos-reference-1.png" alt="first_photo is a reference"/></p>
<figcaption>
<p><code>first_photo</code> is a reference</p>
</figcaption>
</figure>
<p>If we add a new photo and that causes the memory allocated to
the array or vector to resize (this can happen even if we
just add an element to the end), then suddenly <code>first_photo</code> is
pointing to an unallocated region of memory, as shown below.</p>
<figure>
<p><img src="https://educatedguesswork.org/img/photos-reference-2.png" alt="after resize"/></p>
<figcaption>
<p><code>first_photo</code> after a resize</p>
</figcaption>
</figure>
<p>If Rust is going to be safe, it can&#39;t allow this, so the code
won&#39;t compile.</p>
<div>
<h4 id="safer-handles">Safer Handles <a href="#safer-handles">#</a></h4>
<p>As an aside, it&#39;s somewhat possible to write handles in a way that
is safer than just a simple integer. For example, we could
have the handle store not just the index of the element
but also some identifier for the contents of the element
in such a way that the handle would become invalid if the
element changed. In this case, the result would be that
if an element were inserted before the photo, shifting the
elements to the right, an attempt to dereference the handle
would fail, so you&#39;d get a runtime error.</p>
<p>Probably a better approach in this case is to replace
a generic handle with a query which caches its results.
For instance, we could have <code>find_cutest_cat()</code> remember
the current cutest cat and which photos it had looked at
and then when you ask for the result, it just looks at any
new pictures of cats to compare them to the current cutest;
this is far more robust than trying to build some kind of
safer handle structure.</p>
</div>
<p>It&#39;s important to realize that the <em>logical</em> situation is the
same as with handles: we have a reference (in the general sense,
not the Rust technical sense), which is now invalid. The
difference is that the handle (in this case an integer) is
an offset into the vector, as opposed to the address of
some random region in memory. This means that only one of
two things can happen:</p>
<ol>
<li>
<p>The handle is smaller than the size of the array and so
there&#39;s an element at the relevant location, just
not the one that&#39;s expected. This causes the program
to silently malfunction.</p>
</li>
<li>
<p>The handle is greater than or equal to the size of the
array, in which case you&#39;ll get a runtime error right
away.</p>
</li>
</ol>
<p>In neither case do you have a memory error. This nicely illustrates the sense in which Rust is &#34;safe&#34;,
namely that it prevents you from memory errors but not logic
errors (though it does protect against some, as seen below).
It&#39;s still very possible to write bugs in Rust; it&#39;s just
that they don&#39;t result in memory corruption.</p>
<h2 id="lifetimes">Lifetimes <a href="#lifetimes">#</a></h2>
<p>In the previous section I just glossed over something tricky. Let&#39;s
take another look at <code>Album::get_photo()</code>:</p>
<pre><code>    <span>pub</span> <span>fn</span> <span>get_photo</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> index<span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>Photo</span> <span>{</span></code></pre>
<p>In this code I&#39;m taking a reference to <code>&amp;self.photos[index]</code> and
returning it, but what makes this safe? Suppose that <code>album</code> gets
deleted while I&#39;m still hanging on to the return value. Don&#39;t
I get a dangling reference. Let&#39;s try it and see.</p>
<pre><code><span>use</span> <span>photos<span>::</span>photos<span>::</span></span><span>*</span><span>;</span></code></pre>
<p>Reassuringly, this won&#39;t compile, producing the following
error:</p>
<pre><code>error[E0597]: `album` does not live long enough</code></pre>
<p>Dodged a bullet there. After we&#39;ve taken a deep breath because Rust saved us from ourselves,
we might start to wonder what is actually going on here: how
does Rust know that <code>first_photo</code> is a borrow of <code>album</code>? That&#39;s
information that is only available by looking at the implementation
of <code>get_photo()</code> and remember what I said about local reasoning?</p>
<p>Understanding what is going on here requires understanding what
Rust calls &#34;lifetimes&#34;. Let&#39;s start with the basic rule that Rust
enforces.</p>
<center>
<p><em>If <code>B</code> is a reference to object <code>A</code> then <code>B</code> can&#39;t outlive object <code>A</code>.</em></p>
</center>
<p>Obviously, what&#39;s gone wrong here is that <code>album</code> goes out of scope at the end
of the block enclosing it, at which point the reference to <code>album</code>
in <code>first_photo</code> is invalid. I.e., it has <em>outlived</em> <code>album</code>.</p>
<p>The <em>lifetime</em> of a variable is the time between when it&#39;s first
created and when it&#39;s last used. So, another way of stating the
above rule is that:</p>
<center>
<p><em>If <code>B</code> is a reference to object <code>A</code> then <code>B</code>&#39;s lifetime must be contained
within <code>A</code>&#39;s lifetime (though they can be coextensive).</em></p>
</center>
<p>Just to see the problem more clearly here, I&#39;ve annotated the code
to show the relevant lifetimes.
The annotated code below shows the lifetime of <code>album</code> and <code>first_photo</code>
in our working code. As you can see, <code>first_photo</code> is last used
before the end of the block, which is when <code>album</code> goes out of scope (and
hence the end of its lifetime).</p>
<pre><code>use photos::photos::*;</code></pre>
<p>Now compare the annotated version of the broken code:</p>
<pre><code>use photos::photos::*;</code></pre>
<p>As before, <code>album</code>&#39;s lifetime ends at the end of the enclosing block,
but in this case, <code>first_photo</code> is used after that point, so its lifetime
extends past the end of <code>album</code>, which, as noted before, is forbidden.
Note that <code>first_photo</code> <em>exists</em> before it is first assigned to
point to <code>album</code>, but it&#39;s not a reference to <code>album</code>. Actually,
in this case it&#39;s not assigned to anything, and so using it would
be forbidden prior to assignment.</p>
<p>This brings us back to the question I asked above: how does Rust know
that <code>first_photo</code> is a borrow of <code>album</code> and not of something else?
And what if I did want to borrow something else?</p>
<h3 id="seeing-like-a-compiler">Seeing Like a Compiler <a href="#seeing-like-a-compiler">#</a></h3>
<p>Although every variable in Rust has a lifetime, so far we&#39;ve managed
to avoid dealing with that because the compiler can often infer
those lifetimes and act appropriately. However, there are situations
where that&#39;s not the case.</p>
<p>Let&#39;s start with a simple example to get the idea:</p>
<pre><code><span>fn</span> <span>return_first</span><span>(</span>first<span>:</span> <span>&amp;</span><span>str</span><span>,</span> second<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>str</span> <span>{</span></code></pre>
<p>This is some pretty obvious code: we pass two string references
into <code>return_first()</code> and it returns the first one. But when
we try to compile it we get an error:</p>
<pre><code>error[E0106]: missing lifetime specifier</code></pre>
<p>Rust error messages are usually clearer than this, but what&#39;s
going on is that the compiler isn&#39;t able to verify that the
lifetimes here follow the rules.
Specifically, the return value of <code>return_first()</code> is a reference to
something, but the compiler doesn&#39;t know how long it&#39;s supposed to be
valid for. This will cause a problem when we try to use <code>println!()</code>
on it, because Rust doesn&#39;t know if it&#39;s safe to use in that context.
We are able to examine the function and realize it&#39;s safe, but
because the compiler wants to use local reasoning, it&#39;s not able
to do so.</p>
<p>What I mean by local reasoning is when checking <code>main()</code>
from the compiler&#39;s perspective, at this point the program looks like this:</p>
<pre><code><span>fn</span> <span>return_first</span><span>(</span>first<span>:</span> <span>&amp;</span><span>str</span><span>,</span> second<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>str</span> <span>{</span></code></pre>
<p>When checking to see if <code>main()</code> is following the lifetime rules,
the compiler wants to use only the information it has available
from the function <em>signature</em>, without looking at the implementation.
Conversely, when it checks <code>return_first()</code> it won&#39;t look at <code>main()</code>.
If you&#39;re a C or C++ programmer, this should be conceptually familiar
because C and C++ programs have header (<code>.h</code>) files which conventionally
contain function and method signatures, with the implementation
(the body) living in <code>.c</code> or <code>.cc</code> (or <code>.cpp</code> or <code>.c++</code>) files.
This allows the compiler to compile one file (technical term: &#34;translation unit&#34;)
without knowing how another file works, but only the interfaces it
provides. Rust doesn&#39;t have a header/body split like C and C++
but you can still get into the same situation if you are operating
on a &#34;trait object&#34; (the Rust equivalent of C++ virtual functions),
because you only know the trait definition.</p>
<p>In order to make this code compile, we have to help the compiler
out by telling it the <em>expected</em> lifetime of the return value.
We do this by decorating variables with a lifetime annotation,
which looks like <code>&#39;a</code>.
Specifically, what we need to express here
is that the return value is not expected to outlive the first
argument and thus it&#39;s safe to use the return value as long as
the first argument is also alive. The notation for this looks
like:</p>
<pre><code><span>fn</span> <span>return_first</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span>a<span>:</span> <span>&amp;</span><span>&#39;first</span> <span>str</span><span>,</span> second<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>str</span></code></pre>
<p>Note how the notation here looks a little like C++ templates
(and Rust generics, which we didn&#39;t go into as much), because
this is a kind of generic. You read this line as follows:</p>
<blockquote>
<p>There is some lifetime <code>&#39;a</code> such that the return value is valid
during <code>&#39;a</code> (and can&#39;t be safely used after) and that whatever
<code>first</code> is pointing to lives
at least as long as <code>&#39;a</code>.</p>
</blockquote>
<p>The way to look at these lifetime annotations is that they are
defining the <em>contract</em> for this function. In order to enforce
that contract, the compiler does two things:</p>
<ul>
<li>
<p>Analyzes the caller of the function to verify that it isn&#39;t
using the return value outside of the lifetime of whatever
it passed as the first argument. As noted above, it can do
this without looking at the function body.</p>
</li>
<li>
<p>Analyzes the body of the function to verify that the return
value is actually derived from the first argument, so that
it will be safe as long as the first argument is valid.</p>
</li>
</ul>
<p>We&#39;ve seen the first check in action, but let&#39;s look at the
second check. Consider what happens if we change the return
value to be derived from the second argument:</p>
<pre><code><span>fn</span> <span>return_first</span><span>(</span>first<span>:</span> <span>&amp;</span><span>str</span><span>,</span> second<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>str</span> <span>{</span></code></pre>
<p>I&#39;ve commented out the call to <code>return_first()</code> so we&#39;re not even using
the return value, but we still get an error because the
function body isn&#39;t fulfilling the contract:</p>
<pre><code>error[E0106]: missing lifetime specifier</code></pre>
<p>As illustrated here, it&#39;s not possible to produce unsafe code by
giving the compiler the wrong lifetime: if we screw up
the compiler will throw an error. In this sense, lifetimes are
just a hint to the compiler and a sufficiently smart compiler could
do without them.</p>
<h3 id="lifetime-elision">Lifetime Elision <a href="#lifetime-elision">#</a></h3>
<p>In fact, it&#39;s because lifetimes are a kind of hint that our original photo handling
code works without lifetime annotations. To see this, consider
the following trivial modification of this program in which
we only pass in one argument:</p>
<pre><code>fn return_first(first: &amp;str) -&gt; &amp;str {
    first
}

fn main() {
    println!(&#34;{:?}&#34;, return_first(&amp;&#34;first&#34;));
}
</code></pre>
<p>The compiler will process this just fine because it contains
a set of <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">default rules</a>
(&#34;lifetime elision&#34;) that handle common cases. The rule that is applicable to this
case are:</p>
<blockquote>
<p>The second rule is that, if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32.</p>
</blockquote>
<p>In other words, Rust is secretly changing the function signature
to be:</p>
<pre><code><span>fn</span> <span>return_first</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span>first<span>:</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>str</span></code></pre>
<p>This is reasonable because the vast majority of—but not all—valid code that
has this kind of signature will be returning a reference to
something derived from one of the arguments.
However, once again, this is just a default: if we were to change <code>return_first()</code> to
return a reference to something not derived from <code>first</code>, then the compiler
would generate an error. First, consider the following:</p>
<pre><code><span>fn</span> <span>return_first</span><span>(</span>first<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>str</span> <span>{</span></code></pre>
<p>In this case, we are returning a dangling reference to <code>s</code>,
which only lives to the end of the function. This is plainly
illegal—in fact, this is exactly what Rust lifetimes
are designed to prevent—and so the compiler returns
an error. No amount of lifetime decorations will make it
compile.</p>
<h3 id="multiple-arguments">Multiple Arguments <a href="#multiple-arguments">#</a></h3>
<p>Functions with a single argument are easy mode. For functions with
multiple arguments, Rust will assign each one its own
lifetime (rule one), at which point it doesn&#39;t know which lifetime to
associate the return value with. This is why the version above with two arguments
doesn&#39;t work without lifetime annotations, because Rust
is internally giving it the following signature:</p>
<pre><code><span>fn</span> <span>return_first</span><span>&lt;</span><span>&#39;a</span><span>,</span><span>&#39;b</span><span>,</span><span>&#39;c</span><span>&gt;</span><span>(</span>first<span>:</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>,</span> second<span>:</span> <span>&amp;</span><span>&#39;b</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;c</span> <span>str</span></code></pre>
<p>Because it doesn&#39;t know the lifetime of <code>&#39;c</code>, the compiler is
not able to determine either whether the return value is being
used safely at the call site. We can resolve this issue
as above by explicitly labeling the return value with a lifetime
matching one of the arguments.  To take one of the <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures">examples</a> from the Rust book, if the function might
return either <code>first</code> or <code>second</code> then you need to
attach the same lifetime to both arguments, with the
result that Rust will verify safety for whatever lifetime
is shorter (recall that <code>&#39;a</code> only has to be a lifetime that
satisfies all the constraints).</p>
<h3 id="member-functions">Member Functions <a href="#member-functions">#</a></h3>
<p>There is one more special case: when you have a method call,
then Rust assumes that the lifetime of any references returned
will be the same as <code>self</code>. Turning back to <code>get_photo()</code>, this
means that Rust is internally assigning the lifetime.</p>
<pre><code>    <span>pub</span> <span>fn</span> <span>get_photo</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>&#39;a</span> <span>self</span><span>,</span> index<span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>Photo</span></code></pre>
<p>If you wanted a member function to return another argument,
you would need to explicitly annotate the function, like so:</p>
<pre><code>    <span>fn</span> <span>get_stuff</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> s<span>:</span> <span>&amp;</span><span>&#39;a</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>str</span></code></pre>
<h3 id="structs">Structs <a href="#structs">#</a></h3>
<p>There&#39;s one more case worth covering: structs can have members
that are references, in which case you have to provide a lifetime
for the reference. This looks like:</p>
<pre><code><span>struct</span> <span>Foo</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span></code></pre>
<p>The semantics of this are the same as having a variable with the same
reference label: the lifetime of <code>x</code> and hence <code>Foo</code> has to be shorter
than the lifetime of whatever <code>x</code> is a reference to. This all
works, but things start to get hairy pretty fast because you have to
decorate a lot of stuff with the lifetimes, as in:</p>
<pre><code><span>#[derive(Debug)]</span></code></pre>
<p>Now let&#39;s try one more thing. Check out the following code:</p>
<pre><code><span>#[derive(Debug)]</span></code></pre>
<p>Just to orient you, this code defines a struct called <code>Holder</code>. It&#39;s a
generic type parameterized on <code>T</code> so that it can hold an instance of any <code>T</code>. The
actual member value (<code>t</code>) is an <code>Option&lt;T&gt;</code> so that we can create
an empty <code>Holder</code> and then fill it with <code>.set_value()</code>—or at least
in principle can fill it with <code>.set_value()</code>. In practice, <code>.set_value()</code>
has the signature you would expect from the name, but doesn&#39;t actually do anything,
so <code>Holder</code> always contains a <code>None</code>. You have to use this <code>Option</code>
trick a lot in Rust because there&#39;s no way to have empty object
references like C++ <code>nullptr</code> (or, arguably, that&#39;s what <code>Option</code> is for).</p>
<p>If we call <code>.set_value()</code> with an instance of <code>i32</code>, then everything
works as expected. The program compiles and outputs:</p>
<pre><code>Holder { t: None }
</code></pre>
<p>Note that even though this is a generic, we didn&#39;t need to tell
Rust which type to instantiate it (Rust jargon: monomorphize) with.
Instead, it inferred it from the fact that we called <code>.set_value()</code> with
a type of <code>i32</code>: <code>set_value()</code> is defined as taking an argument of
type <code>T</code> and thus this means we must have a <code>Holder&lt;i32&gt;</code>.</p>
<p>Now let&#39;s do the exact same thing but but with one small change:
pass <code>&amp;tmp</code> to <code>holder.set_value()</code>:</p>
<pre><code><span>#[derive(Debug)]</span></code></pre>
<p>Surprise (or maybe not?)! This doesn&#39;t compile at all.</p>
<pre><code>warning: unused variable: `t`</code></pre>
<p>We&#39;re now seeing the downstream consequences of the lifetime
annotations for structs. As mentioned above, if you have a reference
member in a struct, it needs a lifetime, so when we monomorphized
<code>Holder</code> with an <code>i32</code>, it had to associate a lifetime with it,
so we ended up with something like:</p>
<pre><code><span>struct</span> <span>Holder</span><span>&lt;</span><span>&amp;</span><span>&#39;a</span> <span>i32</span><span>&gt;</span> <span>{</span></code></pre>
<p>And when we called <code>.set_value(&amp;tmp)</code>, <code>&#39;a</code> got associated with
the lifetime of <code>tmp</code>. That lifetime ends when the block ends,
but <code>holder</code> extends past the end of the block, so we have
a lifetime error. You&#39;ll note that we didn&#39;t even have to use
the reference passed to <code>.set_value()</code> to make this happen:
Rust just looked at the function signature and decided that
in principle we <em>could</em> be using it and so that meant
<code>holder</code> had to be treated as if it were holding a reference
to <code>tmp</code>. If we change <code>.set_value()</code> to take a <code>&amp;self</code> instead
of a <code>&amp;self</code> (this is fine because we&#39;re not touching
<code>self.t</code> anyway), then the problem resolves itself and the
program will compile just fine.</p>
<h2 id="bonus%3A-thread-safety">Bonus: Thread Safety <a href="#bonus%3A-thread-safety">#</a></h2>
<p>Everything in this post has been about memory allocation, but here&#39;s
the cool part: Rust also provides thread safety, mostly through
the same mechanisms that provide memory safety. This post is
already quite long, but I want to briefly give you an intuition of
how this works.</p>
<p>The basic cause of thread safety issues in software is when you
have the same data value being modified by two threads at once.
Consider the following trivial function for a bank&#39;s accounting
system:</p>
<pre><code><span>function</span> <span>pay_money</span><span>(</span><span>payee<span>,</span> amount</span><span>)</span> <span>{</span></code></pre>
<p>This looks like perfectly reasonable code, but what happens if
we decide to run it in a multithreaded program where requests
to pay people can come in in parallel. Suddenly, we have a serious
problem because the individual steps of these threads can
execute in any order. For instance, we might have the following
order of execution:</p>
<pre><code>Thread 1                                  Thread 2</code></pre>
<p>This will (maybe) work fine sometimes but what happens if we have $100
in the account and then we get two transactions for $75 each?  The
obvious thing to expect is that we end up with $-50 dollars in the
account—or, depending on the language, maybe
<code>$4294967246</code> dollars, oops!—because thread 1 checks the balance prior to thread 2 debiting
it. This is what&#39;s called a &#34;time of check time of use&#34; bug.</p>
<p>Actually the situation is much much worse than this because
compiler output isn&#39;t really anywhere near as neat as I&#39;ve suggested here, so all
sorts of things could happen. For example, the compiler during the
initial read of <code>balance</code> the compiler could decide to store the
value of <code>balance</code> in a register and then write it back to balance
from that register, with the result that the first write is lost.
To take a more extreme example, the compiler can move values in registers
<em>into</em> your variables if it wants to (this is called a &#34;register spill&#34;)
as long as it restores them afterwards; this can cause obvious problems
if you then contaminate one of the values it&#39;s using.
This great <a href="https://web.archive.org/web/20170316072356/https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong">post</a> by Dmitry Vyukov) goes into a lot more detail here, but the basic
point is that if you ever do uncoordinated writes to the same
data values it&#39;s incredibly bad news (again, it&#39;s undefined
behavior in C/C++). In general, the compiler is allowed to assume
you never try to access the same value in two threads and so if you
do, all bets are off.</p>
<p>If you&#39;ve written any multithreaded code, you know that the basic
defense against this kind of problem is what&#39;s called &#34;locking&#34;:
one thread &#34;locks&#34; a region of memory and as long as it&#39;s holding
the lock, no other thread can touch that region.
There are a lot
of different kinds of lock, but one common one is what&#39;s called a
&#34;read-write lock&#34;. A read-write lock has the following semantics:</p>
<ul>
<li>
<p>If you hold a read lock on a particular region, you&#39;re allowed to
read the memory but not write it. An arbitrary number of threads can
hold read locks on a given region as long as no thread holds a write
lock.</p>
</li>
<li>
<p>If you hold a write lock on a particular region, you can read or
write it.  No other thread
can hold any kind of lock on a region as long
as someone is holding a write lock.</p>
</li>
</ul>
<p>This should sound very familiar because it&#39;s precisely the semantics
Rust uses for mutability, if you just substitute &#34;immutable reference&#34;
for &#34;read lock&#34; and &#34;mutable reference&#34; for &#34;write lock&#34;. This is
not an accident, but instead it&#39;s a sign of a deep connection
between memory safety and thread safety.</p>
<h3 id="moving-data-between-threads">Moving Data Between Threads <a href="#moving-data-between-threads">#</a></h3>
<p>As we&#39;ve discussed from the very beginning, Rust is a single
ownership language; if a given object is owned by one thread
then obviously it cannot be modified by two threads at once.
It can, however, be moved between threads, by two basic
mechanisms:</p>
<ul>
<li>
<p>When you <a href="https://doc.rust-lang.org/book/ch16-01-threads.html#creating-a-new-thread-with-spawn">spawn</a>
a thread, you provide a function for the
thread to run. This function can be a <a href="https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html">closure</a>, which is a fancy term for an anonymous function defined in line.
The closure can capture variables from the environment.</p>
</li>
<li>
<p>Rust provides mechanisms to write from one thread to another, such
as
<a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">channels</a>.</p>
</li>
</ul>
<h4 id="spawning-a-thread">Spawning a Thread <a href="#spawning-a-thread">#</a></h4>
<p>Let&#39;s start with spawning a new thread. The basic code looks like this:</p>
<pre><code><span>use</span> <span>std<span>::</span></span>thread<span>;</span></code></pre>
<p>The <code>|| {}</code> is the syntax for a closure and when used with the <code>move</code>
keyword, which means that any variable used in the body of
the closure (&#34;captured&#34;) is moved into the closure. This means
that <code>val</code> will be unavailable inside <code>main</code> after this point,
but will be available inside the closure, which is why we can
pass it to <code>println!()</code>.</p>
<p>Now look what happens if we do the same thing but moving a reference
to <code>val</code>:</p>
<pre><code><span>use</span> <span>std<span>::</span></span>thread<span>;</span></code></pre>
<p>As expected, this doesn&#39;t compile at all.</p>
<pre><code>error[E0597]: `val` does not live long enough</code></pre>
<p>The lifetime problem here is that <code>main()</code> may exit or
at least start to exit while
the thread is still running, which means that <code>val</code>
get dropped and <code>val_ref</code> becomes invalid. There&#39;s no
way to statically verify that <code>main()</code> will wait for
the other thread to complete, so there&#39;s no way to
have the thread reference a local variable of <code>main()</code>.
As indicated by this error, the only kind of reference
you can pass to a thread is one that has the special
<code>&#39;static</code> lifetime, which means it lasts the entire lifetime
of the program (typically it&#39;s a global variable).</p>
<p>You can make <code>val</code> static, as shown in the code below,
but safe Rust <a href="https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics">forbids mutable static variables</a>, so the result
is that the variable is read only in both the thread
and in <code>main()</code>, which preserves the &#34;arbitrary number
of immutable references&#34; invariant.</p>
<pre><code><span>use</span> <span>std<span>::</span></span>thread<span>;</span></code></pre>
<p>While the logic is similar to what we saw <a href="#structs">above</a>,
the enforcement mechanism for this is slightly different.
The reason for this is that <code>thread::spawn()</code> is just a function
and so even though we&#39;re passing it a reference there&#39;s nowhere
for it to store it, so once <code>thread::spwan()</code> returns, that
reference should have been dropped which would mean it was safe
to drop the object it pointed to. You know and I know that
what <code>thread::spawn()</code> actually does is to create a new thread
that runs independently from the main thread, but how is the
compiler to know that?</p>
<p>What is happening here is that <code>thread::spawn()</code> is defined with
a specific set of trait bounds (traits which the arguments
and return values have to implement):</p>
<pre><code><span>pub</span> <span>fn</span> <span>spawn</span><span>&lt;</span><span>F</span><span>,</span> <span>T</span><span>&gt;</span><span>(</span>f<span>:</span> <span>F</span><span>)</span> <span>-&gt;</span> <span>JoinHandle</span><span>&lt;</span><span>T</span><span>&gt;</span></code></pre>
<p>Focus your attention on the generic parameter <code>F</code>, which is
the type of the closure passed to <code>spawn()</code>. This is defined
as having to implement the following traits:</p>
<dl>
<dt><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce() -&gt; T</code></a>:</dt>
<dd>Be a function which can be safely called at least once and
has a return value of type <code>T</code></dd>
<dt><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>:</dt>
<dd>Can be safely [transferred across thread boundaries.</dd>
<dt><code>&#39;static</code>:</dt>
<dd>Lasts for the duration of the program.</dd>
</dl>
<p>It&#39;s this last constraint which matters for our purposes, because it
requires that the closure and <em>anything it captures</em> has the
lifetime <code>&#39;static</code>. Because a reference to a local variable doesn&#39;t
have <code>&#39;static</code> lifetime, it can&#39;t be passed to <code>thread::spawn()</code>
so there&#39;s no way to use <code>thread::spawn()</code> to create an unsafe
reference.</p>
<h4 id="channels">Channels <a href="#channels">#</a></h4>
<p>The other main option is to use some sort of messaging
system to write data from one thread to another. For
instance, Rust has a built-in mechanism called channels,
which works like this:</p>
<div>
<div>
<h4 id="sender">Sender <a href="#sender">#</a></h4>
<pre><code><span>let</span> value <span>=</span> <span>Foo</span> <span>{</span> <span>...</span> <span>}</span><span>;</span></code></pre>
</div>
<div>
<h4 id="receiver">Receiver <a href="#receiver">#</a></h4>
<pre><code><span>let</span> value <span>=</span> channel_rx<span>.</span><span>recv</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span></code></pre>
</div>
</div>
<p>As with <code>thread::spawn()</code>, we can&#39;t use channels to unsafely
send references from one thread to another, though the mechanisms Rust
uses to prevent this are somewhat more complicated, and
I&#39;m not going to go into them here.
With that said, here&#39;s an example of the obvious thing that you
might try to do and the compiler will reject:</p>
<pre><code><span>use</span> <span>std<span>::</span>sync<span>::</span>mpsc<span>::</span></span>channel<span>;</span></code></pre>
<h3 id="cross-thread-sharing">Cross-Thread Sharing <a href="#cross-thread-sharing">#</a></h3>
<p>Obviously, there are situations when you <em>do</em> want to share data
across threads, and just as Rust provides a mechanism (<code>RefCell</code>)
for controlled mutation of data shared through immutable references,
it similarly has a set of mechanisms for controlled sharing
of writable data. A full description of how to do this is outside
of the scope of this already long post, but here is a trivial example.</p>
<pre><code><span>use</span> <span>std<span>::</span>sync<span>::</span></span><span>{</span><span>Arc</span><span>,</span> <span>Mutex</span><span>}</span><span>;</span></code></pre>
<p>The basic idea here is that we first wrap our shared data in a
<code>Mutex</code>, which allows one reference (either readable or writable)
at once at a time. You obtain the reference by calling <code>.lock()</code>,
and if someone else has it your thread will wait until they
have unlocked it.
A reference to a <code>Mutex</code> can&#39;t be shared across threads directly any more
than any other variable can, but we <em>can</em> wrap it in a reference
counted structure, in this case <code>Arc</code> (the thread safe version
of <code>Rc</code>) and move that across threads. The logic here is:</p>
<ul>
<li>We have two copies of <code>Arc</code>, one in each thread, but both
pointing to the same <code>Mutex</code>.</li>
<li>Each thread uses <code>.lock()</code> to access the data inside the
<code>Mutex</code>.</li>
</ul>
<p>This allows us to share the data across the threads but guarantees
that only one thread at a time can use it. The call to <code>.join()</code> in the main thread is just waiting for
the other thread to finish to guarantee we have a chance to print both values.</p>
<p>There&#39;s a lot more to say about multithreaded programming in Rust,
but I&#39;m not trying to teach you how to write parallel programs
in Rust; instead I want to make two points here:</p>
<ul>
<li>
<p>Writing memory safe and thread safe programs depends on the
same basic concepts, namely ensuring single ownership,
guaranteed lifetimes, and
preventing simultaneous writing and reading, whether that
simultaneity is a result of concurrency or not.</p>
</li>
<li>
<p>The mechanisms that Rust uses to provide thread safety are
much the same basic mechanisms as those which are used to
provide memory safety and similarly are based on clear
contracts between components plus local analysis for safety.</p>
</li>
</ul>
<p>As I said this isn&#39;t an accident, but rather a result of the
connection between memory safety and thread safety, which
logical errors related to unclear ownership, and the
results of trying to
touch the same data in inconsistent ways in multiple places.</p>
<h2 id="next-up%3A-garbage-collection">Next Up: Garbage Collection <a href="#next-up%3A-garbage-collection">#</a></h2>
<p>There&#39;s plenty more to say about Rust memory management and in
particular about how to write manageable code that conforms to
Rust&#39;s rules—as well as how to break those rules
using <code>unsafe</code> when you have to—but hopefully this gives you
an overall sense of how things are put together. In the next
post, I want to talk about a completely different approach
to memory, namely automatic memory management with garbage
collection, as used in languages ranging from Lisp to Go to
JavaScript.</p>



    </article>

    
      
  </div>
  
</div>

<!-- Cloudflare Web Analytics --><!-- End Cloudflare Web Analytics -->


          </main>
        </div></div>
  </body>
</html>
