<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/raphamorim/goiaba">Original</a>
    <h1>Goiaba: An experimental Go compiler, written in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">An experimental Go parser and WebAssembly compiler written in Rust. Goiaba translates Go source code into WebAssembly bytecode, enabling Go programs to run in web browsers and other WebAssembly environments.</p>
<p dir="auto">Reasons why I am building it:</p>
<ul dir="auto">
<li>Create a complete bindgen support for JavaScript (web/nodejs/bun/deno)</li>
<li>Study of <a href="https://go.googlesource.com/gollvm/" rel="nofollow">gollvm</a> project</li>
<li>It will be used by a code editor I am writing in Rust called <a href="https://raphamorim.io/building-boo-code-editor-1/" rel="nofollow">Boo</a></li>
<li>Well, mostly learn tbh</li>
</ul>

<ul dir="auto">
<li>Parse Go source code into an Abstract Syntax Tree (AST)</li>
<li>Compile Go functions to WebAssembly modules</li>
<li>Support for fundamental Go language features (functions, control flow, arithmetic)</li>
<li>Export Go functions for use in JavaScript/WebAssembly environments</li>
<li>Export Go functions for use in Rust through C ABI</li>
<li>Export Go functions for use in Zig through C ABI</li>
<li>Command-line interface for compilation</li>
<li>Programmatic API for integration into Rust projects</li>
</ul>




<p dir="auto">Add to your <code>Cargo.toml</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
goiaba = &#34;*&#34;"><pre>[<span>dependencies</span>]
<span>goiaba</span> = <span><span>&#34;</span>*<span>&#34;</span></span></pre></div>


<p dir="auto">Basic compilation:</p>
<div dir="auto" data-snippet-clipboard-copy-content="goiaba main.go -o main.wasm"><pre>goiaba main.go -o main.wasm</pre></div>
<p dir="auto">Compile with verbose output:</p>
<div dir="auto" data-snippet-clipboard-copy-content="goiaba input.go --output output.wasm --verbose"><pre>goiaba input.go --output output.wasm --verbose</pre></div>
<p dir="auto">Generate a complete web project with HTML and JavaScript:</p>
<div dir="auto" data-snippet-clipboard-copy-content="goiaba main.go -w ./web-project"><pre>goiaba main.go -w ./web-project</pre></div>
<p dir="auto">Advanced usage with multiple options:</p>
<div dir="auto" data-snippet-clipboard-copy-content="goiaba calculator.go -o calc.wasm -w ./demo --verbose"><pre>goiaba calculator.go -o calc.wasm -w ./demo --verbose</pre></div>


<div dir="auto" data-snippet-clipboard-copy-content="use goiaba::wasm::compiler::compile_str;

fn main() {
    let go_source = r#&#34;
        package main

        //export add
        func add(x int, y int) int {
            return x + y
        }
    &#34;#;

    let wasm_bytes = compile_str(go_source)
        .expect(&#34;Failed to compile Go to WASM&#34;);

    // Write to file or use with a WASM runtime
    std::fs::write(&#34;output.wasm&#34;, wasm_bytes)
        .expect(&#34;Failed to write WASM file&#34;);
}"><pre><span>use</span> goiaba<span>::</span>wasm<span>::</span>compiler<span>::</span>compile_str<span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> go_source = <span>r#&#34;</span>
<span>        package main</span>
<span></span>
<span>        //export add</span>
<span>        func add(x int, y int) int {</span>
<span>            return x + y</span>
<span>        }</span>
<span>    &#34;#</span><span>;</span>

    <span>let</span> wasm_bytes = <span>compile_str</span><span>(</span>go_source<span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to compile Go to WASM&#34;</span><span>)</span><span>;</span>

    <span>// Write to file or use with a WASM runtime</span>
    std<span>::</span>fs<span>::</span><span>write</span><span>(</span><span>&#34;output.wasm&#34;</span><span>,</span> wasm_bytes<span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to write WASM file&#34;</span><span>)</span><span>;</span>
<span>}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="use goiaba::wasm::compiler::compile_str;
use wasmtime::{Engine, Instance, Module, Store};

fn main() {
    let go_source = r#&#34;
        package main
        
        //export add
        func add(x int, y int) int {
            return x + y
        }
    &#34;#;

    let wasm_bytes = compile_str(go_source)
        .expect(&#34;Failed to compile Go to WASM&#34;);

    // Create a WASM runtime
    let engine = Engine::default();
    let module = Module::from_binary(&amp;engine, &amp;wasm_bytes)
        .expect(&#34;Failed to load WASM module&#34;);
    let mut store = Store::new(&amp;engine, ());

    // Instantiate the module
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[])
        .expect(&#34;Failed to instantiate module&#34;);

    // Get the exported function
    let add_func = instance
        .get_typed_func::&lt;(i32, i32), i32&gt;(&amp;mut store, &#34;add&#34;)
        .expect(&#34;Failed to get &#39;add&#39; function&#34;);

    // Call the function
    let result = add_func
        .call(&amp;mut store, (5, 3))
        .expect(&#34;Failed to call &#39;add&#39; function&#34;);

    assert_eq!(result, 8);
}"><pre><span>use</span> goiaba<span>::</span>wasm<span>::</span>compiler<span>::</span>compile_str<span>;</span>
<span>use</span> wasmtime<span>::</span><span>{</span><span>Engine</span><span>,</span> <span>Instance</span><span>,</span> <span>Module</span><span>,</span> <span>Store</span><span>}</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> go_source = <span>r#&#34;</span>
<span>        package main</span>
<span>        </span>
<span>        //export add</span>
<span>        func add(x int, y int) int {</span>
<span>            return x + y</span>
<span>        }</span>
<span>    &#34;#</span><span>;</span>

    <span>let</span> wasm_bytes = <span>compile_str</span><span>(</span>go_source<span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to compile Go to WASM&#34;</span><span>)</span><span>;</span>

    <span>// Create a WASM runtime</span>
    <span>let</span> engine = <span>Engine</span><span>::</span><span>default</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> module = <span>Module</span><span>::</span><span>from_binary</span><span>(</span><span>&amp;</span>engine<span>,</span> <span>&amp;</span>wasm_bytes<span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to load WASM module&#34;</span><span>)</span><span>;</span>
    <span>let</span> <span>mut</span> store = <span>Store</span><span>::</span><span>new</span><span>(</span><span>&amp;</span>engine<span>,</span> <span>(</span><span>)</span><span>)</span><span>;</span>

    <span>// Instantiate the module</span>
    <span>let</span> instance = <span>Instance</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> store<span>,</span> <span>&amp;</span>module<span>,</span> <span>&amp;</span><span>[</span><span>]</span><span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to instantiate module&#34;</span><span>)</span><span>;</span>

    <span>// Get the exported function</span>
    <span>let</span> add_func = instance
        <span>.</span><span>get_typed_func</span><span>::</span><span>&lt;</span><span>(</span><span>i32</span><span>,</span> <span>i32</span><span>)</span><span>,</span> <span>i32</span><span>&gt;</span><span>(</span><span>&amp;</span><span>mut</span> store<span>,</span> <span>&#34;add&#34;</span><span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to get &#39;add&#39; function&#34;</span><span>)</span><span>;</span>

    <span>// Call the function</span>
    <span>let</span> result = add_func
        <span>.</span><span>call</span><span>(</span><span>&amp;</span><span>mut</span> store<span>,</span> <span>(</span><span>5</span><span>,</span> <span>3</span><span>)</span><span>)</span>
        <span>.</span><span>expect</span><span>(</span><span>&#34;Failed to call &#39;add&#39; function&#34;</span><span>)</span><span>;</span>

    <span>assert_eq</span><span>!</span><span>(</span>result<span>,</span> <span>8</span><span>)</span><span>;</span>
<span>}</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="use goiaba::parser::parse_str;

fn main() {
    let source = r#&#34;
        package main

        func fibonacci(n int) int {
            if n &lt;= 1 {
                return n
            }
            return fibonacci(n-1) + fibonacci(n-2)
        }
    &#34;#;

    match parse_str(source) {
        Ok((objects, file)) =&gt; {
            println!(&#34;Successfully parsed Go source code&#34;);
            // Access AST nodes through objects and file
        }
        Err(err) =&gt; {
            eprintln!(&#34;Parse error: {}&#34;, err);
        }
    }
}"><pre><span>use</span> goiaba<span>::</span>parser<span>::</span>parse_str<span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> source = <span>r#&#34;</span>
<span>        package main</span>
<span></span>
<span>        func fibonacci(n int) int {</span>
<span>            if n &lt;= 1 {</span>
<span>                return n</span>
<span>            }</span>
<span>            return fibonacci(n-1) + fibonacci(n-2)</span>
<span>        }</span>
<span>    &#34;#</span><span>;</span>

    <span>match</span> <span>parse_str</span><span>(</span>source<span>)</span> <span>{</span>
        <span>Ok</span><span>(</span><span>(</span>objects<span>,</span> file<span>)</span><span>)</span> =&gt; <span>{</span>
            <span>println</span><span>!</span><span>(</span><span>&#34;Successfully parsed Go source code&#34;</span><span>)</span><span>;</span>
            <span>// Access AST nodes through objects and file</span>
        <span>}</span>
        <span>Err</span><span>(</span>err<span>)</span> =&gt; <span>{</span>
            <span>eprintln</span><span>!</span><span>(</span><span>&#34;Parse error: {}&#34;</span><span>,</span> err<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>


<ul dir="auto">
<li>Function definitions with parameters and return types</li>
<li>Integer arithmetic operations (+, -, *, /, %)</li>
<li>Comparison operations (&lt;, &gt;, &lt;=, &gt;=, ==, !=)</li>
<li>Bitwise operations (&amp;, |, ^, &lt;&lt;, &gt;&gt;)</li>
<li>Logical operations (&amp;&amp;, ||, !)</li>
<li>Variable declarations and assignments</li>
<li>If-else statements and nested conditionals</li>
<li>For loops with initialization, condition, and post statements</li>
<li>Recursive function calls</li>
<li>Function calls with multiple arguments</li>
<li>Increment and decrement operators (++, --)</li>
<li>Unary operators (-, !)</li>
<li>Struct types with field access and assignment</li>
<li>Composite literals for struct initialization</li>
</ul>

<ul dir="auto">
<li>Arrays and slices</li>
<li>String literals and operations</li>
<li>Switch statements</li>
<li>Pointer operations</li>
<li>Methods on types</li>
<li>Interfaces</li>
<li>Multiple return values</li>
<li>Defer statements</li>
<li>Panic and recover</li>
<li>Goroutines and channels</li>
<li>Package imports</li>
<li>Standard library support</li>
</ul>

<p dir="auto">To make Go functions callable from WebAssembly, use the <code>//export</code> directive:</p>
<div dir="auto" data-snippet-clipboard-copy-content="//export function_name
func function_name(param1 int, param2 int) int {
    return param1 + param2
}"><pre><span>//export function_name</span>
<span>func</span> <span>function_name</span>(<span>param1</span> <span>int</span>, <span>param2</span> <span>int</span>) <span>int</span> {
    <span>return</span> <span>param1</span> <span>+</span> <span>param2</span>
}</pre></div>
<p dir="auto">The exported name will be used in the WebAssembly module exports.</p>


<ul>
<li> Go source code parsing to Abstract Syntax Tree (AST)</li>
<li> Translation of Go constructs to WebAssembly representations</li>
<li> WebAssembly bytecode generation</li>
<li> Function definitions with parameter and return types</li>
<li> Variable declarations and assignments</li>
<li> Control flow statements (if/else, for loops)</li>
<li> Exportable WASM functions</li>
<li> Arithmetic operations (+, -, *, /, %)</li>
<li> Comparison operations (&lt;, &gt;, &lt;=, &gt;=, ==, !=)</li>
<li> Bitwise operations (&amp;, |, ^, &lt;&lt;, &gt;&gt;)</li>
<li> Logical operations (&amp;&amp;, ||, !)</li>
<li> Increment/decrement operators (++, --)</li>
<li> Recursive function calls</li>
<li> Struct types with field access and assignment</li>
<li> Command-line interface</li>
<li> Unary operators (negation, logical NOT)</li>
<li> Arrays and slices</li>
<li> String literals and operations</li>
<li> Switch statements</li>
</ul>

<ul>
<li> Pointer dereferencing and operations</li>
<li> Methods on types</li>
<li> Interfaces</li>
<li> Multiple return values</li>
<li> Defer statements</li>
<li> Panic and recover</li>
<li> Package imports</li>
<li> Standard library functions</li>
<li> Floating-point operations</li>
<li> Memory management optimizations</li>
</ul>

<ul>
<li> Goroutines and channels</li>
<li> Complete standard library support</li>
<li> Source maps for debugging</li>
<li> Optimization passes for generated WASM</li>
<li> JavaScript bindings generation (wasm-bindgen)</li>
<li> Rust code generation</li>
<li> Zig code generation</li>
<li> LLVM-IR target compilation</li>
</ul>

<p dir="auto">Goiaba consists of several key components:</p>
<ol dir="auto">
<li><strong>Parser</strong>: Lexical analysis and syntax parsing of Go source code</li>
<li><strong>AST</strong>: Internal representation of Go program structure</li>
<li><strong>Translator</strong>: Conversion from Go AST to WebAssembly IR</li>
<li><strong>Compiler</strong>: Generation of WebAssembly bytecode</li>
<li><strong>CLI</strong>: Command-line interface for user interaction</li>
</ol>
<div dir="auto"><h2 tabindex="-1" dir="auto">Performance Considerations</h2><a id="user-content-performance-considerations" aria-label="Permalink: Performance Considerations" href="#performance-considerations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The generated WebAssembly code prioritizes correctness over optimization. Future versions will include:</p>
<ul dir="auto">
<li>Dead code elimination</li>
<li>Constant folding</li>
<li>Register allocation improvements</li>
<li>Memory access optimization</li>
<li>Function inlining for small functions</li>
</ul>

<p dir="auto">Contributions are welcome. Please ensure all tests pass before submitting pull requests:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cargo test
cargo clippy
cargo fmt"><pre>cargo <span>test</span>
cargo clippy
cargo fmt</pre></div>

<p dir="auto">Run the test suite:</p>


<p dir="auto">Current limitations of the compiler, yet to be added:</p>
<ul dir="auto">
<li>No garbage collection (manual memory management)</li>
<li>Limited standard library support</li>
<li>No concurrency primitives (goroutines, channels)</li>
<li>Single file compilation only</li>
<li>No optimizer passes</li>
</ul>

<p dir="auto">BSD-3-Clause</p>
<p dir="auto">Copyright (c) 2024 Raphael Amorim</p>

<p dir="auto">This project builds upon concepts from the Go language specification and WebAssembly standards. Parser implementation is adapted from the Goscript project.</p>
</article></div></div>
  </body>
</html>
