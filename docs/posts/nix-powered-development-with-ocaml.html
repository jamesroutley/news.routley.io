<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dimitrije.website/posts/2023-03-04-nix-ocaml.html">Original</a>
    <h1>Nix-Powered Development with OCaml</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>Nix is one of those tools that look like they provide amazing value, but you
have to pay a hefty entry fee for it. I’ve had my eye on Nix ecosystem for some
time because I get pretty excited about reproducible builds (and declarative
host management, in case of NixOS). As with many new pieces of tech that I try
out, I strive to get <em>some</em> value for <em>some</em> learning effort as <em>quickly</em> as
possible. Thus I hopefully get to a state where I can decide if putting in
additional effort is justified for remaining value.</p>
<p>In my opinion, this sweet spot in case of Nix is setting up a consistent,
<strong>reproducible</strong> development environment. For any new project I start nowadays,
I use Nix to pin and pull in:</p>
<ol type="1">
<li>Toolchain: compiler/interpreter/REPL, what have you.</li>
<li>IDE and supporting tools: customized editor with plugins, formatters,
linters etc.</li>
<li>Project dependencies: language-specific libraries can usually be found in
<code>nixpkgs</code>, or can easily be added as new derivations.</li>
</ol>
<p>My setup was inspired by <a href="https://xeiaso.net/blog/how-i-start-nix-2020-03-08">this great blog
post</a> by Xe, which
demonstrates how Nix can be used to to setup (and build) new Rust projects. One
notable difference here is that I don’t use Nix to build artifacts (yet).<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>I recently started a new job at an OCaml shop, so, naturally, I’m going to be
using OCaml as an example here. I’ve also successfully used this setup for
other languages<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> as well, including Haskell, Java, Golang and Python.</p>
<blockquote>
<p><strong>N.B.</strong> I do not claim I fully grok Nix, nor that this is the idiomatic way
of doing stuff. The approach I use here would certainly raise some eyebrows
with Home Manager folks. It works for me, YMMV. I will not be going into
nitty-gritty details of how or why Nix works the way it does. More
knowledgable people than me have already covered that in
<a href="https://ianthehenry.com/posts/how-to-learn-nix/">more</a>
<a href="https://zero-to-nix.com/">than</a> a
<a href="https://github.com/nix-community/awesome-nix#learning">few</a> guides online.</p>
</blockquote>
<section id="prerequisites">

<p>You will need a working installation of Nix, the package manager. Instructions
are <a href="https://nixos.org/download">here</a>. In addition to Nix, I
also make use of <a href="https://github.com/nmattia/niv">niv</a> to pin <code>nixpkgs</code> and
other Nix sources<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>. To install <code>niv</code> through Nix and make it available in your
user environment, run:</p>

</section>
<section id="pinning-nixpkgs">

<p>I start with a fresh Git repo, and then I use <code>niv</code> to pin down <code>nixpkgs</code>:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>mkdir</span> repo <span>&amp;&amp;</span> <span>cd</span> repo</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>git</span> init</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>niv</span> init <span>&amp;&amp;</span> <span>niv</span> update nixpkgs <span>-b</span> 22.11</span></code></pre></div>
<p>What are <code>nixpkgs</code> anyway? <a href="https://github.com/NixOS/nixpkgs">nixpkgs</a> is a
collection of build formulas, called Nix derivations, that are used to
build<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> various packages. These packages can be anything, but are usually
binary artifacts – like libraries and executables. I guess you can think of
Nixpkgs in terms of a repository of software that can be “installed”, similar
to Debian sources lists or RPM package repositories.</p>
<p>There are two salient points concerning Nix that give it advantage over
standard package repos:</p>
<ol type="1">
<li>Every package built with Nix contains in its name a unique hash that depends
on <em>all</em> of its build-time dependencies, all the way down to specific
<code>glibc</code> version and all the way up to <code>configure</code> flags used to build that
package. In an ideal world, if you build <code>123deadbeef-x-1.0</code> on your
machine, and I build <code>123deadbeef-x-1.0</code> on my machine, these two packages
are absolutely identical. The real world is messy, so it’s not exactly like
that, but it’s pretty close.</li>
<li>Nix installs packages and all their dependencies to Nix store, an isolated
part of filesystem. These packages are not in your <code>PATH</code>, or
<code>LD_LIBRARY_PATH</code>, and they do not interfere with the rest of your system in
any way. In fact, many different versions of the same package can coexist
peacefully in Nix store.</li>
</ol>
<p>Nixpkgs gets major releases every 6 months, and this is reflected in the
version (Nix calls it channels): <code>nixpkgs-22.11</code> was released in November 2022.
There’s also <code>nixpkgs-unstable</code>, which regularly gets updates, doesn’t have a
fixed release schedule, and generally contains the most recent versions of
packages. It’s worth noting that stable Nixpkgs channels, such as <code>22.11</code>, do
get security patches after being released. Therefore, stable doesn’t mean
immutable.</p>
<p>Different channels contain different versions of packages. For example, version
of <code>bash</code> in <code>22.11</code> is pinned to <code>5.1-p16</code>, whereas <code>21.05</code> had slightly more
dated <code>bash-5.1-p4</code>. On the other hand, <code>nixpks-unstable</code> currently has
bleeding edge <code>bash-5.2-p15</code>. You can use
<a href="https://search.nixos.org">search.nixos.org</a> to check this, albeit only for
latest stable channel and <code>nixpkgs-unstable</code>. If you can’t find a package in
stable channels, try unstable, or even <code>master</code> branch – someone may have
added it. Alternatively, you can be a good open source citizen and write a Nix
derivation for the thing you need yourself, and submit a pull request.</p>
<p>Good thing about <code>niv</code> is that it doesn’t really care about channels. Instead,
it records commit hash of the tip of specified channel at time of <code>niv init</code>
execution. This guarantees that Nix will always use the same version of
Nixpkgs, regardless of which channel you reference<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Note that you can update
pinned commit hash to latest tip, or even change the channel you are pinning
with <code>niv update nixpkgs -b &lt;branch&gt;</code>.</p>
<p>All right, let’s get back to setting our project up. I will also add my
<a href="https://github.com/dimitrijer/nixfiles">nixfiles</a> to Nix sources, so I can
reference Nix expressions of custom setups of some of my favorite development
tools:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>niv</span> add dimitrijer/nixfiles <span>-b</span> main <span># niv will pin this to tip of main branch</span></span></code></pre></div>
<p>At this point, there are a few files in my project:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>.</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>└── nix</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    ├── sources.json</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    └── sources.nix</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>2 directories, 2 files</span></code></pre></div>
<p><code>niv</code> keeps source of truth in <code>sources.json</code>, which contains commit hashes and
SHA-256 checksums of all Nix sources. <code>sources.nix</code> is a Nix expressions that
is used to reference Nix derivations specified in Nix sources that were pinned
through <code>niv</code>.</p>
</section>
<section id="nix-shell">

<p>Next, I create <code>shell.nix</code> file. This Nix expression is evaluated when you invoke
<code>nix-shell</code> from your project’s root directory. <code>shell.nix</code> describes your
development environment by listing all your tools and dependencies. I’ll start
out small, and add things along the way as I need them:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>let</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span>sources</span> <span>=</span> <span>import</span> <span>./nix/sources.nix</span><span>;</span> <span># sources.nix was generated by niv</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span>pkgs</span> <span>=</span> <span>import</span> sources.nixpkgs <span>{</span> <span>};</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span>nixfiles</span> <span>=</span> <span>import</span> sources.nixfiles <span>{</span> <span>};</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span>neovim</span> <span>=</span> nixfiles.neovim <span>{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span>pkgs</span> <span>=</span> pkgs<span>;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span>withOCaml</span> <span>=</span> <span>true</span><span>;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span>withWriting</span> <span>=</span> <span>true</span><span>;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span>};</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span>in</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>pkgs.mkShell</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span># nix-shell evaluates shellHooks at start</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span>shellHooks</span> <span>=</span> <span>&#39;&#39;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span>    alias vim=&#39;nvim&#39; </span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span>  &#39;&#39;</span><span>;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span># all packages in development environment are listed here</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span>buildInputs</span> <span>=</span> <span>[</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    pkgs.bash</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>  <span>];</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>If the syntax looks weird, don’t worry about it – I will point out
important bits and pieces. This is also the only Nix file we’re going to be
looking at, and the only changes to this file will be adding more packages.
That’s it.</p>
<p><code>let</code> part contains some prep work and establishes bindings that will be used
below. I first import auto-generated <code>sources.nix</code> file, and then I reference
two Nix sources that I added through <code>niv</code>: <code>nixpkgs</code> and <code>nixfiles</code>. Remember,
both of these are already pinned down. Next, I invoke a Nix function from
<code>nixfiles</code> that builds my customized Neovim derivation.</p>
<p>Now, the important part: I invoke <code>pkgs.mkShell</code> function, which sets up the
development shell. This function is defined in <code>nixpkgs</code>. I provide two
arguments to this function: <code>shellHooks</code> is a shell expression that is
evaluated when <code>nix-shell</code> runs, and <code>buildInputs</code> lists all packages that Nix
should provide in our development shell. For starters, I just need <code>bash</code>. I
will add in custom <code>neovim</code> that I defined above later on.</p>
<p>Let’s try it out by running <code>nix-shell --pure</code>:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>these 38 paths will be fetched (66.44 MiB download, 303.90 MiB unpacked):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  /nix/store/026hln0aq1hyshaxsdvhg0kmcm6yf45r-zlib-1.2.13</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  /nix/store/039g378vc3pc3dvi9dzdlrd0i4q93qwf-binutils-2.39</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  /nix/store/1d6ian3r8kdzspw8hacjhl3xkp40g1lj-binutils-wrapper-2.39</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  /nix/store/1dgws25664p544znpc6f1nh9xmjf4ykc-pcre-8.45</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  /nix/store/1gf2flfqnpqbr1b4p4qz2f72y42bs56r-gcc-11.3.0</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  /nix/store/34xlpp3j3vy7ksn09zh44f1c04w77khf-libunistring-1.0</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  /nix/store/38db4p333ibll7r1v151yc5f6ms1fr00-bash-interactive-5.2-p15</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  (... omitted for brevity ...)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/38db4p333ibll7r1v151yc5f6ms1fr00-bash-interactive-5.2-p15&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/34xlpp3j3vy7ksn09zh44f1c04w77khf-libunistring-1.0&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/i38jcxrwa4fxk2b7acxircpi399kyixw-linux-headers-6.0&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/5mh5019jigj0k14rdnjam1xwk5avn1id-libidn2-2.3.2&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/4nlgxhb09sdr51nc9hdm8az5b08vzkgx-glibc-2.35-163&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/cr5fmwri3601s7724ayjvckhsg6cz4rv-attr-2.5.1&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>copying path &#39;/nix/store/dsd5gz46hdbdk2rfdimqddhq6m8m8fqs-bash-5.1-p16&#39; from &#39;https://cache.nixos.org&#39;...</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  (... omitted for brevity ...)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>[nix-shell:/home/dimitrije/git/repo]$ echo $PATH | tr &#39;:&#39; &#39;\n&#39;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>/nix/store/38db4p333ibll7r1v151yc5f6ms1fr00-bash-interactive-5.2-p15/bin</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>/nix/store/pr5n59mb4jzmfx6kanwxly0l07p861fg-patchelf-0.15.0/bin</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>/nix/store/dq0xwmsk1g0i2ayg6pb7y87na2knzylh-gcc-wrapper-11.3.0/bin</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>/nix/store/1gf2flfqnpqbr1b4p4qz2f72y42bs56r-gcc-11.3.0/bin</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>/nix/store/57xv61c5zi8pphjbcwxxjlgc34p61ic9-glibc-2.35-163-bin/bin</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>/nix/store/a7gvj343m05j2s32xcnwr35v31ynlypr-coreutils-9.1/bin</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>/nix/store/1d6ian3r8kdzspw8hacjhl3xkp40g1lj-binutils-wrapper-2.39/bin</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>/nix/store/039g378vc3pc3dvi9dzdlrd0i4q93qwf-binutils-2.39/bin</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>/nix/store/dsd5gz46hdbdk2rfdimqddhq6m8m8fqs-bash-5.1-p16/bin</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>/nix/store/a7gvj343m05j2s32xcnwr35v31ynlypr-coreutils-9.1/bin</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>/nix/store/mydc6f4k2z73xlcz7ilif3v2lcaiqvza-findutils-4.9.0/bin</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>/nix/store/j9p3g8472iijd50vhdprx0nmk2fqn5gv-diffutils-3.8/bin</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>/nix/store/89zs7rms6x00xfq4dq6m7mjnhkr8a6r4-gnused-4.8/bin</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>/nix/store/86bp03jkmsl6f92w0yzg4s59g5mhxwmy-gnugrep-3.7/bin</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>/nix/store/hwcdqw4jrjnd37wxqgsd47hd0j8bnj09-gawk-5.1.1/bin</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>/nix/store/cfbhw8r8ags41vwqaz47r583d0p4h4a1-gnutar-1.34/bin</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>/nix/store/p3m1ndl1lapwrlh698bnb5lvvxh67378-gzip-1.12/bin</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>/nix/store/a8mhcagrsly7c7mpjrpsnaahk4aax056-bzip2-1.0.8-bin/bin</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>/nix/store/mblgz65m3zv9x548a3d5m96fj2pbwr09-gnumake-4.3/bin</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>/nix/store/dsd5gz46hdbdk2rfdimqddhq6m8m8fqs-bash-5.1-p16/bin</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>/nix/store/v7ljksji50mg3w61dykaa3n3y79n6nil-patch-2.7.6/bin</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>/nix/store/zlcnmqq14jz5x9439jf937mvayyl63da-xz-5.2.7-bin/bin</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>/nix/store/y6aj732zm9m87c82fpvf103a1xb22blp-file-5.43/bin</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>[nix-shell:/home/dimitrije/git/repo]$</span></code></pre></div>
<p>Nix first builds all specified packages and their dependencies. All of them are
fetched from Nix binary cache and copied to local Nix store. Then Nix drops me
in a brand new shell. <code>man nix-shell</code> can tell us what <code>--pure</code> does:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a> • --pure</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   If  this  flag is specified, the environment is almost entirely cleared before</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>   the interactive shell is started, so you get an environment that more closely</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>   corresponds to the “real” Nix build. A few variables, in particular HOME, USER</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>   and DISPLAY, are retained.</span></code></pre></div>
<p>Indeed, you can see that <code>PATH</code> does not list the usual binary paths like
<code>/usr/bin</code>, but only lists a few essential binaries that are provided in the
development environment, including <code>bash</code>. If you omit <code>--pure</code>, Nix will
modify <code>PATH</code> such that Nix binaries are first, but will not get rid of your
existing <code>PATH</code>. This is useful, but it means that you might inadvertently use
something that is outside of your development environment, so take heed.</p>
<p>You can get out of Nix shell with <code>^D</code>, or just type <code>exit</code>.</p>
<p>Let’s add <code>neovim</code> to <code>buildInputs</code>:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>diff --git a/shell.nix b/shell.nix</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>index 2a58852..7e47567 100644</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>--- a/shell.nix</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span>+++ b/shell.nix</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>@@ -18,5 +18,6 @@ pkgs.mkShell</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>   # lists all packages in development environment</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>   buildInputs = [</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>     pkgs.bash</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span>+    neovim</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>   ];</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>(Yes, getting new stuff in your development environment is as simple as adding
it to <code>buildInputs</code>). Running <code>nix-shell --pure</code> again pulls in more packages,
and drops me in a shell where I have my customized <code>nvim</code> available:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>[nix-shell:/home/dimitrije/git/repo]$ echo $PATH | tr &#39;:&#39; &#39;\n&#39; | grep neovim</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>/nix/store/31hxsrr6akz91nxaf4zzlgh6wwijqvd1-neovim-0.8.1/bin</span></code></pre></div>
<p>I could have simply specified <code>pkgs.neovim</code> instead of <code>neovim</code> to use Nixpkgs
derivation of Neovim, but my derivation contains plugins and other
customizations. Note that I didn’t have to install Neovim through package
manager, or otherwise mutate the state of my system to get it to run. The
binary is not even visible outside of Nix shell, and someone would have to
figure out its Nix store path in order to find it.</p>
<p>In general, you don’t really need to specify <code>bash</code> as build input. By default,
Nix will use <code>bash</code> from your global Nixpkgs, or system-wide <code>bash</code> if there’s
no Nixpkgs one. And there are ways to override your existing shell environment
with <code>nix-shell</code> environment <em>without</em> having to drop into a new shell. For
that, I suggest you check out Xe’s blog post above, specifically the part about
<code>lorri</code> and <code>direnv</code>.</p>
<p>Let’s wrap this part up:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>git</span> commit <span>-m</span> <span>&#34;Initial commit.&#34;</span></span></code></pre></div>
</section>
<section id="ocaml-project-setup">

<p>Now let’s add some OCaml-specific packages:</p>
<ul>
<li>First and foremost, I need <code>ocaml</code> package, which includes native OCaml
compiler <code>ocamlopt</code> and bytecode OCaml compiler <code>ocamlc</code>, among other things.</li>
<li>I’m going to be using <a href="https://github.com/ocaml/dune">Dune</a> as my build tool.
Dune can build stuff, setup project directory structure, run tests, generate
docs etc.</li>
<li><code>findlib</code> is necessary for Dune to be able to find libraries in Nix shell
environment.</li>
<li><code>ocaml</code> already includes eponymously named top-level (REPL) binary, but
<a href="https://github.com/ocaml-community/utop">utop</a> is pretty much ubiquitous
these days, and it’s much easier on the eye.</li>
<li><code>odoc</code> is documentation generator that plays nicely with Dune.</li>
<li>I will use <code>ocamlformat</code> to autoformat my OCaml sources.</li>
<li>Finally, I need LSP implementation for OCaml <code>ocaml-lsp</code>, so I can make
use of Neovim LSP-powered goodies.</li>
</ul>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>diff --git a/shell.nix b/shell.nix</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>index 7e47567..077ed4b 100644</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>--- a/shell.nix</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>+++ b/shell.nix</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>@@ -16,8 +16,13 @@ pkgs.mkShell</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>   &#39;&#39;;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>   # lists all packages in development environment</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span>-  buildInputs = [</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span>-    pkgs.bash</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span>-    neovim</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span>-  ];</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span>+  buildInputs = with pkgs; [</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span>+    bash</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.ocaml</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.dune_3</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.findlib</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.utop</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.odoc</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.ocaml-lsp</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span>+    ocamlformat</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span>+  ] ++ [ neovim ];</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>I used <code>with</code> keyword to reduce repetition a bit. As you can notice, sometimes
packages are not to be found in <code>nixpkgs</code> root, but are nested. I usually use
<a href="https://search.nixos.org">search.nixos.org</a> to figure out where to find
expression for specific package. If that’s not yielding any results, try
grepping the output of <code>nix-env -qaP</code>. At times I even had to fetch a local
clone of <code>nixpkgs</code> and grep sources. Not ideal, I know <code>¯\_(ツ)_/¯</code>.</p>
<p>Next thing I need to do is to setup a standard OCaml project directory
structure with <code>dune</code> (from my development shell):</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span># Dune always creates a project directory, so I run it in parent directory, and</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span># pass in project dir as project name</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span>(</span><span>cd</span> .. <span>&amp;&amp;</span> <span>dune</span> init proj repo<span>)</span></span></code></pre></div>
<p>This will result in the following layout:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>.</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>├── bin</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>│   ├── dune</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>│   └── main.ml</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>├── dune-project</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>├── lib</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>│   └── dune</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>├── nix</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>│   ├── sources.json</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>│   └── sources.nix</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>├── repo.opam</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>├── shell.nix</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>└── test</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    ├── dune</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    └── repo.ml</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>5 directories, 10 files</span></code></pre></div>
<p>Stating the obvious here: source for binaries should end up in <code>bin</code>, libraries
are in <code>lib</code> and tests should be in <code>test</code>, although <code>dune runtest</code> will also
trigger inline and expect tests added through PPX rewriters. Dune stores
outputs in <code>_build</code>, and it also automatically generates <code>repo.opam</code> based on
contents of <code>dune-project</code>.</p>
<p>I should be able to build and execute the main binary now:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>dune</span> exec <span>--display</span> quiet repo</span></code></pre></div>
<p>Which, unsurprisingly, yields:</p>

<p>Next, I add <code>_build</code> and <code>repo.opam</code> to <code>.gitignore</code>. In addition, you would
probably want to modify the generated <code>dune-project</code> file to specify project
description, author, homepage, license etc. Time for another commit:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>git</span> commit <span>-am</span> <span>&#34;Set up Dune project structure.&#34;</span></span></code></pre></div>
</section>
<section id="adding-ocaml-libraries">

<p>Many languages have tools that handle installation and management of multiple
toolchains, and/or different versions of libraries on a single system in order
to avoid what’s colloquially known as “dependency hell”. Haskell has
<a href="https://docs.haskellstack.org/en/stable/">Stack</a>, OCaml has
<a href="https://opam.ocaml.org/">opam</a>, Python has
<a href="https://github.com/pyenv/pyenv">pyenv</a> etc. One of the best things about Nix
is that it solves this problem for any language. When we talked about pinning
above, I mentioned that pinning Nixpkgs effectively nails down versions of
<em>all</em> packages in Nixpkgs. In other words, <strong>all OCaml libraries are already
pinned</strong> to predefined versions, along with their dependencies. This is also
true for OCaml compiler – running <code>ocamlc --version</code> gives me <code>4.14.0</code>, and
this will be the same for anyone who recreates this development environment.
Furthermore, this environment is local to this directory/project, meaning I can
easily move between different projects that use different versions of OCaml
compiler, libraries, tools etc. on the same system.</p>
<p>There is one nasty side to this global pinning mechanism: you need to use Nix
overlays or other weird tricks if you want to use a different version of a
library than what’s available in pinned Nixpkgs. The easiest thing for me
oftentimes is to simply roll Nixpkgs forward to newer channel, or even
<code>nixpkgs-unstable</code>, assuming it has the version I need. This is far from ideal,
given that changing pinned Nixpkgs effectively changes <em>all</em> versions of <em>all</em>
packages at once.</p>
<p>Anyway, let’s get back to my barebones OCaml project. For purpose of using
external libraries, I stole the idea of a simple TCP echo server powered by
<a href="https://opensource.janestreet.com/async/">Async</a> library from <a href="https://dev.realworldocaml.org">Real World OCaml</a>:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>open</span> <span>Core</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>open</span> <span>Async</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span>let</span> command =</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span>let</span>%map_open.<span>Command</span> port =</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    flag <span>&#34;-port&#34;</span> (required <span>int</span>) ~doc:<span>&#34;port on which to listen&#34;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span>in</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span>fun</span> () -&gt;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span>Echo</span>.<span>Server</span>.create ~port (<span>fun</span> <span>input</span> -&gt;</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>      <span>match</span> <span>input</span> <span>with</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>      | `Ok <span>&#34;bye!&#34;</span> | `Eof -&gt; `Disconnect</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      | `Ok line -&gt; `Ok (<span>String</span>.uppercase line))</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    &gt;&gt;= <span>Echo</span>.<span>Server</span>.close_finished</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span>let</span> () =</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  <span>Command</span>.async ~summary:<span>&#34;A simple echo server that shouts back at you.&#34;</span> command</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  |&gt; <span>Command_unix</span>.run</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>;;</span></code></pre></div>
<p>The rest of the code is on <a href="https://github.com/dimitrijer/echo">Github</a>. I use
local <code>Echo</code> library within the same project, but I also refer to <code>Core</code>,
<code>Async</code> and <code>Command_unix</code> in this code. In addition, I use some PPX rewriters
to write monadic code more concisely. If I were to try and build this right
now, Dune would complain about missing libraries. So what do we do about it?
Add missing libraries to <code>shell.nix</code>, of course:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>diff --git a/shell.nix b/shell.nix</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>index b3a940a..d797380 100644</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>--- a/shell.nix</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span>+++ b/shell.nix</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span>@@ -26,5 +26,10 @@ pkgs.mkShell</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>     ocamlPackages.odoc</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>     ocamlPackages.ocaml-lsp</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>     ocamlformat</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span>+</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.janeStreet.base</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.janeStreet.async</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.janeStreet.core_unix</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span>+    ocamlPackages.janeStreet.ppx_let</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>   ] ++ [ neovim ];</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>Note that names of libraries that need to be added in <code>dune</code> files are
sometimes different than this, or are more granular (e.g.
<code>core_unix.command_unix</code>). You can list all OCaml libraries available to Dune
in your development environment with <code>ocamlfind list</code>.</p>
<p>Now Dune will happily build and start the server:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>dune</span> exec echo <span>--</span> <span>-port</span> 12345</span></code></pre></div>
<p>Feel free to fire up a couple of instances of netcat so the server can holler
back at you simultaneously.</p>
</section>


    </section></div>
  </body>
</html>
