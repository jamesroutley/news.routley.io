<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.asktherelic.com/2024/07/15/connecting-apps-with-the-tailscale-kubernetes-operator-part-2/?utm_source=RSS_Feed&amp;utm_medium=RSS&amp;utm_campaign=RSS_Syndication">Original</a>
    <h1>Connecting Apps with the Tailscale Kubernetes Operator - Part 2</h1>
    
    <div id="readability-page-1" class="page"><div id="main_block"> <div id="prose_block"> <h2><a name="connecting-apps-with-the-tailscale-kubernetes-operator-part-2"></a><a href="https://www.rte.ie/2024/07/15/connecting-apps-with-the-tailscale-kubernetes-operator-part-2/">Connecting Apps with the Tailscale Kubernetes Operator - Part 2</a></h2> <p><small>July 15, 2024 at 01:00 PM</small> <span> <p>In <a href="https://www.rte.ie/2024/02/23/exploring-the-tailscale-kubernetes-operator-part1/">Part 1</a>, I explored installing the Tailscale (TS) K8S operator and adding an Ingress object to make a K8S Service available to the TS network over HTTP.</p> <p>In this post, I want to cover different Egress and Ingress options and ways to connect apps on the TS network.</p> <p>For more context, while I’ve been experimenting with kind and a virtual Kubernetes (K8S) cluster, I run a personal server running at home with plenty of resources and a virtual server that hosts my public web apps. Being able to connect the two servers over TS is one of my goals. It allows me to do more permanent and resource intensive things on my personal server, but also make them available publicly when I want.</p> <p>For example: <span> <img src="https://www.rte.ie/pic/2024-07-15-networks.png" alt=""/> </span></p> <p><strong>Caveat: Under Active Development</strong></p> <p>The TS K8S Operator is under active development and some of these capabilities were add in <a href="https://tailscale.com/changelog#2024-05-15">v1.66</a>. Make sure you are running the latest version. </p> <p>There is even a Helm chart now for easier updating - <a href="https://tailscale.com/kb/1236/kubernetes-operator#helm">https://tailscale.com/kb/1236/kubernetes-operator#helm</a></p> <h3>Exposing TS Apps to your Cluster</h3> <p>To expose existing TS Apps to your K8S cluster, you can use the ExternalName Service, which creates an TS Pod to proxy traffic.</p> <p>For example, to expose the Home Server to K8S, you could create this Service:</p> <div><pre><code><span>---</span>
<span>apiVersion</span><span>:</span> <span>v1</span>
<span>kind</span><span>:</span> <span>Service</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>home-server</span>
  <span>annotations</span><span>:</span>
    <span>tailscale.com/tailnet-ip</span><span>:</span> <span>&#34;</span><span>100.X.X.1&#34;</span>
<span>spec</span><span>:</span>
  <span>externalName</span><span>:</span> <span>placeholder</span>
  <span>type</span><span>:</span> <span>ExternalName</span>
</code></pre></div> <p>Then you would get a K8S Service and could curl <code>ts-home-server-lmc8s.tailscale.svc.cluster.local</code> within your cluster:</p> <div><pre><code><span>$ </span>kubectl get service tower
NAME          TYPE           CLUSTER-IP  EXTERN   
home-server   ExternalName   &lt;none&gt;      ts-home-server-lmc8s.tailscale.svc.cluster.local
</code></pre></div> <h3>Now with TS DNS names</h3> <p>Now with v1.66 of the Operator, using full TS domain names are supported instead of TS IPs, by running a TS managed DNS server. <a href="https://tailscale.com/kb/1236/kubernetes-operator#exposing-a-tailnet-service-to-your-kubernetes-cluster-cluster-egress">Official docs here</a>.</p> <p>First, add the DNS component:</p> <div><pre><code><span>---</span>
<span>apiVersion</span><span>:</span> <span>tailscale.com/v1alpha1</span>
<span>kind</span><span>:</span> <span>DNSConfig</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>ts-dns</span>
<span>spec</span><span>:</span>
  <span>nameserver</span><span>:</span>
    <span>image</span><span>:</span>
      <span>repo</span><span>:</span> <span>tailscale/k8s-nameserver</span>
      <span>tag</span><span>:</span> <span>unstable</span>
</code></pre></div> <p>Then get the Pod IP and add it to your Cluster DNS config. In my K8S setup, I use coredns.</p> <div><pre><code><span>$ </span>kubectl get dnsconfig ts-dns <span>-o</span> json | jq .status.nameserver.ip <span>-r</span>
10.43.239.128

<span>$ </span>kubectl edit configmaps <span>-n</span> kube-system coredns
...
ts.net <span>{</span>
    errors
    cache 30
    forward <span>.</span> 10.43.239.128
<span>}</span>
...

<span>$ </span>kubectl rollout restart <span>-n</span> kube-system deployment coredns
</code></pre></div> <p>Now you can create your Service with a FQDN. And another new feature recently added is the <code>tailscale.com/hostname</code> annotation, that allows you to name the TS Proxy instead of using a random prefix, to keep things more organized on the TS side.</p> <div><pre><code><span>---</span>
<span>apiVersion</span><span>:</span> <span>v1</span>
<span>kind</span><span>:</span> <span>Service</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>homeserver-fqdn</span>
  <span>annotations</span><span>:</span>
    <span>tailscale.com/tailnet-fqdn</span><span>:</span> <span>&#34;</span><span>homeserver.bee-haka.ts.net&#34;</span>
    <span>tailscale.com/hostname</span><span>:</span> <span>&#34;</span><span>homeserver-fqdn&#34;</span>
<span>spec</span><span>:</span>
  <span>externalName</span><span>:</span> <span>placeholder</span>
  <span>type</span><span>:</span> <span>ExternalName</span>
</code></pre></div> <h3>Creating a TS Proxy with Subnet Routes</h3> <p>Another TS feature is subnet routing; sharing entire CIDR routes to TS. </p> <p>In my example, even though I have my Home Server directly shared on TS, I can also get to it via the Apple TV that is sharing the <code>192.168.1.X/24</code> route. <a href="https://www.youtube.com/watch?v=hYd5etBpsO0">Apple TV subnet routing release here</a>.</p> <p>To create a TS Proxy with subnet routings, one of the other new objects is a ProxyClass, for configuring the TS Proxy:</p> <div><pre><code><span>---</span>
<span>apiVersion</span><span>:</span> <span>tailscale.com/v1alpha1</span>
<span>kind</span><span>:</span> <span>ProxyClass</span>
<span>metadata</span><span>:</span>
    <span>name</span><span>:</span> <span>acceptroutes</span>
<span>spec</span><span>:</span>
    <span>tailscale</span><span>:</span>
        <span>acceptRoutes</span><span>:</span> <span>true</span>
<span>---</span>
<span>apiVersion</span><span>:</span> <span>v1</span>
<span>kind</span><span>:</span> <span>Service</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>home-server-via-apple-tv</span>
  <span>labels</span><span>:</span>
    <span>tailscale.com/proxy-class</span><span>:</span> <span>acceptroutes</span>
  <span>annotations</span><span>:</span>
    <span>tailscale.com/tailnet-ip</span><span>:</span> <span>&#34;</span><span>192.168.1.1&#34;</span>
<span>spec</span><span>:</span>
  <span>externalName</span><span>:</span> <span>placeholder</span>
  <span>type</span><span>:</span> <span>ExternalName</span>
</code></pre></div> <h3>Expose HTTPS services with TS SSL</h3> <p>Lastly, you can also expose TS Apps with FQDNs and automatically generated LetsEncrypt certs. I believe you could generate and download the certs manually before, this is another convenient primitive for apps that need to know their address.</p> <p>For example, given an existing “registry” Service, you can expose it with an Ingress and tls params.</p> <div><pre><code><span>---</span>
<span>apiVersion</span><span>:</span> <span>networking.k8s.io/v1</span>
<span>kind</span><span>:</span> <span>Ingress</span>
<span>metadata</span><span>:</span>
  <span>name</span><span>:</span> <span>registry</span>
<span>spec</span><span>:</span>
  <span>defaultBackend</span><span>:</span>
    <span>service</span><span>:</span>
      <span>name</span><span>:</span> <span>registry</span>
      <span>port</span><span>:</span>
        <span>number</span><span>:</span> <span>80</span>
  <span>ingressClassName</span><span>:</span> <span>tailscale</span>
  <span>tls</span><span>:</span>
    <span>-</span> <span>hosts</span><span>:</span>
        <span>-</span> <span>registry</span>
</code></pre></div><div><pre><code><span>$ </span>kubectl get ingress
NAME       CLASS       HOSTS   ADDRESS                                 PORTS     AGE
nginx      tailscale   <span>*</span>       default-nginx-ingress.bee-hake.ts.net   80        3d3h
registry   tailscale   <span>*</span>       registry.bee-hake.ts.net                80, 443   3d2h
</code></pre></div> <p>So this is the Docker Registry service that I’m running, so I can build Docker Images on my Home Server and then use them in K8S. It’s more convenient than other ways to push a Docker Image to a central shared point on TS.</p> <p>Overall, these are useful primitives for bi-directional sharing between the TS network and K8S. The TS Operator has made it easier to connect my apps together securely and I’ll continue to watch for new capabilties!</p> </span> </p></div> </div></div>
  </body>
</html>
