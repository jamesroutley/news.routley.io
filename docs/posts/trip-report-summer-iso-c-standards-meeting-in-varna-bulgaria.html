<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://herbsutter.com/2023/06/16/trip-report-summer-iso-c-standards-meeting-varna-bulgaria/">Original</a>
    <h1>Trip report: Summer ISO C&#43;&#43; standards meeting in Varna, Bulgaria</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Minutes ago, the ISO C++ committee finished its meeting in-person in Varna, Bulgaria and online via Zoom, where we formally began adopting features into C++26.</p>



<p>Our hosts, VMware and Chaos, arranged for high-quality facilities for our six-day meeting from Monday through Saturday. We had nearly 180 attendees, about two-thirds in-person and the others remote via Zoom, formally representing 20 nations. Also, at each meeting we regularly have new attendees who have never attended before, and this time there were 17 new first-time attendees, mostly in-person; to all of them, once again welcome!</p>



<p><a href="https://isocpp.org/std/the-committee">The committee</a> currently has 23 active subgroups, most of which met in parallel tracks throughout the week. Some groups ran all week, and others ran for a few days or a part of a day and/or evening, depending on their workloads. You can find a brief summary of ISO procedures <a href="https://isocpp.org/std/iso-iec-jtc1-procedures">here</a>.</p>



<h2><a>This week’s meeting: Starting C++26</a></h2>



<p>ISO C++ is on a three-year development cycle, which includes a “feature freeze” about one year before we ship and publish that edition of the standard. For example, the feature freeze for C++23 was in early 2022.</p>


<div>
<figure><a href="https://herbsutter.files.wordpress.com/2023/06/image.png"><img loading="lazy" data-attachment-id="4744" data-permalink="https://herbsutter.com/2023/06/16/trip-report-summer-iso-c-standards-meeting-varna-bulgaria/image-10/" data-orig-file="https://herbsutter.files.wordpress.com/2023/06/image.png" data-orig-size="3300,2420" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://herbsutter.files.wordpress.com/2023/06/image.png?w=300" data-large-file="https://herbsutter.files.wordpress.com/2023/06/image.png?w=1024" src="https://herbsutter.files.wordpress.com/2023/06/image.png?w=300" alt="" width="300" height="220" srcset="https://herbsutter.files.wordpress.com/2023/06/image.png?w=300 300w, https://herbsutter.files.wordpress.com/2023/06/image.png?w=600 600w, https://herbsutter.files.wordpress.com/2023/06/image.png?w=150 150w" sizes="(max-width: 300px) 100vw, 300px"/></a></figure></div>


<p>But this doesn’t mean we only have two years’ worth of development time in the cycle and the third year is bug fixes and red tape. Instead, the subgroups are a <a href="https://isocpp.org/files/img/wg21-structure-2022-12.png">three-stage pipeline</a> and continue concurrently working on new feature development all the time, and the feature freezes are just the checkpoints where we pause loading new features into <em>this particular</em> train. So for the past year, as the subgroups finished work on fit-and-finish for the C++23 features, they also increasingly worked on C++26 features.</p>



<p>That showed this week, as we adopted the first 40 proposed change papers for C++26, many of which had been ready for a couple of meetings and were just waiting for the C++26 train to open for loading to be adopted. Of those 40 change papers, two were “apply the resolutions for all Ready issues” papers that applied a bunch of generally-minor changes. The other 38 were individual changes, everything from bug fixes to new features like hazard pointers and RCU.</p>



<p>Here are some of the highlights…</p>



<h2>Adopted for C++26: Core language changes/features</h2>



<p>The core language adopted 11 papers, including the following. Taking them in paper number order, which is roughly the order in which work started on the paper…</p>



<p><a href="https://wg21.link/p2169">P2169 “A nice placeholder with no name”</a> by<strong> Corentin Jabot and Michael Park</strong> officially adds support for the <code>_</code> wildcard in C++26. Thanks to the authors for all their research and evidence for how it could be done in a backward-compatible way! Here are some examples that will now be legal as compilers start to support draft-C++26 syntax:</p>



<p><code>std::lock_guard _(mutex);</code></p>



<p><code>auto [x, y, _] = f();</code></p>



<p><code>inspect(foo) { _ =&gt; bar; };</code></p>



<blockquote>
<p>Some compiler needs to implement <code>-Wunderbar</code>.</p>
</blockquote>



<p>The palindromic <a href="https://wg21.link/p2552">P2552 “On the ignorability of standard attributes”</a> by<strong> Timur Doumler</strong> sets forth the Three Laws of Robotics… er, I mean, the Three Rules of Ignorability for standard attributes. The Three Rules are a language design guideline for all current and future standard attributes going forward… see the paper for the full rules, but my informal summary is:</p>



<ul>
<li>[Already in C++23] Rule 1. Standard attributes must be parseable (i.e., can’t just contain random nonsense).</li>
</ul>



<ul>
<li>[Already in C++23] Rule 2. Removing a standard attribute can’t change the program’s meaning: It can reduce the program’s possible legal behaviors, but it can’t invent new behaviors.</li>
</ul>



<ul>
<li>[New] Rule 3. Feature test macros shouldn’t pretend to support an attribute unless the implementation actually implements the attribute’s optional semantics (i.e., doesn’t just parse it but then ignore it).</li>
</ul>



<p><a href="https://wg21.link/p2558">P2558 “Add <code>@</code>, <code>%</code>, and <code>`</code> to the basic character set”</a> by<strong> Steve Downey</strong> is not a paper whose name was redacted for cussing; it’s a language extension paper that follows in C’s footsteps, and allows these characters to be used in valid C++ programs, and possibly in future C++ language evolution.</p>



<p><a href="https://wg21.link/p2621">P2621 “UB? In my lexer?”</a> by<strong> Corentin Jabot</strong> removes the possibility that just tokenizing C++ code can be a source of undefined behavior in a C++ compiler itself. (Did you know it could be UB? Now it can’t.) Note however that this does not remove all possible UB during compilation; future papers may address more of those compile-time UB sources.</p>



<p><a href="https://wg21.link/p2738">P2738 “constexpr cast from void*: towards constexpr type-erasure”</a> by<strong> Corentin Jabot and David Ledger</strong> takes another step toward powerful compile-time libraries, including enabling <code>std::format</code> to potentially support <code>constexpr</code> compile-time string formatting. Speaking of which…</p>



<p><a href="https://wg21.link/p2741">P2741 “User-generated static_assert messages”</a> by <strong>Corentin Jabot</strong> lets compile-time <code>static_assert</code> accept stringlike messages that are not string literals. For example, the popular {fmt} library (but not yet <code>std::format</code>, but see above!) supports <code>constexpr</code> string formatting, and so this code would work in C++26:</p>



<p><code>static_assert(sizeof(S) == 1, fmt::format(&#34;Unexpected sizeof: expected 1, got {}&#34;, sizeof(S)));</code></p>



<p>Together with P2738, an implementation of <code>std::format</code> that uses both of the above features would now be able to used in a <code>static_assert</code>.</p>



<h2>Adopted for C++26: Standard library changes/features</h2>



<p>The standard library adopted 28 papers, including the following. Starting again with the lowest paper number…</p>



<p>This first one gets the award for “being worked on the longest” (just look at the paper number, and the R revision number): <a href="https://wg21.link/p0792">P0792R14, “function_ref: A type-erased callable reference”</a> by<strong> Vittorio Romeo, Zhihao Yuan, and Jarrad Waterloo</strong> adds <code>function_ref&lt;R(Args...)&gt;</code> as a vocabulary type with reference semantics for passing callable entities to the standard library.</p>



<p><a href="https://wg21.link/p1383">P1383 “More constexpr for &lt;cmath&gt; and &lt;complex&gt;”</a> by<strong> Oliver J. Rosten</strong> adds <code>constexpr</code> to over 100 more standard library functions. The march toward making increasing swathes of the standard library usable at compile time continues… Jason Turner is out there somewhere saying “Moar Constexpr!” and “constexpr all the things!”</p>



<p>Then, still in paper number order, we get to the “Freestanding group”:</p>



<ul>
<li><a href="https://wg21.link/p2013">P2013 “Freestanding language: Optional ::operator new”</a> by<strong> Ben Craig</strong> makes <code>::operator new</code> optional in freestanding implementations.</li>



<li><a href="https://wg21.link/p2198">P2198 “Freestanding feature-test macros and implementation-defined extensions”</a> by<strong> Ben Craig</strong> lets programs targeting freestanding implementations detect which standard library facilities are available.</li>



<li><a href="https://wg21.link/p2338">P2338 “Freestanding library: Character primitives and the C library”</a> by<strong> Ben Craig</strong> adds to the freestanding C and C++ standard library all features that can be implemented without OS calls and space overhead, including <code>&lt;charconv&gt;</code> and <code>char_traits</code>.</li>
</ul>



<p><a href="https://wg21.link/p2510">P2510 “Formatting pointers”</a> by <strong>Mark de Wever</strong> allows nice formatting of pointer values without incanting <code>reinterpret_cast</code> to an integer type first. For example, this will now work: <code>format(&#34;{:P}&#34;, ptr);</code></p>



<p><a href="https://wg21.link/p2530">P2530 “Hazard pointers for C++26”</a> by <strong>Maged M. Michael, Michael Wong, Paul McKenney, Andrew Hunter, Daisy S. Hollman, JF Bastien, Hans Boehm, David Goldblatt, Frank Birbacher, and Mathias Stearn </strong>adds a subset of the Concurrency TS2 hazard pointer feature to add hazard pointer-based deferred cleanup to C++26.</p>



<p><a href="https://wg21.link/p2545">P2545 “Read-Copy-Update (RCU)”</a> by <strong>Paul McKenney, Michael Wong, Maged M. Michael, Andrew Hunter, Daisy Hollman, JF Bastien, Hans Boehm, David Goldblatt, Frank Birbacher, Erik Rigtorp, Tomasz Kamiński, Olivier Giroux, David Vernet, and Timur Doumler</strong> as another complementary way to do deferred cleanup in C++26.</p>



<p><a href="https://wg21.link/p2548">P2548 “copyable_function”</a> by<strong> Michael Hava</strong> adds a copyable replacement for <code>std::function</code>, modeled on <code>move_only_function</code>.</p>



<p><a href="https://wg21.link/p2562">P2562 “constexpr stable sorting”</a> by <strong>Oliver J. Rosten</strong> enables compile-time use of the standard library’s stable sorts (<code>stable_sort</code>, <code>stable_partition</code>, <code>inplace_merge</code>, and the <code>ranges::</code> versions). Jason Turner is probably saying “Moar!”…</p>



<p><a href="https://wg21.link/p2641">P2641 “Checking if a union alternative is active”</a> by<strong> Barry Revzin and Daveed Vandevoorde</strong> introduces the <code>consteval bool is_within_lifetime(const T* p) noexcept</code> function, which works in certain compile-time contexts to find out whether <code>p</code> is a pointer to an object that is within its lifetime — such as checking the active member of a union, but during development the feature was made even more generally useful than just that one use case. (This is technically a core language feature, but it’s in one of the “magic std:: features that look like library functions but are actually implemented by the compiler” section of the standard, in this case the metaprogramming clause.)</p>



<p><a href="https://wg21.link/p2757">P2757 “Type-checking format args”</a> by<strong> Barry Revzin</strong> enables even more compile-time checking for <code>std::format</code> format strings.</p>



<p>Those are just 12 of the adopted papers as highlights… there were 16 more papers adopted that also apply more extensions and fixes for the C++26 standard library.</p>



<h2>Other progress</h2>



<p>We also adopted the <a href="http://wg21.link/p1000r5">C++26 schedule</a> for our next three-year cycle. It’s the same as the schedule for C++23 but just with three years added everywhere, just as the C++23 schedule was in turn the same as the schedule for C++20 plus three years.</p>



<p>The language evolution subgroup (EWG) saw 30 presentations for papers during the week, mostly proposals targeting C++26, including fine-tuning for some of the above that made it into C++26 at this meeting.</p>



<p>The standard library evolution subgroup (LEWG) focused on advancing “big” papers in the queue that really benefit from face-to-face meetings. Notably, there is now design consensus on <a href="https://wg21.link/p1928">P1928 SIMD</a>, <a href="https://wg21.link/p0876">P0876 Fibers</a>, and <a href="https://wg21.link/p0843">P0843 inplace_vector</a>, and those papers have been forwarded to the library wording specification subgroup (LWG) and may come up for adoption into C++26 at our next meeting in November. Additional progress was made on <a href="https://wg21.link/p0447">P0447 hive</a>, <a href="https://wg21.link/p0260">P0260 Concurrent Queues</a>, <a href="https://wg21.link/p1030">P1030 path_view</a>, and <a href="https://wg21.link/p2781">P2781 constexpr_v</a>.</p>



<p>The library wording specification subgroup (LWG) is now caught up with their backlog, and spent a lot of time iterating on the <code>std::execution</code> and <code>sub_mdspan</code> proposals (the latter was adopted this week).</p>



<p>The contracts subgroup made further progress on refining contract semantics targeting C++26, including to get consensus on removing build modes and having a contract violation handling API.</p>



<p>The concurrency and parallelism subgroup are still on track to move forward with std::execution and SIMD parallelism for C++26, which in the words of the subgroup chair will make C++26 a huge release for the concurrency and parallelism group.</p>



<p>Thank you to all the experts who worked all week in all the subgroups to achieve so much this week!</p>



<h2>What’s next</h2>



<p>Our next two meetings will be in <a href="http://isocpp.org/files/papers/N4936.pdf">Kona, HI, USA in November</a> hosted by WorldQuant and the Standard C++ Foundation, and <a href="https://isocpp.org/files/papers/N4946.pdf">Tokyo, Japan in March</a> hosted by Woven by Toyota.</p>



<h2>Wrapping up</h2>



<p>Thank you again to the nearly 180 experts who attended on-site and on-line at this week’s meeting, and the many more who participate in standardization through their national bodies!</p>



<p>But we’re not slowing down… we’ll continue to have subgroup Zoom meetings, and then in less than five months from now we’ll be meeting again in person + Zoom to continue adding features to C++26. Thank you again to everyone reading this for your interest and support for C++ and its standardization.</p>
	</div></div>
  </body>
</html>
