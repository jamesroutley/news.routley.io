<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pathsensitive.com/2018/02/the-practice-is-not-performance-why.html">Original</a>
    <h1>Why project-based learning fails (2018)</h1>
    
    <div id="readability-page-1" class="page"><div><div>




<p>Last night, I encountered an <a href="https://zachholman.com/2011/02/graduated-with-a-major-in-startups/">old post</a> by Zach Holman where he pushes the idea that traditional school-based CS is useless; project-based learning is the way to go. I’ve <a href="https://blog.codinghorror.com/how-should-we-teach-computer-science/">heard</a> this idea <a href="http://archive.is/1BqTf">repeatedly</a> over the <a href="https://www.joelonsoftware.com/2008/01/08/undergraduate-programming/">last 10 years</a>, and know at least one person who’s started an education company with that premise.</p>

<p>I don’t want to debate the current way universities do things (I found my undergrad quite useful, thank you), but I do want to dispel the idea that everything would be better if only we switched to project-based learning. The opposite is closer to true. Project-based learning is not a superior new idea. Project-based learning is the most inefficient form of learning that still works.</p>

<p>To see why, we actually have to sit down and think about the learning process. I’ve learned a number of models of learning over the course of my teaching training, but the <a href="https://www.rationality.org/files/CFAR_Handbook_2021-01.pdf#page=192">one I’ve found most useful</a> is taught by the Center for Applied Rationality. It goes like this:</p>

<ol>
<li>Break down a skill into small components.</li>
<li>Drill each component rapidly, with immediate feedback</li>
<li>Integrate the pieces together into larger components; drill these similarly</li>
</ol>

<p>In that light, project-based learning definitely has something going for it: if you do a project, you will practice all the skills needed to do projects.</p>

<p>There’s something missing, though: it completely gives up on trying to think about what components it’s trying to teach.</p>

<p>Here’s how project-based learning might play out: After finishing his first two Android apps, Bob decides he wants to learn network programming, and generally get better at working on a software team. He and Alice pair up and decide to build a chat app for sending cat gifs, with a distributed replicated backend. They decide to make a spreadsheet of tasks and claim them. Alice also wants to learn network programming, and she swoops in and takes most of the server components; Bob gets left with most of the client work. Over the next three weeks, Bob spends a lot of time building the GUI for the app, which he already knows how to do, and only a couple hours implementing the client protocol. They start writing tests because the teacher said they had to. Bob has trouble writing the tests, and realizes a couple ways he could have made his code differently to make testing easier. He also discovers that two of his tests were too fragile, and needed to be changed when he updated the code.</p>

<p>It’s now one month later. What has he gotten from the experience? He&#39;s learned he needed to be more proactive about taking on tasks that challenge him and grow his skills. He’s learned a smidgeon about network programming, and a couple ideas about how to write better tests. These are good lessons, sure, but expensive. Isn’t there a way for Bob to learn more in that month?</p>

<h3>
False Temptations</h3>

<p>What are the common arguments in favor of project-based learning? Here are two of the main ones.</p>

<h4>Real skills</h4>

<p>The first big reason for project-based learning is that it teaches real skills used in industry. Why do many schools teach much of their curriculum in Haskell, not in the Tiobe Top 10, or even SML or OCaml, not even in the top 50? Wouldn’t they serve their graduates better teaching Node and React?</p>

<p>The first counterargument is that industrial technologies come and go. Proponents acknowledge this, sure, but still call CS departments “out of date” for not following trends. What really drove home the futility of this argument for me was <a href="https://pdfs.semanticscholar.org/3ce8/47852c84c8ffa3c25beb6955f186517c70d8.pdf">this essay</a> by software-engineering pioneer Mary Shaw. Had she followed that advice in the 60s, she points out, her students would have spent their time studying <a href="https://en.wikipedia.org/wiki/Job_Control_Language">JCL</a>, the language used to schedule jobs on IBM mainframes.</p>

<p>The second and bigger counterargument: learning concepts is much more important than learning applications, and the best environment to learn a concept is rarely the one in industrial demand.</p>

<p>People often ask me what’s the best language to learn to study software design. I ask them what’s the best instrument to learn to study music theory. Everyone answers piano. In piano, you can see the chords in a way that you can’t in, say, trombone. We see something similar in other domains. In The Art of Learning, Josh Waitzkin recounts how, unlike others, he started studying chess at the fundamentals, in situations with few pieces on the board. He ultimately beat competitors who studied many times harder. In The Art of Game Design: A Book of Lenses, Jesse Schell advocates looking past modern video games and instead studying the concepts in board games, dice games, playground games.</p>

<p>So, for programming, we need to (1) figure out the core concepts to teach, and (2) pick languages that make the concepts readily available. C and Java --- indeed, all top languages until Swift arrived --- lack elegant ways of expressing the idea of a sum, a value that can be one of many alternatives. Thus, when explaining why adding a new alternative sometimes breaks existing code and sometimes doesn’t, I find myself having to explain using the clumsy manifestations as unions and subclasses. The first time I read Bob Harper’s explanation of why they chose SML for the CMU undergraduate curriculum, I thought he was just rationalizing snobbery. Now, I quite agree.</p>

<h4>
More like real jobs</h4>

<p>The second big argument for project-based learning is that it more closely resembles what students will actually do on the job. This, in turn, is based on the idea that the best way to practice an activity is to do it.</p>

<p>This is false. “The only way to improve at X is to do it” is the advice you give when you actually have no idea how to improve. When you do know, you isolate subskills and drill them. Martial artists punch bags and do kata, and fight with extra constraints like no dodging. Musicians play scales, and practice a single measure over and over. Mathematicians rederive theorems from the book. And to condition a shot-putter, the best way is not to put weights in their hands and have them mimic the throwing motion, but rather to train the body’s ability to produce power, using squats and lots of heavy exercises that don’t even resemble shot-putting.<a href="#1" name="top1"><sup>1</sup></a></p>


<h3>
Drilling programming</h3>

<p>So what am I advocating? I’m advocating that you actually think about what you’re trying to teach, and design drills for it. The first drills should focus on one thing at a time.</p>

<p>So, for Bob trying to learn network programming and the general software engineering skills of being on a team project, here’s my 5-minute attempt to come up with an alternative way to teach these skills:</p>

<ol>
<li>Writing just the networking component of a larger system.</li>
<li>Being asked to write the test cases for a small program given to you. The program is deliberately designed to tempt you into all the classic mistakes of test-writing.</li>
<li>A simulation where you “coordinate” with the TAs to build something, committing pseudocode to version control. They troll you by deliberately misunderstanding things you say and seeing if their misunderstanding can go undetected.</li>
<li>You and several teammates are assigned a small project. You’re asked to divide it amongst yourselves into unrealistically small units of work, and write test cases for each other’s components. (Integrates the skills of 2 and 3.)</li>
</ol>

<p>These total much less time than the chat app, and teach much more. If students find they’re not optimal for learning, I as the instructor have much more room for experimenting. And if the students do choose to do a full project afterwards, they’ll be much more prepared.</p>

<p>I don’t teach network programming and haven’t tested these specific ideas. But, in my specialty of software design and code quality, I use exercises built on similar principles all the time. So I may teach a client some of the pitfalls of a naive understanding of information hiding, and then show them code from a real project that has that problem and ask them how they’d solve it. Or I’ll ask them to give just the type definitions and method signatures for a Minesweeper game; if they violate any design principles, then I can give them a feature request they can’t handle, or show why the implementation will be prone to bugs.</p>

<p>Is it better than just assigning projects? That’s the wrong question to ask because project-based learning is incredibly easy to beat. My clients are mostly working professional software engineers; they’re already doing “project-based learning” every day. On<a href="http://www.jameskoppelcoaching.com/"> my website</a>, I claim.</p>

<blockquote>
Programmers learn by making bad design decisions, working on the codebase for a year, and then find themselves wishing they could go back and do things differently. I can give you that experience in an hour. </blockquote>

<p>Does this sound like a bold statement about my teaching prowess? It’s not. In fact, piano teachers put that claim to shame. You can spend hundreds of hours practicing a piece using <a href="http://fundamentals-of-piano-practice.readthedocs.io/en/latest/chapter1/ch1_procedures/II.14.html">too many muscles on every key press</a>. If your body awareness isn’t great, you might not find out until your hand cramps up right before your performance. A couple seconds to catch that mistake, a couple minutes to tell you a story of that happening to others, and the piano teacher’s just saved you months.</p>

<p>(As an aside, this is why I believe in finding a competent private coach for every skill you really care about improving in.)</p>

<p>Replacing a traditional CS education with a “software engineering BFA,” like <a href="https://www.joelonsoftware.com/2008/01/08/undergraduate-programming/">Spoelsky</a> and <a href="https://blog.codinghorror.com/how-should-we-teach-computer-science/">Atwood</a> suggest, is no longer a hypothetical exercise. We’ve tried it. And now dev bootcamps are going bankrupt. Instead of substituting for a traditional degree, <a href="https://www.bloomberg.com/news/features/2016-12-06/want-a-job-in-silicon-valley-keep-away-from-coding-schools">recruiters are calling bootcamps jokes</a>. Olin College of Engineering is famous for its project-based curriculum, but one student <a href="http://franklyspeakingnews.com/2014/02/criticism-of-project-learning/">reports</a> that she learned much more from traditional classes.</p>

<p>It’s time to stop looking for panaceas and shortcuts and realize that deliberate learning and deliberate practice --- as a separate activity from the everyday doing --- is the only way to mastery. As famed gymnastics coach Chris Sommer puts it, the fastest way to learn is to do things the slow way. Studying the fundamentals may seem like a distraction keeping you from getting your hands dirty making a Rails app using the Google Maps and Twilio APIs, but when you do get there, you’ll find there is <a href="https://blog.bradfieldcs.com/in-2017-learn-every-language-59b11f68eee">less to learn</a> if you’ve already <a href="https://www.quora.com/Do-grad-school-students-remember-everything-they-were-taught-in-college-all-the-time">compressed the knowledge</a> into <a href="http://lesswrong.com/lw/la/truly_part_of_you/">concepts</a>.</p>

<h3>
Shameless Plug</h3>

<p>My <a href="http://jameskoppelcoaching.com/advanced-software-design-web-course/">Advanced Software Design Web Course</a> starts next week. It’s based on a lot of the learning principles I mentioned in this post, starting each concept with isolated drills and progressing to case studies from real software, and comes with personalized feedback from me on every assignment.</p>

<h4>
Disclaimer:</h4>
<p><span>

<p>No, the sum total of knowledge about CS education is not to be found within this post. Yes, I do have some formal training in education; yes, other people have a lot more. Yes, there are a lot of things I didn’t bring up. Yes, the situation with bootcamps is more complicated than a simple referendum on project-based learning. The simple “turbocharging training” model of learning I gave is not a theory of everything. Yes, you need to run into problems in context, find motivation, try things out of order, and even eventually do a full project on a team without guidance. I believe realistic projects do have a place in education, but they still must be coupled with the principles of rapid feedback, and they are a poor substitute for learning the concepts piece-by-piece.</p></span></p><h4>
<span>Acknowledgments</span></h4>

<p>
<span>Thanks to Elliott Jin for comments on earlier drafts of this post.</span>
</p>


<hr/>
<p>
<span>
<a name="1"><b>1</b></a> When I was searching for a personal trainer, I asked about this to help screen candidates.
</span>
</p></div>
</div></div>
  </body>
</html>
