<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.zhenghao.io/posts/ts-never">Original</a>
    <h1>A complete guide to TypeScript‚Äôs never type</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p><small>#typescript</small></p><p><time datetime="2022-03-04">Published on 04 March, 2022</time><time datetime="2022-03-11">Last updated on 11 March, 2022</time></p></div><blockquote>
<p>See discussions on <a href="https://news.ycombinator.com/item?id=30616912" target="_blank" rel="noopener noreferrer">Hacker News</a></p>
</blockquote>
<p>TypeScript‚Äôs <code>never</code> type is very under-discussed, because it‚Äôs not nearly as ubiquitous or inescapable as other types. A TypeScript beginner can probably ignore <code>never</code> type as it only appears when dealing with advanced types, such as conditional types, or reading their cryptic type error messages.</p>
<p>The <code>never</code> type does have quite a few good use cases in TypeScript. However, it also has its own pitfalls you need to be careful of.</p>
<p>In this blog post, I will cover:</p>
<ul>
<li>The meaning of <code>never</code> type and why we need it.</li>
<li>Practical applications and pitfalls of <code>never</code>.</li>
<li>a lot of puns ü§£</li>
</ul>
<h2 id="what-is-never-type">What is never type<a href="https://www.zhenghao.io/posts/ts-never#what-is-never-type">#</a></h2>
<p>To fully understand <code>never</code> type and its purposes, we must first understand what a <strong>type</strong> is, and what role it plays in a type system.</p>
<p>A type is a <strong>set</strong> of possible values. For example, <code>string</code> type represents an infinite set of possible strings. So when we annotate a variable with type <code>string</code>, such a variable can only have values from within that set, i.e. strings:</p>

<p>In TypeScript, <code>never</code> is an <strong>empty set</strong> of values. In fact, in <a href="https://flow.org/" target="_blank" rel="noopener noreferrer">Flow</a>, another popular JavaScript type system, the equivalent type is called exactly <a href="https://github.com/facebook/flow/commit/c603505583993aa953904005f91c350f4b65d6bd" target="_blank" rel="noopener noreferrer">empty</a></p>
<p>Since there‚Äôs no values in the set, <code>never</code> type can never (pun-intended) have any value, including values of <code>any</code> type. That‚Äôs why <code>never</code> is also sometimes referred to as an <a href="https://cs.stackexchange.com/questions/134215/what-is-an-uninhabited-type" target="_blank" rel="noopener noreferrer">uninhabitable type</a> or a <a href="https://en.wikipedia.org/wiki/Bottom_type" target="_blank" rel="noopener noreferrer">bottom type</a>.</p>

<p>The bottom type is how <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#other-important-typescript-types" target="_blank" rel="noopener noreferrer">the TypeScript Handbook</a> defines it. I found it makes more sense when we place <code>never</code> in the <a href="https://www.zhenghao.io/posts/type-hierarchy-tree#the-bottom-of-the-tree" target="_blank" rel="noopener noreferrer">type hierarchy tree</a>, a mental model I use to understand <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">subtyping</a></p>
<p>The next logical question is, why do we need <code>never</code> type?</p>
<h2 id="why-we-need-never-type">Why we need never type<a href="https://www.zhenghao.io/posts/ts-never#why-we-need-never-type">#</a></h2>
<p>Just like we have <strong>zero</strong> in our number system to denote the quantity of nothing, we need a type to denote <strong>impossibility</strong> in our type system.</p>
<p>The word &#34;impossibility&#34; itself is vague. In TypeScript, ‚Äúimpossibility‚Äù manifests itself in various ways, namely:</p>
<ul>
<li>An empty type that can&#39;t have any value, which can be used to represent the following:
<ul>
<li>Inadmissible parameters in generics and functions.</li>
<li>Intersection of incompatible types.</li>
<li>An empty union (a union type of nothingness).</li>
</ul>
</li>
<li>The return type of a function that never (pun-intended) returns control to the caller when it finishes executing, e.g., <code>process.exit</code> in Node
<ul>
<li>Not to confuse it with <code>void</code>, as <code>void</code> means a function doesn‚Äôt return anything useful to the caller.</li>
</ul>
</li>
<li>An else branch that should never (pun-intended... ok I think that&#39;s enough puns for today) be entered in a condition type</li>
<li>The fulfilled value&#39;s type of a rejected <code>promise</code>

</li>
</ul>
<h3 id="how-never-works-with-unions-and-intersections">How never works with unions and intersections<a href="https://www.zhenghao.io/posts/ts-never#how-never-works-with-unions-and-intersections">#</a></h3>
<p>Analogous to how number zero works in addition and multiplication, <code>never</code> type has special properties when used in union types and intersection types:</p>
<ul>
<li>
<p><code>never</code> gets dropped from union types, similiar to when zero added to a number gives the same number.</p>
<ul>
<li>e.g. <code>type Res = never | string // string</code></li>
</ul>
</li>
<li>
<p><code>never</code> overrides other types in intersection types, similiar to when zero multiplying a number gives zero.</p>
<ul>
<li>e.g. <code>type Res = never &amp; string  // never</code></li>
</ul>
</li>
</ul>
<p>These two behaviors/characteristics of <code>never</code> type lay the foundation for some of its most important use cases that we will see later on.</p>
<h2 id="how-to-use-never-type">How to use never type<a href="https://www.zhenghao.io/posts/ts-never#how-to-use-never-type">#</a></h2>
<p>While you probably wouldn‚Äôt find yourself use <code>never</code> a lot, there are quite a few legit use cases for it:</p>
<h3 id="annotate-inadmissible-function-parameters-to-impose-restrictions">Annotate inadmissible function parameters to impose restrictions<a href="https://www.zhenghao.io/posts/ts-never#annotate-inadmissible-function-parameters-to-impose-restrictions">#</a></h3>
<p>Since we can never assign a value to <code>never</code> type, we can use it to impose restrictions on functions for various use cases.</p>
<h4 id="ensure-exhaustive-matching-within-switch-and-if-else-statement">Ensure exhaustive matching within switch and if-else statement<a href="https://www.zhenghao.io/posts/ts-never#ensure-exhaustive-matching-within-switch-and-if-else-statement">#</a></h4>
<p>If a function can only take one argument of <code>never</code> type, that function can never be called with any non-<code>never</code> value (without the TypeScript compiler yelling at us):</p>

<p>We can use such a function to ensure exhaustive matching within switch and if-else statement: by using it as the default case, we ensure that all cases are covered, since what remains must be of type <code>never</code>. If we accidentally leave out a possible match, we get a type error. For example:</p>

<h4 id="partially-disallow-structural-typing">Partially disallow structural typing<a href="https://www.zhenghao.io/posts/ts-never#partially-disallow-structural-typing">#</a></h4>
<p>Let‚Äôs say we have a function that accepts a parameter of either the type <code>VariantA</code> or <code>VariantB</code>. But, the user mustn‚Äôt pass a type encompassing all properties from both types, i.e.,¬†a <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener noreferrer">subtype</a> of both types.</p>
<p>We can leverage a union type <code>VariantA | VariantB</code> for the parameter. However, since type compatibility in TypeScript is based on <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#handbook-content" target="_blank" rel="noopener noreferrer">structural subtyping</a>, passing an object type that has more properties than the parameter‚Äôs type has to a function is allowed (unless you pass object literals):</p>

<p>The above code snippet doesn&#39;t give us a type error in TypeScript.</p>
<p>By using <code>never</code>, we can partially disable structural typing and prevent users from passing object values that include <em>both</em> properties:</p>

<h4 id="prevent-unintended-api-usage">Prevent unintended API usage<a href="https://www.zhenghao.io/posts/ts-never#prevent-unintended-api-usage">#</a></h4>
<p>Let‚Äôs say we want to create a <code>Cache</code> instance to read and store data from/to it:</p>

<p>Now, for some reason we want to have a read-only cache only allowing for reading data via the <code>get</code> method. We can type the argument of the <code>put</code> method as <code>never</code> so it can‚Äôt accept any value passed in it:</p>

<blockquote>
<p>Unrelated to <code>never</code> type, as a side note, this might not be a good use case of derived classes. I am not really an expert on object-oriented programming, so please use your own judgment.</p>
</blockquote>
<h3 id="denote-theoretically-unreachable-conditional-branches">Denote theoretically unreachable conditional branches<a href="https://www.zhenghao.io/posts/ts-never#denote-theoretically-unreachable-conditional-branches">#</a></h3>
<p>When using <code>infer</code> to create an additional type variable inside a conditional type, we must add an else branch for every <code>infer</code> keyword:</p>

<details><summary>Why is this <code>extends infer</code> combo useful?</summary>
<p>In my previous post I mentioned how you can create declare ‚Äúlocal (type) variable‚Äù together with <code>extends infer</code>. Check it out <a href="https://www.zhenghao.io/posts/type-programming#local-variable-declaration">here</a> if you haven‚Äôt seen it.</p></details>
<h3 id="filter-out-union-members-from-union-types">Filter out union members from union types<a href="https://www.zhenghao.io/posts/ts-never#filter-out-union-members-from-union-types">#</a></h3>
<p>Beside denoting impossible branches, <code>never</code> can be used to filter out unwanted types in conditional types.</p>
<p>As we have discussed this before, when used as a union member, <code>never</code> type is removed automatically. In other words, the <code>never</code> type is useless in a union type.</p>
<p>When we are writing a utility type to select union members from a union type based on certain criteria, <code>never</code> type&#39;s uselessness in union types makes it the perfect type to be placed in else branches.</p>
<p>Let&#39;s say we want a utility type <code>ExtractTypeByName</code> to extract the union members with the <code>name</code> property being string literal <code>foo</code> and filter out those that don&#39;t match:</p>

<details><summary>See how this works in detail</summary>
<p>Here are a list of steps TypeScript folllows to evaluate and get the resultant type:</p><ol>
<li>Conditional types are distributed over union types (namely, <code>Name</code> in this case):

</li>
<li>Substitue the implementation and evaluate separately

</li>
<li>Remove <code>never</code> from the union

</li>
</ol></details>
<h3 id="filter-out-keys-in-mapped-types">Filter out keys in mapped types<a href="https://www.zhenghao.io/posts/ts-never#filter-out-keys-in-mapped-types">#</a></h3>
<p>In TypeScript, types are immutable. If we want to delete a property from an object type, we must create a new one by transforming and filtering the existing one. When we conditionally <a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as" target="_blank" rel="noopener noreferrer">re-map keys</a> in mapped types to <code>never</code>, those keys get filtered out.</p>
<p>Here‚Äôs an example for a <code>Filter</code> type that filters out object type properties based on their value types.</p>

<h3 id="narrow-types-in-control-flow-analysis">Narrow types in control flow analysis<a href="https://www.zhenghao.io/posts/ts-never#narrow-types-in-control-flow-analysis">#</a></h3>
<p>When we type a function‚Äôs return value as <code>never</code>, that means the function never returns control to the caller when it finishes executing. We can leverage that to help control flow analysis to narrow down types.</p>
<blockquote>
<p>A function can never return for several reasons: it might throw an exception on all code paths, it might loop forever, or it exits from the program e.g. <code>process.exit</code> in Node.</p>
</blockquote>
<p>In the following code snippet, we use a function that returns <code>never</code> type to strip away <code>undefined</code> from the union type for <code>foo</code>:</p>

<p>Or invoke <code>throwError</code> after <code>||</code> or <code>??</code> operator:</p>

<h3 id="denote-impossible-intersections-of-incompatible-types">Denote impossible intersections of incompatible types<a href="https://www.zhenghao.io/posts/ts-never#denote-impossible-intersections-of-incompatible-types">#</a></h3>
<p>This one might feel more like a behavior/characteristic of the TypeScript language than a practical application for <code>never</code>. Nevertheless, it‚Äôs vital for understanding some of the cryptic error messages you might come across.</p>
<p>You can get <code>never</code> type by intersecting incompatible types</p>

<p>And you get <code>never</code> type by intersecting any types with <code>never</code></p>

<details><summary>It gets complicated for object types...</summary>
<p>When intersecting object types, depending on whether or not the disjoint properties are considered as discriminant properties (basically literal types or unions of literal types), you might or might not get the whole type reduced to <code>never</code></p>
<p>In this example only <code>name</code> property becames <code>never</code> since <code>string</code> and <code>number</code> are not discriminant properties</p><p>In the following example, the whole type <code>Baz</code> is reduced to <code>never</code> because a boolean is a discriminant property (a union of <code>true | false</code>)</p><p>Check out this <a href="https://github.com/microsoft/TypeScript/pull/36696" target="_blank" rel="noopener noreferrer">PR</a> to learn more.</p></details>
<h2 id="how-to-read-never-type-from-error-messages">How to read never type (from error messages)<a href="https://www.zhenghao.io/posts/ts-never#how-to-read-never-type-from-error-messages">#</a></h2>
<p>You might have gotten error messages involving an unexpected <code>never</code> type from code you didn‚Äôt annotate with <code>never</code> explicitly. That‚Äôs usually because the TypeScript compiler intersects the types. It does this implicitly for you to retain type safety and to ensure soundness.</p>
<p>Here‚Äôs an example (play with it in <a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAShwFcBOA7AKuCAhEBJFYCwGkUAvFAN4BQUUAlisAFxQoIC2ARhErVAGMAFgEMkrAM7AkjAOb8uAe0UAbVktUQRKagF9q1AGYIUA4PUUoos+DG0ATRRwA8aKBAAewCCnsSoAOTCYgFQAD6BjMChEQEaKgEAfAAU-FLiUGjUAJSscIioJNh4BERFANpoALpU-PSGUMnp5GQUAVEB2bV0dAD0vdY+vCLeUCJQSA5ObJw8fD0T8MhWALIjQgB0hirKSMlrwJuTvk7JXQBUUACMAAxd-LruKhLQ9Y3NrW3BSJ3dPf2DFDDUbjY6ODiCUTzHpIJaoKAAZWkci2SCcAGEoejFPYIKkFnQAJwAdigAGooAdNttdvt1hswacLlAAEwANmy-DonLojwgz2gNAWAJsQMmIImUwh8S0OgWsIKViwyhUsrphwZihM9nVRylZ2yPKg+l0QA" target="_blank" rel="noopener noreferrer">TypeScript playground</a>) that I used in my previous <a href="https://www.zhenghao.io/posts/type-functions" target="_blank" rel="noopener noreferrer">blog post</a> on typing polymorphic functions:</p>

<p>The function returns either a number, a string, or a boolean depending on the type of argument we pass. We use an indexes access <code>ReturnTypeByInputType[T]</code> to retrieve the corresponding return type.</p>
<p>However, for every return statement we have a type error, namely: <code>Type X is not assignable to type &#39;never&#39;</code> where <code>X</code> is string or number or boolean, depending on the branch.</p>
<p>This is where TypeScript tries to help us narrow down the possibility of problematic states in our program: each return value should be assignable to the type <code>ReturnTypeByInputType[T]</code> (as we annotated in the example) where <code>ReturnTypeByInputType[T]</code> at runtime could end up being either a number, a string, or a boolean.</p>
<p>Type safety can only be achieved if we make sure that the return type is assignable to all possible <code>ReturnTypeByInputType[T]</code>, i.e. the <strong>intersection</strong> of number , string, and boolean.
And what‚Äôs the intersection of these 3 types? It‚Äôs exactly <code>never</code> as they are incompatible with each other. That‚Äôs why we are seeing <code>never</code> in the error messages.</p>
<p>To work around this, you must use type assertions (or function overloads):</p>
<ul>
<li><code>return Math.floor(Math.random() * 10) as ReturnTypeByInputType[T]</code></li>
<li><code>return Math.floor(Math.random() * 10) as never</code></li>
</ul>
<p>Maybe another more obvious example:</p>

<p><code>obj[key]</code> could end up being either a string or a number depending on the value of <code>key</code> at runtime. Therefore, TypeScript added this constraint, i.e., any values we write to <code>obj[key]</code> must be compatible with both types,¬†string and number, just to be safe. So, it intersects both types and gives us <code>never</code> type.</p>
<h2 id="how-to-check-for-never">How to check for never<a href="https://www.zhenghao.io/posts/ts-never#how-to-check-for-never">#</a></h2>
<p>Checking if a type is <code>never</code> is harder than it should be.</p>
<p>Consider the following code snippet:</p>

<p>Is <code>Res</code> <code>true</code> or <code>false</code>? It might surprise you that the answer is neither: <code>Res</code> is actually <code>never</code>. In fact,</p>
<p>It definitely threw me off the first time I came across this. <a href="https://twitter.com/searyanc" target="_blank" rel="noopener noreferrer">Ryan Cavanaugh</a> explained this in <a href="https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379094672" target="_blank" rel="noopener noreferrer">this issue</a>. It boils down to:</p>
<ul>
<li>TypeScript distributes union types in conditional types automatically</li>
<li><code>never</code> is an empty union</li>
<li>Therefore, when distribution happens there‚Äôs nothing to distribute over, so the conditional type resolves to <code>never</code> again.</li>
</ul>
<p>The only workaround here is to opt out of the implicit distribution and to wrap the type parameter in a tuple:</p>

<p>This is actually straight out of <a href="https://github.com/microsoft/TypeScript/blob/main/tests/cases/conformance/types/conditional/conditionalTypes1.ts#L212" target="_blank" rel="noopener noreferrer">TypeScript‚Äôs source code</a> and it would be nice if TypeScript could expose this externally.</p>
<h2 id="in-summary">In summary<a href="https://www.zhenghao.io/posts/ts-never#in-summary">#</a></h2>
<p>We covered quite a lot in this blog post:</p>
<ul>
<li>First, we talked about <code>never</code> type&#39;s definition and purposes.</li>
<li>Then, we talked about its various use cases:
<ul>
<li>imposing restrictions on functions by leveraging the fact that <code>never</code> is an empty type</li>
<li>filtering out unwanted union members and object type&#39;s properties</li>
<li>aiding control flow analysis</li>
<li>denoting invalid or unreachable conditional branches</li>
</ul>
</li>
<li>We also talked about why <code>never</code> can come up unexpectedly in type error messages due to implicit type intersection</li>
<li>Finally, we covered how you can check if a type is indeed <code>never</code> type.</li>
</ul>
<blockquote>
<p>Special thanks to my friend <a href="https://twitter.com/JoshuaKGoldberg" target="_blank" rel="noopener noreferrer">Josh</a> for reviewing this post and giving invaluable feedback!</p>
</blockquote></article></div></div>
  </body>
</html>
