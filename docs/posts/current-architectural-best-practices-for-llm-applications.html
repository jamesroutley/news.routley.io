<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattboegner.com/knowledge-retrieval-architecture-for-llms/">Original</a>
    <h1>Current architectural best practices for LLM applications</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>This is a fascinating time in the study and application of large language models. New advancements are announced every day! </p><p>In this guide, I share my analysis of the current architectural best practices for data-informed language model applications. This particular subdiscipline is experiencing phenomenal research interest even by the standards of large language models - in this guide, I cite 8 research papers and 4 software projects,  with a median initial publication date of <strong>November 22nd, 2022</strong>. </p><h3 id="overview">Overview</h3><p>In nearly all practical applications of large language models (LLM’s), there are instances in which you want the language model to generate an answer based on specific data, rather than supplying a generic answer based on the model’s training set. For example, a company chatbot should be able to reference specific articles on the corporate website, and an analysis tool for lawyers should be able to reference previous filings for the same case. The way in which this external data is introduced is a key design question.</p><p>At a high level, there are two primary methods for referencing specific data:</p><ol><li>Insert data as context in the model prompt, and direct the response to utilize that information</li><li>Fine-tune a model, by providing hundreds or thousands of prompt &lt;&gt; completion pairs</li></ol><h3 id="shortcomings-of-knowledge-retrieval-for-existing-llm%E2%80%99s">Shortcomings of Knowledge Retrieval for Existing LLM’s</h3><p>Both of these methods have significant shortcomings in isolation. </p><p>For the context-based approach:</p><ul><li>Models have a limited context size, with the latest `davinci-003` model only able to process up to 4,000 tokens in a single request. Many documents will not fit into this context.</li><li>Processing more tokens equates to longer processing times. In customer-facing scenarios, this impairs the user experience.</li><li>Processing more tokens equates to higher API costs, and may not lead to more accurate responses if the information in the context is not targeted.</li></ul><p>For the fine-tuning approach:</p><ul><li>Generating prompt &lt;&gt; completion pairs is time-consuming and potentially expensive.</li><li>Many repositories from which you want to reference information are quite large. For example, if your application is a study aid for medical students taking the <a href="https://www.usmle.org/prepare-your-exam/step-1-materials/step-1-content-outline-and-specifications?ref=mattboegner.com">US MLE</a>, a comprehensive model would have to provide training examples across numerous disciplines.</li><li>Some external data sources change quickly. For example, it is not optimal to retrain a customer support model based on a queue of open cases that turns over daily or weekly.</li><li>Best practices around fine-tuning are still being developed. LLM&#39;s themselves can be used to assist with the generation of training data, but this may take some sophistication to be effective.</li></ul><h3 id="the-solution-simplified">The Solution, Simplified</h3><figure><img src="https://lh5.googleusercontent.com/1mMKU2jr3BSGshMcKhpNwdn4n7zV5kUW2a_Jp5xt2vXpw99WSixVOA8WVMjVJ9vGc2eyCqdf5SMm-PbFPrECr_5iDyiOChVj1wtJulaJ2oG6Qe5uJNZ1ViBsdEr53A3o1ckDIpZwy8x_clZR865Db10" alt="" loading="lazy" width="720" height="233"/></figure><p>The design above goes by various names, most commonly &#34;retrieval-augmented generation&#34; or &#34;RETRO&#34;. Links &amp; related concepts:</p><ul><li><a href="https://arxiv.org/abs/2005.11401?ref=mattboegner.com"><strong>RAG</strong></a><strong>:</strong> Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</li><li><a href="https://arxiv.org/abs/2112.04426?ref=mattboegner.com"><strong>RETRO</strong></a><strong>:</strong> Improving language models by retrieving from trillions of tokens</li><li><a href="https://arxiv.org/abs/2002.08909?ref=mattboegner.com"><strong>REALM</strong></a><strong>:</strong> Retrieval-Augmented Language Model Pre-Training</li></ul><p>Retrieval-augmented generation a) <strong>retrieves</strong> relevant data from outside of the language model (non-parametric) and b) <strong>augments</strong> the data with context in the prompt to the LLM. The architecture cleanly routes around most of the limitations of fine-tuning and context-only approaches.</p><p><u>Retrieval</u></p><figure><img src="https://mattboegner.com/content/images/2023/01/Screen-Shot-2023-01-31-at-12.44.17-AM.png" alt="" loading="lazy" width="989" height="310" srcset="https://mattboegner.com/content/images/size/w600/2023/01/Screen-Shot-2023-01-31-at-12.44.17-AM.png 600w, https://mattboegner.com/content/images/2023/01/Screen-Shot-2023-01-31-at-12.44.17-AM.png 989w" sizes="(min-width: 720px) 720px"/></figure><p>The retrieval of relevant information is worth further explanation. As you can see, data may come from multiple sources depending on the use case. In order for the data to be useful, it must be sized small enough for multiple pieces to fit into context <em>and </em>there must be some way to identify relevance. So a typical prerequisite is to split text into sections (for example, via utilities in the <a href="https://github.com/hwchase17/langchain?ref=mattboegner.com">LangChain</a> package), then calculate embeddings on those chunks.</p><p>Language model embeddings are numerical representations of concepts in text and seem to have endless uses. Here&#39;s how they work: an embeddings model converts text into a large, scored vector, which can be efficiently compared to other scored vectors to assist with recommendation, classification, and search (+more) tasks. We store the results of this computation into what I’ll generically refer to as the search index &amp; entity store - more advanced discussions on that below.</p><figure><img src="https://mattboegner.com/content/images/2023/01/Screen-Shot-2023-01-31-at-12.44.42-AM.png" alt="" loading="lazy" width="899" height="150" srcset="https://mattboegner.com/content/images/size/w600/2023/01/Screen-Shot-2023-01-31-at-12.44.42-AM.png 600w, https://mattboegner.com/content/images/2023/01/Screen-Shot-2023-01-31-at-12.44.42-AM.png 899w" sizes="(min-width: 720px) 720px"/></figure><p>Back to the flow – when a user submits a question, an LLM processes the message in multiple ways, but the key step is calculating another embedding - this time, of the user’s text. Now, we can semantically search the search index &amp; entity store by comparing the new embeddings vector to the full set of precomputed vectors. This semantic search is based on the “learned” concepts of the language model and is not limited to just a search for keywords. From the results of this search, we can quantitatively identify one or more relevant text chunks that could help inform the user’s question.</p><p><u>Augmentation</u></p><p>Building the prompt using the relevant text chunks is straightforward. The prompt begins with some basic prompt engineering, instructing the model to avoid “hallucinating” i.e. making up an answer that is false, but sounds plausible. If applicable, we direct the model to answer questions in a certain format e.g. “High”,”Medium”, or “Low” for an ordinal ranking. Finally, we provide the relevant information from which the language model can answer using specific data. In its simplest form, we simply append (“Document 1: ”+  text chunk 1 + “\nDocument 2: ” + text chunk 2 + …) until the context is filled.</p><p>Finally, the combined prompt is sent to the large language model. An answer is parsed from the completion and passed along to the user.</p><p>That’s it! While this is a simple version of the design, it’s inexpensive, accurate, and perfect for many lightweight use cases. I’ve used this setup in an industry prototype to great success. A plug-and-play version of this approach can be found in the <a href="https://github.com/openai/openai-cookbook/blob/main/examples/Question_answering_using_embeddings.ipynb?ref=mattboegner.com">openai-cookbook repository</a> and is a convenient starting point.</p><h3 id="advanced-design">Advanced Design</h3><p><u>Generate-then-Read Pipelines</u></p><p>This category of approaches involves processing the user input with an LLM <em>before</em> retrieving relevant data.</p><p>Basically, a user’s question lacks some of the relevance patterns that an informative answer will display. For example, &#34;What is the syntax for list comprehension in Python?&#34; differs quite a bit from an example in a code repository, such as the snippet &#34;<em>newlist = [x   for x in tables if &#34;customer&#34; in x]</em>&#34;. A proposed approach uses “<a href="https://arxiv.org/abs/2212.10496?ref=mattboegner.com">Hypothetical Document Embeddings</a>” to generate a hypothetical contextual document which may contain false details but mimics a real answer. Embedding <em>this</em> document and searching for relevant (real) examples in the datastore retrieves more relevant results; the relevant results are used to generate the actual answer seen by the user.</p><p>A similar approach titled <a href="https://arxiv.org/abs/2209.10063?ref=mattboegner.com">generate-then-read (GenRead)</a> builds on the practice by implementing a clustering algorithm on multiple contextual document generations. Effectively, it generates multiple sample contexts and ensures they differ in meaningful ways. This approach biases the language model towards returning more diverse hypothetical context document suggestions, which (after embedding) returns more varied results from the datastore and results in a higher chance of the completion including an accurate answer.</p><p><u>Improved Data Structures for LLM Indexing &amp; Response Synthesis</u></p><p>The <a href="https://gpt-index.readthedocs.io/en/latest/guides/primer.html?ref=mattboegner.com">GPT Index project</a> is excellent and worth a read. It utilizes a collection of data structures both created by and optimized for langauge models. GPT Index supports <a href="https://gpt-index.readthedocs.io/en/latest/guides/index_guide.html?ref=mattboegner.com">multiple types of indices</a> described in more detail below. The basic response synthesis is “select top <em>k</em> relevant documents and append them to the context”, but there are multiple strategies for doing so.</p><ul><li>List Index - Each node represents a text chunk, otherwise unaltered. In the default setup, all nodes are combined into the context (response synthesis step).</li></ul><figure><img src="https://mattboegner.com/content/images/2023/01/list-index.png" alt="" loading="lazy" width="630" height="245" srcset="https://mattboegner.com/content/images/size/w600/2023/01/list-index.png 600w, https://mattboegner.com/content/images/2023/01/list-index.png 630w"/></figure><ul><li>Vector Store Index - This is equivalent to the simple design that I explained in the previous section. Each text chunk is stored alongside an embedding; comparing a query embedding to the document embeddings returns the <em>k</em> most similar documents to feed into the context.</li></ul><figure><img src="https://mattboegner.com/content/images/2023/01/vector-store-index.png" alt="" loading="lazy" width="638" height="434" srcset="https://mattboegner.com/content/images/size/w600/2023/01/vector-store-index.png 600w, https://mattboegner.com/content/images/2023/01/vector-store-index.png 638w"/></figure><ul><li>Keyword Index - This supports a quick and efficient lexical search for particular strings.</li></ul><figure><img src="https://mattboegner.com/content/images/2023/01/keyword-index.png" alt="" loading="lazy" width="630" height="345" srcset="https://mattboegner.com/content/images/size/w600/2023/01/keyword-index.png 600w, https://mattboegner.com/content/images/2023/01/keyword-index.png 630w"/></figure><ul><li>Tree Index - This is extremely useful when your data is organized into hierarchies. Consider a clinical documentation application: you may want the text to include both high-level instructions (&#34;here are general ways to improve your heart health&#34;) and low-level text (reference side effects and instructions for a particular blood pressure drug regimen). There are a few different ways of traversing the tree to generate a response, two of which are shown below.</li></ul><figure><img src="https://mattboegner.com/content/images/2023/01/Screen-Shot-2023-01-31-at-2.17.14-PM.png" alt="" loading="lazy" width="446" height="375"/></figure><figure><img src="https://mattboegner.com/content/images/2023/01/tree-summarization.png" alt="" loading="lazy" width="558" height="416"/></figure><ul><li>GPT Index offers <strong>composability</strong> of indices, meaning you can build indices on top of other indices. For example, in a code assistant scenario, you could build one tree index over internal GitHub repositories and another tree index over Wikipedia. Then, you layer on a keyword index over the tree indices.</li></ul><p><u>Expanded Context Size</u></p><p>Some of the approaches outlined in this post sound &#34;hacky&#34; because they involve workarounds to the relatively small context size in current models. There are significant research efforts aimed at expanding this limitation. </p><ul><li>GPT-4 is anticipated within the next 1-3 months. It is rumored to have a larger context size.</li><li><a href="https://arxiv.org/abs/2211.05102?ref=mattboegner.com">This paper</a> from the folks at Google AI features a number of explorations of engineering tradeoffs. One of the configurations allowed for a context length of up to 43,000 tokens.</li><li>A new <a href="https://arxiv.org/abs/2212.14052?ref=mattboegner.com">state space model architecture</a> scales ~linearly with context size instead of quadratically like seen in transformer models. While the performance of this model lags in other areas, it demonstrates that significant research efforts are targeted at improving model considerations such as context size.</li></ul><p>In my opinion, advancements in context size will scale alongside demands for more data retrieval; in other words, it&#39;s safe to assume that text splitting and refinement will continue to be required, even as some configurations evolve.</p><p><u>Persisting State (e.g. Conversation History)</u></p><p>When LLM’s are presented to the user in a conversational form, a major challenge is maintaining that conversation history in context.</p><p>An overview of the relevant strategies is beyond the scope of this post; for an example of a recent code demonstration involving progressive summarization and knowledge retrieval, see this <a href="https://github.com/hwchase17/langchain/blob/master/langchain/chains/conversation/prompt.py?ref=mattboegner.com">LangChain example</a>.</p><h3 id="resources-further-reading">Resources &amp; Further Reading</h3><ul><li><a href="https://github.com/jerryjliu/gpt_index?ref=mattboegner.com">GPT Index</a></li><li><a href="https://docs.haystack.deepset.ai/docs/intro?ref=mattboegner.com">Haystack</a> library for semantic search and other NLP applications</li><li><a href="https://arxiv.org/abs/2005.11401?ref=mattboegner.com">Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</a></li><li><a href="https://github.com/hwchase17/langchain?ref=mattboegner.com">LangChain</a></li><li><a href="https://simonwillison.net/2023/Jan/13/semantic-search-answers/?ref=mattboegner.com">How to implement Q&amp;A against your documentation with GPT3, embeddings and Datasette</a></li><li><a href="https://github.com/facebookresearch/faiss?ref=mattboegner.com">FAISS</a> for vector similarity calculations</li><li><a href="https://arxiv.org/abs/2209.10063?ref=mattboegner.com">Generate rather than Retrieve: Large Language Models are Strong Context Generators</a></li><li><a href="https://github.com/wyu97/GenRead?ref=mattboegner.com">Implementation Code</a></li></ul>
			</div></div>
  </body>
</html>
