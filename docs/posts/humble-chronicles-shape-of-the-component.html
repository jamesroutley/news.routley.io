<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/humble-defcomp/">Original</a>
    <h1>Humble Chronicles: Shape of the Component</h1>
    
    
<p>Last time I ran a huge experiment trying to figure out how components should work in Humble UI. Since then, I’ve been trying to bring it to the main.</p>
<p>This was trickier than I anticipated — even with a working prototype, there are still lots of decisions to make, and each one takes time.</p>
<p>I discussed some ideas in <a href="https://tonsky.me/blog/humble-vdom/">Humble Chronicles: Managing State with VDOM</a>, but this is what we ultimately arrived at.</p>
<p>The simplest component:</p>
<pre><code>(ui/defcomp my-comp []
  [ui/label &quot;Hello, world!&quot;])</code></pre>
<p>Note the use of square brackets <code>[]</code>, it’s important. We are not creating nodes directly, we return a “description” of UI that will later be analyzed and instantiated for us by Humble UI.</p>
<p>Later if you want to use your component, you do the same:</p>
<pre><code>(ui/defcomp other-comp []
  [my-comp])</code></pre>
<p>You can pass arguments to it:</p>
<pre><code>(ui/defcomp my-comp [text text2 text3]
  [ui/label (str text &quot;, &quot; text2 &quot;, &quot; text3)])</code></pre>
<p>To use local state, return a function. In that case, the body itself will become the “setup” phase, and the returned function will become the “render” phase. Setup is called once, render is called many times:</p>
<pre><code>(ui/defcomp my-comp [text]
  ;; setup
  (let [*cnt (signal/signal 0)]
    (fn [text]
      ;; render
      [ui/label (str text &quot;: &quot; @*cnt)])))</code></pre>
<p>As you can see, we have our own signals implementation. They seem to fit very well with the rest of the VDOM paradigm.</p>
<p>Finally, the fullest form is a map with the <code>:render</code> key:</p>
<pre><code>(ui/defcomp my-comp [text]
  (let [timer (timer/schedule #(println 123) 1000)]
    {:after-unmount
     (fn []
       (timer/cancel timer)) 
     :render
     (fn [text]
       [ui/label text])}))</code></pre>
<p>Again, the body of the component itself becomes “setup”, and <code>:render</code> becomes “render”. As you can see, the map form is useful for specifying lifecycle callbacks.</p>
<h1 id="code-reuse">Code reuse</h1>
<p>React has a notion of “hooks”: small reusable bits of code that have access to all the same state and lifecycle machinery that components have.</p>
<p>For example, a timer always needs to be cancelled in unmount, but I don’t want to write <code>after-unmount</code> every time I want to use a timer. I want to use a timer and have its lifecycle to be registered automatically.</p>
<p>Our alternative is <code>with</code> macro:</p>
<pre><code>(defn use-timer []
  (let [*state (signal/signal 0)
        timer  (timer/schedule #(println @*state) 1000)
        cancel (fn []
                 (timer/cancel timer))]
    {:value         *state
     :after-unmount cancel}))

(ui/defcomp ui []
  (ui/with [*timer (use-timer)]
    (fn []
      [ui/label &quot;Timer: &quot; @*timer])))</code></pre>
<p>Under the hood, <code>with</code> just takes a return map of its body and adds stuff it needs to it. Simple, no magic, no special “hooks rules”. </p>
<p>Same as with hooks, <code>with</code> can be used inside <code>with</code> recursively. It just works.</p>
<p>Thanks <a href="https://kevinlynagh.com/">Kevin Lynagh</a> for the idea.</p>
<h1 id="shared-state">Shared state</h1>
<p>One of the goals of Humble UI was to make component reuse trivial. Web, for example, has hundreds of properties to customize a button, and still, it’s often not enough.</p>
<p>I lack the resources to make hundreds of properties, so I wanted to take another route: make components out of simple reusable parts, and let end users recombine them.</p>
<p>So a button becomes <code>clickable</code> (behavior) and <code>button-look</code> (visual). Want a custom button? Implement your own look, and use the same behavior. Want to reuse the look in another component (e.g. a toggle button?). Write your own behavior, and reuse the visuals.</p>
<p>The look itself consists of simple parts that can be reused and recombined:</p>
<pre><code>(ui/defcomp button-look [child]
  [clip-rrect {:radii [4]}
   [rect {:paint button-bg)}
    [padding {:padding 10}
     [center
      [label child]]]]])</code></pre>
<p>And then the button becomes:</p>
<pre><code>(ui/defcomp button [opts child]
  [ui/clickable opts
   [ui/button-look child]])</code></pre>
<p>(this and a previous one are simplified for clarity)</p>
<p>Now, the problem. The button is, of course, interactive. It reacts to being hovered, pressed, etc. But the state that represents it lives in <code>clickable</code> (the behavior). How to share?</p>
<p>The first idea was to use signals. Like this:</p>
<pre><code>(ui/defcomp button [opts child]
  (let [*state (signal/signal nil)]
    (fn [opts child]
      [ui/clickable {:*state *state}
       [ui/button-look @*state child]])))</code></pre>
<p>Which does work, of course, but a little too verbose. It also forces you to define state outside, while logically <code>clickable</code> should be responsible for it.</p>
<p>So the current solution is this:</p>
<pre><code>(ui/defcomp button [opts child]
  [ui/clickable opts
   (fn [state]
     [ui/button-look state child])])</code></pre>
<p>Which is a bit tighter and doesn’t expose the state unnecessarily. The look component is also straightforward: it accepts the state as an argument, without any magic, so it can be reused anywhere.</p>
<h1 id="where-to-try">Where to try</h1>
<p>Current development happens <a href="https://github.com/HumbleUI/HumbleUI/tree/vdom">in the “vdom” branch</a>. Components migrate slowly, but steadily, to the new model.</p>
<p>Current screenshot for history:</p>
<figure>
<img src="https://tonsky.me/blog/humble-defcomp/screenshot@2x.webp"></figure>
<p>Soon we will all live in a Virtual DOM world, I hope.</p>


  </body>
</html>
