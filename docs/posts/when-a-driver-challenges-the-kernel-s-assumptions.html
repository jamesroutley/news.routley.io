<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://miod.online.fr/software/openbsd/stories/udl.html">Original</a>
    <h1>When a driver challenges the kernel&#39;s assumptions</h1>
    
    <div id="readability-page-1" class="page"><div id="content">


<p>
Unix-based systems have been around for more than 50 years now. Although the
best design ideas still prevail to this day, the evolution of the computing
industry has forced operating system designers to rethink the way they work,
multiple times over time.

</p><p>
From a device driver point of view, the most important change was the change
from fixed, compile-time hardware configuration, enumerated upon boot and
never changing afterwards, to a more dynamic model, where devices can come and
go: storage devices first, with the first hotplug-capable SCSI controllers in
the first half of the 1990s, and complete devices shortly later, first with the
introduction of the PCMCIA bus on laptops, then with USB and Firewire, which
were not limited to laptops.

</p><p>
While PCMCIA support in open source operating systems had lingered for a few
years before being integrated (both in Linux with &#34;pcmcia-cs&#34; and in FreeBSD
with the &#34;laptop package&#34;), by the time USB support was being worked on,
the required changes to accept/allow that devices may show up or
disappear at any time had been completed and tested, and the kernel had no
excuse not to cope with removable devices.

</p><p>
Today&#39;s story is the story of a
<a href="https://man.openbsd.org/udl">device driver</a> which caused some kernel
assumptions to no longer stand, and the work done to remediate this situation,
letting the kernel cope with the new world order.

</p><hr/>

<p>
This story starts on the 12th of march 2009. <b>Theo de Raadt</b> is travelling
to Japan to visit fellow OpenBSD developer <b>Ryan McBride</b>, best known for
implementing the CARP network high-availability protocol in OpenBSD, who has
been living in Japan for a few years already.

</p><p>
Every time he goes to Japan, Theo never misses the opportunity to visit
Akihabara in Tokyo, in order to find new computing devices to play with.
 
</p><p>
Among the devices he picks this time, is a small display, the size of a
smartphone, with an usb cable, shown here running an X server under OpenBSD for
the first time, a few months later.
<i>(picture courtesy of Marcus Glocker)</i>
</p><p>
The company making these USB displays is called
<a href="https://web.archive.org/web/20090331070312/http://www.displaylink.com/">DisplayLink</a>.

</p><p>
DisplayLink provides binary-only drivers for Microsoft Windows and Apple Mac
OSX, and nothing more. This caused some frustration in the free software
world, and <b>Florian Echtler</b>, with the help of <b>Chris Hodges</b>,
worked on reverse engineering the device, with the intent to get it working
under Linux.
All of their work is nowadays described at
<a href="https://floe.butterbrot.org/matrix/hacking/dlnk/">https://floe.butterbrot.org/matrix/hacking/dlnk/</a>.

</p><p>
Of course, at this point, there is no support for these devices in OpenBSD
either, and they attach as generic USB devices when connected:

</p><div id="pre">
<pre>&lt;deraadt&gt; ugen0 at uhub0 port 3 &#34;DisplayLink LCD-8000U&#34; rev 2.00/0.02 addr 2
&lt;deraadt&gt; Picked up that too
</pre>
</div>

<p>
Moments later, <b>Matthieu Herrb</b> points to Florian Echtler&#39;s information:

</p><div id="pre">
<pre>&lt;matthieu&gt; &lt;http://floe.butterbrot.org/displaylink/doku.php&gt;
</pre>
</div><p>
(which nowadays redirects to <a href="https://github.com/floe/tubecable/tree/master/doc">https://github.com/floe/tubecable/tree/master/doc</a>)

</p><p>
The DisplayLink device gets passed from Theo de Raadt to developer <b>Claudio
Jeker</b>, who lives in Switzerland close to another developer who has been
recently working on USB devices, and will be the hero of this
story: <b><a href="https://nazgul.ch/dev_openbsd.html">Marcus Glocker</a></b>.

</p><p>
Once told he will be given the device, Marcus does what everyone in his place
would have done: he asks the manufacturer politely for documentation on april
6th.

</p><p>
There was no contact information at DisplayLink, only a &#34;contact us&#34; webform in
which you could enter your name and email address, and your message.

</p><div id="pre">
<pre>Name: Marcus Glocker
Message:
Dear Ladies and Gentleman,

We are thinking about developing an OpenSource driver for your
DL-120/DL-160 chipsets. This would allow several OpenSource projects
(e.g. NetBSD, FreeBSD, OpenBSD, Linux, X.org) to add support for
DisplayLink based USB LCD devices, and therefore extend your potential
user base.

Therefore we would like to talk with you about getting basic
documentation for your chipsets.

It would be nice if the right person for this topic could contact me for
further communication on the e-mail address stated in this form.

Regards,
Marcus Glocker, OpenBSD Developer
</pre>
</div>

<p>
The answer was as unhelpful as possible:

</p><div id="pre">
<pre>Date: Mon, 6 Apr 2009 12:49:42 +0100
From: Jason Slaughter (DisplayLink)
To: Marcus Glocker
Cc: Bernie Thompson (DisplayLink)
Subject: Opensource Driver for OpenBSD

Hello Marcus, thank you for your email.

DisplayLink USB graphics are a software graphics card: graphics
functions are performed on the CPU and then compressed and sent across
the USB cable to be decompressed in a DisplayLink DL-120/DL-160 chip on
the other side. This means that - unlike most PC hardware - getting
basic documentation about the chip would not provide enough information
to implement a driver for BSD.

However, DisplayLink is current in the process of putting together a
library that will provide the functions necessary to drive a DisplayLink
USB graphics chips, and it is our intention to release this library
under an open source license in the very near future. This library would
provide you with all of the information necessary to develop an x.org
compatible driver for DisplayLink USB graphics devices on *BSD.

The best point of contact for you might be Bernie Thompson (cc&#39;d), our
VP of Software Platforms based in Seattle, Washington. We could start
with a conversation on email, but Bernie and I would also be happy to
have a quick phone call with you to help you understand how DisplayLink
graphics work and what our plans are for supporting open source
platforms. I would also be curious to get your thoughts on how
DisplayLink device support might fit into BSD.

Thank you,

Jason
</pre>
</div>

<p>
At the same time, Marcus was sharing the results of this discussion with the
other OpenBSD developers on our private chatroom.

</p><div id="pre">
<pre>&lt;mglock&gt; wow.
&lt;kettenis&gt; wow?
&lt;mglock&gt; DisplayLink TM seems to be very communactive.
&lt;mglock&gt; asked the for specs for their DL-120/DL-160 chips, and got a detailed answer withing 4 hours.
&lt;mglock&gt; they want to call me :-)
&lt;oga&gt; they&#39;re actually responding?
&lt;oga&gt; wow...
&lt;oga&gt; I&#39;d heard they were quite reticent. Someone on the xorg lists is rev engineering them for that reason. Not so much progress so far
&lt;mglock&gt; interessting.
&lt;oga&gt; Well, i asked him if he was reverse engineering, he said yes. I&#39;m sure I asked if he&#39;d asked for docs, but the reply from him doesn&#39;t include that bit.
&lt;oga&gt; If you can get specifications freely, I&#39;d be interested in a copy
&lt;oga&gt; those things are pretty cool, in an oddball kinda way
&lt;mglock&gt; sure.  keep you informed.  lets see how far we come.
[...]
&lt;mglocker&gt; just wrote back to the DisplayLink guys.  lets see what happens.
</pre>
</div>

<p>
The day after:

</p><div id="pre">
<pre>&lt;mglocker&gt; re
&lt;mglocker&gt; got the DisplayLink device from claudio.
&lt;mglocker&gt; and an answer from DisplayLink themselfs.
&lt;mglocker&gt; we will get no docs.
&lt;kettenis&gt; bastards!
&lt;mglocker&gt; but the seem to release the opensource library soon.  based on libusb.
&lt;mglocker&gt; library will be LGPL licensed ...
</pre>
</div>

<p>
However, Marcus does not remain inactive waiting for a hypothetical code release
from DisplayLink. After weeks of trials, he reaches a point where he has a
terminal (text-mode emulation) running on it, albeit slowly, and talks about
it on may 1st, leading to a productive brainstorming session with a few other
OpenBSD developers:

</p><div id="pre">
<pre>&lt;mglocker&gt; hmm, looks bad for the USB display driver for wscons.  all that many little USB bulk transfers which are necessary to draw the fonts make the display rendering slow.
&lt;mglocker&gt; i think there is no way to improve it further.
&lt;oga&gt; mglocker: make a shadow area and blit the whole lot in one go
&lt;oga&gt; so make a line of text in one go the blit all of it
&lt;oga&gt; and use blits to move lines of text around for scrolling
&lt;mglocker&gt; nah, you need to be able to draw one character.
&lt;oga&gt; hmmm
&lt;oga&gt; did they release that library by the way?
&lt;deraadt&gt; there must be memory on the thing, to pre-load the fonts there
&lt;mglocker&gt; even if you preload the fonts, it doesn&#39;t help.  to bit blit one character you also need to setup a bulk xfer.
&lt;oga&gt; oh, offscreen memory if it has, then it&#39;s just blitting chars.
&lt;oga&gt; oh jesus.
&lt;mglocker&gt; it&#39;s the same amount of bulk xfers in the end.
&lt;mglocker&gt; yes, i tried exactly that.
&lt;oga&gt; how slow is slow?
&lt;mglocker&gt; it is exactly as slow as before.
&lt;oga&gt; I mean how slow is the output all told?
&lt;mglocker&gt; i think it&#39;s not the content of the bulk xfer making it slow, but the little peaces of bulk xfers.
&lt;mglocker&gt; ah.
&lt;mglocker&gt; on my amd64 it&#39;s like a 19200 modem connection or such :-)
&lt;deraadt&gt; how do they make it fast, then?
&lt;oga&gt; what info do you have on it?
&lt;drahn&gt; can multiple &#39;blits&#39; be combined?
&lt;oga&gt; all I heard about was some libarary that they will release, and the reveng stuff
&lt;sthen&gt; if you have a shadow buffer, can&#39;t you update multiple chars in one go?
&lt;mglocker&gt; you could.  but then i would need to &#34;collect&#34; lines?
&lt;sthen&gt; yep.
&lt;mglocker&gt; shudder.
&lt;mglocker&gt; sounds ugly.
&lt;oga&gt; welcome to graphics, mate.
&lt;mglocker&gt; heh
&lt;mglocker&gt; i think i quit that area ;-)
&lt;drahn&gt; a timeout to gather up several or polling waiting for the previous one to complete?
&lt;oga&gt; what information do you have on the hardware itself?
&lt;mglocker&gt; http://floe.butterbrot.org/displaylink/doku.php
&lt;mglocker&gt; that&#39;s what we have.
&lt;oga&gt; oh, that&#39;s the reveng stuff?
&lt;oga&gt; yeah, seen it.
&lt;mglocker&gt; there is compression, which doesn&#39;t seem to work yet.  but i&#39;m not sure if the compression stuff would help us for wscons.
&lt;mglocker&gt; since again, you need to setup a bulk xfer for each character.
&lt;oga&gt; good for bulk data moves. less good for char-by-char
&lt;mglocker&gt; and the thing which make it slow seems to be the setup overhead, not the content itself.
&lt;mglocker&gt; yes.
&lt;mglocker&gt; i don&#39;t know how the driver on windows works, but i don&#39;t guess they do something like char-by-char, as we do for wscons.
&lt;oga&gt; is this a problem for scrolling, or for typing?
&lt;oga&gt; scrolling you can coalesce as long as the timeout is short.
&lt;mglocker&gt; the scrolling seems fine.
&lt;oga&gt; and it&#39;d be a LOT better than char-by-char.
&lt;oga&gt; so it&#39;s just typing?
&lt;mglocker&gt; the problem is for rendering the chars.  e.g. &#34;ls -l&#34;.
&lt;oga&gt; if you put a timeout say (out of my arse) 10ms. all chars that come in then go out at the same time
&lt;oga&gt; no one types that fast, so you see char by char, but ls gets done in one go
&lt;mglocker&gt; that would help for sure.
&lt;oga&gt; try that. one transfer per char is not going to help you
&lt;mglocker&gt; the question is how to implement this in a nice manner ... sigh.
&lt;oga&gt; several ways present themselves
&lt;oga&gt; font in offscreen memory, when you get a char make blit command for that char to where you want it. multi commands in one bulkt transfer (which is apparently ok)
&lt;mglocker&gt; and then send it after the timeout is done (if there is something)?
&lt;oga&gt; when the timeout fires, launch off all you&#39;ve got
&lt;oga&gt; exactly
&lt;oga&gt; just queue up commands and put htem all in one bulk
&lt;oga&gt; the timeout will need tuning to be a good average between latency and bandwidth though
&lt;drahn&gt; scrolls are a bit extra info in the queue
&lt;mglocker&gt; putting them in one bulk would improve it for sure.
&lt;oga&gt; give it a try, and mail me the diff so I can see what you&#39;re doing
&lt;oga&gt; i&#39;m curious, even though I don&#39;t understand the usb stack at all
&lt;mglocker&gt; the usb part is not difficult for this device, really.
&lt;oga&gt; oh good. means I might get it.
&lt;mglocker&gt; &#34;ls -l /etc&#34; takes about 5 seconds now to render.  that&#39;s not nice ...
&lt;mglocker&gt; ok, thanks for the hints.  maybe i can get something together which helps ...
&lt;oga&gt; for wsfb you&#39;ll want to provide a mmap area and sync that as well. that will suck though
&lt;oga&gt; horribly
&lt;oga&gt; it&#39;ll need a proper driver to be usabel for X
&lt;mglocker&gt; yes.  there are different opinions for the X driver.
&lt;mglocker&gt; some say, use wsfb, some say you need to write a own accel driver for X :-)
&lt;oga&gt; wsfb iirc mmaps the framebuffer, so you&#39;d need to shadow it and update every X times a second
&lt;oga&gt; you&#39;d need the compression at least for it to not suck
&lt;mglocker&gt; exactly.
&lt;mglocker&gt; jup.  and the compression part is missing from the rev. eng. as it looks.
&lt;oga&gt; it&#39;d help to know more about the hardware it really would
&lt;oga&gt; without compression wsfb will be FAR too slow
&lt;mglocker&gt; i believe so, too, now.
&lt;oga&gt; no mmap over usb :(
&lt;mglocker&gt; no way.
&lt;miod&gt; mglocker: can&#39;t you copy the font image to offscreen video memory and do screen-to-screen blt to display chars?
&lt;miod&gt; that&#39;s the canonical trick.
&lt;oga&gt; that was my suggestion, with batching to keep from too many bulks.
&lt;miod&gt; ah
&lt;mglocker&gt; miod: i thought about that, too, but the bulk xfers keep the same.
&lt;miod&gt; (not caught up with logs yet)
&lt;mglocker&gt; one per bitblit.
&lt;mglocker&gt; i&#39;ve even tested it.
&lt;mglocker&gt; it doesn&#39;t help at all.  it&#39;s exactly as slow as before.
&lt;miod&gt; can you queue the xfers and schedule a batch of them 25 times per second?
&lt;deraadt&gt; you can only request one blt per bulk?
&lt;oga&gt; the rev eng says you can do more, hence the batching
&lt;deraadt&gt; sounds like a retarded protocol if you can only do one blt per bulk
&lt;mglocker&gt; miod: that&#39;s what oga suggested.
&lt;mglocker&gt; yes you can queue more than one bitblit.
&lt;mglocker&gt; but that would be i would need to &#34;collect&#34; chars.  what oga said.
&lt;mglocker&gt; and fire them on a timeout.
</pre>
</div>

<p>
After going back to the drawing board, the driver performance improves, and it
becomes worth commiting to the OpenBSD source code repository, so that people
can try it and developers can work on improving it.

</p><p>
The
<a href="https://github.com/openbsd/src/commit/c197399b252cb241ef20f393eb34bd395fb76b66">first stab of a driver</a> hits the tree on may 9th.

</p><p>
Three days later, possibly related to that commit, but we&#39;ll never know...

</p><div id="pre">
<pre>Date: Tue, 12 May 2009 20:08:44 +0100
From: Jason Slaughter (DisplayLink)
To: Marcus Glocker
Cc: Bernie Thompson (DisplayLink)

Hello Marcus,

Just an update on this: our source code library will be going live this
Friday and you&#39;ll be able to find it by going to http://displaylink.org
around Friday afternoon.

We would be happy to send you a few DL-160 based USB to DVI graphics
adapters if you think you would get good use out of them. If so, let me
know how many you&#39;d like and send me your mailing address. With any luck
they&#39;ll get to you before the code goes live on displaylink.org.

Thank you,

Jason
</pre>
</div><p>

which leads to this conversation at OpenBSD headquarters:

</p><div id="pre">
<pre>&lt;mglocker&gt; oho.  DisplayLink is answering again.
&lt;deraadt&gt; heh
&lt;mglocker&gt; the will release the opensource driver this friday.
&lt;mglocker&gt; and they want to send me DL-160 based USB to DVI graphic adapters.
&lt;oga&gt; the library you mean?
&lt;mglocker&gt; jup.
&lt;oga&gt; i&#39;m sure i found a dl-160 going for 50 quid on amazon the other day
&lt;oga&gt; out of stock though
&lt;mglocker&gt; so, who wants to have such a toy?
&lt;oga&gt; I&#39;d love one.
&lt;mglocker&gt; ok, one for you, one for me, anyone else?
&lt;mglocker&gt; Florian Echtler will be glad to hear this.
&lt;mglocker&gt; because the compression stuff is hard to crack.
&lt;oga&gt; I wonder how complete the library will be
&lt;oga&gt; what license, by the way?
&lt;mglocker&gt; pretty complete i hope ;-)
&lt;oga&gt; hope is definitely the word.
&lt;mglocker&gt; they wrote me about the license.  some GPL shiz if i remember right ...
&lt;oga&gt; well it&#39;s a libusb library anyway, so it&#39;ll want a rewrite
&lt;oga&gt; GPL? if they&#39;re targetting X then they should know X uses MIT.
&lt;mglocker&gt; *shrug*
&lt;mglocker&gt; after the last conversation i don&#39;t know how much they really know about X ...
&lt;mglocker&gt; probably they put the library out and hope somebody will write the X driver for them ...
&lt;oga&gt; time permitting i&#39;ll probably write one
&lt;oga&gt; it&#39;ll be either drm or wscons based depending on what I learn about the hardware
&lt;oga&gt; s/wscons/wsfb-style
&lt;mglocker&gt; oga: if you going to start on the X driver, we should sync with Florian maybe.  it would be probably good if not three people start to write on the X driver when the library has been released I guess ...
&lt;oga&gt; yeah.
&lt;oga&gt; if we&#39;re doing stuff with wscons for the driver though, then it won&#39;t work on linux.
&lt;oga&gt; I don&#39;t know how fbdev works.
&lt;mglocker&gt; and he started some sourceforge page today, to find out about the compression stuff more :-)  i&#39;ll forward him the mail from displaylink now.
</pre>
</div>

<p>
Three more days pass, and indeed, on may 15th...

</p><div id="pre">
<pre>&lt;mglock&gt; re
&lt;mglock&gt; http://www.freedesktop.org/wiki/Software/libdlo
&lt;mglock&gt; the library is online.
&lt;mglock&gt; read first feedback from the displaylink rev. eng. mailling-list.
&lt;mglock&gt; it seems to be useless.
&lt;mglock&gt; since the whole compression stuff is missing.
&lt;mglock&gt; need to look at it myself later.
</pre>
</div><p>
(the libdlo url is now <a href="https://libdlo.freedesktop.org/wiki/">https://libdlo.freedesktop.org/wiki/</a></p><a>)

<p>
5 hours later:

</p><div id="pre">
<pre>&lt;oga&gt; mglock: displaylink rev. eng have a mailing list?
&lt;oga&gt; where?
&lt;mglock&gt; erm, yes.
&lt;mglock&gt; https://lists.sourceforge.net/lists/listinfo/displaylink-devel
&lt;oga&gt; mglock: thanks
&lt;oga&gt; hmmm, glancing at the library it is not that useful
&lt;oga&gt; disappointing
</pre>
</div>

<p>
2 hours later:

</p><div id="pre">
<pre>&lt;oga&gt; mein gott! libdlo is ugly
&lt;oga&gt; ERR_GOTO(function(args)) ...
</pre>
</div>

<p>
and 2 more hours later:

</p><div id="pre">
<pre>&lt;mglocker&gt; i&#39;ve setup another mail to displaylink asking them why they didn&#39;t include the compression stuff in their library :-)
</pre>
</div>

<p>
On the same day, on the displaylink-devel list:

</p><div id="pre">
<pre>Date: 2009-05-15 13:59:30
From: Florian Echtler
To: displaylink-devel mailing list
Subject: Re: [Displaylink-devel] News from Displaylink

&gt; Sigh, pretty disappointing.  LGPL licensed first and then it doesn&#39;t
&gt; contain the compression stuff.  What do the think how people can
&gt; write an usable X.Org driver with this?  I gonna ask them.
All right, this is getting a bit ridiculous. Looking in dlo_usb.c, they
labeled the &#34;set encryption&#34; request as &#34;select channel&#34;, and the
&#34;null-key&#34; for disabling encryption is called STD_CHANNEL. Okay, maybe
just terminology.

However, in dlo_data.h, there&#39;s suddenly always an DLO_MODE_ENABLE_*
sequence (never seen that before), and the DLO_MODE_DATA stuff looks
totally random. Hey, look, in mode_select(), it&#39;s always sending the
ENABLE sequence to the &#34;select channel&#34; command, then the binary blob
and then DLO_MODE_POSTAMBLE. Hmm, this POSTAMBLE looks just like the
STD_CHANNEL default key! Oh, what a surprise, the register sets for the
modes are _still_ encrypted - never mind that we can decrypt this since
Christmas last year.

Displaylink, I really don&#39;t get this. I&#39;ll have a closer look at the way
the stride registers are implemented; this is one of the smaller parts
which I still would like to figure out, but in general, this library is
absolutely useless to the wider opensource community. It&#39;s obviously
designed for some embedded shops which want to use it for non-realtime
stuff like LCD signs etc., <b>but it&#39;s just ridiculous to still try and
obfuscate parts of an opensource library.</b>

Florian
-- 
0666 - Filemode of the Beast
</pre>
</div>
(emphasis mine)

<p>
Two more weeks pass, during which Florian Echtler continues his reverse
engineering efforts and figures out the compression scheme used by the
DisplayLink chip.

</p><div id="pre">
<pre>&lt;mglocker&gt; for those who are interessted in the displaylink stuff ... the compression has been cracked.  florian echtler did a library and showed it to the displaylink guys ;-)
&lt;mglocker&gt; http://lists.freedesktop.org/archives/libdlo/2009-May/000092.html
&lt;mglocker&gt; http://floe.butterbrot.org/external/tubecable-0.1.tar.bz2
&lt;mglocker&gt; ~mglocker/dldemo2_mglocker.tar.gz
&lt;mglocker&gt; if you want to have a kind of C-style demo for the compression.
</pre>
</div>

<p>
Minor fixes to the udl driver occur on june 1st, then there is not much
activity until Marcus resumes working on it, in order to add compression
support.

</p><p>
On august 14th, he mentions the need for a compression table which could be
stored on the filesystem, rather than in the kernel image:

</p><div id="pre">
<pre>&lt;mglocker&gt; anyone mind if we would keep a 300kB huffman table in /etc/firmware? 
&lt;miod&gt; that&#39;s not really firmware... can&#39;t you generate the table at runtime? is this for udl evilness?
&lt;mglocker&gt; jup, for the huffman pixel difference compression.  i could store the table into an *.h file, but i&#39;m not sure if this is what we want.
&lt;mglocker&gt; i don&#39;t think we can &#34;generate&#34; the table.
&lt;miod&gt; but yes, although it&#39;s not technically firmware, it&#39;s loadable data, so why not
&lt;mglocker&gt; yeah.  it&#39;s probably worth an exception in that case. 
&lt;mglocker&gt; i can draw some compressed stuff already, but some issues left to fix.
</pre>
</div>

</a><p><a>
And on august 25th,
</a><a href="https://github.com/openbsd/src/commit/2fa8dc63a726975bf998789c994a878960127963">compression support</a>
is added to the driver.

</p><p>
As more and more developers are trying the driver on as many platforms as
possible, we start hitting situations where heavy screen adjustments would
cause the output to stall, or some display updates to get lost.

</p><p>
Investigating these showed that the device was overflowed with requests, and
needed time to process all the pending operations until further requests could
be made.

</p><p>
This was not very different from a serial line link, where the serial chip has
a small (and sometimes nonexistent) FIFO queue, and no more characters can be
transmitted when it gets full, until the characters get transmitted over the
wire.

</p><p>
For serial links, the kernel handles this nicely, by forcing writers to sleep
when the FIFO gets full, and waking them when space becomes available in the
FIFO.

</p><p>
But for display terminal emulations, there was no such thing, because it was
assumed that every display operation (output a character, draw the cursor shape,
scroll the display in any direction) could be done without having to wait.

</p><p>
And in fact, until the DisplayLink driver came into use, this was the case:
display drivers either had full access to the display memory and could do the
required changes directly in memory or, as e.g. for the
<a href="https://www.openbsd.org/vax.html">Vax</a>
<a href="https://man.openbsd.org/OpenBSD-5.9/vax/gpx">gpx</a> driver
[which I will write the story of soon...], by instructing the graphics
controller to perform these changes.

</p><p>
But here, over the USB bus, bandwidth has to be shared with all the other USB
devices on the controller, and the USB controller itself might not be able to
queue enough requests for the udl needs - in other words, this is similar to
the serial FIFO.

</p><p>
The graphics display being, from the kernel point of view, a special case of
serial line, we could benefit from the FIFO behaviour, even though this had
never been the case.

</p><p>
So a cheap and easy way to solve the &#34;display gets overflowed with requests&#34;
problem would be to simply let the display operation routines (draw the cursor,
paint a character...), which until now where `void` operations, return a value
letting their caller know whether they had been able to perform the requested
operation or not. The DisplayLink specific implementation of these requests
could then return failure when the device FIFO is full, and let the upper
layers know that they need to wait and force the process currently writing
to the display, to sleep.

</p><p>
This would be a large, but mostly mechanical, change to all the display drivers
in the OpenBSD source tree.

</p><p>
On august 30th, I suggested going in this direction:

</p><div id="pre">
<pre>Date: Sun, 30 Aug 2009 20:42:29 +0000
From: Miod Vallat
To: private mailing list
Subject: wsdisplay asynchronous processing
    
After discussing udl(4) behaviour with mglocker@, we came to the
following thoughts which I believe are worth sharing.
    
wscons - and its wsdisplay output part - has been written 10 years ago
with tga(4) and vga(4) style bitmapped devices in mind, with synchronous
operations.
    
This assumption was true, until we started to support video devices on
which the video memory is not directly accessible. Examples of this are
cfxga(4), gpx(4) on vax, and udl(4).
    
The first two such drivers have been coerced to fit the synchronous
model, because sending commands to the hardware was fast and did only
involve the device registers.
    
udl(4), however, is completely alien to this. Commands are sent with USB   
pipes, there might be other devices on the USB bus, and processing is
asynchronous in nature.
    
    
    
Now, if you look at wsdisplay, there are two conditions upon which
wsdisplay will want to update the display contents:
- userland writes to the wsdisplay terminal. wsdisplay is invoked from 
  the tty layer, and has a process context, so it can sleep.
- kernel writes to the console device. wsdisplay can not assume
  anything.
    
So if we are able to flag devices such as udl(4) as not being able to be
a console output device, then it will know that it can sleep at the
wsdisplay level.
    
    
    
Why am I talking about sleeping? Because udl(4) is currently the only
wsdisplay(4) driver unable to behave synchronously. In order to complete
its operation, it needs to get fifo resources and whatnot, and if none
of them are available, there won&#39;t be any new resources available until
the usb stack has a chance to run: udl(4) needs to sleep.
    
Now if udl(4) is allowed to sleep, and the driver&lt;-&gt;wsdisplay interfaces
are modified so that a driver can return <tt>EAGAIN</tt> if it is not a console
device, then wsdisplay(4) can sleep. Problem solved.
</pre>
</div>

<p>
and since the best way to figure out if such a proposal is worth doing is to
write a proof-of-concept, the next day I shared a diff with Marcus.

</p><p>
But that diff was larger and trickier that what my previous message implied.

</p><p>
The reason for that, is that the graphics terminal is not simply a &#34;line printer
on a CRT&#34;.
<i>(and, writing this in 2025, I suppose some of my younger readers will not be
familiar with
<a href="https://en.wikipedia.org/wiki/Cathode_ray_tube">Cathode Ray Tube</a>
displays)</i>

</p><p>
An important improvement of CRT displays above line printers is that most CRT
terminals have an addressable cursor position; this opens the road towards
fancy displays (nowadays with colours!), first to implement
<a href="https://en.wikipedia.org/wiki/3270_emulator">IBM 3270 terminal
emulators</a>, later for more generic needs, thanks to the
<a href="https://man.openbsd.org/man5/termcap.5">termcap</a> and/or
<a href="https://man.openbsd.org/terminfo.5">terminfo</a> abstractions,
and eventually the
<a href="https://man.openbsd.org/curses">curses</a> library.

</p><p>
The OpenBSD workstation console terminal emulation tries to mimic two well-known
console devices, the
<a href="https://en.wikipedia.org/wiki/VT220">Digital VT220 terminal</a>
(minus several seldom used features difficult to implement cleanly,
such as double-width characters) on most platforms, and the Sun console
(with extra features such as colour) on
<a href="https://www.openbsd.org/sparc.html">sparc</a> and
<a href="https://www.openbsd.org/sparc64.html">sparc64</a> ports.
(I tried to have the
<a href="https://www.openbsd.org/luna88k.html">luna88k</a> port, which
defaults to black on white display like the Sun systems,
to use the sun terminal emulation, but got outpowered).

</p><p>
Both these terminal emulations have in common that they recognize specific
escape sequences, e.g. to change the cursor position, change output colours, or
other specific operations. Also, simply outputting a regular character expands
to at least three display operations: hide the cursor, draw the character, and
draw the cursor in its new position; and if the character had been the last on
the last line, the display needs to scroll, which involves one more operation.

</p><p>
If display drivers were able to fail any operations, as allowed in my proposal,
we could end up with a particular output operation processed only partly.
But the tty layer in the kernel has no way to know that a character has been,
sort of, &#34;partially output&#34;. In this layer, a character has either been output,
or needs to be output, and nothing in-between. Any finer-grained state needs to
be maintained in a lower layer, such as the vt220 emulation code.

</p><p>
So, in addition to allowing display drivers to fail operations, I wrapped the
terminal emulation processing into what I called an &#34;abort state&#34;, remembering
at which point we encountered a failure, so that attempting to output a
character would skip the operations which had succeeded already.

</p><p>
With my changes, a character output would only be &#34;validated&#34; if all the display
operations it would cause had been successful. If not, the process writing to
the display would be forced to sleep, until the display driver reports it is
able to process requests again. Processing of the display operations would note
which operations had been successful, so as to skip them and only perform the
operations which had failed or had no chance to start earlier.

</p><div id="pre">
<pre>Date: Mon, 31 Aug 2009 22:00:27 +0000
From: Miod Vallat
To: Marcus Glocker
Subject: early wscons `ok to stall&#39; diff
   
This should be enough for an i386 or amd64 kernel to compile. Many frame
buffer drivers still need to be modified due to interface and prototypes
changes.
   
How does it work? Well, this adds an error path from the display driver
to the tty layer.
   
So we have this path:
   
1. void wsdisplay_emulops routines now return values. The driver
   implementing them can return 0 if it did the work, or nonzero
   (preferrably EAGAIN) if it couldn&#39;t. Note that generic rasops
   routines, accessing frame buffer memory, never fail and always return   
   zero.
   
2. the return values of the emulops are now tested in the wsdisplay
   emulation code. This is the horrible part with a lot of changes,
   which will need careful review.
   
3. I designed this so that, when the emulops return an error, the emulation
   state machine is moved back to a sane state, allowing the operation
   to be tried again later. This involves undoing logical cursor moves,
   and other internal state changes.
   
   Note the code currently assumes an operation involving several emulops
   can fail in the middle and be restarted from the beginning - this is
   wrong, e.g. when scrolling the tty, since we copy rows and then clear
   the bottom row. If the copy works but the clearing fails, we&#39;ll
   restart with the copy.
   
   I am aware of this and working on an `abort state&#39; part of the
   emulation state machine (which is currently the FALSE_ABORT bit in  
   the per-emulation flags, but needs to move into its own thing).
   
   (This is why this is an alpha diff...)
   
4. The error condition detected by the emulation causes the tty write to
   abort early. The MI wsdisplay code will now know how many chars have  
   been processed, and if it detected an early abort, it will not try to
   write more characters, even if there are any left in the tty queue.
   
5. The same function already has logic to schedule a timeout if more
   tty data is pending. This timeout will try to feed the driver more
   work, but until it fires the driver can hopefully get some interrupts
   and gather resources to do so.
   
What is left to do:
   
1. Update all MD frame buffer drivers (mechanical).
   
2. Finish the abort state design and correctly recover from a partial
   operation.

3. Update udl to return EAGAIN in the emulops.

Known problems which won&#39;t be fixed soon:

1. Some operations do not come from the tty layer, but by keyboard
   events (emulation reset sequence), ioctl or timeouts (screen burner).
   We do not necessarily have a process context there, so sleeping is   
   not an option.

   I need to extend some interfaces for the affected routines to know
   whether the caller can recover automatically (tty context), or not, 
   and if not, whether it&#39;s ok to sleep or not.
   
2. There is no way, yet, for the driver which has returned EAGAIN to
   cause the tty timeout to be triggered earlier (i.e. as soon as it
   regains resources). I&#39;ll think about it eventually.
   
Miod (and now time for some zzz)
</pre>
</div>

<p>
The next day, I received the best testimonial ever for a diff:

</p><div id="pre">
<pre>&lt;mglock&gt; hi from udl over wscons with initial EAGAIN support :-)
&lt;mglock&gt; miod is evil.
</pre>
</div>

<p>
After more testing, on september 1st, a new version of that diff was shared:

</p><div id="pre">
<pre>Date: Tue, 1 Sep 2009 20:19:02 +0000
From: Miod Vallat
To: private mailing list
Subject: Re: wsdisplay asynchronous processing

In case people are interested, I have a monster diff (which will be
split in 4 different pieces), which implements error path from the
display drivers up to the tty layer, so that the driver can cause tty
output to stop if it is overflowed.

The tty layer (well, the wsdisplay tty code) will then nicely recover
from this, and everything is fine.

This diff has the disavantage of adding about 1KB of code to the kernel
(for kernels with vt100 emulation), so this might be a problem for the
floppies. And there is no way to disable this if SMALL_KERNEL. Unless
you want to dive in your own sea of macro hell filled with sharks.

Due the large size of the diff (about 200KB, affecting 51 files), I will
not append it to this mail. People interested in it can find it in

cvs:~miod/wscons-stall2.vari

Note that, for it to be really useful on udl(4) devices - since they are
the reason for this work - you need another diff from mglocker@, adding
the necessary EAGAIN code in udl(4).

$ wc wscons-stall2.vari
    7017   26187  194603 wscons-stall2.vari

Miod
</pre>
</div>

<p>
The monster diff started with the following description:

</p><div id="pre">
<pre>This diff is large because many frame buffer drivers need to be modified due to
interface and prototype changes.
   
How does it work? Well, this adds an error path from the display driver
to the tty layer.
   
So we have this path:
   
1. void wsdisplay_emulops routines now return values. The driver
   implementing them can return 0 if it did the work, or nonzero
   (preferrably EAGAIN or EINTR) if it couldn&#39;t. Note that generic rasops
   routines, accessing frame buffer memory, never fail and always return
   zero.
   
2. the return values of the emulops are now tested in the wsdisplay
   emulation code. This is the horrible part with a lot of changes,
   which will need careful review.
   
3. I designed this so that, when the emulops return an error, the emulation
   state machine is moved back to a sane state, allowing the operation
   to be tried again later. This involves undoing logical cursor moves,
   and other internal state changes.

   Note there might be bugs in the undoing so far, I need to review this
   carefully. And test too (-:
   
   There are comments in wsemulvar.h trying to explain how I keep track
   of failures occuring in the middle of a `character&#39; (from the tty
   layer point of view) output.
   
4. The error condition detected by the emulation causes the tty write to
   abort early. The MI wsdisplay code will now know how many chars have
   been processed, and if it detected an early abort, it will not try to  
   write more characters, even if there are any left in the tty queue.
   
5. The same function already has logic to schedule a timeout if more
   tty data is pending. This timeout will try to feed the driver more
   work, but until it fires the driver can hopefully get some interrupts
   and gather resources to do so.
   
   Note that it is not necessary to implement a faster output resume path (e.g. 
   if the driver gets an interrupt and frees resources), as the timeout will run
   only 8ms later (1/128 second). Keep in mind the human persistance of vision
   is about 1/25 second, so in the blink of an eye the wsdisplay code can
   resume stalled output several times.

Problems left with this code:

1. You may notice resetop() does not check for emulops failure. This because
   this is an out-of-tty-layer processing (but ioctl issued to the tty device).
   I know how to make it able to recover, but this will need a few more emulops
   prototypes changes, and I would like to keep the focus of this diff minimal
   (har, har), i.e. trying to only address one problem. A later diff will
   address that area.
   
2. The same comments apply to the screen burner code. Again, I have plans for
   this.
   
How I intend to split this work in individual commits:

1. internal wsemul changes to change the state machine functions from
   returning u_int to returning void (and updating emul state structs
   directly), so that they can later be changed again to return errors.
   (no functional change, but little code growth)
   
2. emulops prototype changes (and all the rasops / driver part of this diff).
   (again, no functional change, but little code growth)

3. wsemul_ops change of output() to return the number of chars consumed, and
   the corresponding logic in wsdisplaystart(), with the emulation code  
   returning the number of chars it has been given
   (again, no functional change, but little code growth)
   
4. the error path handling in the emulation code, i.e. the evil part of this
   diff.
</pre>
</div>

<p>
Of course, testing exposed a few bugs in that diff, which led to a new version:

</p><div id="pre">
<pre>Date: Wed, 2 Sep 2009 16:17:06 +0000
From: Miod Vallat
To: private mailing list
Subject: Re: wsdisplay asynchronous processing

New diff fixing a few bugs in the previous diff (description of changes
at the head of the new diff).

cvs:~miod/wscons-stall3.vari

$ wc wscons-stall3.vari
    7074   26494  196861 wscons-stall23vari

Miod
</pre>
</div>

<p>
<i>And while writing this, I am dissatisfied with past me. It was not a wise
idea to put the details in a file which is now long gone, and I should have
put them both in the file and in the email. But I did not think that future me
would want to tell this story, years later.</i>

</p><p>
<i>
Fortunately, it turns out that I had sent that diff directly to Marcus minutes
later:</i>

</p><div id="pre">
<pre>Date: Wed, 2 Sep 2009 16:13:51 +0000
From: Miod Vallat
To: Marcus Glocker
Subject: latest wscons diff

This is diff #3.
Changes since last diff:
- rearrange changes to wsdisplaystart() so as not to introduce a new goto.
- minor simplification in wsemul_sun when backing out state changes because
  of failed scrollup operation.
- rearrange some double-wide array updates in vt100 to be able to correctly
  recover from operations aborted in the middle. This double width feature is
  something noone uses anyway.
- wrap the COPYCOLS and ERASECOLS operations in vt100 within WSEMULOP so that
  they will not be reissued by mistake if failure occurs after they&#39;re done.
  This ought to have been in the previous diff but I forgot to do this.
</pre>
</div>

<p>
And some time later:

</p><div id="pre">
<pre>Date: Thu, 3 Sep 2009 22:00:06 +0000
From: Miod Vallat
To: Marcus Glocker
Subject: Re: udl

Even better, with a diff that still compiles after the untested last
minute change.

This is diff #4.
Changes since last diff:
- removed udl.c changes, get them from mglocker@
- fixed an unitialized variable in wsemul_vt100_output() causing cursor
  image display to sometimes be skipped.
- extended the abort state with four different states (ok, failed to display
  the cursor image, failed to jump scroll, failed a regular operation) instead
  of two (ok/fail) and having the `fail cursor&#39; a particular state of failure.
  This allows me to make things a bit more clean (arguably) and two fix two
  important bugs:
  + after a regular failure, jump scroll would be attempted before the
    other operation; if the failure had happened after N operations we would
    then skip N operations during the jump scroll (usually causing the
    scroll not to happen, so lines would be overwritten instead of
    scrolling).
  + after a jump scroll failure, we need to retry it with the same number
    of lines as the failed operation, so that the copy/erase parts of the
    scrolling operation are consistent with each other.
</pre>
</div>

<p>
Eventually Marcus confirms it works:

</p><div id="pre">
<pre>From: Miod Vallat
To: Marcus Glocker
Subject: Re: udl

&gt; This diff works pretty fine for me!  I can&#39;t spot any bugs anymore yet,
&gt; even when running in a screen session with crazzy apps like irssi and
&gt; mutt.

Excellent.
</pre>
</div>

<p>
Having been able to wrap these operations in specfic macros to hide the
note-and-restart logic, this allowed installation media kernels (which would not
embed the DisplayLink driver) to use the previous &#34;nothing can fail&#34; logic, in
order not to grow these kernels and still allow them to fit on 3&#34;Â½ floppy
installation media.

This work eventually got commited on september 5th,
<a href="https://github.com/openbsd/src/commit/2b541da856699c3b1d730730df6cc39c8c4d0a42">in</a>
<a href="https://github.com/openbsd/src/commit/072953e3c89278fb6ae80e298ac40d5bd3f6e394">multiple</a>
<a href="https://github.com/openbsd/src/commit/0ba8d49cb814e83f28fa162a6bc07ea9a7d700db">steps</a>
and
<a href="https://github.com/openbsd/src/commit/345431b5cb528a4ba29ef930fa8b7784131ff6cc">then</a>
<a href="https://github.com/openbsd/src/commit/ae9d593cbfe550e923daa0a3eb694eb628de2158">some</a>...

</p><p>
...and udl made use of it
<a href="https://github.com/openbsd/src/commit/8c7540bbae17d285d3147ca5eddb883d929e2496">immediately</a>.

</p><p>
On september 11th, this allowed to nicely fix a
<a href="https://github.com/openbsd/src/commit/fc15257d66be80ee50687172bf0bd06f4d0d71b7">diresome situation</a>.

</p><p>
And since I am only human, a
<a href="https://github.com/openbsd/src/commit/95ca511cdf8bd172a0789d83d2c5dc6b1974fd15">small bugfix</a>
was needed on the 14th.

</p><p>
After these changes, there have been no problem reports with DisplayLink
devices.

</p><p>
Later this month, an X server, based upon the &#34;damage&#34; extension which describes
areas which need to be redrawn, was also added to the OpenBSD source tree, and
support for the DisplayLink devices was now complete.

</p><p>
This allowed &#34;serial console-only&#34; platforms such as the
<a href="https://www.openbsd.org/armish.html">armish</a>
and
<a href="https://www.openbsd.org/landisk.html">landisk</a>
ports to use a graphics console and run an X server.

</p><p>
And even if there had been no X server support, the DisplayLink driver forced
the console code to face new challenges and solve them in a way which will
benefit future drivers.

</p><hr/>

<p>
Today, DisplayLink still exists as part of
<a href="https://www.synaptics.com/products/displaylink-graphics">Synaptics</a>,
and their most recent chips are supported neither by Linux nor by OpenBSD with
open source drivers. Synpatics provides a binary driver for Ubuntu, which to
this day hasn&#39;t been reverse engineered, yet.

</p><p>
The usefulness of these devices has apparently gone away, people do not seem to
be interested by these devices anymore those days.
</p></div></div>
  </body>
</html>
