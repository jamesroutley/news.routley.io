<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/lattice-bitset/?utm_source=rss">Original</a>
    <h1>Representing type lattices compactly</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>The Cinder JIT compiler does some cool stuff with how they represent types so
I’m going to share it with you here. The core of it is thinking about types as
<em>sets</em> (lattices, even), and picking a compact representation. Compilers will
create and manipulate types with abandon, so all operations have to be fast.</p>

<p>We’ll start from first principles, assuming we’re analyzing a language like
Python, and build our way up to roughly what Cinder has (and we could go
further from there).</p>

<p>Note that this post is about a <em>compiler internal</em> view of SSA value types and
nothing to do with surface level type annotations. We’ll use Python code
snippets (as if they were IR) to sketch ideas, though.</p>

<h2 id="types-as-sets">Types as sets</h2>

<p>Types, as a concept, name sets of objects—sets of instances. Some types (say,
<code>int8</code>) have finite members. There are only ever 256 potential values for an
8-bit integer. Some times, (say, <code>list</code>) are infinite. Given enough storage,
one could keep generating bigger and bigger instances. Since it’s not possible
to store all elements of a set, we refer to types by a name.</p>

<p>This reduces precision. Maybe there is some bizarre case where you know that
an object could be one of a thousand different possible <code>list</code>s, so giving up
and saying “it’s a <code>list</code>” loses information. But it also saves a bunch of
space and analysis time, because now we’re dealing with very small labels.
Let’s start off by giving a couple built-in types names and calling it a day.</p>

<h2 id="starting-simple">Starting simple</h2>

<p>A reasonable first way to give types names is with an enum:</p>

<div><div><pre><code><span>enum</span> <span>{</span>
    <span>Int</span><span>,</span>
    <span>List</span><span>,</span>
    <span>String</span><span>,</span>
    <span>Object</span><span>,</span>  <span>// catch-all</span>
<span>};</span>
</code></pre></div></div>

<p>Not bad. We can represent some built-in types and we have a catch-all case to
use when we don’t know what type something is or the type doesn’t fit neatly
into our enum (<code>Object</code>), which captures the <code>object</code> type and all of its
subclasses.</p>

<p>Using this enum, we can assign types to variables (for the purposes of this
post, SSA values) and use those types to optimize. For example, we might see
the following pseudo-Python snippet:</p>



<p>If we know that the type of <code>a</code> is <code>List</code>, we can optimize the call to
<code>len</code><sup id="fnref:redefining-len" role="doc-noteref"><a href="#fn:redefining-len" rel="footnote">1</a></sup> to a direct call to the <code>list</code> class’s <code>__len__</code> method,
or—even better, since we know about CPython’s runtime details—read the
<code>ob_size</code> field directly off the object.</p>

<p>That’s great! It will catch a bunch of real-world cases and speed up code.
Unfortunately, it gives up a little too easily. Consider some silly-ish code
that either assigns a <code>str</code> or a <code>list</code> depending on some condition:</p>

<div><div><pre><code><span>def</span> <span>foo</span><span>(</span><span>cond</span><span>):</span>
    <span>if</span> <span>cond</span><span>:</span>
        <span>a</span> <span>=</span> <span>&#34;...&#34;</span>
    <span>else</span><span>:</span>
        <span>a</span> <span>=</span> <span>[...]</span>
    <span>return</span> <span>len</span><span>(</span><span>a</span><span>)</span>
</code></pre></div></div>

<p>Because <code>a</code> could have either type, we have to union the type information we
know into a more general type. Since we don’t have  <code>ListOrString</code> case in our
enum (nor should we), we have to pick something more general: <code>Object</code>.</p>

<p>That’s a bummer, because we as runtime implementors know that both <code>str</code> and
<code>list</code> have <code>__len__</code> methods that just read the <code>ob_size</code> field. Now that we
have lost so much information in the type union, we have to do a very generic
call to the <code>len</code> function.</p>

<p>To get around this, we can turn the straightforward enum into a <em>bitset</em>.</p>

<h2 id="bitsets">Bitsets</h2>

<p>Bitsets encode set information by assigning each bit in some number (say, a
64-bit word) a value. If that bit is 1, the value is in the set. Otherwise, it
isn’t.</p>

<p>Here’s the enum from earlier, remade as a bitset:</p>

<div><div><pre><code><span>enum</span> <span>{</span>
    <span>Int</span>    <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>0</span><span>,</span>  <span>// 0b001</span>
    <span>List</span>   <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>1</span><span>,</span>  <span>// 0b010</span>
    <span>String</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>2</span><span>,</span>  <span>// 0b100</span>
    <span>Object</span> <span>=</span> <span>7</span><span>,</span>       <span>// 0b111; catch-all</span>
<span>};</span>
</code></pre></div></div>

<p>We have three elements: <code>Int</code>, <code>List</code>, and <code>String</code>. Since we have a bit for
each object and they can be addressed individually, we can very
straightforwardly encode the <code>ListOrString</code> type using bitwise arithmetic:</p>



<p>It doesn’t even need to be a basic type in our enum. We can construct it using
our built-in building blocks.</p>

<p>We have also set our unknown/catch-all/<code>Object</code> type as the value with <em>all</em>
bits set, so that if we <em>or</em> together all of our known types
(<code>Int|List|String</code>), the unknown-ness falls out naturally.</p>

<p>…but what does the unnamed 0 value represent? If we are thinking in terms of
sets still (which we should be), then 0 means no bits set, which means it
represents 0 elements, which means it’s the empty set!</p>

<p>We’re starting to approach a very useful mathematical structure called a
<em>semilattice</em>.</p>

<h2 id="semilattices">Semilattices</h2>

<p>I’m not going to quote you any formal definitions because I’m not very mathy.
I’ll give you a one sentence abstract sounding definition and then make it
concrete very soon after.</p>

<p>A <em>semilattice</em> is a partial (not total) order of a set with a <em>join</em>
operation. The lattice also has a top element and a bottom element. Ok, let’s
talk about what that means for us.</p>

<p>For our limited type data structure, our partial order is determined by set
membership and our <em>join</em> is set union. Top represents “all possible objects”
and bottom represents “no objects”:</p>

<ul>
  <li>bottom is less than every other set, because it has no elements</li>
  <li>int, list, and string are not ordered amongst themselves because none of them
is a superset of any of the others</li>
  <li>top (object) is greater than every set, because it has all elements</li>
</ul>

<p>Check out this handy diagram of our original enum-based type lattice:</p>

<!--
digraph G {
    rankdir="BT";
    int -> any;
    str -> any;
    list -> any;

    any [label="Object/Top/Any"];
    int [label="Int"];
    str [label="String"];
    list[label="List"];
}
-->

<figure>
<svg width="222pt" height="116pt" viewBox="0.00 0.00 222.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 112)">
<title>G</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-112 218,-112 218,4 -4,4"></polygon>
<!-- int -->
<g id="node1">
<title>int</title>
<ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00">Int</text>
</g>
<!-- any -->
<g id="node2">
<title>any</title>
<ellipse fill="none" stroke="black" cx="107" cy="-90" rx="74.33" ry="18"></ellipse>
<text text-anchor="middle" x="107" y="-85.8" font-family="Times,serif" font-size="14.00">Object/Top/Any</text>
</g>
<!-- int->any -->
<g id="edge1">
<title>int-&gt;any</title>
<path fill="none" stroke="black" d="M42.81,-32.83C53.21,-41.94 67.12,-54.1 79.33,-64.79"></path>
<polygon fill="black" stroke="black" points="76.87,-67.29 86.7,-71.24 81.48,-62.02 76.87,-67.29"></polygon>
</g>
<!-- str -->
<g id="node3">
<title>str</title>
<ellipse fill="none" stroke="black" cx="107" cy="-18" rx="34.65" ry="18"></ellipse>
<text text-anchor="middle" x="107" y="-13.8" font-family="Times,serif" font-size="14.00">String</text>
</g>
<!-- str->any -->
<g id="edge2">
<title>str-&gt;any</title>
<path fill="none" stroke="black" d="M107,-36.3C107,-43.59 107,-52.27 107,-60.46"></path>
<polygon fill="black" stroke="black" points="103.5,-60.38 107,-70.38 110.5,-60.38 103.5,-60.38"></polygon>
</g>
<!-- list -->
<g id="node4">
<title>list</title>
<ellipse fill="none" stroke="black" cx="187" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="187" y="-13.8" font-family="Times,serif" font-size="14.00">List</text>
</g>
<!-- list->any -->
<g id="edge3">
<title>list-&gt;any</title>
<path fill="none" stroke="black" d="M171.19,-32.83C160.79,-41.94 146.88,-54.1 134.67,-64.79"></path>
<polygon fill="black" stroke="black" points="132.52,-62.02 127.3,-71.24 137.13,-67.29 132.52,-62.02"></polygon>
</g>
</g>
</svg>
</figure>

<p>The arrows indicate that applying a <em>join</em> will only ever move us upward along
an arrow.  For example, <code>join(Int, String)</code> is <code>Top</code> (we don’t have any
finer-grained way to represent all ints and all strings).</p>

<p>Compare this with, for example, what we can represent with our bitset type
representation:</p>

<!--
digraph G {
    rankdir="BT";
    empty -> list;
    empty -> str;
    empty -> int;

    int -> int_str;
    int -> int_list;
    str -> int_str;
    str -> str_list;
    list -> int_list;
    list -> str_list;

    int_str -> any;
    int_list -> any;
    str_list -> any;

    empty [label="Bottom/Empty"];
    int_str [label="Int|String"];
    int_list [label="Int|List"];
    str_list [label="String|List"];
    any [label="Object/Top/Any"];
    int [label="Int"];
    str [label="String"];
    list[label="List"];
}
-->

<figure>
<svg width="386pt" height="260pt" viewBox="0.00 0.00 385.53 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 256)">
<title>G</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-256 381.53,-256 381.53,4 -4,4"></polygon>
<!-- empty -->
<g id="node1">
<title>empty</title>
<ellipse fill="none" stroke="black" cx="199.92" cy="-18" rx="68.45" ry="18"></ellipse>
<text text-anchor="middle" x="199.92" y="-13.8" font-family="Times,serif" font-size="14.00">Bottom/Empty</text>
</g>
<!-- list -->
<g id="node2">
<title>list</title>
<ellipse fill="none" stroke="black" cx="279.92" cy="-90" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="279.92" y="-85.8" font-family="Times,serif" font-size="14.00">List</text>
</g>
<!-- empty->list -->
<g id="edge1">
<title>empty-&gt;list</title>
<path fill="none" stroke="black" d="M218.88,-35.59C229.85,-45.19 243.78,-57.37 255.56,-67.68"></path>
<polygon fill="black" stroke="black" points="253.09,-70.17 262.92,-74.13 257.7,-64.91 253.09,-70.17"></polygon>
</g>
<!-- str -->
<g id="node3">
<title>str</title>
<ellipse fill="none" stroke="black" cx="199.92" cy="-90" rx="34.65" ry="18"></ellipse>
<text text-anchor="middle" x="199.92" y="-85.8" font-family="Times,serif" font-size="14.00">String</text>
</g>
<!-- empty->str -->
<g id="edge2">
<title>empty-&gt;str</title>
<path fill="none" stroke="black" d="M199.92,-36.3C199.92,-43.59 199.92,-52.27 199.92,-60.46"></path>
<polygon fill="black" stroke="black" points="196.42,-60.38 199.92,-70.38 203.42,-60.38 196.42,-60.38"></polygon>
</g>
<!-- int -->
<g id="node4">
<title>int</title>
<ellipse fill="none" stroke="black" cx="108.92" cy="-90" rx="38.38" ry="18"></ellipse>
<text text-anchor="middle" x="108.92" y="-85.8" font-family="Times,serif" font-size="14.00">Int</text>
</g>
<!-- empty->int -->
<g id="edge3">
<title>empty-&gt;int</title>
<path fill="none" stroke="black" d="M178.82,-35.24C166.45,-44.75 150.66,-56.9 137.22,-67.23"></path>
<polygon fill="black" stroke="black" points="135.35,-64.25 129.56,-73.12 139.62,-69.8 135.35,-64.25"></polygon>
</g>
<!-- int_list -->
<g id="node6">
<title>int_list</title>
<ellipse fill="none" stroke="black" cx="200.92" cy="-162" rx="55.34" ry="18"></ellipse>
<text text-anchor="middle" x="200.92" y="-157.8" font-family="Times,serif" font-size="14.00">Int|List</text>
</g>
<!-- list->int_list -->
<g id="edge8">
<title>list-&gt;int_list</title>
<path fill="none" stroke="black" d="M264.32,-104.83C253.89,-114.06 239.92,-126.45 227.74,-137.24"></path>
<polygon fill="black" stroke="black" points="225.57,-134.49 220.4,-143.74 230.21,-139.73 225.57,-134.49"></polygon>
</g>
<!-- str_list -->
<g id="node7">
<title>str_list</title>
<ellipse fill="none" stroke="black" cx="325.92" cy="-162" rx="51.6" ry="18"></ellipse>
<text text-anchor="middle" x="325.92" y="-157.8" font-family="Times,serif" font-size="14.00">String|List</text>
</g>
<!-- list->str_list -->
<g id="edge9">
<title>list-&gt;str_list</title>
<path fill="none" stroke="black" d="M290.36,-106.88C295.79,-115.15 302.57,-125.46 308.75,-134.86"></path>
<polygon fill="black" stroke="black" points="305.64,-136.5 314.05,-142.94 311.49,-132.66 305.64,-136.5"></polygon>
</g>
<!-- int_str -->
<g id="node5">
<title>int_str</title>
<ellipse fill="none" stroke="black" cx="63.92" cy="-162" rx="63.92" ry="18"></ellipse>
<text text-anchor="middle" x="63.92" y="-157.8" font-family="Times,serif" font-size="14.00">Int|String</text>
</g>
<!-- str->int_str -->
<g id="edge6">
<title>str-&gt;int_str</title>
<path fill="none" stroke="black" d="M175.92,-103.35C155.86,-113.68 126.85,-128.61 103.38,-140.69"></path>
<polygon fill="black" stroke="black" points="102,-137.46 94.71,-145.15 105.21,-143.69 102,-137.46"></polygon>
</g>
<!-- str->str_list -->
<g id="edge7">
<title>str-&gt;str_list</title>
<path fill="none" stroke="black" d="M223.03,-103.84C241.59,-114.15 268,-128.82 289.42,-140.72"></path>
<polygon fill="black" stroke="black" points="287.71,-143.77 298.15,-145.57 291.11,-137.65 287.71,-143.77"></polygon>
</g>
<!-- int->int_str -->
<g id="edge4">
<title>int-&gt;int_str</title>
<path fill="none" stroke="black" d="M98.26,-107.59C93.07,-115.66 86.7,-125.57 80.87,-134.65"></path>
<polygon fill="black" stroke="black" points="78.11,-132.47 75.64,-142.77 83.99,-136.25 78.11,-132.47"></polygon>
</g>
<!-- int->int_list -->
<g id="edge5">
<title>int-&gt;int_list</title>
<path fill="none" stroke="black" d="M128.43,-105.85C140.81,-115.26 157.06,-127.63 171.04,-138.27"></path>
<polygon fill="black" stroke="black" points="168.56,-140.77 178.63,-144.04 172.79,-135.2 168.56,-140.77"></polygon>
</g>
<!-- any -->
<g id="node8">
<title>any</title>
<ellipse fill="none" stroke="black" cx="200.92" cy="-234" rx="74.33" ry="18"></ellipse>
<text text-anchor="middle" x="200.92" y="-229.8" font-family="Times,serif" font-size="14.00">Object/Top/Any</text>
</g>
<!-- int_str->any -->
<g id="edge10">
<title>int_str-&gt;any</title>
<path fill="none" stroke="black" d="M93.99,-178.36C113.35,-188.25 138.76,-201.24 159.96,-212.07"></path>
<polygon fill="black" stroke="black" points="158.13,-215.07 168.63,-216.5 161.32,-208.83 158.13,-215.07"></polygon>
</g>
<!-- int_list->any -->
<g id="edge11">
<title>int_list-&gt;any</title>
<path fill="none" stroke="black" d="M200.92,-180.3C200.92,-187.59 200.92,-196.27 200.92,-204.46"></path>
<polygon fill="black" stroke="black" points="197.42,-204.38 200.92,-214.38 204.42,-204.38 197.42,-204.38"></polygon>
</g>
<!-- str_list->any -->
<g id="edge12">
<title>str_list-&gt;any</title>
<path fill="none" stroke="black" d="M299.41,-177.85C281.96,-187.62 258.83,-200.57 239.36,-211.47"></path>
<polygon fill="black" stroke="black" points="237.91,-208.28 230.89,-216.22 241.33,-214.39 237.91,-208.28"></polygon>
</g>
</g>
</svg>
</figure>

<p>See how we have two new layers! We have a Bottom (empty) type now. For example,
<code>join(Bottom, Bottom)</code> is <code>Bottom</code> (it remains empty), and <code>join(Bottom, List)</code>
is <code>List</code> (no new elements).</p>

<p>We can also address the set of all ints and all strings with <code>Int|String</code>,
which is ordered above each of the invidual int and string sets.</p>

<p>As I alluded to earlier, we can conveniently represent a bottom element in our
bitset type:</p>

<div><div><pre><code><span>enum</span> <span>Type</span> <span>{</span>
    <span>Bottom</span> <span>=</span> <span>0</span><span>,</span>       <span>// 0b000</span>
    <span>Int</span>    <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>0</span><span>,</span>  <span>// 0b001</span>
    <span>List</span>   <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>1</span><span>,</span>  <span>// 0b010</span>
    <span>String</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>2</span><span>,</span>  <span>// 0b100</span>
    <span>Top</span>    <span>=</span> <span>7</span><span>,</span>       <span>// 0b111</span>
<span>};</span>


<span>enum</span> <span>Type</span> <span>join</span><span>(</span><span>enum</span> <span>Type</span> <span>left</span><span>,</span> <span>enum</span> <span>Type</span> <span>right</span><span>)</span> <span>{</span>
    <span>return</span> <span>left</span> <span>|</span> <span>right</span><span>;</span>
<span>}</span>

<span>// Ask if `left` is a subtype of `right`</span>
<span>bool</span> <span>is_subtype</span><span>(</span><span>enum</span> <span>Type</span> <span>left</span><span>,</span> <span>enum</span> <span>Type</span> <span>right</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>left</span> <span>&amp;</span> <span>right</span><span>)</span> <span>==</span> <span>left</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<!-- TODO(max): Maybe talk about intersection from `if isinstance` refinement,
GuardType refinement, or could_be -->

<p>This type representation is neat, but we can go further. Sometimes, you know
more than just the <em>type</em> of an object: you know exactly what object it is.
We’ll introduce what Cinder calls <em>specialization</em>.</p>

<h2 id="specialization">Specialization</h2>

<p>In addition to our existing type lattice, Cinder keeps a second lattice called
a specialization. Its job is to keep track of what specific object an SSA value
is. For example, if we know that <code>a = 5</code>, its type would be <code>Int</code> and its
specialization would be <code>5</code>.</p>

<p>The specialization lattice is much simpler:</p>

<div><div><pre><code><span>struct</span> <span>Spec</span> <span>{</span>
    <span>enum</span> <span>{</span>
        <span>SpecTop</span><span>,</span>
        <span>SpecInt</span><span>,</span>
        <span>SpecBottom</span><span>,</span>
    <span>}</span> <span>spec_kind</span><span>;</span>
    <span>int</span> <span>value</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>In Rust syntax—to make the validity of the <code>value</code> field clearer—that’s:</p>

<div><div><pre><code><span>enum</span> <span>SpecKind</span> <span>{</span>
  <span>SpecTop</span><span>,</span>
  <span>SpecInt</span><span>(</span><span>int</span><span>),</span>
  <span>SpecBottom</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>There’s an internal enum that says what we know about the specialization and an
optional value. There are a couple of cases:</p>

<ul>
  <li>if we have <code>SpecTop</code>, we don’t have any information about the specialization</li>
  <li>if we have <code>SpecInt</code>, we know exactly the integer value, and the <code>value</code>
field is valid (initialized, readable)</li>
  <li>if we have <code>SpecBottom</code>, we know that the spec contains no elements (and
therefore also must have a type of <code>Bottom</code>)</li>
</ul>

<p>Here’s what the diagram looks like:</p>

<!--
digraph G {
    rankdir="BT";
    bottom -> int_spec;
    int_spec -> top;
    bottom [label="Bottom"];
    int_spec [label="Int[N]"];
    top [label="Top"];
}
-->

<figure>
<svg width="88pt" height="188pt" viewBox="0.00 0.00 88.02 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" transform="scale(1 1) rotate(0) translate(4 184)">
<title>G</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-184 84.02,-184 84.02,4 -4,4"></polygon>
<!-- bottom -->
<g id="node1">
<title>bottom</title>
<ellipse fill="none" stroke="black" cx="40.01" cy="-18" rx="40.01" ry="18"></ellipse>
<text text-anchor="middle" x="40.01" y="-13.8" font-family="Times,serif" font-size="14.00">Bottom</text>
</g>
<!-- int_spec -->
<g id="node2">
<title>int_spec</title>
<ellipse fill="none" stroke="black" cx="40.01" cy="-90" rx="35.17" ry="18"></ellipse>
<text text-anchor="middle" x="40.01" y="-85.8" font-family="Times,serif" font-size="14.00">Int[N]</text>
</g>
<!-- bottom->int_spec -->
<g id="edge1">
<title>bottom-&gt;int_spec</title>
<path fill="none" stroke="black" d="M40.01,-36.3C40.01,-43.59 40.01,-52.27 40.01,-60.46"></path>
<polygon fill="black" stroke="black" points="36.51,-60.38 40.01,-70.38 43.51,-60.38 36.51,-60.38"></polygon>
</g>
<!-- top -->
<g id="node3">
<title>top</title>
<ellipse fill="none" stroke="black" cx="40.01" cy="-162" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="40.01" y="-157.8" font-family="Times,serif" font-size="14.00">Top</text>
</g>
<!-- int_spec->top -->
<g id="edge2">
<title>int_spec-&gt;top</title>
<path fill="none" stroke="black" d="M40.01,-108.3C40.01,-115.59 40.01,-124.27 40.01,-132.46"></path>
<polygon fill="black" stroke="black" points="36.51,-132.38 40.01,-142.38 43.51,-132.38 36.51,-132.38"></polygon>
</g>
</g>
</svg>
</figure>

<p>Where <em>N</em> represents some integer stored in the <code>value</code> field.</p>

<p>This complicates things a bit. Let’s put both the type bits and the
specialization together in one structure and admire:</p>

<div><div><pre><code><span>struct</span> <span>Type</span> <span>{</span>
    <span>enum</span> <span>TypeBits</span> <span>{</span>
        <span>Bottom</span> <span>=</span> <span>0</span><span>,</span>       <span>// 0b000</span>
        <span>Int</span>    <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>0</span><span>,</span>  <span>// 0b001</span>
        <span>List</span>   <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>1</span><span>,</span>  <span>// 0b010</span>
        <span>String</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>2</span><span>,</span>  <span>// 0b100</span>
        <span>Top</span>    <span>=</span> <span>7</span><span>,</span>       <span>// 0b111</span>
    <span>}</span> <span>type</span><span>;</span>
    <span>// If you are feeling clever, you can also steal some `type` bits for the</span>
    <span>// `spec_kind` instead of putting it in a separate field.</span>
    <span>struct</span> <span>Spec</span> <span>{</span>
        <span>enum</span> <span>{</span>
            <span>SpecTop</span><span>,</span>
            <span>SpecInt</span><span>,</span>
            <span>SpecBottom</span><span>,</span>
        <span>}</span> <span>spec_kind</span><span>;</span>
        <span>int</span> <span>value</span><span>;</span>
    <span>}</span> <span>spec</span><span>;</span>
<span>};</span>

<span>const</span> <span>struct</span> <span>Type</span> <span>TTop</span> <span>=</span> <span>(</span><span>struct</span> <span>Type</span><span>)</span> <span>{</span>
    <span>.</span><span>type</span> <span>=</span> <span>Top</span><span>,</span>
    <span>.</span><span>spec</span> <span>=</span> <span>(</span><span>struct</span> <span>Spec</span><span>)</span> <span>{</span> <span>.</span><span>spec_kind</span> <span>=</span> <span>SpecTop</span> <span>},</span>
<span>};</span>
<span>const</span> <span>struct</span> <span>Type</span> <span>TInt</span> <span>=</span> <span>(</span><span>struct</span> <span>Type</span><span>)</span> <span>{</span>
    <span>.</span><span>type</span> <span>=</span> <span>Int</span><span>,</span>
    <span>.</span><span>spec</span> <span>=</span> <span>(</span><span>struct</span> <span>Spec</span><span>)</span> <span>{</span> <span>.</span><span>spec_kind</span> <span>=</span> <span>SpecTop</span> <span>},</span>
<span>};</span>
<span>const</span> <span>struct</span> <span>Type</span> <span>TThree</span> <span>=</span> <span>(</span><span>struct</span> <span>Type</span><span>)</span> <span>{</span>
    <span>.</span><span>type</span> <span>=</span> <span>Int</span><span>,</span>
    <span>.</span><span>spec</span> <span>=</span> <span>(</span><span>struct</span> <span>Spec</span><span>)</span> <span>{</span> <span>.</span><span>spec_kind</span> <span>=</span> <span>SpecInt</span><span>,</span> <span>.</span><span>value</span> <span>=</span> <span>3</span> <span>},</span>
<span>};</span>
<span>// Invariant: .type == Bottom if and only if .spec_kind == SpecBottom.</span>
<span>const</span> <span>struct</span> <span>Type</span> <span>Bottom</span> <span>=</span> <span>(</span><span>struct</span> <span>Type</span><span>)</span> <span>{</span>
    <span>.</span><span>type</span> <span>=</span> <span>Bottom</span><span>,</span>
    <span>.</span><span>spec</span> <span>=</span> <span>(</span><span>struct</span> <span>Spec</span><span>)</span> <span>{</span> <span>.</span><span>spec_kind</span> <span>=</span> <span>SpecBottom</span> <span>},</span>
<span>};</span>
</code></pre></div></div>

<p>That’s very nice and more precise, but now our <code>join</code> and <code>is_subtype</code>
operators don’t make a whole lot of sense. We can’t just use bitwise operations
any more. We have to also do the lattice operations on the <code>Spec</code> field:</p>

<div><div><pre><code><span>struct</span> <span>Type</span> <span>join</span><span>(</span><span>struct</span> <span>Type</span> <span>left</span><span>,</span> <span>struct</span> <span>Type</span> <span>right</span><span>)</span> <span>{</span>
    <span>struct</span> <span>Type</span> <span>result</span><span>;</span>
    <span>result</span><span>.</span><span>type</span> <span>=</span> <span>left</span><span>.</span><span>type</span> <span>|</span> <span>right</span><span>.</span><span>type</span><span>;</span>
    <span>result</span><span>.</span><span>spec</span> <span>=</span> <span>spec_join</span><span>(</span><span>left</span><span>.</span><span>spec</span><span>,</span> <span>right</span><span>.</span><span>spec</span><span>);</span>
    <span>return</span> <span>result</span><span>;</span>
<span>}</span>

<span>// Ask if `left` is a subtype of `right`</span>
<span>bool</span> <span>is_subtype</span><span>(</span><span>struct</span> <span>Type</span> <span>left</span><span>,</span> <span>struct</span> <span>Type</span> <span>right</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>left</span> <span>&amp;</span> <span>right</span><span>)</span> <span>==</span> <span>left</span> <span>&amp;&amp;</span> <span>spec_is_subtype</span><span>(</span><span>left</span><span>.</span><span>spec</span><span>,</span> <span>right</span><span>.</span><span>spec</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>If we decompose the problem that way, we can write some lattice operations for
<code>Spec</code>. Let’s start with <code>is_subtype</code>:</p>

<div><div><pre><code><span>// Ask if `left` is a subtype of `right`</span>
<span>bool</span> <span>spec_is_subtype</span><span>(</span><span>struct</span> <span>Spec</span> <span>left</span><span>,</span> <span>struct</span> <span>Spec</span> <span>right</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>right</span><span>.</span><span>spec_kind</span> <span>==</span> <span>SpecTop</span> <span>||</span> <span>left</span><span>.</span><span>spec_kind</span> <span>==</span> <span>SpecBottom</span><span>)</span> <span>{</span>
        <span>// Top is a supertype of everything and Bottom is a subtype of</span>
        <span>// everything</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>// left is now either SpecInt or SpecTop</span>
    <span>// right is now either SpecInt or SpecBottom</span>
    <span>// The only way left could be a subtype of right is if they are both</span>
    <span>// SpecInt and the value is the same</span>
    <span>if</span> <span>(</span><span>left</span><span>.</span><span>spec_kind</span> <span>==</span> <span>SpecInt</span> <span>&amp;&amp;</span>
        <span>right</span><span>.</span><span>spec_kind</span> <span>==</span> <span>SpecInt</span> <span>&amp;&amp;</span>
        <span>left</span><span>.</span><span>value</span> <span>==</span> <span>right</span><span>.</span><span>value</span><span>)</span> <span>{</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>That takes a bit of time to internalize, so please read over it a couple of
times and work out the cases by hand. It’s really useful for implementing
<code>spec_join</code>:</p>

<div><div><pre><code><span>struct</span> <span>Spec</span> <span>spec_join</span><span>(</span><span>struct</span> <span>Spec</span> <span>left</span><span>,</span> <span>struct</span> <span>Spec</span> <span>right</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>spec_is_subtype</span><span>(</span><span>left</span><span>,</span> <span>right</span><span>))</span> <span>{</span> <span>return</span> <span>right</span><span>;</span> <span>}</span>
    <span>if</span> <span>(</span><span>spec_is_subtype</span><span>(</span><span>right</span><span>,</span> <span>left</span><span>))</span> <span>{</span> <span>return</span> <span>left</span><span>;</span> <span>}</span>
    <span>// We know that neither left nor right is either SpecTop or SpecBottom</span>
    <span>// because that would have been covered in one of the subtype cases, so</span>
    <span>// we&#39;re join-ing two SpecInts. That&#39;s SpecTop.</span>
    <span>struct</span> <span>Spec</span> <span>result</span><span>;</span>
    <span>result</span><span>.</span><span>spec_kind</span> <span>=</span> <span>SpecTop</span><span>;</span>
    <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>It’s a couple more instructions than a single bitwise operation and a compare,
but it’s still compact and fast.</p>

<p>Let’s talk about some problems you might run into while using this API.</p>

<h2 id="bottom-api">Bottom API</h2>

<p>A common mistake when handling <code>Bottom</code> is treating it as an error, or assuming
it will never show up in your program. To expand on its brief introduction
above, the two main consequences of <code>Bottom</code>’s place at the bottom of the type
lattice are:</p>

<ol>
  <li>A value of type <code>Bottom</code> can never be <em>defined</em>. An instruction with an
output of type <code>Bottom</code> will therefore never define its output. Such an
instruction might loop infinitely, it might crash your program, or it might
jump to another location in the program (if your compiler supports
control-flow instructions that define values).</li>
  <li>A value of type <code>Bottom</code> can never be <em>used</em>, so an instruction with an
input of type <code>Bottom</code> is unreachable. This follows from the previous item
(since you obviously can’t use a value you can’t define), but is worth
calling out separately.</li>
</ol>

<p>These two properties make checking for <code>Bottom</code> useful in an unreachable code
elimination pass. Otherwise, though, <code>Bottom</code> is just another type, and your
type predicates will generally be cleaner if you design them to correctly
handle <code>Bottom</code> without explicitly testing for it.</p>

<p>Most of the time, <code>Bottom</code> support happens out naturally. Cinder, for
example, calls the exact integer type <code>LongExact</code>. We can check if a type is
an exact integer with:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>t</span><span>.</span><span>is_subtype</span><span>(</span><span>LongExact</span><span>))</span> <span>{</span>
    <span>// generate int-specific code</span>
<span>}</span>
</code></pre></div></div>

<p>In this example, <code>t == Bottom</code> will be fine: any code that is generated (if
your compiler doesn’t eliminate unreachable code) will never run, so it’s
perfectly fine to call a helper function that expects an <code>int</code>, or to load a
field of <code>PyLongObject</code>, etc.</p>

<p>Sometimes, however, we want to get a concrete value out of a type at
compile-time for an optimization such as constant folding. It may be tempting
to assume that if your type <code>t</code> is a strict subtype of (can’t be equal to)
<code>LongExact</code>, it represents a specific <code>int</code> object:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>t</span><span>.</span><span>is_strict_subtype</span><span>(</span><span>LongExact</span><span>))</span> <span>{</span>
    <span>PyLongObject</span><span>*</span> <span>a_long</span> <span>=</span> <span>t</span><span>.</span><span>asPyObject</span><span>();</span>
    <span>// ... optimize based on a_long</span>
<span>}</span>
</code></pre></div></div>

<p>This code is broken for plenty of cases other than <code>Bottom</code> (e.g.,
range-constrained <code>int</code> types), but in many compilers, <code>Bottom</code> will usually be
the first type that causes a crash or failed assertion here. Rather than
excluding <code>Bottom</code> by name, with code like <code>if (t != Bottom &amp;&amp; t.is_strict_subtype(LongExact))</code>, you can handle <code>Bottom</code> (and all other types!) correctly by
refining your type predicate to what you <em>really</em> mean.</p>

<p>In this case, you want to know if <code>t</code> represents exactly one value, so you
might use an API like <code>t.admitsSingleValue(LongExact)</code>. That will correctly
exclude <code>Bottom</code>, which represents zero values, but it will also correctly
exclude a type that means “an <code>int</code> that is less than 0”, which is a strict
subtype of <code>LongExact</code> but doesn’t represent a single value.</p>

<p>Now, these type bits are a pain to write down by hand. Instead, it would be
nice to generate them automatically given a class hierarchy. That’s what Cinder
does.</p>

<h2 id="generating-the-lattice-from-a-type-hierarchy">Generating the lattice from a type hierarchy</h2>

<p>Here is an abridged sketch of the Cinder script to generate it, since the
Cinder version has a couple more quirks that are not crucial to understanding
the core of this post:</p>

<div><div><pre><code><span>class</span> <span>UnionSpec</span><span>(</span><span>NamedTuple</span><span>):</span>
    <span>name</span><span>:</span> <span>str</span>
    <span>components</span><span>:</span> <span>List</span><span>[</span><span>str</span><span>]</span>

<span># All the leaf types, each of which gets a bit
</span><span>BASIC_FINAL_TYPES</span><span>:</span> <span>List</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>[</span>
    <span>&#34;Bool&#34;</span><span>,</span>
    <span>&#34;NoneType&#34;</span><span>,</span>
    <span># ...
</span><span>]</span>

<span>BASIC_BASE_TYPES</span><span>:</span> <span>List</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>[</span>
    <span>&#34;Bytes&#34;</span><span>,</span>
    <span>&#34;Dict&#34;</span><span>,</span>
    <span># ...
</span><span>]</span>

<span>BASIC_EXACT_TYPES</span><span>:</span> <span>List</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>[</span>
    <span>&#34;ObjectExact&#34;</span><span>,</span>
    <span>*</span><span>[</span><span>ty</span> <span>+</span> <span>&#34;Exact&#34;</span> <span>for</span> <span>ty</span> <span>in</span> <span>BASIC_BASE_TYPES</span><span>],</span>
<span>]</span>

<span>BASIC_USER_TYPES</span><span>:</span> <span>List</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>[</span>
    <span>&#34;ObjectUser&#34;</span><span>,</span>
    <span>*</span><span>[</span><span>ty</span> <span>+</span> <span>&#34;User&#34;</span> <span>for</span> <span>ty</span> <span>in</span> <span>BASIC_BASE_TYPES</span><span>],</span>
<span>]</span>

<span>BASIC_PYTYPES</span><span>:</span> <span>List</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>BASIC_FINAL_TYPES</span> <span>+</span> <span>BASIC_EXACT_TYPES</span> <span>+</span> <span>BASIC_USER_TYPES</span>

<span># The unions, which have multiple bits set
</span><span>PYTYPE_UNIONS</span><span>:</span> <span>List</span><span>[</span><span>UnionSpec</span><span>]</span> <span>=</span> <span>[</span>
    <span>UnionSpec</span><span>(</span><span>&#34;BuiltinExact&#34;</span><span>,</span> <span>BASIC_FINAL_TYPES</span> <span>+</span> <span>BASIC_EXACT_TYPES</span><span>),</span>
    <span>*</span><span>[</span><span>UnionSpec</span><span>(</span><span>ty</span><span>,</span> <span>[</span><span>ty</span> <span>+</span> <span>&#34;User&#34;</span><span>,</span> <span>ty</span> <span>+</span> <span>&#34;Exact&#34;</span><span>])</span> <span>for</span> <span>ty</span> <span>in</span> <span>BASIC_BASE_TYPES</span><span>],</span>
    <span>UnionSpec</span><span>(</span><span>&#34;User&#34;</span><span>,</span> <span>BASIC_USER_TYPES</span><span>),</span>
    <span>UnionSpec</span><span>(</span><span>&#34;Object&#34;</span><span>,</span> <span>BASIC_PYTYPES</span><span>),</span>
    <span>UnionSpec</span><span>(</span><span>&#34;Top&#34;</span><span>,</span> <span>BASIC_PYTYPES</span><span>),</span>
    <span>UnionSpec</span><span>(</span><span>&#34;Bottom&#34;</span><span>,</span> <span>[]),</span>
<span>]</span>

<span>def</span> <span>assign_bits</span><span>()</span> <span>-&gt;</span> <span>Tuple</span><span>[</span><span>Dict</span><span>[</span><span>str</span><span>,</span> <span>int</span><span>],</span> <span>int</span><span>]:</span>
    <span>&#34;&#34;&#34;Create the bit patterns for all predefined types: basic types are given
    one bit each, then union types are constructed from the basic types.
    &#34;&#34;&#34;</span>
    <span>bit_idx</span> <span>=</span> <span>0</span>
    <span>bits</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>ty</span> <span>in</span> <span>BASIC_PYTYPES</span><span>:</span>
        <span>bits</span><span>[</span><span>ty</span><span>]</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>bit_idx</span>
        <span>bit_idx</span> <span>+=</span> <span>1</span>

    <span>for</span> <span>ty</span><span>,</span> <span>components</span><span>,</span> <span>_</span> <span>in</span> <span>PYTYPE_UNIONS</span><span>:</span>
        <span>bits</span><span>[</span><span>ty</span><span>]</span> <span>=</span> <span>reduce</span><span>(</span><span>operator</span><span>.</span><span>or_</span><span>,</span> <span>[</span><span>bits</span><span>[</span><span>t</span><span>]</span> <span>for</span> <span>t</span> <span>in</span> <span>components</span><span>],</span> <span>0</span><span>)</span>

    <span>return</span> <span>bits</span><span>,</span> <span>bit_idx</span>
</code></pre></div></div>

<p>It’s a bit of a funky snippet, but the gist is that it creates a bunch of leaf
types such as <code>DictExact</code> and <code>BytesUser</code> and assigns each a bit. Then, it goes
through all of the unions and bitwise <code>or</code>s their component bits together. Last
(not pictured), it prints out a <code>uint64_t</code> for each of these.</p>

<p>The output is an X-macro that looks something like this:</p>

<div><div><pre><code><span>// For all types, call X(name, bits)</span>
<span>#define HIR_TYPES(X) \
  X(Array,                         0x00000000001UL)    \
  X(BaseException,                 0x00000801000UL)    \
  X(BaseExceptionExact,            0x00000001000UL)    \
  X(BaseExceptionUser,             0x00000800000UL)    \
  X(Bool,                          0x00000000002UL)    \
  </span><span>/* ... */</span><span>                                            \
  X(User,                          0x000ffe00000UL)    \
  X(WaitHandle,                    0x00000000200UL)
</span>
<span>const</span> <span>size_t</span> <span>kNumTypeBits</span> <span>=</span> <span>44</span><span>;</span>
</code></pre></div></div>

<p>Check out the <a href="https://github.com/facebookincubator/cinderx/blob/9197ff2a80517304e194ea36b71f973b7daa1bd9/Jit/hir/generate_jit_type_h.py">Cinder implementation</a>.</p>



<p>Cinder also has some other features embedded into the same type bitset:</p>

<ul>
  <li>Primitive type bits and primitive specializations (<code>CInt32</code>, <code>CDouble</code>,
<code>CBool</code>, <code>Null</code>, …), which inherently handles nullability</li>
  <li>A lifetime lattice to support <a href="https://peps.python.org/pep-0683/">immortal objects</a></li>
</ul>

<p>See also the <a href="https://github.com/facebookincubator/cinderx/blob/08ec283e5eaf29196d92f8d308aaadc8e82bc0c0/Jit/hir/type.md">type.md</a> document which goes into detail about Cinder’s
type system.</p>

<p>There are some features Cinder does not (currently) support but would be cool
to implement:</p>

<ul>
  <li>Integer ranges</li>
  <li>Known bits / tristate numbers</li>
  <li>Function pointers</li>
  <li>Non-builtin class unions (as a bitset of class IDs or otherwise)</li>
</ul>

<h2 id="in-other-compilers">In other compilers</h2>

<ul>
  <li>HHVM has a similar looking <a href="https://github.com/facebook/hhvm/blob/11b663fdfde613d477f38af04db15f7ec1ee9bf3/hphp/runtime/vm/jit/type.h">type.h</a> and
<a href="https://github.com/facebook/hhvm/blob/11b663fdfde613d477f38af04db15f7ec1ee9bf3/hphp/runtime/vm/jit/type-specialization-inl.h">specialization</a>. It’s similar looking because both Cinder’s
and HHVM’s were written by my friend and former coworker Brett Simmers!
    <ul>
      <li>See also the <a href="https://github.com/facebook/hhvm/blob/30babc75b3a0cec4fcbf7823493913cca4323a58/hphp/hhbbc/type-system.h">type implementation</a> for the bytecode optimizer</li>
    </ul>
  </li>
  <li>iv, written by Constellation (JavaScriptCore committer), has a <a href="https://github.com/Constellation/iv/blob/64c3a9c7c517063f29d90d449180ea8f6f4d946f/iv/lv5/breaker/type.h">smaller bitset
lattice</a></li>
  <li>V8’s Turbofan compiler has <a href="https://github.com/v8/v8/blob/30be5d03036d6934e847c733315d527915207e85/src/compiler/turbofan-types.h">something similar</a></li>
  <li>Simple (the Sea of Nodes compiler)’s <a href="https://github.com/SeaOfNodes/Simple/blob/2370fb29d4538479af9eb94fc666a5ce09fcb492/chapter20/src/main/java/com/seaofnodes/simple/type/Type.java">Type.java</a></li>
  <li>Cliff Click’s aa language <a href="https://github.com/cliffclick/aa/blob/e50e4a5881f9a15c1c7f063417eaa7b43c23f1bd/src/main/java/com/cliffc/aa/type/Type.java">Type.java</a></li>
  <li>HotSpot’s C2’s <a href="https://github.com/openjdk/jdk/blob/857c53718957283766f6566e5519ab5911cf9f3c/src/hotspot/share/opto/type.hpp">type.hpp</a></li>
  <li>JavaScriptCore’s <a href="https://github.com/WebKit/WebKit/blob/3248b57ad66ab22aff20b48c23c46e8030503f61/Source/JavaScriptCore/bytecode/SpeculatedType.h">SpeculatedType</a></li>
  <li>PyPy’s RPython generates <a href="https://github.com/pypy/pypy/blob/c2324b8ac30693d049214bf6a0447d52ebbfc352/rpython/translator/backendopt/writeanalyze.py">heap effect metadata</a> for functions
that can’t be inlined so that the JIT knows what heap addresses they do and
do not write to. It does not use a bitset (yet?) but is a lattice.</li>
</ul>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Thanks to CF Bolz-Tereick, Cliff Click, Tom Hebb, Kai Williams, and Thomas Gardner for
feedback on this post.</p>


        </div></div>
  </body>
</html>
