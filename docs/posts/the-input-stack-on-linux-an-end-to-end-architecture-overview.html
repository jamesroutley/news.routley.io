<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://venam.net/blog/unix/2025/11/27/input_devices_linux.html">Original</a>
    <h1>The input stack on Linux: An end-to-end architecture overview</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    <p><img src="http://tinylogger.com/blog/assets/input_devices_linux/astrolabe_img.jpg" alt="An Astrolabe" title="Astrolabe"/></p>



<p>Let’s explore and deobfuscate the input stack on Linux. Our aim is to
understand its components and what each does. Input handling can be
divided into two parts, separated by a common layer:</p>

<ul>
  <li>Kernel-level handling: It deals with what happens in the kernel and how events are exposed to user-space
    <ul>
      <li>The actual hardware connected to the machine, along with the different buses and I/O/transport subsystems</li>
      <li>The input core subsystem, and the specific device drivers that register on it</li>
    </ul>
  </li>
  <li>Exposed layer (middle)
    <ul>
      <li>The event abstraction subsystem (evdev)</li>
      <li>devtmpfs for device nodes</li>
      <li>sysfs for kernel objects and device attributes</li>
      <li>procfs for an introspection interface of the input core</li>
    </ul>
  </li>
  <li>User-space handling:
    <ul>
      <li>The user-space device manager (udev) and hardware database (hwdb) for device management and setup</li>
      <li>The libinput library for general input, and other libraries such as
XKB for keyboards, to interpret the events and make them manageable</li>
      <li>The Widgets, X Server, X11 window managers, and Wayland compositors,
which rely on everything else</li>
    </ul>
  </li>
</ul>

<p>We’ll try to make sense of all this, one thing at a time, with a logical
and coherent approach.</p>

<p><em>NB: This article compiles my understand, for any correction please
contact me.</em></p>



<p>How are input devices and their events handled in the kernel? You might
think it is useless to know, but understanding some of the kernel logic
is what makes things click.</p>

<p>To follow along you can either download the kernel
source, or view it in any browser explorer (such as
<a href="https://github.com/torvalds/linux/blob/master/drivers/input/input.c">this</a>,
<a href="https://elixir.bootlin.com/linux/v6.17.9/source/drivers/input/input.c">this</a>,
or <a href="https://reverser.dev/linux-kernel-explorer">this</a>).</p>

<p>Practically, the input core is found in the kernel under
<code>drivers/input/input.c</code>, it defines the basic functionalities related
to the lifecycle of an input device, defined as a <code>struct input_dev</code>
(<code>input.h</code>). Namely:</p>

<ul>
  <li>Allocating the input device structure (<code>input_allocate_device</code> that
returns a <code>struct input_dev</code>)</li>
  <li>Registering and unregistering the input device in the system
along with setting sane default values
(<code>input_register_device</code> adds to <code>input_dev_list</code>). This also integrates with devtmpfs,
exposing the device, and with procfs, exposing debugging information
(<code>/proc/bus/input/</code>).</li>
  <li>Drivers push events to the input core using <code>input_event</code>. The core then
forwards the events to the registered handlers in
a fan-out fashion (<code>input_register_handler</code> adds an <code>input_handler</code> to <code>input_handler_list</code>). Then handlers forward
them to all clients in user-space (called <code>input_handle</code>) listening
for events on that handler. The clients are registered on
the handler with <code>input_register_handle</code> (similar confusing names).
The user-space client/handle can also grab the handler with exclusivity
through <code>input_grab_device</code> (ex: <code>EVIOCGRAB</code> in evdev).</li>
</ul>

<p>An input handler is an implementation of an abstract interface
(<code>include/linux/input.h</code>), which the input core will call. Particularly,
the <code>input_event</code> function in input core will invoke the implementation
of the input handler’s <code>events</code> function. Here’s the interface an input
handler should fulfil:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>input_handler</span> <span>{</span>
	<span>void</span> <span>(</span><span>*</span><span>event</span><span>)(</span><span>struct</span> <span>input_handle</span> <span>*</span><span>handle</span><span>,</span> <span>unsigned</span> <span>int</span> <span>type</span><span>,</span>
			        <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>);</span>
	<span>unsigned</span> <span>int</span> <span>(</span><span>*</span><span>events</span><span>)(</span><span>struct</span> <span>input_handle</span> <span>*</span><span>handle</span><span>,</span>
			       <span>struct</span> <span>input_value</span> <span>*</span><span>vals</span><span>,</span> <span>unsigned</span> <span>int</span> <span>count</span><span>);</span>
	<span>bool</span> <span>(</span><span>*</span><span>filter</span><span>)(</span><span>struct</span> <span>input_handle</span> <span>*</span><span>handle</span><span>,</span> <span>unsigned</span> <span>int</span> <span>type</span><span>,</span>
			       <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>);</span>
	<span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>struct</span> <span>input_handler</span> <span>*</span><span>handler</span><span>,</span>
			       <span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>);</span>
	<span>int</span> <span>(</span><span>*</span><span>connect</span><span>)(</span><span>struct</span> <span>input_handler</span> <span>*</span><span>handler</span><span>,</span>
			      <span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span>
			      <span>const</span> <span>struct</span> <span>input_device_id</span> <span>*</span><span>id</span><span>);</span>
	<span>void</span> <span>(</span><span>*</span><span>disconnect</span><span>)(</span><span>struct</span> <span>input_handle</span> <span>*</span><span>handle</span><span>);</span>
	<span>void</span> <span>(</span><span>*</span><span>start</span><span>)(</span><span>struct</span> <span>input_handle</span> <span>*</span><span>handle</span><span>);</span>
	<span>/* …
	 */</span>
<span>};</span></code></pre></figure>

<p>In the same way, a handle list is simply a pointer to a device and a
handler, along with a function to process events:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>input_handle</span> <span>{</span>
	<span>void</span> <span>*</span><span>private</span><span>;</span>

	<span>int</span> <span>open</span><span>;</span>
	<span>const</span> <span>char</span> <span>*</span><span>name</span><span>;</span>

	<span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>;</span>
	<span>struct</span> <span>input_handler</span> <span>*</span><span>handler</span><span>;</span>

	<span>unsigned</span> <span>int</span> <span>(</span><span>*</span><span>handle_events</span><span>)(</span><span>struct</span> <span>input_handle</span> <span>*</span><span>handle</span><span>,</span>
				      <span>struct</span> <span>input_value</span> <span>*</span><span>vals</span><span>,</span>
				      <span>unsigned</span> <span>int</span> <span>count</span><span>);</span>

	<span>struct</span> <span>list_head</span>	<span>d_node</span><span>;</span>
	<span>struct</span> <span>list_head</span>	<span>h_node</span><span>;</span>
<span>};</span></code></pre></figure>

<p>And the <code>input_dev</code> abstraction returned by <code>input_allocate_device</code>
is a much biger structure:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>input_dev</span> <span>{</span>
	<span>const</span> <span>char</span> <span>*</span><span>name</span><span>;</span>
	<span>const</span> <span>char</span> <span>*</span><span>phys</span><span>;</span>
	<span>const</span> <span>char</span> <span>*</span><span>uniq</span><span>;</span>
	<span>struct</span> <span>input_id</span> <span>id</span><span>;</span>
<span>…</span>
	<span>unsigned</span> <span>int</span> <span>keycodemax</span><span>;</span>
	<span>unsigned</span> <span>int</span> <span>keycodesize</span><span>;</span>
	<span>void</span> <span>*</span><span>keycode</span><span>;</span>
<span>…</span>
	<span>int</span> <span>(</span><span>*</span><span>setkeycode</span><span>)(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span>
			  <span>const</span> <span>struct</span> <span>input_keymap_entry</span> <span>*</span><span>ke</span><span>,</span>
			  <span>unsigned</span> <span>int</span> <span>*</span><span>old_keycode</span><span>);</span>
	<span>int</span> <span>(</span><span>*</span><span>getkeycode</span><span>)(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span>
			  <span>struct</span> <span>input_keymap_entry</span> <span>*</span><span>ke</span><span>);</span>
<span>…</span>
	<span>int</span> <span>(</span><span>*</span><span>open</span><span>)(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>);</span>
	<span>void</span> <span>(</span><span>*</span><span>close</span><span>)(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>);</span>
	<span>int</span> <span>(</span><span>*</span><span>flush</span><span>)(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span> <span>struct</span> <span>file</span> <span>*</span><span>file</span><span>);</span>
	<span>int</span> <span>(</span><span>*</span><span>event</span><span>)(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span> <span>unsigned</span> <span>int</span> <span>type</span><span>,</span> <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>);</span>
<span>…</span>
	<span>struct</span> <span>device</span> <span>dev</span><span>;</span>
<span>…</span>
	<span>struct</span> <span>list_head</span>	<span>h_list</span><span>;</span>
	<span>struct</span> <span>list_head</span>	<span>node</span><span>;</span>
<span>};</span></code></pre></figure>

<p>Each actual specific input device driver builds on top of the functions of the
input core in their internal code, adding their own specificities and
advertising what capabilities and features the device can generate. This
creates a polymorphic-like abstraction where common input core logic is
reused, and where input event handlers are abstracted away. In general,
the main role of input drivers is to translate the device specific
protocol to a more standardized protocol, such as evdev, so that it can
be useful in user-space. And additionally, as with most drivers way of
communicating with the rest of the system, they can possibly have extra
configuration through an ioctl interface.</p>

<p>Along with all this, the kernel has a mechanism called sysfs that is
used to expose its internal objects (kobject) to user-space. Anytime
a device is created, it is exposed in <code>/sys/</code> (usually mounted there)
with its properties (<code>/sys/devices/</code>). For the input core part, we can
find it in <code>/sys/class/input/inputN</code>, and within each sub-directories
we have the properties of the object.</p>

<p>The kobject structure looks like this:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>kobject</span> <span>{</span>
        <span>const</span> <span>char</span>              <span>*</span><span>name</span><span>;</span>
        <span>struct</span> <span>list_head</span>        <span>entry</span><span>;</span>
        <span>struct</span> <span>kobject</span>          <span>*</span><span>parent</span><span>;</span>
        <span>struct</span> <span>kset</span>             <span>*</span><span>kset</span><span>;</span>
        <span>struct</span> <span>kobj_type</span>        <span>*</span><span>ktype</span><span>;</span>
        <span>struct</span> <span>sysfs_dirent</span>     <span>*</span><span>sd</span><span>;</span>
        <span>struct</span> <span>kref</span>             <span>kref</span><span>;</span>
        <span>unsigned</span> <span>int</span> <span>state_initialized</span><span>:</span><span>1</span><span>;</span>
        <span>unsigned</span> <span>int</span> <span>state_in_sysfs</span><span>:</span><span>1</span><span>;</span>
        <span>unsigned</span> <span>int</span> <span>state_add_uevent_sent</span><span>:</span><span>1</span><span>;</span>
        <span>unsigned</span> <span>int</span> <span>state_remove_uevent_sent</span><span>:</span><span>1</span><span>;</span>
        <span>unsigned</span> <span>int</span> <span>uevent_suppress</span><span>:</span><span>1</span><span>;</span>
<span>};</span></code></pre></figure>

<p>This is a general overview of our understanding of the input core so far:</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/input_core.png" alt="Input Core Overview" title="Input Core Overview"/></p>



<p>We may commonly say that devices are connected to a machine and magically
handled from there on. Yet, we know that it’s an abstraction and that
there’s more to it. What happens in reality is that the electrical
connection first passes over a bus/host controller, which then let’s the
data be transported. This data is formatted in a specific input protocol
that should be handled by a driver that speaks it and that subsequently
creates a related input device. In most input device cases, the driver
then translates the protocol into evdev <em>“common speech”</em>.</p>

<p>Here’s what that stack is like in theory, with in reality some lines
blurred together:</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/input_topological_path.png" alt="Topology Overview" title="Topology Overview"/></p>

<p>In this section, let’s try to understand how the kernel uses
plug’n’play/hotplug to pick the right drivers in this stack, and how we
pass from electrical signal to evdev. To do that we’ll first look at
how the kernel pictures its internal objects, and how these together
somehow create the above hierarchy. Finally, we’ll see some concrete
examples of that, along with some command line tools that can clearly
display this encapsulating behavior.</p>

<p>As we said there’s a hierarchy of kobjects in the kernel from the bus
to its connected devices. These are stored in-memory as a linked list
hierarchy, which is also represented under sysfs as a file system tree.</p>

<figure><pre><code data-lang="c"><span>device_register</span><span>(</span><span>&amp;</span><span>child</span><span>-&gt;</span><span>dev</span><span>);</span>
<span>child</span><span>-&gt;</span><span>dev</span><span>.</span><span>parent</span> <span>=</span> <span>&amp;</span><span>parent</span><span>-&gt;</span><span>dev</span><span>;</span></code></pre></figure>

<p>For example, here’s the path that an input device data might take.</p>

<div><div><pre><code>/devices/pci0000:00/0000:00:14.0/usb1/1-1/1-1:1.0/
             0003:046D:C31C.0003/input/input6/event3
</code></pre></div></div>

<ul>
  <li><code>/devices/...</code> — root of the kernel’s sysfs device tree, showing all devices known to the kernel.</li>
  <li><code>pci0000:00/0000:00:14.0</code> — PCI bus and controller (the USB host controller here).</li>
  <li><code>usb1/1-1/1-1:1.0</code> — USB bus and port hierarchy (device 1-1, interface 1.0).</li>
  <li><code>0003:046D:C31C.0003</code> — HID device node (bus <code>0003</code> = USB HID, vendor <code>046D</code> = Logitech, product <code>C31C</code> = specific keyboard).</li>
  <li><code>input/input6</code> — input subsystem device registered under <code>/sys/class/input/input6</code>.</li>
  <li><code>event3</code> — the evdev interface, the character device exposed in <code>/dev/input/event3</code>.</li>
</ul>

<p>How did we end up with this long list, how did it get created? Let’s see
how the kernel stores this info, and what happens from its perpective.</p>

<ul>
  <li>bus - a device to which other devices can be attached</li>
  <li>device - a physical/logical device that is attached to a bus</li>
  <li>driver - a software entity that can be associated with a device and
performs operations with it</li>
  <li>class - a type of device that has similar behavior; There is a class
for disks, partitions, serial ports, input, etc.</li>
  <li>subsystem - a view on the structure of the system; Kernel subsystems
include devices (hierarchical view of all devices in the system), buses
(bus view of devices according to how they are attached to buses),
classes, input, etc. We care about the input subsystem.</li>
</ul>

<p>For example, there are different views of the same device. You’ll find
the physical USB device under <code>/sys/bus/usb/devices/</code> and the logical
device of the input class under <code>/sys/class/input/.</code></p>

<p>Let’s go over these objects, tracing the path, starting with buses.</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>bus_type</span> <span>{</span>
        <span>const</span> <span>char</span>              <span>*</span><span>name</span><span>;</span>
        <span>const</span> <span>char</span>              <span>*</span><span>dev_name</span><span>;</span>
        <span>struct</span> <span>device</span>           <span>*</span><span>dev_root</span><span>;</span>
        <span>struct</span> <span>bus_attribute</span>    <span>*</span><span>bus_attrs</span><span>;</span>
        <span>struct</span> <span>device_attribute</span> <span>*</span><span>dev_attrs</span><span>;</span>
        <span>struct</span> <span>driver_attribute</span> <span>*</span><span>drv_attrs</span><span>;</span>
        <span>struct</span> <span>subsys_private</span> <span>*</span><span>p</span><span>;</span>
        <span>int</span>   <span>(</span><span>*</span><span>match</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>,</span> <span>struct</span> <span>device_driver</span> <span>*</span><span>drv</span><span>);</span>
        <span>int</span>   <span>(</span><span>*</span><span>uevent</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>,</span> <span>struct</span> <span>kobj_uevent_env</span> <span>*</span><span>env</span><span>);</span>
        <span>int</span>   <span>(</span><span>*</span><span>probe</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
        <span>int</span>   <span>(</span><span>*</span><span>remove</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
        <span>//...</span>
<span>};</span></code></pre></figure>

<p>Kernel buses are the connective tissue of everything, the base of the
infrastructure. As you can see from the structure it’s responsible for
probing the device to get info about it, handling connected/disconnected
events, creating a new node for it, and sending uevent to notify
user-space and triggering a chain reaction.</p>

<p>A concrete example of this recursion:</p>

<ul>
  <li>A PCI bus controller (the host bridge) is a device on the platform bus.</li>
  <li>The USB bus (usbcore) is a device on the PCI bus (via xHCI controller).</li>
  <li>The HID bus is a device on the USB bus (via usbhid).</li>
  <li>The specific HID protocol driver is a device on the HID bus</li>
</ul>

<p>The low level kernel buses such as the hardware bus/host controlers
generally don’t handle input data directly, though there are some bus/host
controller drivers that do register input devices to the input core,
bypassing everything else in the stack and acting as event sources. These
exceptions are usually for brightness control hotkeys, lid sensors,
built-in special functions keys, etc.. We have for example the drivers
<code>acpi_video</code>, <code>thinkpad_acpi</code>, <code>asus_wmi</code>, etc..</p>

<p>To know how to handle the devices and whether a driver needs to be loaded
from a module, all devices and buses have specially formatted IDs, to
tell us what kind of devices they are. The ID, which we call MODALIAS,
consists of vendor and product ID with some other subsystem-specific
values. Each bus and device has its own scheme for these IDs.</p>
<div><div><pre><code>MODALIAS=usb:v046DpC03Ed2000dc00dsc00dp00ic03isc01ip02
</code></pre></div></div>

<p>This is needed in case the driver isn’t built-in the kernel and instead
was an external module (<code>*.ko</code>). As a reminder, a driver is some piece
of code responsible for handling a type of device, and a module is a
piece of external kernel code that can be dynamically loaded at runtime
when needed. Depending on the distro choices, some drivers are set as
external modules that need to be loaded at runtime.</p>

<p>To achieve this, the kernel, after composing the MODALIAS string, sends
it within the uevent towards user-space. To complete this information,
each external kernel module comes with a list of known MODALIASes it can
handle, so that they can be loaded as needed. These lists are compiled
by programs such as <code>depmod</code> that creates files like <code>modules.alias</code>
in the kernel’s <code>/lib/modules</code> directory for all currently available
modules that aren’t built-in (<code>/lib/modules/VERSION</code>), and the built-in
ones (<code>modules.builtin</code>).</p>

<p>In theory that’s fine, this infrastructure model makes it easy to
dynamically load modules that are not already built-in, but we need
a piece of software in user-space to catch the events and perform the
actual loading. This is a role that udev embodies by calling <code>modprobe</code>
for every event that has a MODALIAS key, regardless of whether a module
needs loading or not. We’ll see more of udev but for now keep in mind
that its doing this hotplug mechanism.</p>

<p>If you’re curious, you can try this udev command to monitor the MODALIAS.</p>

<div><div><pre><code>devadm monitor --property
</code></pre></div></div>

<p>Yet, this doesn’t solve what happens to devices that were present at
boot and which need modules. The solution: there’s a file in the device
directory in sysfs with all the uevent generated at boot for every
devices in sysfs file system, appropriately named “uevent”. If you write
“add” to that file the kernel resends the same events as the one lost
during boot. So a simple loop over all uevent files in <code>/sys</code> triggers
all events again.</p>

<p>The MODALIAS value is also stored in sysfs along with the device
properties, here are a few commands to gather information on this:</p>

<div><div><pre><code>&gt; cat /sys/devices/pci0000:00/0000:00:10.0/modalias 
pci:v00001022d00007812sv00001025sd00000756bc0Csc03i30

&gt; modprobe --resolve-alias $(cat /sys/devices/\
 pci0000:00/0000:00:13.2/usb1/1-0:1.0/usb1-port3/modalias)
Not everything has an associated module

&gt; ls -l /sys/devices/pci0000:00/0000:00:10.0/driver
lrwxrwxrwx 1 root root 0 Oct 25 11:37 driver \
               -&gt; ../../../bus/pci/drivers/xhci_hcd

If the driver link exists, check which module implements it:
&gt; modprobe -R xhci_hcd
xhci_hcd

&gt; modinfo xhci_hcd
name:           xhci_hcd
filename:       (builtin)
license:        GPL
file:           drivers/usb/host/xhci-hcd
author:         Sarah Sharp
description:    &#39;eXtensible&#39; Host Controller (xHC) Driver
license:        GPL
file:           drivers/usb/host/xhci-hcd
description:    xHCI sideband driver for secondary interrupter management
parm:           link_quirk:Don&#39;t clear the chain bit on a link TRB (int)
parm:           quirks:Bit flags for quirks to be enabled as default (ullong)

For example that xhci_hcd module is builtin
</code></pre></div></div>

<p>So far we’ve learned two things: buses which devices are connected to,
and the MODALIAS mechanism to match modules and dynamically load drivers
that aren’t built-in. Let’s see the devices attached to buses as they
appear as kernel objects.</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>device</span> <span>{</span>
        <span>// …</span>
        <span>struct</span> <span>device</span>           <span>*</span><span>parent</span><span>;</span>
        <span>struct</span> <span>device_private</span>   <span>*</span><span>p</span><span>;</span>
        <span>struct</span> <span>kobject</span>          <span>kobj</span><span>;</span>
        <span>const</span> <span>char</span>              <span>*</span><span>init_name</span><span>;</span> <span>/* initial name of the device */</span>
        <span>// …</span>
        <span>struct</span> <span>bus_type</span>         <span>*</span><span>bus</span><span>;</span>       <span>/* type of bus device is on */</span>
        <span>struct</span> <span>device_driver</span>    <span>*</span><span>driver</span><span>;</span>    <span>/* which driver has allocated this
                                             device */</span>
        <span>// …</span>
        <span>const</span> <span>struct</span> <span>class</span>  <span>*</span><span>class</span><span>;</span>
        <span>// …</span>
        <span>void</span>    <span>(</span><span>*</span><span>release</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
<span>};</span></code></pre></figure>

<p>Along with the related driver:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>device_driver</span> <span>{</span>
         <span>const</span> <span>char</span>              <span>*</span><span>name</span><span>;</span>
         <span>struct</span> <span>bus_type</span>         <span>*</span><span>bus</span><span>;</span>
         <span>struct</span> <span>driver_private</span>   <span>*</span><span>p</span><span>;</span>
         <span>struct</span> <span>module</span>           <span>*</span><span>owner</span><span>;</span>
         <span>const</span> <span>char</span>              <span>*</span><span>mod_name</span><span>;</span>     <span>/* used for built-in modules */</span>
         <span>int</span>     <span>(</span><span>*</span><span>probe</span><span>)</span>        <span>(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
         <span>int</span>     <span>(</span><span>*</span><span>remove</span><span>)</span>       <span>(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
         <span>void</span>    <span>(</span><span>*</span><span>shutdown</span><span>)</span>     <span>(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
         <span>int</span>     <span>(</span><span>*</span><span>suspend</span><span>)</span>      <span>(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>,</span> <span>pm_message_t</span> <span>state</span><span>);</span>
         <span>int</span>     <span>(</span><span>*</span><span>resume</span><span>)</span>       <span>(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
<span>};</span></code></pre></figure>

<p>As you can notice, they also have a probing and lifecycle functions to
be implemented. We also have the registration/unregistration functions
(<code>input_register_device</code> and <code>input_unregister_device</code> in our case)
which will announce that the device is now available in the system (plus
a uevent and other user-space stuff). Each of the registered devices
have an entry in sysfs <code>/sys/devices</code>, along with the information about
its driver, and similar info in <code>/sys/class</code> and <code>/sys/bus</code>. The
device also creates files in devtmpfs that represent its interfaces. Let’s
note that devtmpfs is usually mounted by default to user-space as a virtual
filesystem on most distros.</p>

<p>To check whether devtmpfs is enabled, which is almost always the case today:</p>

<div><div><pre><code>&gt; zcat /proc/config.gz | grep DEVTMPFS
CONFIG_DEVTMPFS=y
CONFIG_DEVTMPFS_MOUNT=y
CONFIG_DEVTMPFS_SAFE=y

&gt; mount | grep devtmpfs
dev on /dev type devtmpfs (rw,nosuid,relatime,size=2720672k,\
   nr_inodes=680168,mode=755,inode64)

&gt; mount | grep sysfs
 sys on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
</code></pre></div></div>

<p>Devices are associated to classes and subsystems that handle them.
The subsystem we care about here is what we’ve seen in the earlier
section: the input core, the input device subsystem.</p>

<figure><pre><code data-lang="c"><span>subsys_initcall</span><span>(</span><span>input_init</span><span>);</span></code></pre></figure>

<p>As for the concept of a class, it’s a high-level view of the device
model, abstracting implementation details. For example there are drivers
for SCSI and ATA but both are in the disks class. Similarly, all input
devices are in the input class, which is what we care about. This is
a grouping mechanism, unrelated to how the devices are connected. They
can be found in sysfs <code>/sys/class/</code>.</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>class</span> <span>{</span>
         <span>const</span> <span>char</span>              <span>*</span><span>name</span><span>;</span>
         <span>struct</span> <span>module</span>           <span>*</span><span>owner</span><span>;</span>
         <span>struct</span> <span>kobject</span>          <span>*</span><span>dev_kobj</span><span>;</span>
         <span>struct</span> <span>subsys_private</span>   <span>*</span><span>p</span><span>;</span>
         <span>struct</span> <span>class_attribute</span>          <span>*</span><span>class_attrs</span><span>;</span>
         <span>struct</span> <span>class_device_attribute</span>   <span>*</span><span>class_dev_attrs</span><span>;</span>
         <span>struct</span> <span>device_attribute</span>         <span>*</span><span>dev_attrs</span><span>;</span>
         <span>int</span>     <span>(</span><span>*</span><span>dev_uevent</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>,</span> <span>struct</span> <span>kobj_uevent_env</span> <span>*</span><span>env</span><span>);</span>
         <span>void</span>    <span>(</span><span>*</span><span>class_release</span><span>)(</span><span>struct</span> <span>class</span> <span>*</span><span>class</span><span>);</span>
         <span>void</span>    <span>(</span><span>*</span><span>dev_release</span><span>)(</span><span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>);</span>
         <span>//...</span>
<span>};</span></code></pre></figure>

<p>In the input core:</p>

<figure><pre><code data-lang="c"><span>const</span> <span>struct</span> <span>class</span> <span>input_class</span> <span>=</span> <span>{</span>
    <span>.</span><span>name</span>       <span>=</span> <span>&#34;input&#34;</span><span>,</span>
    <span>.</span><span>devnode</span>    <span>=</span> <span>input_devnode</span><span>,</span>
<span>};</span></code></pre></figure>

<p>This completes our overview of the way the kernel perceives the different
types of objects it manages. However, that didn’t clarify how we ended
up with the example path above other than somehow having a kernel bus and
device hierarchy.</p>

<p>The IO layer is responsible for handling the physical electrical
communication with the device, it’s setup, and management. At this level
we have USB, Bluetooth, I2C, SPI, etc.. In drivers that means: <code>usbhid</code>
for HID devices over USB, <code>btusb</code> and <code>hidp</code> for HID over Bluetooth,
<code>i2c-hid</code> for touchpads and keyboards that are wired to the motherboard’s
I2C, <code>psmouse</code> and <code>serio</code> for PS2 mouse, etc..</p>

<p>A few examples:</p>

<ul>
  <li>There’s a mouse communication protocol usin 9 pins DE-9 over the RS-232
standard for communication with UART</li>
  <li>The PS/2 mouse which uses a serial transport protocol with 6 pins (<code>serio</code>)</li>
  <li>The atkbd keyboard also over serial transport</li>
  <li>A gamepad that uses HID but the particular case of a sony joystick over USB</li>
  <li>A touchscreen specific driver using I²C or SPI</li>
</ul>

<p>Or as a hierarchical example:</p>

<div><div><pre><code>[PCI bus]
   └── probes -&gt; xhci_hcd (a PCI driver)
         └── registers usb_hcd with -&gt; [USB core]
                 └── enumerates and manages -&gt; [USB bus]
                        └── matches -&gt; usbhid (a USB driver)
                               └── registers -&gt; [HID bus]
                                      └── matches -&gt; hid-generic, hid-apple, ...
                                            └── registers -&gt; [Input bus]
                                                  └── matches -&gt; evdev, ...
</code></pre></div></div>

<p>There’s another component of complexity to add: we don’t have a
single protocol for a single transport over a single hardware bus/host
controller. Sometimes there’s a generic protocol layer which is reused
with different transport mechanisms. There can also be a delegation
mechanism for the more specific sub-protocol handlers for specific
devices or modes.</p>

<p>We’ll see an example of this by diving into the HID subsystem which is
the most popular input protocol these days, but first let’s check some
tools that can help us see all that we’ve learned thus far and make
sense of the hierarchy:</p>

<ul>
  <li><code>lspci -vn</code> list info about devices connected via PCI buses</li>
  <li><code>lsusb -v</code> or <code>usb-devices</code> list usb devices information in a more human readable form</li>
  <li><code>dmesg</code> the sys logs</li>
  <li><code>hwinfo --short</code> to probe hardware</li>
</ul>

<p>Yet the best way to get a lot of info about the bus and device hierarchy
is to rely on <code>udevadm</code>, a user-space tool that comes with udev. Here’s
how it looks for an input device:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> udevadm info <span>-a</span> <span>-p</span> <span>$(</span>udevadm info <span>-q</span> path <span>-n</span> /dev/input/event9<span>)</span>


looking at device <span>&#39;/devices/.../input/input6/event9&#39;</span>:
  <span>KERNEL</span><span>==</span><span>&#34;event9&#34;</span>
  <span>SUBSYSTEM</span><span>==</span><span>&#34;input&#34;</span>
  ATTR<span>{</span>name<span>}==</span><span>&#34;Logitech USB Keyboard&#34;</span>
  ...
looking at parent device <span>&#39;/devices/.../input/input6&#39;</span>:
  <span>KERNEL</span><span>==</span><span>&#34;input6&#34;</span>
  <span>SUBSYSTEM</span><span>==</span><span>&#34;input&#34;</span>
  ...
looking at parent device <span>&#39;/devices/.../0003:046D:C31C.0003&#39;</span>:
  <span>KERNELS</span><span>==</span><span>&#34;0003:046D:C31C.0003&#34;</span>
  <span>DRIVERS</span><span>==</span><span>&#34;hid-generic&#34;</span>
  <span>SUBSYSTEMS</span><span>==</span><span>&#34;hid&#34;</span>
  ...
looking at parent device <span>&#39;/devices/.../1-1:1.0&#39;</span>:
  <span>KERNELS</span><span>==</span><span>&#34;1-1:1.0&#34;</span>
  <span>SUBSYSTEMS</span><span>==</span><span>&#34;usb&#34;</span>
  <span>DRIVERS</span><span>==</span><span>&#34;usbhid&#34;</span>
  ...
looking at parent device <span>&#39;/devices/.../1-1&#39;</span>:
  <span>KERNELS</span><span>==</span><span>&#34;1-1&#34;</span>
  <span>SUBSYSTEMS</span><span>==</span><span>&#34;usb&#34;</span>
  <span>DRIVERS</span><span>==</span><span>&#34;usb&#34;</span>
  ...
looking at parent device <span>&#39;/devices/.../0000:00:14.0&#39;</span>:
  <span>KERNELS</span><span>==</span><span>&#34;0000:00:14.0&#34;</span>
  <span>SUBSYSTEMS</span><span>==</span><span>&#34;pci&#34;</span>
  <span>DRIVERS</span><span>==</span><span>&#34;ohci-pci&#34;</span>
  ...</code></pre></figure>

<p><em>NB</em>: It is also a bit more clearer, though for the moment confusing,
to also look at <code>udevadm info --tree</code>. Similarly, the <code>loginctl
seat-status</code> also clearly shows the hierarchy of devices in the current
session. We’ll talk more about the concept of seats later on.</p>

<p>We see the “looking at parent device” block that corresponds to one
<code>struct device</code> in the kernel kobject mapped in sysfs, along with the
driver, when it’s present, and other info it gathers at every step,
walking down the bus hierarchy. Let’s note that not everything has
an associated driver since the hardware topology might not match the
driver topology. That often means one kernel component handles multiple
parts of the stack. In the above trace, <code>hid-generic</code> handles the input
registering.</p>

<p>This example in particular shows:</p>

<div><div><pre><code>PCI → USB controller → USB device → HID interface → input device → evdev node
</code></pre></div></div>

<p>Another source of information that we briefly mentioned is the procfs
introspection interface (<code>/proc/bus/input/</code>), it can also help see the
handling of input devices more clearly as it’s a text-based view of what
the kernel input subsystem knows. It is more or less analogous to the
sysfs view but is meant for human-readable diagnostics. In conjunction
with what we’ve learned in the previous input core section, it should
clarify some of our understanding.  It has two files underneath: <code>devices</code>
and <code>handlers</code>.</p>

<p>The <code>devices</code> file contain all the current input devices and has entries
with these fields:</p>

<ul>
  <li><code>I</code>: basic info (bus type, vendor/product/version)</li>
  <li><code>N</code>: name</li>
  <li><code>P</code>: physical path (e.g., <code>isa0060/serio0/input0</code>)</li>
  <li><code>S</code>: sysfs path</li>
  <li><code>U</code>: unique identifier (if provided)</li>
  <li><code>H</code>: list of event handler interfaces bound (like <code>event3</code>, <code>js0</code>, etc.)</li>
  <li><code>B</code>: capability bitmaps (<code>EV</code>, <code>KEY</code>, <code>REL</code>, <code>ABS</code>, etc.) we’ll explore what
this means when looking at evdev</li>
</ul>

<p>For instance:</p>

<figure><pre><code data-lang="shell">I: <span>Bus</span><span>=</span>0003 <span>Vendor</span><span>=</span>1a2c <span>Product</span><span>=</span>6004 <span>Version</span><span>=</span>0110
N: <span>Name</span><span>=</span><span>&#34;SEMICO USB Keyboard Consumer Control&#34;</span>
P: <span>Phys</span><span>=</span>usb-0000:00:12.0-1/input1
S: <span>Sysfs</span><span>=</span>/devices/pci0000:00/0000:00:12.0/usb2/2-1/<span>\</span>
   2-1:1.1/0003:1A2C:6004.001E/input/input53
U: <span>Uniq</span><span>=</span>
H: <span>Handlers</span><span>=</span>kbd event7 
B: <span>PROP</span><span>=</span>0
B: <span>EV</span><span>=</span>1f
B: <span>KEY</span><span>=</span>33eff 0 0 483ffff17aff32d bfd4444600000000 1 <span>\</span>
   130c730b17c000 267bfad9415fed 9e168000004400 10000002
B: <span>REL</span><span>=</span>1040
B: <span>ABS</span><span>=</span>100000000
B: <span>MSC</span><span>=</span>10

I: <span>Bus</span><span>=</span>0003 <span>Vendor</span><span>=</span>1a2c <span>Product</span><span>=</span>6004 <span>Version</span><span>=</span>0110
N: <span>Name</span><span>=</span><span>&#34;SEMICO USB Keyboard System Control&#34;</span>
P: <span>Phys</span><span>=</span>usb-0000:00:12.0-1/input1
S: <span>Sysfs</span><span>=</span>/devices/pci0000:00/0000:00:12.0/usb2/2-1/<span>\</span>
   2-1:1.1/0003:1A2C:6004.001E/input/input54
U: <span>Uniq</span><span>=</span>
H: <span>Handlers</span><span>=</span>kbd event9 
B: <span>PROP</span><span>=</span>0
B: <span>EV</span><span>=</span>13
B: <span>KEY</span><span>=</span>c000 10000000000000 0
B: <span>MSC</span><span>=</span>10</code></pre></figure>

<p>Here you can see that a single physical device can possibly present
itself as multiple input devices with different handlers attached for
separate functions (here the keys of the System Control handler are
fewer). Here, <code>kbd</code> is console handler, and <code>eventN</code> is the evdev
user-space handler. Libinput, which we’ll cover later, uses groups
<code>LIBINPUT_DEVICE_GROUP</code> to logically combine the different devices that
are actually on the same hardware.</p>

<p>The handlers file is about instances of the <code>input_handler</code> that will
be called from input core’s <code>input_event</code> we mentioned before. As we
said most of it is handled by evdev, but there are exceptions such as:</p>

<figure><pre><code data-lang="shell">N: <span>Number</span><span>=</span>0 <span>Name</span><span>=</span>kbd
N: <span>Number</span><span>=</span>1 <span>Name</span><span>=</span>leds
N: <span>Number</span><span>=</span>2 <span>Name</span><span>=</span>evdev <span>Minor</span><span>=</span>64
N: <span>Number</span><span>=</span>3 <span>Name</span><span>=</span>sysrq <span>(</span>filter<span>)</span>
N: <span>Number</span><span>=</span>4 <span>Name</span><span>=</span>rfkill
N: <span>Number</span><span>=</span>5 <span>Name</span><span>=</span>mousedev <span>Minor</span><span>=</span>32
N: <span>Number</span><span>=</span>6 <span>Name</span><span>=</span>joydev <span>Minor</span><span>=</span>0</code></pre></figure>

<p>We’ll talk about joydev later on. As for mousedev, it is there only for
legacy compatibility of old <code>/dev/psaux</code>-style mouse interface.</p>

<p>Let’s now see the example of a dummy input driver, to get the idea across.</p>

<figure><pre><code data-lang="c"><span>// SPDX-License-Identifier: GPL-2.0</span>
<span>#include</span> <span>&lt;linux/module.h&gt;</span><span>
#include</span> <span>&lt;linux/init.h&gt;</span><span>
#include</span> <span>&lt;linux/input.h&gt;</span><span>
#include</span> <span>&lt;linux/timer.h&gt;</span><span>
</span>
<span>static</span> <span>struct</span> <span>input_dev</span> <span>*</span><span>dummy_input_dev</span><span>;</span>
<span>static</span> <span>struct</span> <span>timer_list</span> <span>dummy_timer</span><span>;</span>

<span>static</span> <span>void</span> <span>dummy_timer_func</span><span>(</span><span>struct</span> <span>timer_list</span> <span>*</span><span>t</span><span>)</span>
<span>{</span>
    <span>static</span> <span>bool</span> <span>key_down</span> <span>=</span> <span>false</span><span>;</span>

    <span>/* Simulate key press/release of KEY_A */</span>
    <span>key_down</span> <span>=</span> <span>!</span><span>key_down</span><span>;</span>
    <span>input_event</span><span>(</span><span>dummy_input_dev</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>KEY_A</span><span>,</span> <span>key_down</span><span>);</span>
    <span>input_event</span><span>(</span><span>dummy_input_dev</span><span>,</span> <span>EV_SYN</span><span>,</span> <span>SYN_REPORT</span><span>,</span> <span>0</span><span>);</span>

    <span>/* Reschedule timer */</span>
    <span>mod_timer</span><span>(</span><span>&amp;</span><span>dummy_timer</span><span>,</span> <span>jiffies</span> <span>+</span> <span>msecs_to_jiffies</span><span>(</span><span>2000</span><span>));</span>
<span>}</span>

<span>static</span> <span>int</span> <span>__init</span> <span>dummy_input_init</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>int</span> <span>err</span><span>;</span>

    <span>dummy_input_dev</span> <span>=</span> <span>input_allocate_device</span><span>();</span>
    <span>if</span> <span>(</span><span>!</span><span>dummy_input_dev</span><span>)</span>
        <span>return</span> <span>-</span><span>ENOMEM</span><span>;</span>

    <span>dummy_input_dev</span><span>-&gt;</span><span>name</span> <span>=</span> <span>&#34;Dummy Input Device&#34;</span><span>;</span>
    <span>dummy_input_dev</span><span>-&gt;</span><span>phys</span> <span>=</span> <span>&#34;dummy/input0&#34;</span><span>;</span>
    <span>dummy_input_dev</span><span>-&gt;</span><span>id</span><span>.</span><span>bustype</span> <span>=</span> <span>BUS_VIRTUAL</span><span>;</span>
    <span>dummy_input_dev</span><span>-&gt;</span><span>id</span><span>.</span><span>vendor</span>  <span>=</span> <span>0x0001</span><span>;</span>
    <span>dummy_input_dev</span><span>-&gt;</span><span>id</span><span>.</span><span>product</span> <span>=</span> <span>0x0001</span><span>;</span>
    <span>dummy_input_dev</span><span>-&gt;</span><span>id</span><span>.</span><span>version</span> <span>=</span> <span>0x0100</span><span>;</span>

    <span>/* Declare we can emit key events */</span>
    <span>__set_bit</span><span>(</span><span>EV_KEY</span><span>,</span> <span>dummy_input_dev</span><span>-&gt;</span><span>evbit</span><span>);</span>
    <span>__set_bit</span><span>(</span><span>KEY_A</span><span>,</span> <span>dummy_input_dev</span><span>-&gt;</span><span>keybit</span><span>);</span>

    <span>err</span> <span>=</span> <span>input_register_device</span><span>(</span><span>dummy_input_dev</span><span>);</span>
    <span>if</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
        <span>input_free_device</span><span>(</span><span>dummy_input_dev</span><span>);</span>
        <span>return</span> <span>err</span><span>;</span>
    <span>}</span>

    <span>/* Setup a timer to inject key events periodically */</span>
    <span>timer_setup</span><span>(</span><span>&amp;</span><span>dummy_timer</span><span>,</span> <span>dummy_timer_func</span><span>,</span> <span>0</span><span>);</span>
    <span>mod_timer</span><span>(</span><span>&amp;</span><span>dummy_timer</span><span>,</span> <span>jiffies</span> <span>+</span> <span>msecs_to_jiffies</span><span>(</span><span>2000</span><span>));</span>

    <span>pr_info</span><span>(</span><span>&#34;dummy_input: registered fake input device</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span> <span>__exit</span> <span>dummy_input_exit</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>del_timer_sync</span><span>(</span><span>&amp;</span><span>dummy_timer</span><span>);</span>
    <span>input_unregister_device</span><span>(</span><span>dummy_input_dev</span><span>);</span>
    <span>pr_info</span><span>(</span><span>&#34;dummy_input: unregistered</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>

<span>module_init</span><span>(</span><span>dummy_input_init</span><span>);</span>
<span>module_exit</span><span>(</span><span>dummy_input_exit</span><span>);</span>

<span>MODULE_AUTHOR</span><span>(</span><span>&#34;Example Author&#34;</span><span>);</span>
<span>MODULE_DESCRIPTION</span><span>(</span><span>&#34;Minimal Dummy Input Device&#34;</span><span>);</span>
<span>MODULE_LICENSE</span><span>(</span><span>&#34;GPL&#34;</span><span>);</span></code></pre></figure>

<p>That’s it, you should now somewhat have an idea of how we pass from
hardware events, to kernel objects, and end up within the input core
subsystem, which should prepare events for user-space. Let’s now dig on
and explore a few of the topics we’ve grazed in the past two sections.</p>



<p>We already covered a lot of ground in understanding sysfs, so let’s
continue and summarize everything we know and complete the full picture.</p>

<p>As we briefly said before, sysfs is a virtual file system representation in
user-space of the kernel objects and their attributes, it’s how the kernel
views the current state of the system, and also how the user can interface
with the parameters of the kernel in a centralized manner. It’s all done
in a very Unixy way by manipulating simple files.</p>

<p>The object information is categorized as one of the following. Each of
these is a sub-directory under <code>/sys/</code>.</p>

<ul>
  <li>block - all block devices available in the system (disks, partitions)</li>
  <li>bus - types of bus to which physical devices are connected (pci, ide, usb)</li>
  <li>class - drivers classes that are available in the system (net, sound, usb)</li>
  <li>devices - the hierarchical structure of devices connected to the system</li>
  <li>dev - Major and minor device identifier. It can be used to automatically
create entries in the <code>/dev</code> directory. It’s another categorization of
the devices directory</li>
  <li>firmware - information from system firmware (ACPI)</li>
  <li>fs - information about mounted file systems</li>
  <li>kernel - kernel status information (logged-in users, hotplug)</li>
  <li>module - the list of modules currently loaded</li>
  <li>power - information related to the power management subsystem
information is found in standard files that contain an attribute</li>
  <li>device (optionally) - a symbolic link to the directory containing devices; It can be used to discover the hardware devices that provide a particular service (for example, the ethi PCI card)</li>
  <li>driver (optionally) - a symbolic link to the driver directory (located in <code>/sys/bus/*/drivers</code> )</li>
</ul>

<p>As far as we’re concerned, when it comes to input devices, the
<code>/sys/devices/</code> directory is probably one of the most important. It’s
the representation of the hierarchy of devices we’ve talked about in
the previous section.</p>

<p>Furthermore, the <code>/sys/bus</code> directory organizes devices by the type of
bus they are connected to. You can imagine that this isn’t a linear
view since buses can have buses as devices (<code>usb</code> and <code>hid</code> each have
their directory even though <code>hid</code> is probably under <code>usb</code>), but it it
helpful to perceive what is happening, an easy shortcut. Within each
bus directory there are two subdirectories: drivers, that contains the
driver registered for the bus, and devices, that contains symbolic links
to the devices connected to that bus in <code>/sys/devices</code>.</p>

<p>Similarly, the <code>/sys/class</code> directory has another view of the system
from a more functional/type perspective. It’s about what devices do and
not how they’re connected. As far as we’re concerned, the subdirectory
<code>/sys/class/input/</code> is where we’ll find symbolic links to all devices
that have the input class in <code>/sys/devices</code>.</p>

<p>Finally, the last directory that is of interest to us in sysfs is
<code>/sys/module/</code> which provides information and settings for all loaded
kernel modules (the ones that show with <code>lsmod</code>), their dependencies
and parameters.</p>

<div><div><pre><code>├── hid_generic
│   ├── drivers
│   │   └── hid:hid-generic -&gt; ../../../bus/hid/drivers/hid-generic
│   └── uevent

&gt; modinfo hid_generic
name:           hid_generic
filename:       (builtin)
license:        GPL
file:           drivers/hid/hid-generic
description:    HID generic driver
author:         Henrik Rydberg
</code></pre></div></div>

<p>Lastly, and it might not need to be mentioned, but sysfs needs to be
enabled in the kernel confs. It always is these days since it’s expected
by many software.</p>

<div><div><pre><code>CONFIG_SYSFS=y
</code></pre></div></div>



<p>HID, or Human Interface Device, has been mentioned and sprinkled all
over the place in the last sections, we said it’s a device protocol but
what is it exactly?</p>

<p>HID is probably the most important input/output standard device protocol
these days, it’s literally everywhere and most new devices, from mice
to microphones, speak it over all types of transports such as USB, i2c,
Bluetooth, BLE, etc… It’s popular because it’s a universal way to let the
device first describe its capabilities (buttons, keys, axis, etc..),
what it can send/receive (Report Descriptor), and then send/receive them in
the expected way (Input/Output/Feature Reports).</p>

<p>The current list of HID devices can be found under the HID
bus in syfs, <code>/sys/bus/hid/devices/</code>. For each device, say
<code>/sys/bus/hid/devices/0003:1B3F:2008.003E/</code>, one can read the
corresponding report descriptor:</p>

<div><div><pre><code>&gt; hexdump -C /sys/bus/hid/devices/0003:1B3F:2008.003E/report_descriptor
00000000  05 0c 09 01 a1 01 15 00  25 01 09 e9 09 ea 75 01  |........%.....u.|
00000010  95 02 81 02 09 e2 09 cd  09 b5 09 b6 09 8c 95 05  |................|
00000020  81 06 09 00 95 01 81 02  c0                       |.........|
00000029
</code></pre></div></div>

<p>The raw HID reports can also be read from the <code>hidraw</code> file created by
hid core in devtmpfs <code>/dev/hidrawN</code>.</p>

<p>What does an input device HID Report and Report Descriptor look like?
We won’t go into too much details since the HID specifications are huge
but we’ll only do a tour to get an idea and be productive with what
we know. If you want to dive deeper, check the specifications
<a href="https://www.usb.org/hid">here</a>, it’s divided into a basic structure doc
“HID USB Device Class Definition”, and the HUT, “HID Usage Tables”, which
defines constants to be used by applications.</p>

<p>So as we said, the main logic of the protocol is that HID messages are
called Reports and that to parse them we need a Report Descriptor. The
Report Descriptor is a kind of hashmap stream, it contains Items, which
are 1B header followed by an optional payload of up-to 4B. The Items
don’t make sense by themselves, but do make sense together as a whole
when read as a full stream since each Item has a different meaning. Some
meaning apply locally and others globally.</p>

<p>The encapsulating and/or categorizing Items are the Usage Page, which
is a generic category of thing we’re describing, with its subset of
Usage, which is the specific thing we control within that Page. These
are defined in the “HID Usage Tables” doc. It’s things such as:</p>

<div><div><pre><code>Usage Page: Generic Desktop (0x01) Usage: Mouse (0x02)
Usage Page: Button (0x09)          Usage: Optional
Usage Page: Consumer Page (0x0C)   Usage: Numeric Key Pad (0x02)
</code></pre></div></div>

<p>It’s a couple of info to know how to better handle the HID internal data,
it tells you what is actually being handled.</p>

<p>Another grouping mechanism is the Collection, a broader category
to put together all that the device handles. Let’s say a mouse can
have both buttons, a scroll wheel, and axis it moves on, all within
a Collection. There are 3 types of collections that encapsulate each
others: Application (mandatory) the device-level group, Logical (optional)
sub-grouping for related controls, and Physical (optional) sub-grouping
for physical sensors.</p>

<p>Reports within Collections can also be grouped by IDs to facilitate
parsing.</p>

<p>Within all these, within the inner Collections, we finally have the
definition of what the Reports will actually look like. Here’s a subset
of what a Report Descriptor can look like:</p>

<div><div><pre><code>Report ID (01)
Usage Page (Button)
Usage Minimum (1)
Usage Maximum (5)
Report Count (5)
Report Size (1)
Input (Data,Var,Abs)

Report Size (3)
Report Count (1)
Input (Cnst,Arr,Abs)

Usage Page (Generic Desktop)
Usage (X)
Usage (Y)
Report Count (2)
Report Size (16)
Logical Minimum (-32767)
Logical Maximum (32767)
Input (Data,Var,Rel)
</code></pre></div></div>

<p>This is all a single report with ID <code>0x01</code>, and we see first that within
the Button page we have values ranging from 1 to 5, a count of fields
in the current report size of 5, for 5 buttons each having one bit. The
<code>Input</code> Item tells us to start processing the Report as input data (there’s
also <code>Output</code> and <code>Feature</code>). It also indicates that buttons have absolute
values, unlike the X/Y axis which are relative.</p>

<p>The <code>Cnst</code> of the following data in the stream stands for constant,
and it’s basically ignored, it’s padding.</p>

<p>And so on, we parse the data afterward, the X/Y relative movements.</p>

<p>One thing to note, is the scope of the meaning of the Items. Some apply
globally, such as the Usage Page, Logical Min/Max, Report Size, Report
Count, etc.. Meanwhile, Usage only apply locally and needs to be set
again. Other Items have special meaning such as Input, Output, Feature,
Collection and End Collection, and are about defining the structure of
data and when to process it.</p>

<p>Here’s a full real example with the Collection grouping mechanism:</p>

<div><div><pre><code>Usage Page (Generic Desktop)
Usage (Mouse)
Collection (Application)
 Usage Page (Generic Desktop)
 Usage (Mouse)
 Collection (Logical)
  Report ID (26)
  Usage (Pointer)
  Collection (Physical)

   Usage Page (Button)
   Usage Minimum (1)
   Usage Maximum (5)
   Report Count (5)
   Report Size (1)
   Logical Minimum (0)
   Logical Maximum (1)
   Input (Data,Var,Abs)

   Report Size (3)
   Report Count (1)
   Input (Cnst,Arr,Abs)

   Usage Page (Generic Desktop)
   Usage (X)
   Usage (Y)
   Report Count (2)
   Report Size (16)
   Logical Minimum (-32767)
   Logical Maximum (32767)
   Input (Data,Var,Rel)

   Usage (Wheel)
   Physical Minimum (0)
   Physical Maximum (0)
   Report Count (1)
   Report Size (16)
   Logical Minimum (-32767)
   Logical Maximum (32767)
   Input (Data,Var,Rel)
  End Collection
 End Collection
End Collection
</code></pre></div></div>

<p>As you can see, lots of it may seem redundant within the Logical and
Physical optional sub-collections but they’re often there by default
for hierarchical grouping. They’re not mandatory but common.</p>

<p>From the kernel’s perspective, the transport bus notices that a device
is advertised as an HID class and then the data gets routed to the hid
core bus.</p>

<p>For example, this is what the USB transport might notice:</p>

<div><div><pre><code>bInterfaceClass    = 0x03   ← USB_CLASS_HID
bInterfaceSubClass = 0x01   ← Boot Interface Subclass (optional)
bInterfaceProtocol = 0x02   ← Mouse  (0x01 = Keyboard)
</code></pre></div></div>

<p>And you can clearly see similar ATTRS in the <code>udevadm</code> trace we took in
earlier in a previous section:</p>

<figure><pre><code data-lang="shell">looking at parent device <span>&#39;/devices/pci0000:00/0000:00:12.0/usb2/2-4/2-4:1.3&#39;</span>:
  <span>KERNELS</span><span>==</span><span>&#34;2-4:1.3&#34;</span>
  <span>SUBSYSTEMS</span><span>==</span><span>&#34;usb&#34;</span>
  <span>DRIVERS</span><span>==</span><span>&#34;usbhid&#34;</span>
  ATTRS<span>{</span>authorized<span>}==</span><span>&#34;1&#34;</span>
  ATTRS<span>{</span>bAlternateSetting<span>}==</span><span>&#34; 0&#34;</span>
  ATTRS<span>{</span>bInterfaceClass<span>}==</span><span>&#34;03&#34;</span>
  ATTRS<span>{</span>bInterfaceNumber<span>}==</span><span>&#34;03&#34;</span>
  ATTRS<span>{</span>bInterfaceProtocol<span>}==</span><span>&#34;00&#34;</span>
  ATTRS<span>{</span>bInterfaceSubClass<span>}==</span><span>&#34;00&#34;</span>
  ATTRS<span>{</span>bNumEndpoints<span>}==</span><span>&#34;01&#34;</span>
  ATTRS<span>{</span>supports_autosuspend<span>}==</span><span>&#34;1&#34;</span></code></pre></figure>

<p>The HID core subsystem is in charge of managing the lifecycle
(connect/disconnect/open/close), parsing the HID report descriptors
to understand the device capabilities. Once parsed, it dispatches
Reports to the HID drivers registered on the HID bus, each driver can
inspect the Usage Page and Usage to decide how and whether to handle
them. This is like a publish-subscribe mechanism. The most specific
registered driver (vendor specific) will match and handle Reports in
whatever way they see fit, otherwise the hid-generic driver is the
fallback.</p>

<p>Several <code>*_connect</code> hooks in the HID core subsystem allow attaching
handlers for different behavior that HID device provide. The most
important for us is the <code>hidinput_connect</code> for the <code>HID_CONNECT_HIDINPUT</code>,
to handle HID input devices. It’s default implementation lives in
<code>hid-input</code> (internally <code>hidinput_report_event</code>). Device specific drivers
can override this behavior if needed. The hid-input role is to bridge
with the input core, allocating and registering the input device via
<code>input_register_device</code>, which will in turn expose <code>/dev/input/eventN</code>,
as we’ve seen before, and translate HID Reports to evdev.</p>

<p>This looks somewhat like this:</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/hid_core.png" alt="HID Core Overview" title="HID Core Overview"/></p>

<p>This is all neat, let’s list a couple of tools that can help us debug
HID and inspect HID Reports Descriptors and Reports.</p>

<ul>
  <li><code>usbhid-dump</code> - will dump USB HID device report descriptors and streams</li>
  <li><a href="https://github.com/abend0c1/hidrdd">hidrdd</a> - verbose description of hid report descriptors</li>
  <li><code>hid-tools</code> - has many sub-tools such as replay, decode, and recording</li>
  <li><code>hid-replay</code> - to test and replay hid events</li>
  <li><a href="https://eleccelerator.com/usbdescreqparser">Online USB Descriptor and Request Parser</a></li>
</ul>

<p>The simplest one in my opinion is hid-tools, here’s an example of a
keyboard with consumer control and system control, the same one we’ve
seen in the procfs introspection interface earlier (<code>/proc/bus/input/</code>):</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> hid-decode /sys/bus/hid/devices/0003:1A2C:6004.004F/report_descriptor

<span># device 0:0</span>

<span># 0x05, 0x0c,        // Usage Page (Consumer Devices)   0</span>
<span># 0x09, 0x01,        // Usage (Consumer Control)        2</span>
<span># 0xa1, 0x01,        // Collection (Application)        4</span>
<span># 0x85, 0x01,        //  Report ID (1)                  6</span>
<span># 0x19, 0x00,        //  Usage Minimum (0)              8</span>
<span># 0x2a, 0x3c, 0x02,  //  Usage Maximum (572)            10</span>
<span># 0x15, 0x00,        //  Logical Minimum (0)            13</span>
<span># 0x26, 0x3c, 0x02,  //  Logical Maximum (572)          15</span>
<span># 0x95, 0x01,        //  Report Count (1)               18</span>
<span># 0x75, 0x10,        //  Report Size (16)               20</span>
<span># 0x81, 0x00,        //  Input (Data,Arr,Abs)           22</span>
<span># 0xc0,              // End Collection                  24</span>

<span># 0x05, 0x01,        // Usage Page (Generic Desktop)    25</span>
<span># 0x09, 0x80,        // Usage (System Control)          27</span>
<span># 0xa1, 0x01,        // Collection (Application)        29</span>
<span># 0x85, 0x02,        //  Report ID (2)                  31</span>
<span># 0x19, 0x81,        //  Usage Minimum (129)            33</span>
<span># 0x29, 0x83,        //  Usage Maximum (131)            35</span>
<span># 0x25, 0x01,        //  Logical Maximum (1)            37</span>
<span># 0x75, 0x01,        //  Report Size (1)                39</span>
<span># 0x95, 0x03,        //  Report Count (3)               41</span>
<span># 0x81, 0x02,        //  Input (Data,Var,Abs)           43</span>
<span># 0x95, 0x05,        //  Report Count (5)               45</span>
<span># 0x81, 0x01,        //  Input (Cnst,Arr,Abs)           47</span>
<span># 0xc0,              // End Collection                  49</span>
<span># </span>
R: 50 05 0c 09 01 a1 01 85 01 19 00 2a 3c 02 15 00 26 3c <span>\</span>
   02 95 01 75 10 81 00 c0 05 01 09 80 a1 01 85 02 19 81 <span>\</span>
   29 83 25 01 75 01 95 03 81 02 95 05 81 01 c0
N: device 0:0
I: 3 0001 0001</code></pre></figure>

<p>You can see it has two Application Collections, so that’s why we had
two entries for the keyboard.</p>

<p>In some cases, the HID Device Descriptor is wrong
and needs some patching, which can either be done in a
special driver, or on a live system dynamically by relying on
<a href="https://libevdev.pages.freedesktop.org/udev-hid-bpf/"><code>udev-hid-bpf</code></a>
which will be invoked before the kernel handles HID.</p>



<p>Let’s tackle the last piece of the exposed middle-layer that we didn’t
explain yet: The Event Device common protocol, the evdev layer.</p>

<p>From what we’ve seen, we know that evdev is a standardization interface,
it decouples and abstracts the underlying devices. It could be a USB
keyboard, a Bluetooth pointer, or PS/2 device, and all the user needs
is to read from the evdev interface, without worrying about their
differences.</p>

<p>It works because evdev registers itself as the default input handler in
the input core, and the main job of most input driver is to translate
to it:</p>

<figure><pre><code data-lang="c"><span>static</span> <span>struct</span> <span>input_handler</span> <span>evdev_handler</span> <span>=</span> <span>{</span>
	<span>.</span><span>events</span>		<span>=</span> <span>evdev_events</span><span>,</span>
	<span>.</span><span>connect</span>	<span>=</span> <span>evdev_connect</span><span>,</span>
	<span>.</span><span>disconnect</span>	<span>=</span> <span>evdev_disconnect</span><span>,</span>
	<span>.</span><span>legacy_minors</span>	<span>=</span> <span>true</span><span>,</span>
	<span>.</span><span>minor</span>		<span>=</span> <span>EVDEV_MINOR_BASE</span><span>,</span>
	<span>.</span><span>name</span>		<span>=</span> <span>&#34;evdev&#34;</span><span>,</span>
	<span>.</span><span>id_table</span>	<span>=</span> <span>evdev_ids</span><span>,</span>
<span>};</span></code></pre></figure>

<p>When its “connect” event is fired, it creates the corresponding evdev
node in <code>/dev/input/eventN</code>. Furthermore, the info is also reflected
in sysfs within the <code>/sys/class/input/eventN</code> directory along with its
related <code>/sys/class/input/inputN</code> device created by the input core, which
it is the children of (<code>eventN</code> within <code>inputN</code>).</p>

<p>The evdev driver also supports certain ioctl to query
its internal state, let a client handle exclusively grab a
device (<code>EVIOCGRAB</code>), or change certain values. The list of ioctl can be found
<a href="https://www.freedesktop.org/software/libevdev/doc/latest/ioctls.html">here</a>
within libevdev, though libevdev doesn’t support all of them (the list
can also be found in <code>include/linux/input.h</code>).</p>

<p>Let’s see what the evdev format is about, and how the input core
translates to it and generates the events.</p>

<p>The evdev protocol is stateful, it doesn’t forward everything to
user-space but only does when it notices a change. To inquire about
its current state one can rely on ioctl instead.</p>

<p>The format of evdev is composed of a series of <code>input_event</code> (from
<code>include/linux/input.h</code>) which look like the structure here under,
grouped in what’s called a sequence or a frame:</p>

<figure><pre><code data-lang="c"><span>struct</span> <span>input_event</span> <span>{</span>
 <span>struct</span> <span>timeval</span> <span>time</span><span>;</span>
 <span>__u16</span> <span>type</span><span>;</span>
 <span>__u16</span> <span>code</span><span>;</span>
 <span>__s32</span> <span>value</span><span>;</span>
<span>};</span></code></pre></figure>

<p>Basically a timestamp along with a type-code couple and an associated
value. The type is the general category to which this event is part of,
and the code the sub-category. For example it could be a relative movement
(type), on the x-axis (code), of 1 unit (value). The available types of
events and codes can be found under <code>include/linux/input-event-codes.h</code>.</p>

<p>The most common types are:</p>

<ul>
  <li><code>EV_KEY</code>: buttons and keyboards</li>
  <li><code>EV_REL</code>: relative events, on axis or others</li>
  <li><code>EV_ABS</code>: absolute axis value, coordinates, touchscreens</li>
</ul>

<p>Each frame ends whenever a synchronization event comes up, the most
common is of type.code(value) <code>EV_SYN.SYN_REPORT(0)</code>. It’s the marker
that it’s time to make sense of the stream, the whole frame.</p>

<p>An example snapshot of a frame of an “absolute touchpad” would look
like this:</p>

<div><div><pre><code>E: 30.920519 0003 0018 0031     # EV_ABS / ABS_PRESSURE         31
E: 30.920519 0000 0000 0000     # ------------ SYN_REPORT (0) ---------- +13ms
E: 30.933332 0003 0035 2103     # EV_ABS / ABS_MT_POSITION_X    2103
E: 30.933332 0003 0036 1876     # EV_ABS / ABS_MT_POSITION_Y    1876
E: 30.933332 0003 003a 0029     # EV_ABS / ABS_MT_PRESSURE      29
E: 30.933332 0003 0000 2103     # EV_ABS / ABS_X                2103
E: 30.933332 0003 0001 1876     # EV_ABS / ABS_Y                1876
E: 30.933332 0003 0018 0029     # EV_ABS / ABS_PRESSURE         29
E: 30.933332 0000 0000 0000     # ------------ SYN_REPORT (0) ---------- +13ms
E: 30.946156 0003 003a 0017     # EV_ABS / ABS_MT_PRESSURE      17
E: 30.946156 0003 0018 0017     # EV_ABS / ABS_PRESSURE         17
E: 30.946156 0000 0000 0000     # ------------ SYN_REPORT (0) ---------- +13ms
E: 30.959094 0003 0039 -001     # EV_ABS / ABS_MT_TRACKING_ID   -1
E: 30.959094 0001 014a 0000     # EV_KEY / BTN_TOUCH            0
E: 30.959094 0001 0145 0000     # EV_KEY / BTN_TOOL_FINGER      0
E: 30.959094 0003 0018 0000     # EV_ABS / ABS_PRESSURE         0
E: 30.959094 0000 0000 0000     # ------------ SYN_REPORT (0) ---------- +13ms
</code></pre></div></div>

<p>And of a keyboard:</p>

<div><div><pre><code>E: 0.000000 0004 0004 458792    # EV_MSC / MSC_SCAN             458792
E: 0.000000 0001 001c 0000      # EV_KEY / KEY_ENTER            0
E: 0.000000 0000 0000 0000      # ------------ SYN_REPORT (0) ----------
E: 0.560004 0004 0004 458976    # EV_MSC / MSC_SCAN             458976
E: 0.560004 0001 001d 0001      # EV_KEY / KEY_LEFTCTRL         1
E: 0.560004 0000 0000 0000      # ------------ SYN_REPORT (0) ----------
[....]
E: 1.172732 0001 001d 0002      # EV_KEY / KEY_LEFTCTRL         2
E: 1.172732 0000 0000 0001      # ------------ SYN_REPORT (1) ----------
E: 1.200004 0004 0004 458758    # EV_MSC / MSC_SCAN             458758
E: 1.200004 0001 002e 0001      # EV_KEY / KEY_C                1
E: 1.200004 0000 0000 0000      # ------------ SYN_REPORT (0) ----------
</code></pre></div></div>

<p>As we’ve said, it’s stateful, so the events are only sent when there is a
state change, even when the hardware keeps resending the same event. So
for example, if a key is kept pressed, it won’t resend the event until
it’s released.</p>

<p>These events might seem simple on their own but are in fact absolutely
complex to handle, especially touchpads. There are many features such as
pressure, multi-touch, and the tracking of different fingers, which needs an
upper layer to make sense of all this. This is where libinput shines, and
we’ll see that later on. For now just keep in mind it’s a series of event.</p>

<p>So how do drivers use evdev to send events, we’ve talked about
<code>input_event</code> before, but how does it work.</p>

<p>Well, first of before sending any event, the input driver needs at the
registration phase to advertise to the system what it’s capable of,
to say what kind of events it can generate. These event “capabilities”,
as they’re called, are a couple of different bits in sets that are also
inspectable in sysfs <code>/sys/class/input/inputN/capabilities/</code>.</p>

<p>You’ll find the following types of capabilities:</p>

<ul>
  <li><code>ev</code>, set in <code>input_dev-&gt;evbit</code>, Which event types the device can generate (<code>EV_KEY</code>, <code>EV_REL</code>, etc.)</li>
  <li><code>key</code>, set in <code>input_dev-&gt;keybit</code>, Which key/button codes it supports</li>
  <li><code>rel</code>, set in <code>input_dev-&gt;relbit</code>, Which relative axes (e.g., REL_X, REL_WHEEL)</li>
  <li><code>abs</code>, set in <code>input_dev-&gt;absbit</code>, Which absolute axes (e.g., ABS_X, ABS_Y)</li>
  <li><code>led</code>, set in <code>input_dev-&gt;ledbit</code>, LED indicators (e.g., keyboard LEDs)</li>
  <li><code>sw</code> , set in <code>input_dev-&gt;swbit</code>,  Switch states (e.g., lid switch)</li>
  <li><code>ff</code> , set in <code>input_dev-&gt;ffbit</code>,  Force feedback capabilities</li>
  <li><code>msc</code>, set in <code>input_dev-&gt;mscbit</code>, Miscellaneous events</li>
  <li><code>snd</code>, set in <code>input_dev-&gt;sndbit</code>, Sound events</li>
</ul>

<p>As you can see, it’s somewhat related the HID capabilities in a sense,
but applies to all devices.</p>

<p>We’ve also seen these capabilities bits during our inspection of the
input core procfs interface <code>/proc/bus/input/</code> in the <code>B</code> field:</p>

<figure><pre><code data-lang="shell">I: <span>Bus</span><span>=</span>0003 <span>Vendor</span><span>=</span>1a2c <span>Product</span><span>=</span>6004 <span>Version</span><span>=</span>0110
N: <span>Name</span><span>=</span><span>&#34;SEMICO USB Keyboard Consumer Control&#34;</span>
P: <span>Phys</span><span>=</span>usb-0000:00:12.0-1/input1
S: <span>Sysfs</span><span>=</span>/devices/pci0000:00/0000:00:12.0/usb2/<span>\</span>
   2-1/2-1:1.1/0003:1A2C:6004.001E/input/input53
U: <span>Uniq</span><span>=</span>
H: <span>Handlers</span><span>=</span>kbd event7 
B: <span>PROP</span><span>=</span>0
B: <span>EV</span><span>=</span>1f
B: <span>KEY</span><span>=</span>33eff 0 0 483ffff17aff32d bfd4444600000000 <span>\</span>
   1 130c730b17c000 267bfad9415fed 9e168000004400 10000002
B: <span>REL</span><span>=</span>1040
B: <span>ABS</span><span>=</span>100000000
B: <span>MSC</span><span>=</span>10

I: <span>Bus</span><span>=</span>0003 <span>Vendor</span><span>=</span>1a2c <span>Product</span><span>=</span>6004 <span>Version</span><span>=</span>0110
N: <span>Name</span><span>=</span><span>&#34;SEMICO USB Keyboard System Control&#34;</span>
P: <span>Phys</span><span>=</span>usb-0000:00:12.0-1/input1
S: <span>Sysfs</span><span>=</span>/devices/pci0000:00/0000:00:12.0/usb2/<span>\</span>
   2-1/2-1:1.1/0003:1A2C:6004.001E/input/input54
U: <span>Uniq</span><span>=</span>
H: <span>Handlers</span><span>=</span>kbd event9 
B: <span>PROP</span><span>=</span>0
B: <span>EV</span><span>=</span>13
B: <span>KEY</span><span>=</span>c000 10000000000000 0
B: <span>MSC</span><span>=</span>10</code></pre></figure>

<p>However, parsing the bits manually in procfs or sysfs would be cumbersome,
it’s better to rely on tools such as <code>libinput record</code>, check the
<strong>“Supported Events”</strong> section:</p>

<figure><pre><code data-lang="shell">devices:
- node: /dev/input/event5
  evdev:
    <span># Name: SEMICO USB Keyboard</span>
    <span># ID: bus 0x0003 (usb) vendor 0x1a2c \</span>
    <span>#         product 0x6004 version 0x0110</span>
    <span># Supported Events:</span>
    <span># Event type 0 (EV_SYN)</span>
    <span># Event type 1 (EV_KEY)</span>
    <span>#   Event code 1 (KEY_ESC)</span>
    <span>#   Event code 2 (KEY_1)</span>
    <span>#   Event code 3 (KEY_2)</span>
    <span>#   Event code 4 (KEY_3)</span>
    …
    <span>#   Event code 12 (KEY_MINUS)</span>
    <span>#   Event code 13 (KEY_EQUAL)</span>
    <span>#   Event code 14 (KEY_BACKSPACE)</span>
    <span>#   Event code 15 (KEY_TAB)</span>
    <span>#   Event code 16 (KEY_Q)</span>
    …
    <span># Event type 4 (EV_MSC)</span>
    <span>#   Event code 4 (MSC_SCAN)</span>
    <span># Event type 17 (EV_LED)</span>
    <span>#   Event code 0 (LED_NUML)</span>
    <span>#       State 0</span>
    <span>#   Event code 1 (LED_CAPSL)</span>
    <span>#       State 0</span>
    <span>#   Event code 2 (LED_SCROLLL)</span>
    <span>#       State 0</span>
    <span># Event type 20 (EV_REP)</span>
    <span>#   Event code 0 (REP_DELAY)</span>
    <span>#   Event code 1 (REP_PERIOD)</span>
    <span># Properties:</span>
    name: <span>&#34;SEMICO USB Keyboard&#34;</span>
    <span>id</span>: <span>[</span>3, 6700, 24580, 272]
    codes:
      0: <span>[</span>0, 1, 2, 3, 4,…, 13, 14, 15] <span># EV_SYN</span>
      1: <span>[</span>1, 2, 3, 4, 5, 6, 7, 8, 9 …]
      4: <span>[</span>4] <span># EV_MSC</span>
      17: <span>[</span>0, 1, 2] <span># EV_LED</span>
      20: <span>[</span>0, 1] <span># EV_REP</span>
    properties: <span>[]</span>
  hid: <span>[</span>
    0x05, 0x01, 0x09, 0x06, 0xa1, 0x01, 0x05, 0x08, 0x19, 0x01, 0x29,
    0x03, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x03, 0x91, 0x02,
    0x95, 0x05, 0x91, 0x01, 0x05, 0x07, 0x19, 0xe0, 0x29, 0xe7, 0x95,
    0x08, 0x81, 0x02, 0x75, 0x08, 0x95, 0x01, 0x81, 0x01, 0x19, 0x00,
    0x29, 0x91, 0x26, 0xff, 0x00, 0x95, 0x06, 0x81, 0x00, 0xc0
  <span>]</span>
  udev:
    properties:
    - <span>ID_INPUT</span><span>=</span>1
    - <span>ID_INPUT_KEY</span><span>=</span>1
    - <span>ID_INPUT_KEYBOARD</span><span>=</span>1
    - <span>LIBINPUT_DEVICE_GROUP</span><span>=</span>3/1a2c/6004:usb-0000:00:12.0-1
    - <span>DRIVER</span><span>=</span>hid-generic
    virtual: <span>false</span></code></pre></figure>

<p>As you can see it also dumps more information such as the HID Report
Descriptor and the attached udev properties.</p>

<p>Here’s what you can see from the much longer list that a touchpad
generates:</p>

<div><div><pre><code># Input device name: &#34;SynPS/2 Synaptics TouchPad&#34;
# Input device ID: bus 0x11 vendor 0x02 \
#            product 0x07 version 0x1b1
# Supported events:
#   Event type 0 (EV_SYN)
#     Event code 0 (SYN_REPORT)
#     Event code 1 (SYN_CONFIG)
#     Event code 2 (SYN_MT_REPORT)
#     Event code 3 (SYN_DROPPED)
#     Event code 4 ((null))
#     Event code 5 ((null))
#     Event code 6 ((null))
#     Event code 7 ((null))
#     Event code 8 ((null))
#     Event code 9 ((null))
#     Event code 10 ((null))
#     Event code 11 ((null))
#     Event code 12 ((null))
#     Event code 13 ((null))
#     Event code 14 ((null))
#   Event type 1 (EV_KEY)
#     Event code 272 (BTN_LEFT)
#     Event code 325 (BTN_TOOL_FINGER)
#     Event code 328 (BTN_TOOL_QUINTTAP)
#     Event code 330 (BTN_TOUCH)
#     Event code 333 (BTN_TOOL_DOUBLETAP)
#     Event code 334 (BTN_TOOL_TRIPLETAP)
#     Event code 335 (BTN_TOOL_QUADTAP)
#   Event type 3 (EV_ABS)
#     Event code 0 (ABS_X)
#       Value   2919
#       Min     1024
#       Max     5112
#       Fuzz       0
#       Flat       0
#       Resolution 42
#     Event code 1 (ABS_Y)
#       Value   3711
#       Min     2024
#       Max     4832
#       Fuzz       0
#       Flat       0
#       Resolution 42
#     Event code 24 (ABS_PRESSURE)
#       Value      0
#       Min        0
#       Max      255
#       Fuzz       0
#       Flat       0
#       Resolution 0
#     Event code 28 (ABS_TOOL_WIDTH)
#       Value      0
#       Min        0
#       Max       15
#       Fuzz       0
#       Flat       0
#       Resolution 0
# Properties:
#   Property  type 0 (INPUT_PROP_POINTER)
#   Property  type 2 (INPUT_PROP_BUTTONPAD)
#   Property  type 4 (INPUT_PROP_TOPBUTTONPAD)
</code></pre></div></div>

<p>As a note, the Properties can let us know whether we’re dealing with
a touchscreen <code>INPUT_PROP_DIRECT</code>, or a touchpad <code>INPUT_PROP_POINTER</code>,
and <code>INPUT_PROP_BUTTONPAD</code> also tells us that it’s a so-called clickpad
(no separate physical buttons but the whole touchpad clicks). These are
hints for libinput to properly handle different kinds of devices.</p>

<p>So after registering its capabilities, the input driver simply reports
its events by relying on the <code>input_event</code> function, or one of it’s
many wrappers:</p>

<figure><pre><code data-lang="c"><span>void</span> <span>input_event</span><span>(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span> <span>unsigned</span> <span>int</span> <span>type</span><span>,</span> <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>);</span>

<span>static</span> <span>inline</span> <span>void</span> <span>input_report_key</span><span>(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span> <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>)</span>
<span>{</span>
	<span>input_event</span><span>(</span><span>dev</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>code</span><span>,</span> <span>!!</span><span>value</span><span>);</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>void</span> <span>input_report_rel</span><span>(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span> <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>)</span>
<span>{</span>
	<span>input_event</span><span>(</span><span>dev</span><span>,</span> <span>EV_REL</span><span>,</span> <span>code</span><span>,</span> <span>value</span><span>);</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>void</span> <span>input_report_abs</span><span>(</span><span>struct</span> <span>input_dev</span> <span>*</span><span>dev</span><span>,</span> <span>unsigned</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>value</span><span>)</span>
<span>{</span>
	<span>input_event</span><span>(</span><span>dev</span><span>,</span> <span>EV_ABS</span><span>,</span> <span>code</span><span>,</span> <span>value</span><span>);</span>
<span>}</span></code></pre></figure>

<p>That’s it mostly to understand evdev! There are multiple tools to help
debug evdev-related issues. We’ve seen <code>libinput record</code>. Similarly,
there’s the <code>evemu</code> suite with its record, device, play functions to
simulate and test devices, and <code>evtest</code>.</p>



<p>After going through the kernel and exposed layers, we’re finally in
user-space!</p>

<p>Udev, or the dynamic user-space device manager, implemented as the
udev daemon <code>systemd-udevd</code>, has as role to take actions whenever a
uevent (<code>PF_NETLINK, NETLINK_KOBJECT_UEVENT</code>) is sent from the kernel
to user-space. We’ve seen a few of the possible actions it performs,
here’s a summary of the kind of things it does:</p>

<ul>
  <li>Load kernel modules based on the uevent MODALIAS</li>
  <li>Set access rights on device nodes</li>
  <li>Attach properties to devices on detection</li>
  <li>Create symlinks so that devices have more predictable names</li>
  <li>Keep track internally of device info in its internal db</li>
  <li>Use its rule system to take any kind of action on plug/unplug of a device</li>
</ul>

<p>The most important part is the last point: udev has a set of rules against
which it can match devices and their attributes and take all sorts of
actions based on that. The fields it has access to not only come from the
uevents but also from all related info on the system.</p>

<p>These rules, as is the convention for pretty much all big daemons these
days, are read from system locations such as <code>/usr/lib/udev/rules.d</code>,
<code>/usr/local/lib/udev/rules.d</code>, and the volatile runtime in
<code>/run/udev/rules.d</code>, and from the local admin directory of
<code>/etc/udev/rules.d</code> which takes precedence over the other locations. The
directories contains files with a <code>.rules</code> extension and are processed and
ordered lexically (<code>01-example.rules</code> comes before <code>05-example.rules</code>).</p>

<p>Now the syntax of udev rules, which are mainly composed of matching
patterns and actions to perform or properties to set upon match, is
dense and complex (it even has branching). Only a deep study of <code>udev(7)</code>
man page will help. Yet, we can still learn the very basics of it to be
able to understand what’s happening.</p>

<p>The first example is quite simple, it will run a script when a specific
keyboard is plugged/unplugged.</p>

<figure><pre><code data-lang="shell"><span>ACTION</span><span>==</span><span>&#34;add&#34;</span>, <span>SUBSYSTEM</span><span>==</span><span>&#34;input&#34;</span>,
  ATTRS<span>{</span><span>id</span>/product<span>}==</span><span>&#34;6004&#34;</span>,
  ATTRS<span>{</span><span>id</span>/vendor<span>}==</span><span>&#34;1a2c&#34;</span>,
  RUN+<span>=</span><span>&#34;/bin/kbd_is_plugged&#34;</span>

<span>ACTION</span><span>==</span><span>&#34;remove&#34;</span>, <span>SUBSYSTEM</span><span>==</span><span>&#34;input&#34;</span>,
  ATTRS<span>{</span><span>id</span>/product<span>}==</span><span>&#34;6004&#34;</span>,
  ATTRS<span>{</span><span>id</span>/vendor<span>}==</span><span>&#34;1a2c&#34;</span>,
  RUN+<span>=</span><span>&#34;/bin/kbd_is_unplugged&#34;</span></code></pre></figure>

<p>The rule is pretty clear about what it does, on “add” or “remove” action
for specific match it’ll execute a script. But you’ll also notice that the
match components such as SUBSYSTEM and ATTRS are things we’ve seen before
in previous traces of <code>udevadm info</code>, which is exactly the point. <code>udevadm
info</code> will show us certain components we can used to match.</p>

<p>The second example is a tad bit more complex, we will parse
<code>/usr/lib/udev/rules.d/60-persistent-input.rules</code>. That file creates
a more persistent naming scheme for input devices in devtmpfs under
<code>/dev/input/by-id</code> and <code>/dev/input/by-path/</code>. Here’s a simplified version
of it.</p>

<figure><pre><code data-lang="shell"><span>ACTION</span><span>==</span><span>&#34;remove&#34;</span>, <span>GOTO</span><span>=</span><span>&#34;persistent_input_end&#34;</span>
SUBSYSTEM!<span>=</span><span>&#34;input&#34;</span>, <span>GOTO</span><span>=</span><span>&#34;persistent_input_end&#34;</span>
<span># …</span>

<span># determine class name for persistent symlinks</span>
ENV<span>{</span>ID_INPUT_KEYBOARD<span>}==</span><span>&#34;?*&#34;</span>, ENV<span>{</span>.INPUT_CLASS<span>}=</span><span>&#34;kbd&#34;</span>
ENV<span>{</span>ID_INPUT_MOUSE<span>}==</span><span>&#34;?*&#34;</span>, ENV<span>{</span>.INPUT_CLASS<span>}=</span><span>&#34;mouse&#34;</span>
<span># …</span>

<span># by-id links</span>
<span>KERNEL</span><span>==</span><span>&#34;event*&#34;</span>, ENV<span>{</span>ID_BUS<span>}==</span><span>&#34;?*&#34;</span>, ENV<span>{</span>.INPUT_CLASS<span>}==</span><span>&#34;?*&#34;</span>,
  ATTRS<span>{</span>bInterfaceNumber<span>}==</span><span>&#34;|00&#34;</span>,
  SYMLINK+<span>=</span><span>&#34;input/by-id/</span><span>$env</span><span>{ID_BUS}-</span><span>$env</span><span>{ID_SERIAL}-event-</span><span>$env</span><span>{.INPUT_CLASS}&#34;</span>

<span># by-path</span>
ENV<span>{</span>.INPUT_CLASS<span>}==</span><span>&#34;?*&#34;</span>, <span>KERNEL</span><span>==</span><span>&#34;event*&#34;</span>,
  ENV<span>{</span>ID_PATH<span>}==</span><span>&#34;?*&#34;</span>, 
  SYMLINK+<span>=</span><span>&#34;input/by-path/</span><span>$env</span><span>{ID_PATH}-event-</span><span>$env</span><span>{.INPUT_CLASS}&#34;</span>

<span># …</span>

<span>LABEL</span><span>=</span><span>&#34;persistent_input_end&#34;</span></code></pre></figure>

<p>We can see multiple things from this short example. First of all,
the branching mechanism with its use of <code>GOTO</code> whenever certain matches
don’t fit the specific use-case. We can also see the standard comparison
operators such as <code>==</code> and <code>!=</code>.</p>

<p>Yet, overall the idea makes sense. We create some string variable based
on what type of input device we’re dealing with (prepended with <code>.</code>
means it’s only temporary), which we found in <code>ENV{…}</code>, the device
properties. Then for event devices we create two symlink files in
different directories “by-id” and “by-path”. For the by-id it’s composed
of the bus name, followed by the device name, “-event-“, and the input
class we’ve stored in the temporary variable.</p>

<p>Let’s see how that would look for this device:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> udevadm info <span>-p</span> <span>$(</span>udevadm info <span>-q</span> path <span>-n</span> /dev/input/event7<span>)</span>
…
M: event7
…
N: input/event7
…
E: <span>DEVNAME</span><span>=</span>/dev/input/event7
E: <span>MAJOR</span><span>=</span>13
E: <span>MINOR</span><span>=</span>71
E: <span>SUBSYSTEM</span><span>=</span>input
…
E: <span>ID_INPUT</span><span>=</span>1
E: <span>ID_INPUT_KEY</span><span>=</span>1
E: <span>ID_BUS</span><span>=</span>usb
E: <span>ID_MODEL</span><span>=</span>USB_Keyboard
E: <span>ID_MODEL_ENC</span><span>=</span>USB<span>\x</span>20Keyboard
E: <span>ID_MODEL_ID</span><span>=</span>6004
E: <span>ID_SERIAL</span><span>=</span>SEMICO_USB_Keyboard
E: <span>ID_VENDOR</span><span>=</span>SEMICO
E: <span>ID_VENDOR_ENC</span><span>=</span>SEMICO
E: <span>ID_VENDOR_ID</span><span>=</span>1a2c
E: <span>ID_REVISION</span><span>=</span>0110
E: <span>ID_TYPE</span><span>=</span>hid
…</code></pre></figure>

<p>The lines starting with <code>E:</code> are device properties that are in <code>ENV{…}</code>,
the meaning can be found in <code>udevadm(8)</code> manpage, which we’ll see more
of in other examples.</p>

<p>That’s a neat example, it gives us a generic idea of udev. Let’s continue
and try to get a more general idea of the udev syntax.</p>

<p>So far we’ve seen that the rules files contain key-value pairs, or
comments starting with <code>#</code> as is standard in most conf files, and
has operators that are either for comparison, <code>==</code> and <code>!=</code>, or for
assignment, we’ve seen <code>=</code> and <code>+=</code>.</p>

<p>The difference between these two assignment operators is that some
variables/keys are lists, and the <code>+=</code> appends to that list, while the
<code>=</code> operator would basically empty the list and set only the single
value in it. Additionally, there are two other assignment operators
we haven’t seen: the <code>-=</code> to remove a value from a list, and the <code>:=</code>
which sets a constant and disallow future change.</p>

<p>How to know if something is a list or a scalar value, and if the key can
be used in comparison or assignment. Well, it depends on the key itself,
which are listed in the man page <code>udev(7)</code>, we’ll see the most common
but first let’s talk about the values.</p>

<p>The values assigned are always strings within double quotes, and use
the usual same escape mechanism that C and other languages use. It also
allows case-insensitive comparison by having the string preceded by “i”,
such as <code>i&#34;casedoesn&#39;t matter&#34;</code>.</p>

<p>Now, as we said there are keys used to do matching/searching, and keys
that allow assigning values (list or not), yet what’s confusing is that
lots of keys can be used for both, but not all of them. A quick look at
<code>udev(7)</code> to be sure doesn’t hurt.</p>

<p>Here are some common matching keys:</p>

<ul>
  <li><code>KERNEL</code>: kernel name</li>
  <li><code>SUBSYSTEM</code>: the kernel subsystem the device is associated to</li>
  <li><code>DRIVER</code>: the driver currently handling the device</li>
  <li><code>ACTION</code>: Represents what’s happening on a device. Either <code>add/remove</code>
when the device is created or removed, <code>bind/unbind</code> for the driver,
<code>change</code> when something happens on a device such as a state change (ex:
eject, power plug, brightness), <code>offline/online</code> for memory and cpu,
<code>move</code> when a device is renamed.</li>
  <li><code>ATTR{attributename}</code>: match any sysfs attribute of the device</li>
  <li><code>TAG</code>: arbitrary tags, mostly used for user-space special behavior</li>
  <li><code>ENV{property_name}</code>: Context info, device properties, added by the
kernel or other udev rules associated to device. They are not
environment variables, but do get passed as <code>env</code> to <code>RUN+=</code> commands.</li>
  <li><code>PROGRAM</code> and <code>RESULT</code>: The first executes an external program and
if it’s successful then the match is ok, the second checks the string
result of the last program and uses it as a comparator.</li>
</ul>

<p>Still, there are variants of some of the above to allow a match with any
of the parents of the devices in the topological hierarchy, these include
<code>KERNELS</code>, <code>SUBSYSTEMS</code>, <code>DRIVERS</code>, and <code>ATTRS</code>.</p>

<p>Now, we’ve dealt with the keys used for comparison, let’s see the common
assignment keys:</p>

<ul>
  <li><code>SYMLINK</code>: A list of symlinks to be created</li>
  <li><code>ATTR{attributename}</code>: Value that should be set in sysfs</li>
  <li><code>TAG</code>: A list of special attributes for user-space to act
upon. For example, systemd acts on <code>TAG+=&#34;systemd&#34;</code> and will read
<code>ENV{SYSTEMD_WANTS}</code> and interpret it as a unit dependency for the
device. It can be used to automatically start services.</li>
  <li><code>ENV{property_name}</code>: Context info, device properties, of the device. If
the property name is prepended with a dot <code>.</code>, then it will only
temporarily be set.</li>
  <li><code>OWNER</code>, <code>GROUP</code>, <code>MODE</code>: Set permissions on the device</li>
  <li><code>RUN{type}</code>: A list of external programs to run. The type is optional
and defaults to “program”, but it can be “builtin”, which are
plugins. Beware that <code>RUN</code> will timeout, and so it’s always better to
dispatch long running process to starter scripts instead that will exit
directly. <code>systemd-run --user</code> is often used here to execute things
in a normal graphical session such as notifications.</li>
  <li><code>IMPORT{type}</code>: Similar to <code>RUN</code> but used to import a set of variables (<code>ENV</code>)
depending on the type, can be “program”, “builtin”, “file”, “db”,
“parent”, “cmdline”.</li>
  <li><code>LABEL</code>, <code>GOTO</code>: A label and goto to jump to it, creating branching.</li>
</ul>

<p>The <code>RUN{builtin}</code> is a bit of an edge-case within udev since there are
many builtin modules and most of them are blackboxes that are hardly
documented. We know from <code>udevadm test-builtin --help</code> that these exist:</p>

<div><div><pre><code>blkid           Filesystem and partition probing
btrfs           btrfs volume management
dissect_image   Dissect Disk Images
factory_reset   Factory Reset Mode
hwdb            Hardware database
input_id        Input device properties
keyboard        Keyboard scancode mapping and touchpad/pointingstick characteristics
kmod            Kernel module loader
net_driver      Set driver for network device
net_id          Network device properties
net_setup_link  Configure network link
path_id         Compose persistent device path
uaccess         Manage device node user ACL
usb_id          USB device properties
</code></pre></div></div>

<p>Unfortunately, what they do isn’t clear unless you step in the code of
<a href="https://github.com/systemd/systemd/blob/main/src/udev/udev-builtin.c">udev-builtin</a>.
For example,
<a href="https://github.com/systemd/systemd/blob/main/src/udev/udev-builtin-input_id.c"><code>input_id</code></a>
will set a series of <code>ENV</code> info on the device depending on what it thinks
it is. Here’s some relevant code snippet:</p>

<figure><pre><code data-lang="c"><span>if</span> <span>(</span><span>is_pointing_stick</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_POINTINGSTICK&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span>
<span>if</span> <span>(</span><span>is_mouse</span> <span>||</span> <span>is_abs_mouse</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_MOUSE&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span>
<span>if</span> <span>(</span><span>is_touchpad</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_TOUCHPAD&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span>
<span>if</span> <span>(</span><span>is_touchscreen</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_TOUCHSCREEN&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span>
<span>if</span> <span>(</span><span>is_joystick</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_JOYSTICK&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span>
<span>if</span> <span>(</span><span>is_tablet</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_TABLET&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span>
<span>if</span> <span>(</span><span>is_tablet_pad</span><span>)</span>
        <span>udev_builtin_add_property</span><span>(</span><span>event</span><span>,</span> <span>&#34;ID_INPUT_TABLET_PAD&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>);</span></code></pre></figure>

<p>And, that’s the tip of the iceberg to understand udev rules. Yet, the ones on
a real system are a monstrously big patchup. The only way to visualize
all of them on your system, in the way they’ll be processed, is with
<code>systemd-analyze cat-config udev/rules.d</code>.</p>

<p>Before getting on with actual examples and tools, let’s take some time
to talk about one of the most important builtin module to udev: <code>hwdb</code>,
the harware db, or <code>systemd-hwdb</code>. Which is an extra mechanism to write
rules for udev to add device properties (<code>ENV{}</code>).</p>

<p>The hardware db is a lookup table that lives in files with the <code>.hwdb</code>
extension under the udev directory in the <code>hwdb.d</code> directory. These
key-values at <code>systemd-hwdb</code> start are compiled in a <code>hwdb.bin</code> file for
quick retrieval. They consist of matches of modalias-like keys and then
a series of assignment for properties. Something like:</p>

<div><div><pre><code>bluetooth:v0000*
 ID_VENDOR_FROM_DATABASE=Ericsson Technology Licensing
</code></pre></div></div>

<p>The format is a simple series of match strings, one or multiple, and then
assignment values following it on lines that start with a space. Match
strings can use glob for the match, they’re not really following any
specific format other than <code>prefix:search criteria</code>. Yet, the question is:
how are these modalias-like strings used. And the answer is obviously:
it’s used by udev via its <code>IMPORT</code> of the builtin hwdb to set certain
device properties based on the lookup. For example:</p>

<figure><pre><code data-lang="shell"><span>DRIVERS</span><span>==</span><span>&#34;atkbd&#34;</span>, <span>\</span>
  IMPORT<span>{</span><span>builtin</span><span>}=</span><span>&#34;hwdb &#39;evdev:atkbd:</span><span>$attr</span><span>{[dmi/id]modalias}&#39;&#34;</span>, <span>\</span>
  ENV<span>{</span>.HAVE_HWDB_PROPERTIES<span>}=</span><span>&#34;1&#34;</span></code></pre></figure>

<p>So udev passes a set of parameters to hwdb, along with the device, and it
will return <code>ENV</code> properties to set. hwdb also has an accompanying command
line tool that works in a similar way and allows querying it. However, it
has no man page, as far as I can see, but the following args are allowed:</p>

<figure><pre><code data-lang="shell"><span>--filter</span> or <span>-f</span>: 
<span>--device</span> or <span>-d</span>:
<span>--subsystem</span> or <span>-s</span>:
<span>--lookup-prefix</span> <span>-p</span>:</code></pre></figure>

<p>So for example when passing <code>--subsystem=usb</code> and a device, hwdb will get
the actual <code>MODALIAS</code> of the device, or construct one from the <code>idVendor</code>,
<code>idProduct</code>, and <code>product</code>, then try to match it in its lookup table.</p>

<p>Anyhow, we won’t spend time breaking down the source code. Let’s just
add that since the <code>hwdb</code> lookup table is compiled at the start, then
when entries are added or modified <code>systemd-hwdb</code> needs to be updated
or notified via:</p>

<figure><pre><code data-lang="shell">systemd-hwdb update <span># compile the hwdb</span></code></pre></figure>

<p>Similarly, the same is also true of udev. However, udev has more granular
reload mechanism, either to reload rules or to re-emit events so that
they can be processed by the new rules:</p>

<figure><pre><code data-lang="shell">udevadm trigger <span># re-emits all the uevents</span>
udevadm trigger /sys/class/input/eventXYZ <span># only re-emit this device events</span>
udevadm control <span>--reload</span> <span># reload all rules but will only apply to new events</span></code></pre></figure>

<p>Let’s see more examples of <code>udevadm</code>, which is the main way to interface
with udev.</p>

<p><code>udevadm info</code> is used to gather information about devices, we’ve seen
it earlier in previous sections. It’s handy to write udev rules. You can
pass it either a devtmpfs path, a sysfs path, a device ID, or a systemd
unit name of <code>.device</code> type (these are the <code>TAG+=&#34;systemd&#34;</code> devices to
automatically load other units).</p>

<p>For example, we can walk and find the attribute hierarchy of a certain
device.</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> udevadm info <span>--attribute-walk</span> /dev/input/event5

  looking at device <span>&#39;/devices/pci0000:00/0000:00:12.0/usb2\
      /2-4/2-4:1.0/0003:1A2C:6004.0069/input/input159/event5&#39;</span>:
    <span>KERNEL</span><span>==</span><span>&#34;event5&#34;</span>
    <span>SUBSYSTEM</span><span>==</span><span>&#34;input&#34;</span>
    <span>DRIVER</span><span>==</span><span>&#34;&#34;</span>
    ATTR<span>{</span>power/control<span>}==</span><span>&#34;auto&#34;</span>
    ATTR<span>{</span>power/runtime_active_time<span>}==</span><span>&#34;0&#34;</span>
    ATTR<span>{</span>power/runtime_status<span>}==</span><span>&#34;unsupported&#34;</span>
    ATTR<span>{</span>power/runtime_suspended_time<span>}==</span><span>&#34;0&#34;</span>


  looking at parent device <span>&#39;/devices/pci0000:00/0000:00:12.0/usb\
      2/2-4/2-4:1.0/0003:1A2C:6004.0069/input/input159&#39;</span>:
    <span>KERNELS</span><span>==</span><span>&#34;input159&#34;</span>
    <span>SUBSYSTEMS</span><span>==</span><span>&#34;input&#34;</span>
    <span>DRIVERS</span><span>==</span><span>&#34;&#34;</span>
    ATTRS<span>{</span>capabilities/abs<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>capabilities/ev<span>}==</span><span>&#34;120013&#34;</span>
    ATTRS<span>{</span>capabilities/ff<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>capabilities/key<span>}==</span><span>&#34;1000000000007 ff800000000007ff </span><span>\</span><span>
        febeffdff3cfffff fffffffffffffffe&#34;</span>
    ATTRS<span>{</span>capabilities/led<span>}==</span><span>&#34;7&#34;</span>
    ATTRS<span>{</span>capabilities/msc<span>}==</span><span>&#34;10&#34;</span>
    ATTRS<span>{</span>capabilities/rel<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>capabilities/snd<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>capabilities/sw<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span><span>id</span>/bustype<span>}==</span><span>&#34;0003&#34;</span>
    ATTRS<span>{</span><span>id</span>/product<span>}==</span><span>&#34;6004&#34;</span>
    ATTRS<span>{</span><span>id</span>/vendor<span>}==</span><span>&#34;1a2c&#34;</span>
    ATTRS<span>{</span><span>id</span>/version<span>}==</span><span>&#34;0110&#34;</span>
    ATTRS<span>{</span>inhibited<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>name<span>}==</span><span>&#34;SEMICO USB Keyboard&#34;</span>
    ATTRS<span>{</span>phys<span>}==</span><span>&#34;usb-0000:00:12.0-4/input0&#34;</span>
    ATTRS<span>{</span>power/control<span>}==</span><span>&#34;auto&#34;</span>
    ATTRS<span>{</span>power/runtime_active_time<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>power/runtime_status<span>}==</span><span>&#34;unsupported&#34;</span>
    ATTRS<span>{</span>power/runtime_suspended_time<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span>properties<span>}==</span><span>&#34;0&#34;</span>
    ATTRS<span>{</span><span>uniq</span><span>}==</span><span>&#34;&#34;</span>

  looking at parent device <span>&#39;/devices/pci0000:00/0000:00:12.0/usb2\
      /2-4/2-4:1.0/0003:1A2C:6004.0069&#39;</span>:
    <span>KERNELS</span><span>==</span><span>&#34;0003:1A2C:6004.0069&#34;</span>
    <span>SUBSYSTEMS</span><span>==</span><span>&#34;hid&#34;</span>
…</code></pre></figure>

<p>It’s something we’ve seen before.</p>

<p>Another option is to rely on <code>udevadm monitor</code>, which is a live trace
of all the uevent being sent.</p>

<p>Yet another option is <code>udevadm test</code> to print the rules that will get
triggered on a certain device uevent. This is useful to check whether
the rules make sense and will get executed.</p>

<p>A last tip to remember when writing udev rules is that <code>ATTR{}</code> is
anything in the files of sysfs. So we can simply match like this:</p>

<div><div><pre><code>&gt; cat /sys/class/input/event5/device/name
SEMICO USB Keyboard
</code></pre></div></div>

<p>And the rule would be <code>ATTR{name}==&#34;SEMICO USB Keyboard&#34;</code>.</p>

<p>Finally, let’s have a honorable mention to the mdev and eudev projects,
which are udev-like projects but more compatible with other init systems.</p>



<p>Libinput is a wrapper over udev and evdev. It provides a centralized way
to perform device detection, device event handling, input processing,
along with abstractions and common set of facilities to make the
practical, and user-expected, input handling easier. Today, libinput is
the major input library used by all graphical environments and toolkits,
it’s used by Xorg (through a driver) and Wayland compositors, so we’re
all probably using it indirectly.</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/libinput.png" alt="libinput Overview" title="libinput Overview"/></p>

<p>Its basic mechanism works as you’d expect.</p>

<p>That also means it handles only the usual input devices such as mice,
keyboards, touchpads/clickpads, switches, trackpoints/pointing sticks,
touchscreens, and graphic tablets. It doesn’t handle joysticks, for
example, since these aren’t used for desktop environment but for games.</p>

<p>The main features handled by libinput are:</p>

<ul>
  <li>Button debouncing</li>
  <li>Clickpad software button behavior, Middle button emulation</li>
  <li>Touchpad pressure-based touch detection</li>
  <li>Palm and thumb detection</li>
  <li>Scrolling, Three-finger drag, and Tap-to-click behaviour</li>
  <li>Gestures</li>
</ul>

<p>We’ll see what these means, but first, why is libinput needed, can’t
udev and evdev be handled directly? Why have another layer of indirection?</p>

<p>The answer is twofold: to avoid having additional separate modules in the
upper stack such as in the X server, and because handling input devices
is messy and not as simple as taking evdev events as-is, they need a
bit more interpretation and cleanup.</p>

<p>Previously, before Wayland got traction, the X11 stack had specific
custom drivers, the xf86 input driver API, for each type of hardware and
use-case. Yet, these xf86 drivers could also have common functionalities
such as two-finger scrolling, which adds confusion. This was mostly a
hack for days before evdev existed, and there was a need for a library
independent of X11 that would centralize this responsibility, instead
of having it dispersed in different places. This makes it easier to
test each options, and have the features interact with one another,
cross-device communication.</p>

<p>Now why not handle it all directly, well because it’s messy. Multiple
devices have bad firmware and might send wrong capabilities and info
in their HID Report Descriptors, which will then be forwarded as-is
with evdev. Plus, having handling these in the driver would be even
more messy. For example, it could say that the size or resolution of
the touchpad is something while it’s something else. Or that the range
of valid inputs is 0 to 10 but that it’s 5-10. That’s why libinput
includes vendor-specific quirks handling in <code>/usr/share/libinput/</code>
along with the help of hwdb, which we’ve seen earlier, that has
<code>/usr/lib/udev/hwdb.d/60-evdev.hwdb</code>.</p>

<p>For example:</p>

<figure><pre><code data-lang="shell"><span>[</span>Aiptek 8000U pressure threshold]
<span>MatchUdevType</span><span>=</span>tablet
<span>MatchBus</span><span>=</span>usb
<span>MatchVendor</span><span>=</span>0x08CA
<span>MatchProduct</span><span>=</span>0x0010
<span>AttrPressureRange</span><span>=</span>70:50</code></pre></figure>

<p>This says that when a udev event is a usb tablet from a specific vendor,
that the pressure range should be change to <code>70:50</code>.</p>

<figure><pre><code data-lang="shell"><span>[</span>Bluetooth Keyboards]
<span>MatchUdevType</span><span>=</span>keyboard
<span>MatchBus</span><span>=</span>bluetooth
<span>AttrKeyboardIntegration</span><span>=</span>external</code></pre></figure>

<p>And this says that when a keyboard’s bus is over Bluetooth, it should
add the libinput attribute to say it’s an external keyboard.</p>

<p>The <code>60-evdev.hwdb</code> is mostly for touchpad’s axis, the device properties
set will look like this:</p>

<figure><pre><code data-lang="shell">EVDEV_ABS_&lt;axis&gt;<span>=</span>&lt;min&gt;:&lt;max&gt;:&lt;res&gt;:&lt;fuzz&gt;:&lt;flat&gt;
<span># where &lt;axis&gt; is the hexadecimal EV_ABS code as listed in linux/input.h and</span>
<span># min, max, res, fuzz, flat are the decimal values to the respective fields of</span>
<span># the struct input_absinfo as listed in linux/input.h. If a field is missing</span>
<span># the field will be left as-is. Not all fields need to be present. e.g. ::45</span>
<span># sets the resolution to 45 units/mm.</span>
<span># resolution: it is given in units per millimeter and thus tells us the</span>
<span># size of the device. in the above case: (5112 - 1024)/42 means the device</span>
<span># is 97mm wide. The resolution is quite commonly wrong, a lot of axis</span>
<span># overrides need the resolution changed to the correct value.</span></code></pre></figure>

<p>Furthermore, apart from quirks, there are hardware physical issues,
such as the fact that some touchpads send out events before the finger
even touches them, or how to handle the difference in pressure on them,
or what to do to track different fingers on multitouch (MT) hardware
which requires handling evdev tracking ID and slots.</p>

<p>Here’s a two-fingers scroll example, see how complex that is:</p>

<div><div><pre><code>E: 0.000001 0003 0039 0557 # EV_ABS / ABS_MT_TRACKING_ID   557
E: 0.000001 0003 0035 2589 # EV_ABS / ABS_MT_POSITION_X    2589
E: 0.000001 0003 0036 3363 # EV_ABS / ABS_MT_POSITION_Y    3363
E: 0.000001 0003 003a 0048 # EV_ABS / ABS_MT_PRESSURE      48
E: 0.000001 0003 002f 0001 # EV_ABS / ABS_MT_SLOT          1
E: 0.000001 0003 0039 0558 # EV_ABS / ABS_MT_TRACKING_ID   558
E: 0.000001 0003 0035 3512 # EV_ABS / ABS_MT_POSITION_X    3512
E: 0.000001 0003 0036 3028 # EV_ABS / ABS_MT_POSITION_Y    3028
E: 0.000001 0003 003a 0044 # EV_ABS / ABS_MT_PRESSURE      44
E: 0.000001 0001 014a 0001 # EV_KEY / BTN_TOUCH            1
E: 0.000001 0003 0000 2589 # EV_ABS / ABS_X                2589
E: 0.000001 0003 0001 3363 # EV_ABS / ABS_Y                3363
E: 0.000001 0003 0018 0048 # EV_ABS / ABS_PRESSURE         48
E: 0.000001 0001 014d 0001 # EV_KEY / BTN_TOOL_DOUBLETAP   1
E: 0.000001 0000 0000 0000 # ------------ SYN_REPORT (0) ---------- +0ms
E: 0.027960 0003 002f 0000 # EV_ABS / ABS_MT_SLOT          0
E: 0.027960 0003 0035 2590 # EV_ABS / ABS_MT_POSITION_X    2590
E: 0.027960 0003 0036 3395 # EV_ABS / ABS_MT_POSITION_Y    3395
E: 0.027960 0003 003a 0046 # EV_ABS / ABS_MT_PRESSURE      46
E: 0.027960 0003 002f 0001 # EV_ABS / ABS_MT_SLOT          1
E: 0.027960 0003 0035 3511 # EV_ABS / ABS_MT_POSITION_X    3511
E: 0.027960 0003 0036 3052 # EV_ABS / ABS_MT_POSITION_Y    3052
E: 0.027960 0003 0000 2590 # EV_ABS / ABS_X                2590
E: 0.027960 0003 0001 3395 # EV_ABS / ABS_Y                3395
E: 0.027960 0003 0018 0046 # EV_ABS / ABS_PRESSURE         46
E: 0.027960 0000 0000 0000 # ------------ SYN_REPORT (0) ---------- +27ms
E: 0.051720 0003 002f 0000 # EV_ABS / ABS_MT_SLOT          0
E: 0.051720 0003 0035 2609 # EV_ABS / ABS_MT_POSITION_X    2609
E: 0.051720 0003 0036 3447 # EV_ABS / ABS_MT_POSITION_Y    3447
E: 0.051720 0003 002f 0001 # EV_ABS / ABS_MT_SLOT          1
E: 0.051720 0003 0036 3080 # EV_ABS / ABS_MT_POSITION_Y    3080
E: 0.051720 0003 0000 2609 # EV_ABS / ABS_X                2609
E: 0.051720 0003 0001 3447 # EV_ABS / ABS_Y                3447
E: 0.051720 0000 0000 0000 # ------------ SYN_REPORT (0) ---------- +24ms
[...]
E: 0.272034 0003 002f 0000 # EV_ABS / ABS_MT_SLOT          0
E: 0.272034 0003 0039 -001 # EV_ABS / ABS_MT_TRACKING_ID   -1
E: 0.272034 0003 002f 0001 # EV_ABS / ABS_MT_SLOT          1
E: 0.272034 0003 0039 -001 # EV_ABS / ABS_MT_TRACKING_ID   -1
E: 0.272034 0001 014a 0000 # EV_KEY / BTN_TOUCH            0
E: 0.272034 0003 0018 0000 # EV_ABS / ABS_PRESSURE         0
E: 0.272034 0001 014d 0000 # EV_KEY / BTN_TOOL_DOUBLETAP   0
E: 0.272034 0000 0000 0000 # ------------ SYN_REPORT (0) ---------- +30ms
</code></pre></div></div>

<p>Additionally, you also have misbehaving keyboards, with bad
firmware, buttons that are old, that get stuck, or send the same
events multiple time (so-called contact bouncing or chatter). We
need a mechanism to decide whether the event is valid or not, that’s
called hardware debouncing, and libinput does it out-of-the-box for us
(<a href="https://wayland.freedesktop.org/libinput/doc/latest/button-debouncing.html">see</a>),
which is truly impressive. This feature, with the help of the upper stack,
may also help people that have certain disabilities with involuntary
muscle movement.</p>

<p>So, for many reasons, libinput is indispensable!</p>

<p>One of the interesting part of libinput is that it’s minimal in how
it decides to access external things. As we said, you can either opt
for events coming from udev, or manually pass them by path, both will
create libinput internal objects (pointer, keyboard, etc..). Furthermore,
libinput has no configuration files, it’s up to the caller to decide
how to configure each device, as we’ll see Wayland compositors and X11
have different ways. Similarly, it leaves the opening of evdev character
devices up to the caller implementation, usually either manually opening
it, which requires root privileges, or via <code>systemd-logind</code> or <code>seatd</code>, dbus
services which will automatically pass back the file descriptors of evdev
devices associated with the current “seat”.</p>

<p>A seat is a collection of input devices associated with a user
session. That seems redundant, since most machines have only one seat,
yet it only truly makes sense in multi-seat machines: one machine,
multiple input devices, with multiple users. Still, it takes this
particular use-case in consideration.</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> libinput list-devices.
…
Device:           SEMICO USB Keyboard
Kernel:           /dev/input/event5
Id:               usb:1a2c:6004
Group:            6
Seat:             seat0, default
Capabilities:     keyboard 
…


<span>&gt;</span> loginctl seat status <span># will list all input in the hierarchy</span></code></pre></figure>

<p>As you would’ve guessed, the safest and most favored way to get access
to evdev event file descriptors is through the delegation that <code>systemd-logind</code>
provides. This is done in the code by implementing <code>open_restricted</code>
to call the dbus service.</p>

<div><div><pre><code>&gt; loginctl attach &#39;seat0&#39; /sys/devices/…/input/input174
</code></pre></div></div>

<p>Then checking the device properties in udev:</p>

<figure><pre><code data-lang="shell">E: <span>ID_FOR_SEAT</span><span>=</span>input-pci-0000_00_12_0-usb-0_1_1_0
E: <span>ID_SEAT</span><span>=</span>seat0
E: <span>TAGS</span><span>=</span>:seat:seat0:
E: <span>CURRENT_TAGS</span><span>=</span>:seat:seat0:</code></pre></figure>

<p>There are alternatives to <code>logind</code> such as <code>elogind</code> and
<a href="https://sr.ht/~kennylevinsen/seatd/"><code>seatd</code></a> that don’t depend on
systemd.</p>

<p>Another detail is that we’ve seen that the same physical device can
appear as multiple input devices on the system. With the help of udev,
libinput gets the device property <code>LIBINPUT_DEVICE_GROUP</code> to group them,
like that we can have the whole group under a single seat, which is more
logical than giving access to only part of a physical hardware.</p>

<p>From <code>udevadm info</code>:</p>

<figure><pre><code data-lang="shell">E: <span>ID_PATH_TAG</span><span>=</span>pci-0000_00_12_0-usb-0_1_1_1
E: <span>ID_SEAT</span><span>=</span>seat0
E: <span>LIBINPUT_DEVICE_GROUP</span><span>=</span>3/1a2c/6004:usb-0000:00:12.0-1</code></pre></figure>

<p>And from <code>libinput list-devices</code>, look at the <code>Group</code> part:</p>

<div><div><pre><code>Device:           SEMICO USB Keyboard
Kernel:           /dev/input/event5
Id:               usb:1a2c:6004
Group:            6
Seat:             seat0, default
Capabilities:     keyboard 
…
Device:           SEMICO USB Keyboard Consumer Control
Kernel:           /dev/input/event6
Id:               usb:1a2c:6004
Group:            6
Seat:             seat0, default
Capabilities:     keyboard pointer 
…
Device:           SEMICO USB Keyboard System Control
Kernel:           /dev/input/event7
Id:               usb:1a2c:6004
Group:            6
Seat:             seat0, default
Capabilities:     keyboard 
</code></pre></div></div>

<p>You can get more info on this by checking the related udev rule in
<code>80-libinput-device-groups.rules</code>, which calls the built-in program
<code>libinput-device-group</code> with the sysfs mount point. The <code>IMPORT{program}</code>
basically uses a program right within <code>/usr/lib/udev/</code> directory.</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> /usr/lib/udev/libinput-device-group /sys/class/input/input191
<span>LIBINPUT_DEVICE_GROUP</span><span>=</span>3/1a2c/6004:usb-0000:00:12.0-1</code></pre></figure>

<p>As far as the technical features are concerned, there are the ones which
we listed earlier, so let’s explain the rest of them.</p>

<p>It offers full clickpad management. A clickpad (<code>INPUT_PROP_BUTTONPAD</code>)
is basically a touchpad with a single button, which we might not notice at
first because depending on where we press in the “software button area”
at the bottom, we have different behavior. That’s exactly the behavior
that libinput facilitates. It also handles what happens when a finger
enters or exits that area, these sort of edge cases.</p>

<p>Furthermore, libinput handles tap to click, be it one-finger tap for
left click, two-fingers for right click, and three-fingers tap for
middle click. While that seems simple in theory, libinput has to draw
the line between what is considered a tap and what is considered a finger
drag/move; indeed, our fingers aren’t very stable in the real world.</p>

<p>When talking about multiple fingers, the hardware needs to support
it obviously, but also libinput needs to track each one individually,
which is done via evdev tracking ID and slots, what we call multi-touch
handling or MT.</p>

<p>Similarly, there’s also different scrolling use-cases that are supported
by libinput: two-fingers scrolling, similar to a swipe, edge scrolling,
when there’s a specific area on the trackpad used for scrolling, and
on-button scrolling, which scrolls while having a button pressed just by
moving the finger.</p>

<p>With all these, libinput offers palm and thumb detection to disable
the clickpad/touchpad when typing, or ignore a thumb in the corner or
accidental touches while other fingers are moving. It achieves this by
detecting the different pressure, speed, or touch sizes reported by evdev,
along with where they are happening (exclusion zones).</p>

<p>Lastly, libinput has lua plugins in <code>/usr/lib/libinput/plugins/</code> and
<code>/etc/libinput/plugins</code>. As with other quirk fixing mechanisms in
udev and the quirk directory, the plugins are there for the last few
unfixable issues. They can be used to override evdev events.</p>

<figure><pre><code data-lang="lua"><span>libinput</span><span>:</span><span>register</span><span>(</span><span>1</span><span>)</span> <span>-- register plugin version 1</span>
<span>libinput</span><span>:</span><span>connect</span><span>(</span><span>&#34;new-evdev-device&#34;</span><span>,</span> <span>function</span> <span>(</span><span>_</span><span>,</span> <span>device</span><span>)</span>
    <span>if</span> <span>device</span><span>:</span><span>vid</span><span>()</span> <span>==</span> <span>0x046D</span> <span>and</span> <span>device</span><span>:</span><span>pid</span><span>()</span> <span>==</span> <span>0xC548</span> <span>then</span>
        <span>device</span><span>:</span><span>connect</span><span>(</span><span>&#34;evdev-frame&#34;</span><span>,</span> <span>function</span> <span>(</span><span>_</span><span>,</span> <span>frame</span><span>)</span>
            <span>for</span> <span>_</span><span>,</span> <span>event</span> <span>in</span> <span>ipairs</span><span>(</span><span>frame</span><span>.</span><span>events</span><span>)</span> <span>do</span>
                <span>if</span> <span>event</span><span>.</span><span>type</span> <span>==</span> <span>evdev</span><span>.</span><span>EV_REL</span> <span>and</span> 
                   <span>(</span><span>event</span><span>.</span><span>code</span> <span>==</span> <span>evdev</span><span>.</span><span>REL_HWHEEL</span> <span>or</span> 
                    <span>event</span><span>.</span><span>code</span> <span>==</span> <span>evdev</span><span>.</span><span>REL_HWHEEL_HI_RES</span><span>)</span> <span>then</span>
                    <span>event</span><span>.</span><span>value</span> <span>=</span> <span>-</span><span>event</span><span>.</span><span>value</span>
                <span>end</span>
            <span>end</span>
            <span>return</span> <span>frame</span>
        <span>end</span><span>)</span>
    <span>end</span>
<span>end</span><span>)</span></code></pre></figure>

<p>For example, the above script will reverse the horizontal scroll wheel
(<code>EV_REL.REL_HWHEEL</code>) event value for a certain device vendor and
product ID.</p>

<p>We’ve covered most of the libinput features, now let’s see how to debug
and interface with it.</p>

<p>The main command line interface is <code>libinput</code>, as we’ve seen it can allow
to <code>list-devices</code>, which is a quick summary of the devices it knows about
and on which seat they are connected. Yet most other commands are there
for debugging and testing.</p>

<ul>
  <li><code>libinput debug-gui</code>: is a graphical tool mostly to debug touchpad</li>
  <li><code>libinput debug-events</code>: is a cli tool to debug all events as they are
interpreted by libinput, if you want it’s similar to <code>evtest</code> or <code>xev</code>
in Xorg</li>
  <li><code>libinput record</code> and <code>libinput replay</code>: Used to save and then simulate
again devices. This is amazing if you have a bug and want others to be
able to replicate it on their machines. This is similar to how
<code>hid-tools</code> work.</li>
  <li><code>libinput measure</code>: mostly used for touchpad, to measure things such
as pressure, touch size, tap to click time, etc..</li>
</ul>

<p>The other way to interface with libinput is programmatically. Here’s
the most simple complete example I could come up with:</p>

<figure><pre><code data-lang="c"><span>#include</span> <span>&lt;libinput.h&gt;</span><span>
#include</span> <span>&lt;libudev.h&gt;</span><span>
#include</span> <span>&lt;fcntl.h&gt;</span><span>
#include</span> <span>&lt;unistd.h&gt;</span><span>
#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;errno.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
</span>

<span>static</span> <span>int</span> <span>open_restricted</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>int</span> <span>flags</span><span>,</span> <span>void</span> <span>*</span><span>user_data</span><span>)</span> <span>{</span>
	<span>int</span> <span>fd</span> <span>=</span> <span>open</span><span>(</span><span>path</span><span>,</span> <span>flags</span><span>);</span>
	<span>if</span> <span>(</span><span>fd</span> <span>&lt;</span> <span>0</span><span>)</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Failed to open %s (%s)</span><span>\n</span><span>&#34;</span><span>,</span> <span>path</span><span>,</span> <span>strerror</span><span>(</span><span>errno</span><span>));</span>
	<span>return</span> <span>fd</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span> <span>close_restricted</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>void</span> <span>*</span><span>user_data</span><span>)</span> <span>{</span>
	<span>close</span><span>(</span><span>fd</span><span>);</span>
<span>}</span>

<span>static</span> <span>const</span> <span>struct</span> <span>libinput_interface</span> <span>interface</span> <span>=</span> <span>{</span>
	<span>.</span><span>open_restricted</span> <span>=</span> <span>open_restricted</span><span>,</span>
	<span>.</span><span>close_restricted</span> <span>=</span> <span>close_restricted</span><span>,</span>
<span>};</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>struct</span> <span>udev</span> <span>*</span><span>udev</span> <span>=</span> <span>udev_new</span><span>();</span>
    <span>if</span> <span>(</span><span>!</span><span>udev</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Failed to create udev</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>struct</span> <span>libinput</span> <span>*</span><span>li</span> <span>=</span> <span>libinput_udev_create_context</span><span>(</span><span>&amp;</span><span>interface</span><span>,</span> <span>NULL</span><span>,</span> <span>udev</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>li</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Failed to create libinput context</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>libinput_udev_assign_seat</span><span>(</span><span>li</span><span>,</span> <span>&#34;seat0&#34;</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Failed to assign seat</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>struct</span> <span>libinput_event</span> <span>*</span><span>event</span><span>;</span>
    <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>libinput_dispatch</span><span>(</span><span>li</span><span>);</span>
        <span>event</span> <span>=</span> <span>libinput_get_event</span><span>(</span><span>li</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>event</span><span>)</span> <span>{</span>
            <span>usleep</span><span>(</span><span>10000</span><span>);</span>
            <span>continue</span><span>;</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>libinput_event_get_type</span><span>(</span><span>event</span><span>)</span> <span>==</span> <span>LIBINPUT_EVENT_KEYBOARD_KEY</span><span>)</span> <span>{</span>
            <span>struct</span> <span>libinput_event_keyboard</span> <span>*</span><span>k</span> <span>=</span> <span>libinput_event_get_keyboard_event</span><span>(</span><span>event</span><span>);</span>
            <span>uint32_t</span> <span>key</span> <span>=</span> <span>libinput_event_keyboard_get_key</span><span>(</span><span>k</span><span>);</span>
            <span>enum</span> <span>libinput_key_state</span> <span>state</span> <span>=</span> <span>libinput_event_keyboard_get_key_state</span><span>(</span><span>k</span><span>);</span>

            <span>printf</span><span>(</span><span>&#34;Key %u is %s</span><span>\n</span><span>&#34;</span><span>,</span>
                   <span>key</span><span>,</span>
                   <span>state</span> <span>==</span> <span>LIBINPUT_KEY_STATE_PRESSED</span> <span>?</span> <span>&#34;PRESSED&#34;</span> <span>:</span> <span>&#34;RELEASED&#34;</span><span>);</span>
        <span>}</span>

        <span>libinput_event_destroy</span><span>(</span><span>event</span><span>);</span>
    <span>}</span>

    <span>libinput_unref</span><span>(</span><span>li</span><span>);</span>
    <span>udev_unref</span><span>(</span><span>udev</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

<p>And to compile it:</p>

<figure><pre><code data-lang="shell">gcc <span>-o</span> key_state key_state.c <span>$(</span>pkg-config <span>--cflags</span> <span>--libs</span> libinput libudev<span>)</span></code></pre></figure>

<p>But what about configuring devices, setting up things that we want to
setup per device. Well, as we’ve said this is done in the upper stack
since libinput has no configuration files, and we’ll cover this later. For
now let’s just list a few of the things that can actually be configured.</p>

<ul>
  <li>tap-to-click related, such as how many fingers are supported</li>
  <li>three-finger drag</li>
  <li>pointer acceleration profiles</li>
  <li>scrolling method natural vs traditional</li>
  <li>left-hand mode</li>
  <li>middle button emulation</li>
  <li>click method</li>
  <li>disable while typing (DWT)</li>
  <li>disable while trackpointing (DWTP)</li>
  <li>direct-input device calibration</li>
  <li>rotation confs (if touchpad is sideways)</li>
  <li>area confs</li>
</ul>

<p>You can glimpse at these on X11 with the command <code>xinput --list-props &lt;device_id&gt;</code>
or at <code>libinput list-devices</code> which we’ve seen earlier that
should show the conf per-device:</p>

<div><div><pre><code>Device:                  SYNA801A:00 06CB:CEC6 Touchpad
…
Group:                   1
Seat:                    seat0, default
Size:                    122x69mm
Capabilities:            pointer gesture
Tap-to-click:            disabled
Tap-and-drag:            enabled
Tap button map:          left/right/middle
Tap drag lock:           disabled
Left-handed:             disabled
Nat.scrolling:           disabled
Middle emulation:        disabled
Calibration:             n/a
Scroll methods:          *two-finger edge
Scroll button:           n/a
Scroll button lock:      n/a
Click methods:           *button-areas clickfinger
Clickfinger button map:  left/right/middle
Disable-w-typing:        enabled
Disable-w-trackpointing: enabled
Accel profiles:          flat *adaptive custom
Rotation:                n/a
Area rectangle:          n/a

// or another touchpad
Device:                  ETPS/2 Elantech Touchpad
…
Seat:                    seat0, default
Size:                    102x74mm
Capabilities:            pointer gesture
Tap-to-click:            disabled
Tap-and-drag:            enabled
Tap button map:          left/right/middle
Tap drag lock:           disabled
Left-handed:             disabled
Nat.scrolling:           disabled
Middle emulation:        disabled
Calibration:             n/a
Scroll methods:          *two-finger edge 
Scroll button:           n/a
Scroll button lock:      n/a
Click methods:           *button-areas clickfinger 
Clickfinger button map:  left/right/middle
Disable-w-typing:        enabled
Disable-w-trackpointing: enabled
Accel profiles:          flat *adaptive custom
Rotation:                n/a
Area rectangle:          n/a
</code></pre></div></div>

<p>That’s about it when it comes to libinput. Now we can move to more
specific things in the upper stack.</p>



<p>We’re pretty much done with the lower part of the user-space stack, but
before moving on to the graphical library widgets and desktop environments,
let’s take some time to see some of the specific device handling that
are good to know about, namely keyboards, mice, and gamepads.</p>

<h2 id="scancodes-to-keycodes">Scancodes to Keycodes</h2>

<p>Like other input drivers, the role of keyboard drivers is to translate
from raw hardware keys to events that can be normalized and interpreted by
user-space. We call the raw keys scancodes, and the events ones keycodes
(<code>/usr/include/linux/input-event-codes.h</code>). Keycodes are also mapped
to key symbols in user-space unrelated to their actual keycodes, which we
call keysyms.</p>

<p>We’ll talk more about keysyms mapping when we see XKB. But let’s focus
on the scancodes to keycode translation for now.</p>

<p>When a keyboard input device registers itself in the input core
(<code>input_register_device</code>) it has to report which keycodes it supports
in its capabilities (<code>keybit</code> capability). In general it has to set its
<code>keycode</code>, <code>keycodemax</code>, and <code>keycodesize</code> fields, which are a map of
the translation of scancodes to keycodes.</p>

<p>If a scancode isn’t found in these translation arrays, they’re often
either completely ignored, or the driver returns that it’s an unknown key.</p>

<p>Keyboard input devices can also optionally implement two important
functions: <code>getkeycode</code> and <code>setkeycode</code>, which will by default retrieve
the current keymap and alter the current keymap respectively. Most drivers
fallback to the default mechanism, so this can be taken for granted.</p>

<p>Importantly, the <code>evdev</code> and <code>kbd</code> (console) handlers offer ways to call
these via ioctl interfaces, which will be propagated to the devices
they’re currently handling. For <code>evdev</code> it’s through <code>EVIOCGKEYCODE</code> and
<code>EVIOCSKEYCODE</code>, to get and set keycodes respectively. For the console
handler it’s through <code>KDGETKEYCODE</code> and <code>KDSETKEYCODE</code>. The exception
is that the console driver will propagate it to all handlers, and thus
indirectly to all devices on the platform.</p>

<p>You can also do the runtime patching of scancode to keycode
mapping through udev and hwdb by setting a device property in
<code>ENV{KEYBOARD_KEY_&lt;hex scan code&gt;}=&lt;key code identifier&gt;</code> which will in
turn be caught by <code>systemd/src/udev/udev-builtin-keyboard.c</code> and also
call the same ioctl interfaces.</p>

<p>For example:</p>

<div><div><pre><code>ENV{KEYBOARD_KEY_b4}=dollar
</code></pre></div></div>

<p>To find out the actual scancodes the device is generating the <code>showkey(1)</code>
tool from the Linux Keyboard tools project, with the <code>--scancodes</code> flag,
will attach to the console handler and display them in raw mode. And the
<code>setkeycodes(8)</code> command from the same project will propagate it to the
driver via the console input handler.</p>

<p>There are multiple other tools used to do the keycode remapping such
as <code>evmapd</code>, <code>evremap</code>, <code>evdevremapkeys</code>, but these work at the evdev
layer and don’t know about scancodes. So for now, the simplest one to
do scancode to keycode mapping is obviously the built-in one: hwdb.</p>

<p>This mechanism for runtime modifications might save us time instead of
getting our hands dirty and having to modify kernel drivers.</p>

<h2 id="console-keyboard">Console Keyboard</h2>

<p>We’ve discussed the <code>evdev</code> handler extensively, however in the console
it’s the <code>kbd</code> input event handler (<code>drivers/tty/vt/keyboard.c</code>) that is
used, and it’s working in sync with the tty and line discipline mechanism.</p>

<p>The input handlers coexist. When switching from graphical environment
to console, the VT <code>kbd</code> handler takes over.</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/console.png" alt="Console Overview" title="Console Overview"/></p>

<p>Obviously, as a console input handler, the <code>kbd</code> handler has much more
work to do, and it has a lot of special handling via ioctl too. From
bell and tone, leds, setting console key rate, modifiers, interpreting
special keys that have meanings for the TTY, switching to other modes
such as raw input mode or graphic (X11, Wayland session), all the push
towards line discipline, etc.. It’s handling things that are often
handled in user-space (key rate is handled in the graphical stack too
as we’ll see). The reason: historical entangling, the console existed
before the graphical stack.</p>

<p>For instance, <code>showkey(1)</code> which we’ve just seen, relies on changing the
mode of the terminal via ioctl <code>KDSKBMODE</code> to <code>K_RAW</code>.</p>

<div><div><pre><code>[Keyboard hardware]
   ↓
[input driver: atkbd, hid-input]
   ↓
[input core]
   ↓
[keyboard.c handler (kbd_event)]
   ↓
[TTY layer (virtual console, ttyN)]
   ↓
[N_TTY line discipline]
   ↓
[read() by shell, echo, canonical editing, etc.]
</code></pre></div></div>

<p>Furthermore, since it’s taking a bigger role on handling scancode to
keycode, it also somewhat does keycode interpretation via its internal
keymap. That means, the <code>kbd</code> handler can be responsible of handling the
difference in regional keyboard layouts and special keys. This is
something which usually happens in XKB, in user-space, which we’ll see
in the next section.</p>

<p>Thus it has two sets of ioctl: <code>KDSETKEYCODE</code> and <code>KDGETKEYCODE</code> for
low-level scancodes to keycodes, and <code>KDGKBENT</code> and <code>KDSKBENT</code> for the
keycode to symbol/action mapping (internally also confusingly called
<code>key_maps</code>, as you’ll see everyone uses the word “keymap”).</p>

<p>The format of the keymaps translating keycode to symbol (<code>keymaps(5)</code>)
is managed by the kernel for each console, but usually more
easily set with user-space tools also from the <a href="https://kbd-project.org/">Linux keyboard
tools</a> project. For example <code>loadkeys(1)</code> and
<code>dumpkeys(1)</code>. These can rely on files in <code>/usr/share/kbd/keymaps/</code>
for a predefined set of keymaps. Let’s also mention that the default
one is found in <code>/usr/src/linux/drivers/tty/vt/defkeymap.map</code>.</p>

<p>Before we end, let’s mention <code>systemd-localed.service(8)</code> and its
<code>localectl(1)</code> command. It is used to set the keyboard map for
both the console and the graphical environment (XKB in X11 as we’ll see)
based on the current locale. For example, it sets the keymap,
font, and others, of the console and X11 XKB to the value found in
<code>/etc/vconsole.conf</code> (see <code>vconsole.conf(5)</code>) through its service called
<code>systemd-vconsole-setup(8)</code>, which is also called when the console is
initialized with udev. It can also help in setting the same values in
both the console and graphical stack.</p>

<p>Here’s <code>vconsole.conf</code>:</p>

<figure><pre><code data-lang="shell"><span>KEYMAP</span><span>=</span>us
<span>XKBLAYOUT</span><span>=</span>us</code></pre></figure>

<div><div><pre><code>&gt; localectl
System Locale: LANG=en_US.UTF-8
    VC Keymap: us
   X11 Layout: us
</code></pre></div></div>

<p><em>NB: Terminal emulators don’t rely on the console input handler at all,
they use pseudo-terminals instead (PTYs). These don’t have VGA console,
nor plug to the kbd handler, nor screen, etc.. They are fed entirely by
user-space programs.</em></p>

<div><div><pre><code>Line discipline &lt;-&gt; TTY driver (PTY slave side) &lt;-&gt; user process
 `-&gt; PTY master side &lt;-&gt; xterm process
</code></pre></div></div>

<p>See <a href="https://venam.net/blog/unix/2017/06/04/terminals.html#generic-arch">this old article</a>
for more details on that.</p>

<div><div><pre><code>&gt; cat /proc/consoles
tty0                 -WU (EC  p  )    4:2

&gt; cat /proc/tty/drivers

/proc/tty/drivers
/dev/tty             /dev/tty        5       0 system:/dev/tty
/dev/console         /dev/console    5       1 system:console
/dev/ptmx            /dev/ptmx       5       2 system
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster
serial               /dev/ttyS       4 64-95 serial
pty_slave            /dev/pts      136 0-1048575 pty:slave
pty_master           /dev/ptm      128 0-1048575 pty:master
unknown              /dev/tty        4 1-63 console
</code></pre></div></div>

<p>Now let’s see how the keycode to keysym is done in user-space in the
graphical stack with XKB.</p>

<h2 id="xkb">XKB</h2>

<p>XKB, or X keyboard, is a common library (xkbcommon, xkbregistry,
xkbcompose) with a set of tools, an X11 protocol extension (X
Keyboard Extension), and a database collection of descriptions
(xkeyboard-config). Its role is to handle the keycode to keysym
translation in user-space.</p>

<p>The two things we’ll focus on are xkbcommon, the xkb core engine that
parse and executes XKB definitions, and the xkeyboard-config, which
is a project compiling a database of keyboard info, layouts, variants,
symbols, and rules. They work together.</p>

<p>As a word of notice, XKB is one of the most complex piece of software I’ve
encountered and its documentation is fiercely lacking and dispersed. It
has its own language, compiler, and the format is extremely convoluted
and inconsistent, often mixing camel case and snake case for no apparent
reasons.</p>

<blockquote>
  <p>Todo</p>
</blockquote>

<blockquote>
  <p>Due to the complexity of the format, this document is still is
construction.</p>
</blockquote>

<p>And internally Xorg devs called it <em>“X Kitten Butcher”</em>.</p>

<p>We’ll try to make it approachable, and break the bad
spell. However, if you ever want more info check <a href="https://xkbcommon.org/doc/current/keymap-text-format-v1-v2.html">the official
format</a>.</p>

<p>In order to perform the translation from keycodes coming from event
handlers to actual symbols, XKB relies on something called an XKB keymap
(yes everything is called a keymap). This XKB keymap is a compilation
of different components coming from the xkeyboard-config database that
are chosen based on the abstract, and more coherent, concept of layout,
variants, models, and options the user pick: <strong>“RMLVO”</strong>.</p>

<p>After this is picked, the XKB client software just has to keep track of
what’s called a state, and then send it along with the received keycode
to receive back the keysym.</p>

<figure><pre><code data-lang="c"><span>// create a complete keymap from the xkeyboard-config db</span>
<span>struct</span> <span>xkb_keymap</span> <span>*</span><span>keymap</span><span>;</span>
<span>// .. and a state object to keep track of what special state we&#39;re in</span>
<span>//   that could affect the keysym output</span>
<span>struct</span> <span>xkb_state</span> <span>*</span><span>state</span><span>;</span>
<span>…</span>
<span>state</span> <span>=</span> <span>xkb_state_new</span><span>(</span><span>keymap</span><span>);</span>
<span>xkb_state_update_key</span><span>(</span><span>state</span><span>,</span> <span>keycode</span><span>,</span>
    <span>pressed</span> <span>?</span> <span>XKB_KEY_DOWN</span> <span>:</span> <span>XKB_KEY_UP</span><span>);</span>
<span>xkb_keysym_t</span> <span>sym</span> <span>=</span> <span>xkb_state_key_get_one_sym</span><span>(</span><span>state</span><span>,</span> <span>keycode</span><span>);</span></code></pre></figure>

<p>The XKB state object tracks what affects the output of keycode to keysym,
things like modifiers and groups. This example doesn’t mention the idea
of key composing, but we’ll come back to it.</p>

<p>This is important to understand, since you can either have XKB handle
what happens in a specific state when a key is pressed, or do it from
the client side. For example, a client can choose to catch all Ctrl keys
and interpret Ctrl+h as backspace, or leave it up to XKB with a custom
mechanism to know what Ctrl+h means, and the client will receive back
the keysym for backspace directly, with no special handling from its side.</p>

<p>Before moving forward, we need a little baggage of definitions, and
understanding, otherwise nothing will make sense.</p>

<ul>
  <li>evdev keycodes: the events coming from evdev, the ones listed in
<code>/usr/include/linux/input-event-codes.h</code></li>
  <li>XKB keysyms: Actual symbols (or dead key), actions, and special keys
that XKB will return, they exist in
<code>/usr/include/xkbcommon/xkbcommon-keysyms.h</code></li>
  <li>Modifier Keys: Special keys that can affect other keys such as shift,
alt, ctrl, “win”, etc.. Modifiers are also keysyms.</li>
  <li>Geometry: The physical layout of a keyboard, what it looks like and
where the keys are</li>
  <li>Levels and Groups: Levels is another state a key could be in when you
press a modifier. For example, it’s expected that pressing shift with
“a” will output “A”, upper case “A” is the level 2 of what happens when
pressing the key. A Group is similar but it completely switches the
whole keyboard to another key mapping, as if you switched variants.</li>
</ul>

<p>As you can imagine, there’s a lot at play with levels, groups, modifiers,
and actions that can happen, and that’s apart from the basic idea of
keycodes to keysym.</p>

<p>Even when it comes to keysym, the translation isn’t straight away. XKB
relies on intermediary objects.</p>

<p>Furthermore, XKB converts these keycodes into physical key
positions values that are compatible with ISO/IEC 9995-1. So we
move from evdev keycodes, to XKB keycodes, to physical abstract
position on a keyboard layout. This is what happens in the keycode
component files under <code>/usr/share/xkeyboard-config-2/keycodes/</code>. Keycodes
have this form within <code>&lt;...&gt;</code> tags. For example:</p>

<div><div><pre><code>&lt;TLDE&gt; = 49;
&lt;AE01&gt; = 10;
&lt;AE02&gt; = 11;
&lt;AE03&gt; = 12;
&lt;AE04&gt; = 13;
&lt;AE05&gt; = 14;
&lt;AE06&gt; = 15;
&lt;AE07&gt; = 16;
&lt;AE08&gt; = 17;
&lt;AE09&gt; = 18;
&lt;AE10&gt; = 19;
&lt;AE11&gt; = 20;
&lt;AE12&gt; = 21;
&lt;BKSP&gt; = 22;
</code></pre></div></div>

<p>Remember “49”, “10”, “11” are equivalent to evdev:</p>

<div><div><pre><code>#define KEY_GRAVE		41
#define KEY_1			2
#define KEY_2			3
#define KEY_3			4
#define KEY_4			5
#define KEY_5			6
#define KEY_6			7
#define KEY_7			8
#define KEY_8			9
#define KEY_9			10
#define KEY_0			11
#define KEY_MINUS		12
#define KEY_EQUAL		13
#define KEY_BACKSPACE		14
</code></pre></div></div>

<p>Or basically the first row from ISO/IEC 9995-1 on a keyboard.</p>

<p>To make it easier for users to pick an XKB keymap, without
having to know much details, the idea of picking only RMLVO,
Rules-Model-Layout-Variant-Options, was invented. This is an abstraction
on top to pick the components that make up a keymap, and thus come up with
the right keyboard behavior expected by the user. This is managed by the
XKB registry, which graphical environments interact with, this is what
is shown to the user when they’re asked about picking their keyboard
layout, the list of possible layouts and variants on those layouts,
along with special options.</p>

<ul>
  <li>Model – the name of the model of your keyboard</li>
  <li>Layout – the layout(s) you intend to use (usually refer to country code)</li>
  <li>Variant – the variant(s) of the layout(s) you intend to use (minor
and national variants)</li>
  <li>Options – extra XKB configuration options to customize the standard
layout. For example to change modifier keys.</li>
</ul>

<p>To know what’s actually picked as the final keymap, what’s called KcCGST,
we can run <code>xkbcli</code>. For example, for a dvorak keyboard, or a normal
qwerty keyboard:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xkbcli compile-keymap <span>--kccgst</span> <span>\</span>
  <span>--layout</span> us <span>\</span>
  <span>--variant</span> dvorak <span>\</span>
  <span>--options</span> terminate:ctrl_alt_bksp

xkb_keymap <span>{</span>
  xkb_keycodes <span>{</span> include <span>&#34;evdev+aliases(qwerty)&#34;</span> <span>}</span><span>;</span>
  xkb_types <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_compat <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_symbols <span>{</span> include <span>&#34;pc+us(dvorak)+inet(evdev)+terminate(ctrl_alt_bksp)&#34;</span> <span>}</span><span>;</span>
  xkb_geometry <span>{</span> include <span>&#34;pc(pc105)&#34;</span> <span>}</span><span>;</span>
<span>}</span><span>;</span>

<span>&gt;</span> xkbcli compile-keymap <span>--kccgst</span> <span>\</span>
  <span>--layout</span> us <span>\</span>
  <span>--variant</span> qwerty <span>\</span>
  <span>--options</span> terminate:ctrl_alt_bksp

xkb_keymap <span>{</span>
  xkb_keycodes <span>{</span> include <span>&#34;evdev+aliases(qwerty)&#34;</span> <span>}</span><span>;</span>
  xkb_types <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_compat <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_symbols <span>{</span> include <span>&#34;pc+us(qwerty)+inet(evdev)+terminate(ctrl_alt_bksp)&#34;</span> <span>}</span><span>;</span>
  xkb_geometry <span>{</span> include <span>&#34;pc(pc105)&#34;</span> <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre></figure>

<p>We’ll revisit the RMLVO, let’s just say it’s all about what the “rule”
part refers to: a lookup table with rules mapping the abstract names to
the components of the keymaps which are called KcCGST.</p>

<p>To find your layout and visualize it you can check the <a href="https://xkeyboard-config.freedesktop.org/layouts/gallery/#?model=iso-60&amp;language=tao">gallery here</a> and the <a href="https://xkeyboard-config.freedesktop.org/layouts/analyzer/#?model=iso-60&amp;layout=af">analyzer here</a>.</p>

<p>KcCGST, or the Keycodes, Compat, Geometry, Symbols, Types, are the
component parts of an XKB keymap. This is the actual functional XKB
configuration that is used behind the RMLVO easy facade. In general, XKB
considers it an implementation detail and pushes for users to favor
configuring XKB through RMLVO. Yet, it’s the core of XKB!</p>

<p>The resolution of the RMLVO will create a complete keymap, a self-contain
object that has all the related KcCGST components assembled together. This
complete XKB keymap is what is used by the clients.</p>

<p>To get a quick glimpse at what a full resolved keymap looks like, try
this command:</p>

<div><div><pre><code>&gt; xkbcli compile-keymap --layout us --rules evdev
</code></pre></div></div>

<p>Or for a more compact one, look again at the command such as the one we
just did before:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xkbcli compile-keymap <span>--kccgst</span> <span>--layout</span> us <span>--options</span> terminate:ctrl_alt_bksp
xkb_keymap <span>{</span>
  xkb_keycodes <span>{</span> include <span>&#34;evdev+aliases(qwerty)&#34;</span> <span>}</span><span>;</span>
  xkb_types <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_compat <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_symbols <span>{</span> include <span>&#34;pc+us+inet(evdev)+terminate(ctrl_alt_bksp)&#34;</span> <span>}</span><span>;</span>
  xkb_geometry <span>{</span> include <span>&#34;pc(pc105)&#34;</span> <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre></figure>

<p>Let’s go over these components and explain them.</p>

<p>First of, the KcCGST configurations that come from the keyboard-config
project are often found in the following places in reverse order of
precedence, with the component bundled underneath:</p>

<ul>
  <li><code>/usr/share/X11/xkb</code>, <code>$XKB_CONFIG_ROOT</code>, <code>/usr/share/xkeyboard-config-2/</code></li>
  <li><code>/etc/xkb</code></li>
  <li><code>$XKB_CONFIG_EXTRA_PATH</code></li>
  <li><code>$HOME/.xkb</code></li>
  <li><code>$HOME/.config/xkb</code></li>
</ul>

<p>Most of the components have a useful utility. That’s apart from the
geometry, which is a complex file used to describe what a keyboard
physical layout looks like. It’s not used in the latest xkbcommon
mechanism though, so we’ll skip explaining it.</p>

<p>The XKB configuration format has types: string, numbers, key positions,
and keysym:</p>

<ul>
  <li><code>&#34;hello&#34;</code>, <code>&#34;%S/pc&#34;</code></li>
  <li><code>42</code>, <code>134</code></li>
  <li><code>&lt;AE12&gt;</code>, <code>&lt;BKSP&gt;</code></li>
  <li><code>percent</code>, <code>a</code>, <code>A</code></li>
</ul>

<p>It also has many special keywords, and some structure format. The main
structural format is called a component, basically the components of
the KcCGST. Each XKB conf file is an aggregation of multiple of these
components. They have the form:</p>

<figure><pre><code data-lang="c"><span>&lt;</span><span>generic_flags</span><span>&gt;</span> <span>&lt;</span><span>symbols_flags</span><span>&gt;</span> <span>&lt;</span><span>xkb_componentname</span><span>&gt;</span> <span>&#34;&lt;name&gt;&#34;</span> <span>{</span>

  <span>// body</span>

<span>};</span>

<span>// Example</span>

<span>default</span> <span>partial</span> <span>alphanumeric_keys</span> <span>modifier_keys</span>
<span>xkb_symbols</span> <span>&#34;basic&#34;</span> <span>{</span>
  <span>// body</span>
<span>};</span></code></pre></figure>

<p>The generic flags can be one or many of these:</p>

<ul>
  <li><code>default</code>: One of these “variant” per component file, the default
 values to be used</li>
  <li><code>partial</code>: To be used in another conf</li>
  <li><code>hidden</code>: Only used internally within the file’s scope</li>
</ul>

<p>And the symbols flags can be one or many of these:</p>

<ul>
  <li><code>alphanumeric_keys</code></li>
  <li><code>modifier_keys</code></li>
  <li><code>keypad_keys</code></li>
  <li><code>function_keys</code></li>
  <li><code>alternate_group</code></li>
</ul>

<p>The symbols flags are mostly metadata and don’t affect the XKB processing.
They’re indicators of what the component configuration covers, and if
none are present it’s assumed it covers a complete keyboard.</p>

<p>Let’s start with the most important keywords, the ones used to import
and merge files together, we’ve seen the <code>include</code>. It works by finding
the file of the same component with the specified name, if it exists
in any of the valid conf paths (or if explicitly mentioned with string
substitution shorthands), and then look for the variants inside or the
default value if none are passed: <code>include &#34;file(variant)&#34;</code>.</p>

<p>This “merge resolution” mechanism also applies to values within the
components objects, which can be tagged with <code>augment</code>, <code>override</code>,
<code>replace</code>, too.</p>

<p>As for files, a shorthand exists to have a single statement with multiple
includes concatenated. In this case the following merge mode prefixes
are used:</p>

<ul>
  <li><code>+</code> selects the override merge mode (default).</li>
  <li><code>|</code> selects the augment merge mode.</li>
  <li><code>^</code> selects the replace merge mode.</li>
</ul>

<p>So you can now understand why the following line we’ve seen works, and
how it creates an inheritance mechanism, plugging multiple files together:</p>

<figure><pre><code data-lang="c"><span>xkb_symbols</span> <span>{</span> <span>include</span> <span>&#34;pc+us+inet(evdev)+terminate(ctrl_alt_bksp)&#34;</span> <span>};</span></code></pre></figure>

<p>Let’s now explain what each component does, and wrap up with how the
rules mechanism of the RMLVO then resolves them into an XKB full keymap.</p>

<p>The keycodes file is the most obvious one and the first entry-point
for XKB logic, it translates from XKB keycodes to the physical codes
ISO/IEC 9995-1. The syntax of the components looks something like this:</p>

<figure><pre><code data-lang="c"><span>default</span> <span>xkb_keycodes</span> <span>&#34;mykeycode&#34;</span> <span>{</span>
	<span>// defining the range</span>
	<span>minimum</span> <span>=</span> <span>8</span><span>;</span>
	<span>maximum</span> <span>=</span> <span>255</span><span>;</span>

	<span>// mapping of keycodes to layout keys</span>
	<span>&lt;</span><span>TAB</span><span>&gt;</span> <span>=</span> <span>23</span><span>;</span>
	<span>&lt;</span><span>AD01</span><span>&gt;</span> <span>=</span> <span>24</span><span>;</span>
	<span>&lt;</span><span>AD02</span><span>&gt;</span> <span>=</span> <span>25</span><span>;</span>
	<span>&lt;</span><span>AD03</span><span>&gt;</span> <span>=</span> <span>26</span><span>;</span>
	<span>&lt;</span><span>AD04</span><span>&gt;</span> <span>=</span> <span>27</span><span>;</span>
	<span>&lt;</span><span>AD05</span><span>&gt;</span> <span>=</span> <span>28</span><span>;</span>
	<span>&lt;</span><span>AD06</span><span>&gt;</span> <span>=</span> <span>29</span><span>;</span>
	<span>&lt;</span><span>BKSL</span><span>&gt;</span> <span>=</span> <span>51</span><span>;</span>
	<span>&lt;</span><span>RTRN</span><span>&gt;</span> <span>=</span> <span>36</span><span>;</span>

	<span>// making one physical key name equivalent to another</span>
	<span>alias</span> <span>&lt;</span><span>LatQ</span><span>&gt;</span> <span>=</span> <span>&lt;</span><span>AD01</span><span>&gt;</span><span>;</span>
	<span>alias</span> <span>&lt;</span><span>LatW</span><span>&gt;</span> <span>=</span> <span>&lt;</span><span>AD02</span><span>&gt;</span><span>;</span>
	<span>alias</span> <span>&lt;</span><span>LatE</span><span>&gt;</span> <span>=</span> <span>&lt;</span><span>AD03</span><span>&gt;</span><span>;</span>
	<span>alias</span> <span>&lt;</span><span>LatR</span><span>&gt;</span> <span>=</span> <span>&lt;</span><span>AD04</span><span>&gt;</span><span>;</span>
	<span>alias</span> <span>&lt;</span><span>LatT</span><span>&gt;</span> <span>=</span> <span>&lt;</span><span>AD05</span><span>&gt;</span><span>;</span>
	<span>alias</span> <span>&lt;</span><span>LatY</span><span>&gt;</span> <span>=</span> <span>&lt;</span><span>AD06</span><span>&gt;</span><span>;</span>

	<span>// these are for LEDs, not always used by clients</span>
	<span>indicator</span> <span>1</span>  <span>=</span> <span>&#34;Caps Lock&#34;</span><span>;</span>
	<span>indicator</span> <span>2</span>  <span>=</span> <span>&#34;Num Lock&#34;</span><span>;</span>
	<span>indicator</span> <span>3</span>  <span>=</span> <span>&#34;Scroll Lock&#34;</span><span>;</span>
<span>};</span></code></pre></figure>

<p>The syntax is straight forward, it’s a couple of assignment, with the
possibility to have aliases, and giving names to LEDs, indicators, which
aren’t really leds afaik but keys that lock or latch. By convention it
explicitly names special keys, but other keys as their ISO positions.</p>

<p>Here’s a standard keyboard with its key positions:</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/xkb_key_layout.png" alt="keypositions" title="XKB key positions layout"/>
Courtesy from <a href="https://www.charvolant.org/doug/xkb/html/img3.png">https://www.charvolant.org/doug/xkb/html/img3.png</a></p>

<p>Let’s move to the types component. This is where the information about
levels, and how to switch between them is defined.</p>

<figure><pre><code data-lang="c"><span>virtual_modifiers</span>  <span>NumLock</span><span>;</span>

<span>type</span> <span>&#34;ONE_LEVEL&#34;</span> <span>{</span>
	<span>modifiers</span> <span>=</span> <span>None</span><span>;</span>
	<span>map</span><span>[</span><span>None</span><span>]</span> <span>=</span> <span>Level1</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Any&#34;</span><span>;</span>
<span>};</span>

<span>type</span> <span>&#34;TWO_LEVEL&#34;</span> <span>{</span>
	<span>modifiers</span> <span>=</span> <span>Shift</span><span>;</span>
	<span>map</span><span>[</span><span>Shift</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Base&#34;</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level2</span><span>]</span> <span>=</span> <span>&#34;Shift&#34;</span><span>;</span>
<span>};</span>

<span>type</span> <span>&#34;ALPHABETIC&#34;</span> <span>{</span>
	<span>modifiers</span> <span>=</span> <span>Shift</span> <span>+</span> <span>Lock</span><span>;</span>
	<span>map</span><span>[</span><span>Shift</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>map</span><span>[</span><span>Lock</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Base&#34;</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level2</span><span>]</span> <span>=</span> <span>&#34;Caps&#34;</span><span>;</span>
<span>};</span>

<span>// override ALPHABETIC Shift will cancel capslock</span>
<span>override</span> <span>type</span> <span>&#34;ALPHABETIC&#34;</span> <span>{</span>
	<span>modifiers</span> <span>=</span> <span>Shift</span> <span>+</span> <span>Lock</span><span>;</span>
	<span>map</span><span>[</span><span>Shift</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>preserve</span><span>[</span><span>Lock</span><span>]</span> <span>=</span> <span>Lock</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Base&#34;</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level2</span><span>]</span> <span>=</span> <span>&#34;Caps&#34;</span><span>;</span>
<span>};</span>

<span>// override ALPHABETIC, Shift will ignore capslock</span>
<span>override</span> <span>type</span> <span>&#34;ALPHABETIC&#34;</span> <span>{</span>
	<span>modifiers</span> <span>=</span> <span>Shift</span><span>;</span>
	<span>map</span><span>[</span><span>Shift</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Base&#34;</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level2</span><span>]</span> <span>=</span> <span>&#34;Caps&#34;</span><span>;</span>
<span>};</span>

<span>// CapsLock acts as Shift with locking, Shift does not cancel CapsLock.</span>
<span>type</span> <span>&#34;ALPHABETIC&#34;</span> <span>{</span>
	<span>modifiers</span> <span>=</span> <span>Shift</span> <span>+</span> <span>Lock</span><span>;</span>
	<span>map</span><span>[</span><span>Shift</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>map</span><span>[</span><span>Lock</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>map</span><span>[</span><span>Shift</span><span>+</span><span>Lock</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Base&#34;</span><span>;</span>
	<span>level_name</span><span>[</span><span>Level2</span><span>]</span> <span>=</span> <span>&#34;Caps&#34;</span><span>;</span>
<span>};</span></code></pre></figure>

<p>The syntax here is more cumbersome. Firstly, there are some definition
lines. In each <code>type</code> entry (which can be prepended with merge syntax
like anything else in this syntax really) of the form <code>type &#34;name&#34;</code>,
we have to define the modifiers that will be used as such:</p>

<figure><pre><code data-lang="c"><span>modifiers</span> <span>=</span> <span>Shift</span> <span>+</span> <span>Lock</span><span>;</span></code></pre></figure>

<p>The <code>+</code>, is just a separator here.</p>

<figure><pre><code data-lang="c"><span>virtual_modifiers</span>  <span>NumLock</span><span>;</span></code></pre></figure>

<p>After defining the modifiers that are used for that type, we have a series
of mapping to define the combination and what levels these will achieve.</p>

<figure><pre><code data-lang="c"><span>map</span><span>[</span><span>Shift</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
<span>map</span><span>[</span><span>Lock</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span>
<span>map</span><span>[</span><span>Shift</span><span>+</span><span>Lock</span><span>]</span> <span>=</span> <span>Level2</span><span>;</span></code></pre></figure>

<p>The syntax is also straight forward, it’s a list of mapping from a
combination of modifiers to the <code>LevelX</code> it will take the keysym to.</p>

<p>Afterward, we have a naming section, which is there only for the metadata
information, to give names to levels:</p>

<figure><pre><code data-lang="c"><span>level_name</span><span>[</span><span>Level1</span><span>]</span> <span>=</span> <span>&#34;Base&#34;</span><span>;</span>
<span>level_name</span><span>[</span><span>Level2</span><span>]</span> <span>=</span> <span>&#34;Caps&#34;</span><span>;</span></code></pre></figure>

<p>The only tricky part is the <code>preserve</code> keyword:</p>

<figure><pre><code data-lang="c"><span>preserve</span><span>[</span><span>Lock</span><span>]</span> <span>=</span> <span>Lock</span><span>;</span></code></pre></figure>

<p>This has to do with how XKB consumes modifiers as it processes types
and outputs keysyms, its internal list of effective modifiers. Simply
said, without the <code>preserve</code> when the keysym is sent back to the client
(<code>xkb_state_key_get_one_sym</code>) the state object doesn’t consume the
modifier, so the client can inspect it for further special handling.</p>

<figure><pre><code data-lang="c"><span>xkb_mod_mask_t</span> <span>mods</span> <span>=</span> <span>xkb_state_serialize_mods</span><span>(</span><span>state</span><span>,</span> <span>XKB_STATE_MODS_EFFECTIVE</span><span>);</span>
<span>xkb_mod_mask_t</span> <span>consumed</span> <span>=</span> <span>xkb_state_key_get_consumed_mods2</span><span>(</span><span>state</span><span>,</span> <span>keycode</span><span>,</span> <span>XKB_CONSUMED_MODE_XKB</span><span>);</span>
<span>xkb_mod_mask_t</span> <span>unconsumed_mods</span> <span>=</span> <span>mods</span> <span>&amp;</span> <span>~</span><span>consumed</span><span>;</span></code></pre></figure>

<p>That’s useful for layout where you have, let’s say Greek letters for
Level1 and Level2, and at Level3 and Level4 there are the usual Latin
letters. So you’d want to preserve <code>Ctrl</code> and <code>Shift</code>, so that the
application can catch <code>Ctrl+c</code> for example, which would be in Level3
(Latin lower-case).</p>

<p>I’ve added different versions of the <code>ALPHABETIC</code> type in the example,
and how the capslock and shift combinations can affect letters.</p>

<p>Later on we’ll see how we assign the levels logic to symbols and
compatibility logic, but let’s just say that XKB will categorize keys
with a heuristic and assign them to default types if no other types were
explicitly chosen. These are:</p>

<ul>
  <li><code>&#34;ONE_LEVEL&#34;</code>: When there are only one level change for the keysym</li>
  <li><code>&#34;TWO_LEVEL&#34;</code>: When there are exacly two levels change for the keysym</li>
  <li><code>&#34;ALPHABETIC&#34;</code>: When the keysym is alphabetic and has two levels</li>
  <li><code>&#34;KEYPAD&#34;</code>: For keypad keys of any level (two usually)</li>
  <li><code>&#34;FOUR_LEVEL_ALPHABETIC&#34;</code>, <code>&#34;FOUR_LEVEL_SEMIALPHABETIC&#34;</code>, 3 to 4 keysym</li>
  <li><code>&#34;FOUR_LEVEL&#34;</code>: When nothing else matches</li>
</ul>

<p>The next component is the XKB compatibility, which is used to translate
key combinations into action statements. Actions can also be attached
directly in the XKB symbols component for each key, however it’s done in
the compatibility layer because it has a mechanism for generic pattern
matching of keysym combinations, so we don’t have to repeat the same
things in different places.</p>

<figure><pre><code data-lang="c"><span>default</span> <span>xkb_compatibility</span> <span>&#34;basic&#34;</span>  <span>{</span>
    <span>virtual_modifiers</span> <span>NumLock</span><span>,</span><span>AltGr</span><span>;</span>
<span>...</span>
    <span>interpret</span><span>.</span><span>repeat</span><span>=</span> <span>False</span><span>;</span>
    <span>setMods</span><span>.</span><span>clearLocks</span><span>=</span> <span>True</span><span>;</span>
<span>...</span>
    <span>interpret</span> <span>Shift_Lock</span><span>+</span><span>AnyOf</span><span>(</span><span>Shift</span><span>+</span><span>Lock</span><span>)</span> <span>{</span>
        <span>action</span><span>=</span> <span>LockMods</span><span>(</span><span>modifiers</span><span>=</span><span>Shift</span><span>);</span>
    <span>};</span>
<span>...</span>
    <span>group</span> <span>2</span> <span>=</span> <span>AltGr</span><span>;</span>
<span>...</span>
    <span>indicator</span><span>.</span><span>allowExplicit</span><span>=</span> <span>False</span><span>;</span>
<span>...</span>
    <span>indicator</span> <span>&#34;Caps Lock&#34;</span> <span>{</span>
        <span>whichModState</span><span>=</span> <span>Locked</span><span>;</span>
        <span>modifiers</span><span>=</span> <span>Lock</span><span>;</span>
    <span>};</span>
<span>...</span>
<span>};</span>

<span>default</span> <span>partial</span> <span>xkb_compatibility</span> <span>&#34;pc&#34;</span> <span>{</span>
    <span>// Sets the &#34;Alt&#34; virtual modifier.</span>
    <span>virtual_modifiers</span>  <span>Alt</span><span>;</span>
    <span>setMods</span><span>.</span><span>clearLocks</span><span>=</span> <span>True</span><span>;</span>

    <span>interpret</span> <span>Alt_L</span><span>+</span><span>Any</span> <span>{</span>
	<span>virtualModifier</span><span>=</span> <span>Alt</span><span>;</span>
	<span>action</span> <span>=</span> <span>SetMods</span><span>(</span><span>modifiers</span><span>=</span><span>modMapMods</span><span>);</span>
    <span>};</span>

    <span>interpret</span> <span>Alt_R</span><span>+</span><span>Any</span> <span>{</span>
	<span>virtualModifier</span><span>=</span> <span>Alt</span><span>;</span>
	<span>action</span> <span>=</span> <span>SetMods</span><span>(</span><span>modifiers</span><span>=</span><span>modMapMods</span><span>);</span>
    <span>};</span>
<span>};</span></code></pre></figure>

<p>This has many components, the <code>interpret</code> sections to map keys to actions,
the virtual modifier definitions, indicators, repeat behavior of keys,
and more. The important part is the <code>interpret</code> section which matches
keysym along with a modifier (<code>AnyOfOrNone</code>, <code>AnyOf</code>, <code>Any</code>, <code>NoneOf</code>,
<code>AllOf</code>, <code>Exactly</code>). The body of the interpret can also be more specific
by setting values of <code>useModMapMods</code> to match a certain level.</p>

<p>Let’s move to the keysym or symbol component, which as you would
have guessed, finally maps physical keys in ISO location format to
symbols. These files are often named after countries or languages or
specific features, <code>us</code>, <code>jp</code>, <code>group</code>.</p>

<figure><pre><code data-lang="c"><span>partial</span> <span>alphanumeric_keys</span>
<span>xkb_symbols</span> <span>&#34;basic&#34;</span> <span>{</span>

    <span>name</span><span>[</span><span>Group1</span><span>]</span><span>=</span> <span>&#34;US/ASCII&#34;</span><span>;</span>
    <span>key</span> <span>&lt;</span><span>ESC</span><span>&gt;</span>  <span>{</span>        <span>[</span> <span>Escape</span>                        <span>]</span>       <span>};</span>
<span>...</span>
    <span>key</span> <span>&lt;</span><span>TLDE</span><span>&gt;</span> <span>{</span>        <span>[</span> <span>quoteleft</span><span>,</span>    <span>asciitilde</span>      <span>]</span>       <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE01</span><span>&gt;</span> <span>{</span>        <span>[</span>         <span>1</span><span>,</span>    <span>exclam</span>          <span>]</span>       <span>};</span>
<span>...</span>
    <span>modifier_map</span> <span>Shift</span>  <span>{</span> <span>Shift_L</span><span>,</span> <span>Shift_R</span> <span>};</span>
<span>...</span>
<span>};</span></code></pre></figure>

<p>It first has a metadata name in the <code>name[GroupX] = &#34;Symbols Name&#34;</code>
property, which can also be used to find which groups the symbols
belong to.</p>

<figure><pre><code data-lang="c"><span>key</span> <span>&lt;</span><span>TLDE</span><span>&gt;</span> <span>{</span>        <span>[</span> <span>quoteleft</span><span>,</span>    <span>asciitilde</span>      <span>]</span>       <span>};</span></code></pre></figure>

<p>This means the physical key <code>&lt;TLDE&gt;</code>, in level1 will output a left quote
(backtick), and in level2 will output the tilde character.</p>

<p>Additionally, we can also specify within the curly brackets whether a
specific type should be used instead of the default matching one:</p>

<figure><pre><code data-lang="c"><span>key</span> <span>&lt;</span><span>AE05</span><span>&gt;</span> <span>{</span> <span>[</span><span>parenleft</span><span>,</span> <span>1</span><span>,</span> <span>EuroSign</span><span>],</span> <span>type</span><span>[</span><span>Group1</span><span>]</span> <span>=</span> <span>&#34;FOUR_LEVEL_ALPHABETIC&#34;</span> <span>};</span></code></pre></figure>

<p>Similarly, the actions can be assigned here instead of in the
compatibility component, and the groups can also be explicitly expressed with
the syntax:</p>

<figure><pre><code data-lang="c"><span>key</span> <span>&lt;</span><span>LALT</span><span>&gt;</span> <span>{</span>
    <span>symbols</span><span>[</span><span>Group1</span><span>]</span><span>=</span><span>[</span><span>Alt_L</span><span>],</span>
    <span>actions</span><span>[</span><span>Group1</span><span>]</span><span>=</span><span>[</span><span>SetMods</span><span>(</span><span>modifiers</span><span>=</span><span>modMapMods</span><span>)]</span>
<span>};</span></code></pre></figure>

<p>That all should cover the KcCGST component syntax. It’s very long already,
I know, yet it barely covers the basics. Let’s see a few examples to
grasp the concepts.</p>

<p>In <code>symbol/group</code> we have:</p>

<figure><pre><code data-lang="c"><span>// The left Alt key (while pressed) chooses the next group.</span>
<span>partial</span> <span>modifier_keys</span>
<span>xkb_symbols</span> <span>&#34;lswitch&#34;</span> <span>{</span>
    <span>key</span> <span>&lt;</span><span>LALT</span><span>&gt;</span> <span>{[</span>  <span>Mode_switch</span><span>,</span>  <span>Multi_key</span>  <span>]};</span>
<span>};</span></code></pre></figure>

<p>And in <code>compat/basic</code> we have these <code>interpret</code>:</p>

<figure><pre><code data-lang="c"><span>interpret</span> <span>Mode_switch</span> <span>{</span>
	<span>action</span><span>=</span> <span>SetGroup</span><span>(</span><span>group</span><span>=+</span><span>1</span><span>);</span>
<span>};</span></code></pre></figure>

<p>The <code>Multi_key</code> maps to a compose key in <code>compat/ledcompose</code>:</p>

<figure><pre><code data-lang="c"><span>interpret</span> <span>Multi_key</span><span>+</span><span>Any</span> <span>{</span>
	<span>virtualModifier</span><span>=</span> <span>Compose</span><span>;</span>
	<span>action</span> <span>=</span> <span>LatchMods</span><span>(</span><span>modifiers</span><span>=</span><span>modMapMods</span><span>);</span>
<span>};</span>

<span>indicator</span> <span>&#34;Compose&#34;</span> <span>{</span>
	<span>allowExplicit</span><span>;</span>
	<span>whichModState</span><span>=</span> <span>Latched</span><span>;</span>
	<span>modifiers</span><span>=</span> <span>Compose</span><span>;</span>
<span>};</span></code></pre></figure>

<p>We’ll see in a bit how compose works.</p>

<p>Another example setting <code>&lt;LWIN&gt;</code> to <code>Super_L</code> which sets <code>Mod3</code> modifier.</p>

<figure><pre><code data-lang="c"><span>xkb_compatibility</span> <span>{</span>
   <span>interpret</span> <span>Super_L</span> <span>{</span> <span>action</span> <span>=</span> <span>SetMods</span><span>(</span><span>modifiers</span><span>=</span><span>Mod3</span><span>);</span> <span>};</span>
<span>}</span>

<span>xkb_symbols</span> <span>{</span>
   <span>key</span> <span>&lt;</span><span>LWIN</span><span>&gt;</span> <span>{</span> <span>[</span> <span>Super_L</span> <span>]</span> <span>};</span>
   <span>modifier_map</span> <span>Mod3</span> <span>{</span> <span>Super_L</span> <span>};</span>
<span>}</span></code></pre></figure>

<p>Here’s another example swapping the top row numbers on shift:</p>

<figure><pre><code data-lang="c"><span>default</span> <span>partial</span> <span>alphanumeric_keys</span>
<span>xkb_symbols</span> <span>&#34;basic&#34;</span> <span>{</span>
    <span>include</span> <span>&#34;us(basic)&#34;</span>
    <span>name</span><span>[</span><span>Group1</span><span>]</span><span>=</span> <span>&#34;Banana (US)&#34;</span><span>;</span>
 
    <span>key</span> <span>&lt;</span><span>AE01</span><span>&gt;</span> <span>{</span> <span>[</span> <span>exclam</span><span>,</span>          <span>1</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE02</span><span>&gt;</span> <span>{</span> <span>[</span> <span>at</span><span>,</span>              <span>2</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE03</span><span>&gt;</span> <span>{</span> <span>[</span> <span>numbersign</span><span>,</span>      <span>3</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE04</span><span>&gt;</span> <span>{</span> <span>[</span> <span>dollar</span><span>,</span>          <span>4</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE05</span><span>&gt;</span> <span>{</span> <span>[</span> <span>percent</span><span>,</span>         <span>5</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE06</span><span>&gt;</span> <span>{</span> <span>[</span> <span>asciicircum</span><span>,</span>     <span>6</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE07</span><span>&gt;</span> <span>{</span> <span>[</span> <span>ampersand</span><span>,</span>       <span>7</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE08</span><span>&gt;</span> <span>{</span> <span>[</span> <span>asterisk</span><span>,</span>        <span>8</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE09</span><span>&gt;</span> <span>{</span> <span>[</span> <span>parenleft</span><span>,</span>       <span>9</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE10</span><span>&gt;</span> <span>{</span> <span>[</span> <span>parenright</span><span>,</span>      <span>0</span><span>]</span>     <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE11</span><span>&gt;</span> <span>{</span> <span>[</span> <span>underscore</span><span>,</span>      <span>minus</span><span>]</span> <span>};</span>
    <span>key</span> <span>&lt;</span><span>AE12</span><span>&gt;</span> <span>{</span> <span>[</span> <span>plus</span><span>,</span>            <span>equal</span><span>]</span> <span>};</span>
<span>};</span>
 
<span>// Same as banana but map the euro sign to the 5 key</span>
<span>partial</span> <span>alphanumeric_keys</span>
<span>xkb_symbols</span> <span>&#34;orange&#34;</span> <span>{</span>
    <span>include</span> <span>&#34;banana(basic)&#34;</span>
    <span>name</span><span>[</span><span>Group1</span><span>]</span> <span>=</span> <span>&#34;Banana (Eurosign on 5)&#34;</span><span>;</span>
    <span>include</span> <span>&#34;eurosign(5)&#34;</span>
<span>};</span></code></pre></figure>

<p>Here’s a symbol component which replaces key “B” to have a third level
activated with the right alt to display a broccoli.</p>

<figure><pre><code data-lang="c"><span>partial</span> <span>alphanumeric_keys</span>
<span>xkb_symbols</span> <span>&#34;broccoli&#34;</span> <span>{</span>
    <span>include</span> <span>&#34;us(basic)&#34;</span>
    <span>name</span><span>[</span><span>Group1</span><span>]</span> <span>=</span> <span>&#34;Broccoli&#34;</span><span>;</span>
    <span>key</span> <span>&lt;</span><span>AD05</span><span>&gt;</span> <span>{</span> <span>[</span> <span>b</span><span>,</span> <span>B</span><span>,</span> <span>U1F966</span> <span>]};</span> <span>// 🥦</span>
    <span>include</span> <span>&#34;level3(ralt_switch)&#34;</span>
<span>};</span></code></pre></figure>

<p><em>NB</em>: XKB has keysym to allow controlling the mouse pointer from the
keyboard, this can be useful if clients actually understand these keysym
and act on them.</p>

<p>It’s fine and all but we need the RMLVO so that the users can actually
use the keymap properly without bothering with all that we’ve seen.</p>

<p>The logic exists within the rules files, that have this sort syntax:</p>

<figure><pre><code data-lang="shell"><span>!</span> include %S/evdev
 
<span>!</span> option     <span>=</span> symbols
  custom:foo <span>=</span> +custom<span>(</span>bar<span>)</span>
  custom:baz <span>=</span> +other<span>(</span>baz<span>)</span>

// One may use multiple MLVO components on the LHS
<span>!</span> layout    option          <span>=</span> symbols
  be        caps:digits_row <span>=</span> +capslock<span>(</span>digits_row<span>)</span>
  fr        caps:digits_row <span>=</span> +capslock<span>(</span>digits_row<span>)</span></code></pre></figure>

<p>The full syntax grammar looks like this:</p>

<figure><pre><code data-lang="shell">File         ::<span>=</span> <span>{</span> <span>&#34;!&#34;</span> <span>(</span>Include | Group | RuleSet<span>)</span> <span>}</span>

Include      ::<span>=</span> <span>&#34;include&#34;</span> &lt;ident&gt;

Group        ::<span>=</span> GroupName <span>&#34;=&#34;</span> <span>{</span> GroupElement <span>}</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
GroupName    ::<span>=</span> <span>&#34;$&#34;</span>&lt;ident&gt;
GroupElement ::<span>=</span> &lt;ident&gt;

RuleSet      ::<span>=</span> Mapping <span>{</span> Rule <span>}</span>

Mapping      ::<span>=</span> <span>{</span> Mlvo <span>}</span> <span>&#34;=&#34;</span> <span>{</span> Kccgst <span>}</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
Mlvo         ::<span>=</span> <span>&#34;model&#34;</span> | <span>&#34;option&#34;</span> | <span>(</span><span>&#34;layout&#34;</span> | <span>&#34;variant&#34;</span><span>)</span> <span>[</span> Index <span>]</span>
Index        ::<span>=</span> <span>&#34;[&#34;</span> <span>({</span> NumericIndex <span>}</span> | <span>{</span> SpecialIndex <span>})</span> <span>&#34;]&#34;</span>
NumericIndex ::<span>=</span> 1..XKB_MAX_GROUPS
SpecialIndex ::<span>=</span> <span>&#34;single&#34;</span> | <span>&#34;first&#34;</span> | <span>&#34;later&#34;</span> | <span>&#34;any&#34;</span>
Kccgst       ::<span>=</span> <span>&#34;keycodes&#34;</span> | <span>&#34;symbols&#34;</span> | <span>&#34;types&#34;</span> | <span>&#34;compat&#34;</span> | <span>&#34;geometry&#34;</span>

Rule         ::<span>=</span> <span>{</span> MlvoValue <span>}</span> <span>&#34;=&#34;</span> <span>{</span> KccgstValue <span>}</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
MlvoValue    ::<span>=</span> <span>&#34;*&#34;</span> | <span>&#34;&lt;none&gt;&#34;</span> | <span>&#34;&lt;some&gt;&#34;</span> | <span>&#34;&lt;any&gt;&#34;</span> | GroupName | &lt;ident&gt;
KccgstValue  ::<span>=</span> &lt;ident&gt; <span>[</span> <span>{</span> Qualifier <span>}</span> <span>]</span>
Qualifier    ::<span>=</span> <span>&#34;:&#34;</span> <span>({</span> NumericIndex <span>}</span> | <span>&#34;all&#34;</span><span>)</span></code></pre></figure>

<p>We won’t go into details, but basically it has lines starting with <code>!</code>
that set certain MLVO values and then map them to KccgstValue specific
component values. There are also variable names that can be defined
as shorthand for multiple values with <code>$var = val1 val2</code>, and there
are string substitutions starting with <code>%</code>. More info can be found
<a href="https://xkbcommon.org/doc/current/rule-file-format.html">here</a>.</p>

<p>So we’ve got the full scope now of RMLVO to KcCGST, the big picture!</p>

<p>We didn’t discuss another sub-feature of XKB called composing, or the
compose key processor. We didn’t mention it because the configuration
doesn’t come with the xkeyboard-config project. It’s loaded independently
by clients that want to perform composition.</p>

<div><div><pre><code>&lt;Multi_key&gt; &lt;e&gt; &lt;&#39;&gt;       : &#34;é&#34;   U00E9
&lt;Multi_key&gt; &lt;&#39;&gt; &lt;e&gt;       : &#34;é&#34;   U00E9
&lt;Multi_key&gt; &lt;o&gt; &lt;slash&gt;   : &#34;ø&#34;   U00F8
&lt;Multi_key&gt; &lt;s&gt; &lt;s&gt;       : &#34;ß&#34;   U00DF
</code></pre></div></div>

<p>As you can see, this is the <code>&lt;Multi_key&gt;</code> keysym we’ve talked about in
an earlier example, this is where it’s interpreted.</p>

<p>After editing any of the files, the syntax can be validated with <code>xkbcli
compile-compose</code>.</p>

<p>The way the file is used is that clients will pass it to the XKB compose
parser to get an in-memory table of it. Then the client keeps the compose
state, just like the modifier state, and plug it in the main interaction
with XKB we’ve seen earlier. Like this:</p>

<figure><pre><code data-lang="c"><span>// 1. Load compose table (locale-dependent)</span>
<span>struct</span> <span>xkb_compose_table</span> <span>*</span><span>table</span> <span>=</span>
    <span>xkb_compose_table_new_from_locale</span><span>(</span><span>ctx</span><span>,</span> <span>getenv</span><span>(</span><span>&#34;LANG&#34;</span><span>),</span>
                                      <span>XKB_COMPOSE_COMPILE_NO_FLAGS</span><span>);</span>

<span>// 2. Create a compose state</span>
<span>struct</span> <span>xkb_compose_state</span> <span>*</span><span>compose</span> <span>=</span>
    <span>xkb_compose_state_new</span><span>(</span><span>table</span><span>,</span> <span>XKB_COMPOSE_STATE_NO_FLAGS</span><span>);</span>

<span>// 3. For each key press:</span>
<span>xkb_keysym_t</span> <span>sym</span> <span>=</span> <span>xkb_state_key_get_one_sym</span><span>(</span><span>state</span><span>,</span> <span>keycode</span><span>);</span>
<span>xkb_compose_feed_result</span> <span>res</span> <span>=</span> <span>xkb_compose_state_feed</span><span>(</span><span>compose</span><span>,</span> <span>sym</span><span>);</span>

<span>// Feed all keysyms into the compose engine:</span>
<span>xkb_compose_state_feed</span><span>(</span><span>compose_state</span><span>,</span> <span>sym</span><span>);</span>

<span>// 4. Check compose status</span>
<span>switch</span> <span>(</span><span>xkb_compose_state_get_status</span><span>(</span><span>compose_state</span><span>))</span> <span>{</span>
    <span>case</span> <span>XKB_COMPOSE_COMPOSED</span><span>:</span>
        <span>composed_sym</span> <span>=</span> <span>xkb_compose_state_get_one_sym</span><span>(</span><span>compose_state</span><span>);</span>
        <span>// Use composed_sym; DO NOT use &#39;sym&#39;</span>
        <span>// char buf[64];</span>
        <span>// xkb_compose_state_get_utf8(compose_state, buf, sizeof(buf));</span>
        <span>// printf(&#34;→ composed result: %s\n&#34;, buf);</span>
        <span>break</span><span>;</span>

    <span>case</span> <span>XKB_COMPOSE_CANCELLED</span><span>:</span>
        <span>// Typically fall back to original sym</span>
        <span>break</span><span>;</span>

    <span>case</span> <span>XKB_COMPOSE_COMPOSING</span><span>:</span>
        <span>// Wait for next key</span>
        <span>break</span><span>;</span>

    <span>case</span> <span>XKB_COMPOSE_NOTHING</span><span>:</span>
        <span>// No composition; use raw &#39;sym&#39;</span>
        <span>break</span><span>;</span>
<span>}</span>

<span>// otherwise</span>
<span>// xkb_state_key_get_utf8</span></code></pre></figure>

<p>So, to make key composing work, it’s all dependent on the client, be
it in X11 or Wayland. In general widget/toolkit libraries, and Xlib,
does it out-of-the-box and/or easily for us.</p>

<p>Finally, let’s review how to interface with XKB from the command line.</p>

<p>There are a couple of X11 bound, and deprecated legacy, commands such as:</p>

<ul>
  <li><code>xmodmap</code> (pre-XKB even)</li>
  <li><code>setxkbmap</code></li>
  <li><code>xkbcomp</code></li>
  <li><code>xev</code></li>
  <li><code>xkbprint</code></li>
  <li><code>xkbevd</code></li>
</ul>

<p>They will not work on Wayland since they rely on the XKB X11 specific
proto (XKM binary format and others), but are still good to debug certain
behavior on X11, and to directly interface with X11 to configure XKB
interpretation on the fly, since obviously it’s these software that rely
on the library and load the appropriate configurations.</p>

<p>The main interaction these days should all pass through <code>xkbcli</code> and
its subcommands. It comes with a few handy man pages:</p>

<ul>
  <li><code>xkbcli</code></li>
  <li><code>xkbcli-list</code></li>
  <li><code>xkbcli-dump-keymap-x11</code></li>
  <li><code>xkbcli-dump-keymap-wayland</code></li>
  <li><code>xkbcli-interactive-x11</code></li>
  <li><code>xkbcli-interactive-wayland</code></li>
  <li><code>xkbcli-compile-compose</code></li>
  <li><code>xkbcli-how-to-type</code></li>
  <li><code>xkbcli-compile-keymap</code></li>
  <li><code>xkbcli-interactive-evdev</code></li>
</ul>

<div><div><pre><code>&gt; xkbcli how-to-type &#39;P&#39;
keysym: P (0x0050)
KEYCODE  KEY NAME  LAYOUT   LAYOUT NAME          LEVEL#  MODIFIERS
33       AD10      1        English (US)         2       [ Shift ]
33       AD10      1        English (US)         2       [ Lock ]
</code></pre></div></div>

<figure><pre><code data-lang="shell"><span>&gt;</span> xkbcli compile-keymap <span>--kccgst</span> <span>--layout</span> us <span>--options</span> terminate:ctrl_alt_bksp
xkb_keymap <span>{</span>
  xkb_keycodes <span>{</span> include <span>&#34;evdev+aliases(qwerty)&#34;</span> <span>}</span><span>;</span>
  xkb_types <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_compat <span>{</span> include <span>&#34;complete&#34;</span> <span>}</span><span>;</span>
  xkb_symbols <span>{</span> include <span>&#34;pc+us+inet(evdev)+terminate(ctrl_alt_bksp)&#34;</span> <span>}</span><span>;</span>
  xkb_geometry <span>{</span> include <span>&#34;pc(pc105)&#34;</span> <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre></figure>

<p>To list the whole RMLVO possible values from the registry:</p>

<div><div><pre><code>&gt; xkbcli list
</code></pre></div></div>

<p>Print current RMLVO:</p>

<div><div><pre><code>&gt; xkbcli compile-keymap --rmlvo
rules: &#34;evdev&#34;
model: &#34;pc105&#34;
layout: &#34;us&#34;
variant: &#34;&#34;
options: &#34;&#34;
</code></pre></div></div>

<p>A nice debugging trace for a compose example <code>alt+&#39;+e</code> that outputs “é”.</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xkbcli interactive-x11 <span>--enable-compose</span> <span>--multiline</span>
<span>------------</span>
key down: 0x06c &lt;RALT&gt;
    layout: depressed: 0
            latched:   0
            locked:    0 <span>&#34;English (US)&#34;</span>
            effective: 0 <span>&#34;English (US)&#34;</span>
            key:       0 <span>&#34;English (US)&#34;</span>
    modifiers: depressed: 0x00000000
               latched:   0x00000000
               locked:    0x00000010 Mod2 NumLock
               effective: 0x00000010 Mod2 NumLock
    level: 0
    raw keysyms: Multi_key
    compose: pending
    LEDs: 1 <span>&#34;Num Lock&#34;</span>
<span>------------</span>
key up:   0x06c &lt;RALT&gt;
<span>------------</span>
key down: 0x030 &lt;AC11&gt;
    layout: depressed: 0
            latched:   0
            locked:    0 <span>&#34;English (US)&#34;</span>
            effective: 0 <span>&#34;English (US)&#34;</span>
            key:       0 <span>&#34;English (US)&#34;</span>
    modifiers: depressed: 0x00000000
               latched:   0x00000000
               locked:    0x00000010 Mod2 NumLock
               effective: 0x00000010 Mod2 NumLock
    level: 0
    raw keysyms: apostrophe
    compose: pending
    LEDs: 1 <span>&#34;Num Lock&#34;</span>
<span>------------</span>
key up:   0x030 &lt;AC11&gt;
<span>------------</span>
key down: 0x01a &lt;AD03&gt;
    layout: depressed: 0
            latched:   0
            locked:    0 <span>&#34;English (US)&#34;</span>
            effective: 0 <span>&#34;English (US)&#34;</span>
            key:       0 <span>&#34;English (US)&#34;</span>
    modifiers: depressed: 0x00000000
               latched:   0x00000000
               locked:    0x00000010 Mod2 NumLock
               effective: 0x00000010 Mod2 NumLock
    level: 0
    raw keysyms: e
    composed: eacute <span>&#34;é&#34;</span> <span>(</span>U+00E9, 1 code point<span>)</span>
    LEDs: 1 <span>&#34;Num Lock&#34;</span>
<span>------------</span></code></pre></figure>

<p>Let’s note I have these confs:</p>

<figure><pre><code data-lang="c"><span>// in symbols</span>
<span>key</span> <span>&lt;</span><span>RALT</span><span>&gt;</span> <span>{</span>
  <span>type</span><span>=</span> <span>&#34;TWO_LEVEL&#34;</span><span>,</span>
  <span>symbols</span><span>[</span><span>1</span><span>]</span><span>=</span> <span>[</span>       <span>Multi_key</span><span>,</span>       <span>Multi_key</span> <span>]</span>
<span>};</span>

<span>// in Compose</span>
<span>&lt;</span><span>Multi_key</span><span>&gt;</span> <span>&lt;</span><span>apostrophe</span><span>&gt;</span> <span>&lt;</span><span>e</span><span>&gt;</span> <span>:</span> <span>&#34;é&#34;</span> <span>eacute</span> <span>#</span> <span>LATIN</span> <span>SMALL</span> <span>LETTER</span> <span>E</span> <span>WITH</span> <span>ACUTE</span></code></pre></figure>

<p>There are additional third party projects such as <code>klfcAUR</code> to compile
layouts from JSON.</p>

<p>Probably the most impressive is how you can rely on the geometry and
print it as a PDF, this only works with the legacy tools though:</p>

<div><div><pre><code>&gt; setxkbmap -print | xkbcomp -xkm - - | xkbprint - - | ps2pdf - mymap.pdf
</code></pre></div></div>

<p>Another thing that is interesting to know is that the XKB
keymap can be converted to Console keymap with scripts such as the
<a href="https://manpages.debian.org/testing/console-setup/setupcon.1.en.html"><code>setupcon(1)</code></a>
which relies on <code>ckbcomp</code> and others, and will read confs from <code>/etc/default/keyboard</code>.</p>

<div><div><pre><code>&gt; localectl
System Locale: LANG=en_US.UTF-8
    VC Keymap: us
   X11 Layout: us
</code></pre></div></div>

<p>We’ll see how it sets it in X11, but let’s just say it can be used to
list keymaps:</p>

<div><div><pre><code>&gt; localectl list-keymaps
</code></pre></div></div>

<p>There are also the options <code>list-x11-keymap-models</code>,
<code>list-x11-keymap-layouts</code>, <code>list-x11-keymap-variants [LAYOUT]</code>,
<code>list-x11-keymap-options</code>.</p>

<p>And to set it with <code>set-x11-keymap</code>. However it always tries to convert
the XKB keymap to console keymap whenever it can, if you don’t want that
behavior, you should add this option:</p>

<div><div><pre><code>&gt; localectl set-x11-keymap --no-convert keymap
</code></pre></div></div>

<p>Let’s end on a funny note to wrap things up about XKB. Yubikeys work by
simulating keyboards, and thus they have to anticipate a very specific
layout and variant, otherwise inserting a Yubikey would output the
wrong values. To skip this, there are udev device properties (<code>ENV{}</code>
set from hwdb) called <code>XKB_FIXED_LAYOUT</code> and <code>XKB_FIXED_VARIANT</code> that
need to be set and respected by the clients of libxkbcommon.</p>

<p>From <code>60-keyboard.hwdb</code>:</p>

<div><div><pre><code># Yubico Yubico Yubikey II
evdev:input:b0003v1050p0010*
# Yubico Yubikey NEO OTP+CCID
evdev:input:b0003v1050p0111*
# Yubico Yubikey NEO OTP+U2F+CCID
evdev:input:b0003v1050p0116*
# OKE Electron Company USB barcode reader
evdev:input:b0003v05FEp1010*
 XKB_FIXED_LAYOUT=us
 XKB_FIXED_VARIANT=
</code></pre></div></div>

<p>Here’s a summary of what was discussed in the XKB stack:</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/xkb.png" alt="XKB Overview" title="XKB Overview"/></p>



<p>We’ve seen a lot of complex keyboard specific input behavior, let’s
dabble a bit with pointer devices now, from mice to touchpads.</p>

<h2 id="types-of-touchpads">Types of Touchpads</h2>

<p>Let’s mention a few definitions.</p>

<p>We have clickpads, a touchpad that has no separate buttons, but
that is all clickable. The behavior then depends on where the click
happens. Meanwhile, forcepads are like clickpads but they don’t have
any buttons and instead will vibrate when pressed. Lastly, trackpoints
are the little balls/nudge in the middle of the keyboard of Thinkpads,
they’re tagged in udev/hwdb with <code>ID_INPUT_POINTINGSTICK</code> property.</p>

<figure><pre><code data-lang="shell">Device:                  TPPS/2 Elan TrackPoint
trackpoint: the nudge of thinkpads

    <span># Name: TPPS/2 Elan TrackPoint</span>
    <span># ID: bus 0x0011 vendor 0x0002 product 0x000a version 0x0063</span>
    <span># Supported Events:</span>
    <span># Event type 0 (EV_SYN)</span>
    <span># Event type 1 (EV_KEY)</span>
    <span>#   Event code 272 (BTN_LEFT)</span>
    <span>#   Event code 273 (BTN_RIGHT)</span>
    <span>#   Event code 274 (BTN_MIDDLE)</span>
    <span># Event type 2 (EV_REL)</span>
    <span>#   Event code 0 (REL_X)</span>
    <span>#   Event code 1 (REL_Y)</span>
    <span># Properties:</span>
    <span>#    Property 0 (INPUT_PROP_POINTER)</span>
    <span>#    Property 5 (INPUT_PROP_POINTING_STICK)</span>

    properties:
    - <span>ID_INPUT</span><span>=</span>1
    - <span>ID_INPUT_MOUSE</span><span>=</span>1
    - <span>ID_INPUT_POINTINGSTICK</span><span>=</span>1
driver:psmouse</code></pre></figure>

<p>As you can see from the above, the trackpoint also has attached to it
some physical buttons, they’re the ones above the Thinkpad touchpad. It’s
in between a mouse and a touchpad.</p>

<p>There are internal touchpads and external touchpads. The external
touchpads don’t get turned off when the lid is closed, nor disabled
while typing. A graphic tablet such as a wacom device is effectively an
external touchpad.</p>

<figure><pre><code data-lang="shell"> ~ <span>&gt;</span> udevadm info /dev/input/event11  
P: /devices/platform/i8042/serio1/input/input11/event11
M: event11
….
N: input/event11
E: <span>DEVNAME</span><span>=</span>/dev/input/event11
…
E: <span>SUBSYSTEM</span><span>=</span>input
E: <span>ID_INPUT</span><span>=</span>1
E: <span>ID_INPUT_TOUCHPAD</span><span>=</span>1
E: <span>ID_INPUT_WIDTH_MM</span><span>=</span>101
E: <span>ID_INPUT_HEIGHT_MM</span><span>=</span>73
…
E: <span>ID_INPUT_TOUCHPAD_INTEGRATION</span><span>=</span>internal</code></pre></figure>

<p>Last interesting fact is that some touchpad can have capacitive touch,
that means they can detect the finger in a range above the touchpad,
hovering in proximity. This is the <code>BTN_TOOL_FINGER</code> in contrast to
<code>BTN_TOUCH</code>, but they often come together and so you have to discern if
it’s a real touchdown or not. For MT there’s also <code>ABS_MT_PRESSURE</code> and
<code>ABS_MT_DISTANCE</code> that can be used for this. That’s another job that
libinput is good at.</p>

<h2 id="mt--multitouch">MT — MultiTouch</h2>

<p>We quickly went over the concept of MT, or multitouch before, let’s add
a bit more info to that.</p>

<p>Multitouch are touchpads that support tracking more than one finger. They
speak evdev multitouch to user-space (type B), and most often are handled
by the hid-multitouch driver from the kernel side.</p>

<p>The capabilities of an MT touchpad should have something similar to this
(<code>libinput record</code> output or others):</p>

<div><div><pre><code>key: BTN_LEFT, BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP, BTN_TOUCH 
     (BTN_TOOL_DOUBLETAP up to BTN_TOOL_QUINTTAP)
abs: ABS_X, ABS_Y, ABS_MT_SLOT, ABS_MT_POSITION_X, ABS_MT_POSITION_Y,
     ABS_MT_TOOL_TYPE, ABS_MT_TRACKING_ID
</code></pre></div></div>

<p>There can also be <code>ABS_MT_TOUCH_MAJOR</code>, <code>ABS_MT_TOUCH_MINOR</code>,
<code>ABS_MT_WIDTH_MINOR</code>, and <code>ABS_MT_WIDTH_MAJOR</code>, that are used to provide
the size of the contact area in surface or absolute units. There’s
also <code>ABS_MT_ORIENTATION</code>, for the orientation of the touching ellipse
(finger).</p>

<p>For MT, the key events are simple, they tell us how many fingers are
tapping.</p>

<p>So for example, slot 0 gets assigned tracking id 1 when the first finger
is down, then slot 1 gets assigned tracking id 2 when the second finger
is down, then the first finger is lifted and put back down again, and
slot 0 gets assigned tracking id 3.</p>

<div><div><pre><code>ABS_MT_SLOT 0
ABS_MT_TRACKING_ID 45
ABS_MT_POSITION_X x[0]
ABS_MT_POSITION_Y y[0]
ABS_MT_SLOT 1
ABS_MT_TRACKING_ID 46
ABS_MT_POSITION_X x[1]
ABS_MT_POSITION_Y y[1]
SYN_REPORT
// slot 0 moves in x position
ABS_MT_SLOT 0
ABS_MT_POSITION_X x[0]
SYN_REPORT
// lifting slot 0
ABS_MT_TRACKING_ID -1
SYN_REPORT
// lifting slot 1
ABS_MT_SLOT 1
ABS_MT_TRACKING_ID -1
SYN_REPORT
</code></pre></div></div>

<h2 id="synaptics">Synaptics</h2>

<p>Once upon a time everyone was bragging about their synaptics touchpad
confs, yet this is now deprecated in favor of libinput. What was that
all about?</p>

<p>Synaptics, unrelated to synaptics inc, was a complex X11 driver with
so many configurations. It was buggy and had lots of internal magic,
especially its acceleration profiles, which had logic split between the
X11 server and the driver.</p>

<div><div><pre><code> $ synclient -l
 Parameter settings:
 LeftEdge                = 1310
 RightEdge               = 4826
 TopEdge                 = 2220
 BottomEdge              = 4636
 FingerLow               = 25
 FingerHigh              = 30
 MaxTapTime              = 180
 ...
</code></pre></div></div>

<p>Synaptics was configured through the command line <code>synclient</code>. They
talked through a special interfaced with a custom protocol (shared memory
segment). That is before X11 had any standard way to dynamically be
configured (with <code>xinput</code>), and before evdev was a thing. This was hacky.</p>

<p>These days X11 and Wayland rely on libinput so this should be used
instead.</p>

<p>The only feature missing from libinput, which is implemented in user-space
by the widget libraries and DE, is non-linear acceleration and speed,
kinetic scrolling. That’s mostly a non-issue.</p>

<h2 id="acceleration-profile">Acceleration Profile</h2>

<p>Simply said, pointer acceleration is the function that multiplies the
movement deltas with a given factor:</p>

<div><div><pre><code>accel(x,y) = (Fx, Fy)
</code></pre></div></div>

<p>One of the main role of libinput is to make pointer movement as precise
as possible on all devices. If the user intends and performs action,
the feedback should be that it’s what they expected to do.</p>

<p>An acceleration profile defines a series of points of the form <code>(x, f(x))</code>,
input to output speed, that are linearly interpolated (a curve is drawn
between them for deduction). For example, flat acceleration is 
<code>[(0.0, 0.0), (1.0, 1.0)]</code>.</p>

<p>The default acceleration, adaptive, is pretty smart, and differs per
device type and resolution, it already has these configured for touchpads
for example:</p>

<ul>
  <li>super-slow: deceleration</li>
  <li>slow: deceleration</li>
  <li>medium: adaptive+deceleration</li>
  <li>fast: adaptive+fast</li>
  <li>flick: fast</li>
</ul>

<p>In general, libinput allows to configure this behavior. We can pick
between 3 pointer acceleration profiles: adaptive (default), flat the
45° one we’ve seen, and custom profiles. Along with different types
of motions the profiles can apply to: motion, scroll, fallback. We can
configure points and steps for each one: the points are the x and y
creating the curve of the acceleration profile we talked about, and the
steps is how the interpolation granularity happens between the points
(a value of 0 will use the default).</p>

<p>In <code>libinput list-devices</code> for a touchpad:</p>

<div><div><pre><code>Accel profiles:          flat *adaptive custom
</code></pre></div></div>

<h2 id="gestures">Gestures</h2>

<p>We’ve seen that libinput offers two types of gestures out-of-the-box:
swiping and pinching. For anything else, one has to rely on third party
libraries. Here are a few:</p>

<ul>
  <li><a href="https://github.com/iberianpig/fusuma">fusuma</a></li>
  <li><a href="https://github.com/bulletmark/libinput-gestures">libinput-gestures</a></li>
  <li><a href="https://github.com/Coffee2CodeNL/gebaar-libinput">gebaar-libinput</a></li>
</ul>

<p>YMMV while using them.</p>

<h2 id="gaming-libwacom-and-others">Gaming, libwacom, and Others</h2>

<p>Let’s close this section with a few random details that don’t need
much discussion.</p>

<p>High-end gaming mice are finicky and often normal basic drivers are not
enough to configure their high precision, nor is libinput. That’s why the
<a href="https://libratbag.github.io/">libratbag</a> project exists.</p>

<p>The libwacom (not only wacom) and tools such as Tuhi are used to manage
information needed by libinput to handle drawing tablets. These tablets
come with a tool such as a pen/stylus, it’s specificities are handled too.
For example, pressing certain button to reverse the behavior and start
erasing. There are X11 tools such as <code>xsetwacom</code> that also help.</p>

<p>An interesting software is <code>gpm(8)</code> which is a mouse in
the console that relies on reading directly the mouse stream
character device and interfacing/translating them to <code>TIOCLINUX</code>
<code>TIOCL_SELMOUSEREPORT</code>, terminal ioctl, to draw it. The terminal
will then output specific mouse reporting escape codes (more info
<a href="https://man.archlinux.org/man/console_codes.4.en#Mouse_tracking">here</a>).</p>

<p>Finally, here’s a few pointer specific debug tools:</p>

<ul>
  <li><a href="https://github.com/canadaduane/cleartouch">cleartouch</a></li>
  <li><a href="https://github.com/whot/mtview">mtview</a></li>
  <li><a href="https://github.com/bentiss/mtdiag-qt">mtdiag-qt</a></li>
  <li>The <code>libinput debug-gui</code> and <code>libinput debug-tablet</code></li>
</ul>



<p>Gamepads aren’t handled by libinput in user-space, nor do they rely on
the evdev handler in the kernel. Instead they rely on the joydev handler.</p>

<p>The gamepads get associated to their specific drivers, which
will consume all these events. The joydev handler then normalizes
and sends them to user-space in a format called <code>js_event</code> from
<code>include/uapi/linux/joystick.h</code>.</p>

<p>The handler character device supports a bunch of standard ioctl calls
to get/set info:</p>

<ul>
  <li><code>JSIOCGVERSION</code>: get driver version</li>
  <li><code>JSIOCGAXES</code>: get number of axes</li>
  <li><code>JSIOCGBUTTONS</code>: get number of buttons</li>
  <li><code>JSIOCGNAME(len)</code>: get identifier string</li>
  <li><code>JSIOCSCORR</code>: set correction values</li>
  <li><code>JSIOCGCORR</code>: get correction values</li>
  <li><code>JSIOCSAXMAP</code>: set axis mapping</li>
  <li><code>JSIOCGAXMAP</code>: get axis mapping</li>
  <li><code>JSIOCSBTNMAP</code>: set button mapping</li>
  <li><code>JSIOCGBTNMAP</code>: get button mapping</li>
</ul>

<p>Obviously, it’s better to do this via tools such as:</p>

<ul>
  <li><code>jstest</code> and <code>jstest-gtk</code></li>
  <li><code>jscal</code></li>
  <li><code>joyful</code></li>
</ul>



<p>We’ve reached the graphical environment with desktop widget libraries such
as GNOME and Qt, and the XServer and Wayland Compositors. They’re
the ones that rely on all types of input events for concrete behavior,
from clicking buttons on the appropriate window, drawing a cursor
on screen, scrolling, and literally all interactions a user has with
a computer.</p>

<p>The big difference between the X11 stack and Wayland stack is related to
the protocol and where these libraries are included. There are no window
managers in Wayland, but compositors that fully implement the standard
protocol of both a display server and window manager at the same time. So
it’s not a two-process equation, the compositor is the one handling
libinput and implementing the desktop interface. Meanwhile, in X11, the
Xserver, which is quite old, has the abstract concept of input drivers,
of which the currently only useful one is <code>xf86-input-libinput</code>. The
X11 input are interfaced with through the X11 protocol with XInput
events shared to the WM and other clients so that they can use them,
and configure the server’s input devices. Similarly, in X11 all the
configurations happen over the X protocol and its extensions, meanwhile
for compositors there’s no agreed way to configure things, so each
compositor can implement their own thing.</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/xorg-input-stack.png" alt="Xorg Input stack" title="Xorg Input stack"/></p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/libinput-input-stack.png" alt="libinput Wayland Compositor Input Stack" title="libinput Wayland Compositor Input Stack"/></p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/Libinput_for_Wayland_compositors.png" alt="libinput Wayland Compositor Input Stack 2" title="libinput Wayland Compositor Input Stack 2"/></p>

<p>Obviously, each have their own internal representation and ways of managing
the information they get from libinput, XKB, and others, but this is
outside the scope of this article (<code>wl_pointer</code> and <code>wl_keyboard</code> on
Wayland for example). Let’s focus more on how they configure the input
stack we’ve seen.</p>

<p>The X server has an internal store of information about input devices,
and their drivers, and will apply the default settings for each. To
apply specific configurations for certain devices, we can add snippets
in the X11 config directory, usually <code>/usr/share/X11/xorg.conf.d/</code>.
The <code>libinput(4)</code> driver settings can be passed there for a matching
device.</p>

<figure><pre><code data-lang="shell">Section <span>&#34;InputClass&#34;</span>
        Identifier <span>&#34;libinput touchpad catchall&#34;</span>
        MatchIsTouchpad <span>&#34;on&#34;</span>
        MatchDevicePath <span>&#34;/dev/input/event*&#34;</span>
        MatchProduct <span>&#34;substring of the device name&#34;</span>
        Driver <span>&#34;libinput&#34;</span>
        Option <span>&#34;some option name&#34;</span> <span>&#34;the option value&#34;</span>
EndSection</code></pre></figure>

<p>The “Identifier” is just a human-readable string for logging, meanwhile
the series of “Match” statements can be found in <code>xorg.conf(5)</code>, there’s
quite a few of them and they remind us of udev rules. The “Option”
part is what interests us, these are the settings to pass to libinput
and that can be found in <code>libinput(4)</code>. For example:</p>

<figure><pre><code data-lang="shell">Option <span>&#34;AccelSpeed&#34;</span> <span>&#34;float&#34;</span>
Option <span>&#34;ButtonMapping&#34;</span> <span>&#34;string&#34;</span>
Option <span>&#34;DisableWhileTyping&#34;</span> <span>&#34;bool&#34;</span>
Option <span>&#34;ClickMethod&#34;</span> <span>&#34;string&#34;</span>
Option <span>&#34;Tapping&#34;</span> <span>&#34;on&#34;</span></code></pre></figure>

<p>These should all be very familiar by now.</p>

<p>On the X11 stack, the server will initially set these values to override
the default ones, but afterward, during runtime, any caller can rely on
the X protocol to update them. The <code>xinput(1)</code> command can be used to
debug and test setting X input devices.</p>

<p>To list input devices that the X server is aware of:</p>

<div><div><pre><code>&gt; xinput list
⎡ Virtual core pointer                          id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
⎜   ↳ ETPS/2 Elantech Touchpad                  id=15   [slave  pointer  (2)]
⎜   ↳ SEMICO USB Keyboard Consumer Control      id=10   [slave  pointer  (2)]
⎣ Virtual core keyboard                         id=3    [master keyboard (2)]
    ↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]
    ↳ Power Button                              id=6    [slave  keyboard (3)]
    ↳ Video Bus                                 id=7    [slave  keyboard (3)]
    ↳ Power Button                              id=8    [slave  keyboard (3)]
    ↳ Sleep Button                              id=9    [slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard              id=14   [slave  keyboard (3)]
    ↳ Acer WMI hotkeys                          id=16   [slave  keyboard (3)]
    ↳ GeneralPlus USB Audio Device              id=17   [slave  keyboard (3)]
    ↳ SEMICO USB Keyboard Consumer Control      id=11   [slave  keyboard (3)]
    ↳ SEMICO USB Keyboard System Control        id=12   [slave  keyboard (3)]
    ↳ SEMICO USB Keyboard                       id=13   [slave  keyboard (3)]
</code></pre></div></div>

<p><em>NB</em>: Keep in mind the XTEST virtual devices, which only exist within
X11 internally and don’t appear in <code>libinput list-devices</code>, we’ll get
back to these in the next section.</p>

<p>Or list the properties of a particular device entry:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xinput list-props 14
Device <span>&#39;AT Translated Set 2 keyboard&#39;</span>:
        Device Enabled <span>(</span>147<span>)</span>:   1
        libinput Rotation Angle <span>(</span>263<span>)</span>:  0.000000
        libinput Rotation Angle Default <span>(</span>264<span>)</span>:  0.000000
        libinput Send Events Modes Available <span>(</span>265<span>)</span>:     1, 0
        libinput Send Events Mode Enabled <span>(</span>266<span>)</span>:        0, 0
        libinput Send Events Mode Enabled Default <span>(</span>267<span>)</span>:        0, 0
        Device Node <span>(</span>268<span>)</span>:      <span>&#34;/dev/input/event4&#34;</span>
        Device Product ID <span>(</span>269<span>)</span>:        1, 1</code></pre></figure>

<p>Or setting particular properties:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xinput set-prop <span>&#34;the device name&#34;</span> <span>&#34;the property name&#34;</span> value <span>[</span>value2]</code></pre></figure>

<p>For example:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xinput set-prop <span>&#39;ETPS/2 Elantech Touchpad&#39;</span> <span>&#34;libinput Tapping Enabled&#34;</span> <span>&#39;1&#39;</span>
<span>&gt;</span> xinput set-prop <span>&#39;ETPS/2 Elantech Touchpad&#39;</span> <span>&#34;libinput Accel Speed&#34;</span> <span>&#39;-0.1&#39;</span></code></pre></figure>

<p>What happens here is that the client (<code>xinput</code>) talks to the X server
over the X protocol, then the X server talks to its libinput driver
<code>xf86-input-libinput</code> which in turn talks to libinput and updates its
configurations, and the X server keeps track of all this.</p>

<p>These all look somewhat redundant, as you can see, it’s like having an
intermediate layer. That’s why on Wayland there’s no intermediary, if
a client tells it, through whatever configuration means it exposes, to
set certain settings on an input device, it does it directly via libinput.</p>

<p>For instance, if we’re toggling a setting in GNOME, KDE, MATE, or others,
the behavior will be more direct. In GNOME, things happen through
<code>gsettings</code>:</p>

<div><div><pre><code>&gt; gsettings list-keys  org.gnome.desktop.peripherals.
org.gnome.desktop.peripherals.keyboard
org.gnome.desktop.peripherals.mouse
org.gnome.desktop.peripherals.trackball
org.gnome.desktop.peripherals.pointingstick
org.gnome.desktop.peripherals.touchpad
…
&gt; gsettings list-keys  org.gnome.desktop.peripherals.mouse
accel-profile
double-click
drag-threshold
left-handed
middle-click-emulation
natural-scroll
speed
&gt; gsettings get org.gnome.desktop.peripherals.mouse accel-profile
&#39;default&#39;
</code></pre></div></div>

<p>So that’s how you’d configure input devices on GNOME Wayland compositor
Mutter. Yet that’s annoying, isn’t there a common way to do this on
Wayland?</p>

<p>So, clients in graphical environments need to get input events to
them. On X11 these are called X events, and they can be spied on with the
<code>xev(1)</code> tool, which can help debug issues. It shows events sent to the
particular window chosen.</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> xev <span>-event</span> keyboard
KeyRelease event, serial 28, synthetic NO, window 0x2e00001,
    root 0x3fa, subw 0x0, <span>time </span>465318306, <span>(</span>81,81<span>)</span>, root:<span>(</span>893,376<span>)</span>,
    state 0x10, keycode 108 <span>(</span>keysym 0xff20, Multi_key<span>)</span>, same_screen YES,
    XLookupString gives 0 bytes: 
    XFilterEvent returns: False
…
KeyRelease event, serial 28, synthetic NO, window 0x2e00001,
    root 0x3fa, subw 0x0, <span>time </span>465318602, <span>(</span>81,81<span>)</span>, root:<span>(</span>893,376<span>)</span>,
    state 0x10, keycode 48 <span>(</span>keysym 0x27, apostrophe<span>)</span>, same_screen YES,
    XLookupString gives 1 bytes: <span>(</span>27<span>)</span> <span>&#34;&#39;&#34;</span>
    XFilterEvent returns: False
KeyPress event, serial 28, synthetic NO, window 0x2e00001,
    root 0x3fa, subw 0x0, <span>time </span>465318866, <span>(</span>81,81<span>)</span>, root:<span>(</span>893,376<span>)</span>,
    state 0x10, keycode 26 <span>(</span>keysym 0x65, e<span>)</span>, same_screen YES,
    XLookupString gives 1 bytes: <span>(</span>65<span>)</span> <span>&#34;e&#34;</span>
    XmbLookupString gives 1 bytes: <span>(</span>65<span>)</span> <span>&#34;e&#34;</span>
    XFilterEvent returns: True
KeyPress event, serial 28, synthetic NO, window 0x2e00001,
    root 0x3fa, subw 0x0, <span>time </span>465318866, <span>(</span>81,81<span>)</span>, root:<span>(</span>893,376<span>)</span>,
    state 0x10, keycode 0 <span>(</span>keysym 0xe9, eacute<span>)</span>, same_screen YES,
    XLookupString gives 0 bytes: 
    XmbLookupString gives 2 bytes: <span>(</span>c3 a9<span>)</span> <span>&#34;é&#34;</span>
    XFilterEvent returns: False</code></pre></figure>

<p>As you can observe here, The Xlib client does a lookup for keycode to
keysym translation by relying on functions such as <code>XLookupString</code> and
<code>XmbLookupString</code>. These particular functions use a keymap logic that
dates back to pre-XKB time, we’ll talk more about them in a bit. Yet,
internally now, the X server does rely on XKB in the backend, just like
for input device info, it keeps a keymap table internally, and it’s
shared over the X protocol with clients (they ask for it at connection,
or lazily when calling functions, and cache it) so that they perform
the translation with Xlib or XCB.</p>
<ul>
  <li><code>xcb_key_symbols_get_keycode</code></li>
  <li><code>xcb_key_symbols_get_keysym</code></li>
</ul>

<p>And in Xlib with functions such as:</p>

<ul>
  <li><code>XLookupString</code></li>
  <li><code>Xutf8LookupString</code></li>
  <li><code>XLookupKeysym</code></li>
  <li><code>XkbTranslateKeyCode</code></li>
  <li><code>XkbTranslateKeySym</code></li>
  <li><code>XStringToKeysym</code></li>
  <li><code>XKeysymToKeycode</code></li>
</ul>

<p>Meanwhile, with the newer XKB keymap it’s done via:</p>
<ul>
  <li><code>XkbTranslateKeyCode</code></li>
</ul>

<p>Or in XCB with the <code>xcb_xkb_*</code> functions (you have to do it manually).</p>

<p>In all cases, since XKB is the tech in the backend of the X server
that stores the keymap truth, it’s what needs to be configured. The XKB
configuration can be set statically, along with the usual input confs
we’ve seen earlier, with the Xkb options:</p>

<figure><pre><code data-lang="shell">Section <span>&#34;InputClass&#34;</span>
        Identifier <span>&#34;system-keyboard&#34;</span>
        MatchIsKeyboard <span>&#34;on&#34;</span>
        Option <span>&#34;XkbLayout&#34;</span> <span>&#34;us&#34;</span>
        Option <span>&#34;XkbModel&#34;</span> <span>&#34;pc104&#34;</span>
        Option <span>&#34;XkbVariant&#34;</span> <span>&#34;dvorak&#34;</span>
        Option <span>&#34;XkbOptions&#34;</span> <span>&#34;terminate:ctrl_alt_bksp&#34;</span>
EndSection</code></pre></figure>

<p>There are also two special options that get interpreted when certain
special keysym are generated, the <code>DontVTSwitch</code> which is there to disable
the <code>ctrl+alt+fn</code> sequence to switch virtual terminal, and the <code>DontZap</code>
which catches the <code>Terminate_Server</code> keysym of XKB and will kill the Xorg
server. Both are enabled by default and these options would turn them off.</p>

<p>To change the XKB options on a running X server on-the-fly, we need to
rely on two tools: <code>xkbcomp(1)</code> and <code>setxkbmap(1)</code>. The first one is
used to compile new KcCGST and upload it to the server as a full keymap
in XKM compiled format that the server understands, and the second one
to change the current value of the RMLVO.</p>

<div><div><pre><code>$ setxkbmap -model thinkpad60 -layout us,sk,de -variant altgr-intl,qwerty \
       -option -option grp:menu_toggle -option grp_led:caps -print
</code></pre></div></div>

<p>We can get the same info as with <code>xkbcli</code> too:</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> setxkbmap <span>-print</span> <span>-verbose</span> 10
Setting verbose level to 10
locale is C
Trying to load rules file ./rules/evdev...
Trying to load rules file /usr/share/X11/xkb/rules/evdev...
Success.
Applied rules from evdev:
rules:      evdev
model:      pc105
layout:     us
options:    compose:ralt
Trying to build keymap using the following components:
keycodes:   evdev+aliases<span>(</span>qwerty<span>)</span>
types:      <span>complete
</span>compat:     <span>complete
</span>symbols:    pc+us+inet<span>(</span>evdev<span>)</span>+compose<span>(</span>ralt<span>)</span>
geometry:   pc<span>(</span>pc105<span>)</span>
xkb_keymap <span>{</span>
        xkb_keycodes  <span>{</span> include <span>&#34;evdev+aliases(qwerty)&#34;</span> <span>}</span><span>;</span>
        xkb_types     <span>{</span> include <span>&#34;complete&#34;</span>      <span>}</span><span>;</span>
        xkb_compat    <span>{</span> include <span>&#34;complete&#34;</span>      <span>}</span><span>;</span>
        xkb_symbols   <span>{</span> include <span>&#34;pc+us+inet(evdev)+compose(ralt)&#34;</span>       <span>}</span><span>;</span>
        xkb_geometry  <span>{</span> include <span>&#34;pc(pc105)&#34;</span>     <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre></figure>

<p>Now let’s talk about that pre-XKB logic with functions such as
<code>XLookupKeysym(3)</code> we’ve seen in the <code>xev</code> trace earlier. It’s currently
basically a wrapper over XKB, but that can also bypass it entirely. It
relies on the old “X core keymap table” in the X server, a facade on
the authoritative keymap that is XKB backed. The client asks for it
via a request, cache it, and use it for the mapping of X11 keycode
to X11 keysym. It’s own X11 keycodes are implementation dependent,
but nowadays it’s mostly <code>evdev + 8</code>, and its keysyms are found in
<code>/usr/include/X11/keysymdef.h</code>, which the newer XKB stack also relies
on in X11. So that old keymap is indeed initially filled with the XKB
keymap. The tool <code>xmodmap(1)</code> will help us explore and show some of the
things it handles.</p>

<p>To print its internal keymap table:</p>

<div><div><pre><code>&gt; xmodmap -pk
There are 7 KeySyms per KeyCode; KeyCodes range from 8 to 255.

    KeyCode Keysym (Keysym)   ...
    Value   Value   (Name)    ...

      8
      9     0xff1b (Escape)   0x0000 (NoSymbol) 0xff1b (Escape)
     10     0x0031 (1)  0x0021 (exclam)   0x0031 (1)  0x0021 (exclam)
     11     0x0032 (2)  0x0040 (at) 0x0032 (2)  0x0040 (at)
     12     0x0033 (3)  0x0023 (numbersign)  0x0033 (3)  0x0023 (numbersign)
     13     0x0034 (4)  0x0024 (dollar)   0x0034 (4)  0x0024 (dollar)
     14     0x0035 (5)  0x0025 (percent)  0x0035 (5)  0x0025 (percent)
     15     0x0036 (6)  0x005e (asciicircum) 0x0036 (6)  0x005e (asciicircum)
     16     0x0037 (7)  0x0026 (ampersand)   0x0037 (7)  0x0026 (ampersand)
     17     0x0038 (8)  0x002a (asterisk) 0x0038 (8)  0x002a (asterisk)
</code></pre></div></div>

<p>And print the modifiers:</p>

<div><div><pre><code>&gt; xmodmap -pm
xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

shift       Shift_L (0x32),  Shift_R (0x3e)
lock        Caps_Lock (0x42)
control     Control_L (0x25),  Control_R (0x69)
mod1        Alt_L (0x40),  Alt_L (0xcc),  Meta_L (0xcd)
mod2        Num_Lock (0x4d)
mod3        ISO_Level5_Shift (0xcb)
mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce)
mod5        ISO_Level3_Shift (0x5c)
</code></pre></div></div>

<p>Or print the keymap as “expressions”:</p>

<figure><pre><code data-lang="shell">keycode   8 <span>=</span>
keycode   9 <span>=</span> Escape NoSymbol Escape
keycode  10 <span>=</span> 1 exclam 1 exclam
keycode  11 <span>=</span> 2 at 2 at
keycode  12 <span>=</span> 3 numbersign 3 numbersign
keycode  13 <span>=</span> 4 dollar 4 dollar
keycode  14 <span>=</span> 5 percent 5 percent
keycode  15 <span>=</span> 6 asciicircum 6 asciicircum
keycode  16 <span>=</span> 7 ampersand 7 ampersand
keycode  17 <span>=</span> 8 asterisk 8 asterisk</code></pre></figure>

<p>Yes, <code>xmodmap</code> has its own configuration in <code>~/.Xmodmap</code> and expression
grammar that looks something like a simplified version of XKB:</p>

<div><div><pre><code>! remove Caps Lock functionality
remove Lock = Caps_Lock

! make CapsLock (keycode 66) act as Tab
keycode 66 = Tab

! set Menu key (keycode 134) properly
keycode 134 = Menu

! Set Right Alt as Compose (Multi_key)
! Use keysym form so you don&#39;t need to know the numeric keycode:
keycode 108 = Multi_key

! ensure Right Alt is not still treated as an Alt modifier
remove Mod1 = Alt_R
</code></pre></div></div>

<p>Or on-the-fly with:</p>

<figure><pre><code data-lang="shell">xmodmap <span>-e</span> <span>&#34;remove Lock = Caps_Lock&#34;</span>
xmodmap <span>-e</span> <span>&#34;keycode 66 = Tab&#34;</span>
xmodmap <span>-e</span> <span>&#34;keycode 134 = Menu&#34;</span></code></pre></figure>

<p>There’s even the <code>xkeycaps</code> GUI around it, and wrappers like
<a href="https://github.com/alols/xcape"><code>xcape</code></a>.</p>

<p>Yet, GNOME and certain other toolkits and desktop environments
have stopped relying on the old core keymap a long time ago,
deprecating it in favor of the XKB related functions. Still, the
X server will internally reflect these changes in its XKB cache,
making them internally compatible, notifying X clients of teh
change, and it’ll work but temporarily
(mainly with <code>XChangeKeyboardMapping</code> which calls
<a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/xkb/xkbUtils.c#L549"><code>XkbApplyMappingChange</code></a>
in the X Server). It’s fragile and legacy. Also, changing the keymap with
<code>xmodmap</code> is flimsy since any time the XKB keymap is reloading the changes
to the old in-memory X keymap compatibility is lost. Those combined
together means that it isn’t reliable to use the old X11 core keymap.</p>

<p>As you can see yet again, this is quite confusing and redundant, and
obviously Wayland doesn’t have these old layers of indirection and
relies on XKB directly. It also doesn’t need a compiled forms like XKM
to upload keymaps to the server, but it doesn’t even include that upload
part in the protocol anyhow. The keycode to keysym translation is also
done in the client (with calls such as <code>xkb_state_key_get_one_sym</code>)
but the keymap is directly shared along the <code>wl_keyboard</code> object that
it gets accessed to when it wants input access on the seat, so there’s
no need for another round-trip.</p>

<p>Yet, again the configuration of XKB-related stuff on Wayland depends on
the compositor implementation.</p>

<p>For example
<a href="https://github.com/swaywm/wlroots/blob/4984ea49eeaa292d66be9e535d93a4d8185f3e18/examples/simple.c#L113">wlroots</a>
relies on environment variables to set the RMLVO.</p>
<div><div><pre><code>gsettings set org.gnome.desktop.input-sources sources &#34;[(&#39;xkb&#39;, &#39;us&#39;), (&#39;xkb&#39;, &#39;fr&#39;)]&#34;
</code></pre></div></div>
<p>Hyprland has</p>
<div><div><pre><code>hyprctl keyword input:kb_layout &#34;us,fr&#34;
</code></pre></div></div>
<p>And etc…</p>

<figure><pre><code data-lang="shell"><span>&gt;</span> gsettings list-recursively org.gnome.desktop.input-sources
org.gnome.desktop.input-sources current uint32 0
org.gnome.desktop.input-sources mru-sources @a<span>(</span>ss<span>)</span> <span>[]</span>
org.gnome.desktop.input-sources per-window <span>false
</span>org.gnome.desktop.input-sources show-all-sources <span>false
</span>org.gnome.desktop.input-sources sources <span>[(</span><span>&#39;xkb&#39;</span>, <span>&#39;us&#39;</span><span>)]</span>
org.gnome.desktop.input-sources xkb-model <span>&#39;pc105+inet&#39;</span>
org.gnome.desktop.input-sources xkb-options <span>[</span><span>&#39;compose:ralt&#39;</span><span>]</span></code></pre></figure>

<p>Let’s go back to the
<a href="https://github.com/jwrdegoede/wev/blob/master/wev.c"><code>wev</code></a> tool,
which displays input events on Wayland, it’ll help us understand a
huge difference in input handling on Wayland compared to X11. Unlike X
severs, a Wayland compositor doesn’t propagate and broadcast the events
globally to anyone listening. Instead, clients must explicitly register
a listener for the objects they care about. These are announced via the
global Wayland registry, which it has to register to (<code>wl_registry</code>).</p>

<p>Beyond the core protocol, there are more “unstable”
or “non-standard” extensions that allow clients to do
more things related to input. Here’s a non-exhaustive
<a href="https://wayland.app/protocols/pointer-constraints-unstable-v1">list</a>:</p>

<ul>
  <li>Repositioning the pointer (<code>wp_pointer_warp_v1</code>)</li>
  <li>Subscribing to high-def keyboard timestamps (<code>zwp_input_timestamps_manager_v1</code>)</li>
  <li>Ignoring keyboard shortcuts from a client (<code>zwp_keyboard_shortcuts_inhibit_manager_v1</code>)</li>
  <li>Adding constraints to pointer motion (<code>zwp_pointer_constraints_v1</code>)</li>
  <li>Register to handle gestures, swipe, pinch, and hold (<code>zwp_pointer_gestures_v1</code>)</li>
  <li>Specific XWayland grabbing of input, monopolizing it (<code>zwp_xwayland_keyboard_grab_manager_v1</code>)</li>
  <li>Grab hotkeys, usually not needed since the compositor do this (<code>hyprland_global_shortcuts_manager_v1</code>)</li>
  <li>Grab/Inhibit an input to a single surface such as lock screen (<code>zwlr_input_inhibit_manager_v1</code>, <code>hyprland_focus_grab_manager_v1</code>)</li>
  <li>Create virtual pointer/keyboard, fake input (<code>zwlr_virtual_pointer_manager_v1</code>, <code>org_kde_kwin_fake_input</code>, <code>zwp_virtual_keyboard_v1</code>)</li>
</ul>

<p>Notice too that nowhere in the protocol is there any interface
to list the compositor’s internal input devices in its registry,
it’s intentionally abstracted away. It’s up to each compositor
to choose if it wants to expose this info. To my knowledge,
there’s only Sway that offers an interface for this through
<a href="https://man.archlinux.org/man/sway-input.5">swaymsg</a>, it’s kind of
similar to <code>gsettings</code>.</p>

<div><div><pre><code>&gt; swaymsg -t get_inputs
</code></pre></div></div>

<p>The closest compositor-agnostic tools are external utilities such
as <code>libinput list-devices</code> or <code>loginctl seat-status</code>. However, these
enumerate kernel devices, not the compositor’s internal virtual devices,
so you will not see compositor-created synthetic devices there.</p>

<p>In short, which compositor implements which part of the “non-standard”
protocol varies a lot. GNOME uses almost none of the wlroots/WLR
extensions. KDE uses KDE-specific extensions. wlroots-based
compositors share WLR extensions. It’s a mix really, check
<a href="https://wayland.app/protocols/">this</a> for support and more info.</p>

<p>We mentioned before <code>localectl</code> too for setting keyboard keymap
setups that works across environments. Let’s add that when using
the <code>set-x11-keymap</code> option it will modify X11 configurations in
<code>/etc/X11/xorg.conf.d/00-keyboard.conf</code> and pre-fill them for you so
you won’t have to worry about editing anything with the options we’ve
listed. It doesn’t have this option for Wayland though.</p>

<div><div><pre><code>&gt; localectl [--no-convert] set-x11-keymap layout [model [variant [options]]]
</code></pre></div></div>

<p>Yet, what if someone on Wayland wants to remap just a specific
key without passing by the static XKB and its mess, just a
quick runtime change. There’s no real solution to that other
than what we’ve already mentioned in the scancode to keycode
section, namely tools that rely on evdev interception to remap events
such as <code>evmapd</code>, <code>evremap</code>, <code>evdevremapkeys</code>, <code>evsieve</code>,
<a href="https://github.com/rvaiya/keyd"><code>keyd</code></a> , <code>kbct</code>, <code>makima</code>,
<a href="https://github.com/sezanzeb/input-remapper/"><code>input-remapper</code></a>,
etc.. A true panoply of tools that are hacks. Most, if not all, of
these  work by intercepting evdev events, creating a new virtual device
(we’ll see how <code>uinput</code> works in the next section), and modifying the
events on-the-fly to write them to the virtual device. This adds a new
unnecessary layer of indirection, which you should obviously avoid if
you are doing anything speed sensitive with the keyboard. Furthermore,
some of these re-include the key composition and a semblance of XKB
logic within them, which creates a total mess.</p>

<p>Contrary to everything else in the GUI stack, XKB composition is a
bit less cumbersome. Both Wayland clients, through their toolkits
(GTK, Qt, etc..) and X11, through Xlib with the functions we’ve seen
earlier that do it out-of-the-box (<code>XLookupString</code>), rely on the
same configuration files we’ve discussed in the XKB section. Namely,
<code>/usr/share/X11/locale/&lt;locale&gt;/Compose</code> and the home <code>~/.XCompose</code>. It
follows the simple format described in <code>Compose(5)</code>.</p>

<p>And lastly, one thing that isn’t handled neither in libinput nor XKB is
key repeat: how long when pressing a key will the client wait to print
it again.</p>

<p>In X11 this is configured in the X Server, either as a startup option
<code>-ardelay</code> and <code>-arinterval</code>, or dynamically via <code>xset(1)</code>. There’s the
option to set the delay and interval for a specific key too.</p>

<div><div><pre><code>&gt; xset r rate delay [rate]
&gt; xset r rate 210 50
</code></pre></div></div>

<p>If you inspect <code>xev</code> you’ll see that the server resends keys to the
client continuously.</p>

<p>Meanwhile, as with everything else on Wayland, it depends on the
compositor. The compositor sends to the clients the repeat parameters
<code>wl_keyboard.repeat_info(rate, delay)</code> and it’s up to them to respect
it. So, the compositor doesn’t keep forwarding the key to the client but
instead this is handled directly in the client.</p>

<p>The repeat key rate and delay being delegated to
clients on Wayland has had its share of issues it created though
(<a href="https://www.csslayer.info/wordpress/linux/key-repetition-and-key-event-handling-issue-with-wayland-input-method-protocols/">see</a>)
and some people want to have it <a href="https://gitlab.freedesktop.org/wayland/wayland/-/merge_requests/368">back in the
compositor</a>.</p>

<p>That’s it, we’ve covered most of the things we wanted in the upper
graphical stack.</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/de_upper_stack.png" alt="DE/Upper Stack Overview" title="DE/Upper Stack Overview"/></p>



<p>We’ve grazed the topic of virtual inputs before, in this section we’ll
see what types exist and where they’re used, from automation, emulation,
and remote desktop.</p>

<p>The first layer where we can create virtual input devices is at the
kernel layer. It provides two modules that can be used for this:
<code>UHID</code>, User-space I/O driver support for HID subsystem, and uinput,
the User-space input emulation module.</p>

<p>The <a href="https://docs.kernel.org/5.10/hid/uhid.html">uhid module</a>,
as the name implies, allows simulating HID events from user-space
by reading/writing to a special character device in devtmpfs
<code>/dev/uhid</code>. The interface is quite simple as is shown in <a href="https://github.com/torvalds/linux/blob/master/samples/uhid/uhid-example.c">this
example</a>.
However, this is only used for emulating devices and debugging, not for
the average user’s virtual input. This is the underlying mechanism behind
<code>hid-record</code> and <code>hid-replay</code>, which can easily allow debugging hid
issues by reproducing the exact sequences of events on anyone’s machine.</p>

<p>While uhid acts in the HID layer, the uinput module
(<code>drivers/input/misc/uinput.c</code>) acts at the input core layer, which
makes it more approachable for basic input event virtualisation.</p>

<p>There are two main ways to use uinput in the code, via <code>&lt;linux/uinput.h&gt;</code>
or via <code>&lt;libevdev/libevdev-uinput.h&gt;</code>. The libevdev mechanism is simpler
and recommended.</p>

<p>Example 1:</p>

<figure><pre><code data-lang="c"><span>#include</span> <span>&lt;unistd.h&gt;</span><span>
#include</span> <span>&lt;linux/uinput.h&gt;</span><span>
#include</span> <span>&lt;fcntl.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;errno.h&gt;</span><span>
#include</span> <span>&lt;linux/uinput.h&gt;</span><span>
</span>
<span>void</span> <span>emit</span><span>(</span><span>int</span> <span>fd</span><span>,</span> <span>int</span> <span>type</span><span>,</span> <span>int</span> <span>code</span><span>,</span> <span>int</span> <span>val</span><span>)</span>
<span>{</span>
   <span>struct</span> <span>input_event</span> <span>ie</span><span>;</span>

   <span>ie</span><span>.</span><span>type</span> <span>=</span> <span>type</span><span>;</span>
   <span>ie</span><span>.</span><span>code</span> <span>=</span> <span>code</span><span>;</span>
   <span>ie</span><span>.</span><span>value</span> <span>=</span> <span>val</span><span>;</span>
   <span>/* timestamp values below are ignored */</span>
   <span>ie</span><span>.</span><span>time</span><span>.</span><span>tv_sec</span> <span>=</span> <span>0</span><span>;</span>
   <span>ie</span><span>.</span><span>time</span><span>.</span><span>tv_usec</span> <span>=</span> <span>0</span><span>;</span>

   <span>write</span><span>(</span><span>fd</span><span>,</span> <span>&amp;</span><span>ie</span><span>,</span> <span>sizeof</span><span>(</span><span>ie</span><span>));</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
   <span>struct</span> <span>uinput_setup</span> <span>usetup</span><span>;</span>

   <span>int</span> <span>fd</span> <span>=</span> <span>open</span><span>(</span><span>&#34;/dev/uinput&#34;</span><span>,</span> <span>O_WRONLY</span> <span>|</span> <span>O_NONBLOCK</span><span>);</span>


   <span>/*
    * The ioctls below will enable the device that is about to be
    * created, to pass key events, in this case the space key.
    */</span>
   <span>ioctl</span><span>(</span><span>fd</span><span>,</span> <span>UI_SET_EVBIT</span><span>,</span> <span>EV_KEY</span><span>);</span>
   <span>ioctl</span><span>(</span><span>fd</span><span>,</span> <span>UI_SET_KEYBIT</span><span>,</span> <span>KEY_SPACE</span><span>);</span>

   <span>memset</span><span>(</span><span>&amp;</span><span>usetup</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>usetup</span><span>));</span>
   <span>usetup</span><span>.</span><span>id</span><span>.</span><span>bustype</span> <span>=</span> <span>BUS_USB</span><span>;</span>
   <span>usetup</span><span>.</span><span>id</span><span>.</span><span>vendor</span> <span>=</span> <span>0x1234</span><span>;</span> <span>/* sample vendor */</span>
   <span>usetup</span><span>.</span><span>id</span><span>.</span><span>product</span> <span>=</span> <span>0x5678</span><span>;</span> <span>/* sample product */</span>
   <span>strcpy</span><span>(</span><span>usetup</span><span>.</span><span>name</span><span>,</span> <span>&#34;Example device&#34;</span><span>);</span>

   <span>ioctl</span><span>(</span><span>fd</span><span>,</span> <span>UI_DEV_SETUP</span><span>,</span> <span>&amp;</span><span>usetup</span><span>);</span>
   <span>ioctl</span><span>(</span><span>fd</span><span>,</span> <span>UI_DEV_CREATE</span><span>);</span>

   <span>/*
    * On UI_DEV_CREATE the kernel will create the device node for this
    * device. We are inserting a pause here so that user-space has time
    * to detect, initialize the new device, and can start listening to
    * the event, otherwise it will not notice the event we are about
    * to send. This pause is only needed in our example code!
    */</span>
   <span>sleep</span><span>(</span><span>60</span><span>);</span>

   <span>/* Key press, report the event, send key release, and report again */</span>
   <span>emit</span><span>(</span><span>fd</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>KEY_SPACE</span><span>,</span> <span>1</span><span>);</span>
   <span>emit</span><span>(</span><span>fd</span><span>,</span> <span>EV_SYN</span><span>,</span> <span>SYN_REPORT</span><span>,</span> <span>0</span><span>);</span>
   <span>emit</span><span>(</span><span>fd</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>KEY_SPACE</span><span>,</span> <span>0</span><span>);</span>
   <span>emit</span><span>(</span><span>fd</span><span>,</span> <span>EV_SYN</span><span>,</span> <span>SYN_REPORT</span><span>,</span> <span>0</span><span>);</span>

   <span>/*
    * Give user-space some time to read the events before we destroy the
    * device with UI_DEV_DESTROY.
    */</span>
   <span>sleep</span><span>(</span><span>100</span><span>);</span>

   <span>ioctl</span><span>(</span><span>fd</span><span>,</span> <span>UI_DEV_DESTROY</span><span>);</span>
   <span>close</span><span>(</span><span>fd</span><span>);</span>

   <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

<p>Compile with</p>

<div><div><pre><code>gcc -o uinput_test uinput_test.c -Wall -Wextra
</code></pre></div></div>

<p>And example 2 with libevdev:</p>

<figure><pre><code data-lang="c"><span>#include</span> <span>&lt;libevdev/libevdev.h&gt;</span><span>
#include</span> <span>&lt;libevdev/libevdev-uinput.h&gt;</span><span>
#include</span> <span>&lt;unistd.h&gt;</span><span>
#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
#include</span> <span>&lt;errno.h&gt;</span><span>
</span>
<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>libevdev</span> <span>*</span><span>dev</span> <span>=</span> <span>NULL</span><span>;</span>
    <span>struct</span> <span>libevdev_uinput</span> <span>*</span><span>uidev</span> <span>=</span> <span>NULL</span><span>;</span>
    <span>int</span> <span>err</span><span>;</span>

    <span>/* Allocate and configure the virtual device */</span>
    <span>dev</span> <span>=</span> <span>libevdev_new</span><span>();</span>
    <span>if</span> <span>(</span><span>!</span><span>dev</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Failed to allocate libevdev device</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>libevdev_set_name</span><span>(</span><span>dev</span><span>,</span> <span>&#34;Example device (libevdev uinput)&#34;</span><span>);</span>
    <span>libevdev_set_id_bustype</span><span>(</span><span>dev</span><span>,</span> <span>BUS_USB</span><span>);</span>
    <span>libevdev_set_id_vendor</span><span>(</span><span>dev</span><span>,</span> <span>0x1234</span><span>);</span>
    <span>libevdev_set_id_product</span><span>(</span><span>dev</span><span>,</span> <span>0x5678</span><span>);</span>

    <span>/* Enable only one key: KEY_SPACE */</span>
    <span>libevdev_enable_event_type</span><span>(</span><span>dev</span><span>,</span> <span>EV_KEY</span><span>);</span>
    <span>libevdev_enable_event_code</span><span>(</span><span>dev</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>KEY_SPACE</span><span>,</span> <span>NULL</span><span>);</span>

    <span>/* Create the uinput device */</span>
    <span>err</span> <span>=</span> <span>libevdev_uinput_create_from_device</span><span>(</span><span>dev</span><span>,</span> <span>LIBEVDEV_UINPUT_OPEN_MANAGED</span><span>,</span> <span>&amp;</span><span>uidev</span><span>);</span>
    <span>if</span> <span>(</span><span>err</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Failed to create uinput device: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>strerror</span><span>(</span><span>-</span><span>err</span><span>));</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>/* A pause to allow the system (udev etc.) to register the device */</span>
    <span>sleep</span><span>(</span><span>100</span><span>);</span>

    <span>/* Emit a space key press */</span>
    <span>libevdev_uinput_write_event</span><span>(</span><span>uidev</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>KEY_SPACE</span><span>,</span> <span>1</span><span>);</span>
    <span>libevdev_uinput_write_event</span><span>(</span><span>uidev</span><span>,</span> <span>EV_SYN</span><span>,</span> <span>SYN_REPORT</span><span>,</span> <span>0</span><span>);</span>

    <span>/* Emit the key release */</span>
    <span>libevdev_uinput_write_event</span><span>(</span><span>uidev</span><span>,</span> <span>EV_KEY</span><span>,</span> <span>KEY_SPACE</span><span>,</span> <span>0</span><span>);</span>
    <span>libevdev_uinput_write_event</span><span>(</span><span>uidev</span><span>,</span> <span>EV_SYN</span><span>,</span> <span>SYN_REPORT</span><span>,</span> <span>0</span><span>);</span>

    <span>/* Let user-space read the events before destruction (optional) */</span>
    <span>sleep</span><span>(</span><span>200</span><span>);</span>

    <span>libevdev_uinput_destroy</span><span>(</span><span>uidev</span><span>);</span>
    <span>libevdev_free</span><span>(</span><span>dev</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

<p>Compile with</p>

<div><div><pre><code>gcc $(pkg-config --cflags --libs libevdev) -o libevdev_example example.c
</code></pre></div></div>

<p>The disadvantage of uhid and uinput is that, since they interface with
the kernel, they require root privilege and relying on HID or evdev might
not be practical for the average day-to-day usage. For example, if we
want to output a symbol, let’s say ‘p’, we have to know its keycode, and
for that we need to know the keymapping, which in turn requires XKB or
others. Thus, we’re back to square one and re-creating the upper input
stack from scratch.</p>

<p>What if we could directly say “send this keycode or keysym, it’s from this
virtual device”, without even needing extra permission if we’re already in
a desktop environment. Well, that’s exactly what the X11 XTEST extension
does, and what some Wayland extensions and mechanisms achieve too.</p>

<p>Remember when we used xinput to list some devices and some virtual ones
were listed:</p>

<div><div><pre><code>&gt; xinput list
Virtual core pointer                          id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
…
Virtual core keyboard                         id=3    [master keyboard (2)]
    ↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]
…
</code></pre></div></div>

<p>These were created by the XTest extension which was written to support
automated testing of X server. These days this can be used for remote
desktop, task automation, password managers (autofill), and others. When
clients interface through this extension they directly inject keyboard
and mouse events into the X server, bypassing the whole input stack,
and these events are propagated afterward to the X clients.</p>

<figure><pre><code data-lang="c"><span>#include</span> <span>&lt;X11/Xlib.h&gt;</span><span>
#include</span> <span>&lt;X11/extensions/XTest.h&gt;</span><span>
#include</span> <span>&lt;X11/keysym.h&gt;</span><span>
</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>Display</span> <span>*</span><span>dpy</span> <span>=</span> <span>XOpenDisplay</span><span>(</span><span>NULL</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>dpy</span><span>)</span> <span>return</span> <span>1</span><span>;</span>

    <span>KeyCode</span> <span>kc</span> <span>=</span> <span>XKeysymToKeycode</span><span>(</span><span>dpy</span><span>,</span> <span>XStringToKeysym</span><span>(</span><span>&#34;a&#34;</span><span>));</span>
    <span>XTestFakeKeyEvent</span><span>(</span><span>dpy</span><span>,</span> <span>kc</span><span>,</span> <span>True</span><span>,</span>  <span>0</span><span>);</span>
    <span>XTestFakeKeyEvent</span><span>(</span><span>dpy</span><span>,</span> <span>kc</span><span>,</span> <span>False</span><span>,</span> <span>0</span><span>);</span>

    <span>XFlush</span><span>(</span><span>dpy</span><span>);</span>
    <span>XCloseDisplay</span><span>(</span><span>dpy</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

<p>Compile with:</p>

<div><div><pre><code>&gt; gcc xtest_min.c -o xtest_min -lX11 -lXtst
</code></pre></div></div>

<p>That’s clean and easy, now on Wayland the picture is a bit more complex
since the protocol doesn’t allow clients to randomly generate input
events. It was designed this way for security reasons.</p>

<p>As with anything Wayland, there are a few unstable extensions,
though deprecated now, such as <code>zwlr_virtual_pointer_v1</code> and
<code>zwp_virtual_keyboard_manager_v1</code>, mostly wlroots Wayland extensions.</p>

<p>An example of the <code>zwp_virtual_keyboard_manager_v1</code> extension would look
somewhat like this:</p>

<figure><pre><code data-lang="c"><span>#define _POSIX_C_SOURCE 200809L
#include</span> <span>&lt;wayland-client.h&gt;</span><span>
#include</span> <span>&#34;virtual-keyboard-unstable-v1-client-protocol.h&#34;</span><span>
</span>
<span>static</span> <span>struct</span> <span>zwp_virtual_keyboard_v1</span> <span>*</span><span>vk</span><span>;</span>

<span>static</span> <span>void</span> <span>global_add</span><span>(</span><span>void</span> <span>*</span><span>data</span><span>,</span> <span>struct</span> <span>wl_registry</span> <span>*</span><span>reg</span><span>,</span>
                       <span>uint32_t</span> <span>name</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>iface</span><span>,</span> <span>uint32_t</span> <span>ver</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>strcmp</span><span>(</span><span>iface</span><span>,</span> <span>zwp_virtual_keyboard_manager_v1_interface</span><span>.</span><span>name</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>auto</span> <span>*</span><span>mgr</span> <span>=</span> <span>wl_registry_bind</span><span>(</span><span>reg</span><span>,</span> <span>name</span><span>,</span>
            <span>&amp;</span><span>zwp_virtual_keyboard_manager_v1_interface</span><span>,</span> <span>1</span><span>);</span>
        <span>// NULL seat → compositor chooses default seat</span>
        <span>vk</span> <span>=</span> <span>zwp_virtual_keyboard_manager_v1_create_virtual_keyboard</span><span>(</span><span>mgr</span><span>,</span> <span>NULL</span><span>);</span>
    <span>}</span>
<span>}</span>

<span>static</span> <span>const</span> <span>struct</span> <span>wl_registry_listener</span> <span>reg_listener</span> <span>=</span> <span>{</span>
    <span>.</span><span>global</span> <span>=</span> <span>global_add</span><span>,</span>
    <span>.</span><span>global_remove</span> <span>=</span> <span>NULL</span>
<span>};</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>struct</span> <span>wl_display</span> <span>*</span><span>d</span> <span>=</span> <span>wl_display_connect</span><span>(</span><span>NULL</span><span>);</span>
    <span>struct</span> <span>wl_registry</span> <span>*</span><span>reg</span> <span>=</span> <span>wl_display_get_registry</span><span>(</span><span>d</span><span>);</span>
    <span>wl_registry_add_listener</span><span>(</span><span>reg</span><span>,</span> <span>&amp;</span><span>reg_listener</span><span>,</span> <span>NULL</span><span>);</span>

    <span>wl_display_roundtrip</span><span>(</span><span>d</span><span>);</span> <span>// wait until vk is ready</span>

    <span>uint32_t</span> <span>keycode</span> <span>=</span> <span>30</span><span>;</span>   <span>// Linux evdev (KEY_A)</span>
    <span>uint32_t</span> <span>state_pressed</span>  <span>=</span> <span>1</span><span>;</span>
    <span>uint32_t</span> <span>state_released</span> <span>=</span> <span>0</span><span>;</span>

    <span>zwp_virtual_keyboard_v1_key</span><span>(</span><span>vk</span><span>,</span> <span>0</span><span>,</span> <span>keycode</span><span>,</span> <span>state_pressed</span><span>);</span>
    <span>zwp_virtual_keyboard_v1_key</span><span>(</span><span>vk</span><span>,</span> <span>0</span><span>,</span> <span>keycode</span><span>,</span> <span>state_released</span><span>);</span>
    <span>wl_display_flush</span><span>(</span><span>d</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

<p>But for a better example check the source of
<a href="https://git.sr.ht/~brocellous/wlrctl/tree/master/item/keyboard.c#L171"><code>wlrctl</code></a>
that also relies on the <code>zwp_virtual_keyboard_manager_v1</code> extension.</p>

<p>Yet, these days, this isn’t the path that Wayland has taken, and none of
the compositors agree on these extensions, instead they rely on libei,
a library to consolidate Emulated Input. This is its architecture:</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/libei_arch.png" alt="libei architecture" title="libei architecture"/>
Courtesy from <a href="https://libinput.pages.freedesktop.org/libei/">https://libinput.pages.freedesktop.org/libei/</a></p>

<p>It has two pieces: a client side that creates virtual devices and
generates evdev events, and the server side called EIS that lives within
the compositor (but that isn’t limited to Wayland) and is responsible for
giving a file descriptor to the client to interface with, and dispatching
received events to where they need to go. The dispatching could be through
uinput devices, that’s an implementation detail, yet most compositors
just store it as an internal virtual device.</p>

<p>This allows compositor to be aware of who is currently emulating input,
which capabilities they require (keyboard, touch, pointer), and to
restrict and/or suspend devices at any time.</p>

<p>Optionally, the compositor may delegate the file descriptor mechanism to
a xdg-desktop-portal dbus service implemented by the desktop environment
so that it can check with polkit and others the allowed permissions
(<a href="https://flatpak.github.io/xdg-desktop-portal/docs/">see</a>). So it would
look like this:</p>

<div><div><pre><code>    +--------------------+
    | Wayland compositor |_
    +--------------------+  \
    | libinput | libeis  |   \_wayland______
    +----------+---------+                  \
        |     [eis-0.socket]                 \
 /dev/input/     /   \\       +-------+------------------+
                |      ======&gt;| libei | Wayland client A |
                |      after    +-------+------------------+
         initial|     handover   /
      connection|               / initial request
                |              /  dbus[org.freedesktop.portal.EmulatedInput]
                |              /  or dbus[org.freedesktop.portal.RemoteDesktop]
        +--------------------+
        | xdg-desktop-portal |
        +--------------------+
</code></pre></div></div>

<p>An example implementation of a client can be found
<a href="https://gitlab.freedesktop.org/libinput/libei/-/blob/main/tools/ei-demo-client.c">here</a>.
Or mixed with an XKB mess to translate from keysym to keycode, for the
pleasure of your eyes:</p>

<figure><pre><code data-lang="c"><span>#include</span> <span>&lt;ei.h&gt;</span><span>
#include</span> <span>&lt;xkbcommon/xkbcommon.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>// ----------------------------</span>
    <span>// 1. Create an XKB context</span>
    <span>// ----------------------------</span>
    <span>struct</span> <span>xkb_context</span> <span>*</span><span>ctx</span> <span>=</span> <span>xkb_context_new</span><span>(</span><span>XKB_CONTEXT_NO_FLAGS</span><span>);</span>

    <span>// load the default system keymap (XKB rules, model, layout, variant, options)</span>
    <span>struct</span> <span>xkb_keymap</span> <span>*</span><span>keymap</span> <span>=</span>
        <span>xkb_keymap_new_from_names</span><span>(</span><span>ctx</span><span>,</span> <span>NULL</span><span>,</span> <span>XKB_KEYMAP_COMPILE_NO_FLAGS</span><span>);</span>

    <span>if</span> <span>(</span><span>!</span><span>keymap</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;failed to load xkb keymap</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>


    <span>// ----------------------------</span>
    <span>// 2. Convert keysym → evdev code but only for group 1 and level 1</span>
    <span>// ----------------------------</span>
    <span>xkb_keysym_t</span> <span>sym</span> <span>=</span> <span>xkb_keysym_from_name</span><span>(</span><span>&#34;a&#34;</span><span>,</span> <span>XKB_KEYSYM_NO_FLAGS</span><span>);</span>

    <span>// if we know the key by name it would be much easier</span>
    <span>// xkb_keycode_t code = xkb_keymap_key_by_name(keymap, &#34;AD01&#34;); </span>

    <span>// But better: find the keycode for the keysym</span>
    <span>xkb_keycode_t</span> <span>key</span> <span>=</span> <span>0</span><span>;</span>

    <span>// Iterate keycodes until we find the one producing this keysym</span>
    <span>// That&#39;s because keycodes-&gt;keysym is many-to-one</span>
    <span>xkb_keycode_t</span> <span>min</span> <span>=</span> <span>xkb_keymap_min_keycode</span><span>(</span><span>keymap</span><span>);</span>
    <span>xkb_keycode_t</span> <span>max</span> <span>=</span> <span>xkb_keymap_max_keycode</span><span>(</span><span>keymap</span><span>);</span>

    <span>for</span> <span>(</span><span>xkb_keycode_t</span> <span>k</span> <span>=</span> <span>min</span><span>;</span> <span>k</span> <span>&lt;=</span> <span>max</span><span>;</span> <span>k</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>xkb_keymap_key_get_level</span><span>(</span><span>keymap</span><span>,</span> <span>k</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span> <span>&gt;=</span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span> <span>nsyms</span><span>;</span>
            <span>const</span> <span>xkb_keysym_t</span> <span>*</span><span>syms</span> <span>=</span> <span>xkb_keymap_key_get_syms_by_level</span><span>(</span><span>keymap</span><span>,</span> <span>k</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>nsyms</span><span>);</span>
            <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>nsyms</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>syms</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>sym</span><span>)</span> <span>{</span>
                    <span>key</span> <span>=</span> <span>k</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>!</span><span>key</span><span>)</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;could not map keysym</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>// IMPORTANT: xkbcommon keycodes are **+8** relative to evdev</span>
    <span>int</span> <span>evdev_code</span> <span>=</span> <span>key</span> <span>-</span> <span>8</span><span>;</span>

    <span>struct</span> <span>ei</span> <span>*</span><span>ei</span> <span>=</span> <span>ei_new</span><span>();</span>
    <span>// compositor socket, we&#39;d need to get it through portal in real scenario</span>
    <span>ei_connect</span><span>(</span><span>ei</span><span>,</span> <span>&#34;unix:path=/run/user/1000/ei_socket&#34;</span><span>);</span>

    <span>struct</span> <span>ei_client</span> <span>*</span><span>client</span> <span>=</span> <span>ei_get_client</span><span>(</span><span>ei</span><span>);</span>
    <span>ei_client_set_name</span><span>(</span><span>client</span><span>,</span> <span>&#34;xkb-sender&#34;</span><span>);</span>

    <span>struct</span> <span>ei_device</span> <span>*</span><span>dev</span> <span>=</span> <span>ei_device_new</span><span>(</span><span>client</span><span>,</span> <span>&#34;xkd-virt-keyboard0&#34;</span><span>);</span>
    <span>ei_device_add_capability</span><span>(</span><span>dev</span><span>,</span> <span>EI_DEVICE_CAP_KEYBOARD</span><span>);</span>

    <span>ei_device_start_emulating</span><span>(</span><span>dev</span><span>);</span>


    <span>// press and release</span>
    <span>ei_key</span><span>(</span><span>dev</span><span>,</span> <span>evdev_code</span><span>,</span> <span>true</span><span>);</span>
    <span>ei_key</span><span>(</span><span>dev</span><span>,</span> <span>evdev_code</span><span>,</span> <span>false</span><span>);</span>

    <span>ei_flush</span><span>(</span><span>ei</span><span>);</span>
    <span>ei_disconnect</span><span>(</span><span>ei</span><span>);</span>
    <span>ei_free</span><span>(</span><span>ei</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

<p>Then obviously the EIS side has to catch these events and handle
them. There’s also an example that creates uinput devices found
<a href="https://gitlab.freedesktop.org/libinput/libei/-/blob/main/tools/eis-demo-server.c">here</a>.</p>

<p>The main logic of an EIS is quite straight forward (from the official docs):</p>

<ul>
  <li>create a context with <code>eis_new()</code></li>
  <li>set up a backend with <code>eis_setup_backend_fd()</code> or <code>eis_setup_backend_socket()</code></li>
  <li>register the <code>eis_get_fd()</code> with its own event loop</li>
  <li>call <code>eis_dispatch()</code> whenever the fd triggers</li>
  <li>call <code>eis_get_event()</code> and process incoming events</li>
</ul>

<p>And whenever a new client connects:</p>

<ul>
  <li>accept new clients with <code>eis_client_connect()</code></li>
  <li>create one or more seats for the client with <code>eis_client_new_seat()</code></li>
  <li>wait for <code>EIS_EVENT_SEAT_BIND</code> and then</li>
  <li>create one or more devices with the bound capabilities, see <code>eis_seat_new_device()</code></li>
</ul>

<p>That’s kind of like network programming.</p>

<p>So far, most Wayland compositors implement this mechanism
along with portals. You can see the list of support
<a href="https://gitlab.freedesktop.org/libinput/libei/-/issues/1">here</a>, from
GNOME, KDE, XWayland, and more.</p>

<p>On that note, XWayland is both an X server, and a Wayland client. So it
understands XTest requests. Yet what happens when it receives them is
that internally it relies on libei client side to handle virtual device
events. That means xdotool can work on XWayland with libei context.</p>

<div><div><pre><code>    +--------------------+             +------------------+
    | Wayland compositor |---wayland---| Wayland client B |
    +--------------------+\            +------------------+
    | libinput | libeis  | \_wayland______
    +----------+---------+                \
        |          |           +-------+------------------+
 /dev/input/       +---brei----| libei |     XWayland     |
                               +-------+------------------+
                                                |
                                                | XTEST
                                                |
                                         +-----------+
                                         |  X client |
                                         +-----------+
</code></pre></div></div>

<p>This is summarized well
<a href="https://www.semicomplete.com/blog/xdotool-and-exploring-wayland-fragmentation/">here</a>,
I quote:</p>

<blockquote>
  <ul>
    <li>An X11 client sends a key event using XTEST (normal)</li>
    <li>XWayland receives it and initiates Remote Desktop XDG Portal session to … your own system (???)</li>
    <li>XDG Portal uses DBus in an odd way, with many method calls receiving responses via signals because DBus isn’t designed for long asynchronous methods.</li>
    <li>Once the Remote Desktop portal session is setup, Xwayland asks for a file descriptor to talk an libei server (emulated input server).</li>
    <li>After that, libei is used to send events, query the keyboard map, etc.</li>
    <li>You can ask libei for the keyboard mapping (keycodes to keysyms, etc), you get another file descriptor and process that with yet another library, libxkbcommon.</li>
  </ul>
</blockquote>

<p>The main issue is that if the libei client gets its file descriptor
via dbus portal, then every time it asks for it then the user will get
prompted to “Allow remote interaction?”. And most portal software don’t
have config or whitelist rule mechanisms to skip that (as far as I know),
which would make sense while keeping the same security level.</p>

<p>When it comes to remote desktop on Wayland, it’s quite similar, it
relies on the same libei mechanism. Yet, we need to add to the equation,
as far as input goes, a listener that captures input regardless of the
focused window.</p>

<p>The remote desktop is also achieved with libei and a dbus xdg-desktop-portal
either <code>org.freedesktop.portal.RemoteDesktop</code> or
<code>.InputCapture</code>, which will give back to the client
a special file descriptor for listening to the input stream.</p>

<p>Let’s note that in the case of Wayland it is the compositor that usually
provides VNC/RDP servers, for example KWin and GNOME Mutter (apart from
<code>wayvnc</code> for wlroots compositors).</p>

<p>Let’s now review a couple of tools used for automation.</p>

<p>We’ve already seen quite a lot of the ones that rely on evdev and uinput,
but now they will make more sense with our current context:</p>

<ul>
  <li><code>evemu</code> and <code>evtest</code></li>
  <li><code>libinput record</code> and <code>libinput replay</code></li>
  <li><a href="https://gitlab.freedesktop.org/whot/unplug"><code>unplug</code></a></li>
  <li><code>evsieve</code></li>
  <li><code>keyd</code> - creates a uinput device to remap keys</li>
  <li><code>evmux</code> and <code>inputattach</code> - multiplex multiple evdev devices into a
 single virtual stream</li>
</ul>

<p>The most popular tool that relies on XTEST (plus EWMH and others) is
<code>xdotool</code>.</p>

<p><em>NB</em>: the “toplevel-management” Wayland “unstable” extension somewhat
replaces some of the EWMH, but it’s not implemented by most compositor
for security reasons.</p>

<p>Similar tools to <code>xdotool</code> but that relies on uinput are <code>ydotool</code> and
<a href="https://git.sr.ht/~geb/dotool"><code>dotool</code></a>.</p>

<p>We’ve seen <code>wlrctl</code> that relies on the unstable wayland protocol for
wlroots-based compositors. There’s also <code>wtype</code> that also relies on the
unstable virtual keyboard protocol.</p>

<p>We can also possibly perform automation via very specific desktop
environment mechanisms. That means using something such as GNOME shell
extensions for example, which has a javascript API. KDE has that
concept and the utility <code>kdotool</code> relies on this.</p>

<p>As you’ve observed, the situation is a bit fragmented on Wayland when
it comes to automations, both in utilities and extensions.</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/emulation.png" alt="Emulation Overview" title="Emulation Overview"/></p>



<p>In this last section we’ll explore the concept of input method (IMF &amp;
IME), a mechanism to input keysym/characters that are not natively
available on the user’s input device. This is necessary for languages
that have more graphemes than there are keys on the keyboard.</p>

<p>There are two sides to the equation: the IMF, the input method framework,
and the IME, the input method engine which works within the framework. An
input method framework’s role is to pick the most appropriate way
to enter the text, shape it, and return it to the widget. The IME is
basically the place where input are interpreted in any way shape, form,
or logic, to produce the text that the IMF asked for.</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/input_method_overview.png" alt="Input Method Overview 1" title="Input Method Overview 1"/>
Courtesy from <a href="https://nerufic.com/en/posts/how-input-methods-work-in-linux/">https://nerufic.com/en/posts/how-input-methods-work-in-linux/</a></p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/input_method_arch.png" alt="Input Method Overview 2" title="Input Method Overview 2"/>
Courtesy from <a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/text-input/basic-architecture2.png">https://www.chromium.org/chromium-os/chromiumos-design-docs/text-input/basic-architecture2.png</a></p>

<p>The way the input method plugs into the whole input stack is at the window
client side, within the widget/toolkit library framework in the input
handling event loop. After the client performs the keycode to keysym
translation and composing, it calls the toolkit specifically configured
input method, which will reroute it to the IM pipeline. Within the
pipeline, the IMF implementation will talk over its protocol to have
the IME interpret the input, and return preedit and committed text. This
will in turn be pushed back to the toolkit to display.</p>

<p>Some of these input frameworks are swappable, either because they talk
over the same protocol, be it the old deprecated XIM protocol for legacy
purpose (X Input Method over X protocol extension), or because they
plug straight as a module into the widget framework, which is mostly that
case today.</p>

<p>There are a lot of IMFs and IMEs implementations, and interoperability,
<a href="https://wiki.archlinux.org/title/Input_method#List_of_available_input_method_editors">see this list</a>.
These days the two major IMFs are IBus (Intelligent Input Bus, GTK-based like GNOME), and Fcitx5
(Qt-based like KDE).</p>

<p>To swap between them, if they are compatible with the toolkit, one can
set certain environment variables related to their toolkit:</p>

<div><div><pre><code>GTK_IM_MODULE=ibus
QT_IM_MODULE=ibus
XMODIFIERS=@im=ibus
</code></pre></div></div>

<p>For example the path that the text will take with Ibus looks like this:</p>

<div><div><pre><code>Application → GTK/Qt IM module → D-Bus → IBus/Fcitx
               →    IME      → D-Bus → GTK/Qt widget
</code></pre></div></div>

<p>As you can see, this bypasses all graphic servers, be it the X servers
or Wayland compositors.</p>

<p>Yet for it to work across the Wayland ecosystem, and not only on some
widgets like GTK and Qt (games, electron apps, java apps, sandboxed apps,
etc..), the IMF/IME stack needs to be able to listen to key events from
any application, provided it is focused, get the surrounding context,
take field focus, and inject text into clients. This is why some
“unstable” extensions were created, mostly “text-input-unstable-v3”
(<code>zwp_text_input_v3</code>) and “input-method-v2” (<code>zwp_input_methd_v2</code>)
protocol. With this, there’ll be consistent IM behavior across all
applications without compromising security.</p>

<p>On a side note, this same extension protocol for injecting text can be
used for the speech-to-text accessibility framework. In practice this
can either be done via a virtual input device, or a specific desktop
service mechanism integrated in the toolkits. We have a desktop service
catching voice input, a standalone voice recognizer to convert it to
text, and a virtual keyboard or feature to inject events. For example,
GNOME VoiceInput, Plasma Whisper Integration, QtSpeech, SpeechDispatcher,
Caribou, Onboard, or GNOME Accessibility Services (AT-SPI). We won’t
go into details on that, nor mention text-to-speech, since it’s outside
our scope.</p>

<p>One issue remains though, and it’s related to the key repeat rate
and delay, which on Wayland is implemented client-side. It’s
not implemented by IMs, and tough to handle apparently (<a href="https://www.csslayer.info/wordpress/linux/key-repetition-and-key-event-handling-issue-with-wayland-input-method-protocols/">see</a>).</p>

<p>And that it!</p>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/IM.png" alt="IM Overview" title="IM Overview"/></p>



<p>Congratulations for making it this far into the article!</p>

<p>I have some hope that in the future there’s going to be a more common
way to configure the Wayland input stack across compositors and have
fewer discrepancies and fragmentation. I also wish the XKB stack would
one day get cleanup up, but on this one my hopes are pretty low. It’s
fallen victim to entropy and chaos.</p>

<p>A huge gigantic thanks to “who-t” aka Peter Hutterer, whose <a href="https://who-t.blogspot.com/">blog</a> has
been my trusty companion for the past months.</p>

<p>We need more articles like this in the age of AI overlords, so please
share it if you’ve enjoyed it!</p>

<p>Thanks for reading, have a wonderful end of day!</p>

<pre>



</pre>

<p><em>NB: This article compiles my understand, for any correction please
contact me.</em></p>

<pre>





</pre>



<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/input_topological_path.png" alt="Topology Overview" title="Topology Overview"/></p>

<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/hid_core.png" alt="HID Core Overview" title="HID Core Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/input_core.png" alt="Input Core Overview" title="Input Core Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/libinput.png" alt="libinput Overview" title="libinput Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/console.png" alt="Console Overview" title="Console Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/xkb.png" alt="XKB Overview" title="XKB Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/de_upper_stack.png" alt="DE/Upper Stack Overview" title="DE/Upper Stack Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/emulation.png" alt="Emulation Overview" title="Emulation Overview"/></p>
<pre>


</pre>

<p><img src="http://tinylogger.com/blog/assets/input_devices_linux/IM.png" alt="IM Overview" title="IM Overview"/></p>

<pre>





</pre>

<hr/>



<ul>
  <li>GENERIC, FULL STACK
    <ul>
      <li><a href="https://linuxtouchpad.org/docs/">https://linuxtouchpad.org/docs/</a></li>
      <li><a href="https://linuxtouchpad.org/resources/">https://linuxtouchpad.org/resources/</a></li>
      <li><a href="https://monroeclinton.com/pointing-devices-in-linux/">https://monroeclinton.com/pointing-devices-in-linux/</a></li>
      <li><a href="https://wiki.archlinux.org/title/Keyboard_input">https://wiki.archlinux.org/title/Keyboard_input</a></li>
      <li><a href="https://vkoskiv.com/first-linux-patch/">https://vkoskiv.com/first-linux-patch/</a></li>
      <li><a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/device_model.html">https://linux-kernel-labs.github.io/refs/heads/master/labs/device_model.html</a></li>
      <li><a href="https://apexpenn.github.io/2025/02/13/linux-input-subsystem/">https://apexpenn.github.io/2025/02/13/linux-input-subsystem/</a></li>
    </ul>
  </li>
  <li>HARDWARE INTERFACE
    <ul>
      <li><a href="https://wiki.osdev.org/PS/2_Mouse">https://wiki.osdev.org/PS/2_Mouse</a></li>
      <li><a href="https://isdaman.com/alsos/hardware/mouse/ps2interface.htm">https://isdaman.com/alsos/hardware/mouse/ps2interface.htm</a></li>
      <li><a href="https://www.eecg.utoronto.ca/~jayar/ece241_08F/AudioVideoCores/ps2/ps2.html">https://www.eecg.utoronto.ca/~jayar/ece241_08F/AudioVideoCores/ps2/ps2.html</a></li>
      <li><a href="https://www.cpcwiki.eu/index.php/Serial_RS232_Mouse">https://www.cpcwiki.eu/index.php/Serial_RS232_Mouse</a></li>
      <li><a href="https://eleccelerator.com/usbdescreqparser/">https://eleccelerator.com/usbdescreqparser/</a></li>
    </ul>
  </li>
  <li>KERNEL, MODULES, HID AND OTHERS
    <ul>
      <li><a href="https://who-t.blogspot.com/2018/12/understanding-hid-report-descriptors.html">https://who-t.blogspot.com/2018/12/understanding-hid-report-descriptors.html</a></li>
      <li><a href="https://who-t.blogspot.com/2021/01/parsing-hid-unit-items.html">https://who-t.blogspot.com/2021/01/parsing-hid-unit-items.html</a></li>
      <li><a href="http://bentiss.github.io/hid-replay-docs/">http://bentiss.github.io/hid-replay-docs/</a></li>
      <li><a href="https://gitlab.freedesktop.org/libevdev/hid-tools/">https://gitlab.freedesktop.org/libevdev/hid-tools/</a></li>
      <li><a href="https://docs.kernel.org/hid/hidintro.html">https://docs.kernel.org/hid/hidintro.html</a></li>
      <li><a href="https://docs.kernel.org/hid/hid-transport.html">https://docs.kernel.org/hid/hid-transport.html</a></li>
      <li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/hid/">https://learn.microsoft.com/en-us/windows-hardware/drivers/hid/</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/hid/hiddev.txt">https://www.kernel.org/doc/Documentation/hid/hiddev.txt</a></li>
      <li><a href="https://www.man7.org/linux//man-pages/man8/usbhid-dump.8.html">https://www.man7.org/linux//man-pages/man8/usbhid-dump.8.html</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/input.txt">https://www.kernel.org/doc/Documentation/input/input.txt</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/input-programming.txt">https://www.kernel.org/doc/Documentation/input/input-programming.txt</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/joystick.txt">https://www.kernel.org/doc/Documentation/input/joystick.txt</a></li>
      <li><a href="https://github.com/libratbag/piper/">https://github.com/libratbag/piper/</a></li>
      <li><a href="https://git.annabunches.net/anna/joyful">https://git.annabunches.net/anna/joyful</a></li>
      <li><a href="https://docs.kernel.org/input/">https://docs.kernel.org/input/</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/">https://www.kernel.org/doc/Documentation/input/</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/event-codes.rst">https://www.kernel.org/doc/Documentation/input/event-codes.rst</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/appletouch.txt">https://www.kernel.org/doc/Documentation/input/appletouch.txt</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/gamepad.rst">https://www.kernel.org/doc/Documentation/input/gamepad.rst</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.rst">https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.rst</a></li>
      <li><a href="https://github.com/torvalds/linux/blob/master/drivers/input/keyboard/atkbd.c">https://github.com/torvalds/linux/blob/master/drivers/input/keyboard/atkbd.c</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/laptops/thinkpad-acpi.txt">https://www.kernel.org/doc/Documentation/laptops/thinkpad-acpi.txt</a></li>
      <li><a href="https://www.kernel.org/doc/html/latest/driver-api/input.html">https://www.kernel.org/doc/html/latest/driver-api/input.html</a></li>
      <li><a href="https://www.kernelconfig.io/config_devtmpfs_safe">https://www.kernelconfig.io/config_devtmpfs_safe</a></li>
    </ul>
  </li>
  <li>SYSFS MAPPING
    <ul>
      <li><a href="https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf">https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man5/sysfs.5.html">https://www.man7.org/linux/man-pages/man5/sysfs.5.html</a></li>
      <li><a href="https://www.kernel.org/doc/html/latest/filesystems/sysfs.html">https://www.kernel.org/doc/html/latest/filesystems/sysfs.html</a></li>
    </ul>
  </li>
  <li>UDEV, MDEV, SMDEV, HWDB
    <ul>
      <li><a href="https://codelucky.com/devtmpfs-linux/">https://codelucky.com/devtmpfs-linux/</a></li>
      <li><a href="https://who-t.blogspot.com/2019/02/adding-entries-to-udev-hwdb.html">https://who-t.blogspot.com/2019/02/adding-entries-to-udev-hwdb.html</a></li>
      <li><a href="https://who-t.blogspot.com/2024/04/udev-hid-bpf-quickstart-tooling-to-fix.html">https://who-t.blogspot.com/2024/04/udev-hid-bpf-quickstart-tooling-to-fix.html</a></li>
      <li><a href="https://libevdev.pages.freedesktop.org/udev-hid-bpf/index.html">https://libevdev.pages.freedesktop.org/udev-hid-bpf/index.html</a></li>
      <li><a href="https://lwn.net/Articles/970702/">https://lwn.net/Articles/970702/</a></li>
      <li><a href="https://wiki.archlinux.org/title/Udev">https://wiki.archlinux.org/title/Udev</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man5/udev.conf.5.html">https://www.man7.org/linux/man-pages/man5/udev.conf.5.html</a></li>
      <li><a href="https://www.freedesktop.org/software/systemd/man/latest/systemd-udevd.service.html">https://www.freedesktop.org/software/systemd/man/latest/systemd-udevd.service.html</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man8/udevadm.8.html udevadm">https://www.man7.org/linux/man-pages/man8/udevadm.8.html udevadm</a></li>
      <li><a href="https://www.freedesktop.org/software/systemd/man/latest/udev.html#">https://www.freedesktop.org/software/systemd/man/latest/udev.html#</a></li>
      <li><a href="https://www.reactivated.net/writing_udev_rules.html">https://www.reactivated.net/writing_udev_rules.html</a></li>
      <li><a href="https://opensource.com/article/18/11/udev">https://opensource.com/article/18/11/udev</a></li>
      <li><a href="https://stackoverflow.com/questions/45987478/udev-rule-for-input-device">https://stackoverflow.com/questions/45987478/udev-rule-for-input-device</a></li>
      <li><a href="https://dataswamp.org/~solene/2025-05-31-linux-killswitch-on-power-disconnect.html">https://dataswamp.org/~solene/2025-05-31-linux-killswitch-on-power-disconnect.html</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Udev">https://en.wikipedia.org/wiki/Udev</a></li>
      <li><a href="https://www.linuxfromscratch.org/lfs/view/12.3/chapter09/udev.html">https://www.linuxfromscratch.org/lfs/view/12.3/chapter09/udev.html</a></li>
      <li><a href="https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html">https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html</a></li>
      <li><a href="https://wiki.gentoo.org/wiki/Mdev">https://wiki.gentoo.org/wiki/Mdev</a></li>
      <li><a href="https://wiki.gentoo.org/wiki/Udev">https://wiki.gentoo.org/wiki/Udev</a></li>
      <li><a href="https://git.suckless.org/smdev/file/README.html">https://git.suckless.org/smdev/file/README.html</a></li>
      <li><a href="https://www.man7.org/linux/man-pages/man7/hwdb.7.html">https://www.man7.org/linux/man-pages/man7/hwdb.7.html</a></li>
      <li><a href="https://github.com/systemd/systemd/blob/main/hwdb.d/60-evdev.hwdb">https://github.com/systemd/systemd/blob/main/hwdb.d/60-evdev.hwdb</a></li>
      <li><a href="http://www.linux-usb.org/ (deprecated)">http://www.linux-usb.org/ (deprecated)</a></li>
      <li><a href="https://web.archive.org/web/20160127215232/https://www.kernel.org/doc/pending/hotplug.txt">https://web.archive.org/web/20160127215232/https://www.kernel.org/doc/pending/hotplug.txt</a></li>
      <li><a href="https://elixir.bootlin.com/linux/v3.12.74/source/lib/kobject_uevent.c#L121">https://elixir.bootlin.com/linux/v3.12.74/source/lib/kobject_uevent.c#L121</a></li>
    </ul>
  </li>
  <li>EVDEV, LIBEVDEV, IOCTL
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Evdev#/media/File:Linux_API.svg">https://en.wikipedia.org/wiki/Evdev#/media/File:Linux_API.svg</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Evdev">https://en.wikipedia.org/wiki/Evdev</a></li>
      <li><a href="https://www.kernel.org/doc/Documentation/input/uinput.rst">https://www.kernel.org/doc/Documentation/input/uinput.rst</a></li>
      <li><a href="https://www.freedesktop.org/software/libevdev/doc/latest/ioctls.html">https://www.freedesktop.org/software/libevdev/doc/latest/ioctls.html</a></li>
      <li><a href="https://gitlab.freedesktop.org/libevdev/libevdev">https://gitlab.freedesktop.org/libevdev/libevdev</a></li>
      <li><a href="https://www.freedesktop.org/software/libevdev/doc/latest/">https://www.freedesktop.org/software/libevdev/doc/latest/</a></li>
      <li><a href="https://who-t.blogspot.com/2016/09/understanding-evdev.html">https://who-t.blogspot.com/2016/09/understanding-evdev.html</a></li>
      <li><a href="https://who-t.blogspot.com/2018/07/why-its-not-good-idea-to-handle-evdev.html">https://who-t.blogspot.com/2018/07/why-its-not-good-idea-to-handle-evdev.html</a></li>
      <li><a href="https://who-t.blogspot.com/2018/01/libevdev-python.html">https://who-t.blogspot.com/2018/01/libevdev-python.html</a></li>
      <li><a href="https://gist.github.com/TriceHelix/de47ed38dcb4f7216b26291c47445d99">https://gist.github.com/TriceHelix/de47ed38dcb4f7216b26291c47445d99</a></li>
      <li><a href="https://who-t.blogspot.com/2014/11/analysing-input-events-with-evemu.html">https://who-t.blogspot.com/2014/11/analysing-input-events-with-evemu.html</a></li>
    </ul>
  </li>
  <li>LIBINPUT
    <ul>
      <li><a href="https://blog.martin-graesslin.com/blog/2016/12/how-input-works-creating-a-device/">https://blog.martin-graesslin.com/blog/2016/12/how-input-works-creating-a-device/</a></li>
      <li><a href="https://blog.martin-graesslin.com/blog/2016/12/how-input-works-keyboard-input/">https://blog.martin-graesslin.com/blog/2016/12/how-input-works-keyboard-input/</a></li>
      <li><a href="https://blog.martin-graesslin.com/blog/2016/12/how-input-works-pointer-input/">https://blog.martin-graesslin.com/blog/2016/12/how-input-works-pointer-input/</a></li>
      <li><a href="https://blog.martin-graesslin.com/blog/2017/02/how-input-works-touch-input/">https://blog.martin-graesslin.com/blog/2017/02/how-input-works-touch-input/</a></li>
      <li><a href="https://www.michaelminn.com/linux/peripherals/">https://www.michaelminn.com/linux/peripherals/</a></li>
      <li><a href="https://linuxtouchpad.org/news/2021/12/03/best-of-libinput-on-lwn.html">https://linuxtouchpad.org/news/2021/12/03/best-of-libinput-on-lwn.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/07/libinput-is-done.html">https://who-t.blogspot.com/2016/07/libinput-is-done.html</a></li>
      <li><a href="https://who-t.blogspot.com/2014/09/libinput-common-input-stack-for-wayland.html">https://who-t.blogspot.com/2014/09/libinput-common-input-stack-for-wayland.html</a></li>
      <li><a href="https://who-t.blogspot.com/2019/03/libinputs-internal-building-blocks.html">https://who-t.blogspot.com/2019/03/libinputs-internal-building-blocks.html</a></li>
      <li><a href="https://wiki.archlinux.org/title/Libinput">https://wiki.archlinux.org/title/Libinput</a></li>
      <li><a href="https://who-t.blogspot.com/2017/01/how-libinput-opens-device-nodes.html">https://who-t.blogspot.com/2017/01/how-libinput-opens-device-nodes.html</a></li>
      <li><a href="https://who-t.blogspot.com/2025/06/libinput-and-tablet-tool-eraser-buttons.html">https://who-t.blogspot.com/2025/06/libinput-and-tablet-tool-eraser-buttons.html</a></li>
      <li><a href="https://who-t.blogspot.com/2025/05/libinput-and-lua-plugins.html">https://who-t.blogspot.com/2025/05/libinput-and-lua-plugins.html</a></li>
      <li><a href="https://wayland.freedesktop.org/libinput/doc/latest/lua-plugins.html">https://wayland.freedesktop.org/libinput/doc/latest/lua-plugins.html</a></li>
      <li><a href="https://wayland.freedesktop.org/libinput/doc/latest/">https://wayland.freedesktop.org/libinput/doc/latest/</a></li>
      <li><a href="https://wayland.freedesktop.org/libinput/doc/latest/configuration.html">https://wayland.freedesktop.org/libinput/doc/latest/configuration.html</a></li>
      <li><a href="https://www.x.org/wiki/Events/XDC2014/XDC2014HuttererLibInput/">https://www.x.org/wiki/Events/XDC2014/XDC2014HuttererLibInput/</a></li>
      <li><a href="https://who-t.blogspot.com/2015/02/libinput-device-groups.html">https://who-t.blogspot.com/2015/02/libinput-device-groups.html</a></li>
      <li><a href="https://who-t.blogspot.com/2019/10/libinputs-bus-factor-is-1.html">https://who-t.blogspot.com/2019/10/libinputs-bus-factor-is-1.html</a></li>
      <li><a href="https://who-t.blogspot.com/2017/02/libinput-knows-about-internal-and.html">https://who-t.blogspot.com/2017/02/libinput-knows-about-internal-and.html</a></li>
      <li><a href="https://who-t.blogspot.com/2017/02/libinput-and-lid-switch-events.html">https://who-t.blogspot.com/2017/02/libinput-and-lid-switch-events.html</a></li>
    </ul>
  </li>
  <li>LIBINPUT AND POINTER SPECFICIS
    <ul>
      <li><a href="https://bitmath.se/org/code/mtdev/">https://bitmath.se/org/code/mtdev/</a></li>
      <li><a href="https://who-t.blogspot.com/2015/07/a-short-overview-of-touchpad-devices.html">https://who-t.blogspot.com/2015/07/a-short-overview-of-touchpad-devices.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/12/libinput-touchpad-pointer-acceleration.html">https://who-t.blogspot.com/2016/12/libinput-touchpad-pointer-acceleration.html</a></li>
      <li><a href="https://who-t.blogspot.com/2018/06/x-server-pointer-acceleration-analysis.html">https://who-t.blogspot.com/2018/06/x-server-pointer-acceleration-analysis.html</a></li>
      <li><a href="https://who-t.blogspot.com/2014/09/pointer-acceleration-in-libinput.html">https://who-t.blogspot.com/2014/09/pointer-acceleration-in-libinput.html</a></li>
      <li><a href="https://who-t.blogspot.com/2017/07/libinput-and-pressure-based-palm.html">https://who-t.blogspot.com/2017/07/libinput-and-pressure-based-palm.html</a></li>
      <li><a href="https://who-t.blogspot.com/2019/07/libinputs-new-thumb-detection-code.html">https://who-t.blogspot.com/2019/07/libinputs-new-thumb-detection-code.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/09/synaptics-pointer-acceleration.html">https://who-t.blogspot.com/2016/09/synaptics-pointer-acceleration.html</a></li>
      <li><a href="https://who-t.blogspot.com/2017/01/the-definitive-guide-to-synclient.html">https://who-t.blogspot.com/2017/01/the-definitive-guide-to-synclient.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/07/why-synclient-does-not-work-anymore.html">https://who-t.blogspot.com/2016/07/why-synclient-does-not-work-anymore.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/12/xf86-input-synaptics-is-not-synaptics.html">https://who-t.blogspot.com/2016/12/xf86-input-synaptics-is-not-synaptics.html</a></li>
      <li><a href="https://www.x.org/releases/X11R7.6-RC1/doc/man/man4/synaptics.4.xhtml">https://www.x.org/releases/X11R7.6-RC1/doc/man/man4/synaptics.4.xhtml</a></li>
      <li><a href="https://cookie.engineer/weblog/articles/synaptics-touchpad-on-linux.html">https://cookie.engineer/weblog/articles/synaptics-touchpad-on-linux.html</a></li>
      <li><a href="https://who-t.blogspot.com/2017/10/what-is-libwacom.html">https://who-t.blogspot.com/2017/10/what-is-libwacom.html</a></li>
      <li><a href="https://github.com/tuhiproject/tuhi/">https://github.com/tuhiproject/tuhi/</a></li>
      <li><a href="https://who-t.blogspot.com/2020/02/a-tale-of-missing-touches.html">https://who-t.blogspot.com/2020/02/a-tale-of-missing-touches.html</a></li>
      <li><a href="https://who-t.blogspot.com/2021/07/libinput-and-hold-gestures.html">https://who-t.blogspot.com/2021/07/libinput-and-hold-gestures.html</a></li>
      <li><a href="https://who-t.blogspot.com/2021/08/libinput-and-high-resolution-wheel.html">https://who-t.blogspot.com/2021/08/libinput-and-high-resolution-wheel.html</a></li>
      <li><a href="https://who-t.blogspot.com/2023/01/libinput-and-custom-pointer.html">https://who-t.blogspot.com/2023/01/libinput-and-custom-pointer.html</a></li>
      <li><a href="https://who-t.blogspot.com/2024/03/enforcing-touchscreen-mapping-in-gnome.html">https://who-t.blogspot.com/2024/03/enforcing-touchscreen-mapping-in-gnome.html</a></li>
      <li><a href="https://github.com/iberianpig/fusuma">https://github.com/iberianpig/fusuma</a></li>
      <li><a href="https://github.com/bulletmark/libinput-gestures">https://github.com/bulletmark/libinput-gestures</a></li>
      <li><a href="https://github.com/Coffee2CodeNL/gebaar-libinput">https://github.com/Coffee2CodeNL/gebaar-libinput</a></li>
      <li><a href="https://bill.harding.blog/2019/03/25/linux-touchpad-like-a-macbook-progress-and-a-call-for-help/">https://bill.harding.blog/2019/03/25/linux-touchpad-like-a-macbook-progress-and-a-call-for-help/</a></li>
      <li><a href="https://www.davidrevoy.com/article1002/how-a-kernel-developer-made-my-styluses-work-again">https://www.davidrevoy.com/article1002/how-a-kernel-developer-made-my-styluses-work-again</a></li>
      <li><a href="https://lwn.net/Articles/801767/">https://lwn.net/Articles/801767/</a></li>
      <li><a href="http://github.com/libratbag/libratbag">http://github.com/libratbag/libratbag</a></li>
      <li><a href="https://libratbag.github.io/">https://libratbag.github.io/</a></li>
      <li><a href="https://github.com/libratbag/ratbag-toolbox">https://github.com/libratbag/ratbag-toolbox</a></li>
      <li><a href="https://github.com/libratbag/ratbag-emu">https://github.com/libratbag/ratbag-emu</a></li>
    </ul>
  </li>
  <li>KEYBOARDS SCANCODES TO KEYCODES
    <ul>
      <li><a href="https://docs.kernel.org/input/event-codes.html">https://docs.kernel.org/input/event-codes.html</a></li>
      <li><a href="https://wiki.archlinux.org/title/Map_scancodes_to_keycodes">https://wiki.archlinux.org/title/Map_scancodes_to_keycodes</a></li>
    </ul>
  </li>
  <li>XKB
    <ul>
      <li><a href="https://xkbcommon.org/">https://xkbcommon.org/</a></li>
      <li><a href="https://web.archive.org/web/20170825051821/http://madduck.net:80/docs/extending-xkb/">https://web.archive.org/web/20170825051821/http://madduck.net:80/docs/extending-xkb/</a></li>
      <li><a href="https://man.archlinux.org/man/xkbcli.1 xkbcli">https://man.archlinux.org/man/xkbcli.1 xkbcli</a></li>
      <li><a href="https://www.charvolant.org/doug/xkb/html/index.html">https://www.charvolant.org/doug/xkb/html/index.html</a></li>
      <li><a href="https://xkbcommon.org/doc/current/user-configuration.html">https://xkbcommon.org/doc/current/user-configuration.html</a></li>
      <li><a href="https://wiki.archlinux.org/title/X_keyboard_extension">https://wiki.archlinux.org/title/X_keyboard_extension</a></li>
      <li><a href="https://who-t.blogspot.com/2021/02/a-pre-supplied-custom-keyboard-layout.html">https://who-t.blogspot.com/2021/02/a-pre-supplied-custom-keyboard-layout.html</a></li>
      <li><a href="https://who-t.blogspot.com/2020/02/user-specific-xkb-configuration-part-1.html">https://who-t.blogspot.com/2020/02/user-specific-xkb-configuration-part-1.html</a></li>
      <li><a href="https://who-t.blogspot.com/2020/07/user-specific-xkb-configuration-part-2.html">https://who-t.blogspot.com/2020/07/user-specific-xkb-configuration-part-2.html</a></li>
      <li><a href="https://who-t.blogspot.com/2020/08/user-specific-xkb-configuration-part-3.html">https://who-t.blogspot.com/2020/08/user-specific-xkb-configuration-part-3.html</a></li>
      <li><a href="https://who-t.blogspot.com/2020/09/user-specific-xkb-configuration-putting.html">https://who-t.blogspot.com/2020/09/user-specific-xkb-configuration-putting.html</a></li>
      <li><a href="https://who-t.blogspot.com/2021/01/auto-updating-xkb-for-new-kernel.html">https://who-t.blogspot.com/2021/01/auto-updating-xkb-for-new-kernel.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/12/new-udev-property-xkbfixedlayout-for.html">https://who-t.blogspot.com/2016/12/new-udev-property-xkbfixedlayout-for.html</a></li>
      <li><a href="https://xkbcommon.org/doc/current/xkb-intro.html#md_doc_2introduction-to-xkb">https://xkbcommon.org/doc/current/xkb-intro.html#md_doc_2introduction-to-xkb</a></li>
      <li><a href="https://x.org/releases/current/doc/kbproto/xkbproto.pdf">https://x.org/releases/current/doc/kbproto/xkbproto.pdf</a></li>
      <li><a href="https://xkeyboard-config.freedesktop.org/">https://xkeyboard-config.freedesktop.org/</a></li>
      <li><a href="https://xkbcommon.org/doc/current/keymap-text-format-v1-v2.html">https://xkbcommon.org/doc/current/keymap-text-format-v1-v2.html</a></li>
      <li><a href="https://xkbcommon.org/doc/current/rule-file-format.html">https://xkbcommon.org/doc/current/rule-file-format.html</a></li>
      <li><a href="https://xkbcommon.org/doc/current/user-configuration.html">https://xkbcommon.org/doc/current/user-configuration.html</a></li>
      <li><a href="https://xkbcommon.org/doc/current/debugging.html">https://xkbcommon.org/doc/current/debugging.html</a></li>
      <li><a href="https://web.archive.org/web/20190718184358/http://pascal.tsu.ru/en/xkb/internals.html">https://web.archive.org/web/20190718184358/http://pascal.tsu.ru/en/xkb/internals.html</a></li>
      <li><a href="https://who-t.blogspot.com/2008/09/rmlvo-keyboard-configuration.html">https://who-t.blogspot.com/2008/09/rmlvo-keyboard-configuration.html</a></li>
      <li><a href="https://www.x.org/wiki/XKB/">https://www.x.org/wiki/XKB/</a></li>
      <li><a href="https://medium.com/@damko/a-simple-humble-but-comprehensive-guide-to-xkb-for-linux-6f1ad5e13450">https://medium.com/@damko/a-simple-humble-but-comprehensive-guide-to-xkb-for-linux-6f1ad5e13450</a></li>
    </ul>
  </li>
  <li>UPPER STACK, CONSOLE, XSERVER, WAYLAND
    <ul>
      <li><a href="https://wiki.archlinux.org/title/Input_remap_utilities">https://wiki.archlinux.org/title/Input_remap_utilities</a></li>
      <li><a href="https://who-t.blogspot.com/2016/12/the-future-of-xinput-xmodmap-setxkbmap.html">https://who-t.blogspot.com/2016/12/the-future-of-xinput-xmodmap-setxkbmap.html</a></li>
      <li><a href="https://wiki.archlinux.org/title/Xmodmap">https://wiki.archlinux.org/title/Xmodmap</a></li>
      <li><a href="https://who-t.blogspot.com/2016/01/xorg-project-vs-xorg-foundation.html">https://who-t.blogspot.com/2016/01/xorg-project-vs-xorg-foundation.html</a></li>
      <li><a href="https://who-t.blogspot.com/2015/01/xf86-input-libinput-compatibility-with.html">https://who-t.blogspot.com/2015/01/xf86-input-libinput-compatibility-with.html</a></li>
      <li><a href="https://who-t.blogspot.com/2016/12/xinput-is-not-configuration-ui.html">https://who-t.blogspot.com/2016/12/xinput-is-not-configuration-ui.html</a></li>
      <li><a href="https://who-t.blogspot.com/2018/06/x-server-pointer-acceleration-analysis.html Series">https://who-t.blogspot.com/2018/06/x-server-pointer-acceleration-analysis.html Series</a></li>
      <li><a href="https://who-t.blogspot.com/2021/09/an-xorg-release-without-xwayland.html">https://who-t.blogspot.com/2021/09/an-xorg-release-without-xwayland.html</a></li>
      <li><a href="https://en.wikipedia.org/wiki/X.Org_Server">https://en.wikipedia.org/wiki/X.Org_Server</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Wayland_(protocol)">https://en.wikipedia.org/wiki/Wayland_(protocol)</a></li>
      <li><a href="https://mort.coffee/home/wayland-input-latency/">https://mort.coffee/home/wayland-input-latency/</a></li>
      <li><a href="https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html">https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html</a></li>
      <li><a href="https://fcitx-im.org/wiki/Input_method_related_environment_variables">https://fcitx-im.org/wiki/Input_method_related_environment_variables</a></li>
      <li><a href="https://gitlab.freedesktop.org/xorg/driver/xf86-input-libinput">https://gitlab.freedesktop.org/xorg/driver/xf86-input-libinput</a></li>
      <li><a href="https://gitlab.freedesktop.org/xorg/app/xmodmap">https://gitlab.freedesktop.org/xorg/app/xmodmap</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Unicode_input#In_X11_and_Wayland_(Linux_and_other_Unix_variants_including_ChromeOS)">https://en.wikipedia.org/wiki/Unicode_input#In_X11_and_Wayland_(Linux_and_other_Unix_variants_including_ChromeOS)</a></li>
      <li><a href="https://nixers.net/showthread.php?tid=1970">https://nixers.net/showthread.php?tid=1970</a></li>
      <li><a href="https://wiki.archlinux.org/title/Xorg/Keyboard_configuration">https://wiki.archlinux.org/title/Xorg/Keyboard_configuration</a></li>
      <li><a href="https://wiki.archlinux.org/title/Linux_console/Keyboard_configuration">https://wiki.archlinux.org/title/Linux_console/Keyboard_configuration</a></li>
      <li><a href="https://manpages.debian.org/testing/console-setup/setupcon.1.en.html">https://manpages.debian.org/testing/console-setup/setupcon.1.en.html</a></li>
      <li><a href="https://github.com/pierre-labastie/blocaled">https://github.com/pierre-labastie/blocaled</a></li>
      <li><a href="http://www.freedesktop.org/wiki/Software/systemd/localed">http://www.freedesktop.org/wiki/Software/systemd/localed</a></li>
    </ul>
  </li>
  <li>AUTOMATION, LIBEI, INPUTFD, &amp; other protoc
    <ul>
      <li><a href="https://docs.kernel.org/5.10/hid/uhid.html">https://docs.kernel.org/5.10/hid/uhid.html</a></li>
      <li><a href="https://www.kernel.org/doc/html/v4.12/input/uinput.html">https://www.kernel.org/doc/html/v4.12/input/uinput.html</a></li>
      <li><a href="https://github.com/torvalds/linux/blob/2eba5e05d9bcf4cdea995ed51b0f07ba0275794a/drivers/hid/uhid.c#L4">https://github.com/torvalds/linux/blob/2eba5e05d9bcf4cdea995ed51b0f07ba0275794a/drivers/hid/uhid.c#L4</a></li>
      <li><a href="https://github.com/torvalds/linux/blob/master/samples/uhid/uhid-example.c">https://github.com/torvalds/linux/blob/master/samples/uhid/uhid-example.c</a></li>
      <li><a href="https://who-t.blogspot.com/2020/08/libei-library-to-support-emulated-input.html">https://who-t.blogspot.com/2020/08/libei-library-to-support-emulated-input.html</a></li>
      <li><a href="https://who-t.blogspot.com/2022/03/libei-adding-support-for-passive.html">https://who-t.blogspot.com/2022/03/libei-adding-support-for-passive.html</a></li>
      <li><a href="https://who-t.blogspot.com/2022/12/libei-opening-portal-doors.html">https://who-t.blogspot.com/2022/12/libei-opening-portal-doors.html</a></li>
      <li><a href="https://who-t.blogspot.com/2023/05/libei-and-fancy-protocol.html">https://who-t.blogspot.com/2023/05/libei-and-fancy-protocol.html</a></li>
      <li><a href="https://who-t.blogspot.com/2017/04/inputfd-protocol-for-direct-access-to.html">https://who-t.blogspot.com/2017/04/inputfd-protocol-for-direct-access-to.html</a></li>
      <li><a href="https://gitlab.freedesktop.org/libinput/libei/-/tree/main">https://gitlab.freedesktop.org/libinput/libei/-/tree/main</a></li>
      <li><a href="https://libinput.pages.freedesktop.org/libei/">https://libinput.pages.freedesktop.org/libei/</a></li>
      <li><a href="https://libinput.pages.freedesktop.org/libei/api/index.html">https://libinput.pages.freedesktop.org/libei/api/index.html</a></li>
      <li><a href="https://github.com/ReimuNotMoe/ydotool">https://github.com/ReimuNotMoe/ydotool</a></li>
      <li><a href="https://who-t.blogspot.com/2025/08/unplug-tool-to-test-input-devices-via.html">https://who-t.blogspot.com/2025/08/unplug-tool-to-test-input-devices-via.html</a></li>
      <li><a href="https://git.sr.ht/~brocellous/wlrctl">https://git.sr.ht/~brocellous/wlrctl</a></li>
      <li><a href="https://www.semicomplete.com/blog/xdotool-and-exploring-wayland-fragmentation/">https://www.semicomplete.com/blog/xdotool-and-exploring-wayland-fragmentation/</a></li>
    </ul>
  </li>
  <li>INPUT METHOD
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Input_method">https://en.wikipedia.org/wiki/Input_method</a></li>
      <li><a href="https://linuxcommandlibrary.com/man/scim">https://linuxcommandlibrary.com/man/scim</a></li>
      <li><a href="https://wiki.archlinux.org/title/Input_method">https://wiki.archlinux.org/title/Input_method</a></li>
      <li><a href="https://wiki.archlinux.org/title/IBus">https://wiki.archlinux.org/title/IBus</a></li>
      <li><a href="https://www.csslayer.info/wordpress/linux/key-repetition-and-key-event-handling-issue-with-wayland-input-method-protocols/">https://www.csslayer.info/wordpress/linux/key-repetition-and-key-event-handling-issue-with-wayland-input-method-protocols/</a></li>
      <li><a href="https://wayland.app/protocols/xx-input-method-v2">https://wayland.app/protocols/xx-input-method-v2</a></li>
      <li><a href="https://wiki.qt.io/QtCS2021_-_Wayland_text-input-unstable-v4_protocol">https://wiki.qt.io/QtCS2021_-_Wayland_text-input-unstable-v4_protocol</a></li>
      <li><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/text-input/">https://www.chromium.org/chromium-os/chromiumos-design-docs/text-input/</a></li>
      <li><a href="https://lwn.net/Articles/503320/">https://lwn.net/Articles/503320/</a></li>
      <li><a href="https://nerufic.com/en/posts/how-input-methods-work-in-linux/">https://nerufic.com/en/posts/how-input-methods-work-in-linux/</a></li>
      <li><a href="https://mail.gnome.org/archives/desktop-devel-list/2012-May/msg00093.html">https://mail.gnome.org/archives/desktop-devel-list/2012-May/msg00093.html</a></li>
      <li><a href="https://wiki.gnome.org/Design(2f)OS(2f)LanguageInput.html">https://wiki.gnome.org/Design(2f)OS(2f)LanguageInput.html</a></li>
      <li><a href="https://docs.gtk.org/gtk4/class.IMContext.html">https://docs.gtk.org/gtk4/class.IMContext.html</a></li>
      <li><a href="https://docs.gtk.org/gtk4/property.Settings.gtk-im-module.html">https://docs.gtk.org/gtk4/property.Settings.gtk-im-module.html</a></li>
    </ul>
  </li>
</ul>


	
</article>
</div></div>
  </body>
</html>
