<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.4rknova.com/blog/2016/11/01/plasma">Original</a>
    <h1>Plasma Effect (2016)</h1>
    
    <div id="readability-page-1" class="page"><div><p>The plasma effect is one of the most iconic visual effects from the demoscene era of the 1980s and 1990s. Named for its resemblance to flowing plasma or aurora-like patterns, this effect creates organic, continuously moving patterns using surprisingly simple mathematics. Despite its simplicity, the visual result is captivating and has remained a favorite demonstration of procedural graphics techniques.</p><p>The effect relies on combining multiple sinusoidal wave patterns to create complex interference patterns. By animating these patterns over time and mapping them to color gradients, we achieve the characteristic flowing, pulsing appearance.</p><p>On early hardware like the Commodore 64 and Amiga, plasma effects often used pre-calculated lookup tables to avoid expensive real-time sine calculations. Modern GPUs can compute these effects in real-time with minimal performance impact, allowing for more complex variations and higher resolutions.</p><p>At its heart, the plasma effect combines multiple sine and cosine functions with different frequencies and phases. The basic approach involves:</p><ol><li><strong>Generating wave patterns</strong>: Create 2D wave patterns using sine and cosine functions based on screen coordinates</li><li><strong>Combining waves</strong>: Add or multiply multiple wave patterns to create interference effects</li><li><strong>Time animation</strong>: Offset the wave patterns over time to create motion</li><li><strong>Color mapping</strong>: Map the resulting values to a color gradient</li></ol><p>The typical formula structure looks like:</p><div><div><pre><code>value = sin(x + time) + cos(y + time) + sin(distance + time)
</code></pre></div></div><p>Where different combinations of <code>x</code>, <code>y</code>, <code>distance</code>, and <code>time</code> create different visual patterns.</p><p>The beauty of the plasma effect comes from wave interference. When multiple sinusoidal patterns overlap, they create complex patterns through constructive and destructive interference:</p><ul><li><strong>Constructive interference</strong>: Waves align and amplify each other</li><li><strong>Destructive interference</strong>: Waves cancel each other out</li></ul><p>This creates the characteristic peaks and valleys that define the plasma’s flowing appearance.</p><p>The numerical output of the combined sine waves is then mapped to colors. A common approach uses the cosine color palette technique, which provides smooth, continuous color gradients by treating the wave output as input to RGB color channels with different phase offsets.</p><p>Modern implementations can add specular highlights by analyzing the gradient of the color field. This creates the illusion of a reflective surface and adds depth to the otherwise flat 2D pattern.</p><p>The specular component is typically implemented using derivatives (dFdx and dFdy in GLSL) to detect rapid color changes, treating these as “surface normals” for lighting calculations.</p><p>Below is my implementation of the above in GLSL along with a live preview of the effect.</p><pre><code>// by Nikos Papadopoulos, 4rknova / 2016
// Specular highlights contributed by Shane

#define SPECULAR
#define SCALE 1.0

void mainImage(out vec4 col, in vec2 pc)
{
	float time = iTime;
    vec2 a = vec2(iResolution.x /iResolution.y, 1);
    vec2 c = SCALE * pc.xy / iResolution.xy * a * 4. + time * .3;

	float k = .1 + cos(c.y + sin(.148 - time)) + 2.4 * time;
	float w = .9 + sin(c.x + cos(.628 + time)) - 0.7 * time;
	float d = length(c);
	float s = 7. * cos(d+w) * sin(k+w);
	
	col = vec4(.5 + .5 * cos(s + vec3(.2, .5, .9)), 1);
    
    #ifdef SPECULAR
    col *= vec4(1, .7, .4, 1) 
        *  pow(max(normalize(vec3(length(dFdx(col)), 
               length(dFdy(col)), .5/iResolution.y)).z, 0.), 2.)
        + .75; 
    #endif
}</code></pre></div></div>
  </body>
</html>
