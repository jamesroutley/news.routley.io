<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wagslane.dev/posts/go-struct-ordering/">Original</a>
    <h1>Saving a Third of Our Memory by Re-Ordering Go Struct Fields (2020)</h1>
    
    <div id="readability-page-1" class="page"><p>
    
    
    <h2>
        By Lane Wagner
        
        on Aug 07, 2020
        
    </h2>
    
</p><div>
    <p><img src="https://wagslane.dev/img/tetris.jpg" alt="tetris"/></p>
<p>We had application at one of my previous companies that typically ran with ~2GB in memory at any given time, but simply changing the order of some uint variables we managed to drop the memory usage to less than 1.4GB. Let’s dive into how inefficient field ordering in Go structs can have a huge impact on the memory footprint of a program.</p>
<h2 id="our-situation">Our Situation</h2>
<p>The vast majority of the allocated memory in our case was due to an enormous slice of <code>stats</code> structs. The <code>stats</code> struct had the following type definition:</p>
<div><pre><code data-lang="golang"><span>type</span> <span>stats</span> <span>struct</span> {
	<span>NumPosts</span> <span>uint8</span>
	<span>Reach</span>    <span>uint16</span>
	<span>NumLikes</span> <span>uint8</span>
}
</code></pre></div><p>In theory, this struct will use a measly 4 bytes. Each <code>uint8</code> uses 1 byte, and the single <code>uint16</code> needs 2. We began to suspect that we had some wasteful memory issues, so I built the following little program to show how memory is being used by our struct:</p>
<div><pre><code data-lang="golang"><span>package</span> <span>main</span>

<span>import</span> (
	<span>&#34;fmt&#34;</span>
	<span>&#34;reflect&#34;</span>
	<span>&#34;runtime&#34;</span>
)

<span>type</span> <span>stats</span> <span>struct</span> {
	<span>NumPosts</span> <span>uint8</span>
	<span>Reach</span>    <span>uint16</span>
	<span>NumLikes</span> <span>uint8</span>
}

<span>func</span> <span>main</span>() {
	<span>typ</span> <span>:=</span> <span>reflect</span>.<span>TypeOf</span>(<span>stats</span>{})
	<span>fmt</span>.<span>Printf</span>(<span>&#34;Struct is %d bytes long\n&#34;</span>, <span>typ</span>.<span>Size</span>())
	<span>n</span> <span>:=</span> <span>typ</span>.<span>NumField</span>()
	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>n</span>; <span>i</span><span>++</span> {
		<span>field</span> <span>:=</span> <span>typ</span>.<span>Field</span>(<span>i</span>)
		<span>fmt</span>.<span>Printf</span>(<span>&#34;%s at offset %v, size=%d, align=%d\n&#34;</span>,
			<span>field</span>.<span>Name</span>, <span>field</span>.<span>Offset</span>, <span>field</span>.<span>Type</span>.<span>Size</span>(),
			<span>field</span>.<span>Type</span>.<span>Align</span>())
	}

	<span>allStats</span> <span>:=</span> []<span>stats</span>{}
	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>100000000</span>; <span>i</span><span>++</span> {
		<span>allStats</span> = append(<span>allStats</span>, <span>stats</span>{})
	}

	<span>printMemUsage</span>()
}

<span>func</span> <span>printMemUsage</span>() {
	<span>var</span> <span>m</span> <span>runtime</span>.<span>MemStats</span>
	<span>runtime</span>.<span>ReadMemStats</span>(<span>&amp;</span><span>m</span>)
	<span>fmt</span>.<span>Printf</span>(<span>&#34;Alloc = %v MiB&#34;</span>, <span>bToMb</span>(<span>m</span>.<span>Alloc</span>))
	<span>fmt</span>.<span>Printf</span>(<span>&#34;\tTotalAlloc = %v MiB&#34;</span>, <span>bToMb</span>(<span>m</span>.<span>TotalAlloc</span>))
	<span>fmt</span>.<span>Printf</span>(<span>&#34;\tSys = %v MiB&#34;</span>, <span>bToMb</span>(<span>m</span>.<span>Sys</span>))
	<span>fmt</span>.<span>Printf</span>(<span>&#34;\tNumGC = %v\n&#34;</span>, <span>m</span>.<span>NumGC</span>)
}

<span>func</span> <span>bToMb</span>(<span>b</span> <span>uint64</span>) <span>uint64</span> {
	<span>return</span> <span>b</span> <span>/</span> <span>1024</span> <span>/</span> <span>1024</span>
}
</code></pre></div><p>On my MacBook using Go 1.14.1 the above program prints:</p>
<pre><code>Struct is 6 bytes long
NumPosts at offset 0, size=1, align=1
Reach at offset 2, size=2, align=2
NumLikes at offset 4, size=1, align=1
Alloc = 1084 MiB        TotalAlloc = 3012 MiB   Sys = 2713 MiB  NumGC = 19
</code></pre><p>Notice that even though <code>NumPosts</code> only has a size of 1 byte, the next field, <code>Reach</code>, still starts at offset 2. A whole byte is being wasted! The same thing happens with the <code>NumLikes</code> field, it starts at offset 4 with a size of 1, but the struct still takes up the full 6 bytes.</p>
<p>This may not seem like a big deal, but when you are storing millions of these structs in memory the bloat starts to add up quick.</p>
<p>If we change the stats struct such that the <code>uint16</code> isn’t defined between the <code>uint8</code>s:</p>
<div><pre><code data-lang="golang"><span>type</span> <span>stats</span> <span>struct</span> {
	<span>Reach</span>    <span>uint16</span>
	<span>NumPosts</span> <span>uint8</span>
	<span>NumLikes</span> <span>uint8</span>
}
</code></pre></div><pre><code>Struct is 4 bytes long
Reach at offset 0, size=2, align=2
NumPosts at offset 2, size=1, align=1
NumLikes at offset 3, size=1, align=1
Alloc = 694 MiB TotalAlloc = 1927 MiB   Sys = 1391 MiB  NumGC = 19
</code></pre><p>The total allocated memory drops from 3 GB to less than 2, and each instance of the struct now only uses 4 bytes.</p>
<h2 id="why">Why?</h2>
<p>Modern CPU hardware performs reads and writes to memory most efficiently when the data is <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">naturally aligned</a>. The memory that is stored side by side should be accessible using a common multiple, so the Go compiler makes sure that it is.</p>
<p>With our first struct, the Reach field is between the NumPosts and NumLikes fields, which means that the compiler will add some padding to keep things nice and even.</p>
<p><img src="https://wagslane.dev/img/memory-usage-go.png" alt="mem1"/></p>
<p>In our updated struct however, we have grouped the smaller fields, and since they add up to the same amount of memory as the larger Reach field we can save some space!</p>
<p><img src="https://wagslane.dev/img/memory-usage-go-2.png" alt="mem1"/></p>
<p>This was is a weird quirk, but making the small optimizations has made a huge impact on some of our services.</p>

</div></div>
  </body>
</html>
