<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://victorpoughon.fr/non-random-uniform-disk-sampling/">Original</a>
    <h1>Non-random uniform disk sampling</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-01-27T14:45Z">
                    27 Jan, 2025
                </time>
            </i>
        </p>
    

    <p>Consider the problem of generating N points on a disk of diameter D. The function must be deterministic and the points somewhat uniformly spread around on the disk. Importantly, I want to generate <strong>exactly</strong> N points, for any integer value of N.</p>
<p>Here&#39;s what I mean with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>N</mi><mo>=</mo><mn>1721</mn></mrow></math>:</p>
<p><img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/victorpoughon/post4img3.webp"/>
</p>
<p>I needed to solve that problem recently, and this is what I came up with.</p>
<p>First, we know that the first point will be hardcoded at the origin <code>(0,0)</code> so it&#39;s safe to ignore it as we&#39;ll manually add it anyway, and consider only N-1 points for the next part.</p>
<p>Let&#39;s define an integer M. We will spread our N-1 remaining points over M concentric rings. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow></math> be the number of points on ring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math>. We want:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mo>∑</mo><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mi>N</mi><mo>−</mo><mn>1</mn></mrow></math><p>How should the number of points vary from ring to ring? Well, if rings are linearly spaced from the center, their radiuses are a linear progression, so it seems a good idea to have the number of points per ring be proportional to the ring perimeter. Let&#39;s call that proportion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>α</mi></mrow></math>:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn><mi>π</mi><msub><mi>R</mi><mi>i</mi></msub><mi>α</mi></mrow></math><p>We choose uniform concentric rings, aka <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi><mo stretchy="false">]</mo></mrow></math>, so:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mn>2</mn><mi>π</mi><mi>α</mi><mo>∑</mo><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mi>N</mi><mo>−</mo><mn>1</mn><mspace linebreak="newline"></mspace></mrow></math><p>We know that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>∑</mo><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn></mrow></mfrac></mrow></math>, so:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi>α</mi><mo>=</mo><mfrac><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>π</mi><mi>M</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow></math><p>This gives a good value for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>α</mi></mrow></math>, but there is still the issue of choosing a value for M.</p>
<p>Let&#39;s look at what values are possible for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>M</mi></mrow></math>. Using the reasonable constraint that we want <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>α</mi><mo>&gt;</mo><mn>1</mn></mrow></math> this gives this quadratic inequality for choosing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>M</mi></mrow></math>:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi>π</mi><msup><mi>M</mi><mn>2</mn></msup><mo>+</mo><mi>π</mi><mi>M</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>0</mn></mrow></math><p>This quadratic polynomial will be negative when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>M</mi></mrow></math> is between its roots. And since we obviously want a positive number of rings, this gives us bounds for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>M</mi></mrow></math>. Let&#39;s looks at the roots of this polynomial for integer values between 1 and 20:</p>
<div><pre><span></span> N     M1     M2
 1   0.25  -1.25
 2   0.44  -1.44
 3   0.60  -1.60
 4   0.73  -1.73
 5   0.86  -1.86
 6   0.97  -1.97
 7   1.07  -2.07
 8   1.17  -2.17
 9   1.26  -2.26
10   1.35  -2.35
11   1.44  -2.44
12   1.52  -2.52
13   1.59  -2.59
14   1.67  -2.67
15   1.74  -2.74
16   1.81  -2.81
17   1.88  -2.88
18   1.95  -2.95
19   2.01  -3.01
20   2.07  -3.07
</pre></div>
<p>Not only does the positive root grow quite slow, we have to be careful of rounding. For the rest of this article, I&#39;ll choose the maximum value for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>M</mi></mrow></math>, which gives maximum &#34;density&#34; of points, so to speak. But any value less than that is possible. Use a lower M value for a more &#34;ringy&#34; looking sampling, and the maximum value for most &#34;dense&#34; looking sampling.</p>
<p>So, here is the formula for maximum M value:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><msub><mi>M</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mtext>floor</mtext><mo minsize="1.623em" maxsize="1.623em">(</mo><mfrac><mrow><mo>−</mo><mi>π</mi><mo>+</mo><msqrt><mrow><msup><mi>π</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>π</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><mo minsize="1.623em" maxsize="1.623em">)</mo></mrow></math><p>Now that we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>M</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>α</mi></mrow></math>, getting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow></math> is easy from the formula above! Here&#39;s what we get for N=50:</p>
<div><pre><span></span><span>import</span><span> </span><span>numpy</span><span> </span><span>as</span><span> </span><span>np</span>

<span>N</span> <span>=</span> <span>50</span>
<span>M</span> <span>=</span> <span>np</span><span>.</span><span>floor</span><span>((</span><span>-</span><span>np</span><span>.</span><span>pi</span> <span>+</span> <span>math</span><span>.</span><span>sqrt</span><span>(</span><span>np</span><span>.</span><span>pi</span><span>**</span><span>2</span> <span>-</span> <span>4</span><span>*</span><span>np</span><span>.</span><span>pi</span><span>*</span><span>(</span><span>1</span><span>-</span><span>N</span><span>)))</span> <span>/</span> <span>(</span><span>2</span><span>*</span><span>np</span><span>.</span><span>pi</span><span>))</span>
<span>alpha</span> <span>=</span> <span>(</span><span>N</span><span>-</span><span>1</span><span>)</span><span>/</span><span>(</span><span>math</span><span>.</span><span>pi</span><span>*</span><span>M</span><span>*</span><span>(</span><span>M</span><span>+</span><span>1</span><span>))</span>
<span>R</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>1</span><span>,</span> <span>M</span><span>+</span><span>1</span><span>)</span>
<span>S</span> <span>=</span> <span>2</span><span>*</span><span>np</span><span>.</span><span>pi</span><span>*</span><span>alpha</span><span>*</span><span>R</span>

<span>print</span><span>(</span><span>S</span><span>)</span>
<span>print</span><span>(</span><span>&#34;sum = &#34;</span><span>,</span> <span>S</span><span>.</span><span>sum</span><span>())</span>
</pre></div>
<div><pre><span></span>[ 8.16666667 16.33333333 24.5       ]
sum =  49.0
</pre></div>
<p>Yes! We got it! That&#39;s our number of points per ring, and the sum is a perfect <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>N</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>49</mn></mrow></math>! With the additional center point, that&#39;s the 50 we want!</p>
<p>But wait! Those are real numbers... we need an integer number of points per ring. How do we go from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow></math> to an array of integers?</p>
<p>Well, there&#39;s probably a lot of ways to accomplish that. For me, I choose a simple trick. First, round S and check the sum again. With some luck, that sum is still <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></math>. If not, subtract the difference from the last element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow></math>. This is quick and easy, and the last ring is the one with the most points, making this choice hardly noticeable.</p>
<p>Converting the number of points per ring to actual point coordinates is then just a matter of sampling in polar coordinates and converting to Cartesian. This is the full <code>uniform_disk_sampling()</code> function in Python:</p>
<div><pre><span></span><span>import</span><span> </span><span>numpy</span><span> </span><span>as</span><span> </span><span>np</span>

<span>def</span><span> </span><span>uniform_disk_sampling</span><span>(</span><span>N</span><span>,</span> <span>diameter</span><span>):</span>
    <span>M</span> <span>=</span> <span>np</span><span>.</span><span>floor</span><span>((</span><span>-</span><span>np</span><span>.</span><span>pi</span> <span>+</span> <span>np</span><span>.</span><span>sqrt</span><span>(</span><span>np</span><span>.</span><span>pi</span><span>**</span><span>2</span> <span>-</span> <span>4</span><span>*</span><span>np</span><span>.</span><span>pi</span><span>*</span><span>(</span><span>1</span><span>-</span><span>N</span><span>)))</span> <span>/</span> <span>(</span><span>2</span><span>*</span><span>np</span><span>.</span><span>pi</span><span>))</span>
    <span>if</span> <span>M</span> <span>==</span> <span>0</span><span>:</span>
        <span>M</span> <span>=</span> <span>1</span>
    <span>alpha</span> <span>=</span> <span>(</span><span>N</span><span>-</span><span>1</span><span>)</span><span>/</span><span>(</span><span>np</span><span>.</span><span>pi</span><span>*</span><span>M</span><span>*</span><span>(</span><span>M</span><span>+</span><span>1</span><span>))</span>
    <span>R</span> <span>=</span> <span>np</span><span>.</span><span>arange</span><span>(</span><span>1</span><span>,</span> <span>M</span><span>+</span><span>1</span><span>)</span>
    <span>S</span> <span>=</span> <span>2</span><span>*</span><span>np</span><span>.</span><span>pi</span><span>*</span><span>alpha</span><span>*</span><span>R</span>

    <span># If we&#39;re off, subtract the difference from the last element</span>
    <span>S</span> <span>=</span> <span>np</span><span>.</span><span>round</span><span>(</span><span>S</span><span>)</span>
    <span>S</span><span>[</span><span>-</span><span>1</span><span>]</span> <span>-=</span> <span>(</span><span>S</span><span>.</span><span>sum</span><span>()</span> <span>-</span> <span>(</span><span>N</span> <span>-</span> <span>1</span><span>))</span>
    <span>S</span> <span>=</span> <span>S</span><span>.</span><span>astype</span><span>(</span><span>int</span><span>)</span>

    <span># List of sample points, start with the origin point</span>
    <span>points</span> <span>=</span> <span>[</span><span>np</span><span>.</span><span>zeros</span><span>((</span><span>1</span><span>,</span> <span>2</span><span>))]</span>

    <span>for</span> <span>s</span><span>,</span> <span>r</span> <span>in</span> <span>zip</span><span>(</span><span>S</span><span>,</span> <span>R</span><span>):</span>
        <span>theta</span> <span>=</span> <span>np</span><span>.</span><span>linspace</span><span>(</span><span>-</span><span>np</span><span>.</span><span>pi</span><span>,</span> <span>np</span><span>.</span><span>pi</span><span>,</span> <span>s</span><span>+</span><span>1</span><span>)[:</span><span>-</span><span>1</span><span>]</span>
        <span>radius</span> <span>=</span> <span>r</span><span>/</span><span>M</span> <span>*</span> <span>diameter</span><span>/</span><span>2</span>
        <span>points</span><span>.</span><span>append</span><span>(</span><span>np</span><span>.</span><span>column_stack</span><span>((</span><span>radius</span><span>*</span><span>np</span><span>.</span><span>cos</span><span>(</span><span>theta</span><span>),</span> <span>radius</span><span>*</span><span>np</span><span>.</span><span>sin</span><span>(</span><span>theta</span><span>))))</span>

    <span>return</span> <span>np</span><span>.</span><span>vstack</span><span>(</span><span>points</span><span>)</span>
</pre></div>
<p>And this is what it looks like from N=1 to 10000:</p>
<p><img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/victorpoughon/post4img4.webp" alt="post4img4"/></p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
