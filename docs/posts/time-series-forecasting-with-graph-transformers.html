<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kumo.ai/research/time-series-forecasting/">Original</a>
    <h1>Time Series Forecasting with Graph Transformers</h1>
    
    <div id="readability-page-1" class="page"><div><p>Time series forecasting is a cornerstone in modern business analytics, whether it is concerned with anticipating market trends, user behavior, optimizing resource allocation, or planning for future growth. As such, a wide range of different approaches have been introduced and investigated for forecasting, lately data-driven approaches using machine learning and generative models.</p><p>This blog post will dive into forecasting on graph structured entities, <em>e.g.</em>, as obtained from a relational database, utilizing not only the individual time series as signal but also related information. As most of the worldâ€™s data is stored in relational structures, this topic is of particular interest for real world applications. We describe an end-to-end pipeline to perform forecasting using graph transformers and specifically discuss predictive vs. generative paradigms.</p><h2 id="forecasting-on-graph-structured-data">Forecasting on Graph-structured Data</h2><p>Forecasting is the process of making predictions about future events based on historical data and current observations, requiring detecting patterns, trends, and seasonal variations.</p><p>Traditional forecasting methods often treat time series data in isolation, focusing solely on temporal patterns within a single sequence. However, in real-world applications, valuable predictive signals often exist in related data sources. For instance, when forecasting product sales, factors such as marketing campaigns, competitor pricing, or regional economic indicators can significantly impact the accuracy of predictions. Graphs are a natural structure to represent such inter-connected data sources. They represent a set of inter-connected nodes of different entities, where some entities can have time series that can be forecasted. Each node can potentially hold a variety of features that hold important signal for forecasting tasks on other nodes. Further, they lend themselves to a wide arrange of machine learning methods, <em>e.g.</em>, <a href="https://kumo.ai/research/introduction-to-graph-transformers/"><em>Graph Transformers</em></a>.</p><p>A prominent option for obtaining graphs directly from an underlying business problem on a relational database is <a href="https://kumo.ai/research/relational-deep-learning-rdl/"><em>Relational Deep Learning (RDL)</em></a>, which automatically discovers and utilizes cross-table relationships and data in connected tables. The RDL scheme allows to automatically extract a graph structure from the relational database, allowing us to treat timeseries forecasting as a graph learning task. We will use the graph obtained via RDL as an example below. However, our graph forecasting techniques are not limited to graphs obtained via RDL but can be applied on arbitrary forecasting tasks where time series have to be forecasted for a subset of graph nodes.</p><div><p><img alt="" loading="lazy" width="2106" height="488" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F9c7f308dc5e8fe48c1deba1d8967c31c9a081e62-2106x488.png&amp;w=3840&amp;q=75 1x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F9c7f308dc5e8fe48c1deba1d8967c31c9a081e62-2106x488.png&amp;w=3840&amp;q=75"/></p></div><p><strong>Example. </strong>Consider the task of forecasting the sales per day for all products stored in a product table (yellow). Further tables containing transactions (blue), customers (green), product marketing (red) can provide additional signals that help solving the task. Using the RDL scheme, we can automatically transform the relational tables into a graph with node features. Then, the task is to perform forecasting on the subset of product nodes via graph machine learning.</p><p><strong>Notation.</strong> We denote the input to our graph forecasting task as a graph <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> with node set <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> and edge set <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, where <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> is a subset of nodes that serve as forecasting entities with a given (past) time series <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>. Additionally, the graph nodes are annotated with arbitrary node features <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, <em>e.g.</em>, encoded row features.</p><h2 id="core-forecasting-framework">Core Forecasting Framework</h2><p>We formulate the core forecasting framework for a single time series <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> of an entity <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> as</p><p>where a function <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> predicts or generates the next time series value <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> given a set of conditioning signals <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, and <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>. The function <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, <em>e.g.</em>, modeled by a Multi-Layer Perceptron (MLP), is shared over all <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>. The conditioning signals serve specific purposes as follows.</p><div><p><img alt="" loading="lazy" width="1761" height="352" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F71df4bc5650b18caf1b27f8180f889f72bee5f0b-1761x352.png&amp;w=1920&amp;q=75 1x, /_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F71df4bc5650b18caf1b27f8180f889f72bee5f0b-1761x352.png&amp;w=3840&amp;q=75 2x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F71df4bc5650b18caf1b27f8180f889f72bee5f0b-1761x352.png&amp;w=3840&amp;q=75"/></p></div><p><strong>Architecture Overview. </strong>Data flow shown for one entity.<strong> </strong>The forecasting head unifies information from the graph, the past time series, temporal frequency encodings and calendar features. While past and graph encodings are given for the whole entity, the temporal encodings and calendar features are individual for each future prediction.</p><p><strong>Date-time encodings</strong>. To provide the model with information about the current date, current time, day of week, month of year, <em>etc</em>, frequency encodings <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> of several date-time values are provided to the model. Date-time encodings enable to correctly model seasonal effects.</p><p><strong>Calendar encodings</strong>. Embeddings <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> represent indicators given in calendar tables. These can be indicators for specific holidays or other special times, which could be relevant for the model. We find that providing such information explicitly improves the models ability to capture, <em>e.g.</em>, rare outlier days with specific characteristics. Embeddings <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> are processed by a 1-dimensional CNN before fed into <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> to allow the model to see a window of adjacent calendar information.</p><p><strong>Graph entity encodings. </strong>Embeddings <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span><strong> </strong>encode the subgraph around entity <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> obtained via temporal subgraph sampling according to the RDL formula. After neighbor sampling, the embeddings can be obtained with a Graph Transformer or Graph Neural Network on <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> and <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, as described in a dedicated section below. The entity subgraph conditioning allows the model to consider rich signals occurring in relational data.</p><p><strong>Past sequence encodings.</strong> Auto-regressive signals are important for any forecasting model. Thus, the past time series <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> for entity <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> is encoded into embedding <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> with a sequence encoder, <em>e.g.</em>, a Transformer, and provided to the model. The past sequence encoding allows the model to react to the current trend in the time series. We describe the past encoders in a dedicated section below.</p><h3 id="graph-encoding-via-graph-transformers">Graph Encoding via Graph Transformers</h3><p>The forecasting head <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> is conditioned on node embeddings <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> for each entity <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, respectively. A temporal neighbor sampler can be used to obtain subgraphs <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> with features <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> around entities <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, allowing to scale the approach to real world graphs. If temporal graphs are present (such as in the RDL context), subgraphs are sampled to only contain nodes with a timestamp smaller than current time <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, preventing data leakage from future information in the given graph. The subgraph can then be encoded with a Graph Transformer:</p><p>Graph Transformers employ graph positional encodings of the given graph <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, which allow a sequence Transformer architecture to process and understand the graph structure underlying individual node features <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>. For an in-depth discussion about Graph Transformers, check out our<a href="https://kumo.ai/research/introduction-to-graph-transformers/"> Graph Transformer blog post</a>.</p><h3 id="past-sequence-encoder">Past Sequence Encoder</h3><p>The past embedding <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> is another important conditioning for function <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>. Auto-regressive models have been shown to perform well in forecasting tasks, allowing the model to continue current trends in recently observed past values. To this end, we encode the past sequence <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> for each entity <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> with a past encoding network:</p><p>In theory, any sequence encoder can be used, such as transformers, convolutional neural networks (CNNs), or simple MLPs. We found that one-dimensional CNNs performing convolution over the temporal dimension provide a good trade-off between efficiency and accuracy.</p><h3 id="training">Training</h3><p>The above forecasting framework provides a deep learning architecture that can be trained in an end-to-end fashion on existing graphs with time series per entity. Naively, we can sample a specific time <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, apply temporal sampling to sample subgraphs with timestamp earlier than <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> and train the network to predict future values at time <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> by minimizing an MSE loss against ground truth time series values <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>:</p><h2 id="regression-vs.-generative-forecasting">Regression vs. Generative Forecasting</h2><p>At its core, time series forecasting is a probabilistic task due to ambiguities in the mapping from input signals/features to future value. Thus, it is reasonable to consider a more advanced framework than above, where we model distributions over random variables instead of a function:</p><p>Here, it is assumed that the future value follows some conditional distribution, from which we can obtain the most likely value or perform probabilistic inference via sampling.</p><p><strong>Forecasting via Regression.</strong> In the above framework, the function <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> is naively modeled with an Multi-Layer Perceptron (MLP) and trained to regress value <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> by minimizing a mean-squared error. This paradigm provides good forecast in an efficient manner. However, simple regression via MSE implicitly assumes <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> to be Gaussian and trains the model to predict the mean of that Gaussian, which is a conceptual limitation of the given framework. A result is that the naive regression head above is prone to mean collapse, potentially smoothing out higher frequency forecasts, especially if the actual distribution is far away from a Gaussian, <em>e.g.</em>, multi-modal.</p><p>In the past, forecasting research came up with alternatives, <em>e.g.</em>, optimizing the negative log likelihood of examples given a parameterized distribution, with distribution parameters predicted by the model. This allows to predict the full distribution instead of individual point estimates and provides additional outputs, such as quantile bands as a measure of uncertainty. Typically, this is used to model Gaussian distributions or alternatives for discrete forecasts like the Negative Binomial distribution. However, one crucial limitation remains: the given time series data needs to follow a parameterized distribution in the first place and that distribution needs to be assumed a priori.</p><p><strong>Generative Forecasting. </strong>Here, we explore an alternative probabilistic inference formulation based on recent research in <a href="https://arxiv.org/abs/2406.11838">continuous generative modeling</a>, concretely, conditional diffusion models. Instead of using a simple regression MLP <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, we use a diffusion head, which iteratively denoises a randomly initialized future time series, conditioned on the embeddings from above.</p><p>The diffusion head, modeled via a CNN, takes above conditionings <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>, <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> and iteratively denoises a noisy time-series. During training, we follow the common practice of a <a href="https://arxiv.org/abs/2006.11239">Denoising Diffusion Probabilistic Model (DDPM) schedule over 1000 steps</a>, adding noise to a future time series and training the model to predict the added noise. During inference, we start with a time-series randomly initialized from a Gaussian distribution and iteratively denoise it until obtaining a sample from the modeled distribution.</p><p>Modeling the time series forecasting task in this manner enables some interesting properties. Firstly, the trained model allows to sample values from <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span> without making any assumption on the form of <span><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></span>. We can sample multiple times and statistics can be obtained empirically, by extracting modes or providing quantile bands. We can obtain an empirical mean and variance, which would require again the assumption on the distribution type. However, we can also empirically extract modes or provide quantiles bands.</p><h2 id="forecasting-results">Forecasting Results</h2><p>In the following, we provide some example forecast for a task of predicting future visits in individual stores. We observe that the generative model is able to forecast higher frequency details and reacts better to rare events than the predictive forecasting baseline. In quantitative comparison both perform equally well, though.</p><div><p><img alt="" loading="lazy" width="1013" height="294" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fbdbb336c3990139b1cca9b119d0d229260cc54bd-1013x294.png&amp;w=1080&amp;q=75 1x, /_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fbdbb336c3990139b1cca9b119d0d229260cc54bd-1013x294.png&amp;w=2048&amp;q=75 2x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fbdbb336c3990139b1cca9b119d0d229260cc54bd-1013x294.png&amp;w=2048&amp;q=75"/></p></div><div><p><img alt="" loading="lazy" width="1013" height="294" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fb20fa890a423c6ddfd70d163397adff18cb2a1aa-1013x294.png&amp;w=1080&amp;q=75 1x, /_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fb20fa890a423c6ddfd70d163397adff18cb2a1aa-1013x294.png&amp;w=2048&amp;q=75 2x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fb20fa890a423c6ddfd70d163397adff18cb2a1aa-1013x294.png&amp;w=2048&amp;q=75"/></p></div><div><p><img alt="" loading="lazy" width="1013" height="294" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F155ff4b25c95935f9c03450709e77c52f2e307c2-1013x294.png&amp;w=1080&amp;q=75 1x, /_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F155ff4b25c95935f9c03450709e77c52f2e307c2-1013x294.png&amp;w=2048&amp;q=75 2x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F155ff4b25c95935f9c03450709e77c52f2e307c2-1013x294.png&amp;w=2048&amp;q=75"/></p></div><p><strong>Generative Forecasting Comparison. </strong>We compare predictive and generative forecasting results for three entities of a forecasting task, where our models make one prediction per day for the next 90 days in advance. While quantitatively both models perform similarly well, generative forecasting shows less mean collapse and captures some high frequency details better.</p><div><p><img alt="" loading="lazy" width="1013" height="294" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fcd04d2a35153d682b57e25fa23f4c3a979fccd8a-1013x294.png&amp;w=1080&amp;q=75 1x, /_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fcd04d2a35153d682b57e25fa23f4c3a979fccd8a-1013x294.png&amp;w=2048&amp;q=75 2x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2Fcd04d2a35153d682b57e25fa23f4c3a979fccd8a-1013x294.png&amp;w=2048&amp;q=75"/></p></div><div><p><img alt="" loading="lazy" width="1013" height="294" decoding="async" data-nimg="1" srcset="/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F1403456633bb96d5802921b0ca3ff1b7efb57f6a-1013x294.png&amp;w=1080&amp;q=75 1x, /_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F1403456633bb96d5802921b0ca3ff1b7efb57f6a-1013x294.png&amp;w=2048&amp;q=75 2x" src="https://kumo.ai/_next/image/?url=https%3A%2F%2Fcdn.sanity.io%2Fimages%2Fs3lh42f5%2Fproduction%2F1403456633bb96d5802921b0ca3ff1b7efb57f6a-1013x294.png&amp;w=2048&amp;q=75"/></p></div><p><strong>Comparison to Facebook Prophet. </strong>We compare our forecasting results against forecasts from Facebook Prophet. While Prophet also captures trend and seasonality mostly correct, it shows slightly more divergence and more mean collapse behavior.</p><h2 id="conclusion">Conclusion</h2><p>Time series forecasting has been and will continue to be an important task in machine learning for several different applications. In this blog post, we described how to design an end-to-end pipeline for forecasting on graph structures, performing forecasting on a subset of graph nodes while using input signals from the whole graph,<em> e.g.</em>, to combine data from multiple tables in a database. We also discussed the differences between point predictions and probabilistic forecasting using generative formulations, which we believe to be an interesting area for future investigation.</p><h3 id="further-resources">Further Resources</h3><p>If youâ€™re excited to dive deeper and start experimenting with forecasting on graphs or Graph Transformers on your own, <a href="https://pyg.org/">PyTorch Geometric (PyG)</a> is a great place to begin. Itâ€™s one of the most widely used libraries for building Graph Neural Networks and comes with built-in support for Graph Transformers. The <a href="https://pytorch-geometric.readthedocs.io/en/latest/?utm_source=chatgpt">official documentation</a> is packed with examples, and the <a href="https://pytorch-geometric.readthedocs.io/en/latest/tutorial/graph_transformer.html?highlight=transformers&amp;utm_source=chatgpt">Graph Transformer tutorial</a> walks you through building Transformer-based models on graphs.</p><p>Also make sure to check out our <a href="https://kumo.ai/research/relational-deep-learning-rdl/">Relational Deep Learning</a> framework, which allows to directly apply Graph Neural Networks and Graph Transformers to relational data, and <a href="https://relbench.stanford.edu/">RelBench</a>, a unified evaluation framework for a wide arrange of practical analytics tasks.</p></div></div>
  </body>
</html>
