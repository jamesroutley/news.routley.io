<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eta.st/2021/06/20/showtime.html">Original</a>
    <h1>Sending audio to LKV373 HDMI extenders (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>My <a href="https://benjojo.co.uk/">current flatmate</a> has a bunch of these <a href="https://blog.benjojo.co.uk/post/cheap-hdmi-capture-for-linux">HDMI extender devices</a>
(also apparently known as “LKV373” / “Lenkeng extenders” / “LK-3080-ACL”). They’re pretty nifty: HDMI goes in one end, they emit UDP over ethernet,
and then HDMI comes out on the receiver end with surprisingly minimal latency (around 100ms).</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/extender-3.jpg" alt="photo of an extender"/></p>

<p><em>image: the receiver end of a transmitter-receiver pair, taken by said flatmate</em></p>

<p>A couple months ago we decided it’d be quite nifty to be able to play arbitrary audio out of the devices without having to plug a transmitter into someone’s
laptop – so that we could have BBC Radio 4 or something constantly playing whenever the sound system is turned on.</p>

<p>My flatmate’s blog post, <a href="https://blog.benjojo.co.uk/post/cheap-hdmi-capture-for-linux">“Ludicrously cheap HDMI capture for Linux”</a>, outlined a way to
<em>decode</em> the signal the transmitters sent (using his own tool, 
<a href="https://github.com/benjojo/de-ip-hdmi"><code>de-ip-hdmi</code></a>). But could we do the opposite,
and <em>encode</em> signals the receivers would accept?</p>

<h2 id="testing-without-the-actual-devices">Testing without the actual devices</h2>

<p>I figured I’d start by looking at <code>de-ip-hdmi</code>’s source code to see how it
decoded the packets and then use it as a way to test the output of my
custom sender until it was able to decode what I was sending. It’s pretty
unlikely that I’d just be able to send audio without also sending a picture,
so I tried to figure out the picture format first.</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/sharked-sequences.png" alt="video picture packet format"/></p>

<p>The video picture packets have a fairly simple format: two big-endian, 16-bit
integers (frame number, and sequence number), and then data, up to 1020 bytes
(making UDP packets with a 1024-byte payload, total).</p>

<p>Extracting the output from <code>de-ip-hdmi</code> with a transmitter running
confirms that the data is just a JPEG:</p>

<div><div><pre><code>$ file test.mjpeg 
test.mjpeg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 1920x1080, components 3
</code></pre></div></div>

<p>The frame number counts
monotonically up from 0, incrementing with each new frame. Since you’re not
going to fit a whole JPEG frame in 1020 bytes, the sequence number provides a way of
splitting the frame up into multiple chunks; you increment it for each chunk
you send within a frame, while keeping the frame number constant.</p>

<p>The <code>de-ip-hdmi</code> <a href="https://github.com/benjojo/de-ip-hdmi/blob/0bdfab96c7fbe8819977846e402c56a0b7660b47/main.go#L117">source code to decode</a>
looks like this:</p>

<figure><pre><code data-lang="go"><span>// taken from the de-ip-hdmi source code, in Go</span>
<span>FrameNumber</span> <span>:=</span> <span>uint16</span><span>(</span><span>0</span><span>)</span>
<span>CurrentChunk</span> <span>:=</span> <span>uint16</span><span>(</span><span>0</span><span>)</span>

<span>buf</span> <span>:=</span> <span>bytes</span><span>.</span><span>NewBuffer</span><span>(</span><span>ApplicationData</span><span>[</span><span>:</span><span>2</span><span>])</span>
<span>buf2</span> <span>:=</span> <span>bytes</span><span>.</span><span>NewBuffer</span><span>(</span><span>ApplicationData</span><span>[</span><span>2</span><span>:</span><span>4</span><span>])</span>
<span>binary</span><span>.</span><span>Read</span><span>(</span><span>buf</span><span>,</span> <span>binary</span><span>.</span><span>BigEndian</span><span>,</span> <span>&amp;</span><span>FrameNumber</span><span>)</span>
<span>binary</span><span>.</span><span>Read</span><span>(</span><span>buf2</span><span>,</span> <span>binary</span><span>.</span><span>BigEndian</span><span>,</span> <span>&amp;</span><span>CurrentChunk</span><span>)</span>

<span>// does stuff with ApplicationData[4:]</span></code></pre></figure>

<p>Seems simple enough. I wrote a small Rust <code>struct</code> that could chunk up a
slice of bytes into 1024-byte vectors that fit this format:</p>

<figure><pre><code data-lang="rust"><span>struct</span> <span>FrameChunker</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
    <span>inner</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>[</span><span>u8</span><span>],</span> <span>// the data to send</span>
    <span>frame_no</span><span>:</span> <span>u16</span><span>,</span> <span>// frame number</span>
    <span>seq_no</span><span>:</span> <span>u16</span> <span>// sequence number</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>FrameChunker</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>{</span>
    <span>// constructor emitted for brevity</span>

    <span>// get a new 1024 (or less)-byte chunk to send</span>
    <span>fn</span> <span>next_chunk</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>ret</span> <span>=</span> <span>Vec</span><span>::</span><span>with_capacity</span><span>(</span><span>1024</span><span>);</span>
        <span>let</span> <span>(</span><span>remaining</span><span>,</span> <span>last</span><span>)</span> <span>=</span> <span>if</span> <span>self</span><span>.inner</span><span>.len</span><span>()</span> <span>&gt;</span> <span>1020</span> <span>{</span>
            <span>(</span><span>1020</span><span>,</span> <span>false</span><span>)</span>
        <span>}</span>
        <span>else</span> <span>{</span>
            <span>(</span><span>self</span><span>.inner</span><span>.len</span><span>(),</span> <span>true</span><span>)</span>
        <span>};</span>
        <span>// this is from the `byteorder` crate&#39;s `WriteBytesExt` trait</span>
        <span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>self</span><span>.frame_no</span><span>)</span><span>.unwrap</span><span>();</span>
        <span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>self</span><span>.seq_no</span><span>)</span><span>.unwrap</span><span>();</span>
        <span>ret</span><span>.extend</span><span>(</span><span>&amp;</span><span>self</span><span>.inner</span><span>[</span><span>..</span><span>remaining</span><span>]);</span>
        <span>self</span><span>.inner</span> <span>=</span> <span>&amp;</span><span>self</span><span>.inner</span><span>[</span><span>remaining</span><span>..</span><span>];</span>
        <span>self</span><span>.seq_no</span> <span>+=</span> <span>1</span><span>;</span>
        <span>ret</span>
    <span>}</span>

    <span>// returns true if we&#39;re done transmitting the current frame;</span>
    <span>// used to know when to send the next one</span>
    <span>fn</span> <span>is_empty</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>bool</span> <span>{</span>
        <span>self</span><span>.inner</span><span>.is_empty</span><span>()</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>I then made a little 1920×1080 all white JPEG in GIMP, wrote it to a file, and
wrote some code to send out UDP multicast packets in the format the receiver
(and <code>de-ip-hdmi</code>) would expect:</p>

<figure><pre><code data-lang="rust"><span>// The magic IPv4 address for the multicast group the transmitter would send</span>
<span>// to.</span>
<span>const</span> <span>MAGIC_ADDRESS</span><span>:</span> <span>Ipv4Addr</span> <span>=</span> <span>Ipv4Addr</span><span>::</span><span>new</span><span>(</span><span>226</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>);</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// load the test image data in at compile-time</span>
    <span>let</span> <span>test_data</span> <span>=</span> <span>include_bytes!</span><span>(</span><span>&#34;../white.mjpeg&#34;</span><span>);</span>

    <span>// make a UDP socket for sending</span>
    <span>// note: this requires creating an interface with this address</span>
    <span>let</span> <span>mjpeg</span> <span>=</span> <span>UdpSocket</span><span>::</span><span>bind</span><span>(</span><span>&#34;192.168.168.55:2068&#34;</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>// destination address:port for video picture data</span>
    <span>let</span> <span>mjpeg_dest</span><span>:</span> <span>SocketAddr</span> <span>=</span> <span>&#34;226.2.2.2:2068&#34;</span><span>.parse</span><span>()</span><span>.unwrap</span><span>();</span>

    <span>// join the multicast group</span>
    <span>mjpeg</span><span>.join_multicast_v4</span><span>(</span><span>&amp;</span><span>MAGIC_ADDRESS</span><span>,</span> <span>&amp;</span><span>&#34;192.168.168.55&#34;</span><span>.parse</span><span>()</span><span>.unwrap</span><span>())</span><span>.unwrap</span><span>();</span>

    <span>// current frame number</span>
    <span>let</span> <span>mut</span> <span>frame_no</span> <span>=</span> <span>0</span><span>;</span>
    <span>loop</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>chonker</span> <span>=</span> <span>FrameChunker</span><span>::</span><span>new</span><span>(</span><span>frame_no</span><span>,</span> <span>image</span><span>);</span>
        <span>while</span> <span>!</span><span>chonker</span><span>.is_empty</span><span>()</span> <span>{</span>
            <span>let</span> <span>buf</span> <span>=</span> <span>chonker</span><span>.next_chunk</span><span>();</span>
            <span>mjpeg</span><span>.send_to</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>mjpeg_dest</span><span>)</span><span>.unwrap</span><span>();</span>
        <span>}</span>
        <span>frame_no</span> <span>+=</span> <span>1</span><span>;</span>

        <span>::</span><span>std</span><span>::</span><span>thread</span><span>::</span><span>sleep_ms</span><span>(</span><span>33</span><span>);</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<p>I added a suitable network interface for the sender to use (the actual flat networking
setup uses <a href="https://en.wikipedia.org/wiki/Virtual_LAN">VLAN</a>s for the HDMI
traffic, but I found out that if you just want to test then adding a loopback interface also
works):</p>

<div><div><pre><code>$ sudo ip link add link enp5s0f3u1u1 name showtime0 type vlan id 1024
$ sudo ip link set dev showtime0 address 00:0b:78:00:60:01
$ sudo ip addr add 192.168.168.55/32 dev showtime0
</code></pre></div></div>

<p>With much anticipation I then ran the code for the first time, with <code>de-ip-hdmi</code>
running in parallel – and got…nothing.</p>

<h3 id="adventures-in-bitshifting">Adventures in bitshifting</h3>

<p>Turns out I forgot something else in the packet format: a way to signal the
last chunk in a series of chunks for a frame. Going back to <code>de-ip-hdmi</code>:</p>

<figure><pre><code data-lang="go"><span>if</span> <span>uint16</span><span>(</span><span>^</span><span>(</span><span>CurrentChunk</span> <span>&gt;&gt;</span> <span>15</span><span>))</span> <span>==</span> <span>65534</span> <span>{</span>
	<span>// Flush the frame to output</span>
	<span>// [code snipped]</span>

	<span>CurrentPacket</span> <span>=</span> <span>Frame</span><span>{}</span>
	<span>CurrentPacket</span><span>.</span><span>Data</span> <span>=</span> <span>make</span><span>([]</span><span>byte</span><span>,</span> <span>0</span><span>)</span>
	<span>CurrentPacket</span><span>.</span><span>FrameID</span> <span>=</span> <span>0</span>
	<span>CurrentPacket</span><span>.</span><span>LastChunk</span> <span>=</span> <span>0</span>
<span>}</span>    </code></pre></figure>

<p>What the heck is <code>uint16(^(CurrentChunk &gt;&gt; 15)) == 65534</code> doing? Let’s break
that down:</p>

<ul>
  <li>it shifts <code>CurrentChunk</code> to the right by 15 bits, discarding all bits apart
from the most significant bit (MSB), which becomes the new least significant
bit (LSB).</li>
  <li>unary <code>^</code> (caret) is the Go “logical NOT” operator, so we flip all of the
bits in the result above</li>
  <li><code>65534</code> is a 16-bit integer with every bit set except the LSB</li>
</ul>

<p><img src="https://www.datadoodad.com/assets/img/showtime/bitshift.png" alt="bit shift diagrammatic explanation"/></p>

<p>So… this is a <a href="https://mobile.twitter.com/Benjojo12/status/1400616243300872193">very long-winded</a>
way of checking whether the MSB of
<code>CurrentChunk</code> is equal to 1 (in Rust, <code>(number &amp; 0b1000_0000_0000_0000) &gt; 0</code>).
Accordingly, we need to set the MSB to 1 to denote the end of a frame, so
let’s do that in the <code>FrameChunker</code>:</p>

<figure><pre><code data-lang="rust"><span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>self</span><span>.frame_no</span><span>)</span><span>.unwrap</span><span>();</span>
<span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>self</span><span>.seq_no</span><span>)</span><span>.unwrap</span><span>();</span>
<span>if</span> <span>last</span> <span>{</span>
    <span>// it&#39;s big-endian, so ret[2] contains the most significant</span>
    <span>// 8 bits of the 16-bit integer</span>
    <span>ret</span><span>[</span><span>2</span><span>]</span> <span>|</span><span>=</span> <span>0b1000_0000</span><span>;</span>
<span>}</span></code></pre></figure>

<h3 id="partial-victory">Partial victory!</h3>

<p>With this change applied <code>de-ip-hdmi</code> would decode our image! Yay!</p>

<video controls="" autoplay="" loop="" muted="">
    <source src="/assets/img/showtime/deip.mp4" type="video/mp4"/>

    Sorry, your browser doesn&#39;t support embedded videos.
</video>

<p>However, the real transmitter wasn’t having any of it; it refused to display a
picture (behaving as if it couldn’t see any transmitters; it says “Searching
TX” when this happens).</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/searching-tx.png" alt="&#34;Searching TX&#34; display"/></p>

<p>Hmm.</p>

<h2 id="lets-do-the-wireshark-again">Let’s do the Wireshark again</h2>

<p>I connected a real transmitter and dumped some of the packets it sends using
<a href="https://www.wireshark.org/">Wireshark</a>. Turns out there’s more stuff you need
to do.</p>

<h3 id="mysterious-packets-on-port-2067">Mysterious packets on port 2067</h3>

<p>Here’s a screenshot of some of the packets the real transmitter sends.</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/tasty-packet.png" alt="wireshark screenshot"/></p>

<ul>
  <li>the (source port) 2065 → (destination port) 2066 packets are audio data.
We’ll get to those later!</li>
  <li>the 2068 → 2068 packets are video picture data</li>
  <li>…but what are these 2067 → 2067 packets?</li>
</ul>

<p><img src="https://www.datadoodad.com/assets/img/showtime/2067-1.png" alt="2067 packet 1"/></p>

<p>Hmm, it’s all zeroes. What about the next one?</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/2067-2.png" alt="2067 packet 2"/></p>

<p>Aha, a byte went from 00 to 01!</p>

<p>Turns out this pattern continues; before each picture frame is sent, an
additional packet is sent on port 2067 of length 20, with the 5th and 6th
bytes being a 16-bit big-endian integer, which is the same as the frame
number of the frame we just sent.</p>

<p>I’m guessing this is a sort of <a href="https://en.wikipedia.org/wiki/Vertical_blanking_interval">“vsync” / “vblank” packet</a>,
used to tell the
receiver to get ready for a new frame.
We should probably replicate it, so I wrote some code:</p>

<figure><pre><code data-lang="rust"><span>fn</span> <span>make_vsync</span><span>(</span><span>frame_no</span><span>:</span> <span>u16</span><span>)</span> <span>-&gt;</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>ret</span> <span>=</span> <span>Vec</span><span>::</span><span>with_capacity</span><span>(</span><span>20</span><span>);</span>
    <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>frame_no</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>14</span> <span>{</span>
        <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>}</span>
    <span>ret</span>
<span>}</span>
<span>// code to send this to port 2066 before sending frame packets elided</span></code></pre></figure>

<p>Alas, this was not enough. The receiver continued to say “Searching TX”.</p>

<h2 id="heartbeat-packets">Heartbeat packets</h2>

<p><img src="https://www.datadoodad.com/assets/img/showtime/heartbeat-list.png" alt="heartbeat packet list"/></p>

<p>There are also some weird 512-byte payloads being sent on port 48689. These
are easy to miss because they’re only sent once every second (and so are
comparatively infrequent relative to the firehose of data the transmitters
send for pictures and video). However, you can notice them by looking at
the start of a packet capture since they get sent even when no picture
data is being sent.</p>

<p>Let’s look at a dump of some of these packet payloads over time (using
“[right click] Follow → UDP Stream” in Wireshark):</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/heartbeat.png" alt="heartbeat packet diagram"/></p>

<p>After squinting at it for a while, you notice a few things:</p>

<ul>
  <li>The first three packets are identical, apart from a small 2-byte region that
carries on going up with each new packet (marked in red), and a sequence
number incremented with each new packet (marked in pink).</li>
  <li>Between the third and fourth packets, a large chunk of data (marked in blue)
changes to something else (marked in green), and then stays that way.</li>
  <li>This change is also correlated with the video and audio starting.</li>
  <li>After the change happens the packets stay identical apart from the counter.</li>
</ul>

<p>This must be some kind of heartbeat packet sent by the transmitter to tell
the receiver that it’s there. Let’s try and figure out the various bits
in the payload in more detail.</p>

<h3 id="incrementing-counter">Incrementing counter</h3>

<p>How is this counter being generated? Well, let’s assume that
it’s a 16-bit big-endian integer, since
everything else in this blog post has been that, and interpret the values
accordingly.</p>

<ul>
  <li><code>0x0458</code> is 1112, sent at time <em>t</em> = 0.0</li>
  <li><code>0x0842</code> is 2114 (delta = 1002), sent at <em>t</em> = 1.001</li>
  <li><code>0x0c2b</code> is 3115 (delta = 1001), sent at <em>t</em> = 2.002</li>
  <li><code>0x0ee5</code> is 3813 (delta = 698), sent at <em>t</em> = 2.700</li>
</ul>

<p><em>Hmm…</em></p>

<p>I think it’s pretty reasonable to assume this counter just tracks time since
the transmitter was powered on. <em>Why</em> the receiver needs that information
isn’t exactly clear though (maybe for some synchronization purposes?).</p>

<p>Anyway, we should probably do the same as the transmitter when sending our
own packets here so we’ll add a timer to the code.</p>

<h3 id="other-gubbins">Other gubbins</h3>

<p>We have two sets of weird data:</p>

<ul>
  <li><code>00 03 07 80 04 38 02 57 07 80 04 38 00 78 03</code> (when the HDMI port is active)</li>
  <li><code>00 10 00 00 00 00 00 00 00 00 00 00 00 78 00</code> (when it isn’t)</li>
</ul>

<p><code>07 80</code> and <code>04 38</code> are repeated multiple times. Let’s try decoding those
as 16-bit big-endian integers:</p>

<ul>
  <li><code>0x0780</code> is 1920</li>
  <li><code>0x0438</code> is 1080</li>
</ul>

<p>That seems familiar; isn’t 1920×1080 the resolution for <a href="https://en.wikipedia.org/wiki/1080p">1080p</a>?
This data is presumably used to initialize the HDMI port on the other end.</p>

<p>What about when the HDMI is off? Well, it looks like most of the
fields are just zeroed out, which makes sense since it doesn’t have a resolution
or anything to send yet.
(This causes the message “Check Tx’s input signal” to appear on the receiver, which
is useful for debugging why the receiver isn’t displaying anything.)</p>

<p>In the end, I just encoded all of this data as constants (interpreting it
as a set of 16-bit big endian integers), sending one set (the one with 1920s
in it) if we’re ready to send data, and another set (the zeroed out set)
if we aren’t.</p>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>The code to make a heartbeat packet ended up looking like this:</p>

<figure><pre><code data-lang="rust"><span>fn</span> <span>make_heartbeat</span><span>(</span><span>seq_no</span><span>:</span> <span>u16</span><span>,</span> <span>cur_ts</span><span>:</span> <span>u16</span><span>,</span> <span>init</span><span>:</span> <span>bool</span><span>)</span> <span>-&gt;</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>ret</span> <span>=</span> <span>Vec</span><span>::</span><span>with_capacity</span><span>(</span><span>512</span><span>);</span>
    <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0x54</span><span>,</span> <span>0x46</span><span>,</span> <span>0x36</span><span>,</span> <span>0x7a</span><span>,</span> <span>0x63</span><span>,</span> <span>0x01</span><span>,</span> <span>0x00</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>seq_no</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x03</span><span>,</span> <span>0x03</span><span>,</span> <span>0x03</span><span>,</span> <span>0x00</span><span>,</span> <span>0x24</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>8</span> <span>{</span>
        <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>}</span>
    <span>// woohoo, magic numbers</span>
    <span>let</span> <span>(</span><span>mode</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>,</span> <span>d</span><span>,</span> <span>e</span><span>,</span> <span>f</span><span>,</span> <span>other</span><span>)</span> <span>=</span> <span>if</span> <span>init</span> <span>{</span>
        <span>(</span><span>3</span><span>,</span> <span>1920</span><span>,</span> <span>1080</span><span>,</span> <span>599</span><span>,</span> <span>1920</span><span>,</span> <span>1080</span><span>,</span> <span>120</span><span>,</span> <span>3</span><span>)</span>
    <span>}</span>
    <span>else</span> <span>{</span>
        <span>(</span><span>16</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>120</span><span>,</span> <span>0</span><span>)</span>
    <span>};</span>
    <span>for</span> <span>thing</span> <span>in</span> <span>&amp;</span><span>[</span><span>mode</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>,</span> <span>d</span><span>,</span> <span>e</span><span>,</span> <span>f</span><span>]</span> <span>{</span>
        <span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>*</span><span>thing</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>}</span>
    <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>,</span> <span>0</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>ret</span><span>.write_u16</span><span>::</span><span>&lt;</span><span>BigEndian</span><span>&gt;</span><span>(</span><span>cur_ts</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>other</span><span>,</span> <span>0x0a</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>for</span> <span>_</span> <span>in</span> <span>ret</span><span>.len</span><span>()</span><span>..</span><span>512</span> <span>{</span>
        <span>ret</span><span>.write_all</span><span>(</span><span>&amp;</span><span>[</span><span>0</span><span>])</span><span>.unwrap</span><span>();</span>
    <span>}</span>
    <span>assert_eq!</span><span>(</span><span>ret</span><span>.len</span><span>(),</span> <span>512</span><span>);</span>
    <span>ret</span>
<span>}</span></code></pre></figure>

<p>Putting it all together and sending heartbeat packets, vsync packets, and
the actual picture data… got the receiver to initialize, but output a black rectangle
instead of the test image.</p>

<video controls="" autoplay="" loop="" muted="">
    <source src="/assets/img/showtime/blackscreen.mp4" type="video/mp4"/>

    Sorry, your browser doesn&#39;t support embedded videos.
</video>

<p>After trying many other things, I eventually tried sending the original <code>test.mjpeg</code> file
I’d dumped from the receiver when first trying to get this to work, instead of my own
JPEG that I made in GIMP. That actually produced some output!</p>

<video controls="" autoplay="" loop="" muted="">
    <source src="/assets/img/showtime/functional.mp4" type="video/mp4"/>

    Sorry, your browser doesn&#39;t support embedded videos.
</video>

<p>Yay!</p>

<p><em>(the test image was produced by writing some text on a laptop, making it full-screen, and connecting it to the transmitter)</em></p>

<h2 id="but-what-about-audio">But what about audio?</h2>

<p>While this is (somewhat) useful, it doesn’t do what we originally wanted; what about actually sending audio?</p>

<h3 id="how-does-digital-audio-work-anyway">How does digital audio work, anyway?</h3>

<p>Digital audio is represented as a series of <a href="https://en.wikipedia.org/wiki/Sampling_(signal_processing)"><em>samples</em></a> – individual measurements
of what the voltage of your speaker should be at a given point in time (the “signal”), taken at a given <em>sampling rate</em> that’s high enough to provide
a decent approximation of what the speaker should be doing to reproduce your favourite tunes.</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/sampling.png" alt="sampling visualization"/></p>

<p><em>image: sourced from the above linked Wikipedia article, CC0</em></p>

<p>There are a number of important variables involved in this process that we need to know in order to send and receive audio in a given format:</p>

<ul>
  <li>what the sample rate was (measured in Hertz, aka “times per second”)</li>
  <li>how the samples are stored (as floating-point numbers? as signed integers? how many bits?)</li>
  <li>what the “maximum” and “minimum” values are (for floats, we typically use <code>1.0</code> and <code>-1.0</code>; integer formats use <code>INT_MAX</code> and <code>INT_MIN</code>)</li>
</ul>

<h3 id="what-format-do-the-extenders-use">What format do the extenders use?</h3>

<p><code>de-ip-hdmi</code> has already figured this out for us:</p>

<figure><pre><code data-lang="go"><span>if</span> <span>audio</span> <span>{</span>
    <span>ffmpeg</span> <span>=</span> <span>exec</span><span>.</span><span>Command</span><span>(</span><span>&#34;ffmpeg&#34;</span><span>,</span> <span>&#34;-f&#34;</span><span>,</span> <span>&#34;mjpeg&#34;</span><span>,</span> <span>&#34;-i&#34;</span><span>,</span> <span>uuidpath</span><span>,</span> <span>&#34;-f&#34;</span><span>,</span> <span>&#34;s32be&#34;</span><span>,</span> <span>&#34;-ac&#34;</span><span>,</span> <span>&#34;2&#34;</span><span>,</span> <span>&#34;-ar&#34;</span><span>,</span> <span>&#34;44100&#34;</span><span>,</span> <span>&#34;-i&#34;</span><span>,</span> <span>&#34;pipe:0&#34;</span><span>,</span> <span>&#34;-f&#34;</span><span>,</span> <span>&#34;matroska&#34;</span><span>,</span> <span>&#34;-codec&#34;</span><span>,</span> <span>&#34;copy&#34;</span><span>,</span> <span>&#34;pipe:1&#34;</span><span>)</span>
<span>}</span></code></pre></figure>

<p>This is a <a href="https://www.ffmpeg.org/">ffmpeg</a> command line that <code>de-ip-hdmi</code> uses to wrap the data from the extenders in a <a href="https://en.wikipedia.org/wiki/Matroska">Matroska container</a>
(a way of combining audio and images together into one video file). We can tell a few things from this:</p>

<ul>
  <li><code>-f s32be</code>: the samples are stored as signed 32-bit big-endian integers
    <ul>
      <li>this uses <code>i32::MIN</code> and <code>i32::MAX</code> as minimum/maximum (i.e. -2147483648 and 2147483647)</li>
    </ul>
  </li>
  <li><code>-ac 2</code>: there are 2 audio channels
    <ul>
      <li>the samples from each channel will be <a href="https://en.wikipedia.org/wiki/Interleaving_(data)">interleaved</a>, since we just have one big audio stream</li>
    </ul>
  </li>
  <li><code>-ar 44100</code>: the sample rate is 44100 Hz</li>
</ul>

<p>It looks like <code>de-ip-hdmi</code> just treats everything after the 16th byte as a set of samples in the above format:</p>

<figure><pre><code data-lang="go"><span>// Maybe there is some audio data on port 2066?</span>
<span>if</span> <span>pkt</span><span>.</span><span>Data</span><span>[</span><span>36</span><span>]</span> <span>==</span> <span>0x08</span> <span>&amp;&amp;</span> <span>pkt</span><span>.</span><span>Data</span><span>[</span><span>37</span><span>]</span> <span>==</span> <span>0x12</span> <span>&amp;&amp;</span> <span>*</span><span>output_mkv</span> <span>&amp;&amp;</span> <span>*</span><span>audio</span> <span>{</span>
    <span>select</span> <span>{</span>
    <span>case</span> <span>audiodis</span> <span>&lt;-</span> <span>ApplicationData</span><span>[</span><span>16</span><span>:</span><span>]</span><span>:</span>
    <span>default</span><span>:</span>
    <span>}</span>
    
    <span>continue</span>
<span>}</span></code></pre></figure>

<p>Going back to our Wireshark dump, the first 16 bytes of every audio packet seem to be identical (and the packets are always 1008
bytes long):</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/audiohdr.png" alt="audio header in wireshark"/></p>

<p>So, to send audio data we should in theory be able to write the header and then 992 (1008 - 16) bytes worth of samples into a packet
and send it as UDP from port 2065 to port 2066.</p>

<p>However, how frequently should we send the packets?</p>

<h3 id="timing-is-everything">Timing is everything</h3>

<p>We need to provide <code>44100 × 2 = 88200</code> samples each second, since we have 2 audio channels at 44100 Hz sample rate. Each packet of audio
contains 996 bytes of samples at 32 bits (= 4 bytes) per sample, so <code>992 / 4 = 248</code> samples fit in a packet.</p>

<p>That means we need to send a packet every <code>248 / 88200</code> seconds, or roughly <strong>2.812 milliseconds</strong> (to 3 decimal places) – which seems to line
up with the frequency observed in the Wireshark dump:</p>

<p><img src="https://www.datadoodad.com/assets/img/showtime/audiointerval.png" alt="audio intervals in wireshark"/></p>

<p><em>(e.g. 2.9222 s - 2.9195 s = 2.7ms, 2.9251s - 2.9222s = 2.9ms, etc)</em></p>

<hr/>

<p>I wrote up some sample code that read samples from <code>stdin</code> (fed in using ffmpeg) and sent a packet, then slept for 2812 nanoseconds, and then repeated.
This resulted in…complete silence!</p>

<p>That is, until we changed the device connected to the HDMI receiver unit (a hifi system with HDMI passthrough) to another device (a projector).
The projector happily played the audio we were sending… but it sounded distorted (kinda “crunchy” sounding). What’s going on?</p>

<h3 id="jitter-is-unacceptable">Jitter is unacceptable</h3>

<p>A while ago, I wrote some audio code for a project called <a href="https://git.eta.st/eta/sqa">“SQA”</a>. This taught me one of the ‘cardinal rules’
of audio programming: jitter is unacceptable. There’s a great blog post called 
<a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">“Real-time audio programming 101: time waits for nothing”</a> that
explains this in more detail but to sum up: when supplying audio samples for playback, you have a fixed amount of time to fill a buffer of a certain size,
and you must <em>always</em> fill the buffer in the time given to you (or less).</p>

<p>If you leave the buffer half-filled the audio will “glitch”: it’ll have pops and clicks in it and/or sound distorted, because the new samples you’ve
only half written will stop halfway through the playback buffer and jump suddenly to a bunch of zeroes instead (or some other garbage data). This is called
a buffer under/overrun, or an <em>xrun</em> for short.</p>

<p>So, how do you make sure you never glitch? Well, doing anything that could block or take lots of time to complete (reading from a file, waiting on a mutex,
etc.) in the thread that handles audio is strictly forbidden; you’ve basically got to have something else put the audio samples in a <a href="https://en.wikipedia.org/wiki/Circular_buffer">ringbuffer</a>
for you to copy out
in the audio thread.</p>

<h2 id="final-audio-thread-code">Final audio thread code</h2>

<p>Armed with the above knowledge, I completely rewrote the audio thread – and it actually works!</p>

<p>It now uses the excellent <a href="https://crates.io/crates/bounded_spsc_queue"><code>bounded_spsc_queue</code></a> ringbuffer library to ship samples from the rest of the program
and the audio thread, and <a href="https://en.wikipedia.org/wiki/Busy_waiting">spin-waits</a> (loops) until it needs to send the next packet.
(Doing the “proper” thing and using something like <a href="https://linux.die.net/man/2/nanosleep"><code>nanosleep(2)</code></a> would be more efficient – but was unreliable
compared to just spinning in my tests.)</p>

<p>The full audio thread code is below:</p>

<figure><pre><code data-lang="rust"><span>fn</span> <span>audio_thread</span><span>(</span><span>udp</span><span>:</span> <span>UdpSocket</span><span>,</span> <span>dest</span><span>:</span> <span>SocketAddr</span><span>,</span> <span>queue</span><span>:</span> <span>Consumer</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>pkt</span> <span>=</span> <span>[</span><span>0u8</span><span>;</span> <span>1008</span><span>];</span>
    <span>// Pre-write the header on to the packet.</span>
    <span>for</span> <span>(</span><span>i</span><span>,</span> <span>b</span><span>)</span> <span>in</span> <span>[</span><span>0</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0x55</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span><span>.iter</span><span>()</span><span>.enumerate</span><span>()</span> <span>{</span>
        <span>pkt</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>*</span><span>b</span><span>;</span>
    <span>}</span>
    <span>let</span> <span>now</span> <span>=</span> <span>Instant</span><span>::</span><span>now</span><span>();</span>
    <span>// Monotonic nanosecond counter.</span>
    <span>let</span> <span>cur_nanos</span> <span>=</span> <span>||</span> <span>{</span>
        <span>Instant</span><span>::</span><span>now</span><span>()</span><span>.duration_since</span><span>(</span><span>now</span><span>)</span><span>.as_micros</span><span>()</span>
    <span>};</span>
    <span>// 2.812 milliseconds!</span>
    <span>const</span> <span>INTERVAL</span><span>:</span> <span>u128</span> <span>=</span> <span>2812</span><span>;</span>
    <span>// Next time (on the counter) we need to send a packet.</span>
    <span>let</span> <span>mut</span> <span>next</span> <span>=</span> <span>INTERVAL</span><span>;</span>
    <span>// Current buffer pointer.</span>
    <span>let</span> <span>mut</span> <span>ptr</span> <span>=</span> <span>16</span><span>;</span>
    <span>// Consecutive Xrun counter.</span>
    <span>let</span> <span>mut</span> <span>num_xruns</span> <span>=</span> <span>0</span><span>;</span>
    <span>loop</span> <span>{</span>
        <span>let</span> <span>cur</span> <span>=</span> <span>cur_nanos</span><span>();</span>
        <span>if</span> <span>cur</span> <span>&gt;=</span> <span>next</span> <span>{</span>
            <span>// Send the packet.</span>
            <span>udp</span><span>.send_to</span><span>(</span><span>&amp;</span><span>pkt</span><span>,</span> <span>&amp;</span><span>dest</span><span>)</span><span>.unwrap</span><span>();</span>
            <span>// Check if we managed to fill the buf; if not, we&#39;ve xrun&#39;d.</span>
            <span>if</span> <span>ptr</span> <span>!=</span> <span>1008</span> <span>{</span>
                <span>num_xruns</span> <span>+=</span> <span>1</span><span>;</span>
            <span>}</span>
            <span>else</span> <span>{</span>
                <span>// Reset the pointer.</span>
                <span>ptr</span> <span>=</span> <span>16</span><span>;</span>
                <span>num_xruns</span> <span>=</span> <span>0</span><span>;</span>
            <span>}</span>
            <span>// Advance the deadline so it&#39;s 2.8ms after the previous one.</span>
            <span>// We skip over if we&#39;re already going to miss it.</span>
            <span>while</span> <span>cur</span> <span>&gt;=</span> <span>next</span> <span>{</span>
                <span>next</span> <span>+=</span> <span>INTERVAL</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// Okay, now time to fill the buffer a bit.</span>
        <span>if</span> <span>ptr</span> <span>&lt;</span> <span>1008</span> <span>{</span>
            <span>if</span> <span>num_xruns</span> <span>&gt;</span> <span>5</span> <span>{</span>
                <span>// Let&#39;s just fill it up with silence instead.</span>
                <span>// (otherwise you get a buzzing effect that&#39;s highly irritating)</span>
                <span>pkt</span><span>[</span><span>ptr</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
                <span>ptr</span> <span>+=</span> <span>1</span><span>;</span>
            <span>}</span>
            <span>else</span> <span>{</span>
                <span>if</span> <span>let</span> <span>Some</span><span>(</span><span>smpl</span><span>)</span> <span>=</span> <span>queue</span><span>.try_pop</span><span>()</span> <span>{</span>
                    <span>pkt</span><span>[</span><span>ptr</span><span>]</span> <span>=</span> <span>smpl</span><span>;</span>
                    <span>ptr</span> <span>+=</span> <span>1</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>else</span> <span>{</span>
            <span>::</span><span>std</span><span>::</span><span>thread</span><span>::</span><span>yield_now</span><span>();</span>
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre></figure>

<h2 id="conclusions">Conclusions</h2>

<p>The code is <a href="https://git.eta.st/eta/showtime">here</a>. Don’t expect miracles.
(If you actually plan to use this, you might want to <a href="https://www.datadoodad.com/#contact">get in touch</a>.)</p>

<p>There are a number of ways to feed data into it, which you choose at compile time using <a href="https://doc.rust-lang.org/cargo/reference/features.html">Cargo features</a>.
You can either feed in raw s32be samples from
either stdin or TCP (it’ll make a TCP server and you can connect and send stuff, but not with more than one client at the same time…).
I also ended up adding a <a href="https://jackaudio.org/">JACK</a> backend (using my own <a href="https://docs.rs/sqa-jack/0.6.1/sqa_jack/">sqa-jack</a> library), if that’s
your thing.</p>

  </div>
  

</article>


      </div>
    </div></div>
  </body>
</html>
