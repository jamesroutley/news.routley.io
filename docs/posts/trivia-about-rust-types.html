<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thecodedmessage.com/posts/trivia-rust-types/">Original</a>
    <h1>Trivia About Rust Types</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        
<p>I am a huge fan of Jon Gjengset’s <a href="https://nostarch.com/rust-rustaceans">Rust for
Rustaceans</a>,
an excellent book to bridge the gap between beginner
Rust programming skills and becoming a fully-functional
member of the Rust community.  He’s famous for his <a href="https://www.youtube.com/playlist?app=desktop&amp;list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">YouTube
channel</a>
as well; I’ve heard good things about it (watching video
instruction isn’t really my thing personally).  I have also
greatly enjoyed his <a href="https://twitter.com/jonhoo">Twitter feed</a>,
and especially have enjoyed the thread surrounding <a href="https://twitter.com/jonhoo/status/1532761983606411264">this
tweet</a>:</p>
<blockquote>
<p>Okay, learning time! Name a @rustlang
type (can be generic), and I’ll (try to) tell you something you didn’t
know about that type!</p>
</blockquote>
<p>What great fun!</p>
<p>I immediately felt that this thread should have a
transcription outside of social media (Jon Gjengset already did a <a href="https://www.reddit.com/r/rust/comments/v4dnaj/twitter_thread_with_trivia_about_rust_types/">Reddit
transcription</a>),
and so I asked him if he had any plans to turn
it into a blog post, and failing that, whether <a href="https://twitter.com/thecodedmessage/status/1533080530513801219">I
could</a>.
Much to my surprise, <a href="https://twitter.com/jonhoo/status/1533139200811290625">he gave me the
go-ahead</a>.</p>
<p>So I have done so, and this is the blog post!  It wasn’t even boring,
because I learned so much as I copied the entries!  Minor edits have
been made to add formatting and adapt links to how blogs work rather
than how Twitter works. This is taken from the Reddit version.</p>
<p>So, without further ado, Jon Gjengset’s “Trivia About Rust Types.”</p>

<h2 id="stdfmtdebug"><code>std::fmt::Debug</code><a href="#stdfmtdebug" arialabel="Anchor">#</a> </h2>
<p>Did you know that the Formatter argument to <code>Debug::fmt</code> makes it really easy to customize debug representations for structs, enums, lists, and sets? See the <code>debug_*</code> methods on it.</p>
<h2 id="formatter"><code>Formatter</code><a href="#formatter" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>std::fmt::Formatter</code> is super easy to use if you want more control over debugging for a custom type? For example, to emit a “list-like” type, just <code>Formatter::debug_list().entries(self.0.iter()).finish()</code>.</p>
<h2 id="optiont"><code>Option&lt;T&gt;</code><a href="#optiont" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>Option&lt;T&gt;</code> implements <code>IntoIterator</code> yielding 0/1
elements, and you can then call <code>Iterator::flatten</code> to make that be 0/n
elements if T: IntoIterator?</p>
<h2 id="type-emptytuplelist--vec"><code>type EmptyTupleList = Vec&lt;()&gt;</code><a href="#type-emptytuplelist--vec" arialabel="Anchor">#</a> </h2>
<p>Did you know that since <code>()</code> is a zero-sized type, and the vector never actually has to store any data, the capacity of <code>Vec&lt;()&gt;</code> is <code>usize::MAX</code>!</p>
<h2 id="t"><code>T</code><a href="#t" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>T</code> doesn’t imply ownership? When we say a type is
generic over <code>T</code>, that <code>T</code> can just as easily be a reference to something
on the stack, and the type system will still be happy. Even <code>T: &#39;static</code>
doesn’t imply owned — consider <code>&amp;&#39;static str</code> for example.</p>
<p>[Reminds me of this <a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md">excellent article</a> -Jimmy]</p>
<h2 id="stdsyncmpscchannelsender"><code>std::sync::mpsc::channel::Sender</code><a href="#stdsyncmpscchannelsender" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>std::sync::mpsc</code> has had a <a href="https://github.com/rust-lang/rust/issues/39364">known bug since
2017</a>, and that the
implementation may actually be replaced entirely with the crossbeam
channel implementation? <a href="https://github.com/rust-lang/rust/pull/93563">https://github.com/rust-lang/rust/pull/93563</a></p>
<h2 id="u128"><code>u128</code><a href="#u128" arialabel="Anchor">#</a> </h2>
<p>Did you know that even though we got <code>u128</code> a long time ago now, we
still don’t have <code>repr(128)</code>? <a href="https://github.com/rust-lang/rust/issues/56071">https://github.com/rust-lang/rust/issues/56071</a></p>
<h2 id="stdffiosstring"><code>std::ffi::OsString</code><a href="#stdffiosstring" arialabel="Anchor">#</a> </h2>
<p>Did you know that there are per-platform extension traits
for <code>OsString</code> that bake in the assumptions you can safely
make on that platform? Such as <a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStringExt.html">strings being <code>[u8]</code> on
Unix</a>
and <a href="https://doc.rust-lang.org/std/os/windows/ffi/trait.OsStringExt.html">UTF-16 on
Windows</a>.</p>
<h2 id="stdptrnonnull"><code>std::ptr::NonNull</code><a href="#stdptrnonnull" arialabel="Anchor">#</a> </h2>
<p>Did you know that one of the super neat features of <code>NonNull</code> is that
it enables the same niche optimization that regular references and the
<code>NonZero*</code> types get where <code>Option&lt;NonNull&lt;T&gt;&gt;</code> is the same size as <code>*mut T</code>?</p>
<h2 id="cowt"><code>Cow&lt;T&gt;</code><a href="#cowt" arialabel="Anchor">#</a> </h2>
<p>Did you know that there used to be a special
<code>IntoCow</code> trait, but it was deprecated before 1.0 was
released! <a href="https://github.com/rust-lang/rust/issues/27735">https://github.com/rust-lang/rust/issues/27735</a></p>
<h2 id="boxt"><code>Box&lt;T&gt;</code><a href="#boxt" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>Box&lt;T&gt;</code> is a <code>#[fundamental]</code> type, which means that
it’s exempt from the normal rules that don’t allow you to implement
foreign traits for foreign types (assuming T is a local type)?</p>
<h2 id="stdprocesschild"><code>std::process::Child</code><a href="#stdprocesschild" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>std</code> has
<a href="https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/process/process_unix.rs">three different ways</a>
to spawn a
child process on Linux (<code>posix_spawn</code>, <code>clone3</code>/<code>exec</code>, <code>fork</code>/<code>exec</code>)
depending on what capabilities your kernel version has?</p>
<h2 id="pint"><code>Pin&lt;T&gt;</code><a href="#pint" arialabel="Anchor">#</a> </h2>
<p>Did you know that the name <code>Pin</code> (and the name <code>Unpin</code>) where
both heavily debated? Pin was almost called Pinned, for example. <a href="https://github.com/rust-lang/rust/issues/55766#issuecomment-438789462">The
discussion</a>
is an interesting read now after the fact.</p>
<h2 id="vect"><code>Vec&lt;T&gt;</code><a href="#vect" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>Vec::swap_remove</code> is way faster than <code>Vec::remove</code>
if you can tolerate changes to ordering?</p>
<p>Did you know that the smallest non-zero
capacity for a <code>Vec&lt;T&gt;</code> <a href="https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/library/alloc/src/raw_vec.rs#L106-L110">depends on the size of
<code>T</code></a>?</p>
<h2 id="cstr"><code>CStr</code><a href="#cstr" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>CStr::default</code> creates a <code>CStr</code> that points to a
const string <code>&#34;\0&#34;</code> stored in the binary text segment, which means all
default <code>CStr</code>s point to the same (non-null) string!</p>
<h2 id="fora-sometraita"><code>for&lt;&#39;a&gt; SomeTrait&lt;&#39;a&gt;</code><a href="#fora-sometraita" arialabel="Anchor">#</a> </h2>
<p>Did you know that you can use <code>for&lt;&#39;a&gt;</code> to say that a bound has to hold
for any lifetime <code>&#39;a</code>, not just a specific lifetime you happen to have
available at the time. For example, <code>&lt;T&gt; for&lt;&#39;a&gt;: &amp;&#39;a T: Read</code> says that
any shared reference to a <code>T</code> must implement <code>Read</code>.</p>
<h2 id="this-monstrous-warp-typehttpsgistgithubusercontentcomfasterthanlimede0955a8b29d0d66110983ebb5fae442raw1827a3afbca01cd42eafd0905cfdc451da805cb7gistfile1txt"><a href="https://gist.githubusercontent.com/fasterthanlime/de0955a8b29d0d66110983ebb5fae442/raw/1827a3afbca01cd42eafd0905cfdc451da805cb7/gistfile1.txt">This monstrous warp type</a><a href="#this-monstrous-warp-typehttpsgistgithubusercontentcomfasterthanlimede0955a8b29d0d66110983ebb5fae442raw1827a3afbca01cd42eafd0905cfdc451da805cb7gistfile1txt" arialabel="Anchor">#</a> </h2>
<p>Did you know that the trailing commas you see in some places in there,
<code>,)</code>, are to <a href="https://doc.rust-lang.org/nightly/reference/expressions/tuple-expr.html">distinguish one-element tuples from regular parenthetical
expressions</a>?</p>
<h2 id="fnonce"><code>FnOnce</code><a href="#fnonce" arialabel="Anchor">#</a> </h2>
<p>Did you know that until Rust 1.35, you couldn’t call a <code>Box&lt;dyn FnOnce&gt;</code> and needed a special type (<code>FnBox</code>) for it! This was
because it requires “unsized rvalues” to implement, which are still
unstable today. <a href="https://github.com/rust-lang/rust/issues/28796">https://github.com/rust-lang/rust/issues/28796</a> +
<a href="https://github.com/rust-lang/rust/issues/48055">https://github.com/rust-lang/rust/issues/48055</a></p>
<h2 id="f32"><code>f32</code><a href="#f32" arialabel="Anchor">#</a> </h2>
<p>Did you know that in Rust 1.62 we’ll get a deterministic ordering function
for floating point numbers? <a href="https://github.com/rust-lang/rust/pull/95431">https://github.com/rust-lang/rust/pull/95431</a></p>
<h2 id="arct"><code>Arc&lt;T&gt;</code><a href="#arct" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>Arc</code> has a <code>make_mut</code> method that effectively gives
you copy-on-write? Given a <code>&amp;mut Arc&lt;T&gt;</code>, it will either give you <code>&amp;mut T</code> if there are no other Arcs, or it will clone <code>T</code>, make the <code>Arc&lt;T&gt;</code>
point to that new <code>T</code>, and then give you a <code>&amp;mut</code> to it!</p>
<h2 id="heading"><code>!</code><a href="#heading" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>std::convert::Infallible</code> is the “original” <code>!</code>, and that
the plan is to one day replace <code>Infallible</code> with a type alias for <code>!</code>?</p>
<h2 id="fn"><code>fn</code><a href="#fn" arialabel="Anchor">#</a> </h2>
<p>Specifically, did you know that the name of a function is not an
<code>fn</code>? It’s a <code>FnDef</code>, which can then be
<a href="https://github.com/rust-lang/rust/issues/86654#issuecomment-869173835">coerced to a <code>FnPtr</code></a>?</p>
<h2 id="phantomdata"><code>PhantomData</code><a href="#phantomdata" arialabel="Anchor">#</a> </h2>
<p>Did you know that it’s actually kind of tricky to define <code>PhantomData</code> yourself: <a href="https://github.com/dtolnay/ghost">https://github.com/dtolnay/ghost</a></p>
<h2 id="u32"><code>u32</code><a href="#u32" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>u32</code> now has associated constants for <code>MIN</code> and <code>MAX</code>,
so you no longer need to use <code>std::u32::MIN</code> and can use <code>u32::MIN</code>
directly instead?</p>
<h2 id="bool"><code>bool</code><a href="#bool" arialabel="Anchor">#</a> </h2>
<p>Did you know that bool isn’t just “stored as a byte”, the compiler
straight up declares its representation as <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_middle/src/ty/layout.rs#L676-L682">the same as that of
u8</a>?</p>
<h2 id="any"><code>Any</code><a href="#any" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>Any</code> is <em>really</em> non-magical? It just has a blanket
implementation for all <code>T</code> that returns <code>TypeId::of::&lt;T&gt;()</code>, and to
downcast it simply compares the return value of that trait method to
see if it’s safe to cast to downcast to a type! <code>TypeId</code> is magic though.</p>
<h2 id="self"><code>Self</code><a href="#self" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>fn foo(self)</code> is syntactic sugar for
<code>fn foo(self: Self)</code>, and that one day you’ll be able to use
other types for <code>self</code> that involve <code>Self</code>, like <code>fn foo(self: Arc&lt;Self&gt;)</code>?
<a href="https://github.com/rust-lang/rust/issues/44874">https://github.com/rust-lang/rust/issues/44874</a></p>
<h2 id="heading-1"><code>()</code><a href="#heading-1" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>()</code> implements FromIterator, so you can
<code>.collect::&lt;Result&lt;(), E&gt;&gt;</code> to just see if anything in an iterator erred?</p>
<p>[Note that this doesn’t say whether or not this is a good idea. -Jimmy]</p>
<h2 id="struct-s"><code>struct S</code><a href="#struct-s" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>struct S</code> implicitly declares a constant called <code>S</code>,
which is why you can make one using just <code>S</code>?</p>
<h2 id="refcell"><code>RefCell</code><a href="#refcell" arialabel="Anchor">#</a> </h2>
<p>Did you know that RefCell allows you to replace a
value in-place directly (like <code>std::mem::replace</code>)?
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace">https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace</a></p>
<h2 id="corenumwrapping"><code>core::num::Wrapping</code><a href="#corenumwrapping" arialabel="Anchor">#</a> </h2>
<p>Did you know that there used to also be a trait accompanying <code>Wrapping</code>,
<code>WrappingOps</code>, that was removed last minute before
1.0? <a href="https://github.com/rust-lang/rust/pull/23549">https://github.com/rust-lang/rust/pull/23549</a></p>
<h2 id="const-t"><code>*const T</code><a href="#const-t" arialabel="Anchor">#</a> </h2>
<p>Did you know that, at least for the time being,
<code>*const T</code> and <code>*mut T</code> are more or less
equivalent? <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/257">https://github.com/rust-lang/unsafe-code-guidelines/issues/257</a></p>
<h2 id="stdosunixnetunixstream"><code>std::os::unix::net::UnixStream</code><a href="#stdosunixnetunixstream" arialabel="Anchor">#</a> </h2>
<p>Did you know that (on nightly) you can pass UNIX file
descriptors over UnixStreams too, and thereby <a href="https://doc.rust-lang.org/std/os/unix/net/struct.SocketAncillary.html#method.add_fds">give another process
access</a>
to a file it may not otherwise be able to open?</p>
<h2 id="stdsynccondvarmutex"><code>std::sync::Condvar</code>/<code>Mutex</code><a href="#stdsynccondvarmutex" arialabel="Anchor">#</a> </h2>
<p>Did you know that Mara is doing some awesome work on making
<code>Condvar</code> (and <code>Mutex</code> and <code>RwLock</code>) much better on a wide array on
platforms? <a href="https://github.com/rust-lang/rust/issues/93740">https://github.com/rust-lang/rust/issues/93740</a>￼￼</p>
<h2 id="stdtaskwaker"><code>std::task::Waker</code><a href="#stdtaskwaker" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>Waker</code> is secretly just a <code>dyn std::task::Wake + Clone</code> done in a way that doesn’t require a
wide pointer or support for multi-trait dynamic dispatch? See
<a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html">https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html</a></p>
<h2 id="impl-trait"><code>impl Trait</code><a href="#impl-trait" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>impl Trait</code> in argument position and
<code>impl Trait</code> in return position represent completely
different type constructs, even though they “feel”
related? <a href="https://doc.rust-lang.org/nightly/reference/types/impl-trait.html">https://doc.rust-lang.org/nightly/reference/types/impl-trait.html</a></p>
<h2 id="btreemapk-v"><code>BTreeMap&lt;K, V&gt;</code><a href="#btreemapk-v" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>BTreeMap</code> is one of the few
collections that still doesn’t have a <code>drain</code>
method? <a href="https://github.com/rust-lang/rust/issues/81074">https://github.com/rust-lang/rust/issues/81074</a></p>
<h2 id="struct-invariantlifetimeidphantomdatamut-id-"><code>struct InvariantLifetime&lt;&#39;id&gt;(PhantomData&lt;*mut &amp;&#39;id ()&gt;);</code><a href="#struct-invariantlifetimeidphantomdatamut-id-" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>PhantomData&lt;T&gt;</code> has variance like <code>T</code>, and <code>*mut T</code>
is invariant over <code>T</code>, and so by placing a lifetime inside <code>T</code> you make
the outer type invariant over that lifetime?</p>
<h2 id="rct"><code>Rc&lt;T&gt;</code><a href="#rct" arialabel="Anchor">#</a> </h2>
<p>Did you know that the <code>Rc</code> type was among the arguments
for why <code>std::mem::forget</code> shouldn’t be marked as
unsafe? <a href="https://github.com/rust-lang/rust/issues/24456">https://github.com/rust-lang/rust/issues/24456</a></p>
<h2 id="stdfutureready"><code>std::future::Ready</code><a href="#stdfutureready" arialabel="Anchor">#</a> </h2>
<p>Did you know that these days you can just use <code>async move { x }</code> instead
of <code>future::ready(x)</code>. The main reason to still use <code>future::ready(x)</code>
is that you can name the future it returns, which is harder with <code>async</code>
(without <code>type_alias_impl_trait</code> that is).</p>
<h2 id="usize"><code>usize</code><a href="#usize" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>usize</code> isn’t really “the size of a pointer”. Instead,
it’s more like “the size of a pointer address difference”, and the two
can be fairly different! <a href="https://github.com/rust-lang/rust/issues/95228">https://github.com/rust-lang/rust/issues/95228</a></p>
<h2 id="stdthreadthread"><code>std::thread::Thread</code><a href="#stdthreadthread" arialabel="Anchor">#</a> </h2>
<p>Did you know that the <code>ThreadId</code> that’s available for each <code>Thread</code> is
entirely a <code>std</code> construct? Creating a <code>ThreadId</code> simply increments a global
static counter under a lock.</p>
<h2 id="stdopscontrolflow"><code>std::ops::ControlFlow</code><a href="#stdopscontrolflow" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>ControlFlow</code> is really a stepping stone towards making
<code>?</code> work for other types than <code>Option</code> and <code>Result</code>? The full design has gone
through a lot of iterations, but the latest and greatest is
<a href="https://github.com/rust-lang/rust/issues/84277">RFC3058</a>.</p>
<h2 id="file"><code>File</code><a href="#file" arialabel="Anchor">#</a> </h2>
<p>Did you know that there are implementations of <code>Read</code>, <code>Write</code>, and <code>Seek</code>
for <code>&amp;File</code> as well, so multiple threads can share a single <code>File</code> and call
those concurrently. Whether they should is a different question of course.</p>
<h2 id="resultt-e"><code>Result&lt;T, E&gt;</code><a href="#resultt-e" arialabel="Anchor">#</a> </h2>
<p>Did you know that Rust originally (pre-1.0) had both Result and an Either type? They decided to remove Either <a href="https://github.com/rust-lang/rust/issues/9157">way back in 2013</a></p>
<h2 id="cowstr"><code>Cow&lt;str&gt;</code><a href="#cowstr" arialabel="Anchor">#</a> </h2>
<p>Did you know that because <code>Cow&lt;&#39;a, T&gt;</code> is covariant in <code>&#39;a</code>, you can always
assign <code>Cow::Borrowed(&#34;some string&#34;)</code> to one no matter what it originally
held?</p>
<h2 id="panicinfo"><code>PanicInfo</code><a href="#panicinfo" arialabel="Anchor">#</a> </h2>
<p>Did you know that since <code>PanicInfo</code> is in core, its <code>Display</code>
implementation cannot access the panic data if it’s a <code>String</code> (since
it can’t name that type), so trying to print the <code>PanicInfo</code> after
a <code>std::panic::panic_any(format!(&#34;x y z&#34;))</code> won’t print <code>&#34;x y z&#34;</code>?
<a href="https://github.com/rust-lang/rust/blob/352e621368c31d7b4a6362e081586cdb931ba020/library/core/src/panic/panic_info.rs#L159-L162">Source link.</a></p>
<h2 id="stdffic_void"><code>std::ffi::c_void</code><a href="#stdffic_void" arialabel="Anchor">#</a> </h2>
<p>Did you know that the whole <code>c_void</code> type is a collection
of hacks to try to work around the lack for extern
types? <a href="https://github.com/rust-lang/rust/issues/43467">https://github.com/rust-lang/rust/issues/43467</a></p>
<h2 id="featureraw_ref_op-raw-const-t"><code>#[feature(raw_ref_op)] &amp;raw const T</code><a href="#featureraw_ref_op-raw-const-t" arialabel="Anchor">#</a> </h2>
<p>Definitely cheating :p But did you know that originally the intention
was to have <code>&amp;const raw</code> variable be just a MIR construct and let
<code>&amp;variable as *const _</code> be automatically changed to <code>&amp;const raw</code>?
<a href="https://github.com/RalfJung/rfcs/blob/fd4b4cd769300cfde5d54865d227990b71b762d1/text/0000-raw-reference-operator.md">https://github.com/RalfJung/rfcs/blob/fd4b4cd769300cfde5d54865d227990b71b762d1/text/0000-raw-reference-operator.md</a></p>
<h2 id="u256"><code>u256</code><a href="#u256" arialabel="Anchor">#</a> </h2>
<p>Did you know that because Rust compiles through LLVM,
we’re sort of constrained to the primitive types
LLVM supports, and <a href="https://llvm.org/doxygen/classllvm_1_1Type.html#pub-static-methods">LLVM itself only goes up to
128</a>?</p>
<h2 id="_"><code>_</code><a href="#_" arialabel="Anchor">#</a> </h2>
<p>Did you know that whether or not <code>let _ = x</code> should move <code>x</code> is actually
fairly subtle? <a href="https://github.com/rust-lang/rust/issues/10488">https://github.com/rust-lang/rust/issues/10488</a></p>
<h2 id="maybeuninit"><code>MaybeUninit</code><a href="#maybeuninit" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>MaybeUninit</code> arose because the previous mechanism,
<code>std::mem::uninitialized</code>, produced immediate undefined behavior when
invoked with most types (like <code>uninitialized::&lt;bool&gt;()</code>).</p>
<h2 id="struct-tconst-c-usize"><code>struct T&lt;const C: usize&gt;</code><a href="#struct-tconst-c-usize" arialabel="Anchor">#</a> </h2>
<p>Did you know that with Rust 1.59.0 you can now
<a href="https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html#const-generics-defaults-and-interleaving">give <code>C</code> a default value</a>?</p>
<h2 id="weakt"><code>Weak&lt;T&gt;</code><a href="#weakt" arialabel="Anchor">#</a> </h2>
<p>Did you know that actual deallocation logic for <code>Arc&lt;T&gt;</code> is
implemented in <code>Weak&lt;T&gt;</code>, and is invoked by considering all copies of
a particular <code>Arc&lt;T&gt;</code> to collectively hold a single <code>Weak&lt;T&gt;</code> between them?
<a href="https://github.com/rust-lang/rust/blob/7e9b92cb43a489b34e2bcb8d21f36198e02eedbc/library/alloc/src/sync.rs#L1108-L1109">Source link.</a></p>
<h2 id="t-n"><code>[T; N]</code><a href="#t-n" arialabel="Anchor">#</a> </h2>
<p>Did you know that while <em>most</em> trait implementations for arrays now use
const generics to impl for any length <code>N</code>, <a href="https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/library/core/src/array/mod.rs#L371-L394">we can’t <em>yet</em> do the same for
<code>Default</code></a>.</p>
<h2 id="u8"><code>u8</code><a href="#u8" arialabel="Anchor">#</a> </h2>
<p>Did you know that as of Rust 1.60, you can now use <code>u8::escape_ascii</code> to
<a href="https://doc.rust-lang.org/std/ascii/fn.escape_default.html">get an iterator of the bytes needed to escape that byte character in
most contexts</a>.</p>
<h2 id="hashmapk-v"><code>HashMap&lt;K, V&gt;</code><a href="#hashmapk-v" arialabel="Anchor">#</a> </h2>
<p>Did you know that the Rust devs are working on a “raw” entry API for
<code>HashMap</code> that allows you to (unsafely) avoid re-hashing a key you’ve
already hashed? <a href="https://github.com/rust-lang/rust/issues/56167">https://github.com/rust-lang/rust/issues/56167</a></p>
<h2 id="mut-t"><code>&amp;mut T</code><a href="#mut-t" arialabel="Anchor">#</a> </h2>
<p>Did you know that while <code>&amp;mut T</code> is defined as meaning “mutable reference” in the Rust reference, you’re often better off thinking of it as “mutually exclusive reference”. <a href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">Quoth David Tolnay</a>.</p>
<h2 id="stdopsrange"><code>std::ops::Range</code><a href="#stdopsrange" arialabel="Anchor">#</a> </h2>
<p>Did you know that there’s been a lot of debate around whether or not the
<code>Range</code> types should be <code>Copy</code>? <a href="https://github.com/rust-lang/rust/pull/21846">https://github.com/rust-lang/rust/pull/21846</a></p>
<h2 id="atomicu32"><code>AtomicU32</code><a href="#atomicu32" arialabel="Anchor">#</a> </h2>
<p>Did you know that you’ll often want <code>compare_exchange_weak</code>
over <code>compare_exchange</code> to get
<a href="https://devblogs.microsoft.com/oldnewthing/20180329-00/?p=98375">more efficient code on ARM cores</a>.</p>
<h2 id="stdopshash"><code>std::ops::Hash</code><a href="#stdopshash" arialabel="Anchor">#</a> </h2>
<p>Did you know that Hash is responsible for not just
<a href="https://github.com/rust-lang/rust/issues/29263">one</a>
, but
<a href="https://github.com/rust-lang/rust/issues/65744">two</a>
of the issues on the “rust 2 breakage wishlist”?</p>
<h2 id="integer"><code>{integer}</code><a href="#integer" arialabel="Anchor">#</a> </h2>
<p>Did you know that fasterthanlime’s <a href="https://fasterthanli.me/articles/the-curse-of-strong-typing#different-kinds-of-numbers">most recent
article</a>
does a great job at explaining <code>{integer}</code>?</p>
<h2 id="fn-1"><code>Fn</code><a href="#fn-1" arialabel="Anchor">#</a> </h2>
<p>Did you know that until Rust 1.35.0, <code>Box&lt;T&gt; where T: Fn</code>
did not <code>impl Fn</code>, so you couldn’t (easily) call boxed
closures! <a href="https://github.com/rust-lang/rust/pull/55431">https://github.com/rust-lang/rust/pull/55431</a></p>
<h2 id="-"><code>((), ())</code><a href="#-" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>((), ())</code> and <code>()</code> have the same hash?
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=894b78e8ee2721440aa8dea5e35f9dc3">Playground link.</a></p>
<h2 id="t-1"><code>[T]</code><a href="#t-1" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>&amp;[u8]</code> implements <code>Read</code> and <code>Write</code>? So for anything
that takes <code>impl Read</code>, you can provide <code>&amp;mut</code> slice instead! Comes in
handy for testing. Note that the slice itself is shortened for each read,
hence <code>&amp;mut &amp;[u8]</code>.</p>
<h2 id="heading-2"><code>*</code><a href="#heading-2" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>*</code> is (mostly) just syntax sugar for the std::ops::Mul
trait?</p>
<h2 id="unsafecellt"><code>UnsafeCell&lt;T&gt;</code><a href="#unsafecellt" arialabel="Anchor">#</a> </h2>
<p>Did you know that <code>UnsafeCell</code> is one of those types that the compiler
needs “special magic” for because it has to instruct LLVM to not assume
Rust’s normal aliasing rules hold once code traverses the boundary of any
<code>UnsafeCell</code>?</p>

      </div></div></div>
  </body>
</html>
