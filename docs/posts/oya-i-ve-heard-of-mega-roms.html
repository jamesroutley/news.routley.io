<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.leadedsolder.com/2024/09/03/msx-megarom-oyanami.html">Original</a>
    <h1>Oya, I&#39;ve heard of mega-ROMs</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>Konami made some of the best games for the MSX computer platform. Unfortunately, the market being what it is, those cartridges have become expensive collectibles rather than cheap games, which takes all the fun out of it. Before we can build a bootleg cart, we need to understand Konami’s unique mapper.</p>

<p>My goal for this project was to make a functional cartridge that could play Konami’s <em>Knightmare II: The Maze of Galious</em>. Although I think the game is interesting and ambitious, this was mostly because blog friend famiclone loved the game, and I owed him an MSX in exchange for the lovely ColecoVision and busted 48k Spectrum he sent me.</p>

<h2 id="failure-to-launch">Failure to Launch</h2>
<p>For a couple years now, I’ve wanted to play <a href="https://en.wikipedia.org/wiki/The_Maze_of_Galious"><em>The Maze of Galious</em></a> on an MSX. <em>Galious</em> is a side-scrolling action-adventure game with some long gameplay, multiple characters, and some fiendish puzzles. Blog friend famiclone has been really interested in it, and I wanted to see what all the fuss is about, too.</p>

<p>At first, I looked at the used market to see if I could buy a cartridge. The absolute lowest I’ve seen a (very worn) cartridge listed for over the years is ¥4800. In retrospect, after all this adventure, that doesn’t seem like much, but “spending fifty bucks instead of learning something” is not the name of this blog.</p>

<p>As you have probably inferred, the obstacle was understanding the mapping scheme in use. I’d soldered together a bunch of homebrew MSX cartridges before, but they were always a simple “bare ROM” on a pre-made board that is keyed off of slot-select. No fancy mappers, and limited to 64k at most. I certainly did not <em>program</em> the software on those cartridges – MSX programming is an experience I am saving for the future!</p>

<p>I set about trying to figure out the paging scheme in use, by piecing together MSX.org wikis and squinting at pictures of other mega-ROM boards. But everything was very confusing, and it seemed like with every step forward, I’d end up having to pull the design apart and redo it from scratch, or end up with way too many parts.</p>

<p>So what changed? I got talking to <a href="https://www.msx.org/users/bsittler">bsittler</a>, a huge MSX fan, about the MSX.</p>

<p>When he heard about the project, blog friend bsittler sent me <a href="https://retrogamerestore.com/store/msx_cart_shell/">some Konami-style cases from Retro Game Restore</a> that he had lying around the property. This act of generosity was the spark that motivated me to actually finish this project up enough to send it to fab. Thank you!</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-pcb-view.png" alt="The version-one PCB as it was sent to JLCPCB. It reads &#34;Oyanami Megabit Mapper for Legitimate Purposes.&#34;"/></p>

<p>I made Microchip send me a sample DIP32 SST39SF040 EEPROM, which was very nice of them to provide. Thank you, too, Microchip!</p>

<p>For my initial run I decided to try <em>Galious</em>. I could also have done <em>Metal Gear</em>, but I only wanted to have MSX1 games on this initial cart.</p>

<h2 id="mapping-for-these-territories">Mapping for These Territories</h2>
<p>What is a cartridge mapper, and why do we need one?</p>

<p>A lot of early MSX games are similar to most ColecoVision cartridges: a bare ROM on a PCB, without any fancy logic.</p>

<p>As cartridges got bigger, they no longer fit entirely into the Z80 CPU’s 64k of address space. Some page-switching had to be added. It’s just what it sounds like: instead of looking at a whole book’s worth of information laid out on a table all at once, we cut that information into pages, and then flip the book to look at one page at a time.</p>

<p>In other words, one address in the Z80 space could now point to multiple different addresses on the ROM. This was an inevitable development: anyone who knows programmers can tell you that they <em>always</em> need more memory (both ROM and RAM!)</p>

<p>Long-time readers will remember that we’ve delved into cartridge page-switching routines before, such as <a href="https://www.leadedsolder.com/2020/07/28/portopia-repro.html">the explanation of how UNROM cartridges worked on the NES</a>.</p>

<p>Page switching was built into the MSX standard’s design from the start. ASCII Corporation, which originated the standard, had a whole lot of programmers on staff and they got what they wanted. MSX’s basic “slot” scheme makes it easy to access two 64k cartridges while still keeping BIOS ROM and RAM available.</p>

<h2 id="msx-slot-mapping">MSX Slot Mapping</h2>
<p>Because the MSX came relatively late in 1983, the design of the standard benefited from seeing the limitations of other Z80-based systems. Many parts were inspired by my beloved NEC PC-6001, but ASCII picked and chose some reasonably sane choices. For our purposes at the moment, one of the more significant features of the MSX design is the slot system, which allows manufacturers to specify a huge memory map that can be “paged” in and out at runtime.</p>

<p>I had tried to fit the slot system into my head on many previous occasions. It is hard to go into any discussion of the MSX hardware standard without seeing words like “slot,” “mapper,” “page,” and “segment” thrown around, often interchangeably. Things made more sense once I talked to bsittler, who has had a long history tinkering with the MSX and features a near-infinite amount of patience for my dumb questions.</p>

<p>Here, then, are the basic rules as I understand them:</p>

<ol>
  <li>The MSX divides the 64kB Z80 address space into four 16kB “pages.”</li>
  <li>Each page can choose between one of four “slots” to point to, which usually (but not always) correspond to “built in,” “cartridge slot 1,” “cartridge slot 2,” and “miscellaneous.”</li>
  <li>To set the pages, you write a byte to I/O port <span>$a8 </span> to tell it what slot to display at which page<sup id="fnref:bios-not-port" role="doc-noteref"><a href="#fn:bios-not-port" rel="footnote">1</a></sup>. Page 3 (<span>$c0000 </span> to <span>$ffff </span>) is the most significant half-nibble of that byte.</li>
</ol>

<p>I wrote a quick example, based on <a href="https://www.leadedsolder.com/tag/hb101">my 16kB Sony HB-101</a>, that you can play with on your own to see what I mean:</p>

<div>
    <p>
        Click on slots on the left-side table in order to map them into the MSX&#39;s Z80 address space on the right.
    </p>

    <div>    
        <div>
            <h3>Assign MSX Slots</h3>
            <table id="available-slots">
                <tbody><tr>
                    <th></th>
                    <th>Slot 0</th>
                    <th>Slot 1</th>
                    <th>Slot 2</th>
                    <th>Slot 3</th>
                </tr>
                <tr id="page0">
                    <th>Page $C000 - $FFFF</th>
                    <td>16k RAM</td>
                    <td>Cart Slot 1</td>
                    <td>Cart Slot 2</td>
                    <td>Nothing</td>
                </tr>
                <tr id="page1">
                    <th>Page $8000 - $BFFF</th>
                    <td>Nothing</td>
                    <td>Cart Slot 1</td>
                    <td>Cart Slot 2</td>
                    <td>Nothing</td>
                </tr>
                <tr id="page2">
                    <th>Page $4000 - $7FFF</th>
                    <td>Main ROM (top)</td>
                    <td>Cart Slot 1</td>
                    <td>Cart Slot 2</td>
                    <td>Hit-Bit Organizer</td>
                </tr>
                <tr id="page3">
                    <th>Page $0000 - $3FFF</th>
                    <td>Main ROM (bottom)</td>
                    <td>Cart Slot 1</td>
                    <td>Cart Slot 2</td>
                    <td>Nothing</td>
                </tr>
            </tbody></table>
        </div>     
        
        <div>
            <h3>Current Memory Map</h3>
            <table id="active-slots">
                <tbody><tr>
                    <th>Page</th>
                    <th>Mapped to...</th>
                </tr>
                <tr>
                    <th>Page $C000 - $FFFF</th>
                    <td>...</td>
                </tr>
                <tr>
                    <th>Page $8000 - $BFFF</th>
                    <td>...</td>
                </tr>
                <tr>
                    <th>Page $4000 - $7FFF</th>
                    <td>...</td>
                </tr>
                <tr>
                    <th>Page $0000 - $3FFF</th>
                    <td>...</td>
                </tr>
            </tbody></table>
        </div>
    </div>

    <h3>Slot-Changing Instructions</h3>
    </div>

<p>The critical point I didn’t get on previous attempts was that each page can only use slots in its <em>row</em>. For example, on this example of the Sony HB-101, you can’t map the main ROM into high memory. I had been confused before why everything seemed to still be in the same order, despite there seemingly being a lot of flexibility in the design of an MSX-standard computer.</p>

<p>If you put the above example into the configuration where RAM, the BIOS ROM, and the cartridge are all assigned into the memory map at the same time (i.e. <code>OUT ($a8), 0b00010100</code>), you’ll find that the lowest address available to the cartridge is <span>$4000 </span>. This is why MSX ROM cartridges decode their initialization code at <span>$4000 </span>. It’s where the MSX BIOS will look for it when it mounts the slot.</p>

<p>There is a <a href="https://www.msx.org/wiki/Category:Slot_Expanders">“slot-expander” peripheral</a> to further subdivide these slots if you need more space. The MSX2 has a lot of additional fancy mapper schemes built into the standard as well, but I don’t understand those yet, so we’re not going to cover those in this article.</p>

<p>Under the standard MSX scheme, a cartridge is split into four 16k slots, which means that your theoretical game can be a whopping 64 kilobytes without requiring any additional fancy mapping schemes, which add cost to every cartridge. That’s a huge amount of space, if you’re used to the Nintendo NROM, which limited cartridges to a measly 16k of program space.</p>

<h2 id="konami-bon-ami">Konami Bon Ami</h2>
<p>Unfortunately for the MSX planners, games kept getting bigger and bigger… When Konami started making <em>128-kilobyte</em> games, they had to implement an extra mapping scheme of their own.</p>

<p>That’s where the “MegaROM” mapper comes in: it lets you page-switch one megabit (128 kilo <em>bytes</em>) of cartridge ROM so that it can be fully accessed by the MSX through the 64k of slots that it makes available to the cartridge.</p>

<p><img src="https://www.leadedsolder.com/assets/msx-megarom-base.png" alt="The MegaROM mapper design. The four 16k slots of the cartridge are expanded to point to arbitrary 16k segments in a ROM."/></p>

<p>Under the Konami scheme, we divide the 1Mbit ROM into eight 16k segments.</p>

<p>Each 16k slot of the MSX cartridge’s slot space can now choose to point to one of eight 16k segments of the ROM on the cartridge. This design is very similar to that of the MSX’s own mapper!</p>

<p>There is just one caveat: on the early Konami mappers, the <span>$4000 </span> to <span>$7fff </span> slot is <em>always</em> mapped to the first segment of the ROM. This is because the MSX will look at this slot first in order to boot a cartridge, so it has to contain the boot code for the game when the MSX turns on.</p>

<p>Why is this fixed, then? Why not make it configurable and just default to segment zero? It’s probably because Konami would otherwise have to add logic to detect when the MSX is starting up, and reset all these registers to zero<sup id="fnref:other-mappers" role="doc-noteref"><a href="#fn:other-mappers" rel="footnote">2</a></sup>. I’m glad they didn’t do this, because it would have made it much harder for me to implement, but more on that in a bit.</p>

<h2 id="the-guts-of-page-switching">The Guts of Page Switching</h2>
<p>Now that we know logically how things are supposed to work from the software side of the MSX, how do we actually implement a mapper in <em>hardware</em>?</p>

<p>At the most basic level, a page-switching scheme controls the upper address bits of the RAM or ROM that we want to switch. For instance, you can think of a 32k RAM chip as being four chunks of 8k, arranged in a line.</p>

<p><img src="https://www.leadedsolder.com/assets/32k-a13-a14-lines.png" alt="A 32k RAM chip split into four 8k chunks."/></p>

<p>Instead of being driven directly by the CPU, we instead drive those lines from some sort of latch. When we want to look at a different chunk of the RAM, we change the latch’s settings, and it changes how it’s driving the mapped RAM/ROM’s address lines.</p>

<p>The Konami mapper needs a pretty fancy latch, but it’s still a part we can just get off the shelf. Let’s ditch the generalities and get down to how it specifically works..</p>

<h2 id="the-magic-74ls670">The Magic 74LS670</h2>
<p>Most of the homebrew MegaROM cartridges are based around the 74LS670. That part is called a “4x4 register file,” which is a very Texas Instruments name for what is basically four 4-bit latches stuck together in one teeny tiny chip.</p>

<p>To use the ‘670, you set two address pins (2<sup>2</sup> = 4 registers) and then can enable read or write. Enabling write sets the registers inside the chip for the given address, and enabling read expresses the content of that register on the output pins.</p>

<p>It’s a pretty useful part, especially when you realize that you can write to a different register than you’re reading from at the same time. You can almost think of it as a crude, very small dual-port SRAM.</p>

<p>Unfortunately, it’s a little harder to get these days: Digi-Key is asking over $11 for it in HCT DIP, and most varieties are simply discontinued. My supplies all came from salvage. I think it could be a cool project to try and build one of these using a PLD.</p>

<h2 id="the-struggle">The Struggle</h2>
<p>I had tried making one of these before, because I figured it was something simple like the UNROM mapper. Previously, I had started figuring it out from <a href="https://www.msx.org/wiki/MegaROM_Mappers#Konami_MegaROMs_without_SCC">the MSX.org description of the mapper’s addresses</a>, but I kept making very complex decode circuits.</p>

<p>This time around, I looked at <a href="https://www.msx.org/forum/msx-talk/hardware/konami-mapper-circuit-diagram">this thread complaining about a non-working MegaROM schematic</a> and decided to take a peek. I was surprised to find that they didn’t route A<sub>14</sub> at all, and started to puzzle that out on paper.</p>

<p>Eventually, I figured out that A14 doesn’t usefully distinguish any access. Here, let me show you:</p>

<table>
  <thead>
    <tr>
      <th>Address</th>
      <th>Segment</th>
      <th>A13</th>
      <th>A14</th>
      <th>A15</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span>$4000 </span></td>
      <td>Always 0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td><span>$6000 </span></td>
      <td>Variable</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td><span>$8000 </span></td>
      <td>Variable</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td><span>$a000 </span></td>
      <td>Variable</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>As you can see from the table, A<sub>14</sub> isn’t needed to decide between “paged” and “unpaged” access.</p>

<p>If A13 or A15 are high, then we know it’s trying to read a paged segment, and we should activate the 74LS670 to set the upper address lines to whatever it has set.</p>

<p>Otherwise, the ‘670 doesn’t turn on, and the upper address lines on the ROM would be left low (more on this in a second.) A<sub>14</sub> is just not necessary to know. Once I figured this out, the penny dropped on the decoding.</p>

<p>Although it’s not my design, I figure it’s okay to crib from other designs as long as I’m actually <em>learning</em> from them.</p>

<p>Now that I know how it works, it would be easy to expand to a “Konami 16” mapper (for 256k games) or even something more complicated.</p>

<h2 id="arrival">Arrival</h2>
<p>In order to rough out the PCB dimensions, I measured a Gerber of another MSX cartridge using the KiCad Gerber viewer. However, I got the hole diameter slightly wrong for the case: I measured 4mm, but the cases provided were 4.5-ish mm when they arrived.</p>

<p>Even so, the edge connector was correct and fit properly into the system, so we can still test it!</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-installed-in-hb101.jpg" alt="The initial PCB is installed into the black HB-101."/></p>

<p>For testing, I grabbed the closest MSX to hand: a black Sony HB-101 that I knew to have exceptionally dirty and glitchy cartridge slots. Perfect!</p>

<p>Unfortunately, the HB-101 didn’t want to boot my new cartridge, even after repeatedly cleaning those slots. Instead, the BIOS would just jump to the built-in Sony HitBit organizer menu every time, indicating it couldn’t read the cart, or just didn’t like what was going on there.</p>

<p>I decided that I would grab my copy of <em>Tiny Slot Checker</em> and see if anything legible was coming back from the cart.</p>

<h2 id="tiny-slot-checked">Tiny Slot Checked</h2>
<p><a href="http://www.tiny-yarou.com/slotchecker.html"><em>Tiny Slot Checker</em></a> is a fantastic MSX utility written by Tiny Yarou, a Japanese hobbyist. Basically, it scans the MSX’s memory space and displays what it thinks is installed in each of the MSX’s slots.</p>

<p>Critically, for our purposes, it includes a hex viewer. My plan was to use this hex viewer to inspect the cartridge slot containing my prototype Oyanami. That way, I’d be able to see if the cartridge is able to be read at all. And if the paging scheme was wrong, I’d maybe even be able to figure out what segment of the ROM it was looking at instead of the one containing the boot code.</p>

<p><em>Tiny Slot Checker</em> reported that slot 2 was populated. It tries to make an educated guess about the contents of the slot, and can fingerprint many games and BIOS ROMs. In this case, it had no idea what was in that slot, so it just displayed <code>?</code>.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Page 0</th>
      <th>Page 1</th>
      <th>Page 2</th>
      <th>Page 3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Slot 0</td>
      <td>Main (BIOS)</td>
      <td>Main</td>
      <td>Empty</td>
      <td>Empty</td>
    </tr>
    <tr>
      <td>Slot 1 (Tiny Slot Checker)</td>
      <td>Empty</td>
      <td>This Tool</td>
      <td>Empty</td>
      <td>Empty</td>
    </tr>
    <tr>
      <td>Slot 2 (our cart)</td>
      <td>Empty</td>
      <td>?</td>
      <td>?</td>
      <td>Empty</td>
    </tr>
    <tr>
      <td>Slot 3</td>
      <td>Empty</td>
      <td>HitBit Tools</td>
      <td>Empty</td>
      <td>RAM</td>
    </tr>
  </tbody>
</table>

<p>Every MSX cartridge must start with ASCII <code>&#34;AB&#34;</code> (<span>$41 </span> <span>$42 </span>) in order to be identified by the BIOS as a bootable ROM. We also know that this magic string must be mounted at <span>$4000 </span> on the cartridge, because that’s where the MSX looks to boot a cart.</p>

<p>I inspected Page 1, Slot 2 of the cartridge with <em>Tiny Slot Checker</em>’s hex viewer. Instead of <code>AB</code>, I saw <span>$C1 </span> <span>$84 </span> <span>$21 </span> <span>$C1 </span>!</p>

<p>I went back to my modern computer, and plugged that string into the search function in <a href="https://hexfiend.com/">my favourite hex editor, Hex Fiend</a>. The only place in the entire 4Mbit ROM where that byte string could be found was at the address <span>$72000 </span>, which means that when we accessed the ROM on the cart, A<sub>13</sub>, A<sub>16</sub>, A<sub>17</sub>, and A<sub>18</sub> are all stuck high.</p>

<h2 id="dont-be-a-dip">Don’t be a DIP</h2>
<p>For starters, that meant that my DIP-switch for choosing games also wasn’t working, because it’s the only thing that controls A<sub>17</sub> and A<sub>18</sub> on the ROM.</p>

<p>Oh, did I forget to mention that DIP switch earlier? I added it when I realized that it was the same price to get a 4-megabit SST39SF040 as it is a 1-megabit SST39SF010. This way, I could put <em>four</em> Konami MegaROM games on the same cart, which I think everyone agrees is more.</p>

<p>The DIP switch is its own kind of mapper, in that it controls the A<sub>17</sub> and A<sub>18</sub> lines of the ROM, splitting the 4Mbit ROM into four equal 1Mbit chunks (remember again that 2<sup>2</sup> = 4.) It’s just that it’s actuated with my greasy human fingers instead of an efficient, perfect machine.</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-backwards-rom-switch.png" alt="When the ROM switch is closed, it will short A17 and A18 low, defeating two 10k pullups. Unfortunately, it&#39;s only closed when it&#39;s &#34;on,&#34; which is the opposite of what you&#39;d expect."/></p>

<p>Once I checked my schematic, I realized I had wired the switch up backward. When the ROM switch is closed, it will short A17 and A18 low, defeating two 10k pullups. Unfortunately, it’s only closed when it’s “on,” which is the opposite of what you’d expect.</p>

<p>So that’s one bug found. I turned off the computer and flipped both DIP-switches to “ON.” If my theory was correct, I should now only see A<sub>13</sub> and A<sub>16</sub> high in page 1, or <span>$12000 </span>.</p>

<p>That’s not what I got. The byte string <span>$5b </span>, <span>$68 </span>, <span>$67 </span>, <span>$61 </span> was found at <span>$1e000 </span> – which sets A<sub>13</sub>, A<sub>14</sub>, A<sub>15</sub> and A<sub>16</sub>. Where did A<sub>14</sub> and A<sub>15</sub> come from all of a sudden? Page 2 was decoding to the segment at <span>$18000 </span>, which shouldn’t be possible, because it’s supposed to be a fixed mapping to <span>$00000 </span>!</p>

<h2 id="wild-pointers-could-not-drag-me-away-from-boot">Wild Pointers Could Not Drag Me Away From Boot</h2>
<p>Momentarily devoid of higher-order thought, I decided to power cycle the system and see if the pages moved around. If it was randomly changing, I could assume something was uninitialized or being driven by a floating pin. After letting the machine sit for awhile, I turned it back on to find that the same pages were shown in the same spots. What was going on, I asked the heavens, but they refused to bestow me with any better insights.</p>

<p>With my sanity returning, I decided to look at pictures of other MegaROM cartridges. I found a picture of a MegaFlashROM PCB, which stirred some memories. Surprising myself, I found a 512K Konami MegaFlashROM cartridge PCB that I had forgotten about in my MSX cartridges box. Whoops. I could’ve just built this in the first place.</p>

<p>With more luck, I immediately noticed that the 512K FlashMegaROM has a pretty prominent resistor network. Through the magic of datasheets and the continuity test, I determined that the FlashMegaROM cartridge is in fact pulling the segmented lines (all the high address outputs from the ‘670s) low!</p>

<p>It was only now that I remembered the datasheet for the ‘670 said it was <em>tri-state</em>: it can output true, false, or nothing at all. If I don’t select the ‘670, it doesn’t drive the output lines at all, leaving the ROM’s input address lines floating, and picking up whatever cosmic radio-frequency strangeness that also tells my cat what to do.</p>

<p>In other words, all the segmented address lines on my ROM were floating whenever I did an access to the “fixed” segment. You know, the segment that contains the boot code for the cart. By adding the pull-downs, those address lines are driven low by default, which keeps things consistent.</p>

<p>Normally, I would expect floating address pins to be completely random, but this was very consistent. My best guess is that, because Tiny Slot Checker is reading the ROM sequentially, quick enough to prevent decay of any internally latched matrix addresses, and always in the same order, there is some aspect of the ROM’s internal addressing logic that makes this fairly deterministic (if still useless.) If you have a better theory, please let me know.</p>

<p>I bodged a 10k onto the paged-A13 output of the 670, and suddenly I was now reading from <span>$1c000 </span> – A<sub>14</sub>, A<sub>15</sub>, and A<sub>16</sub> high, but <em>not</em> A<sub>13</sub>. Progress!</p>

<p>Okay, let’s bodge ‘em all.</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-bodged-resistors.jpg" alt="Four bodged 10k resistors are going from the various paged address pins to ground. You can also see my sharpie mark indicating that the mounting hole is too dang small."/></p>

<p>After some creative routing of 10ks to avoid shorts, I had wired up all four of the paged address pins. I turned on the system to see what <em>Tiny Slot Checker</em> would make of it, but I was surprised to see… a Konami logo<sup id="fnref:tsc-boot" role="doc-noteref"><a href="#fn:tsc-boot" rel="footnote">3</a></sup>!</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-salamander.jpg" alt="The title screen for Salamander"/></p>

<p>The MSX was booting into <em>Salamander</em>!</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-galious-title.jpg" alt="The logo for Maze of Galious"/></p>

<p>And with a quick adjustment of the DIP-switches, <em>Galious</em>!</p>

<h2 id="finishing-touches">Finishing Touches</h2>
<p>There’s one thing missing, as long as you ignore the fact that the PCB doesn’t work properly out of the box: a cartridge label. Form over function, that’s what I always say.</p>

<p>I decided to try and get a custom sticker made, and I went to a Canadian manufacturer, <a href="https://stickerbeaver.ca/">Sticker Beaver</a>. I’ve been meaning to use this shop for something for quite some time now, and I figure this was as good as a time as any.</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-case-sticker-arrived.jpg" alt="The sparkly Oyanami stickers arrived in a package with a Sticker Beaver promo brochure and some samples."/></p>

<p>After a lot of learning curve in Inkscape, and a little bit of back-and-forth with the proofs, I had these <a href="https://stickerbeaver.ca/stickers/glitter-stickers/">holographic glitter stickers</a> cut and sent to me. Even on the free shipping plan, it only took about three business days to arrive, but it was like waiting for Christmas morning.</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v1-case-with-sticker.jpg" alt="The sticker is applied to the Oyanami cartridge shell. It looks sparkly and beautiful."/></p>

<p>While I was waiting for the stickers, I had time to debug the board. Now that I knew what was wrong, I made some tweaks to the cartridge PCB. I added a resistor network to provide the pull-downs (rolling the DIP-switch resistors into it in the process,) and fixed the mounting holes. Then I reordered it from JLCPCB, this time choosing ENIG gold plating.</p>

<p>These new Oyanami Gold cartridges cost more money to make because of the ENIG, but I think we can all agree that they look pretty cool. And now they fit in the case!</p>

<p><img src="https://www.leadedsolder.com/assets/oyanami-v2-installed-in-case.jpg" alt="The gold version-2 cartridge stuck into a case."/></p>

<p>That is, as long as you don’t want to socket your ROMs; there’s not quite enough height, a common complaint about MSX cartridges. This one is soldered down.</p>

<h2 id="maze-of-galious">Maze of Galious</h2>
<p>Ah, the part of the project where I get to play a game for five minutes! I did a quick check to make sure the game was bootable, then spent thirty minutes digging out my AV capture/splitter rig and its hydra of cables and messing with OBS to record a short clip.</p>

<p>Although <em>Galious</em> involves a lot of keyboard action (for instance, F1 to open the sub-screen menu,) all the movement, combat, and tricky platforming is easier with a d-pad. That’s where <a href="https://ompearetro.com/shop/ols/products/fm2and6-custom-controller-for-fm-towns-and-other-japanese-pcs">the FM2AND6</a> comes in:</p>

<p><img src="https://www.leadedsolder.com/assets/cf2700-and-fm2and6.jpg" alt="A white game controller, reading &#34;FM2AND6,&#34; is sitting on top of the stark black National CF2700 MSX."/></p>

<p>Made by blog friend OMPeaRetro, the FM2AND6 is a familiar controller layout that’s got a new PCB inside. It offers a no-brainer setup for 2-button games on old Japanese PCs, including the MSX, and 6-button games on the FM Towns. You’ll hear more about it later, but for now it’s going to help Popolon and Aphrodite dole out the harshness.</p>

<center><iframe width="560" height="315" src="https://www.youtube.com/embed/ht72N8Vc1zE?si=QmGodM6B0Zixy4KM" title="YouTube video player - the Maze of Galious on Oyanami MegaROM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></center>

<h2 id="conclusion">Conclusion</h2>
<p><img src="https://www.leadedsolder.com/assets/oyanami-v2-installed-in-msx.jpg" alt="The finished cartridge is inserted into the HB-101, and a sparkly reflection can be seen on the gloss black of the case."/></p>

<p>This was a fun project to do! It all came together fairly quickly, thanks to the help of some smart friends. And playing these old Konami games is a lot of fun.</p>

<p>You can download <a href="https://github.com/barbeque/oyanami-msx-megarom">the cartridge KiCad files</a> for yourself from the GitHub repository. There’s also a bunch of <a href="https://github.com/barbeque/oyanami-msx-megarom/releases">Gerbers on the release page</a>, which can be sent directly to fabrication.</p>

<p>Now if only I could reflash this cart on the fly… and load games from a host PC… and… and… and…</p>


  </article></div>
  </body>
</html>
