<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://compiler.club/compiling-pattern-matching/">Original</a>
    <h1>Compiling Pattern Matching</h1>
    
    <div id="readability-page-1" class="page"><div><h3 id="introduction">Introduction</h3>
<p>This post intends to provide a brief overview of the algorithm described in Luc Maranget’s
“<a href="http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf">Compiling Pattern Matching to Good Decision Trees</a>”.</p>
<p>I’m fond of this formalisation as it has a straightforward implementation and results
in reasonable decision trees for the majority of practical instances of pattern matching
encountered in functional programming.
Additionally, the resulting decision tree is easy to reason about and can be used as the basis
of related transformations - such as translating into matching over simple patterns (patterns without nesting), or directly into an intermediary
representation with join points (a potential way to express branching control flow in normal-form intermediate representations).</p>
<h3 id="the-matrix">The Matrix</h3>
<p>The central data structure in the algorithm is that of a pattern matrix and associated occurrence and
action vectors.</p>
<p><img src="https://compiler.club/img/dt/main.svg" alt="pattern matrix and vectors"/></p><ul>
<li>Pattern matrix - stores examinable patterns appearing on the left-hand side of pattern matching rules.
The “examinable” refers to the fact that each cell stores a pattern that can be scrutinised against a matching criteria (the refutable component of patterns) -
as we’ll see in this scheme, tuples do not directly appear in cells of the pattern matrix, but their components do (as it is assumed that the arity of a tuple cannot be refuted - otherwise prior typechecking would fail in ML).
The core compilation algorithm works by performing transformations on the pattern matrix, decomposing patterns that admit certain constructors (and values).</li>
<li>Occurrence vector - describes sequence of extractions required to fetch the associated value from a column in the pattern matrix. Occurrences must be maintained during decomposition of the pattern matrix as they
effectively describe the access paths to the scrutinees of the n-way branches of the interior nodes in the resulting decision tree.</li>
<li>Action vector - stores corresponding actions for each row in the pattern matrix. These are the expressions that appear on the right-hand side of pattern matching rules (or some other identifying value, as they may appear in multiple leaves of the decision tree). Upon successful matching of a pattern, the associated
action is executed (actions therefore appear as leaves in the decision tree or, as we’ll come to see, sink nodes in the associated DAG representation).</li>
</ul>
<h3 id="matrix-operations">Matrix Operations</h3>
<p>The following sections describe the transformations performed during the algorithm.</p>
<h3 id="construction">Construction</h3>
<p>The construction of the pattern matrix and related action and occurrence vectors requires some care.
The primary difficulty comes from the inclusion of tuples.</p>
<p>In the case of tuples, they are never directly stored in cells of the pattern matrix - their components are.
This is exemplified by the first example in Maranget’s paper concerning the implementation of a canonical
<code>merge</code> function in an ML-like language:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>fun</span> <span>merge</span> xs ys = 
</span></span><span><span>  <span>case</span> <span>(</span>xs<span>,</span> ys<span>)</span> <span>of</span>
</span></span><span><span>     <span>(</span>Nil<span>,</span> <span>_)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span>   | <span>(_,</span> Nil<span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span>   | <span>(</span>Cons <span>(</span>x<span>,</span> xs<span>),</span> Cons <span>(</span>y<span>,</span> ys<span>))</span> =&gt; <span>(* 3 *)</span>
</span></span></code></pre></div><p>For clarity, I’ve opted to name <code>list</code> constructors explicitly (as <code>Nil</code> and <code>Cons</code>).</p>
<p>The initial pattern matrix and associated vectors will look like this:</p>
<p><img src="https://compiler.club/img/dt/first.svg" alt="example initial pattern matrix"/></p><p>The <code>v</code> appearing in the occurrence vector denotes the scrutinee of the <code>case</code> (<code>(xs, ys)</code>).
The <code>v.i</code> notation denotes a projection.
It’s written this way to make the presentation shorter. Furthermore, it is implicitly assumed that
the base of occurrences are not actually the original expressions themselves, but a variable that refers to them.
This is because, when generating code for each match case, you can bring the relevant pattern variables
into scope by introducing them with <code>let</code> bindings (that bind the result of translating occurrences into the relevant unwrappings and projections).
To avoid potentially duplicating an effectful operation when introducing these variables, it’s assumed a kind of
normalisation is performed to give a name to the expression being matched upon.
This kind of legalisation can be performed before match compilation
or potentially during a combined normalisation algorithm, where normalising the scrutinee of a <code>case</code> will yield an atomic value.</p>
<p>As you can see in the above illustration, the pattern matrix does not retain the structure of the tuples
appearing in each rule of the match. When translating a tuple pattern into a row for the pattern matrix,
you introduce a column for each component. Each component is additionally labelled with an occurrence that denotes
the projection from the relevant index of the tuple.</p>
<p>Another source of complexity comes from the fact that patterns in a <code>case</code> need not have the same shape.
This scenario is typified by catch-all pattern variables that may follow tuple patterns.
Consider the following snippet of SML code:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> f <span>()</span> <span>of</span> 
</span></span><span><span>   <span>(</span>SOME x<span>,</span> <span>_)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span> | t =&gt; <span>(* 2 *)</span>
</span></span></code></pre></div><p>The problem with the above is that <code>t</code> will disappear when constructing the pattern matrix because columns
for components of the prior tuple are introduced instead.
A solution for this scenario may be a prior legalisation that moves top-level pattern variables to the right-hand
side of match rules:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>let</span> <span>val</span> <span>v</span> <span>=</span> f <span>()</span> <span>in</span>
</span></span><span><span>  <span>case</span> v <span>of</span> 
</span></span><span><span>     <span>(</span>SOME x<span>,</span> <span>_)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span>   | <span>_</span> =&gt; <span>let</span> <span>val</span> <span>t</span> <span>=</span> v <span>in</span> <span>(* 2 *)</span> <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>Doing this will ensure that <code>t</code> will be in scope for the code in <code>(* 2 *)</code>.</p>
<p>Another way of ensuring the shape of patterns don’t introduce annoying edge cases or require writing the program is to bookkeep each pattern in terms of its occurrences.
For example, in my own simple implementation of the match compilation algorithm (<a href="https://github.com/contificate/match">here</a>), construction of the pattern matrices is done by collecting
dictionaries (one for each pattern), mapping occurrences to their related pattern components. Then, a matrix is constructed by filling in a table whose columns are the occurrences traversed during the dictionary creation process (in the left-to-right order they were visited). From this perspective, much of the match compilation algorithm can be seen as building and decomposing tables (matrices).</p>
<h3 id="specialisation">Specialisation</h3>
<p>In order to transform the matrix and vectors into a state that represents the successful matching of a value or constructor upon a collection of rows, specialisation is performed. Specialisation is an operation that retains only the rows of the matrix that admit a specified value or constructor,
simultaneously decomposing value-carrying sub-patterns into their corresponding entries in the pattern matrix and occurrence vector (with requirements similar to that of the initial construction of the pattern matrix).</p>
<p>Consider the following code snippet and associated initial pattern matrix and vectors:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> v <span>of</span>
</span></span><span><span>   Some <span>(</span><span>1</span><span>,</span> x<span>)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span> | Some <span>(</span>y<span>,</span> <span>2</span><span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span> | None =&gt; <span>(* 3 *)</span>
</span></span></code></pre></div><p><img src="https://compiler.club/img/dt/2.svg" alt="initial pattern matrix"/></p><p>Specialisation of the <code>Some</code> constructor yields the following:</p>
<p><img src="https://compiler.club/img/dt/3.svg" alt="initial pattern matrix"/></p><p>Here, <code>[v]</code>, denotes accessing the value held by the constructor.
The appeal of the matrix formalism for simultaneous matching is clear when you consider that the resultant matrix effectively models the inner <code>case</code> of the
following snippet:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> v <span>of</span>
</span></span><span><span>   Some z =&gt;
</span></span><span><span>     <span>case</span> z <span>of</span> 
</span></span><span><span>        <span>(</span><span>1</span><span>,</span> x<span>)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span>      | <span>(</span>y<span>,</span> <span>2</span><span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span>     <span>end</span>
</span></span><span><span> | None =&gt; <span>(* 3 *)</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>where <code>z</code> is a name given to the unwrapping occurrence.
It is not hard to see that the resultant decision tree can be used to rewrite pattern matching into matching over simple patterns.</p>
<p>Similarly, specialising the original matrix from above upon <code>None</code> yields the following:</p>
<p><img src="https://compiler.club/img/dt/4.svg" alt="specialisation of None"/></p><p>Note that, for consistency, nullary constructors such as <code>None</code> must be treated as though they carry unit, <code>()</code>, which - when introduced to the pattern matrix - will
construct a row with a single wildcard pattern. The reason for this is for consistency and to avoid a case of the algorithm (described in a later section)
that would treat an empty matrix as indicative of matching failure.</p>
<h3 id="defaulting">Defaulting</h3>
<p>Producing the <em>default</em> matrix of a given pattern matrix retains only the rows that match constructors or values not already present
in the column being scrutinised.
In other words, if the column being scrutinised contains an irrefutable (either a pattern variable or wildcard) entry, then its decomposition
is included in the default matrix.
Or, in the case where matching is inexhaustive, defaulting creates an empty pattern matrix (since there are no rows to admit any constructor or value).
Intuitively, if each interior node of the decision tree <code>switch</code>es on a column’s value (using the occurence for that column), then
defaulting is used to create the <code>default</code> case (to account for constructors or values not present).</p>
<p><img src="https://compiler.club/img/dt/5.svg" alt="defaulting"/></p><p>Note that specialisation and defaulting may produce matrices with rows in common.
Additionally, it may be important that defaulting retains variables and their occurrences (in order to introduce pattern variables into scope upon a sucessful match).
This concern is mitigated in Maranget’s explanation of the algorithm as their paper
dispenses of pattern variables, considering only wildcards (which can be thought of as locally unique pattern variables with no uses).</p>
<h3 id="swapping">Swapping</h3>
<p>To aid with implementation of the algorithm, an auxiliary operation that swaps columns of the pattern matrix (and, consequentially, the occurrence vector) must be implemented. As you will see in the following section that describes the algorithm, all prior references to the “column being scrutinised” actually refer only to the first column, as matching proceeds left-to-right; ensuring that there is always a refutable pattern in the first column by potentially swapping it for another.</p>
<p><img src="https://compiler.club/img/dt/6.svg" alt="swapping"/></p><h3 id="the-algorithm">The Algorithm</h3>
<p>The algorithm is well described in the paper, but I will recite it here anyway.
It’s defined as recursive function that performs case analysis over the provided matrix.
The cases are as follows:</p>
<ol>
<li>
<p>If the pattern matrix is empty, that implies it was produced by a defaulting operation that could find
no row to include, so it is indicative of matching failure. A leaf node indicating failure is returned.</p>
</li>
<li>
<p>If the first row of the pattern matrix is irrefutable (i.e. only pattern variables or wildcards), then
matching has succeeded and we return a leaf node containing a reference to the action vector entry the for the first row.</p>
<p>If there are other rows in the pattern matrix that are also irrefutable then that implies the pattern corresponding to the first row
subsumes them. In other words, those extra rows are redundant as they can never be reached.</p>
</li>
<li>
<p>If neither of the previous cases hold then we look for a column that contains at least one refutable entry.
If the found column is not the first one, we make it the first by swapping their positions.</p>
<p>Now that the first column is refutable, we collect a form of signature by analysing each entry.
If the column’s type is a variant, then we collect all the names of constructors from entries that contain
variant constructor patterns (for example, we would collect <code>Some</code> if we encounter <code>Some (1, x)</code>). A similar collection is done for other kinds of refutable patterns, such as integer constants.</p>
<p>Once the signatures are collected, a specialised matrix is produced for each one. Those matrices are then recursively compiled by the
algorithm and the resultant decision trees are recorded as targets of an n-way switching node in the decision tree.</p>
<p>If the signature is not complete, i.e. does not contain all potential constructors for a given type, then the default matrix is computed
for the original matrix - the resultant decision tree is then included among the alternatives of the returned switch node as the default case.</p>
</li>
</ol>
<h3 id="example">Example</h3>
<p>Below is a complete annotated example of the conceptual process of computing the decision tree for the following SML snippet:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> v <span>of</span>
</span></span><span><span>   Some <span>(</span><span>1</span><span>,</span> x<span>)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span> | Some <span>(</span>y<span>,</span> <span>2</span><span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span> | None =&gt; <span>(* 3 *)</span>
</span></span></code></pre></div><p><img src="https://compiler.club/img/dt/7.svg" alt="full example"/></p><h3 id="further-examples">Further examples</h3>
<p>Below are a few example SML snippets and their corresponding decision trees, produced by my implementation of the algorithm described above:</p>
<p>First, the example given in the paper (for <code>merge</code> or a similar function, such as <code>zip</code>):</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> e <span>of</span>
</span></span><span><span>    <span>(</span>Nil<span>,</span> <span>_)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span>  | <span>(_,</span> Nil<span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span>  | <span>(</span>Cons <span>(</span>x<span>,</span> xs<span>),</span> Cons <span>(</span>y<span>,</span> ys<span>))</span> =&gt; 
</span></span></code></pre></div><p><img src="https://compiler.club/img/dt/a-1.svg" alt="full example"/></p><p>Secondly, a more compact presentation of the running example used in this article:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> e <span>of</span>
</span></span><span><span>   Some <span>(</span><span>1</span><span>,</span> x<span>)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span> | Some <span>(</span>y<span>,</span> <span>2</span><span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span> | None =&gt; <span>(* 3 *)</span>
</span></span></code></pre></div><p><img src="https://compiler.club/img/dt/a-2.svg" alt="full example"/></p><p>Finally, Okasaki’s red-black tree <code>balance</code> function (from “Purely Functional Data Structures”):</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> e <span>of</span>
</span></span><span><span>   <span>(</span>B<span>,</span>T <span>(</span>R<span>,</span>T <span>(</span>R<span>,</span>a<span>,</span>x<span>,</span>b<span>),</span>y<span>,</span>c<span>),</span>z<span>,</span>d<span>)</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span> | <span>(</span>B<span>,</span>T <span>(</span>R<span>,</span>a<span>,</span>x<span>,</span>T <span>(</span>R<span>,</span>b<span>,</span>y<span>,</span>c<span>)),</span>z<span>,</span>d<span>)</span> =&gt; <span>(* 2 *)</span>
</span></span><span><span> | <span>(</span>B<span>,</span>a<span>,</span>x<span>,</span>T <span>(</span>R<span>,</span>T <span>(</span>R<span>,</span>b<span>,</span>y<span>,</span>c<span>),</span>z<span>,</span>d<span>))</span> =&gt; <span>(* 3 *)</span>
</span></span><span><span> | <span>(</span>B<span>,</span>a<span>,</span>x<span>,</span>T <span>(</span>R<span>,</span>b<span>,</span>y<span>,</span>T <span>(</span>R<span>,</span>c<span>,</span>z<span>,</span>d<span>)))</span> =&gt; <span>(* 4 *)</span>
</span></span><span><span> | body =&gt; <span>(* 5 *)</span>
</span></span></code></pre></div><p><img id="rb" src="https://compiler.club/img/dt/rb.svg" alt="full example"/></p><p>I include this example because it illustrates an important point - those aware of the implementation of <code>balance</code>
will know that every case, except the last, has the same body. So, in SuccessorML, one would write this as a disjunctive pattern:</p>
<div><pre tabindex="0"><code data-lang="sml"><span><span><span>case</span> e <span>of</span>
</span></span><span><span>   <span>(</span>B<span>,</span>T <span>(</span>R<span>,</span>T <span>(</span>R<span>,</span>a<span>,</span>x<span>,</span>b<span>),</span>y<span>,</span>c<span>),</span>z<span>,</span>d<span>)</span>
</span></span><span><span> | <span>(</span>B<span>,</span>T <span>(</span>R<span>,</span>a<span>,</span>x<span>,</span>T <span>(</span>R<span>,</span>b<span>,</span>y<span>,</span>c<span>)),</span>z<span>,</span>d<span>)</span>
</span></span><span><span> | <span>(</span>B<span>,</span>a<span>,</span>x<span>,</span>T <span>(</span>R<span>,</span>T <span>(</span>R<span>,</span>b<span>,</span>y<span>,</span>c<span>),</span>z<span>,</span>d<span>))</span>
</span></span><span><span> | <span>(</span>B<span>,</span>a<span>,</span>x<span>,</span>T <span>(</span>R<span>,</span>b<span>,</span>y<span>,</span>T <span>(</span>R<span>,</span>c<span>,</span>z<span>,</span>d<span>)))</span> =&gt; <span>(* 1 *)</span>
</span></span><span><span> | body =&gt; <span>(* 2 *)</span>
</span></span></code></pre></div><p>If compilation were to naively proceed by duplicating the body at <code>(* 1 *)</code> for each case, we would get the same decision tree as above.
A more involved approach would attempt to achieve sharing by constructing a DAG (directed acyclic graph) in order to deduplicate the repeated rule bodies.
However, naively doing this from the above tree may produce a DAG that contains redundant decisions (e.g. value and <code>default</code> branches that have the same destination).
A possible approach would be to attempt to optimise the DAG after-the-fact and then, when emitting code for the decision tree, the shared rule body becomes its own function that
receives its variables (those bound as pattern variables and free variables - similar to lambda lifting) as arguments. Then, dependent on the path followed to get there, the variables will be projected from the scrutinee and
provided as arguments to the deduplicated function.</p>
<p>The simple approach is to identify sharing upon construction of nodes in the decision tree, by means of hash consing.
This approach is described in Pettersson’s book “Compiling Natural Semantics” and the one I took for my own implementation.</p>
<p>Below, you can see the decision DAG (for the <code>balance</code> example) resulting from an implementation that uses hash consing:</p>
<p><img id="rb" src="https://compiler.club/img/dt/dag.png" alt="decision dag"/></p><hr/>
<h3 id="an-implementation">An Implementation</h3>
<p>In the time since writing this article, I’ve created a very simple implementation of the algorithm <a href="https://github.com/contificate/match">here</a>.
Along with providing a faithful implementation of the core ideas described in this article, it also provides a small user interface for playing around with seeing potential decision trees.</p>
<p><img id="rb" src="https://compiler.club/img/dt/repo.gif" alt="user interface"/></p><hr/>
<h3 id="further-reading">Further Reading</h3>
<ul>
<li>[<a href="https://ccs.neu.edu/~types/resources/a-fpca-1985.pdf">Augustsson 85</a>] - compiles pattern matching to backtracking automata, thus ensuring code size that is linear in the size of the original pattern matching expression, but potentially checking subterms multiple times.</li>
<li>[<a href="https://www.classes.cs.uchicago.edu/archive/2011/spring/22620-1/papers/pettersson92.pdf">Pettersson 92</a>] - models the match compilation problem as the construction of a DFA for a regular language, thus enabling
certain forms of optimisations (viewed as minimisation of the DFA) and checking of various matching properties such as exhaustiveness and redundancy.</li>
<li>[<a href="https://link.springer.com/book/10.1007/b71652">Pettersson 99</a>] - Pettersson’s book “Compiling Natural Semantics” contains a more detailed retelling of the algorithm described in the work above.</li>
<li>[<a href="https://github.com/JohnReppy/compiling-pattern-guards">Reppy et al. 19</a>] - considers compilation of Successor ML guards. The linked repository also has several implementations of various approaches to the compilation
of pattern matching.</li>
</ul>
<h3 id="afterword">Afterword</h3>
<p>In efforts to teach the core idea of the algorithm described in this blog article,
I’ve found that it’s beneficial to start with simpler examples - consisting purely of tuples of, say, integers patterns (no wildcards or variable patterns).
Then, once someone is familiar with the general approach (matrix specialisation), adding all the bookkeeping for pattern variables, defaulting of the matrix, deconstructing nested patterns into the matrix, etc. become reasonable extension projects for them to program around.</p>
<p>For example, in the OCaml compiler, pattern matching over constant strings actually follows the simpler subset of the match compilation algorithm described in this article. I hope to dedicate a future article to this - but, until then, an excellent description of the core idea has been given by Gabriel Scherer on the OCaml forum <a href="https://discuss.ocaml.org/t/constant-string-pattern-matching/10801/4">here</a>.</p>
</div></div>
  </body>
</html>
