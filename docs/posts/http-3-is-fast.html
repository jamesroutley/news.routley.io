<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://requestmetrics.com/web-performance/http3-is-fast">Original</a>
    <h1>HTTP/3 Is Fast</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>HTTP/3 is here, and it’s a big deal for web performance.  See just how much faster it makes websites!</p>

<!--more-->

<p>Wait, wait, wait, what happened to HTTP/2?  Wasn’t that all the rage only a few short years ago?  It sure was, but there were some <a href="https://en.wikipedia.org/wiki/HTTP/2#Criticisms">problems</a>. To address them, there’s a <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html">new version</a> of the venerable protocol working its way through the standards track.</p>

<p>Ok, but does HTTP/3 actually make things faster?  It sure does, and we’ve got the benchmarks to prove it.</p>

<h2 id="a-quick-preview">A Quick Preview</h2>
<p>Before we get too deep in the details, let’s look at a quick preview of the benchmark results.  In the charts below the same browser was used to request the same site, over the same network, varying only the HTTP protocol in-use.  Each site was retrieved 20 times and the response time measured via the performance API. (More details on <a href="#benchmarking-http3">benchmark methodology</a> later)</p>

<p>You can clearly see the performance improvement as each new version of the HTTP protocol is used:</p>

<figure>
  <p><img data-src="https://requestmetrics.com/assets/images/webperf/http3/ny-all-protocols.png" width="1144" loading="lazy" height="353" alt="Comparing the three HTTP protocol versions when loading pages from NY"/>
  </p>
</figure>

<p>And the changes become even more pronounced when requesting resources over larger geographic distances and less reliable networks.</p>

<p>But before we can get fully in to all the HTTP/3 benchmark minutiae, a little context is required.</p>

<h2 id="a-brief-history-of-http">A Brief History of HTTP</h2>

<p>The <a href="https://datatracker.ietf.org/doc/html/rfc1945">first official version</a> of HTTP (Hypertext Transfer Protocol 1.0) was finalized in 1996.  There were some practical issues and parts of the standard that needed updating, so <a href="https://datatracker.ietf.org/doc/html/rfc2068">HTTP/1.1</a> was released a year later in 1997.  Per the authors:</p>

<blockquote>
  <p>However, HTTP/1.0 does not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, and virtual  hosts. In addition, the proliferation of incompletely-implemented applications calling themselves “HTTP/1.0” has necessitated a protocol version change in order for two communicating applications to determine each other’s true capabilities.</p>
</blockquote>

<p>It would be 18 more years before a new version of HTTP was released.  In 2015, and with much fanfare, <a href="https://datatracker.ietf.org/doc/html/rfc7540">RFC 7540</a> would standardize HTTP/2 as the next major version of the protocol.</p>

<h3 id="one-file-at-a-time">One File at a Time</h3>
<p>If a web page requires 10 javascript files, the web browser needs to retrieve those 10 files before the page can finish loading.  In HTTP/1.1-land, the web browser can only download a single file at a time over a TCP connection with the server.  This means the files are downloaded sequentially, and any delay in one file would block everything else behind it.  This is called <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head-of-line Blocking</a> and it’s not good for performance.</p>

<p>To work around this, browsers can open multiple TCP connections to the server to parallelize the data retrieval.  But this approach is resource intensive.  Each new TCP connection requires client and server resources, and when you add TLS in the mix there’s plenty of SSL negotiation happening too.  A better way was needed.</p>

<h3 id="multiplexing-with-http2">Multiplexing with HTTP/2</h3>
<p>HTTP/2’s big selling point was multiplexing. It fixed <em>application level</em> head-of-line blocking issues by switching to a binary over-the-wire format that allowed multiplexed file downloads.  That is, a client could request all 10 files at once and start downloading them all in parallel over a single TCP connection.</p>

<p>Unfortunately HTTP/2 still suffers from a head-of-line blocking issue, just one layer lower. TCP itself becomes the weak link in the chain.  Any data stream that loses a packet must wait until that packet is <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-prior-versions-of-http">retransmitted to continue</a>.</p>

<blockquote>
  <p>However, because the parallel nature of HTTP/2’s multiplexing is not visible to TCP’s loss recovery mechanisms, a lost or reordered packet causes all active transactions to experience a stall regardless of whether that transaction was directly impacted by the lost packet.</p>
</blockquote>

<p>In fact, in high packet loss environments, HTTP/1.1 performs better because of the multiple parallel TCP connections the browser opens!</p>

<h3 id="true-multiplexing-with-http3-and-quic">True Multiplexing with HTTP/3 and QUIC</h3>
<p>Enter HTTP/3.  The major difference between HTTP/2 and HTTP/3 is which transport protocol they use. Instead of TCP, HTTP/3 uses a new protocol called <a href="https://www.rfc-editor.org/rfc/rfc9000.html">QUIC</a>.  QUIC is a general purpose transport protocol meant to address the head-of-line blocking issues HTTP/2 has with TCP.  It allows you to create a <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-delegation-to-quic">series of stateful streams</a> (similar to TCP) over UDP.</p>

<figure>
  <img data-src="https://requestmetrics.com/assets/images/webperf/http3/udp-joke.min.png" width="400" height="480" loading="lazy" alt="I have a UDP Joke... but you might not get it"/>
</figure>

<blockquote>
  <p>The QUIC transport protocol incorporates stream multiplexing and per-stream flow control, similar to that provided by the HTTP/2 framing layer. By providing reliability at the stream level and congestion control across the entire connection, <strong>QUIC has the capability to improve the performance of HTTP compared to a TCP mapping</strong></p>
</blockquote>

<p>And improve the performance of HTTP it does!  <a href="#so-how-fast-is-http3">Jump to the results if you don’t care about how the test was conducted</a></p>

<h2 id="benchmarking-http3">Benchmarking HTTP/3</h2>
<p>To see just what sort of performance difference HTTP/3 makes, a benchmarking test setup was needed.</p>
<h3 id="the-html">The HTML</h3>
<p>In order to more closely approximate actual usage, the test setup consisted of three scenarios - a small site, a content-heavy site (lots of images and some JS), and a single page application (heavy on the JS).  I looked at several real-world sites and averaged the number of images and JS files for each, then coded up some demo sites that matched those resource counts (and sizes).</p>

<ul>
  <li>Small Site
    <ul>
      <li><strong>10</strong> JS files from 2kb to 100kb</li>
      <li><strong>10</strong> images from 1kb to 50kb</li>
      <li>Total payload size <strong>600kb</strong>, 20 blocking resources total</li>
    </ul>
  </li>
  <li>Content Site
    <ul>
      <li><strong>50</strong> JS files from 2kb to 1mb</li>
      <li><strong>55</strong> images ranging in size from 1kb to 1mb.</li>
      <li>Total payload size <strong>10MB</strong>, 105 resources total (look at cnn.com sometime in dev tools and you’ll see why this is so big)</li>
    </ul>
  </li>
  <li>Single Page Application
    <ul>
      <li><strong>85</strong> JS files from 2kb to 1mb</li>
      <li><strong>30</strong> images ranging in size from 1kb to 50kb.</li>
      <li>Total payload size <strong>15MB</strong>, 115 resources total (look at JIRA sometime in dev tools)</li>
    </ul>
  </li>
</ul>

<h3 id="the-server">The Server</h3>
<p><a href="https://caddyserver.com/">Caddy</a> was used to serve all assets and HTML.</p>

<ul>
  <li>All responses were served with <code>Cache-Control: &#34;no-store&#34;</code> to ensure the browser would re-download every time.</li>
  <li>TLS 1.2 was used for HTTP/1.1 and HTTP/2</li>
  <li><a href="https://www.rfc-editor.org/rfc/rfc9001.html">TLS 1.3</a> was used for HTTP/3.</li>
  <li><a href="https://www.rfc-editor.org/rfc/rfc9001.html#name-0-rtt">0-RTT</a> was enabled for all HTTP/3 connections</li>
</ul>

<h3 id="the-locations">The Locations</h3>
<p>The tests were conducted from my computer in Minnesota, to three separate datacenters hosted by Digital Ocean:</p>

<ul>
  <li>New York, USA</li>
  <li>London, England</li>
  <li>Bangalore, India</li>
</ul>

<h3 id="the-client">The Client</h3>
<p>I automated the browser to request the same page 20 times in a row, waiting 3 seconds after page load to begin the next request.  The internet connection is rated at 200mbps.  No other applications were running on the computer at the time of data capture.</p>

<h2 id="so-how-fast-is-http3">So How Fast Is HTTP/3?</h2>
<h3 id="new-york-usa">New York, USA</h3>
<p>Here’s the response times of HTTP/2 vs. HTTP/3 when requesting the three different sites from the NY datacenter:</p>

<figure>
  <p><img data-src="https://requestmetrics.com/assets/images/webperf/http3/ny-http2and3.png" width="749" loading="lazy" height="353" alt="Comparing HTTP/2 and HTTP/3 protocol versions when loading pages from NY"/>
  </p>
</figure>

<p>HTTP/3 is:</p>
<ul>
  <li><strong>200ms</strong> faster for the Small Site</li>
  <li><strong>325ms</strong> faster for the Content Site</li>
  <li><strong>300ms</strong> faster for the Single Page Application</li>
</ul>

<p>The distance from Minnesota to New York is 1,000 miles, which is pretty small by networking standards.  It’s significant that even at a relatively short distance HTTP/3 was able to improve performance this much.</p>

<h3 id="london-england">London, England</h3>
<p>I’ve included the HTTP/1.1 benchmarking run for London in the results as well.  In order to show just how much faster HTTP/2 and HTTP/3 are, I’ve kept the graphs to the same scale.  You can see that for the Content Site, the timings are so slow that they don’t even fit entirely on the graph!</p>

<figure>
  <p><img data-src="https://requestmetrics.com/assets/images/webperf/http3/london-all-protocols.png" width="1144" loading="lazy" height="353" alt="Comparing the three HTTP protocol versions when loading pages from London"/>
  </p>
</figure>

<p>As you can see, the speed increase is even more pronounced when greater distances over the network are in play.  HTTP/3 is:</p>
<ul>
  <li><strong>600ms</strong> faster for the Small Site (<strong>3x</strong> the speedup compared with New York)</li>
  <li><strong>1200ms</strong> faster for the Content Site (over <strong>3.5x</strong> the speedup compared with New York)</li>
  <li><strong>1000ms</strong> faster for the Single Page Application (over <strong>3x</strong> the speedup compared with New York)</li>
</ul>

<h3 id="bangalore-india">Bangalore, India</h3>
<p>The performance improvement with HTTP/3 is extremely pronounced when loading pages from the server in India.  I didn’t even run an HTTP/1.1 test because it was so slow.  Here are the results of HTTP/2 vs. HTTP/3:</p>

<figure>
  <p><img data-src="https://requestmetrics.com/assets/images/webperf/http3/india-http2and3.png" width="749" loading="lazy" height="353" alt="Comparing the three HTTP protocol versions when loading pages from India"/>
  </p>
</figure>

<p>HTTP/3 continues to pull ahead when larger geographies and more network hops are involved.  What’s perhaps more striking is just how tightly grouped the response times are for HTTP/3.  QUIC is having a big impact when packets are traveling thousands of miles.</p>

<p>In every case HTTP/3 was faster than its predecessor!</p>

<h3 id="why-is-http3-so-much-faster">Why is HTTP/3 so Much Faster?</h3>

<h4 id="real-multiplexing">Real Multiplexing</h4>
<p>The true multiplexed nature of HTTP/3 means that there is no Head-of-line blocking happening anywhere on the stack.  When requesting resources from further away, geographically, there is a much higher chance of packet loss and the need for TCP to re-transmit those packets.</p>

<h4 id="0-rtt-is-a-game-changer">0-RTT Is a Game Changer</h4>
<p>Additionally, HTTP/3 supports <a href="https://www.rfc-editor.org/rfc/rfc9001.html#section-4.6-1">O-RTT</a> QUIC connections, which lowers the number of round trips required to establish a secure TLS connection with the server.</p>

<blockquote>
  <p>The 0-RTT feature in QUIC allows a client to send application data before the handshake is complete. This is made possible by reusing negotiated parameters from a previous connection. To enable this, 0-RTT depends on the client remembering critical parameters and providing the server with a TLS session ticket that allows the server to recover the same information.</p>
</blockquote>

<p>However, 0-RTT should not be blindly enabled.  There are some <a href="https://www.rfc-editor.org/rfc/rfc8446#section-2.3">possible</a> <a href="https://www.rfc-editor.org/rfc/rfc9001.html#name-replay-attacks-with-0-rtt">security concerns</a> depending on your threat model.</p>

<blockquote>
  <p>The security properties for 0-RTT data are weaker than those for other kinds of TLS data.  Specifically:</p>
  <ol>
    <li>This data is not forward secret, as it is encrypted solely under keys derived using the offered PSK.</li>
    <li>There are no guarantees of non-replay between connections.</li>
  </ol>
</blockquote>

<h2 id="can-i-use-http3-today">Can I Use HTTP/3 Today?</h2>
<p>Maybe!  While the protocol is currently in <em>Internet-Draft</em> status, there are plenty of existing <a href="https://en.wikipedia.org/wiki/HTTP/3#Server">implementations</a>.</p>

<p>I specifically chose <strong>Caddy</strong> for these benchmarks because HTTP/3 can be enabled with a <a href="https://caddyserver.com/docs/caddyfile/options#protocol">simple config value</a> in the <code>Caddyfile</code></p>

<p>NGINX also has experimental support and is <a href="https://www.nginx.com/blog/our-roadmap-quic-http-3-support-nginx/">working towards an official HTTP/3</a> release in the near future.</p>

<p>The big tech players like Google and Facebook are serving their traffic over HTTP/3 already.  <a href="https://google.com">Google.com</a> is entirely served over HTTP/3 for modern browsers.</p>

<p>For those folks stuck in the Windows ecosystem, supposedly Windows Server 2022 will support HTTP/3, with some rather <a href="https://techcommunity.microsoft.com/t5/networking-blog/enabling-http-3-support-on-windows-server-2022/ba-p/2676880">esoteric steps required</a> to enable it.</p>

<h2 id="conclusion">Conclusion</h2>
<p>HTTP/3 can make a big difference in how users experience your site.  In general, the more resources your site requires, the bigger the performance improvement you’ll see with HTTP/3 and QUIC.  As the standard continues to inch closer to finalization, it may be time to start looking at enabling it for your sites.</p>

</div></div>
  </body>
</html>
