<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2017/06/28/notes-on-bpf---ebpf/">Original</a>
    <h1>Notes on BPF and eBPF</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Today it was Papers We Love, my favorite meetup! Today <a href="http://suchakra.in/">Suchakra Sharma</a> (<a href="https://twitter.com/tuxology">@tuxology</a> on twitter/github)
gave a GREAT talk about the original BPF paper and recent work in Linux on
eBPF. It really made me want to go write eBPF programs!</p>
<p>The paper is <a href="http://www.vodun.org/papers/net-papers/van_jacobson_the_bpf_packet_filter.pdf">The BSD Packet Filter: A New Architecture for User-level Packet Capture</a></p>
<p>I wanted to write some notes on the talk here because I thought it was super
super good.</p>
<p>To start, here are the
<a href="https://speakerdeck.com/tuxology/the-bsd-packet-filter">slides</a> and a
<a href="http://step.polymtl.ca/~suchakra/PWL-Jun28-MTL.pdf">pdf</a>. The pdf is good
because there are links at the end and in the PDF you can click the links.</p>

<h3 id="what-s-bpf">what’s BPF?</h3>
<p>Before BPF, if you wanted to do packet filtering you had to copy all the
packets into userspace and then filter them there (with “tap”).</p>
<p>this had 2 problems:</p>
<ol>
<li>if you filter in userspace, it means you have to copy all the packets into userspace, copying data is expensive</li>
<li>the filtering algorithms people were using were inefficient</li>
</ol>
<p>The solution to problem #1 seems sort of obvious, move the filtering logic into
the kernel somehow. Okay. (though the details of how that’s done isn’t obvious,
we’ll talk about that in a second)</p>
<p>But why were the filtering algorithms inefficient! Well!!</p>
<p>If you run <code>tcpdump host foo</code> it actually runs a relatively complicated query,
which you could represent with this tree:</p>
<p><img src="https://jvns.ca/images/bpf-1.png"/>
</p>
<p>Evaluating this tree is kind of expensive. so the first insight is that you can
actually represent this tree in a simpler way, like this:</p>
<p><img src="https://jvns.ca/images/bpf-2.png"/>
</p>
<p>Then if you have <code>ether.type = IP</code> and <code>ip.src = foo</code> you automatically know
that the packet matches <code>host foo</code>, you don’t need to check anything else. So
this data structure (they call it a “control flow graph” or “CFG”) is a way
better representation of the program you actually want to execute to check
matches than the tree we started with.</p>
<h3 id="how-bpf-works-in-the-kernel">How BPF works in the kernel</h3>
<p>The main important here is that packets are just arrays of bytes. BPF programs
run on these arrays of bytes. They’re not allowed to have loops but they <em>can</em>
have smart stuff to figure out the length of the IP header (IPv6 &amp; IPv4 are
different lengths!) and then find the TCP port based on that length</p>
<pre><code>x = ip_header_length
port = *(packet_start + x + port_offset) 
</code></pre>
<p>(it looks different from that but it’s basically the same). There’s a nice
description of the virtual machine in the paper/slides so I won’t explain it.</p>
<p>When you run <code>tcpdump host foo</code> this is what happens, as far as I understand</p>
<ol>
<li>convert <code>host foo</code> into an efficient DAG of the rules</li>
<li>convert that DAG into a BPF program (in BPF bytecode) for the BPF virtual machine</li>
<li>Send the BPF bytecode to the Linux kernel, which verifies it</li>
<li>compile the BPF bytecode program into native code. For example <a href="https://github.com/torvalds/linux/blob/v4.10/arch/arm/net/bpf_jit_32.c#L512">here’s the JIT code for ARM</a> and for <a href="https://github.com/torvalds/linux/blob/v3.18/arch/x86/net/bpf_jit_comp.c#L189">x86</a></li>
<li>when packets come in, Linux runs the native code to decide if that packet should be filtered or not. It’l often run only 100-200 CPU instructions for each packet that needs to be processed, which is super fast!</li>
</ol>
<h3 id="the-present-ebpf">the present: eBPF</h3>
<p>But BPF has been around for a long time! Now we live in the EXCITING FUTURE
which is eBPF. I’d heard about eBPF a bunch before but I felt like this helped
me put the pieces together a little better. (i wrote this <a href="https://jvns.ca/blog/2017/04/07/xdp-bpf-tutorial/">XDP &amp; eBPF post</a> back in April when I was at netdev)</p>
<p>some facts about eBPF:</p>
<ul>
<li>eBPF programs have their own bytecode language, and are compiled from that
bytecode language into native code in the kernel, just like BPF programs</li>
<li>eBPF programs run in the kernel</li>
<li>eBPF programs can’t access arbitrary kernel memory. Instead the kernel
provides functions to get at some restricted subset of things.</li>
<li>they <em>can</em> communicate with userspace programs through BPF maps</li>
<li>there’s a <code>bpf</code> syscall as of Linux 3.18</li>
</ul>
<h3 id="kprobes-ebpf">kprobes &amp; eBPF</h3>
<p>You can pick a function (any function!) in the Linux kernel and execute a
program that you write every time that function happens. This seems really
amazing and magical.</p>
<p>For example! There’s this <a href="https://github.com/iovisor/bcc/blob/0c8c179fc1283600887efa46fe428022efc4151b/examples/tracing/disksnoop.py">BPF program called disksnoop</a> which tracks when you start/finish writing a block to disk.
Here’s a snippet from the code:</p>
<pre><code>BPF_HASH(start, struct request *);
void trace_start(struct pt_regs *ctx, struct request *req) {
	// stash start timestamp by request ptr
	u64 ts = bpf_ktime_get_ns();
	start.update(&amp;req, &amp;ts);
}
...
b.attach_kprobe(event=&#34;blk_start_request&#34;, fn_name=&#34;trace_start&#34;)
b.attach_kprobe(event=&#34;blk_mq_start_request&#34;, fn_name=&#34;trace_start&#34;)
</code></pre>
<p>This basically declares a BPF hash (which the program uses to keep track of
when the request starts / finishes), a
function called <code>trace_start</code> which is going to be compiled into BPF bytecode,
and attaches <code>trace_start</code> to the <code>blk_start_request</code> kernel function.</p>
<p>This is all using the <code>bcc</code> framework which lets you write Python-ish programs
that generate BPF code. You can find it (it has tons of example programs) at
<a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a></p>
<h3 id="uprobes-ebpf">uprobes &amp; eBPF</h3>
<p>So I sort of knew you could attach eBPF programs to kernel functions, but I
didn’t realize you could attach eBPF programs to userspace functions! That’s
really exciting. Here’s
<a href="https://github.com/iovisor/bcc/blob/00f662dbea87a071714913e5c7382687fef6a508/tests/lua/test_uprobes.lua">an example of counting malloc calls in Python using an eBPF program</a>.</p>
<h3 id="things-you-can-attach-ebpf-programs-to">things you can attach eBPF programs to</h3>
<ul>
<li>network cards, with XDP (which I wrote about a while back)</li>
<li>tc egress/ingress (in the network stack)</li>
<li>kprobes (any kernel function)</li>
<li>uprobes (any userspace function apparently ?? like in any C program with
symbols.)</li>
<li>probes that were built for dtrace called “USDT probes” (like <a href="https://dev.mysql.com/doc/refman/5.7/en/dba-dtrace-ref-query.html">these mysql probes</a>).
Here’s an <a href="https://github.com/iovisor/bcc/blob/master/examples/tracing/mysqld_query.py">example program using dtrace probes</a></li>
<li><a href="http://blogs.microsoft.co.il/sasha/2016/03/31/probing-the-jvm-with-bpfbcc/">the JVM</a></li>
<li>tracepoints (not sure what that is yet)</li>
<li>seccomp / landlock security things</li>
<li>a bunch more things</li>
</ul>
<h3 id="this-talk-was-super-cool">this talk was super cool</h3>
<p>There are a bunch of great links in the slides and in
<a href="https://github.com/iovisor/bcc/blob/master/LINKS.md">LINKS.md</a> in the iovisor
repository. It is late now but soon I want to actually write my first eBPF
program!</p>
</div></div>
  </body>
</html>
