<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/bitfield/script">Original</a>
    <h1>Shell-ish scripting in Go with ease</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a href="https://pkg.go.dev/github.com/bitfield/script" rel="nofollow"><img src="https://camo.githubusercontent.com/26683446980ba8cccc9e6b1d6c3036dcc42964dec198651d8be9fc67607085ad/68747470733a2f2f706b672e676f2e6465762f62616467652f6769746875622e636f6d2f6269746669656c642f7363726970742e737667" alt="Go Reference" data-canonical-src="https://pkg.go.dev/badge/github.com/bitfield/script.svg"/></a>
<a href="https://goreportcard.com/report/github.com/bitfield/script" rel="nofollow"><img src="https://camo.githubusercontent.com/43e914a62d1aba296838a8b5a731c48c210541313f8549be9436193364624f4f/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f6269746669656c642f736372697074" alt="Go Report Card" data-canonical-src="https://goreportcard.com/badge/github.com/bitfield/script"/></a>
<a href="https://github.com/avelino/awesome-go"><img src="https://camo.githubusercontent.com/adb8f3e4da7635816556cc11275410d326f132ce011955a341259bc1061ff351/68747470733a2f2f617765736f6d652e72652f6d656e74696f6e65642d62616467652d666c61742e737667" alt="Mentioned in Awesome Go" data-canonical-src="https://awesome.re/mentioned-badge-flat.svg"/></a>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/bitfield/script/actions/workflows/ci.yml/badge.svg"><img src="https://github.com/bitfield/script/actions/workflows/ci.yml/badge.svg" alt="CI"/></a>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/bitfield/script/actions/workflows/audit.yml/badge.svg"><img src="https://github.com/bitfield/script/actions/workflows/audit.yml/badge.svg" alt="Audit"/></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="import &#34;github.com/bitfield/script&#34;"><pre><span>import</span> <span>&#34;github.com/bitfield/script&#34;</span></pre></div>
<p dir="auto"><a href="https://bitfieldconsulting.com/golang/scripting" rel="nofollow"><img src="https://github.com/bitfield/script/raw/master/img/magic.png" alt="Magical gopher logo"/></a></p>

<p dir="auto"><code>script</code> is a Go library for doing the kind of tasks that shell scripts are good at: reading files, executing subprocesses, counting lines, matching strings, and so on.</p>
<p dir="auto">Why shouldn&#39;t it be as easy to write system administration programs in Go as it is in a typical shell? <code>script</code> aims to make it just that easy.</p>
<p dir="auto">Shell scripts often compose a sequence of operations on a stream of data (a <em>pipeline</em>). This is how <code>script</code> works, too.</p>
<blockquote>
<p dir="auto"><em>This is one absolutely superb API design. Taking inspiration from shell pipes and turning it into a Go library with syntax this clean is really impressive.</em></p>
</blockquote>
<p dir="auto">Read more: <a href="https://bitfieldconsulting.com/golang/scripting" rel="nofollow">Scripting with Go</a></p>

<p dir="auto">If you&#39;re already familiar with shell scripting and the Unix toolset, here is a rough guide to the equivalent <code>script</code> operation for each listed Unix command.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Unix / shell</th>
<th><code>script</code> equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td>(any program name)</td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Exec" rel="nofollow"><code>Exec</code></a></td>
</tr>
<tr>
<td><code>[ -f FILE ]</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#IfExists" rel="nofollow"><code>IfExists</code></a></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WriteFile" rel="nofollow"><code>WriteFile</code></a></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.AppendFile" rel="nofollow"><code>AppendFile</code></a></td>
</tr>
<tr>
<td><code>$*</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Args" rel="nofollow"><code>Args</code></a></td>
</tr>
<tr>
<td><code>base64</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.DecodeBase64" rel="nofollow"><code>DecodeBase64</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.EncodeBase64" rel="nofollow"><code>EncodeBase64</code></a></td>
</tr>
<tr>
<td><code>basename</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Basename" rel="nofollow"><code>Basename</code></a></td>
</tr>
<tr>
<td><code>cat</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#File" rel="nofollow"><code>File</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Concat" rel="nofollow"><code>Concat</code></a></td>
</tr>
<tr>
<td><code>curl</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Do" rel="nofollow"><code>Do</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Get" rel="nofollow"><code>Get</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Post" rel="nofollow"><code>Post</code></a></td>
</tr>
<tr>
<td><code>cut</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Column" rel="nofollow"><code>Column</code></a></td>
</tr>
<tr>
<td><code>dirname</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Dirname" rel="nofollow"><code>Dirname</code></a></td>
</tr>
<tr>
<td><code>echo</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Echo" rel="nofollow"><code>Echo</code></a></td>
</tr>
<tr>
<td><code>find</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#FindFiles" rel="nofollow"><code>FindFiles</code></a></td>
</tr>
<tr>
<td><code>grep</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Match" rel="nofollow"><code>Match</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.MatchRegexp" rel="nofollow"><code>MatchRegexp</code></a></td>
</tr>
<tr>
<td><code>grep -v</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Reject" rel="nofollow"><code>Reject</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.RejectRegexp" rel="nofollow"><code>RejectRegexp</code></a></td>
</tr>
<tr>
<td><code>head</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.First" rel="nofollow"><code>First</code></a></td>
</tr>
<tr>
<td><code>jq</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.JQ" rel="nofollow"><code>JQ</code></a></td>
</tr>
<tr>
<td><code>ls</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#ListFiles" rel="nofollow"><code>ListFiles</code></a></td>
</tr>
<tr>
<td><code>sed</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Replace" rel="nofollow"><code>Replace</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.ReplaceRegexp" rel="nofollow"><code>ReplaceRegexp</code></a></td>
</tr>
<tr>
<td><code>sha256sum</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Hash" rel="nofollow"><code>Hash</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.HashSums" rel="nofollow"><code>HashSums</code></a></td>
</tr>
<tr>
<td><code>tail</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Last" rel="nofollow"><code>Last</code></a></td>
</tr>
<tr>
<td><code>tee</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Tee" rel="nofollow"><code>Tee</code></a></td>
</tr>
<tr>
<td><code>uniq -c</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Freq" rel="nofollow"><code>Freq</code></a></td>
</tr>
<tr>
<td><code>wc -l</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.CountLines" rel="nofollow"><code>CountLines</code></a></td>
</tr>
<tr>
<td><code>xargs</code></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.ExecForEach" rel="nofollow"><code>ExecForEach</code></a></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">Let&#39;s see some simple examples. Suppose you want to read the contents of a file as a string:</p>
<div dir="auto" data-snippet-clipboard-copy-content="contents, err := script.File(&#34;test.txt&#34;).String()"><pre><span>contents</span>, <span>err</span> <span>:=</span> <span>script</span>.<span>File</span>(<span>&#34;test.txt&#34;</span>).<span>String</span>()</pre></div>
<p dir="auto">That looks straightforward enough, but suppose you now want to count the lines in that file.</p>
<div dir="auto" data-snippet-clipboard-copy-content="numLines, err := script.File(&#34;test.txt&#34;).CountLines()"><pre><span>numLines</span>, <span>err</span> <span>:=</span> <span>script</span>.<span>File</span>(<span>&#34;test.txt&#34;</span>).<span>CountLines</span>()</pre></div>
<p dir="auto">For something a bit more challenging, let&#39;s try counting the number of lines in the file that match the string <code>Error</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="numErrors, err := script.File(&#34;test.txt&#34;).Match(&#34;Error&#34;).CountLines()"><pre><span>numErrors</span>, <span>err</span> <span>:=</span> <span>script</span>.<span>File</span>(<span>&#34;test.txt&#34;</span>).<span>Match</span>(<span>&#34;Error&#34;</span>).<span>CountLines</span>()</pre></div>
<p dir="auto">But what if, instead of reading a specific file, we want to simply pipe input into this program, and have it output only matching lines (like <code>grep</code>)?</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Stdin().Match(&#34;Error&#34;).Stdout()"><pre><span>script</span>.<span>Stdin</span>().<span>Match</span>(<span>&#34;Error&#34;</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">Just for fun, let&#39;s filter all the results through some arbitrary Go function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Stdin().Match(&#34;Error&#34;).FilterLine(strings.ToUpper).Stdout()"><pre><span>script</span>.<span>Stdin</span>().<span>Match</span>(<span>&#34;Error&#34;</span>).<span>FilterLine</span>(<span>strings</span>.<span>ToUpper</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">That was almost too easy! So let&#39;s pass in a list of files on the command line, and have our program read them all in sequence and output the matching lines:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Args().Concat().Match(&#34;Error&#34;).Stdout()"><pre><span>script</span>.<span>Args</span>().<span>Concat</span>().<span>Match</span>(<span>&#34;Error&#34;</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">Maybe we&#39;re only interested in the first 10 matches. No problem:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Args().Concat().Match(&#34;Error&#34;).First(10).Stdout()"><pre><span>script</span>.<span>Args</span>().<span>Concat</span>().<span>Match</span>(<span>&#34;Error&#34;</span>).<span>First</span>(<span>10</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">What&#39;s that? You want to append that output to a file instead of printing it to the terminal? <em>You&#39;ve got some attitude, mister</em>. But okay:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Args().Concat().Match(&#34;Error&#34;).First(10).AppendFile(&#34;/var/log/errors.txt&#34;)"><pre><span>script</span>.<span>Args</span>().<span>Concat</span>().<span>Match</span>(<span>&#34;Error&#34;</span>).<span>First</span>(<span>10</span>).<span>AppendFile</span>(<span>&#34;/var/log/errors.txt&#34;</span>)</pre></div>
<p dir="auto">And if we&#39;d like to send the output to the terminal <em>as well as</em> to the file, we can do that:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Echo(&#34;data&#34;).Tee().AppendFile(&#34;data.txt&#34;)"><pre><span>script</span>.<span>Echo</span>(<span>&#34;data&#34;</span>).<span>Tee</span>().<span>AppendFile</span>(<span>&#34;data.txt&#34;</span>)</pre></div>
<p dir="auto">We&#39;re not limited to getting data only from files or standard input. We can get it from HTTP requests too:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Get(&#34;https://wttr.in/London?format=3&#34;).Stdout()
// Output:
// London: 🌦   +13°C"><pre><span>script</span>.<span>Get</span>(<span>&#34;https://wttr.in/London?format=3&#34;</span>).<span>Stdout</span>()
<span>// Output:</span>
<span>// London: 🌦   +13°C</span></pre></div>
<p dir="auto">That&#39;s great for simple GET requests, but suppose we want to <em>send</em> some data in the body of a POST request, for example. Here&#39;s how that works:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Echo(data).Post(URL).Stdout()"><pre><span>script</span>.<span>Echo</span>(<span>data</span>).<span>Post</span>(<span>URL</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">If we need to customise the HTTP behaviour in some way, such as using our own HTTP client, we can do that:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.NewPipe().WithHTTPClient(&amp;http.Client{
	Timeout: 10 * time.Second,
}).Get(&#34;https://example.com&#34;).Stdout()"><pre><span>script</span>.<span>NewPipe</span>().<span>WithHTTPClient</span>(<span>&amp;</span>http.<span>Client</span>{
	<span>Timeout</span>: <span>10</span> <span>*</span> <span>time</span>.<span>Second</span>,
}).<span>Get</span>(<span>&#34;https://example.com&#34;</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">Or maybe we need to set some custom header on the request. No problem. We can just create the request in the usual way, and set it up however we want. Then we pass it to <code>Do</code>, which will actually perform the request:</p>
<div dir="auto" data-snippet-clipboard-copy-content="req, err := http.NewRequest(http.MethodGet, &#34;http://example.com&#34;, nil)
req.Header.Add(&#34;Authorization&#34;, &#34;Bearer &#34;+token)
script.Do(req).Stdout()"><pre><span>req</span>, <span>err</span> <span>:=</span> <span>http</span>.<span>NewRequest</span>(<span>http</span>.<span>MethodGet</span>, <span>&#34;http://example.com&#34;</span>, <span>nil</span>)
<span>req</span>.<span>Header</span>.<span>Add</span>(<span>&#34;Authorization&#34;</span>, <span>&#34;Bearer &#34;</span><span>+</span><span>token</span>)
<span>script</span>.<span>Do</span>(<span>req</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">The HTTP server could return some non-okay response, though; for example, “404 Not Found”. So what happens then?</p>
<p dir="auto">In general, when any pipe stage (such as <code>Do</code>) encounters an error, it produces no output to subsequent stages. And <code>script</code> treats HTTP response status codes outside the range 200-299 as errors. So the answer for the previous example is that we just won&#39;t <em>see</em> any output from this program if the server returns an error response.</p>
<p dir="auto">Instead, the pipe “remembers” any error that occurs, and we can retrieve it later by calling its <code>Error</code> method, or by using a <em>sink</em> method such as <code>String</code>, which returns an <code>error</code> value along with the result.</p>
<p dir="auto"><code>Stdout</code> also returns an error, plus the number of bytes successfully written (which we don&#39;t care about for this particular case). So we can check that error, which is always a good idea in Go:</p>
<div dir="auto" data-snippet-clipboard-copy-content="_, err := script.Do(req).Stdout()
if err != nil {
	log.Fatal(err)
}"><pre><span>_</span>, <span>err</span> <span>:=</span> <span>script</span>.<span>Do</span>(<span>req</span>).<span>Stdout</span>()
<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
	<span>log</span>.<span>Fatal</span>(<span>err</span>)
}</pre></div>
<p dir="auto">If, as is common, the data we get from an HTTP request is in JSON format, we can use <a href="https://stedolan.github.io/jq/" rel="nofollow">JQ</a> queries to interrogate it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="data, err := script.Do(req).JQ(&#34;.[0] | {message: .commit.message, name: .commit.committer.name}&#34;).String()"><pre><span>data</span>, <span>err</span> <span>:=</span> <span>script</span>.<span>Do</span>(<span>req</span>).<span>JQ</span>(<span>&#34;.[0] | {message: .commit.message, name: .commit.committer.name}&#34;</span>).<span>String</span>()</pre></div>
<p dir="auto">We can also run external programs and get their output:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Exec(&#34;ping 127.0.0.1&#34;).Stdout()"><pre><span>script</span>.<span>Exec</span>(<span>&#34;ping 127.0.0.1&#34;</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">Note that <code>Exec</code> runs the command concurrently: it doesn&#39;t wait for the command to complete before returning any output. That&#39;s good, because this <code>ping</code> command will run forever (or until we get bored).</p>
<p dir="auto">Instead, when we read from the pipe using <code>Stdout</code>, we see each line of output as it&#39;s produced:</p>
<div data-snippet-clipboard-copy-content="PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.056 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.054 ms
..."><pre><code>PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.056 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.054 ms
...
</code></pre></div>
<p dir="auto">In the <code>ping</code> example, we knew the exact arguments we wanted to send the command, and we just needed to run it once. But what if we don&#39;t know the arguments yet? We might get them from the user, for example.</p>
<p dir="auto">We might like to be able to run the external command repeatedly, each time passing it the next line of data from the pipe as an argument. No worries:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Args().ExecForEach(&#34;ping -c 1 {{.}}&#34;).Stdout()"><pre><span>script</span>.<span>Args</span>().<span>ExecForEach</span>(<span>&#34;ping -c 1 {{.}}&#34;</span>).<span>Stdout</span>()</pre></div>
<p dir="auto">That <code>{{.}}</code> is standard Go template syntax; it&#39;ll substitute each line of data from the pipe into the command line before it&#39;s executed. You can write as fancy a Go template expression as you want here (but this simple example probably covers most use cases).</p>
<p dir="auto">If there isn&#39;t a built-in operation that does what we want, we can just write our own, using <code>Filter</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Echo(&#34;hello world&#34;).Filter(func (r io.Reader, w io.Writer) error {
	n, err := io.Copy(w, r)
	fmt.Fprintf(w, &#34;\nfiltered %d bytes\n&#34;, n)
	return err
}).Stdout()
// Output:
// hello world
// filtered 11 bytes"><pre><span>script</span>.<span>Echo</span>(<span>&#34;hello world&#34;</span>).<span>Filter</span>(<span>func</span> (<span>r</span> io.<span>Reader</span>, <span>w</span> io.<span>Writer</span>) <span>error</span> {
	<span>n</span>, <span>err</span> <span>:=</span> <span>io</span>.<span>Copy</span>(<span>w</span>, <span>r</span>)
	<span>fmt</span>.<span>Fprintf</span>(<span>w</span>, <span>&#34;<span>\n</span>filtered %d bytes<span>\n</span>&#34;</span>, <span>n</span>)
	<span>return</span> <span>err</span>
}).<span>Stdout</span>()
<span>// Output:</span>
<span>// hello world</span>
<span>// filtered 11 bytes</span></pre></div>
<p dir="auto">The <code>func</code> we supply to <code>Filter</code> takes just two parameters: a reader to read from, and a writer to write to. The reader reads the previous stages of the pipe, as you might expect, and anything written to the writer goes to the <em>next</em> stage of the pipe.</p>
<p dir="auto">If our <code>func</code> returns some error, then, just as with the <code>Do</code> example, the pipe&#39;s error status is set, and subsequent stages become a no-op.</p>
<p dir="auto">Filters run concurrently, so the pipeline can start producing output before the input has been fully read, as it did in the <code>ping</code> example. In fact, most built-in pipe methods, including <code>Exec</code>, are implemented <em>using</em> <code>Filter</code>.</p>
<p dir="auto">If we want to scan input line by line, we could do that with a <code>Filter</code> function that creates a <code>bufio.Scanner</code> on its input, but we don&#39;t need to:</p>
<div dir="auto" data-snippet-clipboard-copy-content="script.Echo(&#34;a\nb\nc&#34;).FilterScan(func(line string, w io.Writer) {
	fmt.Fprintf(w, &#34;scanned line: %q\n&#34;, line)
}).Stdout()
// Output:
// scanned line: &#34;a&#34;
// scanned line: &#34;b&#34;
// scanned line: &#34;c&#34;"><pre><span>script</span>.<span>Echo</span>(<span>&#34;a<span>\n</span>b<span>\n</span>c&#34;</span>).<span>FilterScan</span>(<span>func</span>(<span>line</span> <span>string</span>, <span>w</span> io.<span>Writer</span>) {
	<span>fmt</span>.<span>Fprintf</span>(<span>w</span>, <span>&#34;scanned line: %q<span>\n</span>&#34;</span>, <span>line</span>)
}).<span>Stdout</span>()
<span>// Output:</span>
<span>// scanned line: &#34;a&#34;</span>
<span>// scanned line: &#34;b&#34;</span>
<span>// scanned line: &#34;c&#34;</span></pre></div>
<p dir="auto">And there&#39;s more. Much more. <a href="https://pkg.go.dev/github.com/bitfield/script" rel="nofollow">Read the docs</a> for full details, and more examples.</p>

<p dir="auto">Let&#39;s use <code>script</code> to write a program that system administrators might actually need. One thing I often find myself doing is counting the most frequent visitors to a website over a given period of time. Given an Apache log in the Common Log Format like this:</p>
<div data-snippet-clipboard-copy-content="212.205.21.11 - - [30/Jun/2019:17:06:15 +0000] &#34;GET / HTTP/1.1&#34; 200 2028 &#34;https://example.com/ &#34;Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX1 Build/HUAWEIFIG-LX1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.156 Mobile Safari/537.36&#34;"><pre><code>212.205.21.11 - - [30/Jun/2019:17:06:15 +0000] &#34;GET / HTTP/1.1&#34; 200 2028 &#34;https://example.com/ &#34;Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX1 Build/HUAWEIFIG-LX1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.156 Mobile Safari/537.36&#34;
</code></pre></div>
<p dir="auto">we would like to extract the visitor&#39;s IP address (the first column in the logfile), and count the number of times this IP address occurs in the file. Finally, we might like to list the top 10 visitors by frequency. In a shell script we might do something like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cut -d&#39; &#39; -f 1 access.log |sort |uniq -c |sort -rn |head"><pre>cut -d<span><span>&#39;</span> <span>&#39;</span></span> -f 1 access.log <span>|</span>sort <span>|</span>uniq -c <span>|</span>sort -rn <span>|</span>head</pre></div>
<p dir="auto">There&#39;s a lot going on there, and it&#39;s pleasing to find that the equivalent <code>script</code> program is quite brief:</p>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
	&#34;github.com/bitfield/script&#34;
)

func main() {
	script.Stdin().Column(1).Freq().First(10).Stdout()
}"><pre><span>package</span> main

<span>import</span> (
	<span>&#34;github.com/bitfield/script&#34;</span>
)

<span>func</span> <span>main</span>() {
	<span>script</span>.<span>Stdin</span>().<span>Column</span>(<span>1</span>).<span>Freq</span>().<span>First</span>(<span>10</span>).<span>Stdout</span>()
}</pre></div>
<p dir="auto">Let&#39;s try it out with some <a href="https://github.com/bitfield/script/blob/master/testdata/access.log">sample data</a>:</p>
<div data-snippet-clipboard-copy-content="16 176.182.2.191
 7 212.205.21.11
 1 190.253.121.1
 1 90.53.111.17"><pre><code>16 176.182.2.191
 7 212.205.21.11
 1 190.253.121.1
 1 90.53.111.17
</code></pre></div>

<p dir="auto">One of the nice things about shell scripts is that there&#39;s no build process: the script file itself is the “executable” (in fact, it&#39;s interpreted by the shell). Simon Willison (and GPT-4) contributed this elegant <code>script</code> interpreter, written in <code>bash</code>:</p>
<ul dir="auto">
<li><a href="https://til.simonwillison.net/bash/go-script" rel="nofollow"><code>go-script</code></a></li>
</ul>
<p dir="auto">With <code>go-script</code>, you can run <code>script</code> one-liners directly:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cat file.txt | ./goscript.sh -c &#39;script.Stdin().Column(1).Freq().First(10).Stdout()&#39;"><pre>cat file.txt <span>|</span> ./goscript.sh -c <span><span>&#39;</span>script.Stdin().Column(1).Freq().First(10).Stdout()<span>&#39;</span></span></pre></div>
<p dir="auto">or create <code>.goscript</code> files that you can run using a “shebang” line:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#!/tmp/goscript.sh
script.Stdin().Column(1).Freq().First(10).Stdout()"><pre><span><span>#!</span>/tmp/goscript.sh</span>
<span>script.Stdin().Column(1).Freq().First(10).Stdout</span>()</pre></div>

<p dir="auto">See <a href="https://pkg.go.dev/github.com/bitfield/script" rel="nofollow">pkg.go.dev</a> for the full documentation, or read on for a summary.</p>
<p dir="auto"><a href="https://bitfieldconsulting.com/books/tools" rel="nofollow"><img src="https://github.com/bitfield/script/raw/master/img/tools.png" alt="The Power of Go: Tools cover image"/></a></p>
<p dir="auto">The <code>script</code> package originated as an exercise in my book <a href="https://bitfieldconsulting.com/books/tools" rel="nofollow">The Power of Go: Tools</a>:</p>
<blockquote>
<p dir="auto"><em>Not all software engineering is about writing applications. Developers also need tooling: programs and services to automate everyday tasks like configuring servers and containers, running builds and tests, deploying their applications, and so on. Why shouldn&#39;t we be able to use Go for that purpose, too?</em></p>
<p dir="auto"><em><code>script</code> is designed to make it easy to write Go programs that chain together operations into a pipeline, in the same way that shell scripts do, but with the robust type checking and error handling of a real programming language. You can use <code>script</code> to construct the sort of simple one‐off pipelines that would otherwise require the shell, or special‐purpose tools.</em></p>
<p dir="auto"><em>So, when plain Go doesn’t provide a convenient way to solve a problem, you yourself can use it to implement a domain-specific “language” that does. In this case, we used Go to provide the language of Unix‐style pipelines. But we could have chosen any architecture we wanted to suit the problem. If Go doesn’t already provide the tool you need, use Go to build that tool, then use it.</em></p>
</blockquote>

<p dir="auto">These are functions that create a pipe with a given contents:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Source</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Args" rel="nofollow"><code>Args</code></a></td>
<td>command-line arguments</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Do" rel="nofollow"><code>Do</code></a></td>
<td>HTTP response</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Echo" rel="nofollow"><code>Echo</code></a></td>
<td>a string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Exec" rel="nofollow"><code>Exec</code></a></td>
<td>command output</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#File" rel="nofollow"><code>File</code></a></td>
<td>file contents</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#FindFiles" rel="nofollow"><code>FindFiles</code></a></td>
<td>recursive file listing</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Get" rel="nofollow"><code>Get</code></a></td>
<td>HTTP response</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#IfExists" rel="nofollow"><code>IfExists</code></a></td>
<td>do something only if some file exists</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#ListFiles" rel="nofollow"><code>ListFiles</code></a></td>
<td>file listing (including wildcards)</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Post" rel="nofollow"><code>Post</code></a></td>
<td>HTTP response</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Slice" rel="nofollow"><code>Slice</code></a></td>
<td>slice elements, one per line</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Stdin" rel="nofollow"><code>Stdin</code></a></td>
<td>standard input</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">These are methods on a pipe that change its configuration:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Source</th>
<th>Modifies</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithEnv" rel="nofollow"><code>WithEnv</code></a></td>
<td>environment for commands</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithError" rel="nofollow"><code>WithError</code></a></td>
<td>pipe error status</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithHTTPClient" rel="nofollow"><code>WithHTTPClient</code></a></td>
<td>client for HTTP requests</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithReader" rel="nofollow"><code>WithReader</code></a></td>
<td>pipe source</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithStderr" rel="nofollow"><code>WithStderr</code></a></td>
<td>standard error output stream for command</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithStdout" rel="nofollow"><code>WithStdout</code></a></td>
<td>standard output stream for pipe</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">Filters are methods on an existing pipe that also return a pipe, allowing you to chain filters indefinitely. The filters modify each line of their input according to the following rules:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Filter</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Basename" rel="nofollow"><code>Basename</code></a></td>
<td>removes leading path components from each line, leaving only the filename</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Column" rel="nofollow"><code>Column</code></a></td>
<td>Nth column of input</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Concat" rel="nofollow"><code>Concat</code></a></td>
<td>contents of multiple files</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.DecodeBase64" rel="nofollow"><code>DecodeBase64</code></a></td>
<td>input decoded from base64</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Dirname" rel="nofollow"><code>Dirname</code></a></td>
<td>removes filename from each line, leaving only leading path components</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Do" rel="nofollow"><code>Do</code></a></td>
<td>response to supplied HTTP request</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Echo" rel="nofollow"><code>Echo</code></a></td>
<td>all input replaced by given string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.EncodeBase64" rel="nofollow"><code>EncodeBase64</code></a></td>
<td>input encoded to base64</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Exec" rel="nofollow"><code>Exec</code></a></td>
<td>filtered through external command</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.ExecForEach" rel="nofollow"><code>ExecForEach</code></a></td>
<td>execute given command template for each line of input</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Filter" rel="nofollow"><code>Filter</code></a></td>
<td>user-supplied function filtering a reader to a writer</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.FilterLine" rel="nofollow"><code>FilterLine</code></a></td>
<td>user-supplied function filtering each line to a string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.FilterScan" rel="nofollow"><code>FilterScan</code></a></td>
<td>user-supplied function filtering each line to a writer</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.First" rel="nofollow"><code>First</code></a></td>
<td>first N lines of input</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Freq" rel="nofollow"><code>Freq</code></a></td>
<td>frequency count of unique input lines, most frequent first</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Get" rel="nofollow"><code>Get</code></a></td>
<td>response to HTTP GET on supplied URL</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.HashSums" rel="nofollow"><code>HashSums</code></a></td>
<td>hashes of each listed file</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Join" rel="nofollow"><code>Join</code></a></td>
<td>replace all newlines with spaces</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.JQ" rel="nofollow"><code>JQ</code></a></td>
<td>result of <code>jq</code> query</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Last" rel="nofollow"><code>Last</code></a></td>
<td>last N lines of input</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Match" rel="nofollow"><code>Match</code></a></td>
<td>lines matching given string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.MatchRegexp" rel="nofollow"><code>MatchRegexp</code></a></td>
<td>lines matching given regexp</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Post" rel="nofollow"><code>Post</code></a></td>
<td>response to HTTP POST on supplied URL</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Reject" rel="nofollow"><code>Reject</code></a></td>
<td>lines not matching given string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.RejectRegexp" rel="nofollow"><code>RejectRegexp</code></a></td>
<td>lines not matching given regexp</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Replace" rel="nofollow"><code>Replace</code></a></td>
<td>matching text replaced with given string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.ReplaceRegexp" rel="nofollow"><code>ReplaceRegexp</code></a></td>
<td>matching text replaced with given string</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Tee" rel="nofollow"><code>Tee</code></a></td>
<td>input copied to supplied writers</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Note that filters run concurrently, rather than producing nothing until each stage has fully read its input. This is convenient for executing long-running commands, for example. If you do need to wait for the pipeline to complete, call <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Wait" rel="nofollow"><code>Wait</code></a>.</p>

<p dir="auto">Sinks are methods that return some data from a pipe, ending the pipeline and extracting its full contents in a specified way:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Sink</th>
<th>Destination</th>
<th>Results</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.AppendFile" rel="nofollow"><code>AppendFile</code></a></td>
<td>appended to file, creating if it doesn&#39;t exist</td>
<td>bytes written, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Bytes" rel="nofollow"><code>Bytes</code></a></td>
<td></td>
<td>data as <code>[]byte</code>, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Hash" rel="nofollow"><code>Hash</code></a></td>
<td></td>
<td>hash, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.CountLines" rel="nofollow"><code>CountLines</code></a></td>
<td></td>
<td>number of lines, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Read" rel="nofollow"><code>Read</code></a></td>
<td>given <code>[]byte</code></td>
<td>bytes read, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Slice" rel="nofollow"><code>Slice</code></a></td>
<td></td>
<td>data as <code>[]string</code>, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Stdout" rel="nofollow"><code>Stdout</code></a></td>
<td>standard output</td>
<td>bytes written, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.String" rel="nofollow"><code>String</code></a></td>
<td></td>
<td>data as <code>string</code>, error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Wait" rel="nofollow"><code>Wait</code></a></td>
<td></td>
<td>error</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WriteFile" rel="nofollow"><code>WriteFile</code></a></td>
<td>specified file, truncating if it exists</td>
<td>bytes written, error</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Version</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.24.0</td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Hash" rel="nofollow"><code>Hash</code></a></td>
</tr>
<tr>
<td></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.HashSums" rel="nofollow"><code>HashSums</code></a></td>
</tr>
<tr>
<td>0.23.0</td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithEnv" rel="nofollow"><code>WithEnv</code></a></td>
</tr>
<tr>
<td></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.DecodeBase64" rel="nofollow"><code>DecodeBase64</code></a> / <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.EncodeBase64" rel="nofollow"><code>EncodeBase64</code></a></td>
</tr>
<tr>
<td></td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Wait" rel="nofollow"><code>Wait</code></a> returns error</td>
</tr>
<tr>
<td>v0.22.0</td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Tee" rel="nofollow"><code>Tee</code></a>, <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.WithStderr" rel="nofollow"><code>WithStderr</code></a></td>
</tr>
<tr>
<td>v0.21.0</td>
<td>HTTP support: <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Do" rel="nofollow"><code>Do</code></a>, <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Get" rel="nofollow"><code>Get</code></a>, <a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.Post" rel="nofollow"><code>Post</code></a></td>
</tr>
<tr>
<td>v0.20.0</td>
<td><a href="https://pkg.go.dev/github.com/bitfield/script#Pipe.JQ" rel="nofollow"><code>JQ</code></a></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">See the <a href="https://github.com/bitfield/script/blob/master/CONTRIBUTING.md">contributor&#39;s guide</a> for some helpful tips if you&#39;d like to contribute to the <code>script</code> project.</p>

<ul dir="auto">
<li><a href="https://bitfieldconsulting.com/posts/scripting" rel="nofollow">Scripting with Go</a></li>
<li><a href="https://www.youtube.com/watch?v=6S5EqzVwpEg" rel="nofollow">Code Club: Script</a></li>
<li><a href="https://bitfieldconsulting.com/" rel="nofollow">Bitfield Consulting</a></li>
<li><a href="https://bitfieldconsulting.com/books" rel="nofollow">Go books by John Arundel</a></li>
</ul>
<p dir="auto">Gopher image by <a href="https://github.com/MariaLetta/free-gophers-pack">MariaLetta</a></p>
</article></div></div>
  </body>
</html>
