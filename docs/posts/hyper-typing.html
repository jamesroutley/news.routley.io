<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pscanf.com/s/341/">Original</a>
    <h1>Hyper Typing</h1>
    
    <div id="readability-page-1" class="page"><section id="content" data-astro-cid-f65lieke=""> <p>TypeScript’s type system is <em>gradual</em>: when describing a JavaScript value with
TypeScript, you can be more or less accurate, ranging from saying that the value
could be anything (<code>any</code>), to describing in absolute detail what the value is
under different conditions.</p>
<p>Consider for example this function which prints the property of an object - if
it exists:</p>
<pre tabindex="0" data-language="js"><code><span><span>function</span><span> </span><span>printProperty</span><span>(</span><span>obj</span><span>,</span><span> </span><span>key</span><span>)</span><span> </span><span>{</span></span>
<span><span> </span><span> </span><span>if</span><span> </span><span>(</span><span>typeof</span><span> </span><span>obj</span><span> </span><span>===</span><span> </span><span>&#34;object&#34;</span><span> </span><span>&amp;&amp;</span><span> </span><span>obj</span><span> </span><span>!==</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>Object.</span><span>hasOwn</span><span>(obj,</span><span> </span><span>key))</span><span> </span><span>{</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>console.</span><span>log</span><span>(obj[key]);</span></span>
<span><span> </span><span> </span><span>}</span></span>
<span><span>}</span></span></code></pre>
<p>We can type it in a <em>loose</em> way as follows:</p>
<pre tabindex="0" data-language="ts"><code><span><span>function</span><span> </span><span>printProperty</span><span>(</span><span>obj</span><span>:</span><span> </span><span>any</span><span>,</span><span> </span><span>key</span><span>:</span><span> </span><span>string</span><span>)</span><span> </span><span>{</span></span>
<span><span> </span><span> </span><span>if</span><span> </span><span>(</span><span>typeof</span><span> </span><span>obj</span><span> </span><span>===</span><span> </span><span>&#34;object&#34;</span><span> </span><span>&amp;&amp;</span><span> </span><span>obj</span><span> </span><span>!==</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>Object.</span><span>hasOwn</span><span>(obj,</span><span> </span><span>key))</span><span> </span><span>{</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>console.</span><span>log</span><span>(obj[key]);</span></span>
<span><span> </span><span> </span><span>}</span></span>
<span><span>}</span></span></code></pre>
<p>But we can also be more <em>strict</em>, requiring <code>obj</code> to be an object and <code>key</code> to
be one of its properties:</p>
<pre tabindex="0" data-language="ts"><code><span><span>function</span><span> </span><span>printProperty</span><span>&lt;</span><span>Obj</span><span> </span><span>extends</span><span> </span><span>object</span><span>&gt;(</span><span>obj</span><span>:</span><span> </span><span>Obj</span><span>,</span><span> </span><span>key</span><span>:</span><span> </span><span>keyof</span><span> </span><span>Obj</span><span>)</span><span> </span><span>{</span></span>
<span><span> </span><span> </span><span>console.</span><span>log</span><span>(obj[key]);</span></span>
<span><span>}</span></span></code></pre>
<p>The strictness even allows us to remove the <code>if</code> check inside the function,
since now TypeScript gives us the compile-time guarantee that <code>obj</code> will always
have property <code>key</code>:</p>
<pre tabindex="0" data-language="ts"><code><span><span>//</span><span> </span><span>Passing</span><span> </span><span>in</span><span> </span><span>a</span><span> </span><span>non-existing</span><span> </span><span>property</span><span> </span><span>gives</span><span> </span><span>an</span><span> </span><span>error.</span></span>
<span><span>printProperty</span><span>({</span><span> </span><span>a:</span><span> </span><span>&#34;a&#34;</span><span> </span><span>},</span><span> </span><span><span>&#34;b&#34;</span></span><span>);</span></span><p>Argument of type &#39;&#34;b&#34;&#39; is not assignable to parameter of type &#39;&#34;a&#34;&#39;.</p></code></pre>
<p>Having this additional guarantee is obviously desirable, but it comes at the
expense of making the type definition more complex. Not much in this case - the
type is still very understandable - but it reveals an inherent trade-off. Where
should we draw the line?</p>
<h3 id="hyper-typing"><a href="#hyper-typing">Hyper-Typing</a></h3>
<p>Lately I’ve been trying out a few libraries that - in pursuit of perfect type
safety - make their typings so complex that it makes them almost unusable, in my
opinion. I call this approach <em>hyper-typing</em>, and I worry it’s becoming a trend
in the TypeScript ecosystem.</p>
<p>I get why, actually. I myself am often a <em>hyper-typer</em>! It’s a slippery slope:
“If I add this type constraint then the caller will get an error in this
particular case”. “I can make this function infer this type here so the caller
will get the correct type hint there”.</p>
<p>At the bottom of the slope you get to a place where yes, things work, and they
might also look good for the caller - <em>in the happy case</em>. The resulting types,
however, are a complex mess, and the compilation errors produced when the caller
deviates from the happy path are walls of inscrutable text.</p>
<h3 id="an-example-tanstack-form"><a href="#an-example-tanstack-form">An Example: TanStack Form</a></h3>
<p>TanStack Form is the new kid on the block of form libraries. It pushes heavily
on type-safety, promising “first-class TypeScript support with outstanding
autocompletion” for a “smoother development experience”.</p>
<p>What the library accomplishes is honestly impressive. Just give it the default
values of your form and you’re set: now for every form field you define - no
matter how deeply nested - you get the correct type when you read or write its
value, when you do validation, etc.</p>
<p>Don’t look at how the sausage is made, though: you won’t even understand it.
Take
<a href="https://tanstack.com/form/v1/docs/framework/react/examples/simple?panel=sandbox" target="_blank" rel="noopener noreferrer">the simple example from TanStack Form’s documentation</a>.
Use the interactive sandbox and try to check what’s the shape of a field’s
<code>meta</code> property (or any other library value, really). Here’s what you’ll see:</p>
<p><img src="https://pscanf.com/_astro/00.hgh9tLG0.avif" alt="Typings for the meta property of a TanStack form field." width="1560" height="900" loading="lazy" decoding="async" data-astro-cid-ythktxs6=""/> </p>  
<p>The <code>FieldMeta</code> type has 17 (!) generic parameters and is the intersection of
two types - each taking the same 17 generics - which is where you eventually
find its properties defined.</p>
<p>To be fair, after re-formatting the type definition file and staring at it for a
couple of minutes, I do start to understand what’s going on. For the <code>FieldMeta</code>
type in particular there’s nothing too obscure, but I can’t help but feel that
this undoubtedly clever and accurate type definition is not actually <em>helping</em>
me as a user of the library.</p>
<h3 id="cons-of-hyper-typing"><a href="#cons-of-hyper-typing">Cons of Hyper-Typing</a></h3>
<p>TanStack Form is one example of a hyper-typing library, but as I said, lately
I’ve encountered others that follow a similar approach and leave me with similar
issues:</p>
<ul>
<li>
<p><strong>Badly-formatted type definition files</strong>. This is technically TypeScript’s
fault, but I guess the issue is not apparent until the typings become very
complex. It should be easy to fix, though, just by running the files through
prettier.</p>
</li>
<li>
<p><strong>Difficult to understand types</strong>. I agree that they’re safer and more
accurate, but that’s not very useful if I don’t understand what they’re
actually describing.</p>
</li>
<li>
<p><strong>Unsafe workarounds</strong>. Getting into situations where I need to explicitly
define a type is inevitable, and when the library types are so difficult to
understand and use, I often end up resorting to casting things <code>as any</code>,
losing more type safety than I gained.</p>
</li>
<li>
<p><strong>Incomprehensible error messages</strong>. TypeScript error messages are not amazing
to start, and the more complex the type, the more complex the error message.</p>
</li>
</ul>
<h3 id="a-happy-medium"><a href="#a-happy-medium">A Happy Medium</a></h3>
<p>Having banged my head against hyper-typed stuff, I can now say I prefer less
accurate, less safe libraries. They might be dumber; I might need to explicitly
define a type that <em>technically</em> could have been inferred. But the practical
reality is that I find working with them being overall more enjoyable, and the
resulting code more understandable and maintainable.</p>
<p>An alternative approach that I also find more enjoyable is having a separate
build step that <em>generates</em> types - from a schema definition, for example. In
some corners of the internet I’ve seen it being depicted as the ultimate DX sin,
but on more than one occasion I’ve actually found it works very well. For
example, the way the <a href="https://astro.build/" target="_blank" rel="noopener noreferrer">Astro framework</a> for building static
websites generates types for your content collections is just delightful. I
really hope more tools follow in its footsteps.</p> </section></div>
  </body>
</html>
