<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.corsix.org/content/riscv-conditional-moves">Original</a>
    <h1>RISC-V Conditional Moves</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <div>
      <p>I&#39;m a big fan of aarch64&#39;s <code>csel</code> family of instructions. A single instruction can evaluate <code>rd = cond ? rs1 : f(rs2)</code>, where <code>cond</code> is any condition code and <code>f</code> is any of <code>f<sub>0</sub>(x) = x</code> or <code>f<sub>1</sub>(x) = x+1</code> or <code>f<sub>2</sub>(x) = ~x</code> or  or <code>f<sub>3</sub>(x) = -x</code>. Want to convert a condition to a boolean? Use <code>f<sub>1</sub></code> with <code>rs1 == rs2 == x0</code>. Want to convert a condition to a mask? Use <code>f<sub>2</sub></code> with <code>rs1 == rs2 == x0</code>. Want to compute an absolute value? Use <code>f<sub>3</sub></code> with <code>rs1 == rs2</code>. It is pleasing that the composition of <code>f<sub>1</sub></code> and <code>f<sub>2</sub></code> is <code>f<sub>3</sub></code>. I could continue espousing, but hopefully you get the idea.</p>
<p>RISC-V is the hot new thing, but it lacks a direct equivalent to <code>csel</code>. <em>Some</em> cases of converting conditions to booleans are possible with the <code>slt</code> family of instructions in the base instruction set. Beyond that, a few special cases are implemented by instruction set extensions: Zbb adds <code>min</code> and <code>max</code> instructions which are a particular pattern of compare and select, and Zicond adds <code>czero.eqz</code> and <code>czero.nez</code> which again are particular patterns of compare and select. But the general case? Considered and rejected, as per this direct quote from The RISC-V Instruction Set Manual Volume I Version 20250508:</p>
<blockquote>
<p>We considered but did not include conditional moves or predicated instructions, which can effectively replace unpredictable short forward branches. Conditional moves are the simpler of the two, but are difficult to use ...</p>
</blockquote>
<p>That quote hints at short forward branches being the recommended alternative. It doesn&#39;t <em>quite</em> go as far as to say that out-of-order cores are encouraged to perform macro fusion in the frontend to convert short forward branches back into conditional moves (when possible), but it is commonly taken to mean this, and <a href="https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg211045.html">some SiFive cores implement exactly this fusion</a>.</p>
<p>Continuing to quote from The RISC-V Instruction Set Manual Volume I Version 20250508, the introductory text motivating Zicond also mentions fusion:</p>
<blockquote>
<p>Using these [Zicond] instructions, branchless sequences can be implemented (typically in two-instruction sequences) without the need for instruction fusion, special provisions during the decoding of architectural instructions, or other microarchitectural provisions.</p>
<p>One of the shortcomings of RISC-V, compared to competing instruction set architectures, is the absence of conditional operations to support branchless code-generation: this includes conditional arithmetic, conditional select and conditional move operations. The design principles of RISC-V (e.g. the absence of an instruction-format that supports 3 source registers and an output register) make it unlikely that direct equivalents of the competing instructions will be introduced.</p>
</blockquote>
<p>The design principles mentioned in passing mean that <code>czero.eqz</code> has slightly odd semantics. Assuming <code>rd ≠ rs2</code>, the intent is that these two instruction sequences compute the same thing:</p>
<table><tbody><tr><th>Base instruction set</th><th>With Zicond</th></tr>
<tr><td><pre><code>  mv rd, x0
  beq rs2, x0, skip_next
  mv rd, rs1
skip_next:</code></pre></td><td><pre><code>  czero.eqz rd, rs1, rs2
 
 
 </code></pre></td></tr></tbody></table>
<p>The whole premise of fusion is predicated on the idea that it is valid for a core to transform code similar to the branchy code on the left into code similar to the branch-free code on the right. I wish to cast doubt on this validity: it is true that the two instruction sequences compute the same thing, but details of the RISC-V memory consistency model mean that the two sequences are very much <strong>not</strong> equivalent, and therefore a core cannot blindly turn one into the other.</p>
<p>To see why, consider this example, again from The RISC-V Instruction Set Manual Volume I Version 20250508:</p>
<blockquote>
<p>Control dependencies behave differently from address and data dependencies in the sense that a control dependency always extends to all instructions following the original target in program order.</p>
<pre><code>  lw x1, 0(x2)
  bne x1, x0, next
next:
  sw x3, 0(x4)
</code></pre>
<p>Even though both branch outcomes have the same target, there is still a control dependency from the memory operation generated by the first instruction in this snippet to the memory operation generated by the last instruction. This definition of control dependency is subtly stronger than what might be seen in other contexts (e.g., C++), but it conforms with standard definitions of control dependencies in the literature.</p>
</blockquote>
<p>The general point highlighted by this example is that every branch (or indirect jump) instruction imposes a syntactic control dependency on <em>every</em> store instruction anywhere after it in program order. If a branch is converted to a conditional move, there is no longer a syntactic control dependency. There can instead be an address or data dependency, but this only applies to stores which use the result of the conditional move, whereas the syntactic control dependency applied to <em>all</em> stores. In other words, not equivalent.</p>
<p>TLDR: If RISC-V cores want to perform fusion of short forward branches into conditional moves (to mitigate the lack of conditional moves in the instruction set), the resultant fused instruction needs to retain some branch-like properties to avoid violating the memory model.</p>

    </div>
  </div></div>
  </body>
</html>
