<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lbjgruppen.com/en/posts/functional-quadtree-clojure">Original</a>
    <h1>Functional Quadtrees</h1>
    
    <div id="readability-page-1" class="page"><div id="id4fe611ed-e871-8fb9-75be-07d4c8c7ded3"><div><div id="id3aff6b50-89f5-5410-043d-635f3ea25696" name=""><p id="idc069d362-a503-47f5-8b91-ae6555aef1c8" name="">A 
    <a href="https://en.wikipedia.org/wiki/Quadtree" target="_blank">Quadtree</a> is a tree data structure, which is useful for giving more focus/detail to certain regions of your data, while saving resources elsewhere. I could only find a couple tutorials/guides and both were imperative, so I figured it&#39;d be fun to do a functional version in Clojure which runs in the browser.</p><h2 id="ida8d55fc5-a6f9-13de-65a1-651242969fc6">A demo</h2><p id="ida4d41ae1-7244-154b-124a-dda4df4b52d8">In this blogpost I&#39;ll show you how to build both a functional Quadtree and the visualization you see below. Imagine the canvas to be a top-view of map and your mouse-position to be the spot you&#39;re occupying on the map. Near you, you want crisp details, small cells of high resolution. The further away we get from you/the camera (your mouse-position), the less we care about details.</p><p id="id36c70d4f-303f-6733-dd94-df77618ed3f6">Be aware that on mobile, you have to click at the spot you want to simulate the cameras position. I recommend you view this on a desktop system with a mouse, where the simulation reacts to the mouse position in real time.</p><canvas id="quadtree" width="1094" height="1307"></canvas><h2 id="idf455fbb8-e6ff-130b-4c10-85210af0043b">The recursive approach</h2><p id="id65ba922e-f8ab-f5ad-1cff-d19be5998908">It&#39;s hard to find any tutorials on how to build a general purpose Quadtree, but the 2 I did find both took the imperative approach, ie. editing directly on each node. Nothing wrong with that approach, it can be blazingly fast but it does leave you with the housekeeping, ie. downscaling nodes that are no longer close to the camera. I&#39;d much prefer a declarative definition that rebuilds the entire tree in sub-milliseconds, so let&#39;s make that happen.</p><p id="id78d7f802-e63d-b86d-fe7b-ab0fd0b9a1a3">In this implementation, I want to show a very general functional approach and goes like this:</p><ol><li id="ida02f7c23-0229-3904-53fd-26c88561f17b">Read a camera (player,mouse,focus-point,whatever) position</li><li>Test if the current node is optimally sized</li><li id="idee1968ef-b2e2-f813-02e3-64acde10238d">If not, split into 4 children, goto 2</li></ol><p id="id59cd7567-1298-b4d8-2428-f8515d04f9b6">Optimally sized in this case is just &#34;Am I too far away from the edge of the node&#34; ? If the distance is greater than some threshold, let&#39;s say the width of the node, then we split.</p><h2 id="id84cf3a80-088a-6491-5581-fe7ba370638d">Our data model</h2><p id="idaf717747-68ef-8fc6-bb8d-c9ae1fcc1b15">Depending on your use-case, you can fit as much information as you want into this model. If you&#39;re doing some kind of 3D rendering, you might want to keep tabs on neighbor-relations, <span id="id3a1caced-d9f1-a962-5d81-18ad30935964" name=""><abbrev title="Level of detail">LOD</abbrev></span> steps and such, but for the basic tree structure, you just need this:</p><pre id="id7cd9711e-065d-27a6-1660-0946e4326493" name=""><code id="iddff7bdbc-dc86-4af4-de53-b44c256cfca3">(defn qtree
  &#34; Instantiates a tree node &#34;
  [[x1 y1 x2 y2]]
  {:root?   false
   :bounds  [x1 y1 x2 y2]
   :center  (mapv #(js/Math.floor %)
                  [(half x2 x1)
                   (half y2 y1)])
   :width   (- x2 x1)})</code></pre><p id="id8d09870d-0a6f-1dd3-fd44-1b3945fd10c3">In fact we strictly speaking, don&#39;t need the center/width stored, but it does make life a bit easier. </p><p id="idc66488b3-4600-f2fc-75c4-32fb41c5944e">Given a root node and a camera-position we can determine if we want to split or not, simply by testing the distance from the camera to the center:</p><pre id="id26c16ec0-693e-b547-3849-d623223cec6e" name=""><code id="idcaf54670-fb85-b7b5-7874-8d49429145e4">(defn distance
  [[x1 y1] [x2 y2]]
  (js/Math.sqrt
   (+ (js/Math.pow (- x2 x1) 2)
      (js/Math.pow (- y2 y1) 2))))

(defn too-close?
  &#34; Determines if the camera is closer than halfway to
    the edge of a node &#34;
  [ node camera ]
  (&lt; (distance camera (:center node))
     (:width node)))

(defn split?
  [ node camera ]
  (and (too-close? node camera)
       (&gt; (:width node) _Q_MINIMUM_SIZE)))
</code></pre><p id="id91a55439-849e-8e91-2208-29fcf91343d1">That final check on the width of the node, essentially allow us to recurse until we can&#39;t split anymore. In Clojure we have 2 very powerful idioms for walking a tree structure: Postwalk and Prewalk.</p><p id="ide626256a-dd51-93b0-1b21-b3b89870b764">Postwalk is a depth-first, post-order walk of the tree which applies some arbitrary function to each element. </p><pre id="idc8128a9c-4535-4cdc-6e69-a21f60b75dad"><code id="idbfbfe952-66a5-fcb2-d667-84e5aa6c4eff">(w/postwalk (fn [e]
                (prn &#34;Looking at: &#34; e)
                e)
            {:rootval 1
            :node1 {:data &#34;foo&#34;
            :vec  [1 2 3]}})
&#34;Looking at: &#34; :rootval
&#34;Looking at: &#34; 1
&#34;Looking at: &#34; [:rootval 1]
&#34;Looking at: &#34; :node1
&#34;Looking at: &#34; :data
&#34;Looking at: &#34; &#34;foo&#34;
&#34;Looking at: &#34; [:data &#34;foo&#34;]
&#34;Looking at: &#34; :vec
&#34;Looking at: &#34; 1
&#34;Looking at: &#34; 2
&#34;Looking at: &#34; 3
&#34;Looking at: &#34; [1 2 3]
&#34;Looking at: &#34; [:vec [1 2 3]]
&#34;Looking at: &#34; {:data &#34;foo&#34;, :vec [1 2 3]}
&#34;Looking at: &#34; [:node1 {:data &#34;foo&#34;, :vec [1 2 3]}]
&#34;Looking at: &#34; {:rootval 1, :node1 {:data &#34;foo&#34;, :vec [1 2 3]}}
{:rootval 1, :node1 {:data &#34;foo&#34;, :vec [1 2 3]}}</code></pre><p id="id07726ba6-699e-8080-dfc6-c1376e4d13b8">I hope this is an intuitive way to see the path postwalk takes. The function only prints what it sees and then returns it as is, thus the end result is exactly the map we started out with. Notice how we first see the root key, then its value, then both together as a MapEntry, then it goes deeper into the tree. </p><p id="idd7e048a2-ae75-19cf-b204-38029caf3478">Now compare that with prewalk:</p><pre id="id86792181-d6e8-3565-15ff-33a196a58e7c"><code id="id9f24702f-1664-b92b-3149-c16c484ab459">(w/prewalk (fn [e]
               (prn &#34;Looking at: &#34; e)
               e)
           {:rootval 1
           :node1 {:data &#34;foo&#34;
           :vec  [1 2 3]}})
&#34;Looking at: &#34; {:rootval 1, :node1 {:data &#34;foo&#34;, :vec [1 2 3]}}
&#34;Looking at: &#34; [:rootval 1]
&#34;Looking at: &#34; :rootval
&#34;Looking at: &#34; 1
&#34;Looking at: &#34; [:node1 {:data &#34;foo&#34;, :vec [1 2 3]}]
&#34;Looking at: &#34; :node1
&#34;Looking at: &#34; {:data &#34;foo&#34;, :vec [1 2 3]}
&#34;Looking at: &#34; [:data &#34;foo&#34;]
&#34;Looking at: &#34; :data
&#34;Looking at: &#34; &#34;foo&#34;
&#34;Looking at: &#34; [:vec [1 2 3]]
&#34;Looking at: &#34; :vec
&#34;Looking at: &#34; [1 2 3]
&#34;Looking at: &#34; 1
&#34;Looking at: &#34; 2
&#34;Looking at: &#34; 3
{:rootval 1, :node1 {:data &#34;foo&#34;, :vec [1 2 3]}}</code></pre><p id="id88158913-5d05-4912-8b87-8d32e91b05b4">Prewalk examines the same elements and in the same way, but the path is what we call a pre-order traversal, which means you see contents of nodes before the elements - And by implication, you can swap those nodes and then visit the elements. All in all, prewalk makes for a very simple recursive pattern:</p><pre id="idacb3480a-a191-3307-48ef-c974b4e42383"><code id="id5eb8fa1e-b8ff-f27f-d371-7eea0f448611" name="">(w/prewalk
 (fn [n]
     (if (and (map? n) (split? n [x y]))
         (subdivide n)
       n))
 qtree)</code></pre><p id="id64f8a003-21e6-0d90-6d2c-b7ac51ef3914">Yes, it&#39;s really that simple. Given a root-node and a camera-position (x,y), this will recursively resolve all children to the maximum resolution. </p><h2 id="idbb2a4f21-5c31-f03d-4c21-4b7743576f39">The Visualization</h2><p id="id0cf79047-dc8e-146b-5914-f6707d7b0ef6">If you want to read ahead, I&#39;ve shared a repo here: <a href="https://github.com/LauJensen/functional-qtree" target="_blank">Github</a></p><p id="id728576b9-12f7-2770-abf9-f9e26692403a">The code should run straight out of the box and open a webinterface on port 8020. Shadow-cljs makes light work of compiling anything from a single file to a huge frontend application, into a single JS file.</p><p id="idd5b0d402-a09a-7341-ddf9-af253d60999c">Running in a browser we get a nice 2D API from the standard canvas element. Basically, to draw our Quadtree we need only 3 things:</p><ul><li>A Quadtree</li><li>A function which draws a node</li><li>A function which draws all children</li></ul><p id="id8e5f98c7-0231-bda2-6efb-6a6b2f8c8d25">As you&#39;ve probably guessed, the Quadtree itself is just a simple map with some keys. But because this is a realtime visualization, I want to create a connection between whichever tree I generated and what&#39;s drawn on screen. Fortunately both Clojure and Clojurescript support both atoms and watches:</p><pre id="idff639cb7-b636-787f-d80b-6af51b8a3cc3"><code id="id88b3eb97-510c-e104-1865-86c51f6fd49e" name="">(def quadInst (atom nil))

(add-watch quadInst :updateQuads
           (fn [_ _ old-tree new-tree]
             (draw-all new-tree)))</code></pre><p id="id4601d97f-33aa-005a-f20a-f1ce3c5986a9">By convention in Clojure, we name arguments underscore (_) if we do not care about them. In this case, I only need the new-tree for the visualization. If you&#39;re not a native Clojurian you might find this pattern appealing as it gives you access to both the pre-updated version and the updated tree, meaning you can run diffs, add new children to a scene while removing others. </p><p id="idee1ceb8c-e6f6-5c13-82ee-0febf41a5d9d">I mention it here for demonstration purposes only, in the latest commit you&#39;ll see I actually remove all atoms and demonstrate a 100% pure functional solution without atoms. However for the purpose of explaining Quadtree this is a simple subscription-pattern which most developers will recognize. It ensures that whenever the atom Quadtree is updated, so is the screen.</p><pre id="id21aef20b-8282-3527-a633-b0ace9af347f"><code id="id354f10fb-e09a-70d6-a41c-4779c011d119">(defn draw-all
  [ tree ]
  (draw (:root? tree)
        tree
        (get-tree-color tree))
  (when-let [children (:children tree)]
    (doseq [c children]
      (draw-all c))))</code></pre><p id="id073b58cb-2fde-0ad1-62f7-2fc1a667edfc">However there&#39;s a fun detail here. To make it seem fairly consistent I couldn&#39;t just use random colors, that would make the entire screen flicker whenever you moved the mouse. Basically, if I have a rectangle centered at 50,50 - I always want it to have the same color. A really neat and simple trick is the 32bit hash, which is succinctly implemented in javascript like so:</p><pre id="id06d3a06d-9b2d-a112-5ffa-b03d502b6ffb" name=""><code id="idc228c757-8340-2412-fe85-8611b376e8a1">function fastHash(str) {
    let hash = 0;
    for (let i = 0; i &lt; str.length; i++) {
        hash = (hash &lt;&lt; 5) - hash + str.charCodeAt(i); // Hash computation
        hash |= 0; // Convert to 32bit integer
    }
    return hash &gt;&gt;&gt; 0; // Ensure the result is unsigned
}</code></pre><p id="id71638fc9-7ef5-7a66-6ddb-f15d44794282">Basically my idea is to hash the center, ie &#34;[50,50]&#34; and convert that to a hex color. In Clojurescript, you could do it like so:</p><pre id="id6548d756-dc94-c7c0-afbc-d45cd9b5d4cf" name=""><code id="id2d9b1995-5fe4-9c00-9795-237bb15d4f78">(defn hash-str
  &#34; Standard 32bit hash: [..].map((% &lt;&lt; 5) - h + ch(idx) &#34;
  [ s ]
  (reduce #(-&gt; (bit-shift-left %1 5)
               (- %1)
               (+ (.charCodeAt %2 0))
               (bit-or 0))
          0 s))

(defn get-tree-color
  [ {c :center} ]
  (let [hash (bit-and (hash-str (str c)) 0xffffff)
        hex  (.toString hash 16)]
    (str &#34;#&#34; (apply str (repeat (- 6 (count hex)) &#34;0&#34;)) hex)))</code></pre><p id="id225fb846-282a-9648-47ce-424698cc9ab1">That&#39;s basically all you need.</p><h2 id="id63091e8d-0954-7467-289c-bc7b03f6a36d">Conclusion</h2><p id="id7f7adce0-b9e3-5439-aa16-e261b28d9177" name="">Quadtrees are great when you have more work to do, than resources available. Imagine using a VR headset. Whichever point you&#39;re focused at, needs to be crisp in detail, you want the highest resolution possible on your hardware. Everything outside of your focus area should be dialed down in resolution because your eyes won&#39;t be able to pick it up anyway, so that compute power can be used elsewhere. There are many other applications.</p><p id="idfcd45aa1-d974-3cd6-daf6-e0cca719a308">Clojurescript is great, because it allows us to express ourselves succinctly and functionally. The core of this implementation is only about 25 lines long. That&#39;s much easier to reason about and debug, than some other implementations I&#39;ve seen, which span several hundred lines.</p><p id="ide15a4ce5-d4b9-a6bc-e707-b48e8a022afa">Shadow-cljs is great for more reasons than I can cover in this post, but I will highlight the ability to quickly ship highly optimized bit of JS using only 10 lines of configuration - And they even throw in a free webserver for easy testing and repl driven development, what&#39;s not to like?</p><p id="idf133d0b6-7796-8faa-cf9c-15f408073d06">Full source code: <a href="https://github.com/LauJensen/functional-qtree" target="_blank">Github</a></p></div></div></div></div>
  </body>
</html>
