<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://driftingin.space/posts/complexity-kubernetes">Original</a>
    <h1>Accidental complexity, essential complexity, and Kubernetes</h1>
    
    <div id="readability-page-1" class="page"><div id="__next" data-reactroot=""><div><div><article><p><time datetime="2022-09-05">September 5, 2022</time> • <!-- -->Paul Butler</p><p>Kubernetes has a reputation among developers for being complex and scary, enough so that posts about <em>not</em> using Kubernetes are a <a href="https://endler.dev/2019/maybe-you-dont-need-kubernetes/">genre</a> <a href="https://matt-rickard.com/dont-use-kubernetes-yet">unto</a> <a href="https://ably.com/blog/no-we-dont-use-kubernetes">themselves</a>. In this post, I want to delve into the roots of Kubernetes’ complexity, as a framework for evaluating when it&#39;s the right tool for the job.</p>
<p>Complexity in software systems can be broken into <strong>essential complexity</strong> and <strong>accidental complexity</strong>, following Fred Brooks’ 1987 paper <em><a href="https://www.cgl.ucsf.edu/Outreach/pc204/NoSilverBullet.html">No Silver Bullet</a></em>. Essential complexity is the unavoidable complexity that results from building a system that solves complex problems. Accidental complexity might be best described as any complexity that <em>isn’t</em> essential: complexity introduced by path dependence, design decisions, bad assumptions, and poorly-chosen abstractions.</p>
<p>Through Brooks’ accidental-vs-essential lens, a lot of discussion around when to use Kubernetes boils down to the idea that essential complexity can become accidental complexity when you use the wrong tool for the job. The number of states my microwave can enter is <em>essential complexity</em> if I want to heat food, but <em>accidental complexity</em> if I just want a timer.</p>
<p>With that in mind, I want to talk about the sources of complexity in Kubernetes. It’s useful to separate Kubernetes’ functionality into three distinct responsibilities: a distributed <strong>control loop</strong> framework, a <strong>container orchestrator</strong>, and an abstract <strong>interface to cloud resources</strong>, which I&#39;ll discuss in turn.</p>
<h2>Control loops</h2>
<p>One way to think of Kubernetes is as a distributed framework for control loops. Broadly speaking, control loops create a declarative layer on top of an imperative system. Think of a thermostat: instead of switching a cooler or heater on or off, you set a desired state (temperature). The thermostat makes frequent measurements, calculates the difference in the actual and desired state, and translates that into a sequence of imperative actions.</p>
<p>Control loops are just a generalization of this concept to anything that can be measured, compared with a desired state, and acted upon. This idea is at the core of Kubernetes. “Deploying” software with Kubernetes really means providing Kubernetes with a desired state in which that software is deployed. The same is true for setting up networking, storage, and every other resource that Kubernetes interacts with.</p>
<p>Resources in Kubernetes are just YAML blobs, and developers can create their own resource types by providing a schema definition. The underlying storage for these resources is a <a href="https://etcd.io/">strongly consistent, distributed data store</a>. The combination of these two facts makes Kubernetes a solid base for implementing your own control loops, which is called the <a href="https://www.cncf.io/wp-content/uploads/2021/07/CNCF_Operator_WhitePaper.pdf">Operator Pattern</a>.</p>
<p>Control loops are a building block of <a href="https://en.wikipedia.org/wiki/High_availability">highly-available systems</a>, but bring with them their own complexity. In an imperative system, there is a tight feedback loop between action and effect. If I switch on a broken fan, I know immediately when I don’t feel a nice breeze. By contrast, if I turn a thermostat down and I don’t immediately feel cold air, I can&#39;t tell whether the thermostat is broken, the AC is broken, or if everything works and just hasn’t kicked in yet.</p>
<p>I suspect this detachment between cause and effect grates on many beginners of Kubernetes. The tightness of the cause/effect loop directly impacts how easy (and fun) something is to learn. Bret Victor took this to one extreme in <a href="https://www.youtube.com/watch?v=PUv66718DII">Inventing on Principle</a>. Control loops take it to the opposite extreme. Learning Kubernetes is less about learning how to <em>do</em> things as it is about learning how to observe the state of Kubernetes.</p>
<h2>Container orchestration</h2>
<p>On top of the underlying control loop framework, Kubernetes is a container orchestrator. Fundamentally, a container orchestrator creates an abstraction over multiple computers that allow them to be treated as one abstract blob within which containers can be run. When you run a container on Kubernetes, you don’t specify which computer they run on; you (hopefully) don’t care.</p>
<p>Actually, that’s not quite true. Containers generally correspond to one process, and inter-process communication is a common thing to want. If processes aren’t running on the same machine, that IPC now has to go over the network, which may be orders of magnitude slower. So instead of containers being the level of abstraction, Kubernetes treats groups of containers (<em>pods</em>) as the unit of compute that gets scheduled.</p>
<p>Unfortunately, as Joel Spolsky’s <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">law of leaky abstractions</a> states:</p>
<blockquote>
<p>All non-trivial abstractions, to some degree, are leaky.</p>
</blockquote>
<p>Kubernetes abstracts away the decision of which computer a pod runs on, but reality has a way of poking through. For example, if you want multiple pods to access the same <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">persistent storage volume</a>, whether or not they are running on the same node suddenly becomes your concern again.</p>
<p>This is just the nature of providing abstractions: reality doesn&#39;t care about them. It doesn’t mean that creating abstractions is a bad approach, it just means that you can’t get rid of all the complexity you would like to.</p>
<h3>Aside: Containers</h3>
<p>Some other complexity around container orchestration comes from the nature of containers themselves. At some point, we decided that it was useful for programs to be able to share libraries, data, and language interpreters with other programs on the same computer. This meant that programs occupied less space on disk and in memory.</p>
<p>Then, disk and memory got cheap, and we realized that depending on shared libraries and interpreters led to deployment headaches. Containers came around to solve the problem by clumping together all a program’s user-space dependencies into one deployable unit.</p>
<p>The result is kind of a mess. It’s nobody’s fault, it’s just vestigial. But the result is that in addition to writing code, we also need to collect all of our system dependencies and bake them into a mini Linux distro (sans kernel).</p>
<p>Containers were a great advance, but much of their complexity falls into the “accidental” category. There’s no fundamental reason that I should need anything except my compiler to produce a universally deployable unit of code. To that end, I’m excited by what’s happening with WebAssembly (including our <a href="https://github.com/drifting-in-space/stateroom">stateroom</a> and <a href="https://github.com/drifting-in-space/wasmbox">wasmbox</a>), but for now containers are a fact of life.</p>
<h2>Cloud interface</h2>
<p>A third piece of Kubernetes is that it provides a vendor-agnostic(ish) abstraction over cloud services.</p>
<p>A container orchestrator is more useful if things like network ingress and storage volumes can be attached to it, and doing so on the cloud requires interacting with vendor-specific APIs. Kubernetes provides a higher-level, resource-based abstraction on top of these interfaces, so that you can specify them declaratively in the same way you do containers.</p>
<p>This aspect of Kubernetes might be its most under-appreciated, because if you use a managed Kubernetes service like GKE or EKS, it’s not always clear where Kubernetes ends and the cloud APIs begin. But it’s the reason that releasing Kubernetes was an ingenious strategy for Google: it gave cloud vendors and open-source developers an API to target that wasn&#39;t tied to AWS.</p>
<p>As you might expect, though, abstracting over cloud providers is a minefield of leaky abstractions. The Kubernetes documentation is scattered with notes about special cases to be aware of with different providers, even for core resources like <a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer">services</a>. Kubernetes reduces lock-in, but the idea of seamlessly transfering infrastructure between cloud vendors is still a pipe dream.</p>
<h2>Accidental complexity</h2>
<p>Each of the above cases are instances of essential complexity. They do incorporate some accidental complexity as I discussed around containers, but we can&#39;t fault Kubernetes for the world that it was born into.</p>
<p>There are other areas where Kubernetes does introduce accidental complexity, though. I won’t attempt an exhaustive list, but a few that I’ve encountered:</p>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/#use-a-json-merge-patch-to-update-a-deployment">Multiple sets of semantics</a> for patching resources that differ in subtle ways.</li>
<li>The use of YAML as the primary interface, which is notoriously <a href="https://noyaml.com/">full of foot-guns</a>.</li>
<li>The fact that you need a special distribution like minikube, Kind, k3s, microk8s, or k0s to run on a single-node instance. (The fact that I named five such distributions is a canary of its own.)</li>
</ul>
<h2>Tool/job fit</h2>
<p>A tool a good fit for a job when their complexities line up. Kubernetes’ complexities come from being highly-available, container-based, and interacting with cloud providers.</p>
<p>At Drifting in Space, we’ve found that Kubernetes makes sense for use-cases that align with those complexities (for example, hosting our <a href="https://nats.io/">NATS</a> cluster). For the ephemeral containers that are our bread and butter, Kubernetes was handy for our proof-of-concept, but we quickly realized the complexities we faced were not the same ones Kubernetes was built for. To orchestrate those containers, we built a control plane called <a href="https://github.com/drifting-in-space/spawner">Spawner</a>, but that&#39;s a subject for another post.</p>
<p><em>For more like this, <a href="https://twitter.com/drifting_corp">follow us on Twitter</a></em></p></article></div></div></div></div>
  </body>
</html>
