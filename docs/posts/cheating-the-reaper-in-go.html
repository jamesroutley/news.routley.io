<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mcyoung.xyz/2025/04/21/go-arenas/">Original</a>
    <h1>Cheating the Reaper in Go</h1>
    
    <div id="readability-page-1" class="page"><div> <p>Even though I am a C++ programmer at heart, Go fascinates me for none of the reasons you think. Go has made several interesting design decisions:</p> <ol> <li> <p>It has virtually no Undefined Behavior<sup id="fnref:goub" role="doc-noteref"><a href="#fn:goub" rel="footnote">1</a></sup>.</p> </li> <li> <p>It has very simple GC semantics that they’re mostly stuck with due to design decisions in the surface language.</p> </li> </ol> <p>These things mean that despite Go having a GC, it’s possible to do manual memory management in pure Go and in cooperation with the GC (although without any help from the <code>runtime</code> package). To demonstrate this, we will be building an untyped, garbage-collected arena abstraction in Go which relies on several GC implementation details.</p> <p>I would never play this kind of game in Rust or C++, because LLVM is extremely intelligent and able to find all kinds of ways to break you over the course of frequent compiler upgrades. On the other hand, although Go does not promise any compatibility across versions for code that imports <code>unsafe</code>, in practice, two forces work against Go doing this:</p> <ol> <li> <p>Go does not attempt to define what is and isn’t allowed: <code>unsafe</code> lacks any <a href="https://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a>.</p> </li> <li> <p>Go prioritizes not breaking the ecosystem; this allows to assume that <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a> will protect certain observable behaviors of the runtime, from which we may infer what can or cannot break easily.</p> </li> </ol> <p>This is in contrast to a high-performance native compiler like LLVM, which has a carefully defined boundary around all UB, allowing them to arbitrarily break programs that cross it (mostly) without fear of breaking the ecosystem.</p> <p>So, let’s dive in and cheat death.</p> <h2 id="what-are-we-building"><a href="#what-are-we-building">What Are We Building?</a></h2> <p>Our goal is to build an <em>arena</em>, which is a data structure for efficient allocation of memory that has the same lifetime. This reduces pressure on the general-purpose allocator by only requesting memory in large chunks and then freeing it all at once.</p> <p>For a comparison in Go, consider the following program:</p> <div><figure><pre><code data-lang="go"><span>package</span> <span>main</span>

<span>import</span> <span>&#34;fmt&#34;</span>

<span>func</span> <span>main</span><span>()</span> <span>{</span>
  <span>var</span> <span>s</span> <span>[]</span><span>int</span>
  <span>for</span> <span>i</span> <span>:=</span> <span>range</span> <span>1000</span> <span>{</span>
    <span>prev</span> <span>:=</span> <span>cap</span><span>(</span><span>s</span><span>)</span>
    <span>s</span> <span>=</span> <span>append</span><span>(</span><span>s</span><span>,</span> <span>i</span><span>)</span>
    <span>if</span> <span>cap</span><span>(</span><span>s</span><span>)</span> <span>!=</span> <span>prev</span> <span>{</span>
      <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>cap</span><span>(</span><span>s</span><span>))</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code></pre></figure></div> <p>This program will print successive powers of 2: this is because <code>append</code> is implemented approximately like so:</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>append</span><span>[</span><span>S</span> <span>~</span><span>[]</span><span>T</span><span>,</span> <span>T</span> <span>any</span><span>](</span><span>a</span><span>,</span> <span>b</span> <span>S</span><span>)</span> <span>S</span> <span>{</span>
  <span>// If needed, grow the allocation.</span>
  <span>if</span> <span>cap</span><span>(</span><span>a</span><span>)</span> <span>-</span> <span>len</span><span>(</span><span>a</span><span>)</span> <span>&lt;</span> <span>len</span><span>(</span><span>b</span><span>)</span> <span>{</span>
    <span>// Either double the size, or allocate just enough if doubling is</span>
    <span>// too little.</span>
    <span>newCap</span> <span>:=</span> <span>max</span><span>(</span><span>2</span><span>*</span><span>cap</span><span>(</span><span>a</span><span>),</span> <span>len</span><span>(</span><span>a</span><span>)</span><span>+</span><span>len</span><span>(</span><span>b</span><span>))</span>

    <span>// Grow a.</span>
    <span>a2</span> <span>:=</span> <span>make</span><span>([]</span><span>T</span><span>,</span> <span>len</span><span>(</span><span>a</span><span>),</span> <span>newCap</span><span>)</span>
    <span>copy</span><span>(</span><span>a2</span><span>,</span> <span>a</span><span>)</span>
    <span>a</span> <span>=</span> <span>a2</span>
  <span>}</span>

  <span>// Increase the length of a to fit b, then write b into the freshly</span>
  <span>// grown region.</span>
  <span>a</span> <span>=</span> <span>a</span><span>[</span><span>:</span><span>len</span><span>(</span><span>a</span><span>)</span><span>+</span><span>len</span><span>(</span><span>b</span><span>)]</span>
  <span>copy</span><span>(</span><span>a</span><span>[</span><span>len</span><span>(</span><span>a</span><span>)</span><span>-</span><span>len</span><span>(</span><span>b</span><span>)</span><span>:</span><span>],</span> <span>b</span><span>)</span>
  <span>return</span> <span>a</span>
<span>}</span></code></pre></figure></div> <p>For appending small pieces, <code>make</code> is only called <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span>lo<span>g</span></span><span></span><span>n</span><span>)</span></span></span></span></span> times, a big improvement over calling it for every call to <code>append</code>. Virtually every programming language’s dynamic array abstraction makes this optimization.</p> <p>An arena generalizes this concept, but instead of resizing exponentially, it allocates <em>new</em> blocks and vends pointers into them. The interface we want to conform to is as follows:</p> <div><figure><pre><code data-lang="go"><span>type</span> <span>Allocator</span> <span>interface</span> <span>{</span>
  <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span></code></pre></figure></div> <p>In go a size and and an alignment, out comes a pointer fresh memory with that layout. Go does not have user-visible uninitialized memory, so we additionally require that the returned region be zeroed. We also require that <code>align</code> be a power of two.</p> <p>We can give this a type-safe interface by writing a generic <code>New</code> function:</p> <div><figure><pre><code data-lang="go"><span>// New allocates a fresh zero value of type T on the given allocator, and</span>
<span>// returns a pointer to it.</span>
<span>func</span> <span>New</span><span>[</span><span>T</span> <span>any</span><span>](</span><span>a</span> <span>Allocator</span><span>)</span> <span>*</span><span>T</span> <span>{</span>
  <span>var</span> <span>t</span> <span>T</span>
  <span>p</span> <span>:=</span> <span>a</span><span>.</span><span>Alloc</span><span>(</span><span>unsafe</span><span>.</span><span>Sizeof</span><span>(</span><span>t</span><span>),</span> <span>unsafe</span><span>.</span><span>Alignof</span><span>(</span><span>t</span><span>))</span>
  <span>return</span> <span>(</span><span>*</span><span>T</span><span>)(</span><span>p</span><span>)</span>
<span>}</span></code></pre></figure></div> <p>This all feels very fine and dandy to anyone used to hurting themselves with <code>malloc</code> or <code>operator new</code> in C++, but there is a small problem. What happens when we allocate pointer-typed memory into this allocator?</p> <div><figure><pre><code data-lang="go"><span>// Allocate a pointer in our custom allocator, and then</span>
<span>// initialize it to a pointer on the Go heap.</span>
<span>p</span> <span>:=</span> <span>New</span><span>[</span><span>*</span><span>int</span><span>](</span><span>myAlloc</span><span>)</span>
<span>*</span><span>p</span> <span>=</span> <span>new</span><span>(</span><span>int</span><span>)</span>

<span>runtime</span><span>.</span><span>GC</span><span>()</span>
<span>**</span><span>p</span> <span>=</span> <span>42</span>  <span>// Use after free!</span></code></pre></figure></div> <p><code>Allocator.Alloc</code> takes a size and an alignment, which is sufficient to describe the <em>layout</em> of any type. For example, on 64-bit systems, <code>int</code> and <code>*int</code> have the same layout: 8 bytes of size, and 8 bytes of alignment.</p> <p>However, the Go GC (and all garbage collectors, generally) require one additional piece of information, which is somewhere between the layout of a value (how it is placed in memory) and the type of a value (rich information on its structure). To understand this, we need a brief overview on what a GC does.</p> <h2 id="mark-and-sweep"><a href="#mark-and-sweep">Mark and Sweep</a></h2> <blockquote> <p>For a complete overview on how to build a simple GC, take a look at a toy GC I designed some time ago: <a href="https://mcyoung.xyz/2022/06/07/alkyne-gc/">The Alkyne GC</a>.</p> </blockquote> <p>A garbage collector’s responsibility is to maintain a memory allocator and an accounting of:</p> <ol> <li>What memory has been allocated.</li> <li>Whether that memory is still in use.</li> </ol> <p>Memory that is not in use can be reclaimed and marked as unallocated, for re-use.</p> <p>The most popular way to accomplish this is via a “mark and sweep” architecture. The GC will periodically walk the entire object graph of the program from certain pre-determined <em>roots</em>; anything it finds is “marked” as alive. After a mark is complete, all other memory is “swept”, which means to mark it is unallocated for future re-use, or to return it to the OS, in the case of significant surplus.</p> <p>The roots are typically entities that are actively being manipulated by the program. In the case of Go, this is anything currently on the stack of some G<sup id="fnref:g" role="doc-noteref"><a href="#fn:g" rel="footnote">2</a></sup>, or anything in a global (of which there is a compile-time-known set).</p> <p>The marking phase begins with <em>stack scanning</em>, which looks at the stack of each G and locates any pointers contained therein. The Go compiler generates metadata for each function that specifies which stack slots in a function’s frame contain pointers. All of these pointers are live by definition.</p> <p>These pointers are placed into a queue, and each pointer is traced to its allocation on the heap. If the GC does not know anything about a particular address, it is discarded as foreign memory that does not need to be marked. If it does, each pointer in that allocation is pushed onto the queue if it has not already been marked as alive. The process continues until the queue is empty.</p> <p>The critical step here is to take the address of some allocation, and convert it into all of the pointer values within. Go has precise garbage collection, which means that it only treats things declared as pointers in the surface language as pointers: an integer that happens to look like an address will not result in sweeping. This results in more efficient memory usage, but trades off some more complexity in the GC.</p> <p>For example, the types <code>*int</code>, <code>map[int]byte</code>, <code>string</code>, <code>struct {A int; B *int}</code> all contain at least one pointer, while <code>int</code>, <code>[1000]byte</code>, <code>struct {X bool; F uintptr}</code> do not. The latter are called <em>pointer-free</em> types.</p> <p>Go enhances the layout of a type into a <em>shape</em> by adding a bitset that specifies which pointer-aligned, pointer-sized words of the type’s memory region contain a pointer. These are called the <em>pointer bits</em>. For example, here are the shapes of a few Go types on a 64-bit system.</p> <table> <thead> <tr> <th>Type</th> <th>Size/Align</th> <th>Pointer Bits<sup id="fnref:ptr-bits-endian" role="doc-noteref"><a href="#fn:ptr-bits-endian" rel="footnote">3</a></sup></th> </tr> </thead> <tbody> <tr> <td><code>byte</code></td> <td>1/1</td> <td><code>0</code></td> </tr> <tr> <td><code>int</code></td> <td>8/8</td> <td><code>0</code></td> </tr> <tr> <td><code>rune</code></td> <td>4/4</td> <td><code>0</code></td> </tr> <tr> <td><code>*int</code></td> <td>8/8</td> <td><code>1</code></td> </tr> <tr> <td><code>unsafe.Pointer</code></td> <td>8/8</td> <td><code>1</code></td> </tr> <tr> <td><code>string</code></td> <td>16/8</td> <td><code>10</code></td> </tr> <tr> <td><code>[]int</code></td> <td>24/8</td> <td><code>100</code></td> </tr> <tr> <td><code>[3]string</code></td> <td>48/8</td> <td><code>101010</code></td> </tr> <tr> <td><code>map[int]byte</code></td> <td>8/8</td> <td><code>1</code></td> </tr> <tr> <td><code>map[int]string</code></td> <td>8/8</td> <td><code>1</code></td> </tr> <tr> <td><code>any</code></td> <td>16/8</td> <td><code>01</code><sup id="fnref:itab" role="doc-noteref"><a href="#fn:itab" rel="footnote">4</a></sup></td> </tr> <tr> <td><code>error</code></td> <td>16/8</td> <td><code>01</code></td> </tr> <tr> <td><code>func(int) int</code></td> <td>8/8</td> <td><code>1</code></td> </tr> <tr> <td><code>runtime.hchan</code><sup id="fnref:hchan" role="doc-noteref"><a href="#fn:hchan" rel="footnote">5</a></sup></td> <td>104/8</td> <td><code>0010110011110</code></td> </tr> </tbody> </table> <p>In the Go GC, each allocation is tagged with its shape (this is done in a variety of ways in the GC, either through an explicit header on the allocation, itself (a “malloc header”), a runtime type stored in the allocation’s <code>runtime.mspan</code>, or another mechanism). When scanning a value, it uses this information to determine where the pointers to scan through are.</p> <p>The most obvious problem with our <code>Allocator.Alloc</code> type is that it does not discriminate shapes, so it cannot allocate memory that contains pointers: the GC will not be able to find the pointers, and will free them prematurely!</p> <p>In our example where we allocated an <code>*int</code> in our custom allocator, we wind up with a <code>**int</code> on the stack. You would think that Go would simply trace through the first <code>*</code> to find an <code>*int</code> and mark it as being alive, but that is not what happens! Go instead finds a pointer into some chunk that the custom allocator grabbed from the heap, which is missing the pointer bits of its shape!</p> <p>Why does go not look at the type of the pointer it steps through? Two reasons.</p> <ol> <li> <p>All pointers in Go are untyped from the runtime’s perspective; every <code>*T</code> gets erased into an <code>unsafe.Pointer</code>. This allows much of the Go runtime to be “generic” without using actual generics.</p> </li> <li> <p>Pointee metadata can be aggregated, so that each pointer to an object does not have to remember its type at runtime.</p> </li> </ol> <p>The end result for us is that we can’t put pointers on the arena. This makes our <code>New</code> API unsafe, especially since Go does not provide a standard constraint for marking generic parameters as pointer-free: unsurprisingly, the don’t expect most users to care about such a detail.</p> <p>It <em>is</em> possible to deduce the pointer bits of a type using reflection, but that’s very slow, and the whole point of using arenas is to go fast. As we design our arena, though, it will become clear that there is a safe way to have pointers on it.</p> <h2 id="designing-the-arena"><a href="#designing-the-arena">Designing The Arena</a></h2> <p>Now that we have a pretty good understanding about what the Go GC is doing, we can go about designing a fast arena structure.</p> <p>The ideal case is that a call to <code>Alloc</code> is very fast: just offsetting a pointer in the common case. One assumption we can make off the bat is that all memory can be forced to have maximum alignment: most objects are a pointer or larger, and Go does have a maximum alignment for ordinary user types, so we can just ignore the <code>align</code> parameter and always align to say, 8 bytes. This means that the pointer to the next unallocated chunk will always be well-aligned. Thus, we might come up with a structure like this one:</p> <div><figure><pre><code data-lang="go"><span>type</span> <span>Arena</span> <span>struct</span> <span>{</span>
  <span>next</span>      <span>unsafe</span><span>.</span><span>Pointer</span>
  <span>left</span><span>,</span> <span>cap</span> <span>uintptr</span>
<span>}</span>

<span>const</span> <span>(</span>
  <span>// Power of two size of the minimum allocation granularity.</span>
  <span>wordBytes</span> <span>=</span> <span>8</span>  <span>// Depends on target, this is for 64-bit.</span>
  <span>minWords</span>  <span>=</span> <span>8</span>
<span>)</span>

<span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
  <span>// First, round the size up to the alignment of every object in</span>
  <span>// the arena.</span>
  <span>mask</span> <span>:=</span> <span>wordBytes</span> <span>-</span> <span>1</span>
  <span>size</span> <span>=</span> <span>(</span><span>size</span> <span>+</span> <span>mask</span><span>)</span> <span>&amp;^</span> <span>mask</span>
  <span>// Then, replace the size with the size in pointer-sized words.</span>
  <span>// This does not result in any loss of size, since size is now</span>
  <span>// a multiple of the uintptr size.</span>
  <span>words</span> <span>:=</span> <span>size</span> <span>/</span> <span>wordBytes</span>

  <span>// Next, check if we have enough space left for this chunk. If</span>
  <span>// there isn&#39;t, we need to grow.</span>
  <span>if</span> <span>a</span><span>.</span><span>left</span> <span>&lt;</span> <span>words</span> <span>{</span>
    <span>// Pick whichever is largest: the minimum allocation size,</span>
    <span>// twice the last allocation, or the next power of two</span>
    <span>// after words.</span>
    <span>a</span><span>.</span><span>cap</span> <span>=</span> <span>max</span><span>(</span><span>minWords</span><span>,</span> <span>a</span><span>.</span><span>cap</span><span>*</span><span>2</span><span>,</span> <span>nextPow2</span><span>(</span><span>words</span><span>))</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>unsafe</span><span>.</span><span>SliceData</span><span>(</span><span>make</span><span>([]</span><span>uintptr</span><span>,</span> <span>a</span><span>.</span><span>cap</span><span>)))</span>
    <span>a</span><span>.</span><span>left</span> <span>=</span> <span>a</span><span>.</span><span>cap</span>
  <span>}</span>

  <span>// Allocate the chunk by incrementing the pointer.</span>
  <span>p</span> <span>:=</span> <span>a</span><span>.</span><span>next</span>
  <span>a</span><span>.</span><span>left</span> <span>-=</span> <span>words</span>
  <span>if</span> <span>a</span><span>.</span><span>left</span> <span>&gt;</span> <span>0</span> <span>{</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>unsafe</span><span>.</span><span>Add</span><span>(</span><span>a</span><span>.</span><span>next</span><span>,</span> <span>size</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// Beware, offsetting to one-past-the-end is one of the few</span>
    <span>// things explicitly not allowed by Go.</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>nil</span>
  <span>}</span>

  <span>return</span> <span>p</span>
<span>}</span>

<span>// nextPow2 returns the smallest power of two greater than n.</span>
<span>func</span> <span>nextPow2</span><span>(</span><span>n</span> <span>uintptr</span><span>)</span> <span>uintptr</span> <span>{</span>
  <span>return</span> <span>uintptr</span><span>(</span><span>1</span><span>)</span> <span>&lt;&lt;</span> <span>bits</span><span>.</span><span>Len</span><span>(</span><span>uint</span><span>(</span><span>n</span><span>))</span>
<span>}</span></code></pre></figure></div> <p>How fast is this really? Here’s a simple benchmark for it.</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>BenchmarkArena</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span>
  <span>bench</span><span>[</span><span>int</span><span>](</span><span>b</span><span>)</span>
  <span>bench</span><span>[[</span><span>2</span><span>]</span><span>int</span><span>](</span><span>b</span><span>)</span>
  <span>bench</span><span>[[</span><span>64</span><span>]</span><span>int</span><span>](</span><span>b</span><span>)</span>
  <span>bench</span><span>[[</span><span>1024</span><span>]</span><span>int</span><span>](</span><span>b</span><span>)</span>
<span>}</span>

<span>const</span> <span>runs</span> <span>=</span> <span>100000</span>

<span>var</span> <span>sink</span> <span>any</span>

<span>func</span> <span>bench</span><span>[</span><span>T</span> <span>any</span><span>](</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span>
  <span>var</span> <span>z</span> <span>T</span>
  <span>n</span> <span>:=</span> <span>int64</span><span>(</span><span>runs</span> <span>*</span> <span>unsafe</span><span>.</span><span>Sizeof</span><span>(</span><span>z</span><span>))</span>
  <span>name</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;%v&#34;</span><span>,</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>T</span><span>]())</span>

  <span>b</span><span>.</span><span>Run</span><span>(</span><span>name</span><span>,</span> <span>func</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span>
    <span>b</span><span>.</span><span>Run</span><span>(</span><span>&#34;arena&#34;</span><span>,</span> <span>func</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span>
      <span>b</span><span>.</span><span>SetBytes</span><span>(</span><span>n</span><span>)</span>
      <span>for</span> <span>b</span><span>.</span><span>Loop</span><span>()</span> <span>{</span>
        <span>a</span> <span>:=</span> <span>new</span><span>(</span><span>arena</span><span>.</span><span>Arena</span><span>)</span>
        <span>for</span> <span>range</span> <span>runs</span> <span>{</span>
          <span>sink</span> <span>=</span> <span>arena</span><span>.</span><span>New</span><span>[</span><span>T</span><span>](</span><span>a</span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>})</span>

    <span>b</span><span>.</span><span>Run</span><span>(</span><span>&#34;new&#34;</span><span>,</span> <span>func</span><span>(</span><span>b</span> <span>*</span><span>testing</span><span>.</span><span>B</span><span>)</span> <span>{</span>
      <span>b</span><span>.</span><span>SetBytes</span><span>(</span><span>n</span><span>)</span>
      <span>for</span> <span>b</span><span>.</span><span>Loop</span><span>()</span> <span>{</span>
        <span>for</span> <span>range</span> <span>runs</span> <span>{</span>
          <span>sink</span> <span>=</span> <span>new</span><span>(</span><span>T</span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>})</span>
  <span>})</span>
<span>}</span></code></pre></figure></div> <p>The focus of this benchmark is to measure the cost of allocating many objects of the same size. The number of times the <code>for b.Loop()</code> loop will execute is unknown, and determined by the benchmarking framework to try to reduce statistical anomaly. This means that if we instead just benchmark a single allocation, the result will be <em>very</em> sensitive to the number of runs.</p> <p>We also use <code>b.SetBytes</code> to get a throughput measurement on the benchmark. This is a bit easier to interpret than the gross <code>ns/op</code>, the benchmark would otherwise produce. It tells us how much memory each allocator can allocate per unit time.</p> <p>We want to compare against <code>new</code>, but just writing <code>_ = new(T)</code> will get optimized out, since the resulting pointer does not escape. Writing it to a global is sufficient to convince Go that it escapes.</p> <p>Here’s the results, abbreviated to show only the bytes per second. All benchmarks were performed on my AMD Ryzen Threadripper 3960X. Larger is better.</p> <div><figure><pre><code data-lang="console"><span>BenchmarkArena/int/arena-48         794.84 MB/s
BenchmarkArena/int/new-48           390.59 MB/s
BenchmarkArena/[2]int/arena-48      1263.58 MB/s
BenchmarkArena/[2]int/new-48        528.06 MB/s
BenchmarkArena/[64]int/arena-48     7370.08 MB/s
BenchmarkArena/[64]int/new-48       2865.24 MB/s
BenchmarkArena/[1024]int/arena-48   9889.20 MB/s
BenchmarkArena/[1024]int/new-48     2875.75 MB/s</span></code></pre></figure></div> <p>This is quite nice, and certainly worth pursuing! The performance increase seems to scale up with the amount of memory allocated, for a 2x-4x improvement across different cases.</p> <p>Now we need to contend with the fact that our implementation is completely broken if we want to have pointers in it.</p> <h3 id="not-dropping-memory-on-the-ground"><a href="#not-dropping-memory-on-the-ground">Not Dropping Memory on the Ground</a></h3> <p>In <code>(*Arena).Alloc</code>, when we assign a freshly-allocated chunk, we overwrite <code>a.next</code>, which means the GC can reclaim it. But this is fine: as long as pointers into that arena chunk are alive, the GC will not free it, independent of the arena. So it seems like we don’t need to worry about it?</p> <p>However, the whole point of an arena is to allocate lots of memory that has the same lifetime. This is common for graph data structures, such as an AST or a compiler IR, which performs a lot of work that allocates a lot and then throws the result away.</p> <p>We are not allowed to put pointers in the arena, because they would disappear from the view of the GC and become freed too soon. But, if a pointer wants to go on an arena, it necessarily outlive the whole arena, since it outlives part of the arena, and the arena is meant to have the same lifetime.</p> <p>In particular, if we could make it so that holding any pointer returned by <code>Alloc</code> prevents the <em>entire arena</em> from being swept by the GC, the arena can safely contain pointers into itself! Consider this:</p> <ol> <li> <p>We have a pointer <code>p **int</code>. It is allocated on some arena <code>a</code>.</p> </li> <li> <p>The GC sees our pointer (as a type-erased <code>unsafe.Pointer</code>) and marks its allocation as live.</p> </li> <li> <p>Somehow, the GC also marks <code>a</code> as alive as a consequence.</p> </li> <li> <p>Somehow, the GC then marks every chunk <code>a</code> has allocated as alive.</p> </li> <li> <p>Therefore he chunk that <code>*p</code> points to is also alive, so <code>*p</code> does not need to be marked directly, and will not be freed early.</p> </li> </ol> <p>The step (3) is crucial. By forcing the whole arena to be marked, any pointers stored in the arena into itself will be kept alive automatically, without the GC needing to know how to scan for them.</p> <p>So, even though <code>*New[*int](a) = new(int)</code> is still going to result in a use-after-free, <code>*New[*int](a) = New[int](a)</code> would not! This small improvement does not make arenas themselves safe, but a data structure with an internal arena can be completely safe, so long as the only pointers that go into the arena are from the arena itself.</p> <p>How can we make this work? The easy part is (4), which we can implement by adding a <code>[]unsafe.Pointer</code> to the arena, and sticking every pointer we allocate into it.</p> <div><figure><pre><code data-lang="go"><span>type</span> <span>Arena</span> <span>struct</span> <span>{</span>
  <span>next</span>      <span>unsafe</span><span>.</span><span>Pointer</span>
  <span>left</span><span>,</span> <span>cap</span> <span>uintptr</span>

  <span>chunks</span> <span>[]</span><span>unsafe</span><span>.</span><span>Pointer</span>  <span>// New field.</span>
<span>}</span>

<span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
  <span>// ... snip ...</span>
  <span>if</span> <span>a</span><span>.</span><span>left</span> <span>&lt;</span> <span>words</span> <span>{</span>
    <span>// Pick whichever is largest: the minimum allocation size,</span>
    <span>// twice the last allocation, or the next power of two</span>
    <span>// after words.</span>
    <span>a</span><span>.</span><span>cap</span> <span>=</span> <span>max</span><span>(</span><span>minWords</span><span>,</span> <span>a</span><span>.</span><span>cap</span><span>*</span><span>2</span><span>,</span> <span>nextPow2</span><span>(</span><span>words</span><span>))</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>unsafe</span><span>.</span><span>SliceData</span><span>(</span><span>make</span><span>([]</span><span>uintptr</span><span>,</span> <span>a</span><span>.</span><span>cap</span><span>)))</span>
    <span>a</span><span>.</span><span>left</span> <span>=</span> <span>a</span><span>.</span><span>cap</span>
    <span>a</span><span>.</span><span>chunks</span> <span>=</span> <span>append</span><span>(</span><span>a</span><span>.</span><span>chunks</span><span>,</span> <span>a</span><span>.</span><span>next</span><span>)</span>
  <span>}</span>
  <span>// ... snip ...</span>
<span>}</span></code></pre></figure></div> <p>The cost of the <code>append</code> is amortized: to allocate <code>n</code> bytes, we wind up allocating an additional <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log \log n)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span>lo<span>g</span></span><span></span><span>lo<span>g</span></span><span></span><span>n</span><span>)</span></span></span></span></span> times. But what does this do to our benchmarks?</p> <div><figure><pre><code data-lang="console"><span>BenchmarkArena/int/arena-48         800.08 MB/s
BenchmarkArena/int/new-48           386.81 MB/s
BenchmarkArena/[2]int/arena-48      1236.00 MB/s
BenchmarkArena/[2]int/new-48        520.84 MB/s
BenchmarkArena/[64]int/arena-48     7999.71 MB/s
BenchmarkArena/[64]int/new-48       2706.68 MB/s
BenchmarkArena/[1024]int/arena-48   9998.00 MB/s
BenchmarkArena/[1024]int/new-48     2816.28 MB/s</span></code></pre></figure></div> <p>Seems pretty much the same, which is a good sign.</p> <h3 id="back-pointers"><a href="#back-pointers">Back Pointers</a></h3> <p>Now that the arena does not discard any allocated memory, we can focus on condition (3): making it so that if any pointer returned by <code>Alloc</code> is alive, then so is the whole arena.</p> <p>Here we can make use of an important property of how Go’s GC works: any pointer into an allocation will keep it alive, as well as <em>anything reachable from that pointer</em>. But the chunks we’re allocating are <code>[]uintptr</code>s, which will not be scanned. If there could <em>somehow</em> be a single pointer in this slice that was scanned, we would be able to stick the pointer <code>a *Arena</code> there, and so when anything that <code>Alloc</code> returns is scanned, it would cause <code>a</code> to be marked as alive.</p> <p>So far, we have been allocating <code>[N]uintptr</code> using <code>make([]T)</code>, but we would actually like to allocate <code>struct { A [N]uintptr; P unsafe.Pointer }</code>, where <code>N</code> is some dynamic value.</p> <p>In its infintie wisdom, the Go standard library actually gives us a dedicated mechanism to do this: <code>reflect.StructOf</code>. This can be used to construct arbitrary anonymous <code>struct</code> types at runtime, which we can then allocate on the heap.</p> <p>So, instead of calling <code>make</code>, we might call this function:</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>allocChunk</span><span>(</span><span>words</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
	<span>chunk</span> <span>:=</span> <span>reflect</span><span>.</span><span>New</span><span>(</span><span>reflect</span><span>.</span><span>StructOf</span><span>([]</span><span>reflect</span><span>.</span><span>StructField</span><span>{</span>
		<span>{</span>
			<span>Name</span><span>:</span> <span>&#34;X0&#34;</span><span>,</span>
			<span>Type</span><span>:</span> <span>reflect</span><span>.</span><span>ArrayOf</span><span>(</span><span>int</span><span>(</span><span>words</span><span>),</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>uintptr</span><span>]()),</span>
		<span>},</span>
		<span>{</span><span>Name</span><span>:</span> <span>&#34;X1&#34;</span><span>,</span> <span>Type</span><span>:</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>unsafe</span><span>.</span><span>Pointer</span><span>]()},</span>
	<span>}))</span><span>.</span><span>UnsafePointer</span><span>()</span>

  <span>// Offset to the end of the chunk, and write a to it.</span>
  <span>end</span> <span>:=</span> <span>unsafe</span><span>.</span><span>Add</span><span>(</span><span>chunk</span><span>,</span> <span>words</span> <span>*</span> <span>unsafe</span><span>.</span><span>Sizeof</span><span>(</span><span>uintptr</span><span>(</span><span>0</span><span>)))</span>
  <span>*</span><span>(</span><span>**</span><span>Arena</span><span>)(</span><span>end</span><span>)</span> <span>=</span> <span>a</span>

  <span>return</span> <span>chunk</span>
<span>}</span></code></pre></figure></div> <p>This appears to have a minor but noticeable effect on performance<sup id="fnref:type-cache" role="doc-noteref"><a href="#fn:type-cache" rel="footnote">6</a></sup>.</p> <div><figure><pre><code data-lang="console"><span>BenchmarkArena/int/arena-48         763.91 MB/s
BenchmarkArena/int/new-48           385.49 MB/s
BenchmarkArena/[2]int/arena-48      1174.00 MB/s
BenchmarkArena/[2]int/new-48        524.32 MB/s
BenchmarkArena/[64]int/arena-48     7563.54 MB/s
BenchmarkArena/[64]int/new-48       2649.63 MB/s
BenchmarkArena/[1024]int/arena-48   8668.02 MB/s
BenchmarkArena/[1024]int/new-48     2648.10 MB/s</span></code></pre></figure></div> <h2 id="more-optimizations"><a href="#more-optimizations">More Optimizations</a></h2> <p>Looking back at <code>Arena.Alloc</code>, the end of this function has a branch:</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
  <span>// ... snip...</span>

  <span>// Allocate the chunk by incrementing the pointer.</span>
  <span>p</span> <span>:=</span> <span>a</span><span>.</span><span>next</span>
  <span>a</span><span>.</span><span>left</span> <span>-=</span> <span>words</span>
  <span>if</span> <span>a</span><span>.</span><span>left</span> <span>&gt;</span> <span>0</span> <span>{</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>unsafe</span><span>.</span><span>Add</span><span>(</span><span>a</span><span>.</span><span>next</span><span>,</span> <span>size</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// Beware, offsetting to one-past-the-end is one of the few</span>
    <span>// things explicitly not allowed by Go.</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>nil</span>
  <span>}</span>

  <span>return</span> <span>p</span>
<span>}</span></code></pre></figure></div> <p>This is the absolute hottest part of allocation, since it is executed every time we call this function. The branch is a bit unfortunate, but it’s necessary, as noted by the comment.</p> <p>In C++, if we have an array of <code>int</code> with <code>n</code> elements in it, and <code>int* p</code> is a pointer to the start of the array, <code>p + n</code> is a valid pointer, even though it can’t be dereferenced; it points “one past the end” of the array. This is a useful construction, since, for example, you can use it to eliminate a loop induction variable:</p> <div><figure><pre><code data-lang="c++"><span>// Naive for loop, has an induction variable i.</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
  <span>do_something</span><span>(</span><span>p</span><span>[</span><span>i</span><span>]);</span>
<span>}</span>

<span>// Faster: avoids the extra variable increment in the loop</span>
<span>// body for doing p[i].</span>
<span>for</span> <span>(</span><span>auto</span> <span>end</span> <span>=</span> <span>p</span> <span>+</span> <span>n</span><span>;</span> <span>p</span> <span>&lt;</span> <span>end</span><span>;</span> <span>p</span><span>++</span><span>)</span> <span>{</span>
  <span>do_something</span><span>(</span><span>*</span><span>p</span><span>);</span>
<span>}</span></code></pre></figure></div> <p>Go, however, gets very upset if you do this, because it confuses the garbage collector. The GC can’t tell the difference between a one-past-the-end pointer for allocation A, and for the start of allocation B immediately after it. At best this causes memory to stay alive for longer, and at worst it triggers safety interlocks in the GC. The GC will panic if it happens to scan a pointer for an address that it knows has been freed.</p> <p>But in our code above, every chunk now has an extra element at the very end that is not used for allocation, so we <em>can</em> have a pointer that <em>is</em> one-past-the-end of the <code>[N]uintptr</code> that we are vending memory from.</p> <p>The updated allocation function would look like this:</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
  <span>// ... snip ...</span>

  <span>// Allocate the chunk by incrementing the pointer.</span>
  <span>p</span> <span>:=</span> <span>a</span><span>.</span><span>next</span>
  <span>a</span><span>.</span><span>next</span> <span>=</span> <span>unsafe</span><span>.</span><span>Add</span><span>(</span><span>a</span><span>.</span><span>next</span><span>,</span> <span>size</span><span>)</span>
  <span>a</span><span>.</span><span>left</span> <span>-=</span> <span>words</span>

  <span>return</span> <span>p</span>
<span>}</span></code></pre></figure></div> <p>Notably, we do not replace <code>a.left</code> with an end pointer, because of the <code>if a.left &lt; words</code> comparison. We can’t actually avoid the subtraction <code>a.left -= words</code> because we would have to do it to make this comparison work if we got rid of <code>a.left</code>.</p> <p>So how much better is this?</p> <div><figure><pre><code data-lang="console"><span>BenchmarkArena/int/arena-48         780.07 MB/s
BenchmarkArena/int/new-48           383.16 MB/s
BenchmarkArena/[2]int/arena-48      1245.73 MB/s
BenchmarkArena/[2]int/new-48        530.39 MB/s
BenchmarkArena/[64]int/arena-48     7684.39 MB/s
BenchmarkArena/[64]int/new-48       2679.94 MB/s
BenchmarkArena/[1024]int/arena-48   8859.99 MB/s
BenchmarkArena/[1024]int/new-48     2611.33 MB/s</span></code></pre></figure></div> <p>Remarkably, not very! This is an improvement on the order of magnitude of one or two percentage points. This is because the branch we deleted is extremely predictable.</p> <p>Turns out there’s a bigger improvement we can make.</p> <h3 id="write-barriers"><a href="#write-barriers">Write Barriers</a></h3> <p>Here’s the assembly Go generated for this function, heavily abridged, and annotated with the corresponding Go source code.</p> <div><figure><pre><code data-lang="llvm"><span>TEXT</span> <span>(*</span><span>Arena</span><span>).</span><span>Alloc</span><span>(</span><span>SB</span><span>)</span>
  <span>CMPQ</span>    <span>SP</span><span>,</span> <span>0x10</span><span>(</span><span>R14</span><span>)</span>
  <span>JBE</span>     <span>moreStack</span>  <span>; Stack growth prologue.</span>
  <span>PUSHQ</span>   <span>BP</span>
  <span>MOVQ</span>    <span>SP</span><span>,</span> <span>BP</span>
  <span>SUBQ</span>    <span>$</span><span>0x58</span><span>,</span> <span>SP</span>

  <span>; size = (size + mask) &amp;^ mask</span>
  <span>LEAQ</span>    <span>0x7</span><span>(</span><span>BX</span><span>),</span> <span>DX</span>
  <span>ANDQ</span>    <span>$</span><span>-0</span><span>x</span><span>8</span><span>,</span> <span>DX</span>
  <span>; words := size / wordBytes</span>
  <span>MOVQ</span>    <span>DX</span><span>,</span> <span>SI</span>
  <span>SHRQ</span>    <span>$</span><span>0x3</span><span>,</span> <span>DX</span>

  <span>; if a.left &lt; words</span>
  <span>CMPQ</span>    <span>0x8</span><span>(</span><span>AX</span><span>),</span> <span>DX</span>
  <span>JAE</span>     <span>alloc</span>

  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0x68</span><span>(</span><span>SP</span><span>)</span>
  <span>MOVQ</span>    <span>SI</span><span>,</span> <span>0x48</span><span>(</span><span>SP</span><span>)</span>
  <span>MOVQ</span>    <span>DX</span><span>,</span> <span>0x40</span><span>(</span><span>SP</span><span>)</span>

  <span>; nextPow2(words)</span>
  <span>MOVZX</span>   <span>runtime</span><span>.x</span><span>86</span><span>HasPOPCNT</span><span>(</span><span>SB</span><span>),</span> <span>DI</span>
  <span>TESTL</span>   <span>DI</span><span>,</span> <span>DI</span>
  <span>JE</span>      <span>1</span><span>f</span>
  <span>XORL</span>    <span>DI</span><span>,</span> <span>DI</span>
  <span>POPCNTQ</span> <span>DX</span><span>,</span> <span>DI</span>
  <span>JMP</span>     <span>2</span><span>f</span>
<span>1</span><span>:</span>
  <span>MOVQ</span>    <span>DX</span><span>,</span> <span>AX</span>
  <span>CALL</span>    <span>math/bits</span><span>.</span><span>OnesCount</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>0x40</span><span>(</span><span>SP</span><span>),</span> <span>DX</span>
  <span>MOVQ</span>    <span>0x48</span><span>(</span><span>SP</span><span>),</span> <span>SI</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>DI</span>
  <span>MOVQ</span>    <span>0x68</span><span>(</span><span>SP</span><span>),</span> <span>AX</span>
<span>2</span><span>:</span>
  <span>CMPQ</span>    <span>DI</span><span>,</span> <span>$</span><span>0x1</span>
  <span>JE</span>      <span>1</span><span>f</span>
  <span>BSRQ</span>    <span>DX</span><span>,</span> <span>CX</span>
  <span>MOVQ</span>    <span>$</span><span>-0</span><span>x</span><span>1</span><span>,</span> <span>DI</span>
  <span>CMOVE</span>   <span>DI</span><span>,</span> <span>CX</span>
  <span>INCQ</span>    <span>CX</span>
  <span>MOVL</span>    <span>$</span><span>0x1</span><span>,</span> <span>DI</span>
  <span>SHLQ</span>    <span>CL</span><span>,</span> <span>DI</span>
  <span>CMPQ</span>    <span>CX</span><span>,</span> <span>$</span><span>0x40</span>
  <span>SBBQ</span>    <span>R8</span><span>,</span> <span>R8</span>
  <span>ANDQ</span>    <span>R8</span><span>,</span> <span>DI</span>
  <span>MOVQ</span>    <span>DI</span><span>,</span> <span>DX</span>
<span>1</span><span>:</span>
  <span>MOVQ</span>    <span>0x10</span><span>(</span><span>AX</span><span>),</span> <span>CX</span>
  <span>SHLQ</span>    <span>$</span><span>0x1</span><span>,</span> <span>CX</span>

  <span>; a.cap = max(minWords, a.cap*2, nextPow2(words))</span>
  <span>CMPQ</span>    <span>CX</span><span>,</span> <span>$</span><span>0x8</span>
  <span>MOVL</span>    <span>$</span><span>0x8</span><span>,</span> <span>BX</span>
  <span>CMOVA</span>   <span>CX</span><span>,</span> <span>BX</span>
  <span>CMPQ</span>    <span>DX</span><span>,</span> <span>BX</span>
  <span>CMOVA</span>   <span>DX</span><span>,</span> <span>BX</span>
  <span>MOVQ</span>    <span>BX</span><span>,</span> <span>0x10</span><span>(</span><span>AX</span><span>)</span>

  <span>; a.next = a.allocChunk(a.cap)</span>
  <span>CALL</span>    <span>github</span><span>.</span><span>com/mcy/go-arena</span><span>.(*</span><span>Arena</span><span>).</span><span>allocChunk</span><span>(</span><span>SB</span><span>)</span>
  <span>CMPL</span>    <span>runtime</span><span>.</span><span>writeBarrier</span><span>(</span><span>SB</span><span>),</span> <span>$</span><span>0x0</span>
  <span>JNE</span>     <span>1</span><span>f</span>
  <span>MOVQ</span>    <span>0x68</span><span>(</span><span>SP</span><span>),</span> <span>DX</span>
  <span>JMP</span>     <span>2</span><span>f</span>
<span>1</span><span>:</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>gcWriteBarrier2</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0</span><span>(</span><span>R11</span><span>)</span>
  <span>MOVQ</span>    <span>0x68</span><span>(</span><span>SP</span><span>),</span> <span>DX</span>
  <span>MOVQ</span>    <span>0</span><span>(</span><span>DX</span><span>),</span> <span>R8</span>
  <span>MOVQ</span>    <span>R8</span><span>,</span> <span>0x8</span><span>(</span><span>R11</span><span>)</span>
<span>2</span><span>:</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0</span><span>(</span><span>DX</span><span>)</span>

  <span>; a.left = a.cap</span>
  <span>MOVQ</span>    <span>0x10</span><span>(</span><span>DX</span><span>),</span> <span>R8</span>
  <span>MOVQ</span>    <span>R8</span><span>,</span> <span>0x8</span><span>(</span><span>DX</span><span>)</span>
  <span>MOVQ</span>    <span>0x28</span><span>(</span><span>DX</span><span>),</span> <span>CX</span>
  <span>MOVQ</span>    <span>0x20</span><span>(</span><span>DX</span><span>),</span> <span>BX</span>
  <span>INCQ</span>    <span>BX</span>
  <span>MOVQ</span>    <span>0x18</span><span>(</span><span>DX</span><span>),</span> <span>R8</span>
  <span>CMPQ</span>    <span>CX</span><span>,</span> <span>BX</span>
  <span>JAE</span>     <span>2</span><span>f</span>

  <span>; a.chunks = append(a.chunks, a.next)</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0x50</span><span>(</span><span>SP</span><span>)</span>
  <span>MOVQ</span>    <span>R8</span><span>,</span> <span>AX</span>
  <span>MOVL</span>    <span>$</span><span>0x1</span><span>,</span> <span>DI</span>
  <span>LEAQ</span>    <span>0x28f70</span><span>(</span><span>IP</span><span>),</span> <span>SI</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>growslice</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>0x68</span><span>(</span><span>SP</span><span>),</span> <span>DX</span>
  <span>MOVQ</span>    <span>CX</span><span>,</span> <span>0x28</span><span>(</span><span>DX</span><span>)</span>
  <span>CMPL</span>    <span>runtime</span><span>.</span><span>writeBarrier</span><span>(</span><span>SB</span><span>),</span> <span>$</span><span>0x0</span>
  <span>JE</span>      <span>1</span><span>f</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>gcWriteBarrier2</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0</span><span>(</span><span>R11</span><span>)</span>
  <span>MOVQ</span>    <span>0x18</span><span>(</span><span>DX</span><span>),</span> <span>CX</span>
  <span>MOVQ</span>    <span>CX</span><span>,</span> <span>0x8</span><span>(</span><span>R11</span><span>)</span>
<span>1</span><span>:</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0x18</span><span>(</span><span>DX</span><span>)</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>R8</span>
  <span>MOVQ</span>    <span>0x50</span><span>(</span><span>SP</span><span>),</span> <span>AX</span>
<span>2</span><span>:</span>
  <span>MOVQ</span>    <span>BX</span><span>,</span> <span>0x20</span><span>(</span><span>DX</span><span>)</span>
  <span>CMPL</span>    <span>runtime</span><span>.</span><span>writeBarrier</span><span>(</span><span>SB</span><span>),</span> <span>$</span><span>0x0</span>
  <span>JE</span>      <span>1</span><span>f</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>gcWriteBarrier2</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>0</span><span>(</span><span>R11</span><span>)</span>
  <span>MOVQ</span>    <span>-0</span><span>x</span><span>8</span><span>(</span><span>R8</span><span>)(</span><span>BX</span><span>*</span><span>8</span><span>),</span> <span>CX</span>
  <span>MOVQ</span>    <span>CX</span><span>,</span> <span>0x8</span><span>(</span><span>R11</span><span>)</span>
<span>1</span><span>:</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>-0</span><span>x</span><span>8</span><span>(</span><span>R8</span><span>)(</span><span>BX</span><span>*</span><span>8</span><span>)</span>
  <span>MOVQ</span>    <span>DX</span><span>,</span> <span>AX</span>
  <span>MOVQ</span>    <span>0x40</span><span>(</span><span>SP</span><span>),</span> <span>DX</span>
  <span>MOVQ</span>    <span>0x48</span><span>(</span><span>SP</span><span>),</span> <span>SI</span>

<span>alloc:</span>
  <span>; p := a.next</span>
  <span>MOVQ</span>    <span>0</span><span>(</span><span>AX</span><span>),</span> <span>CX</span>

  <span>; a.next = unsafe.Add(a.next, size)</span>
  <span>LEAQ</span>    <span>0</span><span>(</span><span>CX</span><span>)(</span><span>SI</span><span>*</span><span>1</span><span>),</span> <span>BX</span>
  <span>CMPL</span>    <span>runtime</span><span>.</span><span>writeBarrier</span><span>(</span><span>SB</span><span>),</span> <span>$</span><span>0x0</span>
  <span>JE</span>      <span>1</span><span>f</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>gcWriteBarrier2</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>BX</span><span>,</span> <span>0</span><span>(</span><span>R11</span><span>)</span>
  <span>MOVQ</span>    <span>0</span><span>(</span><span>AX</span><span>),</span> <span>SI</span>
  <span>MOVQ</span>    <span>SI</span><span>,</span> <span>0x8</span><span>(</span><span>R11</span><span>)</span>
<span>1</span><span>:</span>
  <span>MOVQ</span>    <span>BX</span><span>,</span> <span>0</span><span>(</span><span>AX</span><span>)</span>

  <span>; a.left -= words</span>
  <span>LEAQ</span>    <span>0</span><span>(</span><span>CX</span><span>)(</span><span>SI</span><span>*</span><span>1</span><span>),</span> <span>BX</span>
  <span>SUBQ</span>    <span>DX</span><span>,</span> <span>0x8</span><span>(</span><span>AX</span><span>)</span>

  <span>; return p</span>
  <span>MOVQ</span>    <span>CX</span><span>,</span> <span>AX</span>
  <span>ADDQ</span>    <span>$</span><span>0x58</span><span>,</span> <span>SP</span>
  <span>POPQ</span>    <span>BP</span>
  <span>RET</span></code></pre></figure></div> <p>There’s a lot going on in this function, but most of it is a mix of Go not being great at register allocation, and lots of <em>write barriers</em>.</p> <p>A write barrier is a mechanism for synchronizing ordinary user code with the GC. Go generates code for one any time a non-pointer-free type is stored. For example, writing to a <code>**int</code>, <code>*string</code>, or <code>*[]int</code> requires a write barrier.</p> <p>Write barriers are implemented as follows:</p> <ol> <li> <p><code>runtime.writeBarrier</code> is checked, which determines whether the write barrier is necessary, which is only when the GC is in the mark phase. Otherwise the branch is taken to skip the write barrier.</p> </li> <li> <p>A call to one of the <code>runtime.gcWriteBarrierN</code> functions happens. <code>N</code> is the number of pointers that the GC needs to be informed of.</p> </li> <li> <p>This function calls <code>runtime.gcWriteBarrier</code>, which returns a buffer onto which pointers the GC needs to now trace through should be written to.</p> </li> <li> <p>The actual store happens.</p> </li> </ol> <p>A write barrier is required for a case like the following. Consider the following code.</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>alloc</span><span>(</span><span>n</span> <span>**</span><span>int</span><span>)</span> <span>{</span>
  <span>*</span><span>n</span> <span>=</span> <span>new</span><span>(</span><span>int</span><span>)</span>
<span>}</span></code></pre></figure></div> <p>This function will call <code>runtime.newobject</code> to allocate eight bytes of memory. The resulting pointer will be returned in <code>rax</code>. This function then stores <code>rax</code> into <code>n</code> and returns. If we Godbolt this function, we’ll find that it does, in fact, generate a write barrier:</p> <div><figure><pre><code data-lang="llvm"><span>TEXT</span> <span>x.</span><span>alloc</span>
  <span>CMPQ</span>    <span>SP</span><span>,</span> <span>16</span><span>(</span><span>R14</span><span>)</span>
  <span>JLS</span>     <span>growStack</span>
  <span>PUSHQ</span>   <span>BP</span>
  <span>MOVQ</span>    <span>SP</span><span>,</span> <span>BP</span>
  <span>SUBQ</span>    <span>$</span><span>16</span><span>,</span> <span>SP</span>

  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>main</span><span>.</span><span>n+</span><span>32</span><span>(</span><span>SP</span><span>)</span>

  <span>; new(int)</span>
  <span>LEAQ</span>    <span>type:</span><span>int</span><span>(</span><span>SB</span><span>),</span> <span>AX</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>newobject</span><span>(</span><span>SB</span><span>)</span>

  <span>MOVQ</span>    <span>main</span><span>.</span><span>n+</span><span>32</span><span>(</span><span>SP</span><span>),</span> <span>CX</span>
  <span>TESTB</span>   <span>AL</span><span>,</span> <span>(</span><span>CX</span><span>)</span>

  <span>; This is the write barrier.</span>
  <span>CMPL</span>    <span>runtime</span><span>.</span><span>writeBarrier</span><span>(</span><span>SB</span><span>),</span> <span>$</span><span>0</span>
  <span>JEQ</span>     <span>skip</span>
  <span>MOVQ</span>    <span>(</span><span>CX</span><span>),</span> <span>DX</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>gcWriteBarrier2</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>(</span><span>R11</span><span>)</span>
  <span>MOVQ</span>    <span>DX</span><span>,</span> <span>8</span><span>(</span><span>R11</span><span>)</span>

<span>skip:</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>(</span><span>CX</span><span>)</span>
  <span>PCDATA</span>  <span>$</span><span>0</span><span>,</span> <span>$</span><span>-1</span>
  <span>ADDQ</span>    <span>$</span><span>16</span><span>,</span> <span>SP</span>
  <span>POPQ</span>    <span>BP</span>
  <span>RET</span>

<span>growStack:</span>
  <span>NOP</span>
  <span>MOVQ</span>    <span>AX</span><span>,</span> <span>8</span><span>(</span><span>SP</span><span>)</span>
  <span>CALL</span>    <span>runtime</span><span>.</span><span>morestack_noctxt</span><span>(</span><span>SB</span><span>)</span>
  <span>MOVQ</span>    <span>8</span><span>(</span><span>SP</span><span>),</span> <span>AX</span>
  <span>JMP</span>     <span>x.</span><span>alloc</span></code></pre></figure></div> <p>Note that two pointers get written: the pointer returned by <code>new(int)</code>, and the old value of <code>*n</code>. This ensures that regardless of where in this function the GC happens to be scanning through <code>*n</code>, it sees both values during the mark phase.</p> <p>Now, this isn’t necessary if the relevant pointers are already reachable in some other way… which is exactly the case in our arena (thanks to the <code>chunks</code> slice). So the write barrier in the fast path is redundant.</p> <p>But, how do we get rid of it? There is a <code>//go:nowritebarrier</code>, but that’s not allowed outside of a list of packages allowlisted in the compiler. It also doens’t disable write barriers; it simply generates a diagnostic if any are emitted.</p> <p>But remember, write barriers only occur when storing pointer-typed memory… so we can just replace <code>next unsafe.Pointer</code> with <code>next uintptr</code>.</p> <div><figure><pre><code data-lang="go"><span>type</span> <span>Arena</span> <span>struct</span> <span>{</span>
  <span>next</span>      <span>uintptr</span> <span>// A real pointer!</span>
  <span>left</span><span>,</span> <span>cap</span> <span>uintptr</span>

  <span>chunks</span> <span>[]</span><span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span>

<span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
  <span>mask</span> <span>:=</span> <span>wordBytes</span> <span>-</span> <span>1</span>
  <span>size</span> <span>=</span> <span>(</span><span>size</span> <span>+</span> <span>mask</span><span>)</span> <span>&amp;^</span> <span>mask</span>
  <span>words</span> <span>:=</span> <span>size</span> <span>/</span> <span>wordBytes</span>

  <span>if</span> <span>a</span><span>.</span><span>left</span> <span>&lt;</span> <span>words</span> <span>{</span>
    <span>a</span><span>.</span><span>cap</span> <span>=</span> <span>max</span><span>(</span><span>minWords</span><span>,</span> <span>a</span><span>.</span><span>cap</span><span>*</span><span>2</span><span>,</span> <span>nextPow2</span><span>(</span><span>words</span><span>))</span>

    <span>p</span> <span>:=</span> <span>a</span><span>.</span><span>allocChunk</span><span>(</span><span>a</span><span>.</span><span>cap</span><span>)</span>
    <span>a</span><span>.</span><span>next</span> <span>=</span> <span>uintptr</span><span>(</span><span>p</span><span>)</span>
    <span>a</span><span>.</span><span>left</span> <span>=</span> <span>a</span><span>.</span><span>cap</span>
    <span>a</span><span>.</span><span>chunks</span> <span>=</span> <span>append</span><span>(</span><span>a</span><span>.</span><span>chunks</span><span>,</span> <span>p</span><span>)</span>
  <span>}</span>

  <span>p</span> <span>:=</span> <span>a</span><span>.</span><span>next</span>
  <span>a</span><span>.</span><span>next</span> <span>+=</span> <span>size</span>
  <span>a</span><span>.</span><span>left</span> <span>-=</span> <span>words</span>

  <span>return</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>p</span><span>)</span>
<span>}</span></code></pre></figure></div> <p><code>go vet</code> hates this, because it doesn’t know that we’re smarter than it is. Does This make the code faster? To make it a little bit more realistic, I’ve written a separate variant of the benchmarks that hammers the GC really hard in a separate G:</p> <div><figure><pre><code data-lang="go"><span>go</span> <span>func</span><span>()</span> <span>{</span>
  <span>for</span> <span>{</span> <span>runtime</span><span>.</span><span>GC</span><span>()</span> <span>}</span>
<span>}()</span></code></pre></figure></div> <p>The result indicates that this is a worthwhile optimization for churn-heavy contexts. Performance is much worse overall, but that’s because the GC is pre-empting everyone. The improvement seems to be on the order of 20% for very small allocations.</p> <div><figure><pre><code data-lang="console"><span>#</span><span> </span>Before
<span>BenchmarkArena/int/arena-48         169.09 MB/s
BenchmarkArena/int/new-48           84.73 MB/s
BenchmarkArena/[2]int/arena-48      309.40 MB/s
BenchmarkArena/[2]int/new-48        120.23 MB/s
BenchmarkArena/[64]int/arena-48     1954.16 MB/s
BenchmarkArena/[64]int/new-48       950.48 MB/s
BenchmarkArena/[1024]int/arena-48   3341.13 MB/s
BenchmarkArena/[1024]int/new-48     1413.26 MB/s

</span><span>#</span><span> </span>After
<span>BenchmarkArena/int/arena-48         195.58 MB/s
BenchmarkArena/int/new-48           83.67 MB/s
BenchmarkArena/[2]int/arena-48      352.49 MB/s
BenchmarkArena/[2]int/new-48        120.13 MB/s
BenchmarkArena/[64]int/arena-48     1987.22 MB/s
BenchmarkArena/[64]int/new-48       903.78 MB/s
BenchmarkArena/[1024]int/arena-48   3342.67 MB/s
BenchmarkArena/[1024]int/new-48     1439.99 MB/s</span></code></pre></figure></div> <h3 id="realloc"><a href="#realloc">Realloc</a></h3> <p>Go does not offer an easy mechanism to “reallocate” an allocation, as with <code>realloc()</code> in C. This is because it has no mechanism for freeing pointers explicitly, which is necessary for a reallocation abstraction.</p> <p>But we already don’t care about safety, so we can offer reallocation on our arena. Now, the reallocation we can offer is quite primitive: if a chunk happens to be the most recent one allocated, we can grow it. Otherwise we just allocate a new chunk and don’t free the old one.</p> <p>This makes it possible to implement “arena slices” that can be constructed by appending, which will not trigger reallocation on slice growth as long as nothing else gets put on the arena.</p> <p><code>Realloc</code> would look something like this:</p> <div><figure><pre><code data-lang="go"><span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Realloc</span><span>(</span>
  <span>ptr</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>,</span>
  <span>oldSize</span><span>,</span> <span>newSize</span><span>,</span> <span>align</span> <span>uintptr</span><span>,</span>
<span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
  <span>mask</span> <span>:=</span> <span>wordBytes</span> <span>-</span> <span>1</span>
  <span>oldSize</span> <span>=</span> <span>(</span><span>oldSize</span> <span>+</span> <span>mask</span><span>)</span> <span>&amp;^</span> <span>mask</span>
  <span>newSize</span> <span>=</span> <span>(</span><span>newSize</span> <span>+</span> <span>mask</span><span>)</span> <span>&amp;^</span> <span>mask</span>

  <span>if</span> <span>newSize</span> <span>&lt;=</span> <span>oldSize</span> <span>{</span>
    <span>return</span> <span>ptr</span>
  <span>}</span>

  <span>// Check if this is the most recent allocation. If it is,</span>
  <span>// we can grow in-place.</span>
  <span>if</span> <span>a</span><span>.</span><span>next</span> <span>-</span> <span>oldSize</span> <span>==</span> <span>uintptr</span><span>(</span><span>ptr</span><span>)</span> <span>{</span>
    <span>// Check if we have enough space available for the</span>
    <span>// requisite extra space.</span>
    <span>need</span> <span>:=</span> <span>(</span><span>newSize</span> <span>-</span> <span>oldSize</span><span>)</span> <span>/</span> <span>wordBytes</span>
    <span>if</span> <span>a</span><span>.</span><span>left</span> <span>&gt;=</span> <span>need</span> <span>{</span>
      <span>// Grow in-place.</span>
      <span>a</span><span>.</span><span>left</span> <span>-=</span> <span>need</span>
      <span>return</span> <span>ptr</span>
    <span>}</span>
  <span>}</span>

  <span>// Can&#39;t grow in place, allocate new memory and copy to it.</span>
  <span>new</span> <span>:=</span> <span>a</span><span>.</span><span>Alloc</span><span>(</span><span>newSize</span><span>,</span> <span>align</span><span>)</span>
  <span>copy</span><span>(</span>
    <span>unsafe</span><span>.</span><span>Slice</span><span>((</span><span>*</span><span>byte</span><span>)(</span><span>new</span><span>),</span> <span>newSize</span><span>),</span>
    <span>unsafe</span><span>.</span><span>Slice</span><span>((</span><span>*</span><span>byte</span><span>)(</span><span>ptr</span><span>),</span> <span>oldSize</span><span>),</span>
  <span>)</span>

  <span>return</span> <span>new</span>
<span>}</span></code></pre></figure></div> <p>Then, whenever we append to our arena slice, we can call <code>a.Realloc()</code> to grow it. However, this does not work if the slice’s base pointer is not the original address returned by <code>Alloc</code> or <code>Realloc</code>. It is an exercise for the reader to:</p> <ol> <li> <p>Implement a <code>Slice[T]</code> type that uses an arena for allocation.</p> </li> <li> <p>Make this work for any value of <code>ptr</code> within the most recent allocation, not just the base offset. This requires extra book-keeping.</p> </li> </ol> <h2 id="all-together"><a href="#all-together">All Together</a></h2> <p>Here is the entirety of the code that we have developed, not including the reallocation function above.</p> <div><figure><pre><code data-lang="go"><span>package</span> <span>arena</span>

<span>import</span> <span>(</span>
	<span>&#34;math/bits&#34;</span>
	<span>&#34;reflect&#34;</span>
	<span>&#34;unsafe&#34;</span>
<span>)</span>

<span>func</span> <span>New</span><span>[</span><span>T</span> <span>any</span><span>](</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>*</span><span>T</span> <span>{</span>
	<span>var</span> <span>t</span> <span>T</span>
	<span>p</span> <span>:=</span> <span>a</span><span>.</span><span>Alloc</span><span>(</span><span>unsafe</span><span>.</span><span>Sizeof</span><span>(</span><span>t</span><span>),</span> <span>unsafe</span><span>.</span><span>Alignof</span><span>(</span><span>t</span><span>))</span>
	<span>return</span> <span>(</span><span>*</span><span>T</span><span>)(</span><span>p</span><span>)</span>
<span>}</span>

<span>type</span> <span>Arena</span> <span>struct</span> <span>{</span>
	<span>next</span>      <span>unsafe</span><span>.</span><span>Pointer</span>
	<span>left</span><span>,</span> <span>cap</span> <span>uintptr</span>
	<span>chunks</span>    <span>[]</span><span>unsafe</span><span>.</span><span>Pointer</span>
<span>}</span>

<span>const</span> <span>(</span>
	<span>maxAlign</span> <span>uintptr</span> <span>=</span> <span>8</span> <span>// Depends on target, this is for 64-bit.</span>
	<span>minWords</span> <span>uintptr</span> <span>=</span> <span>8</span>
<span>)</span>

<span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>Alloc</span><span>(</span><span>size</span><span>,</span> <span>align</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
	<span>// First, round the size up to the alignment of every object in the arena.</span>
	<span>mask</span> <span>:=</span> <span>maxAlign</span> <span>-</span> <span>1</span>
	<span>size</span> <span>=</span> <span>(</span><span>size</span> <span>+</span> <span>mask</span><span>)</span> <span>&amp;^</span> <span>mask</span>
	<span>// Then, replace the size with the size in pointer-sized words. This does not</span>
	<span>// result in any loss of size, since size is now a multiple of the uintptr</span>
	<span>// size.</span>
	<span>words</span> <span>:=</span> <span>size</span> <span>/</span> <span>maxAlign</span>

	<span>// Next, check if we have enough space left for this chunk. If there isn&#39;t,</span>
	<span>// we need to grow.</span>
	<span>if</span> <span>a</span><span>.</span><span>left</span> <span>&lt;</span> <span>words</span> <span>{</span>
		<span>// Pick whichever is largest: the minimum allocation size, twice the last</span>
		<span>// allocation, or the next power of two after words.</span>
		<span>a</span><span>.</span><span>cap</span> <span>=</span> <span>max</span><span>(</span><span>minWords</span><span>,</span> <span>a</span><span>.</span><span>cap</span><span>*</span><span>2</span><span>,</span> <span>nextPow2</span><span>(</span><span>words</span><span>))</span>
		<span>a</span><span>.</span><span>next</span> <span>=</span> <span>a</span><span>.</span><span>allocChunk</span><span>(</span><span>a</span><span>.</span><span>cap</span><span>)</span>
		<span>a</span><span>.</span><span>left</span> <span>=</span> <span>a</span><span>.</span><span>cap</span>

		<span>a</span><span>.</span><span>chunks</span> <span>=</span> <span>append</span><span>(</span><span>a</span><span>.</span><span>chunks</span><span>,</span> <span>a</span><span>.</span><span>next</span><span>)</span>
	<span>}</span>

	<span>// Allocate the chunk by incrementing the pointer.</span>
	<span>p</span> <span>:=</span> <span>a</span><span>.</span><span>next</span>
	<span>a</span><span>.</span><span>next</span> <span>=</span> <span>unsafe</span><span>.</span><span>Add</span><span>(</span><span>a</span><span>.</span><span>next</span><span>,</span> <span>size</span><span>)</span>
	<span>a</span><span>.</span><span>left</span> <span>-=</span> <span>words</span>

	<span>return</span> <span>p</span>
<span>}</span>

<span>func</span> <span>(</span><span>a</span> <span>*</span><span>Arena</span><span>)</span> <span>allocChunk</span><span>(</span><span>words</span> <span>uintptr</span><span>)</span> <span>unsafe</span><span>.</span><span>Pointer</span> <span>{</span>
	<span>chunk</span> <span>:=</span> <span>reflect</span><span>.</span><span>New</span><span>(</span><span>reflect</span><span>.</span><span>StructOf</span><span>([]</span><span>reflect</span><span>.</span><span>StructField</span><span>{</span>
		<span>{</span>
			<span>Name</span><span>:</span> <span>&#34;X0&#34;</span><span>,</span>
			<span>Type</span><span>:</span> <span>reflect</span><span>.</span><span>ArrayOf</span><span>(</span><span>int</span><span>(</span><span>words</span><span>),</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>uintptr</span><span>]()),</span>
		<span>},</span>
		<span>{</span><span>Name</span><span>:</span> <span>&#34;X1&#34;</span><span>,</span> <span>Type</span><span>:</span> <span>reflect</span><span>.</span><span>TypeFor</span><span>[</span><span>unsafe</span><span>.</span><span>Pointer</span><span>]()},</span>
	<span>}))</span><span>.</span><span>UnsafePointer</span><span>()</span>

	<span>// Offset to the end of the chunk, and write a to it.</span>
	<span>end</span> <span>:=</span> <span>unsafe</span><span>.</span><span>Add</span><span>(</span><span>chunk</span><span>,</span> <span>words</span><span>*</span><span>unsafe</span><span>.</span><span>Sizeof</span><span>(</span><span>uintptr</span><span>(</span><span>0</span><span>)))</span>
	<span>*</span><span>(</span><span>**</span><span>Arena</span><span>)(</span><span>end</span><span>)</span> <span>=</span> <span>a</span>

	<span>return</span> <span>chunk</span>
<span>}</span>

<span>func</span> <span>nextPow2</span><span>(</span><span>n</span> <span>uintptr</span><span>)</span> <span>uintptr</span> <span>{</span>
	<span>return</span> <span>uintptr</span><span>(</span><span>1</span><span>)</span> <span>&lt;&lt;</span> <span>bits</span><span>.</span><span>Len</span><span>(</span><span>uint</span><span>(</span><span>n</span><span>))</span>
<span>}</span></code></pre></figure></div> <p>There are other optimizations that we could make here that I haven’t discussed. For example, arenas could be re-used; once an arena is done, it could be “reset” and placed into a <code>sync.Pool</code>. This arena would not need to go into the GC to request new chunks, re-using the ones previously allocated (and potentially saving on the cost of zeroing memory over and over again).</p> <p>I did say that this relies very heavily on Go’s internal implementation details. Whats the odds that they get broken in the future? Well, the requirement that allocations know their shape is forced by the existence of <code>unsafe.Pointer</code>, and the requirement that a pointer into any part of an allocation keeps the whole thing alive essentially comes from slices being both sliceable and mutable; once a slice escapes to the heap (and thus multiple goroutines) coordinating copies for shrinking a slice would require much more complexity than the current write barrier implementation.</p> <p>And in my opinion, it’s pretty safe to say that Hyrum’s Law has us covered here. ;)</p>  </div></div>
  </body>
</html>
