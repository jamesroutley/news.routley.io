<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1001645/b1e4453a8c6c16d7/">Original</a>
    <h1>Using Guile for Emacs</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
<a href="https://www.gnu.org/software/emacs/">Emacs</a> is, famously, an
editor—perhaps far more—that is extensible using its own
variant of the Lisp programming language, <a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/">Emacs
Lisp</a> (or Elisp).  <a href="https://emacsconf.org/2024/">This year&#39;s
edition of EmacsConf</a>, which is an annual &#34;gathering&#34; that has been held
online for the past five years, had two separate talks on using a different
variant of Lisp, <a href="https://www.gnu.org/software/guile/">Guile</a>,
for Emacs.  Both projects would preserve Elisp compatibility, which is a
must, but they would use Guile differently.  The first talk we will cover
was given by Robin Templeton, who described the relaunch of the <a href="https://guile-emacs.org/">Guile-Emacs project</a>, which would replace
the Elisp in Emacs with a compiler using Guile.  A subsequent article will look
at the other talk, which is about <a href="https://emacsconf.org/2024/talks/gypsum/">an Emacs clone</a> written
using Guile.
</p>

<p>
LWN <a href="https://lwn.net/Articles/615220/">looked at Guile-Emacs</a> way back in 2014,
when Templeton had completed the last of several Google Summer of Code (GSoC)
internships working on it.  Around that time, Templeton had a fully functional
prototype, but they moved on to other things until recently
reviving the project.
</p>

<h4>Guile-Emacs</h4>

<p>
Guile is an implementation of <a href="https://www.scheme.org/">Scheme</a>,
which is a language in the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp
family</a>, as is Elisp, they began; Guile is also the official extension
language for the GNU project.  The goal of the Guile-Emacs project is to
use Guile to implement Elisp in Emacs.  There are two main components to
that: an Elisp compiler built on Guile and an Emacs that has its built-in
Lisp implementation completely replaced with Guile.
</p>

<blockquote>
<b>No slop, all substance: subscribe to LWN today</b>
<p>
LWN has always been about quality over quantity; we need your help
to continue publishing in-depth, reader-focused articles about Linux
and the free-software community. Please subscribe today to support our work
and keep LWN on the air; we are offering <a href="https://lwn.net/Promo/no-slop/claim">a free one-month trial subscription</a> to get you started.
</p></blockquote>
<p>
There are several benefits that they see for Emacs from the project.  They
believe it will improve performance while also increasing expressiveness
for Elisp.  The latter will make it easier to extend Elisp and to
experiment with new features in the language.  It will also reduce the
amount of C 
code in Emacs because it will no longer need a Lisp interpreter since Guile
will be providing that.  In answer to a question, Templeton said that roughly half of Guile is C code, but it is largely only
used for the lower layers, while the C code in Emacs is more widespread in
its use. Also, with
Guile, much more of Emacs can be written in Lisp than can be done now,
which also reduces the amount of C code needed.
</p>

<p>
Guile is a good choice for a few reasons, Templeton said.  While it is
primarily a Scheme implementation, it also has support for multiple
languages using its <a href="https://www.gnu.org/software/guile/manual/html_node/Compiler-Tower.html">compiler
tower</a>. In order to support a new language in Guile, it is only
necessary to write a compiler for the source language to <a href="https://www.gnu.org/software/guile/manual/html_node/Tree_002dIL.html">Tree-IL</a>,
&#34;<q>which is essentially a low-level, minimal representation of
Scheme</q>&#34;.  All of Guile&#39;s compiler optimizations are done on Tree-IL or
at lower levels, so a new language will benefit from those.
</p>

<p>
Guile also has some features that are uncommon in other Scheme
implementations, including a <tt>nil</tt> value that is both false and the
empty list, as it is in Elisp.  Guile also has <a href="https://www.gnu.org/software/guile/manual/html_node/GOOPS.html">GOOPS</a>,
which is a version of the <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">Common Lisp
Object System</a> (CLOS) and its <a href="https://en.wikipedia.org/wiki/Metaobject#Metaobject_protocol">metaobject
protocol</a>.
</p>

<p>
The idea of using Guile for Emacs has a long history, going back at least
three decades, they said.  There have been half-a-dozen previous
implementation attempts along the way.  The current project got its start
from a series of GSoC projects, beginning with Daniel Kraft&#39;s <a href="https://www.google-melange.com/archive/gsoc/2009/orgs/karlberry/projects/domob.html">2009
project</a>, followed by Templeton&#39;s five GSoC internships, 2010-2014
(which can be found in the <a href="https://www.google-melange.com/archive/gsoc">GSoC archive</a> under
the GNU Project for the year).
</p>

<p>
Over that time, they modified the Emacs garbage collector and data
structures for Lisp objects to use the libguile equivalents.  They also
replaced the Lisp evaluator in Emacs with the <a href="https://git.savannah.gnu.org/cgit/guile.git/tree/module/language/elisp/README">Elisp
compiler from Guile</a>.  A year after their last GSoC project, they had an
Guile-Emacs prototype that &#34;<q>was completely compatible with Emacs
functionality and with external extensions</q>&#34;.  The performance was poor,
because they were focused on correctness and ease of integration with the C
code in Emacs, but it was &#34;<q>a major milestone
for the project</q>&#34;. 
</p>

<p>
They gave a brief demo of Guile-Emacs by typing some Elisp into an Emacs
scratch buffer and evaluating it.  Scheme/Guile can be easily accessed from
within Elisp, which was shown by calling the Guile <tt>version</tt>
function and by producing a Scheme rational number from integer division.
Perhaps the most interesting piece was the demonstration that the classic
recursive factorial function did not actually call itself, because Scheme
requires tail-call optimization, which turns those calls into jumps.
</p>

<p>
The demo (and the rest of the talk) can be seen from the
<a href="https://emacsconf.org/2024/talks/guile/">EmacsConf page for the
talk</a>, where there are videos of the talk and Q&amp;A session
along with a transcript of the talk and, at the time of this
writing, an unedited transcript of the Q&amp;A.  There is some additional
information on that page for those wishing to dig in more.
</p>

<h4>Resurrection</h4>

<p>
In 2015, Templeton left their university to go to work on web technologies, so
Guile-Emacs went dormant.  That has been changing recently, because they
have been working with Larry Valkama over the last few months to rebase
Guile-Emacs onto a development branch of the Emacs upstream code.  There
were actually a series of rebases onto various versions of Emacs, which worked
increasingly poorly since Emacs internals had changed over time. Currently,
they have &#34;<q>a version of Emacs 30 which boots correctly and can be used for interactive debugging, as well as the ability to bisect the revisions of Emacs and find out where regressions were introduced</q>&#34;.
</p>

<p>
The immediate goal is to finish the rebase, but performance is next up.
They want to get the Guile Elisp performance to be competitive with the
existing Emacs Elisp; it is roughly half as fast right now.  &#34;<q>Guile
Scheme is quite often an order of magnitude faster than ordinary
Elisp</q>&#34; based on microbenchmarks like the &#34;Gabriel benchmarks&#34; (from the
book <a href="https://dreamsongs.com/Files/Timrep.pdf"><i>Performance and
Evaluation of Lisp Systems</i></a> by Richard P. Gabriel), so there is
still a lot of room to improve Guile-Emacs. The hope is to have a usable
version of Guile-Emacs based on Emacs 30 sometime in the next four or five
months (by northern-hemisphere spring, Templeton said).
</p>

<p>
There is also an effort to get some of this work upstream. On the Guile
side, that includes optimizing the <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Dynamic-Binding.html">dynamic-binding</a> facilities; dynamic
binding is rarely used in Scheme, but is used frequently in other Lisp
dialects, including Elisp.  For Emacs, they want to work on &#34;<q>abstracting
away the details of the Lisp implementation where they&#39;re not
relevant</q>&#34;, which will make it easier to integrate Emacs and Guile
Elisp.  It also cleans up some code that will make things easier for anyone
working on Elisp.
</p>

<p>
They also have plans to add features to Elisp, including the Scheme <a href="https://www.gnu.org/software/guile/manual/html_node/Numerical-Tower.html">numeric
tower</a>, tail-call optimization, and more Common Lisp compatibility.
Access to the <a href="https://github.com/wingo/fibers?tab=readme-ov-file#fibers">Fibers</a>
Guile Scheme library is planned.  Fibers is based on ideas from <a href="https://en.wikipedia.org/wiki/Concurrent_ML">Concurrent ML</a> and
&#34;<q>provides much more powerful facilities for concurrent and parallel
programming than what Emacs currently offers</q>&#34;. 
</p>

<p>
The idea is that this work furthers the goals of Guile-Emacs and it can
perhaps be integrated into the upstream projects relatively soon.
Templeton said that it is worth considering &#34;<q>what effect Guile-Emacs
might have on Emacs if it becomes simply Emacs</q>&#34;.  The amount of C code
in Emacs has increased by 50% in the last decade and now is around 1/4 of
the codebase. But that C code can be a barrier to extending and customizing
Emacs; writing more of Emacs in Lisp will make it more customizable.  C
functions that are called both from Lisp and C in Emacs (around 500 of
them) cannot practically be redefined from Elisp.
</p>

<h4>Common Lisp</h4>

<p>
One way to speed up the process of writing more of Emacs in Lisp would be
to use a Guile implementation of Common Lisp, they said; the essential
ingredients for 
doing that are already present in the Scheme and Elisp implementations in
Guile.  Implementation code could be shared with other open-source
projects, such as <a href="https://www.sbcl.org/">Steel Bank Common
Lisp</a> (SBCL) and <a href="https://github.com/robert-strandh/SICL">SICL</a>, too.
Even though Common Lisp has a reputation as a large language, they think
getting it running on Guile would be a matter of &#34;<q>months rather than
years</q>&#34;.
</p>

<p>
Common Lisp would bring other advantages, including the ability for Elisp
to adopt some of its features.  From the perspective of reducing the amount
of C in Emacs, though, Common Lisp &#34;<q>would also provide us with instant
access to a huge number of high-quality libraries</q>&#34; for handling things
that Guile is lacking, such as &#34;<q>access to low-level Windows APIs</q>&#34;
and &#34;<q>interfaces to GUI toolkits for a variety of operating systems</q>&#34;.
</p>

<p>
Templeton did not mention it, but LWN readers may remember that <a href="https://lwn.net/Articles/951090/">Richard Stallman is not a fan of Common Lisp</a>; rewriting Emacs using it is not likely to go far.
</p>

<p>
Meanwhile, if most of Emacs is written in Lisp, it may be possible to use
<a href="https://spritely.institute/hoot/">Guile Hoot</a> to compile it to
WebAssembly and run it in browsers and other environments.  Writing more of
Emacs in Lisp would also be &#34;<q>a great victory for practical software
freedom</q>&#34; because it would help make the freedom to study and modify
programs easier. 
</p><blockquote>
When Emacs is implemented primarily in Lisp, the
entirety of the system will be transparent to examination and open to
modification. Every part of Emacs will be instantaneously inspectable,
redefinable, and debuggable.
</blockquote>


<p>
It would also allow Emacs extensions to do more.  An experiment that
Templeton would like to try would be to use the <a href="https://en.wikipedia.org/wiki/Common_Lisp_Interface_Manager">Common
Lisp Interface Manager</a> (CLIM) as the basis of the Emacs user interface.
CLIM is &#34;<q>a super-powered version of Emacs&#39;s concept of interactive
functions</q>&#34;, they said, but trying that in today&#39;s Emacs would be
difficult; if the lowest layers were customizable via Lisp, though, it
would be almost trivial to do.  They noted that there was another EmacsConf 2024 <a href="https://emacsconf.org/2024/talks/mcclim/">talk</a> on using
the 
<a href="https://codeberg.org/McCLIM/McCLIM#logo-https-common-lisp-net-project-mcclim-img-mcclim-png">McCLIM</a>
CLIM implementation
with Elisp.
</p>

<p>
They closed the talk with suggestions on how to get involved with
Guile-Emacs.  Trying it out and providing feedback are one obvious way;
there is a <a href="https://codeberg.org/guile-emacs">Codeberg
repository</a> for the project that will contain both a tarball and Guix
package, they said.
Bug reports and feature requests are welcome as well, as are contributors
and collaborators. The project is being developed by a &#34;<q>small worker
cooperative</q>&#34;, so donations are a direct means of supporting it.
</p>

<h4>Q&amp;A</h4>

<p>
The talk was followed by a Q&amp;A session.  Templeton reviewed the IRC log and
<a href="https://pad.emacsconf.org/2024-guile">Etherpad</a>, noting that
they had expected the Common Lisp piece to be the most controversial
(it &#34;<q>would piss people off</q>&#34;) because it is not part of either
the Emacs or Guile communities.
In addition, one of the motivations for transitioning from C to
Lisp was left out of the talk.  As more Lisp is added atop a
high-performance Lisp implementation, the less sense it makes to call out
to C to speed up operations, in part because of the cost of the
<a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign-function
interface</a> (FFI).  C limits the use of some &#34;<q>advanced control
structures</q>&#34; like <a href="https://en.wikipedia.org/wiki/Continuation">continuations</a>, as
well, so
there is more to be gained by providing ways to make the Lisp code faster,
Templeton said.
</p>

<p>
A few of the questions related to Common Lisp, including one on whether
there is active work on it for Guile.  Templeton said that they have been
working on it in their spare time over the last few years and have
implemented a few chapters of the <a href="https://www.lispworks.com/documentation/HyperSpec/Front/">Common Lisp
HyperSpec</a> (CLHS).  Lately, their focus has been on researching ways to
ergonomically support a polyglot Lisp environment, where Common Lisp,
Scheme, and Elisp can all work together easily. One of the problem areas is
the differences between a Lisp 1, which only has a single namespace, as with Scheme, and a Lisp 2, like
Common Lisp and Elisp, where a name can have different definitions as a
function or variable.  They have been looking into some ideas that Kent
Pitman has on combining the two.
</p>

<p>
The &#34;elephant in the room&#34; question was asked as well: does Templeton know
if the Emacs maintainers are interested in using Guile?  They said that
they are unsure how the current maintainers feel about it, though the
reception overall has been &#34;<q>generally cautiously optimistic</q>&#34;.  There
are political aspects to a change of that sort, but from a technical
perspective, some previous Emacs maintainers &#34;<q>didn&#39;t think that it was a
bad idea</q>&#34;.  Templeton knows that current Emacs maintainer Eli Zaretskii
is concerned about cross-platform compatibility, so Guile-Emacs needs to be
&#34;<q>rock solid</q>&#34; in that department before any kind of upstreaming can
be contemplated. 
</p>

<p>
The talk was interesting, as is the project, though there is something of a quixotic
feel to it.  An upheaval of that sort in a codebase that is as old as Emacs
seems a little hard to imagine, and the political barriers may well be
insurmountable even if the technical case is compelling.  Based on this
talk (and others at the conference), though, there is some pent-up interest
in finding ways for Emacs to take advantage of advances in other Lisp
dialects. 
</p></div></div>
  </body>
</html>
