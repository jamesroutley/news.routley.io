<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cameronsworld.net">Original</a>
    <h1>A Love Letter to Geocities Sites</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
        <span>
            <time datetime="2022-07-29">29 Jul 2022</time>
        </span>
        
        
        <section>
            <!--kg-card-begin: markdown--><p>They&#39;re here! <a href="https://csrc.nist.gov/projects/post-quantum-cryptography/selected-algorithms-2022">NIST selected a first batch</a> of post-quantum cryptographic key exchange and signature algorithms. <a href="https://nvlpubs.nist.gov/nistpubs/ir/2022/NIST.IR.8413.pdf">The report</a> is a nice read that explains a lot of the goals, candidates, selections, and rationales. I recommend Sections 2, 3.3, and 4.1.</p>
<p>For key exchange, NIST selected only CRYSTALS-Kyber, a KEM with IND-CCA2 security based on structured lattices, <a href="https://cryptojedi.org/peter/data/inria-20170411.pdf">a successor of NewHope</a>, with 800 bytes keys and ciphertexts (although the authors <a href="https://pq-crystals.org/kyber/">recommend</a> using the category 3 parameters, with 1184 bytes public keys and 1088 bytes ciphertexts). Four other KEMs based on codes and isogenies are continuing to a fourth round that will select a key exchange fallback in case lattices turn out to be a bad idea.<sup><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2 id="kems">KEMs</h2>
<p>What&#39;s a KEM and what does it mean for it to have IND-CCA2 security? A Key Encapsulation Method is an implementation of the following API.</p>
<pre><code>KeyGen() -&gt; public key, secret key
Encapsulate(public key) -&gt; ciphertext, shared key
Decapsulate(secret key, ciphertext) -&gt; shared key
</code></pre>
<p>One way to implement a KEM that you might already be familiar with is with Elliptic Curve Diffie-Hellman. In ECDH, the ciphertext is more commonly called the peer or ephemeral share.</p>
<pre><code>KeyGen():
    secret key = random_scalar()
    public key = scalar_mult(secret key, generator)

Encapsulate(public key):
    ephemeral = random_scalar()
    ciphertext = scalar_mult(ephemeral, generator)
    s = scalar_mult(ephemeral, public key)
    shared key = KDF(s || public key || ciphertext)

Decapsulate(secret key, ciphertext):
    s = scalar_mult(secret key, ciphertext)
    shared key = KDF(s || public key || ciphertext)
</code></pre>
<p>One can also make a KEM from RSA. It&#39;s actually a much simpler, safer, and easier-to-prove way to do RSA encryption, compared with RSA-OAEP and especially with with RSA PKCS #1 v1.5 encryption. I regret using RSA-OAEP instead of RSA-KEM for <code>ssh-rsa</code> support in age.</p>
<pre><code>KeyGen():
    p, q = random_prime(), random_prime()
    public key = n = p * q
    e = 65537
    secret key = d = e⁻¹ mod λ(n)

Encapsulate(n):
    m = random(2, n)
    ciphertext = m ^ e mod n
    shared key = KDF(m || n || ciphertext)

Decapsulate(d, ciphertext):
    m = ciphertext ^ d mod n
    shared key = KDF(m || n || ciphertext)
</code></pre>
<p>(In the wild, you&#39;ll find RSA-KEM with configurable public exponent <code>e</code> and without <code>n</code> and <code>c</code> hashed into the shared key. Good cryptographic engineering hygiene requires <a href="https://www.imperialviolet.org/2022/03/15/pickingparameters.html">fixing parameters</a>, and hashing transcripts. The former <a href="https://github.com/ytdl-org/youtube-dl/pull/8142">saved my homebrew youtube-dl update verification function</a>, and the latter makes the KEM <a href="https://eprint.iacr.org/2019/526">contributory</a>.)</p>
<p>So that&#39;s what a KEM is.<sup><a href="#fn2" id="fnref2">[2]</a></sup> What about IND-CCA2 security? It means that it provides &#34;ciphertext indistinguishability against adaptive chosen ciphertext attacks&#34;. More concretely, it means you can reuse a public key instead of having to generate a new one for every decapsulation. The alternative is for it to be secure only against chosen plaintext attacks (CPA), where the attacker doesn&#39;t have access to a decryption oracle. In practice, that would require using each public key only once, restricting its use mostly to interactive protocols.</p>
<p>A CCA-secure KEM is a very versatile tool, that lets us do many (although not all) things we&#39;re used to doing in the pre-quantum world. The main difference from (EC)DH is that KEMs are asymmetric: you can&#39;t use the public key as a ciphertext and vice-versa.</p>
<p>Here&#39;s what can be done with a CCA-secure KEM:</p>
<ul>
<li>
<p>It can be combined with symmetric encryption in an offline KEM-DEM public key encryption scheme, like ECDHE turns into ECIES (which is what age&#39;s X25519 recipients implement): the sender does an encapsulation to the recipient&#39;s public key, uses the shared key to encrypt a message with a symmetric AEAD, and sends the KEM ciphertext and the encrypted message.<sup><a href="#fn3" id="fnref3">[3]</a></sup></p>
</li>
<li>
<p>It can be used to build authenticated key exchanges by running the KEM three times (or two, to authenticate only one side) in parallel: once with an ephemeral  public key for forward secrecy, once with one peer&#39;s long term public key, and once with the other peer&#39;s long term public key. The three shared keys are hashed together, and using the resulting key authenticates the two peers.<sup><a href="#fn4" id="fnref4">[4]</a></sup></p>
</li>
<li>
<p>It allows caching and reusing public keys in ephemeral key exchanges like ECDHE in TLS (which you might or might not want to do—with ECDH we pretty much collectively gave up on it, because many many many implementation errors become unexploitable if the &#34;public key&#34; is used only once<sup><a href="#fn5" id="fnref5">[5]</a></sup>).</p>
</li>
</ul>
<h2 id="kyber">Kyber</h2>
<p>Kyber is designed as a CPA-secure PKE core, turned into a CCA-secure KEM with a standard construction, but only the CCA-secure KEM is specified as an exposed primitive. This is cheap—it just adds a handful of hash invocations<sup><a href="#fn6" id="fnref6">[6]</a></sup> and a PKE encapsulation to the KEM decapsulation step—and a very good idea: we don&#39;t need two very similarly named primitives with very different security properties floating around, when we could just have the safer one everywhere. I hope implementations respect the spirit of the design and don&#39;t expose the CPA-secure PKE.</p>
<p>Another robustness detail I appreciate of Kyber is that it hashes the transcript (ciphertext and public key) into the key by design.<sup><a href="#fn7" id="fnref7">[7]</a></sup> When making a KEM out of ECDH, you need to feed shared secret, public key, and peer share/ciphertext into the KDF to get a contributory KEM. Kyber does that for you. While not required for CCA-security, contributory behavior <a href="https://eprint.iacr.org/2019/526">can prevent some neat real-world attacks</a> and should even allow using the public key as an authentication key.<sup><a href="#fn8" id="fnref8">[8]</a></sup> Enshrining this property into the design and test vectors is the right way to ensure implementations don&#39;t forget it when they need it.</p>
<h2 id="post-quantum-age">Post-quantum age</h2>
<p><a href="https://age-encryption.org">age</a> is a simple, modern, and secure file encryption format, tool, and library. Its native recipient type is based on X25519, but it supports custom recipient types through Go interfaces or an stdin/stdout plugin system. All a recipient needs to do is wrap and unwrap a file key given a recipient and identity string, respectively. Can we make a post-quantum age recipient based on Kyber?</p>
<h3 id="128-bits-are-enough">128 bits are enough</h3>
<p>The main concern is the size of the file key: 128 bits.<sup><a href="#fn9" id="fnref9">[9]</a></sup> My previous rough understanding of <a href="https://en.wikipedia.org/wiki/Grover%27s_algorithm">Grover&#39;s attack</a> was that it allowed searching an n-bit key space for a black box function in n/2 &#34;time&#34; on a quantum computer. This understanding is fairly popular: it&#39;s sort of a meme that you need to support AES-256 for &#34;post-quantum reasons&#34;. If that&#39;s right, then no matter what we use for the recipient implementation, age v1 can be attacked with a quantum computer by bruteforcing the file key (and checking it correctness against the header HMAC) in 2⁶⁴ time, which sounds unacceptable.</p>
<p>That understanding is practically wrong.</p>
<p>The <a href="https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria)">NIST security evaluation criteria</a> for post-quantum cryptography define five security categories of increasing strength. Each proposed post-quantum scheme provides a set of parameters to match these categories, which you can think about like key sizes in classical cryptography. To meet category 1 requirements, attacking a set of parameters &#34;must require computational resources comparable to or greater than those required for key search on a block cipher with a 128-bit key (e.g. AES128)&#34;.</p>
<p>Not only is a 128-bit key not a deal-breaker, then, but it&#39;s the benchmark against which category 1 post-quantum parameters are measured against. How to reconcile this with our understanding of Grover? NIST explains:</p>
<blockquote>
<p>[...] NIST suggests an approach where quantum attacks are restricted to a fixed running time, or circuit depth. Call this parameter MAXDEPTH. This restriction is motivated by the difficulty of running extremely long serial computations. Plausible values for MAXDEPTH range from 2⁴⁰ logical gates (the approximate number of gates that presently envisioned quantum computing architectures are expected to serially perform in a year) through 2⁶⁴ logical gates (the approximate number of gates that current classical computing architectures can perform serially in a decade), to no more than 2⁹⁶ logical gates (the approximate number of gates that atomic scale qubits with speed of light propagation times could perform in a millennium).</p>
<p>The complexity of quantum attacks can then be measured in terms of circuit size. These numbers can be compared to the resources required to break AES and SHA3. At the present time, NIST would give the following estimates for the classical and quantum gate counts for the optimal key recovery and collision attacks on AES and SHA3, respectively, where circuit depth is limited to MAXDEPTH:</p>
<p>AES-128: 2¹⁷⁰ / MAXDEPTH quantum gates</p>
<p>It is worth noting that the security categories based on these reference primitives provide substantially more quantum security than a naïve analysis might suggest. For example, categories 1, 3 and 5 are defined in terms of block ciphers, which can be broken using Grover’s algorithm, with a quadratic quantum speedup. But Grover’s algorithm requires a long-running serial computation, which is difficult to implement in practice. In a realistic attack, one has to run many smaller instances of the algorithm in parallel, which makes the quantum speedup less dramatic.</p>
</blockquote>
<p>The summary is that Grover requires an unrealistically long-running serial computation<sup><a href="#fn10" id="fnref10">[10]</a></sup>, and <a href="https://arxiv.org/abs/quant-ph/9711070">can&#39;t be parallelized better than naively running multiple instances</a>. When taking into account a conservative maximum running time, such as 2⁶⁴ gates, running Grover on a 128-bit key space would require a circuit size of 2¹⁰⁶.</p>
<p>Assuming that there aren&#39;t any better-than-Grover attacks against the age primitives—HKDF-SHA-256 followed by HMAC-SHA-256 or ChaCha20Poly1305—it&#39;s fully appropriate to match category 1 post-quantum KEMs with 128-bit symmetric keys, like in age.</p>
<blockquote data-dnt="true"><p lang="en" dir="ltr">Yes, it&#39;s fine to use Kyber512 like this. But I recommend defaulting to Kyber768 unless you have a hard performance constraint that forces you to use 512.</p>— John Schanck (@susurrusus) <a href="https://twitter.com/susurrusus/status/1544698275718053890?ref_src=twsrc%5Etfw">July 6, 2022</a></blockquote>  
<blockquote data-conversation="none" data-dnt="true"><p lang="en" dir="ltr">Indeed If 128-bit brute force is the best way of attacking the protocol, then it meets Level 1 requirements; being equivalent to AES-128.</p>— mjos\dwez (@mjos_crypto) <a href="https://twitter.com/mjos_crypto/status/1544699876545634307?ref_src=twsrc%5Etfw">July 6, 2022</a></blockquote>  
<h3 id="the-age-kyber768x25519-plugin">The age Kyber768+X25519 plugin</h3>
<p>Having established that the overall age protocol can by definition meet NIST&#39;s category 1 post-quantum security requirements, we can start thinking about how a post-quantum age plugin would look like.</p>
<p>Kyber&#39;s category 1 parameters are Kyber512, but <a href="https://pq-crystals.org/kyber/index.shtml">the authors recommend using Kyber768</a> unless prohibitive due to performance reasons. Both are plenty fast, and both have large public keys (800 vs 1184 bytes), so let&#39;s pick the conservative option. As str4d—<a href="https://github.com/str4d/rage">rage</a>&#39;s author—points out, this would also let us decide later that we do instead want to increase the file key size, while letting users keep their keys with a matching comfortable margin.</p>
<p>Any deployment of experimental post-quantum cryptography should be hybrid: paired with classical cryptography such that even if lattice cryptography turns out to be a bad idea, the combined system will be at least as secure as the classical algorithm. For our plugin, we&#39;ll just combine the Kyber768 KEM with X25519.</p>
<p>Native X25519 recipients wrap the file key using ChaCha20Poly1305 with a key derived as <code>HKDF-SHA-256(ikm = shared secret, salt = ephemeral share || recipient, info = &#34;age-encryption.org/v1/X25519&#34;)</code>. We could just add the Kyber key to the input key material, but we can take the occasion to fix a small regret in the age design: the salt is supposed to be random or fixed for domain separation, while ephemeral share and recipient should have been part of the input key material. This is not a security issue, but it makes applying some proofs more convoluted.</p>
<p>The wrapping key for the Kyber768+X25519 plugin can then be <code>HKDF-SHA-256(ikm = shared secret || ephemeral share || recipient || kyber key, salt = &#34;age-encryption.org/Kyber768+X25519&#34;, info = nil)</code>.</p>
<p>There are a few open questions that relate to optional properties that are not part of the core age guarantees but some recipients provide:</p>
<ul>
<li>Do a decryption or encryption oracle leak information about the public key? As we talked about above,<sup><a href="#fn8" id="fnref8:1">[8:1]</a></sup> the public key is hashed into the key (the KEM is contributory), so an attacker can&#39;t generate a valid ciphertext for an unknown public key. If the attacker also can&#39;t learn the public key from an oracle, it might be possible to build authentication semantics around this.</li>
<li>Are ciphertexts for the same public key efficiently linkable? X25519 and Scrypt ciphertexts are unlikable, so given two age files you can&#39;t tell if they are encrypted to the same recipient. Does the same hold for Kyber768+X25519? (This does not hold for the SSH recipients, which intentionally include a public key hash, so we don&#39;t ask for the passphrase for keys that wouldn&#39;t work.)</li>
<li>Is it possible to craft ciphertexts that are valid (and lead to known keys) under multiple public keys, enabling multi-key attacks <a href="https://github.com/FiloSottile/age/commit/2194f6962c8bb3bca8a55f313d5b9302596b593b">like against X25519 and ChaCha20Poly1305</a>? Although the impact of this is limited—allows efficient searches of the accepted public keys of a decryption oracle—it might be a good reason to use a robust AEAD instead of ChaCha20Poly1305.</li>
</ul>
<p>Finally, there&#39;s the elephant in the room: the UX issue of the large public keys.</p>
<p>One of the key strengths (pun not intended) of age is that it has small, copy-pastable recipients like age1ydzqkt4vfuumwgk5hxus22gakwpqk9knua62qnzcqw5nzta30d9q3va9x0. A Kyber768+X25519 recipient would be... quite a bit longer. I am not going to paste one here because I care about the delivery rate of this email, but it&#39;d be 1960 characters, more than 30 times longer than the X25519 one.</p>
<p>A suggestion I like was to have the plugin store keys with a <code>-learn</code> flag, and then allow using them with a short identifier, like a hash. Or, maybe we bring back the aliases file that was in the original <a href="https://age-encryption.org/design">age design document</a> but never made it to v1.0.0. Or, we just accept that Kyber768+X25519 recipients will be mostly used with <code>--recipients-file</code>. It is still shorter than an armored OpenPGP public key. I welcome opinions and ideas.</p>
<blockquote data-conversation="none" data-dnt="true"><p lang="en" dir="ltr">Does age currently use any local state? You could do like a mapping from H(public key) -&gt; public key locally, then just require registering a public key once.</p>— Lúcás Meier (@cronokirby) <a href="https://twitter.com/cronokirby/status/1544716869671784450?ref_src=twsrc%5Etfw">July 6, 2022</a></blockquote>  
<p>One more bonus UX issue: how do we stop people from mixing Kyber768+X25519 and plain X25519 recipients, defeating the post-quantum security of the file? Ideally without a special case.</p>
<p>If you&#39;ve made it this far, you might enjoy <a href="#/portal/signup">subscribing to Cryptography Dispatches</a> or <a href="https://twitter.com/FiloSottile">following me on Twitter</a>.</p>
<h2 id="bonus-picture">Bonus picture</h2>
<p>I&#39;m <a href="https://words.filippo.io/dispatches/dsa/">back</a> on the lake for the Italian math team training (where the promising kids train and I mostly play board games)!</p>
<p><img src="https://words.filippo.io/content/images/2022/07/IMG_6905.jpg" alt="A picture of a lake taken from the shore. The sky is full of clouds colored orange from a recent storm. They reflect on the water, where a few boats sit anchored. Two wooden piers extend from the shore from right to left. In the distance mountains on the other side of the lake, and a small sliver of blue sky." loading="lazy"/></p>
<hr/>
<section>
<ol>
<li id="fn1"><p>For signatures, NIST selected CRYSTALS-Dilithium, FALCON, and SPHINCS+. CRYSTALS-Dilithium is based on structured lattices and has 1312 bytes keys and 2420 bytes signatures (at category 2, see below). FALCON is also based on structured lattices, has significantly more complex implementation (requiring constant time floating point operations, which we collectively don&#39;t have experience with), but provides 897 bytes public keys and 666 bytes signatures (at category 1). SPHINCS+ is a stateless hash-based signature scheme, with compact 32 bytes public keys but very large signatures starting at 7856 bytes. CRYSTALS-Dilithium is the main recommendation, FALCON is there for when you don&#39;t have 2KiB for a signature (which, regrettably, probably means we&#39;ll have to use the complex option in X.509), and SPHINCS+ is the fallback in case lattices turn out to be a bad idea (or you don&#39;t care at all about signature size, like apparently firmware updates don&#39;t, since the signature is discarded after verifying it and it&#39;s only the public key taking up precious flash memory). This leaves a gap for non-lattice small signatures, for which NIST is planning to run a new Call for Proposal over the coming years. No other current candidates are being considered anymore. <a href="#fnref1">↩︎</a></p>
</li>
<li id="fn2"><p>If this explanation of what a KEM is didn&#39;t work for you, I liked <a href="https://crypto.stackexchange.com/a/52395">this Stack Exchange answer</a> which maps out the relationship between KEMs, public key encryption, and key exchanges. <a href="#fnref2">↩︎</a></p>
</li>
<li id="fn3"><p>See Appendix A of <a href="https://eprint.iacr.org/2017/634.pdf">the Kyber paper</a> for a sketch of a KEM-DEM public key encryption scheme. <a href="#fnref3">↩︎</a></p>
</li>
<li id="fn4"><p>See Section 5 of <a href="https://eprint.iacr.org/2017/634.pdf">the original Kyber paper</a> for a fully worked out sketch of this key exchange protocol. <a href="#fnref4">↩︎</a></p>
</li>
<li id="fn5"><p>It&#39;s interesting to think about ECDH implementation vulnerabilities, such as <a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Valsorda-Squeezing-A-Key-Through-A-Carry-Bit-wp.pdf">our old attack against a carry bug in Go</a> and many others, as degrading security of the scheme from CCA to CPA. In that sense, making a CPA-secure ECDH implementing is actually not that hard. I can&#39;t think of any implementation vulnerabilities, including side channel attacks, that violated CPA security. This makes intuitive sense, since in a CPA/ephemeral scenario the attacker only gets one shot at extracting information about the key, which usually comes a few bits at a time. I wonder if this will be true of post-quantum KEMs, too. Maybe we should generally try to design protocols that only require CPA security even when a CCA-secure tool is available, as a mitigation for implementation issues. <a href="#fnref5">↩︎</a></p>
</li>
<li id="fn6"><p>Kyber is so fast that the hashes take almost ¾ of the Encaps and Decaps CPU cycles. Kyber also made some <a href="https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/h4Is0_xuDaM">slightly bizarre hash choices</a>, using different SHA-3 variants for domain separation. This is a small thing that I hope will change in the final standard, as I&#39;m not a fan of using four different hash variants in one scheme, I&#39;d rather see SHAKE used everywhere and the fixed size SHA-3 variants forgotten, and domain separation is best understood in the context of a whole protocol, where prefixes (or HMAC keys, or context-aware hashes) are the standard. You run out even of SHA-3 variants, eventually. <a href="#fnref6">↩︎</a></p>
</li>
<li id="fn7"><p>See Section 4 of <a href="https://eprint.iacr.org/2017/634.pdf">the Kyber paper</a>, subheading &#34;Hashing pk into ˆK&#34;. <a href="#fnref7">↩︎</a></p>
</li>
<li id="fn8"><p>The idea being that without the public key it might be impossible for the attacker to forge a ciphertext for that public key that will decrypt to a known key, making the public key a valid authentication capability key. It&#39;s easy to show that knowledge of the public key is necessary to produce a ciphertext that decrypts to a known key, since the public key is hashed into the key; what&#39;s harder is showing that a CCA decryption oracle doesn&#39;t leak information about the public key. We&#39;ll return to this in the context of adding authentication to age. <a href="#fnref8">↩︎</a> <a href="#fnref8:1">↩︎</a></p>
</li>
<li id="fn9"><p>Why 128 bits? Because the file key is wrapped in each recipient stanza, so adding 16 more bytes to the file key would add 16 bytes to the file size <em>per recipient</em>. Instead, we have a 128-bit per-file nonce to provide a comfortable margin against multi-user attacks, where a shared search space of only 128 bits would be too tight. <a href="#fnref9">↩︎</a></p>
</li>
<li id="fn10"><p>This nuance comes up in evaluating classical attacks, too, by the way. There was some commotion about attacks against static Diffie-Hellman oracles a few years ago, claiming it reduced the security of Privacy Pass over Curve25519 or ristretto255, but a <a href="https://mailarchive.ietf.org/arch/msg/cfrg/YDVS5Trpr6suig_VCFEOH6SOn8Q/">careful analysis</a> showed that to get a worrying improvement it required almost 2⁶⁴ <em>sequential</em> oracle queries, which even at one query per nanosecond would take 400 years. For a parallelizable attack, 2⁶⁴ is almost trivial, but as sequential operations where the input of the next requires the previous one, it&#39;s a prohibitive scale. <a href="#fnref10">↩︎</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown-->
        </section>
    </article>
</div></div>
  </body>
</html>
