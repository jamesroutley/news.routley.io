<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/">Original</a>
    <h1>Crafting Interpreters with Rust: On Garbage Collection</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><strong>TL;DR</strong> Here’s the <a href="https://github.com/ltungv/rox">link to the project</a>.</p>
<p>I became interested in implementing programming languages a few years ago and discovered <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> by Bob Nystrom. At the time, I had experience with Rust and decided to use it to follow the book. Albeit, being a noob, I managed to implement a fully functional bytecode interpreter that supported every feature of the Lox language as described. However, my implementation suffered memory leaks due to reference counting. Back then, I didn’t fully grasp Rust to design and implement a proper garbage collector (GC)! Now that I have more confidence in the language, I decided to revisit the project and improve its memory management scheme.</p>
<p>As for the goals, I aim to implement a mark-and-sweep GC that is on par with the C implementation. You probably guessed that lots of <code>unsafe</code> statements will be thrown around. If you have the <em>ick</em> for <code>unsafe</code>, look elsewhere. Although I’m not an expert on this subject matter and might make many mistakes, I hope you’ll find something useful here.</p>
<figure><a href="https://programmerhumor.io/backend-memes/so-annoying-having-to-put-that-everywhere/"><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/rust-is-just-cpp.webp" loading="lazy" alt="Viewer discretion is advised!" width="100%"/></a><figcaption>
      <h4>Viewer discretion is advised!</h4>
    </figcaption>
</figure>

<h2 id="preface">preface</h2>
<p>Following the book, I implemented an interpreter for the Lox language, which has three phases - scanner, compiler, and virtual machine (VM). This post will only touch on the GC residing in the VM. Here’s a picture of how the interpreter operates and its components to clarify our starting point.</p>
<figure><a href="https://craftinginterpreters.com/scanning-on-demand.html"><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/interpreter-pipeline.png" loading="lazy" alt="Scanning on Demand - Pipline." width="100%"/></a><figcaption>
      <h4>Scanning on Demand - Pipline.</h4><p>
          <a href="https://github.com/munificent">by Bob Nystrom</a></p>
    </figcaption>
</figure>

<h2 id="managed-memory">managed memory</h2>
<p>Before diving deeper, let’s define garbage and what the GC does. Many readers likely know this already, but I’ll briefly review it so we’re all on the same page. If you need to learn more about this subject, there are already much better resources, and the chapter on <a href="https://craftinginterpreters.com/garbage-collection.html">Garbage Collection</a> is also a great read on the topic.</p>
<p>We all know software needs to store data on your computer memory, i.e., RAM, to operate. Most, if not all, programs have two separate regions to hold data - the stack and the heap. How much memory is used for the stack and when it is freed can always be determined at compile-time. We are more interested in the heap, where data can be of arbitrary sizes, and the program can ask your computer for more memory when needed. Think about taking in user inputs. Before running the program, we couldn’t know how much memory would be used to hold those inputs and would have to rely on runtime information to allocate enough memory to hold them.</p>
<figure><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/kylo-ren-more.gif" loading="lazy" alt="Your browser." width="100%"/><figcaption>
      <h4>Your browser.</h4>
    </figcaption>
</figure>

<p>This is one of the most important aspects where languages differ. The programming language we’re trying to implement, Lox, is a managed high-level language. That means all the heap memory is automatically dealt with for you behind the scenes. When data is needed to be put on the heap, the VM automatically allocates memory to hold it. Once that data is no longer used, the VM ensures it is returned to your computer so your program doesn’t eat up all the memory. The component doing all of these is called the <strong>garbage collector</strong>.</p>
<h2 id="garbage-collection">garbage collection</h2>
<p>One of the most important tasks of a GC is determining which piece of data is no longer used. Because memory is dynamically allocated, the GC cannot determine precisely at any particular moment if a piece of memory is still in use. Thus, the GC can only approximate by considering that data is still in use if it can potentially be read at any future point.</p>
<blockquote>
<p>Lox uses the term object to refer to any values that are heap-allocated.</p>
</blockquote>
<p>Let’s consider an example from the book:</p>
<div><pre tabindex="0"><code data-lang="kotlin"><span><span><span>var</span> <span>a</span> <span>=</span> <span>&#34;first value&#34;</span><span>;</span>
</span></span><span><span><span>a</span> <span>=</span> <span>&#34;updated&#34;</span><span>;</span>
</span></span><span><span><span>// GC here.
</span></span></span><span><span><span></span><span>print</span> <span>a</span><span>;</span>
</span></span></code></pre></div><p>If the GC runs right after <code>a</code> is reassigned to <code>&#34;updated&#34;</code>, the string <code>&#34;first value&#34;</code> is in memory, but the program can no longer access it. As a result, the GC can safely remove it. We say an object is <strong>reachable</strong> if there’s a way for the program to reference it, like the string <code>&#34;updated&#34;</code> in this case. Conversely, the string <code>&#34;first value&#34;</code> is <strong>unreachable</strong>. Intuitively, we see that reachable objects can’t be freed.</p>
<p>Objects that can be reached directly from the VM are called <strong>roots</strong>. Root objects can be global variables, objects on the VM’s stack, objects on the frame stack, or upvalues, i.e., values hoisted by closures. Additionally, objects can be referenced indirectly through other references, and we must also consider those. Again, taken from the book:</p>
<div><pre tabindex="0"><code data-lang="kotlin"><span><span><span>fun</span> <span>makeClosure</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>var</span> <span>a</span> <span>=</span> <span>&#34;data&#34;</span><span>;</span>
</span></span><span><span>    <span>fun</span> <span>f</span><span>()</span> <span>{</span> <span>print</span> <span>a</span><span>;</span> <span>}</span>
</span></span><span><span>    <span>return</span> <span>f</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>var</span> <span>closure</span> <span>=</span> <span>makeClosure</span><span>();</span>
</span></span><span><span>    <span>// GC here.
</span></span></span><span><span><span></span>    <span>closure</span><span>();</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Here, we have a function <code>makeClosure</code> returning another function <code>f</code>. Suppose the GC runs once <code>makeClosure</code> was called after we have returned a reference to the function <code>f</code>. After the GC finishes, the returned closure is called printing out the string <code>&#34;data&#34;</code>. Therefore, the GC must not free <code>&#34;data&#34;</code> when it runs. However, if we take a look at the stack when the GC ran, it’s like this:</p>
<figure><a href="https://craftinginterpreters.com/garbage-collection.html"><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/closure-memory.png" loading="lazy" alt="Garbage Collection - Reachable." width="100%"/></a><figcaption>
      <h4>Garbage Collection - Reachable.</h4><p>
          <a href="https://github.com/munificent">by Bob Nystrom</a></p>
    </figcaption>
</figure>

<p>The string <code>&#34;data&#34;</code> is nowhere to be found on the stack because it is hoisted into the closure, where it can be later referenced. Because the program can, at some point, indirectly access objects through root objects, they must also be considered reachable. Hence, the problem of finding garbage reduces to a graph reachability problem.</p>
<figure><a href="https://craftinginterpreters.com/garbage-collection.html"><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/mark-sweep.png" loading="lazy" alt="Garbage Collection - Mark-Sweep." width="100%"/></a><figcaption>
      <h4>Garbage Collection - Mark-Sweep.</h4><p>
          <a href="https://github.com/munificent">by Bob Nystrom</a></p>
    </figcaption>
</figure>

<p>Considering the above, we arrive at a straightforward GC algorithm called <strong>mark-and-sweep</strong>. This was the first algorithm for garbage collection, devised by John McCarthy in his <a href="https://dl.acm.org/doi/10.1145/367177.367199">paper</a> on the Lisp language. It works in two phases:</p>
<ul>
<li><strong>Mark</strong>: Starting with the roots, the GC transitively traverses all objects referenced by them. Each time an object is visited, it is marked.</li>
<li><strong>Sweep</strong>: When the mark phase is complete, every reachable object is marked. Consequently, any unmarked object is unreachable, so we can go through them and free each one.</li>
</ul>
<h2 id="when-worlds-collide">when worlds collide</h2>
<p>Fundamentally, the issues we faced when implementing Lox’s object system aren’t due to the GC but to the difference between how Lox and Rust handle objects. In Rust, a variable can roughly be one of three kinds:</p>
<ul>
<li><strong><code>T</code></strong>: A value represents true <strong>ownership</strong>. Variables are in charge of freeing their resources, and resources can only have one owner. This prevents resources from being freed more than once. When doing assignments or passing function arguments by value, the ownership of the resources is transferred. This is known as a move.</li>
<li><strong><code>&amp;T</code></strong>: A shared reference gives the borrower read-only access. Essentially, it represents temporary <strong>shared access</strong> to a value you don’t own. Data can be immutably borrowed any number of times, but while immutably borrowed, the original data can’t be mutably borrowed.</li>
<li><strong><code>&amp;mut T</code></strong>: A mutable reference gives the borrower read/write access. Essentially, it represents temporary <strong>exclusive access</strong> to a value you don’t own. Consequently, only one mutable borrow is allowed at a time. The original data can be borrowed again only after the mutable reference has been used for the last time.</li>
</ul>
<p>These rules are enforced by the <strong>borrow-checker</strong>, famously known for being hard to grasp for a Rust beginner. By making our program conform to these rules, the compiler can reason about when objects are no longer used and can automatically insert <code>destroy</code> statements for us. This can also be considered a form of garbage collection, but the only difference is that it’s done at compile time, not runtime. But, unlike stack memory, we don’t know beforehand how much memory needs to be allocated.</p>
<p>On the other hand, Lox’s semantics deal with none of these rules. Essentially, every object in Lox is passed by reference, with no distinction between whether it’s shared or exclusive. Consider the following Lox program:</p>
<div><pre tabindex="0"><code data-lang="kotlin"><span><span><span>class</span> <span>Number</span> <span>{</span>
</span></span><span><span>    <span>init</span><span>(</span><span>value</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>fun</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>a</span><span>.</span><span>value</span> <span>=</span> <span>a</span><span>.</span><span>value</span> <span>+</span> <span>b</span><span>.</span><span>value</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>var</span> <span>a</span> <span>=</span> <span>Number</span><span>(</span><span>3</span><span>);</span>
</span></span><span><span><span>add</span><span>(</span><span>a</span><span>,</span> <span>a</span><span>);</span>
</span></span><span><span><span>print</span> <span>a</span><span>.</span><span>value</span><span>;</span>
</span></span></code></pre></div><p>The example above is perfectly valid Lox and will print out the value 6 when it is run. If we were to translate it to Rust while keeping similar semantics, it would look like this:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>struct</span> <span>Number</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>value</span>: <span>f64</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>add</span><span>(</span><span>a</span>: <span>&amp;</span><span>mut</span><span> </span><span>Number</span><span>,</span><span> </span><span>b</span>: <span>&amp;</span><span>mut</span><span> </span><span>Number</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>a</span><span>.</span><span>value</span><span> </span><span>=</span><span> </span><span>a</span><span>.</span><span>value</span><span> </span><span>+</span><span> </span><span>b</span><span>.</span><span>value</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>Number</span><span> </span><span>{</span><span> </span><span>value</span>: <span>3.0</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>add</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>a</span><span>,</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>a</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>print!</span><span>(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> </span><span>a</span><span>.</span><span>value</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The Rust program will not compile, and the compiler will return the following error:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>error<span>[</span>E0499<span>]</span>: cannot borrow <span>`</span>a<span>`</span> as mutable more than once at a <span>time</span>
</span></span><span><span>  --&gt; src/main.rs:11:17
</span></span><span><span>   <span>|</span>
</span></span><span><span><span>11</span> <span>|</span>     add<span>(</span><span>&amp;</span>mut a, <span>&amp;</span>mut a<span>)</span><span>;</span>
</span></span><span><span>   <span>|</span>     --- ------  ^^^^^^ second mutable borrow occurs here
</span></span><span><span>   <span>|</span>     <span>|</span>   <span>|</span>
</span></span><span><span>   <span>|</span>     <span>|</span>   first mutable borrow occurs here
</span></span><span><span>   <span>|</span>     first borrow later used by call
</span></span></code></pre></div><p>As an experiment, let’s say we modify the function <code>add()</code> in Rust to take two mutable values instead of two mutable references, like so:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>add</span><span>(</span><span>mut</span><span> </span><span>a</span>: <span>Number</span><span>,</span><span> </span><span>mut</span><span> </span><span>b</span>: <span>Number</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>a</span><span>.</span><span>value</span><span> </span><span>=</span><span> </span><span>a</span><span>.</span><span>value</span><span> </span><span>+</span><span> </span><span>b</span><span>.</span><span>value</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>We then face another error:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>error<span>[</span>E0382<span>]</span>: use of moved value: <span>`</span>a<span>`</span>
</span></span><span><span>  --&gt; src/main.rs:11:12
</span></span><span><span>   <span>|</span>
</span></span><span><span><span>10</span> <span>|</span>     <span>let</span> <span>a</span> <span>=</span> Number <span>{</span> value: 3.0 <span>}</span><span>;</span>
</span></span><span><span>   <span>|</span>         - move occurs because <span>`</span>a<span>`</span> has <span>type</span> <span>`</span>Number<span>`</span>, which does not implement the <span>`</span>Copy<span>`</span> trait
</span></span><span><span><span>11</span> <span>|</span>     add<span>(</span>a, a<span>)</span><span>;</span>
</span></span><span><span>   <span>|</span>         -  ^ value used here after move
</span></span><span><span>   <span>|</span>         <span>|</span>
</span></span><span><span>   <span>|</span>         value moved here
</span></span><span><span>   <span>|</span>
</span></span><span><span>
</span></span><span><span>error<span>[</span>E0382<span>]</span>: borrow of moved value: <span>`</span>a<span>`</span>
</span></span><span><span>  --&gt; src/main.rs:12:18
</span></span><span><span>   <span>|</span>
</span></span><span><span><span>10</span> <span>|</span>     <span>let</span> <span>a</span> <span>=</span> Number <span>{</span> value: 3.0 <span>}</span><span>;</span>
</span></span><span><span>   <span>|</span>         - move occurs because <span>`</span>a<span>`</span> has <span>type</span> <span>`</span>Number<span>`</span>, which does not implement the <span>`</span>Copy<span>`</span> trait
</span></span><span><span><span>11</span> <span>|</span>     add<span>(</span>a, a<span>)</span><span>;</span>
</span></span><span><span>   <span>|</span>            - value moved here
</span></span><span><span><span>12</span> <span>|</span>     print!<span>(</span><span>&#34;{}&#34;</span>, a.value<span>)</span><span>;</span>
</span></span><span><span>   <span>|</span>                  ^^^^^^^ value borrowed here after move
</span></span><span><span>   <span>|</span>
</span></span></code></pre></div><p>Needless to say, if we strictly follow Rust’s borrow-checker, it’s impossible to have two variables modifying the same memory address. To do so, we are required to jump through a few hoops to bypass the borrow-checker.</p>
<h2 id="safe-bets">safe bets</h2>
<p>We went a long-winded path to show the difficulties of making the two language semantics work happily together. But how do we address these fundamental differences? In essence, we want some mechanism to enable pointer aliasing and shared mutable access to objects. Lucky for us, Rust does provide tools for dealing with these cases. Despite that, we’ll soon see there’s more to desire from doing things the Rust’s way.</p>
<p>In the following sections, I’ll discuss two approaches for implementing a GC for Lox VM without using <code>unsafe</code> that I know of. This is not a comprehensive list, but it shows the choices that can be made while working on this problem. I’ve also encountered other approaches that utilize Rust’s type system and macros to their full extent, ensuring both safety and performance. Still, I don’t understand them enough for a meaningful discussion.</p>
<h3 id="reference-counting">reference counting</h3>
<p>The simplest approach to GC is to utilize existing Rust types for automatic memory management, ditching the mark-and-sweep algorithm. In Rust, we typically reach out for reference counting when we need shared resource management, i.e., <strong>shared ownership</strong>. This is supported through two different types - <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>. <code>Rc&lt;T&gt;</code> uses a non-atomic reference count and can’t be sent across threads, while <code>Arc&lt;T&gt;</code> uses an atomic reference count and can be sent across threads. We only cover <code>Rc&lt;T&gt;</code> for brevity, but the concept will also hold for <code>Arc&lt;T&gt;</code>.</p>
<p>According to Rust’s documentation, the type <code>Rc&lt;T&gt;</code> provides shared ownership of a value of type <code>T</code> allocated in the heap. Invoking <code>clone</code> on it produces a new pointer to the same allocation in the heap. When the last <code>Rc&lt;T&gt;</code> pointer to a given allocation is destroyed, the value stored in that allocation is also dropped. Thanks to Rust semantics, there’s no way to get a new reference from an <code>Rc&lt;T&gt;</code> without using <code>clone</code> or <code>unsafe</code>.</p>
<figure><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/rc-refcell.png" loading="lazy" alt="Reference counting with interior mutability." width="100%"/><figcaption>
      <h4>Reference counting with interior mutability.</h4>
    </figcaption>
</figure>

<p>By using <code>Rc&lt;T&gt;</code>, we are free from caring about how resources are released, but that only solves half of the problem since the reference we get from <code>Rc&lt;T&gt;</code> is immutable. In addition to <code>Rc&lt;T&gt;</code>, we have to introduce <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> to enable mutation through immutable reference. This pattern in Rust is called <strong>interior mutability</strong>. Instead of enforcing the borrowing rules with the compiler, <code>RefCell&lt;T&gt;</code> implements it at runtime. This has one significant implication - failure to adhere to the borrowing rule results in a runtime panic instead of a compile-time error. The resulting type <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> provides exactly what we need, a shared mutable reference to a heap-allocated value that gets free automatically when it’s no longer referenced. But what’s the catch?</p>
<p>One crucial thing to remember when using <code>Rc&lt;T&gt;</code> is to not create cycles between <code>Rc&lt;T&gt;</code>. Nonetheless, Lox doesn’t have this constraint and allows reference cycles to form. Moreover, Lox users should not care about the underlying memory model to avoid forming reference cycles. Consider the following Lox program:</p>
<div><pre tabindex="0"><code data-lang="kotlin"><span><span><span>class</span> <span>Node</span> <span>{}</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>var</span> <span>n1</span> <span>=</span> <span>Node</span><span>();</span>
</span></span><span><span>    <span>var</span> <span>n2</span> <span>=</span> <span>Node</span><span>();</span>
</span></span><span><span>    <span>n1</span><span>.</span><span>inner</span> <span>=</span> <span>n2</span><span>;</span>
</span></span><span><span>    <span>n2</span><span>.</span><span>inner</span> <span>=</span> <span>n1</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Here, we create a reference cycle between two objects. When the stack variables <code>n1</code> and <code>n2</code> go out of scope, the reference count of both objects gets decremented to 1, and we lose access to both objects. Due to the reference cycle, there’s no way to get the count to 0 because the count of one object depends on the deallocation of the other and vice versa.</p>
<figure><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/reference-cycle.png" loading="lazy" alt="Reference counting with cycle." width="100%"/><figcaption>
      <h4>Reference counting with cycle.</h4>
    </figcaption>
</figure>

<p>Using Rust’s API, such a cycle can be broken using <code>Weak&lt;T&gt;</code>. Giving out a <code>Weak&lt;T&gt;</code> only increments the weak count, which does not prevent the value from being destroyed even when it’s greater than zero. However, there’s no way for a Lox program to specify to the VM that it wants to use a weak pointer, and we don’t even want to expose such functionality due to the high-level nature of the language. Therefore, while being extremely simple to implement, this approach is ultimately unsound on its own.</p>
<p>On top of reference counting, languages typically employ a cycle detection algorithm and have a cycle collection phase to clean up unreachable objects that form reference cycles. Examples of such languages include Python, Nim, etc. You can implement this in Rust by defining your own <code>Rc&lt;T&gt;</code> like the one described in <a href="https://hyperbo.la/w/cactus-harvesting/">this article</a>. Even so, to keep true to how Lox is implemented in the book, I decided to not use reference counting and explored other methods for doing mark-and-sweep instead.</p>
<h3 id="object-manager">object manager</h3>
<p>We now know that reference counting is a no-go. What options do we have left? If we squint and look a bit closer at Lox’s memory model and object system, we see that every heap-allocated object is actually owned by “the heap”, and variables are just borrowing from it.</p>
<p>Taking this idea, we can explicitly model Lox’s heap using an object manager, i.e., a dynamic array containing all the objects. But then we have a problem - how do more than two variables hold mutable references to the same object inside the heap? We again face the scrutiny of the borrow-checker.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of indirection, except for the problem of too many layers of indirection
– David Wheeler</p>
</blockquote>
<p>Instead of directly referencing objects’ data in the object manager with memory pointers, our objects simply hold an index into the dynamic array where their data is stored. Essentially, we’re building our own <strong>memory address translation</strong> layer. This is a typical pattern in Rust for complex object graphs and cyclic data structures. When we need to access an object, we simply give the index to the object manager and get a mutable/immutable reference to that object’s data in return.</p>
<figure><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/object-manager.png" loading="lazy" alt="Object manager." width="100%"/><figcaption>
      <h4>Object manager.</h4>
    </figcaption>
</figure>

<p>One caveat when applying this pattern is ensuring that the index held by the objects is, in fact, pointing to a valid position within the dynamic array. In general, supporting data deletion is quite complex because we don’t know whether an item at a particular index is no longer in use. We may still have an index into the deleted position somewhere in our program if we’re not careful. Fortunately, we are building a GC, and within the confines of our VM, we know exactly when the object will no longer be accessible using mark-and-sweep!</p>
<h3 id="erm-ackchyually">erm… ackchyually</h3>
<p>With the “object manager” approach, haven’t we just solved the GC problem? Well, yes and no. While having an indirection is nice and easy to reason about, we lose lots of performance doing so.</p>
<ul>
<li>Every object access now requires at least two memory accesses to reach the data - one for the array and one for the data itself.</li>
<li>Array access in Rust always performs <strong>bounds-checking</strong>, leading to additional overheads.</li>
</ul>
<p>Besides the performance implications, this approach doesn’t return memory to the operating system. Unless we employ a much more complex strategy, we can’t shrink the dynamic array because of the indexing issue mentioned earlier. As a result, the GC only reclaims memory for reuse without actually reducing the program’s memory usage. Imagine a situation when we allocate a bunch of objects at the start of the program and then don’t use them. The large memory region is still being held until the program exits, even though it was “freed” by the GC.</p>
<h2 id="oii-speed-up">oii, speed up!</h2>
<figure><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/sanic.png" loading="lazy" alt="Sanic." width="100%"/><figcaption>
      <h4>Sanic.</h4>
    </figcaption>
</figure>

<p>What if we forget about “safety” and implement the GC exactly as described? How do we do that, then? Following the original C implementation, we can define the following structures:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(Debug)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>ptr</span>: <span>NonNull</span><span>&lt;</span><span>GcData</span><span>&lt;</span><span>T</span><span>&gt;&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>#[derive(Debug)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>GcData</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>marked</span>: <span>bool</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>next</span>: <span>Option</span><span>&lt;</span><span>Object</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>data</span>: <span>T</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Here, objects are just pointers to their data with no fancy reference counting or indirection. Object data simply contains two sections - its header containing metadata and its body containing actual information about the object. The type <code>Gc&lt;T&gt;</code> is just a simple wrapper around <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a> to indicate that the pointer is managed by our GC and provides some questionable <code>unsafe</code> implementation that makes our life a bit easier. Additionally, objects form a linked list, so the GC can easily traverse through all of them while cleaning up unreachable objects.</p>
<p>For those who don’t know, <code>NonNull&lt;T&gt;</code> is an abstraction for a <strong>raw pointer</strong> that is non-null and covariant. Don’t ask me about covariance since I honestly don’t know the answer. I recommend reading the section on <a href="https://doc.rust-lang.org/reference/subtyping.html">subtyping and variance</a> and <a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>. I went through them a few times but still don’t entirely get all the details.</p>
<p>Then, we can define each type of object like so:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>/// The content of a function object.
</span></span></span><span><span><span></span><span>#[derive(Debug)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>ObjFun</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// The name of the function.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>name</span>: <span>Option</span><span>&lt;</span><span>RefString</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>/// The number of parameters of the function.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>arity</span>: <span>u8</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>/// The number of upvalues captured by the function.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>upvalue_count</span>: <span>usize</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>/// The bytecode chunk of this function.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>chunk</span>: <span>Chunk</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>/// The content of a closure object.
</span></span></span><span><span><span></span><span>#[derive(Debug)]</span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>struct</span> <span>ObjClosure</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// The function definition of this closure.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fun</span>: <span>RefFun</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>/// The variables hoisted by this closure.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>upvalues</span>: <span>Vec</span><span>&lt;</span><span>RefUpvalue</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>/// A type alias for a heap-allocated function.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>type</span> <span>RefFun</span><span> </span><span>=</span><span> </span><span>Gc</span><span>&lt;</span><span>ObjFun</span><span>&gt;</span><span>;</span><span>
</span></span></span><span><span><span></span><span>/// A type alias for a heap-allocated closure.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>type</span> <span>RefClosure</span><span> </span><span>=</span><span> </span><span>Gc</span><span>&lt;</span><span>ObjClosure</span><span>&gt;</span><span>;</span><span>
</span></span></span></code></pre></div><p>Now, for the questionable parts:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>ops</span>::<span>Deref</span><span> </span><span>for</span><span> </span><span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>type</span> <span>Target</span><span> </span><span>=</span><span> </span><span>GcData</span><span>&lt;</span><span>T</span><span>&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>Self</span>::<span>Target</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>self</span><span>.</span><span>ptr</span><span>.</span><span>as_ref</span><span>()</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>ops</span>::<span>DerefMut</span><span> </span><span>for</span><span> </span><span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>deref_mut</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>mut</span><span> </span><span>Self</span>::<span>Target</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>self</span><span>.</span><span>ptr</span><span>.</span><span>as_mut</span><span>()</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>These two trait implementations define a way for Rust to dereference the pointers and access the data behind them. It’s questionable because <code>Deref</code> and <code>DerefMut</code> must not fail, and we cannot guarantee that. In addition, we cannot guarantee this won’t result in an <strong>undefined behavior</strong>. If we’re being rigorous, we must not implement these traits but instead provide a distinct method to <code>Gc&lt;T&gt;</code> for performing dereference and mark them as <code>unsafe</code>.</p>
<p>However, I would argue that it’s okay to do so because we only use <code>Gc&lt;T&gt;</code> within the VM to represent garbage-collected objects. With the GC guarantees that no object in use will be freed, we can always dereference the raw pointers in a “safe” manner. Any issue that arises, primarily <strong>dangling pointers</strong>, is a bug in our GC that causes the VM to malfunction regardless of how we represent an object.</p>
<p>Finally, we have a heap structure to manage all operations performed on the VM’s heap and provide a destructor for freeing all objects once the program finishes running.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>struct</span> <span>Heap</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Interned string table.
</span></span></span><span><span><span></span><span>    </span><span>strings</span>: <span>Table</span><span>&lt;</span><span>()</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>// The head of the linked list of heap-allocated objects.
</span></span></span><span><span><span></span><span>    </span><span>head</span>: <span>Option</span><span>&lt;</span><span>Object</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Heap</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// Allocates an object and returns its handle. The object is pushed to the front of
</span></span></span><span><span><span></span><span>    </span><span>/// the list of allocated objects.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>alloc</span><span>&lt;</span><span>T</span>: <span>GcSized</span><span>,</span><span> </span><span>F</span><span>&gt;</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>data</span>: <span>T</span><span>,</span><span> </span><span>map</span>: <span>F</span><span>)</span><span> </span>-&gt; <span>(</span><span>Object</span><span>,</span><span> </span><span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>where</span><span>
</span></span></span><span><span><span>        </span><span>F</span>: <span>Fn</span><span>(</span><span>Gc</span><span>&lt;</span><span>T</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>Object</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Interns a string and returns its handle. The same reference is returned for 2
</span></span></span><span><span><span></span><span>    </span><span>/// equal strings.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>intern</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>data</span>: <span>String</span><span>)</span><span> </span>-&gt; <span>RefString</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Releases all objects that aren&#39;t marked. This also removes interned strings
</span></span></span><span><span><span></span><span>    </span><span>/// when no object is referencing them.
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>unsafe</span><span> </span><span>fn</span> <span>sweep</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Deallocates an object.
</span></span></span><span><span><span></span><span>    </span><span>unsafe</span><span> </span><span>fn</span> <span>dealloc</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>object</span>: <span>Object</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Drop</span><span> </span><span>for</span><span> </span><span>Heap</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>for</span><span> </span><span>object</span><span> </span><span>in</span><span> </span><span>&amp;*</span><span>self</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>self</span><span>.</span><span>dealloc</span><span>(</span><span>object</span><span>)</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>        </span><span>debug_assert_eq!</span><span>(</span><span>0</span><span>,</span><span> </span><span>self</span><span>.</span><span>alloc_bytes</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>And we’re done. As for the actual GC implementation, I recommend reading the book and following along because it’s pretty straightforward. These Rust data structures are more or less one-to-one mappings of the C implementation, and there should be no trouble translating them.</p>
<h2 id="afterword">afterword</h2>
<div><pre tabindex="0"><code data-lang="kotlin"><span><span><span>{</span>
</span></span><span><span>  <span>var</span> <span>s</span> <span>=</span> <span>&#34;Hello, world!&#34;</span><span>;</span>
</span></span><span><span>  <span>fun</span> <span>helloWorld</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>print</span> <span>s</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>var</span> <span>f</span> <span>=</span> <span>helloWorld</span><span>;</span>
</span></span><span><span>  <span>f</span><span>();</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><figure><img src="https://www.tunglevo.com/note/crafting-interpreters-with-rust-on-garbage-collection/images/gc-memory.png" loading="lazy" alt="A Lox program and its memory at runtime (incorrect linked list order, but you get the idea)." width="100%"/><figcaption>
      <h4>A Lox program and its memory at runtime (incorrect linked list order, but you get the idea).</h4>
    </figcaption>
</figure>

<p>Implementing an interpreter is a fun project that anyone should try once. <a href="https://craftinginterpreters.com/">Crafting Interpreters</a> is one of the most impressive technical books I have ever read, and I would recommend it to anyone interested in the topic.</p>
<p>With Rust, I think we can agree that its memory model is unsuitable for creating a mark-and-sweep GC, and there are many different methods to overcome its limitations. The simplest way to achieve maximum performance is to ignore all Rust’s safety guarantees like the method I presented here. While there are better ways to go about it, it’s effortless to understand, especially when you have some experience with C or C++ and are following along the book. Excluding the GC, other components of the interpreter are actually quite easy to implement in Rust. Its excellent type system and capabilities make it very nice for the task.</p>
<p>One thing to keep in mind is that it’s feasible to utilize Rust’s type system to prove that the GC is safe. An intriguing approach I want to try at some point is utilizing <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin&lt;T&gt;</code></a> and carefully weaving the lifetime of rooted objects through our program to prove they’re safe for access. Such a strategy is described in this blog series on <a href="https://without.boats/tags/shifgrethor/">shifgrethor</a> and implemented in <a href="https://github.com/CeleritasCelery/rune">rune</a>. Furthermore, there are many more exciting developments in providing GC as a library in Rust, and all have been nicely summarized in <a href="https://manishearth.github.io/blog/2021/04/05/a-tour-of-safe-tracing-gc-designs-in-rust/">this article</a>.</p>
<p>With that, thanks for reading! To see more of the code, you can visit <a href="https://github.com/ltungv/rox">https://github.com/ltungv/rox</a>. If you’re interested, I keep a repository containing the old GC implementation using <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> at <a href="https://github.com/ltungv/lox">https://github.com/ltungv/lox</a>.</p>

</div></div>
  </body>
</html>
