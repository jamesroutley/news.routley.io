<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://svelte.dev/blog/runes">Original</a>
    <h1>Svelte 5: Runes</h1>
    
    <div id="readability-page-1" class="page"><div id="main"> <div><article> <p>Rethinking &#39;rethinking reactivity&#39;</p>    <!-- HTML_TAG_START --><p>In 2019, Svelte 3 turned JavaScript into a <a href="https://svelte.dev/blog/svelte-3-rethinking-reactivity">reactive language</a>. Svelte is a web UI framework that uses a compiler to turn declarative component code like this...</p>
<pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span>
<span><span>	</span><span>let</span><span> count </span><span>=</span><span> </span><span>0</span><span>;</span></span>
<span></span>
<span><span>	</span><span>function</span><span> </span><span>increment</span><span>() {</span></span>
<span><span>		count </span><span>+=</span><span> </span><span>1</span><span>;</span></span>
<span><span>	}</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span>
<span></span>
<span><span>&lt;</span><span>button</span><span> </span><span>on</span><span>:</span><span>click</span><span>=</span><span>{increment}&gt;</span></span>
<span><span>	clicks: {count}</span></span>
<span><span>&lt;/</span><span>button</span><span>&gt;</span></span></code></pre><p>...into tightly optimized JavaScript that updates the document when state like <code>count</code> changes. Because the compiler can &#39;see&#39; where <code>count</code> is referenced, the generated code is <a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">highly efficient</a>, and because we&#39;re hijacking syntax like <code>let</code> and <code>=</code> instead of using cumbersome APIs, you can <a href="https://svelte.dev/blog/write-less-code">write less code</a>.</p>
<p>A common piece of feedback we get is &#39;I wish I could write all my JavaScript like this&#39;. When you&#39;re used to things inside components magically updating, going back to boring old procedural code feels like going from colour to black-and-white.</p>
<p>Svelte 5 changes all that with <em>runes</em>, which unlock <em>universal, fine-grained reactivity</em>.</p>
<div>
<figure>
<p>
  <iframe src="https://www.youtube-nocookie.com/embed/RVnxF3j3N8U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

<figcaption>Introducing runes</figcaption>
</figure>
</div>

<h2 id="before-we-begin">Before we begin<a href="#before-we-begin"><span>permalink</span></a></h2><p>Even though we&#39;re changing how things work under the hood, Svelte 5 should be a drop-in replacement for almost everyone. The new features are opt-in — your existing components will continue to work.</p>
<p>We don&#39;t yet have a release date for Svelte 5. What we&#39;re showing you here is a work-in-progress that is likely to change!</p>
<h2 id="what-are-runes">What are runes?<a href="#what-are-runes"><span>permalink</span></a></h2><blockquote>
<p><strong>rune</strong> /ro͞on/ <em>noun</em></p>
<p>A letter or mark used as a mystical or magic symbol.</p>
</blockquote>
<p>Runes are symbols that influence the Svelte compiler. Whereas Svelte today uses <code>let</code>, <code>=</code>, the <a href="https://learn.svelte.dev/tutorial/declaring-props"><code>export</code></a> keyword and the <a href="https://learn.svelte.dev/tutorial/reactive-declarations"><code>$:</code></a> label to mean specific things, runes use <em>function syntax</em> to achieve the same things and more.</p>
<p>For example, to declare a piece of reactive state, we can use the <code>$state</code> rune:</p>
<pre><code>&lt;script&gt;
<span>	let count = 0;
</span><span>	let count = $state(0);
</span>
	function increment() {
		count += 1;
	}
&lt;/script&gt;

&lt;button on:click={increment}&gt;
	clicks: {count}
&lt;/button&gt;
</code></pre><p>At first glance, this might seem like a step back — perhaps even <a href="https://twitter.com/stolinski/status/1438173489479958536">un-Svelte-like</a>. Isn&#39;t it better if <code>let count</code> is reactive by default?</p>
<p>Well, no. The reality is that as applications grow in complexity, figuring out which values are reactive and which aren&#39;t can get tricky. And the heuristic only works for <code>let</code> declarations at the top level of a component, which can cause confusion. Having code behave one way inside <code>.svelte</code> files and another inside <code>.js</code> can make it hard to refactor code, for example if you need to turn something into a <a href="https://learn.svelte.dev/tutorial/writable-stores">store</a> so that you can use it in multiple places.</p>
<h2 id="beyond-components">Beyond components<a href="#beyond-components"><span>permalink</span></a></h2><p>With runes, reactivity extends beyond the boundaries of your <code>.svelte</code> files. Suppose we wanted to encapsulate our counter logic in a way that could be reused between components. Today, you would use a <a href="https://learn.svelte.dev/tutorial/custom-stores">custom store</a> in a <code>.js</code> or <code>.ts</code> file:</p>
<pre><p>ts</p><p><code><p><span>import</span><span> { <data-lsp lsp="(alias) function writable&amp;lt;T&gt;(value?: T | undefined, start?: StartStopNotifier&amp;lt;T&gt; | undefined): Writable&amp;lt;T&gt;&amp;#10;import writable">writable</data-lsp> } </span><span>from</span><span> </span><span>&#39;svelte/store&#39;</span><span>;</span></p><p><span>export</span><span> </span><span>function</span><span> </span><span><data-lsp lsp="function createCounter(): {&amp;#10;  subscribe: (this: void, run: Subscriber&amp;lt;number&gt;, invalidate?: Invalidator&amp;lt;number&gt; | undefined) =&gt; Unsubscriber;&amp;#10;  increment: () =&gt; void;&amp;#10;}">createCounter</data-lsp></span><span>() {</span></p><p><span>	</span><span>const</span><span> { </span><span><data-lsp lsp="const subscribe: (this: void, run: Subscriber&amp;lt;number&gt;, invalidate?: Invalidator&amp;lt;number&gt; | undefined) =&gt; Unsubscriber">subscribe</data-lsp></span><span>,</span><span> </span><span><data-lsp lsp="const update: (this: void, updater: Updater&amp;lt;number&gt;) =&gt; void">update</data-lsp></span><span> } </span><span>=</span><span> </span><span><data-lsp lsp="(alias) writable&amp;lt;number&gt;(value?: number | undefined, start?: StartStopNotifier&amp;lt;number&gt; | undefined): Writable&amp;lt;number&gt;&amp;#10;import writable">writable</data-lsp></span><span>(</span><span>0</span><span>);</span></p><p><span>	</span><span>return</span><span> {</span></p><p><span>		<data-lsp lsp="(property) subscribe: (this: void, run: Subscriber&amp;lt;number&gt;, invalidate?: Invalidator&amp;lt;number&gt; | undefined) =&gt; Unsubscriber">subscribe</data-lsp></span><span>,</span></p><p><span>		</span><span><data-lsp lsp="(property) increment: () =&gt; void">increment</data-lsp></span><span>:</span><span> () </span><span>=&gt;</span><span> </span><span><data-lsp lsp="const update: (this: void, updater: Updater&amp;lt;number&gt;) =&gt; void">update</data-lsp></span><span>((<data-lsp lsp="(parameter) n: number">n</data-lsp>) </span><span>=&gt;</span><span> <data-lsp lsp="(parameter) n: number">n</data-lsp> </span><span>+</span><span> </span><span>1</span><span>)</span></p><p><span>	};</span></p><p><span>}</span></p></code></p></pre><p>Because this implements the <em>store contract</em> — the returned value has a <code>subscribe</code> method — we can reference the store value by prefixing the store name with <code>$</code>:</p>
<pre><code>&lt;script&gt;
<span>	import { createCounter } from &#39;./counter.js&#39;;
</span><span>
</span><span>	const counter = createCounter();
</span><span>	let count = 0;
</span><span>
</span><span>	function increment() {
</span><span>		count += 1;
</span><span>	}
</span>&lt;/script&gt;

<span>&lt;button on:click={increment}&gt;
</span><span>	clicks: {count}
</span><span>&lt;button on:click={counter.increment}&gt;
</span><span>	clicks: {$counter}
</span>&lt;/button&gt;
</code></pre><p>This works, but it&#39;s pretty weird! We&#39;ve found that the store API can get rather unwieldy when you start doing more complex things.</p>
<p>With runes, things get much simpler:</p>
<pre><code><span>import { writable } from &#39;svelte/store&#39;;
</span>
export function createCounter() {
<span>	const { subscribe, update } = writable(0);
</span><span>	let count = $state(0);
</span>
	return {
<span>		subscribe,
</span><span>		increment: () =&gt; update((n) =&gt; n + 1)
</span><span>		get count() { return count },
</span><span>		increment: () =&gt; count += 1
</span>   };
}
</code></pre><pre><code>&lt;script&gt;
	import { createCounter } from &#39;./counter.js&#39;;

	const counter = createCounter();
&lt;/script&gt;

&lt;button on:click={counter.increment}&gt;
<span>	clicks: {$counter}
</span><span>	clicks: {counter.count}
</span>&lt;/button&gt;
</code></pre><p>Note that we&#39;re using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">get property</a> in the returned object, so that <code>counter.count</code> always refers to the current value rather than the value at the time the function was called.</p>
<h2 id="runtime-reactivity">Runtime reactivity<a href="#runtime-reactivity"><span>permalink</span></a></h2><p>Today, Svelte uses <em>compile-time reactivity</em>. This means that if you have some code that uses the <code>$:</code> label to re-run automatically when dependencies change, those dependencies are determined when Svelte compiles your component:</p>
<pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span>
<span><span>	</span><span>export</span><span> </span><span>let</span><span> width;</span></span>
<span><span>	</span><span>export</span><span> </span><span>let</span><span> height;</span></span>
<span></span>
<span><span>	</span><span>// the compiler knows it should recalculate `area`</span></span>
<span><span>	</span><span>// when either `width` or `height` change...</span></span>
<span><span>	$</span><span>:</span><span> area </span><span>=</span><span> width </span><span>*</span><span> height;</span></span>
<span></span>
<span><span>	</span><span>// ...and that it should log the value of `area`</span></span>
<span><span>	</span><span>// when _it_ changes</span></span>
<span><span>	$</span><span>:</span><span> </span><span>console</span><span>.log</span><span>(area);</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span></code></pre><p>This works well... until it doesn&#39;t. Suppose we refactored the code above:</p>
<pre><p>ts</p><p><code><p><span>const</span><span> </span><span><data-lsp lsp="const multiplyByHeight: (width: any) =&gt; number">multiplyByHeight</data-lsp></span><span> </span><span>=</span><span> (<data-err><data-lsp lsp="(parameter) width: any">width</data-lsp></data-err>) </span><span>=&gt;</span><span> <data-lsp lsp="(parameter) width: any">width</data-lsp> </span><span>*</span><span> <data-err><data-lsp lsp="any">height</data-lsp></data-err>;</span></p><span><span>Parameter &#39;width&#39; implicitly has an &#39;any&#39; type.</span><span>7006</span></span><span>Parameter &#39;width&#39; implicitly has an &#39;any&#39; type.</span><p><span>$</span><span>:</span><span> <data-err><data-lsp lsp="any">area</data-lsp></data-err> </span><span>=</span><span> </span><span><data-lsp lsp="const multiplyByHeight: (width: any) =&gt; number">multiplyByHeight</data-lsp></span><span>(<data-err><data-lsp lsp="any">width</data-lsp></data-err>);</span></p><span><span>Cannot find name &#39;area&#39;.</span><span>2304</span></span><span>Cannot find name &#39;area&#39;.</span></code></p></pre><p>Because the <code>$: area = ...</code> declaration can only &#39;see&#39; <code>width</code>, it won&#39;t be recalculated when <code>height</code> changes. As a result, code is hard to refactor, and understanding the intricacies of when Svelte chooses to update which values can become rather tricky beyond a certain level of complexity.</p>
<p>Svelte 5 introduces the <code>$derived</code> and <code>$effect</code> runes, which instead determine the dependencies of their expressions when they are evaluated:</p>
<pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span>
<span><span>	</span><span>let</span><span> { width</span><span>,</span><span> height } </span><span>=</span><span> $</span><span>props</span><span>(); </span><span>// instead of `export let`</span></span>
<span></span>
<span><span>	</span><span>const</span><span> </span><span>area</span><span> </span><span>=</span><span> $</span><span>derived</span><span>(width </span><span>*</span><span> height);</span></span>
<span></span>
<span><span>	$</span><span>effect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>		</span><span>console</span><span>.log</span><span>(area);</span></span>
<span><span>	});</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span></code></pre><p>As with <code>$state</code>, <code>$derived</code> and <code>$effect</code> can also be used in your <code>.js</code> and <code>.ts</code> files.</p>
<h2 id="signal-boost">Signal boost<a href="#signal-boost"><span>permalink</span></a></h2><p>Like every other framework, we&#39;ve come to the realisation that <a href="https://knockoutjs.com/">Knockout</a> was right all along.</p>
<p>Svelte 5&#39;s reactivity is powered by <em>signals</em>, which are essentially <a href="https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob">what Knockout was doing in 2010</a>. More recently, signals have been popularised by <a href="https://www.solidjs.com/">Solid</a> and adopted by a multitude of other frameworks.</p>
<p>We&#39;re doing things a bit differently though. In Svelte 5, signals are an under-the-hood implementation detail rather than something you interact with directly. As such, we don&#39;t have the same API design constraints, and can maximise both efficiency <em>and</em> ergonomics. For example, we avoid the type narrowing issues that arise when values are accessed by function call, and when compiling in server-side rendering mode we can ditch the signals altogether, since on the server they&#39;re nothing but overhead.</p>
<p>Signals unlock <em>fine-grained reactivity</em>, meaning that (for example) changes to a value inside a large list needn&#39;t invalidate all the <em>other</em> members of the list. As such, Svelte 5 is ridonkulously fast.</p>
<h2 id="simpler-times-ahead">Simpler times ahead<a href="#simpler-times-ahead"><span>permalink</span></a></h2><p>Runes are an additive feature, but they make a whole bunch of existing concepts obsolete:</p>
<ul>
<li>the difference between <code>let</code> at the top level of a component and everywhere else</li>
<li><code>export let</code></li>
<li><code>$:</code>, with all its attendant quirks</li>
<li>different behaviour between <code>&lt;script&gt;</code> and <code>&lt;script context=&#34;module&#34;&gt;</code></li>
<li>the store API, parts of which are genuinely quite complicated</li>
<li>the <code>$</code> store prefix</li>
<li><code>$$props</code> and <code>$$restProps</code></li>
<li>lifecycle functions (things like <code>onMount</code> can just be <code>$effect</code> functions)</li>
</ul>
<p>For those of you who already use Svelte, it&#39;s new stuff to learn, albeit hopefully stuff that makes your Svelte apps easier to build and maintain. But newcomers won&#39;t need to learn all those things — it&#39;ll just be in a section of the docs titled &#39;old stuff&#39;.</p>
<p>This is just the beginning though. We have a long list of ideas for subsequent releases that will make Svelte simpler and more capable.</p>
<h2 id="try-it">Try it!<a href="#try-it"><span>permalink</span></a></h2><p>You can&#39;t use Svelte 5 in production yet. We&#39;re in the thick of it at the moment and can&#39;t tell you when it&#39;ll be ready to use in your apps.</p>
<p>But we didn&#39;t want to leave you hanging. We&#39;ve created a <a href="https://svelte-5-preview.vercel.app">preview site</a> with detailed explanations of the new features and an interactive playground. You can also visit the <code>#svelte-5-runes</code> channel of the <a href="https://svelte.dev/chat">Svelte Discord</a> to learn more. We&#39;d love to have your feedback!</p>
<!-- HTML_TAG_END --></article></div>  </div></div>
  </body>
</html>
