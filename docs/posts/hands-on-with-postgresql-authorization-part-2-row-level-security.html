<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tangramvision.com/blog/hands-on-with-postgresql-authorization-part-2-row-level-security">Original</a>
    <h1>Hands-On with PostgreSQL Authorization ‚Äì Part 2 ‚Äì Row-Level Security</h1>
    
    <div id="readability-page-1" class="page"><div><p>Welcome to another exploration of PostgreSQL‚Äôs authorization tools! If you‚Äôre interested in why you might want to learn about or use PostgreSQL authorization, check out [the first couple sections of the first article](https://www.tangramvision.com/blog/hands-on-with-postgresql-authorization-part-1-roles-and-grants). Here‚Äôs where we are in the series:</p><p>1. [Roles and Grants](https://www.tangramvision.com/blog/hands-on-with-postgresql-authorization-part-1-roles-and-grants)</p><p>In the [first article](https://www.tangramvision.com/blog/hands-on-with-postgresql-authorization-part-1-roles-and-grants), we looked into how database roles and granted privileges can be used to control what database objects (e.g. tables, views, functions) can be accessed and modified (with SELECT, INSERT, UPDATE, and DELETE queries) by different users. That article ended with a bit of a cliffhanger: if you build a multi-user application using only roles and GRANTs for authorization, then your users will be able to delete each others‚Äô data or even delete each other! We need another mechanism to limit users to reading and mutating only their own data ‚Äî that mechanism is [row-level security (RLS) policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html).</p><p>In this article, we‚Äôll use an example-driven approach to dive into the basics of understanding and using RLS policies.</p><p>## Hands-On With an Example Schema</p><p>The best way to understand RLS is to use it! We‚Äôll continue using the previous article‚Äôs database schema, roles, and privilege grants (with the addition of a new ‚Äúsongs‚Äù table) ‚Äî we‚Äôre modeling an example app akin to [Bandcamp](https://bandcamp.com/), where musical artists can publish albums and songs and fans can discover and follow artists.</p><p>![Sample schema relating musical artists, albums, songs, and followers (fans).](https://uploads-ssl.webflow.com/5fff85e7f613e35edb5806ed/62320b68af53d202a2812373_blog-postgres-authz-2-schema-v2.png)</p><p>You can follow along using Docker and the [schema](https://gitlab.com/tangram-vision/oss/tangram-visions-blog/-/blob/main/2022.03.16_PostgreSQLAuthorizationRowLevelSecurity/schema.sql) at: [https://gitlab.com/tangram-vision/oss/tangram-visions-blog/-/tree/main/2022.03.16_PostgreSQLAuthorizationRowLevelSecurity](https://gitlab.com/tangram-vision/oss/tangram-visions-blog/-/tree/main/2022.03.16_PostgreSQLAuthorizationRowLevelSecurity)</p><p>As described in the repo&#39;s README, you can run the command below, which uses the [official Postgres Docker image](https://hub.docker.com/_/postgres) to run a PostgreSQL database locally. The first volume mount will load the `schema.sql` file, which will populate your database with the tables diagrammed above.</p><p>```bash</p><p>To open a `psql` prompt in that container, run the following in another terminal:</p><p>```bash</p><p>## Row-Level Security</p><p>What is [Row-Level Security](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) (RLS)? It‚Äôs a way for PostgreSQL to limit what *rows* of a table are visible to a query. Typically, if you `SELECT * FROM mytable` then PostgreSQL will return all the columns and all the rows from the table. With Row-Level Security enabled on the table, PostgreSQL won‚Äôt return *any* rows (unless you‚Äôre querying from a database role that is a superuser, the owner of the table, or has the [BYPASSRLS option](https://www.postgresql.org/docs/current/sql-createrole.html)).</p><p>### Basic Policies</p><p>In order to return rows from a table with RLS enabled, we need to write a [policy](https://www.postgresql.org/docs/current/sql-createpolicy.html). Policies use an SQL expression (returning a boolean result) that is evaluated for every row in the table, which determines which rows are accessible to the user submitting the query. Policies can apply to specific roles and/or specific commands (e.g. SELECT, INSERT, ...).</p><p>As a first, simple example, let‚Äôs add some data to our database and enable row-level security on a table:</p><p>```sql</p><p>-- Switch to the artist role (so we&#39;re not querying from a superuser role, which</p><p>=&gt; SELECT * FROM artists;</p><p>-- Switch to the postgres superuser to enable RLS on the artists table</p><p>-- Now we don&#39;t see any rows! RLS hides all rows if no policies are declared on</p><p>Now, let‚Äôs try out a couple basic RLS policies:</p><p>```sql</p><p>-- The expression &#34;true&#34; is true for all rows, so all rows are visible.</p><p>-- Let&#39;s change the policy to use an expression that depends on a value in the</p><p>-- Now, we see that only 1 row passes the policy&#39;s test.</p><p>### Policies Based on the Querying User</p><p>Let‚Äôs get a little more realistic: we want artists to be able to change their own name and be unable to change other artists‚Äô names. To model this situation, we need to know the artist identity that is querying the database ‚Äî issuing queries from a generic ‚Äúartist‚Äù role (as in the above examples) doesn‚Äôt give us enough information. One way to assume a specific identity within the ‚Äúartist‚Äù role/group is to create another database role and make it a member of the ‚Äúartist‚Äù role:</p><p>```sql</p><p>Now, if you log into the database as ‚Äúartist:1‚Äù, then you‚Äôll have all the same privileges as the ‚Äúartist‚Äù group. By using specific, single-user logins (and corresponding usernames), we can write a policy that uses the user name to identify which rows in the database belong to that user.</p><p>```sql</p><p>-- We create an RLS policy specific to the &#34;artist&#34; role/group and the UPDATE</p><p>=# SET ROLE &#34;artist:1&#34;;</p><p>-- Trying to update a row that no policy gives us access to simply results in no</p><p>We successfully implemented permissions that allow an artist to update their name and nobody else‚Äôs! This example also introduced:</p><p>- Limiting a policy to a specific command (e.g. SELECT, UPDATE)</p><p>By default, policies apply to all commands and to all roles. If a query is issued and there is no policy with matching command and role, then no policies apply and no rows will be visible or affected by the query.</p><p>&gt; üí° You may see that `artist_id = substr(current_user, 8)::int` expression in the update policy and frown a bit or raise an eyebrow. If so, good! This example was written to be (hopefully) easy to follow, but in a real app you probably wouldn‚Äôt want to use usernames that are a string-concatenation of the role/group name with an ID, because then you have tightly-coupled pieces of data that require string operations to extract every time you need them! A better approach might be to log in with a UUID username, which keys into a ‚Äúusers‚Äù table that ‚Äúfans‚Äù and ‚Äúartists‚Äù tables join to. There are a few different ways to design database usernames and tie them into RLS policies, which we may explore in a future article.</p><p>### Policies That Span Tables</p><p>Let‚Äôs take it one step further! We want artists to be able to create/edit/delete albums (but only their own!) and create/edit/delete songs on those albums. The USING expression in RLS policies can contain any SQL expression, so we can use foreign-key relationships in our data model to span tables when checking permissions.</p><p>```sql</p><p>-- Limit create/edit/delete of albums to the &#34;owning&#34; artist.</p><p>-- Add a Missy Elliott (artist_id=3) album (album_id=1) for testing below</p><p>-- Change to the user account corresponding to the artist TWRP (artist_id=1)</p><p>-- Trying to add an album to another artist fails the RLS policy</p><p>-- Trying to add a song to Missy Elliott&#39;s album fails the RLS policy</p><p>The notable piece of the above is the policy on the ‚Äúsongs‚Äù table. When we issue an INSERT, UPDATE, or DELETE command on that table, the RLS policy ensures that we can only insert, modify, or delete songs in an album associated with the artist issuing the query.</p><p>We used an EXISTS subquery for the USING expression in the ‚Äúsongs‚Äù table‚Äôs policy above, but there are a variety of ways that permission could be implemented. Which way is most performant? Great question! We‚Äôll dig deeper into that in the ‚ÄúPerformance of Row-Level Security‚Äù article later in this series (make sure to [subscribe to our newsletter](https://buildwith.tangramrobotics.com/newsletter) or [blog RSS](https://www.tangramvision.com/blog/rss.xml) to get notified).</p><p>### Interactions of Multiple Policies</p><p>We‚Äôve seen that policies can apply:</p><p>- to all commands (the default) or specific commands (SELECT, INSERT, UPDATE, DELETE)</p><p>but one more critical aspect of how RLS policies work is how multiple policies can be combined. Policies can interact in two main ways:</p><p>- A table can have multiple policies</p><p>**Tables with Multiple Policies**</p><p>When a table has multiple policies, pay attention to whether the policies are declared as PERMISSIVE (the default) or RESTRICTIVE. A PERMISSIVE policy must exist on a table for any rows to be accessible. If there are multiple PERMISSIVE policies, a row is accessible if *any* PERMISSIVE policy evaluates to true. On the other hand, RESTRICTIVE policies must *all* evaluate to true for a row to be accessible. We can explore this behavior by adding a new feature to our sample app ‚Äî we want to allow artists to create albums with a future release date, but only the owning artist should be able to see these not-yet-released albums.</p><p>```sql</p><p>-- For fans: restrict visibility to albums with a release date in the past.</p><p>-- For artists: restrict visibility to albums with a release date in the past,</p><p>By combining a PERMISSIVE policy and RESTRICTIVE policies targeting different roles (fans and artists), we‚Äôve made future-release albums visible only to the owning artist. Arguably, a better way to represent this logic would be to use only PERMISSIVE policies, as follows:</p><p>```sql</p><p>-- Reminder: We previously created an affect_own_albums policy on albums that</p><p>Now, the `viewable_by_all` policy lets everyone see albums with a release date in the past, and the `affect_own_albums` policy lets artists do anything (SELECT, INSERT, etc.) to albums they own.</p><p>**Querying Other Tables with Their Own Policies**</p><p>The other way that multiple policies can interact is when a policy‚Äôs USING expression queries another table that has its own policy. In our sample app, we can use the policy on the albums table to determine whether the songs in that album should be visible:</p><p>```sql</p><p>Finally, let‚Äôs test out our new policies to make sure that the correct roles/groups see (or cannot see!) albums with future release dates and their songs.</p><p>```sql</p><p>-- Test that the owning artist (artist:1) can see future albums and songs, but</p><p>=&gt; SELECT * FROM songs;</p><p>=&gt; SET ROLE fan;</p><p>=&gt; SELECT * FROM songs;</p><p>=&gt; SET ROLE &#34;artist:2&#34;;</p><p>=&gt; SELECT * FROM songs;</p><p>Success! We‚Äôll conclude this overview of Row-Level Security in PostgreSQL here; there‚Äôs lots more to learn (check out the docs on [Row Security Policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) and the [CREATE POLICY](https://www.postgresql.org/docs/current/sql-createpolicy.html) command), but we‚Äôve covered the basics. So far, I‚Äôve left a big question unanswered: what are the performance implications of using policies, especially when they contain complex USING expressions (e.g. querying other tables, using joins, calling functions)? We‚Äôll dig into that question in the next article!</p><p>---</p><p>Thanks for reading! I hope you learned something new and will return for the next article in the series. If you have any corrections to this article or suggestions/questions for future articles, please [let me know](mailto:greg.schafer@tangramvision.com) or [send us a tweet](https://www.twitter.com/tangramvision), and if you‚Äôre curious to learn more about how we improve perception sensors, visit us at [Tangram Vision](https://www.tangramvision.com/).</p><p>‚Äç</p></div></div>
  </body>
</html>
