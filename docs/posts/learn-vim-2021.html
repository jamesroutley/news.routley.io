<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/iggredible/Learn-Vim">Original</a>
    <h1>Learn Vim (2021)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody" id="content"><p>Recently, I wondered <a href="https://capnfabs.net/posts/lowercase-dot-mp3/">whether songs were being increasingly released with entirely lowercase titles</a>. I ended up using <a href="https://musicbrainz.org/doc/MusicBrainz_Database">MusicBrainz’ library as a datasource</a>, which comes packaged up as a Postgres database, but the data source I considered initially was one of <a href="https://www.discogs.com/developers/#">Discogs’ monthly data dumps</a>, which is made available for download as a set of (gzipped) XML files. The file I was interested in – the <code>releases</code> dataset – is 11.62 GB gzipped, 74 GB once decompressed. I wanted to iterate through every record and check for (a) entry quality, and (b) whether the track title was lowercase. Normally I’d use some kind of serialization framework, gesture at the shape of data, and then tell the framework to deserialize the whole object, but - that’s not an option when the file you’re working with is several times the RAM on your computer.</p><p>When you’re writing a deserializer and your file size is too big, the standard advice is to switch the deserializer into a “streaming” mode – the deserializer will tell you things like:</p><ul><li>here is a starting tag</li><li>here is an ending tag</li><li>here is a comment</li></ul><p>… but this is significantly less ergonomic than being able to load the object into memory and then just access struct fields directly, especially once there’s several layers of nesting involved! One approach to handling a setup like this is to roll-your-own state machine, but I personally find complex state machines difficult to write and think about.</p><p>The data file in question has one top level <code>&lt;releases&gt;</code> tag, which contains something like 16 million <code>&lt;release&gt;</code> tags, each of which contains metadata, and a bundle of <code>&lt;tracks&gt;</code>.</p><p>Something like this:</p><div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;releases&gt;</span>
</span></span><span><span>  <span>&lt;release</span> <span>id=</span><span>&#34;769&#34;</span> <span>status=</span><span>&#34;Accepted&#34;</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;images&gt;</span>...<span>&lt;/images&gt;</span>
</span></span><span><span>    <span>&lt;artists&gt;</span>
</span></span><span><span>     <span>&lt;artist&gt;</span>
</span></span><span><span>       <span>&lt;id&gt;</span>194<span>&lt;/id&gt;</span>
</span></span><span><span>       <span>&lt;name&gt;</span>Various<span>&lt;/name&gt;</span>
</span></span><span><span>       <span>&lt;anv/&gt;</span>
</span></span><span><span>       <span>&lt;join/&gt;</span>
</span></span><span><span>       <span>&lt;role/&gt;</span>
</span></span><span><span>       <span>&lt;tracks/&gt;</span>
</span></span><span><span>     <span>&lt;/artist&gt;</span>
</span></span><span><span>    <span>&lt;/artists&gt;</span>
</span></span><span><span>    <span>&lt;title&gt;</span>Hi-Fidelity House Imprint One<span>&lt;/title&gt;</span>
</span></span><span><span>    ...
</span></span><span><span>  <span>&lt;/release&gt;</span>
</span></span><span><span>  ... 18 million times
</span></span><span><span><span>&lt;/releases&gt;</span>
</span></span></code></pre></div><p>Each release is probably only a few kB in size (74 GB / 16 million releases); so the problematic part is the huge number of <code>&lt;release&gt;</code> entities. Maybe we can stream the <code>&lt;release&gt;</code>s, and then use a deserialization framework on the individual records that they’re more convenient to work with?</p><p>I ended up implementing a hybrid approach like this after googling around for a while and finding nothing. I’m documenting it here in the hope that it’s useful to you, dear Reader, for your esoteric large XML parsing tasks.</p><h2 id="first-attempt-try-it-in-python">First attempt: try it in Python</h2><p>Initially, I wrote this in Python. Python’s great for quick-and-dirty data parsing: I think it took around 20 minutes to write this code.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span>import</span> <span>argparse</span>
</span></span><span><span><span>import</span> <span>gzip</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>bs4</span>
</span></span><span><span><span>from</span> <span>lxml</span> <span>import</span> <span>etree</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>process_release</span><span>(</span><span>release</span><span>):</span>
</span></span><span><span>    <span># parse into something nice</span>
</span></span><span><span>    <span>soup</span> <span>=</span> <span>bs4</span><span>.</span><span>BeautifulSoup</span><span>(</span>
</span></span><span><span>        <span>etree</span><span>.</span><span>tostring</span><span>(</span><span>release</span><span>),</span>
</span></span><span><span>        <span>features</span><span>=</span><span>&#39;lxml-xml&#39;</span><span>,</span>
</span></span><span><span>    <span>)</span>
</span></span><span><span>    <span>return</span> <span>todo_arbitrary_business_logic</span><span>(</span><span>soup</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>main</span><span>():</span>
</span></span><span><span>    <span># get filename from command line</span>
</span></span><span><span>    <span>argparser</span> <span>=</span> <span>argparse</span><span>.</span><span>ArgumentParser</span><span>()</span>
</span></span><span><span>    <span>argparser</span><span>.</span><span>add_argument</span><span>(</span><span>&#34;--file&#34;</span><span>)</span>
</span></span><span><span>    <span>args</span> <span>=</span> <span>argparser</span><span>.</span><span>parse_args</span><span>()</span>
</span></span><span><span>    <span>filepath</span> <span>=</span> <span>args</span><span>.</span><span>file</span>
</span></span><span><span>
</span></span><span><span>    <span># stream the compressed file so we don&#39;t have to unpack it</span>
</span></span><span><span>    <span>f</span> <span>=</span> <span>gzip</span><span>.</span><span>open</span><span>(</span><span>filepath</span><span>)</span>
</span></span><span><span>    <span># iterate through &#39;release&#39; tags</span>
</span></span><span><span>    <span>context</span> <span>=</span> <span>etree</span><span>.</span><span>iterparse</span><span>(</span><span>f</span><span>,</span> <span>tag</span><span>=</span><span>(</span><span>&#39;release&#39;</span><span>,))</span>
</span></span><span><span>    <span>for</span> <span>_action</span><span>,</span> <span>element</span> <span>in</span> <span>context</span><span>:</span>
</span></span><span><span>        <span>results</span> <span>=</span> <span>process_release</span><span>(</span><span>element</span><span>)</span>
</span></span><span><span>        <span>todo_collate_results</span><span>(</span><span>results</span><span>)</span>
</span></span><span><span>        <span># release memory</span>
</span></span><span><span>        <span>element</span><span>.</span><span>clear</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
</span></span><span><span>    <span>main</span><span>()</span>
</span></span></code></pre></div><p>Unfortunately – Python’s also slow. I was watching the process in the activity monitor, and keeping an eye on how much data it had read from disk to get a sense for progress – and after around an hour it had processed around 10% of the file. I was 99% sure that the code wouldn’t be correct immediately, and didn’t want to have a ten hour iteration time, so something needed to change. Maybe I should unzip the file ahead of time, i.e. maybe the unzipping is the slow bit? That doesn’t sound right; the <a href="https://docs.python.org/3/library/gzip.html">gzip code</a> looks like it calls into native code<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>I guess I could parallelise the code? My computer’s got 8 cores, so maybe if I split the file into 8 pieces I could parse them all at the same time. The python script had been sitting at 100% CPU the whole time, meaning that the job was definitely <a href="https://en.wikipedia.org/wiki/CPU-bound">CPU-bound</a> and not I/O-bound, so parallelisation would probably help. But then I’d also have to figure out how to split a huge XML file into eight pieces, and there’s no good tools to do that easily, so I’d have to write a program… and I can probably get <em>that</em> correct in one go but then I’ve still gotta wait for a long time. Hmm.</p><p>Maybe let’s try rewriting in Rust?</p><h2 id="a-rewrite-in-rust">A rewrite in Rust</h2><p>It took a <em>lot</em> longer to write equivalent Rust code (~ 2 hours). I stumbled across <a href="https://crates.io/crates/quick-xml">quick-xml</a> pretty quickly, and it works with <a href="https://crates.io/crates/serde">serde</a>, the classic Rust deserialization framework. But Rust is verbose and boilerplatey, and it can sometimes be hard to wrap your head around the abstractions that library authors choose.</p><p>After some googling, I found:</p><ul><li>someone had opened a GitHub issue asking <a href="https://github.com/tafia/quick-xml/issues/165">exactly how to do this</a>, even before <code>quick-xml</code> had <code>serde</code> support. There’s mention in there about exactly my use case – switching from streaming to deserialization at a certain point – but the changes to make that possible don’t appear to have landed.</li><li>someone else had <a href="https://usethe.computer/posts/14-xmhell.html">parsed a 38GB XML file with a full-blown state machine</a> – there is a state diagram in there and it is making my head spin.</li></ul><p>What I wanted to do was:</p><ul><li>Stream events to collect all the bytes that make up a <code>release</code></li><li>Parse that using serde to get a nice convenient datastructure.</li></ul><p>Here’s the solution I landed on:</p><div><pre tabindex="0"><code data-lang="rs"><span><span><span>fn</span> <span>main</span><span>()</span><span> </span>-&gt; <span>std</span>::<span>io</span>::<span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>// open file
</span></span></span><span><span><span></span><span>  </span><span>let</span><span> </span><span>args</span>: <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>env</span>::<span>args</span><span>().</span><span>collect</span><span>();</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>file_path</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>args</span><span>[</span><span>1</span><span>];</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>file</span><span> </span><span>=</span><span> </span><span>File</span>::<span>open</span><span>(</span><span>file_path</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>gz</span><span> </span><span>=</span><span> </span><span>BufReader</span>::<span>new</span><span>(</span><span>GzDecoder</span>::<span>new</span><span>(</span><span>BufReader</span>::<span>new</span><span>(</span><span>&amp;</span><span>file</span><span>)));</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>reader</span><span> </span><span>=</span><span> </span><span>Reader</span>::<span>from_reader</span><span>(</span><span>gz</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>junk_buf</span>: <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>count</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>stats</span><span> </span><span>=</span><span> </span><span>HashMap</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// streaming code
</span></span></span><span><span><span></span><span>  </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>reader</span><span>.</span><span>read_event_into</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>buf</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span><span>Err</span><span>(</span><span>e</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>panic!</span><span>(</span><span>
</span></span></span><span><span><span>        </span><span>&#34;Error at position {}: {:?}&#34;</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>reader</span><span>.</span><span>buffer_position</span><span>(),</span><span>
</span></span></span><span><span><span>        </span><span>e</span><span>
</span></span></span><span><span><span>      </span><span>),</span><span>
</span></span></span><span><span><span>      </span><span>Ok</span><span>(</span><span>Event</span>::<span>Eof</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>break</span><span>,</span><span>
</span></span></span><span><span><span>      </span><span>Ok</span><span>(</span><span>Event</span>::<span>Start</span><span>(</span><span>e</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>match</span><span> </span><span>e</span><span>.</span><span>name</span><span>().</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>          </span><span>b&#34;release&#34;</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>// load entire tag into buffer
</span></span></span><span><span><span></span><span>            </span><span>let</span><span> </span><span>release_bytes</span><span> </span><span>=</span><span> </span><span>read_to_end_into_buffer</span><span>(</span><span>
</span></span></span><span><span><span>              </span><span>&amp;</span><span>mut</span><span> </span><span>reader</span><span>,</span><span>
</span></span></span><span><span><span>              </span><span>&amp;</span><span>e</span><span>,</span><span>
</span></span></span><span><span><span>              </span><span>&amp;</span><span>mut</span><span> </span><span>junk_buf</span><span>
</span></span></span><span><span><span>            </span><span>).</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>std</span>::<span>str</span>::<span>from_utf8</span><span>(</span><span>&amp;</span><span>release_bytes</span><span>)</span><span>
</span></span></span><span><span><span>              </span><span>.</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>            </span><span>// deserialize from buffer
</span></span></span><span><span><span></span><span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>deserializer</span><span> </span><span>=</span><span> </span><span>Deserializer</span>::<span>from_str</span><span>(</span><span>str</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span><span>release</span><span> </span><span>=</span><span> </span><span>Release</span>::<span>deserialize</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>deserializer</span><span>)</span><span>
</span></span></span><span><span><span>              </span><span>.</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>            </span><span>// &#34;business&#34; &#34;logic&#34;
</span></span></span><span><span><span></span><span>            </span><span>todo_process_release</span><span>(</span><span>&amp;</span><span>release</span><span>,</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>stats</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>count</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>            </span><span>if</span><span> </span><span>count</span><span> </span><span>%</span><span> </span><span>1_000_000</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>              </span><span>println!</span><span>(</span><span>&#34;checked {} records&#34;</span><span>,</span><span> </span><span>count</span><span>);</span><span>
</span></span></span><span><span><span>            </span><span>}</span><span>
</span></span></span><span><span><span>          </span><span>}</span><span>
</span></span></span><span><span><span>          </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>(),</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>      </span><span>}</span><span>
</span></span></span><span><span><span>      </span><span>// Other Events are not important for us
</span></span></span><span><span><span></span><span>      </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>(),</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>// clear buffer to prevent memory leak
</span></span></span><span><span><span></span><span>    </span><span>buf</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>  </span><span>}</span><span>
</span></span></span><span><span><span>  </span><span>todo_print_results</span><span>(</span><span>&amp;</span><span>stats</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>Result</span>::<span>Ok</span><span>(())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The real trick is in that <code>read_to_end_into_buffer</code> method, which I copy-pasted from the quick-xml <a href="https://docs.rs/quick-xml/0.27.1/quick_xml/reader/struct.Reader.html#method.read_to_end"><code>read_to_end</code></a> method and modified. It’s basically a passthrough: it keeps reading elements til it hits the corresponding end tag, writes them all out to a buffer, and then returns the buffer. It’s worth noting that this isn’t efficient: we’re copying bytes out of the file into memory, and then presumably copying them around again into the data struct - but it’s maybe fast enough?</p><div><pre tabindex="0"><code data-lang="rs"><span><span><span>// reads from a start tag all the way to the corresponding end tag,
</span></span></span><span><span><span>// returns the bytes of the whole tag
</span></span></span><span><span><span></span><span>fn</span> <span>read_to_end_into_buffer</span><span>&lt;</span><span>R</span>: <span>BufRead</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>  </span><span>reader</span>: <span>&amp;</span><span>mut</span><span> </span><span>Reader</span><span>&lt;</span><span>R</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>start_tag</span>: <span>&amp;</span><span>BytesStart</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>junk_buf</span>: <span>&amp;</span><span>mut</span><span> </span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span><span> </span><span>quick_xml</span>::<span>Error</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>depth</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>output_buf</span>: <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>w</span><span> </span><span>=</span><span> </span><span>Writer</span>::<span>new</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>output_buf</span><span>);</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>tag_name</span><span> </span><span>=</span><span> </span><span>start_tag</span><span>.</span><span>name</span><span>();</span><span>
</span></span></span><span><span><span>  </span><span>w</span><span>.</span><span>write_event</span><span>(</span><span>Event</span>::<span>Start</span><span>(</span><span>start_tag</span><span>.</span><span>clone</span><span>()))</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>  </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span><span>junk_buf</span><span>.</span><span>clear</span><span>();</span><span>
</span></span></span><span><span><span>      </span><span>let</span><span> </span><span>event</span><span> </span><span>=</span><span> </span><span>reader</span><span>.</span><span>read_event_into</span><span>(</span><span>junk_buf</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>      </span><span>w</span><span>.</span><span>write_event</span><span>(</span><span>&amp;</span><span>event</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>      </span><span>match</span><span> </span><span>event</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>          </span><span>Event</span>::<span>Start</span><span>(</span><span>e</span><span>)</span><span> </span><span>if</span><span> </span><span>e</span><span>.</span><span>name</span><span>()</span><span> </span><span>==</span><span> </span><span>tag_name</span><span> </span><span>=&gt;</span><span> </span><span>depth</span><span> </span><span>+=</span><span> </span><span>1</span><span>,</span><span>
</span></span></span><span><span><span>          </span><span>Event</span>::<span>End</span><span>(</span><span>e</span><span>)</span><span> </span><span>if</span><span> </span><span>e</span><span>.</span><span>name</span><span>()</span><span> </span><span>==</span><span> </span><span>tag_name</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>              </span><span>if</span><span> </span><span>depth</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>                  </span><span>return</span><span> </span><span>Ok</span><span>(</span><span>output_buf</span><span>);</span><span>
</span></span></span><span><span><span>              </span><span>}</span><span>
</span></span></span><span><span><span>              </span><span>depth</span><span> </span><span>-=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>          </span><span>}</span><span>
</span></span></span><span><span><span>          </span><span>Event</span>::<span>Eof</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>              </span><span>panic!</span><span>(</span><span>&#34;oh no&#34;</span><span>)</span><span>
</span></span></span><span><span><span>          </span><span>}</span><span>
</span></span></span><span><span><span>          </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>{}</span><span>
</span></span></span><span><span><span>      </span><span>}</span><span>
</span></span></span><span><span><span>  </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Ok so: as you can see, a lot more fiddling, and a lot more code. How fast does it go?</p><pre tabindex="0"><code>time cargo run --release ~/Downloads/discogs_20230101_releases.xml.gz
    Finished release [optimized] target(s) in 0.01s
     Running `target/release/main /Users/fabian/Downloads/discogs_202
        30101_releases.xml.gz`
checked 1000000 records
checked 2000000 records
...
cargo run --release ~/Downloads/discogs_20230101_releases.xml.gz
  659.70s user 10.99s system 99% cpu 11:12.32 total
</code></pre><p>Wowweeee that’s <em>so</em> much better! We’re still clearly CPU bound:</p><figure><img src="https://capnfabs.net/posts/parsing-huge-xml-quickxml-rust-serde/cpubound2.png" alt="If my computer had fans you would definitely be able to hear them right about now"/><figcaption><p>If my computer had fans you would <em>definitely</em> be able to hear them right about now</p></figcaption></figure><p>… but eleven minutes instead of 10 hours is still a 55x performance boost. Not bad!</p><h2 id="rust-is-pretty-good-for-tasks-like-this">Rust is pretty good for tasks like this!</h2><p>Rust has a real steep learning curve in general, and it definitely takes longer to write than python, even when you’re experienced. But it’s a pretty good candidate for tasks like this once you’ve got the hang of it! I think this task would’ve been significantly easier if a method to read the entire tag content into the buffer existed in the quick-xml library, though <a href="https://github.com/tafia/quick-xml/issues/165#issue-483628334">the discussion on that issue I mentioned earlier</a> makes me wonder if the better solution would be to add a method which constructs a deserializer from a <code>StartEvent</code> and the input stream<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p><p>If you’re also trying to parse extremely large XML files (whyyyyyy???), feel free to <a href="https://github.com/capnfabs/trackscan">lift my code from Github</a>, and if you figure out how to do the tricky solution without the string copies, <a href="https://capnfabs.net/contact/">let me know</a>!</p><div role="doc-endnotes"><hr/><ol><li id="fn:1"><p>I didn’t test this assumption at the time, but upon googling there are a bunch of people complaining about gzip being slower in python than on the command line. <a href="#fnref:1" role="doc-backlink">↩︎</a></p></li><li id="fn:2"><p>I’ve also spent the last 30 minutes wondering if the solution was right in front of my eyes the whole time; the people on that thread got so close to solving my exact problem that it’s uncanny 😅 <a href="#fnref:2" role="doc-backlink">↩︎</a></p></li></ol></div></div></div>
  </body>
</html>
