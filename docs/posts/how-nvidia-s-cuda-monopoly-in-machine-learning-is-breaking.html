<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.semianalysis.com/p/nvidiaopenaitritonpytorch">Original</a>
    <h1>How Nvidia’s CUDA Monopoly in Machine Learning Is Breaking</h1>
    
    <div id="readability-page-1" class="page"><div><div dir="auto"><p>Over the last decade, the landscape of machine learning software development has undergone significant changes. Many frameworks have come and gone, but most have relied heavily on leveraging Nvidia&#39;s CUDA and performed best on Nvidia GPUs. However, with the arrival of PyTorch 2.0 and OpenAI&#39;s Triton, Nvidia&#39;s dominant position in this field, mainly due to its software moat, is being disrupted.</p><p>This report will touch on topics such as why Google’s TensorFlow lost out to PyTorch, why Google hasn’t been able to capitalize publicly on its early leadership of AI, the major components of machine learning model training time, the memory capacity/bandwidth/cost wall, model optimization, why other AI hardware companies haven’t been able to make a dent in Nvidia’s dominance so far, why hardware will start to matter more, how Nvidia’s competitive advantage in CUDA is wiped away, and a major win one of Nvidia’s competitors has at a large cloud for training silicon.</p><p>The 1,000-foot summary is that the default software stack for machine learning models will no longer be Nvidia’s closed-source CUDA. The ball was in Nvidia’s court, and they let OpenAI and Meta take control of the software stack. That ecosystem built its own tools because of Nvidia’s failure with their proprietary tools, and now Nvidia’s moat will be permanently weakened.</p><p>A handful of years ago, the framework ecosystem was quite fragmented, but TensorFlow was the frontrunner. Google looked poised to control the machine learning industry. They had a first movers’ advantage with the most commonly used framework, TensorFlow, and by designing/deploying the only successful AI application-specific accelerator, TPU.</p><p>Instead, PyTorch won. Google failed to convert its first mover’s advantage into dominance of the nascent ML industry. Nowadays, Google is somewhat isolated within the machine learning community because of its lack of use of PyTorch and GPUs in favor of its own software stack and hardware. In typical Google fashion, they even have a 2nd framework called Jax that competes directly with TensorFlow.</p><p><span>There’s even endless talk of Google’s dominance in search and natural language processing waning due to large language models, particularly those from OpenAI and the various startups that utilize OpenAI APIs or are building similar foundational models. While we believe this doom and gloom is overblown, that story is for another day. Despite these challenges, Google is still at the forefront of </span><a href="https://arxiv.org/abs/2212.13138" rel="">the most advanced machine learning models</a><span>. They invented transformers and remain state-of-the-art in many areas (PaLM, LaMBDA, Chinchilla, MUM, TPU).</span></p><p><span>Back to why PyTorch won. While there was an element of wrestling control away from Google, it was primarily due to its increased flexibility and usability of PyTorch versus TensorFlow. If we boil it down to a first principal level, PyTorch differed from TensorFlow in using “</span><strong>Eager mode</strong><span>” rather than &#34;</span><strong>Graph Mode</strong><span>.&#34;</span></p><p>Eager mode can be thought of as a standard scripting execution method. The deep learning framework executes each operation immediately, as it is called, line by line, like any other piece of Python code. This makes debugging and understanding your code more accessible, as you can see the results of intermediate operations and see how your model behaves.</p><p>In contrast, graph mode has two phases. The first phase is the definition of a computation graph representing the operations to perform. A computation graph is a series of interconnected nodes representing operations or variables, and the edges between nodes represent the data flow between them. The second phase is the deferred execution of an optimized version of the computation graph.</p><p>This two-phase approach makes it more challenging to understand and debug your code, as you cannot see what is happening until the end of the graph execution. This is analogous to &#34;interpreted&#34; vs. &#34;compiled&#34; languages, like python vs. C++. It&#39;s easier to debug Python, largely since it&#39;s interpreted.</p><p><span>While TensorFlow now has Eager mode by default, the research community and most large tech firms have settled around PyTorch. For a deeper explanation of why PyTorch won, see </span><a href="https://thegradient.pub/state-of-ml-frameworks-2019-pytorch-dominates-research-tensorflow-dominates-industry/" rel="">here</a><span>.</span></p><p>If we boil machine learning model training to its most simplistic form, there are two major time components in a machine learning model’s training time.</p><ol><li><p>Compute (FLOPS):  Running dense matrix multiplication within each layer</p></li><li><p><span>Memory (Bandwidth): Waiting for data or layer weights to get to the compute resources. Common examples of bandwidth-constrained operations are various </span><a href="https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html" rel="">normalizations</a><span>, </span><a href="https://pytorch.org/docs/stable/torch.html" rel="">pointwise operations</a><span>, </span><a href="https://pytorch.org/docs/stable/generated/torch.nn.Softmax.html" rel="">SoftMax</a><span>, and </span><a href="https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html" rel="">ReLU</a><span>.</span></p></li></ol><p>In the past, the dominant factor in machine learning training time was compute time, waiting for matrix multiplies. As Nvidia’s GPUs continued to develop, this quickly faded away from being the primary concern.</p><p><span>Nvidia’s FLOPS have increased multiple orders of magnitude by leveraging Moore’s Law, but primarily architectural changes such as the tensor core and lower precision floating point formats. In contrast, </span><a href="https://www.semianalysis.com/p/cxl-enables-microsoft-azure-to-cut" rel="">memory has not followed the same path</a><span>.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png" width="1187" height="862" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/e68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:862,&#34;width&#34;:1187,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:102857,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe68356e1-1d59-4d41-83f3-dda0c8786142_1187x862.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>If we go back to 2018, when the BERT model was state of the art, and the Nvidia V100 was the most advanced GPU, we could see that matrix multiplication was no longer the primary factor for improving a model’s performance. Since then, the most advanced models have grown 3 to 4 orders of magnitude in parameter count, and the fastest GPUs have grown an order of magnitude in FLOPS.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png" width="1456" height="469" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:469,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:49821,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b844875-6c57-4771-9930-e9f34bf89539_1513x487.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>https://arxiv.org/pdf/2007.00072.pdf</figcaption></figure></div><p>Even in 2018, purely compute-bound workloads made up 99.8% of FLOPS but only 61% of the runtime. The normalization and pointwise ops achieve 250x less FLOPS and 700x less FLOPS than matrix multiplications, respectively, yet they consume nearly 40% of the model’s runtime.</p><p>As models continue to soar in size, large language models take 100s gigabytes, if not terabytes, for the model weights alone. Production recommendation networks deployed by Baidu and Meta require dozens of terabytes of memory for their massive embedding tables. A huge chunk of the time in large model training/inference is not spent computing matrix multiplies, but rather waiting for data to get to the compute resources. The obvious question is why don’t architects put more memory closer to the compute. The answer is $$$.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg" width="704" height="513" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:513,&#34;width&#34;:704,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:319926,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/jpeg&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1c122a1e-05bb-41d5-9197-d610fcf7cdd9_704x513.jpeg 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p><span>Memory follows a hierarchy from close and fast to slow and cheap. The nearest shared memory pool is on the same chip and is generally made of SRAM. Some machine-learning ASICs attempt to utilize huge pools of SRAM to hold model weights, but there are issues with this approach. </span><a href="https://www.semianalysis.com/p/gpt-model-training-competition-heats" rel="">Even Cerebras’ ~$5,000,000 wafer scale chips</a><span> only have 40GB of SRAM on the chip. There isn’t enough memory capacity to hold the weights of a 100B+ parameter model.</span></p><p>Nvidia’s architecture has always used a much smaller amount of memory on the die. The current generation A100 has 40MB, and the next generation H100 has 50MB. 1GB of SRAM and the associated control logic/fabric on TSMC’s 5nm process node would require ~200mm^2 of silicon, or about 25% of the total logic area of an Nvidia datacenter GPU. Given that an A100 GPU costs $10k+ and the H100 is more like $20k+, economically, this is infeasible. Even when you ignore Nvidia’s ~75% gross margin on datacenter GPUs (~4x markup), the cost per GB of SRAM memory would still be in the $100s for a fully yielded product.</p><p>Furthermore, the cost of on-chip SRAM memory will not decrease much through conventional Moore’s Law process technology shrinks. The same 1GB of memory actually costs more with the next-generation TSMC 3nm process technology. While 3D SRAM will help with SRAM costs to some degree, that is only a temporary bend of the curve.</p><div data-attrs="{&#34;id&#34;:92075531,&#34;url&#34;:&#34;https://www.semianalysis.com/p/tsmcs-3nm-conundrum-does-it-even&#34;,&#34;publication_id&#34;:329241,&#34;publication_name&#34;:&#34;SemiAnalysis&#34;,&#34;publication_logo_url&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/0150776c-9bf2-4bea-a9c2-41b24b7a0f15_1280x1280.png&#34;,&#34;title&#34;:&#34;TSMC’s 3nm Conundrum, Does It Even Make Sense? – N3 &amp; N3E Process Technology &amp; Cost Detailed&#34;,&#34;truncated_body_text&#34;:&#34;A couple of weeks ago, we were able to attend IEDM, where TSMC presented many details about their N3B and N3E, 3nm class process nodes. Furthermore, TSMC announced it would up its capital expenditure in Phoenix, Arizona, with a total of $40 Billion invested in Fab 21 phases 1 and 2. This fab would produce chips in the N5 and N3 families, respectively. This report will cover the process node transition, the excessive costs of TSMC’s most advanced technology, and how it will significantly accelerate changes in the industry towards&#34;,&#34;date&#34;:&#34;2022-12-21T13:05:27.751Z&#34;,&#34;like_count&#34;:32,&#34;comment_count&#34;:3,&#34;bylines&#34;:[{&#34;id&#34;:21783302,&#34;name&#34;:&#34;Dylan Patel&#34;,&#34;previous_name&#34;:null,&#34;photo_url&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/b32454ba-4e7d-4beb-8616-45a9769f487a_3751x3751.png&#34;,&#34;bio&#34;:&#34;Bridging the gap between business and the worlds most important industry.&#34;,&#34;profile_set_up_at&#34;:&#34;2021-07-02T16:10:19.044Z&#34;,&#34;publicationUsers&#34;:[{&#34;id&#34;:124825,&#34;user_id&#34;:21783302,&#34;publication_id&#34;:329241,&#34;role&#34;:&#34;admin&#34;,&#34;public&#34;:true,&#34;is_primary&#34;:false,&#34;publication&#34;:{&#34;id&#34;:329241,&#34;name&#34;:&#34;SemiAnalysis&#34;,&#34;subdomain&#34;:&#34;semianalysis&#34;,&#34;custom_domain&#34;:&#34;www.semianalysis.com&#34;,&#34;custom_domain_optional&#34;:false,&#34;hero_text&#34;:&#34;Bridging the gap between business and the world&#39;s most important industry.&#34;,&#34;logo_url&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/0150776c-9bf2-4bea-a9c2-41b24b7a0f15_1280x1280.png&#34;,&#34;author_id&#34;:21783302,&#34;theme_var_background_pop&#34;:&#34;#67BDFC&#34;,&#34;created_at&#34;:&#34;2021-04-05T17:57:56.139Z&#34;,&#34;rss_website_url&#34;:null,&#34;email_from_name&#34;:&#34;SemiAnalysis&#34;,&#34;copyright&#34;:&#34;SemiAnalysis&#34;,&#34;founding_plan_name&#34;:&#34;Elite subscription&#34;,&#34;community_enabled&#34;:true,&#34;invite_only&#34;:false,&#34;payments_state&#34;:&#34;enabled&#34;}}],&#34;twitter_screen_name&#34;:&#34;dylan522p&#34;,&#34;is_guest&#34;:false,&#34;bestseller_tier&#34;:100,&#34;inviteAccepted&#34;:true},{&#34;id&#34;:112610384,&#34;name&#34;:&#34;Afzal Ahmad&#34;,&#34;previous_name&#34;:null,&#34;photo_url&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/b99c9003-37f4-4d78-819c-80fd256038cc_640x640.png&#34;,&#34;bio&#34;:null,&#34;profile_set_up_at&#34;:&#34;2022-11-23T09:32:35.528Z&#34;,&#34;is_guest&#34;:true,&#34;bestseller_tier&#34;:null,&#34;inviteAccepted&#34;:true}],&#34;utm_campaign&#34;:null,&#34;belowTheFold&#34;:true,&#34;type&#34;:&#34;newsletter&#34;}"><a native="true" href="https://www.semianalysis.com/p/tsmcs-3nm-conundrum-does-it-even?utm_source=substack&amp;utm_campaign=post_embed&amp;utm_medium=web" rel=""><div><p>TSMC’s 3nm Conundrum, Does It Even Make Sense? – N3 &amp; N3E Process Technology &amp; Cost Detailed</p></div><p>A couple of weeks ago, we were able to attend IEDM, where TSMC presented many details about their N3B and N3E, 3nm class process nodes. Furthermore, TSMC announced it would up its capital expenditure in Phoenix, Arizona, with a total of $40 Billion invested in Fab 21 phases 1 and 2. This fab would produce chips in the N5 and N3 families, respectively. This report will cover the process node transition, the excessive costs of TSMC’s most advanced technology, and how it will significantly accelerate changes in the industry towards…</p><p><span>Read more</span></p><p>a month ago · 32 likes · 3 comments · Dylan Patel and Afzal Ahmad</p></a></div><p>The next step down in the memory hierarchy is tightly coupled off-chip memory, DRAM. DRAM has an order magnitude higher latency than SRAM (~&gt;100 nanoseconds vs. ~10 nanoseconds), but it’s also much cheaper ($1s a GB vs. $100s GB.)</p><p>DRAM followed the path of Moore’s Law for many decades. When Gordon Moore coined the term, Intel’s primary business was DRAM. His economic prediction about density and cost of transistors generally held true until ~2009 for DRAM. Since ~2012 though, the cost of DRAM has barely improved.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png" width="1456" height="758" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:758,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:135153,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9503ab79-0d99-4332-8729-8cb09fad5e40_1697x883.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p><span>The demands for memory have only increased. DRAM now </span><a href="https://www.semianalysis.com/p/cxl-enables-microsoft-azure-to-cut" rel="">comprises 50% of the total server’s cost</a><span>. This is the memory wall, and it has shown up in products. Comparing Nvidia’s 2016 P100 GPU to their 2022 H100 GPU that is just starting to ship, there is a 5x increase in memory capacity (16GB -&gt; 80GB) but a 46x increase in FP16 performance (21.2 TFLOPS -&gt; 989.5 TFLOPS).</span></p><p><span>While capacity is a significant bottleneck, it is intimately tied to the other major bottleneck, bandwidth. Increased memory bandwidth is generally obtained through parallelism. While standard DRAM is only a few dollars per GB today, to get the massive bandwidth machine learning requires, Nvidia uses HBM memory, a device comprised of </span><a href="https://www.semianalysis.com/p/advanced-packaging-part-1-pad-limited" rel="">3D stacked layers of DRAM that requires more expensive packaging.</a><span> HBM is in the $10 to $20 a GB range, including packaging and yield costs.</span></p><p>The cost constraints of memory bandwidth and capacity show up in Nvidia’s A100 GPUs constantly. The A100 tends to have very low FLOPS utilization without heavy optimization. FLOPS utilization measures the total computed FLOPS required to train a model vs. the theoretical FLOPS the GPUs could compute in a model’s training time.</p><p>Even with heavy optimizations from leading researchers, 60% FLOPS utilization is considered a very high utilization rate for large language model training. The rest of the time is overhead, idle time spent waiting for data from another calculation/memory, or recomputing results just in time to reduce memory bottlenecks.</p><p><span>From the current generation A100 to the next generation H100, the FLOPS grow by more than 6X, but memory bandwidth only grows by 1.65x. This has led to many fears of low utilization for H100. The A100 </span><a href="https://www.mosaicml.com/composer" rel="">required many tricks</a><span> to get around the memory wall, and more will need to be implemented with the H100.</span></p><p><span>The H100 brings </span><a href="https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/" rel="">distributed shared memory and L2 multicast to Hopper</a><span>. The idea is that different SMs (think cores) can write directly to another SM’s SRAM (shared memory/L1 Cache). This </span><a href="https://www.nvidia.com/en-us/on-demand/session/gtcfall22-a41095/" rel="">effectively increases the size of the cache and reduces the required bandwidth</a><span> of DRAM read/writes. Future architectures will rely on sending fewer operations to memory to minimize the impact of the memory wall. It should be noted that larger models tend to achieve higher utilization rates as FLOPS demands scale at 2^n, whereas memory bandwidth and capacity demands tend to scale at 2*n.</span></p><blockquote><p>Just like with training ML models, knowing what regime you&#39;re in allows you to narrow in on optimizations that matters. For example, if you&#39;re spending all of your time doing memory transfers (i.e. you are in a memory-bandwidth bound regime), then increasing the FLOPS of your GPU won&#39;t help. On the other hand, if you&#39;re spending all of your time performing big chonky matmuls (i.e. a compute-bound regime), then rewriting your model logic into C++ to reduce overhead won&#39;t help.</p><p><a href="https://horace.io/brrr_intro.html" rel="">https://horace.io/brrr_intro.html</a></p></blockquote><p>Referring back to why PyTorch won, it was the increased flexibility and usability due to Eager mode, but moving to Eager mode isn’t all sunshine and rainbows. When executing in Eager mode, each operation is read from memory, computed, then sent to memory before the next operation is handled. This significantly increases the memory bandwidth demands if heavy optimizations aren’t done.</p><p>As such, one of the principal optimization methods for a model executed in Eager mode is called operator fusion. Instead of writing each intermediate result to memory, operations are fused, so multiple functions are computed in one pass to minimize memory reads/writes. Operator fusion improves operator dispatch, memory bandwidth, and memory size costs.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png" width="1456" height="831" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/a1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:831,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:838907,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa1abef1e-6021-474b-88d9-2117792580b0_3420x1952.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a><figcaption>https://horace.io/brrr_intro.html</figcaption></figure></div><p>This optimization often involves writing custom CUDA kernels, but that is much more difficult than using simple python scripts. As a built-in compromise, PyTorch steadily implemented more and more operators over time natively within PyTorch. Many of these operators were simply multiple commonly used operations fused into a single, more complex function.</p><p>The increase in operators made both creating the model within PyTorch easier and the performance of Eager mode faster due to having fewer memory read/writes. The downside was that PyTorch ballooned to over 2,000 operators over a few years.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png" width="690" height="862" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/fba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:862,&#34;width&#34;:690,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:302316,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffba6bd56-469a-4e90-93cb-d82384f0eea3_690x862.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>We would say software developers are lazy, but let’s be honest, almost all people are lazy. If they get used to one of the new operators within PyTorch, they will continue to use that. The developer may not even recognize the performance improvement but instead, use that operator because it means writing less code.</p><p>Additionally, not all operations can be fused. A significant amount of time is often spent deciding which operations to fuse and which operations to assign to specific compute resources at the chip and cluster levels. The strategy of which operations to fuse where, although generally similar, does vary significantly depending on the architecture.</p><p>The growth in operators and position as the default has helped Nvidia as each operator was quickly optimized for their architecture but not for any other hardware. If an AI hardware startup wanted to fully implement PyTorch, that meant supporting the growing list of 2,000 operators natively with high performance.</p><p>The talent level required to train a massive model with high FLOPS utilization on a GPU grows increasingly higher because of all the tricks needed to extract maximum performance. Eager mode execution plus operator fusion means that software, techniques, and models that are developed are pushed to fit within the ratios of compute and memory that the current generation GPU has.</p><p>Everyone developing machine learning chips is beholden to the same memory wall. ASICs are beholden to supporting the most commonly used frameworks. ASICs are beholden to the default development methodology, GPU-optimized PyTorch code with a mix of Nvidia and external libraries. An architecture that eschews a GPU’s various non-compute baggage in favor of more FLOPS and a stiffer programming model makes very little sense in this context.</p><p><strong>Ease of use is king.</strong></p><p><span>The only way to break the vicious cycle is for the software that runs models on Nvidia GPUs to transfer seamlessly to other hardware with as little effort as possible. As model architectures stabilize and abstractions from PyTorch 2.0, OpenAI Triton, </span><a href="https://www.mosaicml.com/composer" rel="">and MLOps firms such as MosaicML</a><span> become the default, the architecture and economics of the chip solution starts to become the biggest driver of the purchase rather than the ease of use afforded to it by Nvidia’s superior software.</span></p><p><span>The </span><a href="https://ai.facebook.com/blog/pytorch-foundation/" rel="">PyTorch Foundation was established and moved out from under the wings of Meta</a><span> just a few months ago. Alongside this change to an open development and governance model, 2.0 has been released for early testing with full availability in March. PyTorch 2.0 brings many changes, but the primary difference is that it adds a compiled solution that supports a graph execution model. This shift will make properly utilizing various hardware resources much easier.</span></p><p><span>PyTorch 2.0 brings </span><a href="https://www.youtube.com/watch?v=ppWKVg-VxmQ" rel="">an 86% performance improvement</a><span> for training on Nvidia’s A100 and </span><a href="https://www.youtube.com/watch?v=ppWKVg-VxmQ" rel="">26% on CPUs for inference</a><span>! This dramatically reduces the compute time and cost required for training a model. These benefits could extend to other GPUs and accelerators from </span><a href="https://www.semianalysis.com/p/amd-to-infinity-and-beyond" rel="">AMD</a><span>, </span><a href="https://www.semianalysis.com/p/intel-is-throwing-the-kitchen-sink" rel="">Intel</a><span>, </span><a href="https://www.semianalysis.com/p/tenstorrent-blackhole-grendel-and" rel="">Tenstorrent</a><span>, Luminous Computing, </span><a href="https://www.semianalysis.com/p/tesla-dojo-unique-packaging-and-chip" rel="">Tesla</a><span>, Google, </span><a href="https://www.semianalysis.com/p/amazon-graviton-3-uses-chiplets-and" rel="">Amazon</a><span>, Microsoft, </span><a href="https://www.semianalysis.com/p/marvelldeepdive2022" rel="">Marvell</a><span>, </span><a href="https://www.semianalysis.com/p/meta-discusses-ai-hardware-and-co" rel="">Meta</a><span>, </span><a href="https://www.semianalysis.com/p/graphcore-announces-worlds-first?s=w" rel="">Graphcore</a><span>, </span><a href="https://www.semianalysis.com/p/gpt-model-training-competition-heats" rel="">Cerebras</a><span>, SambaNova, etc.</span></p><p>The performance improvements from PyTorch 2.0 will be larger for currently unoptimized hardware. Meta and other firms’ heavy contribution to PyTorch stems from the fact that they want to make it easier to achieve higher FLOPS utilization with less effort on their multi-billion-dollar training clusters made of GPUs. They are also motivated to make their software stacks more portable to other hardware to introduce competition to the machine learning space.</p><p><span>PyTorch 2.0 also brings </span><a href="https://www.youtube.com/watch?v=bGo-2xNvNAc" rel="">advancements to distributed training</a><span> with better API support for data parallelism, </span><a href="https://pytorch.org/blog/introducing-pytorch-fully-sharded-data-parallel-api/" rel="">sharding</a><span>, </span><a href="https://github.com/pytorch/tau" rel="">pipeline parallelism</a><span>, and tensor parallelism. In addition, it supports dynamic shapes natively through the entire stack, which among many other examples, </span><a href="https://www.youtube.com/watch?v=rn-kJQ-7JmQ" rel="">makes varying sequence lengths for LLMs much easier to support.</a><span> This is the first time a major compiler supports Dynamic Shapes from training to inference.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png" width="936" height="656" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/ac54850d-f514-4a07-95aa-1097574bbae4_936x656.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:656,&#34;width&#34;:936,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:270397,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fac54850d-f514-4a07-95aa-1097574bbae4_936x656.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>Writing a performant backend for PyTorch that fully supports all 2,000+ operators has been difficult for every machine learning ASIC except for Nvidia GPUs. PrimTorch brings the number of operators down to ~250 primitive operators while also keeping usability unchanged for end users of PyTorch. PrimTorch makes the implementation of different, non-Nvidia backends to PyTorch much simpler and more accessible. Custom hardware and system vendors can bring up their software stacks more easily.</p><p><span>Moving to graph mode requires a robust graph definition. Meta and PyTorch have been attempting to work on implementing this for ~5 years, but every solution they came up with had significant drawbacks. They finally cracked the puzzle with TorchDynamo. TorchDynamo will ingest any PyTorch user script, including those that call outside 3rd party libraries, and generate </span><a href="https://arxiv.org/pdf/2112.08429.pdf" rel="">an FX graph</a><span>.</span></p><p>Dynamo lowers all complex operations to the ~250 primitive operations in PrimTorch. Once the graph is formed, unused operations are discarded, and the graph determines which intermediate operations need to be stored or written to memory and which can potentially be fused. This dramatically reduces the overhead within a model while also being seamless for the user.</p><p><span>TorchDynamo already works for </span><a href="https://dev-discuss.pytorch.org/t/torchdynamo-update-8-torchdynamo-passed-correctness-check-on-7k-github-models/663" rel="">over 99% of the 7,000 PyTorch models tested</a><span>, including those from OpenAI, HuggingFace, Meta, Nvidia, Stability.AI, and more, </span><strong>without any changes to the original code</strong><span>. The 7,000 models tested were indiscriminately chosen from the most popular projects using PyTorch on GitHub.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png" width="1058" height="736" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:736,&#34;width&#34;:1058,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:255731,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F640f7eef-8288-4940-9e1b-d25e8d458db4_1058x736.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>Google’s TensorFlow/Jax and other graph mode execution pipelines generally require the user to ensure their model fits into the compiler architecture so that the graph can be captured. Dynamo changes this by enabling partial graph capture, guarded graph capture, and just-in-time recapture.</p><ul><li><p>Partial graph capture allows the model to include unsupported/non-python constructs. When a graph cannot be generated for that portion of the model, a graph break is inserted, and the unsupported constructs will be executed in eager mode between the partial graphs.</p></li><li><p>Guarded graph capture checks if the captured graph is valid for execution. A guard is a change that would require recompilation. This is important because running the same code multiple times won&#39;t recompile multiple times.</p></li><li><p>Just-in-time recapture allows the graph to be recaptured if the captured graph is invalid for execution.</p></li></ul><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png" width="1456" height="733" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/e45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:733,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:671207,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe45581a1-1bb5-4ec8-971f-7c0d6cab1148_1920x966.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>PyTorch’s goal is to create a unified front end with a smooth UX that leverages Dynamo to generate graphs. The user experience of this solution would be unchanged, but the performance can be significantly improved. Capturing the graph means execution can be parallelized more efficiently over a large base of compute resources.</p><p><span>Dynamo and </span><a href="https://pytorch.org/functorch/stable/notebooks/aot_autograd_optimizations.html" rel="">AOT Autograd</a><span> then pass the optimized FX graphs to the PyTorch native compiler level, TorchInductor. Hardware companies can also take this graph and input it into their own backend compilers.</span></p><p>TorchInductor is a python native deep learning compiler that generates fast code for multiple accelerators and backends. Inductor will take the FX graphs, which have ~250 operators, and lowers them to ~50 operators. Inductor then moves to a scheduling phase where operators are fused, and memory planning is determined.</p><p>Inductor then goes to the “Wrapper Codegen,” which generates code that runs on the CPU, GPU, or other AI accelerators. The wrapper codegen replaces the interpreter part of a compiler stack and can call kernels and allocate memory. The backend code generation portion leverages OpenAI Triton for GPUs and outputs PTX code. For CPUs, an Intel compiler generates C++ (will work on non-Intel CPUs too).</p><p>More hardware will be supported going forward, but the key is that Inductor dramatically reduces the amount of work a compiler team must do when making a compiler for their AI hardware accelerator. Furthermore, the code is more optimized for performance. There are significant reductions in memory bandwidth and capacity requirements.</p><blockquote><p>We didn&#39;t want to build a compiler that only supported GPUs. We wanted something that could scale to support a wide variety of hardware back ends, and having a C++ as well as [OpenAI] Triton forces that generality.</p><p><a href="https://www.youtube.com/watch?v=ppWKVg-VxmQ" rel="">Jason Ansel – Meta AI</a></p></blockquote><p><span>OpenAI’s Triton is very disruptive angle to Nvidia’s closed-source software moat for machine learning. Triton takes in Python directly or feeds through the </span><a href="https://github.com/pytorch/pytorch/blob/master/torch/_inductor/codegen/triton.py" rel="">PyTorch Inductor stack</a><span>. The latter will be the most common use case. Triton then converts the input to an LLVM intermediate representation and then generates code. In the case of Nvidia GPUs, it directly generates PTX code, skipping Nvidia’s closed-source CUDA libraries, such as cuBLAS, in favor of open-source libraries, such as cutlass.</span></p><p>CUDA is commonly used by those specializing in accelerated computing, but it is less well-known among machine learning researchers and data scientists. It can be challenging to use efficiently and requires a deep understanding of the hardware architecture, which can slow down the development process. As a result, machine learning experts may rely on CUDA experts to modify, optimize, and parallelize their code.</p><p><span>Triton bridges the gap enabling higher-level languages to achieve performance comparable to those using lower-level languages. The Triton kernels themselves are quite legible to the typical ML researcher which is huge for usability. Triton automates memory coalescing, shared memory management, and scheduling within SMs. Triton is not particularly helpful for the element-wise matrix multiplies, which are already done very efficiently. Triton is incredibly useful for costly pointwise operations and </span><a href="https://github.com/HazyResearch/flash-attention/blob/main/flash_attn/flash_attn_triton.py" rel="">reducing overhead from more complex operations</a><span> such as </span><a href="https://github.com/HazyResearch/flash-attention" rel="">Flash Attention</a><span> that involve matrix multiplies as a portion of a larger fused operation.</span></p><p data-attrs="{&#34;url&#34;:&#34;https://www.semianalysis.com/p/nvidiaopenaitritonpytorch?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;,&#34;action&#34;:null,&#34;class&#34;:null}"><a href="https://www.semianalysis.com/p/nvidiaopenaitritonpytorch?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel=""><span>Share</span></a></p><p>OpenAI Triton only officially supports Nvidia GPUs today, but that is changing in the near future. Multiple other hardware vendors will be supported in the future, and this open-source project is gaining incredible steam. The ability for other hardware accelerators to integrate directly into the LLVM IR that is part of Triton dramatically reduces the time to build an AI compiler stack for a new piece of hardware.</p><p>Nvidia’s colossal software organization lacked the foresight to take their massive advantage in ML hardware and software and become the default compiler for machine learning. Their lack of focus on usability is what enabled outsiders at OpenAI and Meta to create a software stack that is portable to other hardware.</p><p>The rest of this report will point out the specific hardware accelerator that has a huge win at Microsoft, as well as multiple companies’ hardware that is quickly being integrated into the PyTorch 2.0/OpenAI Trion software stack. Furthermore, it will share the opposing view as a defense of Nvidia’s moat/strength in the AI training market.</p><p data-attrs="{&#34;url&#34;:&#34;https://www.semianalysis.com/subscribe?group=true&amp;coupon=fe141654&#34;,&#34;text&#34;:&#34;Get 20% off a group subscription&#34;,&#34;action&#34;:null,&#34;class&#34;:null}"><a href="https://www.semianalysis.com/subscribe?group=true&amp;coupon=fe141654" rel=""><span>Get 20% off a group subscription</span></a></p></div></div></div>
  </body>
</html>
