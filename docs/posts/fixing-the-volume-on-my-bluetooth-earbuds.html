<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ornx.net/post/bluetooth-volume-fix/">Original</a>
    <h1>Fixing the Volume on My Bluetooth Earbuds</h1>
    
    <div id="readability-page-1" class="page"><article>
    <header>
        <p><a href="https://blog.ornx.net/post/bluetooth-volume-fix/">
                <img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_hexdump_rofs_banner_hu9f10eb583e5810089a711ba6408d8f55_39932_800x0_resize_box_3.png" srcset="/post/bluetooth-volume-fix/fw_hexdump_rofs_banner_hu9f10eb583e5810089a711ba6408d8f55_39932_800x0_resize_box_3.png 800w, /post/bluetooth-volume-fix/fw_hexdump_rofs_banner_hu9f10eb583e5810089a711ba6408d8f55_39932_1600x0_resize_box_3.png 1600w" width="800" height="273" loading="lazy" alt="Featured image of post Fixing the Volume on my Bluetooth Earbuds"/>
                
            </a>
        </p>
    

    

</header>

    <section>
    
    
    
<p>I recently got a pair of Tozo T6 earbuds. They’re great and I love them but they play a sound whenever you pair, unpair, or connect them, and it’s way too loud for my preference.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> I also wasn’t able to fix it by e.g. setting the equalizer to subtract a few decibels across the board. I asked them via email about this and they responded promptly and said that there was nothing they could do, which is understandable - it’s probably not a common request. But it was too loud for me to continue using them, so I decided to try to solve the problem myself.</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/tozo_t6_earbuds.jpg" alt="Tozo T6 earbuds. They&amp;rsquo;re great. I only have one complaint&amp;hellip;" width="66%"/><figcaption>
            <p>Tozo T6 earbuds. They’re great. I only have one complaint…</p>
        </figcaption>
</figure>

<p>To solve the problem, I need to modify the firmware that runs on the device. My initial expectation of how this would work was:</p>
<ol>
<li>I would get a binary file from somewhere for my device. People often share firmware files online, maybe I could find a copy using a search engine.</li>
<li>The firmware file would be in some easily-understood binary structure like ELF.</li>
<li>The audio files would be contained in the binary somewhere, maybe as an ELF symbol (going from the last point). Knowing how the image format worked would let me modify the data within it while making sure that I didn’t accidentally give it a corrupt image and possibly brick my device.</li>
<li>The audio files would be in a format that would be easy to transform, maybe PCM since it’s running on an embedded device with perhaps limited computational power to decode audio (of course, it’s also a headset, so probably it can decode compressed audio just fine).</li>
<li>Once I can modify data within the firmware image (either unpack/repack it or modify data in-situ by knowing its offset and length within the image), do so to make the audio quieter (e.g. if it’s PCM then maybe halve each sample, etc).</li>
<li>Finally, I would flash my modified firmware to the device with some kind of tool made for my model of equipment or its underlying chipset, etc.</li>
</ol>
<p>Some of these assumptions ended up being completely false and unwarranted (I have no idea why I hoped that the audio would be uncompressed on a low-power device like this, for example), but this was my thinking starting out. It also doesn’t include any reverse engineering, which ended up taking up most of the time that wasn’t spent on setting up infrastructure (such as an intercepting proxy), but this was mostly just going down rabbitholes. In the end, I actually didn’t need to reverse engineer much at all. So this post is less about reverse engineering and more about the general process of solving my particular problem.</p>

<p>The first step is to collect information about what exactly the device is. There seem to be several different entities involved in the production of cheap electronics:</p>
<ul>
<li>The vendor, who actually brands and sells the device - Tozo, in this case.</li>
<li>The chipset, a specific piece of hardware the device is mostly designed around, which runs the firmware code and might have special features for the application at hand.</li>
<li>The ISA - the chipset will run code of a particular instruction set, with a “core” derived from some other base tech like ARM, MIPS, etc (or perhaps they rolled their own).</li>
<li>Additional features - the chipset might integrate technology from other people onto their chip, such as additional coprocessors, chips to interface with different kinds of hardware, etc.</li>
</ul>
<p>The chipset for my device ended up being an Airoha AB1562, which apparently is based on an Tensilica Xtensa ISA and includes a “Cadence HiFi DSP coprocessor”. I wasn’t able to find this out searching for my device model however, so I ended up just looking through the disassembly for their Android app. There I found an SDK for a company called “Airoha”, with references to specific chip models and containing all of the primitives for talking to devices. I wasn’t able to find any other chipset SDK’s, so I assumed this was the chipset manufacturer.</p>
<p>I still had to find the specific model though. After a bit more searching, I found a Reddit community for discussing AirPods clones called /r/airreps, which gave me some good advice about how to proceed. They have also written an Android application called “AirReps156X”<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> which also uses the Airoha SDK, and can provide diagnostic information about Airoha devices<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. I was able to connect to this app with my device, so it’s definitely an Airoha chipset, and one of the diagnostic strings was “QW_1562U_SDK1.5.1”, which leads me to believe that my device chipset is in the Airoha AB1562 series:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/airreps_156x_diagnostic.png" alt="The &amp;ldquo;Airreps 156X&amp;rdquo; app display device information." width="33%"/><figcaption>
            <p>The “Airreps 156X” app display device information.</p>
        </figcaption>
</figure>

<p>The application also lets you flash new firmware, which is a fairly critical item on the checklist. So now that we’ve gotten that prerequisite out of the way and identified the chipset all that’s left to do is to find the actual firmware and modify it.</p>

<p>The Tozo application is my first lead. When you connect your earbuds to the Tozo app, it displays the firmware version and whether or not it’s “current”. So it must talk to a server somewhere, which knows what the latest version of the firmware is:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/tozo_app_current.png" alt="Tozo&amp;rsquo;s app displaying the current firmware version." width="33%"/><figcaption>
            <p>Tozo’s app displaying the current firmware version.</p>
        </figcaption>
</figure>

<p>In theory, I could probably just read through the decompiled code in jadx or something until I find out what servers it’s talking to, how, and what it does when it checks for updates (such as, presumably, downloading the firmware files I’m looking for). But that’s a lot of work, so I have a better idea - when the app checks if the firmware is up to date, it might also make API requests that could shed some light on where to find the actual firmware files. It might even be able to be tricked into trying to update, which would also lead me to the right URLs. So some quick and dirty “dynamic analysis” via traffic interception is the logical next step.</p>
<h2 id="setting-up-an-intercepting-proxy">Setting up an intercepting proxy</h2>
<p>To this end I set up an intercepting proxy using my wireless NIC with hostapd and mitmproxy, and patched the Tozo app with apktool + uber apk signer so that it’ll let us strip the TLS and snoop on its raw network traffic.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>
<p>Patching the APK is pretty standard stuff - I just followed <a href="https://gist.github.com/unoexperto/80694ccaed6dadc304ad5b8196cbbd2c" target="_blank" rel="noopener">this gist</a>. The idea is that Android applications have two CA stores, one that can be easily modified by the user, and one that can’t, and by default most Android apps only check TLS certificates against the latter. But, by patching the APK, we can tell it to use the former too, which is where we put our mitmproxy-provided TLS certificate that we’re going to use to snoop on all of the network traffic used by our app. Then we have to sign it so Android will deal with it.</p>
<p>The intercepting proxy setup was pretty straightforward - just set up the AP, set up some iptables rules to direct traffic to mitmproxy’s listening port, and do the typical NAT song and dance:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="make"><span><span><span>.PHONY</span><span>:</span> <span>start</span>
</span></span><span><span><span>start</span><span>:</span>
</span></span><span><span>	nmcli device <span>set</span> wlp3s0 managed no
</span></span><span><span>	sudo sysctl -w net.ipv4.conf.all.send_redirects<span>=</span><span>0</span>
</span></span><span><span>	sudo sysctl -w net.ipv4.ip_forward<span>=</span><span>1</span>
</span></span><span><span>	sudo iptables -I INPUT -i wlp3s0 -j ACCEPT
</span></span><span><span>	sudo iptables -t nat -A PREROUTING -i wlp3s0 -p tcp --dport <span>80</span> -j REDIRECT --to-port <span>8080</span>
</span></span><span><span>	sudo iptables -t nat -A PREROUTING -i wlp3s0 -p tcp --dport <span>443</span> -j REDIRECT --to-port <span>8080</span>
</span></span><span><span>	sudo iptables -A FORWARD -i wlp3s0 -o enp5s0f3u1u3c2 -j ACCEPT
</span></span><span><span>	sudo iptables -t nat -A POSTROUTING -o enp5s0f3u1u3c2 -j MASQUERADE
</span></span><span><span>	sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</span></span><span><span>	sudo hostapd hostapd.conf
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>stop</span>
</span></span><span><span><span>stop</span><span>:</span>
</span></span><span><span>	sudo sysctl -w net.ipv4.conf.all.send_redirects<span>=</span><span>1</span>
</span></span><span><span>	sudo sysctl -w net.ipv4.ip_forward<span>=</span><span>0</span>
</span></span><span><span>	sudo iptables -D INPUT -i wlp3s0 -j ACCEPT
</span></span><span><span>	sudo iptables -t nat -D PREROUTING -i wlp3s0 -p tcp --dport <span>80</span> -j REDIRECT --to-port <span>8080</span>
</span></span><span><span>	sudo iptables -t nat -D PREROUTING -i wlp3s0 -p tcp --dport <span>443</span> -j REDIRECT --to-port <span>8080</span>
</span></span><span><span>	sudo iptables -D FORWARD -i wlp3s0 -o enp5s0f3u1u3c2 -j ACCEPT
</span></span><span><span>	sudo iptables -t nat -D POSTROUTING -o enp5s0f3u1u3c2 -j MASQUERADE
</span></span><span><span>	sudo iptables -D FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</span></span><span><span>	nmcli device <span>set</span> wlp3s0 managed yes
</span></span><span><span>				
</span></span><span><span><span>.PHONY</span><span>:</span> <span>mitmproxy</span>
</span></span><span><span><span>mitmproxy</span><span>:</span>
</span></span><span><span>	<span>SSLKEYLOGFILE</span><span>=</span><span>&#34;sslkeylogfile-attempt1.txt&#34;</span> mitmdump --mode transparent --showhost -k
</span></span></code></pre></td></tr></tbody></table>
</div>
</div>

<p>


<em>The script I used to start and stop the TLS-stripping wireless AP. I know <code>make</code> isn’t really the right tool for this, but it’s a force of habit at this point.</em>

</p>


<h2 id="snooping-on-the-applications-network-traffic">Snooping on the application’s network traffic</h2>
<p>Once it was all working, I saw that when I connected the device to the app and the “current” string popped up next to the firmware version, it made a request to an endpoint /api/v1/getOtaVersionV3. And, lo and behold, the response contains links to all of the firmware bins we’re looking for! How nice. No trickery needed.</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/tozo_netcap_checkota_request_redacted.png" alt="getOtaVersionV3 Request in Wireshark" width="92%"/><figcaption>
            <p>getOtaVersionV3 Request in Wireshark</p>
        </figcaption>
</figure>

<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/tozo_mitmproxy_response.png" alt="getOtaVersionV3 Response in mitmproxy" width="92%"/><figcaption>
            <p>getOtaVersionV3 Response in mitmproxy</p>
        </figcaption>
</figure>


<p>There are four files, two per earbud, each having a “FotaPackage” and a “FileSystemImage”. The two filesystem images are identical, so we wind up with three distinct files - two fotapackages for L and R earbuds, and the filesystem image.</p>
<p>The first thing anybody does when they get a weird file is, they run the Linux command “file” on it, to see if it has a magic number that indicates its file format:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_file.png" alt="Unhelpful." width="92%"/><figcaption>
            <p>Unhelpful.</p>
        </figcaption>
</figure>

<p>…and, if that doesn’t help, they might run strings or hexdump over it, to see if there’s any interesting human-readable ASCII strings in it:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_strings_rofs.png" alt="From the filesystem image - some filenames, at least." width="92%"/><figcaption>
            <p>From the filesystem image - some filenames, at least.</p>
        </figcaption>
</figure>

<p>and then binwalk to see if there’s any files embedded in it:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binwalk.png" alt="The LZ4 region contains the NVROM, which isn&amp;rsquo;t useful to us - it doesn&amp;rsquo;t contain any audio files." width="92%"/><figcaption>
            <p>The LZ4 region contains the NVROM, which isn’t useful to us - it doesn’t contain any audio files.</p>
        </figcaption>
</figure>

<p>Unfortunately, binwalk didn’t find anything, even the mp3 files whose filenames are referenced directly in the image. They are indeed in there, it’s just that the mp3 file format is just not very easy to carve out of arbitrary binary data because it doesn’t have any kind of magic number (it can start with either 0xFFFF or 0xFFFE, neither of which are particularly distinctive, and there’s no footer). So even though you can tell they’re in there, it’s not immediately obvious how to unambiguously calculate the offset and length for each mp3 file. So, I decided the best way to figure this out would be to decipher the filesystem image format, which probably has information that tells you where each file begins and ends.</p>
<h2 id="entropy-analysis">Entropy analysis</h2>
<p>The next step for this is entropy analysis. This basically tells you what parts of a file are constant (0x00 or 0xFF are popular bytes for this), which parts resemble random noise, which parts are valid ASCII text, and the offsets at which one of those things changes into another. It’s useful because it sometimes lets you visualize the structure of something without actually knowing anything about it.</p>
<p>The filesystem image looked promising (generated with <a href="http://binvis.io/%29" target="_blank" rel="noopener">http://binvis.io/)</a>:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binvisio_entropy_rofs.png" alt="It does some grouping of the data into blocks to make the structure more visible, so it&amp;rsquo;s not row-by-row like you might expect." width="10%"/><figcaption>
            <p>It does some grouping of the data into blocks to make the structure more visible, so it’s not row-by-row like you might expect.</p>
        </figcaption>
</figure>

<p>Unfortunately, the FotaPackage files however were obviously encrypted or compressed somehow:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binwalk_entropy_l.png" alt="It&amp;rsquo;s not looking good." width="92%"/><figcaption>
            <p>It’s not looking good.</p>
        </figcaption>
</figure>

<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binvisio_entropy_fota_l.png" alt="Oof." width="10%"/><figcaption>
            <p>Oof.</p>
        </figcaption>
</figure>

<p>I also noticed that the left and right FotaPackage binaries had some curious differences - their headers only differed sporadically, while the body was identical except for the end, where there was about 7KB of complete difference.</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binwalk_lr_diff_start.png" alt="The header (0x00-0x1000) appears to be unencrypted and only differs in small segments." width="92%"/><figcaption>
            <p>The header (0x00-0x1000) appears to be unencrypted and only differs in small segments.</p>
        </figcaption>
</figure>

<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binwalk_lr_diff_end.png" alt="Then, at the end, the footer suddenly changes to completely different, at around 0xC4E38." width="92%"/><figcaption>
            <p>Then, at the end, the footer suddenly changes to completely different, at around 0xC4E38.</p>
        </figcaption>
</figure>

<p>I wasn’t completely sure as to the meaning of this, beyond the fact that there was obviously some kind of opaque transformation at work. My initial guess was encryption, with the same key/IV but different plaintexts, and that the sudden difference corresponds to a single-byte difference (perhaps an #ifdef EARBUD_R doBluetoothMasterThings(); #else doBluetoothSlaveThings(); #endif sort of thing) that then leads to the rest of the file being different, but I wasn’t able to verify this. Regardless of why, it was obvious I wasn’t going to get anything out of them without serious effort.</p>
<h2 id="a-quick-appraisal-of-the-situation">A quick appraisal of the situation</h2>
<p>The fact that we know the audio is mp3 was actually pretty bad news to me at first glance. My understanding of media encoders is that they generally have a lot of options for how to encode something, while sometimes a given decoder will barf on a perfectly well-formed file that happens to use a feature it wasn’t expecting.</p>
<p>This is very bad for us for two reasons:</p>
<ol>
<li>Our decoder is of utterly unknown provenance, who knows what it might barf on.</li>
<li>The audio gets played right when the device first pairs, so if we produce an mp3 file that the decoder does not like and the device crashes before we can connect to it again, then we risk putting it into an unrecoverable state.</li>
</ol>
<p>Furthermore, even if we use precisely the expected encoding parameters while producing our volume-adjusted mp3 files, if we change the length of the file while modifying it then we must also make sure that we account for this when we modify the filesystem image, where what that specifically means depends on the exact structure of the filesystem format. Presumably, it records the length of each file somewhere, and we need to make sure we adjust this number to accurately refect the new length of the file (or else it will either be truncated or have garbage added to the end). This is a lot of work, and with an uncertain outcome.</p>
<p>So, at this point I was somewhat worried about the future of this project, and was desperately trying to figure out how to proceed without any re-encoding.</p>
<p>Luckily, it turns out that you can indeed modify the volume (or “gain”) of an mp3 file without changing its length, or re-encoding it, or even modifying its metadata. It’s kind of like how you can rotate a JPEG file without re-encoding it as well - you can just look inside of its data structures and modify them for this one particular transformation without needing to change anything else. Pretty neat!</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/mp3_binwalk_gainadjusted.png" alt="An mp3 file transformed with mp3gain - see, only a few bytes of difference." width="75%"/><figcaption>
            <p>An mp3 file transformed with mp3gain - see, only a few bytes of difference.</p>
        </figcaption>
</figure>

<h2 id="rofs">ROFS</h2>
<p>Back to the filesystem image - it seems to contain the mp3 files that correspond to the sounds I am trying to enquiet, and I want to replace them with modified versions, so at a bare minimum I need to know where files begin and end inside of the image. At this point, binwalk couldn’t identify them, so I thought that the problem was that either they were either obfuscated somehow (compressed/encrypted) or the structure of the filesystem might be making it difficult to identify them. So, I decided that the next point of attack was to understand the structure of the filesystem image, which begins with the ASCII string “ROFS”:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_hexdump_rofs.png" alt="Hexdump of ROFS image." width="50%"/><figcaption>
            <p>Hexdump of ROFS image.</p>
        </figcaption>
</figure>

<p>The first step is to search for information about anything with that name online, but no dice. I’m pretty sure it’s bespoke to this particular chipset manufacturer, as I was completely unable to find any reference or documentation of something called “ROFS” that would describe the file I have and the Airoha SDK I would later find contains an implementation of an interface for reading files from it.</p>
<p>At this point, I made a somewhat regrettable decision that the next course of action was to try to attack the firmware, so that I could get to the code that presumably understands the filesystem image format. But the firmware code was (seemingly) encrypted, so I decided to see if they were doing something silly with their encryption and check if maybe the FotaPackage files were decrypted client-side by the SDK before being sent out over the wire. I was eventually able to ascertain with some certainty that the SDK does not transform the firmware in any way before sending it out, but it took me a few hours of reading decompiled code before I came to this conclusion. So of course, I didn’t succeed in attacking the firmware crypto and it was all a waste of time. Oh well.</p>
<h2 id="sdk-breakthrough">SDK Breakthrough</h2>
<p>The final breakthrough occurred when I searched for the chipset name online, and found a copy of their SDK. Looking through it, I could see that it had a bunch of .mp3 files in it - the same ones I could hear on the device. I wrote a quick python program to check if a file was contained within another file (probably a tool already exists for this?) and verified that the mp3 files in the SDK were contained in the filesystem image verbatim.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>sys</span>
</span></span><span><span>
</span></span><span><span><span>assert</span><span>(</span><span>len</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>)</span> <span>==</span> <span>3</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># returns if a is contained within b</span>
</span></span><span><span><span>a</span><span>=</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]</span>
</span></span><span><span><span>b</span><span>=</span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span>
</span></span><span><span>
</span></span><span><span><span>x</span> <span>=</span> <span>False</span>
</span></span><span><span><span>i</span> <span>=</span> <span>0</span>
</span></span><span><span><span>with</span> <span>open</span><span>(</span><span>a</span><span>,</span> <span>mode</span><span>=</span><span>&#39;rb&#39;</span><span>)</span> <span>as</span> <span>af</span><span>:</span>
</span></span><span><span>  <span>ab</span> <span>=</span> <span>af</span><span>.</span><span>read</span><span>()</span>
</span></span><span><span>  <span>with</span> <span>open</span><span>(</span><span>b</span><span>,</span> <span>mode</span><span>=</span><span>&#39;rb&#39;</span><span>)</span> <span>as</span> <span>bf</span><span>:</span>
</span></span><span><span>    <span>bb</span> <span>=</span> <span>bf</span><span>.</span><span>read</span><span>()</span>
</span></span><span><span>    
</span></span><span><span>    <span>while</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>bb</span><span>):</span>
</span></span><span><span>      <span>o</span> <span>=</span> <span>0</span>
</span></span><span><span>      <span>while</span> <span>((</span><span>o</span> <span>&lt;</span> <span>len</span><span>(</span><span>ab</span><span>))</span> <span>and</span> <span>((</span><span>i</span> <span>+</span> <span>o</span><span>)</span> <span>&lt;</span> <span>len</span><span>(</span><span>bb</span><span>))</span> <span>and</span> <span>ab</span><span>[</span><span>o</span><span>]</span> <span>==</span> <span>bb</span><span>[</span><span>i</span> <span>+</span> <span>o</span><span>]):</span>
</span></span><span><span>        <span>o</span> <span>=</span> <span>o</span> <span>+</span> <span>1</span>
</span></span><span><span>      <span>if</span> <span>(</span><span>o</span> <span>==</span> <span>len</span><span>(</span><span>ab</span><span>)):</span>
</span></span><span><span>        <span>x</span> <span>=</span> <span>True</span>
</span></span><span><span>        <span>break</span>
</span></span><span><span>      <span>else</span><span>:</span>
</span></span><span><span>        <span>i</span> <span>=</span> <span>i</span> <span>+</span> <span>1</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>x</span><span>:</span>
</span></span><span><span>  <span>print</span><span>(</span><span>&#34;found: </span><span>{}</span><span>&#34;</span><span>.</span><span>format</span><span>(</span><span>i</span><span>))</span>
</span></span><span><span>  <span>exit</span><span>(</span><span>0</span><span>)</span>
</span></span><span><span><span>else</span><span>:</span>
</span></span><span><span>  <span>print</span><span>(</span><span>&#34;not found&#34;</span><span>)</span>
</span></span><span><span>  <span>exit</span><span>(</span><span>1</span><span>)</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>

<p>


<em>bincontains.py</em>

</p>



<p>I was slightly worried that the ROFS image might contain additional data, such as checksums for the files inside of it, but I briefly skimmed the ROFS-related code from the SDK (unfortunately it only seemed to exist as prebuilt object files) and it only had a few symbols in it for operating on the filesystem, none of which suggested the presence of checksumming:</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/ghidra_rofs_obj_symboltable.png" alt="There&amp;rsquo;s not a lot of code in here, and there&amp;rsquo;s no external references to anything relating to checksumming." width="92%"/><figcaption>
            <p>There’s not a lot of code in here, and there’s no external references to anything relating to checksumming.</p>
        </figcaption>
</figure>

<p>So with that out of the way, at this point I actually have everything I need to complete the task of modifying the volume of the sound files in the firmware image with no further reverse engineering. I have:</p>
<ul>
<li>A way to flash updated firmware to the device, as well as the firmware files themselves.</li>
<li>Knowledge that the mp3 files from the SDK are included verbatim in the filesystem image (no compression, splitting into blocks, etc). This means I have their lengths and offsets in the filesystem image.</li>
<li>Knowledge that you can modify the gain of an mp3 file without re-encoding it or changing its length.</li>
<li>The assumption that the filesystem format doesn’t include any checksumming or additional information about its files that would be invalidated upon modifying their occupant byte range in the image.</li>
</ul>
<p>Then, it’s just as simple as looping over the mp3 files, and if it’s contained in the image, running mp3gain on the file and then replacing it in the image with the gain-modified version. I used an adjustment of -19.5 decibels.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="bash"><span><span><span>#!/usr/bin/env bash
</span></span></span><span><span><span></span>
</span></span><span><span><span>NS</span><span>=</span><span>&#34;</span><span>$1</span><span>&#34;</span>
</span></span><span><span><span>HS</span><span>=</span><span>&#34;</span><span>$2</span><span>&#34;</span>
</span></span><span><span><span>DB</span><span>=</span><span>&#34;</span><span>$3</span><span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span>for</span> N in <span>$(</span>find <span>&#34;</span><span>$NS</span><span>&#34;</span> -type f <span>|</span> grep -E <span>&#39;mp3$&#39;</span><span>)</span><span>;</span> <span>do</span>
</span></span><span><span>	<span>F</span><span>=</span><span>$(</span>python3 bincontains.py <span>&#34;</span><span>$N</span><span>&#34;</span> <span>&#34;</span><span>$HS</span><span>&#34;</span><span>)</span><span>;</span>
</span></span><span><span>	<span>X</span><span>=</span><span>$?</span>
</span></span><span><span>	<span>if</span> <span>[</span> <span>$X</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
</span></span><span><span>		<span>START</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$F</span><span>&#34;</span> <span>|</span> awk <span>&#39;{print $2;}&#39;</span><span>)</span>
</span></span><span><span>		<span>LEN</span><span>=</span><span>$(</span>stat -c <span>&#39;%s&#39;</span> <span>&#34;</span><span>$N</span><span>&#34;</span><span>)</span>
</span></span><span><span>		<span>TMP</span><span>=</span><span>$(</span>mktemp <span>&#34;XXXXXXX.mp3&#34;</span><span>)</span>
</span></span><span><span>		cp <span>&#34;</span><span>$N</span><span>&#34;</span> <span>&#34;</span><span>$TMP</span><span>&#34;</span>
</span></span><span><span>		mp3gain -q -T -s r -s s -g <span>&#34;</span><span>$DB</span><span>&#34;</span> <span>&#34;</span><span>$TMP</span><span>&#34;</span>
</span></span><span><span>		<span>LEN2</span><span>=</span><span>$(</span>stat -c <span>&#39;%s&#39;</span> <span>&#34;</span><span>$TMP</span><span>&#34;</span><span>)</span>
</span></span><span><span>		<span>printf</span> <span>&#34;%s,%s,%s,%s\n&#34;</span> <span>&#34;</span><span>$N</span><span>&#34;</span> <span>&#34;</span><span>$START</span><span>&#34;</span> <span>&#34;</span><span>$LEN</span><span>&#34;</span> <span>&#34;</span><span>$LEN2</span><span>&#34;</span>
</span></span><span><span>		dd <span>if</span><span>=</span><span>&#34;</span><span>$TMP</span><span>&#34;</span> <span>of</span><span>=</span><span>&#34;</span><span>$HS</span><span>&#34;</span> <span>bs</span><span>=</span><span>1</span> <span>seek</span><span>=</span><span>&#34;</span><span>$START</span><span>&#34;</span> <span>count</span><span>=</span><span>&#34;</span><span>$LEN</span><span>&#34;</span> <span>conv</span><span>=</span>notrunc
</span></span><span><span>	<span>fi</span>
</span></span><span><span><span>done</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>

<p>


<em>binsearch.sh</em>

</p>


<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/fw_binwalk_modified_diff.png" alt="A quick binary diff of the final firmware image - only a few bytes of difference, as expected." width="92%"/><figcaption>
            <p>A quick binary diff of the final firmware image - only a few bytes of difference, as expected.</p>
        </figcaption>
</figure>

<p>Finally, I flashed it to the device and it worked!</p>
<figure><img src="https://blog.ornx.net/post/bluetooth-volume-fix/airreps_156x_fotasucceed.png" alt="Hooray!" width="33%"/><figcaption>
            <p>Hooray!</p>
        </figcaption>
</figure>

<p>I shortly verified that the device was fully operational and the sound was, indeed, much quieter than it was when I started.</p>
<p>Mission accomplished!</p>

<p>I didn’t end up having to decrypt the firmware (probably impossible for me) or understand the ROFS image format at all - most of the time spent reverse-engineering was actually going down rabbitholes that didn’t help me in the end.</p>
<p>I also kind of wish that volume control of system sounds was a first-class feature - from a UI perspective, I think it’s an error for a device that plays audio to not have a volume control that modifies all of the sound that gets produced by the device. But apparently it has a workaround, so I guess it’s fine.</p>
<p>But yeah, all in all this was a pretty fun little project, would do again/10.</p>


</section>


    


    
</article></div>
  </body>
</html>
