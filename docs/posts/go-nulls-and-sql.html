<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ente.io/blog/tech/go-nulls-and-sql/">Original</a>
    <h1>Go nulls and SQL</h1>
    
    <div id="readability-page-1" class="page"><div><p>Go has &#34;zero&#34; values. These are the values that variables of primitive types get
when they are created and we don&#39;t explicitly give them a initial value.</p><pre><p><span>var</span><span> i </span><span>int</span><span></span></p><p><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%#v\n&#34;</span><span>,</span><span> i</span><span>)</span><span> </span><span></span></p><p><span></span><span>var</span><span> s </span><span>string</span><span></span></p><p><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%#v\n&#34;</span><span>,</span><span> s</span><span>)</span><span> </span><span></span></p></pre><p>Numbers start off as <code>0</code>, booleans as <code>false</code>, and strings as <code>&#34;&#34;</code>.</p><p>Go also has <code>nil</code>, and &#34;nilable&#34; types to which a <code>nil</code> can be assigned. The
canonical example is a pointer. If we create a pointer and don&#39;t explicitly give
it an initial value, then it starts off as <code>nil</code>.</p><pre><p><span>var</span><span> p </span><span>*</span><span>int</span><span></span></p><p><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%#v\n&#34;</span><span>,</span><span> p</span><span>)</span><span> </span><span></span></p></pre><p>You can look but you cannot touch, these nilables. If you try doing something
that uses a nilable type that currently has a nil value, Go will panic.</p><pre><p><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%#v\n&#34;</span><span>,</span><span> </span><span>*</span><span>p</span><span>)</span><span> </span><span></span></p></pre><p>Apart from pointers, uninitialized variables for slices, maps, interfaces,
functions and channels also start off as <code>nil</code>.</p><p>So, for example, the predeclared type <code>error</code> is an interface, and
conventionally we use <code>nil</code> to represent no error.</p><p>Structs are recursively auto initialized.</p><pre><p><span>type</span><span> R </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    i </span><span>int</span><span></span></p><p><span>    s </span><span>string</span><span></span></p><p><span>    p </span><span>*</span><span>int</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>var</span><span> r R</span></p><p><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%#v\n&#34;</span><span>,</span><span> r</span><span>)</span><span> </span><span></span></p></pre><p>Elementary, Watson, you say (if you&#39;ve managed to reach this point). Ah but the
case is not out in the open yet.</p><p>The issue that happens is ‚Äì¬†zeroables and nilables don&#39;t mix.</p><p>This is something which comes up when we try to interact with, for example, SQL
or JSON. In SQL, a string may both be empty (<code>&#34;&#34;</code>, just like a zeroable in Go)
and <code>NULL</code> (like a Go <code>nil</code>). But a Go string can only be zeroable, not nil. So
how do we assign a string we get from SQL to a Go variable?</p><p>Pointers. We can point to a string. The pointer can be <code>nil</code>. And the string it
points to can be empty.</p><p>Nice and easy. However, not everyone likes this approach <!-- -->[2]<!-- -->.</p><blockquote><p>Pointers are easy first, but then you realize that you have to put nilness
checks everywhere. But that time those easy to use pointers are everywhere,
and appear only at run time, only in prod, at night...</p></blockquote><p>So the Go stdlib provides so called &#34;Null wrappers&#34; specifically for use with
SQL. For our string example, we can use a <code>NullString</code>.</p><pre><p><span>var</span><span> ns sql</span><span>.</span><span>NullString</span></p><p><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;%#v\n&#34;</span><span>,</span><span> ns</span><span>)</span><span> </span><span></span></p></pre><p>We can also deal with this problem at the SQL level, by using <code>COALESCE</code> (which
returns the first non-<code>NULL</code> value from the list it is given).</p><pre><p><span>db</span><span>.</span><span>QueryRow</span><span>(</span><span>&#34;SELECT COALESCE(NULL, &#39;&#39;)&#34;</span><span>)</span><span></span></p></pre><p>Finally, as usual, sometimes the best way to solve a problem is to avoid the
problem üèñ; by declaring our SQL columns as <code>NOT NULL</code> when possible.</p><hr/><p>If you&#39;d like to hear more about our experience with Go, follow us on
<a href="https://twitter.com/enteio">Twitter</a>.</p><p>Or if you&#39;d hang out with a bunch of engineers building an e2ee photo storage
service, come say hello on <a href="https://ente.io/discord">Discord</a>.</p></div></div>
  </body>
</html>
