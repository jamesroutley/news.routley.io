<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evanmiller.org/attention-is-off-by-one.html">Original</a>
    <h1>Attention Is Off By One</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
        
        <div>

<p>By <a href="https://www.cyberdemon.org/">Evan Miller</a></p>

<p><em>July 24, 2023</em></p>





<blockquote>
    <hr/>
<p>
About which one cannot speak, one must pass over in silence. –Wittgenstein
</p>

    <hr/>
</blockquote>

<p>
Do you see the off-by-one error in this formula?
</p><p>

\[
\textrm{Attention}(Q, K, V) = \textrm{softmax}\left(\frac{QK^T}{\sqrt{d}}\right)V
\]

</p><p>
The attention formula is the central equation of modern AI,
but there’s a bug in it that has been driving me nuts the last week. I tried
writing a serious-looking research paper about the bug and my proposed fix, but
I lost a series of pitched battles against Pytorch and <code>biblatex</code>,
so I figured I’d just write a blog post instead. (History is written by the
winners; blogs are written by…)
</p>

<p>
In this post I’ll explain how (IMHO) the current generation of AI models have
an off-by-one error in a crucial place, and it’s making everyone’s Transformer
models needlessly difficult to compress and deploy. Consider this an opinion
piece, but if anyone out there on the Internet wants to run some experiments and
prove me right, we can collaborate and call ourselves scientists.
</p>

<h2>
It’s All About Outliers
</h2>

<p>
First let’s talk about why this off-by-one error matters. <em>ChatGPT works
great, what’s your problem bro?</em> I first caught the scent of something
amiss whilst minding my business and perusing research papers on quantization,
the technique by which LLM Edgers <a href="https://justine.lol/mmap/">cram</a>
big models onto Mac Minis and <a href="https://github.com/ggerganov/llama.cpp/issues/2164">Rasberry Pis</a> and
jailbroken home thermostats. 
    Everybody in AI is limited by
    RAM, so the less RAM you use the more cool stuff you can do, both <a href="https://arxiv.org/abs/2211.05102">Up
        There In The Cloud</a> and down here on the edge. LLMs have billions of weights,
and if we can make these weights tighten their haunches and suck in their
paunches, we can compose better sonnets or plagiarize superior essays or
accelerate the end of days, whatever your personal motivation for using
language may be.
</p>

<p>
RAM stores information. This sounds like a tautology, but hang with me.
<a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Information is negative log-probability</a>,
and is how many bits we need to store things. If a stream of numbers is highly
predictable, for example is always contained in a limited range, we need fewer
bits to store them. If a stream of numbers is not predictable, like once in a
blue moon a mega-number shows up, we need more binary digits to encode the
Colossus.
</p>

<p>
This is what’s been happening in LLMs – for reasons that are only partially
understood, Transformer models contain these outlier weights and are
emitting Black Swan mega-activations that are much, much, much larger, like
orders of magnitude larger, than their peers. <em>But no one can get rid of them</em>;
the megalodons seem to be critical to the operation of these models, and their
existence is contrary to everything we thought we knew about neural networks
prior to building ones that worked so well. <a href="https://arxiv.org/abs/2105.06990">Many</a> <a href="https://arxiv.org/abs/2109.12948">papers</a> have been written about
these outlier values, and people have been <a href="https://arxiv.org/abs/1909.05840">cooking</a> <a href="https://arxiv.org/abs/2101.01321">up</a> <a href="https://arxiv.org/abs/2208.07339">all</a> <a href="https://arxiv.org/abs/2211.10438">kinds</a> <a href="https://arxiv.org/abs/1910.06188">of</a> bit-burning
schemes to encode them with fewer ones and zeroes, because right now we get
pretty gnarly performance degradation with vanilla scale-and-bias integer
quantization. <a href="https://github.com/ggerganov">Georgi</a> can tell you more; I’m getting ahead of myself.
</p>

<p>
The best analysis of all of this comes from a team at Qualcomm AI Research in this paper:
<strong><a href="https://arxiv.org/abs/2306.12929">Quantizable Transformers: Removing Outliers by Helping Attention Heads Do Nothing</a></strong>. The authors traced the existence of these outlier values to the
attention mechanism’s 
    softmax function,
the seemingly innocent exponentiator that no one thought capable of such
kurtotic barbarities. The researchers came <em>this close</em> to finding the
off-by-one error, like killer-in-the-closet close, but they must all be on
summer vacation in Italy as none of them are responding to my email overtures, and so I
must appeal to the international community of scholars the old-fashioned way.
</p>

<p>
If you read the linked paper, just ignore their proposals. Sounds harsh, but
hear me out. The clipped softmax comes with a wheel-spinning zero gradient, and
their gated attention proposal, while workable, introduces millions of new
parameters to solve what is really just a failure to increment. There’s a
simple and hindsight-obvious solution here that, from all of my reading, no one
has thought to try.
</p>

<p>
All right, I’ve talked up this silly error enough. I’ve alluded to its
location. Let’s talk about the 
    <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax function</a>
and why it’s
not-quite-the-right tool for the job when it comes to attention.
</p>


<h2>
The Trouble With Softmax
</h2>

<p>
Now to explain the bug you really have to understand what the attention
mechanism is trying to do. Most numerical bugs are programmers implementing
equations incorrectly. However, when you’re dealing not with bad code, but with
bad math, you need to understand where that equation comes from and what it’s
supposed to be doing before you have any hope of fixing it.
</p>

<p>
I had to read like 50 arXiV papers to understand all this, and probably I
should have taken a Udemy course or binge-watched Andrej Karpathy’s YouTube
<a href="https://www.youtube.com/c/AndrejKarpathy">channel</a> instead, but
let’s start with what is called the input embedding, which is a floating-point
vector that represents a word in the input string.
</p>

<p>
This vector seems to get taller every model year, for example the recent <a href="https://ai.meta.com/llama/">LLaMA
    2 model from Meta</a> uses an embedding vector of length 3,204, which works out to
6KB+ in half-precision floating-point, just to represent <em>one word</em> in
the vocabulary, which typically contains 30,000 - 50,000 entries.
</p>

<p>
Now if you’re a memory-miserly C programmer <a href="https://www.cyberdemon.org/2023/07/19/you-cant-dig-upwards.html">like me</a>, you might wonder, why in
the world are these AI goobers using 6KB to represent something that ought to
take, like 2 bytes tops? If their vocabulary is less than \(2^{16}\)=65,384, we
only need 16 bits to represent an entry, yeah?
</p>

<p>
Well, here is what the Transformer is actually doing: it <em>transforms</em>
(eh?) that input vector to an output vector <em>of the same size</em>, and that
final 6KB output vector needs to encode <em>absolutely everything needed to
predict the token after the current one</em>. The job of each layer of the
Transformer is quite literally adding information to the original, single-word
vector. This is where the residual (née skip) connections come in: all of the
attention machinery is just adding supplementary material to that original two
bytes’ worth of information, analyzing the larger context to indicate, for
instance, that the word <em>pupil</em> is referring to a student, and not to the
hole in your eye. Repeat the attention mechanism a few dozen times and you’ve mastered
the English language and all its vasty contents.
</p>

<p>
Now the final step of Transformer is to multiply this output vector by a
rectangular matrix, and cram the resulting vocabulary-length vector into a
softmax, treating those exponentiated outputs as next-token probabilities. This
is reasonable, but everyone knows it’s not quite right, as no sane and
respected model out there regards those output probabilities as correct, but
instead every implementation and its sister uses a <a href="https://arxiv.org/abs/2007.14966">sampling mechanism</a> to hide
the fact that softmax is over-representing low probabilities.
</p>

<p>
That’s all fine and workable; softmax in the output step gives us a gradient
for every word in the vocabulary, and it’s a reasonable choice until something
better comes along.
</p>

<p>
But what I want to argue is that sauce for the goose shouldn’t be slathered on
the gander; the Transformer’s <em>output</em> softmax serves a very different
purpose from the attention mechanism’s <em>internal</em> softmax, and we’d all
do well to get rid of the latter, or at least prop up its denominator with something
handy ⛱️.
</p>

<h3>An exponential peg…</h3>

<p>
So what is softmax? It started out in statistical mechanics as a way to
predict the distribution of states based on their energy levels:
</p><p>

\[
p_i \propto \exp\left(-\frac{\varepsilon_i}{kT}\right)
\]

</p><p>
Then the economists got a hold of it and realized that if the noise term in
people’s otherwise linear utility functions happened to follow a <a href="https://en.wikipedia.org/wiki/Gumbel_distribution">Gumbel
distribution</a> (doesn’t yours?), then the probability someone will choose an
item will be proportional to the exponent of the utility inputs:
</p><p>

\[
\Pr(Y_i=k)=\frac{\exp(X_i \beta_k)}{\sum_j \exp(X_i \beta_j)}
\]

</p><p>
This gave softmax a life in multinomial logistic functions; this is where I got
to know the old chap, as in I hand-derived the Hessian of this sucker in grad
school and coded it up to run on GPUs using linear fixed effects, which to my
knowledge no one else has been foolish enough to attempt before or since. I
just mention this because I know the softmax function better than I know many
of my humanoid friends, and I can recognize when it’s being used for things it
oughtn’t.
</p>

<p>
Softmax is a kind of cheat code to map real-valued numbers to probabilities
that sum to one. In physics, it works quite well; in economics, it’s a little
bit of a lie, but by the time it got to machine learning, it just became a
thing that seemed to work whenever a discrete choice was involved. Softmax
the vector and pick something, all right?
</p><p>

\[
(\textrm{softmax(x)})_i =\frac{\exp(x_i)}{\sum_j \exp(x_j)}
\]

</p><p>
Here’s the core mechanic of softmax: <em>it forces a choice among competing
alternatives</em>, whether it’s particles picking an energy state or consumers
choosing a car. That is, if a softmax mechanism <em>doesn’t want to choose
anything at all</em>, softmax will require modification, or else we would
expect the softmax to produce distortions once it encounters actual data.
</p>

<p>
In the context of LLMs, one of those distortions is to heavily weight
non-semantic tokens (commas and such), and those beefy weights become those
difficult-to-compress outlier values that make Life on the Edge harder
than it should be. <em>The Qualcomm AI researchers found that 97%+ of outlier
activations in LLMs occur in whitespace and punctuation positions.</em>
Something’s fishy around here… and I thought I ordered the chicken.
</p>

<h3>
    …in a linear hole
</h3>

<p>
Let’s dive in to how softmax is used inside of attention and see exactly where
it goes wrong. Here’s the equation again:
</p><p>

\[
\textrm{Attention}(Q, K, V) = \textrm{softmax}\left(\frac{QK^T}{\sqrt{d}}\right)V
\]

</p><p>
Breaking it down: in decoder-only models (i.e., everything since ChatGPT), \(Q\),
\(K\), and \(V\) all originate from the same input sequence. They’re not identical,
as they’ve been projected in different ways along the way, but in each layer
they all start with the same annotated (added-to) embedding vector.
</p>

<p>
Now: \(QK^T\) is looking for correlations between token (embedding) vectors in
different positions, essentially building up a square matrix of correlation
(dot-product scaled by \(1/\sqrt{d}\)) values, where each column and row corresponds to a token
position. Then each row of this square matrix is softmaxed, with the
resulting probabilities used as a mixing function for the value vectors in the
\(V\) matrix. The probability-mixed \(V\) gets added to the input vector, with the
sum passed on down the neural network for further processing.
</p>

<p>
Multi-head attention goes through this process several times, in parallel, per
layer. Essentially it divides up the embedding vector, and each head uses
information in the entire vector to annotate one (non-overlapping) segment of
the output vector. If you were confused by the Concatenation operation in the
<a href="https://arxiv.org/abs/1706.03762">original Transformer paper</a>, that’s all that’s happening: Head 1 adds
information to Segment 1, Head 2 adds information to Segment 2, and so on.
</p>

<p>
<em>The problem with using softmax is that it forces each attention head to
make an annotation, even if it has no information to add to the output
vector.</em> Using softmax to choose among discrete alternatives is great;
using it for optional annotation (i.e. as input into addition) is, like,
not cool, man. The problem here is exacerbated with multi-head attention, as a
specialized head is more likely to want to “pass” than a general-purpose one.
These attention heads are needlessly noisy, a deafening democracy where
abstention is disallowed.
</p>

<p>
Now it’s possible that softmax should be replaced wholesale, but it’s worked
pretty well for the most part, except for this one wee little bug that prevents
attention heads from saying nothing. So I propose a very small tweak on which I
am willing to stake all future Internet claims to being correct. The tweak
is so small, yet so obvious, and it’s been sitting here under everyone’s noses
ever since attention was <a href="https://arxiv.org/abs/1409.0473">invented</a> (2014).
</p><p>
Are you ready?
</p>

<p>
Are you <em>ready-ready</em>?
</p>

<p>
I can’t hear you.
</p>


<h2>
Softmax One and Quiet Attention
</h2>

<p>
All right, here it is and you are welcome, the long-awaited Softmax Super-Mod that
is soon to set the LLM hacker channels aflame:
</p><p>

\[
(\textrm{softmax}_1(x))_i = \frac{\exp(x_i)}{1+\sum_j \exp(x_j)}
\]

</p><p>
Bit of a let-down, eh? All I did was added one to the denominator. This lets
the vector as a whole tend to zero if it wants, but otherwise just shrinks the
values by a small amount, a shrinkage which will be made up for during
normalization, which happens right after attention.
</p>

<p>
The key difference is in the negative limit, when entries in \(x\) are significantly
less than zero and the model is trying to avoid an annotation altogether.
Compare the limiting behavior of the original softmax
</p><p>

\[
\lim_{x_1 \to -\infty} \ldots
\lim_{x_k \to -\infty} 
(\textrm{softmax}(x))_i = \frac{1}{k} \gt 0
\]

</p><p>
to that of the new and improved softmax<sub>1</sub>:
</p><p>

\[
\lim_{x_1 \to -\infty} \ldots
\lim_{x_k \to -\infty} 
(\textrm{softmax}_1(x))_i = 0
\]

</p><p>
Vanilla softmax will always emit the same total weight; softmax<sub>1</sub>
mostly looks the same, but comes with an escape hatch in the negative orthant.
To be clear: the core issue here is <em>mathematical</em> and not
<em>numerical</em> in nature. Extra precision won’t save the softmax; all
Transformers are affected.
</p>

<p>
You’ll notice a couple of other things about softmax<sub>1</sub>. The
derivative is positive, so we always have a non-zero gradient, and its sum is
between zero and one, so the output isn’t out of control. The function maintains the property
</p><p>

\[
\frac{(\textrm{softmax}_1(x))_i}{(\textrm{softmax}_1(x))_j} 
= \frac{(\textrm{softmax}(x))_i}{(\textrm{softmax}(x))_j} 
= \frac{\exp(x_i)}{\exp(x_j)} \quad \forall \ i, j
\]

</p><p>i.e. relative values in the output vector are unchanged.</p>

<p>
Originally I wanted to call this
function <em>ghostmax</em>, as you can think of there being an extra
zero-valued entry in \(x\) (as \(\exp(0)=1\)), as well as a zero vector in the
\(V\) matrix that attenuates the result. But I didn’t want to scare anyone.
</p>

<p>
Even though softmax<sub>1</sub> is facially quite boring, I’m 99.44% sure that it will
resolve the outlier feedback loop that’s making quantization the subject of
cascades of research. If you want to run some experiments and prove me right,
<a href="https://twitter.com/EvMill">DM me on Twitter</a> and we’ll get a
paper going.
</p>

<p>
We can call the improved mechanism <em>QuietAttention</em>, as it allows
attention heads to keep their yaps shut. So may I propose to a receptive public
</p><p>

\[
\textrm{QuietAttention}(Q, K, V) := \textrm{softmax}_1 \left(\frac{QK^T}{\sqrt{d}}\right)V
\]

</p><p>
I think a test could be hacked together fairly quickly: if you prefix every
input context with a zero vector, and ensure that your neural network of choice
doesn’t add any bias (including with the positional encoding), then the zero
should pass through unaltered and will have the effect of adding unity to every
subsequent softmax denominator; that way you won’t lose your mind mucking with 
gradient code. I <em>think</em> this could be done with a LLaMA model that uses
fixed embeddings and a special prefix token, but 
I’d very much like to get
back to my non-existent hobbies, and
I’ve already spent more time
on this problem than my therapist needs to know about.
</p>

<p>
You’d still have to re-train the model, so don’t try this on an RPi just yet.
But do let me know how those weight kurtoses and activation infinity norms are
looking after a few runs. I’m thinking those numbers will make for a handsome
table in a soon-to-be influential arXiV paper, either when those Qualcomm AI
researchers step off the plane from Italy, or someone in an LLM hacker channel
figures out <code>biblatex</code>, whichever happens first.
</p>



<hr/>

<p><em>You’re reading <a href="https://www.cyberdemon.org/">evanmiller.org</a>, a random collection of math, tech, and musings. If you liked this you might also enjoy:
    </em></p><ul><em>
        <li><a href="https://www.cyberdemon.org/2023/07/19/how-not-to-sort-by-average-rating.html">How Not To Sort By Average Rating</a>
        </li><li><a href="https://www.cyberdemon.org/2023/07/19/winkel-tripel-warping-trouble.html">Winkel Tripel Warping Trouble</a>
        </li><li><a href="https://www.cyberdemon.org/2023/07/19/you-cant-spell-cuped-without-frisch-waugh-lovell.html">You Can’t Spell CUPED Without Frisch-Waugh-Lovell</a>
        </li><li><a href="https://www.cyberdemon.org/2023/07/19/evaluating-splatoons-ranking-system.html">Evaluating Splatoon’s Ranking System</a>
    </li></em></ul>

<hr/>
<p><em>Get new articles as they’re published, via <a href="https://www.linkedin.com/in/evanmmiller/">LinkedIn</a>, <a href="https://twitter.com/EvMill">Twitter</a>, or <a href="https://www.cyberdemon.org/news.xml">RSS</a>.</em></p>

<hr/>

<p><em>Want to look for statistical patterns in your MySQL, PostgreSQL, or SQLite database? My desktop statistics software <strong><a href="https://www.wizardmac.com/">Wizard</a></strong> can help you analyze <strong>more data in less time</strong> and <strong>communicate discoveries visually</strong> without spending days struggling with pointless command syntax. Check it out!</em></p>
<div>
<p><a href="https://www.wizardmac.com/"><img height="128" width="128" src="https://www.cyberdemon.org/2023/07/19/images/index/wizard2.png"/></a></p></div>


<hr/>

<p><a href="https://www.cyberdemon.org/">Back to Evan Miller’s home page</a> 
– <a href="https://www.cyberdemon.org/news.xml">Subscribe to RSS</a>
– <a href="https://www.linkedin.com/in/evanmmiller/">LinkedIn</a>
– <a href="https://twitter.com/EvMill">Twitter</a> 
</p>

<hr/>

</div>
</div></div>
  </body>
</html>
