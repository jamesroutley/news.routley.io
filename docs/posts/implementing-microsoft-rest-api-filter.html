<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sergeykibish.com/blog/implementing-microsoft-rest-api-filter/">Original</a>
    <h1>Implementing Microsoft REST API Filter</h1>
    
    <div id="readability-page-1" class="page"><div><p>Enterprise organizations try to adapt Microsoft REST API Guidelines<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> as a basis for their services more and more.
Overall, this is a good idea.
Few points why:</p><ol><li>Everybody likes standards</li><li>It’s good to stand on the shoulder of the giants who developed good practices which are proven by time</li></ol><p>Something is simple to follow, something is not, like <code>$filter</code>.</p><p>Some time ago I searched for a good examples of how <code>$filter</code> can be implemented to match the guidelines requirements<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.
Have not found such example, so here is mine for you!</p><p>By looking at <code>$filter</code> you might draw a parallel with OData Filter<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> and you would be right.
Microsoft definitely are inspired by OData because:</p><ul><li>They are OData initiators<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></li><li>ASP.NET (Microsoft thing) even has an out-of-the-box tooling to create OData server<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></li></ul><p>But guidelines are generic, they should be applicable to any tooling.
As we know, many enterprises are built using Java.</p><p>In this post I will show you how to work with <code>$filter</code> outside the Microsoft tooling.</p><h2 id="the-problem">The problem <a href="#the-problem">¶</a></h2><p>Looking at the requirements we can see the following challenges that should be solved:</p><ul><li>Filter has set of operations that SHOULD be supported</li><li>Logical, comparison and grouping operators<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> SHOULD be implemented to support the operations</li></ul><p>Data should be queryable like so:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>GET https://api.contoso.com/v1.0/products?$filter=(name eq &#39;Milk&#39; or name eq &#39;Eggs&#39;) and price lt 2.55
</span></span></code></pre></div><p>Goal of the solution is translsate the following query:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>(name eq &#39;Milk&#39; or name eq &#39;Eggs&#39;) and price lt 2.55
</span></span></code></pre></div><p>Into some database query:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>WHERE</span><span> </span><span>(</span><span>name</span><span>=</span><span>&#39;Milk&#39;</span><span> </span><span>OR</span><span> </span><span>name</span><span>=</span><span>&#39;Eggs&#39;</span><span>)</span><span> </span><span>AND</span><span> </span><span>price</span><span> </span><span>&lt;</span><span> </span><span>2</span><span>.</span><span>55</span><span>
</span></span></span></code></pre></div><h2 id="writing-a-parser">Writing a parser <a href="#writing-a-parser">¶</a></h2><p>To solve such problem (translate one thing into another) parsers<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> are used.</p><p>Parsers usually construct the tree that can be traversed.
We could traverse it, extract tokens and create a query.
Tokens are nodes in a tree.
This is a task of lexer<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> to understand what nodes (tokens) are there in a string.</p><p>I will not dive in the topic of compilers<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> in this post but when Lexers and/or Parsers are mentioned, usually it means that compliers topic is touched.</p><p>Tree that we aim to construct for the string above should look close to this one:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>            -------and------
</span></span><span><span>           /                \
</span></span><span><span>      ----or----            lt
</span></span><span><span>     /          \         /    \
</span></span><span><span>    eq          eq     price  2.55
</span></span><span><span>  /    \      /    \
</span></span><span><span>name &#39;Milk&#39; name &#39;Eggs&#39;
</span></span></code></pre></div><p>Then, for Mongo, we would be able to construct the following query walking this tree:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>{ $and: [
</span></span><span><span>    { $or: [
</span></span><span><span>        { name: { $eq: &#34;Milk&#34; } },
</span></span><span><span>        { name: { $eq: &#34;Eggs&#34; } }
</span></span><span><span>      ]
</span></span><span><span>    },
</span></span><span><span>    { price: { $lt: 2.55 } }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div><p>Sounds fun, huh?
But before going further let me ask a question.
Do we want to write our own complier for this task?
No!</p><p>Still, we need somehow to defined the language (grammar), feed it to some tool which then will be able to understand how to construct a tree from the given string.
Seems like a Machine Learning task nowadays, right?
No!</p><h2 id="welcome-antlr">Welcome ANTLR <a href="#welcome-antlr">¶</a></h2><p>Thankfully, there is ANTLR (ANother Tool for Language Recognition)<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup> which does what we need:</p><ol><li>We can describe the language</li><li>Give tool a text</li><li>It will construct the tree</li><li>We will be able to walk it</li></ol><p>First, we need to create the grammar for our <code>$filter</code> language.
Grammar in ANTLR is described in a similar to Backus–Naur (BNF) form<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup>.
Not diving into the details we will end-up with the following grammar.
You should read it from bottom to top.
If you are interested in more details of what’s happening here I’m highly suggesting to go through the fantastic ANTLR Mega Tutorial<sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup>.
On the high level I will explain it after the snippet.</p><div><pre tabindex="0"><code data-lang="antlr"><span><span><span>grammar</span><span> </span><span>Filter</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>filter</span><span>:</span><span> </span><span>expr</span><span>+</span><span> </span><span>EOF</span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>expr</span><span>
</span></span></span><span><span><span> </span><span>:</span><span> </span><span>OPAR</span><span> </span><span>expr</span><span> </span><span>CPAR</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>NOT</span><span> </span><span>PROPERTY</span><span> </span><span>COMPARISON</span><span> </span><span>VALUE</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>PROPERTY</span><span> </span><span>COMPARISON</span><span> </span><span>VALUE</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>expr</span><span> </span><span>AND</span><span> </span><span>expr</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>expr</span><span> </span><span>OR</span><span> </span><span>expr</span><span>
</span></span></span><span><span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>OPAR</span><span>:</span><span> </span><span>&#39;(&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>CPAR</span><span>:</span><span> </span><span>&#39;)&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>OR</span><span>  </span><span>:</span><span> </span><span>&#39;or&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>AND</span><span> </span><span>:</span><span> </span><span>&#39;and&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>NOT</span><span> </span><span>:</span><span> </span><span>&#39;not&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>COMPARISON</span><span>:</span><span> </span><span>(</span><span>GT</span><span> </span><span>|</span><span> </span><span>GE</span><span> </span><span>|</span><span> </span><span>LT</span><span> </span><span>|</span><span> </span><span>LE</span><span> </span><span>|</span><span> </span><span>EQ</span><span> </span><span>|</span><span> </span><span>NE</span><span>)</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>GT</span><span> </span><span>:</span><span> </span><span>&#39;gt&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>GE</span><span> </span><span>:</span><span> </span><span>&#39;ge&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>LT</span><span> </span><span>:</span><span> </span><span>&#39;lt&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>LE</span><span> </span><span>:</span><span> </span><span>&#39;le&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>EQ</span><span> </span><span>:</span><span> </span><span>&#39;eq&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span></span><span>NE</span><span> </span><span>:</span><span> </span><span>&#39;ne&#39;</span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>VALUE</span><span>
</span></span></span><span><span><span> </span><span>:</span><span> </span><span>TRUE</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>FALSE</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>INT</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>FLOAT</span><span>
</span></span></span><span><span><span> </span><span>|</span><span> </span><span>STRING</span><span>
</span></span></span><span><span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>TRUE</span><span>
</span></span></span><span><span><span> </span><span>:</span><span> </span><span>&#39;true&#39;</span><span>
</span></span></span><span><span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>FALSE</span><span>
</span></span></span><span><span><span> </span><span>:</span><span> </span><span>&#39;false&#39;</span><span>
</span></span></span><span><span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>PROPERTY</span><span>
</span></span></span><span><span><span> </span><span>:</span><span> </span><span>ALLOWED_CHARACTERS</span><span>+</span><span> </span><span>(</span><span>&#39;.&#39;</span><span> </span><span>ALLOWED_CHARACTERS</span><span>+)*</span><span>
</span></span></span><span><span><span> </span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fragment</span><span> </span><span>ALLOWED_CHARACTERS</span><span> </span><span>:</span><span> </span><span>[</span><span>a-zA-Z0-9_-</span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>STRING</span><span>
</span></span></span><span><span><span> </span><span>:</span><span> </span><span>&#39;\&#39;&#39;</span><span> </span><span>(~</span><span>[</span><span>&#39;\r\n] | &#39;\&#39;\&#39;&#39;)* &#39;\&#39;&#39;
</span></span></span><span><span><span> ;
</span></span></span><span><span><span>
</span></span></span><span><span><span>INT
</span></span></span><span><span><span> : DIGIT+
</span></span></span><span><span><span> ;
</span></span></span><span><span><span>
</span></span></span><span><span><span>FLOAT
</span></span></span><span><span><span> : DIGIT+ &#39;.&#39; DIGIT*
</span></span></span><span><span><span> | &#39;.&#39; DIGIT+
</span></span></span><span><span><span> ;
</span></span></span><span><span><span>
</span></span></span><span><span><span>fragment DIGIT : </span><span>[</span><span>0-9</span><span>]</span><span> ;
</span></span></span><span><span><span>
</span></span></span><span><span><span>SPACE
</span></span></span><span><span><span> : </span><span>[</span><span> \t\r\n</span><span>]</span><span> -&gt; skip
</span></span></span><span><span><span> ;
</span></span></span></code></pre></div><p>Taking some inspiration from OData <code>$filter</code> syntax in Azure Cognitive Search<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup> I came up with the grammar which you see above.
This grammar describes that:</p><ol><li>Spaces, tabs and new lines are ignored for tokenization</li><li>Strings should be quoted in <code>&#39;</code> and if you want to escape a quote in a string, e.g. <code>Mary&#39;s</code>, you should double it (<code>Mary&#39;&#39;s</code>)</li><li>Numbers can be <code>0</code>, <code>0.0</code> or <code>.0</code></li><li>Booleans are <code>true</code> and <code>false</code></li><li>Expression are of various forms and those can have nested expressions</li></ol><p>Time to code!</p><h2 id="environment-setup">Environment setup <a href="#environment-setup">¶</a></h2><p>Because ANTLR is Java based tool I will use a better Java language which is Kotlin<sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup>.</p><p>The setup is:</p><ul><li>Kotlin</li><li>Gradle</li><li>(optional) IntelliJ IDEA (I’m using Community Edition)</li></ul><p>After default Kotlin project structure generation let’s add the ANTLR.
Extend your <code>build.gradle.kts</code> file with the following lines:</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>plugins</span> <span>{</span>
</span></span><span><span>  <span>antlr</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>dependencies</span> <span>{</span>
</span></span><span><span>  <span>antlr</span><span>(</span><span>&#34;org.antlr:antlr4:4.10.1)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>tasks</span><span>.</span><span>generateGrammarSource</span> <span>{</span>
</span></span><span><span>  <span>maxHeapSize</span> <span>=</span> <span>&#34;64m&#34;</span>
</span></span><span><span>  <span>arguments</span> <span>=</span> <span>arguments</span> <span>+</span> <span>listOf</span><span>(</span><span>&#34;-long-messages&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>tasks</span><span>.</span><span>named</span><span>(</span><span>&#34;compileTestKotlin&#34;</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>dependsOn</span><span>(</span><span>&#34;:generateTestGrammarSource&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>tasks</span><span>.</span><span>named</span><span>(</span><span>&#34;compileKotlin&#34;</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>dependsOn</span><span>(</span><span>&#34;:generateGrammarSource&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We’ve added ANTRL dependency and instructed Gradle to build classes from found grammars when we compile project or compiling tests.</p><h2 id="creating-grammar-file">Creating grammar file <a href="#creating-grammar-file">¶</a></h2><p>Now let’s add our grammar which we defined higher in the post.</p><p>Create a file <code>Filter.g4</code> in the <code>main/antlr/com/your/path/antlr4</code> package and copy the content.</p><p>ANTLR will generate Lexer and Parses classes based on the grammar.
We want generated classes to be added to the package which is not <code>root</code>.
To do so we need to instruct ANTLR to add package definition to the generated class files.
Add the following:</p><div><pre tabindex="0"><code data-lang="antlr"><span><span><span>@header</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>package com.your.path.antlr4;
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>to the <code>Filter.g4</code> file after the line <code>grammar Filter;</code>.</p><p>Now we are ready to write a class which will transform the input into Mongo query.
You can do the similar for another DB, I’ve chosen Mongo.</p><h2 id="creating-listener">Creating Listener <a href="#creating-listener">¶</a></h2><p>Create <code>FilterListener.kt</code> file and create a class:</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>class</span> <span>FilterListener</span> <span>:</span> <span>FilterBaseListener</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>private</span> <span>var</span> <span>result</span><span>:</span> <span>MutableList</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>=</span> <span>mutableListOf</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p><code>FilterBaseListener</code> is a class generated by ANTLR.</p><p>I’ve named our class it <code>FilterListener</code> listener because we will use listener for this task, not visitor.
What is the difference between the two can be found in the Mega Tutorial listed above or in a nice summary on StackOverflow<sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup>.</p><p>List <code>result</code> is where values will be pushed during the query string construction.</p><p>We want to build something when exiting expression nodes.
For this we need to override the <code>exitExpr</code> method.</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>class</span> <span>FilterListener</span> <span>:</span> <span>FilterBaseListener</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>override</span> <span>fun</span> <span>exitExpr</span><span>(</span><span>ctx</span><span>:</span> <span>FilterParser</span><span>.</span><span>ExprContext</span><span>?)</span> <span>{}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We are interested to run the code when we are leaving the <code>and</code>, <code>or</code> and comparison expressions.</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>class</span> <span>FilterListener</span> <span>:</span> <span>FilterBaseListener</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>override</span> <span>fun</span> <span>exitExpr</span><span>(</span><span>ctx</span><span>:</span> <span>FilterParser</span><span>.</span><span>ExprContext</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>when</span> <span>{</span>
</span></span><span><span>      <span>ctx</span><span>.</span><span>COMPARISON</span><span>()</span> <span>!=</span> <span>null</span> <span>-&gt;</span> <span>buildComparison</span><span>(</span>
</span></span><span><span>        <span>property</span> <span>=</span> <span>ctx</span><span>.</span><span>PROPERTY</span><span>().</span><span>text</span><span>,</span>
</span></span><span><span>        <span>operator</span> <span>=</span> <span>ctx</span><span>.</span><span>COMPARISON</span><span>().</span><span>text</span><span>,</span>
</span></span><span><span>        <span>value</span> <span>=</span> <span>ctx</span><span>.</span><span>VALUE</span><span>().</span><span>text</span>
</span></span><span><span>      <span>)</span>
</span></span><span><span>      <span>ctx</span><span>.</span><span>AND</span><span>()</span> <span>!=</span> <span>null</span> <span>-&gt;</span> <span>buildAnd</span><span>()</span>
</span></span><span><span>      <span>ctx</span><span>.</span><span>OR</span><span>()</span> <span>!=</span> <span>null</span> <span>-&gt;</span> <span>buildOr</span><span>()</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Method <code>buildComparison</code> is responsible for constructing the valid Mongo Comparison Query Operator based on the data received.
Looks like this:</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>private</span> <span>fun</span> <span>buildComparison</span><span>(</span><span>property</span><span>:</span> <span>String</span><span>,</span> <span>operator</span><span>:</span> <span>String</span><span>,</span> <span>value</span><span>:</span> <span>String</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>val</span> <span>parsed</span> <span>=</span> <span>when</span> <span>{</span>
</span></span><span><span>    <span>value</span> <span>==</span> <span>&#34;true&#34;</span> <span>||</span> <span>value</span> <span>==</span> <span>&#34;false&#34;</span> <span>-&gt;</span> <span>value</span>
</span></span><span><span>    <span>value</span><span>.</span><span>toDoubleOrNull</span><span>()</span> <span>!=</span> <span>null</span> <span>-&gt;</span> <span>&#34;</span><span>${value.toDouble()}</span><span>&#34;</span>
</span></span><span><span>    <span>else</span> <span>-&gt;</span>
</span></span><span><span>      <span>&#34;</span><span>\&#34;</span><span>${</span>
</span></span><span><span>      <span>value</span>
</span></span><span><span>        <span>.</span><span>drop</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span>        <span>.</span><span>dropLast</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span>        <span>.</span><span>split</span><span>(</span><span>&#34;&#39;&#39;&#34;</span><span>)</span>
</span></span><span><span>        <span>.</span><span>joinToString</span><span>(</span><span>&#34;&#39;&#34;</span><span>)</span>
</span></span><span><span>      <span>}</span><span>\</span><span>&#34;&#34;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>val</span> <span>q</span> <span>=</span> <span>when</span> <span>(</span><span>operator</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>&#34;gt&#34;</span><span>,</span> <span>&#34;lt&#34;</span><span>,</span> <span>&#34;eq&#34;</span><span>,</span> <span>&#34;ne&#34;</span> <span>-&gt;</span> <span>comparisonQueryOperator</span><span>(</span><span>property</span><span>,</span> <span>&#34;</span><span>\$</span><span>$operator</span><span>&#34;</span><span>,</span> <span>parsed</span><span>)</span>
</span></span><span><span>    <span>&#34;ge&#34;</span> <span>-&gt;</span> <span>comparisonQueryOperator</span><span>(</span><span>property</span><span>,</span> <span>&#34;</span><span>\$</span><span>gte&#34;</span><span>,</span> <span>parsed</span><span>)</span>
</span></span><span><span>    <span>&#34;le&#34;</span> <span>-&gt;</span> <span>comparisonQueryOperator</span><span>(</span><span>property</span><span>,</span> <span>&#34;</span><span>\$</span><span>lte&#34;</span><span>,</span> <span>parsed</span><span>)</span>
</span></span><span><span>    <span>else</span> <span>-&gt;</span> <span>throw</span> <span>Exception</span><span>(</span><span>&#34;operator </span><span>$operator</span><span> not implemented&#34;</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>result</span><span>.</span><span>add</span><span>(</span><span>q</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>private</span> <span>fun</span> <span>comparisonQueryOperator</span><span>(</span><span>property</span><span>:</span> <span>String</span><span>,</span> <span>operator</span><span>:</span> <span>String</span><span>,</span> <span>value</span><span>:</span> <span>String</span><span>):</span> <span>String</span> <span>{</span>
</span></span><span><span>  <span>return</span> <span>&#34;{ </span><span>\&#34;</span><span>$property</span><span>\&#34;</span><span>: { </span><span>$operator</span><span>: </span><span>$value</span><span> } }&#34;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>How it works:</p><ul><li>If it’s <code>true</code> or <code>false</code> then we just return these values because they are booleans.</li><li>If it’s something numeric, try to convert it to double.</li><li>If it’s not any from the above, it should be a string.</li><li>Finally construct the query itself.</li></ul><p>Because queries can be combined with help of <code>and</code> or <code>or</code> we need to implements methods which will create <code>and</code> and <code>or</code> queries from what is saved to the <code>result</code>.</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>private</span> <span>fun</span> <span>buildAnd</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>val</span> <span>(</span><span>left</span><span>,</span> <span>right</span><span>)</span> <span>=</span> <span>result</span>
</span></span><span><span>  <span>result</span> <span>=</span> <span>mutableListOf</span><span>()</span>
</span></span><span><span>
</span></span><span><span>  <span>result</span><span>.</span><span>add</span><span>(</span><span>&#34;{ </span><span>\$</span><span>and: [ </span><span>$left</span><span>, </span><span>$right</span><span> ] }&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>private</span> <span>fun</span> <span>buildOr</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>val</span> <span>(</span><span>left</span><span>,</span> <span>right</span><span>)</span> <span>=</span> <span>result</span>
</span></span><span><span>  <span>result</span> <span>=</span> <span>mutableListOf</span><span>()</span>
</span></span><span><span>
</span></span><span><span>  <span>result</span><span>.</span><span>add</span><span>(</span><span>&#34;{ </span><span>\$</span><span>or: [ </span><span>$left</span><span>, </span><span>$right</span><span> ] }&#34;</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The <code>result</code> list will always have only left and right side of the tree (two values in the list).
AND and OR are combination of left and right parts.</p><h2 id="traversing-the-built-tree">Traversing the built tree <a href="#traversing-the-built-tree">¶</a></h2><p>Now it’s time to write the public method which takes the raw filter as string and returns the Mongo query back.</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>fun</span> <span>generateQueryString</span><span>(</span><span>filter</span><span>:</span> <span>String</span><span>):</span> <span>String</span> <span>{</span>
</span></span><span><span>  <span>// lexer
</span></span></span><span><span><span></span>  <span>val</span> <span>chars</span> <span>=</span> <span>CharStreams</span><span>.</span><span>fromString</span><span>(</span><span>filter</span><span>)</span>
</span></span><span><span>  <span>val</span> <span>lexer</span> <span>=</span> <span>FilterLexer</span><span>(</span><span>chars</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>// parser
</span></span></span><span><span><span></span>  <span>val</span> <span>tokens</span> <span>=</span> <span>CommonTokenStream</span><span>(</span><span>lexer</span><span>)</span>
</span></span><span><span>  <span>val</span> <span>parser</span> <span>=</span> <span>FilterParser</span><span>(</span><span>tokens</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>// walk
</span></span></span><span><span><span></span>  <span>ParseTreeWalker</span><span>().</span><span>walk</span><span>(</span><span>this</span><span>,</span> <span>parser</span><span>.</span><span>filter</span><span>())</span>
</span></span><span><span>  <span>return</span> <span>result</span><span>.</span><span>last</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Here ANTLR classes are used to construct lexer, parser, filter, walk the tree and return the result.</p><h2 id="checking-that-it-works">Checking that it works <a href="#checking-that-it-works">¶</a></h2><p>In <code>Main.kt</code> you can now write the following:</p><div><pre tabindex="0"><code data-lang="kt"><span><span><span>fun</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>print</span><span>(</span><span>&#34;input filter: &#34;</span><span>)</span>
</span></span><span><span>  <span>val</span> <span>filter</span> <span>=</span> <span>readln</span><span>()</span>
</span></span><span><span>  <span>val</span> <span>filterListener</span> <span>=</span> <span>FilterListener</span><span>()</span>
</span></span><span><span>  <span>println</span><span>(</span><span>&#34;output:&#34;</span><span>)</span>
</span></span><span><span>  <span>println</span><span>(</span><span>filterListener</span><span>.</span><span>generateQueryString</span><span>(</span><span>filter</span><span>))</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>And try it out in the terminal:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>input filter: name eq <span>&#39;Milk&#39;</span>
</span></span><span><span>output:
</span></span><span><span><span>{</span> <span>&#34;name&#34;</span>: <span>{</span> <span>$eq</span>: <span>&#34;Milk&#34;</span> <span>}</span> <span>}</span>
</span></span></code></pre></div><h2 id="closing-words">Closing words <a href="#closing-words">¶</a></h2><p>So this is how you can start building out the filter.
Hope this helps!
There is a <a href="https://github.com/skibish/ms-rest-api-filter-implementation-example">bigger example on GitHub</a> that you can explore.
But please be aware that <strong>this is an example and not production ready code to use</strong>.
Use for inspiration.
PRs with improvements are welcome.</p></div></div>
  </body>
</html>
