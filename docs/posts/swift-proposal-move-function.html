<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md">Original</a>
    <h1>Swift Proposal: Move Function</h1>
    
    <div id="readability-page-1" class="page"><div>

    <div data-target="readme-toc.content">
      
  


        <div id="readme">
    <article itemprop="text">
<ul dir="auto">
<li>Proposal: <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md">SE-0366</a></li>
<li>Authors: <a href="https://github.com/gottesmm">Michael Gottesman</a>, <a href="https://github.com/atrick">Andrew Trick</a>, <a href="https://github.com/jckarter">Joe Groff</a></li>
<li>Review Manager: <a href="https://github.com/hborla">Holly Borla</a></li>
<li>Status: <strong>Active Review (July 25...August 8, 2022)</strong></li>
<li>Implementation: Implemented on main as stdlib SPI (<code>_move</code> instead of <code>move</code>)</li>
<li>Review: (<a href="https://forums.swift.org/t/pitch-move-function-use-after-move-diagnostic" rel="nofollow">pitch</a>) (<a href="https://forums.swift.org/t/se-0366-move-function-use-after-move-diagnostic/59202" rel="nofollow">review</a>)</li>
</ul>
<h2 dir="auto"><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Introduction</h2>
<p dir="auto">In this document, we propose adding a new function called <code>move</code> to the swift
standard library, which ends the lifetime of a specific local <code>let</code>,
local <code>var</code>, or <code>consuming</code> function parameter, and which enforces this
by causing the compiler to emit a diagnostic upon any uses that are after the
move function. This allows for code that relies on <strong>forwarding ownership</strong>
of values for performance or correctness to communicate that requirement to
the compiler and to human readers. As an example:</p>
<div data-snippet-clipboard-copy-content="useX(x) // do some stuff with local variable x

// Ends lifetime of x, y&#39;s lifetime begins.
let y = move(x) // [1]

useY(y) // do some stuff with local variable y
useX(x) // error, x&#39;s lifetime was ended at [1]

// Ends lifetime of y, destroying the current value
// since it is explicitly thrown away assigning to `_`
_ = move(y) // [2]
useX(x) // error, x&#39;s lifetime was ended at [1]
useY(y) // error, y&#39;s lifetime was ended at [2]"><pre><span>useX</span>(x) <span><span>//</span> do some stuff with local variable x</span>
<span></span>
<span><span>//</span> Ends lifetime of x, y&#39;s lifetime begins.</span>
<span></span><span>let</span> y <span>=</span> <span>move</span>(x) <span><span>//</span> [1]</span>
<span></span>
<span>useY</span>(y) <span><span>//</span> do some stuff with local variable y</span>
<span></span><span>useX</span>(x) <span><span>//</span> error, x&#39;s lifetime was ended at [1]</span>
<span></span>
<span><span>//</span> Ends lifetime of y, destroying the current value</span>
<span><span>//</span> since it is explicitly thrown away assigning to `_`</span>
<span></span><span>_</span> <span>=</span> <span>move</span>(y) <span><span>//</span> [2]</span>
<span></span><span>useX</span>(x) <span><span>//</span> error, x&#39;s lifetime was ended at [1]</span>
<span></span><span>useY</span>(y) <span><span>//</span> error, y&#39;s lifetime was ended at [2]</span></pre></div>
<h2 dir="auto"><a id="user-content-motivation" aria-hidden="true" href="#motivation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Motivation</h2>
<p dir="auto">Swift uses reference counting and copy-on-write to allow for developers to
write code with value semantics, without normally having to worry too much
about performance or memory management. However, in performance sensitive code,
developers want to be able to control the uniqueness of COW data structures and
reduce retain/release calls in a way that is future-proof against changes to
the language implementation or source code. Consider the following array/uniqueness
example:</p>
<div data-snippet-clipboard-copy-content="func test() {
  var x: [Int] = getArray()
  
  // x is appended to. After this point, we know that x is unique. We want to
  // preserve that property.
  x.append(5)
  
  // We create a new variable y so we can write an algorithm where we may
  // change the value of y (causing a COW copy of the buffer shared with x).
  var y = x
  longAlgorithmUsing(&amp;y)
  consumeFinalY(y)

  // We no longer use y after this point. Ideally, x would be guaranteed
  // unique so we know we can append again without copying.
  x.append(7)
}"><pre><span>func</span> <span>test</span>() {
  <span>var</span> x: [<span>Int</span>] <span>=</span> <span>getArray</span>()
  
  <span><span>//</span> x is appended to. After this point, we know that x is unique. We want to</span>
<span></span>  <span><span>//</span> preserve that property.</span>
<span></span>  x.<span>append</span>(<span>5</span>)
  
  <span><span>//</span> We create a new variable y so we can write an algorithm where we may</span>
<span></span>  <span><span>//</span> change the value of y (causing a COW copy of the buffer shared with x).</span>
<span></span>  <span>var</span> y <span>=</span> x
  <span>longAlgorithmUsing</span>(<span>&amp;</span>y)
  <span>consumeFinalY</span>(y)

  <span><span>//</span> We no longer use y after this point. Ideally, x would be guaranteed</span>
<span></span>  <span><span>//</span> unique so we know we can append again without copying.</span>
<span></span>  x.<span>append</span>(<span>7</span>)
}</pre></div>
<p dir="auto">In the example above, <code>y</code>&#39;s formal lifetime extends to the end of
scope. When we go back to using <code>x</code>, although the compiler may optimize
the actual lifetime of <code>y</code> to release it after its last use, there isn&#39;t
a strong guarantee that it will. Even if the optimizer does what we want,
programmers modifying this code in the future
may introduce new references to <code>y</code> that inadvertently extend its lifetime
and break our attempt to keep <code>x</code> unique. There isn&#39;t any indication in the
source code that that the end of <code>y</code>&#39;s use is important to the performance
characteristics of the code.</p>
<p dir="auto">Swift-evolution pitch thread: <a href="https://forums.swift.org/t/pitch-move-function-use-after-move-diagnostic" rel="nofollow">https://forums.swift.org/t/pitch-move-function-use-after-move-diagnostic</a></p>
<h2 dir="auto"><a id="user-content-proposed-solution-move-function--use-after-move-diagnostic" aria-hidden="true" href="#proposed-solution-move-function--use-after-move-diagnostic"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Proposed solution: Move Function + &#34;Use After Move&#34; Diagnostic</h2>
<p dir="auto">That is where the <code>move</code> function comes into play. The <code>move</code> function consumes
a <strong>movable binding</strong>, which is either
an unescaped local <code>let</code>, unescaped local <code>var</code>, or function argument, with
no property wrappers or get/set/read/modify/etc. accessors applied. It then
provides a compiler guarantee that the binding will
be unable to be used again locally. If such a use occurs, the compiler will
emit an error diagnostic. We can modify the previous example to use <code>move</code> to
explicitly end the lifetime of <code>y</code> when we&#39;re done with it:</p>
<div data-snippet-clipboard-copy-content="func test() {
  var x: [Int] = getArray()
  
  // x is appended to. After this point, we know that x is unique. We want to
  // preserve that property.
  x.append(5)
  
  // We create a new variable y so we can write an algorithm where we may
  // change the value of y (causing a COW copy of the buffer shared with x).
  var y = x
  longAlgorithmUsing(&amp;y)
  // We no longer use y after this point, so move it when we pass it off to
  // the last use.
  consumeFinalY(move(y))

  // x will be unique again here.
  x.append(7)
}"><pre><span>func</span> <span>test</span>() {
  <span>var</span> x: [<span>Int</span>] <span>=</span> <span>getArray</span>()
  
  <span><span>//</span> x is appended to. After this point, we know that x is unique. We want to</span>
<span></span>  <span><span>//</span> preserve that property.</span>
<span></span>  x.<span>append</span>(<span>5</span>)
  
  <span><span>//</span> We create a new variable y so we can write an algorithm where we may</span>
<span></span>  <span><span>//</span> change the value of y (causing a COW copy of the buffer shared with x).</span>
<span></span>  <span>var</span> y <span>=</span> x
  <span>longAlgorithmUsing</span>(<span>&amp;</span>y)
  <span><span>//</span> We no longer use y after this point, so move it when we pass it off to</span>
<span></span>  <span><span>//</span> the last use.</span>
<span></span>  <span>consumeFinalY</span>(<span>move</span>(y))

  <span><span>//</span> x will be unique again here.</span>
<span></span>  x.<span>append</span>(<span>7</span>)
}</pre></div>
<p dir="auto">This addresses both of the motivating issues above: <code>move</code> guarantees the
lifetime of <code>y</code> ends at the given point, allowing the compiler to generate
code to clean up or transfer ownership of <code>y</code> without relying on optimization.
Furthermore, if a future maintainer modifies the code in a way that extends
the lifetime of <code>y</code> past the expected point, then the compiler will raise an
error. For instance, if a maintainer later introduces an additional use of
<code>y</code> after the move, it will raise an error:</p>
<div data-snippet-clipboard-copy-content="func test() {
  var x: [Int] = getArray()
  
  // x is appended to. After this point, we know that x is unique. We want to
  // preserve that property.
  x.append(5)
  
  // We create a new variable y so we can write an algorithm where we may
  // change the value of y (causing a COW copy of the buffer shared with x).
  var y = x
  longAlgorithmUsing(&amp;y)
  // We think we no longer use y after this point...
  consumeFinalY(move(y))

  // ...and x will be unique again here...
  x.append(7)

  // ...but this additional use of y snuck in:
  useYAgain(y) // error: &#39;y&#39; used after being moved
}"><pre><span>func</span> <span>test</span>() {
  <span>var</span> x: [<span>Int</span>] <span>=</span> <span>getArray</span>()
  
  <span><span>//</span> x is appended to. After this point, we know that x is unique. We want to</span>
<span></span>  <span><span>//</span> preserve that property.</span>
<span></span>  x.<span>append</span>(<span>5</span>)
  
  <span><span>//</span> We create a new variable y so we can write an algorithm where we may</span>
<span></span>  <span><span>//</span> change the value of y (causing a COW copy of the buffer shared with x).</span>
<span></span>  <span>var</span> y <span>=</span> x
  <span>longAlgorithmUsing</span>(<span>&amp;</span>y)
  <span><span>//</span> We think we no longer use y after this point...</span>
<span></span>  <span>consumeFinalY</span>(<span>move</span>(y))

  <span><span>//</span> ...and x will be unique again here...</span>
<span></span>  x.<span>append</span>(<span>7</span>)

  <span><span>//</span> ...but this additional use of y snuck in:</span>
<span></span>  <span>useYAgain</span>(y) <span><span>//</span> error: &#39;y&#39; used after being moved</span>
<span></span>}</pre></div>
<p dir="auto"><code>move</code> only ends the lifetime of a specific movable binding.  It is not tied to
the lifetime of the value of the binding at the time of the move, or to any
particular object instance. If we declare another local constant <code>other</code> with
the same value of <code>x</code>, we can use that other binding after we end the lifetime
of <code>x</code>, as in:</p>
<div data-snippet-clipboard-copy-content="func useX(_ x: SomeClassType) -&gt; () {}
func consumeX(_ x: __owned SomeClassType) -&gt; () {}

func f() {
  let x = ...
  useX(x)
  let other = x   // other is a new binding used to extend the lifetime of x
  _ = move(x) // x&#39;s lifetime ends
  useX(other)     // other is used here... no problem.
  consumeX(other) // other is used here... no problem.
}"><pre><span>func</span> <span>useX</span>(<span>_</span> <span>x</span>: SomeClassType) <span>-&gt;</span> () {}
<span>func</span> <span>consumeX</span>(<span>_</span> <span>x</span>: __owned SomeClassType) <span>-&gt;</span> () {}

<span>func</span> <span>f</span>() {
  <span>let</span> x <span>=</span> <span>...</span>
  <span>useX</span>(x)
  <span>let</span> other <span>=</span> x   <span><span>//</span> other is a new binding used to extend the lifetime of x</span>
<span></span>  <span>_</span> <span>=</span> <span>move</span>(x) <span><span>//</span> x&#39;s lifetime ends</span>
<span></span>  <span>useX</span>(other)     <span><span>//</span> other is used here... no problem.</span>
<span></span>  <span>consumeX</span>(other) <span><span>//</span> other is used here... no problem.</span>
<span></span>}</pre></div>
<p dir="auto">In fact, each movable binding&#39;s lifetime is tracked independently, and gets a
separate diagnostic if used after move. We can move <code>other</code> independently
of <code>x</code>, and get separate diagnostics for both variables:</p>
<div data-snippet-clipboard-copy-content="func useX(_ x: SomeClassType) -&gt; () {}
func consumeX(_ x: __owned SomeClassType) -&gt; () {}

func f() {
  let x = ...
  useX(x)
  let other = x
  _ = move(x)
  useX(move(other))
  consumeX(other) // error: &#39;other&#39; used after being moved
  useX(x) // error: &#39;x&#39; used after being moved
}"><pre><span>func</span> <span>useX</span>(<span>_</span> <span>x</span>: SomeClassType) <span>-&gt;</span> () {}
<span>func</span> <span>consumeX</span>(<span>_</span> <span>x</span>: __owned SomeClassType) <span>-&gt;</span> () {}

<span>func</span> <span>f</span>() {
  <span>let</span> x <span>=</span> <span>...</span>
  <span>useX</span>(x)
  <span>let</span> other <span>=</span> x
  <span>_</span> <span>=</span> <span>move</span>(x)
  <span>useX</span>(<span>move</span>(other))
  <span>consumeX</span>(other) <span><span>//</span> error: &#39;other&#39; used after being moved</span>
<span></span>  <span>useX</span>(x) <span><span>//</span> error: &#39;x&#39; used after being moved</span>
<span></span>}</pre></div>
<p dir="auto">If a local <code>var</code> is moved, then a new value can be assigned into
the variable after an old value has been moved out. One can
begin using the var again after one re-assigns to the var:</p>
<div data-snippet-clipboard-copy-content="func f() {
  var x = getValue()
  let _ = move(x)
  useX(x) // error: no value in x
  x = getValue()
  useX(x) // ok, x has a new value here
}"><pre><span>func</span> <span>f</span>() {
  <span>var</span> x <span>=</span> <span>getValue</span>()
  <span>let</span> <span>_</span> <span>=</span> <span>move</span>(x)
  <span>useX</span>(x) <span><span>//</span> error: no value in x</span>
<span></span>  x <span>=</span> <span>getValue</span>()
  <span>useX</span>(x) <span><span>//</span> ok, x has a new value here</span>
<span></span>}</pre></div>
<p dir="auto">This follows from move being applied to the binding (<code>x</code>), not the value in the
binding (the value returned from <code>getValue()</code>).</p>
<p dir="auto">We also support applying the move operation to consuming function arguments:</p>
<div data-snippet-clipboard-copy-content="func f(_ x: __owned SomeClassType) {
    let _ = move(x)
    useX(x) // !! Error! Use of x after move
}"><pre><span>func</span> <span>f</span>(<span>_</span> <span>x</span>: __owned SomeClassType) {
    <span>let</span> <span>_</span> <span>=</span> <span>move</span>(x)
    <span>useX</span>(x) <span><span>//</span> !! Error! Use of x after move</span>
<span></span>}</pre></div>
<p dir="auto">Normal arguments are passed by borrow, meaning that the lifetime of the value
is managed by the caller. Although we could allow <code>move</code> on these arguments,
shortening the syntactic lifetime of the variable, doing so would have no
practical effect on the value&#39;s lifetime at runtime, so we choose to leave this
disallowed for now, in order to avoid potentially misleading developers who
might expect the value to be destroyed at the point of the move.</p>
<p dir="auto">On the other hand, one can <code>move</code> out of an <code>inout</code>
function argument. Like a <code>var</code>, the <code>inout</code> argument can be reassigned after
being moved from and used again; however, since the final value of an
<code>inout</code> argument is passed back to the caller, an <code>inout</code> argument <em>must</em> be
reassigned by the callee before it returns. This will raise an error because
<code>buffer</code> doesn&#39;t have a value at the point of return:</p>
<div data-snippet-clipboard-copy-content="func f(_ buffer: inout Buffer) { // error: &#39;buffer&#39; not reinitialized after move!
  let b = move(buffer)           // note: move was here
  b.deinitialize()
  ... write code ...
}                                // note: return without reassigning inout argument `buffer`"><pre><span>func</span> <span>f</span>(<span>_</span> <span>buffer</span>: <span>inout</span> <span>Buffer</span>) { <span><span>//</span> error: &#39;buffer&#39; not reinitialized after move!</span>
<span></span>  <span>let</span> b <span>=</span> <span>move</span>(buffer)           <span><span>//</span> note: move was here</span>
<span></span>  b.<span>deinitialize</span>()
  <span>...</span> write code <span>...</span>
}                                <span><span>//</span> note: return without reassigning inout argument `buffer`</span></pre></div>
<p dir="auto">But we can reinitialize <code>buffer</code> by writing the following code:</p>
<div data-snippet-clipboard-copy-content="func f(_ buffer: inout Buffer) {
  let b = move(buffer)
  b.deinitialize()
  // ... write code ...
  // We re-initialized buffer before end of function so the checker is satisfied
  buffer = getNewInstance()
}"><pre><span>func</span> <span>f</span>(<span>_</span> <span>buffer</span>: <span>inout</span> <span>Buffer</span>) {
  <span>let</span> b <span>=</span> <span>move</span>(buffer)
  b.<span>deinitialize</span>()
  <span><span>//</span> ... write code ...</span>
<span></span>  <span><span>//</span> We re-initialized buffer before end of function so the checker is satisfied</span>
<span></span>  buffer <span>=</span> <span>getNewInstance</span>()
}</pre></div>
<p dir="auto"><code>defer</code> can also be used to reinitialize an <code>inout</code> or <code>var</code> after a move,
in order to ensure that reassignment happens on any exit from scope, including
thrown errors or breaks out of loops. So we can also write:</p>
<div data-snippet-clipboard-copy-content="func f(_ buffer: inout Buffer) {
  let b = move(buffer)
  // Ensure the buffer is reinitialized before we exit.
  defer { buffer = getNewInstance() }
  try b.deinitializeOrError()
  // ... write code ...
}"><pre><span>func</span> <span>f</span>(<span>_</span> <span>buffer</span>: <span>inout</span> <span>Buffer</span>) {
  <span>let</span> b <span>=</span> <span>move</span>(buffer)
  <span><span>//</span> Ensure the buffer is reinitialized before we exit.</span>
<span></span>  <span>defer</span> { buffer <span>=</span> <span>getNewInstance</span>() }
  <span>try</span> b.<span>deinitializeOrError</span>()
  <span><span>//</span> ... write code ...</span>
<span></span>}</pre></div>
<h2 dir="auto"><a id="user-content-detailed-design" aria-hidden="true" href="#detailed-design"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Detailed design</h2>
<p dir="auto">We declare <code>move</code> as follows:</p>
<div data-snippet-clipboard-copy-content="/// This function ends the lifetime of the passed in binding.
func move&lt;T&gt;(_ value: __owned T) -&gt; T"><pre><span><span>///</span> This function ends the lifetime of the passed in binding.</span>
<span></span><span>func</span> <span>move</span>&lt;<span>T</span>&gt;(<span>_</span> <span>value</span>: __owned T) <span>-&gt;</span> T</pre></div>
<p dir="auto">At runtime, the function returns <code>value</code> unmodified back to its caller.
However, at compile time, the presence of a call to <code>move</code> forces
ownership of the argument to be transferred out of the binding at the given
point, and triggers diagnostics that prove that it is safe to do so,
by flagging any proceeding uses of the binding that are reachable from the move.
The argument to <code>move</code> is required to be a reference to a <em>movable binding</em>.
The following kinds of declarations can currently be referenced as movable
bindings:</p>
<ul dir="auto">
<li>a local <code>let</code> constant in the immediately-enclosing function,</li>
<li>a local <code>var</code> variable in the immediately-enclosing function,</li>
<li>one of the immediately-enclosing function&#39;s parameters that
has the <code>__owned</code> or <code>inout</code> ownership modifier, or</li>
<li>the <code>self</code> parameter in a <code>mutating</code> or <code>__consuming</code> method.</li>
</ul>
<p dir="auto">A movable binding also must satisfy the following requirements:</p>
<ul dir="auto">
<li>it cannot be captured by an <code>@escaping</code> closure or nested function,</li>
<li>it cannot have any property wrappers applied,</li>
<li>it cannot have any accessors attached, such as <code>get</code>, <code>set</code>,
<code>didSet</code>, <code>willSet</code>, <code>_read</code>, or <code>_modify</code>,</li>
<li>it cannot be an <code>async let</code>.</li>
</ul>
<p dir="auto">Possible extensions to the set of movable bindings are discussed under
Future Directions. It is an error to pass <code>move</code> an argument that doesn&#39;t
reference a movable binding.</p>
<p dir="auto">Given a valid movable binding, the compiler ensures that there are no other
references to the binding after it is moved. The analysis is
flow sensitive, so one is able to end the lifetime of a value conditionally:</p>
<div data-snippet-clipboard-copy-content="if condition {
  let y = move(x)
  // I can&#39;t use x anymore here!
  useX(x) // !! ERROR! Use after move.
} else {
  // I can still use x here!
  useX(x) // OK
}
// But I can&#39;t use x here.
useX(x) // !! ERROR! Use after move."><pre><span>if</span> condition {
  <span>let</span> y <span>=</span> <span>move</span>(x)
  <span><span>//</span> I can&#39;t use x anymore here!</span>
<span></span>  <span>useX</span>(x) <span><span>//</span> !! ERROR! Use after move.</span>
<span></span>} <span>else</span> {
  <span><span>//</span> I can still use x here!</span>
<span></span>  <span>useX</span>(x) <span><span>//</span> OK</span>
<span></span>}
<span><span>//</span> But I can&#39;t use x here.</span>
<span></span><span>useX</span>(x) <span><span>//</span> !! ERROR! Use after move.</span></pre></div>
<p dir="auto">If the binding is a <code>var</code>, the analysis additionally allows for code to
conditionally reinitialize the var and thus be able to use it in positions
that are dominated by the reinitialization. Consider the
following example:</p>
<div data-snippet-clipboard-copy-content="if condition {
  let _ = move(x)
  // I can&#39;t use x anymore here!
  useX(x) // !! ERROR! Use after move.
  x = newValue
  // But now that I have re-assigned into x a new value, I can use the var
  // again.
  useX(x) // OK
} else {
  // I can still use x here, since it wasn&#39;t moved on this path!
  useX(x) // OK
}
// Since I reinitialized x along the `if` branch, and it was never moved
// from on the `else` branch, I can use it here too.
useX(x) // OK"><pre><span>if</span> condition {
  <span>let</span> <span>_</span> <span>=</span> <span>move</span>(x)
  <span><span>//</span> I can&#39;t use x anymore here!</span>
<span></span>  <span>useX</span>(x) <span><span>//</span> !! ERROR! Use after move.</span>
<span></span>  x <span>=</span> newValue
  <span><span>//</span> But now that I have re-assigned into x a new value, I can use the var</span>
<span></span>  <span><span>//</span> again.</span>
<span></span>  <span>useX</span>(x) <span><span>//</span> OK</span>
<span></span>} <span>else</span> {
  <span><span>//</span> I can still use x here, since it wasn&#39;t moved on this path!</span>
<span></span>  <span>useX</span>(x) <span><span>//</span> OK</span>
<span></span>}
<span><span>//</span> Since I reinitialized x along the `if` branch, and it was never moved</span>
<span><span>//</span> from on the `else` branch, I can use it here too.</span>
<span></span><span>useX</span>(x) <span><span>//</span> OK</span></pre></div>
<p dir="auto">Notice how in the above, we are able to use <code>x</code> both in the true block AND the
code after the <code>if</code> block, since over both paths through the <code>if</code>, <code>x</code> ends up
with a valid value before proceeding.</p>
<p dir="auto">For an <code>inout</code> parameter, the analysis behaves the same as for a <code>var</code>, except
that all exits from the function (whether by <code>return</code> or by <code>throw</code>) are
considered to be uses of the parameter. Correct code therefore <em>must</em> reassign
inout parameters after they are moved from.</p>
<h2 dir="auto"><a id="user-content-source-compatibility" aria-hidden="true" href="#source-compatibility"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Source compatibility</h2>
<p dir="auto">This is additive. If a user already in their module has a function called
&#34;move&#34;, they can call the Stdlib specific move by calling Swift.move.</p>
<h2 dir="auto"><a id="user-content-effect-on-abi-stability" aria-hidden="true" href="#effect-on-abi-stability"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Effect on ABI stability</h2>
<p dir="auto"><code>move</code> will use the <code>@_alwaysEmitIntoClient</code> attribute, so that it adds no
ABI requirements to the standard library or clients.</p>
<h2 dir="auto"><a id="user-content-effect-on-api-resilience" aria-hidden="true" href="#effect-on-api-resilience"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Effect on API resilience</h2>
<p dir="auto">None, this is additive.</p>
<h2 dir="auto"><a id="user-content-alternatives-considered" aria-hidden="true" href="#alternatives-considered"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternatives considered</h2>
<h3 dir="auto"><a id="user-content-alternative-spellings" aria-hidden="true" href="#alternative-spellings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternative spellings</h3>
<p dir="auto">As a function, <code>move</code> is rather unusual, since it only accepts certain forms of
expression as its argument, and it doesn&#39;t really have any runtime behavior
of its own, acting more as a marker for the compiler to perform additional
analysis. As such, many have suggested alternative spellings that make <code>move</code>&#39;s
special nature more syntactically distinct, including:</p>
<ul dir="auto">
<li>a contextual keyword operator, like <code>useX(move x)</code></li>
<li>an expression attribute, like <code>useX(@move x)</code></li>
<li>a compiler directive, like <code>useX(#move(x))</code></li>
</ul>
<p dir="auto">There are also potentially other names besides <code>move</code> that we could use. We&#39;re
proposing using the name <code>move</code> because it is an established term of art in
other programming language communities including C++ and Rust, as well as a
term that has already been used in other Swift standard library APIs such as
the <code>UnsafeMutablePointer.move*</code> family of methods that move a value out of
memory referenced by a pointer.</p>
<p dir="auto">Declaring <code>move</code> as a function also minimizes the potential impact to the
language syntax. We&#39;ve introduced new contextual keywords without breaking
compatibility before, like <code>some</code> and <code>any</code> for types. But to do so, we&#39;ve had
to impose constraints on their use, such as not allowing the constraints
modified by <code>some</code> or <code>any</code> to be parenthesized to avoid the result looking
like a function call. Although that would be acceptable for <code>move</code> given its
current constraints, it might be premature to assume we won&#39;t expand the
capabilities of <code>move</code> to include more expression forms.</p>
<h3 dir="auto"><a id="user-content-drop-function" aria-hidden="true" href="#drop-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>drop</code> function</h3>
<p dir="auto">We could also introduce a separate <code>drop</code> function like languages like Rust does
that doesn&#39;t have a result like <code>move</code> does. We decided not to go with this
since in Swift the idiomatic way to throw away a value is to assign to <code>_</code>
implying that the idiomatic way to write <code>drop</code> would be:</p>

<p dir="auto">suggesting adding an additional API would not be idiomatic. We do not propose
making <code>move</code> use the <code>@discardableResult</code> attribute, so that this kind of
standalone drop is syntactically explicit in client code.</p>
<h2 dir="auto"><a id="user-content-future-directions" aria-hidden="true" href="#future-directions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Future directions</h2>
<h3 dir="auto"><a id="user-content-dynamic-enforcement-of-move-for-other-kinds-of-bindings" aria-hidden="true" href="#dynamic-enforcement-of-move-for-other-kinds-of-bindings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dynamic enforcement of <code>move</code> for other kinds of bindings</h3>
<p dir="auto">In the future, we may expand the set of movable bindings to include globals,
escaped local variables, and class stored properties, although doing so in full
generality would require dynamic enforcement in addition to static checking to
ensure that shared state is not read from once it is moved, similar to how we
need to dynamically enforce exclusivity when accessing globals and class stored
properties. Since this dynamic enforcement turns misuse of <code>move</code>s into runtime
errors rather than compile-time guarantees, we might want to make those dynamic
cases syntactically distinct, to make the possibility of runtime errors clear.</p>
<h3 dir="auto"><a id="user-content-piecewise-move-of-frozen-structs-and-tuples" aria-hidden="true" href="#piecewise-move-of-frozen-structs-and-tuples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Piecewise <code>move</code> of frozen structs and tuples</h3>
<p dir="auto">For frozen structs and tuples, both aggregates that the compiler can statically
know the layout of, we could do finer-grained analysis and allow their
individual fields to be moved independently:</p>
<div data-snippet-clipboard-copy-content="struct TwoStrings {
  var first: String
  var second: String
}

func foo(x: __owned TwoStrings) {
  use(move(x.first))
  // ERROR! part of x was moved out of
  use(x)
  // OK, this part wasn&#39;t
  use(x.second)
}"><pre><span>struct</span> <span>TwoStrings</span> {
  <span>var</span> first: <span>String</span>
  <span>var</span> second: <span>String</span>
}

<span>func</span> <span>foo</span>(<span><span>x</span></span>: __owned TwoStrings) {
  <span>use</span>(<span>move</span>(x.<span>first</span>))
  <span><span>//</span> ERROR! part of x was moved out of</span>
<span></span>  <span>use</span>(x)
  <span><span>//</span> OK, this part wasn&#39;t</span>
<span></span>  <span>use</span>(x.<span>second</span>)
}</pre></div>
<h3 dir="auto"><a id="user-content-move-of-computed-properties-property-wrappers-properties-with-accessors-etc" aria-hidden="true" href="#move-of-computed-properties-property-wrappers-properties-with-accessors-etc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>move</code> of computed properties, property wrappers, properties with accessors, etc.</h3>
<p dir="auto">It would potentially be useful to be able to move variables and properties with
modified access behavior, such as computed properties, properties with
didSet/willSet observers, property wrappers, and so on. Although we could do
move analysis on these properties, we wouldn&#39;t be able to get the full
performance benefits from consuming a computed variable without allowing
for some additional accessors to be defined, such as a &#34;consuming getter&#34; that
can consume its <code>self</code> in order to produce the property value, and an
initializer to reinitialize <code>self</code> on reassignment after a <code>move</code>.</p>
<h3 dir="auto"><a id="user-content-suppressing-implicit-copying" aria-hidden="true" href="#suppressing-implicit-copying"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Suppressing implicit copying</h3>
<p dir="auto">Another useful tool for programmers is to be able to suppress Swift&#39;s usual
implicit copying rules for a type, specific values, or a scope. The <code>move</code> function
as proposed is not intended to be a replacement for move-only types or for
&#34;no-implicit-copy&#34; constraints on values or scopes. The authors believe that
there is room in the language for both features; <code>move</code> is a useful incremental
annotation for code that is value type- or object-oriented which needs
minor amounts of fine control for performance. Suppressing implicit copies can
ultimately achieve the same goal, but requires adapting to a stricter
programming model and controlling ownership in order to avoid the need for
explicit copies or to eliminate copies entirely. That level of control
definitely has its place, but requires a higher investment than we expect
<code>move</code> to.</p>
<h2 dir="auto"><a id="user-content-acknowledgments" aria-hidden="true" href="#acknowledgments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Acknowledgments</h2>
<p dir="auto">Thanks to Nate Chandler, Tim Kientzle, and Holly Borla for their help with this!</p>
</article>
  </div>

    </div>

  </div></div>
  </body>
</html>
