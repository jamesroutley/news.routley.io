<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408">Original</a>
    <h1>PEP 750: Tag Strings for Writing Domain-Specific Languages</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
              <p>Thanks, I can tell a lot of good thought went into this PEP. Overall, I like the design and think it would be a good addition to the language.</p>
<p>However, I have one <em>significant</em> concern. It relates to the deferred evaluation of interpolation expressions. I understand the motivation for this design choice, but I think it has many downsides that are not recognized or addressed in the PEP. The good news is that there are reasonable ways to accommodate lazy evaluation use cases without any of these downsides (more on that later).</p>
<p>Let me start by trying to convince you that deferring the evaluation of interpolation expressions in the common case is a bad idea.</p>
<p>First, it complicates the mental model for users of tag strings. They have to assume that all of their interpolation expressions may not be evaluated immediately. Deferred evaluation requires special considerations, so doing it implicitly leads to surprises. It places a higher burden on users to make their code correct in all circumstances. If they are the author of both the tag function and the tag string, this is less of an issue, but in many cases these will be different developers.</p>
<p>Users of tag strings cannot reassign or modify any of the values used in interpolation expressions after the tag string definition because the final evaluated string may be affected.</p>
<pre data-code-wrap="python"><code>name = &#34;Bob&#34;
my_str = greet&#34;hello {name}&#34;

name = &#34;Ellen&#34;
print(my_str) # What would you expect here?

del name
print(my_str) # Will this crash?
</code></pre>
<p>There is no guarantee that evaluations will be performed by the tag function exactly once and in a left-to-right order.</p>
<pre data-code-wrap="python"><code>id = 1
def get_next_id():
    global id
    id += 1
    return id

my_str = tag_fn&#34;{get_next_id()}: a, {get_next_id()}: b&#34;
print(my_str) # Is this guaranteed to print &#34;1: a, 2: b&#34;?
# What if the tag function evaluates them multiple times?
# What if the tag function evaluates them in a different order?
# What if the tag function skips evaluating some of the?

print(my_str) # Will this print &#34;3: a, 4: b&#34;?
</code></pre>
<p>Second, when users encounter problems like this, the issue will be difficult to debug. Debugging async code is challenging in general, and this is even more challenging because debuggers will typically lack the context to show users what is executing at the time the bug occurs.</p>
<p>Third, static analysis tools like mypy and pyright will need to conservatively assume that all interpolation expressions are evaluated in a deferred manner. This means they’ll inevitably produce false positives in cases where evaluation isn’t deferred (the common case). Here’s an example:</p>
<pre data-code-wrap="python"><code>def func(name_or_id: str | int):
    if isinstance(name_or_id, str):
        # The type of name_or_id is narrowed to `str` here,
        # but the narrowed type cannot be used if `name_or_id`
        # is evaluated in a deferred manner. This will result in
        # a static type error when calling the `upper` method.
        print(greet&#34;Hello {name_or_id.upper()}!&#34;)
</code></pre>
<hr/>
<p>I see two potential ways to avoid some or all of the above problems.</p>
<p><strong>Fix 1</strong> (my recommendation): Make deferred execution explicit by having the user provide a callable in the interpolation expression. This fix addresses all of the problems I mentioned above.</p>
<p>With this fix, all interpolation expressions are evaluated immediately by the runtime, as they are with f-strings. This guarantees that they are all evaluated exactly once in left-to-right order, preserving the common-sense mental model of f-strings.</p>
<p>In the (relatively rare) case where the user wants their interpolation expression to be evaluated lazily (e.g. because it’s an expensive call or the information is not yet available) and this functionality is supported by the tag function, they can provide a lambda or other callable in their interpolation expression. If a tag function supports deferred (lazy) evaluation, it can look at the evaluated value of the interpolation expression and determine whether it’s callable. If it’s callable, it should call it to retrieve the value. If the value is not callable, the tag function should assume that the value can be used directly in a non-deferred manner.</p>
<pre data-code-wrap="python"><code>name = &#34;Ralph&#34;

# `name` is evaluated immediately
greet&#34;Hello {name}&#34;

# The expression `lambda: name` is evaluated immediately.
# It is callable, so the tag function calls it in a deferred
# manner to retrieve the final value.
greet&#34;Hello {lambda: name}!&#34;

# Here &#34;tag&#34; is evaluated immediately but `fetch_body_deferred`
# is callable, so it is called in a deferred manner.
tag = &#34;body&#34;
def fetch_body_deferred() -&gt; str: ...
html&#34;&lt;{tag}&gt;{fetch_body_deferred}&lt;{/tag}&gt;&#34;
</code></pre>
<p>The nice thing about this approach is that the common case (where deferred evaluation isn’t needed or desired) is much simpler. It puts the user of the tag string in control. In the less-common situation where deferred evaluation is desired, it’s clear to the user — and to static analysis tools — that deferred evaluation is being used. Users can be more cautious when deferred evaluation is intended, and static analysis tools can detect potential programming errors that result from deferred evaluation without generating false positives in the common immediate-evaluation case.</p>
<hr/>
<p><strong>(Partial) Fix 2</strong>: Document clear expectations for tag functions. This mitigates some, but not all, of the problems. I don’t recommend this fix unless there are objections to fix 1.</p>
<p>This fix involves a clear, documented contract for tag functions. They should be expected to evaluate every interpolation expression exactly once and in order. If they fail to honor this contract, users of tag strings may see unexpected behaviors.</p>
<p>This approach is still problematic because it addresses only some of the problems. There’s also no way for the runtime or static analysis tools to enforce this contract, so there’s still potential for bugs.</p>
            </div></div>
  </body>
</html>
