<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.swtch.com/pcdata">Original</a>
    <h1>Storing Data in Control Flow</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        
        

<p>
A decision that arises over and over when designing concurrent programs
is whether to represent program state in control flow or as data.
This post is about what that decision means and how to approach it.
Done well, taking program state stored in data
and storing it instead in control flow can make programs
much clearer and more maintainable than they otherwise would be.

</p><p>
Before saying much more, it’s important to note that
<a href="https://www.youtube.com/watch?v=oV9rvDllKEg">concurrency is not parallelism.</a>:
</p><ul>
<li>


<p>
Concurrency is about <i>how you write programs</i>,
about being able to compose independently executing control flows,
whether you call them processes or threads or goroutines,
so that your program can be <i>dealing with</i> lots of things at once without turning into a giant mess.
</p></li><li>


<p>
On the other hand, parallelism is about <i>how you execute programs</i>,
allowing multiple computations to run simultaneously,
so that your program can be <i>doing</i> lots of things at once efficiently.</p></li></ul>


<p>
Concurrency lends itself naturally to parallel execution,
but the focus in this post is about how to use concurrency
to write cleaner programs, not faster ones.

</p><p>
The difference between concurrent programs and non-concurrent programs
is that concurrent programs can be written as if they are executing multiple
independent control flows at the same time.
The name for the smaller control flows varies by language:
thread, task, process, fiber, coroutine, goroutine, and so on.
No matter the name, the fundamental point for this post
is that writing a program in terms of multiple independently executing control flows
allows you to store program state in the execution state of one or more
of those control flows, specifically in the program counter
(which line is executing in that piece)
and on the stack.
Control flow state can always be maintained as explicit data instead,
but then the explicit data form is essentially simulating the control flow.
Most of the time, using the control flow features built into a programming language
is easier to understand, reason about, and maintain than simulating them
in data structures.

</p><p>
The rest of this post illustrates the rather abstract claims I’ve been making
about storing data in control flow by walking through some
concrete examples.
They happen to be written in <a href="https://go.dev/">Go</a>,
but the ideas apply to any language that supports writing concurrent programs,
including essentially every modern language.
<a href="#step"></a></p><h2 id="step"><a href="#step">A Step-by-Step Example</a></h2>


<p>
Here is a seemingly trivial problem
that demonstrates what it means to store program state in control flow.
Suppose we are reading characters from a file and want to scan over a C-style double-quoted string.
In this case, we have a non-parallel program.
There is no opportunity for parallelism here,
but as we will see, concurrency can still play a useful part.

</p><p>
If we don’t worry about checking the exact escape sequences in the string,
it suffices to match the regular expression <code>&#34;([^&#34;\\]|\\.)*&#34;</code>,
which matches a double quote, then a sequence of zero or more characters,
and then another double quote.
Between the quotes, a character is anything that’s not a quote or backslash,
or else a backslash followed by anything (including a quote or backslash).

</p><p>
Every regular expression can be compiled into finite automaton or state machine,
so we might use a tool to turn that specification into this Go code:
</p><pre>state := 0
for {
    c := read()
    switch state {
    case 0:
        if c != &#39;&#34;&#39; {
            return false
        }
        state = 1
    case 1:
        if c == &#39;&#34;&#39; {
            return true
        }
        if c == &#39;\\&#39; {
            state = 2
        } else {
            state = 1
        }
    case 2:
        state = 1
    }
}
</pre>


<p>
The code has a single variable named <code>state</code> that represents the state of the automaton.
The for loop reads a character and updates the state, over and over,
until it finds either the end of the string or a syntax error.
This is the kind of code that a program would write and that only a program could love.
It’s difficult for people to read, and it will be difficult for people to maintain.

</p><p>
The main reason this program is so opaque is that its program state is stored as data,
specifically in the variable named <code>state</code>.
When it’s possible to store state in code instead, that often leads to a clearer program.
To see this, let’s transform the program, one small step at a time,
into an equivalent but much more understandable version.

</p><p>
We can start by duplicating the <code>read</code> calls into each case of the switch:
</p><pre><span>state := 0                          state := 0</span>
<span>for {                               for {</span>
    c := read()                     
<span>    switch state {                      switch state {</span>
<span>    case 0:                             case 0:</span>
                                            c := read()
<span>        if c != &#39;&#34;&#39; {                       if c != &#39;&#34;&#39; {</span>
<span>            return false                        return false</span>
<span>        }                                   }</span>
<span>        state = 1                           state = 1</span>
<span>    case 1:                             case 1:</span>
                                            c := read()
<span>        if c == &#39;&#34;&#39; {                       if c == &#39;&#34;&#39; {</span>
<span>            return true                         return true</span>
<span>        }                                   }</span>
<span>        if c == &#39;\\&#39; {                      if c == &#39;\\&#39; {</span>
<span>            state = 2                           state = 2</span>
<span>        } else {                            } else {</span>
<span>            state = 1                           state = 1</span>
<span>        }                                   }</span>
<span>    case 2:                             case 2:</span>
                                            c := read()
<span>        state = 1                           state = 1</span>
<span>    }                                   }</span>
<span>}                                   }</span>
</pre>


<p>
(In this and all the displays that follow, the old program is on the left, the new program
is on the right, and lines that haven’t changed are printed in gray text.)

</p><p>
Now, instead of writing to <code>state</code> and then immediately going around the for loop again
to look up what to do in that state, we can use code labels and goto statements:
</p><pre>state := 0                          state0:
for {                               
    switch state {                  
    case 0:                         
<span>        c := read()                     c := read()</span>
<span>        if c != &#39;&#34;&#39; {                   if c != &#39;&#34;&#39; {</span>
<span>            return false                    return false</span>
<span>        }                               }</span>
        state = 1                       goto state1
    case 1:                         state1:
<span>        c := read()                     c := read()</span>
<span>        if c == &#39;&#34;&#39; {                   if c == &#39;&#34;&#39; {</span>
<span>            return true                     return true</span>
<span>        }                               }</span>
<span>        if c == &#39;\\&#39; {                  if c == &#39;\\&#39; {</span>
            state = 2                       goto state2
<span>        } else {                        } else {</span>
            state = 1                       goto state1
<span>        }                               }</span>
    case 2:                         state2:
        c := read()                     read()
        state = 1                       goto state1
    }                               
}                                   
</pre>


<p>
Then we can simplify the program further.
The <code>goto</code> <code>state1</code> right before the <code>state1</code> label is a no-op and can be deleted.
And we can see that there’s only one way to get to state2,
so we might as well replace the <code>goto</code> <code>state2</code> with the actual code from state2:
</p><pre><span>state0:                         state0:</span>
<span>    c := read()                     c := read()</span>
<span>    if c != &#39;&#34;&#39; {                   if c != &#39;&#34;&#39; {</span>
<span>        return false                    return false</span>
<span>    }                               }</span>
    goto state1                 
<span>state1:                         state1:</span>
<span>    c := read()                     c := read()</span>
<span>    if c == &#39;&#34;&#39; {                   if c == &#39;&#34;&#39; {</span>
<span>        return true                     return true</span>
<span>    }                               }</span>
<span>    if c == &#39;\\&#39; {                  if c == &#39;\\&#39; {</span>
        goto state2             
    } else {                    
        goto state1             
    }                           
state2:                         
<span>    read()                              read()</span>
<span>    goto state1                         goto state1</span>
                                    } else {
                                        goto state1
                                    }
</pre>


<p>
Then we can factor the “goto state1” out of both branches of the if statement.
</p><pre><span>state0:                         state0:</span>
<span>    c := read()                     c := read()</span>
<span>    if c != &#39;&#34;&#39; {                   if c != &#39;&#34;&#39; {</span>
<span>        return false                    return false</span>
<span>    }                               }</span>
<span>                                </span>
<span>state1:                         state1:</span>
<span>    c := read()                     c := read()</span>
<span>    if c == &#39;&#34;&#39; {                   if c == &#39;&#34;&#39; {</span>
<span>        return true                     return true</span>
<span>    }                               }</span>
<span>    if c == &#39;\\&#39; {                  if c == &#39;\\&#39; {</span>
<span>        read()                          read()</span>
        goto state1                 }
    } else {                        goto state1
        goto state1             
    }                           
</pre>


<p>
Then we can drop the unused <code>state0</code> label and replace the <code>state1</code> loop with an actual loop.
Now we have something that looks like a real program:
</p><pre>state0:                         
<span>    c := read()                 c := read()</span>
<span>    if c != &#39;&#34;&#39; {               if c != &#39;&#34;&#39; {</span>
<span>        return false                return false</span>
<span>    }                           }</span>
<span>                                </span>
state1:                         for {
<span>    c := read()                     c := read()</span>
<span>    if c == &#39;&#34;&#39; {                   if c == &#39;&#34;&#39; {</span>
<span>        return true                     return true</span>
<span>    }                               }</span>
<span>    if c == &#39;\\&#39; {                  if c == &#39;\\&#39; {</span>
<span>        read()                          read()</span>
<span>    }                               }</span>
    goto state1                 }
</pre>


<p>
We can simplify a little further, eliminating some unnecessary variables,
and we can make the check for the final quote (<code>c</code> <code>==</code> <code>&#34;&#34;</code>) be the loop terminator.
</p><pre>c := read()                     if read() != &#39;&#34;&#39; {
if c != &#39;&#34;&#39; {                   
<span>    return false                    return false</span>
<span>}                               }</span>
<span>                                </span>
for {                           var c byte
    c := read()                 for c != &#39;&#34;&#39; {
    if c == &#39;&#34;&#39; {                   c = read()
        return true             
    }                           
<span>    if c == &#39;\\&#39; {                  if c == &#39;\\&#39; {</span>
<span>        read()                          read()</span>
<span>    }                               }</span>
<span>}                               }</span>
                                return true
</pre>


<p>
The final version is:
</p><pre>func parseQuoted(read func() byte) bool {
    if read() != &#39;&#34;&#39; {
        return false
    }
    var c byte
    for c != &#39;&#34;&#39; {
        c = read()
        if c == &#39;\\&#39; {
            read()
        }
    }
    return true
}
</pre>


<p>
Earlier I explained the regular expression by saying it
“matches a double quote, then a sequence of zero or more characters,
and then another double quote.
Between the quotes, a character is anything that’s not a quote or backslash,
or else a backslash followed by anything.”
It’s easy to see that this program does exactly that.

</p><p>
Hand-written programs can have opportunities to use control flow too.
For example, here is a version that a person might have written by hand:
</p><pre>if read() != &#39;&#34;&#39; {
    return false
}
inEscape := false
for {
    c := read()
    if inEscape {
        inEscape = false
        continue
    }
    if c == &#39;&#34;&#39; {
        return true
    }
    if c == &#39;\\&#39; {
        inEscape = true
    }
}
</pre>


<p>
The same kinds of small steps can be used to convert the boolean variable
<code>inEscape</code> from data to control flow,
ending at the same cleaned up version.

</p><p>
Either way, the <code>state</code> variable in the original is now implicitly represented
by the program counter, meaning which part of the program is executing.
The comments in this version indicate the implicit value of the original’s
<code>state</code> (or <code>inEscape</code>) variables:
</p><pre><span>func parseQuoted(read func() byte) bool {</span>
    // state == 0
<span>    if read() != &#39;&#34;&#39; {</span>
<span>        return false</span>
<span>    }</span>
<span></span>
<span>    var c byte</span>
<span>    for c != &#39;&#34;&#39; {</span>
        // state == 1 (inEscape = false)
<span>        c = read()</span>
<span>        if c == &#39;\\&#39; {</span>
            // state == 2 (inEscape = true)
<span>            read()</span>
<span>        }</span>
<span>    }</span>
<span>    return true</span>
<span>}</span>
</pre>


<p>
The original program was, in essence, <i>simulating</i> this control flow
using the explicit <code>state</code> variable as a program counter,
tracking which line was executing.
If a program can be converted to store explicit state in control flow instead,
then that explicit state was merely an awkward simulation of the control flow.
<a href="#more"></a></p><h2 id="more"><a href="#more">More Threads for More State</a></h2>


<p>
Before widespread support for concurrency,
that kind of awkward simulation was often necessary,
because a different part of the program wanted
to use the control flow instead.

</p><p>
For example, suppose the text being parsed is
the result of decoding base64 input, in which
sequences of four 6-bit characters (drawn from a 64-character alphabet)
decode to three 8-bit bytes.
The core of that decoder looks like:
</p><pre>for {
    c1, c2, c3, c4 := read(), read(), read(), read()
    b1, b2, b3 := decode(c1, c2, c3, c4)
    write(b1)
    write(b2)
    write(b3)
}
</pre>


<p>
If we want those <code>write</code> calls to feed into the parser from the
previous section, we need a parser that can be called with one byte at a time,
not one that demands a <code>read</code> callback.
This decode loop cannot be presented as a <code>read</code> callback
bceause it obtains 3 input bytes at a time and
uses its control flow to track which ones have been written.
Because the decoder is storing its own state
in its control flow, <code>parseQuoted</code> cannot.

</p><p>
In a non-concurrent program, this base64 decoder and <code>parseQuoted</code>
would be at an impasse: one would have to give up
its use of control flow state and fall back to some kind
of simulated version instead.

</p><p>
To rewrite <code>parseQuoted</code>, we have to reintroduce the <code>state</code>
variable, which we can encapsulate in a struct with a <code>Write</code> method:
</p><pre>type parser struct {
    state int
}

func (p *parser) Init() {
    p.state = 0
}

func (p *parser) Write(c byte) Status {
    switch p.state {
    case 0:
        if c != &#39;&#34;&#39; {
            return BadInput
        }
        p.state = 1
    case 1:
        if c == &#39;&#34;&#39; {
            return Success
        }
        if c == &#39;\\&#39; {
            p.state = 2
        } else {
            p.state = 1
        }
    case 2:
        p.state = 1
    }
    return NeedMoreInput
}
</pre>


<p>
The <code>Init</code> method initializes the state,
and then each <code>Write</code> loads the state,
takes actions based on the state and the input byte,
and then saves the state back to the struct.

</p><p>
For <code>parseQuoted</code>, the state machine is simple enough that this may be completely fine.
But maybe the state machine is much more complex,
or maybe the algorithm is best expressed recursively.
In those cases, being passed an input sequence by the caller
one byte at a time means making all that state explicit in a
data structure simulating the original control flow.

</p><p>
Concurrency eliminates the contention between different parts of the
program over which gets to store state in control flow,
because now there can be multiple control flows.

</p><p>
Suppose we already have the <code>parseQuoted</code> function,
and it’s big and complicated
and tested and correct, and we don’t want to change it.
We can avoid editing that code at all by writing this wrapper:
</p><pre>type parser struct {
    c      chan byte
    status chan Status
}

func (p *parser) Init() {
    p.char = make(chan byte)
    p.status = make(chan Status)
    go p.run()
    &lt;-p.status // always NeedMoreInput
}

func (p *parser) run() {
    if !parseQuoted(p.read) {
        p.status &lt;- BadSyntax
    } else {
        p.status &lt;- Success
    }
}

func (p *parser) read() byte {
    p.status &lt;- NeedMoreInput
    return &lt;-p.c
}

func (p *parser) Write(c byte) Status {
    p.c &lt;- c
    return &lt;-p.status
}
</pre>


<p>
Note the use of <code>parseQuoted</code>, completely unmodified, in the <code>run</code> method.
Now the base64 decoder can use <code>p.Write</code> and keep its program counter
and local variables.

</p><p>
The new goroutine that <code>Init</code> creates runs the <code>p.run</code> method,
which invokes the original <code>parseQuoted</code> function with an
appropriate implementation of <code>read</code>.
Before starting <code>p.run</code>, <code>Init</code> allocates two channels for communicating
between the <code>p.run</code> method, runing in its own goroutine,
and whatever goroutine calls <code>p.Write</code> (such as the base64 decoder’s goroutine).
The channel <code>p.c</code> carries bytes from <code>Write</code> to <code>read</code>, and the channel <code>p.status</code>
carries status updates back.
Each time <code>parseQuoted</code> calls <code>read</code>, <code>p.read</code> sends <code>NeedMoreInput</code> on <code>p.status</code>
and waits for an input byte on <code>p.c</code>.
Each time <code>p.Write</code> is called, it does the opposite: it sends the input byte <code>c</code> on <code>p.c</code>
and then waits for and returns an updated status from <code>p.status</code>.
These two calls take turns, back and forth,
one executing and one waiting at any given moment.

</p><p>
To get this cycle going, the <code>Init</code> method does the initial receive from <code>p.status</code>,
which will correspond to the first <code>read</code> in <code>parseQuoted</code>.
The actual status for that first update is guaranteed to be <code>NeedMoreInput</code>
and is discarded.
To end the cycle, we assume that when <code>Write</code> returns <code>BadSyntax</code> or <code>Success</code>,
the caller knows not to call <code>Write</code> again.
If the caller incorrectly kept calling <code>Write</code>,
the send on <code>p.c</code> would block forever, since <code>parseQuoted</code> is done.
We would of course make that more robust in a production implementation.

</p><p>
By creating a new control flow (a new goroutine), we were able to keep the
code-state-based implementation of <code>parseQuoted</code> as well as our code-state-based
base64 decoder.
We avoided having to understand the internals of either implementation.
In this example, both are trivial enough that rewriting one would not
have been a big deal,
but in a larger program, it could be a huge win to be able to write this kind of
adapter instead of having to make changes to existing code.
As we’ll discuss <a href="#limitations">later</a>, the conversion is not entirely free – we need to
make sure the extra control flow gets cleaned up, and we need to think about
the cost of the context switches – but it may well still be a net win.
<a href="#stack"></a></p><h2 id="stack"><a href="#stack">Store Stacks on the Stack</a></h2>


<p>
The base64 decoder’s control flow state included not just the program counter
but also two local variables.
Those would have to be pulled out into a struct if the decoder had to be changed
not to use control flow state.
Programs can use an arbitrary number of local variables by using their call stack.
For example, suppose we have a simple binary tree data structure:
</p><pre>type Tree[V any] struct {
    left  *Tree[V]
    right *Tree[V]
    value V
}
</pre>


<p>
If you can’t use control flow state, then to implement iteration over this tree,
you have to introduce an explicit “iterator”:
</p><pre>type Iter[V any] struct {
    stk []*Tree[V]
}

func (t *Tree[V]) NewIter() *Iter[V] {
    it := new(Iter[V])
    for ; t != nil; t = t.left {
        it.stk = append(it.stk, t)
    }
    return it
}

func (it *Iter[V]) Next() (v V, ok bool) {
    if len(it.stk) == 0 {
        return v, false
    }
    t := it.stk[len(it.stk)-1]
    v = t.value
    it.stk = it.stk[:len(it.stk)-1]
    for t = t.right; t != nil; t = t.left {
        it.stk = append(it.stk, t)
    }
    return v, true
}
</pre>


<p>
On the other hand, if you can use control flow state,
confident that other parts of the
program that need their own state can run in other control flows,
then you can implement iteration without an explicit iterator,
as a method that calls a yield function for each value:
</p><pre>func (t *Tree[V]) All(f func(v V)) {
    if t != nil {
        t.left.All(f)
        f(t.value)
        t.right.All(f)
    }
}
</pre>


<p>
The <code>All</code> method is obviously correct.
The correctness of the <code>Iter</code> version is much less obvious.
The simplest explanation is that <code>Iter</code> is simulating <code>All</code>.
The <code>NewIter</code> method’s loop that sets up <code>stk</code> is
simulating the recursion in <code>t.All(f)</code> down successive <code>t.left</code> branches.
<code>Next</code> pops and saves the <code>t</code> at the top of the stack
and then simulates the recursion in <code>t.right.All(f)</code> down successive <code>t.left</code> branches,
setting up for the next <code>Next</code>.
Finally it returns the value from the top-of-stack <code>t</code>,
simulating <code>f(value)</code>.

</p><p>
We could write code like <code>NewIter</code> and argue its correctness
by explaining that it simulates a simple function like <code>All</code>.
I’d rather write <code>All</code> and stop there.
<a href="#tree"></a></p><h2 id="tree"><a href="#tree">Comparing Binary Trees</a></h2>


<p>
One might argue that <code>NewIter</code> is better than <code>All</code>,
because it does not use any control flow state, so it can be
used in contexts that already use their control flows
to hold other information.
For example, what if we want to traverse two binary trees
at the same time, checking that they hold the same values
even if their internal structure differs.
With <code>NewIter</code>, this is straighforward:
</p><pre>func SameValues[V any](t1, t2 *Tree[V]) bool {
    it1 := t1.NewIter()
    it2 := t2.NewIter()
    for {
        v1, ok1 := it1.Next()
        v2, ok2 := it2.Next()
        if v1 != v2 || ok1 != ok2 {
            return false
        }
        if !ok1 &amp;&amp; !ok2 {
            return true
        }
    }
}
</pre>


<p>
This program cannot be written as easily using <code>All</code>,
the argument goes, because <code>SameValues</code> wants to use
its own control flow (advancing two lists in lockstep)
that cannot be replaced by <code>All</code>’s control flow
(recursion over the tree).
But this is a false dichotomy, the same one we saw
with <code>parseQuoted</code> and the base64 decoder.
If two different functions have different demands
on control flow state, they can run in different control flows.

</p><p>
In our case, we can write this instead:
</p><pre><span>func SameValues[V any](t1, t2 *Tree[V]) bool {</span>
    c1 := make(chan V)
    c2 := make(chan V)
    go gopher(c1, t1.All)
    go gopher(c2, t2.All)
<span>    for {</span>
        v1, ok1 := &lt;-c1
        v2, ok2 := &lt;-c2
<span>        if v1 != v2 || ok1 != ok2 {</span>
<span>            return false</span>
<span>        }</span>
<span>        if !ok1 &amp;&amp; !ok2 {</span>
<span>            return true</span>
<span>        }</span>
<span>    }</span>
<span>}</span>
<span></span>
func gopher[V any](c chan&lt;- V, all func(func(V))) {
    all(func(v V) { c &lt;- v })
    close(c)
}
</pre>


<p>
The function <code>gopher</code> uses <code>all</code> to walk a tree, announcing
each value into a channel. After the walk, it closes the channel.

</p><p>
<code>SameValues</code> starts two concurrent gophers,
each of which walks one tree and announces the values into one channel.
Then <code>SameValues</code> does exactly the same loop as before
to compare the two value streams.

</p><p>
Note that <code>gopher</code> is not specific to binary trees in any way:
it applies to <i>any</i> iteration function.
That is, the general idea of starting a goroutine to run the <code>All</code> method
works for converting any code-state-based iteration into an
incremental iterator.
A future post will expand on this idea.
<a href="#limitations"></a></p><h2 id="limitations"><a href="#limitations">Limitations</a></h2>


<p>
This approach of storing data in control flow is not a panacea.
Here are a few caveats:
</p><ul>
<li>


<p>
If the state needs to evolve in ways that don’t naturally map
to control flow, then it’s usually best to leave the state as data.
For example, the state maintained by a node in a distributed system
is usually not best represented in control flow,
because timeouts, errors, and other unexpected events tend to
require adjusting the state in unpredictable ways.
</p></li><li>


<p>
If the state needs to be serialized for operations like snapshots,
or sending over a network, that’s usually easier with data than code.
</p></li><li>


<p>
When you do need to create multiple control flows to hold different control flow state,
the helper control flows need to be shut down. When <code>SameValues</code> returns
false, it leaves the two concurrent <code>gopher</code>s blocked waiting to
send their next values. Instead, it should unblock them.
That requires communication in the other direction
to tell <code>gopher</code> to stop early. A future post will show that.
</p></li><li>


<p>
In the multiple thread case, the switching costs can be significant.
On my laptop, a C thread switch takes a few microseconds.
A channel operation and goroutine switch
is an order of magnitude cheaper: a couple hundred nanoseconds.
An optimized coroutine system can reduce the cost to tens of
nanoseconds or less.</p></li></ul>


<p>
In general, storing data in control flow is a valuable tool
for writing clean, simple, maintainable programs.
Like all tools, it works very well for some jobs and not as well for others.
<a href="#counterpoint"></a></p><h2 id="counterpoint"><a href="#counterpoint">Counterpoint: John McCarthy’s GOPHER</a></h2>


<p>
The idea of using concurrency to align a pair of binary trees is over 50 years old.
It first appeared in Charles Prenner’s
“<a href="https://dl.acm.org/doi/abs/10.1145/942582.807990">The control structure facilities of ECL</a>”
(<i>ACM SIGPLAN Notices</i>, Volume 6, Issue 12, December 1971; see pages 106–109).
In that presentation, titled “Tree Walks Using Coroutines”, the problem was to take two binary trees A and B with the same number of nodes
and copy the value sequence from A into B despite the two having different internal structure.
They present a straightforward coroutine-based variant.

</p><p>
Brian Smith and Carl Hewitt introduced the problem of simply comparing two
Lisp-style cons trees (in which internal nodes carry no values)
in their draft of “<a href="https://www.scribd.com/document/185900689/A-Plasma-Primer">A Plasma Primer</a>” (March 1975; see pages 61-62).
For that problem, which they named “samefringe”, they used continuation-based actors
to run a pair of “fringe” actors (credited to Howie Shrobe)
over the two trees and report nodes back to a comparison loop.

</p><p>
Gerald Sussman and Guy Steele presented the samefringe problem again,
in “<a href="https://dspace.mit.edu/bitstream/handle/1721.1/5794/AIM-349.pdf">Scheme: An Interpreter for Extended Lambda Calculus</a>” (December 1975; see pages 8–9),
with roughly equivalent code (crediting Smith, Hewitt, and Shrobe for inspiration).
They refer to it as a “classic problem difficult to solve in most programming languages”.

</p><p>
In August 1976, <i>ACM SIGART Bulletin</i> published Patrick Greussay’s
“<a href="https://dl.acm.org/doi/10.1145/1045270.1045273">An Iterative Lisp Solution to the Samefringe Problem</a>”,
This prompted <a href="https://dl.acm.org/action/showFmPdf?doi=10.1145%2F1045276">a response letter by Tim Finin and Paul Rutler in the November 1976 issue</a> (see pages 4–5)
pointing out that Greussay’s solution runs in quadratic time and memory
but also remarking that
“the SAMEFRINGE problem has been notoriously overused as a justification for coroutines.”
That discussion prompted <a href="https://dl.acm.org/action/showFmPdf?doi=10.1145%2F1045283">a response letter by John McCarthy in the February 1977 issue</a> (see page 4).

</p><p>
In his response, titled “Another samefringe”, McCarthy gives the following LISP solution:
</p><pre>(DE SAMEFRINGE (X Y)
       (OR (EQ X Y)
           (AND (NOT (ATOM X))
                (NOT (ATOM Y))
                (SAME (GOPHER X) (GOPHER Y)))))

(DE SAME (X Y)
       (AND (EQ (CAR X) (CAR Y))
            (SAMEFRINGE (CDR X) (CDR Y))))

(DE GOPHER (U)
       (COND ((ATOM (CAR U)) U)
             (T (GOPHER (CONS (CAAR U)
                              (CONS (CDAR U) (CDR U)))))))
</pre>


<p>
He then explains:</p><blockquote>

<p>
<i>gopher</i> digs up the first atom in an S-expression, piling up the <i>cdr</i> parts
(with its hind legs) so that indexing through the atoms can be resumed.
Because of shared structure, the number of new cells in use in each argument
at any time (apart from those occupied by the original expression and assuming
iterative execution) is the number of <i>cars</i> required to go from the top to the
current atom – usually a small fraction of the size of the S-expression.</p></blockquote>

<p>
In modern terms, McCarthy’s <code>GOPHER</code> loops applying <a href="https://en.wikipedia.org/wiki/Tree_rotation">right tree rotations</a>
until the leftmost node is at the top of the tree.
<code>SAMEFRINGE</code> applies <code>GOPHER</code> to the two trees, compares the tops,
and then loops to consider the remainders.

</p><p>
After presenting a second, more elaborate solution, McCarthy remarks:</p><blockquote>

<p>
I think all this shows that <i>samefringe</i> is not an example of the need for co-routines,
and a new “simplest example” should be found.
There is no merit in merely moving information from data structure to control structure,
and it makes some kinds of modification harder.</p></blockquote>

<p>
I disagree with “no merit”. We can view McCarthy’s <code>GOPHER</code>-ized trees as an encoding
of the same stack that <code>NewIter</code> maintains but in tree form.
The correctness follows for the same reasons: it is simulating a
simple recursive traversal.
This <code>GOPHER</code> is clever, but it only works on trees.
If you’re not John McCarthy, it’s easier to write the recursive traversal
and then rely on the general, concurrency-based <code>gopher</code> we saw earlier
to do the rest.

</p><p>
My experience is that when it is possible,
moving information from data structure to control structure
usually makes programs clearer, easier to understand,
and easier to maintain.
I hope you find similar results.
      </p></div>
    </div></div>
  </body>
</html>
