<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evalapply.org/posts/poor-mans-job-runner-clojure-agents/index.html">Original</a>
    <h1>Poor man&#39;s job runner with Clojure Agents</h1>
    
    <div id="readability-page-1" class="page"><div id="the-very-top">
        
  <main id="main">
    <article id="blog-post">
  <header>
    <div>
      <p>Poor man&#39;s job runner with Clojure Agents</p>
      
      <p>On (mis)using Clojure&#39;s concurrency features to make an in-memory job runner, because I needed an excuse to use more than atoms for once. Definitely not Rich Hickey&#39;s &#34;Ants&#34; demo.</p>
      
      <hr/>
    </div>
  </header>
  <section>
      
<hr/>
  <p><strong>Author&#39;s note:</strong> To run real background jobs like a proper Clojure professional, maybe use one of the proper professional libraries out there, like <a href="https://github.com/nilenso/goose">goose</a>.</p>

<p>Opportunity to use not just atoms made its way to me a decade after I first watched Rich Hickey&#39;s &#34;Ants&#34; demo <a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. The demo shows off a Java Swing GUI world swarming with ants, driven using all three of Clojure&#39;s built-in concurrency features.</p>
<p>Clojure wants us to be explicit about <em><strong>type of concurrency</strong></em> <a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>, depending on how state is to be shared between threads. We must choose a feature accordingly.</p>
<table>
<thead>
<tr>
<th>↓ State Sharing / Threads →</th>
<th>Independent</th>
<th>Coordinated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Synchronous</td>
<td>atom</td>
<td>ref</td>
</tr>
<tr>
<td>Asynchronous</td>
<td>agent</td>
<td>not in our universe</td>
</tr>
</tbody>
</table>
<p>However, like maybe 99% of all Clojure programmers, I&#39;ve only ever used atoms in practice <a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Like maybe some of them, I&#39;ve always wanted to use the others some day. Because that demo is rad!</p>
<p>While working through the (very nice!) <a href="https://hypermedia.systems/">hypermedia.systems</a> book, I reached the section where we must code up a <a href="https://hypermedia.systems/a-dynamic-archive-ui/">Dynamic Archive UI</a>, complete with a live progress indicator.</p>
<p>The scenario requires an <em>Archive</em> job that runs in the background, with basic job control stuff (run, pause, cancel, reset, status, progress, etc.).</p>
<p>Obviously we must kick jobs off of the main execution thread, to avoid blocking it. Further, if we have many jobs and/or many batches per job, we need to queue them all up for asynchronous evaluation. And job state must be observable at all times without blocking job execution.</p>
<p>Of course, we are here because I didn&#39;t want to just get on with life by using a <code>Thread/sleep</code> or some trivial mock; definitely not a library. Because Clojure has features that can help us.</p>
<p>Upon squinting a little, the, ah, job description looked an awful lot like the place in <a href="#backstory">the table up above</a> where <em>Asynchronous state update</em> meets <em>Independent threads</em>.</p>
<p>Aha! Send in our agent!</p>

<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span>agent</span> {<span>:status</span> (<span>atom</span> <span>:waiting</span>) <span>; the one weird trick</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>        <span>:total-batches</span> <span>0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>        <span>:progress</span> <span>0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span>:job-file</span> <span>&#34;resources/job-log.json&#34;</span>}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>       <span>;; the one weird trick</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>       <span>:validator</span> (<span>fn</span> [self] </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>                    (<span>not=</span> <span>:paused</span> @(<span>:status</span> self))))</span></code></pre></div>
<p>I modeled a single job runner as a Clojure agent:</p>
<ul>
<li>meant to manage one job at a time,</li>
<li>where a job has one or more long-running batches,</li>
<li>where the runner&#39;s current status may be one of <code>:waiting</code>, <code>:running</code>, or <code>:paused</code>,</li>
<li>and it is always initialised in the <code>:waiting</code> state.</li>
</ul>
<p>Additionally, the job state reflects current progress and points to a file that accumulates the work of each batch.</p>
<p>The one weird trick is how to implement out-of-band job control, if we use an agent this way?</p>
<p>Because…</p>
<ul>
<li>Our job batches must be executed in order.</li>
<li>Actions dispatched to an agent occur in the order they were sent.</li>
<li>Only one action is executed at a time for an agent.</li>
<li>So I must queue all batches up-front (using <code>send-off</code>).</li>
</ul>
<p><em>However</em>…</p>
<ul>
<li>The trouble is the agent system is designed to be reactive and has no built-in pause/resume facility.</li>
<li>To ensure the agent system&#39;s sequential execution guarantee, the queue of actions cannot be modified post-hoc.</li>
</ul>
<p>So!</p>
<ul>
<li>I had to hack it by making the agent do some navel-gazing.</li>
<li><a href="https://stackoverflow.com/a/4610972">This StackOverflow answer</a> provided clues key to the solution.</li>
</ul>
<p>The problem in pictures, with reference to code in the next section.</p>
<p>Let&#39;s say the following actions are already queued using the agent system&#39;s <code>send</code> and <code>send-off</code> functions.</p>
<pre><code>|---|send increment3 -----------\
|--|send-off batch3 ------------\
|----------|send increment1 ----\
|---------|send-off batch1 -----\
                                 #[job-runner agent]
|-send increment4 --------------/
|send-off batch4 ---------------/
|-------|send increment2 -------/
|------|send-off batch2 --------/
</code></pre>
<p>Note: I have visually placed actions on separate thread-like tracks to emphasise that they are independent actions that will be performed asynchronously on a fixed-size thread pool allocated by the agent system. <em>However</em> each action is sequentially ordered, and will be executed in the order it was sent to the agent.</p>
<p>Now, if I <code>send</code> a <code>:pause</code> action to update the <code>:status</code> of the agent, the agent system will queue this latest action behind all the earlier actions. This means if <code>batch1</code> is in progress and I want to pause the job run, I cannot do it with a <code>send</code>.</p>
<pre><code>             |---|send increment3 -----------\
             |--|send-off batch3 ------------\
             |----------|send increment1 ----\
             |---------|send-off batch1 -----\
                                              #[job-runner agent]
             |-send increment4 --------------/
             |send-off batch4 ---------------/
             |-------|send increment2 -------/
             |------|send-off batch2 --------/
|send :pause --------------------------------/
</code></pre>
<p>What if I put job <code>:status</code> in an atom, and observe the atom via a validator?</p>
<ul>
<li>Any validator attached to an agent is evaluated for every action sent to the agent. The agent halts if the validator returns <code>false</code>. <a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></li>
<li>The agent&#39;s state is always observable out-of-band.
<ul>
<li>Which means I can see the <code>:state</code> atom from the outside.</li>
<li>Which further means I can update it from the outside too.</li>
</ul></li>
<li>Putting the two together…
<ul>
<li>If a batch is in progress,</li>
<li>and I set the <code>:state</code> atom to <code>:paused</code>,</li>
<li>then the next batch won&#39;t execute,</li>
<li>because the validator will fail the agent <em>before it runs the next action</em>,</li>
<li>thus effectively pausing the queue. Phew!</li>
</ul></li>
</ul>
<p>So I gave the agent a validator function that returns <code>false</code> if the <code>:state</code> atom is set to <code>:paused</code>, thus halting the agent.</p>
<p>Upon halting, <code>agent-error</code> allows us to see the reason for job interruption (an Exception). And <code>restart-agent</code> lets us resume the job after suitably dealing with the interruption.</p>
<p>The state of atoms and agents is always readable without blocking writers, so one can get away with pretty straightforward lock-free code.</p>

<p>Here&#39;s the basic idea. It works on my computer. I also am pleased to report that I finished the book example and have moved on in life.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(<span>ns</span> study-htmx.pmjc</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span>&#34;Poor Man&#39;s Job Control&#34;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>(<span>defn</span><span> make-initial-job-state</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  []</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  (<span>agent</span> {<span>:status</span> (<span>atom</span> <span>:waiting</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>          <span>:total-batches</span> <span>0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>          <span>:progress</span> <span>0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>          <span>:job-file</span> <span>&#34;resources/job-log.json&#34;</span>}</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>         <span>:validator</span> (<span>fn</span> [job-runner]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>                      (<span>not=</span> <span>:paused</span> @(<span>:status</span> job-runner)))))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>(<span>defonce</span><span> job-runner</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  (make-initial-job-state))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>(<span>defn</span><span> create-job!</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  <span>&#34;Queue all the batches for the given job and</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span>  keep the job progress current.&#34;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>  [job-runner batches batch-executor]</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>  <span>;; Start the job when it is parked in the initial</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>  <span>;; :waiting state. Also rotate the job file.</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>  (<span>when</span> (<span>=</span> @(<span>:status</span> <span>@job-runner</span>) <span>:waiting</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>    (<span>swap!</span> (<span>:status</span> <span>@job-runner</span>)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>           (<span>constantly</span> <span>:running</span>))</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>    (<span>send</span> job-runner <span>assoc</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>          <span>:total-batches</span> (<span>count</span> batches))</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    (spit (<span>:job-file</span> <span>@job-runner</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>          <span>&#34;&#34;</span>))</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>  <span>;; As soon as a job is set to run, queue all batches</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>  <span>;; and progress updates</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a>  (<span>when</span> (<span>=</span> @(<span>:status</span> <span>@job-runner</span>) <span>:running</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a>    (<span>doseq</span> [batch batches]</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true"></a>      (<span>send</span> job-runner <span>update</span> <span>:progress</span> <span>inc</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true"></a>      (<span>send-off</span> job-runner batch-executor batch)))</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true"></a>  <span>;; Queue a final action to mark the job as :done</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true"></a>  (<span>send-off</span> job-runner</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true"></a>            (<span>fn</span> [runner]</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true"></a>              (<span>swap!</span> (<span>:status</span> runner) (<span>constantly</span> <span>:done</span>))</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true"></a>              runner)))</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true"></a>(<span>defn</span><span> pause-job!</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true"></a>  <span>&#34;Out-of-band job control by reaching into the :status atom.&#34;</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true"></a>  [job-runner]</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true"></a>  (<span>swap!</span> (<span>:status</span> <span>@job-runner</span>)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true"></a>         (<span>constantly</span> <span>:paused</span>))</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true"></a>  job-runner)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true"></a>(<span>defn</span><span> resume-job!</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true"></a>  <span>&#34;Out-of-band job control by reaching into the :status atom.&#34;</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true"></a>  [job-runner]</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true"></a>  (<span>when</span> (<span>=</span> <span>:paused</span> @(<span>:status</span> <span>@job-runner</span>))</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true"></a>    (<span>swap!</span> (<span>:status</span> <span>@job-runner</span>) (<span>constantly</span> <span>:running</span>))</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true"></a>    (restart-agent job-runner <span>@job-runner</span>))</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true"></a>  job-runner)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true"></a></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true"></a>(<span>defn</span><span> reset-job!</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true"></a>  <span>&#34;Cheaping out by resetting the var because we mean to be</span></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true"></a><span>  destructive and consign the agent to garbage collector.</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true"></a><span>  Wrapping the agent in an atom would be better.&#34;</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true"></a>  [job-runner-var]</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true"></a>  (<span>alter-var-root</span> job-runner-var</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true"></a>                  (<span>constantly</span> (make-initial-job-state))))</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true"></a></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true"></a>(<span>defn</span><span> cancel-job!</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true"></a>  [job-runner job-runner-var]</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true"></a>  (pause-job! job-runner)</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true"></a>  (reset-job! job-runner-var))</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true"></a></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true"></a>(<span>defn</span><span> do-batch!</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true"></a>  <span>&#34;Presumably a long-running batch. We must always accept</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true"></a><span>  and return the job runner as this is an action sent off</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true"></a><span>  to the job runner agent.&#34;</span></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true"></a>  [job-runner batch]</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true"></a>  (Thread/sleep <span>5000</span>) <span>; the batch is running</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true"></a>  (spit (<span>:job-file</span> job-runner)</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true"></a>        (<span>format</span> <span>&#34;Completed batch %s</span><span>\n</span><span>&#34;</span> batch)</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true"></a>        <span>:append</span> <span>true</span>)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true"></a>  job-runner)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true"></a></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true"></a>(<span>comment</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true"></a>  (create-job! job-runner</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true"></a>               [<span>&#34;ONE&#34;</span> <span>&#34;TWO&#34;</span> <span>&#34;THREE&#34;</span> <span>&#34;FOUR&#34;</span> <span>&#34;FIVE&#34;</span>]</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true"></a>               do-batch!)</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true"></a></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true"></a>  (pause-job! job-runner)</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true"></a>  (resume-job! job-runner)</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true"></a>  (reset-job! (var job-runner))</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true"></a>  (cancel-job! job-runner (var job-runner))</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true"></a></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true"></a>  (agent-error job-runner))</span></code></pre></div>

<p>This is proooobably gross misuse of the agent system. <em>But</em> if it is not, I would <a href="#site-header">like to know</a>!</p>
<p>Pros:</p>
<ul>
<li>No need for an external library.</li>
<li>Straightforward lock-free code.</li>
<li>Built-in thread safety of Clojure&#39;s concurrency system.</li>
<li>Built-in error recovery.</li>
<li>Built-in observability of state and errors.</li>
<li>Extensible, if you have the iron constitution to live with the consequences.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Obviously, in-memory job control is bound to a single process. If it dies, we lose our jobs.
<ul>
<li>Mitigation: We can attach a watcher to the agent and write to a log file to track progress and recover from a process restart.</li>
<li>Alternative: Use SQLite to manage job state. When in WAL mode, SQLite is a lot like an agent, allowing for mutually non blocking sequential writes and concurrent reads.</li>
</ul></li>
<li>Easy to write subtle bugs, especially timing and order problems like incrementing progress counter in the wrong order, leading to off-by-one errors if we pause / resume the job.
<ul>
<li>Mitigation: Write side-effecting functions with care. Design for idempotence. Test thoroughly. Be well aware of each feature&#39;s concurrency model and the intended behaviour of operations supported by the the feature.</li>
</ul></li>
<li>Abusing your programming language&#39;s standard library.
<ul>
<li>Mitigation: ¯\<sub>(ツ)</sub>_/¯</li>
</ul></li>
</ul>

<p>I feel compelled to contribute back to the HTMX community seeing as we began our side quest because of the <a href="https://hypermedia.systems/">hypermedia.systems</a> book.</p>
<figure>
<img src="https://i.imgflip.com/8wy4em.jpg" title="HTMX is Boring Technology (via imgflip.com)"/>
<figcaption>
This <em><a href="https://imgflip.com/i/8wy4em">HTMX is Boring Technology</a></em> fact is brought to you using <a href="https://imgflip.com/memegenerator">Imgflip</a>.
</figcaption>
</figure>



  </section>
  
</article>
  </main>
      
      <!-- Cloudflare Web Analytics -->
      
      <!-- End Cloudflare Web Analytics -->
    </div></div>
  </body>
</html>
