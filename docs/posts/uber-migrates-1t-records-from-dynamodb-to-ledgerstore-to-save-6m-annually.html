<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/news/2024/05/uber-dynamodb-ledgerstore/">Original</a>
    <h1>Uber Migrates 1T Records from DynamoDB to LedgerStore to Save $6M Annually</h1>
    
    <div id="readability-page-1" class="page"><div>
								<p>Uber <a href="https://www.uber.com/en-AU/blog/migrating-from-dynamodb-to-ledgerstore/">migrated all its payment transaction data from DynamoDB and blob storage into a new long-term solution</a>, a purpose-built data store named LedgerStore. The company was looking for cost savings and had previously reduced the use of DynamoDB to store hot data (12 weeks old). The move resulted in significant savings and simplified the storage architecture.</p>

<p>Uber built Gulfstream, its payment platform, in 2017 and used DynamoDB for storage. Due to rising storage costs, DynamoDB was used only for the most recent data (12 weeks), and older data was stored in TerraBlob, an S3-like service created in-house by Uber.</p>

<p>In the meantime, the company started working on a dedicated solution for storing financial transactions with data integrity guarantees. <a href="https://www.linkedin.com/in/kaushikd49">Kaushik Devarajaiah</a>, tech lead at Uber, explains the unique challenges of creating a bespoke data store:</p>

<blockquote>
<p>LedgerStore is an immutable storage solution at Uber that provides verifiable data completeness and correctness guarantees to ensure data integrity for these transactions. [...] Considering that ledgers are the source of truth of any financial event or data movement at Uber, it is important to be able to look up ledgers from various access patterns via indexes. This brings in the need for trillions of indexes to index hundreds of billions of ledgers.</p>
</blockquote>

<p><a href="https://www.uber.com/en-AU/blog/how-ledgerstore-supports-trillions-of-indexes/">LedgerStore</a> supports strongly and eventually consistent indexes. For strongly consistent indexes, the data store uses a two-phase commit. It first persists the indent on the index and subsequently persists the record. Lastly, if the record write succeeds, the intent is asynchronously committed or rolled back in case of failure. If the intent write fails, the whole insert operation fails, as consistency guarantees cannot be supported. During reads, any writes with uncommitted intents are either committed (if the record read succeeds) or deleted (if the record read fails) asynchronously. LedgerStore implements eventually consistent indexes by leveraging materialized views from its home-grown <a href="https://www.uber.com/blog/schemaless-sql-database/?uclick_id=37e0581b-5432-40df-b0a8-4b055bb80aa7">Docstore database</a>, a distributed database built on top of MySQL.</p>

<p><img alt="" data-src="news/2024/05/uber-dynamodb-ledgerstore/en/resources/1uber-ledgerstore-writes-1716025995484.jpeg" src="https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2024/05/uber-dynamodb-ledgerstore/en/resources/1uber-ledgerstore-writes-1716025995484.jpeg" rel="share"/></p>

<p>Two-phase Commit Write For Strongly Consistent Indexes (Source: <a href="https://www.uber.com/en-AU/blog/how-ledgerstore-supports-trillions-of-indexes/">Uber Engineering Blog</a>)</p>

<p>To offload older ledger data to cold storage, LedgerStore uses time-range indexes to support temporal queries. Uber moved from using <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a> and Docstore for storing time-range indexes. The original solution utilized two tables in DynamoDB, one optimized for writes and the second for reads. This design was dictated by DynamoDB’s capacity management and avoided hot partitions and throttling. The new design uses the Docstore database with a single table, and leverages prefix scanning for efficient reads.</p>

<p>LedgerStore supports index lifecycle management, automating data reindexing in case the index definition changes. The process creates a new index, backfills the data from the old index, performs relevant validations, swaps indexes, and deletes the old one.</p>

<p><img alt="" data-src="news/2024/05/uber-dynamodb-ledgerstore/en/resources/1uber-ledgerstore-index-backfill-1716025995484.jpeg" src="https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2024/05/uber-dynamodb-ledgerstore/en/resources/1uber-ledgerstore-index-backfill-1716025995484.jpeg" rel="share"/></p>

<p>Index Backfilling From Cold Storage (Source: <a href="https://www.uber.com/en-AU/blog/how-ledgerstore-supports-trillions-of-indexes/">Uber Engineering Blog</a>)</p>

<p>The company faced unique challenges while migrating petabytes of financial transaction data into LedgerStore. It used shadow and offline validation to ensure the correctness of the migration and the performance and scalability of LedgerStore in the production environment. For shadow validation, Gulfstorm was double-writing the data to DynamoDB and LedgerStore and comparing the data returned by reads between the two data stores.</p>

<p>Additionally, Uber implemented offline validation for historical data, coupled with the incremental backfill job running in <a href="https://spark.apache.org/">Apache Spark</a>. The backfill process alone posed significant problems, as the load generated by the process amounted to ten times the usual production load, and the overall process took three months. Engineers used several measures to control the process and mitigate any issues, including dynamic rate control to adjust the processing rate based on the production traffic handled by the platform and emergency stop to halt the process quickly in case of major issues.</p>

<p>Lastly, the team took a conservative approach towards the rollout and adopted a fallback to fetching the data from DynamoDB in case it wasn’t found in LedgerStore. The overall migration was completed successfully, and the company didn’t experience any downtime or outages during and after the migration. The move to LedgerStore resulted in significant cost savings, with estimated yearly savings of over $6 million.</p>

								









  
    

							</div></div>
  </body>
</html>
