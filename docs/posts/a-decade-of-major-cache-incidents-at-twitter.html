<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/cache-incidents/">Original</a>
    <h1>A decade of major cache incidents at Twitter</h1>
    
    <div id="readability-page-1" class="page"><i><b><a href="https://patreon.com/danluu">I&#39;m trying some experimental tiers on Patreon</a></b> to see if I can get to <a href="https://twitter.com/danluu/status/1456346963691991041">substack-like levels of financial support for this blog without moving to substack</a>!</i> <hr/> <strong>A decade of major cache incidents at Twitter</strong> <p><i>This was co-authored with Yao Yue</i></p> <p>This is a collection of information on severe (<code>SEV-0</code> or <code>SEV-1</code>, the most severe incident classifications) incidents at Twitter that were at least partially attributed to cache from the time Twitter started using its current incident tracking JIRA (2012) to date (2022), with one bonus incident from before 2012. Not including the bonus incident, there were 6 <code>SEV-0</code>s and 6 <code>SEV-1</code>s that were at least partially attributed to cache in the incident tracker, along with 38 less severe incidents that aren&#39;t discussed in this post.</p> <p>There are a couple reasons we want to write this down. First, historical knowledge about what happens at tech companies is lost at a fairly high rate and we think it&#39;s nice to preserve some of it. Second, we think it can be useful to look at incidents and reliability from a specific angle, putting all of the information into one place, because that can sometimes make some patterns very obvious.</p> <p>On knowledge loss, when we&#39;ve seen viral Twitter threads or other viral stories about what happened at some tech company, when we look into what happened, the most widely spread stories are usually quite wrong, generally for banal reasons. One reason is that outrageously exaggerated stories are more likely to go viral, so those are the ones that tend to be remembered. Another is that there&#39;s a cottage industry of former directors / VPs who tell self-aggrandizing stories about all the great things they did that, to put it mildly, frequently distort the truth (although there&#39;s nothing stopping ICs from doing this, the most spread false stories we see tend to come from people on the management track). In both cases, there&#39;s a kind of <a href="https://en.wikipedia.org/wiki/Gresham%27s_law">Gresham&#39;s law of stories in play</a>, where incorrect stories tend to win out over correct stories.</p> <p>And even when making a genuine attempt to try to understand what happened, it turns out that knowledge is lost fairly quickly. For this and other incident analysis projects we&#39;ve done, links to documents and tickets from the past few years tend to work (90%+ chance), but older links are less likely to work, with the rate getting pretty close to 0% by the time we&#39;re looking at things from 2012. Sometimes, people have things squirreled away in locked down documents, emails, etc. but those will often link to things that are now completely dead, and figuring out what happened requires talking to a bunch of people who will, <a href="https://www.pnas.org/content/114/30/7758">due to the nature of human memory, give you inconsistent stories that you need to piece together</a>.</p> <p>On looking at things from a specific angle, while <a href="https://danluu.com/postmortem-lessons/">looking at failures broadly and classifying and collating all failures is useful</a>, it&#39;s also useful to drill down into certain classes of failures. For example, when Rebecca Isaacs and Dan Luu did an (internal, non-public) analysis of Twitter failover tests (from 2018 to 2020), which found a number of things that led to operational changes. In some sense, there was no new information in the analysis since the information we got all came from various documents that already existed, but putting into one place made a number of patterns obvious that weren&#39;t obvious when looking at incidents one at a time across multiple years.</p> <p>This document shouldn&#39;t cause any changes at Twitter since looking at what patterns exist in cache incidents over time and what should be done about that has already been done, but collecting these into one place may still be useful to people outside of Twitter.</p> <p>As for why we might want to look at cache failures (as opposed to failures in other systems), cache is relatively commonly implicated in major failures, as illustrated by this comment Yao made during an internal Twitter War Stories session (referring to the dark ages of Twitter, in operational terms):</p> <blockquote> <p>Every single incident so far has at least mentioned cache. In fact, for a long time, cache was probably the #1 source of bringing the site down for a while.</p> <p>In my first six months, every time I restarted a cache server, it was a <code>SEV-0</code> by today&#39;s standards. On a good day, you might have 95% Success Rate (SR) [for external requests to the site] if I restarted one cache ...</p> </blockquote> <p>Also, the vast majority of Twitter cache is (a fork of) memcached, which is widely used elsewhere, making the knowledge more generally applicable than if we discussed a fully custom Twitter system.</p> <p>More generally, caches are nice source of relatively clean real-world examples of common distributed systems failure modes because of how simple caches are. Conceptually, a cache server is a high-throughput, low-latency RPC server plus a library that manages data, such as memory and/or disk and key value indices. For in memory caches, the data management side should be able to easily outpace the RPC side (a naive in-memory key-value library should be able to hit millions of QPS per core, whereas a naive RPC server that doesn&#39;t use userspace networking, batching and/or pipelining, etc. will have problems getting to 1/10th that level of performance). Because of the simplicity of everything outside of the RPC stack, cache can be thought of as an approximation of nearly pure RPC workloads, which are frequently important in heavily service-oriented architectures.</p> <p>When scale and performance are concerns, cache will frequently use sharded clusters, which then subject cache to the constraints and pitfalls of distributed systems (but with less emphasis on synchronization issues than with some other workloads, such as strongly consistent distributed databases, due to the emphasis on performance). Also, by the nature of distributed systems, users of cache will be exposed to these failure modes and be vulnerable to or possibly implicated in failures caused by the cascading impact of some kinds of distributed systems failures.</p> <p>Cache failure modes are also interesting because, when cache is used to serve a significant fraction of requests or fraction of data, cache outages or even degradation can easily cause a total outage because an architecture designed with cache performance in mind will not (and should not) have backing DB store performance that&#39;s sufficient to keep the site up.</p> <p>Compared to most workloads, cache is more sensitive to performance anomalies below it in the stack (e.g., kernel, firmware, hardware, etc.) because it tends to have relatively high-volume and low-latency SLOs (because the point of cache is that it&#39;s fast) and it spends (barring things like userspace networking) a lot of time in kernel (~80% as a ballpark for Twitter memcached running normal kernel networking). Also, because cache servers often run a small number of threads, cache is relatively sensitive to being starved by other workloads sharing the same underlying resources (CPU, memory, disk, etc.). The high volume and low latency SLOs worsen positive feedback loops that lead to a &#34;death spiral&#34;, a classic distributed systems failure mode.</p> <p>When we look at the incidents below, we&#39;ll see that most aren&#39;t really due to errors in the logic of cache, but rather, some kind of anomaly that causes an insufficiently mitigated positive feedback loop that becomes a runaway feedback loop.</p> <p>So, when reading the incidents below, it may be helpful to read them with an eye towards how cache interacts with things above cache in the stack that call caches and things below cache in the stack that cache interacts with. Something else to look for is how frequently a major incident occured due to an incompletely applied fix for an earlier incident or because something that was considered a serious operational issue by an engineer wasn&#39;t prioritized. These were both common themes in the analysis Rebecca Isaacs and Dan Luu did on causes of failover test failures as well.</p> <h3 id="2011-08-sev-0">2011-08 (SEV-0)</h3> <p>For a few months, a significant fraction of user-initiated changes (such as username, screen name, and password) would get reverted. There was continued risk of this for a couple more years.</p> <h4 id="background">Background</h4> <p>At the time, the rails app had single threaded workers, managed by a single master that did health checks, redeploys, etc. If a worker got stuck for 30 seconds, the master would kill the worker and restart it.</p> <p>Teams were running on bare metal, without the benefit of a cluster manager like mesos or kubernetes. Teams had full ownership of the hardware and were responsible for kernel upgrades, etc.</p> <p><a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients">The algorithm for deciding which shard a key would land involved a hash. If a node went away, the keys that previously hashed to that node would end up getting hashed to other nodes</a>. Each worker had a client that made its own independent routing decisions to figure out which cache shard to talk to, which means that each worker made independent decisions as to which cache nodes were live and where keys should live. If a client thinks that a host isn&#39;t &#34;good&#34; anymore, that host is said to be ejected.</p> <h4 id="incident">Incident</h4> <p>On Nov 8, a user changed their name from <code>tigertwo</code> to <code>Woflstar_Bachi</code>. One week later, their username reverted to <code>tigertwo</code>.</p> <p>Between Nov 8th and early December, tens of these tickets were filed by support agents. Twitter didn&#39;t have the instrumentation to tell where things were going wrong, so the first two weeks of investigation was mostly getting metrics into the rails app to understand where the issue was coming from Each change needed to be coordinated with the deploy team, which would take at least two hours. After the rails app was sufficiently instrumented, all signs pointed to cache as the source of the problem. The full set of changes needed to really determine if cache was at fault took another week or two, which included adding metrics to track cache inconsistency, cache exception paths, and host ejection.</p> <p>After adding instrumentation, an engineer made the following comment on a JIRA ticket in early December:</p> <blockquote> <p>I turned on code today to allow us to see the extent to which users in cache are out of sync with users in the database, at the point where we write the user in cache back to the database, at the point where we write the user in cache back to the database. The number is roughly 0.2% &gt; ... Checked 150 popular users on Twitter to see how many caches they were in (should be at most one). Most of them were on at least two, with some on as many as six.</p> </blockquote> <p>The first fix was to avoid writing stale data back to the DB. However, that didn&#39;t address the issue of having multiple copies of the same data in different cache shards. The second fix, intended to reduce the number of times keys appeared in multiple locations, was to retry multiple times before ejecting a host. The idea is that, if a host is really permanently down, that will trigger an alert, but alerts for dead hosts weren&#39;t firing, so the errors that were causing host ejections should be transient and therefore, if a client keeps retrying, it should be able to find a key &#34;where it&#39;s supposed to be&#34;. And then, to prevent flapping keys from hosts having many transient errors, the time that ejected hosts were kept ejected was increased.</p> <p>This change was tested on one cache and the rolled out to other caches. Rolling out the change to all caches immediately caused the site to go down because ejections still occurred and the longer ejection time caused the backend to get stressed. At the time, the backend was MySQL, which, as configured, could take an arbitrarily long amount of time to return a request under high load. This caused workers to take an arbitrarily long time to return results, which caused the master to kill workers, which took down the site when this happened at scale since not enough workers were available to serve requests.</p> <p>After rolling back the second fix, users could still see stale data since, even though stale data wasn&#39;t being written back to the DB, cache updates could happen to a key in one location and then a client could read a stale, cached, copy of that key in another location. Another mitigation that was deployed was to move the user data cache from a high utilization cluster to a low utilization cluster.</p> <p>After debugging further, it was determined that retrying could address ejections occurring due to &#34;random&#34; causes of tail latency, but there was still a high rate of ejections coming from some kind of non-random cause. From looking at metrics, it was observed that there was sometimes a high rate of packet loss and that this was correlated with incoming packet rate but not bandwidth usage. Looking at the host during times of high packet rate and packet loss showed that CPU0 was spending 65% to 70% of time handling soft IRQs, indicating that the packet loss was likely coming from CPU0 not being able to keep with the packet arrival rate.</p> <p>The fix for this was to set <a href="https://www.kernel.org/doc/Documentation/IRQ-affinity.txt">IRQ affinity</a> to spread incoming packet processing across all of the physical cores on the box. After deploying the fix, packet loss and cache inconsistency was observed on the new cluster that user data was moved to but not the old cluster.</p> <p>At this point, it&#39;s late December. Looking at other clusters, it was observed that some other clusters also had packet loss. Looking more closely, the packet loss was happening every 20 hours and 40 minutes on some specific machines. All machines that had this issue were a particular <a href="https://en.wikipedia.org/wiki/Stock_keeping_unit">hardware SKU</a> with a particular BIOS version (the latest version; machines from that SKU with earlier BIOS versions were fine). It turned out that hosts with this BIOS version were triggering the BMC to run a very expensive health check every 20 hours and 40 minutes which interrupted the kernel for the duration, preventing any packets from being processed, causing packet drops.</p> <p>It turned out that someone from the kernel team had noticed this exact issue about six months earlier and had tried to push a kernel config change that would fix the issue (increasing the packet ring buffer size so that transient issues wouldn&#39;t cause the packet drops when the buffer overflowed). Although that ticket was marked resolved, the fix was never widely rolled out for reasons that are unclear.</p> <p>A quick mitigation that was deployed was to stagger host reboot times so that clusters didn&#39;t have coordinated packet drops across the entire cluster at the same time.</p> <p>Because the BMC version needs to match the BIOS version and the BMC couldn&#39;t be rolled back, it wasn&#39;t possible to fix the issue by rolling back the BIOS. In order to roll the BMC and BIOS forward, the <code>HWENG</code> team had to do emergency testing/qualification of those, which was done as quickly as possible, at which point the BIOS fix was rolled out and the packet loss went away.</p> <p>The total time for everything combined was about two months.</p> <p>However, this wasn&#39;t a complete fix since the host ejection behavior was still unchanged and any random issue that caused one or more clients but not all clients to eject a cache shard would still result in inconsistency. Fixing that required changing cache architectures, which couldn&#39;t be quickly done (that took about two years).</p> <p><b>Mitigations / fixes</b>:</p> <ul> <li>Add visibility</li> <li>Set IRQ affinity to avoid overloading CPU0</li> <li>Fix firmware issue causing hosts to drop packets periodically</li> <li>Fix cache architecture to one that can tolerate partitions without becoming inconsistent</li> </ul> <p><b>Lessons learned</b>:</p> <ul> <li>Need visibility</li> <li>Need low-level systems understanding to operate cache</li> <li>Make isolated changes (one thing that confused the issue was migrating to new cluster at the same time as pushing IRQ affinity fix, which confusingly fixed one packet loss problem and introduced another one at the same time).</li> </ul> <h3 id="2012-07-sev-1">2012-07 (SEV-1)</h3> <p>Non-personalized trends didn&#39;t show up for ~10% of users for about 10 hours, who got an empty trends box.</p> <p>An update to the rails app was deployed, after which the trends cache stopped returning results. This only impacted non-personalized trends because those were served directly from rails (personalized trends were served from a separate service)</p> <p>Two hours in, it was determined that this was due to segfaults in the daemon that refreshes the trends cache, which was due to running out of memory The reason this happened was that the deployed change added a thrift field to the Trend object, which increased the trends cache refresh daemon memory usage beyond the limit.</p> <p>There was an alert on the trends cache daemon failing, but it only checked for the daemon starting a run successfully, not for it finishing a run successfully.</p> <p>MItigations / fixes:</p> <ul> <li>Increase ulimit</li> <li>Alert changed to use job success as a criteria, not job startup</li> <li>Add global 404 rate to global dashboard</li> </ul> <p>Lessons learned</p> <ul> <li>Alerts should use job success as a criteria, not job startup</li> </ul> <h3 id="2012-07-sev-0">2012-07 (SEV-0)</h3> <p>This was one of the more externally well-known Twitter incidents because this one resulted in the public error page showing, with no images or CSS:</p> <blockquote> <p>Twitter is currently down for &lt;% = reason %&gt;</p> <p>We expect to be back in &lt;% = deadline %&gt;</p> </blockquote> <p>The site was significantly impacted for about four hours.</p> <p>The information on this one is a bit sketchy since records from this time are highly incomplete (the JIRA ticket for this notes, &#34;This incident was heavily Post-Mortemed and reviewed. Closing incident ticket.&#34;, but written documentation on the incident has mostly been lost).</p> <p>The trigger for this incident was power loss in two racks. In terms of the impact on cache, 48 hosts lost power and were restarted when power came back up, one hour later. 37 of those hosts had their caches fail to come back up because a directory that a script expected to exist wasn&#39;t mounted on those hosts. &#34;Manually&#34; fixing the layouts on those hosts took 30 minutes and caches came back up shortly afterwards.</p> <p>The directory wasn&#39;t actually necessary for running a cache server, at least as they were run at Twitter at the time. However, there was a script that checked for the existence of the directory on startup that was not concurrently updated when the directory was removed from the layout setup script a month earlier.</p> <p>Something else that increased debugging time was that <code>/proc</code> wasn&#39;t mounted properly on hosts when they came back up. Although that wasn&#39;t the issue, it was unusual and it took some time to determine that it wasn&#39;t part of the incident and was an independent non-urgent issue to be fixed.</p> <p>If the rest of the site were operating perfectly, the cache issue above wouldn&#39;t have caused such a severe incident, but a number of other issues in combination caused a total site outage that lasted for an extended period of time.</p> <p>Some other issues were: * Slow requests that should&#39;ve timed out at 5 seconds didn&#39;t. Instead, they would continue for 30 seconds until the entire worker process that was working on the slow request was killed and restarted * The code that was supposed to cause the 5 second timeout was being run, but it wasn&#39;t using the right timestamp to determine duration and therefore didn&#39;t trigger a timeout * User data service took a long time to recover * Logging during failures used a large amount of resources and very high GC pressure * A number of non-cache hosts failed to come back up when rebooted, with issue including hanging at <code>fsck</code> or in a <code>PXE</code> boot loop * Although the site and error message were static, the outage page used Ruby wildcards, resulting in template messages being displayed to users * This came from Twitter having recently migrated from having the rails app act as a front end to having a C++ front end; assets for errors were directly copied over and still had <a href="https://docs.ruby-lang.org/en/2.3.0/ERB.html">ERB templates</a> * CSS didn&#39;t load because the part of the site CSS would&#39;ve loaded from was down * Front end got overloaded and failed to restart properly when health checks found that shards were unhealthy</p> <p>Cache mitigations / fixes:</p> <ul> <li>Fix software that configures layouts to avoid issue in future</li> <li>Audit existing hosts to fix issue on any hosts that were then-currently impacted</li> <li>Make sure <code>/proc</code> is mounted on kernel upgrade</li> <li>Create process for updating/upgrading software that configures layouts to reduce probability of introducing future bug</li> </ul> <p>Other mitigations / fixes (highly incomplete):</p> <ul> <li>Set up disk / RAID health &amp; minantance on observability boxes</li> <li>Send broken / unhealthy hosts to SiteOps for repair</li> <li>Remove Ruby wildcards from outage page</li> <li>Bundle CSS into outage page so that site CSS still works when other things are down but the outage page is up</li> <li>Add load shedding to front end to drop traffic when overloaded</li> <li>Change logging library for user data service to much cheaper logging library to prevent GC pressure from killing the service when error rate is high</li> <li>Fix 5 second timeout to look at correct header</li> <li>Add an independent timeout at a different level of the stack that should also fire if requests are completely failing to make progress</li> <li>Change front-end health check and restart to forcibly kill nodes instead of trying to gracefully shut them down</li> <li>Ensure only one version of the health check script is running on one node at any given time</li> </ul> <p>Lessons learned:</p> <ul> <li>Failure modes need to be actively tested, including failure modes that would cause a host reboot or a timeout</li> <li>Need to have rack diversity requirements, so losing a couple racks won&#39;t disproportionately impact a small number of services</li> </ul> <h3 id="2013-01-sev-0">2013-01 (SEV-0)</h3> <p>Site outage for 3h30m</p> <p>An increase in load (AFAAK, normal for the day, not an outlier load spike) caused a tail latency increase on cache. The tail latency increased on cache was caused by IRQ affinities not being set on new cache hosts, which caused elevated queue lengths and therefore elevated latency.</p> <p>Increased cache latency along with the design of tweet service using cache caused shards of the service using cache to enter a GC death spiral (more latency -&gt; more outstanding requests -&gt; more GC pressure -&gt; more load on the shard -&gt; more latency), which then caused increased load on remaining shards.</p> <p><b>Mitigations / fixes</b>:</p> <ul> <li>IRQ affinity needs to be set for cache hosts, per the 2011-08 incident <ul> <li>Make this the default for boxes instead of having cache hosts do this as one-off changes</li> </ul></li> <li>Change tweet service settings <ul> <li>Reduce max number of connections</li> <li>Increase timeout</li> <li>No GC config changes made because, at the time, GC stats weren&#39;t exported as metrics and the GC logs weren&#39;t logged sufficient information to understand if bad GC settings were a contributing factor</li> </ul></li> <li>Change settings for all services that use cache <ul> <li>Adjust connection limits to ~2x steady state</li> </ul></li> </ul> <h3 id="2013-09-sev-1">2013-09 (SEV-1)</h3> <p>Overall site success rate dropped to 92% in one datacenter. Users were impacted for about 15 minutes.</p> <p>The timeline service lost access to about 75% of one of the caches it uses. The cache team made a serverset change for that cache and the timeline service wasn&#39;t using the recommended mechanism to consume the cache serverset path and didn&#39;t &#34;know&#34; which servers were cache servers.</p> <p><b>Mitigations / fixes</b>:</p> <ul> <li>Have timeline service use recommended mechanism for finding serverset path</li> <li>Audit all code that consumes server set paths to ensure no service is using a non-recommended mechanism for serverset paths</li> </ul> <h3 id="2014-01-sev-0">2014-01 (SEV-0)</h3> <p>The site went down in one datacenter, impacting users whose requests went to that datacenter for 20 minutes.</p> <p>The tweet service started sending elevated load to caches. A then-recent change removed the cap on the number of connections that could be made to caches. At the time, when caches hit around ~160k connections, they would fail to accept new connections. This caused the monitoring service to be unable to connect to cache shards, which caused the monitoring service to restart cache shards, causing an outage.</p> <p>In the months before the outage, there were five tickets describing various ingredients for the outage.</p> <p>In one ticket, a follow-up to a less serious incident caused by a combination of bad C-state configs and SMIs, it was noted that caches stopped accepting connections at ~160k connections. An engineer debugged the issue in detail, figured out what was going on, and suggested a number of possible paths to mitigating the issue.</p> <p>One ingredient is that, especially when cache is highly loaded, cache can not have <code>accept</code>ed the connection even though the kernel will have established the TCP connection.</p> <p>The client doesn&#39;t &#34;know&#34; that the connection isn&#39;t really open to the cache and will send a request and wait for a response. Finagle may open multiple connections if it &#34;thinks&#34; that more concurrency is needed. After 150ms, the request will time out. If the queue is long on the cache side, this is likely to be before the cache has even attempted to do anything about the request.</p> <p>After the timeout, Finagle will try again and open another connection, causing the cache shard to become more overloaded each time this happens.</p> <p>On the client side, each of these requests causes a lot of allocations, causing a lot of GC pressure.</p> <p>At the time, settings allowed for 5 requests before marking a node as unavailable for 30 seconds, with 16 connection parallelism and each client attempting to connect to 3 servers. When all those numbers were multiplied out by the number of shards, that allowed the tweet service to hit the limits of what cache can handle before connections stop being accepted.</p> <p>On the cache side, there was one dispatcher thread and N worker threads. The dispatcher thread would call <code>listen</code> and <code>accept</code> and then put work onto queues for worker threads. By default, the backlog length was 1024. When <code>accept</code> failed due to an fd limit, the dispatcher thread set backlog to 0 in <code>listen</code> and ignored all events coming to listening fds. Backlog got reset to normal and connections were accepted again when a connection was closed, freeing up an fd.</p> <p>Before the major incident, it was observed that after the number of connections gets &#34;too high&#34;, connections start getting rejected. After a period of time, the backpressure caused by rejected connections would allow caches to recover.</p> <p>Another ingredient to the issue was that, on one hardware SKU, there were OOMs when the system ran out of <code>32kB</code> pages under high cache load, which would increase load to caches that didn&#39;t OOM. This was fixed by a Twitter kernel engineer in</p> <pre><code>commit 96c7a2ff21501691587e1ae969b83cbec8b78e08
Author: Eric W. Biederman &lt;ebiederm@xmission.com&gt;
Date:   Mon Feb 10 14:25:41 2014 -0800

    fs/file.c:fdtable: avoid triggering OOMs from alloc_fdmem
    
    Recently due to a spike in connections per second memcached on 3
    separate boxes triggered the OOM killer from accept.  At the time the
    OOM killer was triggered there was 4GB out of 36GB free in zone 1.  The
    problem was that alloc_fdtable was allocating an order 3 page (32KiB) to
    hold a bitmap, and there was sufficient fragmentation that the largest
    page available was 8KiB.
    
    I find the logic that PAGE_ALLOC_COSTLY_ORDER can&#39;t fail pretty dubious
    but I do agree that order 3 allocations are very likely to succeed.
    
    There are always pathologies where order &gt; 0 allocations can fail when
    there are copious amounts of free memory available.  Using the pigeon
    hole principle it is easy to show that it requires 1 page more than 50%
    of the pages being free to guarantee an order 1 (8KiB) allocation will
    succeed, 1 page more than 75% of the pages being free to guarantee an
    order 2 (16KiB) allocation will succeed and 1 page more than 87.5% of
    the pages being free to guarantee an order 3 allocate will succeed.
    
    A server churning memory with a lot of small requests and replies like
    memcached is a common case that if anything can will skew the odds
    against large pages being available.
    
    Therefore let&#39;s not give external applications a practical way to kill
    linux server applications, and specify __GFP_NORETRY to the kmalloc in
    alloc_fdmem.  Unless I am misreading the code and by the time the code
    reaches should_alloc_retry in __alloc_pages_slowpath (where
    __GFP_NORETRY becomes signification).  We have already tried everything
    reasonable to allocate a page and the only thing left to do is wait.  So
    not waiting and falling back to vmalloc immediately seems like the
    reasonable thing to do even if there wasn&#39;t a chance of triggering the
    OOM killer.
    
    Signed-off-by: &#34;Eric W. Biederman&#34; &lt;ebiederm@xmission.com&gt;
    Cc: Eric Dumazet &lt;eric.dumazet@gmail.com&gt;
    Acked-by: David Rientjes &lt;rientjes@google.com&gt;
    Cc: Cong Wang &lt;cwang@twopensource.com&gt;
    Cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
</code></pre> <p>and is another example of why <a href="https://danluu.com/in-house/">companies the size of Twitter get value out of having a kernel team</a>.</p> <p>Another ticket noted the importance of having standardized settings for cache hosts for things like IRQ affinity, C-states, turbo boost, NIC bonding, and firmware version, which was a follow up to another ticket noting that the tweet service sometimes saw elevated latency on some hosts, which was ultimately determined to be due to increased SMIs after a kernel upgrade impacting one hardware SKU type due to some interactions between the kernel and the firmware version.</p> <p><b>Cache Mitigations / fixes</b>:</p> <ul> <li>Reduce backlog from 1024 to 128 to apply back pressure more quickly when dispatcher is overloaded</li> <li>Lower fd limit to avoid some shards running out of memory</li> <li>Use a fixed hash table size in cache to avoid large load of allocations and memory/CPU load during hash table migration</li> <li>Use CPU affinity on low latency memcache hosts</li> </ul> <p>Tests with these mitigations indicated that, even without fixes to clients to prevent clients from &#34;trying to&#34; overwhelm caches, these prevented cache from falling over under conditions similar to the incident.</p> <p><b>Tweet service Mitigations / fixes</b>:</p> <ul> <li>Change timeout, retry, and concurrent client connection settings to avoid overloading caches</li> </ul> <p><b>Lessons learned</b>:</p> <ul> <li>Consistent hardware settings are important</li> <li>Allowing high queue depth before applying backpressure can be dangerous</li> <li>Clients should &#34;do the math&#34; when setting retry policies to avoid using retry policies that can completely overwhelm cache servers when 100% of responses fail and maximal backpressure is being applied</li> </ul> <h3 id="2014-03-sev-0">2014-03 (SEV-0)</h3> <p><a href="https://twitter.com/TheEllenShow/status/440322224407314432">A tweet from Ellen</a> was retweeted very frequently during the Oscars, which resulted in search going down for about 25 minutes as well as a site outage that prevented many users from being able to use the site.</p> <p>This incident had a lot of moving parts. From a cache standpoint, this was another example of caches becoming overloaded due to badly behaved clients.</p> <p>It&#39;s similar to the 2014-01 incident we looked at, except that the cache-side mitigations put in place for that incident weren&#39;t sufficient because the &#34;attacking&#34; clients picked more aggressive values than were used by the tweet service during 2014-01 incident and, by this time, some caches were running in containerized environments on shared mesos, which made them vulnerable to <a href="https://danluu.com/cgroup-throttling/">throttling death spirals</a>.</p> <p>The major fix to this direct problem was to add pipelining to the Finagle memcached client, allowing most clients to get adequate throughput with only 1 or 2 connections, reducing the probability of clients hammering caches until they fall over.</p> <p>For other services, there were close to 50 fixes put into place across many services. Some major themes were for the fixes were:</p> <ul> <li>Add backpressure where appropriate <ul> <li>Avoid retrying when backpressure is being applied</li> </ul></li> <li>Make sure data (mostly) flows to the same DC to avoid expensive and slow cross-DC traffic</li> <li>Create appropriate thread pools to prevent critical work from being starved</li> <li>Add in-process caching for hot items</li> <li>Return incomplete results for queries when under high load / don&#39;t fail requests if results are incomplete</li> <li>Creeate guide for how to cofigure cache clients to avoid DDoSing cache</li> </ul> <h3 id="2016-01-sev-0">2016-01 (SEV-0)</h3> <p>A Japanese boy band, SMAP, held a conference to falsely deny rumors they were going to break up. This resulted in an outage in one datacenter that impacted users routed to that datacenter for ~20 minutes, until that DC was failed away from. It took about six hours for services in the impacted DC to recover.</p> <p>The tweet service in one DC had a load spike, which caused 39 cache shard hosts to OOM kill processes on those hosts. The cluster manager didn&#39;t automatically remove the dead nodes from the server set because there were too many dead nodes (it will automatically remove nodes if a few fail, but if too many fail, this change is not automated due to the possibility of exacerbating some kind of catastrophic failure with an automated action since removing nodes from a cache server set can cause traffic spikes to persistent storage). When cache oncalls manually cleaned up the dead nodes, the service that should have restarted them failed to do so because a puppet change had accidentally removed cache related configs for the service would normally restart the nodes. Once the bad puppet commit was reverted, the cache shards came back up, but these initially came back too slowly and then later came back too quickly, causing recovery of tweet service success rate take an extended period of time.</p> <p>The cache shard hosts were OOM killed because too much kernel socket buffer memory was allocated,</p> <p>The initial fix for this was to limit TCP buffer size on hosts to 4 GB, but this failed a stress test and it was determined that memory fragmentation on hosts with high uptime (2 years) was the reason for the failure and the mitigation was to reboot hosts more frequently to clean up fragmentation.</p> <p><b>Mitigations / fixes</b>:</p> <ul> <li>Reboot hosts more than once every two years</li> <li>Add puppet alerts to cache boxes to detect breaking puppet changes</li> <li>Change cluster manager to handle large changes better (change already in progress due to a previous, smaller, incident)</li> </ul> <h3 id="2016-02-sev-1">2016-02 (SEV-1)</h3> <p>This was the failed stress test from the 2016-01 <code>SEV-0</code> mentioned above. This mildly degraded success rate to the site for a few minutes until the stress test was terminated.</p> <h3 id="2016-07-sev-1">2016-07 (SEV-1)</h3> <p>A planned migration of user data cache from dedicated hosts to mesos led to significant service degradation in one datacenter and then minor degradation in another datacenter. Some existing users were impacted and all basically new user signups failed for about half an hour.</p> <p>115 new cache instances were added to a serverset as quickly as the cluster manager could add them, reducing cache hit rates. The cache cluster manager was expected to add 1 shard every 20 minutes, but the configuration change accidentally changed the minimum cache cluster size, which &#34;forced&#34; the cluster manager to add the nodes as quickly as it could.</p> <p>Adding so many nodes at once reduced user data cache hit rate from the normal 99.8% to 84%. In order to stop this from getting worse, operators killed the cluster manager to prevent it from adding more nodes to the serverset and then redeployed the cluster manager in its previous state to restore the old configuration, which immediately improved user data cache hit rate.</p> <p>During the time period cache hit rate was degraded, the backing DB saw a traffic spike that caused long GC pauses. This caused user data service requests that missed cache to have a 0% success rate when querying the backing DB.</p> <p>Although there was rate limiting in place to prevent overloading the backing DB, the thresholds were too high to trigger. In order to recover the backing DB, operators did a rolling restart and deployed strict rate limits. Since one datacenter was failed away from due to the above, the strict rate limit was hit in another datacenter because the failing away from one datacenter caused elevated traffic in another datacenter. This caused mildly reduces success rate in the user data service because requests were getting rejected by the strict rate limit, which is why this incident also impacted a datacenter that wasn&#39;t impacted by the original cache outage.</p> <p><b>Mitigations / fixes</b>:</p> <ul> <li>Add a deploy hook that warns operators who are adding or removing a large number of nodes from a cache cluster</li> <li>Add detailed information in runbooks about how to do deploys, cluster creation, expansion, shrinkage, etc.</li> <li>Add a checklist for all &#34;tier 0&#34; (critical) cache deploys</li> </ul> <h3 id="2018-04-sev-0">2018-04 (SEV-0)</h3> <p>A planned test datacenter failover caused a partial site outage for about 1 hour. Degraded success rate was noticed 1 minute into the failover. The failover test was immediately reverted, but it took most of an hour for the site to fully recover.</p> <p>The initial site degradation came from increased error rates in the user data service, which was caused by cache hot keys. There was a mechanism intended to cache hot keys, which sampled 1% of events (with sampling being used in order to reduce overhead, the idea being that if a key is hot, it should be noticed even with sampling) and put sampled keys into a FIFO with a hash map to count how often each key appears in the queue.</p> <p>Although this worked for previous high load events, there were some instances were this didn&#39;t work as well as intended (but weren&#39;t a root cause in an incident) when the values are large because the 1% sampling rate wouldn&#39;t allow the cache to &#34;notice&#34; a hot key quickly enough in the case where there were large (and therefore expensive) values. The original hot key detection logic was designed for tweet service cache, where the largest keys were about 5KB. This same logic was then used for other caches, where keys can be much larger. User data cache wasn&#39;t a design consideration for hot keys because, at the time hot key promotion was designed, the user data cache wasn&#39;t having hot key issues because, at the time, the items that would&#39;ve been the hottest keys were served from an in-process cache.</p> <p>The large key issue was exacerbated by the use of <code>FNV1-32</code> for key hashing, which ignores the least significant byte. The data set that was causing a problem had a lot of its variance inside the last byte, so the use of <code>FNV1-32</code> caused all of the keys with large values to be stored on small number of cache shards. There were suggestions to move to migrate off of <code>FNV1-32</code> at least as far back as 2014 for this exact reason and a more modern hash function was added to a utility library, but some cache owners chose not to migrate.</p> <p>Because the hot key promotion logic didn&#39;t trigger, traffic to the hot cache shards saturated NIC bandwidth to the shards that had hot keys that were using 1Gb NICs (Twitter hardware is generally heterogenous unless someone ensures that clusters only have specific characteristics; although many cache hosts had 10Gb NICs, many also had 1Gb NICs).</p> <p>Fixes / mitigations:</p> <ul> <li>Tune user data cache hot key detection</li> <li>Upgrade all hardware in the relevant cache clusters to hosts with 10Gb NICs</li> <li>Switch some cahces from <code>FNV</code> to <code>murmur3</code></li> </ul> <h3 id="2018-06-sev-1">2018-06 (SEV-1)</h3> <p>During a test data center failover, success rate for some kinds of actions dropped to ~50% until the test failover was aborted, about four minutes later.</p> <p>From a cache standpoint, the issue was that tweet service cache shards were able to handle much less traffic than expected (about 50% as much traffic) based on load tests that weren&#39;t representative of real traffic, resulting in the tweet service cache being under provisioned. Among the things that made the load test setup unrealistic were:</p> <ul> <li><a href="https://twitter.com/danluu/status/1360029773011984385">The arrival distribution was highly non-independent, with large spikes due to correlated arrivals when under load</a>. It&#39;s common to assume either a constant or Poisson arrival distribution, but as <a href="https://danluu.com/latency-pitfalls/#minutely-resolution">we saw when looking at metrics data, the assumption that commonly used load generation assumptions that arrivals are either cosntant or Poisson are false</a> in a way that can result in unbounded difference between achievable throughput under actual load vs. a load generator that makes naive assumptions</li> <li>The number of connections used in the load test was significantly smaller than the number of connections when under high load in practice</li> </ul> <p>Also, a reason for degraded cache performance was that, once a minute, container-based performance counter collection was run for ten seconds, which was fairly expensive because many more counters were being collected than there are hardware counters, requiring the kernel to do expensive operations to switch out which counters are being collected.</p> <p>The degraded performance both increased latency enough during the window when performance counters were collected that cache shards were unable to complete their work before hitting <a href="https://danluu.com/cgroup-throttling/">container throttling limits</a>, degrading latency to the point that tweet service requests would time out. As configured, after 12 consecutive failures to a single cache node, tweet service clients would mark the node as dead for 30 seconds and stop issuing requests to it, causing the node to get no traffic for 30 seconds as clients independently made the decision to mark the node as dead. This caused increased request rates to increase past the request rate quota to the backing DB, causing requests to get rejected at the DB, increasing the failure rate of the tweet service.</p> <p><b>Mitigations / fixes</b>:</p> <ul> <li>Reduced number of connections from tweet service client to cache from 4 to 2, which reduced latency <ul> <li>As noted in a previous incident, adding pipelining allowed caches to operate efficiently with only 1 client connection, but some engineers were worried that 1 might not be enough because the number of connections was previously much higher, so 4 was chosen &#34;just in case&#34;, but, with standard Linux kernel networking, <a href="https://twitter.github.io/pelikan/2020/benchmark-adq.html">having more connections increases tail latency</a>, so this degraded performance</li> </ul></li> <li>Add more cache nodes to reduce load on individual cache shards</li> <li>Improve cache hot key promotion algorithm <ul> <li>This wasn&#39;t specific to this incident, but an engineer did an analysis and found that the hot key promotion algorithm introduced a year ago had a cache hit rate of approximately 0.3% due to a combination of issues for one cache cluster. Switching to a better algorithm improved cache hit rate and performance significantly</li> </ul></li> <li>Change cache qualification process so that the cache performance used to determine capacity (number of nodes) more accurately reflects real-world cache performance</li> <li>Do a detailed analysis of the cost of multiplexed performance counter collection</li> </ul> <p><i>Thanks to <SPAN size="+1"><b><a rel="sponsored" href="https://www.reforge.com/all-programs?utm_source=danluu&amp;utm_medium=referral&amp;utm_campaign=spring22_newsletter_test&amp;utm_term=&amp;utm_content=engineering">Reforge - Engineering Programs</a></b></SPAN> and <SPAN size="+1"><b><a rel="sponsored" href="https://flatironsdevelopment.com/">Flatirons Development</a></b></SPAN> for helping to make this post possible by <a href="https://patreon.com/danluu">sponsoring me at the Major Sponsor tier</a>.</i></p> <p>Also, thanks to Michael Leinartas, Michael Motherwell, and Ben Kuhn for comments/corrections/discussion.</p> <h3 id="appendix-pelikan-cache">Appendix: Pelikan cache</h3> <p><a href="https://twitter.github.io/pelikan/">Pelikan</a> was created to address issues we saw when operating memcached and Redis at scale. <a href="https://twitter.github.io/pelikan/2019/why-pelikan.html">This document</a> explains some of the motivations for Pelikan. The moduarlity / ease of modification has allowed us to discover novel cache innovations, such as <a href="https://twitter.com/danluu/status/1381687511362138113">a new eviction algorithm that addresses the problems we ran into with existing eviction algorithms</a>.</p> <p>With respect to the kinds of things discussed in this post, Pelikan has had more predictable performance, better median performance, and better performance in the tail than our existing caches when we&#39;ve tested it in production, which means we get better reliaiblity and more capacity at a lower cost.</p>   </div>
  </body>
</html>
