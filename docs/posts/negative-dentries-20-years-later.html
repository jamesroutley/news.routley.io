<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/890025/16c8b2a4f8bf3340/">Original</a>
    <h1>Negative dentries, 20 years later</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 0 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>
<p>
Filesystems and the virtual filesystem layer are in the business of
managing files that actually exist, but the Linux &#34;dentry cache&#34;, which
remembers the results of file-name lookups, also keeps track of files that
<i>don&#39;t</i> exist.  This cache of &#34;negative dentries&#34; plays an important
role in the overall performance of the system but, if it is allowed to grow
too large, its role can become negative in its own right.  As the 2022 <a href="https://events.linuxfoundation.org/lsfmm/">Linux Storage, Filesystem,
and Memory-Management Summit</a> (LSFMM) approaches, the subject of negative
dentries has come up yet again; whether one can be positive about the
prospects for a resolution this time around remains unclear.
</p><p>
The kernel&#39;s dentry cache saves the results of looking up a
file in a filesystem.  Should the need arise to look up the same file again, the
cached result can be used, avoiding a trip through the underlying
filesystem and accesses to the storage device.  Repeated file-name lookups
are common — consider <tt>/usr/bin/bash</tt> or <tt>~/.nethackrc</tt> — so
this is an important optimization to make.
</p><p>
The importance of remembering failed lookups in negative dentries may be
less obvious at the outset.  As it happens, repeated attempts to look up a
nonexistent file are also common; an example would be the shell&#39;s process of
working through the search path every time a user types &#34;<tt>vi</tt>&#34;
(Emacs users start the editor once and never leave its cozy confines
thereafter, so they don&#39;t benefit in the same way).  Even more common are
failed lookups created by the program loader searching for shared libraries
or a compiler looking for include files.  One is often advised to &#34;fail
fast&#34; in this society; when it comes to lookups of files that don&#39;t exist,
that can indeed be good advice.
</p><p>
So negative dentries are a good thing but, as we all know, it is possible
to have too much of a good thing.  While normal dentries are limited by the
number of files that actually exist, there are few limits to the number of
nonexistent files.  As a result, it is easy for a malicious (or simply
unaware) application to create negative dentries in huge numbers.  If
memory is tight, the memory-management subsystem will eventually work to
push some of these negative dentries out.  In the absence of memory
pressure, though, negative dentries can accumulate indefinitely, leaving a
large mess to clean up when memory does inevitably run out.
</p><p>
Some kernel problems are resolved quickly; others take a little longer.
LWN briefly <a href="https://lwn.net/Articles/1511/">reported on</a> a complaint about the
memory consumption of negative dentries back in 2002, nearly exactly 20 years
ago.  A more recent attempt to solve the problem was <a href="https://lwn.net/Articles/814535/">covered here</a> in early 2020.  While numerous
developers have taken a stab at the negative-dentry problem over time, the
core problem remains.  Those dentries still take up valuable memory, and
they can create other problems (such as <a href="https://lwn.net/ml/linux-fsdevel/20220209231406.187668-1-stephen.s.brennan@oracle.com/">soft
lockups</a>) as well.
</p><h4>A new discussion</h4>
<p>
In mid-March, Matthew Wilcox <a href="https://lwn.net/ml/linux-mm/YjDvRPuxPN0GsxLB@casper.infradead.org/">suggested</a>
that the negative-dentry problem might make a good LSFMM topic:
&#34;<span>maybe some focused brainstorming on the problem would lead to
something that actually works</span>&#34;.  Often, simply proposing a topic
like this can elicit the sort of brainstorming needed to work toward a
solution.  That didn&#39;t happen this time, but it did lead to the posting of
<a href="https://lwn.net/ml/linux-kernel/20220331190827.48241-1-stephen.s.brennan@oracle.com/">a
patch set</a> by Stephen Brennan showing a new approach to the problem.
</p><p>
One of the difficulties posed by the negative-dentry problem is that it can
be hard to know when the time has come to start throwing them away.  The
sizes of systems and workloads vary hugely, so any sort of simple limit is
likely to cause performance regressions somewhere.  Providing a knob for the system
administrator to tune the limit can be tempting, but that just pushes the
problem onto the users, and it is generally felt that the kernel should be
able to figure things out by itself.  But, as Brennan noted, that is not
easy:
</p><blockquote>
	It&#39;s hard to look at a hash bucket or LRU list and design a
	heuristic for an acceptable amount of negative dentries: it won&#39;t
	scale from small to large systems well. But setting up heuristics
	on a per-directory basis will scale better, and it&#39;s easier to
	reason about.
</blockquote>
<p>
The specific heuristic proposed by the patch is that the negative dentries
for any given directory should not outnumber the positive dentries by more
than a factor of five.  If there are 20 positive dentries in the cache for
a directory, there can be no more than 100 negative dentries.  It is a nice
idea, with only one small problem: the kernel doesn&#39;t keep counts of the
number of dentries (or their types) associated with each directory.
</p><p>
To get around that, Brennan added code that maintains a &#34;cursor&#34; in the
list of dentries associated with each directory.  Whenever a dentry
operation (creation or deletion) happens, that code will advance the cursor
through the next six dentries in the list; if it does not encounter at
least one positive dentry, it assumes that the limit has been exceeded and
cleans up some negative dentries.  Attaching this work to the dentry
operations themselves means that the penalty will be paid by processes that
are responsible for the creation of a lot of dentries, which seems correct.
</p><p>
The problem with this approach is, of course, that there is nothing that
forces dentries to be added to a directory&#39;s list in any particular order.
Depending on the order in which dentries are created, this algorithm could
come to an incorrect conclusion regarding the real ratio of positive to
negative dentries and do the wrong thing.  Brennan acknowledged this
problem (&#34;<span>This workload-dependence is bad, full stop</span>&#34;), but
has not yet come up with a better idea.  As things stand, this algorithm
seems certain to lead to pathological cases; that may prevent the
acceptance of this patch set even in the absence of other concerns.

</p><h4>The bigger problem</h4>
<p>
Back in the general discussion, though, Dave Chinner <a href="https://lwn.net/ml/linux-mm/20220316025223.GR661808@dread.disaster.area/">argued</a>
that the focus on negative dentries was addressing a symptom of the problem
and missing the bigger issue.  The real problem, he said, is that
memory pressure is the only mechanism the kernel has for controlling the
size of the many caches it maintains:
</p><blockquote>
	Yup, the underlying issue here is that memory reclaim does nothing
	to manage long term build-up of single use cached objects when
	*there is no memory pressure*. There&#39;s [plenty] of idle time and spare
	resources to manage caches sanely, but we don&#39;t. e.g. there is no
	periodic rotation of caches that could lead to detection and
	reclaim of single use objects (say over a period of minutes) and
	hence prevent them from filling up all of memory unnecessarily and
	creating transient memory reclaim and allocation latency spikes
	when memory finally fills up.
</blockquote>
<p>
Rather than worry about the dentry cache, he said, developers should come
up with a mechanism that can manage the size of all in-kernel caches.
Wilcox <a href="https://lwn.net/ml/linux-mm/YjnmcaHhE1F2oTcH@casper.infradead.org/">agreed
in principle</a>, but cautioned against making the problem so broad that it
becomes intractable.  Chinner <a href="https://lwn.net/ml/linux-mm/20220322222114.GE1609613@dread.disaster.area/">doubled
down</a>, though, saying that multiple kernel caches have the same problem,
and that a solution for one, based on some sort of periodic scanning to age
items out of the cache, would be instantly applicable to all of them.
</p><p>
This discussion has mostly wound down without any suggestion that anybody
is setting out to create the more general cache-aging mechanism that
Chinner would like to see.  The problem remains, though, and seems unlikely
to go away by itself.  So the chances of this discussion showing up in an
LSFMM slot seem fairly high.  Perhaps an in-person discussion — the first
in the memory-management and filesystem communites in three years — will lead to some sort
of consensus on a solution, preferably one that will be implemented before another
20 years pass.</p>
               </div></div>
  </body>
</html>
