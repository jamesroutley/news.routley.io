<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://questdb.io/blog/building-faster-hash-table-high-performance-sql-joins/">Original</a>
    <h1>Building a faster hash table for high performance SQL joins</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>If you run a <strong>JOIN</strong> or a <strong>GROUP BY</strong> in a database of your choice, there is a
good chance that there is a hash table at the core of the data processing. At
QuestDB, we have <strong>FastMap</strong>, a hash table used for hash join and aggregate
handling. While high performing, its design is a bit unconventional as it
differs from most general-purpose hash tables.</p><p>In this article, we&#39;ll tell you why hash tables are important to databases, how
QuestDB&#39;s <strong>FastMap</strong> works and why it speeds up SQL execution.</p><h2><a aria-hidden="true" tabindex="-1" id="database--hash-table--️"></a>Database + hash table = ❤️<a href="#database--hash-table--️" title="Direct link to heading">#</a></h2><p>QuestDB is an open-source time-series database that supports
<a href="https://questdb.io/docs/reference/api/ilp/overview/">InfluxDB Line Protocol</a> for fast streaming
ingestion and SQL over <a href="https://questdb.io/docs/reference/api/postgres/">Postgres wire protocol</a>
and <a href="https://questdb.io/docs/reference/api/rest/">HTTP</a> for flexible and efficient querying. Like
most SQL databases, we support JOINs:</p><p>The above query involves an implicit
<a href="https://questdb.io/docs/reference/sql/join/#inner-join">INNER JOIN</a> and returns something like
the following result set:</p><table><thead><tr><th>first_name</th><th>last_name</th><th>name</th></tr></thead><tbody><tr><td>John</td><td>Doe</td><td>Example Company</td></tr><tr><td>Jane</td><td>Doe</td><td>Example Company</td></tr></tbody></table><p>What exactly does the database do to return this result? There are multiple
approaches to processing a JOIN, one of which is the so-called
<a href="https://en.wikipedia.org/wiki/Hash_join" target="_blank" rel="noopener noreferrer">hash join</a>.</p><p>To complete a hash join, we first iterate the joined table (<strong>companies</strong> in our
example) and store all join key to row mappings in a hash table. Then, we can
iterate the first table (<strong>employees</strong>) while using the hash table to find the
joined rows:</p><p>This is a simplified version of what pretty much any database does when it
decides to execute a hash join. Notice that the hash table is used in a
grow-only manner. This means that once data is added to the hash table, it is
not removed or modified - the table will only grow in size.</p><p>As a result, we only see <strong>get()</strong>/<strong>put()</strong> operations, for retrieval and
addition respectively. Needless to say, a fast hash table is essential for
strong hash join performance.</p><p>Our second use case has to do with <a href="https://questdb.io/docs/reference/sql/group-by/">GROUP BY</a> and
<a href="https://questdb.io/docs/reference/sql/sample-by/">SAMPLE BY</a>, our time-series SQL extension.
Let&#39;s count people with the same surnames with a simple <strong>GROUP BY</strong>:</p><p>The above query will return something like this:</p><table><thead><tr><th>last_name</th><th>count</th></tr></thead><tbody><tr><td>Doe</td><td>2</td></tr></tbody></table><p>Again, what kind of magic does the database do to process such a query? The
answer is that, well, it uses a hash table:</p><p>Notice that we use a cursor over the hash table to traverse and iterate over the
result set. Everything is straightforward:</p><ol><li>We store <strong>GROUP BY</strong> column values (<strong>last_name</strong>) as hash table keys</li><li>Aggregate functions (<strong>count()</strong>) go to hash table values</li></ol><p>Imagine that we run this query over a few hundred million rows. This means at
least a few hundred million hash table operations. As you might imagine, a slow
hash table would make for a slower query. A faster hash table? Faster queries!</p><p>We want a faster table. Let&#39;s discuss what makes <strong>FastMap</strong> different from a
general-purpose data structure. The rest of the post assumes that you&#39;re
familiar with hash table basics and design options, so if that&#39;s not the case,
we recommend reading the
<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener noreferrer">Hash table Wikipedia page</a>.</p><h2><a aria-hidden="true" tabindex="-1" id="fastmap-internals"></a>FastMap internals<a href="#fastmap-internals" title="Direct link to heading">#</a></h2><blockquote><p>Prefer to read the code? Jump over to <strong>FastMap</strong> in the
<a href="https://github.com/questdb/questdb/blob/b50b145867ee1b590a4bcd5413a7d3c4028a650e/core/src/main/java/io/questdb/cairo/map/FastMap.java" target="_blank" rel="noopener noreferrer">QuestDB GitHub repository</a>.</p></blockquote><p><strong>FastMap</strong> is written in Java and uses
<a href="https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java" target="_blank" rel="noopener noreferrer">Unsafe</a>
heavily to store data outside of JVM&#39;s heap, in native memory.</p><p>At a glance, <strong>FastMap</strong> is just a hash table with open addressing and linear
probing. The load factor is kept relatively low (0.7) and hash codes are cached
to mitigate hash collision impact. Nothing surprising so far. The interesting
part is that the hash table is grow-only, and supports var-size keys, but only
fixed-size values.</p><p><strong>FastMap</strong> consists of two main parts:</p><ol><li>An array of offsets and hash codes, i.e. the hash table itself</li><li>a so-called heap, i.e. a grow-only chunk of native memory</li></ol><p>These two parts can be illustrated with the following diagram:</p><figure><div><p><img alt="FastMap memory layout" height="407" src="https://questdb.io/img/blog/2023-11-23/fastmap-layout.webp" width="818" loading="lazy"/></p><figcaption>FastMap memory layout</figcaption></div></figure><div><p><h5><span><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></p><p>Note that we use the &#34;heap&#34; word for a grow-only contiguous chunk of native
memory used to store <strong>FastMap</strong>&#39;s key-value pairs, not JVM&#39;s heap.</p></div><p>Each offset value is a compressed 32-bit offset pointing at a key-value pair
stored in the heap. Key-value pair addresses are 8 byte-aligned, hence we can
compress 35-bit offsets to 32-bit. This means that a <strong>FastMap</strong> is capable of
holding up to 32GB of data. Interestingly, OpenJDK does a similar trick with
object pointers on 64-bit systems when
<a href="https://wiki.openjdk.org/display/HotSpot/CompressedOops" target="_blank" rel="noopener noreferrer">CompressedOops</a>
feature is enabled.</p><p>Since offsets aren&#39;t memory addresses, but address deltas, they remain the same
if the heap is reallocated. In other words, there is no need to update the
offsets when the heap needs to grow.</p><p>The heap itself contains key-value pairs stored in insertion order. Thanks to
our SQL use cases, we can limit <strong>FastMap</strong> to grow-only API. In other words: It
only supports insert and update operations, but doesn&#39;t support key deletion.</p><p>As a result, we don&#39;t need to deal with tombstones and periodical heap
compaction. Once a SQL query execution finishes, we can simply zero the offsets
array and treat the heap as empty.</p><p>Each key-value pair stored on the heap has the following layout:</p><p>The key length is stored in bytes at the entry header, allowing for quick
navigation to the value. This is particularly useful for variable-size keys,
such as a single <strong>STRING</strong> column value. Following the header, the pair memory
contains all key column values (similar to fields), and then the value column
values.</p><p><strong>FastMap</strong> is designed to support only fixed-size values, such as multiple
<strong>INT</strong> columns. This design choice leads to simplified updates to the value
when necessary.</p><p>Another nice side effect of this indirection with the heap is the guaranteed
insertion order on hash table iteration. Most hash tables have no iteration
order guarantees due to the nature of hash functions. But <strong>FastMap</strong> is
different.</p><p>If you insert &#34;John&#34; and then &#34;Jane&#34; string keys into a <strong>FastMap</strong>, then that
would later become the iteration order. While it doesn&#39;t sound like a big deal
for most applications, this guarantee is important in the database world.</p><p>If the underlying table data or index-based access returns sorted data, then we
may want to keep the order to avoid having to sort the result set. This is
helpful in case of a query with an <strong>ORDER BY</strong> clause. Performance-wise, direct
iteration over the heap is also beneficial as it means sequential memory access.</p><p>The hash function used in <strong>FastMap</strong> is also somewhat unconventional. We took a
long path using Java <strong>String</strong>&#39;s
<a href="https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/lang/StringUTF16.java#L414-L421" target="_blank" rel="noopener noreferrer">hash function</a>
(the polynomial hash function from The C Programming Language book by Kernighan
&amp; Ritchie), then <a href="https://github.com/Cyan4973/xxHash" target="_blank" rel="noopener noreferrer">xxHash64</a>, then another
polynomial function inspired by this
<a href="https://vanilla-java.github.io/2018/08/15/Looking-at-randomness-and-performance-for-hash-codes.html" target="_blank" rel="noopener noreferrer">Peter Lawrey&#39;s post</a>:</p><p>Here we calculate the hash code first in 8-byte chunks (<strong>long</strong> type), then in
4 bytes (<strong>int</strong>) and, finally, byte-by-byte. This provides much better speed
than a single byte-size loop and is known as the
<a href="https://en.wikipedia.org/wiki/SWAR" target="_blank" rel="noopener noreferrer">SWAR</a> technique.</p><p>Yes, this function has a worse quality than xxHash, but this is mitigated by its
compactness and the fact that we cache hash codes. A small executable is
important for smaller keys.</p><p>A function that occupies many <a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener noreferrer">i-cache</a>
lines may show worse results than a simpler one. Unless hash code calculation in
a tight loop is everything that your code does, a more complex hash function
with better quality is not necessarily better (wink-wink benchmarks that show
impressive hash function throughput).</p><p>Remember how we also cached hash codes for the inserted keys? Thanks to that, we
don&#39;t need to re-calculate them on look-ups, saving precious CPU cycles for more
important things.</p><p>But is all the complexity worth it? Why not just use a good old
<strong>java.util.HashMap</strong> from the standard Java library? Let&#39;s run a few
<a href="https://github.com/questdb/questdb/tree/b50b145867ee1b590a4bcd5413a7d3c4028a650e/benchmarks/src/main/java/org/questdb" target="_blank" rel="noopener noreferrer">microbenchmarks</a>
to compare them. The
<a href="https://github.com/questdb/questdb/blob/b50b145867ee1b590a4bcd5413a7d3c4028a650e/benchmarks/src/main/java/org/questdb/FastMapReadBenchmark.java" target="_blank" rel="noopener noreferrer">first</a>
benchmark verifies how long it takes to look up a short string key in a hash
map:</p><p>On average it takes 309 nanoseconds for <strong>FastMap</strong> to find the value for the
given key while for <strong>HashMap</strong> it takes 367 nanoseconds.</p><p>The
<a href="https://github.com/questdb/questdb/blob/b50b145867ee1b590a4bcd5413a7d3c4028a650e/benchmarks/src/main/java/org/questdb/FastMapWriteBenchmark.java" target="_blank" rel="noopener noreferrer">next</a>
benchmark tests how long it takes to insert a string key in a map:</p><p>Again, <strong>FastMap</strong> is slightly faster than <strong>HashMap</strong> which is significant
considering that the standard hash table had a long optimization path across so
many Java versions. QuestDB&#39;s hash table also has the advantage of being
zero-GC. It doesn&#39;t put any pressure on the garbage collector since the data is
stored off-heap.</p><p>For those who want to run the benchmarks and compare the results, in this case
we used Ubuntu 22.04, OpenJDK 64-bit 17.0.8.1, and an Intel i7-1185G7 CPU to get
the results.</p><p>While we have the microbenchmarks in place, we prefer relying on the query
execution times as the primary metric. With some of the described <strong>FastMap</strong>
enhancements landing in QuestDB recently, we reduced <strong>GROUP BY</strong> / <strong>SAMPLE
BY</strong> query execution times by 20-30%.</p><h2><a aria-hidden="true" tabindex="-1" id="whats-next"></a>What&#39;s next?<a href="#whats-next" title="Direct link to heading">#</a></h2><p>So, is QuestDB&#39;s <strong>FastMap</strong> the best thing since sliced bread? Of course, it&#39;s
not. As with everything in engineering, it&#39;s a matter of trade-offs. <strong>FastMap</strong>
works nicely for us, but it doesn&#39;t mean that it would be a good choice for,
say, a web application or even for another database. Besides that, there are
always some things to be optimized and improved. For example, the so-called
<a href="https://github.com/questdb/questdb/issues/3848" target="_blank" rel="noopener noreferrer">disk spill</a> could be added to
<strong>FastMap</strong> to handle huge join situations.</p><p>N.B. Thanks to the valuable feedback we received from the community after
publishing this post, we&#39;ve started experimenting with further optimizations.
The most noticeable one is
<a href="https://www.cs.cornell.edu/courses/JavaAndDS/files/hashing_RobinHood.pdf" target="_blank" rel="noopener noreferrer">Robin Hood hashing</a>,
a linear probing enhancement aimed to minimize the number of look-up probes for
the keys. If you prefer jumping to the code, the pull request is
<a href="https://github.com/questdb/questdb/pull/4054" target="_blank" rel="noopener noreferrer">here</a>.</p><p>As usual, we encourage you to try the latest QuestDB release and share your
feedback with our <a href="https://slack.questdb.io/" target="_blank" rel="noopener noreferrer">Slack Community</a>. You can also
play with our <a href="https://demo.questdb.io/" target="_blank" rel="noopener noreferrer">live demo</a> to see how fast it executes
your queries.</p></article></div></div>
  </body>
</html>
