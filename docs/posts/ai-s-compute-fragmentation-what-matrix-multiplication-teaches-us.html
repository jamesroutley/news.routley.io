<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.modular.com/blog/ais-compute-fragmentation-what-matrix-multiplication-teaches-us">Original</a>
    <h1>AI’s compute fragmentation: what matrix multiplication teaches us</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><header><figure id="w-node-_113b8cdb-e5d8-73d8-6e03-166be487a5ae-f575d457"><div></div><div><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c87317cb2740633f6b8f2_ryan-tpAyLp9Ro50-unsplash%20(4).jpg" loading="lazy" alt=""/></p><div></div></div></figure><div id="w-node-_113b8cdb-e5d8-73d8-6e03-166be487a5b9-f575d457"><h2>AI’s compute fragmentation: what matrix multiplication teaches us</h2><p>March 23, 2023</p></div></header></div></section><section><article><div><div><div><h2><strong>Compute fragmentation is holding AI back</strong></h2><p>AI is powered by a virtuous circle of data, algorithms (“models”), and compute. Growth in one pushes needs in the others and can grossly affect the developer experience on aspects like usability and performance. Today, we have more <a href="https://www.statista.com/statistics/871513/worldwide-data-created/">data</a> and more <a href="https://aiindex.stanford.edu/wp-content/uploads/2022/03/2022-AI-Index-Report_Master.pdf">AI model research</a> than ever before, but compute isn’t scaling at the same speed due to … well, physics.</p><p>If you’ve followed the evolution of AI and hardware, you’ve probably heard that <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore’s law</a> is ending. The rate of performance improvement in single-core processors is no longer doubling every 18 months, as has been true for the last 60 years. Beyond the physical limitations of continuing to make transistors smaller and smaller (e.g., excess power usage and heat due to current leakage), performance has become increasingly constrained by <a href="https://en.wikipedia.org/wiki/Random-access_memory#Memory_wall">memory latency</a>, which has grown much slower than processing speeds.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c7896101fcbad3f6ffcb0_Screen%20Shot%202023-02-28%20at%209.42.42%20PM.png" loading="lazy" alt=""/></p><figcaption><a href="https://cacm.acm.org/magazines/2019/2/234352-a-new-golden-age-for-computer-architecture/fulltext" target="_blank">Turing Lecture, Hennessy, Patterson</a>: An analysis of CPU processor performance improvements over time and the different eras of progress. Rate of performance improvement is plateauing.</figcaption></figure><p>‍</p><p>Yet, the need for more AI compute has continued to grow as <a href="https://arxiv.org/pdf/2202.05924.pdf" target="_blank">models become larger and larger</a> and more enterprise data is <a href="https://www.gartner.com/smarterwithgartner/what-edge-computing-means-for-infrastructure-and-operations-leaders" target="_blank">created and processed on the edge</a>. As a result, squeezing performance from hardware has become one of the main focuses of the industry.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c7b6acc9ed600e7bb42de_Screen%20Shot%202023-03-22%20at%208.18.08%20PM.png" loading="lazy" alt=""/></p><figcaption><a href="https://arxiv.org/pdf/2202.05924.pdf" target="_blank">Compute trends across three eras of machine learning</a>, Sevilla: An analysis of the compute needs over time on a logarithmic scale. There have been sharp increases in compute needs since the focus on deep learning started in ~2010 and the large model ear started in ~2016.</figcaption></figure><p>‍</p><p>‍</p><p>So how is compute fragmentation holding AI back? With traditional CPUs not scaling to meet the need for more compute, the only way forward has been to create parallel and domain-specific hardware that is less general, but that does a few AI-related things really well — like graphics processing units (<a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPUs</a>), tensor processing units (<a href="https://en.wikipedia.org/wiki/Tensor_Processing_Unit">TPUs</a>), and other application-specific integrated circuits (<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASICs</a>). While these innovations have helped push the industry forward, enabling greater scale and more power-efficient processors in edge devices, <strong>the increased diversity of hardware has fragmented the industry</strong> and left AI developers struggling to:</p><ol role="list"><li>Develop software that fully leverages the hardware’s capabilities and composes with others.</li><li>Express parallel software algorithms on any one device.</li><li>Scale that software across an ecosystem of many devices or even to heterogeneous systems.</li></ol><p>Modular is focused on rebuilding the world’s AI infrastructure from the ground up. In this blog series, we’ll talk about how we are taking a fresh approach to solving the industry’s compute fragmentation problem. We will motivate the low-level challenges of building a truly unified solution by focusing on a single operation, <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">matrix multiplication</a> (“matmul”), a critical calculation in machine learning algorithms. To understand why it is hard, though, we will look under the hood of matmul and get into some of the nitty-gritty details of how it works. Don’t say you weren’t warned - this post is about to go deep!</p></div></div></div><div><div><div><h2><strong>Matrix multiplication, and why it is so hard</strong></h2><p><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">Matrices</a> are critical to machine learning systems as a simple way to represent data efficiently — such as input data (e.g., sets of pixels in an image) or the internal workings between the model layers. As a result, multiplying these matrices together makes up a large portion of the total computations in deep learning models. In fact, matmuls make up roughly 45-60% of the total runtime of many popular transformer models like <a href="https://huggingface.co/docs/transformers/model_doc/bert">BERT</a>, <a href="https://huggingface.co/docs/transformers/v4.27.2/en/model_doc/clip#overview">CLIP</a>, and even <a href="https://openai.com/blog/chatgpt">ChatGPT</a>, is a popular approach to computing the <a href="https://www.notion.so/Edge-Deployment-Challenges-fe4043b335e24af8807a6a14375f4fe0">convolution</a> operation that forms the foundation of most computer vision models, and makes up the backbone of many <a href="https://en.wikipedia.org/wiki/High-performance_computing">high-performance computing</a> (”HPC”) applications.</p><p>Given its importance, there has been extensive research on writing efficient matmul algorithms. Papers from the <a href="https://ieeexplore.ieee.org/abstract/document/1687427">60s</a>, <a href="https://apps.dtic.mil/sti/pdfs/AD0705509.pdf">70s</a>, <a href="https://dl.acm.org/doi/10.1145/356012.356020">80s</a>, <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.9411&amp;rep=rep1&amp;type=pdf">90s</a>, <a href="https://netlib.org/lapack/lawnspdf/lawn147.pdf">2000s</a>, to the present day exist that try to solve the problem with the hardware of that era.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c802e9e5ddb1a1e143218_Screen%20Shot%202023-03-23%20at%2010.36.46%20AM.png" loading="lazy" alt=""/></p><figcaption>The simple O(n^3) matrix multiplication algorithm.</figcaption></figure><p>‍</p><p>‍</p><p>But the conceptual matmul algorithm isn’t what makes it difficult. Instead, <strong>the challenge is writing a matmul fast enough to achieve state-of-the-art performance across all the hardware, model, and data diversity in the AI industry.  It is even harder to make it compose with all other AI operators.</strong></p><h3>Hardware</h3><p>Each device used to run AI models has different characteristics, including different <a href="https://en.wikipedia.org/wiki/Memory_hierarchy">memory hierarchies</a> and different <a href="https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation">multiply and accumulate units</a> (MAC).</p><p>For example, CPUs employ a hierarchy of memory from slow <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> to increasingly faster <a href="https://en.wikipedia.org/wiki/CPU_cache">caches</a> — Level-3, Level-2, Level-1, and CPU <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>. The size of the memory is inversely proportional to its speed — for example, L1 cache access is typically on the order of single nanoseconds, whereas RAM access is on the order of 100 nanoseconds. To get the highest performance matmul, the algorithm itself has to be implemented to efficiently work with the different memory levels and sizes. Raw matrices are too big to fit into the registers or the fastest memory cache at one time, so the challenge is determining how to decompose them into the right sized blocks or “tiles” that maximize usage of the fastest memory.</p><p>Moreover, the actual shapes of the units that handle the core matrix functionality differ across hardware. CPUs have traditionally been scalar machines, meaning they process <a href="https://en.wikipedia.org/wiki/Machine_code">instructions</a> one step at a time, but all CPU vendors have added vector units (<a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a>) over the last two decades. GPUs execute <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_threads">single operations across multiple threads</a> (SIMT) to maximize the efficiency of highly parallel, repetitive operations like matmuls. And more specialized hardware takes this further by operating on 2D matrices. <a href="https://cloud.google.com/tpu/docs/system-architecture-tpu-vm">Google TPUs</a> are the most well-known, but Apple and <a href="https://en.wikipedia.org/wiki/Advanced_Matrix_Extensions">Intel</a> have added their own matrix multiplication features called AMX. But while more advanced MAC units have led to improved performance, they have also created a greater need for flexible algorithms that work across scalar, vector, and matrix processors.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c7be50d519e0d191f72db_Untitled%20(4).png" loading="lazy" alt=""/></p><figcaption><a href="https://cloud.google.com/blog/products/ai-machine-learning/an-in-depth-look-at-googles-first-tensor-processing-unit-tpu" target="_blank">An in-depth look at Google’s first Tensor Processing Unit</a>: Various multiply and accumulate (MAC) unit shapes.</figcaption></figure><p>‍</p><h3>Models</h3><p>AI models are also quite diverse. While matmuls form the foundation of many models, the matrix sizes used in those matmuls can vary significantly. For example, models have different input shapes (like varying sequence lengths), different internal shapes (i.e., the matrices that are being multiplied together as part of the hidden layers of the model), and even different batch sizes (critical for training and inference efficiencies). As a result, matmuls come in <em>hundreds</em> of different shapes in production, which makes decomposing them into blocks that maximize memory efficiency challenging.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c7c04336d040d0a07c929_Untitled%20(5).png" loading="lazy" alt=""/></p><figcaption><a href="http://jalammar.github.io/illustrated-transformer/" target="_blank">The Illustrated Transformer</a>, Jay Alammar: All the various matrix sizes involved in multi-headed attention blocks, a key building block of transformer models like BERT, GPT2, and CLIP.</figcaption></figure><p>‍</p><h3>Data</h3><p>Lastly, your data can also be diverse. Most readers will be familiar with data diversity in terms of structured and unstructured data, but in this case, we are more concerned with data type (”dtype”). Data in AI models is usually of dtype <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">FP32</a>, but the industry is also adopting lower precision data types like <a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format">Bfloat16</a>, <a href="https://en.wikipedia.org/wiki/8-bit_computing">Int8</a>, and the more exotic FP4 and Int4, to reduce model size and improve performance. Matmul algorithms, then, need to be able to operate on data of many different precisions, depending on the use case.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c7c3891bc840872ea96e4_Screen%20Shot%202023-03-22%20at%2010.27.09%20PM.png" loading="lazy" alt=""/></p><figcaption><a href="https://www.qualcomm.com/news/onq/2019/03/heres-why-quantization-matters-ai" target="_blank">Here’s why quantization matters for AI</a>: Quantizing a FP32 matrix to be Int8.</figcaption></figure></div></div></div><div><div><div><h2><strong>Current state-of-the-art</strong></h2><p>So how are today’s most state-of-the-art matmul algorithms actually implemented? Given its importance, matmul is usually one of the first algorithms that hardware vendors optimize, with many providing implementations through their libraries. Intel provides the <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html">MKL</a> and <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onednn.html#gs.qo4igp">OneDNN</a> libraries, AMD provides <a href="https://www.amd.com/en/developer/aocl.html">AOCL</a> and <a href="https://github.com/ROCmSoftwarePlatform/rocBLAS">RocBLAS</a>, ARM has <a href="https://www.notion.so/Kernel-Blog-Post-5443901d37c7423eb4ab7c441dd41e81">performance libraries</a>, Apple has <a href="https://developer.apple.com/accelerate/">Accelerate</a>, and Nvidia provides <a href="https://docs.nvidia.com/cuda/cublas/">CUBLAS</a>.</p><p>Across the hardware libraries mentioned above, the current state of the art in terms of efficient implementation is to effectively write <a href="https://en.wikipedia.org/wiki/Assembly_language#:~:text=In%20computer%20programming%2C%20assembly%20language,and%20the%20architecture&#39;s%20machine%20code">assembly code</a>: this means micro-managing the hardware by giving it direct instructions at the lowest level that it understands without abstractions.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c806874020f39201ee2a1_Screen%20Shot%202023-03-23%20at%2010.37.39%20AM.png" loading="lazy" alt=""/></p><figcaption>A matmul algorithm written in x86 assembly which targets AVX512</figcaption></figure><p>‍</p><p>‍</p><p><strong>The main reason for this? </strong>Writing assembly produces the best performance for any one specific use-case because developers who are writing assembly can avoid the unpredictability of compilers, which translate higher-level languages like Python &amp; C++ down to assembly, and can perform optimizations that are hard for the compiler to do because compilers must generalize. Importantly, they can leverage instructions and patterns that the compiler is unaware of because extending the compiler to support new hardware features takes time.</p></div></div></div><div><div><div><h2><strong>Hand-written assembly kernels don’t scale!</strong></h2><p>But does this actually solve the fragmentation issue for users? While writing in assembly maximizes performance for any individual example, it’s not portable, doesn’t compose, doesn’t scale, and isn’t user-friendly. Think about it: how can a small number of specialized experts, who hand write and tune assembly code, possibly scale their work to all the different configurations while also incorporating their work into all the AI frameworks?! It’s simply an impossible task.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets.website-files.com/62a8b4a3467401a65a14d263/641c7caeecb40db2dd7164c2_Untitled%20(6).png" loading="lazy" alt=""/></p><figcaption><a href="https://huyenchip.com/2021/09/07/a-friendly-introduction-to-machine-learning-compilers-and-optimizers.html" target="_blank">A friendly introduction to machine learning compilers optimizers</a>, Chip Huyen: the increasing number of combinations of framework and hardware support.</figcaption></figure><p>‍</p><h3>Portability</h3><p>Because assembly is written with a hardware-specific interface called an <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">instruction set architecture</a> (ISA) it is not portable across different hardware platforms. In fact, assembly can’t even deliver the best performance across multiple generations of chips from the same vendor!</p><p>Further, even if you have target hardware in mind when developing your model, there are still two big practical problems:</p><ol role="list"><li>In the cloud, you don’t have control over the specific hardware it runs on. “But I’ve selected an instance that’s perfect for my model” you say. The truth is that instance types on some cloud providers like AWS don’t guarantee a specific CPU type. For example, if you select a <a href="https://aws.amazon.com/ec2/instance-types/c5/">c5.4xlarge</a> instance, you could get an older generation Intel SkyLake processor or a newer Cascade Lake processor. Assembly cannot adapt and give you the best performance for the specific chip your code runs on.</li><li>Your product will continue to evolve rapidly, and you may want to move to a different hardware architecture altogether. Auguring in on one specific configuration will limit your flexibility to adapt as your model requirements change or when a new generation of hardware comes out.</li></ol><h3>Scalability and composability</h3><p>As we discussed earlier, there are many AI models, leading to hundreds of different matmul shapes. Using assembly-based libraries means selecting specific processor instructions that hardcode parameters like memory tiling sizes. These hard-coded assembly libraries can be tuned well for a specific tensor shape but require a different implementation for others. As a result, many existing kernel libraries swell to be gigabytes in size (e.g., MKL is 3.2GB and cuDNN can be up to 2.5GB). This becomes a problem when the size of these libraries impacts container build times, if you deploy to the edge where this is impractical, or if you want to deploy new innovations and research that these vendors haven’t manually specialized yet.</p><p>Looking at the bigger picture, high-performance matmuls are indeed important for performance. But to get the best results, matmuls can be executed together with other operations such as elementwise, strided accesses, broadcasts, etc. <a href="https://learn.microsoft.com/en-us/windows/ai/directml/dml-fused-activations">Operator fusion</a> provides significant performance improvements by reducing memory traffic - but the challenge is that there are thousands of AI operators. Furthermore, models use many permutations of different operations in combination, and (while some have tried!) it isn’t practical to hand-fuse all the important combinations, particularly when research is driving AI forward so fast.</p><h3>User-friendliness</h3><p>And finally, writing assembly is not user-friendly or good for cross-organization productivity. Assembly programming has limited features available in modern programming languages like parameterization and object-oriented programming and does not provide great tooling for debugging, code coverage, testing, etc. While the reality is that most researchers looking to write new operations are most comfortable in Python, it has <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">well-known performance issues</a>, so organizations end up having to hire expensive specialists to bridge the gap.</p></div></div></div><div><div><div><h2><strong>Stay tuned</strong></h2><p><strong>For AI to reach its true potential, compute fragmentation needs to be solved. AI software developers need to be able to seamlessly take full advantage of existing hardware and the next generation of hardware innovations when they become available</strong>. But as you can see, solving this problem is not easy. Diversity in hardware, models, and data means that every existing solution on the market is only just a “point solution” to a much broader problem.</p><p>Modular is solving this problem - stay tuned for part 2 of the blog, in which we outline our approach and show the revolutionary benefits. And if you are excited about solving some of the most challenging and complex problems, go to <a href="http://modular.com">modular.com</a> and apply!</p></div></div></div></article></section></div></div>
  </body>
</html>
