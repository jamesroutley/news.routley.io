<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/">Original</a>
    <h1>DXGI debugging: Microsoft put me on a list</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
	
	<article id="main-article">
		
		<p><time datetime="2025-09-21T14:25:00+0000">
				Sunday September 21, 2025
			</time>
		</p>

		<p>Why does Space Station 14 crash with ANGLE on ARM64? 6 hours later‚Ä¶</p>
<p>So. I‚Äôve been continuing work on getting ARM64 builds out for Space Station 14. The thing I was working on yesterday were launcher builds, specifically a <em>single</em> download that supports both ARM64 and x64. I‚Äôd already gotten the game client itself running natively on ARM64, and it worked perfectly fine in my dev environment. I wrote all the new launcher code, am pretty sure I got it right. Zip it up, test it on ARM64, aaand‚Ä¶</p>
<p>The game client crashes on Windows ARM64. Both in my VM and on Julian‚Äôs real Snapdragon X laptop.</p>
<h2 id="debugging-logs">
	<a href="#debugging-logs">
		Debugging: logs
	</a>
</h2><p>The client logs are empty. They suspiciously cut out right after SDL is initialized.</p>
<p>Of course it isn‚Äôt that easy.</p>
<h2 id="debugging-pulling-windbg-out-of-the-shed">
	<a href="#debugging-pulling-windbg-out-of-the-shed">
		Debugging: pulling WinDbg out of the shed
	</a>
</h2><p>Given that there‚Äôs no logs, this has to be a native crash. That means it‚Äôs WinDbg time.</p>
<p><picture>
	<source srcset="windbg.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg.webp" width="2940" height="1914" alt="Screenshot of WinDbg, running in a VM"/>
</picture>
</p>
<p>So at first I decided to start <code>Space Station 14 Launcher.exe</code> directly through WinDbg. This is annoying because I have to go into child processes (with <code>.childdbg 1</code>) twice, and for some reason there‚Äôs a lot of waiting, but it does work‚Ä¶</p>
<p>The game crashes in <code>USER32!GetDC</code> on an <em>illegal instruction</em>, somewhere after SDL does <em>something</em>. I barely glanced at the disassembly but it made no sense to me, so I just assumed there‚Äôs some UB happening and didn‚Äôt think much of it. After all, <em>why would the implementation of <code>GetDC()</code> have broken assembly?</em></p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>(3148.35e4): Illegal instruction - code c000001d (first chance)
</span></span><span><span>(3148.35e4): Unknown exception - code c000041d (!!! second chance !!!)
</span></span><span><span>*** WARNING: Unable to verify checksum for C:\Users\Luna\Downloads\SS14.Launcher_Windows\bin_arm64\loader\SDL3.DLL
</span></span><span><span>USER32!GetDC+0x8:
</span></span><span><span>00007ff9`f7be9548 ee8e1db0 ???
</span></span></code></pre></div><p><picture>
	<source srcset="windbg_stack_1.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_1.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_1.webp" width="612" height="268" alt="WinDbg stack trace view ending in USER32!GetDC"/>
</picture>
</p>
<p><picture>
	<source srcset="windbg_disasm_1.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_disasm_1.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_disasm_1.webp" width="559" height="121" alt="WinDbg disassembly for USER32!GetDC"/>
</picture>
</p>
<p>WinDbg was also unable to pull stack frames from C# code. It did, thankfully, clearly communicate <em>why</em> this was. Yep, it‚Äôs our friend¬†<a href="https://slugcat.systems/post/24-11-20-why-should-you-download-more-ram/"><code>mscordaccore</code></a> again!</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>CLRDLL: Consider using &#34;.cordll -lp &lt;path&gt;&#34; command to specify .NET runtime directory.
</span></span><span><span>CLRDLL: Consider using &#34;.cordll -lp &lt;path&gt;&#34; command to specify .NET runtime directory.
</span></span></code></pre></div><p>However, my attempts to actually follow said instructions were completely fruitless, giving this error:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>0:027:ARM64EC&gt; .cordll -lp C:\Users\Luna\Downloads\SS14.Launcher_Windows\dotnet_arm64\shared\Microsoft.NETCore.App\9.0.9
</span></span><span><span>CLRDLL: Consider using &#34;.cordll -lp &lt;path&gt;&#34; command to specify .NET runtime directory.
</span></span><span><span>CLR DLL status: ERROR: Unable to load DLL C:\Users\Luna\Downloads\SS14.Launcher_Windows\dotnet_arm64\shared\Microsoft.NETCore.App\9.0.9\mscordaccore_AMD64_arm64_9.0.925.41916.dll, Win32 error 0n87
</span></span></code></pre></div><p>Why is it trying to run an <code>AMD64</code> binary? Wait is WinDbg not natively compiled for ARM64? <em>Sigh</em>. Let‚Äôs just do it without C# debugging, I can probably manage based off the SDL stack trace. So I pull <a href="https://moon.spacestation14.com/natives/SDL3/3.2.20/win-arm64/"><code>SDL3.pdb</code> from our server</a>, drop it next to <code>SDL3.dll</code>, and then use the UI to reload the symbols. And that gets us a bit further, we now have proper function names for SDL3!</p>
<p><picture>
	<source srcset="windbg_stack_2.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_2.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_2.webp" width="627" height="278" alt="WinDbg stack trace view, now with function names starting from SDL_ShowWindow_REAL"/>
</picture>
</p>
<p>So I double click one of the entries in the UI‚Äôs stack trace view. And the entire debugger breaks. Stack trace view goes empty. Every action I try to make causes more of these errors to be printed:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>Machine is not a possible execution machine
</span></span><span><span>Unable to get current machine context, HRESULT 0x8000FFFF
</span></span><span><span>Machine is not a possible execution machine
</span></span><span><span>Unable to get current machine context, HRESULT 0x8000FFFF
</span></span><span><span>Machine is not a possible execution machine
</span></span><span><span>Unable to get current machine context, HRESULT 0x8000FFFF
</span></span><span><span>Machine is not a possible execution machine
</span></span><span><span>Machine is not a possible execution machine
</span></span></code></pre></div><p>Now even WinDbg is broken??</p>
<p>Googling these errors gave nothing useful. One of them gave <em>not a single result</em>. After just pondering the error for a moment, I thought ‚Äúwait, why is the command prompt still saying <code>ARM64EC&gt;</code>? ARM64EC is for emulation, but the active debugger processes (<code>SS14.Launcher.exe</code> and <code>SS14.Loader.exe</code>) are both native ARM64.</p>
<p>Turns out that it‚Äôs because I started <code>Space Station 14 Launcher.exe</code> directly. You see, that executable is x64 native, and its only job is to set up the .NET environment and launch the <em>actual</em> ARM64 executable. Something about <em>starting</em> the debugging session with that program causes WinDbg to get extremely confused when later looking at the child processes it spawns.</p>
<p>From this point on I just started launching <code>SS14.Launcher.exe</code> directly<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. This means I wasn‚Äôt setting up the same <code>DOTNET_ROOT</code> (because WinDbg can‚Äôt set environment variables when launching things‚Ä¶ yes really), but this didn‚Äôt really matter. This fixed both the ‚ÄúMachine is not a possible execution machine‚Äù errors <em>and</em> the issues with showing C# stack traces. I guess WinDbg is compiled for ARM64 after all, and it just decided to run an x64 debug host when you start debugging an x64 application. Fair enough I guess?</p>
<h2 id="debugging-whats-sdl-doing">
	<a href="#debugging-whats-sdl-doing">
		Debugging: what‚Äôs SDL doing?
	</a>
</h2><p>After figuring out all of the above, we could <em>really</em> get started. I also opted to swap out <code>SDL3.dll</code> with a locally-built copy, so that the debugger could locate source files<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. What SDL is doing is pretty straight forward: the first time the window is shown, it clears the background with GDI commands:</p>
<p><picture>
	<source srcset="sdl_code.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/sdl_code.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/sdl_code.webp" width="715" height="568" alt="SDL source code shown in WinDbg. The line that calls GetDC() is highlighted."/>
</picture>
</p>
<p>I mean‚Ä¶ this is like, fine, right? I mean I don‚Äôt know much about this code, but why would this crash on ARM but not x64??? The window is valid. <code>GetDC()</code> is an extremely fundamental Win32 function call. If there was something broken with it, my OS would not be usable. What the fuck is going on?</p>
<p>The <code>if (ShouldClearWindowOnEraseBackground(data))</code> allows it to be disabled via a hint, which can be specified by environment variable. This fixes the crash‚Ä¶ until you open a second OS window, then SDL3 calls <code>GetDC()</code> once again and <em>that</em> crashes. Not a solution.</p>
<p>So I checked the actual <code>USER32!GetDC</code> again, and this time I actually paid attention to the disassembly code instead of glossing over it. What the fuck? <code>pacibsp</code> is missing at the start. It‚Äôs loading an address for a jump that only jumps to <em>the next instruction</em>, which is <em>invalid</em>. In some runs, said instruction was instead a broken <code>x26</code>-relative <code>str</code> instruction that AV‚Äôd because the register was all zeroes.</p>
<p>At this point let‚Äôs introduce the villain. You might have noticed it in the call stack: <code>DXGI!My_GetDC</code>.</p>
<figure><img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_disasm_2.webp" alt="WinDbg disassembly for DXGI!MyDC. The word &amp;quot;Detour&amp;quot; is clearly visible"/><figcaption>
      <p>Microsoft is detouring their <em>own code???</em></p>
    </figcaption>
</figure>

<p>For those who aren‚Äôt well-versed in DirectX stuff: <em>DXGI</em> is a fundamental part of DirectX ever since DirectX 10 (Vista). For those who have never modded a game before: a <em>detour</em> is a hack that injects instructions into other functions at runtime, to do evil shit. Why the <em>hell</em> is Microsoft using this in DXGI?</p>
<h2 id="debugging-dxgi-despair">
	<a href="#debugging-dxgi-despair">
		Debugging: DXGI despair
	</a>
</h2><p>Through the debugging adventure, I ended up putting a breakpoint on every call to <code>USER32!GetDC</code>. The first few calls are fine, but then the <em>last</em> one, the one that crashes, is not.</p>
<p>At this point I got really desperate. ‚ÄúAsking in low-level programming Discords‚Äù-level desperate. I ended up asking for help in the <a href="https://discord.gg/directx">DirectX Discord</a> (yes, there‚Äôs an official DirectX Discord, and there‚Äôs many MS employees in there).</p>
<section aria-label="Thought" aria-role="Thought">
<p>I would like to thank Jesse Natalia from the DirectX Discord for responding swiftly to my messages in there.</p>
</section>
<p>After some back and forth there, I wanted to catch DXGI in the act. Maybe that would tell me something, I don‚Äôt know. So with a simple <code>ba w4 USER32!GetDC</code>, I put a hardware breakpoint for whenever something would <em>write</em> to <code>USER32!GetDC</code>. I did have to awkwardly ‚Äúrun the program for just a little bit‚Äù because <code>USER32.dll</code> isn‚Äôt loaded immediately at program startup.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<section aria-label="Thought" aria-role="Thought">
<p>While writing this blog post I realized there <em>is</em> an intelligent way to do this. It‚Äôs called <code>sxe ld USER32.dll</code>. I‚Äôve literally written about it <a href="https://slugcat.systems/post/25-03-18-virtual-reality-projection-shenanigans/"><em>in this blog before</em></a>. Oops.</p>
</section>
<p><picture>
	<source srcset="windbg_stack_3.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_3.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_3.webp" width="627" height="537" alt="WinDbg stack trace, starting at SDL3!SDL_CreateWindowWithProperties and ending at DXGI!DetourTransactionCommitEx"/>
</picture>
</p>
<p>Now this is very interesting. The bottom of the stack trace is quite expected: SDL creates a window, uses ANGLE‚Äôs EGL implementation for this, that does a bunch of stuff, and eventually creates a DXGI swapchain. But then what is <code>UpgradeSwapEffect</code>? And why is it installing a detour?</p>
<p>Ah, I already know what this is.</p>
<p><picture>
	<source srcset="discord.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/discord.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/discord.webp" width="1408" height="492" alt="Discord conversation between me (PJB) and Jesse Natalie: ‚Äú‚Ä¶upgrade swap effect‚Ä¶?‚Äù ‚ÄúAh, ok I can see why that would need a detour I guess. Been out of the DXGI code for too long‚Äù ‚Äúis this related to whatever the thing in windows 11 is that forces flip model on software (ANGLE [‚Ä¶] create flip model swap chains when using its own swap chain management)‚Äù ‚ÄúYes‚Äù"/>
</picture>
</p>
<h2 id="optimizing-windowed-games-flip-model">
	<a href="#optimizing-windowed-games-flip-model">
		Optimizing windowed games: flip model
	</a>
</h2><p>Right. So. DirectX.</p>
<p>When you create a DirectX swapchain, you specify an ‚Äú<a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/ne-dxgi-dxgi_swap_effect">effect</a>‚Äù, which falls into two categories: ‚Äúbitblt‚Äù and ‚Äúflip‚Äù. To make a <a href="https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/for-best-performance--use-dxgi-flip-model#a-brief-history">long story short</a>: bitblt is the ‚Äúoriginal‚Äù one, while flip is the much more modern one added in Windows 8<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. It‚Äôs more efficient and performant, and all software should be using it. Furthermore, on modern versions of Windows and with a GPU supporting ‚Äú<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/display/multiplane-overlay-support">Multiplane Overlays</a>‚Äù, flip model actually enables windowed games to be displayed with <em>zero additional latency</em> over ‚Äúexclusive‚Äù fullscreen mode.¬†</p>
<p>Of course, many games never get updated, or they‚Äôre stuck on an ancient version. And many of these games don‚Äôt care. So in Windows 11, Microsoft added ‚Äú<a href="https://support.microsoft.com/en-us/windows/optimizations-for-windowed-games-in-windows-11-3f006843-2c7e-4ed0-9a5e-f9389e535952">Optimizations for windowed games</a>‚Äù, which forcibly enables flip model on games that are still using bitblt. Why does DXGI need to install detours for this? Probably some compatibility shit with the bitblt model. I don‚Äôt have any deep knowledge of how Win32 GDI stuff works, but it‚Äôs not hard for me to imagine there‚Äôs some interplay here they need to take care of. I can also confirm that <em>disabling</em> the feature in Windows‚Äô settings menu fixes the crash!</p>
<p>If you‚Äôre wondering why SS14 isn‚Äôt using flip model: it‚Äôs because we can‚Äôt. We‚Äôre not creating the swapchain directly, <em>ANGLE</em> is. And ANGLE is continuing to use <code>SWAP_EFFECT_SEQUENTIAL</code>. I actually once <a href="https://github.com/space-wizards/RobustToolbox/blob/ac3cb4dc2abe970e611b944b252504e602303dfe/Robust.Client/Graphics/Clyde/GLContext/GLContextAngle.cs">experimented with SS14 managing the swapchain</a>, but this ran into some ANGLE limitations and I never got around to ironing out all the edge cases and crashes. I‚Äôd rather just spend the brain power on ditching OpenGL, rather than trying to continue working with this broken API.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p>
<p>So here we are. The entire debugging story so far, you‚Äôre like, ‚Äúsurely Microsoft didn‚Äôt break DXGI on ARM64, huh???‚Äù But now it‚Äôs becoming plausible. There‚Äôs barely any native ARM64 Windows games, and surely none that are using bitblt swapchains. And guess what, you don‚Äôt even <em>need</em> <code>GetDC()</code> for modern DirectX games. SDL does it because it‚Äôs heavily designed for OpenGL. Most games run in x64 emulation, and that presumably works fine. Everything adds up to it being possible this just genuinely fell under the radar at Microsoft.</p>
<p>This should be pretty easy to verify in a minimal example. I cloned an <a href="https://github.com/microsoft/DirectX-SDK-Samples/blob/main/C%2B%2B/Direct3D11/Tutorials/Tutorial01/Tutorial01.cpp">old DirectX SDK sample</a>, updated it to be compiled for ARM64, added some <code>GetDC()</code> calls, aaand‚Ä¶ nope, no crash. Then I spent quite a while <em>trying various stuff</em>: comparing the swapchain creation code with that of ANGLE, changing various parameters, verifying whether the detour was being installed (it wasn‚Äôt). But eventually, I did find it.</p>
<p>It‚Äôs the filename.</p>
<p>Of course it‚Äôs the goddamn filename.</p>
<h2 id="im-on-a-list">
	<a href="#im-on-a-list">
		I‚Äôm on a list
	</a>
</h2><p><strong>It only happens when the program is called <code>SS14.Loader.exe</code>.</strong></p>
<p>The final piece of the puzzle. It didn‚Äôt happen in a dev environment because then the exe isn‚Äôt named <code>SS14.Loader.exe</code>. Microsoft only enables ‚ÄúOptimizations for windowed games‚Äù on a specific list of games. And guess what, <em>none</em> of those select games are on ARM64, at least until I was unfortunate enough to port mine. How did we get on the list? Who knows.</p>
<p>Microsoft put me on a list, that ships with every Windows install. And this list actually broke my game. Achievement unlocked!</p>
<h2 id="addendum-why-angle-and-about-opengl-on-windows-arm64">
	<a href="#addendum-why-angle-and-about-opengl-on-windows-arm64">
		Addendum: why ANGLE, and about OpenGL on Windows ARM64
	</a>
</h2><p>Traditionally, OpenGL on Windows has been implemented by the 3 IHVs (Nvidia, AMD, Intel). If they didn‚Äôt explicitly go out of their way to add it to their drivers, you‚Äôd have no OpenGL beyond 1.0. Those new Snapdragon X devices, however, use Microsoft‚Äôs new-ish ‚ÄúOpenGL on D3D12‚Äù driver. It‚Äôs actually part of Mesa!</p>
<p>The problem with Space Station 14 is that said driver is broken for us, causing severe graphical artifacts and flickering. I had been aware of this for years, because the same driver is used for the GPU acceleration of WSL2, but I never bothered to report it üò¨. So for the purpose of porting SS14 to ARM64 Windows, I decided to just immediately force on ANGLE on Qualcomm devices, and call it a day.</p>
<p>What I didn‚Äôt know until yesterday is that the OpenGL on D3D12 driver does not ship with Qualcomm‚Äôs drivers! <a href="https://apps.microsoft.com/detail/9nqpsl29bfff?hl=en-US&amp;gl=US">It‚Äôs on the Microsoft store!</a> I can even install it in my VM and get it to emulate OpenGL on top of DirectX‚Äôs software renderer (WARP), just like I had been doing with ANGLE. I‚Äôve finally bothered to <a href="https://gitlab.freedesktop.org/mesa/mesa/-/issues/13936">report the graphical issues</a>, so hopefully it gets fixed eventually. If it does get fixed, Microsoft Store distribution means it shouldn‚Äôt take too long to trickle down to users, and then we can stop enforcing ANGLE on Qualcomm devices.</p>
<p>For Space Station 14, I will say that this means I‚Äôll be postponing official Windows ARM64 support <em>for now</em>. At least until either bug (OpenGL on D3D12 <em>or</em> ARM64 DXGI detours) are fixed. Or when I finally rewrite the renderer to drop OpenGL, that‚Äôs also an option.</p>

	</article>

	</div></div>
  </body>
</html>
