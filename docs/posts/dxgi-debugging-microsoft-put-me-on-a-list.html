<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/">Original</a>
    <h1>DXGI debugging: Microsoft put me on a list</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
	
	<article id="main-article">
		
		<p><time datetime="2025-09-21T14:25:00+0000">
				Sunday September 21, 2025
			</time>
		</p>

		<p>Why does Space Station 14 crash with ANGLE on ARM64? 6 hours later…</p>
<p>So. I’ve been continuing work on getting ARM64 builds out for Space Station 14. The thing I was working on yesterday were launcher builds, specifically a <em>single</em> download that supports both ARM64 and x64. I’d already gotten the game client itself running natively on ARM64, and it worked perfectly fine in my dev environment. I wrote all the new launcher code, am pretty sure I got it right. Zip it up, test it on ARM64, aaand…</p>
<p>The game client crashes on Windows ARM64. Both in my VM and on Julian’s real Snapdragon X laptop.</p>
<h2 id="debugging-logs">
	<a href="#debugging-logs">
		Debugging: logs
	</a>
</h2><p>The client logs are empty. They suspiciously cut out right after SDL is initialized.</p>
<p>Of course it isn’t that easy.</p>
<h2 id="debugging-pulling-windbg-out-of-the-shed">
	<a href="#debugging-pulling-windbg-out-of-the-shed">
		Debugging: pulling WinDbg out of the shed
	</a>
</h2><p>Given that there’s no logs, this has to be a native crash. That means it’s WinDbg time.</p>
<p><picture>
	<source srcset="windbg.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg.webp" width="2940" height="1914" alt="Screenshot of WinDbg, running in a VM"/>
</picture>
</p>
<p>So at first I decided to start <code>Space Station 14 Launcher.exe</code> directly through WinDbg. This is annoying because I have to go into child processes (with <code>.childdbg 1</code>) twice, and for some reason there’s a lot of waiting, but it does work…</p>
<p>The game crashes in <code>USER32!GetDC</code> on an <em>illegal instruction</em>, somewhere after SDL does <em>something</em>. I barely glanced at the disassembly but it made no sense to me, so I just assumed there’s some UB happening and didn’t think much of it. After all, <em>why would the implementation of <code>GetDC()</code> have broken assembly?</em></p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>(3148.35e4): Illegal instruction - code c000001d (first chance)
</span></span><span><span>(3148.35e4): Unknown exception - code c000041d (!!! second chance !!!)
</span></span><span><span>*** WARNING: Unable to verify checksum for C:\Users\Luna\Downloads\SS14.Launcher_Windows\bin_arm64\loader\SDL3.DLL
</span></span><span><span>USER32!GetDC+0x8:
</span></span><span><span>00007ff9`f7be9548 ee8e1db0 ???
</span></span></code></pre></div><p><picture>
	<source srcset="windbg_stack_1.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_1.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_1.webp" width="612" height="268" alt="WinDbg stack trace view ending in USER32!GetDC"/>
</picture>
</p>
<p><picture>
	<source srcset="windbg_disasm_1.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_disasm_1.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_disasm_1.webp" width="559" height="121" alt="WinDbg disassembly for USER32!GetDC"/>
</picture>
</p>
<p>WinDbg was also unable to pull stack frames from C# code. It did, thankfully, clearly communicate <em>why</em> this was. Yep, it’s our friend <a href="https://slugcat.systems/post/24-11-20-why-should-you-download-more-ram/"><code>mscordaccore</code></a> again!</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>CLRDLL: Consider using &#34;.cordll -lp &lt;path&gt;&#34; command to specify .NET runtime directory.
</span></span><span><span>CLRDLL: Consider using &#34;.cordll -lp &lt;path&gt;&#34; command to specify .NET runtime directory.
</span></span></code></pre></div><p>However, my attempts to actually follow said instructions were completely fruitless, giving this error:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>0:027:ARM64EC&gt; .cordll -lp C:\Users\Luna\Downloads\SS14.Launcher_Windows\dotnet_arm64\shared\Microsoft.NETCore.App\9.0.9
</span></span><span><span>CLRDLL: Consider using &#34;.cordll -lp &lt;path&gt;&#34; command to specify .NET runtime directory.
</span></span><span><span>CLR DLL status: ERROR: Unable to load DLL C:\Users\Luna\Downloads\SS14.Launcher_Windows\dotnet_arm64\shared\Microsoft.NETCore.App\9.0.9\mscordaccore_AMD64_arm64_9.0.925.41916.dll, Win32 error 0n87
</span></span></code></pre></div><p>Why is it trying to run an <code>AMD64</code> binary? Wait is WinDbg not natively compiled for ARM64? <em>Sigh</em>. Let’s just do it without C# debugging, I can probably manage based off the SDL stack trace. So I pull <a href="https://moon.spacestation14.com/natives/SDL3/3.2.20/win-arm64/"><code>SDL3.pdb</code> from our server</a>, drop it next to <code>SDL3.dll</code>, and then use the UI to reload the symbols. And that gets us a bit further, we now have proper function names for SDL3!</p>
<p><picture>
	<source srcset="windbg_stack_2.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_2.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_2.webp" width="627" height="278" alt="WinDbg stack trace view, now with function names starting from SDL_ShowWindow_REAL"/>
</picture>
</p>
<p>So I double click one of the entries in the UI’s stack trace view. And the entire debugger breaks. Stack trace view goes empty. Every action I try to make causes more of these errors to be printed:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>Machine is not a possible execution machine
</span></span><span><span>Unable to get current machine context, HRESULT 0x8000FFFF
</span></span><span><span>Machine is not a possible execution machine
</span></span><span><span>Unable to get current machine context, HRESULT 0x8000FFFF
</span></span><span><span>Machine is not a possible execution machine
</span></span><span><span>Unable to get current machine context, HRESULT 0x8000FFFF
</span></span><span><span>Machine is not a possible execution machine
</span></span><span><span>Machine is not a possible execution machine
</span></span></code></pre></div><p>Now even WinDbg is broken??</p>
<p>Googling these errors gave nothing useful. One of them gave <em>not a single result</em>. After just pondering the error for a moment, I thought “wait, why is the command prompt still saying <code>ARM64EC&gt;</code>? ARM64EC is for emulation, but the active debugger processes (<code>SS14.Launcher.exe</code> and <code>SS14.Loader.exe</code>) are both native ARM64.</p>
<p>Turns out that it’s because I started <code>Space Station 14 Launcher.exe</code> directly. You see, that executable is x64 native, and its only job is to set up the .NET environment and launch the <em>actual</em> ARM64 executable. Something about <em>starting</em> the debugging session with that program causes WinDbg to get extremely confused when later looking at the child processes it spawns.</p>
<p>From this point on I just started launching <code>SS14.Launcher.exe</code> directly<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. This means I wasn’t setting up the same <code>DOTNET_ROOT</code> (because WinDbg can’t set environment variables when launching things… yes really), but this didn’t really matter. This fixed both the “Machine is not a possible execution machine” errors <em>and</em> the issues with showing C# stack traces. I guess WinDbg is compiled for ARM64 after all, and it just decided to run an x64 debug host when you start debugging an x64 application. Fair enough I guess?</p>
<h2 id="debugging-whats-sdl-doing">
	<a href="#debugging-whats-sdl-doing">
		Debugging: what’s SDL doing?
	</a>
</h2><p>After figuring out all of the above, we could <em>really</em> get started. I also opted to swap out <code>SDL3.dll</code> with a locally-built copy, so that the debugger could locate source files<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. What SDL is doing is pretty straight forward: the first time the window is shown, it clears the background with GDI commands:</p>
<p><picture>
	<source srcset="sdl_code.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/sdl_code.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/sdl_code.webp" width="715" height="568" alt="SDL source code shown in WinDbg. The line that calls GetDC() is highlighted."/>
</picture>
</p>
<p>I mean… this is like, fine, right? I mean I don’t know much about this code, but why would this crash on ARM but not x64??? The window is valid. <code>GetDC()</code> is an extremely fundamental Win32 function call. If there was something broken with it, my OS would not be usable. What the fuck is going on?</p>
<p>The <code>if (ShouldClearWindowOnEraseBackground(data))</code> allows it to be disabled via a hint, which can be specified by environment variable. This fixes the crash… until you open a second OS window, then SDL3 calls <code>GetDC()</code> once again and <em>that</em> crashes. Not a solution.</p>
<p>So I checked the actual <code>USER32!GetDC</code> again, and this time I actually paid attention to the disassembly code instead of glossing over it. What the fuck? <code>pacibsp</code> is missing at the start. It’s loading an address for a jump that only jumps to <em>the next instruction</em>, which is <em>invalid</em>. In some runs, said instruction was instead a broken <code>x26</code>-relative <code>str</code> instruction that AV’d because the register was all zeroes.</p>
<p>At this point let’s introduce the villain. You might have noticed it in the call stack: <code>DXGI!My_GetDC</code>.</p>
<figure><img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_disasm_2.webp" alt="WinDbg disassembly for DXGI!MyDC. The word &amp;quot;Detour&amp;quot; is clearly visible"/><figcaption>
      <p>Microsoft is detouring their <em>own code???</em></p>
    </figcaption>
</figure>

<p>For those who aren’t well-versed in DirectX stuff: <em>DXGI</em> is a fundamental part of DirectX ever since DirectX 10 (Vista). For those who have never modded a game before: a <em>detour</em> is a hack that injects instructions into other functions at runtime, to do evil shit. Why the <em>hell</em> is Microsoft using this in DXGI?</p>
<h2 id="debugging-dxgi-despair">
	<a href="#debugging-dxgi-despair">
		Debugging: DXGI despair
	</a>
</h2><p>Through the debugging adventure, I ended up putting a breakpoint on every call to <code>USER32!GetDC</code>. The first few calls are fine, but then the <em>last</em> one, the one that crashes, is not.</p>
<p>At this point I got really desperate. “Asking in low-level programming Discords”-level desperate. I ended up asking for help in the <a href="https://discord.gg/directx">DirectX Discord</a> (yes, there’s an official DirectX Discord, and there’s many MS employees in there).</p>
<section aria-label="Thought" aria-role="Thought">
<p>I would like to thank Jesse Natalia from the DirectX Discord for responding swiftly to my messages in there.</p>
</section>
<p>After some back and forth there, I wanted to catch DXGI in the act. Maybe that would tell me something, I don’t know. So with a simple <code>ba w4 USER32!GetDC</code>, I put a hardware breakpoint for whenever something would <em>write</em> to <code>USER32!GetDC</code>. I did have to awkwardly “run the program for just a little bit” because <code>USER32.dll</code> isn’t loaded immediately at program startup.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<section aria-label="Thought" aria-role="Thought">
<p>While writing this blog post I realized there <em>is</em> an intelligent way to do this. It’s called <code>sxe ld USER32.dll</code>. I’ve literally written about it <a href="https://slugcat.systems/post/25-03-18-virtual-reality-projection-shenanigans/"><em>in this blog before</em></a>. Oops.</p>
</section>
<p><picture>
	<source srcset="windbg_stack_3.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_3.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/windbg_stack_3.webp" width="627" height="537" alt="WinDbg stack trace, starting at SDL3!SDL_CreateWindowWithProperties and ending at DXGI!DetourTransactionCommitEx"/>
</picture>
</p>
<p>Now this is very interesting. The bottom of the stack trace is quite expected: SDL creates a window, uses ANGLE’s EGL implementation for this, that does a bunch of stuff, and eventually creates a DXGI swapchain. But then what is <code>UpgradeSwapEffect</code>? And why is it installing a detour?</p>
<p>Ah, I already know what this is.</p>
<p><picture>
	<source srcset="discord.webp"/>
	
		
			<source type="image/jpeg" srcset="/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/discord.webp.jpg"/>
		
	

	<img src="https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/discord.webp" width="1408" height="492" alt="Discord conversation between me (PJB) and Jesse Natalie: “…upgrade swap effect…?” “Ah, ok I can see why that would need a detour I guess. Been out of the DXGI code for too long” “is this related to whatever the thing in windows 11 is that forces flip model on software (ANGLE […] create flip model swap chains when using its own swap chain management)” “Yes”"/>
</picture>
</p>
<h2 id="optimizing-windowed-games-flip-model">
	<a href="#optimizing-windowed-games-flip-model">
		Optimizing windowed games: flip model
	</a>
</h2><p>Right. So. DirectX.</p>
<p>When you create a DirectX swapchain, you specify an “<a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/ne-dxgi-dxgi_swap_effect">effect</a>”, which falls into two categories: “bitblt” and “flip”. To make a <a href="https://learn.microsoft.com/en-us/windows/win32/direct3ddxgi/for-best-performance--use-dxgi-flip-model#a-brief-history">long story short</a>: bitblt is the “original” one, while flip is the much more modern one added in Windows 8<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>. It’s more efficient and performant, and all software should be using it. Furthermore, on modern versions of Windows and with a GPU supporting “<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/display/multiplane-overlay-support">Multiplane Overlays</a>”, flip model actually enables windowed games to be displayed with <em>zero additional latency</em> over “exclusive” fullscreen mode. </p>
<p>Of course, many games never get updated, or they’re stuck on an ancient version. And many of these games don’t care. So in Windows 11, Microsoft added “<a href="https://support.microsoft.com/en-us/windows/optimizations-for-windowed-games-in-windows-11-3f006843-2c7e-4ed0-9a5e-f9389e535952">Optimizations for windowed games</a>”, which forcibly enables flip model on games that are still using bitblt. Why does DXGI need to install detours for this? Probably some compatibility shit with the bitblt model. I don’t have any deep knowledge of how Win32 GDI stuff works, but it’s not hard for me to imagine there’s some interplay here they need to take care of. I can also confirm that <em>disabling</em> the feature in Windows’ settings menu fixes the crash!</p>
<p>If you’re wondering why SS14 isn’t using flip model: it’s because we can’t. We’re not creating the swapchain directly, <em>ANGLE</em> is. And ANGLE is continuing to use <code>SWAP_EFFECT_SEQUENTIAL</code>. I actually once <a href="https://github.com/space-wizards/RobustToolbox/blob/ac3cb4dc2abe970e611b944b252504e602303dfe/Robust.Client/Graphics/Clyde/GLContext/GLContextAngle.cs">experimented with SS14 managing the swapchain</a>, but this ran into some ANGLE limitations and I never got around to ironing out all the edge cases and crashes. I’d rather just spend the brain power on ditching OpenGL, rather than trying to continue working with this broken API.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p>
<p>So here we are. The entire debugging story so far, you’re like, “surely Microsoft didn’t break DXGI on ARM64, huh???” But now it’s becoming plausible. There’s barely any native ARM64 Windows games, and surely none that are using bitblt swapchains. And guess what, you don’t even <em>need</em> <code>GetDC()</code> for modern DirectX games. SDL does it because it’s heavily designed for OpenGL. Most games run in x64 emulation, and that presumably works fine. Everything adds up to it being possible this just genuinely fell under the radar at Microsoft.</p>
<p>This should be pretty easy to verify in a minimal example. I cloned an <a href="https://github.com/microsoft/DirectX-SDK-Samples/blob/main/C%2B%2B/Direct3D11/Tutorials/Tutorial01/Tutorial01.cpp">old DirectX SDK sample</a>, updated it to be compiled for ARM64, added some <code>GetDC()</code> calls, aaand… nope, no crash. Then I spent quite a while <em>trying various stuff</em>: comparing the swapchain creation code with that of ANGLE, changing various parameters, verifying whether the detour was being installed (it wasn’t). But eventually, I did find it.</p>
<p>It’s the filename.</p>
<p>Of course it’s the goddamn filename.</p>
<h2 id="im-on-a-list">
	<a href="#im-on-a-list">
		I’m on a list
	</a>
</h2><p><strong>It only happens when the program is called <code>SS14.Loader.exe</code>.</strong></p>
<p>The final piece of the puzzle. It didn’t happen in a dev environment because then the exe isn’t named <code>SS14.Loader.exe</code>. Microsoft only enables “Optimizations for windowed games” on a specific list of games. And guess what, <em>none</em> of those select games are on ARM64, at least until I was unfortunate enough to port mine. How did we get on the list? Who knows.</p>
<p>Microsoft put me on a list, that ships with every Windows install. And this list actually broke my game. Achievement unlocked!</p>
<h2 id="addendum-why-angle-and-about-opengl-on-windows-arm64">
	<a href="#addendum-why-angle-and-about-opengl-on-windows-arm64">
		Addendum: why ANGLE, and about OpenGL on Windows ARM64
	</a>
</h2><p>Traditionally, OpenGL on Windows has been implemented by the 3 IHVs (Nvidia, AMD, Intel). If they didn’t explicitly go out of their way to add it to their drivers, you’d have no OpenGL beyond 1.0. Those new Snapdragon X devices, however, use Microsoft’s new-ish “OpenGL on D3D12” driver. It’s actually part of Mesa!</p>
<p>The problem with Space Station 14 is that said driver is broken for us, causing severe graphical artifacts and flickering. I had been aware of this for years, because the same driver is used for the GPU acceleration of WSL2, but I never bothered to report it 😬. So for the purpose of porting SS14 to ARM64 Windows, I decided to just immediately force on ANGLE on Qualcomm devices, and call it a day.</p>
<p>What I didn’t know until yesterday is that the OpenGL on D3D12 driver does not ship with Qualcomm’s drivers! <a href="https://apps.microsoft.com/detail/9nqpsl29bfff?hl=en-US&amp;gl=US">It’s on the Microsoft store!</a> I can even install it in my VM and get it to emulate OpenGL on top of DirectX’s software renderer (WARP), just like I had been doing with ANGLE. I’ve finally bothered to <a href="https://gitlab.freedesktop.org/mesa/mesa/-/issues/13936">report the graphical issues</a>, so hopefully it gets fixed eventually. If it does get fixed, Microsoft Store distribution means it shouldn’t take too long to trickle down to users, and then we can stop enforcing ANGLE on Qualcomm devices.</p>
<p>For Space Station 14, I will say that this means I’ll be postponing official Windows ARM64 support <em>for now</em>. At least until either bug (OpenGL on D3D12 <em>or</em> ARM64 DXGI detours) are fixed. Or when I finally rewrite the renderer to drop OpenGL, that’s also an option.</p>

	</article>

	</div></div>
  </body>
</html>
