<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/szabolcsdombi/optimization-demo">Original</a>
    <h1>Show HN: Python can make 3M&#43; WebSocket keys per second</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">This article is about optimizing a tiny bit of Python code by replacing it with its C++ counterpart.</p>
<p dir="auto">Beware, geek stuff follows.</p>
<p dir="auto">We are interested in implementing the <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-1.3" rel="nofollow">Opening Handshake</a> of <a href="https://datatracker.ietf.org/doc/html/rfc6455" rel="nofollow">The Websocket Protocol</a>.
It is a fairly simple to understand task, it involes sizeable number crunching and intermediate object allocations to see it pop out in the results.
To be clear, this is a demo project with no real world benefits except for the methodology used.</p>
<p dir="auto">Let&#39;s get started.</p>
<p dir="auto">First, we implement a function that returns the <code>Sec-WebSocket-Accept</code> calculated from the <code>Sec-WebSocket-Key</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="from base64 import b64encode
from hashlib import sha1


def py_accept(key: str) -&gt; str:
    return b64encode(sha1((key + &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;).encode()).digest()).decode()"><pre><span>from</span> <span>base64</span> <span>import</span> <span>b64encode</span>
<span>from</span> <span>hashlib</span> <span>import</span> <span>sha1</span>


<span>def</span> <span>py_accept</span>(<span>key</span>: <span>str</span>) <span>-&gt;</span> <span>str</span>:
    <span>return</span> <span>b64encode</span>(<span>sha1</span>((<span>key</span> <span>+</span> <span>&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;</span>).<span>encode</span>()).<span>digest</span>()).<span>decode</span>()</pre></div>
<p dir="auto">We can easily verify the sample value from the spec matches our return value.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; py_accept(&#39;dGhlIHNhbXBsZSBub25jZQ==&#39;)
&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>py_accept</span>(<span>&#39;dGhlIHNhbXBsZSBub25jZQ==&#39;</span>)
<span>&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;</span></pre></div>
<p dir="auto">So far so good. Now let&#39;s dissamble it to see what is inside.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; import dis
&gt;&gt;&gt; dis.dis(py_accept)

  1           0 RESUME                   0

  2           2 LOAD_GLOBAL              1 (NULL + b64encode)
             14 LOAD_GLOBAL              3 (NULL + sha1)
             26 LOAD_FAST                0 (key)
             28 LOAD_CONST               1 (&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;)
             30 BINARY_OP                0 (+)
             34 LOAD_METHOD              2 (encode)
             56 PRECALL                  0
             60 CALL                     0
             70 PRECALL                  1
             74 CALL                     1
             84 LOAD_METHOD              3 (digest)
            106 PRECALL                  0
            110 CALL                     0
            120 PRECALL                  1
            124 CALL                     1
            134 LOAD_METHOD              4 (decode)
            156 PRECALL                  0
            160 CALL                     0
            170 RETURN_VALUE"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> <span>dis</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>dis</span>.<span>dis</span>(<span>py_accept</span>)

  <span>1</span>           <span>0</span> <span>RESUME</span>                   <span>0</span>

  <span>2</span>           <span>2</span> <span>LOAD_GLOBAL</span>              <span>1</span> (<span>NULL</span> <span>+</span> <span>b64encode</span>)
             <span>14</span> <span>LOAD_GLOBAL</span>              <span>3</span> (<span>NULL</span> <span>+</span> <span>sha1</span>)
             <span>26</span> <span>LOAD_FAST</span>                <span>0</span> (<span>key</span>)
             <span>28</span> <span>LOAD_CONST</span>               <span>1</span> (<span>&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;</span>)
             <span>30</span> <span>BINARY_OP</span>                <span>0</span> (<span>+</span>)
             <span>34</span> <span>LOAD_METHOD</span>              <span>2</span> (<span>encode</span>)
             <span>56</span> <span>PRECALL</span>                  <span>0</span>
             <span>60</span> <span>CALL</span>                     <span>0</span>
             <span>70</span> <span>PRECALL</span>                  <span>1</span>
             <span>74</span> <span>CALL</span>                     <span>1</span>
             <span>84</span> <span>LOAD_METHOD</span>              <span>3</span> (<span>digest</span>)
            <span>106</span> <span>PRECALL</span>                  <span>0</span>
            <span>110</span> <span>CALL</span>                     <span>0</span>
            <span>120</span> <span>PRECALL</span>                  <span>1</span>
            <span>124</span> <span>CALL</span>                     <span>1</span>
            <span>134</span> <span>LOAD_METHOD</span>              <span>4</span> (<span>decode</span>)
            <span>156</span> <span>PRECALL</span>                  <span>0</span>
            <span>160</span> <span>CALL</span>                     <span>0</span>
            <span>170</span> <span>RETURN_VALUE</span></pre></div>
<p dir="auto">Okay, this looks a bit messy. Here is a transformed version of it.</p>
<div dir="auto" data-snippet-clipboard-copy-content="             26 LOAD_FAST                0 (key)
             28 LOAD_CONST               1 (&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;)
             30 BINARY_OP                0 (+)
             60 CALL                     0 (encode)
             74 CALL                     1 (sha1)
            110 CALL                     0 (digest)
            124 CALL                     1 (b64encode)
            160 CALL                     0 (decode)
            170 RETURN_VALUE"><pre>             <span>26</span> <span>LOAD_FAST</span>                <span>0</span> (<span>key</span>)
             <span>28</span> <span>LOAD_CONST</span>               <span>1</span> (<span>&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;</span>)
             <span>30</span> <span>BINARY_OP</span>                <span>0</span> (<span>+</span>)
             <span>60</span> <span>CALL</span>                     <span>0</span> (<span>encode</span>)
             <span>74</span> <span>CALL</span>                     <span>1</span> (<span>sha1</span>)
            <span>110</span> <span>CALL</span>                     <span>0</span> (<span>digest</span>)
            <span>124</span> <span>CALL</span>                     <span>1</span> (<span>b64encode</span>)
            <span>160</span> <span>CALL</span>                     <span>0</span> (<span>decode</span>)
            <span>170</span> <span>RETURN_VALUE</span></pre></div>
<p dir="auto">Except for the temporary values generated within the steps, the code itself looks the fastest possible. All the methods invoked are implemented in C inside the CPython implementation.</p>
<p dir="auto">Now, we are going to implement all this as a single step in C++. To do that, we can initialize a Python extension and add our new function.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;Python.h&gt;

void sec_websocket_accept(const void * src, void * dst) {
    ...
}

PyObject * c_accept(PyObject * self, PyObject * arg) {
    char result[28];
    sec_websocket_accept(PyUnicode_AsUTF8(arg), result);
    return PyUnicode_FromStringAndSize(result, 28);
}

PyMethodDef module_methods[] = {
    {&#34;c_accept&#34;, (PyCFunction)c_accept, METH_O, NULL},
    {},
};

PyModuleDef module_def = {PyModuleDef_HEAD_INIT, &#34;mymodule&#34;, NULL, -1, module_methods};

extern &#34;C&#34; PyObject * PyInit_mymodule() {
    return PyModule_Create(&amp;module_def);
}"><pre>#<span>include</span> <span><span>&lt;</span>Python.h<span>&gt;</span></span>

<span>void</span> <span>sec_websocket_accept</span>(<span>const</span> <span>void</span> * src, <span>void</span> * dst) {
    ...
}

PyObject * <span>c_accept</span>(PyObject * self, PyObject * arg) {
    <span>char</span> result[<span>28</span>];
    <span>sec_websocket_accept</span>(<span>PyUnicode_AsUTF8</span>(arg), result);
    <span>return</span> <span>PyUnicode_FromStringAndSize</span>(result, <span>28</span>);
}

PyMethodDef module_methods[] = {
    {<span><span>&#34;</span>c_accept<span>&#34;</span></span>, (PyCFunction)c_accept, METH_O, <span>NULL</span>},
    {},
};

PyModuleDef module_def = {PyModuleDef_HEAD_INIT, <span><span>&#34;</span>mymodule<span>&#34;</span></span>, <span>NULL</span>, -<span>1</span>, module_methods};

<span>extern</span> <span><span>&#34;</span>C<span>&#34;</span></span> PyObject * <span>PyInit_mymodule</span>() {
    <span>return</span> <span>PyModule_Create</span>(&amp;module_def);
}</pre></div>
<p dir="auto">The implementation of <code>sec_websocket_accept()</code> is cumbersome enough to worth ommitting from this article.
Here is a <a href="https://github.com/szabolcsdombi/optimization-demo/blob/main/mymodule/mymodule.cpp">link</a> to the full code.</p>
<p dir="auto">It might not be trivial to see, but neither the Python, nor the C++ variant contains micro-optimizations or any harware specific ones.
These are just naive implentations. We can achieve significant results without using any of that.</p>
<p dir="auto">We can add our tests, and see the results.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from base64 import b64encode
from hashlib import sha1

from mymodule import c_accept


def py_accept(key: str) -&gt; str:
    return b64encode(sha1((key + &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;).encode()).digest()).decode()


def test_python_code(benchmark):
    assert benchmark(py_accept, &#39;dGhlIHNhbXBsZSBub25jZQ==&#39;) == &#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;


def test_optimized_code(benchmark):
    assert benchmark(c_accept, &#39;dGhlIHNhbXBsZSBub25jZQ==&#39;) == &#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;"><pre><span>from</span> <span>base64</span> <span>import</span> <span>b64encode</span>
<span>from</span> <span>hashlib</span> <span>import</span> <span>sha1</span>

<span>from</span> <span>mymodule</span> <span>import</span> <span>c_accept</span>


<span>def</span> <span>py_accept</span>(<span>key</span>: <span>str</span>) <span>-&gt;</span> <span>str</span>:
    <span>return</span> <span>b64encode</span>(<span>sha1</span>((<span>key</span> <span>+</span> <span>&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;</span>).<span>encode</span>()).<span>digest</span>()).<span>decode</span>()


<span>def</span> <span>test_python_code</span>(<span>benchmark</span>):
    <span>assert</span> <span>benchmark</span>(<span>py_accept</span>, <span>&#39;dGhlIHNhbXBsZSBub25jZQ==&#39;</span>) <span>==</span> <span>&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;</span>


<span>def</span> <span>test_optimized_code</span>(<span>benchmark</span>):
    <span>assert</span> <span>benchmark</span>(<span>c_accept</span>, <span>&#39;dGhlIHNhbXBsZSBub25jZQ==&#39;</span>) <span>==</span> <span>&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-results" aria-hidden="true" href="#results"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Results</h2>
<div data-snippet-clipboard-copy-content="----------------------------------------------------------------------------------------------------------
Name (time in ns)            Mean            StdDev                Median           OPS (Kops/s)
----------------------------------------------------------------------------------------------------------
test_optimized_code      317.0102 (1.0)      0.0384 (1.0)        317.0121 (1.0)       3,154.4725 (1.0)
test_python_code       1,149.9825 (3.63)     0.8864 (23.10)    1,149.8373 (3.63)        869.5785 (0.28)
----------------------------------------------------------------------------------------------------------"><pre><code>----------------------------------------------------------------------------------------------------------
Name (time in ns)            Mean            StdDev                Median           OPS (Kops/s)
----------------------------------------------------------------------------------------------------------
test_optimized_code      317.0102 (1.0)      0.0384 (1.0)        317.0121 (1.0)       3,154.4725 (1.0)
test_python_code       1,149.9825 (3.63)     0.8864 (23.10)    1,149.8373 (3.63)        869.5785 (0.28)
----------------------------------------------------------------------------------------------------------
</code></pre></div>
<ul dir="auto">
<li>It seems our Python code did really well. It can execute 869k calls per second.</li>
<li>It is also clear our C++ variant is 3.63x faster, clocking at 3.15m calls per second.</li>
</ul>
<p dir="auto">Amazing! Replacing a tiny bit of code that seems not optimizable has a significant effect.</p>
<p dir="auto">If you wish to run these tests yourself, you will find all the necessary steps in the github actions <a href="https://github.com/szabolcsdombi/optimization-demo/actions/runs/5423258436/jobs/9860949567">here</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-no-goals-of-this-article" aria-hidden="true" href="#no-goals-of-this-article"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>No-Goals of this Article</h2>
<ul dir="auto">
<li>This article does not address maintainability or any other burden introduced with replacing simple Python code with cumbersome low level C code.</li>
<li>We are not interested in micro-optimization, using SSE or hardware implemented hashing.</li>
<li>Not interested in multi-threaded approaches, concurrency.</li>
<li>Not interested in implementing it in Rust or any other language not supported out of the box for Python Extensions.</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-fun-fact" aria-hidden="true" href="#fun-fact"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fun Fact</h2>
<p dir="auto">We can implement a magic function that may also work.</p>
<div dir="auto" data-snippet-clipboard-copy-content="def magic_accept(key: str) -&gt; str:
    return &#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;"><pre><span>def</span> <span>magic_accept</span>(<span>key</span>: <span>str</span>) <span>-&gt;</span> <span>str</span>:
    <span>return</span> <span>&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;</span></pre></div>
<p dir="auto">Silly, but indeed it passes the test.</p>
<div data-snippet-clipboard-copy-content="----------------------------------------------------------------------------------------------------------
Name (time in ns)            Mean            StdDev                Median           OPS (Kops/s)
----------------------------------------------------------------------------------------------------------
test_magic_code           83.1061 (1.0)      0.7204 (22.09)       82.8925 (1.0)      12,032.8104 (1.0)
test_optimized_code      338.3712 (4.07)     0.0326 (1.0)        338.3669 (4.08)      2,955.3341 (0.25)
test_python_code       1,288.4041 (15.50)    0.6493 (19.91)    1,288.4681 (15.54)       776.1540 (0.06)
----------------------------------------------------------------------------------------------------------"><pre><code>----------------------------------------------------------------------------------------------------------
Name (time in ns)            Mean            StdDev                Median           OPS (Kops/s)
----------------------------------------------------------------------------------------------------------
test_magic_code           83.1061 (1.0)      0.7204 (22.09)       82.8925 (1.0)      12,032.8104 (1.0)
test_optimized_code      338.3712 (4.07)     0.0326 (1.0)        338.3669 (4.08)      2,955.3341 (0.25)
test_python_code       1,288.4041 (15.50)    0.6493 (19.91)    1,288.4681 (15.54)       776.1540 (0.06)
----------------------------------------------------------------------------------------------------------
</code></pre></div>
<p dir="auto">The dissambled version seems to be simple too.</p>
<div dir="auto" data-snippet-clipboard-copy-content="&gt;&gt;&gt; dis.dis(magic_accept)
  1           0 RESUME                   0

  2           2 LOAD_CONST               1 (&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;)
              4 RETURN_VALUE"><pre><span>&gt;&gt;</span><span>&gt;</span> <span>dis</span>.<span>dis</span>(<span>magic_accept</span>)
  <span>1</span>           <span>0</span> <span>RESUME</span>                   <span>0</span>

  <span>2</span>           <span>2</span> <span>LOAD_CONST</span>               <span>1</span> (<span>&#39;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#39;</span>)
              <span>4</span> <span>RETURN_VALUE</span></pre></div>
<p dir="auto">So, how this new method compares to our existing ones that do real work?</p>
<p dir="auto">Supprising as it may sound but our C++ implementation is just 4x slower.
(From measurements and interpretations we are now entering a realm of guessings).
This could be because of the overhead introduced by calling functions, the interpreter parsing bytecode or our mearuring tools used.
At 12m calls per second on a single core this is inevitable.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-summary" aria-hidden="true" href="#summary"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Summary</h2>
<p dir="auto">By implementing a simple task in C++ instead of Python, where the underlying function calls are already implemented in C++, we still can get a significant boost.</p>
</article>
          </div></div>
  </body>
</html>
