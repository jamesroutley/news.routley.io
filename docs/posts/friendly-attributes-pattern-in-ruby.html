<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brunosutic.com/blog/ruby-friendly-attributes-pattern">Original</a>
    <h1>Friendly attributes pattern in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      

      <time datetime="2025-10-30">October 31, 2025</time>

      <p>I run <a href="https://railsbilling.com">RailsBilling</a>, a paid gem for fast Stripe subscription integrations with Rails.</p>

      <p>During development I manually create a lot of subscription plans. Here&#39;s what creating <code>standard</code>, <code>pro</code> and <code>enterprise</code> plans with monthly and yearly intervals looks like:</p>

      <pre><code><span>Billing</span>::<span>Plan</span>::<span>Factory</span>.find_or_create_by!(
  <span>name</span>: <span>:</span><span>standard</span>,
  <span>interval</span>: <span>1</span>.month,
  <span>amount</span>: <span>10</span>
)
<span>Billing</span>::<span>Plan</span>::<span>Factory</span>.find_or_create_by!(
  <span>name</span>: <span>:</span><span>pro</span>,
  <span>interval</span>: <span>1</span>.month,
  <span>amount</span>: <span>50</span>
)
<span>Billing</span>::<span>Plan</span>::<span>Factory</span>.find_or_create_by!(
  <span>name</span>: <span>:</span><span>enterprise</span>,
  <span>interval</span>: <span>1</span>.month,
  <span>amount</span>: <span>100</span>
)
<span>Billing</span>::<span>Plan</span>::<span>Factory</span>.find_or_create_by!(
  <span>name</span>: <span>:</span><span>standard</span>,
  <span>interval</span>: <span>1</span>.year,
  <span>amount</span>: <span>100</span>
)
<span>Billing</span>::<span>Plan</span>::<span>Factory</span>.find_or_create_by!(
  <span>name</span>: <span>:</span><span>pro</span>,
  <span>interval</span>: <span>1</span>.year,
  <span>amount</span>: <span>500</span>
)
<span>Billing</span>::<span>Plan</span>::<span>Factory</span>.find_or_create_by!(
  <span>name</span>: <span>:</span><span>enterprise</span>,
  <span>interval</span>: <span>1</span>.year,
  <span>amount</span>: <span>1000</span>
)</code></pre>

      <p>This code works well and has some nice properties, like being idempotent both locally and in Stripe. But there are some issues:</p>

      <ul>
        <li>It feels bulky and eats more than half my laptop screen.</li>
        <li>My customers usually start by creating plans, and kicking off with this doesn&#39;t exactly feel premium.</li>
        <li>After typing, copying, and tweaking this dozens of times a day, day after day, it began to wear me down.</li>
      </ul>

      <p>One day I snapped and decided this is the new way it should be done:</p>

      <pre><code><span>Billing</span>::<span>Plan</span>.find_or_create_all_by_attrs!(
  <span>1</span>.month =&gt; {<span>standard</span>: <span>10</span>, <span>pro</span>: <span>50</span>, <span>enterprise</span>: <span>100</span>},
  <span>1</span>.year =&gt; {<span>standard</span>: <span>100</span>, <span>pro</span>: <span>500</span>, <span>enterprise</span>: <span>1000</span>}
)</code></pre>

      <p><strong>This snippet does exactly the same thing as the previous example.</strong></p>

      <p>The new attribute schema is easier to type, easier to read, and uses far fewer lines of code. All attribute keys like <code>:name</code>, <code>:interval</code>, and <code>:amount</code> are considered redundant and were removed.</p>

      <p>I&#39;m calling this <strong>Friendly Attributes Pattern</strong>.</p>

      <p>The new attributes also clearly model a mental image of a standard pricing page:</p>

      <ul>
        <li>Interval toggle at the top.</li>
        <li>Plan columns contain names, followed by prices.</li>
      </ul>

      <p>Here&#39;s a screenshot of a standard pricing page for reference.</p>

      <img src="https://brunosutic.com/images/pricing.png" width="620" alt="Standard pricing page"/>

      <p><i>This post uses real, tested examples from RailsBilling. That said, the pattern isn&#39;t limited to billing subscriptions domain, and I share another example toward the end.</i></p>

      <h2>Use cases</h2>

      <p>After I got my Friendly Attributes example to work, new use cases popped up immediately.</p>

      <p>I use it in tests to fetch existing plans:</p>

      <pre><code>billing_plans(<span>1</span>.month =&gt; [<span>:</span><span>standard</span>, <span>:</span><span>pro</span>, <span>:</span><span>enterprise</span>])</code></pre>

      <p>I use it with minitest assertions, and although I&#39;m an RSpec user, I must concede this reads really nice:</p>

      <pre><code>assert_billing_pricing_plans <span>1</span>.month =&gt; [<span>:</span><span>standard</span>, <span>:</span><span>pro</span>, <span>:</span><span>enterprise</span>]</code></pre>

      <p>Fetching a single plan in Rails console:</p>

      <pre><code><span>Billing</span>::<span>Plan</span>.find_sole_by_attrs(<span>:</span><span>pro</span>, <span>1</span>.month)</code></pre>

      <p>Notice that the order of <code>:pro</code> and <code>1.month</code> args follows the way it&#39;s said out loud: &#34;pro monthly plan&#34;. It simply sounds more natural than &#34;monthly pro plan&#34;.</p>

      <p>However, I learned that in French they flip the order of &#34;pro&#34; and &#34;monthly&#34;, and say &#34;Mensuel Pro&#34;. Luckily, Friendly Attributes allows passing args in any order, so now I pride myself for knowing to code in French:</p>

      <pre><code><span>Billing</span>::<span>Plan</span>.find_sole_by_attrs(<span>1</span>.month, <span>:</span><span>pro</span>) </code></pre>

      <p>And lastly, you can use just a single attribute. Here&#39;s the example test helper:</p>

      <pre><code>billing_plan <span>:</span><span>pro</span></code></pre>

      <p>It may seem unusual to put a standalone value <code>:pro</code> in the same bucket as an elaborate hash <code>1.month =&gt; {standard: 10, pro: 50, enterprise: 100}</code>, and claim it&#39;s the same thing, same pattern. The next section clarifies this, and explains how it all works under the hood.</p>

      <h2>Implementation</h2>

      <h3>Conversion</h3>

      <p>Friendly Attributes&#39; job is to convert various structures (arrays, hashes, values) into standard, key-value attributes.</p>

      <p>You pass it an input <code>[:pro, 50, 1.month]</code>, and you get standard attrs on the output: <code>{name: :pro, amount: 50, interval: 1.month}</code>. This is all it does.</p>

      <p>This output can conveniently be passed to various finder, query, or factory methods. But <strong>what you do with the output is a separate concern, and outside the scope of Friendly Attributes as a concept</strong>.

      </p><p>Here&#39;s the example interface:</p>

      <pre><code><span>FriendlyAttrs</span>.new(attrs).resolve </code></pre>

      <h3>Types</h3>

      <p>The main idea behind Friendly Attributes is to <strong>use types to convert standalone values into regular attributes</strong>.</p>

      <p>Each domain has its own rules. Here are the ones used for plan attributes from this post:</p>

      <dl>
        <dt>Integers are amounts</dt>
        <dd><code>50</code> converts to <code>{amount: 50}</code></dd>
        <dt>Symbols or strings are plan names</dt>
        <dd><code>:pro</code> converts to <code>{name: :pro}</code></dd>
        <dt>ActiveSupport::Duration objects are intervals</dt>
        <dd><code>1.month</code> converts to <code>{interval: 1.month}</code></dd>
      </dl>

      <h3>Value lookup</h3>

      <p>You can go a step further and parse standalone strings or symbols for further distinction. For example, <code>:usd</code> can be recognized as a currency and converted to <code>{currency: :usd}</code>.</p>

      <p>For my specific case, I decided not to use this. In 99% cases currency is configured globally and does not need to be specified.</p>

      <p>So the value <code>:usd</code> resolves to <code>{name: :usd}</code> and becomes a plan name.</p>

      <h3>Mixing</h3>

      <p>You can mix Friendly Attributes with standard attributes.</p>

      <pre><code>[<span>1</span>.month, {<span>name</span>: <span>:</span><span>pro</span>, <span>amount</span>: <span>50</span>}]</code></pre>

      <p>This resolves to <code>{interval: 1.month, name: :pro, amount: 50}</code>.</p>

      <p>For this to work you have to keep a list of known attribute names so it&#39;s clear that <code>:amount</code> is an attribute key, not a symbol representing plan name.</p>

      <h3>Superset</h3>

      <p>Friendly Attributes are a superset of standard attributes.</p>

      <p>This hash <code>{interval: 1.month, name: :pro, amount: 50}</code> is a valid input, and it just returns the same value on the output.</p>

      <p>This property keeps everything backward compatible. If Friendly Attributes approach doesn&#39;t click with you, you can still use all helper methods with standard attributes.</p>

      <h3>Object tree</h3>

      <p>At one point I had this code working:</p>

      <pre><code>[<span>1</span>.month, <span>:</span><span>standard</span>, <span>10</span>],
[<span>1</span>.month, <span>:</span><span>pro</span>, <span>50</span>],
[<span>1</span>.month, <span>:</span><span>enterprise</span>, <span>100</span>]</code></pre>

      <p>You see how <code>1.month</code> keeps repeating? In order to reduce repetition I decided to use an object tree. The above set of arrays can now be written like this:</p>

      <pre><code>{<span>1</span>.month =&gt; {<span>standard</span>: <span>10</span>, <span>pro</span>: <span>50</span>, <span>enterprise</span>: <span>100</span>}}</code></pre>

      <p>Here&#39;s a visualization of this hash as a tree:</p>

      <pre>      10         50        100         # leaves
      |          |          |
      |          |          |
  :standard    :pro    :enterprise
      |          |          |
       `---------+---------/
                 |
              1.month                  # root
      </pre>

      <p>The key to understanding how the hash relates to the tree is to read the hash from left to right, and the tree from the bottom up.</p>

      <p>The next steps are:</p>

      <ul>
        <li>Start from the leaf nodes.</li>
        <li>For each leaf, follow its path up to the root and collect the values into an array.</li>
      </ul>

      <p>Here&#39;s the result of that operation:</p>

      <pre><code>[<span>10</span>, <span>:</span><span>standard</span>, <span>1</span>.month],
[<span>50</span>, <span>:</span><span>pro</span>, <span>1</span>.month],
[<span>100</span>, <span>:</span><span>enterprise</span>, <span>1</span>.month]
</code></pre>

      <p>So, we&#39;re back to a set of arrays, but this is now an internal state. The arrays are easily converted to standard attributes using previous guidelines.</p>

      <h2>Flexibility</h2>

      <p>Friendly Attributes allow for very flexible inputs. Here&#39;s an example where each input line produces the same output:</p>

      <pre><code>{<span>1</span>.month =&gt; {<span>pro</span>: <span>50</span>}}
{<span>50</span> =&gt; {<span>pro</span>: <span>1</span>.month}
[<span>1</span>.month, <span>:</span><span>pro</span>, <span>50</span>]
[<span>:</span><span>pro</span>, {<span>1</span>.month =&gt; <span>50</span>}]</code></pre>

      <p><strong>The choice of which line you use comes down to readability</strong>. And as we&#39;ve seen, what you find most readable depends on whether you &#34;think&#34; in English, French, or maybe Greek.</p>

      <p>Additionally, you don&#39;t always have to specify all the attributes. For example, input <code>:pro</code> converts to <code>{name: :pro}</code>. This is not &#34;just theoretical&#34;, I use it actively, and I&#39;m <em>delighted</em> every time I get to use <code>billing_plan :pro</code> in tests.</p>

      <h3>Going too far</h3>

      <p>You can also do some silly things:</p>

      <pre><code>billing_plan <span>50</span></code></pre>

      <p>This fetches a plan with attrs <code>{amount: 50}</code>. It&#39;s a valid example, but it&#39;s unusual and <em>not recommended</em>.</p>

      <p>Here&#39;s another working example that only Yoda would find readable:</p>

      <pre><code>{{<span>name</span>: <span>:</span><span>standard</span>} =&gt; {<span>1</span>.month =&gt; <span>10</span>}}</code></pre>

      <h3>Is flexibility good or bad?</h3>

      <p>In Ruby you can write beautiful code, and convoluted <nobr>one-liners</nobr>. The same applies to Friendly Attributes.</p>

      <p>I believe the flexibility benefits outweigh the potential downsides. So let&#39;s follow Ruby&#39;s lead and aim to write elegant code.</p>

      <h2>Other use cases</h2>

      <p>Look, I genuinely like, and feel excited about this idea. But to be honest, <strong>I can&#39;t find many good examples</strong> that reap the benefits I&#39;m describing here.</p>

      <p>Friendly Attributes is a nice idea, but let&#39;s not force it into every app or model.</p>

      <h3>Example</h3>

      <p><i>This example is just a thought exercise. While all other snippets in this post are real, tested, and working, this one is purely conceptual.</i></p>

      <p>I worked at an IoT company that builds smart door locks. The main part of their app handled who could access which door or floor, and when.</p>

      <p>Here&#39;s how Friendly Attributes could be applied to this domain:</p>

      <pre><code>{
  <span>&#34;</span><span>alice@example.com</span><span>&#34;</span>: <span>:</span><span>entrance</span>,      
  <span>&#34;</span><span>bob@example.com</span><span>&#34;</span>: [<span>1</span>, <span>2</span>],           
  <span>&#34;</span><span>carol@example.com</span><span>&#34;</span>: <span>:</span><span>all</span>,           
  <span>&#34;</span><span>dave@example.com</span><span>&#34;</span>: [<span>1</span>, <span>:</span><span>mailroom</span>]   
  <span>&#34;</span><span>cleaning@company.com</span><span>&#34;</span>: {<span>&#34;</span><span>9am-5pm</span><span>&#34;</span>: {[<span>:</span><span>mon</span>, <span>:</span><span>tue</span>, <span>:</span><span>wed</span>, <span>:</span><span>thu</span>, <span>:</span><span>fri</span>] =&gt; <span>:</span><span>entrance</span>}}
}</code></pre>

      <p>Here are the rough implementation guidelines:</p>

      <dl>
        <dt>Strings that match email regexp become user records</dt>
        <dd><code>&#34;alice@example.com&#34;</code> converts to <code>{user: User.find_or_create_by!(email: &#34;alice@example.com&#34;)}</code></dd>
        <dt>Strings that match interval regexp become intervals</dt>
        <dd><code>&#34;9am-5pm&#34;</code> converts to <code>{start_time: 9, end_time: 17}</code></dd>
        <dt>Integers perform a floor lookup</dt>
        <dd><code>1</code> converts to <code>{access: account.floors.find_by!(number: 1)}</code></dd>
        <dt>Symbol :all is a special case</dt>
        <dd><code>:all</code> converts to <code>{access: account.accesses.all}</code></dd>
        <dt>Symbols representing days are also special cases</dt>
        <dd><code>:mon</code> converts to <code>{day: 1}</code></dd>
        <dt>Non-special symbols perform a door lookup</dt>
        <dd><code>:entrance</code> converts to <code>{door: account.doors.find_by!(name: :entrance)}</code></dd>
      </dl>

      <h3>Use with JSON, YAML?</h3>

      <p><strong>Building an API or storing data in a way that&#39;s based on Friendly Attributes Pattern is a bad idea.</strong></p>

      <p>Friendly Attributes are made primarily for <em>humans</em>. This pattern shines when you have to manually type in attributes, or you want to make a specific part of the code succinct and pretty.</p>

      <p>The repetition of attributes and slight verbosity in popular data formats, like JSON or YAML is <em>not a real problem for computers</em>. If you really need something faster go for existing binary data formats like Protocol Buffers.</p>

      <h3>Conclusion</h3>

      <p>Friendly Attributes took me a couple hours to implement, and the results have been great! Hopefully this post gives you pointers and ideas if you encounter a similar problem in your work.</p>

      <p>The idea is extracted from <a href="https://railsbilling.com">RailsBilling</a>. Check it out, it&#39;s full of <em>gems</em> like this.</p>

      <p><strong>Friendly Attributes embodies the spirit of Ruby.</strong> It&#39;s about reading and writing joyful code - made for humans, typed by humans! If you ever get to use it, I hope you enjoy it as much as I do.</p>

      <p>Happy hacking with Friendly Attributes!</p>
    </article>
  </div></div>
  </body>
</html>
