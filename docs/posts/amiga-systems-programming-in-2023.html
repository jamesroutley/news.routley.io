<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.markround.com/blog/2023/08/30/amiga-systems-programming-in-2023/">Original</a>
    <h1>Amiga Systems Programming in 2023</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          


          
  <p><strong><i aria-hidden="true"></i> Updated:</strong> <time datetime="2023-08-30T07:36:04+00:00">August 30, 2023</time></p>


        </header>
      

      <section itemprop="text">
        


        
        <p><a href="https://www.markround.com/assets/images/amiga/dev/amigaland.jpg"><picture><source srcset="/assets/generated/amiga/dev/amigaland-200-93d7ed270.webp 200w, /assets/generated/amiga/dev/amigaland-400-93d7ed270.webp 400w, /assets/generated/amiga/dev/amigaland-800-93d7ed270.webp 800w, /assets/generated/amiga/dev/amigaland-1600-93d7ed270.webp 1600w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/amigaland-200-347b2b614.jpg 200w, /assets/generated/amiga/dev/amigaland-400-347b2b614.jpg 400w, /assets/generated/amiga/dev/amigaland-800-347b2b614.jpg 800w, /assets/generated/amiga/dev/amigaland-1600-347b2b614.jpg 1600w" type="image/jpeg"/><img src="https://www.markround.com/assets/generated/amiga/dev/amigaland-800-347b2b614.jpg"/></picture></a></p>

<p>If you ever get a chance to look through the classic Amiga OS source-code still floating around some murky corners of the internet, it is a thing of beauty and astonishing capabilities. It’s an inspirational piece of computing history with unmatched capabilities for the time. Remember, this was all originally on a computer released in the 1980s with 512Kb memory, a 7Mhz 68000 16-bit CPU, and a single floppy drive with 880Kb storage. On these limited specs, AmigaOS provided a pre-emptive multi-tasking operating system, a full set of GUI primatives and built-in “Workbench” interface, expansion card auto-configuration and a fully-featured filesystem with some unique and powerful capabilities. Although to be fair, the AmigaDOS parts do literally come from a different time (and possibly planet) - but more on that later.</p>

<p>Oh and of course, there was that amazing <a href="https://en.wikipedia.org/wiki/Original_Chip_Set">chipset</a> that meant even that humble base can do things like <a href="https://www.youtube.com/watch?v=_wpXOsEm7M0" target="_blank">this</a> - while PCs of the time were basically  office boxes that occasionally bleeped and home computers still loaded games from cassette tape. There’s understandably a lot of on-line interest in those parts of the Amiga as they’re the most impressive in an obvious “wow!” way. But while that was what drew me to the Amiga when I was a kid (and the demo/cracking/bbs scene heavily influenced me) I’ve always been more of a systems geek at heart.</p>

<p>I’ve always loved building tools and platforms, and have long been fascinated with the world of operating systems. Apart from reading through the source code (where that’s legally available, of course…) I think there’s no better way to explore and understand a system - and the mindset that produced it - than to develop for it.</p>

<p>What follows is a brain-dump of what I’ve learned about developing for the AmigaOS, both on classic 68k-powered hardware to modern PowerPC systems like the <a href="https://www.markround.com/blog/2018/10/10/new-amiga-x5000/">X5000</a>. I’ll cover development environments, modern workflows like CI builds on containerised infrastructure, distribution of packages and even a look back in time before <code>C</code> existed, thanks to AmigaDOS’s odd heritage.</p>

<!-- TOC -->

<!-- END TOC -->

<h2 id="setcmd">SetCmd</h2>
<p><a href="https://www.markround.com/assets/images/amiga/dev/setcmd-window.png"><picture><source srcset="/assets/generated/amiga/dev/setcmd-window-200-023f759c5.webp 1.0x, /assets/generated/amiga/dev/setcmd-window-300.0-023f759c5.webp 1.5x, /assets/generated/amiga/dev/setcmd-window-400-023f759c5.webp 2.0x" type="image/webp"/><source srcset="/assets/generated/amiga/dev/setcmd-window-200-372f18c0f.png 1.0x, /assets/generated/amiga/dev/setcmd-window-300.0-372f18c0f.png 1.5x, /assets/generated/amiga/dev/setcmd-window-400-372f18c0f.png 2.0x" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/setcmd-window-250-372f18c0f.png"/></picture></a> 
There’s plenty of guides and videos on setting up an old-school game or demo-coding environment, but all of what follows is in the context of developing a systems tool in <code>C</code> as that’s the language of AmigaOS. I started a real-life <a href="https://www.markround.com/projects/#setcmd">project</a> partly to solve a small problem I had (switching between different versions of commands/tools at the Amiga CLI) but mainly to explore and dig deeper into the OS that influenced me so much as a teenager. <code>SetCmd</code> was the result, and is a very simple AmigaOS 4 PowerPC <a href="http://aminet.net/package/util/shell/setcmd">package</a>. I’m working (very slowly) on porting it to run on classic AmigaOS and variants but it has to be said this is my first time writing C in any meaningful capacity beyond wrestling with pointers at University. The source code is on <a href="https://github.com/markround/setcmd">GitHub</a> if you want to take a look but bear in mind despite having owned Amigas since they were released, I’m a total newbie at most of this! I wrote it to have fun, explore the AmigaOS, set up build environments and figure out how to package it up for re-distribution. I have <a href="https://www.markround.com/blog/categories/#amiga">written</a> a bit about my development setup in the past, but things have changed a fair bit since then - so without further ado, here’s my development environment and thoughts in 2023.</p>

<h2 id="sdk-updates">SDK Updates</h2>
<p>Whilst things do move at a glacial pace in the world of <a href="https://en.wikipedia.org/wiki/AmigaOS_4">AmigaOS 4/PPC</a>, there have been a few big updates. A-EON’s <a href="http://wiki.amiga.org/index.php?title=Enhancer_Software" target="_blank">Enhancer Software</a> has had several releases, each adding new applications and developer APIs. As well as shipping their own versions of key Amiga OS applications and utilities, they also now are installing several core AmigaDOS command replacements. I tend to skip the installation of these as I’ve encountered a few edge cases where they don’t <em>quite</em> behave like the original OS 4 commands, but from recent discussions online it appears as if they are preparing for their own “clean-room” re-implementation and modernisation of Amiga OS 4. Presumably in order to free themselves from the eternal legal shenanigans with Hyperion et al. I’m not going to get into that raging dumpster fire here, but it’ll be interesting to see what comes of this.</p>

<p><a href="https://www.markround.com/assets/images/amiga/dev/sdk-03.png"><picture><source srcset="/assets/generated/amiga/dev/sdk-03-200-579a9e856.webp 1.0x, /assets/generated/amiga/dev/sdk-03-300.0-579a9e856.webp 1.5x, /assets/generated/amiga/dev/sdk-03-400-579a9e856.webp 2.0x" type="image/webp"/><source srcset="/assets/generated/amiga/dev/sdk-03-200-a5839a0e7.png 1.0x, /assets/generated/amiga/dev/sdk-03-300.0-a5839a0e7.png 1.5x, /assets/generated/amiga/dev/sdk-03-400-a5839a0e7.png 2.0x" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/sdk-03-250-a5839a0e7.png"/></picture></a> 
On the Hyperion side, they released a big <a href="https://www.hyperion-entertainment.com/index.php/component/content/article/300-new-amigaos-41-sdk-5334-available-now" target="_blank">SDK Update</a> for OS 4 including updated GCC toolchains, cross-compilers, profilers and loads of updated SDKs. Bearing in mind the ancient GCC 4.x toolchain that had been in place for years it was great to have a more modern environment. On the classic Amiga front, Hyperion have also been pushing ahead with their updated AmigaOS 3.x OS for 68k-powered Amigas. Now on version 3.2.2.1 (I’ve got my boxed set of CD and <a href="https://www.markround.com/blog/2019/12/30/back-to-the-floppy/">floppy disks</a>) there have also been several NDK (“Native Developer Kit”) <a href="https://www.hyperion-entertainment.com/index.php/component/content/article/297-native-developer-kit-for-amigaos-32-ndk-32-release-3-available-for-immediate-download" target="_blank">Updates</a> providing updated APIs and tools. AmiKit also released a great “all-in-one” environment called <a href="https://www.amikit.amiga.sk/devpack">DevPack</a> which includes a huge range of languages (C, Assembly, Amos, Lua, Basic…) and NDKs all configured and ready to go. As a quick and easy way of setting up a development environment on classic Amigas, it’s hard to beat and saves a lot of manual downloading, configuring and glue-ing everything together.</p>

<h2 id="editors">Editors</h2>
<p>In my <a href="https://www.markround.com/blog/2019/08/06/my-os4-development-environment/">last update</a> 3 years ago, I’d more or-less settled on using a GUI VIM derivative. While I’m still a die-hard VIM user at $DAYJOB, I really appreciate the modern comforts of e.g. VSCode. Thanks to the amazing work of <a href="https://github.com/walkero-gr/">George Sokianos</a>, there is now a OS 4 <a href="http://os4depot.net/?function=showfile&amp;file=utility/text/edit/litexl.lha">package</a> of the awesome <a href="https://lite-xl.com/en/">Lite-XL</a> editor along with a comprehensive set of plugins. Here’s what a hacking session on my X5000 looks like:</p>

<p><a href="https://www.markround.com/assets/images/amiga/dev/setcmd.png"><picture><source srcset="/assets/generated/amiga/dev/setcmd-200-5dadd9ab5.webp 200w, /assets/generated/amiga/dev/setcmd-400-5dadd9ab5.webp 400w, /assets/generated/amiga/dev/setcmd-800-5dadd9ab5.webp 800w, /assets/generated/amiga/dev/setcmd-1600-5dadd9ab5.webp 1600w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/setcmd-200-9cc0c6e47.png 200w, /assets/generated/amiga/dev/setcmd-400-9cc0c6e47.png 400w, /assets/generated/amiga/dev/setcmd-800-9cc0c6e47.png 800w, /assets/generated/amiga/dev/setcmd-1600-9cc0c6e47.png 1600w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/setcmd-800-9cc0c6e47.png"/></picture></a></p>

<p>In that session you can see alongside LiteXL two terminal windows: I’m compiling <em>and</em> running the PowerPC and classic 68k versions of <code>setcmd</code> thanks to the cross-compilers and native “Petunia” JIT 68k emulation built into OS 4. More on that later, but while we’re talking about classic Amigas…</p>

<h2 id="native-hardware">Native hardware</h2>
<p>Emulation is fine, but nothing beats running on the actual hardware! In the <a href="https://www.markround.com/assets/images/amiga/dev/amigaland.jpg">lead image</a> to this article you can see my treasured <a href="https://www.markround.com/blog/2019/03/18/two-worlds-meet/">Amiga 1200</a> (with older 8-bit friend in the background running my <a href="https://tnfs.markround.com">TNFS site</a>) expanded with an <a href="https://www.markround.com/blog/2020/07/21/apollo-vampire-amiga-1200-review/">Apollo Vampire</a> accelerator. An Ethernet or Wifi adapter is more or less essential though when it comes to transferring data around and fortunately the Vampire card is capable of network connectivity, high-resolution display and other niceities but can easily be switched back to a more “stock” environment. I do still occasionally use my licensed copy of <a href="https://www.softwareandcircuits.com/division/amiga/products/cubic/screenshots.html">CubicIDE</a> but due to the age of this architecture, I tend to keep my tools light and have settled on the simple <a href="http://aminet.net/package/text/edit/JanoEditor">Jano</a> editor or sometimes <a href="http://www.cygnused.de/index-en.php">CygnusEd</a> for old time’s sake.</p>

<p>My build toolchain is provided by Devpack and it’s included <a href="http://sun.hasenbraten.de/vbcc/">VBCC</a> compiler. I use the <code>vbcc_target_m68k-amigaos</code> target with this <a href="https://github.com/markround/setcmd/blob/68k/src.68k/makefile">makefile</a> to build:</p>

<p><a href="https://www.markround.com/assets/images/amiga/dev/setcmd-a1200.png"><picture><source srcset="/assets/generated/amiga/dev/setcmd-a1200-200-df241286b.webp 200w, /assets/generated/amiga/dev/setcmd-a1200-400-df241286b.webp 400w, /assets/generated/amiga/dev/setcmd-a1200-800-df241286b.webp 800w, /assets/generated/amiga/dev/setcmd-a1200-1024-df241286b.webp 1024w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/setcmd-a1200-200-c80f8e9b4.png 200w, /assets/generated/amiga/dev/setcmd-a1200-400-c80f8e9b4.png 400w, /assets/generated/amiga/dev/setcmd-a1200-800-c80f8e9b4.png 800w, /assets/generated/amiga/dev/setcmd-a1200-1024-c80f8e9b4.png 1024w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/setcmd-a1200-800-c80f8e9b4.png"/></picture></a></p>

<h2 id="modern-development">Modern development</h2>
<p>I’m (sadly) not always in front of my Amigas, but these days a modern laptop and cloud-native tools offer a lot of flexibility particularly with the advanced state of emulation. I use VSCode as my editor, and a containerised cross-compiler toolchain built by - again! - George Sokianos to target both 68k and PPC platforms. I can build my project on any system capable of running OCI containers, e.g.</p>

<div><div><pre><code>docker run <span>\</span>
  <span>--user</span> <span>$UID</span>:<span>$GID</span> <span>\</span>
  <span>-v</span> ./:/opt/code <span>\</span>
  walkero/docker4amigavbcc:latest-m68k-amd64 <span>\</span>
  make <span>-f</span> makefile.docker
</code></pre></div></div>

<p>Testing and running the code is made easy by the very advanced state of emulators. On Windows, <a href="https://www.winuae.net">WinUAE</a> is the gold standard and can emulate everything from an original 1985-vintage A1000 up to modern systems with PowerPC accelerators, graphics cards and other devices. I have it multi-booting into clean Hyperion and Commodore/classic OS environments, with my source code directory shared as a virtual hard-drive:</p>

<p><a href="https://www.markround.com/assets/images/amiga/dev/laptop.png"><picture><source srcset="/assets/generated/amiga/dev/laptop-200-f0e9958be.webp 200w, /assets/generated/amiga/dev/laptop-400-f0e9958be.webp 400w, /assets/generated/amiga/dev/laptop-800-f0e9958be.webp 800w, /assets/generated/amiga/dev/laptop-1600-f0e9958be.webp 1600w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/laptop-200-7b38685a9.png 200w, /assets/generated/amiga/dev/laptop-400-7b38685a9.png 400w, /assets/generated/amiga/dev/laptop-800-7b38685a9.png 800w, /assets/generated/amiga/dev/laptop-1600-7b38685a9.png 1600w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/laptop-800-7b38685a9.png"/></picture></a></p>

<p>I can compile in seconds with Docker, and then straight away test the resulting binary in my emulated Amiga. Source-code is kept up to date between systems using Git; on the Amiga X5000 I use the port of SimpleGit, which is now bundled with the latest Hyperion SDK under <code>SDK:c/sgit</code>. I haven’t yet found a suitable Git solution for the classic Amigas, so on those I use a makeshift AmigaDOS shell script that uses <a href="http://www.onyxsoft.se/backup.html">Backup</a> to copy files over to a network mount in an <code>rsync</code> -like fashion.</p>

<p>I also keep meaning to test running AmigaOS 4.1 under <a href="https://www.amiga-news.de/en/news/AN-2023-03-00113-EN.html">QEMU</a> as support for this has greatly improved and looks a lot simpler than the currently convoluted process of getting “classic OS 4” running on an emulated 68k Amiga with PPC accelerator configured. But for now, the WinUAE approach is working pretty well.</p>

<p>Another advantage of having a containerised build-chain is that combined with Git and <a href="https://drone.io">Drone</a> running on my personal Kubernetes clusters, I can build and package my code with a simple <code>git push</code> wherever I am:</p>

<p><a href="https://www.markround.com/assets/images/amiga/dev/drone.png"><picture><source srcset="/assets/generated/amiga/dev/drone-200-c8bffc6c3.webp 200w, /assets/generated/amiga/dev/drone-400-c8bffc6c3.webp 400w, /assets/generated/amiga/dev/drone-800-c8bffc6c3.webp 800w, /assets/generated/amiga/dev/drone-1600-c8bffc6c3.webp 1600w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/drone-200-a1132c150.png 200w, /assets/generated/amiga/dev/drone-400-a1132c150.png 400w, /assets/generated/amiga/dev/drone-800-a1132c150.png 800w, /assets/generated/amiga/dev/drone-1600-a1132c150.png 1600w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/drone-800-a1132c150.png"/></picture></a></p>

<h2 id="amigados-is-weird">AmigaDOS is weird</h2>
<p>Although AmigaOS is frequently lauded for it’s sophistication and elegance, there is a notable “oddness” about the AmigaDOS components which handle storage I/O, devices and filesystems. The original developers of the Amiga had an ambitious DOS system planned, but in the end Commodore had to purchase the <a href="https://en.wikipedia.org/wiki/TRIPOS">Tripos</a> operating system and port parts of it to the Amiga due to deadline challenges. This mismatch is all the more pronounced as Tripos was written in <a href="https://en.wikipedia.org/wiki/BCPL">BCPL</a> - which in turn, influenced the <code>B</code> programming language which begat the <code>C</code> we all know and… well, tolerate, in my case. So it really is looking back into computing history and remnants of this still remain even in the “modern” AmigaOS 4.x and other derivatives.</p>

<p>Once you start diving into AmigaDOS code, you end up face-to-face with this legacy and need to convert back and forth with BCPL and C data-types. For example, BCPL strings are not <code>NULL</code>-terminated, instead they have a length in the first byte and then the characters follow. And pointers are similarly alien. This is why my code has stuff like this littered through it:</p>

<div><div><pre><code>    <span>// Convert the new node to a BPTR</span>
    <span>new_node_bptr</span> <span>=</span> <span>MKBADDR</span><span>(</span><span>new_node</span><span>);</span>

    <span>// Set the new path</span>
    <span>cli</span><span>-&gt;</span><span>cli_CommandDir</span> <span>=</span> <span>new_node_bptr</span><span>;</span>
</code></pre></div></div>

<p>As the NDK include file <code>dos.h</code> explains: “All BCPL data must be long word aligned.  BCPL pointers are the long word address (i.e byte address divided by 4 (»2))”. It also includes helper functions like <code>MKBADDR</code> to help with the conversion as most DOS system calls use BCPL pointers in arguments:</p>

<div><div><pre><code><span>/* Convert BPTR to typical C pointer */</span>
<span>#define BADDR(x)	((APTR)((ULONG)(x) &lt;&lt; 2))
</span><span>/* Convert address into a BPTR */</span>
<span>#define MKBADDR(x)	(((LONG)(x)) &gt;&gt; 2)
</span></code></pre></div></div>

<p>All in all, a fascinating look back into an obscure branch of computing history, but it hasn’t furthered my appreciation of pointers any!</p>

<h2 id="distribution">Distribution</h2>
<p><a href="https://www.markround.com/assets/images/amiga/dev/dist.png"><picture><source srcset="/assets/generated/amiga/dev/dist-200-87c52ef2f.webp 200w, /assets/generated/amiga/dev/dist-400-87c52ef2f.webp 400w, /assets/generated/amiga/dev/dist-800-87c52ef2f.webp 800w, /assets/generated/amiga/dev/dist-1308-87c52ef2f.webp 1308w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/dist-200-b29548dae.png 200w, /assets/generated/amiga/dev/dist-400-b29548dae.png 400w, /assets/generated/amiga/dev/dist-800-b29548dae.png 800w, /assets/generated/amiga/dev/dist-1308-b29548dae.png 1308w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/dist-800-b29548dae.png"/></picture></a></p>

<p>If you want to distribute your project to a wider audience, there’s a few Amiga-specific things you can do that makes life much easier for people running AmigaOS. These all make use of some pretty cool bits of Amiga technology and have been widely adopted by native software since their introduction in the early 1990s.</p>

<h3 id="archive">Archive</h3>
<p>Just use LHA format archives. It’s the standard compression tool on Amigas and even though there are modern (and technically better) alternatives, <code>.lha</code> files are as ubiquitous as e.g. <code>.zip</code> or <code>.tar.gz</code> packages on other systems and can also be handled by low-spec machines. There are ports of CLI tools and GUIs available on all platforms to handle these archives and while the syntax can be a little different, it’s quite easy to use. See my <a href="https://github.com/markround/setcmd/blob/68k/packaging/make_lha">AmigaDOS script</a> that builds the SetCmd release artifact for a practical example.</p>

<h3 id="documentation">Documentation</h3>
<p>Along with a basic README.txt, it’s a great practice to distribute more detailed documentation in <a href="https://wiki.amigaos.net/wiki/AmigaGuide_101">AmigaGuide</a> format. Another area the Amiga was way ahead of it’s time - AmigaGuide is a hyper-text format commonly used for application manuals although people have even used it to publish <a href="http://www.whatiff.info">disk magazines</a>! Introduced in 1992, the bundled tools on any AmigaOS (or clone/derivative) can read and use AmigaGuide as standard so you can include formatting, links and other content in your documentation. You can see the AmigaGuide docs I include with SetCmd in the screenshot above, or view the <a href="https://github.com/markround/setcmd/blob/68k/SetCmd.guide">source</a> to see what the syntax looks like.</p>

<p>It’s pretty simple to write and is much like any other markdown or formatting code. You can set basic parameters:</p>

<figure><pre><code data-lang="text"><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>@Width 72
@wordwrap
</pre></td></tr></tbody></table></code></pre></figure>

<p>Documents have “Nodes” which can be linked to, e.g.</p>

<figure><pre><code data-lang="text"><table><tbody><tr><td><pre>1
2
</pre></td><td><pre>@Node About &#34;About SetCMD&#34; 
@{&#34;About&#34; Link About}
</pre></td></tr></tbody></table></code></pre></figure>

<p>And formatting is much like HTML with opening and closing tags:</p>

<figure><pre><code data-lang="text">@{b}@{u} Bold and Underlined! @{uu}@{ub}</code></pre></figure>

<h3 id="installer">Installer</h3>
<p><a href="https://www.markround.com/assets/images/amiga/setcmd/setcmd-install-dev02.png"><picture><source srcset="/assets/generated/amiga/setcmd/setcmd-install-dev02-200-7c58ead12.webp 1.0x, /assets/generated/amiga/setcmd/setcmd-install-dev02-300.0-7c58ead12.webp 1.5x, /assets/generated/amiga/setcmd/setcmd-install-dev02-400-7c58ead12.webp 2.0x" type="image/webp"/><source srcset="/assets/generated/amiga/setcmd/setcmd-install-dev02-200-ca320d46f.png 1.0x, /assets/generated/amiga/setcmd/setcmd-install-dev02-300.0-ca320d46f.png 1.5x, /assets/generated/amiga/setcmd/setcmd-install-dev02-400-ca320d46f.png 2.0x" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/setcmd/setcmd-install-dev02-250-ca320d46f.png"/></picture></a></p>

<p>A fantastic addition to AmigaOS, the system installer utility reads a developer-provided script which handles copying files, comparing versions, modifying system scripts and so on, in a standardized fashion. You can pass useful information and configuration which controls the Installer tool through standard Amiga tooltypes, and it uses a sort of LISP-ey syntax which again runs on all Amigas and derivatives. The syntax does some getting used to, but the best source of documentation is the AmigaGuide documentation found in the <a href="http://aminet.net/package/util/misc/Installer-43_3">Installer dev package</a>. As an example, here’s an excerpt of the block of code which copies the <code>setcmd</code> program file over to a previously created directory:</p>

<figure><pre><code data-lang="lisp"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>(</span><span>copyfiles</span>
  <span>(</span><span>source</span> <span>&#34;setcmd&#34;</span><span>)</span>
  <span>(</span><span>dest</span> <span>#</span><span>dname</span><span>)</span>
  <span>(</span><span>prompt</span> <span>(</span><span>&#34;Copy SetCmd program file?&#34;</span><span>))</span>
  <span>(</span><span>confirm</span> <span>&#34;expert&#34;</span><span>)</span>
  <span>(</span><span>all</span><span>)</span>
  <span>(</span><span>help</span> <span>@copyfiles-help</span><span>)</span>
<span>)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And for running commands, you can use the <code>run</code> command, along with <code>cat</code> (short for “concatenate”) to build up the command string :</p>

<div><div><pre><code><span>(</span><span>run</span> <span>(</span><span>cat</span> <span>&#34;C:MakeLink FROM &#34;</span> <span>#</span><span>dname</span> <span>&#34;/cmds/setcmd/release TO SETCMD:setcmd SOFT&#34;</span><span>))</span>
</code></pre></div></div>

<p>I found the best approach was to examine other Installer scripts to get a feel for common practices and idioms. Here’s my simplistic <a href="https://github.com/markround/setcmd/blob/68k/Install_SetCmd">Install_SetCmd</a> script, and if you want to see something more complex, there’s always the AmigaOS installation scripts, or the <a href="https://sourceforge.net/projects/qtamigaosnative/files/release/">Qt installer</a> for OS 4 which taught me a lot.</p>

<h3 id="file-sites">File Sites</h3>
<p>The Amiga doesn’t have a universal package manager, so files are usually downloaded manually and installed from the <code>.lha</code> archives. The go-to place for Amiga software for all systems is <a href="https://aminet.net">AmiNet</a>. It’s the biggest repository of Amiga packages on the internet (and, at one point in the mid-90s was actually the largest software repository of any platform) and now also supports hosting packages for Amiga OS 4, MorphOS and AROS alongside classic 68k fare. There are also smaller, platform-focused sites for each platform e.g. <a href="http://os4depot.net">os4depot.net</a> for OS 4, <a href="https://www.morphos-storage.net">morphos-storage.net</a> for MorphOS and so on.</p>

<p>Getting your package uploaded and accepted into the repository is broadly the same for all these: You FTP your package up according to the naming standards, and supply a <code>Readme</code> file which provides the <a href="http://wiki.aminet.net/index.php/The_Readme_file">required metadata</a> like this excerpt in AmiNet format:</p>

<figure><pre><code data-lang="yaml"><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>Short</span><span>:</span>        <span>Switch between versions of software</span>
<span>Author</span><span>:</span>       <span><a href="https://www.markround.com/cdn-cgi/l/email-protection" data-cfemail="c0a1ada9a7a180ada1b2abb2afb5aea4eea3afad">[email protected]</a> (Mark Dastmalchi-Round)</span>
<span>Type</span><span>:</span>         <span>util/shell</span>
<span>Version</span><span>:</span>      <span>1.1.0</span>
<span>Architecture</span><span>:</span> <span>ppc-amigaos &gt;= 4.0.0</span>
<span>Distribution</span><span>:</span> <span>Aminet</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are some Amiga-native GUI tools that assist with creating these files, but the specs e.g. for <a href="http://os4depot.net/?function=ftpinfo">os4depot.net</a> are pretty straight forward. And here’s the end result - My package available on <a href="http://os4depot.net/?function=showfile&amp;file=utility/shell/setcmd.lha">os4depot.net</a> and <a href="http://aminet.net/package/util/shell/setcmd">aminet</a>.</p>

<h2 id="external-documentation">External Documentation</h2>
<p><a href="https://www.markround.com/assets/images/amiga/dev/docs.png"><picture><source srcset="/assets/generated/amiga/dev/docs-200-d61bd6578.webp 200w, /assets/generated/amiga/dev/docs-400-d61bd6578.webp 400w, /assets/generated/amiga/dev/docs-800-d61bd6578.webp 800w, /assets/generated/amiga/dev/docs-1441-d61bd6578.webp 1441w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/docs-200-9c380033f.png 200w, /assets/generated/amiga/dev/docs-400-9c380033f.png 400w, /assets/generated/amiga/dev/docs-800-9c380033f.png 800w, /assets/generated/amiga/dev/docs-1441-9c380033f.png 1441w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/docs-800-9c380033f.png"/></picture></a>
When trying to learn or re-learn everything from C to AmigaDOS scripting, I found a few great resources. However, as with most things in Amiga-land, there’s an extraordinarily high “bus factor” for many websites and my biggest recommendation is to use native tools or save local copies of anything you find! With that said, here’s my essential Amiga bookmarks:</p>

<ul>
  <li>
    <p>Autodocs references. There’s lots of websites where you can browse the auto-generated docs from the SDK header files, like <a href="http://amigadev.elowar.com">this</a> with clickable links to jump between things. If I’m actually at an Amiga though, there are some useful native tools I prefer that can index and search through the local headers. The screenshot above shows the standard “AutoDoc Reader” freeware tool viewing the equivalent of a <code>man</code> page for the AmigaDOS library, alongside the AmigaGuide Installer language reference.</p>
  </li>
  <li>
    <p><a href="http://www.pjhutchison.org/tutorial/amiga_c.html">http://www.pjhutchison.org/tutorial/amiga_c.html</a> - amazing site. This is what inspired me to pick up a compiler again and get to work. There’s a great refresher on the C language itself, and then it dives into Amiga-specific coding with everything from low-level library access, sound and GUI programming and more.</p>
  </li>
  <li><a href="https://wiki.amigaos.net/wiki/DeveloperDoc:Main">Amiga OS Dev wiki</a> is a goldmine, although it can take a little searching to find what you’re after. It’s mostly OS 4-focused but because all Amiga systems share a common ancestor it’s usually pretty applicable to all platforms. Specific articles that I found useful include:
    <ul>
      <li><a href="https://wiki.amigaos.net/wiki/Migration_Guide">OS 4 Migration Guide</a></li>
      <li><a href="https://wiki.amigaos.net/wiki/Programming_in_the_Amiga_Environment">Programming in the Amiga Environment</a></li>
      <li><a href="https://wiki.amigaos.net/wiki/Fundamental_Types">Fundamental Types</a></li>
    </ul>
  </li>
  <li>And lastly, there are great threads I constantly found on <a href="https://www.amigans.net">amigans.net</a> which is where a lot of OS 4/”Next Gen” technical discussion happens. For classic systems, I found the Coders discussions on the <a href="https://eab.abime.net/forumdisplay.php?f=116">English Amiga Board</a> an invaluable resource.</li>
</ul>

<h2 id="the-way-forward-is-back-">The way forward is back ?</h2>
<p><a href="https://www.markround.com/assets/images/amiga/dev/morphos.png"><picture><source srcset="/assets/generated/amiga/dev/morphos-200-e475fa26b.webp 1.0x, /assets/generated/amiga/dev/morphos-300.0-e475fa26b.webp 1.5x, /assets/generated/amiga/dev/morphos-400-e475fa26b.webp 2.0x" type="image/webp"/><source srcset="/assets/generated/amiga/dev/morphos-200-794486915.png 1.0x, /assets/generated/amiga/dev/morphos-300.0-794486915.png 1.5x, /assets/generated/amiga/dev/morphos-400-794486915.png 2.0x" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/morphos-250-794486915.png"/></picture></a></p>

<p>When I started this project, it was really a way to get acquainted with my new X5000. Since then, I’ve decided to port my codebase back to the classic Amiga, as well as explore porting over to other Amiga-like systems such as <a href="https://www.morphos-team.net">MorphOS</a> and <a href="https://en.wikipedia.org/wiki/AROS_Research_Operating_System">AROS</a>. This leads to some choices: From a packaging and distribution point of view, a 68k binary is pretty much the universal standard in Amiga land. It can run natively on classic Amigas, and modern systems like AmigaOS 4.x and MorphOS can run 68k binaries through translation. In a method similar to how Apple has handled the transition between processors in the Mac, it’s a pretty seamless experience and I run a lot of classic 68k software on my X5000. As long as you aren’t “banging on the metal” it works really well and <a href="https://www.markround.com/blog/2018/10/30/classic-amiga-emulation-on-the-x5000/#classic-68k-binaries">integrates smoothly</a> with the rest of the system.</p>

<p>The original 68k AmigaOS from Commodore is also pretty much the standard for source-code compatibility; code targetting this release can be built on most of the derivatives and later systems with very little (if any) modification. On AmigaOS 4 for example, you can simply add <code>-D__USE_INLINE__</code> to your makefiles and in theory build from a common codebase. If you start the other way as I did and write initially targetting AmigaOS 4, it’s harder to port to other systems.</p>

<p>For example, I originally followed the AmigaOS 4 programming style which favours prefixing library calls with interface names. This isn’t compatible with any other system, so the easiest way to port this to more Amiga-like platforms is to refactor this code back to the classic style of calling system functions. I do plan on building platform-specific binaries using <code>#defines</code> so I can for example use functions like <code>dos.library/AddCmdPathNode</code> on OS 4 that I otherwise have to manually implement, and while a lot of higher-level layers (like e.g. MUI for building graphical applications) are shared across platforms this is probably the best bet for adding specific features from one platform that aren’t available on others.</p>

<p>Honestly though, at this point if you want to just get started I’d have to suggest you target classic AmigaOS compatibility and build a 68k binary. I’d personally target AmigaOS 3.x or 2.1 if you want to support a wider range of truly vintage systems; 1.x is facinating from a retro-geek perspective but lacks a lot of the nice features that came with later systems. Everything else like the installer, archive format, documentation format and so on is cross-platform anyway and supported from OS 2.1 and up.</p>

<p>MorphOS, AROS and OS 4 are really fun systems to explore, and I highly recommend checking them out if this article has whetted your appetite (and you can find a system to run them on!) but classic is the easiest way to get your code out to the wider world and ironically provides a better code-base for future porting than my “working backwards” approach.</p>

<h2 id="wrap-up">Wrap-up</h2>
<p><a href="https://www.markround.com/assets/images/amiga/dev/blog.png"><picture><source srcset="/assets/generated/amiga/dev/blog-200-b74f68cd8.webp 200w, /assets/generated/amiga/dev/blog-400-b74f68cd8.webp 400w, /assets/generated/amiga/dev/blog-800-b74f68cd8.webp 800w, /assets/generated/amiga/dev/blog-1600-b74f68cd8.webp 1600w" type="image/webp"/><source srcset="/assets/generated/amiga/dev/blog-200-93cedf6c3.png 200w, /assets/generated/amiga/dev/blog-400-93cedf6c3.png 400w, /assets/generated/amiga/dev/blog-800-93cedf6c3.png 800w, /assets/generated/amiga/dev/blog-1600-93cedf6c3.png 1600w" type="image/png"/><img src="https://www.markround.com/assets/generated/amiga/dev/blog-800-93cedf6c3.png"/></picture></a>
So that’s about the sum total of what I’ve picked up over the last few years, anyway! I still enjoy working on my Amigas when I get some “hacking on code in the evening” time, and in particular I find AmigaOS 4 on my X5000 a refreshing blend of retro appeal and just about enough modern convenience to use it for development tasks, or even for writing this article itself. My A1200 continues to impress me with how much utility there is in such a small box and is a wonderful distraction from the modern era of bloated systems and applications. It is perhaps an evolutionary dead-end, but it’s still a lot of fun and is one of the rare occasions these days where I feel actually in control of <em>my</em> computer. Working backwards in time from OS 4.1 to my classic Amigas has also really given me a greater insight and appreciation for what the Amiga engineers managed to pull off back then. If you’re in any way interested in computer history - or simply want to give something truly different a try - you should definitely check out AmigaOS. I hope this quick <code>type BRAIN: &gt; WEB:</code> dump provides you with some good starting points, and maybe gets you coding too!</p>

        
      </section>

      

      


      
  

    </div></div>
  </body>
</html>
