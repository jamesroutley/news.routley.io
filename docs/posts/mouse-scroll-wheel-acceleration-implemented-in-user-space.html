<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/albertz/mouse-scroll-wheel-acceleration-userspace">Original</a>
    <h1>Mouse scroll wheel acceleration, implemented in user space</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<h2 tabindex="-1" dir="auto"><a id="user-content-background-mouse-scroll-wheel-acceleration" aria-hidden="true" href="#background-mouse-scroll-wheel-acceleration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Background: Mouse scroll wheel acceleration</h2>
<p dir="auto">What is that?</p>
<p dir="auto">It&#39;s the same as mouse cursor movement acceleration,
but for the mouse scroll wheel.</p>
<p dir="auto">This makes esp sense for devices where scrolling is continuous,
such as the trackpad
(but even if the scrolling is discrete, like other mouse, it makes sense).
In any case you want to be able to scroll slowly
(e.g. pixel by pixel, or maybe max only a couple of lines).
If you are in a very long document / webpage,
you also want to be able to scroll very fastly.
It is not possible to have both slow and fast scrolling
without acceleration.
With acceleration, this becomes very natural.</p>
<p dir="auto">If you have used MacOSX, you have that enabled.
You might not even have noticed,
as this feels very natural.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-non-macosx-support" aria-hidden="true" href="#non-macosx-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Non-MacOSX support</h2>
<p dir="auto">Unfortunately, this is not supported yet in other desktop operating systems
(Linux or Windows)
(it is supported on iOS and Android though).
When you switch from MacOSX to Linux or Windows,
you will probably greatly miss this.
(If you have never used MacOSX much,
you might not have gotten used to it,
and might not even know what you miss.)</p>
<p dir="auto">As this is not implemented in the OS,
some applications and frameworks slowly
start to add their own support for it.
This is really a bad solution,
as it means that the behavior will be inconsistent from app to app.
E.g. GTK has some support (<a href="https://gitlab.gnome.org/GNOME/gtk/blob/c734c7e9188b56f56c3a504abee05fa40c5475ac/gtk/gtkrange.c#L3065-3073" rel="nofollow">here</a>),
Firefox has some support (I think only trackpad, <a href="https://searchfox.org/mozilla-central/rev/029d9d2477ef0232bb08db94696badddec4d5bda/gfx/layers/apz/src/AsyncPanZoomController.cpp#2572" rel="nofollow">here</a>).</p>
<p dir="auto">If you want to do it right,
it&#39;s still not so clear where exactly this should be implemented.
Long time ago (2010),
I implemented a patch for xf86-input-mouse (<a href="https://bugs.freedesktop.org/show_bug.cgi?id=29905" rel="nofollow">here</a>).
This code used a similar acceleration logic
as the mouse cursor movement acceleration.
In Xorg/X11, you get discrete button press events for scroll events,
which made it a bit ugly.
The discussion was mostly about whether this is useful at all,
and also where to actually implement it,
where the conclusion was mostly either in libinput,
or in xf86-input-libinput.
A new proposal for libinput mouse wheel acceleration
was opened <a href="https://gitlab.freedesktop.org/libinput/libinput/-/issues/7" rel="nofollow">here</a>.
As continuous scrolling and high resolution scrolling
becomes more widely used,
corresponding support in libinput for
<a href="https://gitlab.freedesktop.org/libinput/libinput/-/merge_requests/139" rel="nofollow">high-resolution scroll wheel support</a>
was merged now (2021).
This was blocking any further development on the scroll acceleration.
Which probably makes sense, as a clean high resolution API
makes any implementation of scroll acceleration much cleaner.
However, it is also slightly problematic,
as applications which do not support the new high-res scroll API
will use the old API.</p>
<p dir="auto">For reference, in MacOSX, this is deeply implemented in the kernel
(see <a href="https://stackoverflow.com/questions/44196338/where-is-mouse-cursor-movement-acceleration-and-scroll-wheel-acceleration-implem" rel="nofollow">here</a>),
specifically in IOHIDFamily (e.g. see <a href="https://github.com/apple-oss-distributions/IOHIDFamily/blob/c56e1c1b2469d9956a585cc2518c8f0c51b5809d/IOHIDSystem/IOHIPointing.cpp#L25">here</a>).</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-user-space-implementation" aria-hidden="true" href="#user-space-implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>User space implementation</h2>
<p dir="auto">I just want to have that support now, on my desktop.</p>
<p dir="auto">How?</p>
<p dir="auto">We can just send extra scroll events,
and basically replicate the logic of my original xf86-input-mouse patch.</p>
<p dir="auto">This uses <a href="https://pypi.org/project/pynput/" rel="nofollow">pynput</a>
both to listen to scroll events,
and also to send out further scroll events.</p>
<p dir="auto">Pynput supports all the major desktop platforms
like X11, Wayland, MacOSX and Windows.
It even works on MacOSX in addition to the OS scroll acceleration,
such that you can further increase the acceleration.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-dependencies" aria-hidden="true" href="#dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dependencies</h2>
<div data-snippet-clipboard-copy-content="pip install -r requirements.txt"><pre><code>pip install -r requirements.txt
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Usage</h2>
<p dir="auto">You can customize the behavior with two numeric values.
Example:</p>
<div data-snippet-clipboard-copy-content="./main.py -v --exp 0.4 --multiplier 1.2"><pre><code>./main.py -v --exp 0.4 --multiplier 1.2
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-settings" aria-hidden="true" href="#settings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Settings</h2>
<ul dir="auto">
<li><code>exp</code>: the exponential factor</li>
<li><code>multiplier</code>: additional multiplier. if this is &gt;1, it means that every single scroll event will always get multiplied by this factor</li>
</ul>
<p dir="auto">The formula is:</p>
<div data-snippet-clipboard-copy-content="m = user_scroll_speed ** exp
target_scroll_speed = user_scroll_speed * m * multiplier"><pre><code>m = user_scroll_speed ** exp
target_scroll_speed = user_scroll_speed * m * multiplier
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Installation</h2>
<p dir="auto">If you found values that work for you, you can install
the script as a systemd user unit (only on Linux):</p>

<p dir="auto">This will create a configuration file in
<code>~/.config/mouse-scroll-wheel-accelerator/config.py</code>.
Enter your preferred values there.</p>
<p dir="auto">The systemd unit can then be controlled like this:</p>
<div data-snippet-clipboard-copy-content="systemctl enable --now --user mouse-scroll-wheel-accelerator
systemctl status --user mouse-scroll-wheel-accelerator
systemctl restart --user mouse-scroll-wheel-accelerator"><pre><code>systemctl enable --now --user mouse-scroll-wheel-accelerator
systemctl status --user mouse-scroll-wheel-accelerator
systemctl restart --user mouse-scroll-wheel-accelerator
</code></pre></div>
</article>
          </div></div>
  </body>
</html>
