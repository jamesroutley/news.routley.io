<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ggandor/leap.nvim">Original</a>
    <h1>Leap: Neovim’s Answer to the Mouse</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ggandor/leap.nvim/blob/media/kangaroo.png?raw=true"><img width="150" height="85" src="https://github.com/ggandor/leap.nvim/raw/media/kangaroo.png?raw=true"/></a></p>

<p dir="auto">Leap is a general-purpose motion plugin for <a href="https://neovim.io/" rel="nofollow">Neovim</a>, with
the ultimate goal of establishing a new standard interface for moving around in
the visible editor area in Vim-like editors.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ggandor/leap.nvim/blob/media/showcase.gif?raw=true"><img src="https://github.com/ggandor/leap.nvim/raw/media/showcase.gif?raw=true" alt="showcase" data-animated-image=""/></a></p>
<h3 dir="auto"><a id="user-content-how-to-use-it-tldr" aria-hidden="true" href="#how-to-use-it-tldr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How to use it (TL;DR)</h3>
<p dir="auto">Leap allows you to jump to any positions in the visible window / tab page area
by entering a 2-character search pattern, and then potentially a &#34;label&#34;
character to choose among multiple matches, similar to
<a href="https://github.com/justinmk/vim-sneak">Sneak</a>. The novel idea in Leap is its
&#34;clairvoyant&#34; ability: it maps possible futures, and shows you which key(s) you
will need to press <em>before</em> you actually need to do that.</p>
<ul dir="auto">
<li>Initiate the search in the forward (<code>s</code>) or backward (<code>S</code>) direction, or in
the other windows (<code>gs</code>).</li>
<li>Start typing a 2-character pattern (<code>{c1}{c2}</code>).</li>
<li>After typing the first character, you see &#34;labels&#34; appearing next to some of
the <code>{c1}{?}</code> pairs. You cannot <em>use</em> the labels yet.</li>
<li>Enter <code>{c2}</code>. If the pair was not labeled, then voilà, you&#39;re already there.
No need to be bothered by remaining labels, just continue editing.</li>
<li>Else: select a label. In case of multiple groups, first switch to the desired
one, using <code>&lt;space&gt;</code> (step back with <code>&lt;tab&gt;</code>, if needed).</li>
</ul>
<h3 dir="auto"><a id="user-content-why-is-this-method-cool" aria-hidden="true" href="#why-is-this-method-cool"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why is this method cool?</h3>
<p dir="auto">It is <strong>ridiculously fast</strong>: leaping to literally anywhere on the screen rarely
takes more than 4 keystrokes in total, that can be typed in one go. Often 3 is
enough.</p>
<p dir="auto">At the same time, it <strong>reduces mental effort to almost zero</strong>:</p>
<ul dir="auto">
<li>
<p dir="auto">You <em>don&#39;t have to weigh alternatives</em>: a single universal motion type can be
used in all non-trivial situations.</p>
</li>
<li>
<p dir="auto">You <em>don&#39;t have to compose in your head</em>: one command achieves one logical
movement.</p>
</li>
<li>
<p dir="auto">You <em>don&#39;t have to be aware of the context</em>: the eyes can keep focusing on the
target the whole time.</p>
</li>
<li>
<p dir="auto">You <em>don&#39;t have to make decisions on the fly</em>: the sequence you should enter
is determined from the very beginning.</p>
</li>
<li>
<p dir="auto">You <em>don&#39;t have to pause in the middle</em>: if typing at a moderate speed, at
each step you already know what the immediate next keypress should be, and
your mind can process the rest in the background.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-down-the-kangaroo-hole" aria-hidden="true" href="#down-the-kangaroo-hole"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Down the kangaroo hole</h3>
<p dir="auto">This was just a teaser - mind that Leap is extremely flexible, and offers much
more beyond the defaults: you can configure it to resemble other similar
plugins, extend it with custom targeting methods, and even do arbitrary actions
with the selected target(s) - read on to dig deeper.</p>
<ul dir="auto">
<li><a href="#design-considerations-in-detail">Design considerations in detail</a></li>
<li><a href="#background">Background</a></li>
<li><a href="#status">Status</a></li>
<li><a href="#faq">FAQ</a></li>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#extending-leap">Extending Leap</a></li>
<li><a href="#plugins-using-leap">Plugins using Leap</a></li>
</ul>
<h2 dir="auto"><a id="user-content-design-considerations-in-detail" aria-hidden="true" href="#design-considerations-in-detail"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Design considerations in detail</h2>
<h3 dir="auto"><a id="user-content-the-ideal" aria-hidden="true" href="#the-ideal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The ideal</h3>
<p dir="auto">Premise: jumping from point A to B on the screen should not be some <a href="https://www.vimgolf.com/" rel="nofollow">exciting
puzzle</a>, for which you should train yourself; it
should be a <em>non-issue</em>. An ideal keyboard-driven interface would impose almost
<strong>no more cognitive burden than using a mouse</strong>, without the constant
context-switching required by the latter.</p>
<p dir="auto">That is, <strong>you do not want to think about</strong></p>
<ul dir="auto">
<li><strong>the context</strong>: it should be enough to look at the target, and nothing else
(<g-emoji alias="left_right_arrow" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2194.png">↔</g-emoji> vanilla Vim motion combinations using relative line numbers and/or repeats)</li>
<li><strong>the command</strong>: we need one fundamental targeting method that can bring you
anywhere: a &#34;jetpack&#34; instead of a &#34;railway network&#34; (<g-emoji alias="left_right_arrow" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2194.png">↔</g-emoji> EasyMotion and its
derivatives)</li>
<li><strong>the steps</strong>: the motion should be atomic (<g-emoji alias="left_right_arrow" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2194.png">↔</g-emoji> Vim motion combos), and you
should be able to type the sequence in one go, without having to make
semi-conscious decisions on the fly (&#34;Shall I start a <code>&lt;C-g&gt;</code> streak, or try
one more input character?&#34;), or instantly react to events (labels appearing).</li>
</ul>
<p dir="auto">All the while using <strong>as few keystrokes as possible</strong>, and getting distracted by
<strong>as little incidental visual noise as possible</strong>.</p>
<h3 dir="auto"><a id="user-content-how-do-we-measure-up" aria-hidden="true" href="#how-do-we-measure-up"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How do we measure up?</h3>
<p dir="auto">It is obviously impossible to achieve all of the above at the same time, without
some trade-offs at least; but Leap comes pretty close, occupying a sweet spot in
the design space.</p>
<p dir="auto">The one-step shift between perception and action - that is, ahead-of-time
labeling - cuts the Gordian knot: while the input sequence can be extended
dynamically, to scale to any number of targets, it still behaves as if it would
be an already known pattern, that you just have to type out. Leaping is like
<code>/?</code> search on some kind of autopilot, where you know it in advance when to
finish.</p>
<p dir="auto">Fortunately, a 2-character search pattern - the shortest one with which we can
play this trick - is also long enough to sufficiently narrow down the matches in
the vast majority of cases (as opposed to just one character). It is very rare
that you should type more than 3 characters altogether to reach a given target.</p>
<h3 dir="auto"><a id="user-content-auxiliary-principles" aria-hidden="true" href="#auxiliary-principles"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Auxiliary principles</h3>
<ul dir="auto">
<li>
<p dir="auto">Optimize for the common case (not the pathological): a good example of this is
the Sneak-like &#34;one-character labels in multiple groups&#34; approach (instead of
using arbitrary-length labels), which can become awkward for, say, 200
targets, but usually more comfortable, eliminates all kinds of edge cases and
implementation problems, and allows for features like
<a href="#extending-leap">multiselect</a>.</p>
</li>
<li>
<p dir="auto"><a href="http://vimcasts.org/blog/2012/08/on-sharpening-the-saw/" rel="nofollow">Sharpen the saw</a>:
build on the native interface, and aim for synergy as much as possible. The
plugin supports macros, operators, dot-repeat (<code>.</code>), inclusive/exclusive
toggle (<code>v</code>), multibyte text and
<a href="http://vimdoc.sourceforge.net/htmldoc/mbyte.html#mbyte-keymap" rel="nofollow">keymaps</a>
(language mappings), autocommands via <code>User</code> events, among others, and intends
to continuously improve in this respect.</p>
</li>
<li>
<p dir="auto"><a href="https://cacm.acm.org/magazines/2018/11/232214-a-look-at-the-design-of-lua/fulltext" rel="nofollow">Mechanisms instead of
policies</a>
(or &#34;be opinionated, but not stubborn&#34;): aim for a small, maintainable core,
with reasonable defaults; at the same time, keep the plugin flexible and
future-proof via <a href="#extending-leap">extension points</a>.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-background" aria-hidden="true" href="#background"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Background</h2>
<p dir="auto">Leap is a reboot of <a href="https://github.com/ggandor/lightspeed.nvim">Lightspeed</a>; a
streamlined but in many respects enhanced version of its ancestor. Compared to
Lightspeed, Leap:</p>
<ul dir="auto">
<li>gets rid of some gimmicks with a low benefit/cost ratio (like Lightspeed&#39;s
&#34;shortcut&#34; labels), but works the same way in the common case; all the really
important features are there</li>
<li>has a smaller and simpler visual footprint; it feels like using Sneak</li>
<li>is more flexible and extensible; it can be used as an engine for selecting
arbitrary targets, and performing arbitrary actions on them</li>
</ul>
<h2 dir="auto"><a id="user-content-status" aria-hidden="true" href="#status"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Status</h2>
<p dir="auto">The plugin is not fully stable yet, but don&#39;t let that stop you - the usage
basics are extremely unlikely to change. To follow breaking changes, subscribe
to the corresponding <a href="https://github.com/ggandor/leap.nvim/issues/18" data-hovercard-type="issue" data-hovercard-url="/ggandor/leap.nvim/issues/18/hovercard">issue</a>.</p>
<h2 dir="auto"><a id="user-content-faq" aria-hidden="true" href="#faq"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>FAQ</h2>
<details>
<summary>Bidirectional search</summary>
<div dir="auto" data-snippet-clipboard-copy-content="-- Initiate multi-window mode with the current window as the only target:
require(&#39;leap&#39;).leap { target_windows = { vim.fn.win_getid() } }"><pre><span><span>--</span> Initiate multi-window mode with the current window as the only target:</span>
<span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> { target_windows <span>=</span> { vim.<span>fn</span>.<span>win_getid</span>() } }</pre></div>
</details>
<details>
<summary>Search in all windows</summary>
<div dir="auto" data-snippet-clipboard-copy-content="require(&#39;leap&#39;).leap { target_windows = vim.tbl_filter(
  function (win) return vim.api.nvim_win_get_config(win).focusable end,
  vim.api.nvim_tabpage_list_wins(0)
)}"><pre><span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> { target_windows <span>=</span> vim.<span>tbl_filter</span>(
  <span>function</span> (<span>win</span>) <span>return</span> vim.<span>api</span>.<span>nvim_win_get_config</span>(win).<span>focusable</span> <span>end</span>,
  vim.<span>api</span>.<span>nvim_tabpage_list_wins</span>(<span>0</span>)
)}</pre></div>
</details>
<details>
<summary>Linewise motions</summary>
<p dir="auto">See the &#34;Extending Leap&#34; section below for an example snippet.</p>
</details>
<details>
<summary>Disable auto-jumping to the first match</summary>
<div dir="auto" data-snippet-clipboard-copy-content="require(&#39;leap&#39;).opts.safe_labels = {}"><pre><span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>opts</span>.<span>safe_labels</span> <span>=</span> {}</pre></div>
</details>
<details>
<summary>Greying out the search area</summary>
<div dir="auto" data-snippet-clipboard-copy-content="vim.api.nvim_set_hl(0, &#39;LeapBackdrop&#39;, { fg = &#39;#707070&#39; })"><pre>vim.<span>api</span>.<span>nvim_set_hl</span>(<span>0</span>, <span><span>&#39;</span>LeapBackdrop<span>&#39;</span></span>, { fg <span>=</span> <span><span>&#39;</span>#707070<span>&#39;</span></span> })</pre></div>
</details>
<details>
<summary>How to live without &#39;s&#39; and &#39;S&#39;?</summary>
<p dir="auto"><code>s</code> = <code>cl</code>, <code>S</code> = <code>cc</code>.</p>
</details>
<h2 dir="auto"><a id="user-content-getting-started" aria-hidden="true" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting started</h2>
<h3 dir="auto"><a id="user-content-requirements" aria-hidden="true" href="#requirements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Requirements</h3>
<ul dir="auto">
<li>Neovim &gt;= 0.7.0</li>
</ul>
<h3 dir="auto"><a id="user-content-dependencies" aria-hidden="true" href="#dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dependencies</h3>
<ul dir="auto">
<li>For the moment, <a href="https://github.com/tpope/vim-repeat">repeat.vim</a> is required
for dot-repeats (<code>.</code>) to work as intended.</li>
</ul>
<h3 dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h3>
<p dir="auto">Use your preferred plugin manager. No extra steps needed, besides optionally
setting the default keymaps:</p>
<p dir="auto"><code>require(&#39;leap&#39;).set_default_keymaps()</code></p>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">Without further ado, let&#39;s cut to the chase, and learn by doing.
(<a href="https://github.com/neovim/neovim/blob/8215c05945054755b2c3cadae198894372dbfe0f/src/nvim/window.c#L1078">Permalink</a>
to the file, if you want to follow along.)</p>
<p dir="auto">The search is invoked with <code>s</code> in the forward direction, and <code>S</code> in the backward
direction. Let&#39;s target some word containing <code>ol</code>. After entering the letter
<code>o</code>, the plugin processes all character pairs starting with it, and from here
on, you have all the visual information you need to reach your specific target.</p>
<p dir="auto">To reach the unlabeled matches, just finish the pattern, i.e., type the second
character. For the others, you also need to type the label character that is
displayed right next to the match.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ggandor/leap.nvim/blob/media/quick_example_1.png?raw=true"><img src="https://github.com/ggandor/leap.nvim/raw/media/quick_example_1.png?raw=true" alt="quick example 1"/></a></p>
<p dir="auto">Now type <code>l</code>. If you aimed for the first match (in <code>oldwin-&gt;w_frame</code>), you are
good to go, just continue the work! (The labels for the subsequent matches of
<code>ol</code> remain visible until the next keypress, but they are carefully chosen
&#34;safe&#34; letters, guaranteed to not interfere with your following editing
command.) If you aimed for some other match, then type the label, for example
<code>u</code>, and move on to that.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ggandor/leap.nvim/blob/media/quick_example_2.png?raw=true"><img src="https://github.com/ggandor/leap.nvim/raw/media/quick_example_2.png?raw=true" alt="quick example 2"/></a></p>
<p dir="auto">To show the last important feature, let&#39;s go back to the start position, and
target the struct member on the line <code>available = oldwin-&gt;w_frame-&gt;fr_height;</code>
near the bottom, using the pattern <code>fr</code>, by first pressing <code>s</code>, and then <code>f</code>:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ggandor/leap.nvim/blob/media/quick_example_3.png?raw=true"><img src="https://github.com/ggandor/leap.nvim/raw/media/quick_example_3.png?raw=true" alt="quick example 3"/></a></p>
<p dir="auto">The blue labels indicate the &#34;secondary&#34; group of matches, where we start to
reuse the available labels for a given pair (<code>s</code>, <code>f</code>, <code>n</code>... again). You can
reach those by prefixing the label with <code>&lt;space&gt;</code>, that switches to the
subsequent match group. For example, to jump to the &#34;blue&#34; <code>j</code> target, you
should now press <code>r&lt;space&gt;j</code>. In very rare cases, if the large number of matches
cannot be covered even by two label groups, you might need to press <code>&lt;space&gt;</code>
multiple times, until you see the target labeled, first with blue, and then,
after one more <code>&lt;space&gt;</code>, green. (Substitute &#34;green&#34; and &#34;blue&#34; with the actual
colors in the current theme.)</p>
<p dir="auto">To summarize, here is the general flow again (in Normal and Visual mode, with
the default settings):</p>
<p dir="auto"><code>s|S char1 char2 &lt;space&gt;? (&lt;space&gt;|&lt;tab&gt;)* label?</code></p>
<p dir="auto">That is,</p>
<ul dir="auto">
<li>invoke in the forward (<code>s</code>) or backward (<code>S</code>) direction</li>
<li>enter the first character of the search pattern
<ul dir="auto">
<li><em>the &#34;beacons&#34; are lit at this point; all potential matches (char1 + ?)
are labeled</em></li>
</ul>
</li>
<li>enter the second character of the search pattern (might short-circuit after
this, if there is only one match)
<ul dir="auto">
<li><em>certain beacons are extinguished; only char1 + char2 matches remain</em></li>
<li><em>the cursor automatically jumps to the first match if there are enough
&#34;safe&#34; labels; pressing any other key than a group-switch or a target
label exits the plugin now</em></li>
</ul>
</li>
<li>optionally cycle through the groups of matches that can be labeled at once</li>
<li>choose a labeled target to jump to (in the current group)</li>
</ul>
<h3 dir="auto"><a id="user-content-smart-autojump" aria-hidden="true" href="#smart-autojump"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Smart autojump</h3>
<p dir="auto">Leap automatically jumps to the first match if the remaining matches can be
covered by a limited set of &#34;safe&#34; target labels (keys you would not use right
after a jump), but stays in place, and switches to an extended, more comfortable
label set otherwise. For fine-tuning, see <code>:h leap-config</code>.</p>
<details>
<summary>Rationale</summary>
<p dir="auto">The reasoning behind this is that the probability of the user aiming for the
very first target lessens with the number of targets; at the same time, the
probability of being able to reach the first target by other means (<code>www</code>, <code>f</code>,
etc.) increases. That is, staying in place in exchange for more comfortable
labels becomes a more and more acceptable trade-off.</p>
<p dir="auto">Smart autojump gives the best of both worlds between Sneak (jumps
unconditionally, can only use a seriously limited label set) and Hop (labels
everything, always requires that one extra keystroke).</p>
</details>
<h3 dir="auto"><a id="user-content-resolving-highlighting-conflicts-in-the-first-phase" aria-hidden="true" href="#resolving-highlighting-conflicts-in-the-first-phase"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Resolving highlighting conflicts in the first phase</h3>
<p dir="auto">If a directly reachable match covers a label, the match will get highlighted
(telling the user, &#34;Label underneath!&#34;), and the label will only be displayed
after the second input, that resolves the ambiguity. If a label gets positioned
over another label (this might occur before EOL or the window edge, when the
labels need to be shifted left), an &#34;empty&#34; label will be displayed until
entering the second input.</p>
<h3 dir="auto"><a id="user-content-operator-pending-mode" aria-hidden="true" href="#operator-pending-mode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Operator-pending mode</h3>
<p dir="auto">In Operator-pending mode, there are two different (pairs of) default motions
available, providing the necessary additional comfort and precision, since in
that case we are targeting exact positions, and can only aim once, without the
means of easy correction.</p>
<p dir="auto"><code>z</code>/<code>Z</code> are the equivalents of Normal/Visual <code>s</code>/<code>S</code>, and behave like <code>/</code> and
<code>?</code>, that is, they are <em>exclusive</em> motions (the end column is not included in
the operation).</p>
<p dir="auto"><code>x</code>/<code>X</code> provide missing variants for the two directions; the mnemonics could be
e<strong>x</strong>tend/e<strong>X</strong>clude:</p>
<div data-snippet-clipboard-copy-content="abcd|                    |bcde
████e  ←  Zab    zde  →  ███de
ab██e  ←  Xab    xde  →  █████"><pre><code>abcd|                    |bcde
████e  ←  Zab    zde  →  ███de
ab██e  ←  Xab    xde  →  █████
</code></pre></div>
<p dir="auto">In the end, <code>x</code>/<code>X</code> both push the relevant edge of the operated area forward by
2, but there is a subtlety here:</p>
<p dir="auto"><code>X</code> = +2</p>
<p dir="auto"><code>x</code> = +1 <em>inclusive</em></p>
<p dir="auto">This is relevant when using the <code>v</code> modifier (<code>:h forced-motion</code>). <code>v</code> works as
expected: for example, <code>vx</code> becomes an exclusive motion, while <code>vz</code> becomes
inclusive (so ultimately they have equivalent results).</p>
<h3 dir="auto"><a id="user-content-jumping-to-the-last-character-on-a-line" aria-hidden="true" href="#jumping-to-the-last-character-on-a-line"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Jumping to the last character on a line</h3>
<p dir="auto">A character at the end of a line can be targeted by pressing <code>&lt;space&gt;</code> after it.
(There is no special mechanism behind this: you can set aliases for the newline
character simply by defining a set in <code>opts.equivalence_classes</code> that contains
it.)</p>
<h3 dir="auto"><a id="user-content-cross-window-motions" aria-hidden="true" href="#cross-window-motions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Cross-window motions</h3>
<p dir="auto"><code>gs</code> searches in all the other windows on the tab page. In this case, the
matches are sorted by their screen distance from the cursor, advancing in
concentric circles.</p>
<h3 dir="auto"><a id="user-content-repeating-the-previous-search" aria-hidden="true" href="#repeating-the-previous-search"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Repeating the previous search</h3>
<p dir="auto">Pressing <code>&lt;enter&gt;</code> (<code>special_keys.repeat_search</code>) after invoking any of Leap&#39;s
motions sets the search pattern to the previous one.</p>
<h3 dir="auto"><a id="user-content-traversal-mode" aria-hidden="true" href="#traversal-mode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Traversal mode</h3>
<p dir="auto">After entering at least one input character, <code>&lt;enter&gt;</code>
(<code>special_keys.next_aot_match</code>) initiates &#34;traversal&#34; mode, moving on to the
next match on each keypress. <code>&lt;tab&gt;</code> (<code>special_keys.prev_match</code>) can revert the
previous jump(s) in case you accidentally overshoot your target.</p>
<p dir="auto"><code>s|S ch1 ch2? &lt;enter&gt; (&lt;enter&gt;|&lt;tab&gt;)*</code></p>
<h4 dir="auto"><a id="user-content-tips" aria-hidden="true" href="#tips"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tips</h4>
<ul dir="auto">
<li>
<p dir="auto">When repeating the previous search, you can immediately move on:
<code>s&lt;enter&gt;&lt;enter&gt;...</code></p>
</li>
<li>
<p dir="auto">Accepting the first match after one input character is a useful shortcut in
operator-pending mode (e.g. <code>dz{char}&lt;enter&gt;</code>).</p>
</li>
<li>
<p dir="auto">Traversal mode can be used as a substitute for normal-mode <code>f</code>/<code>t</code> motions.
<code>s{char}&lt;enter&gt;&lt;enter&gt;</code> is the same as <code>f{char};</code>, but works over multiple
lines.</p>
</li>
</ul>
<h4 dir="auto"><a id="user-content-notes" aria-hidden="true" href="#notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Notes</h4>
<ul dir="auto">
<li>
<p dir="auto">If the safe label set is in use, the labels will remain available during the
whole time.</p>
</li>
<li>
<p dir="auto">For cross-window search, traversal mode is not supported (since there&#39;s no
direction to follow).</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-configuration" aria-hidden="true" href="#configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Configuration</h2>
<p dir="auto"><code>setup</code> has no implicit side effects, it is just a convenience function for
changing the values in the configuration table (which can also be accessed
directly as <code>require(&#39;leap&#39;).opts</code>). There is no need to call it if you&#39;re
fine with the defaults. Also note that table values are not extended, but simply
overwritten by the given ones, so in many cases, it might be more
straightforward to set <code>opts</code> directly.</p>
<div dir="auto" data-snippet-clipboard-copy-content="require(&#39;leap&#39;).setup {
  max_aot_targets = nil,
  highlight_unlabeled = false,
  max_highlighted_traversal_targets = 10,
  case_sensitive = false,
  -- Sets of characters that should match each other.
  -- Obvious candidates are braces and quotes (&#39;([{&#39;, &#39;)]}&#39;, &#39;`&#34;\&#39;&#39;).
  equivalence_classes = { &#39; \t\r\n&#39;, },
  -- Leaving the appropriate list empty effectively disables &#34;smart&#34; mode,
  -- and forces auto-jump to be on or off.
  safe_labels = { . . . },
  labels = { . . . },
  special_keys = {
    repeat_search  = &#39;&lt;enter&gt;&#39;,
    next_aot_match = &#39;&lt;enter&gt;&#39;,
    next_match     = {&#39;;&#39;, &#39;&lt;enter&gt;&#39;}
    prev_match     = {&#39;,&#39;, &#39;&lt;tab&gt;&#39;}
    next_group     = &#39;&lt;space&gt;&#39;,
    prev_group     = &#39;&lt;tab&gt;&#39;,
  },
}"><pre><span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>setup</span> {
  max_aot_targets <span>=</span> <span>nil</span>,
  highlight_unlabeled <span>=</span> <span>false</span>,
  max_highlighted_traversal_targets <span>=</span> <span>10</span>,
  case_sensitive <span>=</span> <span>false</span>,
  <span><span>--</span> Sets of characters that should match each other.</span>
  <span><span>--</span> Obvious candidates are braces and quotes (&#39;([{&#39;, &#39;)]}&#39;, &#39;`&#34;\&#39;&#39;).</span>
  equivalence_classes <span>=</span> { <span><span>&#39;</span> <span>\t\r\n</span><span>&#39;</span></span>, },
  <span><span>--</span> Leaving the appropriate list empty effectively disables &#34;smart&#34; mode,</span>
  <span><span>--</span> and forces auto-jump to be on or off.</span>
  safe_labels <span>=</span> { . . . },
  labels <span>=</span> { . . . },
  special_keys <span>=</span> {
    repeat_search  <span>=</span> <span><span>&#39;</span>&lt;enter&gt;<span>&#39;</span></span>,
    next_aot_match <span>=</span> <span><span>&#39;</span>&lt;enter&gt;<span>&#39;</span></span>,
    next_match     <span>=</span> {<span><span>&#39;</span>;<span>&#39;</span></span>, <span><span>&#39;</span>&lt;enter&gt;<span>&#39;</span></span>}
    prev_match     <span>=</span> {<span><span>&#39;</span>,<span>&#39;</span></span>, <span><span>&#39;</span>&lt;tab&gt;<span>&#39;</span></span>}
    next_group     <span>=</span> <span><span>&#39;</span>&lt;space&gt;<span>&#39;</span></span>,
    prev_group     <span>=</span> <span><span>&#39;</span>&lt;tab&gt;<span>&#39;</span></span>,
  },
}</pre></div>
<p dir="auto">For details, see <code>:h leap-config</code>.</p>
<h3 dir="auto"><a id="user-content-keymaps" aria-hidden="true" href="#keymaps"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Keymaps</h3>
<p dir="auto">You can set the defaults keymaps (listed in <code>:h leap-default-keymaps</code>) by
calling <code>require(&#39;leap&#39;).set_default_keymaps()</code>. Note that the function will
check for conflicts with any custom mappings created by you or other plugins,
and will not overwite them, unless explicitly told so (called with a <code>true</code>
argument).</p>
<p dir="auto">To set alternative keymaps, you can use the <code>&lt;Plug&gt;</code> keys listed in <code>:h leap-custom-keymaps</code>.</p>
<h3 dir="auto"><a id="user-content-highlight-groups" aria-hidden="true" href="#highlight-groups"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Highlight groups</h3>
<p dir="auto">For customizing the highlight colors, see <code>:h leap-highlight</code>.</p>
<p dir="auto">In case you - as a user - are not happy with a certain colorscheme&#39;s
integration, you could force reloading the default settings by calling
<code>leap.init_highlight(true)</code>. The call can even be wrapped in an
autocommand to automatically re-init on every colorscheme change:</p>
<div dir="auto" data-snippet-clipboard-copy-content="autocmd ColorScheme * lua require(&#39;leap&#39;).init_highlight(true)"><pre><span>autocmd</span> <span>ColorScheme</span> <span>*</span> <span>lua</span> <span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>init_highlight</span>(true)</pre></div>
<p dir="auto">This can be tweaked further, you could e.g. check the actual colorscheme, and
only execute for certain ones, etc.</p>
<h2 dir="auto"><a id="user-content-extending-leap" aria-hidden="true" href="#extending-leap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Extending Leap</h2>
<p dir="auto">There is more to Leap than meets the eye. On a general level, you should think
of it as less of a motion plugin and more of an engine for selecting visible
targets on the screen (acquired by arbitrary means), and doing arbitrary things
with them.</p>
<p dir="auto">There are lots of ways you can extend the plugin and bend it to your will, and
the combinations of them give you almost infinite possibilities.</p>
<h3 dir="auto"><a id="user-content-calling-leap-with-custom-arguments" aria-hidden="true" href="#calling-leap-with-custom-arguments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Calling <code>leap</code> with custom arguments</h3>
<p dir="auto">Instead of using the provided <code>&lt;Plug&gt;</code> keys, you can also call the <code>leap</code>
function directly. The following arguments are available:</p>
<p dir="auto"><code>opts</code>: A table just like <code>leap.opts</code>, to override any default setting for the
specific call. E.g.:</p>
<div dir="auto" data-snippet-clipboard-copy-content="require(&#39;leap&#39;).leap { opts = { labels = {} } }"><pre><span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> { opts <span>=</span> { labels <span>=</span> {} } }</pre></div>
<p dir="auto"><code>offset</code>: Where to land with the cursor compared to the target position (-1, 0,
1, 2).</p>
<p dir="auto"><code>inclusive_op</code>: A flag indicating whether an operation should behave as
inclusive (<code>:h inclusive</code>).</p>
<p dir="auto"><code>backward</code>: Search backward instead of forward in the current window.</p>
<p dir="auto"><code>target_windows</code>: A list of windows (as <code>winid</code>s) to be searched.</p>
<details>
<summary>Example: bidirectional and all-windows search</summary>
<div dir="auto" data-snippet-clipboard-copy-content="-- Bidirectional search in the current window is just a specific case of the
-- multi-window mode.
require(&#39;leap&#39;).leap { target_windows = { vim.fn.win_getid() } }

-- Searching in all windows (including the current one) on the tab page.
require(&#39;leap&#39;).leap { target_windows = vim.tbl_filter(
  function (win) return vim.api.nvim_win_get_config(win).focusable end,
  vim.api.nvim_tabpage_list_wins(0)
)}"><pre><span><span>--</span> Bidirectional search in the current window is just a specific case of the</span>
<span><span>--</span> multi-window mode.</span>
<span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> { target_windows <span>=</span> { vim.<span>fn</span>.<span>win_getid</span>() } }

<span><span>--</span> Searching in all windows (including the current one) on the tab page.</span>
<span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> { target_windows <span>=</span> vim.<span>tbl_filter</span>(
  <span>function</span> (<span>win</span>) <span>return</span> vim.<span>api</span>.<span>nvim_win_get_config</span>(win).<span>focusable</span> <span>end</span>,
  vim.<span>api</span>.<span>nvim_tabpage_list_wins</span>(<span>0</span>)
)}</pre></div>
</details>
<p dir="auto">This is where things start to become really interesting:</p>
<p dir="auto"><code>targets</code>: Either a list of targets, or a function returning such a list. The
elements of the list are tables of arbitrary structure, with the only mandatory
field being <code>pos</code> - a (1,1)-indexed tuple; this is the position of the label,
and also the jump target, if there is no custom <code>action</code> provided. If you have
targets in multiple windows, you also need to provide a <code>wininfo</code> field for each
(<code>:h getwininfo()</code>). Targets can represent anything with a position, like
Tree-sitter nodes, etc.</p>
<details>
<summary>Example: linewise motions</summary>
<div dir="auto" data-snippet-clipboard-copy-content="local function get_line_starts(winid)
  local wininfo =  vim.fn.getwininfo(winid)[1]
  local cur_line = vim.fn.line(&#39;.&#39;)

  -- Get targets.
  local targets = {}
  local lnum = wininfo.topline
  while lnum &lt;= wininfo.botline do
    local fold_end = vim.fn.foldclosedend(lnum)
    -- Skip folded ranges.
    if fold_end ~= -1 then
      lnum = fold_end + 1
    else
      if lnum ~= cur_line then table.insert(targets, { pos = { lnum, 1 } }) end
      lnum = lnum + 1
    end
  end
  -- Sort them by vertical screen distance from cursor.
  local cur_screen_row = vim.fn.screenpos(winid, cur_line, 1)[&#39;row&#39;]
  local function screen_rows_from_cur(t)
    local t_screen_row = vim.fn.screenpos(winid, t.pos[1], t.pos[2])[&#39;row&#39;]
    return math.abs(cur_screen_row - t_screen_row)
  end
  table.sort(targets, function (t1, t2)
    return screen_rows_from_cur(t1) &lt; screen_rows_from_cur(t2)
  end)

  if #targets &gt;= 1 then
    return targets
  end
end

-- Usage:
local function leap_to_line()
  winid = vim.api.nvim_get_current_win()
  require(&#39;leap&#39;).leap {
    target_windows = { winid },
    targets = get_line_starts(winid),
  }
end"><pre><span>local</span> <span>function</span> <span>get_line_starts</span>(<span>winid</span>)
  <span>local</span> wininfo <span>=</span>  vim.<span>fn</span>.<span>getwininfo</span>(winid)[<span>1</span>]
  <span>local</span> cur_line <span>=</span> vim.<span>fn</span>.<span>line</span>(<span><span>&#39;</span>.<span>&#39;</span></span>)

  <span><span>--</span> Get targets.</span>
  <span>local</span> targets <span>=</span> {}
  <span>local</span> lnum <span>=</span> wininfo.<span>topline</span>
  <span>while</span> lnum <span>&lt;=</span> wininfo.<span>botline</span> <span>do</span>
    <span>local</span> fold_end <span>=</span> vim.<span>fn</span>.<span>foldclosedend</span>(lnum)
    <span><span>--</span> Skip folded ranges.</span>
    <span>if</span> fold_end <span>~=</span> <span>-</span><span>1</span> <span>then</span>
      lnum <span>=</span> fold_end <span>+</span> <span>1</span>
    <span>else</span>
      <span>if</span> lnum <span>~=</span> cur_line <span>then</span> <span>table.insert</span>(targets, { pos <span>=</span> { lnum, <span>1</span> } }) <span>end</span>
      lnum <span>=</span> lnum <span>+</span> <span>1</span>
    <span>end</span>
  <span>end</span>
  <span><span>--</span> Sort them by vertical screen distance from cursor.</span>
  <span>local</span> cur_screen_row <span>=</span> vim.<span>fn</span>.<span>screenpos</span>(winid, cur_line, <span>1</span>)[<span><span>&#39;</span>row<span>&#39;</span></span>]
  <span>local</span> <span>function</span> <span>screen_rows_from_cur</span>(<span>t</span>)
    <span>local</span> t_screen_row <span>=</span> vim.<span>fn</span>.<span>screenpos</span>(winid, t.<span>pos</span>[<span>1</span>], t.<span>pos</span>[<span>2</span>])[<span><span>&#39;</span>row<span>&#39;</span></span>]
    <span>return</span> <span>math.abs</span>(cur_screen_row <span>-</span> t_screen_row)
  <span>end</span>
  <span>table.sort</span>(targets, <span>function</span> (<span>t1</span>, <span>t2</span>)
    <span>return</span> <span>screen_rows_from_cur</span>(t1) <span>&lt;</span> <span>screen_rows_from_cur</span>(t2)
  <span>end</span>)

  <span>if</span> <span>#</span>targets <span>&gt;=</span> <span>1</span> <span>then</span>
    <span>return</span> targets
  <span>end</span>
<span>end</span>

<span><span>--</span> Usage:</span>
<span>local</span> <span>function</span> <span>leap_to_line</span>()
  winid <span>=</span> vim.<span>api</span>.<span>nvim_get_current_win</span>()
  <span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> {
    target_windows <span>=</span> { winid },
    targets <span>=</span> <span>get_line_starts</span>(winid),
  }
<span>end</span></pre></div>
</details>
<p dir="auto"><code>action</code>: A Lua function that will be executed by Leap in place of the jump. (You
could obviously implement some custom jump logic here too.) Its only argument is
either a target, or a list of targets (in multiselect mode).</p>
<details>
<summary>Example: pick a window</summary>
<div dir="auto" data-snippet-clipboard-copy-content="function leap_to_window()
  target_windows = require(&#39;leap.util&#39;).get_enterable_windows()
  local targets = {}
  for _, win in ipairs(target_windows) do
    local wininfo = vim.fn.getwininfo(win)[1]
    local pos = { wininfo.topline, 1 }  -- top/left corner
    table.insert(targets, { pos = pos, wininfo = wininfo })
  end

  require(&#39;leap&#39;).leap {
    target_windows = target_windows,
    targets = targets,
    action = function (target)
      vim.api.nvim_set_current_win(target.wininfo.winid)
    end
  }
end"><pre><span>function</span> <span>leap_to_window</span>()
  target_windows <span>=</span> <span>require</span>(<span><span>&#39;</span>leap.util<span>&#39;</span></span>).<span>get_enterable_windows</span>()
  <span>local</span> targets <span>=</span> {}
  <span>for</span> _, win <span>in</span> <span>ipairs</span>(target_windows) <span>do</span>
    <span>local</span> wininfo <span>=</span> vim.<span>fn</span>.<span>getwininfo</span>(win)[<span>1</span>]
    <span>local</span> pos <span>=</span> { wininfo.<span>topline</span>, <span>1</span> }  <span><span>--</span> top/left corner</span>
    <span>table.insert</span>(targets, { pos <span>=</span> pos, wininfo <span>=</span> wininfo })
  <span>end</span>

  <span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> {
    target_windows <span>=</span> target_windows,
    targets <span>=</span> targets,
    action <span>=</span> <span>function</span> (<span>target</span>)
      vim.<span>api</span>.<span>nvim_set_current_win</span>(target.<span>wininfo</span>.<span>winid</span>)
    <span>end</span>
  }
<span>end</span></pre></div>
</details>
<p dir="auto"><code>multiselect</code>: A flag allowing for selecting multiple targets for <code>action</code>. In
this mode, you can just start picking labels one after the other. You can revert
the most recent pick with <code>&lt;backspace&gt;</code>, and accept the selection with
<code>&lt;enter&gt;</code>.</p>
<details>
<summary>Example: multi-cursor `:normal`</summary>
<div dir="auto" data-snippet-clipboard-copy-content="-- The following example showcases a custom action, using `multiselect`. We&#39;re
-- executing a `normal!` command at each selected position (this could be even
-- more useful if we&#39;d pass in custom targets too).

function paranormal(targets)
  -- Get the :normal sequence to be executed.
  local input = vim.fn.input(&#34;normal! &#34;)
  if #input &lt; 1 then return end

  local ns = vim.api.nvim_create_namespace(&#34;&#34;)

  -- Set an extmark as an anchor for each target, so that we can also execute
  -- commands that modify the positions of other targets (insert/change/delete).
  for _, target in ipairs(targets) do
    local line, col = unpack(target.pos)
    id = vim.api.nvim_buf_set_extmark(0, ns, line - 1, col - 1, {})
    target.extmark_id = id
  end

  -- Jump to each extmark (anchored to the &#34;moving&#34; targets), and execute the
  -- command sequence.
  for _, target in ipairs(targets) do
    local id = target.extmark_id
    local pos = vim.api.nvim_buf_get_extmark_by_id(0, ns, id, {})
    vim.fn.cursor(pos[1] + 1, pos[2] + 1)
    vim.cmd(&#34;normal! &#34; .. input)
  end

  -- Clean up the extmarks.
  vim.api.nvim_buf_clear_namespace(0, ns, 0, -1)
end

-- Usage:
require(&#39;leap&#39;).leap {
    target_windows = { vim.fn.win_getid() },
    action = paranormal,
    multiselect = true,
}"><pre><span><span>--</span> The following example showcases a custom action, using `multiselect`. We&#39;re</span>
<span><span>--</span> executing a `normal!` command at each selected position (this could be even</span>
<span><span>--</span> more useful if we&#39;d pass in custom targets too).</span>

<span>function</span> <span>paranormal</span>(<span>targets</span>)
  <span><span>--</span> Get the :normal sequence to be executed.</span>
  <span>local</span> input <span>=</span> vim.<span>fn</span>.<span>input</span>(<span><span>&#34;</span>normal! <span>&#34;</span></span>)
  <span>if</span> <span>#</span>input <span>&lt;</span> <span>1</span> <span>then</span> <span>return</span> <span>end</span>

  <span>local</span> ns <span>=</span> vim.<span>api</span>.<span>nvim_create_namespace</span>(<span><span>&#34;</span><span>&#34;</span></span>)

  <span><span>--</span> Set an extmark as an anchor for each target, so that we can also execute</span>
  <span><span>--</span> commands that modify the positions of other targets (insert/change/delete).</span>
  <span>for</span> _, target <span>in</span> <span>ipairs</span>(targets) <span>do</span>
    <span>local</span> line, col <span>=</span> <span>unpack</span>(target.<span>pos</span>)
    id <span>=</span> vim.<span>api</span>.<span>nvim_buf_set_extmark</span>(<span>0</span>, ns, line <span>-</span> <span>1</span>, col <span>-</span> <span>1</span>, {})
    target.<span>extmark_id</span> <span>=</span> id
  <span>end</span>

  <span><span>--</span> Jump to each extmark (anchored to the &#34;moving&#34; targets), and execute the</span>
  <span><span>--</span> command sequence.</span>
  <span>for</span> _, target <span>in</span> <span>ipairs</span>(targets) <span>do</span>
    <span>local</span> id <span>=</span> target.<span>extmark_id</span>
    <span>local</span> pos <span>=</span> vim.<span>api</span>.<span>nvim_buf_get_extmark_by_id</span>(<span>0</span>, ns, id, {})
    vim.<span>fn</span>.<span>cursor</span>(pos[<span>1</span>] <span>+</span> <span>1</span>, pos[<span>2</span>] <span>+</span> <span>1</span>)
    vim.<span>cmd</span>(<span><span>&#34;</span>normal! <span>&#34;</span></span> <span>..</span> input)
  <span>end</span>

  <span><span>--</span> Clean up the extmarks.</span>
  vim.<span>api</span>.<span>nvim_buf_clear_namespace</span>(<span>0</span>, ns, <span>0</span>, <span>-</span><span>1</span>)
<span>end</span>

<span><span>--</span> Usage:</span>
<span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> {
    target_windows <span>=</span> { vim.<span>fn</span>.<span>win_getid</span>() },
    action <span>=</span> paranormal,
    multiselect <span>=</span> <span>true</span>,
}</pre></div>
</details>
<h3 dir="auto"><a id="user-content-accessing-the-arguments-passed-to-leap" aria-hidden="true" href="#accessing-the-arguments-passed-to-leap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Accessing the arguments passed to <code>leap</code></h3>
<p dir="auto">The arguments of the current call are always available at runtime, in the
<code>state.args</code> table.</p>
<h3 dir="auto"><a id="user-content-setting-up-autocommands" aria-hidden="true" href="#setting-up-autocommands"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Setting up autocommands</h3>
<p dir="auto">Leap triggers <code>User</code> events on entering/exiting (with patterns <code>LeapEnter</code> and
<code>LeapLeave</code>), so that you can set up autocommands, e.g. to change the values of
some editor options while the plugin is active (<code>:h leap-events</code>).</p>
<h3 dir="auto"><a id="user-content-customizing-specific-invocations" aria-hidden="true" href="#customizing-specific-invocations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Customizing specific invocations</h3>
<p dir="auto">Using autocommands together with the <code>args</code> table, you can customize practically
anything on a per-call basis - keep in mind that nothing prevents you from
passing arbitrary flags when calling <code>leap</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="function my_custom_leap_func()
    require(&#39;leap&#39;).leap { my_custom_flag = true, ... }
end

vim.api.nvim_create_autocmd(&#39;User&#39;, {
  pattern = &#39;LeapEnter&#39;,
  callback = function ()
    if require(&#39;leap&#39;).state.args.my_custom_flag then
      -- Implement some special logic here, that will only apply to
      -- my_custom_leap_func() (e.g., change the style of the labels),
      -- and clean up with an analogous `LeapLeave` autocommand.
    end
  end
})"><pre><span>function</span> <span>my_custom_leap_func</span>()
    <span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>leap</span> { my_custom_flag <span>=</span> <span>true</span>, <span>...</span> }
<span>end</span>

vim.<span>api</span>.<span>nvim_create_autocmd</span>(<span><span>&#39;</span>User<span>&#39;</span></span>, {
  pattern <span>=</span> <span><span>&#39;</span>LeapEnter<span>&#39;</span></span>,
  callback <span>=</span> <span>function</span> ()
    <span>if</span> <span>require</span>(<span><span>&#39;</span>leap<span>&#39;</span></span>).<span>state</span>.<span>args</span>.<span>my_custom_flag</span> <span>then</span>
      <span><span>--</span> Implement some special logic here, that will only apply to</span>
      <span><span>--</span> my_custom_leap_func() (e.g., change the style of the labels),</span>
      <span><span>--</span> and clean up with an analogous `LeapLeave` autocommand.</span>
    <span>end</span>
  <span>end</span>
})</pre></div>
<h2 dir="auto"><a id="user-content-plugins-using-leap" aria-hidden="true" href="#plugins-using-leap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Plugins using Leap</h2>
<ul dir="auto">
<li><a href="https://github.com/ggandor/flit.nvim">flit.nvim</a> (enhanced f/t motions)</li>
<li><a href="https://github.com/ggandor/leap-ast.nvim">leap-ast.nvim</a> (TreeSitter nodes)</li>
</ul>
</article>
          </div></div>
  </body>
</html>
