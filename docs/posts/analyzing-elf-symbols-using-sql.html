<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fzakaria.com/2023/09/11/quick-insights-using-sqlelf.html">Original</a>
    <h1>Analyzing ELF symbols using SQL</h1>
    
    <div id="readability-page-1" class="page"><article>
      <blockquote>
  <p>Please checkout the <a href="https://github.com/fzakaria/sqlelf">sqlelf</a> repository and give me your feedback.</p>
</blockquote>

<p>I wrote in my earlier <a href="https://fzakaria.com/2023/03/19/sqlelf-and-20-years-of-nix.html">post</a> about releasing <a href="https://github.com/fzakaria/sqlelf">sqlelf</a>.
I had the hunch that the existing tooling we have to interface with our object formats, such as ELF, are antiquated and ill specified.</p>

<p>Declarative languages, such as SQL, are such a wonderful abstraction to articulate over data layouts and let you reason about <em>what you want</em> rather than <em>how to get it</em>.</p>

<p>Since continuing to noodle ğŸ‘¨â€ğŸ’» on the project, Iâ€™ve been pleasantly surprised at some of the introspection, specifically with respect to symbols, Iâ€™ve been able
to accomplish with SQL that would have been a pain using traditional tools.</p>

<!--more-->

<p>Come on a stroll with me on a few case studies Iâ€™ve gone through on how SQL guided analysis wins out.</p>

<h2 id="symbol-resolution">Symbol Resolution</h2>

<p>One of the primary data structures within the ELF file is the symbol table, especially the <em>dynamic symbol table</em> that allows the use of shared objects (libraries).</p>

<p>A typical question someone may ask themselves though is:</p>

<p><strong>Which library that I load is providing <em>function foo</em>?</strong></p>

<p>This is a worthwhile question because you would like to know which shared object is not only providing the symbol definition but also which the linker (<code>ld.so</code>) choses
to link against at runtime.</p>

<p>The <em>state of the art</em> (prior to sqlelf) of how to retrieve this diagnostic information is using <code>LD_DEBUG</code> environment variable and trolling through the large dump of logs it emits. ğŸ¤¦</p>

<div><div><pre><code><span>â¯ LD_DEBUG=symbols,bindings /usr/bin/ruby |&amp; head
</span><span>   1228310:	symbol=__vdso_clock_gettime;</span><span>  </span>lookup <span>in </span><span>file</span><span>=</span>linux-vdso.so.1 <span>[</span>0]
<span>   1228310:	binding file linux-vdso.so.1 [0] to linux-vdso.so.1 [0]: normal symbol `__vdso_clock_gettime&#39; [LINUX_2.6]
</span><span>   1228310:	symbol=__vdso_gettimeofday;</span><span>  </span>lookup <span>in </span><span>file</span><span>=</span>linux-vdso.so.1 <span>[</span>0]
<span>   1228310:	binding file linux-vdso.so.1 [0] to linux-vdso.so.1 [0]: normal symbol `__vdso_gettimeofday&#39; [LINUX_2.6]
</span><span>   1228310:	symbol=__vdso_time;</span><span>  </span>lookup <span>in </span><span>file</span><span>=</span>linux-vdso.so.1 <span>[</span>0]
<span>   1228310:	binding file linux-vdso.so.1 [0] to linux-vdso.so.1 [0]: normal symbol `__vdso_time&#39; [LINUX_2.6]
</span><span>   1228310:	symbol=__vdso_getcpu;</span><span>  </span>lookup <span>in </span><span>file</span><span>=</span>linux-vdso.so.1 <span>[</span>0]
<span>   1228310:	binding file linux-vdso.so.1 [0] to linux-vdso.so.1 [0]: normal symbol `__vdso_getcpu&#39; [LINUX_2.6]
</span><span>   1228310:	symbol=__vdso_clock_getres;</span><span>  </span>lookup <span>in </span><span>file</span><span>=</span>linux-vdso.so.1 <span>[</span>0]
<span>   1228310:	binding file linux-vdso.so.1 [0] to linux-vdso.so.1 [0]: normal symbol `__vdso_clock_getres&#39; [LINUX_2.6]
</span></code></pre></div></div>

<p>Letâ€™s see how we can re-think of this question as a declarative SQL statement:</p>

<pre><code>SELECT caller.path as &#39;caller.path&#39;,
       callee.path as &#39;calee.path&#39;,
       caller.name,
       caller.demangled_name
FROM ELF_SYMBOLS caller
INNER JOIN ELF_SYMBOLS callee
ON
caller.name = callee.name AND
caller.path != callee.path AND
caller.imported = TRUE AND
callee.exported = TRUE
</code></pre>

<p>We can think of the above ask asking:</p>

<p><em>Please provide all pairings of symbols where the name is the same between any two different ELF files.
One of the files must export the symbol and the other must be importing it.</em></p>

<div><div><pre><code><span>â¯ sqlelf /usr/bin/ruby --sql &#34;SELECT caller.path as &#39;caller.path&#39;,
       callee.path as &#39;calee.path&#39;,
       caller.name
FROM ELF_SYMBOLS caller
INNER JOIN ELF_SYMBOLS callee
ON
caller.name = callee.name AND
caller.path != callee.path AND
caller.imported = TRUE AND
callee.exported = TRUE
LIMIT 10&#34;
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  caller.path  â”‚                   calee.path                   â”‚       name        â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libruby-3.1.so.3.1.2 â”‚ ruby_run_node     â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libruby-3.1.so.3.1.2 â”‚ ruby_init         â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libruby-3.1.so.3.1.2 â”‚ ruby_options      â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libruby-3.1.so.3.1.2 â”‚ ruby_sysinit      â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libc.so.6            â”‚ __stack_chk_fail  â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libruby-3.1.so.3.1.2 â”‚ ruby_init_stack   â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libc.so.6            â”‚ setlocale         â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libc.so.6            â”‚ __libc_start_main â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libc.so.6            â”‚ __libc_start_main â”‚
â”‚ /usr/bin/ruby â”‚ /usr/lib/x86_64-linux-gnu/libc.so.6            â”‚ __cxa_finalize    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></code></pre></div></div>

<p>ğŸ¥³ That sure beats dealing with unstructured text. sqlelf can also emit a myriad of output formats such as csv or json.</p>

<h2 id="symbol-shadowing">Symbol Shadowing</h2>

<p>The reality of <code>LD_DEBUG</code> however is that it usefulness came in knowing the <em>final resolution</em> of a given symbol.</p>

<p>ELF files are free to have and export any symbols and often times, wether by accident (benign) or maliciously, the same symbol may be exported by
multiple libraries.</p>

<blockquote>
  <p>This is what empowers tools such as <code>LD_PRELOAD</code> so that users can take over symbols such as <code>malloc</code> and replace them with alternative strategies.</p>
</blockquote>

<p>The linker, according to the <a href="https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html">SystemV ABI</a>, examines the symbol tables with a breadth-first search across the dependency graph of the shared object libraries.</p>

<p>A typical question someone may ask themselves though is:</p>

<p><strong>What symbols are currently shadowed in my dependency graph?</strong></p>

<p>Letâ€™s see how we can re-think of this question as a declarative SQL statement:</p>

<pre><code>SELECT name, version, count(*) as symbol_count,
       GROUP_CONCAT(path, &#39;:&#39;) as libraries
FROM elf_symbols
WHERE exported = TRUE
GROUP BY name, version
HAVING count(*) &gt;= 2
</code></pre>

<p>We can think of the above ask asking:</p>

<p><em>Please provide me all symbols (and the library that defines them) that are exported by more than 2 libraries</em>.</p>

<p>Any symbol here is technically being shadowed, whether on purpose or benign.</p>

<p>Revisiting the same <em>ruby</em> example above we can see the results.</p>
<div><div><pre><code><span>â¯ sqlelf /usr/bin/ruby --recursive --sql &#34;
SELECT name, version, count(*) as symbol_count,
       GROUP_CONCAT(path, &#39;:&#39;) as libraries
FROM elf_symbols
WHERE exported = TRUE
GROUP BY name, version
</span><span>HAVING count(*) &gt;</span><span>=</span> 2<span>&#34;
</span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    name    â”‚   version   â”‚ symbol_count â”‚                                libraries                                â”‚
â”‚ __finite   â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ __finitef  â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ __finitel  â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ __signbit  â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ __signbitf â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ __signbitl â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ copysign   â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ copysignf  â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ copysignl  â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ finite     â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ finitef    â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ finitel    â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ frexp      â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ frexpf     â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ frexpl     â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ ldexp      â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ ldexpf     â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ ldexpl     â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ modf       â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ modff      â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ modfl      â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ scalbn     â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ scalbnf    â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â”‚ scalbnl    â”‚ GLIBC_2.2.5 â”‚ 2            â”‚ /usr/lib/x86_64-linux-gnu/libm.so.6:/usr/lib/x86_64-linux-gnu/libc.so.6 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</span></code></pre></div></div>

<p>In this particular case, there is no malicious symbol shadowing and the symbols shadowed by <code>libm</code> and <code>libc</code> are well
known. In fact, on many systems, <code>libm</code> is a symlink to <code>libc</code>.</p>

<p>I have <a href="https://arxiv.org/abs/2211.05118">previously written</a> about through the development of <a href="https://github.com/fzakaria/shrinkwrap">shrinkwrap</a> that a more
annoying shadowing can happen with OpenMPI. Itâ€™s pretty easy to accidentally get the <em>no-op</em> library implementation earlier in
breadth-first search and find yourself with a sequential application.</p>

<p>Iâ€™ve included a neat <a href="https://github.com/fzakaria/sqlelf/blob/main/examples/shadowed-symbols/Makefile">example</a> in the sqlelf repository that you can play with
to test shadowing symbols and see the results of sqlelf. ğŸ•µï¸</p>

<p>If you find any of this fascinating, contribute and letâ€™s work to make accessing ELF via SQL simple and productive.</p>


<hr/>
    </article></div>
  </body>
</html>
