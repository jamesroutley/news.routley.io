<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2025/convolutions-polynomials-and-flipped-kernels/">Original</a>
    <h1>Convolutions, Polynomials and Flipped Kernels</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>This is a post about multiplying polynomials, convolution sums and the
connection between them.</p>
<div id="multiplying-polynomials">
<h2>Multiplying polynomials</h2>
<p>Suppose we want to multiply one polynomial by another:</p>
<p>This is basic middle-school math - we start by cross-multiplying:</p>
<p>And then collect all the terms together by adding up the coefficients:</p>
<p>Let&#39;s look at a slightly different way to achieve the same result. Instead of
cross multiplying all terms and then adding up, we&#39;ll focus on what terms appear
in the output, and for each such term - what its coefficients are going to be.
This is easy to demonstrate with a table, where we lay out one polynomial
horizontally and the other vertically. Note that we have to be explicit about
the zero coefficient of <em>x</em> in the second polynomial:</p>
<p><img alt="Table showing polynomial multiplication" src="https://eli.thegreenplace.net/images/2025/poly-mul-table.png"/></p><p>The diagonals that add up to each term in the output are highlighted. For example,
to get the coefficient of  in the output, we have to add up:</p>

<p>(if the second polynomial had a  term, there would be another
component to add)</p>
<p>For what follows, let&#39;s move to a somewhat more abstract representation: a
polynomial <em>P</em> can be represented as a sum of coefficients 
multiplied by corresponding powers of <em>x</em> <a href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<p>Suppose we have two polynomials, <em>P</em> and <em>R</em>. When we multiply them together,
the resulting polynomial is <em>S</em>. Based on our insight from the table diagonals
above, we can say that for each <em>k</em>:</p>
<p>And then the entire polynomial <em>S</em> is:</p>
<p>It&#39;s important to understand this formulation, since it&#39;s key to this
post. Let&#39;s use our example polynomials to see how it works. First, we represent
the two
polynomials as sequences of coefficients (starting with 0, so the coefficient
of the constant is first, and the coefficient of the highest power is last):</p>
<p>In this notation,  is the first element in the list for <em>P</em>, etc.
To calculate the coefficient of  in the product:</p>
<p>Expanding the sum for all the non-zero coefficients of <em>P</em>:</p>
<p>Similarly, we&#39;ll find that ,  and so on, resulting
in the final polynomial as before:</p>
<p>There&#39;s a nice graphical approach to multiply polynomials using this idea of
pairing up sums for each term in the output:</p>
<p><img alt="Graphical representation of poly mul, part 1" src="https://eli.thegreenplace.net/images/2025/poly-mul-slide1.png"/></p><p>We start with the diagram on the left: one of the polynomials remains in its
original form, while the other is flipped around (constant term first, highest
power term last). We line up the polynomials vertically, and multiply the
corresponding coefficients: the constant coefficient of the output is just the
constant coefficient of the first polynomial times the constant coefficient of
the second polynomial.</p>
<p>The diagram on the right shows the next step: the second polynomial is shifted
left by one term and lined up vertically again. The corresponding coefficients
are multiplied, and then the results are added to obtain the coefficient of <em>x</em>
in the output polynomial.</p>
<p>We continue the process by shifting the lower polynomial left:</p>
<p><img alt="Graphical representation of poly mul, part 2" src="https://eli.thegreenplace.net/images/2025/poly-mul-slide2.png"/></p><p>Calculating the coefficients of  and then . A couple more
steps:</p>
<p><img alt="Graphical representation of poly mul, part 3" src="https://eli.thegreenplace.net/images/2025/poly-mul-slide3.png"/></p><p>Now we have all the coefficients of the output. Take a moment to convince
yourself that this approach is equivalent to the summation shown just
before it, and also to the &#34;diagonals in a table&#34; approach shown further up.
They all calculate the same thing <a href="#footnote-2" id="footnote-reference-2">[2]</a>!</p>
<p>Hopefully it should be clear why the second polynomial is &#34;flipped&#34; to perform
this procedure. This all comes down to which input terms pair up to calculate
each output term. As seen above:</p>
<p>While the index <em>i</em> moves in one direction (from the low power terms to the
high power terms) in <em>P</em>, the index <em>k-i</em> moves in the opposite direction in
<em>R</em>.</p>
<p>If this procedure reminds you of computing a convolution between two arrays,
that&#39;s because it&#39;s exactly that!</p>
</div>
<div id="signals-systems-and-convolutions">
<h2>Signals, systems and convolutions</h2>
<p>The theory of signals and systems is a large topic (typically taught for one
or two semesters in undergraduate engineering degrees), but here I want to focus
on just one aspect of it which I find really elegant.</p>
<p>Let&#39;s define discrete signals and systems first, restricting ourselves to 1D
(similar ideas apply in higher dimensions):</p>
<p><strong>Discrete signal</strong>: An ordered sequence of numbers  with integer
indices . Can also be
thought of as a function .</p>
<p><strong>Discrete system</strong>: A function mapping input signals  to output
signals . For example,  is a system that scales
all signals by a factor of two.</p>
<p>Here&#39;s an example signal:</p>
<p><img alt="Basic signal" src="https://eli.thegreenplace.net/images/2025/signal-basic.png"/></p><p>This is a <em>finite</em> signal. All values not explicitly shown in the chart are
assumed to be 0 (e.g. , ,  and so
on).</p>
<p>A very important signal is the <em>discrete impulse</em>:</p>
<p>In graphical form, here&#39;s , as well as a couple of time-shifted
variants of it. Note how we shift a signal left and right on the horizontal
axis by adding to or subtracting from <em>n</em>, correspondingly. Take a moment to
double check why this works.</p>
<p><img alt="Discrete impulse function delta with shifts" src="https://eli.thegreenplace.net/images/2025/discrete-delta.png"/></p><p>The impulse is useful because we can decompose any discrete signal into
a sequence of scaled and shifted impulses. Our example signal
has three non-zero values at indices 0, 1 and 2; we can
represent it as follows:</p>
<p>More generally, a signal  can be written as:</p>
<p>(for all <em>k</em> where  is nonzero)</p>
<p>In the study of signals and systems, linear and time-invariant (LTI) systems
are particularly important.</p>
<p><strong>Linear</strong>: suppose  is the output of a system for input signal
, and similarly  is the output for .
A linear system outputs  for the input
 where <em>a</em> and <em>b</em> are constants.</p>
<p><strong>Time-invariant</strong>: if we delay the input signal by some constant:
, the output is similarly delayed: . In other
words, the response of the system has a similar shape, no matter when the
signal was received (it behaves today similarly to the way it behaved
yesterday).</p>
<p>LTI systems are important because of the decomposition of a signal into impulses
discussed above. Suppose we want to characterize a system: what it does to an
arbitrary signal. For an LTI system, all we need to describe is its response to
an impulse!</p>
<p>If the response of our system to  is , then:</p>
<ul>
<li>Its response to  is , for any
constant <em>c</em>, because the system is linear.</li>
<li>Its response to  is , for any time shift
<em>k</em>, because the system is time-invariant.</li>
</ul>
<p>We&#39;ll combine these and use linearity again (note that in the following
 are just constants); the response to a signal decomposed into a sum
of shifted and scaled impulses:</p>
<p>Is:</p>
<p>This operation is called the <em>convolution</em> between sequences  and
, and is denoted with the  operator:</p>
<p>Let&#39;s work through an example. Suppose we have an LTI system with the following
response to an impulse:</p>
<p><img alt="Impulse response h[n]" src="https://eli.thegreenplace.net/images/2025/hn-impulse-response.png"/></p><p>The response has ,  and zeros everywhere else.
Recall our sample signal from the top of this section (the sequence 2, 2, 1).
We can decompose it to a sequence of scaled and shifted impulses, and then
calculate the system response to each of them. Like this:</p>
<p><img alt="Decomposed x[n] and the h[n] for each component" src="https://eli.thegreenplace.net/images/2025/hn-response-decompose.png"/></p><p>The top row shows the input signal decomposed into scaled and shifted impulses;
the bottom row is the corresponding system response to each input. If we carefully
add up the responses for each <em>n</em>, we&#39;ll get the system response 
to our input:</p>
<p><img alt="y[n] full system response" src="https://eli.thegreenplace.net/images/2025/yn-response.png"/></p><p>Now, let&#39;s calculate the same output, but this time using the convolution sum.
First, we&#39;ll represent the signal <em>x</em> and the impulse response <em>h</em> as sequences
(just like we did with polynomials), with  first, then 
etc:</p>
<p>The convolution sum is:</p>
<p>Recall that <em>k</em> ranges over all the non-zero elements in <em>x</em>. Let&#39;s calculate
each element of  (noting that <em>h</em> is nonzero only for indices
0 and 1):</p>
<p>All subsequent values of <em>y</em> are zero because <em>k</em> only ranges up to 2 and
.</p>
<p>If you look carefully at this calculation, you&#39;ll notice that <em>h</em> is &#34;flipped&#34;
in relation to <em>x</em>, just like with the polynomials:</p>
<p><img alt="Convolution between signals by flipping one and sliding" src="https://eli.thegreenplace.net/images/2025/hn-flip-slide.png"/></p><ul>
<li>We start with  (black) and flipped  (blue), and line up the first
non-zero elements. This computes </li>
<li>In subsequent steps,  is slides right, one element at a time,
and the next value of <em>y</em> is computed by adding up the element-wise products
of the lined up <em>x</em> and <em>h</em>.</li>
</ul>
<p>Just like with polynomials <a href="#footnote-3" id="footnote-reference-3">[3]</a>, the reason why one of the inputs is flipped is
clear from the definition of the convolution sum, where one of the the indices
increases (<em>k</em>), while the other decreases (<em>n-k</em>).</p>
</div>
<div id="properties-of-convolution">
<h2>Properties of convolution</h2>
<p>The convolution operation has <a href="https://en.wikipedia.org/wiki/Convolution#Properties">many useful algebraic properties</a>: linearity, associativity,
commutativity, distributivity, etc.</p>
<p>The commutative property means that when computing convolutions graphically,
it doesn&#39;t matter which of the signals is &#34;flipped&#34;, because:</p>
<p>And therefore:</p>
<p>But the most important property of the convolution is how it behaves in the
frequency domain. If we denote  as the Fourier transform
of signal <em>f</em>, then the <a href="https://en.wikipedia.org/wiki/Convolution_theorem">convolution theorem</a> states:</p>
<p>The Fourier transform of a convolution is equal to simple multiplication
between the Fourier transforms of its operands. This fact - along with advanced
algorithms like FFT - make it possible to
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.fftconvolve.html">implement convolutions</a>
very efficiently.</p>
<p>This is a deep and fascinating topic, but we&#39;ll leave it as a story for
another day.</p>
<hr/>



</div>

            </div></div>
  </body>
</html>
