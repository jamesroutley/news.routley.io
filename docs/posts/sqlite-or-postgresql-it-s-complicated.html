<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.twilio.com/blog/sqlite-postgresql-complicated">Original</a>
    <h1>SQLite or PostgreSQL? It&#39;s Complicated</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <section>
        
          <ul>
        
          
          
    
      



<article>
  <header>
  
  
  </header>
  <section>
    
    <div>

<p>We take blogging very seriously at Twilio. To help us understand what content works well and what doesn’t on our blog, we have a dashboard that combines the metadata that we maintain for each article such as author, team, product, publication date, etc., with traffic information from Google Analytics. Users can interactively request charts and tables while filtering and grouping the data in many different ways.</p>
<p><img alt="Dashboard screenshot" height="197" sizes="310px" src="https://twilio-cms-prod.s3.amazonaws.com/images/_3t4ZuHXhvN9M4KvkxWp-XT-pAh4NTbL66pCYvUx4ngmM1.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/_3t4ZuHXhvN9M4KvkxWp-XT-pAh4NTbL66pCYvUx4ngmM1.width-500.png 310w, https://twilio-cms-prod.s3.amazonaws.com/images/_3t4ZuHXhvN9M4KvkxWp-XT-pAh4NTbL66pCYvUx4ngmM.width-1000.png 310w" width="310"/></p>
<p>I chose <a href="https://www.sqlite.org/">SQLite</a> for the database that supports this dashboard, which in early 2021 when I built this system, seemed like a perfect choice for what I thought would be a small, niche application that my teammates and I can use to improve our blogging. But almost a year and a half later, this application tracks daily traffic for close to 8000 articles across the <a href="https://www.twilio.com/blog">Twilio</a> and <a href="https://sendgrid.com/blog/">SendGrid</a> blogs, with about 6.5 million individual daily traffic records, and with a user base that grew to over 200 employees.</p>
<p>At some point I realized that some queries were taking a few seconds to produce results, so I started to wonder if a more robust database such as <a href="https://www.postgresql.org/">PostgreSQL</a> would provide better performance. Having publicly professed my <a href="https://blog.miguelgrinberg.com/post/ignore-all-web-performance-benchmarks-including-this-one">dislike of performance benchmarks</a>, I resisted the urge to look up any comparisons online, and instead embarked on a series of experiments to accurately measure the performance of these two databases for the specific use cases of this application. What follows is a detailed account of my effort, the results of my testing (including a surprising twist!), and my analysis and final decision, which ended up being more involved than I expected.</p>
<h2>Porting the application to PostgreSQL</h2>
<p>The first step that I took was to make sure that I can easily reconfigure the application to use SQLite or PostgreSQL, as this would allow me to run side-by-side comparisons. So I installed PostgreSQL on my Mac laptop to get things working in development.</p>
<p>Adapting the code so that it is compatible with PostgreSQL was relatively easy to achieve because this application uses <a href="https://sqlalchemy.org/">SQLAlchemy</a>, an <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a> library for Python that allows the developer to create schemas and queries using mostly database-independent Python constructs. By making the database connection URL configurable I made it possible to switch between <em>postgresql://</em> and <em>sqlite://</em> URLs. The Python code did not need any modifications, as the differences between these databases were handled internally by SQLAlchemy. SQLAlchemy even created all the tables and indexes on my new PostgreSQL database, exactly as they were in SQLite.</p>
<p>To enable the application to fully work with PostgreSQL, I also needed to migrate the data currently stored in the SQLite database. I used <a href="https://github.com/dimitri/pgloader">pgloader</a>, a fairly complete open source script that imports data from several sources into a PostgreSQL database. Luckily, SQLite is one of the supported data sources.</p>
<p>The easiest way to import data with <code>pgloader</code> is to create a configuration file that defines the source, the destination and the options. Here is the one that I’ve made:</p>
</div>
<div>

<div>
    <div><pre><code>LOAD DATABASE
        FROM ./db.sqlite
        INTO postgresql://username:password@localhost/dbname
        WITH data only
;
</code></pre></div>
</div>
</div>
<div>

<p>The only option that I used is <code>data only</code>, which tells <code>pgloader</code> to not create any tables or indexes, just move data from the source to the destination databases. This is important, because I wanted to have the database schema as close as possible to the SQLite one, and the best way to do that is to let SQLAlchemy create all the tables and indexes.</p>
<p>To perform the data migration, <code>pgloader</code> is invoked with the name of the configuration file as its only argument:</p>
</div>
<div>

<div>
    <div><pre><code>pgloader sqlite-to-pg.conf
</code></pre></div>
</div>
</div>
<div>

<p>After a couple of tries, the import process worked without a hitch. The initial failed attempts alerted me of a couple of potentially serious issues I had in my database design, which SQLite decided not to report or care about:</p>
<ul>
<li>For the article slugs, I have defined a 256 long <code>VARCHAR</code> column. The data migration failed for four articles that had slugs that were longer than the maximum. SQLite, with its <a href="https://www.sqlite.org/datatype3.html">unusual typing system</a>, did not care and stored the longer slugs without complaining. PostgreSQL has strict enforcing of its column types, so these four posts could not be migrated. The solution was to grow the <code>slug</code> column to 512 characters and retry.</li>
<li>Also related to typing, one of my tables initially had integer primary keys, but at some point I decided to change these keys to UUID strings. When I made this change in SQLite I migrated the table by hand, and didn’t realize that I left the primary key column on this table defined as <code>integer</code>. Once again, SQLite happily stored my UUIDs on this column and even indexed them, but to get these across to PostgreSQL I needed to fix the schema and properly declare these keys as strings.</li>
</ul>
<p>At this point, with relatively low effort, I could switch between equivalent SQLite and PostgreSQL databases just by editing the database URL in a configuration file and restarting the Python server.</p>
<p>I manually tested some queries on my development laptop and felt everything was faster with the PostgreSQL database, which was an encouraging first impression.</p>
<h2>Creating a performance test</h2>
<p>My next task was to create a test that is automatable and repeatable, so that I can then test the system under both databases and determine which one wins. Simple, right?</p>
</div>
<div>


<p>In this section I go into a lot of technical details regarding the design and implementation of my test script. While I consider this an important context for anyone interested in undertaking a similar effort, feel free to skip to the results if that is the only thing you care about.</p>
</div>
<div>

<p>Unfortunately, designing a test that covers all the ways this system can be used is very challenging because of the large number of possibilities, as I designed it to let the user create a lot of different queries. For example, it allows the user to obtain traffic stats over a period of time that can cover days, weeks or even years, and categorize the results by article, author, team, product, computer language, written language or publication year. The user can also split the traffic results by country of origin. When retrieving articles, the user can opt to see all the translations of an article grouped with the original. For all queries, the user can filter in or out a section of the data set, given by any combination of authors, teams, products, computer languages, written languages, or publication dates. And all of this can be done for the Twilio or SendGrid blogs, or for both blogs combined.</p>
<p>To avoid going down a rabbit hole, I decided to concentrate on the most common use cases, so I created a list of API requests that represents them. Here is the list that I came up with:</p>
</div>
<div>

<div>
    <div><pre><code>requests = [
    &#39;/api/query/articles?blog=twilio&#39;,
    &#39;/api/query/days?blog=twilio&#39;,
    &#39;/api/query/products?blog=twilio&#39;,
    &#39;/api/query/teams?blog=twilio&#39;,
    &#39;/api/query/authors?blog=twilio&#39;,
    &#39;/api/query/languages?blog=twilio&#39;,
    &#39;/api/query/human_languages?blog=twilio&#39;,
    &#39;/api/query/countries?blog=twilio&#39;,
    &#39;/api/query/article_years?blog=twilio&#39;,
]
</code></pre></div>
</div>
</div>
<div>

<p>These URLs then need to be completed with additional query string arguments. The <code>start</code> and <code>end</code> arguments are required in all queries, as they specify the period of time that is requested. I’ve found that this has a big influence on response times, so my plan was to try different period lengths.</p>
<p>There are a large number of query string arguments that can be used to implement filters. The <code>blog</code> argument that I’ve included in the URLs above selects the Twilio blog, which is the one with the most traffic. I decided not to complicate my testing with other filters, because from looking at usage logs I noticed that most queries by users do not include any.</p>
<p>Armed with this list, I created a short Python function that runs through these queries and records how long each query took in a <code>results</code> dictionary:</p>
</div>
<div>

<div>
    <div><pre><code>import random
import subprocess
from timeit import timeit

requests = [
    # ...
]
results = {url: [] for url in requests}

def test(server, apikey, start, end):
    requests_copy = requests[:]
    random.shuffle(requests_copy)
    for url in requests_copy:
        t = timeit(lambda: subprocess.check_call(
            [&#39;curl&#39;, &#39;-f&#39;, f&#39;{server}{url}&amp;start={start}&amp;end={end}&#39;, &#39;-H&#39;,
             f&#39;Authorization: Bearer {apikey}&#39;],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
        ), number=1)
        results[url].append(t)
</code></pre></div>
</div>
</div>
<div>

<p>The <code>test()</code> function makes a copy of the <code>requests</code> list, reorders it in a random way, and then runs the request with <code>curl</code> as a subprocess. It uses the <code>timeit()</code> function from the Python standard library to measure the time it takes for each query to return a response, and adds this measurement to the <code>results</code> dictionary, under the corresponding URL.</p>
<p>The reason I’m randomizing the list is that I intend to run multiple instances of this function in parallel to simulate concurrent clients. Having the function go through the queries in random order is convenient, as that ensures the database will have a variety of queries to work for at any given time, instead of receiving several instances of the same query.</p>
<p>The function receives the domain portion of the URL as the <code>server</code> argument. I wanted this to be easily configurable, so that I can switch between my development and production systems. An API key is also passed into this function, so that the requests can be authenticated. Finally, the required <code>start</code> and <code>end</code> query string arguments are passed in and added to the URL before making the request.</p>
<p>The <code>results</code> dictionary uses the URLs from the <code>requests</code> list as keys. For each key, I store an array of results and not just a single value, as this would allow me to record multiple runs for each query and get an average.</p>
<p>To complete my test script, I added a <code>run_test()</code> function and a command-line parser:</p>
</div>
<div>

<div>
    <div><pre><code>import argparse
import random
import subprocess
from threading import Thread
from timeit import timeit

requests = [
    # ...
]
results = {url: [] for url in requests}

def test(server, apikey, start, end):
    # ...

def run_test(num_threads, server, apikey, start, end):
    threads = [Thread(target=test, args=(server, apikey, start, end))
               for _ in range(num_threads)]
    for thread in threads:
        thread.start()
    for thread in threads:
        thread.join()

    total_sum = 0
    total_n = 0
    for url in sorted(results.keys()):
        total_sum += sum(results[url])
        total_n += len(results[url])
        avg = sum(results[url]) / len(results[url])
        print(f&#39;{url}: {avg:.2f}&#39;)
    avg = total_sum / total_n
    print(f&#39;Total Query Average: {avg:.2f}&#39;)

parser = argparse.ArgumentParser()
parser.add_argument(&#39;--clients&#39;, &#39;-c&#39;, metavar=&#39;N&#39;, type=int, default=2,
                    help=&#39;number of concurrent clients (default: 2)&#39;)
parser.add_argument(&#39;--start-date&#39;, &#39;-s&#39;, metavar=&#39;DATE&#39;, default=&#39;2021-01-01&#39;,
                    help=&#39;query start date (default: 2021-01-01)&#39;)
parser.add_argument(&#39;--end-date&#39;, &#39;-e&#39;, metavar=&#39;DATE&#39;, default=&#39;2021-12-31&#39;,
                    help=&#39;query end date (default: 2021-12-31)&#39;)
parser.add_argument(&#39;server&#39;, metavar=&#39;SERVER&#39;,
                    help=&#39;server to connect to.&#39;)
parser.add_argument(&#39;apikey&#39;, metavar=&#39;APIKEY&#39;,
                    help=&#39;API key to authenticate with.&#39;)

args = parser.parse_args()
run_test(args.clients, args.server, args.apikey, args.start_date,
         args.end_date)
</code></pre></div>
</div>
</div>
<div>

<p>The <code>run_test()</code> function launches one or more threads, according to the <code>num_threads</code> argument. All the threads are configured to run the <code>test()</code> function in parallel. This simulates load coming from multiple concurrent clients, each going through the list of URLs in their own random order, to create some unpredictability.</p>
<p>After all the threads have ended, <code>run_test()</code> prints the average request time for each request URL, and also an average of all the queries combined, which is the metric I decided to use for my analysis.</p>
<p>The command-line arguments allow me to pass the server root, the API key and the start and end dates to query and the concurrency. With these controls I have the ability to test a variety of scenarios.</p>
<p>The test script is now ready, so it’s time to get some metrics!</p>
<h2>Testing on the development system</h2>
<p>The development system that I work on is a Mac laptop with 6 hyperthreaded cores and 16GB of RAM. The production environment for this dashboard is a Linode virtual server with 1 vCPU and 2GB RAM.</p>
<p>From past experiences with benchmarking, I know that results from a fast system are not always the same as a slower one, so my end goal is to test the production system and make decisions based on the results I get on that platform.</p>
<p>But before doing that, I wanted to do a first round of “practice” tests on my laptop, both as a way to ensure that the test script was working correctly, and also, why not admit it, because I was curious about how these two databases perform on a fairly powerful platform.</p>
<p>The testing methodology that I decided to use is as follows: I would test the system running under the two databases, for queries with periods of a week, a month, a quarter and a year, with all queries having 2021-01-01 as the start date. I would also repeat the tests with 1, 2 and 4 concurrent clients. For each individual test I would run the script three times, and record the best run of the three. The metric I would use is the total average of all queries.</p>
<p>With this plan I ended up with 24 data points (2 databases x 4 query periods x 3 concurrency levels). The following chart shows the response time for PostgreSQL (blue) and SQLite (red), with a single client.</p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/W_FxZVm0ioLyr9tDxD6n-1L57lUYZcMXkW4OAJplUYgiD5.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/W_FxZVm0ioLyr9tDxD6n-1L57lUYZcMXkW4OAJplUYgiD5.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/W_FxZVm0ioLyr9tDxD6n-1L57lUYZcMXkW4OAJplUYgiD.width-1000.png 444w" width="444"/></p>
<p>Here it is very clear that PostgreSQL returns results faster, and is especially efficient for shorter queries. PostgreSQL’s response times increase more or less linearly as the query period grows, but SQLite interestingly had a near flat response time on the first three tests and then suffered greatly on the last one.</p>
<p>Below are the charts for the same test with 2 and 4 concurrent clients.</p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="445px" src="https://twilio-cms-prod.s3.amazonaws.com/images/W9aB15ndX9W58mbp1Q-iqZY2XC9em6v5SeZsb4EPZ7LUYF.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/W9aB15ndX9W58mbp1Q-iqZY2XC9em6v5SeZsb4EPZ7LUYF.width-500.png 445w, https://twilio-cms-prod.s3.amazonaws.com/images/W9aB15ndX9W58mbp1Q-iqZY2XC9em6v5SeZsb4EPZ7LUY.width-1000.png 445w" width="445"/></p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/rq8ZryIFPz-l_pONvGTyweOYpY3Pc4N40EViKNzQHhlZP8.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/rq8ZryIFPz-l_pONvGTyweOYpY3Pc4N40EViKNzQHhlZP8.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/rq8ZryIFPz-l_pONvGTyweOYpY3Pc4N40EViKNzQHhlZP.width-1000.png 444w" width="444"/></p>
<p>I thought it was interesting that changing the concurrency doesn’t appear to have a great impact on response times for most tests, likely due to the multiple cores I have on this laptop. The only case in which there is a difference is in the year-long queries, where PostgreSQL appears to suffer proportionally more than SQLite.</p>
<p>To help visualize this, below is a chart that shows the response times for the PostgreSQL tests, comparing the three levels of concurrency for each of the query periods.</p>
<p><img alt="PostgreSQL chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/aBU3bl4UOXtLd9vk1wVv_l4jRidILrj9nIangxHKbVfTa2.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/aBU3bl4UOXtLd9vk1wVv_l4jRidILrj9nIangxHKbVfTa2.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/aBU3bl4UOXtLd9vk1wVv_l4jRidILrj9nIangxHKbVfTa.width-1000.png 444w" width="444"/></p>
<p>This confirms that for queries involving a small or medium number of rows, a concurrency of up to four clients does not affect response times in a big way. But as the number of rows involved grows, a higher concurrency does start to slow things down.</p>
<p>Here is the same chart for SQLite:</p>
<p><img alt="SQLite chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/8uA_vWt1ELzCRI57qXkb9Hu2NRCtrPWk3XSn9xH4_KCP12.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/8uA_vWt1ELzCRI57qXkb9Hu2NRCtrPWk3XSn9xH4_KCP12.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/8uA_vWt1ELzCRI57qXkb9Hu2NRCtrPWk3XSn9xH4_KCP1.width-1000.png 444w" width="444"/></p>
<p>And this is actually a surprise, because this shows that SQLite can handle concurrent loads much better than PostgreSQL on this system. Of course the response times are longer here, but the fact that concurrency has less of an effect on these response times is very interesting.</p>
<p>Will the production platform show similar results? My expectation is that a single CPU, compared to the 6 on my laptop, is going to make concurrency a much bigger factor in the results.</p>
<h2>Testing on the production system</h2>
<p>Armed with a now well tested benchmarking script, I booted a new Linode with a clone of the production system, repeated all the steps to migrate the SQLite database to PostgreSQL, and made sure that I can, once again, easily switch databases by editing the configuration file and restarting the service.</p>
<p>For this testing effort I decided to run the test script on my own laptop, so all the latencies involved in the traffic going over the Internet, encryption and proxying would be included in the results. I could have chosen to run the tests on the same host as the service and avoid these extra costs, but in the end, my goal is to make the service perform better for users, and users have no choice but to go through all these seemingly unrelated layers.</p>
<p>Here is the chart that I obtained when using a concurrency of one:</p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/R0p8Y55g5PLsRN99excJcllXW8N3gjw5shp9pY0w7QIinE.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/R0p8Y55g5PLsRN99excJcllXW8N3gjw5shp9pY0w7QIinE.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/R0p8Y55g5PLsRN99excJcllXW8N3gjw5shp9pY0w7QIin.width-1000.png 444w" width="444"/></p>
<p>And this is a totally unexpected twist. The lines are crossing!</p>
<p>PostgreSQL beats SQLite on the short and medium length queries, but it has a lot of trouble with the year long query, which takes almost twice as long as SQLite. In case you are thinking that this must have been a fluke, I repeated these tests several times and confirmed that these results are actually correct.</p>
<p>Here are the charts for 2 and 4 clients on this production server.</p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/gBk6nYw1mQonTSbgGZtQRfcMOfexVIJzbdCgB3X0TYRc5o.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/gBk6nYw1mQonTSbgGZtQRfcMOfexVIJzbdCgB3X0TYRc5o.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/gBk6nYw1mQonTSbgGZtQRfcMOfexVIJzbdCgB3X0TYRc5.width-1000.png 444w" width="444"/></p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/zxEDYTQPBCEcvGVSLrmwCSyz9qQ9kvNBh-gIxCqiIRO5QM.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/zxEDYTQPBCEcvGVSLrmwCSyz9qQ9kvNBh-gIxCqiIRO5QM.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/zxEDYTQPBCEcvGVSLrmwCSyz9qQ9kvNBh-gIxCqiIRO5Q.width-1000.png 444w" width="444"/></p>
<p>While the shapes of the curves are pretty much identical at all concurrency levels, you just need to look at the scale of the Y axes to see that on this platform, response times are much more affected by concurrency than my laptop. For the year-long query with four concurrent clients the response times were extremely slow, at about 14 and 8 seconds for PostgreSQL and SQLite respectively.</p>
<p>Are PostgreSQL and SQLite equally affected by concurrency? Let’s look at them separately to find out. The next chart shows how PostgreSQL did on the four period lengths with 1, 2 and 4 concurrent clients.</p>
<p><img alt="PostgreSQL chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/oMVp5bXYZCm-GOeWiXxLU_Kllun7z8PVeVC1O5Q5PjIyqH.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/oMVp5bXYZCm-GOeWiXxLU_Kllun7z8PVeVC1O5Q5PjIyqH.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/oMVp5bXYZCm-GOeWiXxLU_Kllun7z8PVeVC1O5Q5PjIyq.width-1000.png 444w" width="444"/></p>
<p>This shows that for this database, things get very much out of control for large queries, but for small and medium sized queries response times are relatively stable.</p>
<p>Below is the same chart for SQLite:</p>
<p><img alt="SQLite chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/rr-rXFmYJVvzqHJz0IkMFbiCE4ses79_cxq2Js1iT-ztYr.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/rr-rXFmYJVvzqHJz0IkMFbiCE4ses79_cxq2Js1iT-ztYr.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/rr-rXFmYJVvzqHJz0IkMFbiCE4ses79_cxq2Js1iT-ztY.width-1000.png 444w" width="444"/></p>
<p>This paints a different picture, right? With a single CPU, concurrency in SQLite plays a role even for the small and medium sized queries. Response times grow less than linearly, but they always grow, even on the smaller tests.</p>
<p>To help me visualize these differences better, I created another set of charts. For each query period that I tested, the following charts compare the two databases at each concurrency point.</p>
<p><img alt="PostgreSQL vs. SQLite comparison charts" height="461" sizes="729px" src="https://twilio-cms-prod.s3.amazonaws.com/images/6curzmxEHS9I89gaYR6L0oC-vEpHJWqKze-tDLIDypppGv.width-800.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/6curzmxEHS9I89gaYR6L0oC-vEpHJWqKze-tDLIDypppGv.width-800.png 729w, https://twilio-cms-prod.s3.amazonaws.com/images/6curzmxEHS9I89gaYR6L0oC-vEpHJWqKze-tDLIDypppG.width-1600.png 729w" width="729"/></p>
<p>These charts clearly show that PostgreSQL can handle the small and medium queries much better than SQLite, to the point that increasing the concurrency has a very small effect in response times, which is great. SQLite, on the other side, is more directly affected by concurrency for all query sizes, and while it performs worse in the small and medium sized queries, it ends up significantly ahead of PostgreSQL for the longer queries.</p>
<h2>Fine tuning for performance</h2>
<p>Up until now, I have not worried about configuring the databases, I simply assumed the default configuration would be good enough. In the case of SQLite <a href="https://www.sqlite.org/zeroconf.html">there isn’t much to configure</a>, but PostgreSQL does have some tuning levers to play with.</p>
<p>After looking through the configuration options related to <a href="https://www.postgresql.org/docs/current/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-MEMORY">memory usage</a>, I’ve found the <code>work_mem</code> option, which configures how much memory each query can use before it starts storing data in temporary disk files. The default for this option is 4MB. I changed it to 16MB:</p>
</div>

<div>

<p>The week, month and quarter tests had similar response times as before. But this change did improve the longer queries. Below are the charts for 1, 2 and 4 clients after I ran the year-long PostgreSQL tests again:</p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/8uHxGJ37xKZSnYO7TLKWilKW9SRmPsTaD-P_4MilJEMgvU.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/8uHxGJ37xKZSnYO7TLKWilKW9SRmPsTaD-P_4MilJEMgvU.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/8uHxGJ37xKZSnYO7TLKWilKW9SRmPsTaD-P_4MilJEMgv.width-1000.png 444w" width="444"/></p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/5HElvjbRdlNMJwe_zfEscIKUYnbH1Y2s2nXeBlFmXzciHO.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/5HElvjbRdlNMJwe_zfEscIKUYnbH1Y2s2nXeBlFmXzciHO.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/5HElvjbRdlNMJwe_zfEscIKUYnbH1Y2s2nXeBlFmXzciH.width-1000.png 444w" width="444"/></p>
<p><img alt="PostgreSQL vs. SQLite comparison chart" height="276" sizes="444px" src="https://twilio-cms-prod.s3.amazonaws.com/images/y3AFoIj2sqNSCAr1Jd2eO5yd9tK7sFn4ZH7UWWmNwt0-TV.width-500.png" srcset="https://twilio-cms-prod.s3.amazonaws.com/images/y3AFoIj2sqNSCAr1Jd2eO5yd9tK7sFn4ZH7UWWmNwt0-TV.width-500.png 444w, https://twilio-cms-prod.s3.amazonaws.com/images/y3AFoIj2sqNSCAr1Jd2eO5yd9tK7sFn4ZH7UWWmNwt0-T.width-1000.png 444w" width="444"/></p>
<p>With this change, the lines uncrossed, and PostgreSQL started returning faster than SQLite even for the longer queries. For the heavier test with year-long queries and four clients, response times went from 14 seconds down to 6 with the memory-tuned database server. These queries are still slower than I would like, but considering I’m running on a low-end platform I think they are reasonable.</p>
<h2>Conclusion</h2>
<p>As I’m sure you can guess, after the results I obtained I decided to switch to PostgreSQL. After upgrading the production system, I informally asked a few users about performance and all thought the system was responding noticeably faster than before, so my mission was accomplished.</p>
<p>If you are going to take one thing away from this article, I hope it is that the only benchmarks that are valuable are those that run on your own platform, with your own stack, with your own data, and with your own software. And even then, you may need to add custom optimizations to get the best performance.</p>
<p>In terms of improving performance even further, this testing exercise leaves me with two possible avenues:</p>
<ul>
<li>If I get the budget, I now know that adding CPUs is likely to improve those longer tests. Switching to a dedicated server with 4 CPUs should make a considerable difference and bring response times closer to what I measured on my laptop.</li>
<li>Without throwing additional money at the problem, the main area of improvement is in those longer queries, which could maybe be simplified if the database stored precalculated monthly totals in addition to the daily data. A year of traffic could then be retrieved from 12 rows per article instead of 365. Some of the savings will be offset by more complex logic when queries are not aligned on month boundaries, but overall this should reduce the longer query times.</li>
</ul>
<p>I hope you found some new ideas in this article, and you are encouraged to benchmark and optimize your own projects!</p>
<p><em><a href="mailto:mgrinberg@twilio.com">Miguel Grinberg</a></em><em> is a Principal Software Engineer for Technical Content at Twilio. Reach out to him at </em><em><a href="mailto:mgrinberg@twilio.com">mgrinberg [at] twilio [dot] com</a></em><em> if you have a cool project you’d like to share on this blog!</em></p>
</div>
    
    
    

    

    

    
  </section>
</article>


    

        
          </ul>
        
      </section>
    </div></div>
  </body>
</html>
