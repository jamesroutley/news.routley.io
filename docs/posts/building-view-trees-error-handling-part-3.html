<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-3/">Original</a>
    <h1>Building view-trees: Error Handling [Part 3]</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        

        

        

        <section>
            <p>Previously: <a href="https://solar.lowtechmagazine.com/writes/building-view-trees-in-go-part-1">intro</a>, and <a href="https://solar.lowtechmagazine.com/writes/building-view-trees-in-go-part-2">the basics</a>.</p>
<hr/>
<p>We have a bunch of assumptions about what things can fail
and which ones cannot.</p>
<p>Right now, any error will bubble all of the way out of the render
pipeline, and template rendering will fail. If a slot render fails,
the same thing will happen. Any template parsing can/will bubble up
as well, any data fetching, anything that happens during the
<code>Renderable</code> call.</p>
<p>There are a few ways we can build and execute Render. The views
either populate data top down, or they fetch data lazilly,
they can do validation, they can not, each of these can fail.</p>
<h2 id="handling-errors-err-nil">Handling errors, <code>err != nil</code></h2>
<p>Something that can eventually be rendered, something that is <code>AsRenderable</code>
should also be able to handle its own error failure, or handle
a failure lower down in the tree.</p>
<p>Handling errors will introduce another refactor to
our renderer, but will keep our UX/API <em>small</em> and opt-in.</p>
<h3 id="marker-interfaces-duck-typing-yo">Marker interfaces (duck typing yo)</h3>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>ErrorRenderable </span><span>interface </span><span>{
</span><span>    </span><span>ErrorRenderable</span><span>(err </span><span>error</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>)
</span><span>}
</span></code></pre>
<p>And our logic to handle the error is pretty simple:</p>
<ul>
<li>Check to see if we actually have an error handler
<ul>
<li>If we don&#39;t we bubble up the error.</li>
</ul>
</li>
<li>Check to see if the erro handler wants to handle
the error itself.
<ul>
<li>Returning an error means we want to buble it up.</li>
<li>Returning <code>nil</code> for the <code>AsRenderable</code> means we
don&#39;t care about this error at all. OK to move on.</li>
<li>Do we have something to render?
<ul>
<li>Try to do so!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>Note:</em> It is definitely the case here that if our error
handler fails to render and it is <code>ErrorRenderable</code> as well
we&#39;ll keep trying.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>handleRenderError</span><span>(err </span><span>error</span><span>, with </span><span>any</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>var </span><span>empty template.</span><span>HTML
</span><span>
</span><span>    </span><span>if </span><span>with </span><span>== </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    errRenderable, ok </span><span>:= </span><span>with.(</span><span>ErrorRenderable</span><span>)
</span><span>    </span><span>if !</span><span>ok {
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    r, err </span><span>:= </span><span>errRenderable.ErrorRenderable(err)
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    </span><span>if </span><span>r </span><span>== </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, </span><span>nil
</span><span>    }
</span><span>
</span><span>    </span><span>return </span><span>Render(r)
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      with handleRenderError and ErrorRenderable
      <a href="https://github.com/stanistan/veun/commit/400a872b27bc9fdb4a03ce1f1c2b8084702be132">(source: 400a872b)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/error_renderable.go b/error_renderable.go
</span><span>new file mode 100644
</span><span>index 0000000..63159e8
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/error_renderable.go
</span><span>@@ -0,0 +1,39 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import &#34;html/template&#34;
</span><span>+
</span><span>+</span><span>type ErrorRenderable interface {
</span><span>+</span><span>	// ErrorRenderable can return bubble the error
</span><span>+</span><span>	// back up, which will continue to fail the render
</span><span>+</span><span>	// the same as it did before.
</span><span>+</span><span>	//
</span><span>+</span><span>	// It can also return nil for Renderable,
</span><span>+</span><span>	// which will ignore the error entirely.
</span><span>+</span><span>	//
</span><span>+</span><span>	// Otherwise we will attempt to render next one.
</span><span>+</span><span>	ErrorRenderable(err error) (AsRenderable, error)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func handleRenderError(err error, with any) (template.HTML, error) {
</span><span>+</span><span>	var empty template.HTML
</span><span>+
</span><span>+</span><span>	if with == nil {
</span><span>+</span><span>		return empty, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	errRenderable, ok := with.(ErrorRenderable)
</span><span>+</span><span>	if !ok {
</span><span>+</span><span>		return empty, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	r, err := errRenderable.ErrorRenderable(err)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		return empty, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	if r == nil {
</span><span>+</span><span>		return empty, nil
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return Render(r)
</span><span>+</span><span>}
</span><span>diff --git a/render_container_error_test.go b/render_container_error_test.go
</span><span>new file mode 100644
</span><span>index 0000000..8052a8d
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/render_container_error_test.go
</span><span>@@ -0,0 +1,96 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;errors&#34;
</span><span>+</span><span>	&#34;fmt&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+
</span><span>+</span><span>	. &#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type FailingView struct {
</span><span>+</span><span>	Err error
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v FailingView) Renderable() (Renderable, error) {
</span><span>+</span><span>	return nil, fmt.Errorf(&#34;FailingView.Renderable(): %w&#34;, v.Err)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type FallibleView struct {
</span><span>+</span><span>	CapturesErr error
</span><span>+</span><span>	Child       AsRenderable
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v FallibleView) Renderable() (Renderable, error) {
</span><span>+</span><span>	return v.Child.Renderable()
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v FallibleView) ErrorRenderable(err error) (AsRenderable, error) {
</span><span>+</span><span>	if v.CapturesErr == nil {
</span><span>+</span><span>		return nil, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	if errors.Is(err, v.CapturesErr) {
</span><span>+</span><span>		return ChildView1{}, nil
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return nil, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestRenderContainerWithFailingView(t *testing.T) {
</span><span>+</span><span>	_, err := Render(ContainerView2{
</span><span>+</span><span>		Heading: ChildView1{},
</span><span>+</span><span>		Body: FailingView{
</span><span>+</span><span>			Err: fmt.Errorf(&#34;construction: %w&#34;, errSomethingFailed),
</span><span>+</span><span>		},
</span><span>+</span><span>	})
</span><span>+</span><span>	assert.IsError(t, err, errSomethingFailed)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestRenderContainerWithCapturedError(t *testing.T) {
</span><span>+</span><span>	t.Run(&#34;errors_bubble_out&#34;, func(t *testing.T) {
</span><span>+</span><span>		_, err := Render(ContainerView2{
</span><span>+</span><span>			Heading: ChildView1{},
</span><span>+</span><span>			Body: FallibleView{
</span><span>+</span><span>				Child: FailingView{Err: errSomethingFailed},
</span><span>+</span><span>			},
</span><span>+</span><span>		})
</span><span>+</span><span>		assert.IsError(t, err, errSomethingFailed)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;errors_can_push_replacement_views&#34;, func(t *testing.T) {
</span><span>+</span><span>		html, err := Render(ContainerView2{
</span><span>+</span><span>			Heading: ChildView1{},
</span><span>+</span><span>			Body: FallibleView{
</span><span>+</span><span>				Child:       FailingView{Err: errSomethingFailed},
</span><span>+</span><span>				CapturesErr: errSomethingFailed,
</span><span>+</span><span>			},
</span><span>+</span><span>		})
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+</span><span>		assert.Equal(t, template.HTML(`&lt;div&gt;
</span><span>+</span><span>	&lt;div class=&#34;heading&#34;&gt;HEADING&lt;/div&gt;
</span><span>+</span><span>	&lt;div class=&#34;body&#34;&gt;HEADING&lt;/div&gt;
</span><span>+</span><span>&lt;/div&gt;`), html)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;errors_can_return_nil_views&#34;, func(t *testing.T) {
</span><span>+</span><span>		html, err := Render(ContainerView2{
</span><span>+</span><span>			Heading: ChildView1{},
</span><span>+</span><span>			Body: FallibleView{
</span><span>+</span><span>				Child:       FailingView{Err: errors.New(&#34;hi&#34;)},
</span><span>+</span><span>				CapturesErr: errSomethingFailed,
</span><span>+</span><span>			},
</span><span>+</span><span>		})
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+</span><span>		assert.Equal(t, template.HTML(`&lt;div&gt;
</span><span>+</span><span>	&lt;div class=&#34;heading&#34;&gt;HEADING&lt;/div&gt;
</span><span>+</span><span>	&lt;div class=&#34;body&#34;&gt;&lt;/div&gt;
</span><span>+</span><span>&lt;/div&gt;`), html)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>var errSomethingFailed = errors.New(&#34;an error&#34;)
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>index cb2c5f0..27d3abc 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -16,12 +16,17 @@ type AsRenderable interface {
</span><span> }
</span><span> 
</span><span> func Render(r AsRenderable) (template.HTML, error) {
</span><span>-	rr, err := r.Renderable()
</span><span>+</span><span>	renderable, err := r.Renderable()
</span><span> 	if err != nil {
</span><span>-		return template.HTML(&#34;&#34;), err
</span><span>+</span><span>		return handleRenderError(err, r)
</span><span> 	}
</span><span> 
</span><span>-	return render(rr)
</span><span>+</span><span>	out, err := render(renderable)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		return handleRenderError(err, r)
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return out, nil
</span><span> }
</span><span> 
</span><span> func render(r Renderable) (template.HTML, error) {
</span><span>
</span></code></pre>


  </details>
</div>
<h3 id="fallible-views">Fallible Views!</h3>
<p>With this in hand, and a quick change to the <code>Render</code> function to
call this instead of returning an error, we get some neat behavior,
and an example of composition based <em>delegation</em>.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>FallibleView </span><span>struct </span><span>{
</span><span>    Contents     </span><span>AsRenderable
</span><span>    ErrorHandler </span><span>func</span><span>(err </span><span>error</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>)
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>FallibleView</span><span>) </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>v.Contents.Renderable()
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>FallibleView</span><span>) </span><span>ErrorRenderable</span><span>(err </span><span>error</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>v.ErrorHandler(err)
</span><span>}
</span></code></pre>
<p>This starts to show the kind of thing we can do with composition and this
libary.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>logWarningErrorHandler</span><span>(err </span><span>error</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>    log.Printf(</span><span>&#34;something failed, but it&#39;s ok: </span><span>%s</span><span>&#34;</span><span>, err)
</span><span>    </span><span>return </span><span>nil</span><span>, </span><span>nil </span><span>// we don&#39;t care for this example
</span><span>}
</span><span>
</span><span>html, err </span><span>:= </span><span>Render(FallibleView{
</span><span>    Contents:     someViewThatMightFailToRender,
</span><span>    ErrorHandler: logWarningErrorHandler,
</span><span>})
</span></code></pre>
<p>Or more realistically a situation where you&#39;re not sure what
you are rendering in some slot.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>(v </span><span>Container</span><span>) </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>View{
</span><span>        </span><span>// ... snip ...
</span><span>        Slots: Slots{
</span><span>            </span><span>&#34;extra_content&#34;</span><span>: FallibleView{
</span><span>                Contents:     v.ContentFactory(),
</span><span>                ErrorHandler: logWarningErrorHandler,
</span><span>            },
</span><span>        },
</span><span>    }, </span><span>nil
</span><span>}
</span></code></pre>
<p>You can see this in action in the tests in the patch above where
we use <code>errors.Is(err, somethingKnown)</code> to do error bubbling or
handling.</p>
<p>Error handling is going to be much more important when we get
to doing <em>real things</em> like data access.</p>

        </section>

        

    </article></div>
  </body>
</html>
