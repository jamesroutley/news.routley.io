<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2025-06-03-people-keep-inventing-prolly-trees/">Original</a>
    <h1>People Keep Inventing Prolly Trees</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p><strong>Multiple Discovery</strong> refers to when a scientific discovery is made independently by multiple individuals around the same time. The most well-known examples are Isaac Newton and Gottfried Leibniz&#39;s independent invention of calculus, and Charles Darwin and Alfred Russel Wallace&#39;s independent formulation of the theory of evolution.</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/7bc31b7a72f9060d2c2934a70c74167e/50383/xkcd-calculus.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="XKCD 626: Newton and Leibniz" title="" src="https://www.dolthub.com/blog/static/7bc31b7a72f9060d2c2934a70c74167e/50383/xkcd-calculus.png" srcset="/blog/static/7bc31b7a72f9060d2c2934a70c74167e/a48b3/xkcd-calculus.png 214w,
/blog/static/7bc31b7a72f9060d2c2934a70c74167e/47730/xkcd-calculus.png 428w,
/blog/static/7bc31b7a72f9060d2c2934a70c74167e/50383/xkcd-calculus.png 740w" sizes="(max-width: 740px) 100vw, 740px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>(Source: <a href="https://xkcd.com/626/">https://xkcd.com/626/</a>)</p>
<p>There&#39;s even a hypothesis<sup id="fnref-1"><a href="#fn-1">1</a></sup> that multiple discovery is the norm, rather than an exception: that invention is an result of social conditions rather than any single &#34;great thinker&#34;, and that once the conditions for a discovery are met, that discovery is often made multiple times in rapid succession.</p>
<p>It&#39;s not always immediately obvious when multiple discovery happens. There&#39;s several reasons why a case of multiple discovery might go unnoticed:</p>
<ul>
<li>New inventions may bring new terminology or be used in different fields for different purposes. It may require an intimate understanding of the field to even realize that these separate inventions are actually the same thing.</li>
<li>Sometimes an invention is not widely known because its creator doesn&#39;t realize they&#39;ve created something novel: the design seemed obvious and intuitive to them.</li>
</ul>
<p>But if we see multiple discovery happening, it&#39;s a strong indication that the thing being discovered is in enough demand that it&#39;s going to <em>keep</em> being discovered, at least until knowledge of it eventually becomes commonplace. And it won&#39;t stop being discovered even then: <a href="https://en.wikipedia.org/wiki/Tai%27s_model">calculus was still being discovered in 1994.</a></p>
<p>This is all relevant because of how it relates to one of our favorite data structures: <a href="https://www.dolthub.com/blog/2024-03-03-prolly-trees/">prolly trees</a>.</p>
<p>We talk about prolly trees a lot, because they&#39;re the novel tool that makes Dolt possible. We didn&#39;t invent them, we have <a href="https://github.com/attic-labs/noms/">Noms</a> to thank for that. But we did see the value in using them to build the world&#39;s first version controlled relational database.</p>
<p>Except it turns out that Noms isn&#39;t the only group to invent prolly trees. Just like calculus, prolly trees have been independently invented at least four times now, under different names and used in different contexts. And I think that&#39;s worth a closer look.</p>
<h2 id="2015-noms-invents-prolly-trees"><a href="#2015-noms-invents-prolly-trees" aria-label="2015 noms invents prolly trees permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2015: Noms Invents Prolly Trees</h2>
<p>In 2015, Noms <a href="https://github.com/attic-labs/noms/blob/master/doc/intro.md#prolly-trees-probabilistic-b-trees">coined the term &#34;Prolly Tree&#34;</a> for their tree data structure with the following really nice properties:</p>
<ul>
<li><strong>searchable</strong> - They can store ordered data and perform lookups based on ordered keys or offsets.</li>
<li><strong>history independence</strong> - <a href="https://www.dolthub.com/blog/2024-11-26-history-independence/">Any data set has a unique representation, regardless of the sequence of operations that led to the current state.</a></li>
<li><strong>self-balancing</strong> - The tree is probabilistically balanced.</li>
<li><strong>structural sharing</strong> - <a href="https://www.dolthub.com/blog/2020-05-13-dolt-commit-graph-and-structural-sharing/">Storing multiple versions of the data only requires additional storage proportional to their diff: duplicate parts of the data are deduplicated.</a></li>
<li><strong>efficient diffing</strong> - <a href="https://www.dolthub.com/blog/2020-06-16-efficient-diff-on-prolly-trees/">It&#39;s possible to compare two prolly trees (or two snapshots of the same prolly tree) and identify only the parts of the data that are different between the two trees.</a> The time complexity is logarithmic on the total data size, and is only linear on the size of the diff.</li>
<li><strong>efficient mutation</strong> - Applying changes to the data stored in a prolly tree produces a new prolly tree. Like with diffing, the time complexity is logarithmic on the total data size, and is only linear on the size of the diff.</li>
</ul>
<p>These properties make prolly trees great whenever you need to version control structured data, or need to reconcile data changes that may be received out-of-order.</p>
<p>I genuinely think prolly trees are novel. But I also think that they&#39;re are a textbook example of something that seems like an natural next step once you understand the prior work that it&#39;s built on: the novelty isn&#39;t in creating something new, but in combining existing math in a novel way. A prolly tree is ultimately nothing more than a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</a> built by recursively applying a <a href="https://joshleeb.com/posts/content-defined-chunking.html">Content-Defined Chunker</a>, such as with a <a href="https://en.wikipedia.org/wiki/Rolling_hash">rolling hash function</a>.</p>
<p>None of these concepts are new:</p>
<ul>
<li>Content-Defined Chunking is a core part of <a href="https://en.wikipedia.org/wiki/Rsync">rsync</a>, which was first released in 1996, although the concept itself is even older.</li>
<li>The first rolling hash function, the <a href="https://en.wikipedia.org/wiki/Rabin_fingerprint">Rabin fingerprint</a>, was proposed in 1981.</li>
<li>Merkle trees were patented in 1979.</li>
</ul>
<p>If you understand these individual concepts, it&#39;s easy to see how they can be combined to create a tree structure that has all of these properties. It just took a little while to reach a point where prolly trees were needed.</p>
<p>In fact, there&#39;s a lot of prior art of things that are <em>almost</em> prolly trees:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Rsync">rsync</a> uses content-defined chunking to split large files, but stores the chunk hashes in a flat list instead of in a Merkle tree.</li>
<li><a href="https://en.wikipedia.org/wiki/BitTorrent">BitTorrent</a> magnet links represent the torrent data as a Merkle tree of chunks, but the chunks are fixed-size, not content-defined.</li>
<li><a href="https://ipfs.tech/">IPFS</a> uses content-defined chunking to split large files, and then represents these chunks as a Merkle tree, but because the content-defined chunking is not applied recursively, the inner nodes of the tree are prone to shift.</li>
</ul>
<p>It&#39;s not clear what the exact catalyst was that spurred the creation of true prolly trees. But <a href="https://www.pfrazee.com">Paul Frazee</a> has a theory. Frazee is the co-creator and developer of a number of platforms and protocols that we&#39;ve discussed on this blog, including <a href="https://github.com/holepunchto/hypercore">Hypercore</a> and BlueSky&#39;s <a href="https://atproto.com/">ATProto</a>. He&#39;s worked with prolly trees, although he calls them &#34;Merkle Search Trees&#34; for reasons that we&#39;ll get to. He posited that <a href="https://www.pfrazee.com/blog/why-not-p2p#the-2014-generation-of-p2p">a general dissatisfaction with the state of the Web circa 2014</a> led to renewed interest in p2p networks around that time. And p2p networks would have a lot more need for the properties the prolly trees provide.</p>
<p>He may be up to something with that 2014 theory, since Noms released their design and implementation a year later.</p>
<p>The Noms implementation is what Dolt is built upon, as we touched on in <a href="https://www.dolthub.com/blog/2025-06-02-dolt-turns-10/">Monday&#39;s blog post celebrating the 10th anniversary of Dolt&#39;s codebase</a>. While Noms may have created the design, DoltHub <a href="https://www.dolthub.com/blog/2022-06-27-prolly-chunker/">innovated on it</a>, incorporating improvements such as:</p>
<ul>
<li>Using a cumulative distribution function to control the size of tree nodes and better balance the tree.</li>
<li>Only hashing keys when storing key-value pairs, so that merely updating values can&#39;t change the shape of the tree.</li>
</ul>
<p>But in a textbook case of multiple discovery, Noms wouldn&#39;t be the only ones to discover the concept, and DoltHub wouldn&#39;t be the only ones to build applications with it.</p>
<h2 id="2019-france-invents-merkle-search-trees-aka-prolly-trees"><a href="#2019-france-invents-merkle-search-trees-aka-prolly-trees" aria-label="2019 france invents merkle search trees aka prolly trees permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2019: France Invents Merkle Search Trees (a.k.a Prolly Trees)</h2>
<p>In 2019, two researchers at the French Institute for Research in Computer Science and Automation (abbreviated as Inria) published a paper titled <a href="https://inria.hal.science/hal-02303490v1">Merkle Search Trees: Efficient State-Based CRDTs in Open Networks</a>. In it, they describe how to design a conflict-free replicated data type (CRDT) that represents a key-value mapping with a Merkle Tree. It has all the same properties as prolly trees, although they call their design &#34;Merkle Search Trees&#34; instead. The authors didn&#39;t seem to be aware of the prior work done by Noms, perhaps because Noms never published a research paper about it.</p>
<p>The implementation outlined in Inria&#39;s paper differs from other implementations in an interesting way: every other approach builds the tree recursively, applying a rolling hash function to each row, with the following steps:</p>
<ul>
<li>Use a rolling hash chunker on the underlying (L0) data stream to divide it into chunks.</li>
<li>Concatenate the hash of each chunk to create a new (L1) data stream.</li>
<li>Use a rolling hash chunker on the L1 data stream to divide it into chunks.</li>
<li>Concatenate the hash of each chunk to create a new (L2) data stream.</li>
<li>...and so on</li>
</ul>
<p>The implementation described in this paper takes a slightly different approach, hashing the data only once and using the number of leading zeros in the hash of each key to determine how many levels of the tree will split off a new chunk.</p>
<p>This approach has some different tradeoffs: it&#39;s harder to dynamically control chunk sizes, but it relies less on the ordering of the keys in the dataset. This order-independence actually helped inspired our design for <a href="https://www.dolthub.com/blog/2024-10-08-how-to-build-a-vector-index-with-prolly-trees/">vector indexes</a>.</p>
<p>Inria&#39;s design would get later picked up by Bluesky and <a href="https://arxiv.org/pdf/2402.03239">used in their implementation of ATProto</a>. By combining Merkle search trees with the <a href="https://ipld.io/">IPLD data format</a> created by Protocol Labs, ATProto defines a way to uniquely content-address, store, and request and serve large files in a scalable way.</p>
<h2 id="2020-depaul-university-invents-content-defined-merkle-trees-aka-prolly-trees"><a href="#2020-depaul-university-invents-content-defined-merkle-trees-aka-prolly-trees" aria-label="2020 depaul university invents content defined merkle trees aka prolly trees permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2020: DePaul University Invents Content-Defined Merkle Trees (a.k.a Prolly Trees)</h2>
<p>Not long after, a group of researchers at DePaul University were exploring how to use block-based storage to compress Docker images. Existing methods stored images on a per-file level, and couldn&#39;t deduplicate large files with minor changes between them, or the same file stored at multiple paths. Their paper, <a href="https://cdmdicewebprd01.dpu.depaul.edu/pdfs/pubs/C28.pdf">Content-defined Merkle Trees for Efficient Container Delivery</a>, describes a way to break down large files into a tree of manageable chunks that could be stored in a content-addressed block store. Their design is nearly identical to the Noms design.</p>
<p>Their paper would draw the attention of <a href="https://xethub.com/">XetHub</a>, who would use it to build a Git plugin designed to replace <a href="https://git-lfs.com/">Git LFS</a>. XetHub would make their own improvements that are very reminiscent of the improvements that we made at DoltHub, including:</p>
<ul>
<li>Using multiple rolling hash functions with different seeds in order to the normalize the size of tree nodes and better balance the tree.</li>
<li>Content-aware hashing for different data types, including only hashing keys when storing key-value pairs, so that merely updating values can&#39;t change the shape of the tree.</li>
</ul>
<p>They then published their results in a 2023 paper titled &#34;Git is For Data&#34;... which sounds a lot like Dolt&#39;s tagline:</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/897146b9b740dd77f9c4332bf85f9ed0/b9024/front-page.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Dolt is Git for Data" title="" src="https://www.dolthub.com/blog/static/897146b9b740dd77f9c4332bf85f9ed0/ad12c/front-page.png" srcset="/blog/static/897146b9b740dd77f9c4332bf85f9ed0/a48b3/front-page.png 214w,
/blog/static/897146b9b740dd77f9c4332bf85f9ed0/47730/front-page.png 428w,
/blog/static/897146b9b740dd77f9c4332bf85f9ed0/ad12c/front-page.png 856w,
/blog/static/897146b9b740dd77f9c4332bf85f9ed0/b9024/front-page.png 1203w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>(Source: <a href="https://www.dolthub.com/">our front page</a>)</p>
<p>Then in 2024 XetHub got acquired by HuggingFace, and their Git plugin is now used by HuggingFace to store and distribute large database files in their repos, similar to how <a href="https://www.dolthub.com/profile/discover">DoltHub works as a database repository.</a></p>
<p>We&#39;ve been watching XetHub closely and cheering them along on their journey: it was really cool to see how closely their development mirrored ours. The biggest difference between us and them is the use cases we target: XetHub is mainly used to manage and share data for local use, while Dolt is mainly used as a live database server <a href="https://docs.dolthub.com/cli-reference/cli">(although Dolt has a local command line workflow too)</a>.</p>
<p>All of which is to say: hey HuggingFace, if you&#39;re reading this, we&#39;ve been developing your storage model longer than any other extant company. It runs in our veins. Let&#39;s chat.</p>
<h2 id="the-end"><a href="#the-end" aria-label="the end permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The End?</h2>
<p>That&#39;s the end of the timeline. To the best of our knowledge, no one has independently invented prolly trees / Merkle search trees / content-defined Merkle trees since.</p>
<p>But that&#39;s three inventions. At the start of this I said there were four. Where&#39;s the fourth?</p>
<p>On Monday&#39;s post we claimed that <a href="https://www.dolthub.com/blog/2025-06-02-dolt-turns-10/">Noms was the world&#39;s first implementation of a prolly tree</a>. Well, it turns out we were wrong.</p>
<p>Let&#39;s rewind the clock all the way back to 2009.</p>
<h2 id="2009-bup-invents-prolly-trees-but-doesnt-name-it-anything"><a href="#2009-bup-invents-prolly-trees-but-doesnt-name-it-anything" aria-label="2009 bup invents prolly trees but doesnt name it anything permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2009: Bup Invents Prolly Trees (But Doesn&#39;t Name it Anything)</h2>
<p>This is, as far as I can tell, the earliest recorded use of a prolly tree. <a href="https://bup.github.io/">bup</a> is a tool for storing incremental file system backups within a Git repo, originally a solo project by <a href="https://apenwarr.ca">Avery Pennarun</a>. Since Git has issues with large files, bup&#39;s workaround is to split large files up into a tree of Git objects by recursively applying a rolling hash chunker. This is a textbook example of a prolly tree, and it&#39;s been in bup&#39;s codebase since the beginning. But bup didn&#39;t give a name to the technique, possibly because Pennarun didn&#39;t realize that he had created something novel. Perhaps he saw it as the natural solution to the specific problem he was facing.</p>
<p>And he did this in 2009, six years before Noms. I&#39;m not aware of any other examples of prolly trees being invented in that six year period, but it wouldn&#39;t surprise me if they were. It&#39;s fully possible that there are even more people who have independently discovered this data structure, and are using it in their own work with little fanfare. It&#39;s not that wild to believe that something could have been invented five times instead of just four.</p>
<p>Comparing each of these independent discoveries, it&#39;s easy to see how none of them knew about each other:</p>
<ul>
<li>The bup implementation was created to solve a specific need and was never named or promoted, so none of the future inventors were aware of it.</li>
<li>Noms was a private company and never published any research papers. Every subsequent inventor was a public research institution.</li>
<li>Inria&#39;s design was published in a symposium on distributed systems, whereas the DePaul researchers were trying to optimize containerized application storage, two fields of computer science with relatively little overlap.</li>
</ul>
<p>It&#39;s mostly by chance that I even became aware of each of these parallel inventions, making it more plausible that there are others. It&#39;s something I&#39;m on the lookout for now, and who knows where I&#39;ll spot it next.</p>
<h2 id="a-tree-by-any-other-name"><a href="#a-tree-by-any-other-name" aria-label="a tree by any other name permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A Tree By Any Other Name</h2>
<p>Each group also chose their own name for what they discovered, or didn&#39;t name it at all. This poses an obvious question: at some point in the future, when the use of this data structure becomes institutional knowledge, we&#39;ll have standard terminology for it. But what name will that be?</p>
<ul>
<li>Prolly Tree?</li>
<li>Merkle Search Tree?</li>
<li>Content-Defined Merkle Tree?</li>
<li>Or something else?</li>
</ul>
<p>At DoltHub we call them prolly trees because that&#39;s what Noms called them. And we&#39;re going to continue calling them that because it predates every other name that we know of. And speaking as a member of the DoltHub team, I&#39;m hoping the name sticks because that&#39;s the one that we&#39;ve already invested so much messaging around.</p>
<p>I guess we&#39;ll find out eventually. In the meantime, we&#39;re going to keep building cool stuff on top of it. If you like building cool stuff with novel data structures, consider joining our <a href="https://discord.gg/gqr7K4VNKe">Discord</a> server and chatting with us about it. Or if you think like we do that version control is important for all your data, come chat with us about how prolly trees and Dolt can help with your workflow.</p>
</div></div>
  </body>
</html>
