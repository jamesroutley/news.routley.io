<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2025/05/26/acronis-true-image-costs-performance-when-not-used/">Original</a>
    <h1>Acronis True Image costs performance when not used</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>Over two years ago I installed <em>Acronis True Image for Crucial</em> in order to migrate my data to a new SSD I had just purchased. It worked. I then left <em>True Image</em> installed “just in case”, and what harm could that possibly cause.</p>
<p>Well, funny you should ask.</p>
<p>I recently noticed that whenever I plugged or unplugged my external monitor <em>Explorer.exe</em> would consume a lot of CPU time – dozens of seconds of it. It was enough CPU time to make my computer noticeably sluggish until things calmed down which could take 15+ seconds. “That’s odd” is how most of my investigative reporting starts so I <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/">grabbed an ETW trace</a> and drilled in. It didn’t take long to find the culprit.</p>
<blockquote>
<p>Aside: I have worked with Acronis to help them understand this issue and they have provided a mitigation and have said that they plan to address the problem in the next release of their software. See “Workarounds and fixes” for details.</p>
</blockquote>

<p>In the trace <em>Explorer.exe</em> was using 44 s of CPU time over a 16 s time period (from 7.0 s to 23.0 s in the trace) which is way too much:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image.png"><img width="632" height="326" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb.png?w=632&amp;h=326"/></a></p>
<p>I opened up <em>CPU Usage (Sampled)</em> to investigate. The CPU usage was distributed across dozens of unnamed threads so I hid the <em>Thread ID</em> column and the <em>Thread Name</em> column in order to group all the threads together and drilled down:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-1.png"><img width="653" height="432" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-1.png?w=653&amp;h=432"/></a></p>
<p>I quickly found that <em>windows.storage.dll!CFSFolder::_GetOverlayInfo</em> was consuming a large chunk of the time (20,191 of the 42,299 samples), and most of that was in a call to an unknown function in <em>tishell64_26_0_39450.dll</em>. I temporarily ignored the question of who owned that DLL while I first tried to understand what it was doing.</p>
<blockquote>
<p>If you want to follow along you can <a href="https://drive.google.com/file/d/1smkPqKMbLf_rPr9mKr-8S27zDouOgkJV/view?usp=drive_link">download the trace I’m looking at</a> and load it into Microsoft’s Windows Performance Analyzer (WPA).</p>
</blockquote>
<p>The CPU Usage (Sampled) data works by interrupting all running CPUs 1,000 times a second (by default) and grabbing call stacks. This makes it a powerful tool for understanding where CPU time is being spent. You can read more about how to use this information in <a href="https://randomascii.wordpress.com/2013/04/23/xperf-for-excess-cpu-consumption-wpa-edition/">Xperf for Excess CPU Consumption</a>.</p>
<p>The 20,191 samples with <em>CFSFolder::_GetOverlayInfo</em> on the stack suggest that approximately 20 s of CPU time was consumed inside that function and its descendants (on that call stack). Approximately 6.6 s of that is in <em>Process32NextW</em> (and its descendants) and approximately 3.1 s in <em>CreateToolhelp32Snapshot</em> (and its descendants). I don’t have symbols or source for the <em>tishell64</em> DLL but I know what those two Windows functions do so I’ll start with those.</p>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot"><em>CreateToolhelp32Snapshot</em></a> grabs a snapshot of system data that could include a list of processes, threads, modules, heaps, etc. <em>Process32NextW</em> is one of the functions used to iterate through the snapshot and its presence tells us that <em>TH32CS_SNAPPROCESS</em> was specified. So, the <em>tishell64</em> DLL is grabbing a list of running processes and iterating through that list.</p>
<p>The <em>CPU Usage (Sampled)</em> data gives you an approximation of how much time is spent in different call stacks but it cannot differentiate between a small number of expensive function calls and a large number of cheap calls. That is, I couldn’t tell whether <em>CreateToolhelp32Snapshot</em> and <em>Process32NextW </em> were expensive, being called too frequently, or a bit of both.</p>
<p>I decided to investigate this by attaching the<em> Visual Studio</em> debugger to <em>Explorer.exe</em> and setting a breakpoint on <em>kernel32.dll!CreateToolhelp32Snapshot</em>. I set this as a conditional breakpoint that would only halt after being hit one billion times because I didn’t actually want <em>Explore</em>r.exe to halt in the debugger – I just wanted <em>Visual Studio</em> to count how many times the breakpoint was hit. The breakpoint settings looked like this:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-2.png"><img width="591" height="184" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-2.png?w=591&amp;h=184"/></a></p>
<p>Debugging <em>Explorer.exe</em> made me nervous because if <em>Visual Studio’s</em> debugger tried to invoke some <em>Explorer.exe</em> functionality while <em>Explorer</em> was halted at a breakpoint then I could end up with a deadlock. But, it worked! I had to tell <em>Visual Studio</em> not to stop on <a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-3.png"><img width="324" height="164" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-3.png?w=324&amp;h=164"/></a>some sort of COM exception that <em>Explorer.exe</em> was throwing, but after that things went smoothly. <em>Visual Studio</em> doesn’t update the hit count while the debuggee is running so after plugging or unplugging my external monitor I would use <em>Debug-&gt; Break All</em> to temporarily break into <em>Explorer.exe</em> to see the count.</p>
<p>Results varied but with my setup (three <em>Explorer</em> windows open) I would see anywhere from 1,200 to 3,000 hits on the <em>CreateToolhelp32Snapshot</em> breakpoint:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-4.png"><img width="614" height="124" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-4.png?w=614&amp;h=124"/></a></p>
<p>With no Explorer windows open I would still see 44 hits on the breakpoint, so 44 calls to <em>CreateToolhelp32Snapshot</em>. Now, without symbols or source code for the <em>tlshell64 DLL</em> I can’t say what is going on but I will say that I don’t understand why a shell extension would need to get a list of running processes even a single time. That sort of functionality is useful for debugging and development tools but it seems unusual – downright strange in fact – for it to be called in this context.</p>
<p>Calling <em>CreateToolhelp32Snapshot</em>  once is strange. Calling it up to 3,000 times because a monitor is plugged or unplugged is the problem.</p>
<p>How many times <em>CreateToolhelp32Snapshot</em> is called seems to depend on how many Explorer Windows are open (I use three) and perhaps on how many icons are visible (my Downloads folder shows many) and then the cost of <em>CreateToolhelp32Snapshot</em> presumably depends on how many processes are running. With my system under its normal load of processes I saw this path consuming up to 32 CPU seconds in explorer.exe when I unplug my external monitor.</p>
<p>The total cost from the <em>tishell64</em> DLL is greater than this, however. I noticed the tishell64 DLL on some other call stacks so I used WPA’s <em>View Callers By Module</em> feature to group all samples with the <em>tishell64</em> DLL present on the stack:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-5.png"><img width="582" height="244" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-5.png?w=582&amp;h=244"/></a></p>
<p>This showed that the actual cost from the <em>tishell64</em> DLL was somewhere around 26 CPU seconds in my initial trace. In one torture-test trace the total cost from the <em>tishell64</em> DLL was more than 60 CPU seconds! That is an enormous amount of CPU time for just unplugging my external monitor.</p>
<h2>Who dunnit?</h2>
<p>Now it’s time to find out who owns the <em>tishell64</em> DLL, although the title of this blog post is a <em>bit</em> of a spoiler.</p>
<p>In WPA’s <em>Graph Explorer</em> I expanded <em>System Activity</em> and then <em>Images</em> and then double clicked on <em>Lifetime By Process, Image</em>, which gives me this view:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-6.png"><img width="478" height="219" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-6.png?w=478&amp;h=219"/></a></p>
<p>There are 370 (!!!) DLLs loaded into <em>Explorer.exe</em> so I dragged the <em>File Version</em> column to the left of the <em>Image Name</em> column, sorted by that column, and then expanded <em>explorer.exe</em> and the blank and <em>&lt;Unknown&gt;</em> file versions to get this view:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-7.png"><img width="637" height="356" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-7.png?w=637&amp;h=356"/></a></p>
<p>That’s 11 DLLs that are lacking file version information. This strikes me as very sloppy – who would ship all these DLLs with this important information missing? I added the <em>Image Path</em> column and now we can see where all of these DLLs live:</p>
<p><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image-8.png"><img width="639" height="238" title="image" alt="image" src="https://randomascii.wordpress.com/wp-content/uploads/2025/05/image_thumb-8.png?w=639&amp;h=238"/></a></p>
<p>In particular the <em>tlshell64 DLL</em> is located in “C:\Program Files (x86)\Acronis\TrueImageHome” and we can therefore assume that it is published by <em>Acronis</em> as part of <em>Acronis True Image</em>, and running <em>sigcheck</em> on it verifies this.</p>
<h2>Why is Process32NextW expensive?</h2>
<p>The ETW profiling data that showed me that <em>Process32NextW</em>() is consuming lots of CPU time also lets me see exactly where it is spent. It’s mostly in mapping and unmapping sections, and some page faults (<a href="https://randomascii.wordpress.com/2014/12/10/hidden-costs-of-memory-allocation/">probably from this</a>). Maybe it could be faster, but optimizing it is almost certainly the wrong place to spend resources. It just shouldn’t be called this frequently, and if it was called a thousand times less frequently (very practical) then its performance wouldn’t matter.</p>
<p>In other words, I don’t care why it is expensive.</p>
<h2>Workarounds and fixes</h2>
<p>I was able to reach out to Acronis and talk to one of their representatives about this issue. It was a slow process (time zones!) but they shared symbols for the <em>tishell64</em> DLL to help us understand what was going on. Now that they are aware of the process-enumeration issues they plan to address the problem in the next release.</p>
<p>Until then the process-enumeration code can be disabled by deleting the following registry key:</p>
<blockquote>
<p><SPAN face="Courier New">Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\<SPAN face="Courier New">CurrentVersion\</SPAN></SPAN></p>
</blockquote>
<p>Note that the key name has five spaces at the start of it.</p>
<p>The other <em>tishell64</em> costs seem to have already been fixed in the latest versions of <em>Acronis True Image</em>. However if you are using the version from <em>Crucial</em> then all of the performance issues are still there. I tested with the most recent version on Crucial’s website and all of the issues are present. I have reached out to Crucial. Their first response: “We have not encountered any customers experiencing issues with the Acronis free version available on the Crucial website.” After a bit more pushing I got “Our team is looking into this matter, and we will provide any relevant updates as soon as possible.” – here’s hoping.</p>
<p>Personally I have mitigated these performance issues in the simplest and most effective way – I uninstalled <em>Acronis True Image</em>. If you are running the version distributed by <em>Crucial</em> or some other potentially out-of-date version then I recommend this.</p>
<h2>Missing metadata</h2>
<p>I ran <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/sigcheck">sysinternals’ sigcheck</a><em></em> on the 11 DLLs with no version listed and… 10 of them have the <em>Publisher</em> listed as <em>Microsoft</em>, and one as <em>Acronis International GmbH</em>.</p>
<p>These files are also missing <em>Product Name</em>, <em>Company Name</em>, and <em>Product Version</em> in the ETW fields and much of this information is also missing from the sigcheck output. My tests were on Windows 10 but Windows 11 still shows 8 <em>Microsoft</em> DLLs in <em>Explorer.exe</em> that don’t have <em>File Version</em> filled out for ETW to record. There really should be automated checks to make sure that appropriate metadata is added to the bits that <em>Microsoft</em> ships. I’ve reported this before but it’s not clear that there has been any progress.</p>
<p>Acronis also needs to fix this missing metadata, but really, that is the least of their problems. What Acronis needs to do is to either iterate through the list of running processes orders of magnitude less frequently or, better yet, not at all.</p>
<h2>Conclusion</h2>
<p><em>Acronis True Image</em> is iterating through a list of running processes many times – sometimes thousands of times – whenever my monitor is plugged or unplugged. It probably does this same wasteful iteration in other situations as well. This iterating wastes dozens of seconds of CPU time, wasting battery life and making my computer sluggish while this is happening. That’s the bug.</p>
<h2>Don’t look behind the curtain</h2>
<p>Attaching a debugger to <em>Explorer.exe</em> feels like looking into a filthy basement that is being used for packaging of medical supplies. It seems like <em>Explorer</em> should be clean and tidy because otherwise we risk having our computers be unstable but the reality is a busy stream of C++ and COM exceptions and warnings about unsupported interfaces and invalid window handles. The exceptions may be working-as-intended but I am dubious about the other errors. Here is some typical debug spew that I saw when I had the debugger connected:</p>
<blockquote>
<p>Exception thrown at 0x00007FFF89C4B699 in explorer.exe: Microsoft C++ exception: Platform::COMException ^ at memory location 0x0000000002CED670.</p>
</blockquote>
<p>I also noticed in the File I/O graph that <em>Explorer.exe</em> creates (opens) “C:\Program Files (x86)\Acronis\TrueImageHome\ti_managers_proxy.dll” 4,663 times during one of its busy times, representing 79% of its Create calls. I’m not sure what’s going on here and I’m not sure it actually “matters” but this seems wasteful. I am guessing that this is being done by the <em>Acronis</em> code but I didn’t actually check.</p>
<h2>Discussion</h2>
<p><a href="https://news.ycombinator.com/item?id=44960718">Hacker news discussion is here</a></p>
											</div></div>
  </body>
</html>
