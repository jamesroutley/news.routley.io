<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wyounas.github.io/concurrency/2024/12/12/how-concurrency-works-a-visual-guide/">Original</a>
    <h1>How concurrecy works: A visual guide</h1>
    
    <div id="readability-page-1" class="page"><article><p>Dec 12, 2024</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/one.png" alt="concurrency is hard"/></p><p>Concurrent programming is hard.</p><p>Mentally enumerating all the possible states that complex concurrent code might go through is far from easy. Visualizing concurrency can make it easier to understand how these programs operate, especially for those just beginning to learn about concurrency.</p><p>Such visualizations might not always be effective for larger or more complex systems. But even with complex systems, breaking them down into smaller models and visualizing those models can be an excellent way to understand what’s happening behind the scenes.</p><p>Recently, I’ve been exploring model checking and found the mindset it enforces to be not only intriguing but also quite powerful. Leslie Lamport, the renowned researcher in distributed systems and concurrency, has a brilliant quote: <em>If you’re thinking without writing, you only think you’re thinking.</em> For large and complex distributed or concurrent programs, I believe this principle extends further: <em>If you’re implementing without formally verifying your solution through model checking, you only think you’re implementing it correctly</em>.</p><p>Model checking is a powerful tool, and I’ve come across a few resources that can help in understanding concurrency. This inspired me to write about them—not only to deepen my own understanding but also to share what I’ve learned. We’ll begin by exploring how to visualize the execution of a sequential program, then move on to visualizing a concurrent one. Finally, we’ll touch on how to reason about the correctness of concurrent programs.</p><p>Alright, let’s dive in!</p><p>We can visualize how concurrent programs operate by exploring their state space. A few questions arise immediately: What is a state? And what is a state space? Let’s tackle the first question first, then circle back to the second.</p><p>A program’s state is defined by the values of its variables and the location counter (which indicates the next instruction to be executed). Let’s walk through an example using a simple C-like language. We’ll look at the states and demonstrate how states transition during the sequential (non-concurrent) execution of the following program. (We’ll dive into a concurrent program example right after this.)</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/two.png" alt="concurrency is hard"/></p><p>The program above consists of three instructions, and for clarity, labels are added as location counters on the far left (i.e., <em>1</em>, <em>2</em>, <em>3</em>, and <em>end</em>). The program includes a single variable, <strong>n</strong>, which is declared as a byte.</p><p>The state of the program can be represented as a tuple containing the value of the variable <strong>n</strong> and the location counter: <strong>(n, location counter)</strong>. For example, when the program starts, its initial state is <strong>(undefined, 1)</strong>. This is because, at the beginning, none of the program’s statements have been executed, leaving the value of <strong>n</strong> as “undefined,” while the location counter points to the first instruction, labeled as 1.</p><p>We can visualize this state as follows: the orange arrow represents the location counter, and the current value of <strong>n</strong> is displayed at the bottom for clarity.</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/three.png" alt=""/></p><p>To move to the next state, we can advance the location counter. So we advance the location counter to 2 after executing the statement at location counter 1, the next state becomes <strong>(0, 2)</strong>, indicating that <strong>n</strong> is now 0 and the location counter points to 2. This state, <strong>(0, 2)</strong>, reflects that the value of <strong>n</strong> has been set to 0 as a result of executing the first statement and is visualized as follows:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/four.png" alt=""/></p><p>The location counter increments again, and the next state becomes <strong>(1, 3)</strong>. The value of <strong>n</strong> has changed to 1 because, in the previous state, the location counter was 2, and executing the statement at that location set <strong>n</strong> to 1. The situation now looks like this:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/five.png" alt=""/></p><p>Finally, the location counter increments one last time to reach the end, marking the completion of execution. At this point, the value of <strong>n</strong> remains 1.</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/six.png" alt=""/></p><p>A given sequence of states, starting from an initial state and continuing as statements execute, is called a <em>computation</em>. For example, for the program above, the following is a computation:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/seven.png" alt=""/></p><p>As explained earlier, the state of a program is defined by the values of its variables and the location counter (which points at the next instruction to be executed). The state space of a program is simply the set of all possible states that can possibly occur during a computation. Ben-Ari offers a formal definition of state space in [2]: “The state space of a program is a directed graph; each reachable state is a node, and there is an edge from state s1 to state s2 if a transition enabled in s1 moves the computation to s2.”</p><p>Essentially, a state space represents all the states a concurrent program goes through during its execution. By examining the state space, you can understand the full range of program behavior, including unexpected scenarios that might arise from the intricate sequencing of concurrent operations. For this reason, I believe understanding how a state space is generated for a concurrent program can help us grasp how that program works on a more fundamental level.</p><p>In model checking, the state space is also used to reason about the correctness of concurrent programs—another reason to understand how it works. We’ll explore how to reason about correctness at the end.</p><p>We’ll now consider two procedures, running concurrently, to observe how their states transition and how the state space is generated. The program includes a global variable, <strong>n</strong>, and two procedures, <strong>P</strong> and <strong>Q</strong>, each consisting of the following statements:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/eight.png" alt=""/></p><p>These are two simple procedures, similar in their operation, each with its own location counter.</p><p>How can we represent a state for the program described above?</p><p>We can represent the state as a triple consisting of the value of the variable <strong>n</strong> and the location counters of <strong>P</strong> and <strong>Q</strong>: <strong>(n, location counter of P, location counter of Q)</strong>. To make it even clearer, we’ll represent the state as <strong>(n, P: location-counter, Q: location-counter)</strong>. For example, <strong>(5, P: 1, Q: 2)</strong> indicates that the value of <strong>n</strong> is 5, the location counter in <strong>P</strong> is at 1, and the location counter in <strong>Q</strong> is at 2.</p><p>For the program above, the initial state could be <strong>(0, P: 1, Q: 2)</strong>, where the value of <strong>n</strong> is 0, and the location counters are at the first statements of both <strong>P</strong> and <strong>Q</strong>. We can visualize this initiate state with the visualization below, with orange arrows indicating the location counters and the value of <strong>n</strong> displayed at the bottom:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/nine.png" alt=""/></p><p>Let’s explore two possible transitions from this initial state.</p><p>We can transition to the next state by incrementing the location counter in <strong>P</strong>, resulting in <strong>(1, P: end, Q: 2)</strong>. Here, <strong>n</strong> becomes 1, reflecting the result of the evaluated expression when the statement at location counter 1 was executed. The state at this point looks like this:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/ten.png" alt=""/></p><p>The second possible next state from the initial state could be reached by incrementing the location counter in <strong>Q</strong>. That next state we get by incrementing the location counter in <strong>Q</strong> is <strong>(2, P: 1, Q: end)</strong>, and we can visualize it like this:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/eleven.png" alt=""/></p><p>The location counter of <strong>Q</strong> reached its end, while <strong>P</strong> remained at location counter 1, and the value of <strong>n</strong> is 2.</p><p>So, the transition from the initial state <strong>(0, P: 1, Q: 2)</strong> to these two states could be represented as state space like this (left arrow points to the next state after an increment in the location counter of <strong>P</strong> whereas right arrow points to the next state after an increment in the location counter of <strong>Q</strong>) :</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/twelve.png" alt=""/></p><p>Next, we’ll write the above program in PROMELA (a C-like language that SPIN [1] uses; SPIN is a software verification tool and a model checker) and then visualize its state space.</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/thirteen.png" alt=""/></p><p>The code is C-like. The keyword <strong>proctype</strong> is used to declare a process, while the keyword <strong>active</strong> activates a process, ensuring that <strong>P</strong> and <strong>Q</strong> run concurrently when the program starts.</p><p>As before, we represent the state as a triple: <strong>(n, location counter of P, location counter of Q)</strong>. In the image above, the line numbers on the far left serve as location counters.</p><p>Below is the state space of the program:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/fourteen.png" alt=""/></p><p><em>Figure 1</em></p><p>The edges in the state space are labeled with orange text, indicating what triggers the transition to the next state. This state space shows that at the end of the program, the value of <strong>n</strong> could be either 1 or 2. (As an aside: In concurrency, there is also a concept called interleaving, where statements are chosen nondeterministically from processes. For example, a statement from process <strong>P</strong> could execute first, followed by one from <strong>Q</strong>, and so on. In the state space above, depending on the interleavings, we could say that at the end, the value of <strong>n</strong> might be either 1 or 2.)</p><p>Let’s quickly explore how state transitions occur along the right-hand path of the above state space in <em>Figure 1</em>.</p><p>Starting with the initial state at the top of the state space, <strong>(0, P: 5, Q: 9)</strong>,we can represent it as:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/fifteen.png" alt=""/></p><p>Starting from the initial state <strong>(0, P: 5, Q: 9)</strong>, if we increment the location counter in <strong>Q</strong>, moving it to line 10, the statement at line 9 executes, setting <strong>n</strong> to 2. This brings us to the next state, <strong>(2, P: 5, Q: 10)</strong>:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/sixteen.png" alt=""/></p><p>From this state, we transition to the next state by incrementing the location counter in <strong>P</strong>, resulting in <strong>(1, P: 6, Q: 10)</strong>. At this point, the value of <strong>n</strong> becomes 1 as the statement at location counter 5 executes, as shown below:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/seventeen.png" alt=""/></p><p>This marks the end of the computation along the right-hand path of the state space shown in <em>Figure 1</em>.</p><p>What happens if we extend <strong>P</strong> and <strong>Q</strong> by adding more statements? Does the state space expand, or does it shrink? Let’s find out.</p><p>Suppose we add a few more lines to both <strong>P</strong> and <strong>Q</strong>—introducing a local variable, assigning it a value, and setting the global variable <strong>total</strong> to a constant (as shown in <em>Figure 2</em> below). While these changes might seem minor, they can impact the state space.</p><p>To explore the effect of these changes on the state space, I generated a visualization using <em>jSpin</em> [3], an excellent educational tool by Ben-Ari built on top of Spin.</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/eighteen.png" alt=""/></p><p><em>Figure 2</em></p><p>The code is displayed on the left side, while the state space is generated as a graph on the right side. In the graph, each box contains three lines: the top line shows the location counter in <strong>P</strong>, the middle line shows the location counter in <strong>Q</strong>, and the last line displays the value of the variable <strong>total</strong>.</p><p>The state space has expanded dramatically compared to the earlier example.</p><p>Now, imagine a concurrent program with dozens of processes, each executing thousands of lines of code with numerous variables. The state space would grow exponentially. Even small programs, if not managed carefully, can generate massive state spaces.</p><p>To further examine the impact of concurrency on state space size, I modified the above program to run five concurrent processes instead of two. As a result, the state space grew so large that, in the final visualization, each state appeared as a tiny dot, rendering the entire image unreadable.</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/nineteen.png" alt=""/></p><p>This demonstrates just how challenging it can be to debug and test large or complex concurrent programs. You may need to address numerous scenarios, each leading to countless states. While creating visualizations for such large programs might not be practical (at least with jSpin), you can simplify your program into smaller models and generate visualizations from them.</p><p>These simplified visualizations can provide valuable insights into your implementation and serve as an excellent starting point for understanding what’s happening behind the scenes. They’re especially useful as a first step in helping folks grasp the complexities of concurrency.</p><p>State space can help us reason about the correctness of concurrent and distributed systems.</p><p>To increase confidence in a program’s correctness, we can define certain <em>invariants</em> or <em>correctness properties</em> that must hold across a program’s state space. Model checkers like SPIN, for one, can verify that these properties are upheld throughout the entire state space. For instance, we might define a property such as <em>“X should always be true,”</em> meaning that <strong>X</strong> must not be false in any state.</p><p>When reasoning about large and complex distributed systems, this <em>invariant-based thinking</em> becomes essential for ensuring correctness. To achieve this, we rely on two key types of properties:</p><ul><li><strong>Safety properties</strong>: Ensuring that nothing bad happens.</li><li><strong>Liveness properties</strong>: Ensuring that something good eventually happens.</li></ul><p>Model checkers like SPIN and TLA+ allow us to verify these properties.</p><p>Let’s try to come up with a safety property for the program shown in <em>Figure 2</em> above. We want the safety properties to hold for every state in the program’s state space. Since a state is defined by a combination of the location counter and variables, for this example, we’ll focus on defining our property for the variable <strong>total</strong>. Please note that this is a somewhat contrived example, intended to demonstrate concepts.</p><p>For example purposes, to define a safety property, we can try to come up with an expression for the variable <strong>total</strong> that holds true in all program states. Consider the following expression as a safety property, where we expect <strong>total</strong> to be 1 in all states:</p><p>Would this hold true in every state? Let’s revisit the state space, represented as a directed graph on the right side of the code:</p><p><img loading="lazy" src="https://wyounas.github.io/images/2024-12-10-visualizing-concurrency/eighteen.png" alt=""/></p><p>Does <strong>total</strong> equal 1 in all states? No, the above wouldn’t hold in every state because the value of <strong>total</strong> can be 0, 1, or 2 (as shown at the bottom of each square in the state space). There are states where <strong>total</strong> is 0 and others where it is 2, so the property <code>total == 1</code> doesn’t hold universally. Similarly, another property like <code>total == 2</code> wouldn’t hold either, for the same reason.</p><p>How about this instead?</p><p>Since there are states where the value of <strong>total</strong> is 0, the previous property wouldn’t hold universally either. However, the following does hold across all states:</p><div><div><pre><code>total == 1 || total == 2 || total == 0
</code></pre></div></div><p>We almost derived a safety property by exploring the state space—this was just for example purposes. In practice, you may define safety and liveness properties even before writing any models or code.</p><p>As we examine the above expression, a question arises: How can we express it as a safety property and use it to validate correctness in SPIN?</p><p>Expressions like the one above can be expressed as a program’s safety property using <em>Linear Temporal Logic</em> (LTL). LTL is based on propositional logic and allows formulas to include both logical operators and temporal operators, such as:</p><ul><li><strong>Always ([] in SPIN)</strong>: Ensures a condition holds in all states.</li><li><strong>Eventually (&lt;&gt; in SPIN)</strong>: Ensures a condition will hold in some future state.</li></ul><p>As an example, we can express the above expression as a safety property in LTL:</p><div><div><pre><code>[] (total == 1 || total == 2 || total == 0)
</code></pre></div></div><p>This reads as: <em>Always, <strong>total</strong> is either 1, 2, or 0.</em> We can use this property in SPIN and validate the program’s correctness by ensuring it holds across the state space [4]. Our confidence in concurrent programs increases when we know that a certain property holds across the state space.</p><p>There is much more to LTL, and we’ll dive deeper into it in future articles. Validating safety and liveness properties with LTL is especially useful for large or complex programs.</p><p>In complex concurrent or distributed systems with thousands of possible states, relying on unit tests alone makes it hard to be confident in the solution’s correctness. Most of us would struggle to keep such a vast state space in mind while writing tests. Concurrency bugs are also tough to catch during testing as traditional methods, such as unit or integration tests (though essential), might overlook the issues. The timing and interleaving of events make these bugs hard to find and reproduce. This often leads to dealing with “heisenbugs”—bugs that behave unpredictably and are difficult to track down.</p><p>This all is what makes model checkers excel—they allow you to verify program correctness across a wide range of scenarios. Please stay tuned as I plan to write more about this.</p><p><em>Thanks to G. Holzmann, Hillel Wayne, Jack Vanlightly, and Murat Demirbas for reading drafts of this.</em></p><p><em>Please <a href="mailto:waqas.younas@gmail.com">email</a> with questions, ideas, or corrections.</em></p><h3 id="references">References</h3><ol><li><p>More detail and installation instructions are available at https://spinroot.com. And the overview paper The Model Checker Spin, IEEE Trans. on Software Engineering Vol. 23, No. 5, May 1997, pp. 279-295.</p></li><li><p>Mathematical Logic for Computer Science, 3rd edition, by Mordechai Ben-Ari.</p></li><li><p>For state space visualization, I used https://github.com/motib/jspin.</p></li><li><p>You can specify the safety property in a <code>.prp</code> file and, assuming your PROMELA code is in <code>safety.pml</code>, run the following commands to validate it:</p><div><div><pre><code>     $ spin -a -F safety.prp  safety.pml
     $ gcc -DSAFETY -o pan pan.c
     $ ./pan
</code></pre></div></div></li><li><p>Top image courtesy of https://geek-and-poke.com/</p></li></ol><hr/><p><a href="https://wyounas.github.io/articles">← Back to all articles</a></p></article></div>
  </body>
</html>
