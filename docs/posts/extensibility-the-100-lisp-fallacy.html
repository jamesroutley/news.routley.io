<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kyo.iroiro.party/en/posts/100-percent-lisp/">Original</a>
    <h1>Extensibility: The &#34;100% Lisp&#34; Fallacy</h1>
    
    <div id="readability-page-1" class="page"><div id="text-4"> <p> Compared to extending via workarounds, extending in “pure Lisp” can be both easier and harder, as we are still bounded by coding conventions and existing code, and one cannot possibly extend <i>everything</i> without breaking some of them. </p> <p> Let’s start by overriding a single function. <a href="https://codeberg.org/jkreeftmeijer/ox-html-stable-ids.el">For example</a>, when exporting <a href="https://orgmode.org/">Org-mode</a> files to <span>HTML</span>, Org-mode defaults to generating random <span>HTML</span> <span>ID</span> anchors. To change that, you just override the <code>org-export-get-reference</code> function that generates the IDs, right? </p> <div><pre><span></span><code><span>(</span><span>advice-add</span><span> </span><span>#&#39;</span><span>org-export-get-reference</span><span> </span><span>:around</span><span> </span><span>#&#39;</span><span>org-html-stable-ids--get-reference</span><span>)</span>
</code></pre></div> <p> Oh no! It turns out that, sometimes Org-mode directly calls <code>org-html--reference</code>, bypassing our override. That means we also need to redirect <code>org-html--reference</code>: </p> <div><pre><span></span><code><span>(</span><span>advice-add</span><span> </span><span>#&#39;</span><span>org-html--reference</span><span> </span><span>:override</span><span> </span><span>#&#39;</span><span>org-html-stable-ids--reference</span><span>)</span>
</code></pre></div> <p> Problem solved? No. Conventionally, Emacs Lisp code uses double dashes to tell the users “this function is internal”, as is in the <code>org-html--reference</code> name. Yes, by being free to extend <i>any</i> part of the editor, you are free to modify any internal functions or states, in a way that may or may not be problematic under specific circumstances, with code that can be broken in any future updates. </p> <p> And it’s not the end of it. The <a href="https://github.com/radian-software/el-patch">el-patch</a> package allows you to apply “patches” on most any Lisp code to modify behaviours nested deep inside a function: </p> <div><pre><span></span><code><span>;; Original function</span>
<span>(</span><span>defun</span><span> </span><span>company-statistics--load</span><span> </span><span>()</span>
<span>  </span><span>&#34;Restore statistics.&#34;</span>
<span>  </span><span>(</span><span>load</span><span> </span><span>company-statistics-file</span><span> </span><span>&#39;noerror</span><span> </span><span>nil</span><span> </span><span>&#39;nosuffix</span><span>))</span>

<span>;; Patching</span>
<span>(</span><span>el-patch-feature</span><span> </span><span>company-statistics</span><span>)</span>
<span>(</span><span>with-eval-after-load</span><span> </span><span>&#39;company-statistics</span>
<span>  </span><span>(</span><span>el-patch-defun</span><span> </span><span>company-statistics--load</span><span> </span><span>()</span>
<span>                  </span><span>&#34;Restore statistics.&#34;</span>
<span>                  </span><span>(</span><span>load</span><span> </span><span>company-statistics-file</span><span> </span><span>&#39;noerror</span>
<span>                        </span><span>;; The patch</span>
<span>                        </span><span>(</span><span>el-patch-swap</span><span> </span><span>nil</span><span> </span><span>&#39;nomessage</span><span>)</span>
<span>                        </span><span>&#39;nosuffix</span><span>)))</span>

<span>;; Patched version</span>
<span>(</span><span>defun</span><span> </span><span>company-statistics--load</span><span> </span><span>()</span>
<span>  </span><span>&#34;Restore statistics.&#34;</span>
<span>  </span><span>(</span><span>load</span><span> </span><span>company-statistics-file</span><span> </span><span>&#39;noerror</span><span> </span><span>&#39;nomessage</span><span> </span><span>&#39;nosuffix</span><span>))</span>
</code></pre></div> <p> Luckily, el-patch provides <code>el-patch-validate</code> so that you can worry less about your patches going ineffective or unexpectedly destructive. But you still need to maintain all your patches if anything goes wrong. </p> <p> Any extensible system is not void of these problems. If you impose strong enough encapsulation, then eventually something can’t get customized; if you expose everything, well, good luck keeping backward compatibility (as the system maintainer) or forward compatibility (as the user doing your modifications). By making it possible to “extend any part of the editor,” you are literally making any part of your code unextensible, and now “every change breaks someone’s workflow.” </p> <figure><figure><a href="https://xkcd.com/1172/"><img alt="workflow_2x.png" src="https://imgs.xkcd.com/comics/workflow_2x.png"/></a> </figure> </figure><blockquote> <p> Emacs’s cross-language isolation/<span>API</span> might not be perfect, but I’m very grateful for it. If Emacs were written in pure Lisp code and anything is extensible, my work-in-progress Emacs clone couldn’t be remotely possible (because we do want to rid some of the spacebar heating problems while keeping some compatibility). </p> </blockquote> </div></div>
  </body>
</html>
