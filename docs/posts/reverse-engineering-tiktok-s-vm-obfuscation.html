<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullpt.rs/reverse-engineering-tiktok-vm-1">Original</a>
    <h1>Reverse Engineering TikTok&#39;s VM Obfuscation</h1>
    
    <div id="readability-page-1" class="page"><article><p>TikTok has a reputation for its aggressive data collection. In fact, an article published on 22 December 2022 <a href="https://www.forbes.com/sites/emilybaker-white/2022/12/22/tiktok-tracks-forbes-journalists-bytedance/?sh=410b113b7da5">uncovered how ByteDance spied on multiple Forbes journalists using TikTok</a>. While some of the data they collect may seem benign, it can be used to build a detailed profile of each user. Information such as user location, device type, and various hardware metrics are combined to create a unique &#34;fingerprint&#34; that can potentially be used to track a user&#39;s activity on and off the app. This data may also be used to prevent their APIs from being utilized in automated scripts by ensuring that the data from the requests seem humanlike.</p><p>The platform has implemented various methods to make it difficult for reverse-engineers to understand exactly what data is being collected and how it is being used. Analyzing the call stack of a request made on tiktok.com can begin to paint the picture for us. Let&#39;s start by doing a search for the term &#34;food&#34;. Upon pressing enter, TikTok sends off a GET request with our search term and some extra telemetry embedded.</p><p>The response for this request is exactly what we&#39;d expect: The JSON representation of accounts starting with or containing the keyword food.</p><p>Most of the query parameters are self explanatory but there&#39;s three that stand out:</p><ul><li>msToken</li><li>X-Bogus</li><li>_signature</li></ul><p>Removal of the <code>_signature</code> query parameter doesn&#39;t seem to have an affect as the request still goes through as expected but removal of any other parameter causes TikTok to give a 0 length response.</p><p>How are these parameters generated? Taking a look at the call stack tells us the journey from beginning to end.</p><p>The call to window.fetch being located in script <code>secsdk-lastest.umd.js</code> tells us that the <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">fetch</a> function has been monkey patched to provide additional functionality but perhaps what&#39;s more interesting are the obfuscated function names underneath.</p><p>An examination of the <code>webmssdk.js</code> script reveals that the code is intentionally made difficult to understand through obfuscation, as evidenced by the following function:</p><p>View the fully obfuscated script over at <a href="https://sf16-website-login.neutral.ttwstatic.com/obj/tiktok_web_login_static/webmssdk/1.0.0.1/webmssdk.js">webmssdk.js</a></p><p>By utilizing the <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md">Babel suite</a>, we are able to parse the source code and manipulate its Abstract Syntax Tree (AST). With this, we can create a simple transformation that reduces complex binary expressions to a single constant. The transformation code appears as follows:</p><p>The function, previously obfuscated, now appears in the following form:</p><p>Much better, but now we&#39;re stuck in ternary hell. We can create another simple transformation to unpack the nested ternary logic and make it more easily understood:</p><p>Applying this transformation to function _0x4e353d produces the following result:</p><p>We could create more complex transformations to further improve the readability of the obfuscated script, but for the purposes of this article, these two transformations are sufficient.</p><p>As you review the script, you may notice recurring patterns. For example, consider these two function calls:</p><p>They follow a very similar schema: A function call with 3 parameters:</p><ol><li>A string of alphanumeric characters that is not immediately recognizable as to its purpose.</li><li>An object containing getters and setters referencing various browser APIs and global variables.</li><li>void 0 (a fancy obfuscated way of saying undefined)</li></ol><p>An exercise to you: Dump all function calls that meet the criteria listed above</p><p>To determine how this string is being used, we need to analyze the function it is being called in.</p><p>We can immediately see that the function we deobfuscated earlier is defined within the <code>_0x8d6b0f</code> function. Additionally, the argument names have been made more readable for ease of understanding.</p><p>The first 16 characters are evenly split into two parts and then converted into an integer from base 16. The result is then compared to two magic constants: <code>1213091658</code> and <code>1077891651</code>. Applying this logic to our string will result in it passing these checks.</p><p>A check for a 00 separator follows immediately after. While we are still unsure of the exact purpose of this string, we have determined how it should start.</p><p>Characters 24-34 are divided into parts and used in some bitwise arithmetic that is calculated for the variable <code>_0x4fab32</code>. Searching for the use of this variable leads us to a call to the <code>String#fromCharCode</code> function, where it is XORed with another variable.</p><p>This strongly suggests the use of an <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR cipher</a>, leading me to conclude that variable <code>_0x4fab32</code> is likely the key. Based on this discovery, we can infer the purpose of nearby variables. The decryption process now looks as follows:</p><p>With all the necessary pieces in place, we can now isolate this logic and potentially retrieve strings from the previously mentioned long and obfuscated string. I chose to implement this in TypeScript and run it using Node, but the logic can be implemented in any language of your choosing.</p><p>If we run our script using the initial bytecode:</p><p>We obtain the following output:</p><p>Great, we were able to successfully extract all strings from this particular module. We even see the strings <code>_signature</code> and <code>X-Bogus</code>! If we run our script using the strange string from the second function, we obtain a completely separate set of strings.</p><p>This is because each &#34;weird string&#34; is actually bytecode that is interpreted and executed by TikTok&#39;s custom virtual machine to perform various tasks. Many modules handle bot protection and fingerprinting in their own ways.</p><p>For instance, this module is responsible for managing canvas fingerprinting, in which a user&#39;s machine&#39;s rendering of an HTML5 canvas element is used to create a fingerprint for them:</p><p>Here are the strings for TikTok&#39;s WebGL module, which can be used to gather your vendor and other GPU information:</p><canvas width="0" height="0"></canvas><p>This article does not delve into the specifics of how these strings are utilized or how TikTok interprets the rest of the bytecode through its custom virtual machine and various opcodes. If that is something you are interested in, keep an eye out for the second part of this series :)</p><p>If you&#39;re interested in a full strings dump check out <a href="https://gist.github.com/voidstar0/d4d409321ca0a32e2ffd295b59a9a1df">strings.txt</a></p><a href="https://infosec.exchange/@voidstar">Mastodon</a> </article></div>
  </body>
</html>
