<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2024/09/27/some-go-web-dev-notes/">Original</a>
    <h1>Some Go web dev notes</h1>
    
    <div id="readability-page-1" class="page"><div>
     

<p>I spent a lot of time in the past couple of weeks working on a website in Go
that may or may not ever see the light of day, but I learned a couple of things
along the way I wanted to write down. Here they are:</p>

<h3 id="go-1-22-now-has-better-routing">go 1.22 now has better routing</h3>

<p>I’ve never felt motivated to learn any of the Go routing libraries
(gorilla/mux, chi, etc), so I’ve been doing all my routing by hand, like this.</p>

<pre><code>	// DELETE /records:
	case r.Method == &#34;DELETE&#34; &amp;&amp; n == 1 &amp;&amp; p[0] == &#34;records&#34;:
		if !requireLogin(username, r.URL.Path, r, w) {
			return
		}
		deleteAllRecords(ctx, username, rs, w, r)
	// POST /records/&lt;ID&gt;
	case r.Method == &#34;POST&#34; &amp;&amp; n == 2 &amp;&amp; p[0] == &#34;records&#34; &amp;&amp; len(p[1]) &gt; 0:
		if !requireLogin(username, r.URL.Path, r, w) {
			return
		}
		updateRecord(ctx, username, p[1], rs, w, r)

</code></pre>

<p>But apparently <a href="https://go.dev/blog/routing-enhancements">as of Go 1.22</a>, Go
now has better support for routing in the standard library, so that code can be
rewritten something like this:</p>

<pre><code>	mux.HandleFunc(&#34;DELETE /records/&#34;, app.deleteAllRecords)
	mux.HandleFunc(&#34;POST /records/{record_id}&#34;, app.updateRecord)
</code></pre>

<p>Though it would also need a login middleware, so maybe something more like
this, with a <code>requireLogin</code> middleware.</p>

<pre><code>	mux.Handle(&#34;DELETE /records/&#34;, requireLogin(http.HandlerFunc(app.deleteAllRecords)))
</code></pre>

<h3 id="a-gotcha-with-the-built-in-router-redirects-with-trailing-slashes">a gotcha with the built-in router: redirects with trailing slashes</h3>

<p>One annoying gotcha I ran into was: if I make a route for <code>/records/</code>, then a
request for <code>/records</code> <a href="https://pkg.go.dev/net/http#hdr-Trailing_slash_redirection-ServeMux">will be redirected</a> to <code>/records/</code>.</p>

<p>I ran into an issue with this where sending a POST request to <code>/records</code>
redirected to a GET request for <code>/records/</code>, which broke the POST request
because it removed the request body. Thankfully <a href="https://xeiaso.net/blog/go-servemux-slash-2021-11-04/">Xe Iaso wrote a blog post about the exact same issue</a> which made it
easier to debug.</p>

<p>I think the solution to this is just to use API endpoints like <code>POST /records</code>
instead of <code>POST /records/</code>, which seems like a more normal design anyway.</p>

<h3 id="sqlc-automatically-generates-code-for-my-db-queries">sqlc automatically generates code for my db queries</h3>

<p>I got a little bit tired of writing so much boilerplate for my SQL queries, but
I didn’t really feel like learning an ORM, because I know what SQL queries I
want to write, and I didn’t feel like learning the ORM’s conventions for
translating things into SQL queries.</p>

<p>But then I found <a href="https://sqlc.dev/">sqlc</a>, which will compile a query like this:</p>

<pre><code>
-- name: GetVariant :one
SELECT *
FROM variants
WHERE id = ?;

</code></pre>

<p>into Go code like this:</p>

<pre><code>const getVariant = `-- name: GetVariant :one
SELECT id, created_at, updated_at, disabled, product_name, variant_name
FROM variants
WHERE id = ?
`

func (q *Queries) GetVariant(ctx context.Context, id int64) (Variant, error) {
	row := q.db.QueryRowContext(ctx, getVariant, id)
	var i Variant
	err := row.Scan(
		&amp;i.ID,
		&amp;i.CreatedAt,
		&amp;i.UpdatedAt,
		&amp;i.Disabled,
		&amp;i.ProductName,
		&amp;i.VariantName,
	)
	return i, err
}
</code></pre>

<p>What I like about this is that if I’m ever unsure about what Go code to write
for a given SQL query, I can just write the query I want, read the generated
function and it’ll tell me exactly what to do to call it. It feels much easier
to me than trying to dig through the ORM’s documentation to figure out how to
construct the SQL query I want.</p>

<p>Reading <a href="https://brandur.org/fragments/sqlc-2024">Brandur’s sqlc notes from 2024</a> also gave me some confidence
that this is a workable path for my tiny programs. That post gives a really
helpful example of how to conditionally update fields in a table using CASE
statements (for example if you have a table with 20 columns and you only want
to update 3 of them).</p>

<h3 id="sqlite-tips">sqlite tips</h3>

<p>Someone on Mastodon linked me to this post called <a href="https://kerkour.com/sqlite-for-servers">Optimizing sqlite for servers</a>. My projects are small and I’m
not so concerned about performance, but my main takeaways were:</p>

<ul>
<li>have a dedicated object for <strong>writing</strong> to the database, and run
<code>db.SetMaxOpenConns(1)</code> on it. I learned the hard way that if I don’t do this
then I’ll get <code>SQLITE_BUSY</code> errors from two threads trying to write to the db
at the same time.</li>
<li>if I want to make reads faster, I could have 2 separate db objects, one for writing and one for reading</li>
</ul>

<p>There are a more tips in that post that seem useful (like “COUNT queries are
slow” and “Use STRICT tables”), but I haven’t done those yet.</p>

<p>Also sometimes if I have two tables where I know I’ll never need to do a <code>JOIN</code>
beteween them, I’ll just put them in separate databases so that I can connect
to them independently.</p>

<h3 id="go-1-19-introduced-a-way-to-set-a-gc-memory-limit">Go 1.19 introduced a way to set a GC memory limit</h3>

<p>I run all of my Go projects in VMs with relatively little memory, like 256MB or
512MB. I ran into an issue where my application kept getting OOM killed and it
was confusing – did I have a memory leak? What?</p>

<p>After some Googling, I realized that maybe I didn’t have a memory leak, maybe I
just needed to reconfigure the garbage collector! It turns out that by default (according to <a href="https://tip.golang.org/doc/gc-guide">A Guide to the Go Garbage Collector</a>), Go’s garbage collector will
let the application allocate memory up to <strong>2x</strong> the current heap size.</p>

<p><a href="https://messwithdns.net">Mess With DNS</a>’s base heap size is around 170MB and
the amount of memory free on the VM is around 160MB right now, so if its memory
doubled, it’ll get OOM killed.</p>

<p>In Go 1.19, they added a way to tell Go “hey, if the application starts using
this much memory, run a GC”. So I set the GC memory limit to 250MB and it seems
to have resulted in the application getting OOM killed less often:</p>

<pre><code>export GOMEMLIMIT=250MiB
</code></pre>

<h3 id="some-reasons-i-like-making-websites-in-go">some reasons I like making websites in Go</h3>

<p>I’ve been making tiny websites (like the <a href="https://nginx-playground.wizardzines.com/">nginx playground</a>) in Go on and off for the last 4 years or so and it’s really been working for me. I think I like it because:</p>

<ul>
<li>there’s just 1 static binary, all I need to do to deploy it is copy the binary. If there are static files I can just embed them in the binary with <a href="https://pkg.go.dev/embed">embed</a>.</li>
<li>there’s a built-in webserver that’s okay to use in production, so I don’t need to configure WSGI or whatever to get it to work. I can just put it behind <a href="https://caddyserver.com/">Caddy</a> or run it on fly.io or whatever.</li>
<li>Go’s toolchain is very easy to install, I can just do <code>apt-get install golang-go</code> or whatever and then a <code>go build</code> will build my project</li>
<li>it feels like there’s very little to remember to start sending HTTP responses
– basically all there is are functions like <code>Serve(w http.ResponseWriter, r *http.Request)</code> which read the request and send a response. If I need to
remember some detail of how exactly that’s accomplished, I just have to read
the function!</li>
<li>also <code>net/http</code> is in the standard library, so you can start making websites
without installing any libraries at all. I really appreciate this one.</li>
<li>Go is a pretty systems-y language, so if I need to run an <code>ioctl</code> or
something that’s easy to do</li>
</ul>

<p>In general everything about it feels like it makes projects easy to work on for
5 days, abandon for 2 years, and then get back into writing code without a lot
of problems.</p>

<p>For contrast, I’ve tried to learn Rails a couple of times and I really <em>want</em>
to love Rails – I’ve made a couple of toy websites in Rails and it’s always
felt like a really magical experience. But ultimately when I come back to those
projects I can’t remember how anything works and I just end up giving up. It
feels easier to me to come back to my Go projects that are full of a lot of
repetitive boilerplate, because at least I can read the code and figure out how
it works.</p>

<h3 id="things-i-haven-t-figured-out-yet">things I haven’t figured out yet</h3>

<p>some things I haven’t done much of yet in Go:</p>

<ul>
<li>rendering HTML templates: usually my Go servers are just APIs and I make the
frontend a single-page app with Vue. I’ve used <code>html/template</code> a lot in Hugo (which I’ve used for this blog for the last 8 years)
but I’m still not sure how I feel about it.</li>
<li>I’ve never made a real login system, usually my servers don’t have users at all.</li>
<li>I’ve never tried to implement CSRF</li>
</ul>

<p>In general I’m not sure how to implement security-sensitive features so I don’t
start projects which need login/CSRF/etc. I imagine this is where a framework
would help.</p>

<h3 id="it-s-cool-to-see-the-new-features-go-has-been-adding">it’s cool to see the new features Go has been adding</h3>

<p>Both of the Go features I mentioned in this post (<code>GOMEMLIMIT</code> and the routing)
are new in the last couple of years and I didn’t notice when they came out. It
makes me think I should pay closer attention to the release notes for new Go
versions.</p>

</div></div>
  </body>
</html>
