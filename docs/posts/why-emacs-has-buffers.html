<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.masteringemacs.org/article/why-emacs-has-buffers">Original</a>
    <h1>Why Emacs has buffers</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
        
        
        
            
        
        
            
        
        
            
                
            
            <img src="https://www.masteringemacs.org/static/img/fleuron2.gif"/>
            
<p>If you’re new to Emacs, you may wonder why you read and write text from <em>buffers</em> as opposed to, you know, <em>files</em> or <em>documents</em>. There’s the fact that it’s not skeuomorphic, and thus the term lacks the spark that connects it to a real-life concept. Most people have heard of <em>files</em> and <em>documents</em> in real life, and the term <em>buffer</em> is instead a capacious term with little grounding to most people.</p><p>To computer scientists and programmers alike, however, the term <em>buffer</em> has meaning and purpose; it’s still an unsatisfactory answer, even if it <em>is</em> the real reason why Emacs uses the term <em>buffer</em>. And just leaving it there – that a buffer is a chunk of memory and used as a means of shuttling data to and fro peripheral hardware, like your disk – does not go far enough in explaining <em>why</em>. All editors use <em>buffers</em> internally.</p><p>In Emacs, the <em>buffer</em> is the focal point of nearly all user (and machine!) interactions. You read and you write, and you do so in a structure that tugs at its roots in computer science, but it’s so much more than that. And that’s really what I want to talk about, as it will go a long way towards explaining why Emacs and Emacs Lisp is the way it is.</p><h2 id="what-of-strings">What of Strings?</h2><p>Ask a programmer to write a text editor, and they’ll think of strings and how they are, ultimately, the spine of a text editor. And that seems like a natural and foregone conclusion, indeed: you <em>need</em> some way of representing the <em>text</em> in a text editor, and strings fill the gap nicely. Fancier programmers may talk about <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">ropes</a> and <a href="https://en.wikipedia.org/wiki/Gap_buffer">gap buffers</a> as a way of optimizing how you store and modify text, and yet I must insist that this is still not a good enough answer to explain what a <em>buffer</em> is in Emacs. It’d satisfy the <em>technical</em> answer, but not the <em>philosophical</em> one.</p><p>Junior Emacs Lisp programmers quickly discover – much to their surprise and perhaps consternation – the rather sparse set of functions that operate on strings. Strings are everywhere in elisp; they serve a vital role, and you would struggle to get much done without them. And yet the bulk of functions that do operate on strings solve common problems – like splitting, joining, trimming, and so forth – and the rest a much narrower purpose.</p><p>Working with strings is a foregone conclusion to most programmers — it’s a large part of what we do. But the problem with strings (as they relate to the contents of a file, for instance) in Emacs begin when you consider that they have representation – a presence – on your screen. Strings are sequences of characters, but how you look and perceive the string on your screen is a lot more complicated. You’ve got images and different font faces; word-wrapped lines that differ from the physical newlines they’re actually separated by; and not to mention things like narrowed buffers or outright invisible text, like collapsed org mode sections.</p><p>You’d need a robust toolkit to operate on these strings in such a way that it’s intuitive and that the mental model of what you see on the screen and how it’s stored is not too different. In fact, this part’s crucial: for every serious elisp hacker, there’s a 100 occasional ones that turn out little snippets of elisp to improve their workflow. Emacs has millions of lines of elisp and thousands of third-party packages exactly <em>because</em> the mental shift required is non-existent.</p><p>Emacs is not bifurcated, but a lapse of judgment 40 years ago could’ve made it so: a complex, string-fiddly world for Serious Programmers; and a safe, boring, but disjointed, world that “users” are expected to use. That’s how most editors and IDEs work, and you have to pay the piper if you want to join the Serious Programmers.</p><p>But not so in Emacs. You see, in Emacs, the buffer you see and interact with on your screen <em>is</em> the string.</p><h2 id="benefits-of-emacss-buffers">Benefits of Emacs’s Buffers</h2><p>It might surprise you to learn this, but if you want to do complex editing in elisp, you carry it out on a buffer. Maybe that buffer’s the same one as the buffer you asked Emacs to change; maybe it’s a temporary one created for the occasion.</p><p>Either way, if you want a custom function that jumps to the next paragraph and kills the one ahead, then you’d combine calls to <code>forward-paragraph</code> and <code>kill-paragraph</code>. In fact, <code>kill-paragraph</code> <em>itself</em> uses <code>forward-paragraph</code> to find the extents of the text it needs to kill.</p><p>Operating directly on the buffer removes the awkward bifurcation of concerns you’d have with strings and the representation of said strings on your screen.</p><p>You also get to leverage the force multiplier of elisp built on elisp — like <code>kill-paragraph</code> using <code>forward-paragraph</code> to find out where the beginning and end of a paragraph is.</p><pre><code>(<span>defun</span><span> kill-paragraph </span>(arg)
  <span>&#34;Kill forward to end of paragraph.</span>
<span>With ARG N, kill forward to Nth end of paragraph;</span>
<span>negative ARG -N means kill backward to Nth start of paragraph.&#34;</span>
  (interactive <span>&#34;p&#34;</span>)
  (kill-region (point) (<span>progn</span> (forward-paragraph arg) (point))))</code></pre><p>Clever, but also simple. But the <em>good</em> kind of simple. You can enable Emacs’s interactive debugger and step through your elisp code as Emacs diligently goes about its business modifying stuff in your buffer. That’s a really powerful visual <em>and</em> debug aid. You can even poke around Emacs as it’s doing it and alter the outcome by messing with the buffer state as you’re debugging.</p><p>But that’s not all. Emacs’s buffers play a larger role than that:</p><dl><dt>Network I/O</dt><dd><p>Reading from, and writing to, files is a natural enough thing to do in any editor.</p><p>But in Emacs this extends to network I/O. You can ask Emacs open a network socket and output the contents to a buffer so you can use the full power of Emacs to interpret and modify the contents. That’s really powerful stuff, and adds symmetry to the idea that in Emacs everything is treated as a buffer.</p><p>You’re also given an insight into the actual communication that takes place, as you can inspect the buffer — that is particularly useful if you’re debugging a problem.</p></dd><dt>Ephemeral Storage</dt><dd><p>Maybe you’re munging data or you need a temporary storage space for some logs — just chuck it in a throw-away buffer. You don’t need to save it to a file first as, well, a <em>buffer</em> need not be a file in Emacs.</p><p>This is of course well-known to everyone who uses Emacs as it’s something Emacs makes heavy use of itself. The <code>*Help*</code> buffers are one such example.</p></dd><dt>Pseudo-Terminals and Processes</dt><dd><p>Not too dissimilar from network I/O at all, but still a great concept to support natively.</p><p>If you call <code>M-x comint-run</code> you can feed it the name of a binary, interactive or otherwise, and Emacs will try to do the right thing. And, yep, it’s using a good, old-fashioned buffer to drive the interaction.</p><p>More on this:</p><ul><li><a href="https://www.masteringemacs.org/article/executing-shell-commands-emacs">Executing Shell Commands in Emacs</a></li><li><a href="https://www.masteringemacs.org/article/network-utilities-emacs">Using the commandline network utilities from Emacs</a></li><li><a href="https://www.masteringemacs.org/article/running-shells-in-emacs-overview">Running Shells in Emacs: An Overview</a></li><li><a href="https://www.masteringemacs.org/article/comint-writing-command-interpreter">Writing your own comint Command Interpreter</a></li></ul></dd><dt>Enriching the Output from Commands</dt><dd><p>When you use <code>M-x grep</code>, <code>M-x compile</code>, <code>M-x dired</code>, etc. you’re really just looking at a thin veneer on top of the <em>literal output</em> from these commands.</p><p>Try it. Create a throwaway buffer and put this in it and call <code>M-x grep-mode</code>:</p><pre><code>hello.txt:1234:Hello, World</code></pre><p>Emacs uses <code>default-directory</code> to infer the relative paths to the file(s) in the Grep output. But click on that link, and Emacs will try to take you to <code>hello.txt</code> on line 1234.</p><p>The same holds for many other commands in Emacs, like <code>M-x compile</code>.</p><p>From Emacs’s perspective, it’s a simple and effective way of enriching and integrating commandline tools. And you get to combine them with the power of Emacs.</p><p>Why use <code>find</code> on the command line when you can feed it into Emacs and <code>dired</code> and use <code>dired</code> to bulk edit (or execute commands against) some or all of the output from a <code>find</code> command?</p><p>More on this:</p><ul><li><a href="https://www.masteringemacs.org/article/working-multiple-files-dired">Working with multiple files in dired</a></li><li><a href="https://www.masteringemacs.org/article/compiling-running-scripts-emacs">Compiling and Running Scripts</a></li><li><a href="https://www.masteringemacs.org/article/dired-shell-commands-find-xargs-replacement">Dired Shell Commands: The find &amp; xargs replacement</a></li></ul></dd></dl><p>I think the <em>buffer</em> is one of the smartest design decisions in Emacs – along with using LISP as the programming language – because it’s just so flexible and, well, simple? It’s why Emacs’s keyboard macro system works as well as it does: it literally records what you’re doing in the buffer, which results in the exact same outcome when you play it back. That the keyboard macro system is <em>itself written in elisp</em> reinforces my point.</p><p>So why use the name <em>buffer</em>? Because a <em>buffer</em> can be a <em>file</em>, but it need not be; a <em>buffer</em> can host a <em>document</em>, but also the output of a process. Emacs’s <em>buffer</em> is, technically, just a buffer; yet the philosophy behind it is so much more than that.</p>

        
    </article>
      </div></div>
  </body>
</html>
