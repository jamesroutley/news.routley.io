<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/12/11/socket/">Original</a>
    <h1>Circular dependencies for socket activation and WireGuard</h1>
    
    
<p>
One of the more interesting things you can do with systemd is to use the 
&#34;socket activation&#34; feature: systemd itself opens a socket of some sort 
for listening, and then it hands it over to your program, inetd-style.  
And yes, I know by saying &#34;inetd-style&#34; that it&#39;s not even close to 
being a new thing.  Obviously.  This is about what else you can do with 
it.
</p>
<p>
Like in my
<a href="https://rachelbythebay.com/w/2024/07/17/bpf/">previous tale</a>
about systemd stuff, you can add &#34;deny&#34; and &#34;allow&#34; rules which bring 
another dimension of filtering to whatever you&#39;re doing.  That applies 
for the .socket files which are part of this socket activation thing.
It can even forcibly bind it to a specific interface, i.e.:
</p>
<pre class="terminal">[Socket]
ListenStream=443
IPAddressDeny=any
IPAddressAllow=192.0.2.0/24
BindToDevice=wg0
</pre>
<p>
That gives you a socket which listens to TCP port 443 and which will do 
some bpf shenanigans to drop traffic unless the other end is in that 
specific /24.  Then it also locks it down so it&#39;s not listening to the 
entire world, but instead is bound to this wg0 interface (which in this 
case means WireGuard).
</p>
<p>
This plus the usual ip[6]tables rules will keep things pretty narrowly 
defined, and that&#39;s just the way I like it.
</p>
<p>
I did this in a big way over the past year, and then never rebooted the 
box in question after installing such magic.  Then earlier this week, I 
migrated that system&#39;s &#34;personality&#34; to new hardware and that meant 
boots and reboots here and there, and wasn&#39;t it weird how it was 
spending almost two minutes to reboot every time?  What the hell, right?
</p>
<p>
Digging into the systemd journal turned up that some of the &#34;wg&#34; stuff 
wasn&#39;t coming up, and it sure looked like a dependency cycle.  A depends 
on B, which depends on C, which depends on D, which depends on A again?  
If not for the thing eventually timing out, it wouldn&#39;t have EVER 
booted.
</p>
<p>
I&#39;m thankful for that timeout, since the rest of the box came up and I 
was able to get into that little headless monster to work on the 
problem.
</p>
<p>
The problem is basically this: if you have a .socket rigged up in the 
systemd world, you by default pick up a couple of dependencies in terms 
of sequencing/ordering at boot time, and one of them is 
&#34;sockets.target&#34;.  Your foo.socket essentially has a 
&#34;Before=sockets.target&#34;, which means that sockets.target won&#39;t succeed 
until you&#39;re up and running.
</p>
<p>
But, what if your foo.socket has a BindToDevice that&#39;s pointing at 
WireGuard?  You now have a dependency on that wg0 thing coming up, and, 
well, at least on Debian, that gets interesting, because it 
(&#34;wg-quick@wg0&#34; or similar) wants basic.target to be done, and 
basic.target in turn wants sockets.target to happen first.
</p>
<p>
foo.socket waits on wg waits on basic waits on sockets waits on 
foo.socket.  There&#39;s the cycle.
</p>
<p>
Getting out of this mess means breaking the cycle, and the way you do 
that is to remove the default dependencies from your .socket file, like 
this:
</p>
<pre class="terminal">[Unit]
DefaultDependencies=no
</pre>
<p>
After that, it&#39;s on you to set up the appropriate WantedBy, Wants, 
Before or After declarations on your .socket to make sure it&#39;s attached 
to the call graph somewhere.
</p>
<p>
I should mention that it took a LOT of rebooting, journal analysis, 
cursing, and generally complaining about things before I got to this 
point.  If you&#39;re in a mess like this, &#34;systemd-analyze dump &lt;whatever&gt;&#34; 
is generally your friend, because it will point out the *implicit* 
dependencies which are just as important but which won&#39;t show up in your 
.socket or .service files.  Then you get to sketch it out on paper, 
curse some more, and adjust things to not loop any more.
</p>
<p>
There doesn&#39;t seem to be a good way to spot this kind of problem before 
you step in it during a boot.  It&#39;s certainly not the sort of thing 
which would stop you before you aimed a cannon directly at your foot.  
Apparently, &#34;systemd-analyze verify &lt;whatever&gt;&#34; will at least warn you 
that you have a cycle, but figuring out how you got there and what to 
do about it is entirely up to you.  Also, if you don&#39;t remember to run 
that verify step, then obviously it&#39;s not going to help you.  I only 
learned about it just now while writing up this post - far too late for 
the problem I was having.
</p>
<p>
I sure like the features, but the complexity can be a real challenge.
</p>

  </body>
</html>
