<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vgel.me/posts/donut/">Original</a>
    <h1>Signed distance functions in 46 lines of Python</h1>
    
    <div id="readability-page-1" class="page"><article>
    
    <p>Signed distance functions are a really cool method of 3D rendering!
But they unfortunately have a reputation for being difficult to understand.
It makes sense why—they usually get shown off in beautiful, but complicated ShaderToy examples written in GLSL, an unfamiliar language for most programmers.
But at their core, SDFs are a really simple idea.
I&#39;m going to prove that by walking you through a program that raymarches an animated SDF donut in only 46 lines of Python.
Just for fun, and to make it easy to port to your favorite language that can also print strings to the terminal, we&#39;ll also be doing it with ASCII art instead of a graphics API.
So come along!
By the end, you won&#39;t just have this delicious-looking spinning ASCII donut, but an understanding of a cool rendering technique you can use for all kinds of neat things.</p>
<p><img src="https://vgel.me/posts/donut/stage7.gif" alt="A spinning ASCII donut with simple texturing and lighting"/></p>
<span id="continue-reading"></span><h2 id="Setting_up"><a href="#Setting_up">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Setting_up"/>
</a>Setting up</h2>
<p>So to start off with, let&#39;s slap down some Python to render our ASCII frame.
We&#39;ll also add in a game loop so we can do animation:</p>
<!-- stage1 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>time
</span><span>
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>int</span><span>, </span><span>y</span><span>: </span><span>int</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  </span><span># draw an alternating checkboard pattern
</span><span>  </span><span>if </span><span>(x </span><span>+ </span><span>y </span><span>+ </span><span>int</span><span>(time.time())) </span><span>% </span><span>2</span><span>:
</span><span>    </span><span>return </span><span>&#39;#&#39;
</span><span>  </span><span>else</span><span>:
</span><span>    </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span>while </span><span>True</span><span>:
</span><span>  </span><span># loop over each position and sample a character
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      frame_chars.append(sample(x, y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span># print out a control sequence to clear the terminal, then the frame
</span><span>  </span><span># (I haven&#39;t tested this on windows, but I believe it should work there,
</span><span>  </span><span># please get in touch if it doesn&#39;t)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  </span><span># cap at 30fps
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p>This renders a 80x20 checkerboard, which alternates every second:</p>
<p><img src="https://vgel.me/posts/donut/stage1.gif" alt="The 80x20 alternating checkerboard"/></p>
<p>This is a nice foundation, but not too visually interesting, so let&#39;s move on.
The task ahead is simple: for each character on the screen, decide what the character should be—easy! :-)</p>
<h2 id="Drawing_a_circle"><a href="#Drawing_a_circle">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Drawing_a_circle"/>
</a>Drawing a circle</h2>
<p>Let&#39;s start with something simple.
We have an <code>x</code> and a <code>y</code> coordinate, so we can easily draw a <em>circle</em>, if not anything 3D yet.
There&#39;s a few different ways we could go about this, but in the spirit of &#34;for each character on the screen, decide what character it should be&#34;, we&#39;ll do a character-by-character approach.
The basic algorithm will be, for each <code>(x, y)</code> coordinate of a character:</p>
<ol>
<li>Calculate the distance of <code>(x, y)</code> from the center of the screen: √((x-0)^2 + (y-0)^2), aka √(x^2+y^2)</li>
<li>Subtract the desired circle radius. That way, if the point is inside or on the edge of the circle, the value will be ≤ 0, and otherwise it will be &gt; 0.</li>
<li>Now test that value against 0 to either return <code>&#39;#&#39;</code> if the point is inside or on the edge of the circle, or <code>&#39; &#39;</code> otherwise.</li>
</ol>
<p>We&#39;ll also remap <code>x</code> and <code>y</code> to <code>-1..1</code> and <code>(-.5)..(.5)</code>, respectively, to gesture in the direction of resolution independence, and to keep the aspect ratio correct (<code>2 * 20/80 = 0.5</code>, as <code>y</code> covers only 20 characters while <code>x</code> covers 80, and terminal characters are roughly twice as tall as they are wide). This prevents the circle from looking instead like an unappetizingly squished bean.</p>
<!-- stage2 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math, time
</span><span>
</span><span>def </span><span>circle</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  </span><span># since the range of x is -1..1, the circle&#39;s radius will be 40%,
</span><span>  </span><span># meaning the circle&#39;s diameter is 40% of the screen
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  </span><span># calculate the distance from the center of the screen and subtract the
</span><span>  </span><span># radius, so d will be &lt; 0 inside the circle, 0 on the edge, and &gt; 0 outside
</span><span>  </span><span>return </span><span>math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius
</span><span>
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  </span><span># return a &#39;#&#39; if we&#39;re inside the circle, and &#39; &#39; otherwise
</span><span>  </span><span>if </span><span>circle(x, y) </span><span>&lt;= </span><span>0</span><span>:
</span><span>    </span><span>return </span><span>&#39;#&#39;
</span><span>  </span><span>else</span><span>:
</span><span>    </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span>while </span><span>True</span><span>:
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      </span><span># remap to -1..1 range (for x)...
</span><span>      remapped_x </span><span>= </span><span>x </span><span>/ </span><span>80 </span><span>* </span><span>2 </span><span>- </span><span>1
</span><span>      </span><span># ...and corrected for aspect ratio range (for y)
</span><span>      remapped_y </span><span>= </span><span>(y </span><span>/ </span><span>20 </span><span>* </span><span>2 </span><span>- </span><span>1</span><span>) </span><span>* </span><span>(</span><span>2 </span><span>* </span><span>20</span><span>/</span><span>80</span><span>)
</span><span>      frame_chars.append(sample(remapped_x, remapped_y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p><img src="https://vgel.me/posts/donut/stage2.png" alt="A circle made of octothorpes."/></p>
<p>Hey, that&#39;s a circle if I&#39;ve ever seen one!
We didn&#39;t use <code>time.time()</code> in this one, so the circle isn&#39;t animated—we&#39;ll bring animation back later, I promise.</p>
<h2 id="A_2D_donut"><a href="#A_2D_donut">
  <img src="https://vgel.me/permalink.svg" alt="permalink for A_2D_donut"/>
</a>A 2D donut</h2>
<p>A circle is just half a 2D donut—the hole is just another circle if you think about it.
So let&#39;s add the other circle to make a 2D donut!
There&#39;s a few different ways to do this (see if you can figure out a way on your own!), but a nice way is to define it as a radius + thickness around that radius:</p>
<!-- stage3 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math, time
</span><span>
</span><span>def </span><span>donut_2d</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  </span><span># same radius as before, though the donut will appear larger as
</span><span>  </span><span># half the thickness is outside this radius
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  </span><span># how thick the donut will be
</span><span>  thickness </span><span>= </span><span>0.3
</span><span>  </span><span># take the abs of the circle calculation from before, subtracting
</span><span>  </span><span># `thickness / 2`. `abs(...)` will be 0 on the edge of the circle, and
</span><span>  </span><span># increase as you move away. therefore, `abs(...) - thickness / 2` will
</span><span>  </span><span># be ≤ 0 only `thickness / 2` units away from the circle&#39;s edge on either
</span><span>  </span><span># side, giving a donut with a total width of `thickness`
</span><span>  </span><span>return </span><span>abs</span><span>(math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius) </span><span>- </span><span>thickness </span><span>/ </span><span>2
</span><span>
</span><span>
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  </span><span>if </span><span>donut_2d(x, y) </span><span>&lt;= </span><span>0</span><span>:
</span><span>    </span><span>return </span><span>&#39;#&#39;
</span><span>  </span><span>else</span><span>:
</span><span>    </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span>while </span><span>True</span><span>:
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      remapped_x </span><span>= </span><span>x </span><span>/ </span><span>80 </span><span>* </span><span>2 </span><span>- </span><span>1
</span><span>      remapped_y </span><span>= </span><span>(y </span><span>/ </span><span>20 </span><span>* </span><span>2 </span><span>- </span><span>1</span><span>) </span><span>* </span><span>(</span><span>2 </span><span>* </span><span>20</span><span>/</span><span>80</span><span>)
</span><span>      frame_chars.append(sample(remapped_x, remapped_y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p><img src="https://vgel.me/posts/donut/stage3.png" alt="A 2D donut made of hash marks. It looks like a very bold unslashed 0."/></p>
<p>This representation (radius + thickness) is artistically nice because radius and thickness are relatively independent parameters: they can be changed with little reference to each other.</p>
<p>But it&#39;s also nice for our code, since it&#39;s only a slight tweak from how we were calculating the distance: before, we calculated the distance from the center of the circle, and now we calculate the distance from the <em>edge</em> of that circle.
By subtracting <code>thickness / 2</code> from that edge distance, the result will be ≤ 0 if the point is less than <code>thickness / 2</code> from the edge of the circle, resulting in a ring of the given thickness centered on the edge of the circle with the given radius. </p>
<p>The other cool thing is that the tweak was so small that our code was able to stay almost exactly the same.
We just had to update the signed distance function—oops, gave it away—and didn&#39;t have to change the rest of the rendering loop!
More generally, regardless of what SDF we use, our rendering loop can stay the same—we&#39;re just sampling distances at pixels.</p>
<h2 id="Going_3D_mode"><a href="#Going_3D_mode">
  <img src="https://vgel.me/permalink.svg" alt="permalink for Going_3D_mode"/>
</a>Going 3D mode</h2>
<p>Time to enter the exciting decade of the 1990&#39;s and bring 3D graphics to the table!
We&#39;ll step back from the complexity of the donut slightly and start by rendering a sphere, which has an almost identical SDF to a circle, but with a new term: Z!</p>
<pre data-lang="python"><code data-lang="python"><span>def </span><span>sphere</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  </span><span>return </span><span>math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2 </span><span>+ </span><span>z</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius
</span></code></pre>
<p>Before, X was the horizontal axis and Y the vertical, Z will give our image depth.</p>
<p>We&#39;ll also re-use the same <code>frame_chars</code> loop as before.
The only function that needs to substantially change is <code>sample</code>, which now needs to handle <em>the third dimension</em>.
Fundamentally, we need a function that takes in an <code>(x, y)</code> 2D point, and samples 3D space in some way related to that point.
In other words, we need to &#34;come up with&#34; the correct Z to sample to get a reasonable character to render.
We could cheat and simply always sample at <code>z = 0</code>: that would render a 2D slice of our 3D world, showing the inside of any object that happened to cross the z=0 plane.</p>
<p>But to get a more interesting view we need to simulate the real world.
Imagine an eye, which is (to a first approximation) a 2D plane: how does it see distant objects?
Well, the sun shoots out rays, which either hit the eye-plane directly (not good, wear sunglasses folks) or bounce off one or more objects and then hit the eye.
We could treat our screen the same way: for each call to <code>sample(x, y)</code>, we&#39;ll shoot out millions of rays from a simulated light, hoping that at least one will bounce off an object and pass through <code>(x, y, camera_z)</code>.
That approach would be <em>slightly</em> slow, however.
The odds of any given ray hitting that specific point would be vanishingly small, and most of the work would be completely wasted.
You could throw all of us-east-1 at this python code (sorry Reddit, need to borrow your servers for a second), but let&#39;s take a shortcut instead.</p>
<p>In <code>sample(x, y)</code>, we only care about the ray of light that passes through <code>(x, y, camera_z)</code>.
So why bother with all the other rays?
We&#39;ll shoot the ray <em>backwards</em>!
We&#39;ll <em>start</em> it at <code>(x, y, camera_z)</code>, and at each step, query the SDF to get the distance from the ray&#39;s current point to the scene (in any direction).
If the distance is less than some threshold, we hit the scene!
Otherwise, we can safely &#34;march&#34; the ray forward by whatever distance is returned, since we know the scene is <em>at least</em> that distance away in the forward direction.
(It may be more—imagine the ray passes close to the scene, but never hits it: while the ray is near the scene, the distance queried from the SDF will be small, so the ray will be forced to move slowly, but eventually after some large number of steps, it will move past the scene and start moving quickly again.)
We&#39;ll arbitrarily limit the number of marches (steps) to 30 and return the background character if a ray doesn&#39;t hit something by then.
With all of that, this is what our new, 3D sample function looks like:</p>
<pre data-lang="python"><code data-lang="python"><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  </span><span># start `z` far back from the scene, which is centered at 0, 0, 0,
</span><span>  </span><span># so nothing clips
</span><span>  z </span><span>= -</span><span>10
</span><span>  </span><span># we&#39;ll step at most 30 steps before assuming we missed the scene
</span><span>  </span><span>for </span><span>_step </span><span>in </span><span>range</span><span>(</span><span>30</span><span>):
</span><span>    </span><span># get the distance, just like in 2D
</span><span>    d </span><span>= </span><span>sphere(x, y, z)
</span><span>    </span><span># test against 0.01, not 0: we&#39;re a little more forgiving with the distance
</span><span>    </span><span># in 3D for faster convergence
</span><span>    </span><span>if </span><span>d </span><span>&lt;= </span><span>0.01</span><span>:
</span><span>      </span><span># we hit the sphere!
</span><span>      </span><span>return </span><span>&#39;#&#39;
</span><span>    </span><span>else</span><span>:
</span><span>      </span><span># didn&#39;t hit anything yet, move the ray forward
</span><span>      </span><span># we can safely move forward by `d` without hitting anything since we know
</span><span>      </span><span># that&#39;s the distance to the scene
</span><span>      z </span><span>+= </span><span>d
</span><span>  </span><span># we didn&#39;t hit anything after 30 steps, return the background
</span><span>  </span><span>return </span><span>&#39; &#39;
</span></code></pre>
<p>And putting it all together, here&#39;s the code for rendering a sphere!</p>
<!-- stage4 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math, time
</span><span>
</span><span>def </span><span>sphere</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  </span><span>return </span><span>math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2 </span><span>+ </span><span>z</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius
</span><span>
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  z </span><span>= -</span><span>10
</span><span>  </span><span>for </span><span>_step </span><span>in </span><span>range</span><span>(</span><span>30</span><span>):
</span><span>    d </span><span>= </span><span>sphere(x, y, z)
</span><span>    </span><span>if </span><span>d </span><span>&lt;= </span><span>0.01</span><span>:
</span><span>      </span><span>return </span><span>&#39;#&#39;
</span><span>    </span><span>else</span><span>:
</span><span>      z </span><span>+= </span><span>d
</span><span>  </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span># this is unchanged
</span><span>while </span><span>True</span><span>:
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      remapped_x </span><span>= </span><span>x </span><span>/ </span><span>80 </span><span>* </span><span>2 </span><span>- </span><span>1
</span><span>      remapped_y </span><span>= </span><span>(y </span><span>/ </span><span>20 </span><span>* </span><span>2 </span><span>- </span><span>1</span><span>) </span><span>* </span><span>(</span><span>2 </span><span>* </span><span>20</span><span>/</span><span>80</span><span>)
</span><span>      frame_chars.append(sample(remapped_x, remapped_y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p><img src="https://vgel.me/posts/donut/stage4.png" alt="A &#34;sphere&#34;. It looks just like the circle from earlier."/></p>
<p>OK, this isn&#39;t very impressive, I admit it.
If you didn&#39;t know any better, you&#39;d probably accuse me of just re-using the circle image from before!
But I promise this is a sphere, really—let&#39;s keep moving and trust, for now, that it&#39;s 3D.</p>

<p>To move towards our 3D donut, next we&#39;ll need to replace the simple sphere SDF with the more complex <del>torus</del> donut SDF.
The rest of the code stays the same:</p>
<!-- stage5 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math, time
</span><span>
</span><span>def </span><span>donut</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  thickness </span><span>= </span><span>0.3
</span><span>  </span><span># first, we get the distance from the center and subtract the radius,
</span><span>  </span><span># just like the 2d donut.
</span><span>  </span><span># this value is the distance from the edge of the xy circle along a line
</span><span>  </span><span># drawn between [x, y, 0] and [0, 0, 0] (the center of the donut).
</span><span>  xy_d </span><span>= </span><span>math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius
</span><span>
</span><span>  </span><span># now we need to consider z, which, since we&#39;re evaluating the donut at
</span><span>  </span><span># [0, 0, 0], is the distance orthogonal (on the z axis) to that
</span><span>  </span><span># [x, y, 0]..[0, 0, 0] line.
</span><span>  </span><span># we can use these two values in the usual euclidean distance function to get
</span><span>  </span><span># the 3D version of our 2D donut &#34;distance from edge&#34; value.
</span><span>  d </span><span>= </span><span>math.sqrt(xy_d</span><span>**</span><span>2 </span><span>+ </span><span>z</span><span>**</span><span>2</span><span>)
</span><span>
</span><span>  </span><span># then, we subtract `thickness / 2` as before to get the signed distance,
</span><span>  </span><span># just like in 2D.
</span><span>  </span><span>return </span><span>d </span><span>- </span><span>thickness </span><span>/ </span><span>2
</span><span>
</span><span># unchanged from before, except for s/sphere/donut/g:
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  z </span><span>= -</span><span>10
</span><span>  </span><span>for </span><span>_step </span><span>in </span><span>range</span><span>(</span><span>30</span><span>):
</span><span>    d </span><span>= </span><span>donut(x, y, z)
</span><span>    </span><span>if </span><span>d </span><span>&lt;= </span><span>0.01</span><span>:
</span><span>      </span><span>return </span><span>&#39;#&#39;
</span><span>    </span><span>else</span><span>:
</span><span>      z </span><span>+= </span><span>d
</span><span>  </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span>while </span><span>True</span><span>:
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      remapped_x </span><span>= </span><span>x </span><span>/ </span><span>80 </span><span>* </span><span>2 </span><span>- </span><span>1
</span><span>      remapped_y </span><span>= </span><span>(y </span><span>/ </span><span>20 </span><span>* </span><span>2 </span><span>- </span><span>1</span><span>) </span><span>* </span><span>(</span><span>2 </span><span>* </span><span>20</span><span>/</span><span>80</span><span>)
</span><span>      frame_chars.append(sample(remapped_x, remapped_y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p><img src="https://vgel.me/posts/donut/stage5.png" alt="A 3D donut, which again looks suspiciously 2D"/></p>
<p>As before, this donut isn&#39;t very impressive, but since it&#39;s not symmetrical we can now add some motion to <em>prove</em> it&#39;s 3D.</p>

<p>All we need to do to make the donut spin is transform the points in <code>sample</code> before we evaluate the SDF:</p>
<pre data-lang="python"><code data-lang="python"><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  </span><span>...
</span><span>  </span><span>for </span><span>_step </span><span>in </span><span>range</span><span>(</span><span>30</span><span>):
</span><span>    </span><span># calculate the angle based on time, to animate the donut spinning
</span><span>    θ </span><span>= </span><span>time.time() </span><span>* </span><span>2
</span><span>    </span><span># rotate the input coordinates, which is equivalent to rotating the sdf
</span><span>    t_x </span><span>= </span><span>x </span><span>* </span><span>math.cos(θ) </span><span>- </span><span>z </span><span>* </span><span>math.sin(θ)
</span><span>    t_z </span><span>= </span><span>x </span><span>* </span><span>math.sin(θ) </span><span>+ </span><span>z </span><span>* </span><span>math.cos(θ)
</span><span>    d </span><span>= </span><span>donut(t_x, y, t_z)
</span><span>    </span><span>...
</span></code></pre>
<p>This will rotate the donut around the y axis, which is why <code>y</code> is unchanged.
We calculate θ per-sample, and then calculate a <a href="https://en.wikipedia.org/wiki/Rotation_matrix">rotation matrix</a> by hand because <del>I&#39;m too lazy to import numpy</del> real programmers don&#39;t use dependencies 😎.</p>
<p>Here it is in-context:</p>
<!-- stage6 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math, time
</span><span>
</span><span>def </span><span>donut</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  thickness </span><span>= </span><span>0.3
</span><span>  </span><span>return </span><span>math.sqrt((math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius)</span><span>**</span><span>2 </span><span>+ </span><span>z</span><span>**</span><span>2</span><span>) </span><span>- </span><span>thickness </span><span>/ </span><span>2
</span><span>
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  z </span><span>= -</span><span>10
</span><span>  </span><span>for </span><span>_step </span><span>in </span><span>range</span><span>(</span><span>30</span><span>):
</span><span>    θ </span><span>= </span><span>time.time() </span><span>* </span><span>2
</span><span>    t_x </span><span>= </span><span>x </span><span>* </span><span>math.cos(θ) </span><span>- </span><span>z </span><span>* </span><span>math.sin(θ)
</span><span>    t_z </span><span>= </span><span>x </span><span>* </span><span>math.sin(θ) </span><span>+ </span><span>z </span><span>* </span><span>math.cos(θ)
</span><span>    d </span><span>= </span><span>donut(t_x, y, t_z)
</span><span>    </span><span>if </span><span>d </span><span>&lt;= </span><span>0.01</span><span>:
</span><span>      </span><span>return </span><span>&#39;#&#39;
</span><span>    </span><span>else</span><span>:
</span><span>      z </span><span>+= </span><span>d
</span><span>  </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span>while </span><span>True</span><span>:
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      remapped_x </span><span>= </span><span>x </span><span>/ </span><span>80 </span><span>* </span><span>2 </span><span>- </span><span>1
</span><span>      remapped_y </span><span>= </span><span>(y </span><span>/ </span><span>20 </span><span>* </span><span>2 </span><span>- </span><span>1</span><span>) </span><span>* </span><span>(</span><span>2 </span><span>* </span><span>20</span><span>/</span><span>80</span><span>)
</span><span>      frame_chars.append(sample(remapped_x, remapped_y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p><img src="https://vgel.me/posts/donut/stage6.gif" alt="A spinning 3D donut"/></p>
<p>See, that&#39;s definitely 3D, no nits about it!
But since we&#39;re only at 32 lines (count em&#39;!), let&#39;s kick it up a notch and add some simple lighting and texturing with a normal vector estimator.</p>

<p>To add lighting and a frosting texture, we&#39;ll need to calculate normal vectors for our scene.
A normal vector is defined for an object at every point on that object&#39;s surface, and is the vector that sticks &#34;straight out&#34; from that point—imagine the spines on a cactus, or someone&#39;s hair after touching a staticy balloon.</p>
<p>Most surfaces have an analytic way to calculate the normal vector, but that can get difficult when you start combining multiple SDFs into a complex scene.
Plus, who wants to write out a normal function for each SDF they write?
That sucks!
So we can cheat and instead <em>estimate</em> the normal by sampling the SDF on each axis around a target point:</p>
<pre data-lang="python"><code data-lang="python"><span>Sdf </span><span>= </span><span>typing.Callable[[</span><span>float</span><span>, </span><span>float</span><span>, </span><span>float</span><span>], </span><span>float</span><span>]
</span><span>def </span><span>normal</span><span>(</span><span>sdf</span><span>: Sdf, </span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>tuple</span><span>[</span><span>float</span><span>, </span><span>float</span><span>, </span><span>float</span><span>]:
</span><span>  </span><span># an arbitrary small amount to offset around the point
</span><span>  ε </span><span>= </span><span>0.001
</span><span>  </span><span># calculate each axis independently
</span><span>  n_x </span><span>= </span><span>sdf(x </span><span>+ </span><span>ε, y, z) </span><span>- </span><span>sdf(x </span><span>- </span><span>ε, y, z)
</span><span>  n_y </span><span>= </span><span>sdf(x, y </span><span>+ </span><span>ε, z) </span><span>- </span><span>sdf(x, y </span><span>- </span><span>ε, z)
</span><span>  n_z </span><span>= </span><span>sdf(x, y, z </span><span>+ </span><span>ε) </span><span>- </span><span>sdf(x, y, z </span><span>- </span><span>ε)
</span><span>  </span><span># normalize the result to length = 1
</span><span>  norm </span><span>= </span><span>math.sqrt(n_x</span><span>**</span><span>2 </span><span>+ </span><span>n_y</span><span>**</span><span>2 </span><span>+ </span><span>n_z</span><span>**</span><span>2</span><span>)
</span><span>  </span><span>return </span><span>(n_x </span><span>/ </span><span>norm, n_y </span><span>/ </span><span>norm, n_z </span><span>/ </span><span>norm)
</span></code></pre>
<p>To make sense of how this function works, imagine the case where a component of the normal, say x, is 0.
That means the SDF at that point is flat on the x axis, so <code>sdf(x + ε, y, z) == sdf(x - ε, y, z)</code>.
As those values diverge, the x component of the normal will grow either more positive or negative, rotating it around.
It&#39;s just an estimation, but for rendering it&#39;s usually good enough, and even advanced demos will often use it.
The downside is it can be quite slow, since it needs to sample the SDF six times for every call!
As the scene SDF grows more complicated, that can become a big performance drain.</p>
<p>But for us it&#39;s good enough!
We&#39;ll calculate the normal in <code>sample</code> if the ray hits, and use it to compute some lighting and texturing:</p>
<pre data-lang="python"><code data-lang="python"><span>if </span><span>d </span><span>&lt;= </span><span>0.01</span><span>:
</span><span>  _, nt_y, nt_z </span><span>= </span><span>normal(donut, t_x, y, t_z)
</span><span>  is_lit </span><span>= </span><span>nt_y </span><span>&lt; -</span><span>0.15
</span><span>  is_frosted </span><span>= </span><span>nt_z </span><span>&lt; -</span><span>0.5
</span><span>
</span><span>  </span><span>if </span><span>is_frosted:
</span><span>    </span><span>return </span><span>&#39;@&#39; </span><span>if </span><span>is_lit </span><span>else </span><span>&#39;#&#39;
</span><span>  </span><span>else</span><span>:
</span><span>    </span><span>return </span><span>&#39;=&#39; </span><span>if </span><span>is_lit </span><span>else </span><span>&#39;.&#39;
</span></code></pre>
<p>We don&#39;t care about the x component of the normal, just y and z.
We&#39;ll use y to calculate the lighting, assuming that if a surface is facing up (the normal&#39;s y is close to -1), it should be lit.
We&#39;ll use z to show the frosting—by thresholding against different values, we can make the donut more or less frosted.
The best way to gain an intuition for what these values mean is to play with them, so try changing them around in a local copy of the code below and watch what happens!</p>
<!-- stage7 -->
<pre data-lang="python"><code data-lang="python"><span>import </span><span>math, time, typing
</span><span>
</span><span>def </span><span>donut</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>float</span><span>:
</span><span>  radius </span><span>= </span><span>0.4
</span><span>  thickness </span><span>= </span><span>0.3
</span><span>  </span><span>return </span><span>math.sqrt((math.sqrt(x</span><span>**</span><span>2 </span><span>+ </span><span>y</span><span>**</span><span>2</span><span>) </span><span>- </span><span>radius)</span><span>**</span><span>2 </span><span>+ </span><span>z</span><span>**</span><span>2</span><span>) </span><span>- </span><span>thickness </span><span>/ </span><span>2
</span><span>
</span><span>Sdf </span><span>= </span><span>typing.Callable[[</span><span>float</span><span>, </span><span>float</span><span>, </span><span>float</span><span>], </span><span>float</span><span>]
</span><span>def </span><span>normal</span><span>(</span><span>sdf</span><span>: Sdf, </span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>, </span><span>z</span><span>: </span><span>float</span><span>) -&gt; </span><span>tuple</span><span>[</span><span>float</span><span>, </span><span>float</span><span>, </span><span>float</span><span>]:
</span><span>  ε </span><span>= </span><span>0.001
</span><span>  n_x </span><span>= </span><span>sdf(x </span><span>+ </span><span>ε, y, z) </span><span>- </span><span>sdf(x </span><span>- </span><span>ε, y, z)
</span><span>  n_y </span><span>= </span><span>sdf(x, y </span><span>+ </span><span>ε, z) </span><span>- </span><span>sdf(x, y </span><span>- </span><span>ε, z)
</span><span>  n_z </span><span>= </span><span>sdf(x, y, z </span><span>+ </span><span>ε) </span><span>- </span><span>sdf(x, y, z </span><span>- </span><span>ε)
</span><span>  norm </span><span>= </span><span>math.sqrt(n_x</span><span>**</span><span>2 </span><span>+ </span><span>n_y</span><span>**</span><span>2 </span><span>+ </span><span>n_z</span><span>**</span><span>2</span><span>)
</span><span>  </span><span>return </span><span>(n_x </span><span>/ </span><span>norm, n_y </span><span>/ </span><span>norm, n_z </span><span>/ </span><span>norm)
</span><span>
</span><span>def </span><span>sample</span><span>(</span><span>x</span><span>: </span><span>float</span><span>, </span><span>y</span><span>: </span><span>float</span><span>) -&gt; </span><span>str</span><span>:
</span><span>  z </span><span>= -</span><span>10
</span><span>  </span><span>for </span><span>_step </span><span>in </span><span>range</span><span>(</span><span>30</span><span>):
</span><span>    θ </span><span>= </span><span>time.time() </span><span>* </span><span>2
</span><span>    t_x </span><span>= </span><span>x </span><span>* </span><span>math.cos(θ) </span><span>- </span><span>z </span><span>* </span><span>math.sin(θ)
</span><span>    t_z </span><span>= </span><span>x </span><span>* </span><span>math.sin(θ) </span><span>+ </span><span>z </span><span>* </span><span>math.cos(θ)
</span><span>    d </span><span>= </span><span>donut(t_x, y, t_z)
</span><span>    </span><span>if </span><span>d </span><span>&lt;= </span><span>0.01</span><span>:
</span><span>      _, nt_y, nt_z </span><span>= </span><span>normal(donut, t_x, y, t_z)
</span><span>      is_lit </span><span>= </span><span>nt_y </span><span>&lt; -</span><span>0.15
</span><span>      is_frosted </span><span>= </span><span>nt_z </span><span>&lt; -</span><span>0.5
</span><span>
</span><span>      </span><span>if </span><span>is_frosted:
</span><span>        </span><span>return </span><span>&#39;@&#39; </span><span>if </span><span>is_lit </span><span>else </span><span>&#39;#&#39;
</span><span>      </span><span>else</span><span>:
</span><span>        </span><span>return </span><span>&#39;=&#39; </span><span>if </span><span>is_lit </span><span>else </span><span>&#39;.&#39;
</span><span>    </span><span>else</span><span>:
</span><span>      z </span><span>+= </span><span>d
</span><span>  </span><span>return </span><span>&#39; &#39;
</span><span>
</span><span>while </span><span>True</span><span>:
</span><span>  frame_chars </span><span>= </span><span>[]
</span><span>  </span><span>for </span><span>y </span><span>in </span><span>range</span><span>(</span><span>20</span><span>):
</span><span>    </span><span>for </span><span>x </span><span>in </span><span>range</span><span>(</span><span>80</span><span>):
</span><span>      remapped_x </span><span>= </span><span>x </span><span>/ </span><span>80 </span><span>* </span><span>2 </span><span>- </span><span>1
</span><span>      remapped_y </span><span>= </span><span>(y </span><span>/ </span><span>20 </span><span>* </span><span>2 </span><span>- </span><span>1</span><span>) </span><span>* </span><span>(</span><span>2 </span><span>* </span><span>20</span><span>/</span><span>80</span><span>)
</span><span>      frame_chars.append(sample(remapped_x, remapped_y))
</span><span>    frame_chars.append(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>&#39;</span><span>\033</span><span>[2J&#39; </span><span>+ </span><span>&#39;&#39;</span><span>.join(frame_chars))
</span><span>  time.sleep(</span><span>1</span><span>/</span><span>30</span><span>)
</span></code></pre>
<p><img src="https://vgel.me/posts/donut/stage7.gif" alt="A spinning 3D donut with rudimentary lighting and texturing"/></p>
<p>There&#39;s our final 3D donut, lit, textured, and spinning as promised, in only 46 lines of code!
Thanks for sticking through, and I hope this article is inspiring to try and make your own SDF creations.
If you&#39;re interested in learning more about SDFs, there are many resources online, but none I could recommend more highly than <a href="https://iquilezles.org/">Inigio Quilez&#39;s website</a>—he is an SDF master and has made some truly mind-blowing art using SDFs.
He also has <a href="https://www.youtube.com/@InigoQuilez">a Youtube channel</a> where he posts videos of his work and tutorials.
I recommend <a href="https://www.youtube.com/watch?v=BFld4EBO2RE">this video</a> where he makes a landscape using SDFs.
Enjoy, and thanks for reading to the end!</p>
<hr/>









    <ul>
      
        <li><strong>Previous entry:</strong> <a href="https://vgel.me/posts/mmap-arena-alloc/">mmap(1Tb): A Rust arena allocator (ab)using Linux overcommit</a></li>
      
      
    </ul>
</article></div>
  </body>
</html>
