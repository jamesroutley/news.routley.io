<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/lyokha/nginx-haskell-module">Original</a>
    <h1>Show HN: Custom Haskell handlers for Nginx</h1>
    
    <div id="readability-page-1" class="page"><section>
            
<p>Nebcorp Heavy Industries and Sundries, long the world leader in sundries, is proud to announce the
public launch of the official identifier type for all Nebcorp companies&#39; assets and database
entries, <a href="https://gitlab.com/nebkor/julid">Julids</a>. Julids are globally unique sortable identifiers,
backwards-compatible with <a href="https://github.com/ulid/spec">ULIDs</a>, <em>but better</em>.</p>
<p>Inside your Rust program, simply add <code>julid-rs</code><sup><a href="#julid-package">1</a></sup> to your project&#39;s <code>Cargo.toml</code> file, and use it
like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>julid::Julid;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> id = Julid::new();
</span><span>    dbg!(id.</span><span>created_at</span><span>(), id.</span><span>as_string</span><span>());
</span><span>}
</span></code></pre>
<p>Such a program would output something like:</p>
<pre data-lang="text"><code data-lang="text"><span>[main.rs:5] id.created_at() = 2023-07-29T20:21:50.009Z
</span><span>[main.rs:5] id.as_string() = &#34;01H6HN10SS00020YT344XMGA3C&#34;
</span></code></pre>
<p>However, it can also be built as a <a href="https://www.sqlite.org/loadext.html">loadable extension</a> for
SQLite, adding database functions for creating and querying Julids:</p>
<pre data-lang="text"><code data-lang="text"><span>$ sqlite3
</span><span>SQLite version 3.40.1 2022-12-28 14:03:47
</span><span>Enter &#34;.help&#34; for usage hints.
</span><span>Connected to a transient in-memory database.
</span><span>Use &#34;.open FILENAME&#34; to reopen on a persistent database.
</span><span>sqlite&gt; .load ./libjulid
</span><span>sqlite&gt; select hex(julid_new());
</span><span>018998768ACF000060B31DB175E0C5F9
</span><span>sqlite&gt; select julid_string(julid_new());
</span><span>01H6C7D9CT00009TF3EXXJHX4Y
</span><span>sqlite&gt; select julid_seconds(julid_new());
</span><span>1690480066.208
</span><span>sqlite&gt; select datetime(julid_timestamp(julid_new()), &#39;auto&#39;);
</span><span>2023-07-27 17:47:50
</span><span>sqlite&gt; select julid_counter(julid_new());
</span><span>0
</span></code></pre>
<p>Intrigued? Confused? Disgusted? Enraged?? Well, read on!</p>
<h2 id="julids-vs-ulids">Julids vs ULIDs</h2>
<p>Julids are a drop-in replacement for ULIDs: all Julids are valid ULIDs, but not all ULIDs are valid
Julids.</p>
<p>Given their compatibility relationship, Julids and ULIDs must have quite a bit in common, and indeed
they do:</p>
<ul>
<li>they are 128-bits long</li>
<li>they are lexicographically sortable</li>
<li>they encode their creation time as the number of milliseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX
epoch</a> in their top 48 bits</li>
<li>their string representation is a 26-character <a href="https://en.wikipedia.org/wiki/Base32">base-32
Crockford</a> encoding of their big-endian bytes</li>
<li>IDs created within the same millisecond are still meant to sort in their order of creation</li>
</ul>
<p>Julids and ULIDs have different ways to implement that last piece. If you look at the layout of bits
in a ULID, you see:</p>
<p><img src="https://proclamations.nebcorp-hias.com/sundries/presenting-julids/./ulid.svg" alt="ULID bit structure"/></p>
<p>According to the ULID spec, for ULIDs created within the same millisecond, the least-significant bit
should be incremented for each new ID. Since that portion of the ULID is random, that means you may
not be able to increment it without spilling into the timestamp portion. Likewise, it&#39;s easy to
guess a new possibly-valid ULID simply by incrementing an already-known one. And finally, this means
that sorting will need to read all the way to the end of the ULID for IDs created in the same
millisecond.</p>
<p>To address these shortcomings, Julids (Joe&#39;s<sup><a href="#httm">2</a></sup> ULIDs) have the following structure:</p>
<p><img src="https://proclamations.nebcorp-hias.com/sundries/presenting-julids/./julid.svg" alt="Julid bit structure"/></p>
<p>As with ULIDs, the 48 most-significant bits encode the time of creation. Unlike ULIDs, the next 16
most-significant bits are not random<sup><a href="#counter idea">3</a></sup>: they&#39;re a monotonic counter for IDs created
within the same millisecond<sup><a href="#monotonic">4</a></sup>. Since it&#39;s only 16 bits, it will saturate after 65,536 IDs
intra-millisecond creations, after which, IDs in that same millisecond will not have an intrinsic
total order (the random bits will still be different, so you shouldn&#39;t have collisions). My PC,
which is no slouch, can only generate about 20,000 per millisecond, so hopefully this is not an
issue! Because the random bits are always fresh, it&#39;s not possible to easily guess a valid Julid if
you already have one.</p>

<p>The Julid crate can be used in two different ways: as a regular Rust library, declared in your Rust
project&#39;s <code>Cargo.toml</code> file (say, by running <code>cargo add julid-rs</code>), and used as shown above. There&#39;s
a rudimentary <a href="https://gitlab.com/nebkor/julid/-/blob/main/examples/benchmark.rs">benchmark</a> example
in the repo, which I&#39;ll talk more about below. But the primary use case for me was as a loadable
SQLite extension, as I <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery-part-2/#next-steps-with-ids">previously
wrote</a>. Both are covered in the
<a href="https://docs.rs/julid-rs/latest/julid/">documentation</a>, but let&#39;s go over them here, starting with
the extension.</p>
<h2 id="inside-sqlite-as-a-loadable-extension">Inside SQLite as a loadable extension</h2>
<p>The extension, when loaded into SQLite, provides the following functions:</p>
<ul>
<li><code>julid_new()</code>: create a new Julid and return it as a 16-byte
<a href="https://www.sqlite.org/datatype3.html#storage_classes_and_datatypes">blob</a></li>
<li><code>julid_seconds(julid)</code>: get the number seconds (as a 64-bit float) since the UNIX epoch that this
julid was created</li>
<li><code>julid_counter(julid)</code>: show the value of this julid&#39;s monotonic counter</li>
<li><code>julid_sortable(julid)</code>: return the 64-bit concatenation of the timestamp and counter</li>
<li><code>julid_string(julid)</code>: show the <a href="https://en.wikipedia.org/wiki/Base32">base-32 Crockford</a>
encoding of this julid; the raw bytes of Julids won&#39;t be valid UTF-8, so use this or the built-in
<code>hex()</code> function to <code>select</code> a human-readable representation</li>
</ul>
<h3 id="building-and-loading">Building and loading</h3>
<p>If you want to use it as a SQLite extension:</p>
<ul>
<li>clone the <a href="https://gitlab.com/nebkor/julid">repo</a></li>
<li>build it with <code>cargo build --features plugin</code> (this builds the SQLite extension)</li>
<li>copy the resulting <code>libjulid.[so|dylib|whatevs]</code> to some place where you can...</li>
<li>load it into SQLite with <code>.load /path/to/libjulid</code> as shown at the top</li>
<li>party</li>
</ul>
<p>If you, like me, wish to use Julids as primary keys, just create your table like:</p>
<pre data-lang="sql"><code data-lang="sql"><span>create table </span><span>users</span><span> (
</span><span>  id blob not </span><span>null </span><span>primary key default</span><span> (julid_new()),
</span><span>  ...
</span><span>);
</span></code></pre>
<p>and you&#39;ve got a first-class ticket straight to Julid City, baby!</p>
<p>For a table created like:</p>
<pre data-lang="sql"><code data-lang="sql"><span>-- table of things to watch
</span><span>create table </span><span>if not exists </span><span>watches</span><span> (
</span><span>  id blob not </span><span>null </span><span>primary key default</span><span> (julid_new()),
</span><span>  kind </span><span>int </span><span>not </span><span>null</span><span>, </span><span>-- enum for movie or tv show or whatev
</span><span>  title </span><span>text </span><span>not </span><span>null</span><span>,
</span><span>  length </span><span>int</span><span>,
</span><span>  release_date </span><span>int</span><span>,
</span><span>  added_by blob not </span><span>null</span><span>,
</span><span>  last_updated </span><span>int </span><span>not </span><span>null </span><span>default</span><span> (unixepoch()),
</span><span>  </span><span>foreign key</span><span> (added_by) </span><span>references</span><span> users (id)
</span><span>);
</span></code></pre>
<p>and then <a href="https://gitlab.com/nebkor/ww/-/blob/cc14c30fcfbd6cdaecd85d0ba629154d098b4be9/src/import_utils.rs#L92-126">some
code</a>
that inserted rows into that table like</p>
<pre data-lang="sql"><code data-lang="sql"><span>insert into</span><span> watches (kind, title, length, release_date, added_by) </span><span>values</span><span> (?,?,?,?,?)
</span></code></pre>
<p>where the wildcards get bound in a loop with unique values and the Julid <code>id</code> field is
generated by the extension for each row, I get over 100,000 insertions/second.</p>
<h2 id="inside-a-rust-program">Inside a Rust program</h2>
<p>Of course, you can also use it outside of a database; the <code>Julid</code> type is publicly exported. There&#39;s
a simple benchmark in the examples folder of the repo, the important parts of which look like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>julid::Julid;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>/* snip some stuff */
</span><span>
</span><span>    </span><span>let</span><span> start = Instant::now();
</span><span>    </span><span>for </span><span>_ in </span><span>0</span><span>..num {
</span><span>        v.</span><span>push</span><span>(Julid::new());
</span><span>    }
</span><span>    </span><span>let</span><span> end = Instant::now();
</span><span>    </span><span>let</span><span> dur = (end - start).</span><span>as_micros</span><span>();
</span><span>
</span><span>    </span><span>for</span><span> id in v.</span><span>iter</span><span>() {
</span><span>        eprintln!(
</span><span>            &#34;</span><span>{id}</span><span>: created_at </span><span>{}</span><span>; counter: </span><span>{}</span><span>; sortable: </span><span>{}</span><span>&#34;,
</span><span>            id.</span><span>created_at</span><span>(),
</span><span>            id.</span><span>counter</span><span>(),
</span><span>            id.</span><span>sortable</span><span>()
</span><span>        );
</span><span>    }
</span><span>    println!(&#34;</span><span>{num}</span><span> Julids generated in </span><span>{dur}</span><span>us</span><span>&#34;);
</span></code></pre>
<p>If you were to run it on a computer like mine<sup><a href="#my computer">5</a></sup>, you might see something like this:</p>
<pre data-lang="text"><code data-lang="text"><span>$ cargo run --example=benchmark --release -- -n 30000 2&gt; /dev/null
</span><span>30000 Julids generated in 1240us
</span></code></pre>
<p>That&#39;s about 24,000 IDs/millisecond; 24 <em>MILLION</em> per second!</p>
<p>The default optional Cargo features include implementations of traits for getting Julids into and
out of SQLite with <a href="https://github.com/launchbadge/sqlx">SQLx</a>, and for generally
serializing/deserializing with <a href="https://serde.rs/">Serde</a>, via the <code>sqlx</code> and <code>serde</code> features,
respectively. One final default optional feature, <code>chrono</code>, uses the Chrono crate to return the
timestamp as a <a href="https://docs.rs/chrono/latest/chrono/struct.DateTime.html"><code>DateTime</code></a> by adding a
<code>created_at(&amp;self)</code> method to <code>Julid</code>.</p>
<p>Something to note: don&#39;t enable the <code>plugin</code> feature in your Cargo.toml if you&#39;re using this crate
inside your Rust application, especially if you&#39;re <em>also</em> loading it as an extension in SQLite in
your application. You&#39;ll get a long and confusing runtime panic due to there being multiple
entrypoints defined with the same name.</p>

<p>The astute may have noticed that this is the third time I&#39;ve written about globally unique sortable
IDs (<a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery">here is part one</a>, and <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery-part-2">part two is
here</a>). What&#39;s, uh... what&#39;s up with that?</p>
<p><img src="https://proclamations.nebcorp-hias.com/sundries/presenting-julids/./marge_thinks_theyre_neat.png" alt="marge just thinks they&#39;re neat" title="marge simpson holding a potato labeled &#34;globally unique sortable identifiers&#34;"/></p>
<p>we both just think they&#39;re neat</p>
<p>Like Marge, I just think they&#39;re neat! We&#39;re not the only ones; here are just some related projects:</p>
<ul>
<li>Segment&#39;s <a href="https://segment.com/blog/a-brief-history-of-the-uuid/">KSUID</a>, released in 2017. This
was possibly my first exposure to this idea. They&#39;re 36 bits larger than UUIDs or ULIDs, but
otherwise very similar to ULIDs (and hence Julids)</li>
<li><a href="https://github.com/ulid/spec">ULIDs</a>, of course</li>
<li><a href="https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-01.html#name-uuidv7-layout-and-bit-order">UUIDv7</a>;
these are <em>very</em> similar to Julids; the primary difference is that the lower 62 bits are left up
to the implementation, rather than always containing pseudorandom bits as in Julids (which use
the lower 64 bits for that, instead of UUIDv7&#39;s 62)</li>
<li><a href="https://en.wikipedia.org/wiki/Snowflake_ID">Snowflake ID</a>, developed by Twitter in 2010; these
are 63-bit identifiers (so they fit in a signed 64-bit number), where the top 41 bits are a
millisecond timestamp, the next 10 bits are a machine identifier<sup><a href="#twitter machine count">6</a></sup>, and the
last 12 bits are for an intra-millisecond sequence counter (what Julid calls a &#34;monotonic
counter&#34;); unlike all the other IDs discussed, there are no random bits</li>
</ul>
<p>and I&#39;m sure the list can go on.</p>
<p>I wanted to use them in my SQLite-backed <a href="https://gitlab.com/nebkor/ww">web app</a>, in order to fix
some deficiencies in ULIDs and the way I was using them, as <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery-part-2/#next-steps-with-ids">I said
before</a>:</p>
<blockquote>
<p>[...] it bothers me that ID generation is not done inside the database itself. Aside from being
a generally bad idea, this lead to at least one frustrating debug session where I was inserting
one ID but reporting back another. SQLite doesn&#39;t have native support for this, but it does have
good native support for loading shared libraries as plugins in order to add functionality to it,
and so my next step is to write one of those, and remove the ID generation logic from the
application.</p>
</blockquote>
<p>Now that I&#39;ve accomplished all that I&#39;ve set out to do, is this the last time I&#39;ll time I&#39;ll be
writing at length about these things? It&#39;s hard to say for sure, but signs point to &#34;yes&#34;. I hope
you&#39;ve found them at least a little interesting!</p>

<p>This project wouldn&#39;t have happened without a lot of inspiration (and a little shameless stealing)
from the <a href="https://github.com/dylanhart/ulid-rs">ulid-rs</a> crate. For the loadable extension, the
<a href="https://github.com/asg017/sqlite-loadable-rs">sqlite-loadable-rs</a> crate made it <em>extremely</em> easy to
write; what I thought would take a couple days instead took a couple hours. Thank you, authors of
those crates! Feel free to steal code from me any time!</p>
<hr/>







        </section></div>
  </body>
</html>
