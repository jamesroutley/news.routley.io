<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/lyokha/nginx-haskell-module">Original</a>
    <h1>Show HN: Custom Haskell handlers for Nginx</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/lyokha/nginx-haskell-module/blob/master/docs/images/nginx-haskell-module-social.png"><img src="https://github.com/lyokha/nginx-haskell-module/raw/master/docs/images/nginx-haskell-module-social.png"/></a>
</p>

<p dir="auto"><a href="https://github.com/lyokha/nginx-haskell-module/actions?query=workflow%3ACI"><img src="https://github.com/lyokha/nginx-haskell-module/workflows/CI/badge.svg" alt="Build Status"/></a>
<a href="https://hackage.haskell.org/package/ngx-export" rel="nofollow"><img src="https://camo.githubusercontent.com/a558c583eab652c9af2ef1c12740f70dad4c253edfda3e1c6cdca0969f3a1500/68747470733a2f2f696d672e736869656c64732e696f2f6861636b6167652f762f6e67782d6578706f72742e7376673f6c6162656c3d6861636b6167652532302537432532306e67782d6578706f7274266c6f676f3d6861736b656c6c266c6f676f436f6c6f723d253233393538304431" alt="Hackage" data-canonical-src="https://img.shields.io/hackage/v/ngx-export.svg?label=hackage%20%7C%20ngx-export&amp;logo=haskell&amp;logoColor=%239580D1"/></a>
<a href="https://hackage.haskell.org/package/ngx-export-tools" rel="nofollow"><img src="https://camo.githubusercontent.com/ccdb264664762410dc7087a7af1ad4abc4a38487ff55efc5a8e7f98a7e63f627/68747470733a2f2f696d672e736869656c64732e696f2f6861636b6167652f762f6e67782d6578706f72742d746f6f6c732e7376673f6c6162656c3d6861636b6167652532302537432532306e67782d6578706f72742d746f6f6c73266c6f676f3d6861736b656c6c266c6f676f436f6c6f723d253233393538304431" alt="Hackage" data-canonical-src="https://img.shields.io/hackage/v/ngx-export-tools.svg?label=hackage%20%7C%20ngx-export-tools&amp;logo=haskell&amp;logoColor=%239580D1"/></a>
<a href="https://hackage.haskell.org/package/ngx-export-distribution" rel="nofollow"><img src="https://camo.githubusercontent.com/b8638ccb38c73f3bf7859659946463ecfb68ba81130975a911f8ac1d8e36bb3d/68747470733a2f2f696d672e736869656c64732e696f2f6861636b6167652f762f6e67782d6578706f72742d646973747269627574696f6e2e7376673f6c6162656c3d6861636b6167652532302537432532306e67782d6578706f72742d646973747269627574696f6e266c6f676f3d6861736b656c6c266c6f676f436f6c6f723d253233393538304431" alt="Hackage" data-canonical-src="https://img.shields.io/hackage/v/ngx-export-distribution.svg?label=hackage%20%7C%20ngx-export-distribution&amp;logo=haskell&amp;logoColor=%239580D1"/></a>
<a href="https://hub.docker.com/r/lyokha/nginx-haskell-module" rel="nofollow"><img src="https://camo.githubusercontent.com/d67105968d6fdb57d82a676703dab4369eb8af17966dc44c57e09912721e424b/68747470733a2f2f696d672e736869656c64732e696f2f646f636b65722f762f6c796f6b68612f6e67696e782d6861736b656c6c2d6d6f64756c652f6c61746573743f6c6162656c3d646f636b6572266c6f676f3d646f636b6572" alt="Docker" data-canonical-src="https://img.shields.io/docker/v/lyokha/nginx-haskell-module/latest?label=docker&amp;logo=docker"/></a>
<a href="https://nginx-haskell-module.readthedocs.io/en/latest/" rel="nofollow"><img src="https://camo.githubusercontent.com/d9d0d21e00843795ce5e839d64e422bb36d5dc1c266178ecc5e1adacc4b0c6e5/68747470733a2f2f696d672e736869656c64732e696f2f72656164746865646f63732f6e67696e782d6861736b656c6c2d6d6f64756c652f6c61746573743f6c6f676f3d72656164746865646f6373" alt="Read the Docs" data-canonical-src="https://img.shields.io/readthedocs/nginx-haskell-module/latest?logo=readthedocs"/></a>
<a href="https://nbviewer.jupyter.org/github/lyokha/nginx-haskell-module/blob/master/docs/yet-another-doc-with-examples/nginx-haskell-module-yadwe.pdf" rel="nofollow"><img src="https://camo.githubusercontent.com/2ad93d4624ae13eabd50544fbc0551f916caa7cafb08ad0d2d7c6ff9801f40ca/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f7064662d7965745f616e6f746865725f646f635f776974685f6578616d706c65732d3738364435462e7376673f6c6f676f3d6a757079746572" alt="Doc" data-canonical-src="https://img.shields.io/badge/pdf-yet_another_doc_with_examples-786D5F.svg?logo=jupyter"/></a></p>
<p dir="auto">Use this module to build custom Haskell handlers and run them in the Nginx Web
Server. Supported types of custom handlers include</p>
<ul dir="auto">
<li>synchronous variable handlers,</li>
<li>asynchronous tasks,</li>
<li>services (i.e. asynchronous tasks that are not bound to requests),</li>
<li>shared services (i.e. services that work exclusively on a single Nginx worker
process all the time),</li>
<li>content handlers,</li>
<li>POST request handlers.</li>
</ul>
<p dir="auto">Besides the module itself, there is a number of Haskell packages which help to
solve typical higher-level tasks. See the
<a href="#list-of-batteries-included"><em>list of batteries included</em></a>.</p>

<ul dir="auto">
<li><a href="#building-and-installation">Building and installation</a></li>
<li><a href="#synchronous-tasks">Synchronous tasks</a></li>
<li><a href="#synchronous-content-handlers">Synchronous content handlers</a></li>
<li><a href="#asynchronous-tasks-and-request-body-handlers">Asynchronous tasks and request body handlers</a></li>
<li><a href="#asynchronous-content-handlers">Asynchronous content handlers</a></li>
<li><a href="#asynchronous-services">Asynchronous services</a></li>
<li><a href="#shared-services">Shared services</a></li>
<li><a href="#service-hooks">Service hooks</a></li>
<li><a href="#c-plugins-with-low-level-access-to-nginx-objects">C plugins with low level access to Nginx objects</a></li>
<li><a href="#efficiency-of-data-exchange-between-nginx-and-haskell-handlers">Efficiency of data exchange between Nginx and Haskell handlers</a></li>
<li><a href="#exceptions-in-haskell-handlers">Exceptions in Haskell handlers</a></li>
<li><a href="#summary-table-of-all-nginx-directives-of-the-module">Summary table of all Nginx directives of the module</a></li>
<li><a href="#module-ngxexporttools">Module NgxExport.Tools</a></li>
<li><a href="#list-of-batteries-included">List of batteries included</a></li>
<li><a href="#see-also">See also</a></li>
</ul>

<p dir="auto">In directory with the Nginx sources, run</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ ./configure --add-module=/path/to/echo_module_sources --add-module=/path/to/this_module_sources
$ make
$ sudo make install"><pre>$ <span>./configure --add-module=/path/to/echo_module_sources --add-module=/path/to/this_module_sources</span>
$ <span>make</span>
$ <span>sudo make install</span></pre></div>
<p dir="auto">You may also want to add <code>--add-module=/path/to/this_module_sources/aliases</code>
and
<code>--add-module=/path/to/this_module_sources/examples/dynamicUpstreams/nginx-upconf-module</code>
to the configure options to enable modules <a href="https://github.com/lyokha/nginx-haskell-module/blob/master/aliases"><em>aliases</em></a> and
<a href="https://github.com/lyokha/nginx-haskell-module/blob/master/examples/dynamicUpstreams"><em>upconf</em></a> respectively.</p>
<p dir="auto">To build examples, we will use <em>ghc</em>. This is rather not practical in modern
world where dependencies get normally installed by <em>cabal</em> into directories not
known to <em>ghc</em>. Look
<a href="https://github.com/lyokha/nginx-haskell-module/tree/master/docs/yet-another-doc-with-examples/test"><em>here</em></a>
to learn how to build examples using <em>cabal</em> and
<a href="https://hackage.haskell.org/package/ngx-export-distribution" rel="nofollow"><em>ngx-export-distribution</em></a>.</p>

<p dir="auto">Synchronous tasks are mostly <em>pure</em> Haskell functions of various types. To make
them available in Nginx configuration files, they must be exported with special
declarations named <em>exporters</em>. Below is a table of <em>type/exporter</em>
correspondence for all available synchronous handlers.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Exporter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String -&gt; String</code></td>
<td><code>ngxExportSS</code> (<code>NGX_EXPORT_S_S</code>)</td>
</tr>
<tr>
<td><code>String -&gt; String -&gt; String</code></td>
<td><code>ngxExportSSS</code> (<code>NGX_EXPORT_S_SS</code>)</td>
</tr>
<tr>
<td><code>String -&gt; Bool</code></td>
<td><code>ngxExportBS</code> (<code>NGX_EXPORT_B_S</code>)</td>
</tr>
<tr>
<td><code>String -&gt; String -&gt; Bool</code></td>
<td><code>ngxExportBSS</code> (<code>NGX_EXPORT_B_SS</code>)</td>
</tr>
<tr>
<td><code>[String] -&gt; String</code></td>
<td><code>ngxExportSLS</code> (<code>NGX_EXPORT_S_LS</code>)</td>
</tr>
<tr>
<td><code>[String] -&gt; Bool</code></td>
<td><code>ngxExportBLS</code> (<code>NGX_EXPORT_B_LS</code>)</td>
</tr>
<tr>
<td><code>ByteString -&gt; L.ByteString</code></td>
<td><code>ngxExportYY</code> (<code>NGX_EXPORT_Y_Y</code>)</td>
</tr>
<tr>
<td><code>ByteString -&gt; Bool</code></td>
<td><code>ngxExportBY</code> (<code>NGX_EXPORT_B_Y</code>)</td>
</tr>
<tr>
<td><code>ByteString -&gt; IO L.ByteString</code></td>
<td><code>ngxExportIOYY</code> (<code>NGX_EXPORT_IOY_Y</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">All synchronous handlers may accept <em>strings</em> (one or two), a <em>list of strings</em>,
or a <em>strict bytestring</em>, and return a <em>string</em>, a <em>boolean</em> or a <em>lazy
bytestring</em>. The last handler from the table is <em>impure</em> or <em>effectful</em>, and it
returns a <em>lazy bytestring</em> wrapped in <em>IO Monad</em>.</p>
<p dir="auto">There are two kinds of exporters which differ only in their implementations.
The first kind â <em>camel-cased</em> exporters â is implemented by means
of <em>Template Haskell</em>, the other kind â exporters in braces, as they are
shown in the table â is implemented using <em>CPP macros</em>. Both of them
provide <em>FFI</em> declarations for functions they export, but the camel-cased
exporters are available only from a separate Haskell module
<a href="https://hackage.haskell.org/package/ngx-export" rel="nofollow"><em>ngx-export</em></a>, which can be
downloaded and installed by <em>cabal</em>, whereas the CPP exporters are implemented
inside the <em>nginx-haskell-module</em> in so-called <em>standalone</em> approach, where
custom Haskell declarations get wrapped inside common Haskell code.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples</h2>
<p dir="auto">In all examples in this section and later, we will use <em>modular</em> approach with
<em>camel-cased</em> exporters and separate compilation of Haskell code.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths" aria-hidden="true" href="#file-tesths"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs</h4>
<div dir="auto" data-snippet-clipboard-copy-content="{-# LANGUAGE TemplateHaskell #-}

module NgxHaskellUserRuntime where

import           NgxExport
import qualified Data.Char as C

toUpper :: String -&gt; String
toUpper = map C.toUpper
ngxExportSS &#39;toUpper

ngxExportSS &#39;reverse

isInList :: [String] -&gt; Bool
isInList [] = False
isInList (x : xs) = x `elem` xs
ngxExportBLS &#39;isInList"><pre>{-# <span>LANGUAGE</span> TemplateHaskell #-}

<span>module</span> <span>NgxHaskellUserRuntime</span> <span>where</span>

<span>import</span>           <span>NgxExport</span>
<span>import</span> <span>qualified</span> <span>Data.Char</span> <span>as</span> <span>C</span>

<span>toUpper</span> <span>::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>String</span></span>
toUpper <span>=</span> <span>map</span> <span>C.</span>toUpper
ngxExportSS &#39;toUpper

ngxExportSS &#39;reverse

<span>isInList</span> <span>::</span> [<span><span>String</span></span>] <span>-&gt;</span> <span><span>Bool</span></span>
isInList <span>[]</span> <span>=</span> <span><span>False</span></span>
isInList (x <span>:</span> xs) <span>=</span> x <span>`elem`</span> xs
ngxExportBLS &#39;isInList</pre></div>
<p dir="auto">In this module, we declared three synchronous handlers: <em>toUpper</em>, <em>reverse</em>,
and <em>isInList</em>. Handler <em>reverse</em> exports existing and well-known Haskell
function <em>reverse</em> which reverses lists. Let&#39;s compile <em>test.hs</em> and move the
library to a directory, from where we will load this.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ ghc -O2 -dynamic -shared -fPIC -flink-rts test.hs -o test.so
[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )
Linking test.so ...
$ sudo cp test.so /var/lib/nginx/"><pre>$ <span>ghc -O2 -dynamic -shared -fPIC -flink-rts test.hs -o test.so</span>
<span>[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )</span>
<span>Linking test.so ...</span>
$ <span>sudo cp test.so /var/lib/nginx/</span></pre></div>
<p dir="auto">Note that in <em>ghc</em> older than <em>8.10.6</em>, option <em>-flink-rts</em> must be replaced
with option <em>-lHSrts-ghc$(ghc âânumeric-version)</em>.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf" aria-hidden="true" href="#file-testconf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf</h4>
<div dir="auto" data-snippet-clipboard-copy-content="user                    nginx;
worker_processes        4;

events {
    worker_connections  1024;
}

http {
    default_type        application/octet-stream;
    sendfile            on;

    haskell load /var/lib/nginx/test.so;

    server {
        listen          8010;
        server_name     main;

        location / {
            haskell_run toUpper $hs_upper $arg_u;
            haskell_run reverse $hs_reverse $arg_r;
            haskell_run isInList $hs_isInList $arg_a $arg_b $arg_c $arg_d;
            echo &#34;toUpper $arg_u = $hs_upper&#34;;
            echo &#34;reverse $arg_r = $hs_reverse&#34;;
            echo &#34;$arg_a `isInList` [$arg_b, $arg_c, $arg_d] = $hs_isInList&#34;;
        }
    }
}"><pre><span>user</span>                    nginx;
<span>worker_processes</span>        <span>4</span>;

<span>events</span> {
    <span>worker_connections</span>  <span>1024</span>;
}

<span>http</span> {
    <span>default_type</span>        application/octet-stream;
    <span>sendfile</span>           <span> on</span>;

    <span>haskell</span> load /var/lib/nginx/test.so;

    <span>server</span> {
        <span>listen</span>          <span>8010</span>;
        <span>server_name</span>    <span> main</span>;

        <span>location</span> <span>/ </span>{
            <span>haskell_run</span> toUpper <span>$hs_upper</span> <span>$arg_u</span>;
            <span>haskell_run</span> reverse <span>$hs_reverse</span> <span>$arg_r</span>;
            <span>haskell_run</span> isInList <span>$hs_isInList</span> <span>$arg_a</span> <span>$arg_b</span> <span>$arg_c</span> <span>$arg_d</span>;
            <span>echo</span> <span>&#34;toUpper <span>$arg_u</span> = <span>$hs_upper</span>&#34;</span>;
            <span>echo</span> <span>&#34;reverse <span>$arg_r</span> = <span>$hs_reverse</span>&#34;</span>;
            <span>echo</span> <span>&#34;<span>$arg_a</span> `isInList` [<span>$arg_b</span>, <span>$arg_c</span>, <span>$arg_d</span>] = <span>$hs_isInList</span>&#34;</span>;
        }
    }
}</pre></div>
<p dir="auto">Library <em>test.so</em> gets loaded by Nginx directive <em>haskell load</em>. All synchronous
handlers run from directive <em>haskell_run</em>. The first argument of the directive
is a name of a Haskell handler exported from the loaded library <em>test.so</em>, the
second argument is an Nginx variable where the handler will put the result of
its computation, the rest arguments are passed to the Haskell handler as
parameters. Directive <em>haskell_run</em> has <em>lazy</em> semantics in the sense that it
runs its handler only when the result is needed in a content handler or rewrite
directives.</p>
<p dir="auto">Let&#39;s test the configuration with <em>curl</em>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/?u=hello&amp;r=world&amp;a=1&amp;b=10&amp;c=1&#39;
toUpper hello = HELLO
reverse world = dlrow
1 `isInList` [10, 1, ] = 1"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/?u=hello&amp;r=world&amp;a=1&amp;b=10&amp;c=1<span>&#39;</span></span></span>
<span>toUpper hello = HELLO</span>
<span>reverse world = dlrow</span>
<span>1 `isInList` [10, 1, ] = 1</span></pre></div>

<p dir="auto">There are three types of exporters for synchronous content handlers.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Exporter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteString -&gt; ContentHandlerResult</code></td>
<td><code>ngxExportHandler</code> (<code>NGX_EXPORT_HANDLER</code>)</td>
</tr>
<tr>
<td><code>ByteString -&gt; L.ByteString</code></td>
<td><code>ngxExportDefHandler</code> (<code>NGX_EXPORT_DEF_HANDLER</code>)</td>
</tr>
<tr>
<td><code>ByteString -&gt; UnsafeContentHandlerResult</code></td>
<td><code>ngxExportUnsafeHandler</code> (<code>NGX_EXPORT_UNSAFE_HANDLER</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">Types <em>ContentHandlerResult</em> and <em>UnsafeContentHandlerResult</em> are declared as
type synonyms in module <em>NgxExport</em>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="type ContentHandlerResult = (L.ByteString, ByteString, Int, HTTPHeaders)
type UnsafeContentHandlerResult = (ByteString, ByteString, Int)
type HTTPHeaders = [(ByteString, ByteString)]"><pre><span>type</span> <span>ContentHandlerResult</span> <span>=</span> (<span><span>L.</span>ByteString</span>, <span>ByteString</span>, <span><span>Int</span></span>, <span>HTTPHeaders</span>)
<span>type</span> <span>UnsafeContentHandlerResult</span> <span>=</span> (<span>ByteString</span>, <span>ByteString</span>, <span><span>Int</span></span>)
<span>type</span> <span>HTTPHeaders</span> <span>=</span> [(<span>ByteString</span>, <span>ByteString</span>)]</pre></div>
<p dir="auto">All content handlers are <em>pure</em> Haskell functions, as well as the most of other
synchronous handlers. The <em>normal</em> content handler returns a <em>4-tuple</em>
<em>(response-body, content-type, HTTP-status, response-headers)</em>. The response
body consists of a number of chunks packed in a <em>lazy bytestring</em>, the content
type is a <em>strict bytestring</em> such as <em>text/html</em>. The <em>default</em> handler
defaults the content type to <em>text/plain</em> and the HTTP status to <em>200</em>, thus
returning only chunks of the response body. The <em>unsafe</em> handler returns a
<em>3-tuple</em> with a single-chunked response body, the content type and the status,
but the both bytestring parameters are supposed to be taken from static data,
which must not be cleaned up after request termination.</p>
<p dir="auto"><em>Normal</em> and <em>default</em> content handlers can be declared with two directives:
<em>haskell_content</em> and <em>haskell_static_content</em>. The second directive runs its
handler only once, when the first request comes, and returns the same response
on further requests. The <em>unsafe</em> handler is declared with directive
<em>haskell_unsafe_content</em>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-an-example" aria-hidden="true" href="#an-example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h2>
<p dir="auto">Let&#39;s replace Nginx directive <em>echo</em> with our own default content handler
<em>echo</em>. Add in <em>test.hs</em>,</p>
<div dir="auto" data-snippet-clipboard-copy-content="import           Data.ByteString (ByteString)
import qualified Data.ByteString.Lazy as L

-- ...

echo :: ByteString -&gt; L.ByteString
echo = L.fromStrict
ngxExportDefHandler &#39;echo"><pre><span>import</span>           <span>Data.ByteString</span> (<span>ByteString</span>)
<span>import</span> <span>qualified</span> <span>Data.ByteString.Lazy</span> <span>as</span> <span>L</span>

<span><span>--</span> ...</span>

<span>echo</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>L.</span>ByteString</span>
echo <span>=</span> <span>L.</span>fromStrict
ngxExportDefHandler &#39;echo</pre></div>
<p dir="auto">compile it and put <em>test.so</em> into <em>/var/lib/nginx/</em>. Add new location <em>/ch</em> into
<em>test.conf</em>,</p>
<div dir="auto" data-snippet-clipboard-copy-content="        location /ch {
            haskell_run toUpper $hs_upper $arg_u;
            haskell_run reverse $hs_reverse $arg_r;
            haskell_run isInList $hs_isInList $arg_a $arg_b $arg_c $arg_d;
            haskell_content echo
&#34;toUpper $arg_u = $hs_upper
reverse $arg_r = $hs_reverse
$arg_a `isInList` [$arg_b, $arg_c, $arg_d] = $hs_isInList
&#34;;
        }"><pre>        <span>location</span> <span>/ch </span>{
            <span>haskell_run</span> toUpper <span>$hs_upper</span> <span>$arg_u</span>;
            <span>haskell_run</span> reverse <span>$hs_reverse</span> <span>$arg_r</span>;
            <span>haskell_run</span> isInList <span>$hs_isInList</span> <span>$arg_a</span> <span>$arg_b</span> <span>$arg_c</span> <span>$arg_d</span>;
            <span>haskell_content</span> echo
&#34;<span>toUpper</span> <span>$arg_u</span> = <span>$hs_upper</span>
<span>reverse</span> <span>$arg_r</span> = <span>$hs_reverse</span>
$<span>arg_a</span> `isInList` [<span>$arg_b</span>, <span>$arg_c</span>, <span>$arg_d</span>] = <span>$hs_isInList</span>
&#34;;
        }</pre></div>
<p dir="auto">and test again.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/ch?u=content&amp;r=handler&amp;a=needle&amp;b=needle&amp;c=in&amp;d=stack&#39;
toUpper content = CONTENT
reverse handler = reldnah
needle `isInList` [needle, in, stack] = 1"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/ch?u=content&amp;r=handler&amp;a=needle&amp;b=needle&amp;c=in&amp;d=stack<span>&#39;</span></span></span>
<span>toUpper content = CONTENT</span>
<span>reverse handler = reldnah</span>
<span>needle `isInList` [needle, in, stack] = 1</span></pre></div>

<p dir="auto">There are two types of Haskell handlers for per-request asynchronous tasks: an
asynchronous handler and an asynchronous request body handler.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Exporter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteString -&gt; IO L.ByteString</code></td>
<td><code>ngxExportAsyncIOYY</code> (<code>NGX_EXPORT_ASYNC_IOY_Y</code>)</td>
</tr>
<tr>
<td><code>L.ByteString -&gt; ByteString -&gt; IO L.ByteString</code></td>
<td><code>ngxExportAsyncOnReqBody</code> (<code>NGX_EXPORT_ASYNC_ON_REQ_BODY</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">Normal asynchronous handler accepts a strict bytestring and returns a lazy
bytestring. Its type exactly corresponds to that of the handlers exported with
<em>ngxExportIOYY</em>. Request body handler additionally accepts request body chunks
in its first parameter.</p>
<p dir="auto">Unlike synchronous handlers, asynchronous per-request handlers are <em>eager</em>. This
means that they will always run when declared in a location, no matter whether
their results are going to be used in the response and rewrite directives, or
not. The asynchronous handlers run in an early <em>rewrite phase</em> (before rewrite
directives), and in a late rewrite phase (after rewrite directives, if in the
final location there are more asynchronous tasks declared). It is possible to
declare many asynchronous tasks in a single location: in this case they are
spawned one by one in order of their declarations, which lets using results of
early tasks in inputs of later tasks. This ordering rule extends naturally
beyond hierarchical levels: tasks declared in <em>server</em> clause run before tasks
from <em>location</em> clauses, while tasks from <em>location-if</em> clauses run latest.</p>
<p dir="auto">Asynchronous tasks are bound to the Nginx event loop by means of <em>eventfd</em> (or
POSIX <em>pipes</em> if eventfd was not available on the platform when Nginx was being
compiled). When the rewrite phase handler of this module spawns an asynchronous
task, it opens an eventfd, then registers it in the event loop, and passes it to
the Haskell handler. As soon as the Haskell handler finishes the task and pokes
the result into buffers, it writes into the eventfd, thus informing the Nginx
part that the task has finished. Then Nginx gets back to the module&#39;s rewrite
phase handler, and it spawns the next asynchronous task, or returns (when there
are no more tasks left), moving request processing to the next stage.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-an-example-1" aria-hidden="true" href="#an-example-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h2>
<p dir="auto">Let&#39;s add two asynchronous handlers into <em>test.hs</em>: one for extracting a field
from POST data, and the other for delaying response for a given number of
seconds.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions" aria-hidden="true" href="#file-tesths-additions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="import qualified Data.ByteString.Char8 as C8
import qualified Data.ByteString.Lazy.Char8 as C8L
import           Control.Concurrent
import           Safe

-- ...

reqFld :: L.ByteString -&gt; ByteString -&gt; IO L.ByteString
reqFld a fld = return $ maybe C8L.empty C8L.tail $
    lookup (C8L.fromStrict fld) $ map (C8L.break (== &#39;=&#39;)) $ C8L.split &#39;&amp;&#39; a
ngxExportAsyncOnReqBody &#39;reqFld

delay :: ByteString -&gt; IO L.ByteString
delay v = do
    let t = readDef 0 $ C8.unpack v
    threadDelay $ t * 1000000
    return $ C8L.pack $ show t
ngxExportAsyncIOYY &#39;delay"><pre><span>import</span> <span>qualified</span> <span>Data.ByteString.Char8</span> <span>as</span> <span>C8</span>
<span>import</span> <span>qualified</span> <span>Data.ByteString.Lazy.Char8</span> <span>as</span> <span>C8L</span>
<span>import</span>           <span>Control.Concurrent</span>
<span>import</span>           <span>Safe</span>

<span><span>--</span> ...</span>

<span>reqFld</span> <span>::</span> <span><span>L.</span>ByteString</span> <span>-&gt;</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
reqFld a fld <span>=</span> <span>return</span> <span>$</span> <span>maybe</span> <span>C8L.</span>empty <span>C8L.</span><span>tail</span> <span>$</span>
    <span>lookup</span> (<span>C8L.</span>fromStrict fld) <span>$</span> <span>map</span> (<span>C8L.</span><span>break</span> (<span>==</span> <span><span>&#39;</span>=<span>&#39;</span></span>)) <span>$</span> <span>C8L.</span>split <span><span>&#39;</span>&amp;<span>&#39;</span></span> a
ngxExportAsyncOnReqBody &#39;reqFld

<span>delay</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
delay v <span>=</span> <span>do</span>
    <span>let</span> t <span>=</span> readDef <span>0</span> <span>$</span> <span>C8.</span>unpack v
    threadDelay <span>$</span> t <span>*</span> <span>1000000</span>
    <span>return</span> <span>$</span> <span>C8L.</span>pack <span>$</span> <span>show</span> t
ngxExportAsyncIOYY &#39;delay</pre></div>
<p dir="auto">This code must be linked with <em>threaded</em> Haskell RTS this time!</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ ghc -O2 -dynamic -shared -fPIC -flink-rts -threaded test.hs -o test.so
[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )
Linking test.so ...
$ sudo cp test.so /var/lib/nginx/"><pre>$ <span>ghc -O2 -dynamic -shared -fPIC -flink-rts -threaded test.hs -o test.so</span>
<span>[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )</span>
<span>Linking test.so ...</span>
$ <span>sudo cp test.so /var/lib/nginx/</span></pre></div>
<p dir="auto">Note that in <em>ghc</em> older than <em>8.10.6</em>, options <em>-flink-rts -threaded</em> must be
replaced with option <em>-lHSrts_thr-ghc$(ghc âânumeric-version)</em>.</p>
<p dir="auto">Let&#39;s make location <em>/timer</em>, where we will read how many seconds to wait in
POST field <em>timer</em>, and then wait them until returning the response.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions" aria-hidden="true" href="#file-testconf-additions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="        location /timer {
            haskell_run_async_on_request_body reqFld $hs_timeout timer;
            haskell_run_async delay $hs_waited $hs_timeout;
            echo &#34;Waited $hs_waited sec&#34;;
        }"><pre>        <span>location</span> <span>/timer </span>{
            <span>haskell_run_async_on_request_body</span> reqFld <span>$hs_timeout</span> timer;
            <span>haskell_run_async</span> delay <span>$hs_waited</span> <span>$hs_timeout</span>;
            <span>echo</span> <span>&#34;Waited <span>$hs_waited</span> sec&#34;</span>;
        }</pre></div>
<p dir="auto">Run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl -d &#39;timer=3&#39; &#39;http://127.0.0.1:8010/timer&#39;
Waited 3 sec
$ curl -d &#39;timer=bad&#39; &#39;http://127.0.0.1:8010/timer&#39;
Waited 0 sec"><pre>$ <span>curl -d <span><span>&#39;</span>timer=3<span>&#39;</span></span> <span><span>&#39;</span>http://127.0.0.1:8010/timer<span>&#39;</span></span></span>
<span>Waited 3 sec</span>
$ <span>curl -d <span><span>&#39;</span>timer=bad<span>&#39;</span></span> <span><span>&#39;</span>http://127.0.0.1:8010/timer<span>&#39;</span></span></span>
<span>Waited 0 sec</span></pre></div>

<p dir="auto">There are two types of <em>impure</em> content handlers that allow for effectful code.
One of them corresponds to that of the <em>normal</em> content handler, except the
result is wrapped in <em>IO Monad</em>. The other accepts request body chunks in its
first argument like the handler exported with <em>ngxExportAsyncOnReqBody</em>.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Exporter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteString -&gt; IO ContentHandlerResult</code></td>
<td><code>ngxExportAsyncHandler</code> (<code>NGX_EXPORT_ASYNC_HANDLER</code>)</td>
</tr>
<tr>
<td><code>L.ByteString -&gt; ByteString -&gt; IO ContentHandlerResult</code></td>
<td><code>ngxExportAsyncHandlerOnReqBody</code> (<code>NGX_EXPORT_ASYNC_HANDLER_ON_REQ_BODY</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">The first handler is declared with directive <em>haskell_async_content</em>, the
handler that accepts request body chunks is declared with directive
<em>haskell_async_content_on_request_body</em>.</p>
<p dir="auto">It&#39;s easy to emulate effects in a synchronous content handler by combining the
latter with an asynchronous task like in the following example.</p>
<div dir="auto" data-snippet-clipboard-copy-content="        location /async_content {
            haskell_run_async getUrl $hs_async_httpbin &#34;http://httpbin.org&#34;;
            haskell_content echo $hs_async_httpbin;
        }"><pre>        <span>location</span> <span>/async_content </span>{
            <span>haskell_run_async</span> getUrl <span>$hs_async_httpbin</span> <span>&#34;http://httpbin.org&#34;</span>;
            <span>haskell_content</span> echo <span>$hs_async_httpbin</span>;
        }</pre></div>
<p dir="auto">Here <em>getUrl</em> is an asynchronous Haskell handler that returns content of an HTTP
page. This approach has at least two deficiencies related to performance and
memory usage. The content may be huge and chunked, and its chunks could be
naturally reused in the content handler. But they won&#39;t, because here they get
collected by directive <em>haskell_run_async</em> into a single chunk, and then passed
to the content handler <em>echo</em>. The other problem deals with <em>eagerness</em> of
asynchronous tasks. Imagine that we put in the location a rewrite to another
location: handler <em>getUrl</em> will run before redirection, but variable
<em>hs_async_httpbin</em> will never be used because we&#39;ll get out from the current
location.</p>
<p dir="auto">The task starts from the content handler asynchronously, and the lazy
bytestring â the contents â gets used in the task as is, with all
of its originally computed chunks.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-examples-including-online-image-converter" aria-hidden="true" href="#examples-including-online-image-converter"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples (including online image converter)</h2>
<p dir="auto">Let&#39;s rewrite our <em>timer</em> example using <em>haskell_async_content</em>.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-1" aria-hidden="true" href="#file-tesths-additions-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="{-# LANGUAGE TupleSections #-}
{-# LANGUAGE MagicHash #-}

-- ...

import           GHC.Prim
import           Data.ByteString.Unsafe
import           Data.ByteString.Internal (accursedUnutterablePerformIO)

-- ...

packLiteral :: Int -&gt; GHC.Prim.Addr# -&gt; ByteString
packLiteral l s = accursedUnutterablePerformIO $ unsafePackAddressLen l s

delayContent :: ByteString -&gt; IO ContentHandlerResult
delayContent v = do
    v&#39; &lt;- delay v
    return $ (, packLiteral 10 &#34;text/plain&#34;#, 200, []) $
        L.concat [&#34;Waited &#34;, v&#39;, &#34; sec\n&#34;]
ngxExportAsyncHandler &#39;delayContent"><pre>{-# <span>LANGUAGE</span> TupleSections #-}
{-# <span>LANGUAGE</span> MagicHash #-}

<span><span>--</span> ...</span>

<span>import</span>           <span>GHC.Prim</span>
<span>import</span>           <span>Data.ByteString.Unsafe</span>
<span>import</span>           <span>Data.ByteString.Internal</span> (<span>accursedUnutterablePerformIO</span>)

<span><span>--</span> ...</span>

<span>packLiteral</span> <span>::</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>GHC.Prim.</span>Addr</span><span>#</span> <span>-&gt;</span> <span>ByteString</span>
packLiteral l s <span>=</span> accursedUnutterablePerformIO <span>$</span> unsafePackAddressLen l s

<span>delayContent</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span>ContentHandlerResult</span>
delayContent v <span>=</span> <span>do</span>
    v&#39; <span>&lt;-</span> delay v
    <span>return</span> <span>$</span> (, packLiteral <span>10</span> <span><span>&#34;</span>text/plain<span>&#34;</span></span><span>#</span>, <span>200</span>, <span>[]</span>) <span>$</span>
        <span>L.</span><span>concat</span> [<span><span>&#34;</span>Waited <span>&#34;</span></span>, v&#39;, <span><span>&#34;</span> sec<span>\n</span><span>&#34;</span></span>]
ngxExportAsyncHandler &#39;delayContent</pre></div>
<p dir="auto">For the <em>content type</em> we used a static string <em>&#34;text/plain&#34;#</em> that ends with a
<em>magic hash</em> merely to avoid any dynamic memory allocations.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-1" aria-hidden="true" href="#file-testconf-additions-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="        location /timer/ch {
            haskell_run_async_on_request_body reqFld $hs_timeout timer;
            haskell_async_content delayContent $hs_timeout;
        }"><pre>        <span>location</span> <span>/timer/ch </span>{
            <span>haskell_run_async_on_request_body</span> reqFld <span>$hs_timeout</span> timer;
            <span>haskell_async_content</span> delayContent <span>$hs_timeout</span>;
        }</pre></div>
<p dir="auto">Run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl -d &#39;timer=3&#39; &#39;http://127.0.0.1:8010/timer/ch&#39;
Waited 3 sec
$ curl &#39;http://127.0.0.1:8010/timer/ch&#39;
Waited 0 sec"><pre>$ <span>curl -d <span><span>&#39;</span>timer=3<span>&#39;</span></span> <span><span>&#39;</span>http://127.0.0.1:8010/timer/ch<span>&#39;</span></span></span>
<span>Waited 3 sec</span>
$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/timer/ch<span>&#39;</span></span></span>
<span>Waited 0 sec</span></pre></div>
<p dir="auto">In the next example we will create an <em>online image converter</em> to convert images
of various formats into PNG using Haskell library <em>JuicyPixels</em>.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-2" aria-hidden="true" href="#file-tesths-additions-2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="import           Codec.Picture

-- ...

convertToPng :: L.ByteString -&gt; ByteString -&gt; IO ContentHandlerResult
convertToPng t = const $ return $
    case decodeImage $ L.toStrict t of
        Left e -&gt; (C8L.pack e, packLiteral 10 &#34;text/plain&#34;#, 500, [])
        Right image -&gt; case encodeDynamicPng image of
                Left e -&gt; (C8L.pack e, packLiteral 10 &#34;text/plain&#34;#, 500, [])
                Right png -&gt; (png, packLiteral 9 &#34;image/png&#34;#, 200, [])
ngxExportAsyncHandlerOnReqBody &#39;convertToPng"><pre><span>import</span>           <span>Codec.Picture</span>

<span><span>--</span> ...</span>

<span>convertToPng</span> <span>::</span> <span><span>L.</span>ByteString</span> <span>-&gt;</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span>ContentHandlerResult</span>
convertToPng t <span>=</span> <span>const</span> <span>$</span> <span>return</span> <span>$</span>
    <span>case</span> decodeImage <span>$</span> <span>L.</span>toStrict t <span>of</span>
        <span><span>Left</span></span> e <span>-&gt;</span> (<span>C8L.</span>pack e, packLiteral <span>10</span> <span><span>&#34;</span>text/plain<span>&#34;</span></span><span>#</span>, <span>500</span>, <span>[]</span>)
        <span><span>Right</span></span> image <span>-&gt;</span> <span>case</span> encodeDynamicPng image <span>of</span>
                <span><span>Left</span></span> e <span>-&gt;</span> (<span>C8L.</span>pack e, packLiteral <span>10</span> <span><span>&#34;</span>text/plain<span>&#34;</span></span><span>#</span>, <span>500</span>, <span>[]</span>)
                <span><span>Right</span></span> png <span>-&gt;</span> (png, packLiteral <span>9</span> <span><span>&#34;</span>image/png<span>&#34;</span></span><span>#</span>, <span>200</span>, <span>[]</span>)
ngxExportAsyncHandlerOnReqBody &#39;convertToPng</pre></div>
<p dir="auto">We are going to run instances of <em>convertToPng</em> on multiple CPU cores, and
therefore it&#39;s better now to compile this with option <em>-feager-blackholing</em>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ ghc -O2 -feager-blackholing -dynamic -shared -fPIC -flink-rts -threaded test.hs -o test.so
[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )
Linking test.so ...
$ sudo cp test.so /var/lib/nginx/"><pre>$ <span>ghc -O2 -feager-blackholing -dynamic -shared -fPIC -flink-rts -threaded test.hs -o test.so</span>
<span>[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )</span>
<span>Linking test.so ...</span>
$ <span>sudo cp test.so /var/lib/nginx/</span></pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-2" aria-hidden="true" href="#file-testconf-additions-2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell rts_options -N4 -A32m -qg;

    limit_conn_zone all zone=all:10m;

    # ...

        location /convert/topng {
            limit_conn all 4;
            client_max_body_size 20m;
            haskell_request_body_read_temp_file on;
            haskell_async_content_on_request_body convertToPng;
        }"><pre>    <span>haskell</span> rts_options -N4 -A32m -qg;

    <span>limit_conn_zone</span><span> all</span> zone=all:10m;

    <span># ...</span>

        <span>location</span> <span>/convert/topng </span>{
            <span>limit_conn</span><span> all</span> <span>4</span>;
            <span>client_max_body_size</span> <span>20m</span>;
            <span>haskell_request_body_read_temp_file</span> on;
            <span>haskell_async_content_on_request_body</span> convertToPng;
        }</pre></div>
<p dir="auto">Directive <em>haskell rts_options</em> declares that we are going to use 4 CPU cores
(<em>-N4</em>) for image conversion tasks: this is a good choice on a quad-core
processor when high CPU utilization is expected. For dealing with huge images,
we also increased Haskell GC allocation area up to <em>32Mb</em> (<em>-A32m</em>) to possibly
minimize frequency of GC calls. We also forcibly switched to sequential GC
(<em>-qg</em>), which is quite appropriate in our intrinsically single-threaded handler
<em>convertToPng</em>. Directives <em>limit_conn_zone</em> and <em>limit_conn</em> must effectively
limit number of simultaneously processed client requests to the number of CPU
cores (<em>4</em>) in order to protect the CPU from overloading.</p>
<p dir="auto">In location <em>/convert/topng</em>, directive <em>client_max_body_size</em> declares that all
requests whose bodies exceed <em>20Mb</em> will be rejected. Directive
<em>haskell_request_body_read_temp_file on</em> makes the Haskell part able to read
huge request bodies that have been buffered in a temporary file by Nginx.
Notice that we do not pass any value into directive
<em>haskell_async_content_on_request_body</em>, therefore its second argument is simply
omitted.</p>
<p dir="auto">For running tests, an original file, say <em>sample.tif</em>, must be prepared. We will
pipe command <em>display</em> from <em>ImageMagick</em> to the output of curl for more fun.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl --data-binary @sample.tif &#39;http://127.0.0.1:8010/convert/topng&#39; | display"><pre>$ <span>curl --data-binary @sample.tif <span><span>&#39;</span>http://127.0.0.1:8010/convert/topng<span>&#39;</span></span> <span>|</span> display</span></pre></div>

<p dir="auto">Asynchronous tasks run in a request context, whereas asynchronous services run
in a worker context. They start when the module gets initialized in a worker,
and stop when a worker terminates. They are useful for gathering rarely changed
data shared in many requests.</p>
<p dir="auto">There is only one type of asynchronous services exporters.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Exporter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteString -&gt; Bool -&gt; IO L.ByteString</code></td>
<td><code>ngxExportServiceIOYY</code> (<code>NGX_EXPORT_SERVICE_IOY_Y</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">It accepts a strict bytestring and a boolean value, and returns a lazy
bytestring (chunks of data). If the boolean argument is <em>True</em> then this service
has never been called before in this worker process: this can be used to
initialize some global data needed by the service on the first call.</p>
<p dir="auto">Services are declared with Nginx directive <em>haskell_run_service</em>. As far as they
are not bound to requests, the directive is only available on the <em>http</em>
configuration level.</p>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_run_service getUrlService $hs_service_httpbin &#34;http://httpbin.org&#34;;"><pre>    <span>haskell_run_service</span> getUrlService <span>$hs_service_httpbin</span> <span>&#34;http://httpbin.org&#34;</span>;</pre></div>
<p dir="auto">The first argument is, as ever, the name of a Haskell handler, the second
â a variable where the service result will be put, and the third argument
is data passed to the handler <em>getUrlService</em> in its first parameter. Notice
that the third argument cannot contain variables because variable handlers in
Nginx are only available in a request context, hence this argument may only be
a static string.</p>
<p dir="auto">Asynchronous services are bound to the Nginx event loop in the same way as
asynchronous tasks. When a service finishes its computation, it pokes data into
buffers and writes into eventfd (or a pipe&#39;s write end). Then the event handler
immediately restarts the service with the boolean argument equal to <em>False</em>.
This is responsibility of the author of a service handler to avoid dry runs and
make sure that it is called not so often in a row. For example, if a service
polls periodically, then it must delay for this time itself like in the
following example.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-an-example-2" aria-hidden="true" href="#an-example-2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h2>
<p dir="auto">Let&#39;s retrieve content of a specific URL, say <em>httpbin.org</em>, in background. Data
will update every 20 seconds.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-3" aria-hidden="true" href="#file-tesths-additions-3"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="import           Network.HTTP.Client
import           Control.Exception
import           System.IO.Unsafe
import           Control.Monad

-- ...

httpManager :: Manager
httpManager = unsafePerformIO $ newManager defaultManagerSettings
{-# NOINLINE httpManager #-}

getUrl :: ByteString -&gt; IO C8L.ByteString
getUrl url = catchHttpException $ getResponse url $ flip httpLbs httpManager
    where getResponse u = fmap responseBody . (parseRequest (C8.unpack u) &gt;&gt;=)

catchHttpException :: IO C8L.ByteString -&gt; IO C8L.ByteString
catchHttpException = (`catch` \e -&gt;
        return $ C8L.pack $ &#34;HTTP EXCEPTION: &#34; ++ show (e :: HttpException))

getUrlService :: ByteString -&gt; Bool -&gt; IO L.ByteString
getUrlService url firstRun = do
    unless firstRun $ threadDelay $ 20 * 1000000
    getUrl url
ngxExportServiceIOYY &#39;getUrlService"><pre><span>import</span>           <span>Network.HTTP.Client</span>
<span>import</span>           <span>Control.Exception</span>
<span>import</span>           <span>System.IO.Unsafe</span>
<span>import</span>           <span>Control.Monad</span>

<span><span>--</span> ...</span>

<span>httpManager</span> <span>::</span> <span>Manager</span>
httpManager <span>=</span> unsafePerformIO <span>$</span> newManager defaultManagerSettings
{-# <span>NOINLINE</span> httpManager #-}

<span>getUrl</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>C8L.</span>ByteString</span>
getUrl url <span>=</span> catchHttpException <span>$</span> getResponse url <span>$</span> <span>flip</span> httpLbs httpManager
    <span>where</span> getResponse u <span>=</span> <span>fmap</span> responseBody <span>.</span> (parseRequest (<span>C8.</span>unpack u) <span>&gt;&gt;=</span>)

<span>catchHttpException</span> <span>::</span> <span><span>IO</span></span> <span><span>C8L.</span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>C8L.</span>ByteString</span>
catchHttpException <span>=</span> (<span>`catch`</span> <span>\</span>e <span>-&gt;</span>
        <span>return</span> <span>$</span> <span>C8L.</span>pack <span>$</span> <span><span>&#34;</span>HTTP EXCEPTION: <span>&#34;</span></span> <span>++</span> <span>show</span> (e <span>::</span> <span>HttpException</span>))

<span>getUrlService</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>Bool</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
getUrlService url firstRun <span>=</span> <span>do</span>
    unless firstRun <span>$</span> threadDelay <span>$</span> <span>20</span> <span>*</span> <span>1000000</span>
    getUrl url
ngxExportServiceIOYY &#39;getUrlService</pre></div>
<p dir="auto">The <em>httpManager</em> defines a global state, not to say a <em>variable</em>: this is an
asynchronous HTTP client implemented in module <em>Network.HTTP.Client</em>. Pragma
<em>NOINLINE</em> ensures that all functions will refer to the same client object, i.e.
it will nowhere be inlined. Functions <em>getUrl</em> and <em>catchHttpException</em> are used
in our service handler <em>getUrlService</em>. The handler waits 20 seconds on every
run except the first, and then runs the HTTP client. All HTTP exceptions are
caught by <em>catchHttpException</em>, others hit the handler on top of the custom
Haskell code and get logged by Nginx.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-3" aria-hidden="true" href="#file-testconf-additions-3"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_run_service getUrlService $hs_service_httpbin &#34;http://httpbin.org&#34;;

    # ...

        location /httpbin {
            echo $hs_service_httpbin;
        }"><pre>    <span>haskell_run_service</span> getUrlService <span>$hs_service_httpbin</span> <span>&#34;http://httpbin.org&#34;</span>;

    <span># ...</span>

        <span>location</span> <span>/httpbin </span>{
            <span>echo</span> <span>$hs_service_httpbin</span>;
        }</pre></div>
<p dir="auto">Run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin&#39;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&#39;content-type&#39; value=&#39;text/html;charset=utf8&#39;&gt;
  &lt;meta name=&#39;generator&#39; value=&#39;Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)&#39;&gt;
  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;

..."><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin<span>&#39;</span></span></span>
<span>&lt;!DOCTYPE html&gt;</span>
<span>&lt;html&gt;</span>
<span>&lt;head&gt;</span>
<span>  &lt;meta http-equiv=&#39;content-type&#39; value=&#39;text/html;charset=utf8&#39;&gt;</span>
<span>  &lt;meta name=&#39;generator&#39; value=&#39;Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)&#39;&gt;</span>
<span>  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;</span>

<span>...</span></pre></div>
<p dir="auto">This must run really fast because it shows data that has already been retrieved
by the service, requests do not trigger any network activity with <em>httpbin.org</em>
by themselves!</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-termination-of-a-service" aria-hidden="true" href="#termination-of-a-service"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Termination of a service</h2>
<p dir="auto">Services are killed on a worker&#39;s exit with an asynchronous exception
<em>WorkerProcessIsExiting</em>. Then the worker waits <em>synchronously</em> until all of its
services&#39; threads exit, and calls <em>hs_exit()</em>. This scenario has two important
implications.</p>
<ol dir="auto">
<li>The Haskell service handler may catch <em>WorkerProcessIsExiting</em> on exit and
make persistency actions such as writing files if they are needed.</li>
<li><em>Unsafe</em> <em>blocking</em> FFI calls must be avoided in service handlers as they may
hang the Nginx worker, and it won&#39;t exit. Using <em>interruptible</em> FFI fixes
this problem.</li>
</ol>

<p dir="auto">An asynchronous service may store its result in shared memory accessible from
all worker processes. This is achieved with directive
<em>haskell_service_var_in_shm</em>. For example, the following declaration (in <em>http</em>
clause),</p>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_service_var_in_shm httpbin 512k /tmp $hs_service_httpbin;"><pre>    <span>haskell_service_var_in_shm</span> httpbin <span>512k</span> /tmp <span>$hs_service_httpbin</span>;</pre></div>
<p dir="auto">makes service <em>getUrlService</em>, that stores its result in variable
<em>hs_service_httpbin</em>, shared. The first argument of the directive â
<em>httpbin</em> â is an identifier of a shared memory segment, <em>512k</em> is its
maximum size, <em>/tmp</em> is a directory where <em>file locks</em> will be put (see below),
and <em>$hs_service_httpbin</em> is the service variable.</p>
<p dir="auto">Shared services are called <em>shared</em> not only because they store results in
shared memory, but also because at any moment of the Nginx master lifetime there
is only one worker that runs a specific service. When workers start, they race
to acquire a <em>file lock</em> for a service, and if a worker wins the race, it holds
the lock until it exits or dies. Other workers&#39; services of the same type wait
until the lock is freed. The locks are implemented via POSIX <em>advisory</em> file
locks, and so require a directory where they will be put. The directory must be
<em>writable</em> to worker processes, and <em>/tmp</em> seems to be a good choice in general.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-update-variables" aria-hidden="true" href="#update-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Update variables</h2>
<p dir="auto">The active shared service puts the value of the shared variable in a shared
memory, services on other workers wait and do nothing else. Requests may come to
any worker (with active or inactive services), fortunately the service result is
shared and they can return it as is. But what if the result must be somehow
interpreted by Haskell handlers before returning it in the response? Could the
handlers just peek into the shared memory and do what they want with the shared
data? Unfortunately, not: the shared memory is accessible for reading and
writing only from the Nginx part!</p>
<p dir="auto">Does it mean that we have only one option to let the Haskell part update its
global state unavailable in inactive workers: passing values of shared variables
into the Haskell part on every request? This would be extremely inefficient.
Update variables is a trick to avoid this. They evaluate to the corresponding
service variable&#39;s value only when it changes in the shared memory since the
last check in the current worker, and to an empty string otherwise. Every
service variable has its own update variable counterpart whose name is built
from the service variable&#39;s name prefixed by <em>_upd__</em>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-an-example-3" aria-hidden="true" href="#an-example-3"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h3>
<p dir="auto">Let&#39;s extend our example with loading a page in background. We are still going
to load <em>httpbin.org</em>, but this time let&#39;s assume that we have another task, say
extracting all links from the page and showing them in the response sorted. For
that we could add a Haskell handler, say <em>sortLinks</em>, and pass to it all the
page content on every request. But the page may appear huge, let&#39;s extract all
the links from it and put them into a global state using update variable
<em>_upd__hs_service_httpbin</em>. In this case, function <em>sortLinks</em> must be
impure, as it must be able to read from the global state.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-4" aria-hidden="true" href="#file-tesths-additions-4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="{-# LANGUAGE OverloadedStrings #-}

-- ...

import           Data.IORef
import           Text.Regex.PCRE.ByteString
import           Text.Regex.Base.RegexLike
import qualified Data.Array as A
import           Data.List
import qualified Data.ByteString as B

-- ...

gHttpbinLinks :: IORef [ByteString]
gHttpbinLinks = unsafePerformIO $ newIORef []
{-# NOINLINE gHttpbinLinks #-}

grepLinks :: ByteString -&gt; [ByteString]
grepLinks =
    map (fst . snd) . filter ((1 ==) . fst) . concatMap A.assocs .
        filter (not . null) . concatMap (matchAllText regex) .
            C8.lines
    where regex = makeRegex $ C8.pack &#34;a href=\&#34;([^\&#34;]+)\&#34;&#34; :: Regex

grepHttpbinLinks :: ByteString -&gt; IO L.ByteString
grepHttpbinLinks &#34;&#34; = return &#34;&#34;
grepHttpbinLinks v = do
    writeIORef gHttpbinLinks $ grepLinks $ B.copy v
    return &#34;&#34;
ngxExportIOYY &#39;grepHttpbinLinks

sortLinks :: ByteString -&gt; IO L.ByteString
sortLinks &#34;httpbin&#34; =
    L.fromChunks . sort . map (`C8.snoc` &#39;\n&#39;) &lt;$&gt; readIORef gHttpbinLinks
sortLinks _ = return &#34;&#34;
ngxExportIOYY &#39;sortLinks"><pre>{-# <span>LANGUAGE</span> OverloadedStrings #-}

<span><span>--</span> ...</span>

<span>import</span>           <span>Data.IORef</span>
<span>import</span>           <span>Text.Regex.PCRE.ByteString</span>
<span>import</span>           <span>Text.Regex.Base.RegexLike</span>
<span>import</span> <span>qualified</span> <span>Data.Array</span> <span>as</span> <span>A</span>
<span>import</span>           <span>Data.List</span>
<span>import</span> <span>qualified</span> <span>Data.ByteString</span> <span>as</span> <span>B</span>

<span><span>--</span> ...</span>

<span>gHttpbinLinks</span> <span>::</span> <span>IORef</span> [<span>ByteString</span>]
gHttpbinLinks <span>=</span> unsafePerformIO <span>$</span> newIORef <span>[]</span>
{-# <span>NOINLINE</span> gHttpbinLinks #-}

<span>grepLinks</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> [<span>ByteString</span>]
grepLinks <span>=</span>
    <span>map</span> (<span>fst</span> <span>.</span> <span>snd</span>) <span>.</span> <span>filter</span> ((<span>1</span> <span>==</span>) <span>.</span> <span>fst</span>) <span>.</span> <span>concatMap</span> <span>A.</span>assocs <span>.</span>
        <span>filter</span> (<span>not</span> <span>.</span> <span>null</span>) <span>.</span> <span>concatMap</span> (matchAllText regex) <span>.</span>
            <span>C8.</span><span>lines</span>
    <span>where</span> regex <span>=</span> makeRegex <span>$</span> <span>C8.</span>pack <span><span>&#34;</span>a href=<span>\&#34;</span>([^<span>\&#34;</span>]+)<span>\&#34;</span><span>&#34;</span></span> <span>::</span> <span>Regex</span>

<span>grepHttpbinLinks</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
grepHttpbinLinks <span><span>&#34;</span><span>&#34;</span></span> <span>=</span> <span>return</span> <span><span>&#34;</span><span>&#34;</span></span>
grepHttpbinLinks v <span>=</span> <span>do</span>
    writeIORef gHttpbinLinks <span>$</span> grepLinks <span>$</span> <span>B.</span>copy v
    <span>return</span> <span><span>&#34;</span><span>&#34;</span></span>
ngxExportIOYY &#39;grepHttpbinLinks

<span>sortLinks</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
sortLinks <span><span>&#34;</span>httpbin<span>&#34;</span></span> <span>=</span>
    <span>L.</span>fromChunks <span>.</span> sort <span>.</span> <span>map</span> (<span>`C8.snoc`</span> <span><span>&#39;</span><span>\n</span><span>&#39;</span></span>) <span>&lt;$&gt;</span> readIORef gHttpbinLinks
sortLinks _ <span>=</span> <span>return</span> <span><span>&#34;</span><span>&#34;</span></span>
ngxExportIOYY &#39;sortLinks</pre></div>
<p dir="auto">Here <em>gHttpbinLinks</em> is the global state, <em>grepHttpbinLinks</em> is a handler for
update variable <em>_upd__hs_service_httpbin</em>, almost all the time it does
nothing â just returns an empty string, but when the update variable
becomes not empty, it updates the global state and returns an empty string
again. Notice that the original bytestring is copied with <em>B.copy</em> before its
parts get collected as matches and put in the global state. This is an important
step because the original bytestring&#39;s lifetime does not extend beyond the
current request whereas the global state may last much longer! Sometimes copying
is not necessary, for example when the bytestring gets deserialized into an
object in-place. Handler <em>sortLinks</em> is parameterized by data identifier: when
the identifier is equal to <em>httpbin</em>, it reads the global state and returns it
sorted, otherwise it returns an empty string.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-4" aria-hidden="true" href="#file-testconf-additions-4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_service_var_in_shm httpbin 512k /tmp $hs_service_httpbin;

    # ...

        location /httpbin/sortlinks {
            haskell_run grepHttpbinLinks $_upd_links_ $_upd__hs_service_httpbin;
            haskell_run sortLinks $hs_links &#34;${_upd_links_}httpbin&#34;;
            echo $hs_links;
        }"><pre>    <span>haskell_service_var_in_shm</span> httpbin <span>512k</span> /tmp <span>$hs_service_httpbin</span>;

    <span># ...</span>

        <span>location</span> <span>/httpbin/sortlinks </span>{
            <span>haskell_run</span> grepHttpbinLinks <span>$_upd_links_</span> <span>$_upd__hs_service_httpbin</span>;
            <span>haskell_run</span> sortLinks <span>$hs_links</span> <span>&#34;${_upd_links_}httpbin&#34;</span>;
            <span>echo</span> <span>$hs_links</span>;
        }</pre></div>
<p dir="auto">We have to pass variable <em>_upd_links_</em> in <em>sortLinks</em> because this will
trigger update in the worker by <em>grepHttpbinLinks</em>, otherwise update won&#39;t run:
remember that Nginx directives are lazy? On the other hand, <em>_upd_links_</em> is
always empty and won&#39;t mess up with the rest of the argument â value
<em>httpbin</em>.</p>
<p dir="auto">Run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin/sortlinks&#39;
/
/absolute-redirect/6
/anything
/basic-auth/user/passwd
/brotli
/bytes/1024

..."><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/sortlinks<span>&#39;</span></span></span>
<span>/</span>
<span>/absolute-redirect/6</span>
<span>/anything</span>
<span>/basic-auth/user/passwd</span>
<span>/brotli</span>
<span>/bytes/1024</span>

<span>...</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-shm-stats-variables" aria-hidden="true" href="#shm-stats-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Shm stats variables</h2>
<p dir="auto">Every service variable in shared memory has another associated variable that
provides basic stats in format <em>timestamp | size | changes | failures | failed</em>,
where <em>timestamp</em> is a number of seconds elapsed from the beginning of the <em>UNIX
epoch</em> till the last change of the variable&#39;s value, <em>size</em> is the size of the
variable in bytes, <em>changes</em> is a number of changes, and <em>failures</em> is a number
of memory allocation failures since the last Nginx reload, the value of flag
<em>failed</em> (<em>0</em> or <em>1</em>) denotes if the last attempt of memory allocation from the
shared memory pool for a new value of the variable has failed. The name of the
shm stats variable is built from the service variable&#39;s name with prefix
<em>_shm__</em>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-an-example-4" aria-hidden="true" href="#an-example-4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h3>
<p dir="auto">Let&#39;s add a location to show shm stats about our <em>httpbin</em> service. This time
only configuration file <em>test.conf</em> is affected.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-5" aria-hidden="true" href="#file-testconf-additions-5"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="        location /httpbin/shmstats {
            echo &#34;Httpbin service shm stats: $_shm__hs_service_httpbin&#34;;
        }"><pre>        <span>location</span> <span>/httpbin/shmstats </span>{
            <span>echo</span> <span>&#34;Httpbin service shm stats: <span>$_shm__hs_service_httpbin</span>&#34;</span>;
        }</pre></div>
<p dir="auto">Run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin/shmstats&#39;
Httpbin service shm stats: 1516274639 | 13011 | 1 | 0 | 0"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/shmstats<span>&#39;</span></span></span>
<span>Httpbin service shm stats: 1516274639 | 13011 | 1 | 0 | 0</span></pre></div>
<p dir="auto">From this output we can find that payload size of <em>httpbin.org</em> is <em>13011</em>
bytes, the service variable was updated only once (less than 20 seconds elapsed
from start of Nginx), and that there were no memory allocation failures.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-update-callbacks" aria-hidden="true" href="#update-callbacks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Update callbacks</h2>
<p dir="auto">There is a special type of single-shot services called update callbacks. They
are declared like</p>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_service_var_update_callback cbHttpbin $hs_service_httpbin optional_value;"><pre>    <span>haskell_service_var_update_callback</span> cbHttpbin <span>$hs_service_httpbin</span> optional_value;</pre></div>
<p dir="auto">Here <em>cbHttpbin</em> is a Haskell handler exported by <em>ngxExportServiceIOYY</em> as
always. Variable <em>hs_service_httpbin</em> must be declared in directive
<em>haskell_service_var_in_shm</em>. Argument <em>optional_value</em> is a string, it can be
omitted, in which case handler <em>cbHttpbin</em> gets the value of service variable
<em>hs_service_httpbin</em> as its first argument.</p>
<p dir="auto">Update callbacks do not return results. They run from a worker that holds the
active service on every change of the service variable, and shall be supposedly
used to integrate with other Nginx modules by signaling specific Nginx locations
via an HTTP client.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-an-example-5" aria-hidden="true" href="#an-example-5"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h3>
<p dir="auto">Let&#39;s count all changes of service variable <em>hs_service_httpbin</em> during Nginx
lifetime (originally I supposed that its content won&#39;t change after the first
initialization because <em>httpbin.org</em> looks like a static page, but responses
appeared to be able to vary from time to time). For this we will use counters
from
<a href="https://github.com/lyokha/nginx-custom-counters-module"><em>nginx-custom-counters-module</em></a>.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-5" aria-hidden="true" href="#file-tesths-additions-5"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="cbHttpbin :: ByteString -&gt; Bool -&gt; IO L.ByteString
cbHttpbin url firstRun = do
    when firstRun $ threadDelay $ 5 * 1000000
    getUrl url
ngxExportServiceIOYY &#39;cbHttpbin"><pre><span>cbHttpbin</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>Bool</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
cbHttpbin url firstRun <span>=</span> <span>do</span>
    when firstRun <span>$</span> threadDelay <span>$</span> <span>5</span> <span>*</span> <span>1000000</span>
    getUrl url
ngxExportServiceIOYY &#39;cbHttpbin</pre></div>
<p dir="auto">Handler <em>cbHttpbin</em> is a simple HTTP client. On the first run it waits 5 seconds
before sending request because the request is supposed to be destined to self,
while Nginx workers may appear to be not ready to accept it.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-6" aria-hidden="true" href="#file-testconf-additions-6"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_service_var_update_callback cbHttpbin $hs_service_httpbin
                                        &#34;http://127.0.0.1:8010/httpbin/count&#34;;

    # ...

        location /httpbin/count {
            counter $cnt_httpbin inc;
            return 200;
        }

        location /counters {
            echo &#34;Httpbin service changes count: $cnt_httpbin&#34;;
        }"><pre>    <span>haskell_service_var_update_callback</span> cbHttpbin <span>$hs_service_httpbin</span>
                                        &#34;http://127.0.0.1:8010/<span>httpbin/count</span><span>&#34;;</span>
<span></span>
<span>    # ...</span>
<span></span>
<span>        location /httpbin/count {</span>
<span>            counter <span>$cnt_httpbin</span> inc;</span>
<span>            return 200;</span>
<span>        }</span>
<span></span>
<span>        location /counters {</span>
<span>            echo &#34;</span>Httpbin service changes count: <span>$cnt_httpbin</span><span>&#34;;</span>
<span>        }</span></pre></div>
<p dir="auto">Wait at least 5 seconds after Nginx start and run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/counters&#39;
Httpbin service changes count: 1"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/counters<span>&#39;</span></span></span>
<span>Httpbin service changes count: 1</span></pre></div>
<p dir="auto">Further the count will probably be steadily increasing.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/counters&#39;
Httpbin service changes count: 3"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/counters<span>&#39;</span></span></span>
<span>Httpbin service changes count: 3</span></pre></div>

<p dir="auto">Service hooks allow for interaction with running services, both per-worker and
shared. They are supposed to change global states that affect services behavior
and can be thought of as service API handlers, thereto being run from dedicated
Nginx locations.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Exporter</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ByteString -&gt; IO L.ByteString</code></td>
<td><code>ngxExportServiceHook</code> (<code>NGX_EXPORT_SERVICE_HOOK</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">Service hooks install a content handler when declared. In the following example,</p>
<div dir="auto" data-snippet-clipboard-copy-content="        location /httpbin/url {
            haskell_service_hook getUrlServiceHook $hs_service_httpbin $arg_v;
        }"><pre>        <span>location</span> <span>/httpbin/url </span>{
            <span>haskell_service_hook</span> getUrlServiceHook <span>$hs_service_httpbin</span> <span>$arg_v</span>;
        }</pre></div>
<p dir="auto">location <em>/httpbin/url</em> derives the content handler which signals all workers
via an event channel upon receiving a request. Then the event handlers in all
workers run the hook (<em>getUrlServiceHook</em> in our case) <em>synchronously</em>, and
finally send an asynchronous exception <em>ServiceHookInterrupt</em> to the service
to which the service variable from the service hook declaration
(<em>hs_service_httpbin</em>) corresponds. Being run synchronously, service hooks are
expected to be fast, only writing data passed to them (the value of <em>arg_v</em> in
our case) into a global state. In contrast to <em>update variables</em>, this data has
a longer lifetime being freed in the Haskell part when the original bytestring
gets garbage collected.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-an-example-6" aria-hidden="true" href="#an-example-6"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h2>
<p dir="auto">Let&#39;s make it able to change the URL for the <em>httpbin</em> service in runtime. For
this we must enable <em>getUrlService</em> to read from a global state where the URL
value will reside.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-geturlservice-reimplemented" aria-hidden="true" href="#file-tesths-additions-geturlservice-reimplemented"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions, getUrlService reimplemented)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="import           Data.Maybe

-- ...

getUrlServiceLink :: IORef (Maybe ByteString)
getUrlServiceLink = unsafePerformIO $ newIORef Nothing
{-# NOINLINE getUrlServiceLink #-}

getUrlServiceLinkUpdated :: IORef Bool
getUrlServiceLinkUpdated = unsafePerformIO $ newIORef True
{-# NOINLINE getUrlServiceLinkUpdated #-}

getUrlService :: ByteString -&gt; Bool -&gt; IO L.ByteString
getUrlService url = const $ do
    url&#39; &lt;- fromMaybe url &lt;$&gt; readIORef getUrlServiceLink
    updated &lt;- readIORef getUrlServiceLinkUpdated
    atomicWriteIORef getUrlServiceLinkUpdated False
    unless updated $ threadDelay $ 20 * 1000000
    getUrl url&#39;
ngxExportServiceIOYY &#39;getUrlService

getUrlServiceHook :: ByteString -&gt; IO L.ByteString
getUrlServiceHook url = do
    writeIORef getUrlServiceLink $ if B.null url
                                       then Nothing
                                       else Just url
    atomicWriteIORef getUrlServiceLinkUpdated True
    return $ if B.null url
                 then &#34;getUrlService reset URL&#34;
                 else L.fromChunks [&#34;getUrlService set URL &#34;, url]
ngxExportServiceHook &#39;getUrlServiceHook"><pre><span>import</span>           <span>Data.Maybe</span>

<span><span>--</span> ...</span>

<span>getUrlServiceLink</span> <span>::</span> <span>IORef</span> (<span><span>Maybe</span></span> <span>ByteString</span>)
getUrlServiceLink <span>=</span> unsafePerformIO <span>$</span> newIORef <span>Nothing</span>
{-# <span>NOINLINE</span> getUrlServiceLink #-}

<span>getUrlServiceLinkUpdated</span> <span>::</span> <span>IORef</span> <span><span>Bool</span></span>
getUrlServiceLinkUpdated <span>=</span> unsafePerformIO <span>$</span> newIORef <span><span>True</span></span>
{-# <span>NOINLINE</span> getUrlServiceLinkUpdated #-}

<span>getUrlService</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>Bool</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
getUrlService url <span>=</span> <span>const</span> <span>$</span> <span>do</span>
    url&#39; <span>&lt;-</span> fromMaybe url <span>&lt;$&gt;</span> readIORef getUrlServiceLink
    updated <span>&lt;-</span> readIORef getUrlServiceLinkUpdated
    atomicWriteIORef getUrlServiceLinkUpdated <span><span>False</span></span>
    unless updated <span>$</span> threadDelay <span>$</span> <span>20</span> <span>*</span> <span>1000000</span>
    getUrl url&#39;
ngxExportServiceIOYY &#39;getUrlService

<span>getUrlServiceHook</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
getUrlServiceHook url <span>=</span> <span>do</span>
    writeIORef getUrlServiceLink <span>$</span> <span>if</span> <span>B.</span><span>null</span> url
                                       <span>then</span> <span>Nothing</span>
                                       <span>else</span> <span>Just</span> url
    atomicWriteIORef getUrlServiceLinkUpdated <span><span>True</span></span>
    <span>return</span> <span>$</span> <span>if</span> <span>B.</span><span>null</span> url
                 <span>then</span> <span><span>&#34;</span>getUrlService reset URL<span>&#34;</span></span>
                 <span>else</span> <span>L.</span>fromChunks [<span><span>&#34;</span>getUrlService set URL <span>&#34;</span></span>, url]
ngxExportServiceHook &#39;getUrlServiceHook</pre></div>
<p dir="auto">Service hook <em>getUrlServiceHook</em> writes into two global states:
<em>getUrlServiceLink</em> where the URL is stored, and <em>getUrlServiceLinkUpdated</em>
which will signal service <em>getUrlService</em> that the URL has been updated.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-7" aria-hidden="true" href="#file-testconf-additions-7"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_service_hooks_zone hooks 32k;

    # ...

        location /httpbin/url {
            allow 127.0.0.1;
            deny all;
            haskell_service_hook getUrlServiceHook $hs_service_httpbin $arg_v;
        }"><pre>    <span>haskell_service_hooks_zone</span> hooks <span>32k</span>;

    <span># ...</span>

        <span>location</span> <span>/httpbin/url </span>{
            <span>allow</span> <span>127.0.0.1</span>;
            <span>deny</span><span> all</span>;
            <span>haskell_service_hook</span> getUrlServiceHook <span>$hs_service_httpbin</span> <span>$arg_v</span>;
        }</pre></div>
<p dir="auto">Directive <em>haskell_service_hooks_zone</em> declares a shm zone where Nginx will
temporarily store data for the hook (the value of <em>arg_v</em>). This directive is
not mandatory: shm zone is not really needed when service hooks pass nothing.
Location <em>/httpbin/url</em> is protected from unauthorized access with Nginx
directives <em>allow</em> and <em>deny</em>.</p>
<p dir="auto">Run curl tests.</p>
<p dir="auto">First, let&#39;s check that <em>httpbin.org</em> replies as expected.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin&#39;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&#39;content-type&#39; value=&#39;text/html;charset=utf8&#39;&gt;
  &lt;meta name=&#39;generator&#39; value=&#39;Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)&#39;&gt;
  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;

...
$ curl &#39;http://127.0.0.1:8010/httpbin/sortlinks&#39;
/
/absolute-redirect/6
/anything
/basic-auth/user/passwd
/brotli
/bytes/1024

..."><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin<span>&#39;</span></span></span>
<span>&lt;!DOCTYPE html&gt;</span>
<span>&lt;html&gt;</span>
<span>&lt;head&gt;</span>
<span>  &lt;meta http-equiv=&#39;content-type&#39; value=&#39;text/html;charset=utf8&#39;&gt;</span>
<span>  &lt;meta name=&#39;generator&#39; value=&#39;Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)&#39;&gt;</span>
<span>  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;</span>

<span>...</span>
$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/sortlinks<span>&#39;</span></span></span>
<span>/</span>
<span>/absolute-redirect/6</span>
<span>/anything</span>
<span>/basic-auth/user/passwd</span>
<span>/brotli</span>
<span>/bytes/1024</span>

<span>...</span></pre></div>
<p dir="auto">Then change URL to, say, <em>example.com</em>,</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin/url?v=http://example.com&#39;"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/url?v=http://example.com<span>&#39;</span></span></span></pre></div>
<p dir="auto">and peek, by the way, into the Nginx error log.</p>
<div dir="auto" data-snippet-clipboard-copy-content="2018/02/13 16:12:33 [notice] 28794#0: service hook reported &#34;getUrlService set URL http://example.com&#34;
2018/02/13 16:12:33 [notice] 28795#0: service hook reported &#34;getUrlService set URL http://example.com&#34;
2018/02/13 16:12:33 [notice] 28797#0: service hook reported &#34;getUrlService set URL http://example.com&#34;
2018/02/13 16:12:33 [notice] 28798#0: service hook reported &#34;getUrlService set URL http://example.com&#34;
2018/02/13 16:12:33 [notice] 28797#0: an exception was caught while getting value of service variable &#34;hs_service_httpbin&#34;: &#34;Service was interrupted by a service hook&#34;, using old value"><pre><span>2018/02/13 16:12:33 [notice] 28794#0: service hook reported &#34;getUrlService set URL http://example.com&#34;</span>
<span>2018/02/13 16:12:33 [notice] 28795#0: service hook reported &#34;getUrlService set URL http://example.com&#34;</span>
<span>2018/02/13 16:12:33 [notice] 28797#0: service hook reported &#34;getUrlService set URL http://example.com&#34;</span>
<span>2018/02/13 16:12:33 [notice] 28798#0: service hook reported &#34;getUrlService set URL http://example.com&#34;</span>
<span>2018/02/13 16:12:33 [notice] 28797#0: an exception was caught while getting value of service variable &#34;hs_service_httpbin&#34;: &#34;Service was interrupted by a service hook&#34;, using old value</span></pre></div>
<p dir="auto">All 4 workers were signaled, and the only <em>active</em> service (remember that
<em>getUrlService</em> was made <em>shared</em>) was interrupted. Do not be deceived by <em>using
old value</em>: the new URL will be read in by the service from the global state
immediately after restart, and the service variable will be updated.</p>
<p dir="auto">Let&#39;s see what we are getting now.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin&#39;
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;

    &lt;meta charset=&#34;utf-8&#34; /&gt;

...
$ curl &#39;http://127.0.0.1:8010/httpbin/sortlinks&#39;
http://www.iana.org/domains/example"><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin<span>&#39;</span></span></span>
<span>&lt;!doctype html&gt;</span>
<span>&lt;html&gt;</span>
<span>&lt;head&gt;</span>
<span>    &lt;title&gt;Example Domain&lt;/title&gt;</span>

<span>    &lt;meta charset=&#34;utf-8&#34; /&gt;</span>

<span>...</span>
$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/sortlinks<span>&#39;</span></span></span>
<span>http://www.iana.org/domains/example</span></pre></div>
<p dir="auto">Let&#39;s reset the URL.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl &#39;http://127.0.0.1:8010/httpbin/url&#39;
$ curl &#39;http://127.0.0.1:8010/httpbin&#39;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&#39;content-type&#39; value=&#39;text/html;charset=utf8&#39;&gt;
  &lt;meta name=&#39;generator&#39; value=&#39;Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)&#39;&gt;
  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;

...
$ curl &#39;http://127.0.0.1:8010/httpbin/sortlinks&#39;
/
/absolute-redirect/6
/anything
/basic-auth/user/passwd
/brotli
/bytes/1024

..."><pre>$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/url<span>&#39;</span></span></span>
$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin<span>&#39;</span></span></span>
<span>&lt;!DOCTYPE html&gt;</span>
<span>&lt;html&gt;</span>
<span>&lt;head&gt;</span>
<span>  &lt;meta http-equiv=&#39;content-type&#39; value=&#39;text/html;charset=utf8&#39;&gt;</span>
<span>  &lt;meta name=&#39;generator&#39; value=&#39;Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)&#39;&gt;</span>
<span>  &lt;title&gt;httpbin(1): HTTP Client Testing Service&lt;/title&gt;</span>

<span>...</span>
$ <span>curl <span><span>&#39;</span>http://127.0.0.1:8010/httpbin/sortlinks<span>&#39;</span></span></span>
<span>/</span>
<span>/absolute-redirect/6</span>
<span>/anything</span>
<span>/basic-auth/user/passwd</span>
<span>/brotli</span>
<span>/bytes/1024</span>

<span>...</span></pre></div>
<p dir="auto">In the log we&#39;ll find</p>
<div dir="auto" data-snippet-clipboard-copy-content="2018/02/13 16:24:12 [notice] 28795#0: service hook reported &#34;getUrlService reset URL&#34;
2018/02/13 16:24:12 [notice] 28794#0: service hook reported &#34;getUrlService reset URL&#34;
2018/02/13 16:24:12 [notice] 28797#0: service hook reported &#34;getUrlService reset URL&#34;
2018/02/13 16:24:12 [notice] 28798#0: service hook reported &#34;getUrlService reset URL&#34;
2018/02/13 16:24:12 [notice] 28797#0: an exception was caught while getting value of service variable &#34;hs_service_httpbin&#34;: &#34;Service was interrupted by a service hook&#34;, using old value"><pre><span>2018/02/13 16:24:12 [notice] 28795#0: service hook reported &#34;getUrlService reset URL&#34;</span>
<span>2018/02/13 16:24:12 [notice] 28794#0: service hook reported &#34;getUrlService reset URL&#34;</span>
<span>2018/02/13 16:24:12 [notice] 28797#0: service hook reported &#34;getUrlService reset URL&#34;</span>
<span>2018/02/13 16:24:12 [notice] 28798#0: service hook reported &#34;getUrlService reset URL&#34;</span>
<span>2018/02/13 16:24:12 [notice] 28797#0: an exception was caught while getting value of service variable &#34;hs_service_httpbin&#34;: &#34;Service was interrupted by a service hook&#34;, using old value</span></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-service-update-hooks" aria-hidden="true" href="#service-update-hooks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Service update hooks</h2>
<p dir="auto">This is a reimplementation of <em>update variables</em> for shared services by means of
service hooks. Update hooks have a number of advantages over update variables.</p>
<ol dir="auto">
<li>No need for obscure treatment of update variables in configuration files.</li>
<li>No need for copying the original argument: its data is freed in the Haskell
part.</li>
<li>Nginx don&#39;t need to access shared memory on every single request for checking
if the service data has been altered.</li>
</ol>
<p dir="auto">There is a subtle difference with update variables though. As soon as with
update hooks new service variable data is propagated to worker processes
asynchronously via an event channel, there always exists a very short transient
period between the moments when the service variable gets altered in shared
memory and the global state gets updated in a worker, during which events
related to client requests may occur.</p>
<p dir="auto">An update hook is exported with exporter <em>ngxExportServiceHook</em>, and declared
using directive <em>haskell_service_update_hook</em> on the <em>http</em> configuration level.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-an-example-7" aria-hidden="true" href="#an-example-7"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h3>
<p dir="auto">Let&#39;s reimplement the example with update of service links using a service hook.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-6" aria-hidden="true" href="#file-tesths-additions-6"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="grepHttpbinLinksHook :: ByteString -&gt; IO L.ByteString
grepHttpbinLinksHook v = do
    let links = grepLinks v
        linksList = let ls = B.intercalate &#34; &#34; links
                    in if B.null ls
                        then &#34;&lt;NULL&gt;&#34;
                        else ls
    writeIORef gHttpbinLinks links
    return $ L.fromChunks [&#34;getUrlService set links &#34;, linksList]
ngxExportServiceHook &#39;grepHttpbinLinksHook"><pre><span>grepHttpbinLinksHook</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
grepHttpbinLinksHook v <span>=</span> <span>do</span>
    <span>let</span> links <span>=</span> grepLinks v
        linksList <span>=</span> <span>let</span> ls <span>=</span> <span>B.</span>intercalate <span><span>&#34;</span> <span>&#34;</span></span> links
                    <span>in</span> <span>if</span> <span>B.</span><span>null</span> ls
                        <span>then</span> <span><span>&#34;</span>&lt;NULL&gt;<span>&#34;</span></span>
                        <span>else</span> ls
    writeIORef gHttpbinLinks links
    <span>return</span> <span>$</span> <span>L.</span>fromChunks [<span><span>&#34;</span>getUrlService set links <span>&#34;</span></span>, linksList]
ngxExportServiceHook &#39;grepHttpbinLinksHook</pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-8" aria-hidden="true" href="#file-testconf-additions-8"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="    haskell_service_update_hook grepHttpbinLinksHook $hs_service_httpbin;

    # ...

        location /httpbin/sortlinks/hook {
            haskell_run sortLinks $hs_links httpbin;
            echo $hs_links;
        }"><pre>    <span>haskell_service_update_hook</span> grepHttpbinLinksHook <span>$hs_service_httpbin</span>;

    <span># ...</span>

        <span>location</span> <span>/httpbin/sortlinks/hook </span>{
            <span>haskell_run</span> sortLinks <span>$hs_links</span> httpbin;
            <span>echo</span> <span>$hs_links</span>;
        }</pre></div>
<p dir="auto">For testing this, watch the Nginx error log and change the URL of the service
with requests to location <em>/httpbin/url</em> like in the previous example.</p>

<p dir="auto">Serialized pointer to the Nginx <em>request object</em> is accessible via a special
variable <em>_r_ptr</em>. Haskell handlers have no benefit from this because they do
not know how the request object is built. However they may run C code having
been compiled with this knowledge. The low level access to the Nginx request
object makes it possible to do things that are not feasible to do without this.
As soon as a C plugin can do whatever a usual Nginx module can, using it from a
Haskell handler must be very cautious. All synchronous and asynchronous Haskell
handlers can access the Nginx request object and pass it to a C plugin. Using it
in a C plugin which runs in asynchronous context has not been investigated and
is probably dangerous in many aspects, with exception (probably) of read-only
access. After all, an Nginx worker is a single-threaded process, and the
standard Nginx tools and APIs were not designed for using in multi-threaded
environments. As such, using C plugins in asynchronous Haskell handlers must be
regarded strictly as experimental!</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-an-example-8" aria-hidden="true" href="#an-example-8"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h2>
<p dir="auto">Let&#39;s write a plugin that will add an HTTP header to the response.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-test_c_pluginc" aria-hidden="true" href="#file-test_c_pluginc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test_c_plugin.c</h4>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;

static const ngx_str_t haskell_module = ngx_string(&#34;Nginx Haskell module&#34;);

ngx_int_t
ngx_http_haskell_test_c_plugin(ngx_http_request_t *r)
{
    ngx_table_elt_t  *x_powered_by;

    x_powered_by = ngx_list_push(&amp;r-&gt;headers_out.headers);

    if (!x_powered_by) {
        ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0,
                      &#34;Unable to allocate memory to set X-Powered-By header&#34;);
        return NGX_ERROR;
    }

    x_powered_by-&gt;hash = 1;
    ngx_str_set(&amp;x_powered_by-&gt;key, &#34;X-Powered-By&#34;);
    x_powered_by-&gt;value = haskell_module;

    return NGX_OK;
}"><pre><span>#include</span> <span>&lt;ngx_core.h&gt;</span>
<span>#include</span> <span>&lt;ngx_http.h&gt;</span>

<span>static</span> <span>const</span> <span>ngx_str_t</span> <span>haskell_module</span> <span>=</span> <span>ngx_string</span>(<span>&#34;Nginx Haskell module&#34;</span>);

<span>ngx_int_t</span>
<span>ngx_http_haskell_test_c_plugin</span>(<span>ngx_http_request_t</span> <span>*</span><span>r</span>)
{
    <span>ngx_table_elt_t</span>  <span>*</span><span>x_powered_by</span>;

    <span>x_powered_by</span> <span>=</span> <span>ngx_list_push</span>(<span>&amp;</span><span>r</span><span>-&gt;</span><span>headers_out</span>.<span>headers</span>);

    <span>if</span> (!<span>x_powered_by</span>) {
        <span>ngx_log_error</span>(<span>NGX_LOG_CRIT</span>, <span>r</span><span>-&gt;</span><span>connection</span><span>-&gt;</span><span>log</span>, <span>0</span>,
                      <span>&#34;Unable to allocate memory to set X-Powered-By header&#34;</span>);
        <span>return</span> <span>NGX_ERROR</span>;
    }

    <span>x_powered_by</span><span>-&gt;</span><span>hash</span> <span>=</span> <span>1</span>;
    <span>ngx_str_set</span>(<span>&amp;</span><span>x_powered_by</span><span>-&gt;</span><span>key</span>, <span>&#34;X-Powered-By&#34;</span>);
    <span>x_powered_by</span><span>-&gt;</span><span>value</span> <span>=</span> <span>haskell_module</span>;

    <span>return</span> <span>NGX_OK</span>;
}</pre></div>
<p dir="auto">Let&#39;s compile the C code. For this we need a directory where Nginx sources were
sometime compiled. Let&#39;s refer to it in an environment variable <em>NGX_HOME</em>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ NGX_HOME=/path/to/nginx_sources"><pre>$ <span>NGX_HOME=/path/to/nginx_sources</span></pre></div>
<p dir="auto">Here we are going to mimic the Nginx build process.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ gcc -O2 -fPIC -c -o test_c_plugin.o -I $NGX_HOME/src/core -I $NGX_HOME/src/http -I $NGX_HOME/src/http/modules -I $NGX_HOME/src/event -I $NGX_HOME/src/event/modules -I $NGX_HOME/src/os/unix -I $NGX_HOME/objs test_c_plugin.c"><pre>$ <span>gcc -O2 -fPIC -c -o test_c_plugin.o -I <span>$NGX_HOME</span>/src/core -I <span>$NGX_HOME</span>/src/http -I <span>$NGX_HOME</span>/src/http/modules -I <span>$NGX_HOME</span>/src/event -I <span>$NGX_HOME</span>/src/event/modules -I <span>$NGX_HOME</span>/src/os/unix -I <span>$NGX_HOME</span>/objs test_c_plugin.c</span></pre></div>
<p dir="auto">Now we have an object file <em>test_c_plugin.o</em> to link with the Haskell code.
Below is the Haskell code itself.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-tesths-additions-7" aria-hidden="true" href="#file-tesths-additions-7"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.hs (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="import           Data.Binary.Get
import           Foreign.C.Types
import           Foreign.Ptr

-- ...

foreign import ccall unsafe &#34;ngx_http_haskell_test_c_plugin&#34;
    test_c_plugin :: Ptr () -&gt; IO CIntPtr

toRequestPtr :: ByteString -&gt; Ptr ()
toRequestPtr = wordPtrToPtr . fromIntegral . runGet getWordhost . L.fromStrict

testCPlugin :: ByteString -&gt; IO L.ByteString
testCPlugin v = do
    res &lt;- test_c_plugin $ toRequestPtr v
    return $ if res == 0
                 then &#34;Success!&#34;
                 else &#34;Failure!&#34;
ngxExportIOYY &#39;testCPlugin"><pre><span>import</span>           <span>Data.Binary.Get</span>
<span>import</span>           <span>Foreign.C.Types</span>
<span>import</span>           <span>Foreign.Ptr</span>

<span><span>--</span> ...</span>

<span>foreign</span> <span>import</span> ccall <span>unsafe</span> <span><span>&#34;</span>ngx_http_haskell_test_c_plugin<span>&#34;</span></span>
    <span>test_c_plugin</span> <span>::</span> <span>Ptr</span> <span>()</span> <span>-&gt;</span> <span><span>IO</span></span> <span>CIntPtr</span>

<span>toRequestPtr</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span>Ptr</span> <span>()</span>
toRequestPtr <span>=</span> wordPtrToPtr <span>.</span> <span>fromIntegral</span> <span>.</span> runGet getWordhost <span>.</span> <span>L.</span>fromStrict

<span>testCPlugin</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>L.</span>ByteString</span>
testCPlugin v <span>=</span> <span>do</span>
    res <span>&lt;-</span> test_c_plugin <span>$</span> toRequestPtr v
    <span>return</span> <span>$</span> <span>if</span> res <span>==</span> <span>0</span>
                 <span>then</span> <span><span>&#34;</span>Success!<span>&#34;</span></span>
                 <span>else</span> <span><span>&#34;</span>Failure!<span>&#34;</span></span>
ngxExportIOYY &#39;testCPlugin</pre></div>
<p dir="auto">Handler <em>testCPlugin</em> runs function <em>ngx_http_haskell_test_c_plugin()</em> from the
C plugin and returns <em>Success!</em> or <em>Failure!</em> in cases when the C function
returns <em>NGX_OK</em> or <em>NGX_ERROR</em> respectively. When compiled with <em>ghc</em>, this
code has to be linked with <em>test_c_plugin.o</em>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ ghc -O2 -dynamic -shared -fPIC -flink-rts -threaded test_c_plugin.o test.hs -o test.so
[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )
Linking test.so ...
$ sudo cp test.so /var/lib/nginx/"><pre>$ <span>ghc -O2 -dynamic -shared -fPIC -flink-rts -threaded test_c_plugin.o test.hs -o test.so</span>
<span>[1 of 1] Compiling NgxHaskellUserRuntime ( test.hs, test.o )</span>
<span>Linking test.so ...</span>
$ <span>sudo cp test.so /var/lib/nginx/</span></pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-file-testconf-additions-9" aria-hidden="true" href="#file-testconf-additions-9"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>File test.conf (additions)</h4>
<div dir="auto" data-snippet-clipboard-copy-content="        location /cplugin {
            haskell_run testCPlugin $hs_test_c_plugin $_r_ptr;
            echo &#34;Test C plugin returned $hs_test_c_plugin&#34;;
        }"><pre>        <span>location</span> <span>/cplugin </span>{
            <span>haskell_run</span> testCPlugin <span>$hs_test_c_plugin</span> <span>$_r_ptr</span>;
            <span>echo</span> <span>&#34;Test C plugin returned <span>$hs_test_c_plugin</span>&#34;</span>;
        }</pre></div>
<p dir="auto">Run curl tests.</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ curl -D- &#39;http://localhost:8010/cplugin&#39;
HTTP/1.1 200 OK
Server: nginx/1.12.1
Date: Thu, 08 Mar 2018 12:09:52 GMT
Content-Type: application/octet-stream
Transfer-Encoding: chunked
Connection: keep-alive
X-Powered-By: Nginx Haskell module

Test C plugin returned Success!"><pre>$ <span>curl -D- <span><span>&#39;</span>http://localhost:8010/cplugin<span>&#39;</span></span></span>
<span>HTTP/1.1 200 OK</span>
<span>Server: nginx/1.12.1</span>
<span>Date: Thu, 08 Mar 2018 12:09:52 GMT</span>
<span>Content-Type: application/octet-stream</span>
<span>Transfer-Encoding: chunked</span>
<span>Connection: keep-alive</span>
<span>X-Powered-By: Nginx Haskell module</span>

<span>Test C plugin returned Success!</span></pre></div>
<p dir="auto">The header <em>X-Powered-By</em> is in the response!</p>
<p dir="auto">Notice that the value of <em>_r_ptr</em> has a binary representation and therefore
must not be used in textual contexts such as Haskell <em>data</em> declarations or JSON
objects. It makes sense to put <em>_r_ptr</em> in the beginning of the handler&#39;s
argument as it must be easy to extract it from the rest of the argument later.
This can be achieved explicitly, e.g. <em>${_r_ptr}my data</em>, or by adding
suffix <em>(r)</em> at the end of the handler&#39;s name.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-c-plugins-in-service-update-hooks" aria-hidden="true" href="#c-plugins-in-service-update-hooks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>C plugins in service update hooks</h2>
<p dir="auto">Service update hooks can be used to replace service <em>update callbacks</em>. Indeed,
being run <em>synchronously</em> from an event handler, a service hook could safely
call a C function which would acquire related to Nginx context from Nginx global
variables such as <em>ngx_cycle</em> for doing a variety of low level actions.</p>
<p dir="auto">Below is a table of functions exported from the Haskell module that return
opaque pointers to Nginx global variables for using them in C plugins.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Returned value and its type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ngxCyclePtr</code></td>
<td>value of argument <code>cycle</code> in the worker&#39;s initialization function (of type <code>ngx_cycle_t *</code>)</td>
</tr>
<tr>
<td><code>ngxUpstreamMainConfPtr</code></td>
<td>value of expression <code>ngx_http_cycle_get_module_main_conf(cycle, ngx_http_upstream_module)</code> in the worker&#39;s initialization function (of type <code>ngx_http_upstream_main_conf_t *</code>)</td>
</tr>
<tr>
<td><code>ngxCachedTimePtr</code></td>
<td><em>address</em> of the Nginx global variable <code>ngx_cached_time</code> (of type <code>volatile ngx_time_t **</code>)</td>
</tr>
</tbody>
</table>
<p dir="auto">Notice that besides synchronous nature of service update hooks, there are other
features that distinguish them from service update callbacks.</p>
<ol dir="auto">
<li>As soon as running C plugins can be useful not only in shared services, but
in normal per-worker services too, service update hooks are allowed in both
the types.</li>
<li>Unlike update callbacks, service hooks get triggered in all worker processes.</li>
<li>Unlike update callbacks, service hooks get triggered even when the value of
the service variable has not been actually changed.</li>
</ol>
<h3 tabindex="-1" dir="auto"><a id="user-content-an-example-9" aria-hidden="true" href="#an-example-9"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>An example</h3>
<p dir="auto">See implementation of
<a href="https://github.com/lyokha/nginx-healthcheck-plugin"><em>nginx-healthcheck-plugin</em></a>.</p>

<p dir="auto">Haskell handlers may accept strings (<code>String</code> or <code>[String]</code>) and <em>strict</em>
bytestrings (<code>ByteString</code>), and return strings, <em>lazy</em> bytestrings and booleans.
Input C-strings are marshaled into a <em>String</em> with <em>peekCStringLen</em> which has
linear complexity <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="919779c2cac6daf946fab7b59d86b848">$O(n)$</math-renderer>, output <em>Strings</em> are marshaled into C-strings with
<em>newCStringLen</em> which is also <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="919779c2cac6daf946fab7b59d86b848">$O(n)$</math-renderer>. The new C-strings get freed upon the
request termination in the Nginx part.</p>
<p dir="auto">The bytestring counterparts are much faster. Both input and output are <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="919779c2cac6daf946fab7b59d86b848">$O(1)$</math-renderer>,
using <em>unsafePackCStringLen</em> and a Haskell <em>stable pointer</em> to lazy bytestring
buffers created inside Haskell handlers. If an output lazy bytestring has more
than one chunk, a new single-chunked C-string will be created in variable and
service handlers, but not in content handlers because the former use the chunks
directly when constructing contents. Holding a stable pointer to a bytestring&#39;s
chunks in the Nginx part ensures that they won&#39;t be garbage collected until the
pointer gets freed. Stable pointers get freed upon the request termination for
variable and content handlers, and before the next service iteration for service
handlers.</p>
<p dir="auto">Complex scenarios may require <em>typed exchange</em> between Haskell handlers and the
Nginx part using <em>serialized</em> data types such as Haskell records. In this case,
<em>bytestring</em> flavors of the handlers would be the best choice. There are two
well-known serialization mechanisms: <em>packing Show</em> / <em>unpacking Read</em> and
<em>ToJSON</em> / <em>FromJSON</em> from Haskell package <em>aeson</em>. In practice, <em>Show</em> is
basically faster than <em>ToJSON</em>, however in many cases <em>FromJSON</em> outperforms
<em>Read</em>.</p>
<p dir="auto">A variable handler of a shared service makes a copy of the variable&#39;s value
because shared data can be altered by any worker at any moment, and there is no
safe way to hold a reference to a shared data without locking. In contrast, a
variable handler of a normal per-worker service shares a reference to the value
with the service. Obviously, this is still not safe. Imagine that some request
gets a reference to a service value from the variable handler, then lasts some
time and later uses this reference again: the reference could probably be freed
by this time because the service could have altered its data since the beginning
of the request. This catastrophic scenario could have been avoided by using a
copy of the service value in every request like in shared services, but this
would unnecessarily hit performance, therefore requests share <em>counted
references</em> to service values, and as soon as the count reaches <em>0</em>, the service
value gets freed.</p>

<p dir="auto">There is no way to catch exceptions in <em>pure</em> handlers. However they can arise
from using <em>partial</em> functions such as <em>head</em> and <em>tail</em>! Switching to their
<em>total</em> counterparts from module <em>Safe</em> can mitigate this issue, but it is not
possible to eliminate it completely.</p>
<p dir="auto">Fortunately, all exceptions, synchronous and asynchronous, are caught on top of
the module&#39;s Haskell code. If a handler does not catch an exception itself, the
exception gets caught higher and logged by Nginx. However, using exception
handlers in Haskell handlers, when it&#39;s possible, should be preferred.</p>

<table>
<thead>
<tr>
<th>Directive</th>
<th>Level</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>haskell compile</code></td>
<td><code>http</code></td>
<td>Compile Haskell code found in the last argument. Accepts arguments <em>threaded</em> (use <em>threaded</em> RTS library), <em>debug</em> (use <em>debug</em> RTS library), and <em>standalone</em> (use <em>standalone</em> approach).</td>
</tr>
<tr>
<td><code>haskell load</code></td>
<td><code>http</code></td>
<td>Load the specified Haskell library.</td>
</tr>
<tr>
<td><code>haskell ghc_extra_options</code></td>
<td><code>http</code></td>
<td>Specify extra options for GHC when the library compiles.</td>
</tr>
<tr>
<td><code>haskell rts_options</code></td>
<td><code>http</code></td>
<td>Specify options for Haskell RTS.</td>
</tr>
<tr>
<td><code>haskell program_options</code></td>
<td><code>http</code></td>
<td>Specify program options. This is just another way for passing data into Haskell handlers.</td>
</tr>
<tr>
<td><code>haskell_run</code></td>
<td><code>server</code>, <code>location</code>, <code>location if</code></td>
<td>Run a synchronous Haskell task.</td>
</tr>
<tr>
<td><code>haskell_run_async</code></td>
<td><code>server</code>, <code>location</code>, <code>location if</code></td>
<td>Run an asynchronous Haskell task.</td>
</tr>
<tr>
<td><code>haskell_run_async_on_request_body</code></td>
<td><code>server</code>, <code>location</code>, <code>location if</code></td>
<td>Run an asynchronous Haskell request body handler.</td>
</tr>
<tr>
<td><code>haskell_run_service</code></td>
<td><code>http</code></td>
<td>Run a Haskell service.</td>
</tr>
<tr>
<td><code>haskell_service_var_update_callback</code></td>
<td><code>http</code></td>
<td>Run a callback on a service variable&#39;s update.</td>
</tr>
<tr>
<td><code>haskell_content</code></td>
<td><code>location</code>, <code>location if</code></td>
<td>Declare a Haskell content handler.</td>
</tr>
<tr>
<td><code>haskell_static_content</code></td>
<td><code>location</code>, <code>location if</code></td>
<td>Declare a static Haskell content handler.</td>
</tr>
<tr>
<td><code>haskell_unsafe_content</code></td>
<td><code>location</code>, <code>location if</code></td>
<td>Declare an unsafe Haskell content handler.</td>
</tr>
<tr>
<td><code>haskell_async_content</code></td>
<td><code>location</code>, <code>location if</code></td>
<td>Declare an asynchronous Haskell content handler.</td>
</tr>
<tr>
<td><code>haskell_async_content_on_request_body</code></td>
<td><code>location</code>, <code>location if</code></td>
<td>Declare an asynchronous Haskell content handler with access to request body.</td>
</tr>
<tr>
<td><code>haskell_service_hook</code></td>
<td><code>location</code>, <code>location if</code></td>
<td>Declare a service hook and create a content handler for managing the corresponding service.</td>
</tr>
<tr>
<td><code>haskell_service_update_hook</code></td>
<td><code>http</code></td>
<td>Declare a service update hook.</td>
</tr>
<tr>
<td><code>haskell_request_body_read_temp_file</code></td>
<td><code>server</code>, <code>location</code>, <code>location if</code></td>
<td>This flag (<em>on</em> or <em>off</em>) makes asynchronous tasks and content handlers read buffered in a <em>temporary file</em> POST data. If not set, then buffered data is not read.</td>
</tr>
<tr>
<td><code>haskell_var_nocacheable</code></td>
<td><code>http</code></td>
<td>All variables in the list become no cacheable and safe for using in ad-hoc iterations over <em>error_page</em> cycles. Applicable to variables of any <em>get handler</em>.</td>
</tr>
<tr>
<td><code>haskell_var_nohash</code></td>
<td><code>http</code></td>
<td>Nginx won&#39;t build hashes for variables in the list. Applicable to variables of any <em>get handler</em>.</td>
</tr>
<tr>
<td><code>haskell_var_compensate_uri_changes</code></td>
<td><code>http</code></td>
<td>All variables in the list allow to cheat <em>error_page</em> when used in its redirections and make the cycle infinite.</td>
</tr>
<tr>
<td><code>haskell_var_empty_on_error</code></td>
<td><code>http</code></td>
<td>All variables in the list return empty values on errors while the errors are still being logged by Nginx. Applicable to effectful synchronous and asynchronous variable handlers.</td>
</tr>
<tr>
<td><code>haskell_service_var_ignore_empty</code></td>
<td><code>http</code></td>
<td>All service variables in the list do not write the service result when its value is empty.</td>
</tr>
<tr>
<td><code>haskell_service_var_in_shm</code></td>
<td><code>http</code></td>
<td>All service variables in the list store the service result in a shared memory. Implicitly declares a shared service.</td>
</tr>
<tr>
<td><code>haskell_service_hooks_zone</code></td>
<td><code>http</code></td>
<td>Declare shm zone for a temporary storage of service hooks data.</td>
</tr>
<tr>
<td><code>haskell_request_variable_name</code></td>
<td><code>http</code></td>
<td>Change the name of the request variable if default value <em>_r_ptr</em> is already used.</td>
</tr>
<tr>
<td><code>single_listener</code></td>
<td><code>server</code></td>
<td>Make the virtual server accept client requests only from a single worker process.</td>
</tr>
</tbody>
</table>

<p dir="auto">Package
<a href="https://hackage.haskell.org/package/ngx-export-tools" rel="nofollow"><em>ngx-export-tools</em></a>
provides module
<a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools.html" rel="nofollow"><em>NgxExport.Tools</em></a>
that exports various utility functions and data as well as specialized service
exporters and adapters. As soon as the module is well documented, its features
are only basically lined up below.</p>
<ul dir="auto">
<li>Utility functions <em>terminateWorkerProcess</em> and <em>restartWorkerProcess</em> make it
possible to terminate the worker process from within a Haskell service.
Function <em>finalizeHTTPRequest</em> finalizes the current HTTP request from an
asynchronous Haskell handler with the specified HTTP status and body. Function
<em>ngxRequestPtr</em> unmarshals the value of Nginx variable <em>_r_ptr</em>. Function
<em>ngxNow</em> returns the current time cached inside the Nginx core.</li>
<li>Data <em>TimeInterval</em> and utility functions <em>toSec</em> and <em>threadDelaySec</em> can be
used to specify time delays for services.</li>
<li>A number of converters from custom types deriving or implementing instances of
<em>Read</em> and <em>FromJSON</em> (<em>readFromBytestring</em> and friends).</li>
<li>Special service exporters (<em>simple services</em>) combine various <em>sleeping</em>
strategies and typing policies of services and can be used to avoid usual
boilerplate code needed in the vanilla service exporters from module
<em>NgxExport</em>.</li>
<li>Special service adapters (<em>split services</em>) allow for distinguishing between
<em>ignition</em> services (those that run when the service runs for the first time)
and <em>deferred</em> services (those that run when the service runs for the second
time and later).</li>
</ul>

<p dir="auto">Note: click on the links to read descriptions and documentation.</p>
<ul dir="auto">
<li>Haskell modules with docs and examples on Hackage
<ul dir="auto">
<li>Package <a href="https://hackage.haskell.org/package/ngx-export" rel="nofollow"><em>ngx-export</em></a>
<ul dir="auto">
<li>Module <a href="https://hackage.haskell.org/package/ngx-export/docs/NgxExport.html" rel="nofollow"><em>NgxExport</em></a></li>
</ul>
</li>
<li>Package <a href="https://hackage.haskell.org/package/ngx-export-tools" rel="nofollow"><em>ngx-export-tools</em></a>
<ul dir="auto">
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools.html" rel="nofollow"><em>NgxExport.Tools</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools-Read.html" rel="nofollow"><em>NgxExport.Tools.Read</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools-SimpleService.html" rel="nofollow"><em>NgxExport.Tools.SimpleService</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools-SplitService.html" rel="nofollow"><em>NgxExport.Tools.SplitService</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools-System.html" rel="nofollow"><em>NgxExport.Tools.System</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools/docs/NgxExport-Tools-TimeInterval.html" rel="nofollow"><em>NgxExport.Tools.TimeInterval</em></a></li>
</ul>
</li>
<li>Package <a href="https://hackage.haskell.org/package/ngx-export-tools-extra" rel="nofollow"><em>ngx-export-tools-extra</em></a>
<ul dir="auto">
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-Aggregate.html" rel="nofollow"><em>NgxExport.Tools.Aggregate</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-EDE.html" rel="nofollow"><em>NgxExport.Tools.EDE</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-PCRE.html" rel="nofollow"><em>NgxExport.Tools.PCRE</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-Prometheus.html" rel="nofollow"><em>NgxExport.Tools.Prometheus</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-Resolve.html" rel="nofollow"><em>NgxExport.Tools.Resolve</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-ServiceHookAdaptor.html" rel="nofollow"><em>NgxExport.Tools.ServiceHookAdaptor</em></a></li>
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-tools-extra/docs/NgxExport-Tools-Subrequest.html" rel="nofollow"><em>NgxExport.Tools.Subrequest</em></a></li>
</ul>
</li>
<li>Package <a href="https://hackage.haskell.org/package/ngx-export-distribution" rel="nofollow"><em>ngx-export-distribution</em></a>
<ul dir="auto">
<li>Module <a href="https://hackage.haskell.org/package/ngx-export-distribution/docs/NgxExport-Distribution.html" rel="nofollow"><em>NgxExport.Distribution</em></a></li>
</ul>
</li>
</ul>
</li>
<li>Haskell modules implemented as C plugins
<ul dir="auto">
<li>Package <a href="https://github.com/lyokha/nginx-healthcheck-plugin"><em>ngx-export-healthcheck</em></a></li>
<li>Package <a href="https://github.com/lyokha/nginx-log-plugin"><em>ngx-export-log</em></a></li>
</ul>
</li>
</ul>

<ul dir="auto">
<li>The old <a href="https://github.com/lyokha/nginx-haskell-module/blob/master/docs/old-readme/README.md"><em>README.md</em></a> contains more details on the
implementation of the module and some topics not covered here.</li>
<li>Module <a href="https://github.com/lyokha/nginx-haskell-module/blob/master/aliases"><em>aliases</em></a> declares handy aliases for a few directives from
this module.</li>
<li>Module <a href="https://github.com/lyokha/nginx-haskell-module/blob/master/examples/dynamicUpstreams"><em>upconf</em></a> provides basic support for
dynamic upstreams.</li>
</ul>
<p dir="auto">There are some articles about the module in my blog.</p>
<ul dir="auto">
<li><a href="https://lin-techdet.blogspot.com/2015/12/nginx-module-to-enable-haskell-binding.html" rel="nofollow"><em>nginx module to enable haskell binding to nginx configuration
files</em></a>,</li>
<li><a href="https://lin-techdet.blogspot.com/2017/01/nginx-haskell-module-labeled-media.html" rel="nofollow"><em>nginx-haskell-module: labeled media routing
example</em></a>,</li>
<li><a href="https://lin-techdet.blogspot.com/2017/08/passing-bytestring-contents-reliably.html" rel="nofollow"><em>Passing ByteString contents reliably into C
code</em></a>,</li>
<li><a href="https://lin-techdet.blogspot.com/2018/03/signaling-all-worker-processes-in-nginx.html" rel="nofollow"><em>Signaling all worker processes in Nginx via an event
channel</em></a>.</li>
</ul>
</article>
          </div></div>
  </body>
</html>
