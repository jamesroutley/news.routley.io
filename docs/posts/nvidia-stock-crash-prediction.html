<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/nvidia-stock-crash-prediction">Original</a>
    <h1>Nvidia Stock Crash Prediction</h1>
    
    <div id="readability-page-1" class="page"><div>
                <div id="org2e0c7e0">

<p><img src="https://entropicthoughts.com/image/banner/nvidia-stock-crash-prediction.jpg" alt="nvidia-stock-crash-prediction.jpg"/>
</p>

</div>

<p>
One of the questions of <a href="https://www.metaculus.com/notebooks/41230/the-acx-2026-prediction-contest-is-live-10000-prize-pool/">the 2026 <abbr>acx</abbr> prediction contest</a> is whether <a href="https://www.metaculus.com/questions/40972/will-nvda-close-below-100-in-2026/">Nvidia’s
stock price will close below $100</a> on any day in 2026. At the time of writing, it
trades at $184 and a bit, so going down to $100 would be a near halving of the
stock value of the highest valued company in the world.
</p>

<p>
It’s an interesting question, and it’s worth spending some time on it.
</p>



<p>
If you just want the answer, my best prediction is that the probability is
around 10 %. I didn’t expect to get such a high answer, but read on to see how
we can find out.
</p>

<p>
When <a href="https://entropicthoughts.com/forecasting-mistakes-dow-jones-random-walk-barrier.html">we predicted the Dow Jones index crossing a barrier in 2023</a>, we treated the
index as an unbiased random walk. That was convenient, but we cannot do it with
the Nvidia question because of one major difference: the time scale.
</p>
<section id="outline-container-return-grows-faster-than-volatility">

<div id="text-org36b4850">
<p>
Over short time spans, the <i>volatility</i><span><sup>1</sup> Or noise, or variation, or standard
deviation.</span> of stock movements dominate their <i>return</i><span><sup>2</sup> Or signal, or drift,
or average change.</span>. This happens because noise grows with the square root of
time, while signal grows linearly with time.
</p>

<p>
The plot below illustrates an imaginary amazing investment which has a yearly
log-return of 0.3, and a yearly volatility of 0.3.<span><sup>3</sup> Readers aware that <a href="https://entropicthoughts.com/do-stonks-go-up.html">stonks
go up</a> will recognise this as an unrealistic Sharpe ratio of 1.0.</span> The middle
line follows our best guess for how the investment will grow after each year,
and the outer curves illustrate our uncertainty around the exact value of it.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-01.svg" alt="nvidia-prediction-01.svg"/>
</p>

<p>
Early on, we can see that the uncertainty is much bigger than the height to the
trend line. Before a year has passed, the exact result is determined more by
noise than by growth. Toward the end, growth has taken over and the noise has a
smaller effect.
</p>

<p>
One measure of how much volatility there is compared to expected return is the
signal-to-noise ratio. It’s computed as
</p>

<p>
\[10 \log_{10}\left(\frac{\mu\sqrt{t}}{\sigma}\right)\]
</p>

<p>
and for the Dow Jones question, we were looking at a signal-to-noise ratio of
−8 dB. That is already a little too high to safely assume it behaves like an
unbiased random walk, but for a low-stakes prediction contest it works out.
</p>

<p>
Using return data for the Nvidia stock from 2025, the signal-to-noise ratio is
−1.4 dB. Although the movement in this period is still dominated by
noise<span><sup>4</sup> Evidenced by negative signal-to-noise ratio.</span>, the expected return is
still going to matter, and we shouldn’t assume it behaves like an unbiased
random walk.
</p>
</div>
</section>
<section id="outline-container-volatility-is-not-constant-over-a-year">

<div id="text-org369ddd7">
<p>
Even if we ignore the problematic signal-to-noise ratio and pretend the Nvidia
stock price is an unbiased random walk, we’ll run into what’s perhaps the bigger
problem: the theory of unbiased random walks assumes constant volatility
throughout the year. The computer will happily tell us there is a near-zero
percent chance of the stock closing under $100 at any point next year.
</p>



<p><img src="https://entropicthoughts.com/image/nvidia-prediction-02.svg" alt="nvidia-prediction-02.svg"/>
</p>

<p>
The computer does grant a 23 % probability that the stock price drops to $130,
and that might get us thinking. If we assume the stock price <i>has</i> dropped to
$130, that tells us something about the market environment we’re in. Nvidia
might drop to $130 due to random chance alone, but it’s <i>more likely</i> to do that
if we’re in a market with a higher volatility than we assumed based on the
2025 returns. In such a market, a further drop to $100 isn’t so strange anymore.
</p>

<p>
Our simple random walk model does not account for this. When forecasting stock
prices over longer periods, we need a better understanding of how the volatility
might change in the future.
</p>
</div>
</section>
<section id="outline-container-options-traders-estimate-volatility-for-breakfast">

<div id="text-org5bd9b12">
<p>
Fortunately for us, there are people who continuously estimate the volatility of
specific stock prices. They even do it in relation to barriers like the $100
price we’re interested in. They’re options traders!
</p>

<p>
The expected volatility of the stock price is one of the variables that go into
pricing an option. This means we can look up a December 2026 Nvidia call option
with a strike price of $100 in the market, see what it costs, and then reverse
the option pricing process to get an <i>implied volatility</i> out.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-options-chain.png" alt="nvidia-options-chain.png"/>
</p>

<p>
To do this, we first need to learn how to price an option, and to do <i>that</i>, we
need to know what an option is.
</p>

<p>
In this article, we’re going to focus on call options because they are more
thickly traded. Assume we have an un-expired Nvidia call option with a strike
price of $100. We can then <i>exercise</i> it, which means we trade in the option
plus the strike price for one share in the underlying Nvidia stock. If we did
that today, we would earn $84, because we lose the $100, but the share in Nvidia
we get in exchange is worth $184.
</p>

<p>
We don’t have to exercise the option, though. If the price of Nvidia goes up
tomorrow, we would earn more from exercising the option tomorrow. We can delay
exercising it right up until it expires, when it becomes invalid.
</p>

<p>
<i>If</i> we were able to buy the $100 option for less than $84, we would get free
profit. The chart above tells us, however, that the $100 option costs $92.90,
meaning the market expects there to be a better opportunity for exercising that
option before it expires.
</p>
</div>
</section>
<section id="outline-container-the-binomial-asset-price-model">

<div id="text-org5bad75c">
<p>
To keep things computationally simple, we are going to use a binomial model for
the price of the underlying Nvidia stock. We don’t know the daily volatility, so
we’ll keep that as a variable we call \(\sigma\). We will pretend that each day,
the Nvidia stock price can either grow with a factor of \(e^\sigma\) or shrink
with a factor of \(e^{-\sigma}\).<span><sup>5</sup> This is a geometric binomial walk. We could
transform everything in the reasoning below with the logarithm and get an
additive walk in log-returns.</span>
</p>

<p>
Thus, on day zero, the Nvidia stock trades for $184. On day one, it can take one
of two values:
</p>

<ul>
<li>\(184e^\sigma\) because it went up, or</li>
<li>\(184e^{-\sigma}\) because it went down.</li>
</ul>

<p>
On day two, it can have one of three values:
</p>

<ul>
<li>\(184e^{2\sigma}\) (went up both in the first and second day),</li>
<li>\(184e^{\sigma - \sigma} = 184\) (went up and then down, or vice versa), or</li>
<li>\(184e^{-2\sigma}\) (went down both days).</li>
</ul>

<p>
If it’s easier, we can visualise this as a tree. Each day, the stock price
branches into two possibilities, one where it rises, and one where it goes down.
In the graph below, each column of bubbles represents the closing value for a
day.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-03.png" alt="nvidia-prediction-03.png"/>
</p>


<p>
This looks like a very crude approximation, but it actually works if the time
steps are fine-grained enough. The uncertainties involved in some of the other
estimations we’ll do dwarf the inaccuracies introduced by this model.<span><sup>6</sup> Even
for fairly serious use, I wouldn’t be unhappy with daily time steps when the
analysis goes a year out.</span>
</p>

<p>
It is important to keep in mind that the specific numbers in the bubbles depend
on which number we selected for the daily volatility \(\sigma\). Any conclusion we
draw from this tree is a function of the specific \(\sigma\) chosen to construct
the tree.
</p>

<p>
When we have chosen an initial \(\sigma\) and constructed this tree, we can price
an option using it. Maybe we have a call option expiring on day three, with a
strike price of $180. On day four, the last day, the option has expired, so it
is worth nothing. We’ll put that into the tree.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-04.png" alt="nvidia-prediction-04.png"/>
</p>

<p>
We have already seen what the value of the option is on the day it expires: it’s
what we would profit from exercising it. If the stock is valued at $191, the
option is worth $11, the difference between the stock value and the strike
price. On the other hand, if the stock is valued at $177, it is worth less than
the strike price of the option, so we will <i>not</i> exercise the option, instead
letting it expire.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-05.png" alt="nvidia-prediction-05.png"/>
</p>

<p>
The day before the expiration day is when we have the first interesting choice
to make. We can still exercise the option, with the exercise value of the
option calculated the same way.
</p>

<p>
Or we could hold on to the option. If we hold on to the option for a day, the
value of the option will either go up or down, depending on the value of the
underlying stock price. We will compute a weighted average of these movement
possibilities as
</p>

<p>
\[\tilde{p} V_u + (1 - \tilde{p}) V_d\]
</p>

<p>
where \(V_u\) and \(V_d\) are the values the option will have on the next day when
the underlying moves up or down in the tree, respectively. Then we’ll discount
this with a safe interest rate to account for
the fact that by holding the option, we are foregoing cash that could otherwise
be used to invest elsewhere. The general equation for the hold value of the
option at any time before the expiration day is
</p>

<p>
\[e^{-r} \left[ \tilde{p} \; V_u + (1 - \tilde{p}) V_d \right].\]
</p>

<p>
Let’s look specifically at the node where the stock value is $199. We’ll assume
a safe interest rate of 3.6 % annually, which translates to 0.01 % daily.<span><sup>7</sup> In
the texts I’ve read, 4 % is commonly assumed, but more accurate estimations can
be derived from <abbr>us</abbr> Treasury bills and similar extremely low-risk interest
rates.</span> The value of holding on to the option is, then
</p>

<p>
\[0.9999 \left[ \tilde{p} \; 26.97 + (1 - \tilde{p}) 11.36 \right]\]
</p>

<p>
and now we only need to know what \(\tilde{p}\) is. That variable looks and
behaves a lot like a probability, but it’s not. There’s an arbitrage argument
that fixes the value of \(\tilde{p}\) to
</p>

<p>
\[\tilde{p} = \frac{e^r - e^{-\sigma}}{e^\sigma - e^{-\sigma}}\]
</p>

<p>
where \(\sigma\) is the same time step volatility we assumed when creating the
tree – in our case, 4 %. This makes \(\tilde{p} = 0.491\), and with this, we can
compute the hold value of the option when the underlying is $199:
</p>

<ul>
<li>Hold value: $19.03</li>
<li>Exercise value: $19.01</li>
</ul>

<p>
The value of the option at any point in time is the maximum of the hold value
and the exercise value. So we replace the stock value of $199 in the tree with
the option value of $19.03. We perform the same calculation for the other nodes
in day two.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-06.png" alt="nvidia-prediction-06.png"/>
</p>

<p>
and then we do the same for the day before that, then before that, etc., until
we get to day zero.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-07.png" alt="nvidia-prediction-07.png"/>
</p>

<p>
We learn that if someone asks us on day zero to buy a call option with a strike
price of $180 and expiry three days later, when the underlying stock currently
trades for $184, and has an expected daily volatility of 0.04, then we should be
willing to pay $7.38 for that option.
</p>

<p>
What’s weird is this number has <i>nothing</i> to do with the probability we are
assigning to up or down movements. Go through the calculations again. We never
involved any probability in the calculation of the price. Although I won’t go
through the argument – see Shreve’s excellent <i>Stochastic Calculus for
Finance</i><span><sup>8</sup> <i>Stochastic Calculus for Finance I: The Binomial Asset Pricing
Model</i>; Shreve; Springer; 2005.</span> for that – this price for the option is based
on what it would cost to hedge the option with a portfolio of safe investments,
borrowing, and long or short positions in the underlying stock.
</p>

<p>
Even without going through the detailed theory, we can fairly quickly verify
that this is indeed how options are priced. Above, we made educated guesses as
to the safe interest rate, a reasonable volatility, etc. We calculated with a
spot price of $184, a strike price of $180, and expiry three days out. We got an
option price of $7.38.
</p>

<p>
At the time of writing, the Nvidia stock trades at $184.94. It has options that
expire in four days. The ones with a strike price of $180 currently sell for
$6.20. That’s incredibly close, given the rough estimations and the slight
mismatch in duration.<span><sup>9</sup> The main inaccuracy comes from the volatility we used
to construct the tree. The actual volatility of the Nvidia stock on such short
time periods and small differences in price is lower.</span>
</p>
</div>
</section>
<section id="outline-container-backing-the-implied-volatility-out-of-the-option-price">

<div id="text-org24a35e8">
<p>
When we constructed the tree above, we assumed a daily volatility of 4 %. If
we write code that takes the volatility as a parameter and computes the option
price for that volatility, we can try various volatilities until we find one
where our price matches the market price for that option.
</p>

<p>
We write the following code to perform the price calculation faster than we can
do it manually.<span><sup>10</sup> Note that we don’t actually construct the full binomial
tree. We can compute the value of the underlying stock at any node given only
its coordinates, and the option value only depends on the next time step in a
way that lets us optimise the computation with dynamic programming.</span>
</p>

<p><label>In[1]:</label></p><div>
<pre><span>import</span>           <span>Control.Monad.ST</span>
<span>import</span>           <span>Data.Foldable</span>       (forM_)
<span>import</span> <span>qualified</span> <span>Data.Vector</span>         <span>as</span> <span>Vector</span>
<span>import</span> <span>qualified</span> <span>Data.Vector.Mutable</span> <span>as</span> <span>Vector</span>

<span>-- | Given the current price of the underlying,</span>
<span>-- and the duration (in days) and strike price</span>
<span>-- of the option, take a daily volatility and</span>
<span>-- compute the option value.</span>
<span>option_value</span> <span>::</span> <span>Double</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>Double</span>
<span>option_value</span> spot duration strike sigma <span>=</span>
  <span>let</span>
    <span>-- </span><span>Shorthand: u = e^σ</span>
    u <span>=</span> exp sigma
    <span>-- </span><span>Shorthand: d = e^(−σ)</span>
    d <span>=</span> exp (negate sigma)
    <span>-- </span><span>Assuming yearly safe interest of 4 %</span>
    <span>-- </span><span>this is the weighting factor tilde-p.</span>
    p <span>=</span> (exp 0.00016 <span>-</span> d) <span>/</span> (u <span>-</span> d)
    <span>-- </span><span>The value of the underlying stock at</span>
    <span>-- </span><span>day t, node i.</span>
    s t i <span>=</span> spot <span>*</span> u<span>^</span>i <span>*</span> d<span>^</span>(t<span>-</span>i)
    <span>-- </span><span>The exercise value of the option depends</span>
    <span>-- </span><span>only on the strike and the price of the</span>
    <span>-- </span><span>underlying stock.</span>
    v_e t i <span>=</span> max 0 (s t i <span>-</span> strike)
    <span>-- </span><span>The hold value of the option depends on</span>
    <span>-- </span><span>the two possible future values of the</span>
    <span>-- </span><span>option v_d and v_u.</span>
    v_h v_d v_u <span>=</span>
      exp (negate 0.00016)
      <span>*</span> (p <span>*</span> v_u <span>+</span> (1<span>-</span>p) <span>*</span> v_d)
  <span>in</span>
    runST <span>$</span> <span>do</span>
      <span>-- </span><span>Create a mutable vector.</span>
      nodes <span>&lt;-</span> Vector.new (duration <span>+</span> 1)
      <span>-- </span><span>Fill the vector with the exercise value</span>
      <span>-- </span><span>on the expiration day.</span>
      forM_ [0 <span>..</span> duration] <span>$</span> <span>\</span>i <span>-&gt;</span>
        Vector.write nodes i (v_e duration i)
      <span>-- </span><span>Walk the tree backwards from the day</span>
      <span>-- </span><span>before expiration.</span>
      forM_ (reverse [0 <span>..</span> duration <span>-</span> 1]) <span>$</span> <span>\</span>t <span>-&gt;</span> <span>do</span>
        <span>-- </span><span>For each node, calculate hold value</span>
        <span>-- </span><span>based on option value in the next</span>
        <span>-- </span><span>time step (which was just calculated)</span>
        <span>-- </span><span>in the iteration before.</span>
        forM_ [0 <span>..</span> t] <span>$</span> <span>\</span>i <span>-&gt;</span> <span>do</span>
          v_d <span>&lt;-</span> Vector.read nodes i
          v_u <span>&lt;-</span> Vector.read nodes (i<span>+</span>1)
          <span>-- </span><span>Set the value of the option to the</span>
          <span>-- </span><span>highest of the exercise and hold</span>
          <span>-- </span><span>values.</span>
          Vector.write nodes i <span>$</span> max
            (v_e t i)
            (v_h v_d v_u)
      <span>-- </span><span>Get the value of the option at day 0.</span>
      Vector.read nodes 0

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span>
  print (option_value 184.94 31 170 0.04)
</pre>
</div>

<p>
Here we are valuing a 31-day call option for Nvidia, with a strike price of
$170. The market price is $18.68, but our code returns $24.74. This means our
guess for the implied daily volatility of 4 % is too high. If we try various
values for the volatility, we’ll eventually find that 2.2 % leads to an option
price of $18.53, which is fairly close to the market price. This daily
volatility corresponds to a yearly volatility of 35 %. If we look up other
people’s calculations for the 30-day at-the-money implied volatility of the
Nvidia stock, we’ll find they’re at something like 36 %. Definitely close
enough.
</p>

<p>
For answering the question about Nvidia dropping below $100, we don’t want the
30-day at-the-money volatility, though, but the 340-day far out-of-the-money
volatility.
</p>

<p>
The 340-day $100 strike call options sell for $92.90 in the market. To get that
price we need to feed our model a daily volatility of 3.1 %. In other words, the
340-day $100 strike call options imply a daily volatility of 3.1 %. Because
options so far out of the money are more thinly traded, we might want to confirm
this volatility by computing it for other options with nearby strike prices.
</p>

<table>


<colgroup>
<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Strike price</th>
<th scope="col">Implied daily volatility</th>
</tr>
</thead>
<tbody>
<tr>
<td>$80</td>
<td>3.5 %</td>
</tr>

<tr>
<td>$90</td>
<td>3.2 %</td>
</tr>

<tr>
<td>$100</td>
<td>3.1 %</td>
</tr>

<tr>
<td>$110</td>
<td>3.1 %</td>
</tr>

<tr>
<td>$120</td>
<td>3.0 %</td>
</tr>
</tbody>
</table>

<p>
We expect the implied volatility to go up as the strike price is further out of
the money, which it does. It seems that 3.1 % is a reasonable implied volatility
for such large movements.
</p>
</div>
</section>
<section id="outline-container-running-the-model-forward-to-get-a-probability">

<div id="text-org943a8a6">
<p>
The forecasting question asks whether the Nvidia stock price will close below
$100 on <i>any day</i> in 2026. This amounts to asking “which paths in the binomial
tree constructed from a $σ$=3.1 % go through nodes that are smaller than
$100”? We can probably answer this analytically, but easier is to run the
binomial model forward: start at the root of the binomial tree, flip a coin with
probability \(\tilde{p}\), then move up or down according to it. Continue until
either the $100 barrier is crossed, or the end of the 340-day period is reached.
Count the number of barrier crossings.
</p>

<p>
Here’s the crude code that does that.<span><sup>11</sup> The <code>evaluate</code> function seems an awful
lot like a sort of fold. We could probably rewrite it as a fold over chunks.</span>
</p>

<p><label>In[2]:</label></p><div>
<pre><span>-- | Use the infinite stream of uniformly random</span>
<span>-- numbers to compute the option-implied chance</span>
<span>-- of the spot price going below barrier within</span>
<span>-- duration days, with implied volatility sigma.</span>
<span>below_barrier</span> <span>::</span> [<span>Double</span>] <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>Double</span> <span>-&gt;</span> <span>Double</span>
<span>below_barrier</span> numbers spot duration barrier sigma <span>=</span>
  <span>let</span>
    iterations <span>=</span> 5000
    u <span>=</span> exp sigma
    d <span>=</span> exp (negate sigma)
    p <span>=</span> (exp 0.00016 <span>-</span> d) <span>/</span> (u <span>-</span> d)
    <span>-- </span><span>Convert random numbers to returns.</span>
    returns <span>=</span> numbers <span>&lt;&amp;&gt;</span> <span>\</span>x <span>-&gt;</span>
      <span>if</span> x <span>&lt;=</span> p <span>then</span> u <span>else</span> d
    <span>-- </span><span>Use the first duration entries of rrs to</span>
    <span>-- </span><span>simulate price movements. Record if it</span>
    <span>-- </span><span>passed the barrier, then continue</span>
    <span>-- </span><span>with another iteration.</span>
    evaluate rrs belows i <span>=</span>
      <span>let</span>
        <span>-- </span><span>Get duration returns from rrs, save</span>
        <span>-- </span><span>the rest for next iteration.</span>
        (rs, ts) <span>=</span> splitAt duration rrs
        <span>-- </span><span>Compute full path of stock price.</span>
        values <span>=</span> scanl (<span>*</span>) spot rs
        <span>-- </span><span>Check if any below the barrier.</span>
        result <span>=</span>
          <span>if</span> any (<span>&lt;=</span> barrier) values <span>then</span>
            belows <span>+</span> 1
          <span>else</span>
            belows
      <span>in</span>
        <span>-- </span><span>If we&#39;ve run through all iterations</span>
        <span>-- </span><span>return the result. Otherwise iterate</span>
        <span>-- </span><span>once more.</span>
        <span>if</span> i <span>==</span> 0 <span>then</span>
          result<span>/</span>iterations
        <span>else</span>
          evaluate ts result (i<span>-</span>1)
  <span>in</span>
    evaluate returns 0 (iterations<span>-</span>1)
</pre>
</div>

<p>
We’ll call this in the main function with the implied volatility we figured out
from the options prices.
</p>

<p><label>In[3]:</label></p><div>
<pre><span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
  print (option_value 184.94 340 100 0.031)
  numbers <span>&lt;-</span> Random.randoms <span>&lt;$&gt;</span> Random.newStdGen
  print (below_barrier numbers 184.94 340 100 0.031)
</pre>
</div>

<p>
Doing this, we’ll find that the probability of crossing the barrier of $100 is
somewhere in the region of 24 %. That sounds remarkably high!
</p>

<p>
The reason it’s so high is we’ve pretended that \(\tilde{p}\) is a probability,
when it’s not. The value of \(\tilde{p}\) is in fact inspired by the real
probability, but it is computed as if <a href="https://entropicthoughts.com/the-misunderstood-kelly-criterion.html">the Kelly criterion</a> didn’t exist, which
means compared to the real probability, \(\tilde{p}\) is inflated for bad
outcomes.<span><sup>12</sup> I have a fuzzy image in my head of how this happens, but it’s not
clear enough to explain to someone else. Other people sometimes say \(\tilde{p}\)
is a <i>risk neutral</i> probability, i.e. what would be the probability of the
outcome if we pretend everyone in the market is risk neutral rather than risk
averse. Of course, all of this risk aversion stuff is just the applied Kelly
criterion, so I think this whole discussion of risk neutrality is a distraction
rather than intuition.</span>
</p>
</div>
</section>
<section id="outline-container-correcting-the-fake-probability-into-a-real-one">

<div id="text-org6a177a3">
<p>
The Bank of England has published a method<span><sup>13</sup> <i>Working Paper No. 455:
Estimating probability distributions of future asset prices: empirical
transformations from option-implied risk-neutral to real-world density
functions</i>; Vincent-Humphreys &amp; Noss; 2012.</span> to convert option-implied
probabilities into real ones. For one equity-like index, they use this
calibration curve.
</p>


<p><img src="https://entropicthoughts.com/image/nvidia-prediction-08.svg" alt="nvidia-prediction-08.svg"/>
</p>

<p>
This is the cumulative distribution function of the <i>beta</i> distribution. The
effect of this particular calibration is to pull down the estimated probability
of losses (which is higher than realistic in the option-implied probabilities).
The beta distribution is difficult to implement in code, but we can approximate
this one fairly well with a third-degree polynomial.
</p>

<p><label>In[4]:</label></p><div>
<pre><span>adjust_probability</span> <span>::</span> <span>Double</span> <span>-&gt;</span> <span>Double</span>
<span>adjust_probability</span> p <span>=</span>
  <span>-- </span><span>This approximates a regularised incomplete</span>
  <span>-- </span><span>beta function with parameters (1.56, 1.31).</span>
  0.284 <span>*</span> p <span>+</span> 1.625 <span>*</span> p<span>^</span>2 <span>-</span> 0.909 <span>*</span> p<span>^</span>3
</pre>
</div>

<p>
Since we are just reusing the parameters the Bank of England fit to an equity
index, we are already running this calibration with significant uncertainty, so
we might as well approximate the function too.
</p>

<p>
If we plug the probability through this approximation, we get a probability of
14 %. This is probably still too high (I suspect if we calibrated the beta
function against past returns of the Nvidia stock specifically, the calibration
curve would end up more aggressive), but it is a much better forecast than zero
percent. In the end, maybe the truth is somewhere in between: let’s do 10 %.
</p>
</div>
</section>

            </div></div>
  </body>
</html>
