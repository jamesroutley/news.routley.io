<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2024/09/07/conservative-gc-can-be-faster-than-precise-gc">Original</a>
    <h1>Conservative GC can be faster than precise GC</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><article><div><p>Should your garbage collector be precise or conservative?  The
prevailing wisdom is that precise is always better.  Conservative GC can
retain more objects than strictly necessary, making GC slow: GC has to
more frequently, and it has to trace a larger heap on each collection.
However the calculus is not as straightforward as most people think, and
indeed there are some reasons to expect that conservative root-finding
can result in faster systems.</p><p>(I have made / relayed some of these arguments before but I feel like a
dedicated article can make a contribution here.)</p><h3>problem precision</h3><p>Let us assume that by <i>conservative GC</i> we mean conservative
root-finding, in which the collector assumes that any integer on the
stack that happens to be a heap address indicates a reference on the
object containing that address.  The address doesn’t have to be at the
start of the object.  Assume that objects on the heap are traced
precisely; contrast to BDW-GC which generally traces both the stack and
the heap conservatively.  Assume a collector that will pin referents of
conservative roots, but in which objects not referred to by a
conservative root can be moved, as in <a href="https://dl.acm.org/doi/10.1145/2660193.2660198">Conservative
Immix</a> or Whippet’s
<a href="https://github.com/wingo/whippet/blob/main/doc/collector-mmc.md#conservative-stack-scanning"><tt>stack-conservative-mmc</tt>
collector</a>.</p><p>With that out of the way, let’s look at some reasons why conservative GC
might be faster than precise GC.</p><h3>smaller lifetimes</h3><p>A compiler that does precise root-finding will typically output a
side-table indicating which slots in a stack frame hold references to
heap objects.  These lifetimes aren’t always precise, in the sense that
although they precisely enumerate heap references, those heap references
might actually not be used in the continuation of the stack frame.  When
GC occurs, it might mark more objects as live than are actually live,
which is the imputed disadvantage of conservative collectors.</p><p>This is most obviously the case when you need to explicitly register
roots with some kind of handle API: the handle will typically be kept
live until the scope ends, but that might be an overapproximation of
lifetime.  A compiler that can assume conservative stack scanning may
well exhibit more precision than it would if it needed to emit stack
maps.</p><h3>no run-time overhead</h3><p>For generated code, stack maps are great.  But if a compiler needs to
call out to C++ or something, it needs to precisely track roots in a
<a href="https://github.com/v8/v8/blob/main/src/handles/handles.h">run-time data
structure</a>.
This is overhead, and conservative collectors avoid it.</p><h3>smaller stack frames</h3><p>A compiler may partition spill space on a stack into a part that
contains pointers to the heap and a part containing numbers or other
unboxed data.  This may lead to larger stack sizes than if you could
just re-use a slot for two purposes, if the lifetimes don’t overlap.  A
similar concern applies for compilers that partition registers.</p><h3>no stack maps</h3><p>The need to emit stack maps is annoying for a compiler and makes
binaries bigger.  Of course it’s necessary for precise roots.  But then
there is additional overhead when tracing the stack: for each frame on
the stack, you need to look up the stack map for the return
continuation, which takes time.  It may be faster to just test if words
on the stack might be pointers to the heap.</p><h3>unconstrained compiler</h3><p>Having to make stack maps is a constraint imposed on the compiler.
Maybe if you don’t need them, the compiler could do a better job, or you
could use a different compiler entirely.  A conservative compiler can sometimes have better codegen, for example by the use of interior pointers.</p><h3>anecdotal evidence</h3><p>The <a href="https://dl.acm.org/doi/10.1145/2660193.2660198">Conservative Immix</a>
paper shows that conservative stack scanning can beat precise scanning
in some cases.  I have reproduced these results with
<a href="https://github.com/wingo/whippet/blob/main/doc/collector-mmc.md#conservative-stack-scanning"><tt>parallel-stack-conservative-mmc</tt> compared to
<tt>parallel-mmc</tt></a>.
It’s small—maybe a percent—but it was a surprising result to me and I
thought others might want to know.</p><p>Also, Apple’s JavaScriptCore uses conservative stack scanning, and <a href="https://wingolog.org/archives/2023/12/07/the-last-5-years-of-v8s-garbage-collector">V8 is looking at switching to it</a>.  Funny, right?</p><h3>conclusion</h3><p>When it comes to designing a system with GC, don’t count out
conservative stack scanning; the tradeoffs don’t obviously go one way or the other, and conservative scanning might be the right engineering choice for your system.</p></div><section><section><h3><label for="comment">Leave a Reply</label></h3></section></section></article></div></div>
  </body>
</html>
