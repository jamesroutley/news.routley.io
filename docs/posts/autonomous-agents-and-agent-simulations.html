<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.langchain.dev/agents-round/">Original</a>
    <h1>Autonomous Agents and Agent Simulations</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        

            <figure>
                <img srcset="https://images.unsplash.com/photo-1569087682520-45253cc2e0ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHNweXxlbnwwfHx8fDE2ODE4ODQ2NDE&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=300 300w,
                            https://images.unsplash.com/photo-1569087682520-45253cc2e0ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHNweXxlbnwwfHx8fDE2ODE4ODQ2NDE&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=600 600w,
                            https://images.unsplash.com/photo-1569087682520-45253cc2e0ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHNweXxlbnwwfHx8fDE2ODE4ODQ2NDE&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=1000 1000w,
                            https://images.unsplash.com/photo-1569087682520-45253cc2e0ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHNweXxlbnwwfHx8fDE2ODE4ODQ2NDE&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://images.unsplash.com/photo-1569087682520-45253cc2e0ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDF8fHNweXxlbnwwfHx8fDE2ODE4ODQ2NDE&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Autonomous Agents &amp; Agent Simulations"/>
                    <figcaption>Photo by <a href="https://unsplash.com/@chrisyangchrisfilm?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Chris Yang</a> / <a href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Unsplash</a></figcaption>
            </figure>

    </header>

    <section>
        <p>Over the past two weeks, there has been a massive increase in using LLMs in an agentic manner. Specifically, projects like <a href="https://github.com/Significant-Gravitas/Auto-GPT">AutoGPT</a>, <a href="https://github.com/yoheinakajima/babyagi">BabyAGI</a>, <a href="https://github.com/lightaime/camel">CAMEL</a>, and <a href="https://arxiv.org/abs/2304.03442">Generative Agents</a> have popped up. The LangChain community has now implemented some parts of all of those projects in the LangChain framework. While researching and implementing these projects, we’ve tried to best understand what the differences between them are and what the novel features of each are. This blog is an explanation of what we’ve learned.</p><p>Note: this is a fairly technical blog. It assumes some familiarity with LangChain and these related projects. If you are not familiar with these projects, it may be helpful to read a more introductory piece (like <a href="https://t.co/vgZhvKhscG">this fantastic one</a> by Sophia Yang).</p><p><strong>TL;DR:</strong></p><ul><li><strong>The “<a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents.html">autonomous agents</a>” projects (BabyAGI, AutoGPT) are largely novel in their long-term objectives, which necessitate new types of planning techniques and a different use of memory.</strong></li><li><strong>The “<a href="https://python.langchain.com/en/latest/use_cases/agent_simulations.html">agent simulation</a>” projects (CAMEL, Generative Agents) are largely novel for their simulation environments and long-term memory that reflects and adapts based on events.</strong></li></ul><p>We also discuss what parts of each project we’ve replicated in the LangChain framework, and why we chose those parts. Implementing these in the LangChain framework has the benefits of:</p><ul><li>Allowing easy switching between <a href="https://python.langchain.com/en/latest/modules/models.html">LLM providers</a></li><li>Allowing easy switching of <a href="https://python.langchain.com/en/latest/modules/indexes/vectorstores.html">VectorStore providers</a> (or, <a href="https://python.langchain.com/en/latest/modules/indexes/retrievers.html">alternative retrieval methods</a>)</li><li>Allowing connectivity to LangChain’s collection of <a href="https://python.langchain.com/en/latest/modules/agents/tools.html">tools</a></li><li>Allowing connectivity to the LangChain ecosystem in general</li></ul><h2 id="background">Background</h2><p>First, let’s start with some background context. What are “agents” and why are they important? For this discussion, we will use LangChain nomenclature, although it’s worth noting that this field is so new there’s no super standard terminology.</p><p>Agents generally refer to the idea of using a language model as a reasoning engine and connecting it to two key components: tools and memory.</p><p>Tools help connect the LLM to other sources of data or computation. Examples of tools include search engines, APIs, and other datastores. Tools are useful because LLMs only have knowledge of what they were trained on. This knowledge can quickly get out-of-date. In order to overcome this limitations, tools can fetch up-to-date data and insert it as context into the prompt. Tools can also be used to take actions (e.g. run code, modify files, etc), and the outcome of that action can then be observed by the LLM and factored into their decision on what to do next.</p><p>Memory helps the agent remember previous interactions. These interactions can either be with other entities (humans or other agents) or with tools. These memories can either be short term (e.g. a list of the previous 5 tool usages) or long term (tool usages from the past that seem most similar to the current situation).</p><p>Within LangChain, we refer to an “Agent” as the LLM that decides what actions to take; “Tools” as the actions an Agent can take; “Memory” the act of pulling in previous events, and an AgentExecutor as the logic for running an Agent in a while-loop until some stopping criteria is met.</p><p>The stereotypical LangChain Agent is based on the <a href="https://arxiv.org/abs/2210.03629">Reasoning and Acting (ReAct) framework</a> proposed by Yao et all in November of 2022. This approach is characterized by the following algorithm:</p><ol><li>User gives an agent a task</li><li><strong>Thought</strong>: The agent “thinks” about what to do</li><li><strong>Action/Action Input</strong>: The agent decides what action to take (aka what tool to use) and what the input to that tool should be</li><li><strong>Observation</strong>: The output of the tool</li><li>Repeat steps 2-4 until the Agent “thinks” it is done</li></ol><p>When discussing other implementations and frameworks we will compare them to this algorithm.</p><h2 id="autogpt">AutoGPT</h2><p><strong>Links:</strong></p><ul><li><a href="https://github.com/Significant-Gravitas/Auto-GPT">Original Repo</a></li><li><a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents/autogpt.html">LangChain Implementation</a></li></ul><p><strong>What is novel about this project?</strong></p><p>The main differences between the AutoGPT project and traditional LangChain agents can be attributed to different objectives. In AutoGPT, the goals are often more open ended and long running. This means that AutoGPT has a different AgentExecutor and different way of doing memory (both of which are more optimized for long running tasks). Previously, memory of agents in LangChain had two forms:</p><ul><li>Memory of agent steps: this was done by keeping a list of intermediate agent steps relevant for that task, and passing the full list to the LLM calls</li><li>Memory of system: this remembered the final inputs and outputs (but forgot the intermediate agent steps)</li></ul><p>Because AutoGPT is more long running, passing the full list of agent steps to the LLM call is no longer feasible. Instead, AutoGPT added a retrieval-based memory over the intermediate agent steps. Under the hood, this retrieval-based memory is doing doing semantic search over embeddings, using a VectorStore. Note that LangChain has this type of retrieval-based memory, but it was previously applied to <strong>user-agent</strong> interactions, not <a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents/autogpt.html">agent-tool</a> interations.</p><p><strong>How did we incorporate this into LangChain?</strong></p><p>We added a version of this to <code>langchain.experimental</code> - a place where we are putting more experimental and newer code while we figure out the proper abstractions. Specifically, we’ve implemented the prompt templating logic used, as well as <code>while</code> loop used to run the agent. We’ve made it compatible with LangChain LLM wrappers, LangChain VectorStores, and LangChain tools.</p><p>We’ve also created <a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents/autogpt.html">this</a> notebook showing how to use it.</p><h2 id="babyagi">BabyAGI</h2><p><strong>Links:</strong></p><ul><li><a href="https://github.com/yoheinakajima/babyagi">Original Repo</a></li><li><a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents/baby_agi.html">LangChain Implementation</a></li><li><a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents/baby_agi_with_agent.html">LangChain Implementation with Tools</a></li></ul><p><strong>What is novel about this project?</strong></p><p>The BabyAGI project differs from traditional LangChain Agents in the following regards:</p><ul><li>Similar to AutoGPT, it applies retrieval-based memory to intermediate agent-tool steps.</li><li>It has separate planning and execution steps, where it plans a sequence of actions all at once (rather than just the next one)</li></ul><p>Similar to AutoGPT, BabyAGI is designed for more long running tasks, which lead to both of these differences.</p><p>Let’s expand on the second point, since that is one of the more important and substantial differences. In the traditional LangChain Agent framework (and the AutoGPT framework), the agent thinks one step ahead at a time. For a given state of the world it think about what its next immediate action should be, and then does that action. </p><p>BabyAGI differs in that it explicitly plans out a sequence of actions. It then executes on the first one, and then uses the result of that to do another planning step and update it’s task list. Our intuition is that this enables it to execute better on more complex and involved tasks, by using the planning steps essentially as a state tracking system.. We’ve observed (anecdotally) that for tasks that require many steps, the traditional LangChain Agent can sometimes forget its original objective after a few steps, so planning all the steps ahead of time could be beneficial.</p><p><strong>How did we incorporate this into LangChain?</strong></p><p>Similar to AutoGPT, we added this to <code>langchain.experimental</code>. Specifically, we’ve implemented the prompt templating logic used, as well as <code>while</code> loop used to run the agent. We’ve made it compatible with LangChain LLM wrappers, LangChain vectorstores, and LangChain tools.</p><h2 id="camel">Camel</h2><p><strong>Links:</strong></p><ul><li><a href="https://ghli.org/camel.pdf">Original Paper</a></li><li><a href="https://github.com/lightaime/camel">Original Repo</a></li><li><a href="https://python.langchain.com/en/latest/use_cases/agent_simulations/camel_role_playing.html">LangChain Implementation</a></li></ul><p><strong>What is novel about this project?</strong></p><p>The main novelty in this project comes from taking two agents, each with their own personality, and having them chat with each other. In this sense there are two novel components: the idea of having two agents interact with each other in a collaborative manner, and the specific simulation environment.</p><p>The idea of two agents interacting is not entirely new. Given the modular nature of LangChain, we have long been proponents of having agents use other agents as tools. However, what is novel about this type of interaction is that the two agents are poised as equals - in previous LangChain implementations there has always been one agent which calls the other as a tool, in a <a href="https://twitter.com/mathemagic1an/status/1645096275392745477?s=20">&#34;stacking&#34;</a> approach. This idea of putting both agents on equal footing, rather than having one use the other as a tool strikes a chord of being particularly interesting to see evolving behavior emerge.</p><p>Note that these agents can have different tools available to them and could be specialized around that. For example, you could have one agent that is armed with tools needed for coding, another with tools needed for interacting with linear, etc. So it is still possible to achieve a &#34;stacking&#34; effect (where you have different agents responsible for different things).</p><p>The second novel component was the particular simulation environment. This is a two sided conversation, and is not terribly complex but still the first implementation of this in a research setting we have seen.</p><p><strong>How did we incorporate this into LangChain?</strong></p><p>We added a notebook, largely reflecting the simulation environment (having two agents chatting with each other). We may look into making this simulation environment more available off-the-shelf in the future.</p><h2 id="generative-agents">Generative Agents</h2><p><strong>Links:</strong></p><ul><li><a href="https://arxiv.org/abs/2304.03442">Original Paper</a></li><li><a href="https://python.langchain.com/en/latest/modules/indexes/retrievers/examples/time_weighted_vectorstore.html">Retriever Implementation</a></li><li><a href="https://arxiv.org/abs/2304.03442"></a><a href="https://python.langchain.com/en/latest/use_cases/agent_simulations/characters.html">LangChain Memory Implementation</a></li></ul><p><strong>What is novel about this project?</strong></p><p>There are two novel (and fairly complex) aspects to this project. The first is the simulation environment, which consists of 25 different agents. This seems fairly specific, and very complex, so we did not dive into this too much. The other aspect that is novel is the <strong>long-term memory</strong> they created for these agents.</p><p>We did a deep dive on this <a href="https://twitter.com/hwchase17/status/1647987713449263106?s=20">earlier this week</a>. The agents’ memory is made up of:</p><ol><li>Importance reflection steps, to give each observation an importance score. This score can be used in retrieval down the line to fetch particularly important memories and ignore basic ones</li><li>Reflection steps, to “pause” and think about what generalizations the agent has learned. These reflections can then be retrieved alongside normal memories. This reflection step can serve to condense information and observe patterns in recent memories</li><li>A retriever that combines recency, relevancy to the situation, and importance. This can allow for surfacing of memories that similar to the situation at hand, happened a short while ago, and particularly important. All of these seem to be attributes that naturally reflect how we as human “retrieve” memories</li></ol><p>All of these memory components are fairly novel, and extremely exciting to us.</p><p><strong>How did we incorporate this into LangChain?</strong></p><p>The retriever logic seemed generalizable so we added it as a <code><a href="https://python.langchain.com/en/latest/modules/indexes/retrievers/examples/time_weighted_vectorstore.html">TimeWeightedVectorStoreRetriever</a></code>.</p><p>We added a <a href="https://python.langchain.com/en/latest/use_cases/agent_simulations/characters.html">notebook</a> showing off how to use the reflection steps + the new retriever to replicate part of the setup the paper described.</p><p>The simulation environment seemed complex and not super generalizable so we did not do any thing there.</p><h2 id="conclusion">Conclusion</h2><p>All of these projects rightfully garnered a lot of attention. We view them as two separate categories:</p><ul><li><a href="https://python.langchain.com/en/latest/use_cases/autonomous_agents.html">Autonomous Agents</a>, which have improved planning abilities</li><li><a href="https://python.langchain.com/en/latest/use_cases/agent_simulations.html">Agent Simulations</a>, which have novel simulation environments and complex, evolving memory</li></ul><p>We’re excited to have started implementing parts of these projects in the LangChain ecosystem, and look forward to seeing how the community uses these, adds to these, and combines these 🙂</p>
    </section>


</article>
</div></div>
  </body>
</html>
