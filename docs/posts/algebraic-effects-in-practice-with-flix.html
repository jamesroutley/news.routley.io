<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.relax.software/blog/flix-effects-intro/">Original</a>
    <h1>Algebraic Effects in Practice with Flix</h1>
    
    <div id="readability-page-1" class="page"><div> <p>Algebraic effects are not just a research concept anymore. You can use them in real software, today. Here‚Äôs why you‚Äôd want to do that, in order of importance:</p>
<ol>
<li>
<p><strong>Effects make your code testable</strong></p>
<p>One of the central goals of enterprise software development. Dependency injection, mocking, architecture patterns like clean, hexagonal, DDD are all meant to tackle this. Effects solve this elegantly by separating the ‚Äúwhat‚Äù from the ‚Äúhow‚Äù.</p>
</li>
<li>
<p><strong>Effects give immediate visibility into what your own and 3rd-party code is doing</strong></p>
<p>Supply chain attacks are real. And they will get worse with more AI slop entering our codebases. Tools like Go‚Äôs <a href="https://github.com/google/capslock">Capslock</a> fix this by following the whole chain of calls to stdlib functions. Effects provide this by design, as all effects are tracked by the type and effect system.</p>
</li>
<li>
<p><strong>Effects enable user-defined control flow abstractions</strong></p>
<p>Solving the ‚Äúwhat color is your function‚Äù problem<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. You can also leverage effects to implement Async/await, coroutines, backtracking search and other control flow patterns as user libraries without hard-coding these features into the language.</p>
</li>
</ol>
<p>Algebraic effects come from the pure functional world, serving a purpose similar to monads ‚Äî keeping track of and having control over side effects. Like monads, they enable us to write our core logic with pure functions and push side effects like IO outwards, closer to application boundaries.</p>
<p>Unlike monads, effects are easy to grasp for a regular developer and give immediate benefits when starting out. For me personally they‚Äôre a more natural abstraction for managing side effects ‚Äî after all, effects are in the name.</p>
<p>Starting out as an academic concept, algebraic effects were introduced to the world by research languages like <a href="https://github.com/matijapretnar/eff">Eff</a>, <a href="https://github.com/koka-lang/koka">Koka</a>, <a href="https://github.com/effekt-lang/effekt">Effekt</a>, <a href="https://github.com/frank-lang/frank">Frank</a>, <a href="https://links-lang.org/">Links</a>, and more recently <a href="https://github.com/jfecher/ante">Ante</a>.</p>
<p>People have also applied effects in practice, so far usually via a monad-based approach, by making libraries in established languages like Scala <a href="https://getkyo.io/">Kyo</a> / <a href="https://typelevel.org/cats-effect/">Cats Effect</a> / <a href="https://zio.dev/">ZIO</a>; Typescript <a href="https://effect.website/">Effect</a> and <a href="https://effector.dev/">Effector</a>, C# <a href="https://github.com/louthy/language-ext/">language-ext</a>, C <a href="https://github.com/koka-lang/libhandler">libhandler</a> and <a href="https://github.com/koka-lang/libmprompt">libmprompt</a>, C++ <a href="https://github.com/maciejpirog/cpp-effects">cpp-effects</a>, various Haskell libraries, etc.</p>
<p>In addition to forcing you into a monadic way of thinking, libraries implementing effects are limited by their host languages.</p>
<p>In this article, I will walk you through applying algebraic effects on a real world example using <strong><em>Flix</em></strong>, a new programming language that is built with effects from the ground up, and supports functional, logic and imperative paradigms.</p>
<hr/>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#type-and-effect-system-a-motivating-example">Type and Effect System: A Motivating Example</a></li>
<li><a href="#effect-handlers-building-intuition">Effect Handlers: Building Intuition</a></li>
<li><a href="#real-world-app-ai-movie-recommendations">Real-World App: AI movie recommendations</a></li>
<li><a href="#where-to-go-from-here">Where to Go From Here</a></li>
<li><a href="#extra-why-algebraic-effects-are-algebraic-and-how-they-relate-to-monads">Extra: Why Algebraic Effects are Algebraic and how they relate to monads</a></li>
<li><a href="#footnotes">Footnotes</a></li>
</ol>
<hr/>
<p>Currently only few languages support effects out of the box. The only one that I know of besides Flix is Unison. OCaml has a <a href="https://ocaml.org/manual/5.3/effects.html">language extension</a>, but there is <a href="https://ocamlverse.net/content/future_ocaml.html#typed-algebraic-effects">no support yet</a> in the type system. Haskell has added support for delimited continuations, but effects are still only available via <a href="https://discourse.haskell.org/t/what-happens-now-after-delimited-continuations-is-merged-to-ghc/5460/3">libraries</a>.</p>
<p>In addition to having a ‚Äútype and effect system‚Äù that improves function signatures and makes sure all effects are handled, Flix supports traits, local mutability via regions, working with immutable or mutable data, and Go/Rust-like structured concurrency. It also has a first-class Datalog integration. But I will only focus on effects here. Let‚Äôs start.</p>
<h2 id="type-and-effect-system-a-motivating-example">Type and Effect System: A Motivating Example <a href="#type-and-effect-system-a-motivating-example" title="Copy link to this section">üîó</a></h2>
<p>Imagine a function called <code>calculateSalary</code>:</p>
<pre><code><span>def</span> <span>calculateSalary</span>(<span>base_salary, bonus_percent</span>):
</code></pre>
<p>Based on the function name and the signature, one can assume it‚Äôs just a pure function that does some calculations. In a statically typed language you are also guaranteed that the function arguments and outputs will be of a certain type.</p>
<p>But even if the types are correct, nothing stops our little <code>calculateSalary()</code> from, say, sending an offensive email to your grandma<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>:</p>
<pre><code><span>def</span> <span>calculateSalary</span>(<span>base_salary, bonus_percent</span>):
    server.sendmail(<span>&#34;grandma@family.com&#34;</span>, <span>&#34;Your cookies are terrible!&#34;</span>)
    <span>return</span> base_salary * (<span>1</span> + bonus_percent/<span>100</span>)
</code></pre>
<p>If, on the other hand, you extend your type system with effects, you will see immediately in the signature that this function may do something fishy:</p>
<pre><code><span><span>def</span> <span>calculateSalary</span></span>(salary: <span>Float64</span>, percent: <span>Float64</span>): 
    <span>Float64</span> \ {Email} = {

</code></pre>
<p>Of course, in real life the issue it‚Äôs not usually about the grandma. Instead, this function could throw an exception ‚Äî still quite dangerous. If you forget to handle the exception, your app will crash. Or another very realistic scenario is that <code>calculateSalary()</code> calls a database to get some employee details for calculations, and you forgot to provide a database connection string. That can also result in an exception or a panic.</p>
<h2 id="effect-handlers-building-intuition">Effect Handlers: Building Intuition <a href="#effect-handlers-building-intuition" title="Copy link to this section">üîó</a></h2>
<p>The job of the type and effect system is not just to improve our function signatures. It‚Äôs also making sure all the effects are handled somewhere. This is where effect handlers come in.</p>
<p>Usually when people talk about algebraic effects what they‚Äôre actually talking about is effect handlers. If you know exceptions, effect handlers are super easy to understand. Here‚Äôs a Jenga analogy:</p>
<p>Imagine the call stack is a Jenga tower. New blocks are carefully added each time you call a function.</p>
<figure><img src="https://www.relax.software/jenga.jpg" loading="lazy" decoding="async" alt="jenga"/><a href="https://unsplash.com/photos/a-person-holding-a-stack-of-wooden-blocks-sSJ38KiAEp8"><figcaption>Saurav S, Unsplash</figcaption></a></figure>
<p>When an exception is thrown, your whole nice Jenga tower gets destroyed, all the way up to the catch() block. The catch block can safely handle the error, but the stack is unwinded, meaning you lose all of the state you had in your program before throwing the exception. You have to build your tower again, from scratch.</p>
<p>When using effect handlers you can actually go back to your original computation after the handler is done handling the effect. The handler can also return some values back to your program, and it can even resume multiple times with different return values. You also still have the option of not resuming at all and aborting the program ‚Äî that would be the effect equivalent of exceptions.</p>
<p>Back to the Jenga analogy: if your tower is about to fall down, with effects you can freeze it mid-collapse. You then call someone for help (handler), and they decide whether to let the tower fall, magically restore it to the previous statlte. Or even hand you different blocks to try the same move (call the continuation) again, possibly multiple times with different inputs. Your Jenga tower ends up looking more like a fork or a tree, with multiple different copies of your blocks branching out at some point from the base.</p>
<p>To make this more concrete, let‚Äôs start by reproducing exceptions with effects. Here‚Äôs how a try/catch looks like in Python:</p>
<pre><code><span>def</span> <span>divide</span>(<span>x, y</span>):
    <span>try</span>:
        <span>return</span> x / y
    <span>except</span> ZeroDivisionError:
        <span>print</span>(<span>&#34;Division by zero!&#34;</span>)
        <span>return</span> <span>None</span>
</code></pre>
<p>Here‚Äôs the equivalent code in Flix. We first define an Exception effect and a <code>divide()</code> function:</p>
<pre><code><span>eff</span> Exception {
    <span><span>def</span> <span>throw</span></span>(msg: <span>String</span>): Void
}

<span><span>def</span> <span>divide</span></span>(x: <span>Int32</span>, y: <span>Int32</span>): <span>Int32</span> \ Exception = 
    <span>if</span> (y == <span>0</span>) {
        Exception.<span>throw</span>(<span>&#34;Division by zero!&#34;</span>)
    } <span>else</span> {
        x / y
    }
</code></pre>
<p>And then provide a handler for this effect somewhere, <a href="https://doc.flix.dev/effect-oriented-programming.html">preferably close to <code>main()</code></a>:</p>
<pre><code><span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ <span>IO</span> = 
    <span>run</span> {
        <span>println</span>(divide(<span>10</span>, <span>0</span>))
    } <span>with</span> <span>handler</span> Exception {
        <span><span>def</span> <span>throw</span></span>(msg, _<span>resume</span>) = <span>println</span>(<span>&#34;Error: <span>${msg}</span>&#34;</span>)
    }
</code></pre>
<p>What this does is registers an effect called Exception with a method <code>throw()</code>. We then perform this effect in our function when there‚Äôs an error, similar to throwing an exception in the Python version. Control is transferred to the effect handler, which then decides how to handle the exception, similar to a <code>catch()</code> block in Python.</p>
<p>Notice we never call <code>resume()</code> from the handler. This results in the program being aborted, just like with exceptions. Graphically, this can be represented as follows:</p>
<pre>block-beta
    columns 2
    
    A[&#34;Statement 1&#34;] space:1
    B[&#34;Statement 2&#34;] space:1
    C[&#34;Statement 3&#34;] space:1
    D[&#34;Perform Effect&#34;] space:1
    space:1 E[&#34;Handle Effect&#34;]
    space:1 F[&#34;Process &amp; Exit&#34;]
    space:1 space:1
    
    D --&gt; E
    
    style D fill:#ffcccc,color:#000
    style E fill:#ccffcc,color:#000
    style F fill:#ccffcc,color:#000</pre>
<p>So far so good, but this is not much different from Python. To really take full advantage of effect handlers, we can use <code>resume()</code> to return to the original computation and proceed from the line after the effect was performed:</p>
<pre><code><span>eff</span> ResumableException {
    <span><span>def</span> <span>askForInput</span></span>(): <span>Int32</span>
}

<span><span>def</span> <span>divide</span></span>(x: <span>Int32</span>, y: <span>Int32</span>): <span>Int32</span> \ ResumableException = 
    <span>if</span> (y == <span>0</span>) {
        <span>let</span> newY = ResumableException.askForInput();
        x / newY
    } <span>else</span> {
        x / y
    }

<span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ <span>IO</span> = 
    <span>run</span> {
        <span>println</span>(divide(<span>10</span>, <span>0</span>))
    } <span>with</span> <span>handler</span> ResumableException {
        <span><span>def</span> <span>askForInput</span></span>(_, <span>resume</span>) = {
            <span>println</span>(<span>&#34;Enter a new divisor:&#34;</span>);
            <span>resume</span>(<span>5</span>) 
        }
    }
</code></pre>
<pre>block-beta
    columns 2
    
    A[&#34;Statement 1&#34;] space:1
    B[&#34;Statement 2&#34;] space:1
    C[&#34;Statement 3&#34;] space:1
    D[&#34;Perform Effect&#34;] space:1
    space:1 E[&#34;Handle Effect&#34;]
    space:1 F[&#34;Resume&#34;]
    space:1 space:1
    G[&#34;Statement 4&#34;] space:1
    H[&#34;Statement 5&#34;] space:1
    I[&#34;Complete&#34;] space:1
    
    D --&gt; E
    F --&gt; G
    
    style D fill:#ffcccc,color:#000
    style E fill:#ccffcc,color:#000
    style F fill:#ffffcc,color:#000</pre>
<p>I called the effect <code>ResumableException</code> here, but it‚Äôs not really an exception anymore, because the program continues normally.</p>
<p>At this point we can use this power bestowed on us by effects and handlers to roll our own Async/await:</p>
<pre><code><span>eff</span> Async {
    <span><span>def</span> <span>await</span></span>(url: <span>String</span>): <span>String</span>
}

<span><span>def</span> <span>fetchData</span></span>(): <span>String</span> \ Async = 
    Async.await(<span>&#34;https://api.example.com/data&#34;</span>)

<span><span>def</span> <span>processData</span></span>(): <span>String</span> \ Async = {
    <span>let</span> data = fetchData();
    <span>&#34;processed: <span>${data}</span>&#34;</span>
}

<span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ <span>IO</span> = 
    <span>run</span> {
        <span>let</span> result = processData();
        <span>println</span>(result)
    } <span>with</span> <span>handler</span> Async {
        <span><span>def</span> <span>await</span></span>(url, <span>resume</span>) = {
            
            <span>let</span> result = <span>&#34;data from <span>${url}</span>&#34;</span>;
            <span>resume</span>(result)
        }
    }
</code></pre>
<p>See how easy that was? This approach also avoids function coloring, since we didn‚Äôt need to use special keywords anywhere. Here‚Äôs a graphic version:</p>
<pre>block-beta
    columns 2
    
    A[&#34;Statement 1&#34;] space:1
    B[&#34;Statement 2&#34;] space:1
    C[&#34;await operation&#34;] space:1
    space:1 H1[&#34;Start async work&#34;]
    space:1 H2[&#34;‚è≥ Long pause...&#34;]
    space:1 H3[&#34;‚è≥ Still waiting...&#34;]
    space:1 H4[&#34;‚úÖ Async complete&#34;]
    space:1 F[&#34;Resume with result&#34;]
    space:1 space:1
    D[&#34;Statement 3&#34;] space:1
    E[&#34;Complete&#34;] space:1
    
    C --&gt; H1
    F --&gt; D
    
    style C fill:#ffcccc,color:#000
    style H1 fill:#ccffcc,color:#000
    style H2 fill:#fff3cd,color:#000
    style H3 fill:#fff3cd,color:#000
    style H4 fill:#d1ecf1,color:#000
    style F fill:#ffffcc,color:#000
    style D fill:#e7f3ff,color:#000
    style E fill:#d4edda,color:#000</pre>
<p>That‚Äôs cool, but we can do more. Effect handlers allow you to resume multiple times:</p>
<pre><code><span>eff</span> Choose {
    <span><span>def</span> <span>choose</span></span>(): <span>Int32</span>
}

<span><span>def</span> <span>explore</span></span>(): <span>String</span> \ Choose = {
    <span>let</span> x = Choose.<span>choose</span>();
    <span>let</span> y = Choose.<span>choose</span>();
    <span>&#34;<span>${x}</span>, <span>${y}</span>&#34;</span>
}

<span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ <span>IO</span> = 
    <span>run</span> {
        <span>println</span>(explore())
    } <span>with</span> <span>handler</span> Choose {
        <span><span>def</span> <span>choose</span></span>(_, <span>resume</span>) = {
            <span>resume</span>(<span>1</span>);
            <span>resume</span>(<span>2</span>);
            <span>resume</span>(<span>3</span>)
        }
</code></pre>
<pre>block-beta
    columns 4
    
    A[&#34;Statement 1&#34;] space:1 space:1 space:1
    B[&#34;Statement 2&#34;] space:1 space:1 space:1
    C[&#34;Statement 3&#34;] space:1 space:1 space:1
    D[&#34;Perform Effect&#34;] space:1 space:1 space:1
    space:1 space:1 E[&#34;Handle Effect&#34;] space:1
    space:1 F1[&#34;Resume 1&#34;] F2[&#34;Resume 2&#34;] F3[&#34;Resume 3&#34;]
    space:1 G1[&#34;Statement 4a&#34;] G2[&#34;Statement 4b&#34;] G3[&#34;Statement 4c&#34;]
    space:1 H1[&#34;Statement 5a&#34;] H2[&#34;Statement 5b&#34;] H3[&#34;Statement 5c&#34;]
    space:1 R1[&#34;Resume to Main&#34;] R2[&#34;Resume to Main&#34;] R3[&#34;Resume to Main&#34;]
    J[&#34;Statement 6&#34;] space:1 space:1 space:1
    K[&#34;Complete&#34;] space:1 space:1 space:1
    
    D --&gt; E
    F1 --&gt; G1
    F2 --&gt; G2
    F3 --&gt; G3
    H1 --&gt; R1
    H2 --&gt; R2
    H3 --&gt; R3
    R1 --&gt; J
    R2 --&gt; J
    R3 --&gt; J
    
    style D fill:#ffcccc,color:#000
    style E fill:#ccffcc,color:#000
    style F1 fill:#ffffcc,color:#000
    style F2 fill:#ffffcc,color:#000
    style F3 fill:#ffffcc,color:#000
    style G1 fill:#e6f3ff,color:#000
    style G2 fill:#ffe6f3,color:#000
    style G3 fill:#f3ffe6,color:#000
    style H1 fill:#e6f3ff,color:#000
    style H2 fill:#ffe6f3,color:#000
    style H3 fill:#f3ffe6,color:#000
    style R1 fill:#d4edda,color:#000
    style R2 fill:#d4edda,color:#000
    style R3 fill:#d4edda,color:#000
    style J fill:#cce5ff,color:#000
    style K fill:#b3d9ff,color:#000</pre>
<p>With this, you can implement things like coroutines:</p>
<pre>block-beta
    columns 3
    
    A1[&#34;Coroutine 1: Start&#34;] space:1 A2[&#34;Coroutine 2: Start&#34;]
    B1[&#34;Statement 1&#34;] space:1 B2[&#34;Statement 1&#34;]
    C1[&#34;yield to Co2&#34;] H1[&#34;Scheduler&#34;] space:1
    space:1 space:1 C2[&#34;Statement 2&#34;]
    space:1 space:1 D2[&#34;yield to Co1&#34;]
    space:1 H2[&#34;Scheduler&#34;] space:1
    D1[&#34;Statement 2&#34;] space:1 space:1
    E1[&#34;yield to Co2&#34;] H3[&#34;Scheduler&#34;] space:1
    space:1 space:1 E2[&#34;Statement 3&#34;]
    space:1 space:1 F2[&#34;Complete&#34;]
    F1[&#34;Complete&#34;] space:1 space:1
    
    C1 --&gt; H1
    H1 --&gt; C2
    D2 --&gt; H2
    H2 --&gt; D1
    E1 --&gt; H3
    H3 --&gt; E2
    
    style C1 fill:#ffcccc,color:#000
    style D2 fill:#ffcccc,color:#000
    style E1 fill:#ffcccc,color:#000
    style H1 fill:#ccffcc,color:#000
    style H2 fill:#ccffcc,color:#000
    style H3 fill:#ccffcc,color:#000
    style A1 fill:#e6f3ff,color:#000
    style B1 fill:#e6f3ff,color:#000
    style D1 fill:#e6f3ff,color:#000
    style F1 fill:#e6f3ff,color:#000
    style A2 fill:#ffe6f3,color:#000
    style B2 fill:#ffe6f3,color:#000
    style C2 fill:#ffe6f3,color:#000
    style E2 fill:#ffe6f3,color:#000
    style F2 fill:#ffe6f3,color:#000</pre>
<p>Generators:</p>
<pre>block-beta
    columns 2
    
    A[&#34;Start generator&#34;] space:1
    B[&#34;Statement 1&#34;] space:1
    C[&#34;yield value 1&#34;] H1[&#34;Return value&#34;]
    space:1 H2[&#34;‚è∏Ô∏è Paused&#34;]
    D[&#34;next() called&#34;] H3[&#34;Resume generator&#34;]
    E[&#34;Statement 2&#34;] space:1
    F[&#34;yield value 2&#34;] H4[&#34;Return value&#34;]
    space:1 H5[&#34;‚è∏Ô∏è Paused&#34;]
    G[&#34;next() called&#34;] H6[&#34;Resume generator&#34;]
    H[&#34;Statement 3&#34;] space:1
    I[&#34;return (done)&#34;] H7[&#34;Signal complete&#34;]
    
    C --&gt; H1
    H3 --&gt; D
    F --&gt; H4
    H6 --&gt; G
    I --&gt; H7
    
    style C fill:#ffcccc,color:#000
    style F fill:#ffcccc,color:#000
    style I fill:#ffcccc,color:#000
    style H1 fill:#ccffcc,color:#000
    style H3 fill:#ffffcc,color:#000
    style H4 fill:#ccffcc,color:#000
    style H6 fill:#ffffcc,color:#000
    style H7 fill:#ccffcc,color:#000
    style H2 fill:#fff3cd,color:#000
    style H5 fill:#fff3cd,color:#000
    style D fill:#e7f3ff,color:#000
    style G fill:#e7f3ff,color:#000</pre>
<p>And backtracking search:</p>
<pre>block-beta
    columns 4
    
    A[&#34;Start search&#34;] space:1 space:1 space:1
    B[&#34;choose option&#34;] space:1 space:1 space:1
    space:1 H1[&#34;Try option 1&#34;] space:1 space:1
    space:1 space:1 C1[&#34;Explore path 1&#34;] space:1
    space:1 space:1 D1[&#34;‚ùå Dead end&#34;] space:1
    space:1 H2[&#34;Backtrack&#34;] space:1 space:1
    space:1 H3[&#34;Try option 2&#34;] space:1 space:1
    space:1 space:1 space:1 C2[&#34;Explore path 2&#34;]
    space:1 space:1 space:1 D2[&#34;‚úÖ Success!&#34;]
    E[&#34;Resume with solution&#34;] space:1 space:1 space:1
    F[&#34;Complete&#34;] space:1 space:1 space:1
    
    B --&gt; H1
    H1 --&gt; C1
    D1 --&gt; H2
    H2 --&gt; H3
    H3 --&gt; C2
    D2 --&gt; E
    
    style B fill:#ffcccc,color:#000
    style H1 fill:#ccffcc,color:#000
    style H2 fill:#f8d7da,color:#000
    style H3 fill:#ccffcc,color:#000
    style C1 fill:#fff3cd,color:#000
    style D1 fill:#f8d7da,color:#000
    style C2 fill:#d1ecf1,color:#000
    style D2 fill:#d4edda,color:#000
    style E fill:#ffffcc,color:#000
    style F fill:#d4edda,color:#000</pre>
<p>Hopefully this gives you a taste of how effect handlers work. This is just a sketch though ‚Äî you can read more on this and see examples in the <a href="https://doc.flix.dev/effects-and-handlers.html?search=Compo">Flix docs</a>.</p>
<div data-question-id="language" data-astro-cid-axuh2dpf=""> <h4 data-astro-cid-axuh2dpf="">Question</h4> <p data-astro-cid-axuh2dpf="">What&#39;s your primary programming language?</p> <p><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">TypeScript/JavaScript</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Python</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Java or other JVM e.g Scala/Kotlin</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">C#</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">C++/C</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">PHP</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Go</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Rust</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Other</span> </label> </p> <div data-astro-cid-axuh2dpf=""> <p><span data-astro-cid-axuh2dpf="">‚úì</span> Thanks for your input!
</p> </div> </div>  
<div><p><span>These questions help direct new content. Want to get notified when something new is posted?</span></p> </div>
<p>Defining our own control flow abstractions is great, but most of the time regular async/await and/or coroutines are enough for the job.</p>
<p>What is extremely useful for daily programming is that effects let you separate the declaration of the effect (the operation, or the effect ‚Äúconstructor‚Äù) from it‚Äôs implementation, defined by the effect handler.</p>
<p>Add some effect definitions:</p>
<pre><code><span>eff</span> Database {
    <span><span>def</span> <span>getUser</span></span>(id: <span>Int32</span>): Option[User],
    <span><span>def</span> <span>saveUser</span></span>(user: User): <span>Unit</span>
}
</code></pre>
<p>Then use these definitions to perform effects in your code:</p>
<pre><code><span><span>def</span> <span>updateUserEmail</span></span>(userId: <span>Int32</span>, newEmail: <span>String</span>): <span>Result</span>[<span>String</span>, User] \ {Database} = {
    <span>match</span> Database.getUser(userId) {
        <span>case</span> <span>Some</span>(user) =&gt; {
            <span>let</span> updatedUser = {user | email = newEmail};
            Database.saveUser(updatedUser);
            <span>Ok</span>(updatedUser)
        }
        <span>case</span> <span>None</span> =&gt; {
            <span>Err</span>(<span>&#34;User not found&#34;</span>)
        }
    }
}
</code></pre>
<p>This replaces the need for dependency injection, since you can provide different handlers for these database operations in production vs testing:</p>
<pre><code><span><span>def</span> <span>main</span></span>(): <span>Unit</span> \\ <span>IO</span> = { 
    <span>run</span> {
        updateUserEmail(<span>123</span>, <span>&#34;new@example.com&#34;</span>)
    } <span>with</span> <span>handler</span> Database {
        <span><span>def</span> <span>getUser</span></span>(id, <span>resume</span>) = {
		        
            <span>resume</span>(user)
        }
        <span><span>def</span> <span>saveUser</span></span>(user, <span>resume</span>) = {
		        
            <span>resume</span>()
        }
    }
}

<span><span>def</span> <span>testUpdateUserEmail</span></span>(): <span>Unit</span> = { 
    <span>let</span> testUser = {id = <span>123</span>, email = <span>&#34;old@example.com&#34;</span>};
    <span>run</span> {
        <span>let</span> result = updateUserEmail(<span>123</span>, <span>&#34;new@example.com&#34;</span>);
        assert(result == <span>Ok</span>({testUser | email = <span>&#34;new@example.com&#34;</span>}))
    } <span>with</span> <span>handler</span> Database {
        <span><span>def</span> <span>getUser</span></span>(id, <span>resume</span>) = <span>resume</span>(<span>Some</span>(testUser))
        <span><span>def</span> <span>saveUser</span></span>(user, <span>resume</span>) = {
            assert(user.email == <span>&#34;new@example.com&#34;</span>);
            <span>resume</span>()
        }
    
}
</code></pre>
<p>In my opinion, the biggest advantage that effect handlers give is that they abstract away the patterns associated with DDD, Clean Architecture, Hexagonal architecture, etc. commonly found in enterprise code.</p>
<p>All these architectures give you some sort of way to isolate your core logic, which should be pure, from infrastructure and app logic, with deals with external dependencies. But you have to commit to an architecture and the whole team has to be disciplined enough to stick to for this to work.</p>
<p>Using effects encourages separating the definition of effect operations from implementation by default, meaning you don‚Äôt really need these architecture patterns anymore.</p>
<p>This is great, since relying on team discipline exclusively rarely works. It also saves a bunch of time otherwise spent on bike shedding.</p>
<p>Effect handlers also allow you to easily install stubs, which you can use to create quick test cases without boilerplate, just by swapping handlers:</p>
<pre><code><span><span>def</span> <span>testErrorConditions</span></span>(): <span>Unit</span> = {
    <span>run</span> {
        <span>let</span> result = updateUserEmail(<span>123</span>, <span>&#34;new@example.com&#34;</span>);
        assert(result == <span>Err</span>(<span>&#34;User not found&#34;</span>))
    } <span>with</span> <span>handler</span> Database {
        <span><span>def</span> <span>getUser</span></span>(_, <span>resume</span>) = <span>resume</span>(<span>None</span>) 
        <span><span>def</span> <span>saveUser</span></span>(_, <span>resume</span>) = <span>resume</span>()             
    }
}

<span><span>def</span> <span>testSlowDatabase</span></span>(): <span>Unit</span> = {
    <span>run</span> {
        <span>let</span> result = updateUserEmail(<span>123</span>, <span>&#34;new@example.com&#34;</span>);
        assert(result.isOk())
    } <span>with</span> <span>handler</span> Database {
        <span><span>def</span> <span>getUser</span></span>(id, <span>resume</span>) = {
            Thread.sleep(<span>100</span>);  
            <span>resume</span>(<span>Some</span>({id = id, email = <span>&#34;old@example.com&#34;</span>}))
        }
        <span><span>def</span> <span>saveUser</span></span>(user, <span>resume</span>) = {
            Thread.sleep(<span>50</span>);   
            <span>resume</span>()
        }
    }
}
</code></pre>
<p>You can even make a handler that records all interactions instead of executing them. There are many possibilities here.</p>
<h2 id="real-world-app-ai-movie-recommendations">Real-World App: AI movie recommendations <a href="#real-world-app-ai-movie-recommendations" title="Copy link to this section">üîó</a></h2>
<p>To bring this all together, let‚Äôs make a real application using effects.</p>
<p>Our app will fetch some movie data from TheMovieDB, and then use an LLM to recommend some movies based on user preferences provided from the console.</p>
<p>Flix <a href="https://doc.flix.dev/interoperability.html">interoperates with the JVM</a>, meaning we can call code from Java, Kotlin, Scala, etc.</p>
<p>First, let‚Äôs define the two custom effects we will need: MovieAPI and LLM:</p>
<pre><code><span>eff</span> MovieAPI {
    <span><span>def</span> <span>getPopularMovies</span></span>(): <span>String</span>
}

<span>eff</span> LLM {
    <span><span>def</span> <span>recommend</span></span>(movies: <span>String</span>, preferences: <span>String</span>): <span>String</span>
}
</code></pre>
<p>We can then perform the effects in main like so, providing some basic handlers that use the Flix‚Äôs stdlib HTTP client:</p>
<pre><code><span><span>def</span> <span>getRecommendation</span></span>(preferences: <span>String</span>): <span>String</span> \ {MovieAPI, LLM} = {
    <span>let</span> movies = MovieAPI.getPopularMovies();
    LLM.recommend(movies, preferences)
}

<span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ {Net, <span>IO</span>} = 
    <span>run</span> {
        <span>let</span> suggestion = getRecommendation(<span>&#34;action movies&#34;</span>);
        <span>println</span>(suggestion)
    } <span>with</span> <span>handler</span> MovieAPI {
        <span><span>def</span> <span>getPopularMovies</span></span>(_, <span>resume</span>) = {
            <span>let</span> response = HttpWithResult.get(<span>&#34;https://api.themoviedb.org/3/movie/popular&#34;</span>, <span>Map</span>.empty());
            <span>match</span> response {
                <span>case</span> <span>Result</span>.<span>Ok</span>(resp) =&gt; <span>resume</span>(Http.Response.body(resp))
                <span>case</span> <span>Result</span>.<span>Err</span>(_) =&gt; <span>resume</span>(<span>&#34;[]&#34;</span>)
            }
        }
    } <span>with</span> <span>handler</span> LLM {
        <span><span>def</span> <span>recommend</span></span>(movies, prefs, <span>resume</span>) = {
            <span>let</span> prompt = <span>&#34;Movies: <span>${movies}</span>. User likes: <span>${prefs}</span>. Recommend one movie.&#34;</span>;
            <span>let</span> response = HttpWithResult.post(<span>&#34;https://api.openai.com/v1/completions&#34;</span>, <span>Map</span>.empty(), prompt);
            <span>match</span> response {
                <span>case</span> <span>Result</span>.<span>Ok</span>(resp) =&gt; <span>resume</span>(Http.Response.body(resp))
                <span>case</span> <span>Result</span>.<span>Err</span>(_) =&gt; <span>resume</span>(<span>&#34;Try watching a classic!&#34;</span>)
            }
        }
    } <span>with</span> HttpWithResult.runWithIO
</code></pre>
<p>Notice that both effects are quite generic. So we can easily swap either the movie API or the LLM provider without touching anything in the core logic:</p>
<pre><code>
<span>with</span> <span>handler</span> MovieAPI {
    <span><span>def</span> <span>getPopularMovies</span></span>(_, <span>resume</span>) = {
        <span>let</span> response = HttpWithResult.get(<span>&#34;https://api.imdb.com/popular&#34;</span>, <span>Map</span>.empty());
        
    }
}


<span>with</span> <span>handler</span> LLM {
    <span><span>def</span> <span>recommend</span></span>(movies, prefs, <span>resume</span>) = {
        <span>let</span> response = HttpWithResult.post(<span>&#34;https://api.anthropic.com/v1/messages&#34;</span>, <span>Map</span>.empty(), prompt);
        
    }
}
</code></pre>
<p>To get the user input we will need to include the standard Console effect:</p>
<pre><code><span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ {Net, <span>IO</span>} = 
    <span>run</span> {
        Console.<span>println</span>(<span>&#34;What movie genres do you enjoy?&#34;</span>);
        <span>let</span> preferences = Console.readln();
        <span>let</span> suggestion = getRecommendation(preferences);
        Console.<span>println</span>(<span>&#34;Recommendation: <span>${suggestion}</span>&#34;</span>)
    } <span>with</span> <span>handler</span> MovieAPI {  }
      <span>with</span> <span>handler</span> LLM {  }
      <span>with</span> Console.runWithIO
      <span>with</span> HttpWithResult.runWithIO
</code></pre>
<p>We can also add some basic logs using the standard Logger effect:</p>
<pre><code><span><span>def</span> <span>getRecommendation</span></span>(preferences: <span>String</span>): <span>String</span> \ {MovieAPI, LLM, Logger} = {
    Logger.info(<span>&#34;Fetching popular movies...&#34;</span>);
    <span>let</span> movies = MovieAPI.getPopularMovies();
    Logger.info(<span>&#34;Getting LLM recommendation...&#34;</span>);
    LLM.recommend(movies, preferences)
}

<span><span>def</span> <span>main</span></span>(): <span>Unit</span> \ {Net, <span>IO</span>} = 
    <span>run</span> {
        
    } <span>with</span> <span>handler</span> MovieAPI {  }
      <span>with</span> <span>handler</span> LLM {  }
      <span>with</span> Console.runWithIO
      <span>with</span> Logger.runWithIO
      <span>with</span> HttpWithResult.runWithIO
</code></pre>
<p>That‚Äôs it! Let‚Äôs run the app and test it manually like so:</p>
<pre><code> flix run Main.flix
What movie genres <span>do</span> you enjoy?
&gt; sci-fi horror
[INFO] Fetching popular movies...
[INFO] Getting LLM recommendation...
Recommendation: Based on your interest <span>in</span> sci-fi horror, I recommend <span>&#34;Alien&#34;</span> - a perfect blend of both genres!
</code></pre>
<p>We can also easily write tests for the core logic by providing test handlers for our movie and LLM effects:</p>
<pre><code><span><span>def</span> <span>testRecommendation</span></span>(): <span>String</span> = 
    <span>run</span> {
        getRecommendation(<span>&#34;comedy&#34;</span>)
    } <span>with</span> <span>handler</span> MovieAPI {
        <span><span>def</span> <span>getPopularMovies</span></span>(_, <span>resume</span>) = {
            <span>resume</span>(<span>&#34;&#34;</span><span>&#34;[{&#34;</span>title<span>&#34;: &#34;</span>The Grand Budapest Hotel<span>&#34;, &#34;</span>genre<span>&#34;: &#34;</span>comedy<span>&#34;}]&#34;</span><span>&#34;&#34;</span>)
        }
    } <span>with</span> <span>handler</span> LLM {
        <span><span>def</span> <span>recommend</span></span>(movies, prefs, <span>resume</span>) = {
            <span>resume</span>(<span>&#34;I recommend The Grand Budapest Hotel - perfect for comedy lovers!&#34;</span>)
        }
    } <span>with</span> <span>handler</span> Logger {
        <span><span>def</span> <span>log</span></span>(_, _, <span>resume</span>) = <span>resume</span>()  
    }

<span><span>def</span> <span>runTests</span></span>(): <span>Unit</span> \ <span>IO</span> = {
    <span>let</span> result = testRecommendation();
    <span>println</span>(<span>&#34;Test result: <span>${result}</span>&#34;</span>)
}
</code></pre>
<h2 id="where-to-go-from-here">Where to Go From Here <a href="#where-to-go-from-here" title="Copy link to this section">üîó</a></h2>
<p><strong>Read the Flix docs</strong></p>
<p>Especially on cool features like effect polymorphism, effect exclusion etc. Check out code examples in the repo</p>
<p><strong>Join the community and contribute with libraries</strong></p>
<p>The Flix compiler and stdlib are quite feature-rich at this point, and having JVM interop means you have all the essentials you need to write practical code. But there are still very few pure Flix libraries. So it‚Äôs very valuable to contribute some. The ideas I can think of are, for example, rebuilding standard things like Web frameworks in an effect oriented way,. Or taking advantage of the unique feature set in Flix to build something entirely new.</p>
<p><strong>Explore effect-oriented programming</strong></p>
<p>While I personally like Flix and can recommend it to others, there are other ways you can use effects for real-world software. If you‚Äôre in Typescript or Scala, try out Effect or ZIO/Kyo/Cats. If you‚Äôre looking for other languages that support effects natively, and you‚Äôre not afraid of Haskell-like syntax, check out <a href="https://www.unison-lang.org/">Unison</a>. They have a bunch of other concepts I find cool, like a better distributed computing model and the code being content-addressed.</p>
<p>Thanks for reading! I hope this article was useful. Hit me up if you have questions or feedback, and check out my website, where I‚Äôm exploring sustainable tech and coding practices: relax.software</p>
<div data-question-id="what-to-post" data-astro-cid-axuh2dpf=""> <h4 data-astro-cid-axuh2dpf="">Question</h4> <p data-astro-cid-axuh2dpf="">What should I write about next?</p> <p><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">More on Effect-oriented programming</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">More on the Flix programming language</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Comparison of languages and libraries with effects support</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">General correct and maintainable software content</span> </label> </p> <div data-astro-cid-axuh2dpf=""> <p><span data-astro-cid-axuh2dpf="">‚úì</span> Thanks for your input!
</p> </div> </div>  
<div><p><span>These questions help direct new content. Want to get notified when something new is posted?</span></p> </div>
<h2 id="extra-why-algebraic-effects-are-algebraic-and-how-they-relate-to-monads">Extra: Why Algebraic Effects are Algebraic and how they relate to monads <a href="#extra-why-algebraic-effects-are-algebraic-and-how-they-relate-to-monads" title="Copy link to this section">üîó</a></h2>
<p>Okay, practical people have left the room. Following sections are nerds-only.</p>
<p>For some reason, all the content I‚Äôve been reading on algebraic effects uses this term a lot, but no one explains why specifically they‚Äôre called ‚Äúalgebraic‚Äù. So I did some digging.</p>
<p>Turns out, algebraic effects are ‚Äúalgebraic‚Äù because they can be described with laws and equations, <a href="https://arxiv.org/abs/1807.05923">like in algebra</a> ‚Äî the kind we learn at school. Which is I guess why they‚Äôre easier to grasp than monads ‚Äî unlike algebra, you usually don‚Äôt study category theory in high school.</p>
<p>But the algebraic part only applies to the effect ‚Äúconstructors‚Äù, i.e the operations themselves like <code>get()</code> or <code>put()</code> for the state effect.</p>
<p>Effect handlers, on the other hand, are not algebraic at all, which can be a bit confusing. But it makes sense if you think about it ‚Äî the purpose of handlers is to act as ‚Äúdeconstructors‚Äù, interpreting our algebraic effect operations by means of things that cannot be described by algebraic equations alone, such as <a href="https://www.sciencedirect.com/science/article/pii/S0304397506009157">continuations</a> .</p>
<p>In fact, effect handlers are often (but not always) implemented via delimited continuations. There are also other, static/lexically scoped and maybe more performant approaches being explored, <a href="https://dl.acm.org/doi/10.1145/3689770">such as this one</a></p>
<p>‚ÄúReal‚Äù algebraic effects don‚Äôt require monads. Monads and algebraic effects are two different concepts tackling similar problems. One is <a href="https://homepages.inf.ed.ac.uk/slindley/papers/effmondel-jfp.pdf">expressible</a> in terms of the other, but algebraic effects are arguably more flexible.</p>
<p>You could actually implement algebraic effects using a continuation monad. If we don‚Äôt care about types, effects are perfectly <a href="https://arxiv.org/abs/1610.09161">expressible</a> with monads and vice versa</p>
<p>The problems appear when we introduce types into the picture. In a properly typed world, you can‚Äôt actually reproduce the same expressiveness you get with effects using monads. You‚Äôll end up breaking the type system or reducing expressiveness at some point.</p>
<p>Effects are, in this sense, more ‚Äúpowerful‚Äù than monads with their natural type system: you can express infinitely many computations with them. E.g if you use a <code>tick()</code> effect and you do a bunch of sequential <code>tick()</code> s, the result will be a distinct computation each time. With monads and their natural type system the set of computations you could express is finite.</p>
<p>Additionally, with monads you commit to a specific interpretation of an effect in advance, while effects completely decouple effect definition from it‚Äôs implementation.</p>
<p>Finally, effects are easier to compose than monads. With monad transformers you quickly hit the wall having to define a bunch of different combinations that each have distinct semantics. Effects compose naturally.</p>
<p>So while effect libraries in languages like Typescript and Scala are able to express effects using monads<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>, and the behavior could be identical at runtime, this cannot replace having an actual type and effect system, with effects being properly typed.</p>
<div data-question-id="learning-style" data-astro-cid-axuh2dpf=""> <h4 data-astro-cid-axuh2dpf="">Question</h4> <p data-astro-cid-axuh2dpf="">How do you usually learn about new things?</p> <p><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Technical articles (like this one)</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Books</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Screencasts or videos</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Courses, bootcamps or workshops</span> </label><label data-astro-cid-axuh2dpf="">  <span data-astro-cid-axuh2dpf="">Other</span> </label> </p> <div data-astro-cid-axuh2dpf=""> <p><span data-astro-cid-axuh2dpf="">‚úì</span> Thanks for your input!
</p> </div> </div>  
<hr/>

 </div></div>
  </body>
</html>
