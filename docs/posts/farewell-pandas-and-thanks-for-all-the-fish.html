<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ibis-project.org/posts/farewell-pandas/">Original</a>
    <h1>Farewell Pandas, and thanks for all the fish</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-document-content">





<p><strong>TL; DR</strong>: we are deprecating the <code>pandas</code> and <code>dask</code> backends and will be removing them in version 10.0.</p>
<p>There is no feature gap between the <code>pandas</code> backend and our default DuckDB backend, and DuckDB is <em>much</em> more performant. <code>pandas</code> DataFrames will still be available as <em>format</em> for getting data to and from Ibis, we just won’t support using <code>pandas</code> to execute queries.</p>
<p>Most of the rationale below applies to the Dask backend since it has so much in common with pandas. Dask is a great project and people should continue to use it outside the Ibis context.</p>
<section id="why-pandas-and-a-bit-of-ibis-history">
<h2 data-anchor-id="why-pandas-and-a-bit-of-ibis-history">Why <code>pandas</code>? And a bit of Ibis history</h2>
<p>Way back in the early days of Ibis, there was only one backend: Impala. Not everyone used Impala (mindblowing, we know), and so it wasn’t too long until the Postgres backend was added (by the inimitable Phillip Cloud).</p>
<p>These two backends were both featureful, but there was a big problem with adoption: Want to try out Ibis? You need to install Impala or Postgres first.</p>
<p>Not an insurmountable problem, but a LOT more work than “just <code>pip install &lt;newthing&gt;</code>” – which prompted the question, how can a prospective Ibis user take the API for a spin without requiring a DBA or extra infrastructure beyond a laptop?</p>
<p>The obvious answer (at the time) was to use the only in-memory DataFrame engine around and wire up a <code>pandas</code> backend.</p>
</section>
<section id="the-agony-and-the-agony">
<h2 data-anchor-id="the-agony-and-the-agony">The agony and the agony</h2>
<p><code>pandas</code> was the best option at the time, and it allowed new users to try out Ibis. But, it never fit well into the model of data analysis that Ibis strives for. The <code>pandas</code> backend has more specialized code than any other backend, because it is so fundamentally different than all the other systems Ibis works with.</p>
<section id="deferred-vs-eager">
<h3 data-anchor-id="deferred-vs-eager">Deferred vs Eager</h3>
<p><code>pandas</code> is inherently an eager engine – every time you hit Enter you are computing an intermediate result. Ibis uses a deferred execution model, similar to what nearly all SQL backends use, that enables query planning and optimization passes.</p>
<p>Trying to make a <code>pandas</code> interface that behaves in a deferred way is hard.</p>
<p>One of the unfortunate effects of this mismatch is that, unlike our other backends, the <code>pandas</code> backend is often <em>much</em> slower than just using <code>pandas</code> directly.</p>
<p>And to provide this suboptimal experience, we have a few thousand lines of code that are only used in the <code>pandas</code> backend.</p>
</section>
<section id="nan-vs-null">
<h3 data-anchor-id="nan-vs-null"><code>NaN</code> vs <code>NULL</code></h3>
<p>The choice was made a long time ago to accept using <code>NaN</code> as the marker for missing values in <code>pandas</code>. This is because NumPy has a notion of <code>NaN</code>, but a Python <code>None</code> would lead to an <code>object</code>-dtype and poor performance.</p>
<p>Practicality beats purity, but this is a horrible decision to have to make. Ibis <em>doesn’t</em> have to make it with any other backend, because NULL indicates a missing value, and NaN is Not a Number.</p>
<p>Those are fundamentally different ideas and it is an ongoing headache for Ibis to try to pretend that they aren’t.</p>
</section>
<section id="data-types">
<h3 data-anchor-id="data-types">Data types</h3>
<p>The new Arrow-backed types in <code>pandas</code> are a great improvement and we’ll leave it at that.</p>
</section>
</section>
<section id="misleading-new-users">
<h2 data-anchor-id="misleading-new-users">Misleading new users</h2>
<p>People reach for what is familiar. When you try Ibis for the first time, we’re asking you to both a) try Ibis and b) pick a backend. We have defaults to try to help with this, but it can be confusing at first.</p>
<p>We have many reports from new users that “Ibis is slow”. What this almost always means is that they tried the <code>pandas</code> backend (because they know <code>pandas</code>) and they are having a less-than-great time.</p>
<p>If they tried DuckDB or Polars, instead, they would have a much easier time getting things going.</p>
</section>
<section id="feature-parity">
<h2 data-anchor-id="feature-parity">Feature parity</h2>
<p>This is the one of the strongest reasons to drop the <code>pandas</code> backend – it is redundant. The DuckDB backend can seamlessly query pandas DataFrames, supports several flavors of UDF, and can read and write parquet, CSV, JSON, and other formats.</p>
<p>There is a reason DuckDB is our default backend: it’s easy to install, it runs locally, it’s blazing fast, and it interacts well with the Python ecosystem. Those are all the reasons we added <code>pandas</code> as a backend in the first place, but with the added benefit of blazing-fast results, and no type-system headaches.</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i></i> Back to top</a></div></div>
  </body>
</html>
