<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lsd.gnunet.org/lsd0004/draft-schanzen-r5n.html">Original</a>
    <h1>R5N - Obfuscated mesh routing on hostile networks.</h1>
    
    <div id="readability-page-1" class="page">

<table>
<thead><tr>
<td>Internet-Draft</td>
<td>The R5N Distributed Hash Table</td>
<td>July 2024</td>
</tr></thead>
<tfoot><tr>
<td>Schanzenbach, et al.</td>
<td>Expires 22 January 2025</td>
<td>[Page]</td>
</tr></tfoot>
</table>



<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract">Abstract</a></h2>
<p id="section-abstract-1">
        This document contains the R<sup>5</sup>N DHT technical specification.
        R<sup>5</sup>N is a secure distributed hash table (DHT) routing algorithm
        and data structure for decentralized applications.
        It features an open peer-to-peer overlay routing mechanism which supports ad-hoc
        permissionless participation and support for topologies in restricted-route
        environments. Optionally, the paths data takes through the overlay can be
 recorded, allowing decentralized applications to use the DHT to discover routes.<a href="#section-abstract-1">¶</a></p>
<p id="section-abstract-2">
        This document defines the normative wire format of protocol messages,
        routing algorithms, cryptographic routines and security considerations for
        use by implementers.<a href="#section-abstract-2">¶</a></p>
<p id="section-abstract-3">
        This specification was developed outside the IETF and does not have IETF
        consensus. It is published here to guide implementation of R<sup>5</sup>N and to
        ensure interoperability among implementations including the pre-existing
        GNUnet implementation.<a href="#section-abstract-3">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as &#34;work in progress.&#34;<a href="#section-boilerplate.1-3">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 22 January 2025.<a href="#section-boilerplate.1-4">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust&#39;s Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2">¶</a></p>
</section>
</div>

<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1">1. </a><a href="#name-introduction">Introduction</a>
      </h2>
<p id="section-1-1">
        This specification describes the protocol of R<sup>5</sup>N.
        R<sup>5</sup>N is a Distributed Hash Table (DHT). The name is an acronym for
        &#34;randomized recursive routing for restricted-route
        networks&#34; and its first academic description can be found in
        <span>[<a href="#R5N">R5N</a>]</span>.<a href="#section-1-1">¶</a></p>
<p id="section-1-2">
        DHTs are a key data structure for the construction of decentralized applications
        and generally provide a robust and efficient means to distribute the
        storage and retrieval of key-value pairs.<a href="#section-1-2">¶</a></p>
<p id="section-1-3">
        The core idea behind R<sup>5</sup>N is to combine a randomized routing
        algorithm with an efficient, deterministic closest-peer algorithm.
        This allows us to construct an algorithm that is able to escape and circumvent
        restricted route environments while at the same time allow for a logarithmically bounded
        routing complexity.<a href="#section-1-3">¶</a></p>
<p id="section-1-4">
        R<sup>5</sup>N also includes advanced features like recording the path a
 key-value pair took
        through the network, response filters and on-path application-specific data
        validation.<a href="#section-1-4">¶</a></p>
<p id="section-1-5">
        This document defines the normative wire format of peer-to-peer
        messages, routing algorithms, cryptographic routines and security
        considerations for use by implementors.<a href="#section-1-5">¶</a></p>
<section id="section-1.1">
        <h3 id="name-requirements-notation">
<a href="#section-1.1">1.1. </a><a href="#name-requirements-notation">Requirements Notation</a>
        </h3>
<p id="section-1.1-1">
          The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;,
          &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and
          &#34;OPTIONAL&#34; in this document are to be interpreted as described in
          BCP 14 <span>[<a href="#RFC2119">RFC2119</a>]</span> <span>[<a href="#RFC8174">RFC8174</a>]</span> when, and only
          when, they appear in all capitals, as shown here.<a href="#section-1.1-1">¶</a></p>
</section>
<section id="section-1.2">
        <h3 id="name-system-model">
<a href="#section-1.2">1.2. </a><a href="#name-system-model">System Model</a>
        </h3>
<p id="section-1.2-1">
          DHTs usually operate as overlay networks consisting of peers
          communicating over the existing Internet. Hence canonical
          DHT designs often assume that the IP protocol provides the
          peers of the overlay with unrestricted end-to-end pairwise
          connectivity.  However, in practice firewalls and network
          address translation (NAT) <span>[<a href="#RFC2663">RFC2663</a>]</span> make it
          difficult for peers operating on consumer end-devices to
          directly communicate, especially in the absence of core
          network infrastructure enabling NAT traversal via protocols
          such as interactive connectivity establishment (ICE) <span>[<a href="#RFC5245">RFC5245</a>]</span>.<a href="#section-1.2-1">¶</a></p>
<p id="section-1.2-2">
          Furthermore, not all peer-to-peer networks consistently
          operate over the Internet, such as mobile ad-hoc networks
          (MANETs). While routing protocols have been designed for
          such networks (<span>[<a href="#RFC3561">RFC3561</a>]</span>) these generally
          have issues with security in the presence of malicious
          participants, as they vulnerable to impersonation attacks.
          The usual solution to these issues is to assert that the
          entire MANET is a closed network and to require
          authentication on all control messages. In contrast, the
          system model for R<sup>5</sup>N is that of an open network
          without any kind of authorities that could restrict access
          only to trusted participants.<a href="#section-1.2-2">¶</a></p>
</section>
<section id="section-1.3">
        <h3 id="name-security-model">
<a href="#section-1.3">1.3. </a><a href="#name-security-model">Security Model</a>
        </h3>
<p id="section-1.3-1">
          We assume that the network is open and thus a fraction of
          the participating peers is malicious.  Malicious peers may
          create, alter, delay or drop messages.  We also assume that
          an adversary can control (or fake) many peers <span>[<a href="#Sybil">Sybil</a>]</span>, thus any kind
          of voting or punishment of malicious peers would be rather
          pointless.<a href="#section-1.3-1">¶</a></p>
<p id="section-1.3-2">
          Honest peers are expected to establish and maintain many
          connections. We assume that as a result the adversary is
          generally unable to prevent honest peers from maintaining a
          sufficient number of direct connections with other honest
          peers to achieve acceptable performance.  As the number of
          malicious peers and their connections increases, performance
          of the system should gracefully degrade, and
          only collapse for peers that an adversary has fully isolated
          from the benign network.<a href="#section-1.3-2">¶</a></p>
<p id="section-1.3-3">
          The main security objectives are to provide honest nodes
          correct results and to limit the propagation of invalid
          data.  Invalid data includes both invalid key-value pairs as
          well as invalid routing path data if such routing meta-data
          is present. While malicious nodes may make up arbitrary
          key-value pairs and paths within the adversary&#39;s domain,
          invalid key-value pairs are ideally
          discarded at the first honest node, and path data
          honestly state entry- and exit-points
          from the honest network into the subset of malicious nodes.<a href="#section-1.3-3">¶</a></p>
<p id="section-1.3-4">
          Malicious nodes may attempt to exhaust the
          storage capacity of honest nodes by distributing well-formed
          (but possibly otherwise useless) application data. We assume
          that storage space is relatively cheap compared to bandwidth
          and that honest nodes also frequently re-publish the useful
          data that they publish. As a result, an adversary
          may reduce the effectiveness and longevity of
          data cached in the DHT, but is assumed to not be able to
          effectively prevent publication and retrieval of application
          data by honest nodes.<a href="#section-1.3-4">¶</a></p>
</section>
</section>
</div>
<div id="terminology">
<section id="section-2">
      <h2 id="name-terminology">
<a href="#section-2">2. </a><a href="#name-terminology">Terminology</a>
      </h2>
<span></span><dl id="section-2-1">
        <dt id="section-2-1.1">Address</dt>
        <dd id="section-2-1.2">
          <p id="section-2-1.2.1">
         An <em>address</em> is a UTF-8 <span>[<a href="#RFC3629">RFC3629</a>]</span> string which can be
         used to address a <em>peer</em> through the Underlay (<a href="#underlay">Section 5</a>).
         The format of an address is not enforced by this specification,
         but it is expected that in most cases the address is a URI <span>[<a href="#RFC3986">RFC3986</a>]</span>.<a href="#section-2-1.2.1">¶</a></p>
</dd>
        <dd></dd>
<dt id="section-2-1.3">Applications</dt>
        <dd id="section-2-1.4">
          <em>Applications</em> are higher-layer components which directly use the
        <em>Core Operations</em>.
        Possible <em>applications</em> include the GNU Name System
        <span>[<a href="#RFC9498">RFC9498</a>]</span> and the GNUnet
 Confidential Ad-hoc Decentralized End-to-End Transport (CADET)
        <span>[<a href="#cadet">cadet</a>]</span>.<a href="#section-2-1.4">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.5">Core Operations</dt>
        <dd id="section-2-1.6">
        The <em>Core Operations</em> provide an interface to the
        core operations of the DHT overlay to <em>applications</em>.
        This includes storing <em>blocks</em> in the DHT and retrieving
 <em>blocks</em> from the DHT.<a href="#section-2-1.6">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.7">Block</dt>
        <dd id="section-2-1.8">
        Variable-size unit of payload stored in the DHT
        under a <em>key</em>.
        In the context of &#34;key-value stores&#34; this
        refers to &#34;value&#34; stored under a <em>key</em>.<a href="#section-2-1.8">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.9">Block Storage</dt>
        <dd id="section-2-1.10">
        The <em>block storage</em> component is used to persist and manage
        <em>blocks</em> stored by <em>peers</em>.
        It includes logic for enforcing storage quotas, caching strategies and
        block validation.<a href="#section-2-1.10">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.11">Block Type</dt>
        <dd id="section-2-1.12">
        A unique 32-bit value identifying the data format of a <em>block</em>.
        <em>Block types</em> are public and applications that require
        application-specific
        block payloads are expected to register one or more
        block types in the GANA Block-Type registry
        (<a href="#gana_block_type">Section 11.1</a>) and provide a specification
        of the associated block operations (<a href="#block_functions">Section 8.1</a>) to implementors of
        R<sup>5</sup>N.<a href="#section-2-1.12">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.13">Bootstrapping</dt>
        <dd id="section-2-1.14">
          <em>Bootstrapping</em> is the process of establishing a connection
 to the peer-to-peer network.
        It requires an initial, non-empty set of reachable <em>peers</em> and corresponding
        <em>addresses</em> supported by the implementation to connect to.<a href="#section-2-1.14">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.15">Initiator</dt>
        <dd id="section-2-1.16">
        The <em>peer</em> that initially creates and sends a DHT protocol message (<a href="#p2p_hello">Section 7.2</a>,
        <a href="#p2p_put">Section 7.3</a>, <a href="#p2p_get">Section 7.4</a>, <a href="#p2p_result">Section 7.5</a>).<a href="#section-2-1.16">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.17">HELLO block</dt>
        <dd id="section-2-1.18">
        A <code>HELLO block</code> is a type of <em>block</em> that is used to store and retrieve <em>addresses</em> of a <em>peer</em>.
        It are used by the peer discovery mechanism in <a href="#find_peer">Section 6.2</a>.<a href="#section-2-1.18">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.19">HELLO URL</dt>
        <dd id="section-2-1.20">
          <code>HELLO</code> URLs are <code>HELLO</code> blocks represented as URLs.
        They are used for out-of-band exchanges of <em>peer</em> <em>addresses</em>
        and for signalling address updates to <em>neighbours</em>.
        Implementation details of HELLO URLs and examples are found in <a href="#hello_url">Appendix C</a>.<a href="#section-2-1.20">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.21">Key</dt>
        <dd id="section-2-1.22">
        512-bit identifier of a location in the DHT. Multiple <code>blocks</code> can be
        stored under the same <em>key</em>. A <em>peer identity</em> is also a <code>key</code>.
        In the context of &#34;key-value stores&#34; this
        refers to &#34;key&#34; under which <em>blocks</em> are stored.<a href="#section-2-1.22">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.23">Message Processing</dt>
        <dd id="section-2-1.24">
        The <em>message processing</em> component of the DHT implementation processes
 requests from and generates responses to <em>applications</em>
 and the <em>underlay interface</em>.<a href="#section-2-1.24">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.25">Neighbor</dt>
        <dd id="section-2-1.26">
        A neighbor is a <em>peer</em> which is directly able to communicate
        with our <em>peer</em> via the <em>underlay interface</em>.<a href="#section-2-1.26">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.27">Peer</dt>
        <dd id="section-2-1.28">
        A host that is participating in the overlay by running an implementation
 of the DHT protocol.  Each participating host is
        responsible for holding some portion of the data that has been
        stored in the overlay, and they are responsible for routing
        messages on behalf of other <em>peers</em> as needed by the <em>routing
        algorithm</em>.<a href="#section-2-1.28">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.29">Peer Identity</dt>
        <dd id="section-2-1.30">
        The <em>peer identity</em> is the identifier used on the overlay
        to identify a <em>peer</em>.  It is a SHA-512 hash of the <em>peer public key</em>.<a href="#section-2-1.30">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.31">Peer Public Key</dt>
        <dd id="section-2-1.32">
        The <em>peer public key</em> is the key used to authenticate
        a <em>peer</em> in the underlay.<a href="#section-2-1.32">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.33">Routing</dt>
        <dd id="section-2-1.34">
        The <em>routing</em> component includes the routing table as well as
        routing and <em>peer</em> selection logic. It facilitates the R<sup>5</sup>N routing
        algorithm with required data structures and algorithms.<a href="#section-2-1.34">¶</a>
</dd>
        <dd></dd>
<dt id="section-2-1.35">Underlay Interface</dt>
        <dd id="section-2-1.36">
        The <em>underlay interface</em> is an abstraction layer on top of the
        supported links of a <em>peer</em>. Peers may be linked by a variety of
        different transports, including &#34;classical&#34; protocols such as
        TCP, UDP and TLS or higher-layer protocols such as GNUnet, I2P or Tor.<a href="#section-2-1.36">¶</a>
</dd>
      <dd></dd>
</dl>
</section>
</div>
<section id="section-3">
      <h2 id="name-motivation">
<a href="#section-3">3. </a><a href="#name-motivation">Motivation</a>
      </h2>
<section id="section-3.1">
        <h3 id="name-restricted-route-topologies">
<a href="#section-3.1">3.1. </a><a href="#name-restricted-route-topologies">Restricted-route topologies</a>
        </h3>
<p id="section-3.1-1">
          Restricted-route topologies emerge when a connected underlay
          topology prevents (or restricts) direct connections between
          some of the nodes.  This commonly occurs through the use of
          NAT (<span>[<a href="#RFC2663">RFC2663</a>]</span>).  Nodes operated behind a NAT
          cause common DHT routing algorithms such as Kademlia <span>[<a href="#Kademlia">Kademlia</a>]</span> to exhibit degraded performance or even
          to fail.  While excluding such nodes is an option, this
          limits load distribution and is ineffective for some
          networks, such as MANETs.<a href="#section-3.1-1">¶</a></p>
<p id="section-3.1-2">
          In general, nodes may not be mutually reachable (for example
          due to a firewall or NAT) despite being &#34;neighbours&#34;
          according to the routing table construction algorithm of a
          particular DHT.  For example, Kademlia uses the XOR metric
          and would generally connect nodes that have peer identities
          with a small XOR distance. However, the XOR distance between
          (basically randomly assigned) peer identities is completely
          divorced from the ability of the nodes to directly
          communicate.  DHTs usually use greedy routing to store data
          at the peer(s) closest to the key.  In cases where a DHT
          cannot connect peers according to the construction rules of
          its routing algorithm, the topology may ends up with
          multiple (local) minima for a given key.  Using canonical
          greedy routing from a particular fixed location in the
          network, a node may then only be able to publish and
          retrieve data in the proximity of its local minima.<a href="#section-3.1-2">¶</a></p>
<p id="section-3.1-3">
          R<sup>5</sup>N addresses this problem by prepending a random
          walk before a classical, deterministic XOR-based routing
          algorithm is employed.  The optimal number of random hops
          taken is equal to the mixing time of the graph. The mixing
          time for various graphs is well known; for small-world
          networks <span>[<a href="#Smallworld">Smallworld</a>]</span>, the mixing time has
          been shown to be around <code>O(log n)</code> where <code>n</code>
          is the number of nodes in the network
          <span>[<a href="#Smallworldmix">Smallworldmix</a>]</span>.<a href="#section-3.1-3">¶</a></p>
<p id="section-3.1-4">
          Thus, if the network exhibits the properties of a small
          world topology <span>[<a href="#Smallworld">Smallworld</a>]</span>, a random walk of
          length <code>O(log n)</code> will cause the algorithm to land on
          a random node in the network.  Consequently, the
          deterministic part of the algorithm will encounter a random
          local minimum.  It is then possible to repeat this process
          in order to store or retrieve data in the context of all or
          at least multiple local minima.  The ideal length of the
          random walk and the number of repetitions expected to cover
          all local minima depends on the network topology.  Our
          design assumes that the benign subset of the network forms a
          small-world topology <span>[<a href="#Smallworld">Smallworld</a>]</span> and then
          obtains an estimate of the current number of nodes
          <code>n</code> in the network and then uses <code>log n</code> for
          the actual length of the random walk.<a href="#section-3.1-4">¶</a></p>
</section>
<section id="section-3.2">
        <h3 id="name-key-differences-to-reload">
<a href="#section-3.2">3.2. </a><a href="#name-key-differences-to-reload">Key differences to RELOAD</a>
        </h3>
<p id="section-3.2-1">
   <span>[<a href="#RFC6940">RFC6940</a>]</span> specifies the RELOAD DHT.  The R<sup>5</sup>N DHT
   described in this document differs from RELOAD in its objectives
   and thus in its design.
          The authors of RELOAD make the case that P2P networks are often established
          among a set of peers that do not trust each other.
          It addresses this issue by requiring that node identifiers
          are either assigned by a central authority, or self-issued in the case of closed networks.
          In other words, by enforcing the P2P network to be established among a set
          of <em>trusted</em> peers.
          This misses the point that this openness is a core requirement of efficient and
          useful DHTs as they serve a fundamental part in a decentralized network
          infrastructure.
          R<sup>5</sup>N, by contrast, is intended for open
   overlay networks, and thus does not include a central enrollment server to
   certify participants and does not limit participation in another way.
          As participants could be malicious, R<sup>5</sup>N
   includes on-path customizable key-value validation to delete malformed
   data and path randomiziation
   to help evade malicious peers. R<sup>5</sup>N also expects to perform
   over a network where not every peer can communicate with every other peer,
   and where thus its route discovery feature provides utility to higher-level
   applications.  As a result, both the features and the security properties
   of RELOAD and R<sup>5</sup>N are different, except in that both allow
   storing and retrieving key-value pairs.<a href="#section-3.2-1">¶</a></p>
</section>
</section>
<section id="section-4">
      <h2 id="name-overview">
<a href="#section-4">4. </a><a href="#name-overview">Overview</a>
      </h2>
<p id="section-4-1">
        In R<sup>5</sup>N peers provide to their applications
        the two fundamental core operations of any DHT:<a href="#section-4-1">¶</a></p>
<ul>
<li id="section-4-2.1">
          <code>PUT</code>: This operation stores a block
   under a key on one or more peers with
          the goal of making the block availiable for queries using the <code>GET</code> operation.
          In the classical definition of a dictionary interface, this operation would be
          called &#34;insert&#34;.<a href="#section-4-2.1">¶</a>
</li>
        <li id="section-4-2.2">
          <code>GET</code>: This operation queries the network of peers for any number of blocks
          previously stored under or near a key.
          In the classical definition of a dictionary interface, this operation would be
          called &#34;find&#34;.<a href="#section-4-2.2">¶</a>
</li>
      </ul>
<p id="section-4-3">
 An example for possible semantics of the above operations
 provided as an API to applications by an implementation are
 outlined in <a href="#overlay">Appendix B</a>.<a href="#section-4-3">¶</a></p>
<p id="section-4-4">
        A peer does not necessarily need to expose the above
        operations to applications, but it commonly will.  A
        peer that does not expose the above operations could
        be a host purely used for bootstrapping,
 routing or supporting
        the overlay network with resources.<a href="#section-4-4">¶</a></p>
<p id="section-4-5">
 Similarly, there could be hosts on the network that
 participate in the DHT but do not route traffic or store
 data. Examples for such hosts would be mobile devices with
 limited bandwidth, battery and storage capacity.  Such hosts
 may be used to run applications that use the DHT. However, we
 will not refer to such hosts as peers.<a href="#section-4-5">¶</a></p>
<p id="section-4-6">
        In a trivial scenario where there is only one peer (on the local host),
        R<sup>5</sup>N operates similarly to a dictionary data structure.
        However, the default use case is one where nodes communicate directly and
        indirectly in order to realize a distributed storage mechanism.
        This communication requires a lower-level peer addressing and message transport
        mechanism such as TCP/IP.
        R<sup>5</sup>N is agnostic to the underlying transport protocol which is why
        this document defines a common addressing and messaging interface in
        <a href="#underlay">Section 5</a>.
        The interface provided by this underlay is used across the specification of the
        R<sup>5</sup>N protocol.
        It also serves as a set of requirements of possible transport mechanisms that
        can be used to implement R<sup>5</sup>N with.
        That being said, common transport protocols such as TCP/IP or UDP/IP and their
        interfaces are suitable R<sup>5</sup>N underlays and are used as such by existing
        implementations.<a href="#section-4-6">¶</a></p>
<p id="section-4-7">
        Specifics about the protocols of the underlays implementing
        the underlay interface or the applications
        using the DHT are out of the scope of this document.<a href="#section-4-7">¶</a></p>
<p id="section-4-8">
        To establish an initial connection to a network of
        R<sup>5</sup>N peers, at least one initial, addressable
        peer is required as part of the
        bootstrapping process.  Further peers,
        including neighbors, are then learned via a peer
        discovery process as defined in <a href="#find_peer">Section 6.2</a>.<a href="#section-4-8">¶</a></p>
<p id="section-4-9">
        Across this document, the functional components of an
        R<sup>5</sup>N implementation are divided into
        routing (<a href="#routing">Section 6</a>), message
        processing (<a href="#p2p_messages">Section 7</a>) and
        block storage (<a href="#blockstorage">Section 8</a>).
 <a href="#figure_r5n_arch">Figure 1</a> illustrates
        the architectural overview of R<sup>5</sup>N.<a href="#section-4-9">¶</a></p>
<span id="name-the-r5n-architecture"></span><div id="figure_r5n_arch">
<figure id="figure-1">
        <div id="section-4-10.1">
<pre>             |  +-----------------+  +-------+
Applications |  | GNU Name System |  | CADET |  ...
             |  +-----------------+  +-------+
-------------+------------------------------------ Core Operations
             |  ^
             |  |   +---------------+
             |  |   | Block Storage |
             |  |   +---------------+
             |  |    ^
R5N          |  v    v
             | +--------------------+    +---------+
             | | Message Processing |&lt;--&gt;| Routing |
             | +--------------------+    +---------+
             |  ^                          ^
             |  v                          v
-------------+------------------------------------ Underlay Interface
             | +--------+  +--------+  +----------+
             | |GNUnet  |  |IP      |  | QUIC     |
Connectivity | |Underlay|  |Underlay|  | Underlay | ...
             | |Link    |  |Link    |  | Link     |
             | +--------+  +--------+  +----------+

</pre>
</div>
<figcaption><a href="#figure-1">Figure 1</a>:
<a href="#name-the-r5n-architecture">The R5N architecture.</a>
        </figcaption></figure>
</div>
</section>
<div id="underlay">
<section id="section-5">
      <h2 id="name-underlay">
<a href="#section-5">5. </a><a href="#name-underlay">Underlay</a>
      </h2>
<p id="section-5-1">
        A peer <span>MUST</span> support one or more underlay
        protocols.
        Peers supporting multiple underlays effectively
        create a bridge between different networks.  How peers are
        addressed in a specific underlay is out of scope of this
        document.  For example, a peer may have a TCP/IP address, or
        expose a QUIC endpoint, or both.  While the specific addressing options
        and mechanisms are out of scope for this document,
        it is necessary to define a
        universal addressing format in order to facilitate the
        distribution of address information to other
        peers in the DHT overlay.
        This standardized format
        is the HELLO block (described in <a href="#hello_block">Section 8.2</a>), which contains sets of addresses.
        If the address is a URI, it may indicate which
        underlay understands the respective address.<a href="#section-5-1">¶</a></p>
<p id="section-5-2">
        It is expected that the underlay provides basic mechanisms to
        manage peer connectivity and addressing.
        The essence of the underlay interface is
        captured by the following set of API calls:<a href="#section-5-2">¶</a></p>
<span></span><dl id="section-5-3">
        <dt id="section-5-3.1">
          <code>TRY_CONNECT(P, A)</code>
        </dt>
        <dd id="section-5-3.2">
          This call allows the DHT implementation to signal to the
          underlay that the DHT wants to establish a connection to the
          target peer <code>P</code> using the given address <code>A</code>.
          If the connection attempt is successful, information on the
          new peer connection will be offered through the
          <code>PEER_CONNECTED</code> signal.<a href="#section-5-3.2">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-3.3">
          <code>HOLD(P)</code>
        </dt>
        <dd id="section-5-3.4">
          This call tells the underlay to hold on to a connection
          to a peer <code>P</code>.  Underlays are usually limited in the number
   of active connections.  With this function the DHT can indicate to the
   underlay which connections should preferably be preserved.<a href="#section-5-3.4">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-3.5">
          <code>DROP(P)</code>
        </dt>
        <dd id="section-5-3.6">
          This call tells the underlay to drop the connection to a
          peer <code>P</code>.  This call is only there for symmetry and
   used during the peer&#39;s shutdown to release all of the remaining
   <code>HOLDs</code>.
   
   As R<sup>5</sup>N always prefers the longest-lived
   connections, it would never drop an active connection that it
   has called <code>HOLD()</code> on before. Nevertheless, underlay implementations
   should not rely on this always being true.  A call to <code>DROP()</code> also
   does not imply that the underlay must close the connection: it merely
   removes the preference to preserve the connection that was established
   by <code>HOLD()</code>.<a href="#section-5-3.6">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-3.7">
          <code>SEND(P, M)</code>
        </dt>
        <dd id="section-5-3.8">
          This call allows the local peer to send a protocol message
          <code>M</code> to a peer <code>P</code>.  Sending messages is expected
          to be done on a best-effort basis, thus the underlay does not
          have to guarantee delivery or message ordering. If the underlay
          implements flow- or congestion-control, it may
          discard messages to limit its queue size.<a href="#section-5-3.8">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-3.9">
          <code>ESTIMATE_NETWORK_SIZE() -&gt; L2NSE</code>
        </dt>
        <dd id="section-5-3.10">
          This call must return an estimate of the network size.  The
          resulting <code>L2NSE</code> value must be the base-2 logarithm
          of the <em>estimated</em> number of peers in the network.
          This estimate is used by the routing algorithm.  If the underlay does
          not support a protocol for network size estimation (such as
          <span>[<a href="#NSE">NSE</a>]</span>) the value is assumed to be provided as
          a configuration parameter to the underlay implementation.<a href="#section-5-3.10">¶</a>
</dd>
      <dd></dd>
</dl>
<p id="section-5-4">
        The above calls are meant to be actively executed by the
        implementation as part of the peer-to-peer protocol.  In
        addition, the underlay creates <em>signals</em> to drive
        updates of the routing table, local storage and message
        processing (<a href="#p2p_messages">Section 7</a>). Specifically,
        the underlay is expected to emit the following
        signals (usually implemented as callbacks) based on network
        events observed by the underlay implementation:<a href="#section-5-4">¶</a></p>
<span></span><dl id="section-5-5">
        <dt id="section-5-5.1">
          <code>PEER_CONNECTED -&gt; P</code>
        </dt>
        <dd id="section-5-5.2">
          This signal allows the DHT to react to a newly connected
          peer <code>P</code>.  Such an event triggers, for example,
          updates in the routing table and gossiping of HELLOs to that
          peer.  Underlays may include meta-data about the connection,
          for example to indicate that the connection is from a
          resource-constrained host that does not intend to function
          as a full peer and thus should not be considered
          for routing.<a href="#section-5-5.2">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-5.3">
          <code>PEER_DISCONNECTED -&gt; P</code>
        </dt>
        <dd id="section-5-5.4">
          This signal allows the DHT to react to a recently
          disconnected peer.  Such an event primarily triggers updates
          in the routing table.<a href="#section-5-5.4">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-5.5">
          <code>ADDRESS_ADDED -&gt; A</code>
        </dt>
        <dd id="section-5-5.6">
          The underlay signals indicates that an address <code>A</code>
          was added for our local peer and that henceforth the peer
          may be reachable under this address.  This information is
          used to advertise connectivity information about the local
          peer to other peers.  <code>A</code> is an
          address suitable for inclusion in a <code>HELLO</code> payload
          <a href="#hello_block">Section 8.2</a>.<a href="#section-5-5.6">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-5.7">
          <code>ADDRESS_DELETED -&gt; A</code>
        </dt>
        <dd id="section-5-5.8">
          This underlay signal indicates that an address <code>A</code>
          was removed from the set of addresses the local peer is
          possibly reachable under. The signal is used
          to stop advertising this address to other peers.<a href="#section-5-5.8">¶</a>
</dd>
        <dd></dd>
<dt id="section-5-5.9">
          <code>RECEIVE -&gt; (P, M)</code>
        </dt>
        <dd id="section-5-5.10">
          This signal informs the local peer that a protocol
          message <code>M</code> was received from a peer <code>P</code>.<a href="#section-5-5.10">¶</a>
</dd>
      <dd></dd>
</dl>
</section>
</div>
<div id="routing">
<section id="section-6">
      <h2 id="name-routing">
<a href="#section-6">6. </a><a href="#name-routing">Routing</a>
      </h2>
<p id="section-6-1">
        To enable routing, any R<sup>5</sup>N implementation must keep
 information about its current set of neighbors.
        Upon receiving a connection notification from the
 underlay interface through a
        <code>PEER_CONNECTED</code> signal, information on the new neighbor
        <span>MUST</span> be added to the routing table, except if the
 respective <code>k</code>-bucket in the routing table is full or if meta-data
 is present that indicates that the peer does not wish to participate
 in routing.
        Peers added to the routing table <span>SHOULD</span> be signalled to the
        underlay as important connections using a <code>HOLD()</code> call.
        Similarly when a disconnect is indicated by the underlay through
        a <code>PEER_DISCONNECTED</code> signal, the peer
        <span>MUST</span> be removed from the routing table.<a href="#section-6-1">¶</a></p>
<p id="section-6-2">
        To achieve logarithmically bounded routing performance,
        the data structure for managing neighbors and their
        metadata <span>MUST</span> be implemented using the k-buckets concept of
        <span>[<a href="#Kademlia">Kademlia</a>]</span>  as defined in <a href="#routing_table">Section 6.1</a>.
        Maintenance of the routing table (after bootstrapping) is
        described in <a href="#find_peer">Section 6.2</a>.<a href="#section-6-2">¶</a></p>
<p id="section-6-3">
        Unlike <span>[<a href="#Kademlia">Kademlia</a>]</span>, routing decisions in
        R<sup>5</sup>N are also influenced by a Bloom filter in the message
        that prevents routing loops. This data structure is discussed in
 <a href="#routing_bloomfilter">Section 6.3</a>.<a href="#section-6-3">¶</a></p>
<p id="section-6-4">
        In order to select peers which are suitable destinations for
        routing messages, R<sup>5</sup>N uses a hybrid approach: Given
        an estimated network size <code>L2NSE</code> retrieved using
        <code>ESTIMATE_NETWORK_SIZE()</code>, the peer selection for the
        first <code>L2NSE</code> hops is random. After the initial
        <code>L2NSE</code> hops, peer selection follows an XOR-based peer
        distance calculation.
        <a href="#routing_functions">Section 6.4</a>
        describes the corresponding routing functions.<a href="#section-6-4">¶</a></p>
<p id="section-6-5">
        Finally, each <code>ResultMessage</code> is routed back along the
        path that the corresponding <code>GetMessage</code> took
        previously. This is enabled by tracking state per
        <code>GetMessage</code> in the pending table described in
        <a href="#pending_table">Section 6.5</a>.<a href="#section-6-5">¶</a></p>
<div id="routing_table">
<section id="section-6.1">
        <h3 id="name-routing-table">
<a href="#section-6.1">6.1. </a><a href="#name-routing-table">Routing Table</a>
        </h3>
<p id="section-6.1-1">
          Whenever a <code>PEER_CONNECTED</code> signal is received from
          the underlay, the respective peer is considered for
          insertion into the routing table.  The routing table
          consists of an array of <code>k</code>-buckets. Each
          <code>k</code>-bucket contains a list of neighbors.
          The i-th <code>k</code>-bucket stores neighbors whose peer
          public keys are between XOR-distance 2<sup>i</sup> and
          2<sup>i+1</sup> from the local peer; <code>i</code> can be
          directly computed from the two peer identities using the
          <code>GetDistance()</code> function.  System constraints will
          typically force an implementation to impose some upper limit
          on the number of neighbors kept per
          <code>k</code>-bucket.  Upon insertion, the implementation
          <span>MUST</span> call <code>HOLD()</code> on the respective
          neighor.<a href="#section-6.1-1">¶</a></p>
<p id="section-6.1-2">
          Implementations <span>SHOULD</span> try to keep at least
          5 entries per <code>k</code>-bucket.  Embedded systems that cannot manage
          this number of connections <span>MAY</span> use connection-level
          signalling to indicate that they are merely a client utilizing a
          DHT and not able to participate in routing.  DHT peers receiving
          such connections <span>MUST NOT</span> include connections to
          such restricted systems in their <code>k</code>-buckets, thereby effectively
   excluding them when making routing decisions.<a href="#section-6.1-2">¶</a></p>
<p id="section-6.1-3">
          If a system hits constraints with respect to
          the number of active connections, an implementation
          <span>MUST</span> evict neighbours from those <code>k</code>-buckets with the
          largest number of neighbors. The eviction strategy <span>MUST</span> be
          to drop the shortest-lived connection per <code>k</code>-bucket first.<a href="#section-6.1-3">¶</a></p>
<p id="section-6.1-4">
          Implementations <span>MAY</span> cache valid addresses of disconnected
          peers outside of the routing table and sporadically or periodically try to (re-)establish connection
          to the peer by making <code>TRY_CONNECT()</code> calls to the underlay interface
          if the respective <code>k</code>-bucket has empty slots.<a href="#section-6.1-4">¶</a></p>
</section>
</div>
<div id="find_peer">
<section id="section-6.2">
        <h3 id="name-peer-discovery">
<a href="#section-6.2">6.2. </a><a href="#name-peer-discovery">Peer Discovery</a>
        </h3>
<p id="section-6.2-1">
          Initially, implementations require at least one initial connection to a
          neighbor (signalled through
          <code>PEER_CONNECTED</code>).
          The first connection <span>SHOULD</span> be established
          by an out-of-band exchange of the information from a
          <code>HELLO</code> block.
          This is commonly achieved through the
          configuration of hardcoded bootstrap peers or bootstrap
          servers either for the underlay or the R<sup>5</sup>N
          implementation.<a href="#section-6.2-1">¶</a></p>
<p id="section-6.2-2">
          Implementations <span>MAY</span> have other means to achieve this
          initial connection.
          For example, implementations could allow the application or
          even end-user to provide a working <code>HELLO</code>
          which is then in turn used to call <code>TRY_CONNECT()</code> on
          the underlay in order to trigger a subsequent
          <code>PEER_CONNECTED</code> signal from the underlay
          interface.
          <a href="#hello_url">Appendix C</a> specifies
          a URL format for encoding HELLO blocks as text strings. The
          URL format thus provides a portable, human-readable,
          text-based serialization format that can, for example, be
          encoded into a QR code for dissemination.
          HELLO URLs <span>SHOULD</span> be supported by implementations for
          both import and export of <code>HELLOs</code>.<a href="#section-6.2-2">¶</a></p>
<p id="section-6.2-3">
          To discover additional peers for its routing table, a peer
          <span>MUST</span> initiate <code>GetMessage</code> requests
          (see <a href="#p2p_get">Section 7.4</a>) asking for blocks of type
          <code>HELLO</code> using its own peer identity in the
          <code>QUERY_HASH</code> field of the message.  The
          <code>PEER_BF</code> field of the <code>GetMessage</code>
          <span>MUST</span> be
          initialized to filter the peer&#39;s own peer identity as well as the peer
          identities of all currently connected
          neighbors. These requests <span>MUST</span> use
          the <code>FindApproximate</code> and
          <code>DemultiplexEverywhere</code>
          flags. <code>FindApproximate</code> will ensure that other peers
          will reply with results where the keys are merely considered
          close-enough, while <code>DemultiplexEverywhere</code> will
          cause each peer on the path to respond if it has relevant
          information. The combination of these flags is thus likely
          to yield <code>HELLOs</code> of peers that are useful somewhere
          in the initiator&#39;s routing table.  The <span>RECOMMENDED</span>
          replication level to be set in the <code>REPL_LVL</code> field
          is 4.  The size and format of the result filter is specified
          in <a href="#hello_block">Section 8.2</a>.  The <code>XQUERY</code>
          <span>MUST</span> be empty.<a href="#section-6.2-3">¶</a></p>
<p id="section-6.2-4">
          In order to facilitate peers answering requests for
          <code>HELLOs</code>, the underlay is expected to provide the
          implementation with addresses signalled through
          <code>ADDRESS_ADDED</code>. It is possible that no addresses are
          provided if a peer can only establish outgoing connections
          and is otherwise unreachable.  An implementation
          <span>MUST</span> advertise its addresses periodically to
          its neighbors through <code>HelloMessages</code>.  The
          advertisement interval and expiration <span>SHOULD</span>
          be configurable.
          If the values are chosen at the discretion of the
          implementation, it is <span>RECOMMENDED</span> to choose external
          factors such as expiration of DHCP leases to determine the values.
          The specific frequency of advertisements
          <span>SHOULD</span> be smaller than the expiration
          period.
          It <span>MAY</span> additionally depend on available bandwidth,
          the set of already connected neighbors, the workload of the system and
          other factors which are at the discretion of the developer.
   If <code>HelloMessages</code> are not updated before they expire,
   peers might be unable to discover and connect to the respective
   peer, and thus miss out on quality routing table entries. This
   would degrade the performance of the DHT and <span>SHOULD</span>
   thus be avoided by advertising updated <code>HELLOs</code> before the
   previous one expires. When using unreliable underlays, an implementation
   <span>MAY</span> use higher frequencies and transmit
   more <code>HelloMessages</code> within an expiration interval
   to ensure that neighbours almost always have non-expired
   <code>HelloMessages</code> at their disposal even if some messages
   are lost.<a href="#section-6.2-4">¶</a></p>
<p id="section-6.2-5">
          Whenever a peer receives such a <code>HelloMessage</code>
          from another peer that is already in the routing
          table, it must cache it as long as that peer remains in its
          routing table (or until the <code>HELLO</code> expires) and
          serve it in response to <code>GET</code> requests for
          <code>HELLO</code> blocks (see <a href="#p2p_get_processing">Section 7.4.3</a>).  This behaviour makes it
          unnecessary for peers to initiate dedicated
          <code>PutMessages</code> containing <code>HELLO</code> blocks.<a href="#section-6.2-5">¶</a></p>
</section>
</div>
<div id="routing_bloomfilter">
<section id="section-6.3">
        <h3 id="name-peer-bloom-filter">
<a href="#section-6.3">6.3. </a><a href="#name-peer-bloom-filter">Peer Bloom Filter</a>
        </h3>
<p id="section-6.3-1">
          As DHT <code>GetMessages</code> and <code>PutMessages</code>
          traverse a random path through the network for the first
          <code>L2NSE</code> hops, a key design objective of
          R<sup>5</sup>N is to avoid routing loops.  The peer Bloom
          filter is part of the routing metadata in messages to
          prevent circular routes. It is updated at each hop where the
          hop&#39;s peer identity derived from the peer&#39;s public key is
          added to it.
          The peer Bloom filter follows the definition in <a href="#bloom_filters">Appendix A</a>.
          It <span>MUST</span> be <code>L=1024</code> bits
          (128 bytes) in size and <span>MUST</span> set <code>k=16</code> bits per
          element.
          The set of elements <code>E</code> consists of of all possible 256-bit peer
          public keys and the mapping function <code>M</code> is defined as follows:<a href="#section-6.3-1">¶</a></p>
<p id="section-6.3-2">
          <code>M(e) -&gt; SHA-512 (e) as uint32[]</code><a href="#section-6.3-2">¶</a></p>
<p id="section-6.3-3">
          The element <code>e</code> is the peer public key which is hashed using SHA-512.
          The resulting 512-bit peer identity is interpreted as an array of k=16
          32-bit integers in network byte order which are used to set and check the bits
          in <code>B</code> using <code>BF-SET()</code> and <code>BF-TEST()</code>.<a href="#section-6.3-3">¶</a></p>
<p id="section-6.3-4">
          At this size, the Bloom filter reaches a false-positive rate of
          approximately fifty percent at about 200 entries. For peer
          discovery where the Bloom filter is initially populated with
          peer identities from the local routing table, the 200
          entries would still be enough for 40 buckets assuming 5
          peers per bucket, which corresponds to an overlay network
          size of approximately 1 trillion peers. Thus,
          <code>L=1024</code> bits should suffice for all conceivable
          use-cases.<a href="#section-6.3-4">¶</a></p>
<p id="section-6.3-5">
          For the next hop selection in both the random
          and the deterministic case, any peer which is in the peer
          Bloom filter for the respective message is excluded from the
          peer selection process.
          Any peer which is forwarding <code>GetMessages</code> or <code>PutMessages</code>
          (<a href="#p2p_messages">Section 7</a>) thus adds its own peer public key to the
          peer Bloom filter.
          This allows other peers to (probabilistically) exclude already
          traversed peers when searching for the next hops in the routing table.<a href="#section-6.3-5">¶</a></p>
<p id="section-6.3-6">
   We note that the peer Bloom filter may exclude peers due to false-postive
   matches.  This is acceptable as routing should nevertheless
   terminate (with high probability) in close vicinity of the key. Furthermore,
   due to the randomization of the first L2NSE hops, it is possible that
   false-positives will be different when a request is repeated.<a href="#section-6.3-6">¶</a></p>
</section>
</div>
<div id="routing_functions">
<section id="section-6.4">
        <h3 id="name-routing-functions">
<a href="#section-6.4">6.4. </a><a href="#name-routing-functions">Routing Functions</a>
        </h3>
<p id="section-6.4-1">
           Using the data structures described so far,
    the R<sup>5</sup>N routing component provides
    the following functions for
    message processing (<a href="#p2p_messages">Section 7</a>):<a href="#section-6.4-1">¶</a></p>
<span></span><dl id="section-6.4-2">
          <dt id="section-6.4-2.1">
            <code>GetDistance(A, B) -&gt; Distance</code>
          </dt>
          <dd id="section-6.4-2.2">
            This function calculates the binary XOR between A and B.
            The resulting distance is interpreted as an integer where
            the leftmost bit is the most significant bit.<a href="#section-6.4-2.2">¶</a>
</dd>
          <dd></dd>
<dt id="section-6.4-2.3">
            <code>SelectClosestPeer(K, B) -&gt; N</code>
          </dt>
          <dd id="section-6.4-2.4">
            This function selects the neighbor <code>N</code> from our
            routing table with the shortest XOR-distance to the key <code>K</code>.
            This means that for all other peers <code>N&#39;</code> in the routing table
            <code>GetDistance(N, K) &lt; GetDistance(N&#39;,K)</code>.
            Peers with a positive test against the peer Bloom
     filter <code>B</code> are not considered.<a href="#section-6.4-2.4">¶</a>
</dd>
          <dd></dd>
<dt id="section-6.4-2.5">
            <code>SelectRandomPeer(B) -&gt; N</code>
          </dt>
          <dd id="section-6.4-2.6">
            This function selects a random peer <code>N</code> from
     all neighbors.
            Peers with a positive test in the peer Bloom
     filter <code>B</code> are not considered.<a href="#section-6.4-2.6">¶</a>
</dd>
          <dd></dd>
<dt id="section-6.4-2.7">
            <code>SelectPeer(K, H, B) -&gt; N</code>
          </dt>
          <dd id="section-6.4-2.8">
            This function selects a neighbor <code>N</code> depending on the
            number of hops <code>H</code> parameter.
            If <code>H &lt; NETWORK_SIZE_ESTIMATE</code>
            returns <code>SelectRandomPeer(B)</code>, and otherwise
            returns <code>SelectClosestPeer(K, B)</code>.<a href="#section-6.4-2.8">¶</a>
</dd>
          <dd></dd>
<dt id="section-6.4-2.9">
            <code>IsClosestPeer(N, K, B) -&gt; true | false</code>
          </dt>
          <dd id="section-6.4-2.10">
            This function checks if <code>N</code> is the closest peer for <code>K</code>
            (cf. <code>SelectClosestPeer(K, B)</code>).
            Peers with a positive test in the Bloom filter <code>B</code> are not considered.<a href="#section-6.4-2.10">¶</a>
</dd>
          <dd></dd>
<dt id="section-6.4-2.11">
            <code>ComputeOutDegree(REPL_LVL, HOPCOUNT, L2NSE) -&gt; Number</code>
          </dt>
          <dd id="section-6.4-2.12">
            <p id="section-6.4-2.12.1">
      This function computes the number of neighbors
     that a message should be forwarded to.  The arguments
     are the desired replication level (<code>REPL_LVL</code>),
     the <code>HOPCOUNT</code> of the message so far and
     and the current network size estimate (<code>L2NSE</code>)
     as provided by the underlay.
            The result is the non-negative number of next hops to
     select.  The following figure gives the
     pseudocode for computing the number of neighbors
     the peer should attempt to forward the message to.<a href="#section-6.4-2.12.1">¶</a></p>
<span id="name-computing-the-number-of-nex"></span><div id="compute_out_degree">
<figure id="figure-2">
              <div id="section-6.4-2.12.2.1">
<pre>ComputeOutDegree(REPL_LVL, HOPCOUNT, L2NSE):
  if (HOPCOUNT &gt; L2NSE * 4)
    return 0;
  if (HOPCOUNT &gt; L2NSE * 2)
    return 1;
  if (0 = REPL_LEVL)
    REPL_LEVL = 1
  if (REPL_LEVEL &gt; 16)
    REPL_LEVEL = 16
    RM1 = REPL_LEVEL - 1
    FRAC = 1 + (RM1 / (L2NSE + RM1 * HOPCOUNT))
  return PROUND(FRAC)
</pre>
</div>
<figcaption><a href="#figure-2">Figure 2</a>:
<a href="#name-computing-the-number-of-nex">Computing the number of next hops.</a>
              </figcaption></figure>
</div>
<p id="section-6.4-2.12.3">
          The above calculation of <code>FRAC</code> may yield values that are
          not discrete.
          The result is <code>FRAC</code> rounded probabilistically
          (<code>PROUND</code>) to the nearest
       discrete value, using the fraction
          as the probability for rounding up.
          For example, a value of <code>3.14</code> is rounded up to <code>4</code> with
          a probability of 14% and rounded down to <code>3</code> with a probability
          of 86%.
          This probabilistic rounding is necessary to achieve
          the statistically expected value of the replication
          level and average number of peers a message is forwarded to.<a href="#section-6.4-2.12.3">¶</a></p>
</dd>
        <dd></dd>
</dl>
</section>
</div>
<div id="pending_table">
<section id="section-6.5">
        <h3 id="name-pending-table">
<a href="#section-6.5">6.5. </a><a href="#name-pending-table">Pending Table</a>
        </h3>
<p id="section-6.5-1">
   R<sup>5</sup>N performs stateful routing where the messages
   only carry the query hash and do not encode the ultimate
   source or destination of the request.  Routing a request
   towards the key is done hop-by-hop using the routing table and the
   query hash.  The pending table is used to route responses
   back to the originator.  In the pending table each peer
   primarily maps a query hash to the associated
   originator of the request.  The pending table <span>MUST</span>
   store entries for the last <code>MAX_RECENT</code> requests
    the peer has encountered.
    To ensure that the peer does
   not run out of memory, information about older requests
    <span>MAY</span> be discarded.
    The value of <code>MAX_RECENT</code> <span>MAY</span> be configurable
    at the host level to use available memory resources without
    conflicting with other system requirements and limitations.
    <code>MAX_RECENT</code> <span>SHOULD</span>
    be at least 128 * 10<sup>3</sup>.
    If the pending table is smaller, the likelihood grows that a peer
    receives a response to a query but is unable to forward it to the
    initiator because it forgot the predecessor.  Eventually, the
    initiator would likely succeed by repeating the query.
    However, this would be much more expensive than peers having an adequately
    sized pending table.<a href="#section-6.5-1">¶</a></p>
<p id="section-6.5-2">
   For each entry in the pending table, the DHT
   <span>MUST</span> track the query key, the peer identity
   of the previous hop, the extended query, requested block type,
   flags, and the result filter.  If the query did not provide
   a result filter, a fresh result filter <span>MUST</span>
   still be created to filter duplicate replies.  Details of
   how a result filter works depend on the type, as described
   in <a href="#block_functions">Section 8.1</a>.<a href="#section-6.5-2">¶</a></p>
<p id="section-6.5-3">
   When a second query from the same origin for the
   same query hash is received, the DHT <span>MUST</span>
   attempt to merge the new request with the state for
   the old request.  If this is not possible (say because
   the MUTATOR differs), the
   existing result filter <span>MUST</span> be
   discarded and replaced with the result
   filter of the incoming message.<a href="#section-6.5-3">¶</a></p>
<p id="section-6.5-4">
   We note that for local applications, a fixed limit on
   the number of concurrent requests may be problematic.
   Hence, it is <span>RECOMMENDED</span> that implementations
   track requests from local applications separately and
   preserve the information about requests from local
   applications until the local application explicitly
   stops the request.<a href="#section-6.5-4">¶</a></p>
</section>
</div>
</section>
</div>
<div id="p2p_messages">
<section id="section-7">
      <h2 id="name-message-processing">
<a href="#section-7">7. </a><a href="#name-message-processing">Message Processing</a>
      </h2>
<p id="section-7-1">
        An implementation will process
        messages either because it needs to transmit messages as part of routing
 table maintenance, or due to requests from local applications, or
 because it received a message from a neighbor.
        If instructed through an application-facing API such as the one outlined
        in <a href="#overlay">Appendix B</a>, a peer acts as an initiator
 of <code>GetMessages</code>
        or <code>PutMessages</code>.
        The status of initiator is relevant for peers when processing <code>ResultMessages</code>
        due to the required handover of results to the application that requested
        the respective result.<a href="#section-7-1">¶</a></p>
<p id="section-7-2">
        The implementation <span>MUST</span> listen for <code>RECEIVE(P, M)</code> signals
        from the underlay and react to the respective messages sent by
        the peer <code>P</code>.<a href="#section-7-2">¶</a></p>
<p id="section-7-3">
        Whether initiated locally or received from a neighbor, an implementation
        processes messages according to the wire formats and the required
        validations detailed in the following sections.
        Where required, the local peer public key is referred to as <code>SELF</code>.<a href="#section-7-3">¶</a></p>
<div id="message_components">
<section id="section-7.1">
        <h3 id="name-message-components">
<a href="#section-7.1">7.1. </a><a href="#name-message-components">Message components</a>
        </h3>
<p id="section-7.1-1">
   This section describes some data structures and fields shared
   by various types of messages.<a href="#section-7.1-1">¶</a></p>
<div id="route_flags">
<section id="section-7.1.1">
          <h4 id="name-flags">
<a href="#section-7.1.1">7.1.1. </a><a href="#name-flags">Flags</a>
          </h4>
<p id="section-7.1.1-1">
            Flags is an 8-bit vector representing binary options.
            Each flag is represented by a bit in the field starting from 0 as
            the rightmost bit to 7 as the leftmost bit.<a href="#section-7.1.1-1">¶</a></p>
<span></span><dl id="section-7.1.1-2">
            <dt id="section-7.1.1-2.1">0: DemultiplexEverywhere</dt>
            <dd id="section-7.1.1-2.2">
     This bit indicates that each peer along the way should process the request.
            If the bit is not set, intermediate peers only route the message and only
            peers which consider themselves closest to the key (based on their
     routing table) look for answers
            in their local storage for <code>GetMessages</code>, or respectively cache the
     block in their local storage for <code>PutMessages</code> and <code>ResultMessages</code>.<a href="#section-7.1.1-2.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.1-2.3">1: RecordRoute</dt>
            <dd id="section-7.1.1-2.4">
            This bit indicates to keep track of the path that the message takes
            in the P2P network.<a href="#section-7.1.1-2.4">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.1-2.5">2: FindApproximate</dt>
            <dd id="section-7.1.1-2.6">
            This bit asks peers to return results even if the key
     does not exactly match the query hash.<a href="#section-7.1.1-2.6">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.1-2.7">3: Truncated</dt>
            <dd id="section-7.1.1-2.8">
            This is a special flag which is set if a peer truncated the
            recorded path.
            This results in the first hop on the path to be given without a signature
            to enable checking of the next signature.
            This flag <span>MUST NOT</span> be set in
            a <code>GetMessage</code>.<a href="#section-7.1.1-2.8">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.1-2.9">4-7: Reserved</dt>
            <dd id="section-7.1.1-2.10">
            The remaining bits are reserved for future use and
     <span>MUST</span> be set to zero when initiating an operation.
     If non-zero bits are received, implementations <span>MUST</span>
     preserve these bits when forwarding messages.<a href="#section-7.1.1-2.10">¶</a>
</dd>
          <dd></dd>
</dl>
</section>
</div>
<div id="p2p_path">
<section id="section-7.1.2">
          <h4 id="name-path">
<a href="#section-7.1.2">7.1.2. </a><a href="#name-path">Path</a>
          </h4>
<p id="section-7.1.2-1">
          If the <code>RecordRoute</code> flag is set, the route of a <code>PutMessage</code>
          or a <code>ResultMessage</code> through the overlay network is recorded in the
          <code>PATH</code> field of the message. <code>PATH</code> is a list of path elements.
          A new path element (<a href="#p2p_pathelement">Section 7.1.3</a>) is appended to the
          existing <code>PATH</code> before a peer sends the message to the next peer.<a href="#section-7.1.2-1">¶</a></p>
<p id="section-7.1.2-2">
          A path element contains a signature and the public key of the peer that
          created the element. The signature is computed over the public keys of the
          previous peer (from which the message was received) and next peer (the
          peer the message is send to). A new message has no previous peer and
          uses all <code>ZEROs</code> (32 NULL-bytes) in the
          public key field when creating the signature.<a href="#section-7.1.2-2">¶</a></p>
<p id="section-7.1.2-3">
          Assuming peer A sends a new <code>PUT</code> message to peer B, which forwards
          the message to peer C, which forwards to peer D which finally stores the data.
          The <code>PATH</code> field of the message received at peer D contains three
          path elements (build from top to bottom):<a href="#section-7.1.2-3">¶</a></p>
<span id="name-example-path"></span><div id="figure_path">
<figure id="figure-3">
            <div id="section-7.1.2-4.1">
<pre>+---------------------+-------+
| Sig A(ZEROs, Pub B) | Pub A |
+---------------------+-------+
+---------------------+-------+
| Sig B(Pub A, Pub C) | Pub B |
+---------------------+-------+
+---------------------+-------+
| Sig C(Pub B, Pub D) | Pub C |
+---------------------+-------+
</pre>
</div>
<figcaption><a href="#figure-3">Figure 3</a>:
<a href="#name-example-path">Example PATH</a>
            </figcaption></figure>
</div>
<p id="section-7.1.2-5">
          Note that the wire format of <code>PATH</code> (<a href="#p2p_pathelement">Section 7.1.3</a>)
          will not include the last public key (Pub C in our example) as this will be
          redundant; the receiver of a message can use the public key of the sender as
          the public key to verify the last signature.<a href="#section-7.1.2-5">¶</a></p>
<p id="section-7.1.2-6">
          The <code>PATH</code> is stored along with the payload data from the <code>PUT</code>
          message at the final peer. Note that the same payload stored at different
          peers will have a different <code>PATH</code> associated with it.<a href="#section-7.1.2-6">¶</a></p>
<p id="section-7.1.2-7">
          When the storing peer delivers the data based on a <code>GET</code> request, it
          initializes the <code>PATH</code> field with the stored path value and appends
          a new path element. The first part of <code>PATH</code> in a <code>GET</code> response
          message is called the <code>PutPath</code>, followed
          by the <code>GetPath</code>. This way the combined <code>PATH</code> will record the
          whole route of the payload from the originating peer (initial
          <code>PutMessage</code>) to the requesting peer (initial <code>GetMessage</code>).<a href="#section-7.1.2-7">¶</a></p>
<p id="section-7.1.2-8">
          When receiving a message with flag <code>RecordRoute</code> and <code>PATH</code>,
          a peer is encouraged to verify the integrity of <code>PATH</code> (if the
          available resources of the peer allow this) by checking the signatures of
          the path elements.<a href="#section-7.1.2-8">¶</a></p>
<p id="section-7.1.2-9">
          If an invalid signature is detected, the path is truncated keeping only
          element fields following the faulty signature and setting the <code>Truncated</code>
          flag. Assume that peer C detects a faulty signature from peer B,
          the trunacted path has two entries:<a href="#section-7.1.2-9">¶</a></p>
<span id="name-example-truncated-path"></span><div id="figure_path_truncated">
<figure id="figure-4">
            <div id="section-7.1.2-10.1">
<pre>+-------+  +----------------------+-------+
| Pub B |  | Sig C (Pub B, Pub D) | Pub C |
+-------+  +----------------------+-------+
</pre>
</div>
<figcaption><a href="#figure-4">Figure 4</a>:
<a href="#name-example-truncated-path">Example truncated PATH</a>
            </figcaption></figure>
</div>
<p id="section-7.1.2-11">
          The <code>Truncated</code> flag indicates that the first path element does not contain
          a signature but only the public key of the peer where the signature fails.<a href="#section-7.1.2-11">¶</a></p>
</section>
</div>
<div id="p2p_pathelement">
<section id="section-7.1.3">
          <h4 id="name-path-element">
<a href="#section-7.1.3">7.1.3. </a><a href="#name-path-element">Path Element</a>
          </h4>
<p id="section-7.1.3-1">
          A path element represents a hop in the path a message has taken
          through the overlay network.
          The wire format of a path element is illustrated in
          <a href="#figure_pathelement">Figure 5</a>.<a href="#section-7.1.3-1">¶</a></p>
<span id="name-the-wire-format-of-a-path-e"></span><div id="figure_pathelement">
<figure id="figure-5">
            <div id="section-7.1.3-2.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   SIGNATURE                   |
|                   (64 bytes)                  |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|             PRED PEER PUBLIC KEY              |
|                  (32 bytes)                   |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-5">Figure 5</a>:
<a href="#name-the-wire-format-of-a-path-e">The Wire Format of a path element.</a>
            </figcaption></figure>
</div>
<p id="section-7.1.3-3">where:<a href="#section-7.1.3-3">¶</a></p>
<span></span><dl id="section-7.1.3-4">
            <dt id="section-7.1.3-4.1">SIGNATURE</dt>
            <dd id="section-7.1.3-4.2">
            is a 64 byte EdDSA signature <span>[<a href="#ed25519">ed25519</a>]</span> created
            using the current hop&#39;s private
            key which affirms the public keys of the peers from the
            previous and next hops.<a href="#section-7.1.3-4.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.3-4.3">PRED PEER PUBLIC KEY</dt>
            <dd id="section-7.1.3-4.4">
            is the EdDSA public key <span>[<a href="#ed25519">ed25519</a>]</span> of the previous peer on the path.<a href="#section-7.1.3-4.4">¶</a>
</dd>
          <dd></dd>
</dl>
<p id="section-7.1.3-5">
          An ordered list of path elements may be appended to any routed
          <code>PutMessages</code> or <code>ResultMessages</code>.
          The last signature (after which the peer public key is omitted)
   is created by the current hop only after the peer made its routing
   decision identifiying the successor peer. The peer public key is not
   included after the last signature as it must be that of the sender of
   the message and including it would thus be redundant.
   Similarly, the predecessor of the first element of
            an untruncated path is not stated explicitly, as it must be <code>ZERO</code>
            (32 NULL-bytes).<a href="#section-7.1.3-5">¶</a></p>
<p id="section-7.1.3-6">
          <a href="#figure_path_ex">Figure 6</a> shows the wire format of an example
          path from peer A over peers B and C and D as it would be received by peer E in the
          <code>PUTPATH</code> of a <code>PutMessage</code>, or as the combined
          <code>PUTPATH</code> and <code>GETPATH</code> of a <code>ResultMessage</code>.
          The wire format of the path elements allows a natural
          extension of the <code>PUTPATH</code> along the route of the <code>ResultMessage</code>
          to the destination forming the <code>GETPATH</code>.
          The <code>PutMessage</code> would indicate in the <code>PATH_LEN</code> field
          a length of 3.
          The <code>ResultMessage</code> would indicate a path length of 3 as the
          sum of the field values in <code>PUTPATH_L</code> and <code>GETPATH_L</code>.
   Basically, the last signature does not count for the path length.<a href="#section-7.1.3-6">¶</a></p>
<span id="name-example-of-a-path-as-found-"></span><div id="figure_path_ex">
<figure id="figure-6">
            <div id="section-7.1.3-7.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|                  SIGNATURE A                  |
|                  (64 bytes)                   |
|                                               |
|    (Over ZERO and PEER B signed by PEER A)    |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    PEER A                     |
|                  (32 bytes)                   |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                  SIGNATURE B                  |
|                  (64 bytes)                   |
|                                               |
|   (Over PEER A and PEER C signed by PEER B)   |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    PEER B                     |
|                  (32 bytes)                   |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                  SIGNATURE C                  |
|                  (64 bytes)                   |
|                                               |
|   (Over PEER B and PEER D signed by PEER C)   |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    PEER C                     |
|                  (32 bytes)                   |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|             SIGNATURE D (last sig)            |
|                  (64 bytes)                   |
|                                               |
|  (Over PEER C and receiver signed by PEER D)  |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-6">Figure 6</a>:
<a href="#name-example-of-a-path-as-found-">Example of a path as found in PutMessages or ResultMessages from Peer A to Peer D as transmitted by Peer D.</a>
            </figcaption></figure>
</div>
<p id="section-7.1.3-8">
          A path may be truncated in which case the signature of the truncated
          path element is omitted leaving only the public key of the peer preceeding
   the truncation which is required for the
          verification of the subsequent path element signature.
          Such a truncated path is indicated with the respective
   truncated flag (<a href="#route_flags">Section 7.1.1</a>).
          For truncated paths, the peer public key of the signer of the last path element is
   again omitted as it must be that of
          the sender of the <code>PutMesssage</code> or <code>ResultMessage</code>.  Similarly,
   the public key of the receiving peer used in the last path element is omitted as
   it must be SELF.
          The wire format of a truncated example path from peers B over C and D to E
          (possibly still originating at A, but the origin is unknowable to E due to truncation)
   is illustrated in <a href="#figure_path_ex_trunc">Figure 7</a>.
          Here, a <code>ResultMessage</code> would indicate in the <code>PATH_LEN</code> field
          a length of 1 while
          a <code>PutMessage</code> would indicate a length of 1 as the sum of
          <code>PUTPATH_L</code> and <code>GETPATH_L</code> fields.
   Basically, the truncated peer and the last signature do not count
   for the path length.<a href="#section-7.1.3-8">¶</a></p>
<span id="name-example-of-a-truncated-path"></span><div id="figure_path_ex_trunc">
<figure id="figure-7">
            <div id="section-7.1.3-9.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|             PEER B (truncated)                |
|                  (32 byte)                    |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                  SIGNATURE C                  |
|                  (64 bytes)                   |
|                                               |
|   (Over PEER B and PEER D signed by PEER C)   |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    PEER C                     |
|                  (32 bytes)                   |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|            SIGNATURE D (last sig)             |
|                  (64 byte)                    |
|                                               |
|  (Over PEER C and receiver signed by PEER D)  |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-7">Figure 7</a>:
<a href="#name-example-of-a-truncated-path">Example of a truncated path from Peer B to Peer D as transmitted by Peer D.</a>
            </figcaption></figure>
</div>
<p id="section-7.1.3-10">
          The SIGNATURE field in a path element covers a 64-bit contextualization header, the
          the block expiration, a hash of the block
          payload, as well as the predecessor peer public key and the peer public key of the
          successor that the peer making the signature is routing the
   message to.  Thus, the signature made by SELF basically says that
          SELF received the block payload from PEER PREDECESSOR and has forwarded
   it to PEER SUCCESSOR.  The wire format is illustrated
          in <a href="#figure_pathelewithpseudo">Figure 8</a>.<a href="#section-7.1.3-10">¶</a></p>
<span id="name-the-wire-format-of-the-path"></span><div id="figure_pathelewithpseudo">
<figure id="figure-8">
            <div id="section-7.1.3-11.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|         SIZE          |       PURPOSE         |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   EXPIRATION                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                  BLOCK HASH                   |
|                  (64 byte)                    |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                PEER PREDECESSOR               |
|                    (32 byte)                  |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                 PEER SUCCESSOR                |
|                    (32 byte)                  |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-8">Figure 8</a>:
<a href="#name-the-wire-format-of-the-path">The Wire Format of the path element for Signing.</a>
            </figcaption></figure>
</div>
<span></span><dl id="section-7.1.3-12">
            <dt id="section-7.1.3-12.1">SIZE</dt>
            <dd id="section-7.1.3-12.2">
            A 32-bit value containing the length of the signed data in bytes
            in network byte order.
            The length of the signed data <span>MUST</span> be 144 bytes.<a href="#section-7.1.3-12.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.3-12.3">PURPOSE</dt>
            <dd id="section-7.1.3-12.4">
            A 32-bit signature purpose flag. This field <span>MUST</span> be 6 (in network
            byte order).<a href="#section-7.1.3-12.4">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.3-12.5">EXPIRATION</dt>
            <dd id="section-7.1.3-12.6">
            denotes the absolute 64-bit expiration date of the block
            in microseconds since midnight (0 hour), January 1, 1970
            UTC in network byte order.<a href="#section-7.1.3-12.6">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.3-12.7">BLOCK HASH</dt>
            <dd id="section-7.1.3-12.8">
            a SHA-512 hash over the block payload.<a href="#section-7.1.3-12.8">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.3-12.9">PEER PREDECESSOR</dt>
            <dd id="section-7.1.3-12.10">
            the peer public key of the previous hop. If the signing peer initiated
            the PUT, this field is set to all zeroes.<a href="#section-7.1.3-12.10">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.1.3-12.11">PEER SUCCESSOR</dt>
            <dd id="section-7.1.3-12.12">
            the peer public key of the next hop (not of the signer).<a href="#section-7.1.3-12.12">¶</a>
</dd>
          <dd></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="p2p_hello">
<section id="section-7.2">
        <h3 id="name-hellomessage">
<a href="#section-7.2">7.2. </a><a href="#name-hellomessage">HelloMessage</a>
        </h3>
<p id="section-7.2-1">
          When the underlay signals the implementation of added or
          removed addresses through <code>ADDRESS_ADDED</code> and
          <code>ADDRESS_DELETED</code> an implementation
          <span>MUST</span> disseminate those changes to neighbors
          using <code>HelloMessages</code> (as already discussed in
          section <a href="#find_peer">Section 6.2</a>).  <code>HelloMessages</code>
          are used to inform neighbors of a peer about the sender&#39;s
          available addresses. The recipients use these messages to
          inform their respective underlays about ways to sustain the
          connections and to generate <code>HELLO</code> blocks (see <a href="#hello_block">Section 8.2</a>) to answer peer discovery queries
          from other peers.<a href="#section-7.2-1">¶</a></p>
<div id="p2p_hello_wire">
<section id="section-7.2.1">
          <h4 id="name-wire-format">
<a href="#section-7.2.1">7.2.1. </a><a href="#name-wire-format">Wire Format</a>
          </h4>
<span id="name-the-hellomessage-wire-forma"></span><div id="figure_hellomsg">
<figure id="figure-9">
            <div id="section-7.2.1-1.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|   MSIZE   |   MTYPE   |  VERSION  | NUM_ADDRS |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    SIGNATURE                  /
/                   (64 bytes)                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    EXPIRATION                 |
+-----+-----+-----+-----+-----+-----+-----+-----+
/          ADDRESSES (variable length)          /
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-9">Figure 9</a>:
<a href="#name-the-hellomessage-wire-forma">The HelloMessage Wire Format.</a>
            </figcaption></figure>
</div>
<p id="section-7.2.1-2">where:<a href="#section-7.2.1-2">¶</a></p>
<span></span><dl id="section-7.2.1-3">
            <dt id="section-7.2.1-3.1">MSIZE</dt>
            <dd id="section-7.2.1-3.2">
              denotes the size of this message in network byte order.<a href="#section-7.2.1-3.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.2.1-3.3">MTYPE</dt>
            <dd id="section-7.2.1-3.4">
              is the 16-bit message type.
              It must be set to
              the value 157 in network byte order as defined in the GANA &#34;GNUnet Message Type&#34; registry
              (see <a href="#gana_message_type">Section 11.4</a>).<a href="#section-7.2.1-3.4">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.2.1-3.5">VERSION</dt>
            <dd id="section-7.2.1-3.6">
              is a 16-bit field that indicates the version of the <code>HelloMessage</code>. Must be zero.
              In the future, this may be used to extend or update the <code>HelloMessage</code> format.<a href="#section-7.2.1-3.6">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.2.1-3.7">NUM_ADDRS</dt>
            <dd id="section-7.2.1-3.8">
              is a 16-bit number in network byte order that gives the
              total number of addresses encoded in the
              <code>ADDRESSES</code> field.<a href="#section-7.2.1-3.8">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.2.1-3.9">SIGNATURE</dt>
            <dd id="section-7.2.1-3.10">
              is a 64 byte EdDSA signature <span>[<a href="#ed25519">ed25519</a>]</span> using the sender&#39;s private
              key affirming the information contained in the message.
              The signature is signing exactly the same data that is being
              signed in a <code>HELLO</code> block as described in <a href="#hello_block">Section 8.2</a>.<a href="#section-7.2.1-3.10">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.2.1-3.11">EXPIRATION</dt>
            <dd id="section-7.2.1-3.12">
              denotes the absolute 64-bit expiration date of the content.
              The value specified is microseconds since midnight (0 hour),
              January 1, 1970, but must be a multiple of one million
              (so that it can be represented in seconds in a <code>HELLO</code> URL).
              Stored in network byte order.<a href="#section-7.2.1-3.12">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.2.1-3.13">ADDRESSES</dt>
            <dd id="section-7.2.1-3.14">
              A sequence of exactly <code>NUM_ADDRS</code>
              addresses which can be used to contact the peer.
              Each address <span>MUST</span> be 0-terminated.
              If <code>NUM_ADDRS = 0</code> then this field is omitted (0 bytes).<a href="#section-7.2.1-3.14">¶</a>
</dd>
          <dd></dd>
</dl>
</section>
</div>
<div id="p2p_hello_processing">
<section id="section-7.2.2">
          <h4 id="name-processing">
<a href="#section-7.2.2">7.2.2. </a><a href="#name-processing">Processing</a>
          </h4>
<p id="section-7.2.2-1">
            If the initiator of a <code>HelloMessage</code> is <code>SELF</code>, the message
            is simply sent to all neighbors <code>P</code> currently in the routing table
            using the <code>SEND()</code> function of the underlay as defined in
            <a href="#underlay">Section 5</a>.<a href="#section-7.2.2-1">¶</a></p>
<p id="section-7.2.2-2">
            Upon receiving a <code>HelloMessage</code> from a peer <code>P</code>
            an implementation <span>MUST</span> process it step by step as follows:<a href="#section-7.2.2-2">¶</a></p>
<ol start="1" type="1" id="section-7.2.2-3">
            <li id="section-7.2.2-3.1">
              If <code>P</code> is not in its routing table, the message is discarded.<a href="#section-7.2.2-3.1">¶</a>
</li>
            <li id="section-7.2.2-3.2">
              The signature is verified, including a check that the expiration time
              is in the future. If the signature is invalid, the message is discarded.<a href="#section-7.2.2-3.2">¶</a>
</li>
            <li id="section-7.2.2-3.3">
              The information contained in the <code>HelloMessage</code>
              is used to synthesize a block of type <code>HELLO</code>
              (<a href="#hello_block">Section 8.2</a>).  The block is cached in
              the routing table until it expires, or the peer is
              removed from the routing table, or the information is
              replaced by another message from the peer.  The
              implementation <span>SHOULD</span> instruct the
              underlay to connect to all now available addresses using
              <code>TRY_CONNECT()</code> in order to make the underlay
              aware of alternative addresses for this connection and
              to maintain optimal connectivity.<a href="#section-7.2.2-3.3">¶</a>
</li>
            <li id="section-7.2.2-3.4">
              Received <code>HelloMessages</code> <span>MUST NOT</span>
              be forwarded.<a href="#section-7.2.2-3.4">¶</a>
</li>
          </ol>
</section>
</div>
</section>
</div>
<div id="p2p_put">
<section id="section-7.3">
        <h3 id="name-putmessage">
<a href="#section-7.3">7.3. </a><a href="#name-putmessage">PutMessage</a>
        </h3>
<p id="section-7.3-1">
   <code>PutMessages</code> are used to store information at other
   peers in the DHT.  Any application-facing API which allows
   applications to initiate <code>PutMessages</code> to store data
   in the DHT needs to receive sufficient, possibly
   implementation-specific information to construct the initial
   <code>PutMessage</code>.  In general, application-facing APIs
   supporting multiple applications and block types need to be
   given the block type (<code>BTYPE</code>) and message
   <code>FLAGS</code> in addition to the actual <code>BLOCK</code>
   payload. The <code>BLOCK_KEY</code> could be provided
   explicitly, or in some cases might be derived using the
   <code>DeriveBlockKey()</code> function from the block type
   specific operations defined in <a href="#block_functions">Section 8.1</a>.<a href="#section-7.3-1">¶</a></p>
<div id="p2p_put_wire">
<section id="section-7.3.1">
          <h4 id="name-wire-format-2">
<a href="#section-7.3.1">7.3.1. </a><a href="#name-wire-format-2">Wire Format</a>
          </h4>
<span id="name-the-putmessage-wire-format"></span><div id="figure_putmsg">
<figure id="figure-10">
            <div id="section-7.3.1-1.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|   MSIZE   |   MTYPE   |         BTYPE         |
+-----+-----+-----+-----+-----+-----+-----+-----+
| VER |FLAGS| HOPCOUNT  | REPL_LVL  | PATH_LEN  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   EXPIRATION                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                     PEER_BF                   /
/                   (128 byte)                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    BLOCK_KEY                  /
/                    (64 byte)                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
/       TRUNCATED ORIGIN (0 or 32 bytes)        /
+-----+-----+-----+-----+-----+-----+-----+-----+
/           PUTPATH (variable length)           /
+-----+-----+-----+-----+-----+-----+-----+-----+
/      LAST HOP SIGNATURE (0 or 64 bytes)       /
+-----+-----+-----+-----+-----+-----+-----+-----+
/            BLOCK (variable length)            /
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-10">Figure 10</a>:
<a href="#name-the-putmessage-wire-format">The PutMessage Wire Format.</a>
            </figcaption></figure>
</div>
<p id="section-7.3.1-2">where:<a href="#section-7.3.1-2">¶</a></p>
<span></span><dl id="section-7.3.1-3">
            <dt id="section-7.3.1-3.1">MSIZE</dt>
            <dd id="section-7.3.1-3.2">
              denotes the size of this message in network byte order.<a href="#section-7.3.1-3.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.3">MTYPE</dt>
            <dd id="section-7.3.1-3.4">
              is the 16-bit message type. Read-only.  It must be set
              to the value 146 in network byte order as defined in the
              GANA &#34;GNUnet Message Type&#34; registry <a href="#gana_message_type">Section 11.4</a>.<a href="#section-7.3.1-3.4">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.5">BTYPE</dt>
            <dd id="section-7.3.1-3.6">
              is a 32-bit block type in network byte order.  The block
              type indicates the content type of the payload.  Set by
              the initiator. Read-only.<a href="#section-7.3.1-3.6">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.7">VER</dt>
            <dd id="section-7.3.1-3.8">
              is a 8-bit protocol version.
              Set to zero. May be used in future protocol versions.<a href="#section-7.3.1-3.8">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.9">FLAGS</dt>
            <dd id="section-7.3.1-3.10">
              is a 8-bit vector with binary options (see <a href="#route_flags">Section 7.1.1</a>).
              Set by the initiator. Read-only.<a href="#section-7.3.1-3.10">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.11">HOPCOUNT</dt>
            <dd id="section-7.3.1-3.12">
              is a 16-bit number in network byte order indicating how
              many hops this message has traversed to far.  Set by the
              initiator to zero.  <span>MUST</span> be incremented by one
              by each peer before forwarding the request.<a href="#section-7.3.1-3.12">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.13">REPL_LVL</dt>
            <dd id="section-7.3.1-3.14">
              is a 16-bit number in network byte order indicating the
              desired replication level of the data.  Set by the
              initiator. Read-only.<a href="#section-7.3.1-3.14">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.15">PATH_LEN</dt>
            <dd id="section-7.3.1-3.16">
              is a 16-bit number in network byte order indicating the
              number of path elements recorded in <code>PUTPATH</code>.  As <code>PUTPATH</code>
              is optional, this value may be zero.  If the <code>PUTPATH</code> is
              enabled, set initially to zero by the initiator.  Updated
              by processing peers to match the path length in the
              message.<a href="#section-7.3.1-3.16">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.17">EXPIRATION</dt>
            <dd id="section-7.3.1-3.18">
              denotes the absolute 64-bit expiration date of the
              content in microseconds since midnight (0 hour), January
              1, 1970 in network byte order.  Set by the
              initiator. Read-only.<a href="#section-7.3.1-3.18">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.19">PEER_BF</dt>
            <dd id="section-7.3.1-3.20">
              A peer Bloom filter to stop circular routes (see <a href="#routing_bloomfilter">Section 6.3</a>).  Set by the initiator
              to contain the local peer and all neighbors it is
              forwarded to.  Modified by processing peers to include
              their own peer public key using <code>BF-SET()</code>.<a href="#section-7.3.1-3.20">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.21">BLOCK_KEY</dt>
            <dd id="section-7.3.1-3.22">
              The key under which the <code>PutMessage</code> wants to store content
              under.
              Set by the initiator. Read-only.<a href="#section-7.3.1-3.22">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.23">TRUNCATED ORIGIN</dt>
            <dd id="section-7.3.1-3.24">
              is only provided if the <code>Truncated</code> flag is set
              in <code>FLAGS</code>. If present, this is the public key of
              the peer just before the first entry on the
              <code>PUTPATH</code> and the first peer on the
              <code>PUTPATH</code> is not the actual origin of the
              message.  Thus, to verify the first signature on the
              <code>PUTPATH</code>, this public key must be used.  Note
              that due to the truncation, this last hop cannot be
              verified to exist.  Value is modified by processing
              peers.<a href="#section-7.3.1-3.24">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.25">PUTPATH</dt>
            <dd id="section-7.3.1-3.26">
              the variable-length <code>PUT</code> path.
              The path consists of a list of <code>PATH_LEN</code> path elements.
              Set by the initiator to zero.
              Incremented by processing peers.<a href="#section-7.3.1-3.26">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.27">LAST HOP SIGNATURE</dt>
            <dd id="section-7.3.1-3.28">
              is only provided if the <code>RecordRoute</code> flag
              is set in <code>FLAGS</code>. If present, this is
              an EdDSA signature <span>[<a href="#ed25519">ed25519</a>]</span> by the sender of this message
              (using the same format as the signatures in PUTPATH)
              affirming that the sender forwarded the message from
              the predecessor (all zeros if <code>PATH_LEN</code> is zero,
              otherwise the last peer in <code>PUTPATH</code>) to
              the target peer.
              Modified by processing peers (if flag is set).<a href="#section-7.3.1-3.28">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.3.1-3.29">BLOCK</dt>
            <dd id="section-7.3.1-3.30">
              the variable-length block payload. The contents are
              determined by the <code>BTYPE</code> field.  The length is
              determined by <code>MSIZE</code> minus the size of all of
              the other fields.  Set by the initiator. Read-only.<a href="#section-7.3.1-3.30">¶</a>
</dd>
          <dd></dd>
</dl>
</section>
</div>
<div id="p2p_put_processing">
<section id="section-7.3.2">
          <h4 id="name-processing-2">
<a href="#section-7.3.2">7.3.2. </a><a href="#name-processing-2">Processing</a>
          </h4>
<p id="section-7.3.2-1">
            Upon receiving a <code>PutMessage</code> from a peer <code>P</code>,
            or created through initiation by an overlay API,
            an implementation <span>MUST</span> process it step by step as follows:<a href="#section-7.3.2-1">¶</a></p>
<ol start="1" type="1" id="section-7.3.2-2">
            <li id="section-7.3.2-2.1">
              The <code>EXPIRATION</code> field is evaluated.
              If the message is expired, it <span>MUST</span> be discarded.<a href="#section-7.3.2-2.1">¶</a>
</li>
            <li id="section-7.3.2-2.2">
              If the <code>BTYPE</code> is <code>ANY</code>, then the message
              <span>MUST</span> be discarded.  If the <code>BTYPE</code>
              is not supported by the implementation, no validation of
              the block payload is performed and processing continues
              at (5).  Else, the block <span>MUST</span> be
              validated as defined in (3) and (4).<a href="#section-7.3.2-2.2">¶</a>
</li>
            <li id="section-7.3.2-2.3">
              The message is evaluated using the block validation
              functions matching the <code>BTYPE</code>. First, the client
              attempts to derive the key using the respective
              <code>DeriveBlockKey</code> procedure as described in <a href="#block_functions">Section 8.1</a>.  If a key can be derived and
              does not match, the message <span>MUST</span> be
              discarded.<a href="#section-7.3.2-2.3">¶</a>
</li>
            <li id="section-7.3.2-2.4">
       Next, the <code>ValidateBlockStoreRequest</code> procedure
       for the <code>BTYPE</code> as described in <a href="#block_functions">Section 8.1</a> is used to validate the block
       payload. If the block payload is invalid, the message
       <span>MUST</span> be discarded.<a href="#section-7.3.2-2.4">¶</a>
</li>
            <li id="section-7.3.2-2.5">
              The peer identity of the sender peer <code>P</code>
              <span>SHOULD</span> be in <code>PEER_BF</code>.  If not,
              the implementation <span>MAY</span> log an error, but
              <span>MUST</span> continue.<a href="#section-7.3.2-2.5">¶</a>
</li>
            <li id="section-7.3.2-2.6">
              If the <code>RecordRoute</code> flag is not set, the
              <code>PATH_LEN</code> <span>MUST</span> be set to zero.
              If the flag is set and <code>PATH_LEN</code> is non-zero,
              the local peer <span>SHOULD</span> verify the
              signatures from the <code>PUTPATH</code>.  Verification
              <span>MAY</span> involve checking all signatures or
              any random subset of the signatures.  It is
              <span>RECOMMENDED</span> that peers adapt their
              behavior to available computational resources so as to
              not make signature verification a bottleneck.  If an
              invalid signature is found, the <code>PUTPATH</code>
              <span>MUST</span> be truncated to only include the
              elements following the invalid signature.<a href="#section-7.3.2-2.6">¶</a>
</li>
            <li id="section-7.3.2-2.7">
              If the local peer is the closest peer
              (cf. <code>IsClosestPeer(SELF, BLOCK_KEY,
              PeerFilter)</code>) or the <code>DemultiplexEverywhere</code>
              flag ist set, the message <span>SHOULD</span> be
              stored locally in the block storage if possible.  The
              implementation <code>MAY</code> choose not store the block
              if external factors or configurations prevent this, such
              as limited (allotted) disk space.<a href="#section-7.3.2-2.7">¶</a>
</li>
            <li id="section-7.3.2-2.8">
              If the <code>BTYPE</code> of the message indicates a
              <code>HELLO</code> block, the peer <span>MUST</span> be
              considered for the local routing table by using the peer
              identity in <code>BLOCK_KEY</code>.  If neither the peer is
              already connected nor the respective k-bucket is already
              full, then the peer <span>MUST</span> try to establish
              a connection to the peer indicated in the <code>HELLO</code>
              block using the address information from the
              <code>HELLO</code> block and the underlay&#39;s
              <code>TRY_CONNECT()</code> function.  The implementation
              <span>MUST</span> instruct the underlay to try to
              connect to all provided addresses using
              <code>TRY_CONNECT()</code> in order to make the underlay
              aware of multiple addresses for this connection.  When a
              connection can be established, the underlay&#39;s
              <code>PEER_CONNECTED</code> signal will cause the peer to be
              added to the respective k-bucket of the routing table
              (<a href="#routing">Section 6</a>).<a href="#section-7.3.2-2.8">¶</a>
</li>
            <li id="section-7.3.2-2.9">
              Given the value in <code>REPL_LVL</code>, <code>HOPCOUNT</code>
              and <code>FALSE = IsClosestPeer(SELF, BLOCK_KEY,
              PeerFilter)</code> the number of peers to forward to
              <span>MUST</span> be calculated using
              <code>ComputeOutDegree()</code>.  The implementation
              <span>SHOULD</span> select this number of peers
              to forward the message to using the function
              <code>SelectPeer()</code> (<a href="#routing_functions">Section 6.4</a>) using the
              <code>BLOCK_KEY</code>, <code>HOPCOUNT</code>, and utilizing
              <code>PEER_BF</code> as peer Bloom filter.  For each
              selected peer <code>PEER_BF</code> is updated with that peer
              in between calls to <code>SelectPeer()</code>.  The
              implementation <span>MAY</span> forward to fewer or no
              peers in order to handle resource constraints such as
              limited bandwidth or simply because there are not enough
              suitable connected peers.  For each selected peer with
              peer identity <code>P</code> a dedicated
              <code>PutMessage_P</code> is created containing the original
              (and where applicable already updated) fields of the
              received <code>PutMessage</code>.  In each message
              <em>all</em> selected peer identities and the local peer
              identity <span>MUST</span> be added to the
              <code>PEER_BF</code> and the <code>HOPCOUNT</code>
              <span>MUST</span> be incremented by one.  If the
              <code>RecordRoute</code> flag is set, a new path element is
              created using the predecessor peer public key and the
              signature of the current peer.  The path element is
              added to the <code>PUTPATH</code> fields and the
              <code>PATH_LEN</code> field is incremented by one.  When
              creating the path element signature, the successor must
              be set to the recipient peer <code>P</code> of the
              <code>PutMessage_P</code>.  The successor in the new path
              element is the recipient peer <code>P</code>.  If the path
              becomes too long for the resulting message to be
              transmitted by the underlay, it <span>MUST</span> be
              truncated.  Finally, the messages are sent using
              <code>SEND(P, PutMessage_P)</code> to each recipient.<a href="#section-7.3.2-2.9">¶</a>
</li>
          </ol>
</section>
</div>
</section>
</div>
<div id="p2p_get">
<section id="section-7.4">
        <h3 id="name-getmessage">
<a href="#section-7.4">7.4. </a><a href="#name-getmessage">GetMessage</a>
        </h3>
<p id="section-7.4-1">
   <code>GetMessages</code> are used to request information from
   other peers in the DHT.  An application-level API which
   allows applications to initiate <code>GetMessages</code> needs
   to provide sufficient, implementation-specific information
   needed to construct the initial <code>GetMessage</code>.  For
   example, implementations supporting multiple applications
   and blocks will need to be given the block type, message
   <code>FLAG</code> parameters and possibly an <code>XQUERY</code> in
   addition to just the <code>QUERY_HASH</code>. In some cases, it
   might also be useful to enable the application to assist in
   the construction of the <code>RESULT_FILTER</code> such that it
   can filter already known results.  Note that the
   <code>RESULT_FILTER</code> may need to be re-constructed every
   time the query is retransmitted by the initiator (details
   depending on the <code>BTYPE</code>) and thus a
   <code>RESULT_FILTER</code> can often not be passed directly as
   an argument by the application to an application API.
   Instead, applications would typically provide the set of
   results to be filtered, allowing the DHT to construct the
   <code>RESULT_FILTER</code> whenever it retransmits a
   <code>GetMessage</code> request as initiator.<a href="#section-7.4-1">¶</a></p>
<div id="p2p_get_wire">
<section id="section-7.4.1">
          <h4 id="name-wire-format-3">
<a href="#section-7.4.1">7.4.1. </a><a href="#name-wire-format-3">Wire Format</a>
          </h4>
<span id="name-the-getmessage-wire-format"></span><div id="figure_getmsg">
<figure id="figure-11">
            <div id="section-7.4.1-1.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|   MSIZE   |   MTYPE   |         BTYPE         |
+-----+-----+-----+-----+-----+-----+-----+-----+
| VER |FLAGS|  HOPCOUNT | REPL_LVL  |  RF_SIZE  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    PEER_BF                    /
/                   (128 byte)                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   QUERY_HASH                  /
/                   (64 byte)                   |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                 RESULT_FILTER                 /
/               (variable length)               /
+-----+-----+-----+-----+-----+-----+-----+-----+
/            XQUERY (variable length)           /
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-11">Figure 11</a>:
<a href="#name-the-getmessage-wire-format">The GetMessage Wire Format.</a>
            </figcaption></figure>
</div>
<p id="section-7.4.1-2">where:<a href="#section-7.4.1-2">¶</a></p>
<span></span><dl id="section-7.4.1-3">
            <dt id="section-7.4.1-3.1">MSIZE</dt>
            <dd id="section-7.4.1-3.2">
              denotes the size of this message in network byte order.<a href="#section-7.4.1-3.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.3">MTYPE</dt>
            <dd id="section-7.4.1-3.4">
              is the 16-bit message type. Read-only.  It must be set
              to the value 147 in network byte order as defined in the
              GANA &#34;GNUnet Message Type&#34; registry <a href="#gana_message_type">Section 11.4</a>.<a href="#section-7.4.1-3.4">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.5">BTYPE</dt>
            <dd id="section-7.4.1-3.6">
              is a 32-bit block type field in network byte order. The
              block type indicates the content type of the
              payload. Set by the initiator. Read-only.<a href="#section-7.4.1-3.6">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.7">VER</dt>
            <dd id="section-7.4.1-3.8">
              is a 8-bit protocol version.
              Set to zero. May be used in future protocol versions.<a href="#section-7.4.1-3.8">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.9">FLAGS</dt>
            <dd id="section-7.4.1-3.10">
              is a 8-bit vector with binary options (see <a href="#route_flags">Section 7.1.1</a>).
              Set by the initiator. Read-only.<a href="#section-7.4.1-3.10">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.11">HOPCOUNT</dt>
            <dd id="section-7.4.1-3.12">
              is a 16-bit number in network byte order indicating how
              many hops this message has traversed to far.  Set by the
              initiator to zero.  Incremented by each peer by one
              per hop.<a href="#section-7.4.1-3.12">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.13">REPL_LVL</dt>
            <dd id="section-7.4.1-3.14">
              is a 16-bit number in network byte order indicating the
              desired replication level of the data.  Set by the
              initiator. Read-only.<a href="#section-7.4.1-3.14">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.15">RF_SIZE</dt>
            <dd id="section-7.4.1-3.16">
              is a 16-bit number in network byte order indicating the
              length of the <code>RESULT_FILTER</code>.  Set by the
              initiator. Read-only.<a href="#section-7.4.1-3.16">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.17">PEER_BF</dt>
            <dd id="section-7.4.1-3.18">
              A peer Bloom filter to stop circular routes (see <a href="#routing_bloomfilter">Section 6.3</a>).
              Set by the initiator to include itself and all connected neighbors in the routing table.
              Modified by processing peers to include their own peer identity.<a href="#section-7.4.1-3.18">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.19">QUERY_HASH</dt>
            <dd id="section-7.4.1-3.20">
              The query used to indicate what the key is under which
              the initiator is looking for blocks with this request.
              The block type may use a different evaluation logic to
              determine applicable result blocks.  Set by the
              initiator. Read-only.<a href="#section-7.4.1-3.20">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.21">RESULT_FILTER</dt>
            <dd id="section-7.4.1-3.22">
              the variable-length result filter with <code>RF_SIZE</code>
              bytes as described in <a href="#result_filter">Section 7.4.2</a>.
              Set by the initiator.  Modified by processing peers
              based on results returned.<a href="#section-7.4.1-3.22">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.4.1-3.23">XQUERY</dt>
            <dd id="section-7.4.1-3.24">
              the variable-length extended query. Optional.
              Set by the initiator. Read-only. The length is
              determined by subtracting the length of all
              other fields from <code>MSIZE</code>.<a href="#section-7.4.1-3.24">¶</a>
</dd>
          <dd></dd>
</dl>
</section>
</div>
<div id="result_filter">
<section id="section-7.4.2">
          <h4 id="name-result-filter">
<a href="#section-7.4.2">7.4.2. </a><a href="#name-result-filter">Result Filter</a>
          </h4>
<p id="section-7.4.2-1">
            A result filter is used to indicate to other peers which
            results are not of interest when processing a
            <code>GetMessage</code> (<a href="#p2p_get">Section 7.4</a>).  Any peer
            which is processing <code>GetMessages</code> and has a result
            which matches the query key <span>MUST</span> check the
            result filter and only send a reply message if the result
            does not test positive under the result filter. Before
            forwarding the <code>GetMessage</code>, the result filter
            <span>MUST</span> be updated using the result of the
            <code>BTYPE</code>-specific <code>FilterResult</code> (see <a href="#block_functions">Section 8.1</a>) function to filter out all
            results already returned by the local peer.<a href="#section-7.4.2-1">¶</a></p>
<p id="section-7.4.2-2">
            How a result filter is implemented depends on the block type
     as described in <a href="#block_functions">Section 8.1</a>.
     Result filters may be probabilistic data structures. Thus,
     it is possible that a desireable result is filtered by a result
     filter because of a false-positive test.<a href="#section-7.4.2-2">¶</a></p>
<p id="section-7.4.2-3">
     How exactly a block result is added to a result filter is
     specified as part of the definition of a block type
     (cf. <a href="#hello_block">Section 8.2</a>).<a href="#section-7.4.2-3">¶</a></p>
</section>
</div>
<div id="p2p_get_processing">
<section id="section-7.4.3">
          <h4 id="name-processing-3">
<a href="#section-7.4.3">7.4.3. </a><a href="#name-processing-3">Processing</a>
          </h4>
<p id="section-7.4.3-1">
            Upon receiving a <code>GetMessage</code> from a peer <code>P</code>, or
            created through initiation by the overlay API, an
            implementation <span>MUST</span> process it step by step as follows:<a href="#section-7.4.3-1">¶</a></p>
<ol start="1" type="1" id="section-7.4.3-2">
            <li id="section-7.4.3-2.1">
              If the <code>BTYPE</code> is supported, the
              <code>QUERY_HASH</code> and <code>XQUERY</code> fields are
              validated as defined by the respective
              <code>ValidateBlockQuery()</code> procedure for this type.  If
              the result yields <code>REQUEST_INVALID</code>, the message
              <span>MUST</span> be discarded and processing ends.
              If the <code>BTYPE</code> is not supported, the message
              <span>MUST</span> be forwarded (Skip to step 4).  If
              the <code>BTYPE</code> is <code>ANY</code>, the message is
              processed further without validation.<a href="#section-7.4.3-2.1">¶</a>
</li>
            <li id="section-7.4.3-2.2">
              The peer identity of the sender peer <code>P</code>
              <span>SHOULD</span> be in the <code>PEER_BF</code> peer
              Bloom filter. If not, the implementation
              <span>MAY</span> log an error, but <span>MUST</span>
              continue.<a href="#section-7.4.3-2.2">¶</a>
</li>
            <li id="section-7.4.3-2.3">
              <p id="section-7.4.3-2.3.1">
                The local peer <span>SHOULD</span> try to produce a
                reply in any of the following cases: (1) If the local
                peer is the closest peer (cf. <code>IsClosestPeer(SELF,
                QueryHash, PeerFilter)</code>, or (2) if the
                <code>DemultiplexEverywhere</code> flag is set, or (3) if
                the local peer is not the closest and a previously
                cached <code>ResultMessage</code> also matches this
                request (<a href="#p2p_result_processing">Section 7.5.2</a>).<a href="#section-7.4.3-2.3.1">¶</a></p>
<p id="section-7.4.3-2.3.2">
                The reply is produced (if one is available) using the following
                steps:<a href="#section-7.4.3-2.3.2">¶</a></p>
<span></span><dl id="section-7.4.3-2.3.3">
                <dt>a)</dt>
<dd id="section-7.4.3-2.3.3.1">
                  If the <code>BTYPE</code> is <code>HELLO</code>, the
                  implementation <span>MUST</span> only consider
                  synthesizing its own addresses and the addresses it
                  has cached for the peers in its routing table as
                  <code>HELLO</code> block replies.  Otherwise, if the
                  <code>BTYPE</code> does not indicate a request for a
                  <code>HELLO</code> block or <code>ANY</code>, the
                  implementation <span>MUST</span> only consider
                  blocks in the local block storage and previously
                  cached <code>ResultMessages</code>.<a href="#section-7.4.3-2.3.3.1">¶</a>
</dd>
                <dd></dd>
<dt>b)</dt>
<dd id="section-7.4.3-2.3.3.2">
                  If the <code>FLAGS</code> field includes the flag
                  <code>FindApproximate</code>, the peer
                  <span>SHOULD</span> respond with the closest block
                  (smallest value of <code>GetDistance(QUERY_HASH,
                  BLOCK_KEY)</code>) it can find that is not filtered by
                  the <code>RESULT_BF</code>.  Otherwise, the peer
                  <span>MUST</span> respond with the block with a
                  <code>BLOCK_KEY</code> that matches the
                  <code>QUERY_HASH</code> exactly and that is not filtered
                  by the <code>RESULT_BF</code>.<a href="#section-7.4.3-2.3.3.2">¶</a>
</dd>
                <dd></dd>
<dt>c)</dt>
<dd id="section-7.4.3-2.3.3.3">
                  Any resulting (synthesized) block is encapsulated in
                  a <code>ResultMessage</code>.  The
                  <code>ResultMessage</code> <span>SHOULD</span> be
                  transmitted to the neighbor from which the request
                  was received.<a href="#section-7.4.3-2.3.3.3">¶</a>
</dd>
              <dd></dd>
</dl>
<p id="section-7.4.3-2.3.4">
                Implementations <span>MAY</span> not reply if they
                are resource-constrained.  However,
                <code>ResultMessages</code> <span>MUST</span> be given
                the highest priority among competing transmissions.<a href="#section-7.4.3-2.3.4">¶</a></p>
<p id="section-7.4.3-2.3.5">
        If the <code>BTYPE</code> is supported and
        <code>ValidateBlockReply</code> for the given query has
        yielded a status of <code>FILTER_LAST</code>, processing
        <span>MUST</span> end and not continue with
        forwarding of the request to other peers.<a href="#section-7.4.3-2.3.5">¶</a></p>
</li>
            <li id="section-7.4.3-2.4">
              The implementation <code>MUST</code> create (or merge) an
              entry in the pending table (see <a href="#pending_table">Section 6.5</a>) for the query represented by
              this <code>GetMessage</code>.  The pending table
              <span>MUST</span> store the last <code>MAX_RECENT</code>
              requests, and peers thus <span>MUST</span> discard the
              oldest existing request if memory constraints on the
              pending table are encountered. Note that peers
              <span>MUST</span> clean up state for queries that had
              response with a status of <code>FILTER_LAST</code> even if
              they are not the oldest query in the pending table.<a href="#section-7.4.3-2.4">¶</a>
</li>
            <li id="section-7.4.3-2.5">
              Using the value in <code>REPL_LVL</code>, the number of
              peers to forward to <span>MUST</span> be calculated
              using <code>ComputeOutDegree()</code>.  If there is at least
              one peer to forward to, the implementation
              <span>SHOULD</span> select up to this number of peers
              to forward the message to. Furthermore, the
              implementation <span>SHOULD</span> select up to this
              number of peers to using the function
              <code>SelectPeer()</code> (from <a href="#routing_functions">Section 6.4</a>) using the
              <code>QUERY_HASH</code>, <code>HOPCOUNT</code>, and the
              <code>PEER_BF</code>.  The implementation <span>MAY</span>
              forward to fewer or no peers in order to handle resource
              constraints such as bandwidth.  Before forwarding, the
              peer Bloom filter <code>PEER_BF</code> <span>MUST</span>
              be updated to filter all selected peers and the local
              peer identity <code>SELF</code>.  For all peers with peer
              identity <code>P</code> chosen to forward the message to,
              <code>SEND(P, GetMessage_P)</code> is called.  Here,
              <code>GetMessage_P</code> is the original message with the
              updated fields for <code>HOPCOUNT</code> (incremented by
              one), updated <code>PEER_BF</code> and updated
              <code>RESULT_FILTER</code> (based on results already
              returned).<a href="#section-7.4.3-2.5">¶</a>
</li>
          </ol>
</section>
</div>
</section>
</div>
<div id="p2p_result">
<section id="section-7.5">
        <h3 id="name-resultmessage">
<a href="#section-7.5">7.5. </a><a href="#name-resultmessage">ResultMessage</a>
        </h3>
<p id="section-7.5-1">
   <code>ResultMessages</code> are used to return information to
   other peers in the DHT or to applications using the overlay
   API that previously initiated a <code>GetMessage</code>.  The
   initiator of a <code>ResultMessage</code> is a peer triggered
   through the processing of a <code>GetMessage</code>.<a href="#section-7.5-1">¶</a></p>
<div id="p2p_result_wire">
<section id="section-7.5.1">
          <h4 id="name-wire-format-4">
<a href="#section-7.5.1">7.5.1. </a><a href="#name-wire-format-4">Wire Format</a>
          </h4>
<span id="name-the-resultmessage-wire-form"></span><div id="figure_resmsg">
<figure id="figure-12">
            <div id="section-7.5.1-1.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|   MSIZE   |   MTYPE   |        BTYPE          |
+-----+-----+-----+-----+-----+-----+-----+-----+
|  RESERVED | VER |FLAGS| PUTPATH_L | GETPATH_L |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   EXPIRATION                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   QUERY_HASH                  /
/                   (64 byte)                   |
+-----+-----+-----+-----+-----+-----+-----+-----+
/       TRUNCATED ORIGIN (0 or 32 bytes)        /
+-----+-----+-----+-----+-----+-----+-----+-----+
/                    PUTPATH                    /
/                (variable length)              /
+-----+-----+-----+-----+-----+-----+-----+-----+
/                    GETPATH                    /
/                (variable length)              /
+-----+-----+-----+-----+-----+-----+-----+-----+
/      LAST HOP SIGNATURE (0 or 64 bytes)       /
+-----+-----+-----+-----+-----+-----+-----+-----+
/                     BLOCK                     /
/               (variable length)               /
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-12">Figure 12</a>:
<a href="#name-the-resultmessage-wire-form">The ResultMessage Wire Format</a>
            </figcaption></figure>
</div>
<p id="section-7.5.1-2">where:<a href="#section-7.5.1-2">¶</a></p>
<span></span><dl id="section-7.5.1-3">
            <dt id="section-7.5.1-3.1">MSIZE</dt>
            <dd id="section-7.5.1-3.2">
              denotes the size of this message in network byte order.<a href="#section-7.5.1-3.2">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.3">MTYPE</dt>
            <dd id="section-7.5.1-3.4">
              is the 16-bit message type. Set by the
              initiator. Read-only.  It must be set to the value 148
              in network byte order as defined in the GANA &#34;GNUnet
              Message Type&#34; registry (see <a href="#gana_message_type">Section 11.4</a>).<a href="#section-7.5.1-3.4">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.5">BTYPE</dt>
            <dd id="section-7.5.1-3.6">
              is a 32-bit block type field in network byte order. The
              block type indicates the content type of the payload.
              Set by the initiator. Read-only.<a href="#section-7.5.1-3.6">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.7">RESERVED</dt>
            <dd id="section-7.5.1-3.8">
              is a 16-bit value. Implementations <span>MUST</span>
              set this value to zero when originating a result message.
              Implementations <span>MUST</span> forward
              this value unchanged even if it is non-zero.<a href="#section-7.5.1-3.8">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.9">VER</dt>
            <dd id="section-7.5.1-3.10">
              is a 8-bit protocol version in network byte order.
              Set to zero. May be used in future protocol versions.<a href="#section-7.5.1-3.10">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.11">FLAGS</dt>
            <dd id="section-7.5.1-3.12">
              is a 8-bit vector with binary options (see <a href="#route_flags">Section 7.1.1</a>).  Set by the initiator of the
              response based on the flags retained from the original
              <code>PutMessage</code>, possibly setting the
              <code>Truncated</code> bit if the initiator is forced to
              truncate the path.  For <code>HELLO</code> blocks, the
              <code>FLAGS</code> should simply be cleared.<a href="#section-7.5.1-3.12">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.13">PUTPATH_L</dt>
            <dd id="section-7.5.1-3.14">
              is a 16-bit number in network byte order indicating the
              number of path elements recorded in <code>PUTPATH</code>. As
              <code>PUTPATH</code> is optional, this value may be zero
              even if the message has traversed several peers.  Set by
              the initiator to the <code>PATH_LEN</code> of the
              <code>PutMessage</code> from which the block originated.
              Modified by processing peers in case of path truncation.<a href="#section-7.5.1-3.14">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.15">GETPATH_L</dt>
            <dd id="section-7.5.1-3.16">
              is a 16-bit number in network byte order indicating the
              number of path elements recorded in <code>GETPATH</code>. As
              <code>GETPATH</code> is optional, this value may be zero
              even if the message has traversed several peers.
              <span>MUST</span> be set to zero by the initiator.
              Modified by processing peers to match the path length in
              the message.<a href="#section-7.5.1-3.16">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.17">EXPIRATION</dt>
            <dd id="section-7.5.1-3.18">
              denotes the absolute 64-bit expiration date of the
              content in microseconds since midnight (0 hour), January
              1, 1970 in network byte order.  Set by the initiator to
              the expiration value as recorded from the
              <code>PutMessage</code> from which the block originated.
              Read-only.<a href="#section-7.5.1-3.18">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.19">QUERY_HASH</dt>
            <dd id="section-7.5.1-3.20">
              the query hash corresponding to the <code>GetMessage</code>
              which caused this reply message to be sent.  Set by the
              initiator using the value of the <code>GetMessage</code>.
              Read-only.<a href="#section-7.5.1-3.20">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.21">TRUNCATED ORIGIN</dt>
            <dd id="section-7.5.1-3.22">
              is only provided if the <code>Truncated</code> flag is set
              in <code>FLAGS</code>. If present, this is the public key of
              the peer just before the first entry on the
              <code>PUTPATH</code> and the first peer on the
              <code>PUTPATH</code> is not the actual origin of the
              message.  Thus, to verify the first signature on the
              <code>PUTPATH</code>, this public key must be used.  Note
              that due to the truncation, this last hop cannot be
              verified to exist.  Set by processing peers.<a href="#section-7.5.1-3.22">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.23">PUTPATH</dt>
            <dd id="section-7.5.1-3.24">
              the variable-length PUT path.  The path consists of a
              list of <code>PUTPATH_L</code> path elements.  Set by the
              initiator to the the <code>PUTPATH</code> of the
              <code>PutMessage</code> from which the block originated.
              Modified by processing peers in case of path truncation.<a href="#section-7.5.1-3.24">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.25">GETPATH</dt>
            <dd id="section-7.5.1-3.26">
              the variable-length PUT path.  The path consists of a
              list of <code>GETPATH_L</code> path elements.  Set by
              processing peers.<a href="#section-7.5.1-3.26">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.27">LAST HOP SIGNATURE</dt>
            <dd id="section-7.5.1-3.28">
              is only provided if the <code>RecordRoute</code> flag is set
              in <code>FLAGS</code>. If present, this is an EdDSA
              signature <span>[<a href="#ed25519">ed25519</a>]</span> by the sender of this
              message (using the same format as the signatures in
              <code>PUTPATH</code>) affirming that the sender forwarded
              the message from the predecessor (all zeros if
              <code>PATH_LEN</code> is zero, otherwise the last peer in
              <code>PUTPATH</code>) to the target peer.<a href="#section-7.5.1-3.28">¶</a>
</dd>
            <dd></dd>
<dt id="section-7.5.1-3.29">BLOCK</dt>
            <dd id="section-7.5.1-3.30">
              the variable-length resource record data payload.  The
              contents are defined by the respective type of the
              resource record.  Set by the initiator. Read-only.<a href="#section-7.5.1-3.30">¶</a>
</dd>
          <dd></dd>
</dl>
</section>
</div>
<div id="p2p_result_processing">
<section id="section-7.5.2">
          <h4 id="name-processing-4">
<a href="#section-7.5.2">7.5.2. </a><a href="#name-processing-4">Processing</a>
          </h4>
<p id="section-7.5.2-1">
            Upon receiving a <code>ResultMessage</code> from a connected
            peer or triggered by the processing of a
            <code>GetMessage</code>, an implementation <span>MUST</span>
            process it step by step as follows:<a href="#section-7.5.2-1">¶</a></p>
<ol start="1" type="1" id="section-7.5.2-2">
            <li id="section-7.5.2-2.1">
              First, the <code>EXPIRATION</code> field is evaluated.  If
              the message is expired, it <span>MUST</span> be
              discarded.<a href="#section-7.5.2-2.1">¶</a>
</li>
            <li id="section-7.5.2-2.2">
              If the <code>BTYPE</code> is supported, then the
              <code>BLOCK</code> <span>MUST</span> be validated against
              the requested <code>BTYPE</code>.  To do this, the peer
              checks that the block is valid using
              <code>ValidateBlockStoreRequest</code>.  If the result is
              <code>BLOCK_INVALID</code>, the message <span>MUST</span>
              be discarded.<a href="#section-7.5.2-2.2">¶</a>
</li>
            <li id="section-7.5.2-2.3">
              If the <code>PUTPATH_L</code> or the <code>GETPATH_L</code> are
              non-zero, the local peer <span>SHOULD</span> verify
              the signatures from the <code>PUTPATH</code> and the
              <code>GETPATH</code>.  Verification <span>MAY</span>
              involve checking all signatures or any random subset of
              the signatures.  It is <span>RECOMMENDED</span> that
              peers adapt their behavior to available computational
              resources so as to not make signature verification a
              bottleneck.  If an invalid signature is found, the path
              <span>MUST</span> be truncated to only include the
              elements following the invalid signature.  In
              particular, any invalid signature on the
              <code>GETPATH</code> will cause <code>PUTPATH_L</code> to be set
              to zero.<a href="#section-7.5.2-2.3">¶</a>
</li>
            <li id="section-7.5.2-2.4">
       The peer also attempts to compute the key using
       <code>DeriveBlockKey</code>.  This may result in
       <code>NONE</code>.  The result is used later.  Note that
       even if a key was computed, it does not have to match
       the <code>QUERY_HASH</code>.<a href="#section-7.5.2-2.4">¶</a>
</li>
            <li id="section-7.5.2-2.5">
              If the <code>BTYPE</code> of the message indicates a
              <code>HELLO</code> block, the peer <span>SHOULD</span> be
              considered for the local routing table by using the peer
              identity computed from the block using
              <code>DeriveBlockKey</code>.  An implementation
              <span>MAY</span> choose to ignore the <code>HELLO</code>,
              for example because the routing table or the respective
              k-bucket is already full.  If the peer is a suitable
              candidate for insertion, the local peer
              <span>MUST</span> try to establish a connection to the
              peer indicated in the <code>HELLO</code> block using the
              address information from the <code>HELLO</code> block and
              the underlay&#39;s <code>TRY_CONNECT()</code> function.  The
              implementation <span>MUST</span> instruct the underlay
              to connect to all provided addresses using
              <code>TRY_CONNECT()</code> in order to make the underlay
              aware of multiple addresses for this connection.  When a
              connection is established, the signal
              <code>PEER_CONNECTED</code> will cause the peer to be added
              to the respective k-bucket of the routing table (see
              <a href="#routing">Section 6</a>).<a href="#section-7.5.2-2.5">¶</a>
</li>
            <li id="section-7.5.2-2.6">
              If the <code>QUERY_HASH</code> of this
              <code>ResultMessage</code> does not match an entry in the
              pending table (<a href="#pending_table">Section 6.5</a>), then the
              message is discarded and processing ends.  Otherwise,
              processing continues for each entry in the table as
              follows.<a href="#section-7.5.2-2.6">¶</a>
</li>
            <li id="section-7.5.2-2.7">
              <span></span><dl id="section-7.5.2-2.7.1">
 <dt>a)</dt>
<dd id="section-7.5.2-2.7.1.1">
   If the <code>FindApproximate</code> flag was not set in
   the query and the <code>BTYPE</code> enabled the
   implementation to compute the key from the block,
   the computed key must exactly match the
   <code>QUERY_HASH</code>, otherwise the result does not
   match the pending query and processing continues
   with the next pending table entry.<a href="#section-7.5.2-2.7.1.1">¶</a>
</dd>
                <dd></dd>
<dt>b)</dt>
<dd id="section-7.5.2-2.7.1.2">
                  If the <code>BTYPE</code> is supported, result block
                  <span>MUST</span> be validated against the
                  specific query using the respective
                  <code>FilterBlockResult</code> function. This function
                  <span>MUST</span> update the result filter if a
                  result is returned to the originator of the query.<a href="#section-7.5.2-2.7.1.2">¶</a>
</dd>
                <dd></dd>
<dt>c)</dt>
<dd id="section-7.5.2-2.7.1.3">
   If the <code>BTYPE</code> is not supported, filtering of
   exact duplicate replies <span>MUST</span> still be
   performed before forwarding the reply.  Such
   duplicate filtering <span>MAY</span> be
   implemented probabilistically, for example using a
   Bloom filter.  The result of this duplicate
   filtering is always either <code>FILTER_MORE</code> or
   <code>FILTER_DUPLICATE</code>.<a href="#section-7.5.2-2.7.1.3">¶</a>
</dd>
                <dd></dd>
<dt>d)</dt>
<dd id="section-7.5.2-2.7.1.4">
   If the <code>RecordRoute</code> flag is set in
   <code>FLAGS</code>, the local peer identity
   <span>MUST</span> be appended to the
   <code>GETPATH</code> of the message and the respective
   signature <span>MUST</span> be set using the query
   origin as the <code>PEER SUCCESSOR</code> and the
   response origin as the <code>PEER PREDECESSOR</code>.
   If the flag is not set, the <code>GETPATH_L</code> and
   <code>PUTPATH_L</code> <span>MUST</span> be set to
   zero when forwarding the result.<a href="#section-7.5.2-2.7.1.4">¶</a>
</dd>
                <dd></dd>
<dt>e)</dt>
<dd id="section-7.5.2-2.7.1.5">
   If the result filter result is either
   <code>FILTER_MORE</code> or <code>FILTER_LAST</code>, the
   message is forwarded to the origin of the query as
   defined in the entry which may either be the local
   peer or a remote peer.  In case this is a query of
   the local peer the result may have to be provided to
   applications through the overlay API.  Otherwise,
   the result is forwarded using <code>SEND(P,
   ResultMessage&#39;)</code> where <code>ResultMessage&#39;</code>
   is the now modified message.  If the result was
   <code>FILTER_LAST</code>, the query <span>MUST</span>
   be removed from the pending table.<a href="#section-7.5.2-2.7.1.5">¶</a>
</dd>
              <dd></dd>
</dl>
</li>
            <li id="section-7.5.2-2.8">
       Finally, the implementation <span>SHOULD</span> cache
       <code>ResultMessages</code> in order to provide already seen
       replies to future <code>GetMessages</code>.  The
       implementation <span>MAY</span> choose not no cache
       any or a limited number of <code>ResultMessages</code> for
       reasons such as resource limitations.<a href="#section-7.5.2-2.8">¶</a>
</li>
          </ol>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="blockstorage">
<section id="section-8">
      <h2 id="name-blocks">
<a href="#section-8">8. </a><a href="#name-blocks">Blocks</a>
      </h2>
<p id="section-8-1">
 This section describes various considerations R<sup>5</sup>N
 implementations must consider with respect to blocks.
 Specifically, implementations <span>SHOULD</span> be validate and persist
  blocks.
  Implementations
 <span>MAY</span> not support validation for all types
    of blocks.
    For example, on some devices, storing blocks is impossible due to lack of
  storage capacity.
  Block storage improves lookup performance for local applications and also
  other peers. Not storing blocks results in degraded performance.<a href="#section-8-1">¶</a></p>
<p id="section-8-2">
        The block type determines the format and handling of the block
        payload by peers in <code>PutMessages</code> and
        <code>ResultMessages</code>.  Applications can and should define
        their own block types.  Block types <span>MUST</span> be
        registered with GANA (see <a href="#gana_block_type">Section 11.1</a>).
        Especially when new block types are introduced, some peers
        <span>MAY</span> lack support for the respective block
        operations.<a href="#section-8-2">¶</a></p>

<div id="block_functions">
<section id="section-8.1">
        <h3 id="name-block-operations">
<a href="#section-8.1">8.1. </a><a href="#name-block-operations">Block Operations</a>
        </h3>
<p id="section-8.1-1">
            Block validation operations are used as part of message
            processing (see <a href="#p2p_messages">Section 7</a>) for all
            types of DHT messages.  To enable these validation
            operations, any block type specification
            <span>MUST</span> define the following functions:<a href="#section-8.1-1">¶</a></p>
<span></span><dl id="section-8.1-2">
          <dt id="section-8.1-2.1">ValidateBlockQuery(Key, XQuery)
         -&gt; RequestEvaluationResult</dt>
          <dd id="section-8.1-2.2">
            <p id="section-8.1-2.2.1">
              is used to evaluate the request for a block as part of
              <code>GetMessage</code> processing. Here, the block payload is unkown,
              but if possible the <code>XQuery</code> and <code>Key</code>
              <span>SHOULD</span> be verified.  Possible values for
       the <code>RequestEvaluationResult</code> are:<a href="#section-8.1-2.2.1">¶</a></p>
<span></span><dl id="section-8.1-2.2.2">
              <dt id="section-8.1-2.2.2.1">REQUEST_VALID</dt>
              <dd id="section-8.1-2.2.2.2">
                 The query is valid.<a href="#section-8.1-2.2.2.2">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.1-2.2.2.3">REQUEST_INVALID</dt>
              <dd id="section-8.1-2.2.2.4">
  The query format does not match the block type. For example,
  a mandatory <code>XQuery</code> was not provided, or of
  the size of the <code>XQuery</code> is not appropriate
  for the block type.<a href="#section-8.1-2.2.2.4">¶</a>
</dd>
            <dd></dd>
</dl>
</dd>
          <dd></dd>
<dt id="section-8.1-2.3">DeriveBlockKey(Block) -&gt; Key | NONE</dt>
          <dd id="section-8.1-2.4">
              is used to synthesize the block key from the block
              payload as part of <code>PutMessage</code> and
              <code>ResultMessage</code> processing.  The special return
              value of <code>NONE</code> implies that this block type does
              not permit deriving the key from the block.  A
              <code>Key</code> may be returned for a block that is
              ill-formed.<a href="#section-8.1-2.4">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.1-2.5">ValidateBlockStoreRequest(Block)
         -&gt; BlockEvaluationResult</dt>
          <dd id="section-8.1-2.6">
            <p id="section-8.1-2.6.1">
                is used to evaluate a block payload as part of
                <code>PutMessage</code> and <code>ResultMessage</code>
                processing.  Possible values for the
                <code>BlockEvaluationResult</code> are:<a href="#section-8.1-2.6.1">¶</a></p>
<span></span><dl id="section-8.1-2.6.2">
              <dt id="section-8.1-2.6.2.1">BLOCK_VALID</dt>
              <dd id="section-8.1-2.6.2.2">
                 The block is valid.<a href="#section-8.1-2.6.2.2">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.1-2.6.2.3">BLOCK_INVALID</dt>
              <dd id="section-8.1-2.6.2.4">
                 The block payload does not match the block type.<a href="#section-8.1-2.6.2.4">¶</a>
</dd>
            <dd></dd>
</dl>
</dd>
          <dd></dd>
<dt id="section-8.1-2.7">SetupResultFilter(FilterSize, Mutator) -&gt; RF</dt>
          <dd id="section-8.1-2.8">
       is used to setup an empty result filter.  The arguments
       are typically the size of the set of results that must
       be filtered at the initiator, and a <code>Mutator</code>
       value which <span>MAY</span> be used to
       deterministically re-randomize probabilistic data
       structures.  <code>RF</code> <span>MUST</span> be a byte
       sequence suitable for transmission over the network.<a href="#section-8.1-2.8">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.1-2.9">FilterResult(Block, Key, RF, XQuery) -&gt; (FilterEvaluationResult, RF&#39;)</dt>
          <dd id="section-8.1-2.10">
            <p id="section-8.1-2.10.1">
       is used to filter results against specific queries.
       This function does not check the validity of
       <code>Block</code> itself or that it matches the given key,
       as this must have been checked earlier.  Locally
       stored blocks from previously observed
       <code>ResultMessages</code> and <code>PutMessages</code> use
       this function to perform filtering based on the request
       parameters of a particular GET operation.  Possible
       values for the <code>FilterEvaluationResult</code> are:<a href="#section-8.1-2.10.1">¶</a></p>
<span></span><dl id="section-8.1-2.10.2">
              <dt id="section-8.1-2.10.2.1">FILTER_MORE</dt>
              <dd id="section-8.1-2.10.2.2">
                <code>Block</code> is a valid result, and there may be more.<a href="#section-8.1-2.10.2.2">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.1-2.10.2.3">FILTER_LAST</dt>
              <dd id="section-8.1-2.10.2.4">
                The given <code>Block</code> is the last possible valid result.<a href="#section-8.1-2.10.2.4">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.1-2.10.2.5">FILTER_DUPLICATE</dt>
              <dd id="section-8.1-2.10.2.6">
                <code>Block</code> is a valid result, but considered to be
                a duplicate (was filtered by the <code>RF</code>) and
                <span>SHOULD NOT</span> be returned to the previous
                hop.  Peers that do not understand the block type
                <span>MAY</span> return such duplicate results
                anyway and implementations must take this into account.<a href="#section-8.1-2.10.2.6">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.1-2.10.2.7">FILTER_IRRELEVANT</dt>
              <dd id="section-8.1-2.10.2.8">
                <code>Block</code> does not satisfy the constraints
                imposed by the <code>XQuery</code>. The result
                <span>SHOULD NOT</span> be returned to the previous
                hop.  Peers that do not understand the block type
                <span>MAY</span> return such irrelevant results
                anyway and implementations must take this into account.<a href="#section-8.1-2.10.2.8">¶</a>
</dd>
            <dd></dd>
</dl>
<p id="section-8.1-2.10.3">
         If the main evaluation result is <code>FILTER_MORE</code>,
         the function also returns an updated result filter
         where the <code>Block</code> is added to the set of
         filtered replies.  An implementation is not expected
         to actually differenciate between the
         <code>FILTER_DUPLICATE</code> and
         <code>FILTER_IRRELEVANT</code> return values: in both
         cases the <code>Block</code> is ignored for this query.<a href="#section-8.1-2.10.3">¶</a></p>
</dd>
        <dd></dd>
</dl>
</section>
</div>
<div id="hello_block">
<section id="section-8.2">
        <h3 id="name-hello-blocks">
<a href="#section-8.2">8.2. </a><a href="#name-hello-blocks">HELLO Blocks</a>
        </h3>
<p id="section-8.2-1">
            For bootstrapping and peer discovery, the DHT
            implementation uses its own block type called &#34;HELLO&#34;.
            <code>HELLO</code> blocks are the only type of block that
            <span>MUST</span> be supported by every R<sup>5</sup>N
            implementation. A block with this block type contains the
            peer public key of the peer that published the
            <code>HELLO</code> together with a set of addresses of this
            peer. The key of a <code>HELLO</code> block is the SHA-512
            hash <span>[<a href="#RFC4634">RFC4634</a>]</span> of the peer public key and
            thus the peer&#39;s identity in the DHT.<a href="#section-8.2-1">¶</a></p>
<p id="section-8.2-2">
            The <code>HELLO</code> block type wire format is illustrated
            in <a href="#figure_hello">Figure 13</a>. A query for block of
            type <code>HELLO</code> <span>MUST NOT</span> include
            extended query data (XQuery). Any implementation
            encountering a request for a <code>HELLO</code> with non-empty
            XQuery data <span>MUST</span> consider the request
            invalid and ignore it.<a href="#section-8.2-2">¶</a></p>
<span id="name-the-hello-block-format"></span><div id="figure_hello">
<figure id="figure-13">
          <div id="section-8.2-3.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|                PEER PUBLIC KEY                |
|                    (32 byte)                  |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   SIGNATURE                   |
|                   (64 byte)                   |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   EXPIRATION                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
/                   ADDRESSES                   /
/               (variable length)               /
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-13">Figure 13</a>:
<a href="#name-the-hello-block-format">The HELLO Block Format.</a>
          </figcaption></figure>
</div>
<span></span><dl id="section-8.2-4">
          <dt id="section-8.2-4.1">PEER PUBLIC KEY</dt>
          <dd id="section-8.2-4.2">
              is the public key of the peer to which the
              <code>ADDRESSES</code> belong. This is also the public key
              needed to verify the <code>SIGNATURE</code>.<a href="#section-8.2-4.2">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.2-4.3">EXPIRATION</dt>
          <dd id="section-8.2-4.4">
              denotes the absolute 64-bit expiration date of the
              content.  The value specified is microseconds since
              midnight (0 hour), January 1, 1970 in network byte
              order, but must be a multiple of one million (so that it
              can be represented in seconds in a <code>HELLO</code> URL).<a href="#section-8.2-4.4">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.2-4.5">ADDRESSES</dt>
          <dd id="section-8.2-4.6">
              is a list of UTF-8 addresses (<a href="#terminology">Section 2</a>)
              which can be used to contact the peer.
              Each address <span>MUST</span> be 0-terminated.
              The set of addresses <span>MAY</span> be empty, for example
              if the peer knows that it cannot be reached from the outside (i.e. NAT).<a href="#section-8.2-4.6">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.2-4.7">SIGNATURE</dt>
          <dd id="section-8.2-4.8">
            <p id="section-8.2-4.8.1">
              is the EdDSA signature <span>[<a href="#ed25519">ed25519</a>]</span> of the
              <code>HELLO</code> block.  The signature covers various
              information derived from the actual data in the
              <code>HELLO</code> block.  The data signed over includes the
              block expiration time, a constant that uniquely
              identifies the purpose of the signature, and a hash of
              the addresses with 0-terminators in the same order as
              they are present in the <code>HELLO</code> block.  The
              format is illustrated in <a href="#figure_hellowithpseudo">Figure 14</a>.<a href="#section-8.2-4.8.1">¶</a></p>
<span id="name-the-wire-format-of-the-hell"></span><div id="figure_hellowithpseudo">
<figure id="figure-14">
              <div id="section-8.2-4.8.2.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|         SIZE          |        PURPOSE        |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                   EXPIRATION                  |
+-----+-----+-----+-----+-----+-----+-----+-----+
|                    H_ADDRS                    |
|                   (64 byte)                   |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
|                                               |
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-14">Figure 14</a>:
<a href="#name-the-wire-format-of-the-hell">The Wire Format of the HELLO for Signing.</a>
              </figcaption></figure>
</div>
<span></span><dl id="section-8.2-4.8.3">
              <dt id="section-8.2-4.8.3.1">SIZE</dt>
              <dd id="section-8.2-4.8.3.2">
              A 32-bit value containing the length of the signed data
              in bytes in network byte order.  The length of the
              signed data <span>MUST</span> be 80 bytes.<a href="#section-8.2-4.8.3.2">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.2-4.8.3.3">PURPOSE</dt>
              <dd id="section-8.2-4.8.3.4">
              A 32-bit signature purpose flag. This field
              <span>MUST</span> be 7 in network byte order.<a href="#section-8.2-4.8.3.4">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.2-4.8.3.5">EXPIRATION</dt>
              <dd id="section-8.2-4.8.3.6">
              denotes the absolute 64-bit expiration date of the
              <code>HELLO</code> in microseconds since midnight (0 hour),
              January 1, 1970 in network byte order.<a href="#section-8.2-4.8.3.6">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.2-4.8.3.7">H_ADDRS</dt>
              <dd id="section-8.2-4.8.3.8">
              a SHA-512 hash over the addresses in the <code>HELLO</code>.
              <code>H_ADDRS</code> is generated over the
              <code>ADDRESSES</code> field as provided in the
              <code>HELLO</code> block using SHA-512 <span>[<a href="#RFC4634">RFC4634</a>]</span>.<a href="#section-8.2-4.8.3.8">¶</a>
</dd>
            <dd></dd>
</dl>
</dd>
        <dd></dd>
</dl>
<p id="section-8.2-5">
            The <code>HELLO</code> block operations <span>MUST</span> be
            implemented as follows:<a href="#section-8.2-5">¶</a></p>
<span></span><dl id="section-8.2-6">
          <dt id="section-8.2-6.1">ValidateBlockQuery(Key, XQuery)
         -&gt; RequestEvaluationResult</dt>
          <dd id="section-8.2-6.2">
            To validate a block query for a <code>HELLO</code> is to
            simply check that the <code>XQuery</code> is empty. If it is empty,
            <code>REQUEST_VALID</code> ist returned. Otherwise,
            <code>REQUEST_INVALID</code> is returned.<a href="#section-8.2-6.2">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.2-6.3">DeriveBlockKey(Block) -&gt; Key | NONE</dt>
          <dd id="section-8.2-6.4">
            To derive a block key for a <code>HELLO</code> is to simply
            hash the <code>PEER PUBLIC KEY</code> from the <code>HELLO</code>. The
            result of this function is thus always the SHA-512 hash over
            the <code>PEER PUBLIC KEY</code>.<a href="#section-8.2-6.4">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.2-6.5">ValidateBlockStoreRequest(Block)
         -&gt; BlockEvaluationResult</dt>
          <dd id="section-8.2-6.6">
     To validate a block store request is to verify the EdDSA
     <code>SIGNATURE</code> over the hashed <code>ADDRESSES</code>
     against the public key from the <code>PEER PUBLIC KEY</code>
     field.  If the signature is valid <code>BLOCK_VALID</code> is
     returned.  Otherwise <code>BLOCK_INVALID</code> is returned.<a href="#section-8.2-6.6">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.2-6.7">SetupResultFilter(FilterSize, Mutator) -&gt; RF</dt>
          <dd id="section-8.2-6.8">
            <p id="section-8.2-6.8.1">
     The <code>RF</code> for <code>HELLO</code> blocks is implemented
     using a Bloom filter following the definition from <a href="#bloom_filters">Appendix A</a> and consists of a variable number
     of bits <code>L</code>.  <code>L</code> depends on the
            <code>FilterSize</code> which will be the number of
     connected peers <code>|E|</code> known to the peer creating a
     <code>HELLO</code> block from its own addresses: <code>L</code> is
     set to the minimum of 2<sup>18</sup> bits (2<sup>15</sup>
     bytes) and the lowest power of 2 that is strictly larger
     than <code>2*K*|E|</code> bits (<code>K*|E|/4</code> bytes).<a href="#section-8.2-6.8.1">¶</a></p>
<p id="section-8.2-6.8.2">
            The <code>k</code>-value for the Bloom filter
            <span>MUST</span> be 16.  The elements used in the Bloom
            filter consist of an XOR between the <code>H_ADDRS</code>
            field (as computed using SHA-512 over the
            <code>ADDRESSES</code>) and the SHA-512 hash of the
            <code>MUTATOR</code> field from a given <code>HELLO</code> block.
            The mapping function M(<code>H_ADDRS XOR MUTATOR</code>) is
            defined as follows:<a href="#section-8.2-6.8.2">¶</a></p>
<p id="section-8.2-6.8.3">
            <code>M(e = H_ADDR XOR MUTATOR) -&gt; e as uint32[]</code><a href="#section-8.2-6.8.3">¶</a></p>
<p id="section-8.2-6.8.4">
            <code>M</code> is an identity function and returns the 512-bit
            XOR result unmodified.  This resulting byte string is
            interpreted as k=16 32-bit integers in network byte order
            which are used to set and check the bits in <code>B</code>
            using <code>BF-SET()</code> and <code>BF-TEST()</code>.  The
            32-bit <code>MUTATOR</code> is prepended to the L-bit Bloom filter
            field <code>HELLO_BF</code> containing <code>B</code> to create
            the result filter for a <code>HELLO</code> block:<a href="#section-8.2-6.8.4">¶</a></p>
<span id="name-the-hello-block-result-filt"></span><div id="hello_rf">
<figure id="figure-15">
              <div id="section-8.2-6.8.5.1">
<pre>0     8     16    24    32    40    48    56
+-----+-----+-----+-----+-----+-----+-----+-----+
|        MUTATOR        |      HELLO_BF         /
+-----+-----+-----+-----+  (variable length)    /
/                                               /
+-----+-----+-----+-----+-----+-----+-----+-----+
</pre>
</div>
<figcaption><a href="#figure-15">Figure 15</a>:
<a href="#name-the-hello-block-result-filt">The HELLO Block Result Filter.</a>
              </figcaption></figure>
</div>
<p id="section-8.2-6.8.6">where:<a href="#section-8.2-6.8.6">¶</a></p>
<span></span><dl id="section-8.2-6.8.7">
              <dt id="section-8.2-6.8.7.1">MUTATOR</dt>
              <dd id="section-8.2-6.8.7.2">
              The 32-bit mutator for the result filter.<a href="#section-8.2-6.8.7.2">¶</a>
</dd>
              <dd></dd>
<dt id="section-8.2-6.8.7.3">HELLO_BF</dt>
              <dd id="section-8.2-6.8.7.4">
              The L-bit Bloom filter array.<a href="#section-8.2-6.8.7.4">¶</a>
</dd>
            <dd></dd>
</dl>
<p id="section-8.2-6.8.8">
     The <code>MUTATOR</code> value is used to additionally
     &#34;randomize&#34; the computation of the Bloom filter while
     remaining deterministic across peers.  It is only ever set
     by the peer initiating the GET request, and changed every
     time the GET request is repeated.  Peers forwarding GET
     requests <span>MUST</span> not change the mutator value
     included in the <code>RESULT_FILTER</code> as they might not
     be able to recalculate the result filter with a different
     <code>MUTATOR</code> value.<a href="#section-8.2-6.8.8">¶</a></p>
<p id="section-8.2-6.8.9">
     Consequently, repeated requests have statistically
     independent probabilities of creating false-positives in a
     result filter. Thus, even if for one request a result
     filter may exclude a result as a false-positive match,
     subsequent requests are likely to not have the same
     false-positives.<a href="#section-8.2-6.8.9">¶</a></p>
<p id="section-8.2-6.8.10">
     <code>HELLO</code> result filters can be merged if the Bloom
     filters have the same size and <code>MUTATOR</code> by setting
     all bits to 1 that are set in either Bloom filter.  This
     is done whenever a peer receives a query with the same
     <code>MUTATOR</code>, predecessor and Bloom filter size.<a href="#section-8.2-6.8.10">¶</a></p>
</dd>
          <dd></dd>
<dt id="section-8.2-6.9">FilterResult(Block, Key, RF, XQuery) -&gt; (FilterEvaluationResult, RF&#39;)</dt>
          <dd id="section-8.2-6.10">
             The <code>H_ADDRS</code> field is XORed with the SHA-512 hash
             of the <code>MUTATOR</code> field from the <code>HELLO</code>
             block and the resulting value is checked against the
             Bloom filter in <code>RF</code>.  Consequently,
             <code>HELLOs</code> with completely identical sets of
             addresses will be filtered and <code>FILTER_DUPLICATE</code>
             is returned.  Any small variation in the set of addresses
             will cause the block to no longer be filtered (with high
             probability) and <code>FILTER_MORE</code> is returned.<a href="#section-8.2-6.10">¶</a>
</dd>
        <dd></dd>
</dl>
</section>
</div>
<section id="section-8.3">
        <h3 id="name-persistence">
<a href="#section-8.3">8.3. </a><a href="#name-persistence">Persistence</a>
        </h3>
<p id="section-8.3-1">
          An implementation <span>SHOULD</span> provide a local
          persistence mechanism for blocks.  Embedded systems that
          lack storage capability <span>MAY</span> use
          connection-level signalling to indicate that they are merely
          a client utilizing a DHT and are not able to participate
          with storage.  The local storage <span>MUST</span> provide
          the following functionality:<a href="#section-8.3-1">¶</a></p>
<span></span><dl id="section-8.3-2">
          <dt id="section-8.3-2.1">Store(Key, Block)</dt>
          <dd id="section-8.3-2.2">
            Stores a block under the specified key. If an block with identical
     payload exists already under the same key, the meta data should
     be set to the maximum expiration time of both blocks and use the
     corresponding <code>PUTPATH</code> (and if applicable
            <code>TRUNCATED ORIGIN</code>) of that version of the block.<a href="#section-8.3-2.2">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.3-2.3">Lookup(Key) -&gt; Set of Blocks</dt>
          <dd id="section-8.3-2.4">
            Retrieves blocks stored under the specified key.<a href="#section-8.3-2.4">¶</a>
</dd>
          <dd></dd>
<dt id="section-8.3-2.5">LookupApproximate(Key) -&gt; List of Blocks</dt>
          <dd id="section-8.3-2.6">
            Retrieves the blocks stored under the specified key and
            any blocks under keys close to the specified key, in order
            of decreasing proximity.<a href="#section-8.3-2.6">¶</a>
</dd>
        <dd></dd>
</dl>
<div id="approx_search">
<section id="section-8.3.1">
          <h4 id="name-approximate-search-consider">
<a href="#section-8.3.1">8.3.1. </a><a href="#name-approximate-search-consider">Approximate Search Considerations</a>
          </h4>
<p id="section-8.3.1-1">
          Over time a peer may accumulate a significant number of blocks
          which are stored locally in the persistence layer.
          Due to the expected high number of blocks, the method to
          retrieve blocks close to the specified lookup key in the
          <code>LookupApproximate</code> API must be implemented with care
          with respect to efficiency.<a href="#section-8.3.1-1">¶</a></p>
<p id="section-8.3.1-2">
          It is <span>RECOMMENDED</span> to limit the number of
          results from the <code>LookupApproximate</code> procedure to a
          result size which is easily manageable by the local system.
          The <span>RECOMMENDED</span> default is to return blocks
          with the four closest keys.  Note that filtering by the
          <code>RF</code> will be done by the DHT afterwards and it is
          <span>NOT RECOMMENDED</span> to fetch additional records
          even if all four closest keys are filtered by the
          <code>RF</code>.  The main reason for this is to ensure peers do
          not spend extensive resources to process approximate
          lookups.  In particular, implementations <span>MUST</span>
          limit the worst-case effort they spent on approximate
          lookups.<a href="#section-8.3.1-2">¶</a></p>
<p id="section-8.3.1-3">
          In order to efficiently find a suitable result set, the
          implementation <span>SHOULD</span> follow the following
          procedure:<a href="#section-8.3.1-3">¶</a></p>
<ol start="1" type="1" id="section-8.3.1-4">
          <li id="section-8.3.1-4.1">
            Sort all blocks by the block key in ascending (decending) order.
            The block keys are interpreted as integers.<a href="#section-8.3.1-4.1">¶</a>
</li>
            <li id="section-8.3.1-4.2">
            Alternatingly select a block with a key larger and smaller
            from the sortings.  The resulting set is then sorted by
            the XOR distance to the query.  The selection process
            continues until the upper bound for the result set is
            reached and both sortings do not yield any closer blocks.<a href="#section-8.3.1-4.2">¶</a>
</li>
          </ol>
<p id="section-8.3.1-5">
          An implementation <span>MAY</span> decide to use a custom
          algorithm in order to find the closest blocks in the local
          storage.  But, especially for more primitive approaches
          (such as only comparing XOR distances for all blocks in the
          storage), more simplistic procedures may become ineffective
          for large data sets and care <span>MUST</span> be taken
          to strictly bound the maximum effort expended per query.<a href="#section-8.3.1-5">¶</a></p>
</section>
</div>
<section id="section-8.3.2">
          <h4 id="name-caching-strategy-considerat">
<a href="#section-8.3.2">8.3.2. </a><a href="#name-caching-strategy-considerat">Caching Strategy Considerations</a>
          </h4>
<p id="section-8.3.2-1">
            An implementation <span>MUST</span> implement an
            eviction strategy for blocks stored in the block storage
            layer.<a href="#section-8.3.2-1">¶</a></p>
<p id="section-8.3.2-2">
            In order to ensure the freshness of blocks, an implementation
            <span>MUST</span> evict expired blocks in favor of
            new blocks.<a href="#section-8.3.2-2">¶</a></p>
<p id="section-8.3.2-3">
            An implementation <span>MAY</span> preserve blocks which
            are often requested.  This approach can be expensive as it
            requires the implementation to keep track of how often a
            block is requested.<a href="#section-8.3.2-3">¶</a></p>
<p id="section-8.3.2-4">
            An implementation <span>MAY</span> preserve blocks which
            are close to the local peer public key.<a href="#section-8.3.2-4">¶</a></p>
<p id="section-8.3.2-5">
            An implementation <span>MAY</span> provide configurable
            storage quotas and adapt its eviction strategy based on
            the current storage size or other constrained resources.<a href="#section-8.3.2-5">¶</a></p>
</section>
</section>
</section>
</div>
<div id="security">
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9">9. </a><a href="#name-security-considerations">Security Considerations</a>
      </h2>
<p id="section-9-1">
        If an upper bound to the maximum number of neighbors in a
        k-bucket is reached, the implementation <span>MUST</span>
        prefer to preserve the oldest working connections instead of
        new connections.  This makes Sybil attacks <span>[<a href="#Sybil">Sybil</a>]</span> less effective as an adversary would have to
        invest more resources over time to mount an effective attack.<a href="#section-9-1">¶</a></p>
<p id="section-9-2">
 The <code>ComputeOutDegree</code> function limits the
 <code>REPL_LVL</code> to a maximum of 16. This imposes
 an upper limit on bandwidth amplification an attacker
 may achieve for a given network size and topology.<a href="#section-9-2">¶</a></p>
<section id="section-9.1">
        <h3 id="name-disjoint-underlay-or-applic">
<a href="#section-9.1">9.1. </a><a href="#name-disjoint-underlay-or-applic">Disjoint Underlay or Application Protocol Support</a>
        </h3>
<p id="section-9.1-1">
        We note that peers
 implementing disjoint sets of underlay protocols may
 experience difficulties communicating (unless other peers
 bridge the respective underlays). Similarly, peers that
 do not support a particular application will not be able
 to validate application-specific payloads and may thus be
 tricked into storing or forwarding corrupt blocks.<a href="#section-9.1-1">¶</a></p>
</section>
<section id="section-9.2">
        <h3 id="name-approximate-result-filterin">
<a href="#section-9.2">9.2. </a><a href="#name-approximate-result-filterin">Approximate Result Filtering</a>
        </h3>
<p id="section-9.2-1">
          When a <code>FindApproximate</code> flag is encountered in a
          query, a peer will try to respond with the closest block it
          has that is not filtered by the result Bloom filter
          (<code>RF</code>).  Implementations <span>MUST</span> ensure
          that the cost of evaluating any such query is reasonably
          small.  For example, implementations <span>SHOULD</span>
          consider ways to avoid an exhaustive search of their
          database.  Not doing so can lead to denial of service
          attacks as there could be cases where too many local results
          are filtered by the result filter.<a href="#section-9.2-1">¶</a></p>
</section>
<section id="section-9.3">
        <h3 id="name-access-control">
<a href="#section-9.3">9.3. </a><a href="#name-access-control">Access Control</a>
        </h3>
<p id="section-9.3-1">
          By design R<sup>5</sup>N does not rely on strict admission
          control through the use of either centralized enrollment
          servers or pre-shared keys.  This is a key distintion over
          protocols that do rely on this kind of access control such
          as <span>[<a href="#RFC6940">RFC6940</a>]</span> which, like R<sup>5</sup>N,
          provides a peer-to-peer (P2P) signaling protocol with
          extensible routing and topology mechanisms.  Some
          decentralized applications, such as the GNU Name System
          (<span>[<a href="#RFC9498">RFC9498</a>]</span>), require an open system that
          enables ad-hoc participation.<a href="#section-9.3-1">¶</a></p>
</section>
</section>
</div>
<div id="iana">
<section id="section-10">
      <h2 id="name-iana-considerations">
<a href="#section-10">10. </a><a href="#name-iana-considerations">IANA Considerations</a>
      </h2>
<p id="section-10-1">
 IANA maintains a registry called the &#34;Uniform Resource Identifier
 (URI) Schemes&#34; registry.
 The registry should be updated to include
 an entry for the &#39;gnunet&#39; URI scheme.  IANA is requested to
 update that entry to reference this document when published
 as an RFC.<a href="#section-10-1">¶</a></p>
</section>
</div>
<div id="gana">
<section id="section-11">
      <h2 id="name-gana-considerations">
<a href="#section-11">11. </a><a href="#name-gana-considerations">GANA Considerations</a>
      </h2>
<div id="gana_block_type">
<section id="section-11.1">
        <h3 id="name-block-type-registry">
<a href="#section-11.1">11.1. </a><a href="#name-block-type-registry">Block Type Registry</a>
        </h3>
<p id="section-11.1-1">
        GANA <span>[<a href="#GANA">GANA</a>]</span>
        is requested to create a &#34;DHT Block Types&#34; registry.
        The registry shall record for each entry:<a href="#section-11.1-1">¶</a></p>
<ul>
<li id="section-11.1-2.1">Name: The name of the block type (case-insensitive ASCII
          string, restricted to alphanumeric characters<a href="#section-11.1-2.1">¶</a>
</li>
          <li id="section-11.1-2.2">Number: 32-bit<a href="#section-11.1-2.2">¶</a>
</li>
          <li id="section-11.1-2.3">Comment: Optionally, a brief English text describing the purpose of
          the block type (in UTF-8)<a href="#section-11.1-2.3">¶</a>
</li>
          <li id="section-11.1-2.4">Contact: Optionally, the contact information of a person to contact for
          further information<a href="#section-11.1-2.4">¶</a>
</li>
          <li id="section-11.1-2.5">References: Required, references (such as an RFC) specifying the block type and its block functions<a href="#section-11.1-2.5">¶</a>
</li>
        </ul>
<p id="section-11.1-3">
        The registration policy for this sub-registry is &#34;First Come First
        Served&#34;, as described in <span>[<a href="#RFC8126">RFC8126</a>]</span>.
        GANA created the registry as follows:<a href="#section-11.1-3">¶</a></p>
<span id="name-the-block-type-registry"></span><div id="figure_btypenums">
<figure id="figure-16">
          <div id="section-11.1-4.1">
<pre>Number| Name           | References | Description
------+----------------+------------+-------------------------
0       ANY              [This.I-D]   Reserved
13      DHT_HELLO        [This.I-D]   Address data for a peer

Contact: r5n-registry@gnunet.org
</pre>
</div>
<figcaption><a href="#figure-16">Figure 16</a>:
<a href="#name-the-block-type-registry">The Block Type Registry.</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="gana_gnunet_url">
<section id="section-11.2">
        <h3 id="name-gnunet-uri-schema-subregist">
<a href="#section-11.2">11.2. </a><a href="#name-gnunet-uri-schema-subregist">GNUnet URI Schema Subregistry</a>
        </h3>
<p id="section-11.2-1">
        GANA <span>[<a href="#GANA">GANA</a>]</span>
        is requested to create a &#34;gnunet://&#34; sub-registry.
        The registry shall record for each entry:<a href="#section-11.2-1">¶</a></p>
<ul>
<li id="section-11.2-2.1">Name: The name of the subsystem (case-insensitive ASCII
          string, restricted to alphanumeric characters)<a href="#section-11.2-2.1">¶</a>
</li>
          <li id="section-11.2-2.2">Comment: Optionally, a brief English text describing the purpose of
          the subsystem (in UTF-8)<a href="#section-11.2-2.2">¶</a>
</li>
          <li id="section-11.2-2.3">Contact: Optionally, the contact information of a person to contact for
          further information<a href="#section-11.2-2.3">¶</a>
</li>
          <li id="section-11.2-2.4">References: Optionally, references describing the syntax of the URL
          (such as an RFC or LSD)<a href="#section-11.2-2.4">¶</a>
</li>
        </ul>
<p id="section-11.2-3">
        
        The registration policy for this sub-registry is &#34;First Come First
        Served&#34;, as described in <span>[<a href="#RFC8126">RFC8126</a>]</span>.
        GANA created this registry as follows:<a href="#section-11.2-3">¶</a></p>
<span id="name-gnunet-scheme-subregistry"></span><div id="figure_gnunetscheme">
<figure id="figure-17">
          <div id="section-11.2-4.1">
<pre>Name           | References | Description
---------------+------------+-------------------------
HELLO            [This.I-D]   How to contact a peer.
ADDRESS          N/A          Network address.
Contact: gnunet-registry@gnunet.org
</pre>
</div>
<figcaption><a href="#figure-17">Figure 17</a>:
<a href="#name-gnunet-scheme-subregistry">GNUnet scheme Subregistry.</a>
          </figcaption></figure>
</div>
</section>
</div>

<div id="gana_message_type">
<section id="section-11.4">
        <h3 id="name-gnunet-message-type-registr">
<a href="#section-11.4">11.4. </a><a href="#name-gnunet-message-type-registr">GNUnet Message Type Registry</a>
        </h3>
<p id="section-11.4-1">
        GANA is requested to amend the &#34;GNUnet Message Type&#34; registry
        as follows:<a href="#section-11.4-1">¶</a></p>
<span id="name-the-message-type-registry-e"></span><div id="figure_messagetypeenums">
<figure id="figure-19">
          <div id="section-11.4-2.1">
<pre>Type    | Name            | References | Description
--------+-----------------+------------+---------------
146       DHT PUT          [This.I-D]    Store information in DHT
147       DHT GET          [This.I-D]    Request information from DHT
148       DHT RESULT       [This.I-D]    Return information from DHT
157       HELLO Message    [This.I-D]    Peer contact information

</pre>
</div>
<figcaption><a href="#figure-19">Figure 19</a>:
<a href="#name-the-message-type-registry-e">The Message Type Registry Entries.</a>
          </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<section id="section-12">
      <h2 id="name-normative-references">
<a href="#section-12">12. </a><a href="#name-normative-references">Normative References</a>
      </h2>
<dl>
<dt id="RFC2119">[RFC2119]</dt>
      <dd>
<span>Bradner, S.</span>, <span>&#34;Key words for use in RFCs to Indicate Requirement Levels&#34;</span>, <span>BCP 14</span>, <span>RFC 2119</span>, <span>DOI 10.17487/RFC2119</span>, <time datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC2663">[RFC2663]</dt>
      <dd>
<span>Srisuresh, P.</span> and <span>M. Holdrege</span>, <span>&#34;IP Network Address Translator (NAT) Terminology and Considerations&#34;</span>, <span>RFC 2663</span>, <span>DOI 10.17487/RFC2663</span>, <time datetime="1999-08">August 1999</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2663">https://www.rfc-editor.org/info/rfc2663</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC3561">[RFC3561]</dt>
      <dd>
<span>Perkins, C.</span>, <span>Belding-Royer, E.</span>, and <span>S. Das</span>, <span>&#34;Ad hoc On-Demand Distance Vector (AODV) Routing&#34;</span>, <span>RFC 3561</span>, <span>DOI 10.17487/RFC3561</span>, <time datetime="2003-07">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3561">https://www.rfc-editor.org/info/rfc3561</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC3629">[RFC3629]</dt>
      <dd>
<span>Yergeau, F.</span>, <span>&#34;UTF-8, a transformation format of ISO 10646&#34;</span>, <span>STD 63</span>, <span>RFC 3629</span>, <span>DOI 10.17487/RFC3629</span>, <time datetime="2003-11">November 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC3986">[RFC3986]</dt>
      <dd>
<span>Berners-Lee, T.</span>, <span>Fielding, R.</span>, and <span>L. Masinter</span>, <span>&#34;Uniform Resource Identifier (URI): Generic Syntax&#34;</span>, <span>STD 66</span>, <span>RFC 3986</span>, <span>DOI 10.17487/RFC3986</span>, <time datetime="2005-01">January 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC4634">[RFC4634]</dt>
      <dd>
<span>Eastlake 3rd, D.</span> and <span>T. Hansen</span>, <span>&#34;US Secure Hash Algorithms (SHA and HMAC-SHA)&#34;</span>, <span>RFC 4634</span>, <span>DOI 10.17487/RFC4634</span>, <time datetime="2006-07">July 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4634">https://www.rfc-editor.org/info/rfc4634</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC5234">[RFC5234]</dt>
      <dd>
<span>Crocker, D., Ed.</span> and <span>P. Overell</span>, <span>&#34;Augmented BNF for Syntax Specifications: ABNF&#34;</span>, <span>STD 68</span>, <span>RFC 5234</span>, <span>DOI 10.17487/RFC5234</span>, <time datetime="2008-01">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC5245">[RFC5245]</dt>
      <dd>
<span>Rosenberg, J.</span>, <span>&#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols&#34;</span>, <span>RFC 5245</span>, <span>DOI 10.17487/RFC5245</span>, <time datetime="2010-04">April 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5245">https://www.rfc-editor.org/info/rfc5245</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC6940">[RFC6940]</dt>
      <dd>
<span>Jennings, C.</span>, <span>Lowekamp, B., Ed.</span>, <span>Rescorla, E.</span>, <span>Baset, S.</span>, and <span>H. Schulzrinne</span>, <span>&#34;REsource LOcation And Discovery (RELOAD) Base Protocol&#34;</span>, <span>RFC 6940</span>, <span>DOI 10.17487/RFC6940</span>, <time datetime="2014-01">January 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6940">https://www.rfc-editor.org/info/rfc6940</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC8126">[RFC8126]</dt>
      <dd>
<span>Cotton, M.</span>, <span>Leiba, B.</span>, and <span>T. Narten</span>, <span>&#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;</span>, <span>BCP 26</span>, <span>RFC 8126</span>, <span>DOI 10.17487/RFC8126</span>, <time datetime="2017-06">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8126">https://www.rfc-editor.org/info/rfc8126</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC8174">[RFC8174]</dt>
      <dd>
<span>Leiba, B.</span>, <span>&#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;</span>, <span>BCP 14</span>, <span>RFC 8174</span>, <span>DOI 10.17487/RFC8174</span>, <time datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd></dd>
<dt id="RFC9498">[RFC9498]</dt>
      <dd>
<span>Schanzenbach, M.</span>, <span>Grothoff, C.</span>, and <span>B. Fix</span>, <span>&#34;The GNU Name System&#34;</span>, <span>RFC 9498</span>, <span>DOI 10.17487/RFC9498</span>, <time datetime="2023-11">November 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9498">https://www.rfc-editor.org/info/rfc9498</a>&gt;</span>. </dd>
<dd></dd>
<dt id="ed25519">[ed25519]</dt>
      <dd>
<span>Bernstein, D.</span>, <span>Duif, N.</span>, <span>Lange, T.</span>, <span>Schwabe, P.</span>, and <span>B. Yang</span>, <span>&#34;High-Speed High-Security Signatures&#34;</span>, <time datetime="2011">2011</time>, <span>&lt;<a href="http://link.springer.com/chapter/10.1007/978-3-642-23951-9_9">http://link.springer.com/chapter/10.1007/978-3-642-23951-9_9</a>&gt;</span>. </dd>
<dd></dd>
<dt id="GANA">[GANA]</dt>
    <dd>
<span>GNUnet e.V.</span>, <span>&#34;GNUnet Assigned Numbers Authority (GANA)&#34;</span>, <time datetime="2020-04">April 2020</time>, <span>&lt;<a href="https://gana.gnunet.org/">https://gana.gnunet.org/</a>&gt;</span>. </dd>
<dd></dd>
</dl>
</section>
<section id="section-13">
      <h2 id="name-informative-references">
<a href="#section-13">13. </a><a href="#name-informative-references">Informative References</a>
      </h2>
<dl>
<dt id="R5N">[R5N]</dt>
      <dd>
<span>Evans, N. S.</span> and <span>C. Grothoff</span>, <span>&#34;R5N: Randomized recursive routing for restricted-route networks&#34;</span>, <time datetime="2011">2011</time>, <span>&lt;<a href="https://doi.org/10.1109/ICNSS.2011.6060022">https://doi.org/10.1109/ICNSS.2011.6060022</a>&gt;</span>. </dd>
<dd></dd>
<dt id="NSE">[NSE]</dt>
      <dd>
<span>Evans, N. S.</span>, <span>Polot, B.</span>, and <span>C. Grothoff</span>, <span>&#34;Efficient and Secure Decentralized Network Size Estimation&#34;</span>, <time datetime="2012">2012</time>, <span>&lt;<a href="https://doi.org/10.1007/978-3-642-30045-5_23">https://doi.org/10.1007/978-3-642-30045-5_23</a>&gt;</span>. </dd>
<dd></dd>
<dt id="Kademlia">[Kademlia]</dt>
      <dd>
<span>Maymounkov, P.</span> and <span>D. Mazieres</span>, <span>&#34;Kademlia: A peer-to-peer information system based on the xor metric.&#34;</span>, <time datetime="2002">2002</time>, <span>&lt;<a href="http://css.csail.mit.edu/6.824/2014/papers/kademlia.pdf">http://css.csail.mit.edu/6.824/2014/papers/kademlia.pdf</a>&gt;</span>. </dd>
<dd></dd>
<dt id="Sybil">[Sybil]</dt>
      <dd>
<span>Douceur, J.</span>, <span>&#34;The Sybil Attack&#34;</span>, <time datetime="2002">2002</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/3-540-45748-8_24">https://link.springer.com/chapter/10.1007/3-540-45748-8_24</a>&gt;</span>. </dd>
<dd></dd>
<dt id="Smallworldmix">[Smallworldmix]</dt>
      <dd>
<span>Dell&#39;Amico, M.</span>, <span>&#34;A Measurement of Mixing Time in Social Networks&#34;</span>, <time datetime="2009">2009</time>, <span>&lt;<a href="https://api.semanticscholar.org/CorpusID:44240877">https://api.semanticscholar.org/CorpusID:44240877</a>&gt;</span>. </dd>
<dd></dd>
<dt id="Smallworld">[Smallworld]</dt>
      <dd>
<span>Kleinberg, J.</span>, <span>&#34;Navigation in a small world&#34;</span>, <time datetime="2000">2000</time>, <span>&lt;<a href="https://www.nature.com/articles/35022643">https://www.nature.com/articles/35022643</a>&gt;</span>. </dd>
<dd></dd>
<dt id="cadet">[cadet]</dt>
    <dd>
<span>Polot, B.</span> and <span>C. Grothoff</span>, <span>&#34;CADET: Confidential ad-hoc decentralized end-to-end transport&#34;</span>, <time datetime="2014">2014</time>, <span>&lt;<a href="https://doi.org/10.1109/MedHocNet.2014.6849107">https://doi.org/10.1109/MedHocNet.2014.6849107</a>&gt;</span>. </dd>
<dd></dd>
</dl>
</section>
<div id="bloom_filters">
<section id="appendix-A">
      <h2 id="name-bloom-filters-in-r-5-n">
<a href="#appendix-A">Appendix A. </a><a href="#name-bloom-filters-in-r-5-n">Bloom filters in R<sup>5</sup>N</a>
      </h2>
<p id="appendix-A-1">
 R<sup>5</sup>N uses Bloom filters in several places.  This section
 gives some general background on Bloom filters and defines functions
 on this data structure shared by the various use-cases in R<sup>5</sup>N.<a href="#appendix-A-1">¶</a></p>
<p id="appendix-A-2">
        A Bloom filter (BF) is a space-efficient probabilistic datastructure
        to test if an element is part of a set of elements.
        Elements are identified by an element ID.
        Since a BF is a probabilistic datastructure, it is possible to have
        false-positives: when asked if an element is in the set, the answer from
        a BF is either &#34;no&#34; or &#34;maybe&#34;.<a href="#appendix-A-2">¶</a></p>
<p id="appendix-A-3">
        Bloom filters are defined as a string of <code>L</code> bits.
        The bits are initially always empty, meaning that the bits are set to
        zero.
        There are two functions which can be invoked on the Bloom filter &#34;bf&#34;:
        BF-SET(bf, e) and BF-TEST(bf, e) where &#34;e&#34; is an element that is to
        be added to the Bloom filter or queried against the set.<a href="#appendix-A-3">¶</a></p>
<p id="appendix-A-4">
        A mapping function M is used to map each ID of each element from the set to a
        subset of k bits.
        In the original proposal by Bloom, M is non-injective and can thus map the same
        element multiple times to the same bit.
        The type of the mapping function can thus be described by the following
        mathematical notation:<a href="#appendix-A-4">¶</a></p>
<span id="name-bloom-filter-mapping-functi"></span><div id="figure_bf_func">
<figure id="figure-20">
        <div id="appendix-A-5.1">
<pre>        ------------------------------------
        # M: E-&gt;B^k
        ------------------------------------
        # L = Number of bits
        # B = 0,1,2,3,4,...L-1 (the bits)
        # k = Number of bits per element
        # E = Set of elements
        ------------------------------------
        Example: L=256, k=3
        M(&#39;element-data&#39;) = {4,6,255}

</pre>
</div>
<figcaption><a href="#figure-20">Figure 20</a>:
<a href="#name-bloom-filter-mapping-functi">Bloom filter mapping function.</a>
        </figcaption></figure>
</div>
<p id="appendix-A-6">
        When adding an element to the Bloom filter <code>bf</code> using
        <code>BF-SET(bf, e)</code>, each integer <code>n</code> of the mapping
        <code>M(e)</code> is interpreted as a bit offset <code>n mod L</code> within
        <code>bf</code> and set to 1.<a href="#appendix-A-6">¶</a></p>
<p id="appendix-A-7">
        When testing if an element may be in the Bloom filter <code>bf</code> using
        <code>BF-TEST(bf,e)</code>, each bit offset <code>n mod L</code> within
        <code>bf</code> <span>MUST</span> have been set to 1.
        Otherwise, the element is not considered to be in the Bloom filter.<a href="#appendix-A-7">¶</a></p>
</section>
</div>
<div id="overlay">
<section id="appendix-B">
      <h2 id="name-overlay-operations">
<a href="#appendix-B">Appendix B. </a><a href="#name-overlay-operations">Overlay Operations</a>
      </h2>
<p id="appendix-B-1">
        An implementation of this specification commonly exposes the two overlay
        operations &#34;GET&#34; and &#34;PUT&#34;.
        The following are non-normative examples of APIs for those operations.
        Their behaviour is described prosaically in order to give implementers a fuller
        picture of the protocol.<a href="#appendix-B-1">¶</a></p>
<section id="appendix-B.1">
        <h3 id="name-get-operation">
<a href="#appendix-B.1">B.1. </a><a href="#name-get-operation">GET operation</a>
        </h3>
<p id="appendix-B.1-1">
          A basic GET operation interface may be exposed as:<a href="#appendix-B.1-1">¶</a></p>
<p id="appendix-B.1-2">
          <code>GET(Query-Key, Block-Type) -&gt; Results as List</code><a href="#appendix-B.1-2">¶</a></p>
<p id="appendix-B.1-3">
          The procedure typically takes at least two arguments to initiate a lookup:<a href="#appendix-B.1-3">¶</a></p>
<span></span><dl id="appendix-B.1-4">
          <dt id="appendix-B.1-4.1">
<code>QueryKey</code>:</dt>
          <dd id="appendix-B.1-4.2">
            is the 512-bit key to look for in the DHT.<a href="#appendix-B.1-4.2">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-4.3">Block-Type:</dt>
          <dd id="appendix-B.1-4.4">
            is the type of block to look for, possibly &#34;any&#34;.<a href="#appendix-B.1-4.4">¶</a>
</dd>
        <dd></dd>
</dl>
<p id="appendix-B.1-5">
          The GET procedure may allow additional optional parameters in order to
          control or modify the query:<a href="#appendix-B.1-5">¶</a></p>
<span></span><dl id="appendix-B.1-6">
          <dt id="appendix-B.1-6.1">Replication-Level:</dt>
          <dd id="appendix-B.1-6.2">
            is an integer which controls how many nearest peers the request
            should reach.<a href="#appendix-B.1-6.2">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-6.3">Flags:</dt>
          <dd id="appendix-B.1-6.4">
            is a 16-bit vector which indicates certain
            processing requirements for messages.
            Any combination of flags as defined in <a href="#route_flags">Section 7.1.1</a>
            may be specified.<a href="#appendix-B.1-6.4">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-6.5">eXtended-Query (XQuery):</dt>
          <dd id="appendix-B.1-6.6">
            is medatadata which may be
            required depending on the respective <code>Block-Type</code>.
            A <code>Block-Type</code> must define if the <code>XQuery</code> can or must
            be used and what the specific format of its contents should be.
            Extended queries are in general used to implement domain-specific filters.
            These might be particularly useful in combination with FindApproximate
            to add a well-defined filter by an application-specific distance.
            Regardless, the DHT does not define any particular semantics for an XQuery.
            See also <a href="#blockstorage">Section 8</a>.<a href="#appendix-B.1-6.6">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-6.7">Result-Filter:</dt>
          <dd id="appendix-B.1-6.8">
            is data for a <code>Block-type</code>-specific filter
     which allows applications to
     indicate results which are
     not relevant anymore to the
            caller (see <a href="#result_filter">Section 7.4.2</a>).<a href="#appendix-B.1-6.8">¶</a>
</dd>
        <dd></dd>
</dl>
<p id="appendix-B.1-7">
          The GET procedure should be implemented as an asynchronous
   operation that returns individual results as they are found
   in the DHT.  It should terminate only once the application
   explicitly cancels the operation.  A single result commonly
   consists of:<a href="#appendix-B.1-7">¶</a></p>
<span></span><dl id="appendix-B.1-8">
          <dt id="appendix-B.1-8.1">Block-Type:</dt>
          <dd id="appendix-B.1-8.2">
            is the desired type of block in the result.<a href="#appendix-B.1-8.2">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-8.3">Block-Data:</dt>
          <dd id="appendix-B.1-8.4">
            is the application-specific block payload. Contents are
            specific to the <code>Block-Type</code>.<a href="#appendix-B.1-8.4">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-8.5">Block-Expiration:</dt>
          <dd id="appendix-B.1-8.6">
            is the expiration time of the block. After this time, the result should no
     longer be used.<a href="#appendix-B.1-8.6">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-8.7">Key:</dt>
          <dd id="appendix-B.1-8.8">
            is the key under which the block was stored. This may be different from the
            key that was queried if the flag <code>FindApproximate</code> was set.<a href="#appendix-B.1-8.8">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-8.9">GET-Path:</dt>
          <dd id="appendix-B.1-8.10">
            is a signed path of the public keys of peers which the
            query traversed through the network. The DHT will try to
            make the path available if the <code>RecordRoute</code> flag
            was set by the application calling the PUT procedure. The
            reported path may have been truncated from the beginning.
            The API <span>SHOULD</span> signal truncation by exposing
            the <code>Truncated</code> flag.<a href="#appendix-B.1-8.10">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-8.11">PUT-Path:</dt>
          <dd id="appendix-B.1-8.12">
            is a signed path of the public keys of peers which the
            result message traversed.  The DHT will try to make the
            path available if the <code>RecordRoute</code> flag was set
            for the GET procedure.  The reported path may have been
            truncated from the beginning. The API
            <span>SHOULD</span> signal truncation by exposing the
            <code>Truncated</code> flag.  As the block was cached by the
            node at the end of this path, this path is more likely to
            be stale compared to the <code>GET-Path</code>.<a href="#appendix-B.1-8.12">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.1-8.13">Truncated:</dt>
          <dd id="appendix-B.1-8.14">
            is true if the <code>GET-Path</code> or <code>PUT-Path</code>
            was truncated, otherwise false.<a href="#appendix-B.1-8.14">¶</a>
</dd>
        <dd></dd>
</dl>
</section>
<section id="appendix-B.2">
        <h3 id="name-put-operation">
<a href="#appendix-B.2">B.2. </a><a href="#name-put-operation">PUT operation</a>
        </h3>
<p id="appendix-B.2-1">
          A PUT operation interface may be exposed as:<a href="#appendix-B.2-1">¶</a></p>
<p id="appendix-B.2-2">
          <code>PUT(Key, Block-Type, Block-Expiration, Block-Data)</code><a href="#appendix-B.2-2">¶</a></p>
<p id="appendix-B.2-3">
          The procedure typically takes at least four parameters:<a href="#appendix-B.2-3">¶</a></p>
<span></span><dl id="appendix-B.2-4">
          <dt id="appendix-B.2-4.1">Key:</dt>
          <dd id="appendix-B.2-4.2">is the key under which to store the block.<a href="#appendix-B.2-4.2">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.2-4.3">Block-Type:</dt>
          <dd id="appendix-B.2-4.4">is the type of the block to store.<a href="#appendix-B.2-4.4">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.2-4.5">Block-Expiration:</dt>
          <dd id="appendix-B.2-4.6">specifies when the block should expire.<a href="#appendix-B.2-4.6">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.2-4.7">Block-Data:</dt>
          <dd id="appendix-B.2-4.8">is the application-specific payload of the block to store.<a href="#appendix-B.2-4.8">¶</a>
</dd>
        <dd></dd>
</dl>
<p id="appendix-B.2-5">
          The PUT procedure may accept additional optional parameters that
          control or modify the operation:<a href="#appendix-B.2-5">¶</a></p>
<span></span><dl id="appendix-B.2-6">
          <dt id="appendix-B.2-6.1">Replication-Level:</dt>
          <dd id="appendix-B.2-6.2">
            is an integer which controls how many nearest peers the request
            should reach.<a href="#appendix-B.2-6.2">¶</a>
</dd>
          <dd></dd>
<dt id="appendix-B.2-6.3">Flags:</dt>
          <dd id="appendix-B.2-6.4">
            is a bit-vector which indicates certain processing
            requirements for messages.  Any combination of flags as
            defined in <a href="#route_flags">Section 7.1.1</a> may be specified.<a href="#appendix-B.2-6.4">¶</a>
</dd>
        <dd></dd>
</dl>
<p id="appendix-B.2-7">
          The PUT procedure does not necessarily yield any information.<a href="#appendix-B.2-7">¶</a></p>
</section>
</section>
</div>
<div id="hello_url">
<section id="appendix-C">
      <h2 id="name-hello-urls">
<a href="#appendix-C">Appendix C. </a><a href="#name-hello-urls">HELLO URLs</a>
      </h2>
<p id="appendix-C-1">
   The general format of a <code>HELLO</code> URL uses &#34;gnunet://&#34;
          as the scheme, followed by &#34;hello/&#34; for the name
          of the GNUnet subsystem, followed by &#34;/&#34;-separated values
          with the GNS Base32 encoding <span>[<a href="#RFC9498">RFC9498</a>]</span> of
          the peer public key, a Base32-encoded EdDSA signature
          <span>[<a href="#ed25519">ed25519</a>]</span>, and an expiration
          time in seconds since the UNIX Epoch in decimal format.
   After this a &#34;?&#34; begins a list of key-value pairs where the key
          is the URI scheme of one of the peer&#39;s addresses and the value
          is the URL-escaped payload of the address URI without the &#34;://&#34;.<a href="#appendix-C-1">¶</a></p>
<p id="appendix-C-2">
          The general syntax of <code>HELLO</code> URLs specified using
          Augmented Backus-Naur Form (ABNF) of <span>[<a href="#RFC5234">RFC5234</a>]</span> is:<a href="#appendix-C-2">¶</a></p>
<figure id="figure-21">
        <div id="appendix-C-3.1">
<pre>hello-URL = &#34;gnunet://hello[:version]/&#34; meta [ &#34;?&#34; addrs ]
version = *(DIGIT)
meta = pid &#34;/&#34; sig &#34;/&#34; exp
pid = *bchar
sig = *bchar
exp = *DIGIT
addrs = addr *( &#34;&amp;&#34; addr )
addr = addr-name &#34;=&#34; addr-value
addr-name = scheme
addr-value = *pchar
bchar = *(ALPHA / DIGIT)

</pre>
</div>
<figcaption><a href="#figure-21">Figure 21</a></figcaption></figure>
<p id="appendix-C-4">
         &#39;scheme&#39; is defined in <span>[<a href="#RFC3986">RFC3986</a>]</span> in Section 3.1.
         &#39;pchar&#39; is defined in <span>[<a href="#RFC3986">RFC3986</a>]</span>, Appendix A.<a href="#appendix-C-4">¶</a></p>
<p id="appendix-C-5">
          For example, consider the following URL:<a href="#appendix-C-5">¶</a></p>
<figure id="figure-22">
        <div id="appendix-C-6.1">
<pre>          gnunet://hello/1MVZC83SFHXMADVJ5F4
          S7BSM7CCGFNVJ1SMQPGW9Z7ZQBZ689ECG/
          CFJD9SY1NY5VM9X8RC5G2X2TAA7BCVCE16
          726H4JEGTAEB26JNCZKDHBPSN5JD3D60J5
          GJMHFJ5YGRGY4EYBP0E2FJJ3KFEYN6HYM0G/
          1708333757?foo=example.com&amp;bar+baz=1.2.3.4%3A5678%2Ffoo

</pre>
</div>
<figcaption><a href="#figure-22">Figure 22</a></figcaption></figure>
<p id="appendix-C-7">
    It specifies that the peer with the <code>pid</code> &#34;1MVZ...&#34;
          is reachable via &#34;foo&#34; at &#34;example.com&#34; and &#34;bar+baz&#34; at
          &#34;1.2.3.4&#34; on port 5678 until
          1708333757 seconds after the Epoch.  Note that &#34;foo&#34;
   and &#34;bar+baz&#34; here are underspecified and just used as a simple example.
   In practice, the <code>addr-name</code> refers to a scheme supported by a
   DHT underlay.<a href="#appendix-C-7">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-D">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses">Authors&#39; Addresses</a>
      </h2>
<address>
        <p><span>Martin Schanzenbach</span></p>
<p><span>Fraunhofer AISEC</span></p>
<p><span>Lichtenbergstrasse 11</span></p>
<p><span>85748</span> <span>Garching</span>
</p>
<p><span>Germany</span></p>

</address>
<address>
        <p><span>Christian Grothoff</span></p>
<p><span>Berner Fachhochschule</span></p>
<p><span>Hoeheweg 80</span></p>
<p>CH-<span>2501</span> <span>Biel/Bienne</span>
</p>
<p><span>Switzerland</span></p>

</address>
<address>
        <p><span>Bernd Fix</span></p>
<p><span>GNUnet e.V.</span></p>
<p><span>Boltzmannstrasse 3</span></p>
<p><span>85748</span> <span>Garching</span>
</p>
<p><span>Germany</span></p>

</address>
</section>
</div>



</div>
  </body>
</html>
