<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/max-sixty/prql">Original</a>
    <h1>PRQL – A proposal for a better SQL</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<p dir="auto"><strong>P</strong>ipelined <strong>R</strong>elational <strong>Q</strong>uery <strong>L</strong>anguage, pronounced &#34;Prequel&#34;.</p>
<p dir="auto">PRQL is a modern language for transforming data — a simpler and more powerful
SQL. Like SQL, it&#39;s readable, explicit and declarative. Unlike SQL, it forms a
logical pipeline of transformations, and supports abstractions such as variables
and functions. It can be used with any database that uses SQL, since it
transpiles to SQL.</p>
<p dir="auto">PRQL was discussed on Hacker News
<a href="https://news.ycombinator.com/item?id=30060784#30062329" rel="nofollow">here</a>.</p>
<h2 dir="auto"><a id="user-content-an-example" aria-hidden="true" href="#an-example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>An example</h2>
<p dir="auto">Here&#39;s a fairly simple SQL query:</p>
<div data-snippet-clipboard-copy-content="SELECT TOP 20
    title,
    country,
    AVG(salary) AS average_salary,
    SUM(salary) AS sum_salary,
    AVG(salary + payroll_tax) AS average_gross_salary,
    SUM(salary + payroll_tax) AS sum_gross_salary,
    AVG(salary + payroll_tax + benefits_cost) AS average_gross_cost,
    SUM(salary + payroll_tax + benefits_cost) AS sum_gross_cost,
    COUNT(*) as count
FROM employees
WHERE salary + payroll_tax + benefits_cost &gt; 0 AND country = &#39;USA&#39;
GROUP BY title, country
ORDER BY sum_gross_cost
HAVING count &gt; 200"><pre><span>SELECT</span> TOP <span>20</span>
    title,
    country,
    <span>AVG</span>(salary) <span>AS</span> average_salary,
    <span>SUM</span>(salary) <span>AS</span> sum_salary,
    <span>AVG</span>(salary <span>+</span> payroll_tax) <span>AS</span> average_gross_salary,
    <span>SUM</span>(salary <span>+</span> payroll_tax) <span>AS</span> sum_gross_salary,
    <span>AVG</span>(salary <span>+</span> payroll_tax <span>+</span> benefits_cost) <span>AS</span> average_gross_cost,
    <span>SUM</span>(salary <span>+</span> payroll_tax <span>+</span> benefits_cost) <span>AS</span> sum_gross_cost,
    <span>COUNT</span>(<span>*</span>) <span>as</span> count
<span>FROM</span> employees
<span>WHERE</span> salary <span>+</span> payroll_tax <span>+</span> benefits_cost <span>&gt;</span> <span>0</span> <span>AND</span> country <span>=</span> <span><span>&#39;</span>USA<span>&#39;</span></span>
<span>GROUP BY</span> title, country
<span>ORDER BY</span> sum_gross_cost
<span>HAVING</span> count <span>&gt;</span> <span>200</span></pre></div>
<p dir="auto">Even this simple query demonstrates some of the problems with SQL&#39;s lack of
abstractions:</p>
<ul dir="auto">
<li>Unnecessary repetition — the calculations for each measure are repeated,
despite deriving from a previous measure. The repetition in the <code>WHERE</code>
clause obfuscates the meaning of the expression.</li>
<li>Functions have multiple operators — <code>HAVING</code> &amp; <code>WHERE</code> are fundamentally
similar operations applied at different stages of the pipeline but SQL&#39;s lack
of pipeline-based precedence requires it to have two different operators.</li>
<li>Operators have multiple functions — the <code>SELECT</code> operator both
creates new aggregations, and selects which columns to include.</li>
<li>Awkward syntax — when developing the query, commenting out the final line of
the <code>SELECT</code> list causes a syntax error because of how commas are handled, and
we need to repeat the columns in the <code>GROUP BY</code> clause in the <code>SELECT</code> list.</li>
</ul>
<p dir="auto">Here&#39;s the same query with PRQL:</p>
<div data-snippet-clipboard-copy-content="from employees
filter country = &#34;USA&#34;                           # Each line transforms the previous result.
let gross_salary = salary + payroll_tax          # This _adds_ a column / variable.
let gross_cost   = gross_salary + benefits_cost  # Variables can use other variables.
filter gross_cost &gt; 0
aggregate by:[title, country] [                  # `by` are the columns to group by.
    average salary,                              # These are the calcs to run on the groups.
    sum     salary,
    average gross_salary,
    sum     gross_salary,
    average gross_cost,
    sum     gross_cost,
    count,
]
sort sum_gross_cost                              # Uses the auto-generated column name.
filter count &gt; 200
take 20"><pre><span>from </span>employees
<span>filter </span>country <span>=</span> <span><span>&#34;</span>USA<span>&#34;</span></span>                           # <span>Each</span> line transforms the previous result<span>.</span>
<span>let </span>gross_salary <span>=</span> salary <span>+</span> payroll_tax          # <span>This</span> _adds_ a column <span>/</span> variable<span>.</span>
<span>let </span>gross_cost   <span>=</span> gross_salary <span>+</span> benefits_cost  # <span>Variables</span> can use other variables<span>.</span>
<span>filter </span>gross_cost <span>&gt;</span> <span>0</span>
<span>aggregate </span>by<span>:</span><span><span>[</span></span>title<span><span>,</span></span> country<span><span>]</span></span> <span><span>[</span></span>                  # <span>`by`</span> are the columns to group by<span>.</span>
    average salary<span><span>,</span></span>                              # <span>These</span> are the calcs to run on the groups<span>.</span>
    sum     salary<span><span>,</span></span>
    average gross_salary<span><span>,</span></span>
    sum     gross_salary<span><span>,</span></span>
    average gross_cost<span><span>,</span></span>
    sum     gross_cost<span><span>,</span></span>
    count<span><span>,</span></span>
<span><span>]</span></span>
<span>sort </span>sum_gross_cost                              # <span>Uses</span> the auto<span>-</span>generated column name<span>.</span>
<span>filter </span>count <span>&gt;</span> <span>200</span>
<span>take </span><span>20</span></pre></div>
<p dir="auto">As well as using variables to reduce unnecessary repetition, the query is also
more readable — it flows from top to bottom, each line representing a
transformation of the previous line&#39;s result. For example, <code>TOP 20</code> / <code>take 20</code>
modify the final result in both queries — but only PRQL represents it as the
final transformation. And context is localized — the <code>aggregate</code> function
contains both the calculations and the columns to group by.</p>
<h2 dir="auto"><a id="user-content-an-example-using-functions" aria-hidden="true" href="#an-example-using-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>An example using Functions</h2>
<p dir="auto">Here&#39;s another SQL query, which calculates returns from prices on days with
valid prices.</p>
<div data-snippet-clipboard-copy-content="SELECT
  date,
  -- Can&#39;t use a `WHERE` clause, as it would affect the row that the `LAG` function referenced.
  IF(is_valid_price, price_adjusted / LAG(price_adjusted, 1) OVER 
    (PARTITION BY sec_id ORDER BY date) - 1 + dividend_return, NULL) AS return_total,
  IF(is_valid_price, price_adjusted_usd / LAG(price_adjusted_usd, 1) OVER 
    (PARTITION BY sec_id ORDER BY date) - 1 + dividend_return, NULL) AS return_usd,
  IF(is_valid_price, price_adjusted / LAG(price_adjusted, 1) OVER 
    (PARTITION BY sec_id ORDER BY date) - 1 + dividend_return, NULL) 
    - interest_rate / 252 AS return_excess,
  IF(is_valid_price, price_adjusted_usd / LAG(price_adjusted_usd, 1) OVER 
    (PARTITION BY sec_id ORDER BY date) - 1 + dividend_return, NULL) 
    - interest_rate / 252 AS return_usd_excess
FROM prices"><pre><span>SELECT</span>
  <span>date</span>,
  <span><span>--</span> Can&#39;t use a `WHERE` clause, as it would affect the row that the `LAG` function referenced.</span>
  IF(is_valid_price, price_adjusted <span>/</span> LAG(price_adjusted, <span>1</span>) OVER 
    (PARTITION BY sec_id <span>ORDER BY</span> <span>date</span>) <span>-</span> <span>1</span> <span>+</span> dividend_return, <span>NULL</span>) <span>AS</span> return_total,
  IF(is_valid_price, price_adjusted_usd <span>/</span> LAG(price_adjusted_usd, <span>1</span>) OVER 
    (PARTITION BY sec_id <span>ORDER BY</span> <span>date</span>) <span>-</span> <span>1</span> <span>+</span> dividend_return, <span>NULL</span>) <span>AS</span> return_usd,
  IF(is_valid_price, price_adjusted <span>/</span> LAG(price_adjusted, <span>1</span>) OVER 
    (PARTITION BY sec_id <span>ORDER BY</span> <span>date</span>) <span>-</span> <span>1</span> <span>+</span> dividend_return, <span>NULL</span>) 
    <span>-</span> interest_rate <span>/</span> <span>252</span> <span>AS</span> return_excess,
  IF(is_valid_price, price_adjusted_usd <span>/</span> LAG(price_adjusted_usd, <span>1</span>) OVER 
    (PARTITION BY sec_id <span>ORDER BY</span> <span>date</span>) <span>-</span> <span>1</span> <span>+</span> dividend_return, <span>NULL</span>) 
    <span>-</span> interest_rate <span>/</span> <span>252</span> <span>AS</span> return_usd_excess
<span>FROM</span> prices</pre></div>
<blockquote>
<p dir="auto">This might seem like a convoluted example, but it&#39;s taken from a real query.
Indeed, it&#39;s also simpler and smaller than the full logic — note that it
starts from <code>price_adjusted</code>, whose logic had to be split into a previous
query to avoid the SQL becoming even less readable.</p>
</blockquote>
<p dir="auto">Here&#39;s the same query with PRQL:</p>
<div data-snippet-clipboard-copy-content="prql version:0.0.1 db:snowflake                       # Version number &amp; database name.

func lag_day x = (
  window x 
  by sec_id 
  sort date
  lag 1
)
func ret x = x / (x | lag_day) - 1 + dividend_return
func excess x = (x - interest_rate) / 252    
func if_valid x = is_valid_price ? x : null

from prices
let return_total      = prices_adj   | ret | if_valid    # `|` can be used rather than newlines.
let return_usd        = prices_usd   | ret | if_valid
let return_excess     = return_total | excess
let return_usd_excess = return_usd   | excess
select [
  date,
  sec_id,
  return_total,
  return_usd,
  return_excess,
  return_usd_excess,
]"><pre><span>prql </span>version<span>:</span><span>0.0</span><span>.</span><span>1</span> db<span>:</span>snowflake                       # <span>Version</span> number <span>&amp;</span> database name<span>.</span>

<span>func </span>lag_day x <span>=</span> <span>(</span>
  window x 
  by sec_id 
  sort date
  lag <span>1</span>
<span>)</span>
<span>func </span>ret x <span>=</span> x <span>/</span> <span>(</span>x <span>|</span> lag_day<span>)</span> <span>-</span> <span>1</span> <span>+</span> dividend_return
<span>func </span>excess x <span>=</span> <span>(</span>x <span>-</span> interest_rate<span>)</span> <span>/</span> <span>252</span>    
<span>func </span>if_valid x <span>=</span> is_valid_price <span>?</span> x <span>:</span> null

<span>from </span>prices
<span>let </span>return_total      <span>=</span> prices_adj   <span>|</span> ret <span>|</span> if_valid    # `<span>|</span>` can be used rather than newlines<span>.</span>
<span>let </span>return_usd        <span>=</span> prices_usd   <span>|</span> ret <span>|</span> if_valid
<span>let </span>return_excess     <span>=</span> return_total <span>|</span> excess
<span>let </span>return_usd_excess <span>=</span> return_usd   <span>|</span> excess
<span>select </span><span><span>[</span></span>
  date<span><span>,</span></span>
  sec_id<span><span>,</span></span>
  return_total<span><span>,</span></span>
  return_usd<span><span>,</span></span>
  return_excess<span><span>,</span></span>
  return_usd_excess<span><span>,</span></span>
<span><span>]</span></span></pre></div>
<p dir="auto">Because we define the functions once rather than copying &amp; pasting the code, we
get all the benefits of encapsulation and extensibility — we can have reliable &amp;
tested functions, whose purpose is explicit, which we can share across queries
and colleagues.</p>
<h2 dir="auto"><a id="user-content-principles" aria-hidden="true" href="#principles"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Principles</h2>
<p dir="auto">PRQL is intended to be a modern, simple, declarative language for transforming
data, with abstractions such as variables &amp; functions. It&#39;s intended to replace
SQL, but doesn&#39;t have ambitions as a general-purpose programming language. While
it&#39;s at a pre-alpha stage, it has some immutable principles:</p>
<ul dir="auto">
<li><em>Pipelined</em> — PRQL is a linear pipeline of transformations — each line of the
query is a transformation of the previous line&#39;s result. This makes it easy to
read, and simple to write. This is also known as &#34;<a href="https://en.wikipedia.org/w/index.php?title=Point-free_programming" rel="nofollow">point-free
style</a>&#34;.</li>
<li><em>Simple</em> — PRQL serves both sophisticated engineers and analysts without
coding experience. By providing simple, clean abstractions, the
language can be both powerful and easy to use.</li>
<li><em>Compatible</em> — PRQL transpiles to SQL, so it can be used with any database
that uses SQL. Where possible PRQL can unify syntax across databases. PRQL
should allow for a gradual onramp — it should be practical to mix SQL into a
PRQL query where PRQL doesn&#39;t yet have an implementation.</li>
<li><em>Analytical</em> — PRQL&#39;s focus is analytical queries; we de-emphasize other SQL
features such as inserting data or transactions.</li>
<li><em>Extensible</em> — PRQL can be extended through its abstractions, and can evolve
without breaking backward-compatibility, because its queries can specify their
PRQL version.</li>
</ul>
<h2 dir="auto"><a id="user-content-interested-in-seeing-this-happen" aria-hidden="true" href="#interested-in-seeing-this-happen"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Interested in seeing this happen?</h2>
<p dir="auto">If you&#39;re interested in the ideas here and would like to see them explored:</p>
<ul dir="auto">
<li>Star this repo.</li>
<li>Open an issue:
<ul dir="auto">
<li>An analytical SQL query that&#39;s awkward and we could use as a case for
translating to PRQL. If you&#39;d like to add a suggestion of the equivalent
PRQL, that&#39;s very welcome too.</li>
<li>An area that isn&#39;t sufficiently discussed in the existing proposal.</li>
<li>An analytical SQL query that you think would be <em>more</em> difficult to express
in PRQL.</li>
</ul>
</li>
<li>Send the repo to a couple of people whose opinion you respect.</li>
<li>Subscribe to <a href="https://github.com/max-sixty/prql/issues/1">Issue #1</a> for
updates.</li>
<li>(If you&#39;d be up for helping on the compiler, let me know, but it&#39;s at a very
early stage.)</li>
</ul>
<p dir="auto">Any of these will inspire me to spend more time developing this; thank you in
advance.</p>
<h2 dir="auto"><a id="user-content-inspired-by" aria-hidden="true" href="#inspired-by"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Inspired by</h2>
<ul dir="auto">
<li><a href="https://dplyr.tidyverse.org/" rel="nofollow">dplyr</a> is a beautiful language for manipulating
data, in R. It&#39;s very similar to PRQL. It only works on in-memory R data.
<ul dir="auto">
<li>There&#39;s also <a href="https://dbplyr.tidyverse.org/" rel="nofollow">dbplyr</a> which compiles a subset
of dplyr to SQL. It requires an R runtime.</li>
</ul>
</li>
<li><a href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/samples?pivots=azuredataexplorer" rel="nofollow">Kusto</a>
is also a beautiful pipelined language, very similar to PRQL. But it can only
use Kusto-compatible DBs.
<ul dir="auto">
<li>A Kusto-to-SQL transpiler would be a legitimate alternative to PRQL, though
there would be some impediment mismatch in some areas. My central criticism
of Kusto is that it gives up broad compatibility without getting that much
in return.</li>
</ul>
</li>
<li><a href="https://www.scattered-thoughts.net/writing/against-sql/" rel="nofollow">Against SQL</a> gives
a fairly complete description of SQL&#39;s weaknesses, both for analytical and
transactional queries. @jamii consistently writes insightful pieces, and it&#39;s
worth sponsoring him for his updates.</li>
<li>Julia&#39;s <a href="https://gitlab.com/aplavin/DataPipes.jl" rel="nofollow">DataPipes.jl</a> &amp;
<a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a>, which demonstrate how
effective point-free pipelines can be, and how line-breaks can work as pipes.</li>
<li><a href="https://ocaml.org/" rel="nofollow">Ocaml</a>&#39;s elegant and simple syntax.</li>
</ul>
<h2 dir="auto"><a id="user-content-similar-projects" aria-hidden="true" href="#similar-projects"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Similar projects</h2>
<ul dir="auto">
<li><a href="https://github.com/looker-open-source/malloy">Malloy</a>, from @lloydtabb looks
very interesting, and has the team to make it successful. I&#39;ll spend some more
time checking it out.</li>
<li><a href="https://github.com/MechanicalRabbit/FunSQL.jl">FunSQL.jl</a> is a library in
Julia which compiles a nice query syntax to SQL. It requires a Julia runtime.</li>
<li>After writing this proposal (including the name!), I found
<a href="https://github.com/erezsh/Preql">Preql</a>. Despite the similar name and
compiling to SQL, it seems to focus more on making the language python-like,
which is very different to this proposal.</li>
</ul>
<h2 dir="auto"><a id="user-content-todos" aria-hidden="true" href="#todos"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TODOs</h2>
<ul dir="auto">
<li>Write a basic parser
<ul dir="auto">
<li>Currently writing it using <code>nom</code>.</li>
</ul>
</li>
<li>Write a basic complier
<ul dir="auto">
<li>This should be fairly easy since it&#39;s just generating SQL.</li>
</ul>
</li>
<li>Demonstrate some more complicated examples — e.g. most of the examples in
<a href="https://github.com/dbt-labs/dbt-utils">https://github.com/dbt-labs/dbt-utils</a> could all be covered much better by
this.</li>
</ul>
<h2 dir="auto"><a id="user-content-notes" aria-hidden="true" href="#notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Notes</h2>
<h3 dir="auto"><a id="user-content-joins" aria-hidden="true" href="#joins"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Joins</h3>
<ul dir="auto">
<li>
<p dir="auto">Joins are implemented as <code>{join_type} {table} {[conditions]}</code>. For example:</p>
<div data-snippet-clipboard-copy-content="from employees
left_join positions [id=employee_id]"><pre><span>from </span>employees
<span>left_join </span>positions <span><span>[</span></span>id<span>=</span>employee_id<span><span>]</span></span></pre></div>
<p dir="auto">...is equivalent to...</p>
<div data-snippet-clipboard-copy-content="SELECT * FROM employees LEFT JOIN positions ON id = employee_id"><pre><span>SELECT</span> <span>*</span> <span>FROM</span> employees <span>LEFT JOIN</span> positions <span>ON</span> id <span>=</span> employee_id</pre></div>
</li>
<li>
<p dir="auto">Possibly we could shorten <code>[id=id]</code> to <code>id</code>, and use SQL&#39;s <code>USING</code>, but it may
be ambiguous with using <code>id</code> as a boolean column.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-functions" aria-hidden="true" href="#functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functions</h3>
<ul dir="auto">
<li>
<p dir="auto">Functions can take two disjoint types of arguments:</p>
<ol dir="auto">
<li>Positional arguments. Callers must pass these.</li>
<li>Named arguments, which can optionally have a default value.</li>
</ol>
</li>
<li>
<p dir="auto">So a function like:</p>
<div data-snippet-clipboard-copy-content="func lag col sort_col by_col=id = (
  window col 
  by by_col
  sort sort_col
  lag 1
)"><pre><span>func </span>lag col sort_col by_col<span>=</span>id <span>=</span> <span>(</span>
  window col 
  by by_col
  sort sort_col
  lag <span>1</span>
<span>)</span></pre></div>
<p dir="auto">...is called <code>lag</code>, takes three arguments <code>col</code>, <code>sort_col</code> &amp; <code>by_col</code>, of
which the first two much be supplied, the third can optionally be supplied
with <code>by_col:sec_id</code>.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-assignments" aria-hidden="true" href="#assignments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Assignments</h3>
<ul dir="auto">
<li>To create a column, we use <code>let {column_name} = {calculation}</code> in a pipeline.
Technically this &#34;upserts&#34; the column — it&#39;ll either create or overwrite a
column, depending on whether it already exists.</li>
<li>Previously the syntax was just <code>{column_name} = {calculation}</code>, but it breaks
the pattern of every line starting with a keyword.</li>
<li>We could discard the <code>=</code> to just have <code>let {column_name} {calculation}</code>, which
would be more consistent with the other functions, but I think less readable
(and definitely less familiar).</li>
<li>I&#39;m still open to iterating here.</li>
</ul>
<h3 dir="auto"><a id="user-content-lists" aria-hidden="true" href="#lists"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lists</h3>
<ul dir="auto">
<li>
<p dir="auto">Currently lists require brackets; there&#39;s no implicit list like:</p>
<div data-snippet-clipboard-copy-content="from employees
select salary  # fails, would require `select [salary]`"><pre><span>from </span>employees
<span>select </span>salary  # fails<span><span>,</span></span> would require `select <span><span>[</span></span>salary<span><span>]</span></span>`</pre></div>
</li>
<li>
<p dir="auto">For some functions where we&#39;re only expecting a single arg, like <code>select</code>,
we could accept a single arg not as a list?</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-pipelines" aria-hidden="true" href="#pipelines"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Pipelines</h3>
<ul dir="auto">
<li>
<p dir="auto">A line-break generally creates a pipelined transformation. For example:</p>
<div data-snippet-clipboard-copy-content="from tbl
select [
  col1,
  col2,
]
filter col1 = col2"><pre><span>from </span>tbl
<span>select </span><span><span>[</span></span>
  col1<span><span>,</span></span>
  col2<span><span>,</span></span>
<span><span>]</span></span>
<span>filter </span>col1 <span>=</span> col2</pre></div>
<p dir="auto">...is equivalent to:</p>
<div data-snippet-clipboard-copy-content="from tbl | select [col1, col2] | filter col1 = col2"><pre><span>from </span>tbl <span>|</span> select <span><span>[</span></span>col1<span><span>,</span></span> col2<span><span>]</span></span> <span>|</span> filter col1 <span>=</span> col2</pre></div>
</li>
<li>
<p dir="auto">A line-break doesn&#39;t created a pipeline in a few cases:</p>
<ul dir="auto">
<li>Within a list (e.g. the <code>select</code> example above).</li>
<li>When the following line is a new statement, by starting with a keyword such
as <code>func</code>.</li>
</ul>
</li>
</ul>
<h3 dir="auto"><a id="user-content-ctes" aria-hidden="true" href="#ctes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>CTEs</h3>
<ul dir="auto">
<li>
<p dir="auto">Potentially something like:</p>
<div data-snippet-clipboard-copy-content="table newest_employees = (
  from employees
  sort tenure
  take 50
)

from newest_employees
join salary [id]
select [name, salary]"><pre><span>table </span>newest_employees <span>=</span> <span>(</span>
  from employees
  sort tenure
  take <span>50</span>
<span>)</span>

<span>from </span>newest_employees
<span>join </span>salary <span><span>[</span></span>id<span><span>]</span></span>
<span>select </span><span><span>[</span></span>name<span><span>,</span></span> salary<span><span>]</span></span></pre></div>
</li>
<li>
<p dir="auto">This is no longer point-free, but that&#39;s a feature rather than a requirement.
The alternative is subqueries, which are fine in some small queries, but as
queries get more complex, become difficult to digest.</p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-thinking-about" aria-hidden="true" href="#thinking-about"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Thinking about</h2>
<ul dir="auto">
<li>
<p dir="auto">How functions represent the previous result — the previous result is passed as
the final argument of a function; i.e. <code>aggregate</code> would be like this; where
<code>X</code> is taken from the line above:</p>
<div data-snippet-clipboard-copy-content="aggregate by=[] calcs X"><pre><span>aggregate </span>by<span>=</span><span><span>[]</span></span> calcs <span>X</span></pre></div>
</li>
<li>
<p dir="auto">Raw syntax — I think we should have backticks represent raw SQL; i.e. <code>UPPER</code>
could be defined as:</p>
<div data-snippet-clipboard-copy-content="func upper col = `UPPER(`col`)`
# or with f-string-like syntax
func upper col = `UPPER({col})`
# or with &#34; rather than `
func upper col = &#34;UPPER({col})&#34;"><pre><span>func </span>upper col <span>=</span> `<span>UPPER</span><span>(</span><span>`col`</span><span>)</span>`
# or with f<span>-</span>string<span>-</span>like syntax
<span>func </span>upper col <span>=</span> `<span>UPPER</span><span>(</span><span><span>{</span></span>col<span><span>}</span></span><span>)</span>`
# or with <span><span>&#34;</span> rather than `</span>
<span>func upper col = <span>&#34;</span></span><span>UPPER</span><span>(</span><span><span>{</span></span>col<span><span>}</span></span><span>)</span><span><span>&#34;</span></span></pre></div>
</li>
<li>
<p dir="auto">Arrays — PRQL is in part inspired by
<a href="https://gitlab.com/aplavin/DataPipes.jl" rel="nofollow">DataPipes.jl</a>, which demonstrates
how effective point-free pipelines can be
(<a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a> is similar). One benefit
of this is how well it deals with arbitrarily nested pipelines — which are
difficult to read in SQL and even in <code>jq</code>. Could we do something similar for
nested data in PRQL?</p>
<ul dir="auto">
<li>
<p dir="auto">Here&#39;s a snippet from <code>DataPipes.jl</code> — and we could avoid the macros / <code>do</code> / <code>end</code>):</p>
<div data-snippet-clipboard-copy-content="@p begin
  text
  strip
  split(__, &#34;\n&#34;)
  map() do __
      collect
      map() do __
        __ == chars[begin] ? 1 : 0
      end
  end
  hcat(__...)&#39;
end"><pre><span>@p</span> <span>begin</span>
  text
  strip
  <span>split</span>(__, <span><span>&#34;</span><span>\n</span><span>&#34;</span></span>)
  <span>map</span>() <span>do</span> __
      collect
      <span>map</span>() <span>do</span> __
        __ <span>==</span> chars[<span>begin</span>] <span>?</span> <span>1</span> <span>:</span> <span>0</span>
      <span>end</span>
  <span>end</span>
  <span>hcat</span>(__<span>...</span>)<span>&#39;</span>
<span>end</span></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">Partials — how functional do we want to make the lang? e.g. should we have
partial functions? e.g. [now based on an old version of <code>window</code>] potentially
we don&#39;t need the <code>col</code> in <code>lag</code> here?</p>
<div data-snippet-clipboard-copy-content="func lag col = window col by:sec_id sort:date lag:1"><pre><span>func </span>lag col <span>=</span> window col by<span>:</span>sec_id sort<span>:</span>date lag<span>:</span><span>1</span></pre></div>
</li>
<li>
<p dir="auto">Boolean logic — how should we represent boolean logic like <code>or</code>? With some
<code>or</code> function that takes <code>*args</code> (which we don&#39;t currently have a design for)?
Or implement dyadic operators; either <code>or</code> or <code>||</code>? (Same for <code>not</code>)</p>
</li>
<li>
<p dir="auto"><code>from</code> — do we need <code>from</code>? A previous version of this proposal didn&#39;t require
this — just start with the table name. But some initial feedback was that
removing <code>from</code> made it less clear.</p>
</li>
<li>
<p dir="auto">Readme syntax — we can&#39;t get syntax highlighting in GitHub&#39;s markdown — is
there a solution to this aside from submitting a parser to GitHub /
screenshots / creating a website?</p>
<ul dir="auto">
<li>Currently we use <code>elm</code> as it coincidentally provides the best syntax
highlight (open to suggestions for others!).</li>
</ul>
</li>
<li>
<p dir="auto">In advance of a full parser &amp; compiler, could we use something like
<a href="https://beta.openai.com/examples/default-sql-translate" rel="nofollow">Codex</a> to generate
the transformations, and let us explore the space? We can provide our owen
<a href="https://openai.com/blog/customized-gpt3/" rel="nofollow">examples</a>, by using
<a href="https://beta.openai.com/docs/guides/fine-tuning/advanced-usage" rel="nofollow">fine-tuning</a>.
Changing examples is easier than changing compilers!</p>
</li>
</ul>
</article>
        </div></div>
  </body>
</html>
