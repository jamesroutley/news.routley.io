<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eissing.org/icing/posts/rip_pthread_cancel/">Original</a>
    <h1>RIP pthread_cancel</h1>
    
    <div id="readability-page-1" class="page"><div><p>I posted about adding <a href="https://eissing.org/icing/posts/pthread_cancel">pthread_cancel use in curl</a>
about three weeks ago, we released this in curl 8.16.0 and it blew
up right in our faces. Now, with
<a href="https://github.com/curl/curl/pull/18540">#18540</a> we are ripping it
out again. What happened?</p>
<h2 id="short-recap">short recap</h2>
<p><a href="https://www.man7.org/linux/man-pages/man7/pthreads.7.html">pthreads</a>
define “Cancelation points”, a list of POSIX functions where
a pthread may be cancelled. In addition, there is also a list of functions
that <em>may</em> be cancelation points, among those <code>getaddrinfo()</code>.</p>
<p><code>getaddrinfo()</code> is exactly what we are interested in for <code>libcurl</code>. It blocks
until it has resolved a name. That may hang for a long time and <code>libcurl</code>
is unable to do anything else. Meh. So, we start a pthread and let that
call <code>getaddrinfo()</code>. <code>libcurl</code> can do other things while that thread runs.</p>
<p>But eventually, we have to get rid of the pthread again. Which means we
either have to <code>pthread_join()</code> it - which means a blocking wait. Or we
call <code>pthread_detach()</code> - which returns immediately but the thread keeps
on running. Both are bad when you want to do many, many transfers. Either we block and
stall or we let pthreads pile up in an uncontrolled way.</p>
<p>So, we added <code>pthread_cancel()</code> to interrupt a running <code>getaddrinfo()</code>
and get rid of the pthread we no longer needed. So the theory. And, after
some hair pulling, we got this working.</p>
<h2 id="cancel-yes-leakage-also-yes">cancel yes, leakage also yes!</h2>
<p>After releasing curl 8.16.0 we got an issue reported in
<a href="https://github.com/curl/curl/issues/18532">#18532</a> that cancelled
pthreads leaked memory.</p>
<p><img src="https://eissing.org/icing/posts/rip_pthread_cancel/images/modern-times-sigh.png" alt="modern times sigh"/></p>
<p>Digging into the <a href="https://codebrowser.dev/glibc/glibc/nss/getaddrinfo.c.html#gaiconf_init">glibc source</a>
shows that there is this thing called
<a href="https://www.man7.org/linux/man-pages/man5/gai.conf.5.html"><code>/etc/gai.conf</code></a>
which defines how <code>getaddrinfo()</code> should sort returned answers.</p>
<p>The implementation in glibc first resolves the name to addresses. For these,
it needs to allocate memory. <em>Then</em> it needs to sort them if there is more
than one address. And in order
to do <em>that</em> it needs to read <code>/etc/gai.conf</code>. And in order to do <em>that</em>
it calls <code>fopen()</code> on the file. And that may be a pthread “Cancelation Point”
(and if not, it surely calls <code>open()</code> which is a required cancelation point).</p>
<p>So, the pthread may get cancelled when reading <code>/etc/gai.conf</code> and leak all
the allocated responses. And if it gets cancelled there, it will try to
read <code>/etc/gai.conf</code> <em>again</em> the next time it has more than one address
resolved.</p>
<p>At this point, I decided that we need to give up on the whole <code>pthread_cancel()</code>
strategy. The reading of <code>/etc/gai.conf</code> is one point where a cancelled
<code>getaddrinfo()</code> may leak. There might be others. Clearly, glibc is not really
designed to prevent leaks here (admittedly, this is not trivial).</p>
<h2 id="rip">RIP</h2>
<p>Leaking memory potentially on something <code>libcurl</code> does over and over again is
not acceptable. We’d rather pay the price of having to eventually wait on
a long running <code>getaddrinfo()</code>.</p>
<p>Applications using <code>libcurl</code> can avoid this by using <code>c-ares</code> which resolves
unblocking and without the use of threads. But that will not be able to do
everything that glibc does.</p>
<p>DNS continues to be tricky to use well.</p>
<ul>
  
</ul>

    </div></div>
  </body>
</html>
