<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/the-docs-said-no-search-primary/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Using search as a primary datastore since the docs said not to</h1>
    
    <div id="readability-page-1" class="page"><div><p>Look, I&#39;m sorry, but if the docs say not to do something that&#39;s like <em>catnip</em>.
Then I just <em>have</em> to do it.
So when I saw that the <a href="https://shortclick.link/nsx6rt" rel="nofollow">Typesense</a> docs say <a href="https://typesense.org/docs/overview/use-cases.html#bad-use-cases" rel="nofollow">not to use it</a> as a primary datastore?
Well well well, that&#39;s what we&#39;ll have to do.</p>
<p>I spent a little bit of time figuring out what a bad <em>but plausible</em> use-case would be.
The answer is: a chat app.
Most chat apps have a search feature, so if you use search for the primary datastore, you get to remove another component!</p>
<p>Note: this is a sponsored post.
I was paid by Typesense to write this post.
The brief was to use Typesense in a small project and write about it, the good and the bad<sup><a href="#brief">1</a></sup>.
They have not reviewed this post before publication.</p>

<p>One of life&#39;s hard problems is naming things.
This chat app, like all Super Serious Side Projects, needs a fitting name, and so I arrived at: Taut.
It&#39;s named such because it is chat, but it sure ain&#39;t <em>Slack</em>.</p>
<p>The build-out was pretty straightforward and you can see the <a href="https://github.com/ntietz/taut-chat">repo on GitHub</a>.
It&#39;s licensed under the AGPL, and you should almost certainly <em>not</em> reuse this codeâ€”I&#39;m doing what you&#39;re not supposed to!
But it&#39;s open-source, so feel free to draw inspiration from it or use it as an example of how to use the Go SDK for Typesense.</p>
<p>Amusingly, the repo stats show that CSS is what I have the most of.
The Go backend for this is pretty simple, and the JS is non-existent since I used htmx.
Most of that CSS is not hand-written, though, since I used Tailwind.</p>
<p>Here&#39;s what the finished app looks like.
We have a login screen, which has no password requirement because this is for trustworthy people only!
You enter your handle and then you&#39;re logged in.</p>

<p><img src="https://bannerify.co/processed_images/login.d37229b7affa7486.png"/></p><p>Once you&#39;re logged in, you see a chat interface!
Here&#39;s a chat between two of our characters, Nicole and Maddie.</p>

<p><img src="https://bannerify.co/processed_images/chat-1.4f299b15c9821a5f.png"/></p><p>And here&#39;s another, between Nicole and Amy, who are apparently coworkers.</p>

<p><img src="https://bannerify.co/processed_images/chat-2.df555dbe83d9dbde.png"/></p><p>Oops, it looks like Nicole is going to put corporate details into this chat app!
I guess we&#39;d better look at how it&#39;s implemented to see if that&#39;s okay.</p>

<p>The first thing we need for our web app is a data model.
For our chat app, we really need two main things: users and messages.
Each user should have a handle, and each message should have who it&#39;s from and to as well as what was said.</p>
<p>I ended up with these models:</p>
<pre data-lang="go"><code data-lang="go">type User struct {
	ID      string `json:&#34;id&#34;`
	Handle  string `json:&#34;handle&#34;`
	Credits int64  `json:&#34;credits&#34;`
}

type Message struct {
	ID string `json:&#34;id&#34;`

	Sender    string `json:&#34;from_id&#34;`
	Recipient string `json:&#34;to_id&#34;`

	Content   string `json:&#34;content&#34;`
	Timestamp int64  `json:&#34;timestamp&#34;`
}
</code></pre>
<p>(Ignore &#34;Credits&#34;, sssshhh, we&#39;ll come back to that.)</p>
<p>To get records <em>into</em> the datastore, we also have to configure our schema.
There are some auto-schema settings available, but I wasn&#39;t sure how that worked and I want to be <em>certain</em> which schema is picked up, so I went with the old trusty to define how my data is laid out.
It&#39;s pretty straightforward: you tell it what fields you have and what their types are, and then you&#39;re done.
The ID field is created for you automatically, so you can leave that one off.</p>
<p>Here&#39;s an example of creating the users schema.</p>
<pre data-lang="go"><code data-lang="go">ctx := context.Background()

userSchema := &amp;api.CollectionSchema{
  Name: &#34;users&#34;,
  Fields: []api.Field{
    {
      Name: &#34;handle&#34;,
      Type: &#34;string&#34;,
    },
    {
      Name: &#34;credits&#34;,
      Type: &#34;int64&#34;,
    },
  },
}

_, err := ts.Collections().Create(ctx, userSchema)
if err != nil {
  return err
}
</code></pre>
<p>You&#39;d do something similar for any other collection.
This isn&#39;t too bad, but it&#39;s a bit redundant with what we already defined in the struct.
There could be an opportunity for some languages to auto-generate this for you, though the <a href="https://github.com/typesense/typesense-go"><code>typesense-go</code></a> library doesn&#39;t.</p>
<p>Creating records is where we <em>start</em> to see why what we&#39;re doing is probably a bad idea.
I only want to create a record if there isn&#39;t a user already.
In relational databases (especially with an ORM), this is a succinct operation.
Here, it gets a little more verbose.</p>
<p>We retrieve all the existing users by querying by the user&#39;s handle.</p>
<pre data-lang="go"><code data-lang="go">ctx := context.Background()
query := api.SearchCollectionParams{
  Q:       pointer.String(handle),
  QueryBy: pointer.String(&#34;handle&#34;),
}

matchingUsers, err := ts.Collection(&#34;users&#34;).Documents().Search(ctx, &amp;query)
if err != nil {
  return err
}
</code></pre>
<p>Then we count how many there are, and if there is not already a user, we create one!</p>
<pre data-lang="go"><code data-lang="go">if (*matchingUsers.Found) &gt; 0 {
  return nil
}

id := handle
user := User{
  ID:      id,
  Handle:  handle,
  Credits: 100,
}
_, err = ts.Collection(&#34;users&#34;).Documents().Create(ctx, user)
if err != nil {
  return err
}
return nil
</code></pre>
<p>A natural question may be, why not use an <code>Update</code> operation, or <code>upsert</code> if it&#39;s available?
I wanted to do something like this, but this will udpate the document we provide if it already exists!
There&#39;s no create-if-not-exists that I could find, and I didn&#39;t want to reset that <code>Credits</code> field.</p>
<p>We do similar for messages, which is in <a href="https://github.com/ntietz/taut-chat/blob/main/pkg/web/models.go">models.go</a>.
Now we have our models, and we can create instances of them!</p>

<p>Everything is a single-page app these days and <em>doesn&#39;t need to be</em>, so I built this in a traditional client-server way.
But since it&#39;s, you know, <em>chat</em>, it has to be more interactive.
That&#39;s easily addressed with htmx to make things reload!
I did polling here for simplicity, but you can also do it over websockets, which would be the better approach.</p>
<p>The login view isn&#39;t too interesting, but the main chat view and search views are where we see the meat.
Let&#39;s look at the chat view first.</p>
<p>Since we&#39;re using htmx, we&#39;ll implement <em>fragments</em> of views, which we&#39;ll load to replace specific parts of the page.
This led me to write the views in a modular way, and <em>really</em> reminded me how good we have it with other template libraries, and how bare-bones Go&#39;s built-in <a href="https://pkg.go.dev/html/template"><code>html/template</code></a> library is.</p>
<p>The main view looks like this.
Ignoring the html_open and html_close templates, there&#39;s not a lot to it.
Just some divs with styles and invoking the templates for our user list and chat window.</p>
<pre data-lang="html"><code data-lang="html">{{ template &#34;html_open&#34; }}
&lt;main class=&#34;w-full h-full&#34;&gt;

&lt;div class=&#34;flex flex-col w-full h-full p-4 bg-flagpink&#34;&gt;
{{ template &#34;header&#34; . }}
  &lt;div class=&#34;flex flex-row h-full w-full&#34;&gt;
    {{ template &#34;user_list&#34; . }}
    {{ template &#34;chat_window&#34; . }}
  &lt;/div&gt;
&lt;/div&gt;
&lt;/main&gt;
{{ template &#34;html_close&#34; }}
</code></pre>
<p>Each of those is also pretty simple.
This is how the user list is populated.
Each user has a handle, and clicking on their handle will let you chat with them.</p>
<pre data-lang="html"><code data-lang="html">{{ define &#34;user_list&#34; }}
&lt;div id=&#34;users-list&#34; class=&#34;bg-white outline outline-4 outline-black h-full p-2 flex flex-col&#34; hx-get=&#34;/fragment/users&#34; hx-trigger=&#34;every 5s&#34; hx-swap=&#34;outerHTML&#34;&gt;
  &lt;strong&gt;People&lt;/strong&gt;

  {{ range .Handles }}
  &lt;a href=&#34;/start-chat/{{ . }}&#34;&gt;{{ . }}&lt;/a&gt;
  {{ end }}

&lt;/div&gt;
{{ end }}
{{ template &#34;user_list&#34; . }}
</code></pre>
<p>On the backend, we have to get data <em>into</em> these views, though.
To do that, we&#39;re off to query Typesense again!
Full details are in <a href="https://github.com/ntietz/taut-chat/blob/main/pkg/web/views.go">the <code>views.go</code> file</a>, here are the highlights.</p>
<p>The main thing we need to do is list users.
We can make a function to return that list, which will take a Typesense client as an argument (here, it&#39;s called <code>h.Ts</code> due to either idiomatic or poor naming conventions).</p>
<pre data-lang="go"><code data-lang="go">handles, err := ListUserHandles(h.Ts)
</code></pre>
<p>Implementing this is pretty easy.
We search for all users, retrieve them, then from each record we extract just the handle.</p>
<pre data-lang="go"><code data-lang="go">func ListUserHandles(ts *typesense.Client) ([]string, error) {
	ctx := context.Background()

	query := api.SearchCollectionParams{
		Q:       pointer.String(&#34;*&#34;),
		QueryBy: pointer.String(&#34;handle&#34;),
	}

	userRecords, err := ts.Collection(&#34;users&#34;).Documents().Search(ctx, &amp;query)
	if err != nil {
		return nil, err
	}

	handles := make([]string, 0)

	for _, userRecord := range *(*userRecords).Hits {
		handle := (*userRecord.Document)[&#34;handle&#34;].(string)
		handles = append(handles, handle)
	}

	return handles, nil
}
</code></pre>
<p>Not bad, given what we&#39;re doing!
It could be shorter, but this is a raw library, so it&#39;s not too tough to wrap that up yourself.</p>

<p>You&#39;re going to run into cases like this when you hold something wrong on purpose, but yeah, I really stepped in it with message retrieval.
What we wanted was to display all the chat messages between two users, and what we got was definitely that, but then also maybe something spicy.
To make it work, I definitely misused the query interface.</p>
<p>When you query Typesense, you get a few parameters.</p>
<ul>
<li><code>q</code> is the search string. For a recipes app, this might be <code>&#34;pizza&#34;</code>.</li>
<li><code>query_by</code> says which field to search for <code>q</code> within. This could be something like <code>&#34;description&#34;</code>.</li>
<li><code>filter_by</code> lets you provide some criteria to filter out non-matching records. This could be <code>num_steps:&lt;5</code>, because I want a <em>simple</em> pizza recipe.</li>
</ul>
<p>Now, here&#39;s what I wound up with to search for messages.
Remember that our messages have a sender, recipient, and content.
Here we&#39;re just looking at messages from one user to the other, so we&#39;ll just get one side of the conversation.</p>
<pre data-lang="go"><code data-lang="go">filter := fmt.Sprintf(&#34;from_id:=%s&#34;, from)

query := api.SearchCollectionParams{
  Q:        pointer.String(to),
  QueryBy:  pointer.String(&#34;to_id&#34;),
  FilterBy: pointer.String(filter),
  SortBy:   pointer.String(&#34;timestamp:desc&#34;),
}
</code></pre>
<p>If your alarm bells are going off right now, blaring &#34;red alert,&#34; yeah, I hear you.
What I did here is a <em>cardinal sin of web development</em>, one of the <a href="https://owasp.org/www-project-top-ten/">OWASP Top 10</a>.
I allowed an injection attack.
It&#39;s all because of this line:</p>
<pre data-lang="go"><code data-lang="go">filter := fmt.Sprintf(&#34;from_id:=%s&#34;, from)
</code></pre>
<p>See, Typesense doesn&#39;t have parameterized queries.
Those are standard-issue in SQL and when you use them you&#39;re protected from SQL injection attacks.
Here, we don&#39;t have them, sooooo...
If we just carefully craft a handle, that can end up doing fun things from inside our filter query.</p>
<p>I logged in with my <em>totally normal</em> handle, <code>1||from_id:!=1</code>, and what do you know...</p>

<p><img src="https://bannerify.co/processed_images/injection-1.5b3c62f77cbfd45c.png"/></p><p>Whoops, now as long as I get my own username into the filter field, I can see anyone else&#39;s chats!
With that query above, viewing anyone&#39;s chats <em>with me</em> actually result in showing me <em>any</em> message which was intended for them.
Now we can see Nicole messaging Amy about those work secrets, oh no!</p>
<p>To protect against this, you have a few options.
The best solution is to use <a href="https://typesense.org/docs/26.0/api/api-keys.html#generate-scoped-search-key" rel="nofollow">scoped search keys</a>.
These let you essentially pre-filter the dataset with a filter that cannot be modified, so even if someone injects into your filter they can&#39;t gain access to data they otherwise can&#39;t see.
This is a bit more work than parameterized queries would be, though, so I&#39;m a <em>touch</em> sad that this is the solution and I hope parameterized queries land someday!</p>
<p>You could also either <em>ban user input from filter fields</em> or <em>sanitize user input</em>, but both of these are error prone.
It&#39;s very easy to slip up and allow user input through, and it&#39;s really tough to make sure the sanitizer is correct.
So it&#39;s best not to rely on these and do it with scoped keys!</p>

<p>The star of the show here, really, is searching messages.
This was delightfully easy.
Here&#39;s what it looks like.</p>

<p><img src="https://bannerify.co/processed_images/search-1.64228f7e2787fa9a.png"/>

<img src="https://bannerify.co/processed_images/search-2.bbc4924c749b4938.png"/></p><p>We can see that in this search, we&#39;re only seeing Nicole&#39;s prviate work chat in her own history!
And otherwise, we get the results we&#39;d expect.</p>
<p>Typesense helps highlight where the query was found in the search results!
I had a small challenge with it, because it&#39;s different than what I&#39;m used to.
In other libraries I&#39;ve used, I will get back the indexes of where highlighted text starts and ends.
Typesense gives me a convenience here, specifying the start/end tags!
The challenge I ran into is how I would make sure that the underlying content is all escaped, to prevent injection attacks, without also escaping these start/end tags!
I&#39;m sure there&#39;s some way to do that, but I wasn&#39;t clear on how.</p>
<p>As far as Taut goes?
I&#39;m just yeeting those messages raw into the finished template, as html.
I&#39;m also definitely <em>not</em> putting this on the public internet, because y&#39;all can&#39;t be trusted like that and someone would 100% immediately do a script injection attack here.</p>
<p>This is what our search query looks like:</p>
<pre data-lang="go"><code data-lang="go">filter := fmt.Sprintf(&#34;from_id:=%s || to_id:=%s&#34;, currentUser, currentUser)
qparams := api.SearchCollectionParams{
  Q:                   pointer.String(query),
  QueryBy:             pointer.String(&#34;content&#34;),
  FilterBy:            pointer.String(filter),
  SortBy:              pointer.String(&#34;timestamp:desc&#34;),
  HighlightStartTag:   pointer.String(&#34;&lt;b&gt;&#34;),
  HighlightEndTag:     pointer.String(&#34;&lt;/b&gt;&#34;),
  HighlightFullFields: pointer.String(&#34;content&#34;),
}
</code></pre>
<p>This one has the same vulnerability as before, but with a twist: instead of showing messages to the attacker, it will show the attacker&#39;s messages to <em>you</em>.
This is delightful when you pair with a <del>2012 Cabernet</del> script injection attack.
Again, you would mitigate this with scoped search keys, but I didn&#39;t, so we&#39;ve got this little delight.</p>

<p>So, that&#39;s Taut.
I said at the outset that the docs told me not to do this and I did it anyway.
Why do they say not to do it?</p>
<p>There are a few reasons.
Some of them were highlighted above, but some are things you&#39;d run into if you kept going with this.</p>
<p><strong>Flexibility of queries</strong> is a big one for me.
Relational databases have SQL, which is designed for the sort of expressive queries that you do in this sort of app!
On the other hand, Typesense is <strong>built for search!</strong>
So the queries are optimized for <em>search scenarios</em>, which are not the same.</p>
<p><strong>Lack of parameterized queries</strong> is another one for me.
I want my primary datastore to be something that&#39;s hardened and really trusted, from both a reliability and a security perspective.
Something which doesn&#39;t have parameterized queries makes me look twice, from a security perspective.
Maybe we <em>shouldn&#39;t</em> put user input into filter fields but, okay, someone is <em>going</em> to.
We should make that path something that can be reasonably secured.
The existing solution of scoped search keys is also a reasonable one, but it&#39;s one that&#39;s not highlighted in the documentation around filters, so again, someone is <em>going to do this</em> in production.</p>
<p>If you kept adding features to this app, you&#39;d run into <strong>lack of transactions</strong>.
Again, this makes total sense for document search!
But for a primary datastore, you often will have multiple things you want to have happen together or not at all.
The <code>Credits</code> field I&#39;d included?
Originally I wanted to implement a feature that&#39;s totally extra, called Extra Chats.
If you make a chat &#34;extra&#34;, it would send confetti or something.
To do this, you&#39;d have to send the message <em>and</em> deduct from a user&#39;s credits simultaneously.</p>
<p>You can&#39;t insert/update records across two collections, though, and you can&#39;t lock rows!
There are solutions, like using event sourcing, but... those end up pretty complicated.</p>
<p>And then you also have <strong>data durability</strong>.
Typesense stores everything in memory, so unless it&#39;s configured to write to the disk, you can drop data.
I was a <em>little</em> annoyed that this is turned on by default, because the wind was taken out of my sails for this point.
Turns out, Typesense has worked a lot into making things reliable and durable!
Writing data to the disk is enabled by default, and you can enable <a href="https://typesense.org/docs/guide/high-availability.html" rel="nofollow">clustering for high availability</a> as well.</p>
<p>Ultimately, though, it&#39;s not <em>designed</em> to be your primary datastore, so you should probably listen to that.
There are going to be things that aren&#39;t handled perfectly for durability since that&#39;s not what they&#39;re designing for.
So probably don&#39;t do this for real.</p>

<p>I came away from this project hoping that I have a use case sometime soon to use Typesense the <em>right</em> way.
There are rough edges, of course, because <em>everthing</em> has them.
(Seriously, <em>please</em> add parameterized queries, please please, that seems like a big win for happy path security!)</p>
<p>For actually <em>searching</em> across documents?
Oh, it seems really nice!
I&#39;d love to use it in that way and get to see it in its environment where it shines.</p>
<hr/>
<div id="brief"><p><sup>1</sup></p><p>Amusingly, the brief actually stipulates that I&#39;d use it <em>as the primary data store</em>, because I&#39;d pitched that as the idea before the brief was issued and signed.
So they did, technically, pay me to use their product wrong!</p>
</div>
</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://bannerify.co/newsletter/">newsletter</a>. There is also an <a href="https://bannerify.co/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
