<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hypercubed.github.io/joy/html/j02maf.html">Original</a>
    <h1>Mathematical Foundations of Joy</h1>
    
    <div id="readability-page-1" class="page">
<i> by Manfred von Thun </i>
<p>
<em>Abstract:</em>

Joy is a functional programming language which is not based on the
application of functions to arguments but on the composition of
functions.  This paper describes the theoretical basis of the
language.  The denotation of Joy programs maps a syntactic monoid of
program concatenation to a semantic monoid of function composition.
Instead of lambda abstraction Joy uses program quotation, and higher
order functions can be simulated by first order functions which
dequote quoted programs.

</p><p>

<em>Keywords:</em> functional programming, syntactic and semantic
monoids, function composition, quotation and dequotation of programs,
combinators, elimination of recursive definitions.

</p><hr/>



Joy programs are built from smaller programs by just two constructors:
<em>concatenation</em> and <em>quotation</em>.

<p>

Concatenation is a binary constructor, and since it is associative it
is best written in infix notation and hence no parentheses are
required.  Since concatenation is the only binary constructor of its
kind, in Joy it is best written without an explicit symbol.

</p><p>

Quotation is a unary constructor which takes as its operand a program.
In Joy the quotation of a program is written by enclosing it in square
brackets.  Ultimately all programs are built from atomic programs
which do not have any parts.

</p><p>

The semantics of Joy has to explain what the atomic programs mean, how
the meaning of a concatenated program depends on the meaning of its
parts, and what the meaning of a quoted program is.  Moreover, it has
to explain under what conditions it is possible to replace a part by
an equivalent part while retaining the meaning of the whole program.

</p><p>

Joy programs denote functions which take one argument and yield one
value.  The argument and the value are <em>state</em>s consisting of
at least three components.  The principal component is a
<em>stack</em>, and the other components are not needed here.  Much of
the detail of the semantics of Joy depends on specific properties of
programs.

</p><p>

However, central to the semantics of Joy is the following:
</p><blockquote>
  The concatenation of two programs
denotes the composition of the functions denoted by the two programs.
</blockquote>

Function composition is associative, and hence denotation maps the
associative syntactic operation of program concatenation onto the
associative semantic operation of function composition.  The quotation
of a program denotes a function which takes any state as argument and
yields as value the same state except that the quotation is pushed
onto the stack.

<p>

One part of a concatenation may be replaced by another part denoting
the same function while retaining the denotation of the whole
concatenation.
</p><p>

One quoted program may be replaced by another denoting the same
function only in a context where the quoted program will be dequoted
by being executed.  Such contexts are provided by the
<em>combinator</em>s of Joy.  These denote functions which behave like
higher order functions in other languages.

</p><p>

The above may be summarised as follows: Let <code>P</code>,
<code>Q1</code>, <code>Q2</code> and <code>R</code> be programs, and
let <code>C</code> be a combinator.  Then this principle holds:

</p><pre>        IF          Q1      ==      Q2
        THEN     P  Q1  R   ==   P  Q2  R
        AND        [Q1] C   ==     [Q2] C
</pre>

The principle is the prime rule of inference for the <em>algebra of
Joy</em> which deals with the equivalence of Joy programs, and hence
with the identity of functions denoted by such programs.  A few laws
in the algebra can be expressed without combinators, but most require
one or more combinators for their expression.


<p>

The remainder of this paper is organised as follows.  The next
sections deal with program concatenation and function composition.
The first of these reviews certain algebras called monoids, and
homomorphisms between them.  In the following section the meaning of
Joy programs is shown to be a homomorphism from a syntactic monoid to
a semantic monoid.  The last of these sections explains the semantic
monoid in a little more detail, in particular function composition and
the identity function.

</p><p>

The other sections deal with quotations and combinators.  The first
treats combinators that do not involve the stack, the second those
that do.  The next section illustrates how these very basic
combinators can be used to emulate recursion without explicit
definitions.  The summary section recapitulates the main conclusions
and hints at a connection with category theory.

</p>

The design of Joy was motivated by <a href="https://hypercubed.github.io/joy/html/refs.html#%7BQuine71%7D">{Quine71}</a> and <a href="https://hypercubed.github.io/joy/html/refs.html#%7BBackus78%7D">{Backus78}</a> who in
quite different fields examine how variables of one kind or another
can be eliminated and how their work can be done by combinators.  In
turn their work is based on the pioneers Schönfinkel and Curry.
Backus has argued that concepts of programming languages should be
selected on the basis of yielding strong and clean mathematical laws.
In particular he favours concepts that allow simple algebraic
manipulations, where possible replacing variables by combinators or
higher order functions.  With these goals in mind his research
culminated in the language <em>FP</em>.  The language Joy offers a
very different solution to the same goals.

Paulson <a href="https://hypercubed.github.io/joy/html/refs.html#%7BPaulson92%7D">{Paulson92}</a> remarked that &#34;Programming and pure mathematics
are difficult to combine into one formal framework&#34;.  Joy attempts
this task.

<p>

Much of the elegance of Joy is due to the simple algebraic structure
of its syntax and the simple algebraic structure of its semantics and
to the fact that the two structures are so similar.  In particular,
the two structures are <em>monoid</em>s and the meaning function which
maps syntax into semantics is a <em>homomorphism</em>.

</p><p>

Monoids and homomorphisms are familiar from abstract algebra.  A <em>
monoid</em> <code>M</code> consists of a nonempty set <code>{m, m1,
m2 ...}</code> including a special element <code>m</code>, and a
binary operation, written, say, as infix period <code>&#34;.&#34;</code>.  The
special element has to be a left and right <em>unit element</em> for
the binary operation, and the binary operation has to be
<em>associative</em>.  In symbols, for all <code>x</code>,
<code>y</code> and <code>z</code> from the set,

</p><pre>        m . x   =   x   =   x . m
        (x . y) . z   =   x . (y . z)
</pre>

For example, these are monoids: the integers with <code>0</code> as
the unit element and addition as the binary operation, or the integers
with <code>1</code> as the unit element and multiplication as the
binary operation.  Two examples from logic are the truth values with
falsity as the unit element and disjunction as the binary operation,
or truth as the unit element and conjunction as the binary operation.
Two examples from set theory are sets with the nullset as the unit
element and set union as the binary operation, or the universal set as
the unit element and set intersection as the binary operation.  It so
happens that in the preceding examples the binary operation is
commutative, but this is not essential for monoids.  Two other
examples consists of lists with the empty list as the unit element and
concatenation as the binary operation, or strings of characters with
the empty string as the unit element and concatenation as the binary
operation.  Concatenation is <em> not</em> commutative.

<p>

Because of the associative law, parentheses are not needed.  Also, if
there are no other binary operations, the infix operator itself can be
omitted and the operation indicated by juxtaposition.  Unit elements
are often called identity elements, but the word &#34;identity&#34; is already
needed with a different meaning in Joy.  Unit elements are sometimes
called neutral elements, too.

</p><p>

Unit elements should be distinguished from <em>zero element</em>s,
which behave the way the number <code>0</code> interacts with
multiplication: a product containing a zero factor is equal to zero.
In logic falsity is the zero element for conjunction, and truth is the
zero element for disjunction.  For sets the nullset is the zero
element for intersection, and the universal set is the zero element
for union.  In commutative monoids there is always at most one zero
element.

</p><p>

Let <code>M</code> over <code>{m m1 ..}</code> and <code>N</code> over
<code>{n n1 ..}</code> be two monoids.  A function <code>h</code> from
<code>{m m1 ..}</code> to <code>{n n1 ..}</code> is called a <em>
homomorphism</em> if and only if it maps unit elements onto unit
elements and commutes with the binary operation:

</p><pre>        h(m)  =  n                      h(x . y)  =  h(x) . h(y)
</pre>

In the second equation, the binary operation on the left is that of
<code>M</code>, and the one on the right is that of <code>N</code>.
One example is the logarithm function which is a homomorphism from the
multiplicative monoid onto the additive monoid.  Another example of a
homomorphism is the <kbd>size</kbd> (or length) function on lists
which maps the list monoid onto the additive monoid: the size of the
empty list is zero, and the size of the concatenation of two lists is
the sum of the sizes of the two lists:

<pre>        log(1)  =  0                    log(x * y)  =  log(x) + log(y)
        size([])  =  0                  size(x ++ y)  =  size(x) + size(y)
</pre>

(In the last two equations, the symbols <code>[]</code> and
<code>++</code> are used for the empty list and for concatenation.)
Other examples are the function which takes a list (or string) as
argument and returns the set of its elements.  So this function
removes duplicates and forgets order.  It maps the list monoid onto
the set monoid with the nullset as the unit and union as the binary
operation.

<p>

Homomorphisms can be defined over other algebras which are not
monoids.  Examples are groups, rings, fields and Boolean algebras.
They are studied in universal algebra and in category theory.  One
particular homomorphism can only be described as mind-blowing: this is
Gödel&#39;s arithmetisation of syntax - all syntactic operations on
formulas of a theory are mapped onto corresponding arithmetic
operations on their Gödel numbers.  (See for example
<a href="https://hypercubed.github.io/joy/html/refs.html#%7BMendelson64%7D">{Mendelson64}</a>.)

</p><p>

In propositional logic the equivalence classes of formulas constitute
a Boolean algebra of many elements.  A valuation is a homomorphism
from that algebra to the two element Boolean algebra of truth values.
One can go further: the meaning of a formula is the set of valuations
that make it true.  The meaning function then is a homomorphism from
the Boolean algebra of equivalence classes to the Boolean algebra of
sets of valuations.  This situation is typical in semantics: the
meaning function is a homomorphism.  The same holds for Joy - the
meaning function is a homomorphism from Joy syntax to Joy semantics.

</p>

The <em>syntax</em> of Joy programs is very simple: the basic building
blocks are atomic programs, and larger programs are formed by
concatenation as one of the main modes of program construction.
Concatenation is associative, and hence no parentheses are required.
Also, concatenation is the only binary constructor, so no explicit
symbol is required, and hence concatenation can be expressed by
juxtaposition.  It is useful to have a left and right unit element
<kbd>id</kbd>.  Collectively these constitute the syntactic monoid.

<p>

Now to the <em>semantics</em>.  In the introduction it was said that
Joy uses postfix notation for the evaluation of arithmetic
expressions.  To add two numbers they are pushed onto a stack and then
replaced by their sum.  This terminology is helpful but can be
misleading in several ways.  The phrasing suggest a procedural or
imperative interpretation: Joy programs consist of commands such as
push this, push that, pop these and push their sum.  But there is
nothing procedural about Joy, as described here it is a purely
functional language.

</p><p>

However, the terminology of commands does suggest something useful.
Commands, when executed, produce changes.  Exactly what is changed
depends on the nature of the command.  But in the most general terms
what changes is the state of a system.  In particular the execution of
a postfix expression produces changes in the state of a stack.  For
each change there is a before-state and an after-state.  The
after-state of one change is the before-state of the next change.

</p><p>

So, changes are essentially functions that take states as arguments
and yield states as values.  There is only one before-state, so they
are functions of one argument.  Therefore they can be composed.  The
composite of two functions can be applied to a state as argument and
yields as value the state that is obtained by first applying the one
function to the argument and then applying the other function to the
resulting value.  This is essentially the semantics of Joy: All
programs denote functions from states to states.

</p><p>

The state does not have to be the state of a stack.  It just so
happens that evaluation of postfix expressions is so conveniently done
on a stack.  But evaluation of expressions is by no means everything.
In what follows, the stack is an essential part of the state, but for
many purposes it is useful to ignore the whole state altogether.

</p><p>

The operation of <em>function composition</em> is associative and
there is a left and right unit element, the <em>identity
function</em>.  Collectively they comprise the semantic monoid.  The
meaning function maps a syntactic monoid onto a semantic monoid.  The
concatenation of two programs denotes the composition of the functions
denoted by the two programs, and the unit element of concatenation
denotes the unit element of composition.

</p>

If the <em> programs</em> <code>P</code> and <code>Q</code> denote
the same function, then the <em> functions</em> <code>P</code> and
<code>Q</code> are <em> identical</em>.  Two functions are identical
if for all values in the intersection of their domains they yield the
same value.  This will be written

<pre>        P   ==   Q
</pre>

The symbol <code>==</code> will be used to denote the identity of Joy
functions.  The symbol does not belong to the language Joy but to its
metalanguage.  The <em>identity relation</em> between functions is
clearly <em>reflexive</em>, <em>symmetric</em> and
<em>transitive</em>.  Furthermore, identicals are indiscernible in
larger contexts such as compositions.  Hence <em>substitution</em> of
identicals can be used as a rule of inference:

<pre>        IF             Q1      ==      Q2
        THEN        P  Q1  R   ==   P  Q2  R
</pre>

The symbol <kbd>id</kbd> will be used to denote the <em>identity
function</em>.  The fact that function composition is associative and
that the identity function is a left and right unit is expressed by

<pre>        (P  Q)  R   ==   P  (Q  R)
        id  P   ==   P   ==   P  id
</pre>

The notation can be used to express what <em> look</em> like
identities of numbers; for example

<pre>        2  3  +   ==   5
</pre>

expresses that the composition of the three <em> functions</em> on the
left is identical with the one <em> function</em> on the right.  On
the left, the first two functions push the <em> numbers</em> 2 and 3
onto the stack, and the third replaces them by their sum.  On the
right, the function pushes the <em> number</em> 5.  The left and the
right are defined for all stacks as arguments and yield the same stack
as value.  Hence the left and the right are identical.

<p>

But it is important to be quite clear what the equation says.  Each of
the four symbols <code>2</code>, <code>3</code>, <code>+</code> and
<code>5</code> denotes a function which takes a stack as argument and
yields a stack as value.  The three <em> numerals</em> <code>2</code>,
<code>3</code> and <code>5</code> denote <em> functions</em> which are
defined for all argument stacks.  They yield as values other stacks
which are like the argument stacks except that a new <em> number</em>,
2, 3 and 5 has been pushed on top.

</p><p>

The symbol <code>+</code> does <em> not</em> denote a <em>
binary</em> function of two numbers, but like all Joy functions it
takes one argument only.  That argument has to be a stack whose top
two elements are numbers.  The value returned is another stack which
has the top two numbers replaced by their sum.  It follows that the
above equation does <em> not</em> express the identity of numbers
but the identity of <em> functions</em>.

</p><p>

The associativity of composition has as a consequence about
<em>currying</em>: that there is no difference between standard and
curried operators.  Consider the example

</p><pre>        (2  3)  +   ==   2  (3  +)
</pre>

On the left the <code>+</code> takes two parameters supplied by
<code>(2 3)</code>.  On the right <code>+</code> is given one
parameter, <code>3</code>.  The resulting function <code>(3 +)</code>
expects one parameter to which it will add <code>3</code>.  Because of
associativity the two sides are identical and hence no parentheses are
required.

<p>

Let <code>P</code> be a program which pushes <tt>m</tt> values onto the
stack.  Let <code>Q</code> be a program which expects <tt>n</tt> values on
the stack, <tt>m</tt> &lt;= <tt>n</tt>.  Now consider their concatenation <code>P
Q</code>.  Of the <tt>n</tt> expected by <code>Q</code>, <tt>n</tt> will be supplied
by <code>P</code>.  So the program <code>P Q</code> only expects <tt>n -
m</tt> values on the stack.

</p><hr/>
+++HERE+++ assoc and curry
<hr/>

<p>

In the development of mathematics an explicit notation for the number
<code>0</code> has been a rather recent innovation.  The symbol
enables one to say more than just that <code>0</code> is a unit
element for addition.  Similarly, in the algebra of functions an
explicit symbol for the identity function makes it possible to state
many laws.  This is particularly true for the functions in Joy.  The
following are some examples:

</p><p>

In arithmetic <code>0</code> and <code>1</code> are unit elements for
addition and multiplication, so adding <code>0</code> or multiplying
by <code>1</code> have no effect.  For lists the empty list is a unit
element, so concatenation on the left or the right has no effect.
Similarly in logic, falsity and truth are unit elements for
disjunction and conjunction, so disjoining with falsity and conjoining
with truth make no difference.  Also in logic, disjunction and
conjunction are idempotent, so disjoining or conjoining with a
<kbd>dup</kbd>licate yields the original.  For any stack it holds that
<kbd>swap</kbd>ping the top two elements twice has no net effect, and
that duplicating the top element and then <kbd>pop</kbd>ping off the
duplicate has no net effect.

</p><p>

There are many more laws: double negation has no net effect, reversing
a sequence twice just leaves the original, and taking the successor
and the predeccessor of a number - in either order - produces no net
effect.

In the <em>algebra of Joy</em> these are expressed by the following:

</p><pre>        0  +   ==   id                  1  *   ==   id
        []  concat   ==   id            []  swap  concat   ==   id
        false  or   ==   id             true  and   ==   id
        dup  and   ==   id              dup  or   ==   id
        swap  swap   ==   id            dup  pop   ==   id
        not  not   ==   id              reverse  reverse   ==   id
        succ  pred   ==   id            pred  succ   ==   id
</pre>

Note that no variables were needed to express these laws.
<p>

The identity function is a left and right unit element with respect to
function composition.  It is appropriate to remark here that there is
also a <em>left zero element</em> and there is a <em>right zero
element</em>.  Two such elements <code>l</code> and <code>r</code>
satisfy the following for all programs <code>P</code>:

</p><pre>        l  P   ==   l                   P  r   ==   r
</pre>

Since function composition is not commutative, the two zero elements
are not identical.  In Joy the left zero <code>l</code> is the
<kbd>abort</kbd> operator, it ignores any program following it.  The
right zero <code>r</code> is the <kbd>clearstack</kbd> operator, it
empties the stack and hence ignores any calculations that might have
been done before.  The two operators have some theoretical interest,
and they are occasionally useful.



Any program enclosed in square brackets is called a <em>quoted
program</em> or <em>quotation</em>.  The length or <code>size</code>
of the quotation <code>[5]</code> is <code>1</code>, and the size of
the quotation <code>[2 3 +]</code> is <code>3</code>.  However, as
noted earlier, the two programs inside the brackets denote the same
function.  What this shows is that we cannot substitute their
quotations for each other:

<pre>        [5]  size   =/=   [2 3 +]  size
</pre>

What forbids the substitution is the quotation - by the square
brackets.  So quotations produce opaque contexts, quotation is an
intensional constructor.

<p>

However, there are contexts where substitution is permissable across
quotations.  These are contexts where the content of the quote is not
treated as a passive datum but as an active program.  In Joy such
treatment is due to <em>combinator</em>s which in effect dequote one
or more of their parameters.

</p><p>

The <kbd>i</kbd> combinator expects a quoted program on top of the
stack.  It pops that program and executes it.  So, if the quoted
program <code>[P]</code> has just been pushed onto the stack, then the
<code>i</code> combinator will execute <code>P</code>:

</p><pre>        [P]  i   ==   P
</pre>

For example, each of the following four programs compute the same
function - the one which takes any stack as argument and returns as
value another stack which is like the argument stack but has the
number <code>5</code> pushed on top.

<pre>         2  3  +                         5
        [2  3  +] i                     [5] i
</pre>

If the program <code>P</code> computes the identity function, then the
effect of applying the <code>i</code> combinator is that of the
identity function:

<pre>        [id]  i   ==   id               []  i   ==   id
</pre>
Another law is this:
<pre>        i  ==  []  cons  i  i
</pre>
<p>

Two programs <code>P</code> and <code>Q</code> may look very different
- for example, they may differ in their sizes.  But it could be that
the compute the same function.  In that case the dequotations of their
quotations also compute the same function:

</p><p>
Hence
</p><pre>        IF       P       ==    Q
        THEN    [P]  i   ==   [Q]  i
</pre>

Suppose now that a quoted program, <code>[P]</code>, is on top of the
stack.  It could then be executed with the <code>i</code> combinator.
But it could also be manipulated as a passive data structure first.
For example, one could push the quotation <code>[i]</code> and then
use the <kbd>cons</kbd> operator to insert <code>[P]</code> into
<code>[i]</code> to give <code>[[P] i]</code>.  What happens if this
is executed by the <code>i</code> combinator?  The internal
<code>[P]</code> quote is pushed, and then the internal <code>i</code>
combinator is executed.  So the net effect is that of executing
<code>P</code>.

<p>
Hence
</p><pre>        [i]  cons  i   ==   i
</pre>

Note that it has been possible to state this law without reference to
the quoted program <code>[P]</code>.  But it may help to spell out a
consequence:

<pre>        [P]  [i]  cons  i   ==   [[P] i]  i   ==   [P]  i   ==   P
</pre>
<p>

The <code>i</code> combinator is only one of many.  Another is the
<kbd>b</kbd> combinator which expects two quoted programs on top of
the stack.  It pops them both and then executes the program that was
second on the stack and continues by executing the program that was on
top of the stack.  So, in the special case where two programs
<code>[P]</code> and <code>[Q]</code> have just been pushed onto the
stack, the <code>b</code> combinator will execute them in the order in
which they have been pushed:

</p><pre>        [P]  [Q]  b   ==   P  Q
</pre>

It follows that the <code>b</code> combinator actually dequotes both
of its parameters, and hence either or both can be replaced by an
equivalent program:

<pre>        IF       P1  ==  P2     AND    Q1  ==  Q2
        THEN    [P1]  [Q1]  b   ==   [P2]  [Q2]  b
</pre>

If both programs compute the identity function, then the effect of the
<code>b</code> combinator is the identity function.  If either of the
two programs computes the identity function, then the effect is the
same as that of executing the other, which is the same as applying the
<code>i</code> combinator to the other:

<pre>        []  []  b   ==   id
        []  b   ==   i
        []  swap  b   ==   i
</pre>

The second equation could be reversed, and this shows that the
<code>i</code> combinator could be <em> defined</em> in terms of the
<code>b</code> combinator.

<p>

Quotations are sequences, and sequences can be concatenated.  In Joy
strings, lists and, more generally, quotations can be concatenated
with the <kbd>concat</kbd> operator.  If <code>[P]</code> and
<code>[Q]</code> have just been pushed, then they can be concatenated
to become <code>[P Q]</code>.  The resultant concatenation can be
executed by the <code>i</code> combinator.  The net effect is that of
executing the two programs, and that is also achieved by applying the
<code>b</code> combinator:

</p><pre>        [P]  [Q]  concat  i   ==   P  Q   ==   [P]  [Q]  b
</pre>

But the two quoted programs do not have to be pushed immediately
before the concatenation or the application of the <code>b</code>
combinator.  Instead they could have been constructed from smaller
parts or extracted from some larger quotation.  Hence the more general
law:

<pre>        concat  i   ==   b
</pre>

The equation could be reversed, hence the <code>b</code> combinator
could be <em> defined</em> in terms of the <code>i</code>
combinator.  The <em> names</em> <code>i</code> and <code>b</code>
of the two combinators have been chosen because of their similarity to
the <em>I combinator</em> and <em>B combinator</em> in <em>combinatory
logic</em>.  The standard text is <a href="https://hypercubed.github.io/joy/html/refs.html#%7BCurry58%7D">{Curry58}</a>, but good expositions are
to be found in many other books, for example <a href="https://hypercubed.github.io/joy/html/refs.html#%7BBurge75%7D">{Burge75}</a>.



The two previous combinators require one or two quoted programs as
parameters, but the parameters merely have to be in an agreed place,
they do not need to be on a stack.  There are several combinators
which only make sense if the data are located on a stack.

<p>

Sometimes it is necessary to manipulate the stack not at the top but
just below the top.  That is what the <kbd>dip</kbd> combinator is
for.  It is behaves like the <code>i</code> combinator by executing
one quotation on top of the stack, except that it leaves the item just
below the quotation unchanged.  In detail, it expects a program
<code>[P]</code> and below that another item <code>X</code>.  It pops
both, saves <code>X</code>, executes <code>P</code> and then restores
<code>X</code>.

</p><p>
For example, in the following the saved and restored item is <code>4</code>:

</p><pre>        2  3  4  [+]  dip  ==   5  4
</pre>

If a program computes the identity function, then the effect of
applying the <code>dip</code> combinator is to compute the identity
function:

<pre>        [id]  dip   ==   id             []  dip   ==   id
</pre>

Suppose a program <code>[P]</code> is on top of the stack, and it is
first duplicated and then the copy executed with <code>dip</code> just
below the original <code>[P]</code>.  Now the original has been
restored, but suppose it is now popped explicitly.  The net effect was
the same as executing just the original <code>[P]</code> with the
<code>i</code> combinator:

<pre>        i   ==   dup  dip  pop
</pre>

Suppose that there are two programs <code>[P]</code> and
<code>[Q]</code> on top of the stack, with <code>[Q]</code> on top.
It is required to execute <code>[P]</code> while saving
<code>[Q]</code> above.  One way to do that is this: First push
<code>[i]</code>.  Now <code>[Q]</code> is the second element.
Executing <code>dip</code> will save <code>[Q]</code> and execute
<code>[i]</code> on the stack which now has <code>[P]</code> on the
top.  That amounts to executing <code>[P]</code>, and after that
<code>[Q]</code> is restored.

<p>

Suppose further that it is now required to execute <code>[Q]</code>,
and that is easily done with the <code>i</code> combinator.  The net
effect of all this is the same as executing first <code>[P]</code> and
then <code>[Q]</code>, which could have been done with the
<code>b</code> combinator.  Hence

</p><pre>        b   ==   [i]  dip  i
</pre>

The last two equations show that the <code>dip</code> combinator could
be used to <em> define</em> both the <code>i</code> combinator and
the <code>b</code> combinator.  The reverse is not possible.

<p>

The last two equations also serve to illustrate algebraic manipulation
of Joy programs.  In the last equation the <code>i</code> combinator
occurs twice, once quoted and once unquoted.  Both occurrences can be
replaced in accordance with the previous equation, and this yields

</p><pre>        b   ==   [dup dip pop]  dip  dup  dip  pop
</pre>

The substitution of the unquoted occurrence is unproblematic.  But the
other substitution requires comment.  Quoted occurrences can be
substituted only in a context of dequotation, and in this case such a
context is given by the <code>dip</code> combinator.

<p>

Again suppose that there are two quoted programs <code>[P]</code> and
<code>[Q]</code> on the stack.  If the <code>dip</code> combinator is
executed next, it will cause the topmost quotation <code>[Q]</code> to
be executed while saving and later restoring <code>[P]</code> below.
Suppose that the <code>i</code> combinator is executed next, this will
cause the restored <code>[P]</code> to be executed.  So the net effect
of the two combinators is to execute first <code>P</code> and then
<code>Q</code>.  That same effect could have been achieved by first
swapping <code>[P]</code> and <code>[Q]</code> around, so that
<code>[P]</code> is on top, and then executing the <code>b</code>
combinator.  This is expressed in the left law below.  The right law
says the same thing, and it shows another way in which the
<code>b</code> combinator could have been defined.

</p><pre>        dip  i   ==   swap  b           b   ==   swap  dip  i
                                        b   ==   swap  dip  dup  dip  pop
</pre>
<p>
Function composition is associative, and hence the following holds:
</p><pre>        [P]  [Q]  b  [R]  i   ==   [P]  i  [Q]  [R]  b
</pre>

To eliminate the three quotations from this equation observe that they
can be written on the left of both sides provided that the
<code>b</code> combinator and the <code>i</code> combinator are
applied appropriately.  For the left side this is easy:

<pre>        [P]  [Q]  b  [R]  i   ==   [P]  [Q]  [R]  [b] dip i
</pre>

For the right side it is a little harder since the <code>i</code>
combinator has to be applied to <code>[P]</code> which is obscured not
by one but two other quotations.  The <code>dip</code> combinator has
to be used on itself in this case, as follows:

<pre>        [P]  i  [Q]  [R]  b   ==   [P]  [Q]  [R]  [[i] dip]  dip  b
</pre>

Combining the two right hand sides and cancelling the common three
quotations we obtain the following to expressing the associativity of
function composition:

<pre>        [b]  dip  i   ==   [[i] dip]  dip  b
</pre>

In this law we can even replace the <code>i</code> combinator and the
<code>b</code> combinator in accordance with earlier definitions:

<pre>        [swap  dip  dup  dip  pop]  dip  dup  dip  pop
   ==   [[dup  dip  pop]  dip]  dip  swap  dip  dup  dip  pop
</pre>

It is possible to cancel the final <code>pop</code> on both sides, but
it is not possible to cancel the prefinal <code>dip</code> on both
sides.  This unlikely law also expresses the associativity of function
composition.  But the most elegant way of expressing the associativity
is by using a variant of the <code>dip</code> combinator, called
<kbd>dipd</kbd>, which might be defined by

<pre>        dipd   ==   [dip]  cons  dip
</pre>
Then the associativity can be expressed by
<pre>        [b]  dip  i   ==   [i]  dipd  b
</pre>

(<a href="https://hypercubed.github.io/joy/html/refs.html#%7BHenson87%7D">{Henson87}</a> criticises presentations of FP-systems, originally due to
<a href="https://hypercubed.github.io/joy/html/refs.html#%7BBackus78%7D">{Backus78}</a> in that they give no law to this effect although they use
it in proofs.)

<p>

The combination of the <code>dip</code> combinator immediately
followed by the <code>i</code> combinator is sometimes useful for
arranging the top few elements on the stack in a form that is suitable
for executing a quoted program <code>[P]</code> that is at the top of
the stack.

</p><p> 

This is how it is done: first another quoted program
<code>[Q]</code> is pushed, and executed using the <code>dip</code>
combinator.  This will save and restore the <code>[P]</code>, but
arrange the stack in accordance with <code>[Q]</code>.  Then the
restored <code>[P]</code> is executed by the <code>i</code>
combinator.  Depending on the <code>[Q]</code> that is chosen, the
three part combination of <code>[Q]</code>, the <code>dip</code>
combinator and the <code>i</code> combinator will prepare the stack
for the execution of <code>[P]</code>.

</p><p>

Since such a combination still requires the <code>[P]</code> on the
stack, any such combination has the effect of a combinator.  The
following illustrate some simple choices of <code>[Q]</code> that are
sometimes useful.  The names of these combinators have been chosen
because of their similarity to the <em>K combinator</em>, <em>W
combinator</em> and the <em>C combinator</em> in <em>combinatory
logic</em>.

</p><pre>        k   ==   [pop]  dip  i
        w   ==   [dup]  dip  i
        c   ==   [swap] dip  i
</pre>



Suppose that there is a quoted program <code>[P]</code> on top of the
stack.  This could now be executed by some combinator, say
<code>C</code>.  Alternatively, one could push the quotation
<code>[C]</code> and then use the <code>cons</code> operator to insert
the earlier <code>[P]</code> into the later quotation, and this
produces <code>[[P] C]</code>.  This of course may be executed by the
<code>i</code> combinator.  When that happens the inner
<code>[P]</code> is pushed, thus partly undoing the <code>cons</code>
operation.  But then <code>C</code> will be executed.  The net effect
is the same as the earlier alternative.  So we have: For all operators
or combinators <code>C</code>

<pre>        [C]  cons  i   ==   C
</pre>

It should be remarked that this theorem also holds for operators, say
<code>O</code>, instead of combinators <code>C</code>.

<p>

Again suppose that there is a quoted program <code>[P]</code> on top
of the stack.  It could be executed by some combinator <code>C</code>,
or one could do this: push the quotation <code>[i]</code>,
<code>cons</code> the earlier <code>[P]</code> into that and now
execute <code>C</code>.  The <code>cons</code> operation produced
<code>[[P] i]</code> and when this is executed by <code>C</code>, the
inner <code>[P]</code> is pushed partly undoing the <code>cons</code>.
Then the <code>i</code> combinator actually executes this.  The net
effect is that of just executing <code>C</code>.  Hence for all
combinators <code>C</code>

</p><pre>        [i]  cons  C   ==   C
</pre>
<p>

The two laws above may be combined: for all combinators C

</p><pre>        [i]  cons  C   ==   [C]  cons  i
</pre>
<p>

So far we have only encountered one combinator which takes two quoted
parameters - the <code>b</code> combinator.  But Joy has a large
number of combinators which take two, three or even four quoted
parameters.  The following concerns combinators which expect at least
two quoted programs as parameters.  For such combinators the first
three laws holds unchanged, but these variations also hold:

</p><pre>        [i]  cons  cons  C   ==   C
        [C]  cons  cons  i   ==   C
        [i]  cons  cons  C   ==   [C]  cons cons  i
</pre>

The principle generalises to combinators with at least three quoted
parameters, by allowing three <code>cons</code> operations to occur.

<p>

Finally, the second law generalises to all parameters of a combinator:
any one parameter <code>[P]</code> can be replaced by <code>[[P]
i]</code>.  The replacement can of course be constructed by
<code>cons</code>ing <code>[P]</code> into <code>[i]</code>.  That of
course may be done for all quotation parameters.  If there is just the
one parameter <code>[P]</code>, then <code>cons</code>ing it into
<code>[i]</code> to produce <code>[[P] i]</code> is easy enough, as in
the second law.

</p><p>

If there are two parameters <code>[P]</code> and <code>[Q]</code> it
already becomes tedious to change them to <code>[[P] i]</code> and
<code>[[Q] i]</code>.  If there are three or more quotation
parameters, then the program to produce the three changes could be
rather obscure.

</p><p>

Joy has a combinator which can use a function to <kbd>map</kbd> the
elements of a list to a list of the same length containing the results
of applying the function.  Several special forms take as a parameter
not an arbitrary list but a specified number of one, two, three and so
on elements from the stack.  These are the <kbd>app1</kbd> combinator,
the <kbd>app2</kbd> combinator, the <kbd>app3</kbd> combinator and so
on.  These are just the right combinators to produce the changes
required for the parameters of a combinator.  The following laws hold
for combinators <code>C1</code>, <code>C2</code> and <code>C3</code>
requiring one, two or three quotation parameters:

</p><pre>        [[i] cons]  app1  C1   ==   C1
        [[i] cons]  app2  C2   ==   C2
        [[i] cons]  app3  C3   ==   C3
</pre>
To illustrate for a combinator C3:
<pre>         [P]      [Q]      [R]    [[i] cons]  app3  C3
   ==   [[P] i]  [[Q] i]  [[R] i]                   C3
   ==    [P]      [Q]      [R]                      C3
</pre>

Computationally it is of course pointless to replace a quotation such
as <code>[P]</code> by <code>[[P] i]</code> if the quotations are
being used as parameters for a combinator.  But the replacements are
invaluable in a Joy interpreter written in Joy.  This interpreter is
essentially a complex combinator, appropriately called <kbd>joy</kbd>,
and it has to behave just like the <code>i</code> combinator.  In the
definition of the <code>joy</code> combinator, the implementation of
all combinators uses the above mapping combinators but with
<code>[[joy] cons]</code> instead of <code>[[i] cons]</code>.



One of the problems of large pieces of software concerns the
complexity of interdependent parts and the need to make interfaces
lean.  To some extent this is a matter of information hiding, and
programming languages achieve this in various ways.  Most have local
symbols such as formal parameters of functions and local program
variables of procedures.  Many have full block structure allowing
declarations of functions and procedures to be nested and hence
invisible from the outside.  Some have modules or other compilation
units which allow further information hiding in larger program
components.  Joy approaches the problem in a different way -- the
information that needs to be hidden is minimised in the first place.
Mostly the problem arises from declarations of named functions and
procedures and their named formal parameters.

<p>

There are several reasons why one might want to declare
a function, because
</p><ol>
<li> it requires recursion, or
</li><li> it is needed in several seemingly unrelated places in a program, or
</li><li> it makes the program clearer.
</li></ol>


<p>

The third reason is always valid.  In Joy the second reason is much
less compelling, and the first has almost no force at all.

</p><p>

Joy has a large number of combinators which permit computation of
anonymous functions which are normally defined recursively.  It also
has combinators that permit repeated calls of such functions in some
related patterns.  Joy programs which use suitable combinators to
allow the computation of anonymous functions with anonymous formal
parameters.

</p><p>

Consider the following recursive definition and use of the
<em>factorial</em> function in a (fantasy) functional language:

</p><pre>    LET  factorial(n)  =  if n = 0 then 1 else n * factorial(n - 1)
     IN  factorial(5)
</pre>

The call in the second line should return <code>120</code>.  Joy has a
number of ways of doing essentially the same computation without
introducing the <em> name</em> <code>factorial</code> and without
introducing the <em> name</em> of the formal parameter <code>n</code>.
Several of these ways are still modelled on the recursive definition
and have approximately the same length.  Two of them are based on the
fact that the definition has the pattern of <em>linear recursion</em>,
indeed <em>primitive recursion</em>.  As in all languages the use of
<em>accumulating parameter</em>s can avoid the recursion altogether,
but that is not the point here.

<p>

The humble <code>i</code> and <code>dip</code> combinators were
certainly not designed for recursion, so it will come as a surprise
that they can be used to emulate recursion without naming the function
or its formal parameter.  To make the recursion possible, every call
of the anonymous function must be able to access itself again, and
this is done by giving it its own body as a quoted parameter on the
top of the stack.  This is achieved by always duplicating the quoted
body first and then using the <code>i</code> combinator to execute the
duplicate.  The <code>dip</code> combinator can be used to access the
stack below the quoted body.  The only other combinator needed is the
<code>ifte</code> combinator which achieves the same kind of two-way
branching as the <code>if-then-else</code> in the conventional
definition above.

</p><p>
This is the program:
</p><pre>1           5
2           [  [pop  0  =]
3              [pop  pop  1]
4              [  [dup  1  -]  dip
5                 dip  i
6                 *  ]
7              ifte  ]
8           dup  i
</pre>
<p>

The line numbers are only included for reference.  Execution begins in
line 1 by pushing the actual parameter <code>5</code> onto the stack.
Then the long quotation extending from line 2 to line 7 is pushed onto
the stack.  This quotation is the body of the function, it corresponds
to the right hand side of the conventional definition.  Execution
continues in line 8 where the long quotation is duplicated and the top
copy is executed by the <code>i</code> combinator.  This execution has
the effect of pushing the two short quotations in lines 2 and 3 and
also the longer quotation in lines 4 to 6.  So at this point the stack
contains the parameter <code>5</code> and above that four quotations.

</p><p>

But now the <code>ifte</code> combinator in line 7 executes.  It pops
the last three quotations and saves them elsewhere.  Then it executes
the if-part, the saved quotation from line 2.  That will pop what is
now the top of the stack, the body of the function from lines 2 to 7.
This exposes the number which is the parameter, and it is compared
with <code>0</code>.

</p><p>

The comparison will yield a truth value which the <code>ifte</code>
combinator will use to determine whether to execute the saved
then-part from line 3 or the saved else-part from lines 4 to 6.  In
either case the stack is first restored to what it was before the
if-part was executed: the quoted body of the function is again on top
of the stack and below it is the actual parameter for this particular
call.  If the most recent comparison by the if-part was true, then the
saved then-part from line 3 is executed.

</p><p>

This results in the body and the actual parameter being popped off the
stack and replaced by <code>1</code>, the factorial of <code>0</code>.
On the other hand, if the most recent comparison was false, then the
saved else-part from lines 4 to 6 is executed.  For the later
multiplication the parameter has to be duplicated and the top
duplicate has to be decremented.  Since the body of the function is in
the way, the duplicating and decrementing is done via the
<code>dip</code> combinator in line 4.

</p><p>

At this point the top three elements on the stack are the original
parameter for this call, then the decremented duplicate, and right on
top of that the quoted body of the function.  It is now necessary to
compute the factorial of the decremented duplicate, and this call may
need access to the body again.  So the body cannot be simply executed
by the <code>i</code> combinator, but first the body is duplicated in
line 5 and then the duplicate is executed by the <code>i</code>
combinator.  Execution of that duplicate body will eventually
terminate, and then the top two elements will be the original
parameter and the factorial of what was its decremented duplicate.
The two numbers are now multiplied in line 6, yielding the required
factorial of the parameter for this call.  This completes the
execution of the else-part from lines 4 to 6.  Irrespective of whether
the then-part or the else-part was executed, the execution of the
<code>ifte</code> combinator is now complete.

</p><p>

This completes the execution of the body of the function in lines 2 to
7.  It also completes the execution of whichever occurrence of the
<code>i</code> combinator in lines 5 or 8 triggered this execution of
the body.  Ultimately the execution of the <code>i</code> combinator
in line 8 will have completed, and at this point the parameter
<code>5</code> from line 1 will have been replaced by its factorial
<code>120</code> as required.

</p><p>

Two short comments are in order: Firstly, the <em> description</em> of
the program was given in an imperative or procedural mode which is
psychologically helpful.  But this does not change the fact that all
Joy programs and all their parts denote functions.  Secondly, the
program can be written using only the <code>dip</code> combinator and
the <code>ifte</code> combinator by substituting <code>dup dip
pop</code> for the two calls of the <code>i</code> combinator in lines
5 and 8.

</p><p>

Of course this program is a <em> tour de force</em>, it is ugly and
inefficient.  With more suitable combinators much crisper and more
efficient programs can be written.  In particular, the repeated
pushing and saving of the quoted if-part, then-part and else-part is
not necessary.  Also, the repeated duplication of the quoted body is
not necessary, and consequently the three parts do not have to work
around the quoted body when it is in the way on the top.  In fact, the
essence of the if-part and most of the else-part are built into the
<kbd>primrec</kbd> combinator for primitive recursion.  The entire
program then is

</p><pre>        5  [1]  [*]  primrec
</pre>

As mentioned before, even the use of recursion can be eliminated in
favour of a more efficient loop combinator which uses an accumulating
parameter.



This paper has attempted to explain the theoretical foundations of the
language Joy.  Much of the semantics is summarised by observing that
the following are true:

<pre>        2  3  +   ==   7  2 -
        dup  +   ==   2  *
        dip  i   ==   swap  b
</pre>

The first <em> seems</em> to express the identity of numbers.  The
second <em> seems</em> to express the identity of functions which both
double a given number which they expect on the stack.  The third <em>
seems</em> to express the identity of functionals, or second order
functions which take two first order functions as parameter and
compose them.

<p>

While these readings are sometimes helpful, the unity of Joy semantics
really forces a different interpretation.  All three equations express
identity of Joy functions which take one argument stack and yield one
value stack.

</p><p> 

The mathematical discipline of <em>category theory</em> deals with
functions of one arguments.  All Joy functions are of that kind, too.
In fact all monoids are special cases of categories, so Joy&#39;s
syntactic monoid of concatenation and Joy&#39;s semantic monoid of
function composition are categories.  So some fundamental connections
should be expected.  In particular, Joy is related to Cartesian closed
categories, and to the &#34;Combinatory Abstract Machine&#34; <em>CAM</em>,
see for example <a href="https://hypercubed.github.io/joy/html/refs.html#%7BPoigne92%7D">{Poigne92}</a>.

</p><p>

The paper 
<a href="https://hypercubed.github.io/joy/html/J00OVR.HTML">
j00ovr </a>
contains an overview of Joy and references to other
papers dealing with specific aspects of Joy.

</p><hr/>
</div>
  </body>
</html>
