<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/postgres-wasm">Original</a>
    <h1>Show HN: Postgres WASM</h1>
    
    <div id="readability-page-1" class="page"><article><div><p>Today we&#39;re open sourcing <a href="https://github.com/snaplet/postgres-wasm"><code>postgres-wasm</code></a> with our friends at <a href="https://www.snaplet.dev/">Snaplet</a>.</p><p>postgres-wasm is a PostgresQL server that runs inside a browser. It provides a full suite of features, including persisting state to browser,
restoring from pg_dump, and logical replication from a remote database.</p><p>We&#39;re not the first to run Postgres in the browser - that title belongs to the team at <a href="https://www.crunchydata.com/">Crunchy Data</a> who shared their
version of this <a href="https://news.ycombinator.com/item?id=32498435">on HN</a> a month ago. It&#39;s awesome, and we wanted
an <a href="https://staltz.com/time-till-open-source-alternative.html">open source version</a>, so we teamed up with Snaplet build it.
Let&#39;s explore how it&#39;s built, and some extra features we&#39;ve added.</p><h2 id="demo">Demo</h2><p>Before we get into the technical details, try it out yourself (warning: it will download ~30MB):</p><p><a href="https://wasm.supabase.com">wasm.supabase.com</a></p><p><span><img alt="Postgres inside a browser" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>To run it locally:</p><pre></pre><p>And open a browser at <a href="http://localhost:3000">localhost:3000</a>.</p><h2 id="features">Features</h2><p>Our demo version has a few neat features!</p><ul><li>Postgres 14.5, psql, pg_dump, etc.</li><li>Save &amp; restore state to/from a file.</li><li>Save &amp; restore Postgres state to/from the browser storage (IndexedDB).</li><li>Quick start from a state file or fully reboot the emulator.</li><li>Memory configuration options from 128MB to 1024MB.</li><li>Adjust the font size for the terminal.</li><li>Upload files to the emulator (including database dumps and CSVs).</li><li>Download files from the emulator.</li><li>Outgoing network connectivity from the emulator to the internet.</li><li>Incoming network tunnel to postgres port 5432 inside the emulator.</li></ul><h2 id="why">Why?</h2><p>That&#39;s a good question. <code>postgres-wasm</code> is currently about 30mb. So at this stage, running Postgres in the browser isn&#39;t great for general use-cases.
It has a lot of potential though. Some ideas we&#39;ll be playing with over the next few months:</p><ul><li><strong>Documentation:</strong> for tutorials and demos.</li><li><strong>Offline data:</strong> running it in the browser for an offline cache, similar to <a href="https://sql.js.org/#/">sql.js</a> or <a href="https://github.com/jlongster/absurd-sql">absurd-sql</a>.</li><li><strong>Offline data analysis:</strong> using it in a dashboard for offline data analysis and charts.</li><li><strong>Testing:</strong> testing PostgresSQL functions, triggers, data modeling, logical replication, etc.</li><li><strong>Dev environments:</strong> use it as a development environment — pull data from production or push new data, functions, triggers, views up to production.</li><li><strong>Snapshots:</strong> create a test version of your database with sample data, then take a snapshot to send to other developers.</li><li><strong>Support:</strong> send snapshots of your database to support personnel to demonstrate an issue you&#39;re having.</li></ul><h2 id="repository-overview">Repository Overview</h2><p>We&#39;ve divided in our repository into three folders: a virtual machine, a web application, and a network proxy.</p><h3 id="virtual-machine-vm">Virtual Machine (VM)</h3><p>We create an embeddable Virtual Machine (VM) using <a href="https://en.wikipedia.org/wiki/Buildroot">Buildroot</a>.
Our VM is a stripped-down Linux build with Postgres installed.</p><p>See <a href="https://github.com/snaplet/postgres-browser/tree/main/packages/buildroot">source code</a>.</p><h3 id="web-application">Web application</h3><p>Next, we need to run the the VM inside our browser. How? <a href="https://en.wikipedia.org/wiki/WebAssembly">WASM</a>.
We use <a href="https://github.com/copy/v86">v86</a> to run our VM inside the browser. Our demo application is very simple - plain HTML and some basic styling.</p><p>See <a href="https://github.com/snaplet/postgres-browser/tree/main/packages/pg-browser">source code</a>.</p><h3 id="network-proxy">Network proxy</h3><p>Running Postgres in a browser is great, but connecting to it with PgAdmin is even better. Unfortunately browsers block TCP network access to the VM.
To circumvent this, we proxy the traffic through websockets. We run a fork of <a href="https://github.com/benjamincburns/websockproxy">Websockproxy</a>
which allows the emulator to talk to the internet by converting data sent over a websocket port into TCP packets.
Our fork of Websockproxy adds the ability to tunnel into the Postgres server.</p><p>See <a href="https://github.com/snaplet/postgres-browser/tree/main/packages/websockproxy">source code</a>.</p><h2 id="technical-deep-dive">Technical deep-dive</h2><p>There were a lot of hurdles that we discovered throughout the development of postgres-wasm.</p><h3 id="wasm">WASM</h3><p>The first thing to point out is that our implementation isn&#39;t <em>pure</em> WASM. We attempted to compile Postgres for WASM directly from source,
but it was more complicated that we anticipated.</p><p>Crunchy&#39;s HN post provided some hints about the approach they took, which was to virtualize a machine in the browser. We pursued this strategy too, settling on v86
which emulates an x86-compatible CPU and hardware in the browser.</p><h3 id="postgresql-14-segfault-errors">PostgreSQL 14 segfault errors</h3><p>We quickly had PostgreSQL 13.3 running using an outdated version of Buildroot. But version PG14+ wouldn&#39;t start, giving a segfault during initialization. We tried:</p><ul><li>manually copying build files for PG14 into the older version(s) of Buildroot</li><li>building with (many) newer copies of Buildroot</li><li>adjusting kernel parameters and environment settings such as the amount of memory allocated to the emulator, etc.</li></ul><p>Eventually, Fabian, the creator of v86 suggested we turn off JIT compilation for v86 and that solved the issue.
He narrowed it down to a bug in v86 and is pushing an update that will fix it.
Switching Postgres from sysv to posix memory management also solved the issue for the current release of V86.</p><h3 id="optimizing-startup-time-and-image-size">Optimizing startup time and image size</h3><p>With PG14 running in the emulator, we shifted our focus to performance. The image size for the emulator was too big for a browser-based tool.
Even with our best efforts, a compressed snapshot was over 30mb - a fairly large payload to download before you can see any interaction.</p><p>We solved this by booting only a minimal Linux image and then dynamically loading the rest of the VM over HTTPS after initialization.</p><p>We achieve this by mounting a compressed <a href="https://en.wikipedia.org/wiki/9P_(protocol)">9P filesystem</a> in the VM.
9P provides a <a href="https://github.com/supabase-community/postgres-wasm/tree/main/packages/buildroot/tools">Python script</a> which takes a filesystem folder,
renames every file an 8-character name and produces a <code>filesystem.json</code> file representing a nested structure with files, original file names, sizes, etc.
We then <a href="https://github.com/supabase-community/postgres-wasm/blob/main/packages/buildroot/config/board/pg-browser/post-image.sh">copy this compressed output</a> to the VM.
We modified the kernel command line and v86 boot parameters to boot directly from the 9P filesystem, and even put our kernel file into the p9 filesystem.
All non-essential files are loaded asyncrhonously over HTTPS in the browser as needed.</p><p>The initial state was smaller, but still 15-20mb in size. We discussed this with Fabian who pointed us towards the <code>page_poison=on</code> kernel parameter.
This parameter allowed us to clear caches before creating the snapshots, by forcing Linux to write arbitrary bytes on freed memory instead of random bytes,
so unused memory is compressed much more efficiently.</p><p>The end result of all these changes? The compressed initial state file is about 12mb - including a <em>running network state and Postgres 14.4 running with psql loaded.</em></p><p>We experimented without Postgres started too - this produced an even smaller initial state but the time to initialize
Postgres was usually longer than the time to download a few extra megabytes. We opted for a faster startup time.</p><p>Additionally, without a running state you&#39;d hit a performance penalty every time you refreshed the page,
since Postgres would need to be initialized each time. In our current version, after the initial state is
downloaded and cached by the browser the VM feels almost instant on refresh.</p><h3 id="networking">Networking</h3><p>Networking was particularly difficult to solve. For security reasons, browsers only support access to a nominal set of ports.
In short, browsers speak “80/443” and Postgres speaks “5432” so there was no way for our Postgres to communicate with the outside world.</p><p>WASM isn&#39;t much help here - a WebAssembly module running in the browser is generally not able to do anything outside itself,
except for calling functions exposed from JavaScript.</p><p>Browsers provide another connection option for us however: Websockets. The nice thing about websocket connections is that they are <em>persistent</em>,
so all we needed was to figure out how to proxy the virtual machine traffic through a websocket connection.</p><p>The VM includes an emulated network card (<code>ne2k-pci</code>) and a <code>proxy_url</code> startup parameter which points to an external server
running a websocket proxy (i.e. on the internet). The websocket proxy establishes connections via a websocket port, then accepts raw ethernet packets.
It turns those raw packets into TCP/IP packets and routes them between the Internet and the VM.</p><p><span><img alt="Postgres WASM to the proxy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>With our tunnel established, we could now send network traffic to the outside world. For example, try “starting” the network on the VM,
&#34;exiting&#34; out of psql (<code>cmd</code>+<code>D</code>), and then run <code>ping 1.1.1.1</code>.</p><p><span><img alt="Postgres WASM to the internet" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>Most v86 VM&#39;s use an open proxy at <code>wss://relay.widgetry.org/</code> based on <a href="https://github.com/benjamincburns/websockproxy">websockproxy</a>.
This proxy allows the VM to communicate with the outside world. It can handle all the basic use-cases like loading
data from other PostgreSQL databases using <code>pg_dump</code> and <code>psql</code>, or operating as read-only replica of another database.</p><p>However, this proxy doesn&#39;t allow incoming traffic to be routed into a VM running locally on a laptop.
For instance, you can&#39;t connect a local <code>PgAdmin4</code> to the PostgreSQL instance running inside your browser.
So we <a href="https://github.com/snaplet/postgres-wasm/tree/main/packages/websockproxy">forked</a> the <a href="https://github.com/benjamincburns/websockproxy">proxy</a> and
added nginx to provide a reverse proxy.</p><p><span><img alt="Postgres WASM with psql" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>The reverse proxy listens on a range of ports, mapping each port to the VM at a specific private address you want to reach.
The simple solution was to take the last 2 segments of the private IP and map it to a port number. So if your private IP is 10.5.6.123,
you connect to the proxy on port 6123 and that points you to PostgreSQL (running on port 5432) on private IP 10.5.6.123. Shortened addresses are padded,
so 10.5.6.2 maps to port 6002 and 10.5.6.44 to port 6044.</p><p><span><img alt="Postgres WASM with remote logins" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><h3 id="sending-commands-to-the-emulator-from-the-browser-ui">Sending commands to the emulator from the browser UI</h3><p>Once the emulator is running, in the words of Fabian, “it runs as a black box process”, and the only way to communicate between the
UI and the operating system running in the emulator is through <code>serial0_send</code> to send keystrokes over the emulated serial port,
or through the <code>create_file</code> function which uploads a file to the running emulator.</p><p>To restart the network after restoring a state file, we need to run a short script to unbind and re-bind the emulated network card
(so it gets a new mac address and thus a unique private IP address at the proxy), and then a standard network restart command.
We could run this script by sending keystrokes to the emulator, but that&#39;s clumsy. What if the user is at a <code>psql</code> prompt? Then we&#39;d send <code>\! script_command</code>.
But if they&#39;re at an OS prompt, that won&#39;t work.</p><p>We solved the issue by creating a folder called <code>\inbox</code> and added a listener to the folder. When files arrive there, if the file ends in <code>.sh</code> (a shell script),
we <code>chmod +x</code> that file, execute it, then delete it. That allows us to run commands “in the background” without upsetting the UI.</p><h2 id="just-for-fun">Just for fun</h2><p>If you want to do something very cool, you can connect to another user&#39;s Postgres instance that they are running in their browser.
Here are the steps:</p><ol><li>Find a friend (sometimes the first step is the hardest)</li><li>Tell them to go to <a href="https://wasm.supabase.com/">wasm.supabase.com</a></li><li>Tell them to “Start Network” and get their Network URL</li><li>On your own machine, open a terminal and run
<code>psql postgres://postgres:woohoo@wasm.supabase.com:&lt;PORT&gt;</code></li><li>And you&#39;re in! You&#39;re now connecting to a remote Postgres instance, inside a VM, inside a browser, from a terminal on your own computer.</li></ol><p><strong>Database Replication</strong></p><p>Even more mind-blowing - it&#39;s possible to replicate data from an online PostgreSQL database (for example, a Supabase project) to PostgreSQL running inside your browser,
and vice-versa using Postgres&#39;s logical replication. The steps are no different than any other Postgres database - just use the proxy URL as the target.</p><h2 id="whats-next">What&#39;s next?</h2><p>For now, this is very experimental - but it has a lot of potential. If you want to get involved, please reach out to us or
the team at <a href="https://www.snaplet.dev/">Snaplet</a>. The work they&#39;re doing over at Snaplet is incredible, and we&#39;ve had a blast collaborating with them.</p><ul><li>Snaplet repo: <a href="https://github.com/snaplet/postgres-wasm">https://github.com/snaplet/postgres-wasm</a></li><li>Supabase fork: <a href="https://github.com/supabase-community/postgres-wasm">https://github.com/supabase-community/postgres-wasm</a></li></ul></div></article></div>
  </body>
</html>
