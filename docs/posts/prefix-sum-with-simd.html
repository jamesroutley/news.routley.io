<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.algorithmica.org/hpc/algorithms/prefix/">Original</a>
    <h1>Prefix Sum with SIMD</h1>
    
    <div id="readability-page-1" class="page"><article>
The <em>prefix sum</em>, also known as <em>cumulative sum</em>, <em>inclusive scan</em>, or simply <em>scan</em>, is a sequence of numbers $b_i$ generated from another sequence $a_i$ using the following rule:
$$
\begin{aligned}
b_0 &amp;= a_0
\\ b_1 &amp;= a_0 + a_1
\\ b_2 &amp;= a_0 + a_1 + a_2
\\ &amp;\ldots
\end{aligned}
$$
<p>In other words, the $k$-th element of the output sequence is the sum of the first $k$ elements of the input sequence.</p>
<p>Prefix sum is a very important primitive in many algorithms, especially in the context of parallel algorithms, where its computation scales almost perfectly with the number of processors. Unfortunately, it is much harder to speed up with SIMD parallelism on a single CPU core, but we will try it nonetheless — and derive an algorithm that is ~2.5x faster than the baseline scalar implementation.</p>
<span id="baseline"></span>
<h3><a href="https://en.algorithmica.org/hpc/algorithms/prefix/#baseline">#</a>Baseline</h3><p>For our baseline, we could just invoke <code>std::partial_sum</code> from the STL, but for clarity, we will implement it manually. We create an array of integers and then sequentially add the previous element to the current one:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>void</span> <span>prefix</span><span>(</span><span>int</span> <span>*</span><span>a</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span>
        <span>a</span><span>[</span><span>i</span><span>]</span> <span>+=</span> <span>a</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>
<span>}</span>
</code></pre></div><p>It seems like we need two reads, an add, and a write per each iteration, but of course, the compiler optimizes the extra read away and uses a register as the accumulator:</p>
<div><pre tabindex="0"><code data-lang="nasm"><span>loop:</span>
    <span>add</span>     <span>edx</span><span>,</span> <span>DWORD</span> <span>PTR</span> <span>[</span><span>rax</span><span>]</span>
    <span>mov</span>     <span>DWORD</span> <span>PTR</span> <span>[</span><span>rax</span><span>-</span><span>4</span><span>],</span> <span>edx</span>
    <span>add</span>     <span>rax</span><span>,</span> <span>4</span>
    <span>cmp</span>     <span>rax</span><span>,</span> <span>rcx</span>
    <span>jne</span>     <span>loop</span>
</code></pre></div><p>After <a href="https://en.algorithmica.org/hpc/architecture/loops">unrolling</a> the loop, just two instructions effectively remain: the fused read-add and the write-back of the result. Theoretically, these should work at 2 GFLOPS (1 element per CPU cycle), but because the memory system has to constantly <a href="https://en.algorithmica.org/hpc/cpu-cache/bandwidth#directional-access">switch</a> between reading and writing, the actual performance is between 1.2 and 1.6 GFLOPS, depending on the array size.</p>
<span id="vectorization"></span>
<h3><a href="https://en.algorithmica.org/hpc/algorithms/prefix/#vectorization">#</a>Vectorization</h3><p>One way to implement a parallel prefix sum algorithm is to split the array into small blocks, independently calculate <em>local</em> prefix sums on them, and then do a second pass where we adjust the computed values in each block by adding the sum of all previous elements to them.</p>
<figure>
<img src="https://en.algorithmica.org/hpc/algorithms/img/prefix-outline.png"/>
<figcaption></figcaption>
</figure>

<p>This allows processing each block in parallel — both during the computation of the local prefix sums and the accumulation phase — so you usually split the array into as many blocks as you have processors. But since we are only allowed to use one CPU core, and <a href="https://en.algorithmica.org/hpc/simd/moving#non-contiguous-load">non-sequential memory access</a> in SIMD doesn’t work well, we are not going to do that. Instead, we will use a fixed block size equal to the size of a SIMD lane and calculate prefix sums within a register.</p>
<p>Now, to compute these prefix sums locally, we are going to use another parallel prefix sum method that is generally inefficient (the total work is $O(n \log n)$ instead of linear) but is good enough for the case when the data is already in a SIMD register. The idea is to perform $\log n$ iterations where on $k$-th iteration, we add $a_{i - 2^k}$ to $a_i$ for all applicable $i$:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>for</span> <span>(</span><span>int</span> <span>l</span> <span>=</span> <span>0</span><span>;</span> <span>l</span> <span>&lt;</span> <span>logn</span><span>;</span> <span>l</span><span>++</span><span>)</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>l</span><span>);</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span>
        <span>a</span><span>[</span><span>i</span><span>]</span> <span>+=</span> <span>a</span><span>[</span><span>i</span> <span>-</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>l</span><span>)];</span>
</code></pre></div><p>We can prove that this algorithm works by induction: if on $k$-th iteration every element $a_i$ is equal to the sum of the $(i - 2^k, i]$ segment of the original array, then after adding $a_{i - 2^k}$ to it, it will be equal to the sum of $(i - 2^{k+1}, i]$. After $O(\log n)$ iterations, the array will turn into its prefix sum.</p>
<p>To implement it in SIMD, we could use <a href="https://en.algorithmica.org/hpc/simd/shuffles">permutations</a> to place $i$-th element against $(i-2^k)$-th, but they are too slow. Instead, we will use the <code>sll</code> (“shift lanes left”) instruction that does exactly that and also replaces the unmatched elements with zeros:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>typedef</span> <span>__m128i</span> <span>v4i</span><span>;</span>

<span>v4i</span> <span>prefix</span><span>(</span><span>v4i</span> <span>x</span><span>)</span> <span>{</span>
    <span>// x = 1, 2, 3, 4
</span><span></span>    <span>x</span> <span>=</span> <span>_mm_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm_slli_si128</span><span>(</span><span>x</span><span>,</span> <span>4</span><span>));</span>
    <span>// x = 1, 2, 3, 4
</span><span></span>    <span>//   + 0, 1, 2, 3
</span><span></span>    <span>//   = 1, 3, 5, 7
</span><span></span>    <span>x</span> <span>=</span> <span>_mm_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm_slli_si128</span><span>(</span><span>x</span><span>,</span> <span>8</span><span>));</span>
    <span>// x = 1, 3, 5, 7
</span><span></span>    <span>//   + 0, 0, 1, 3
</span><span></span>    <span>//   = 1, 3, 6, 10
</span><span></span>    <span>return</span> <span>s</span><span>;</span>
<span>}</span>
</code></pre></div><p>Unfortunately, the 256-bit version of this instruction performs this byte shift independently within two 128-bit lanes, which is typical to AVX:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>typedef</span> <span>__m256i</span> <span>v8i</span><span>;</span>

<span>v8i</span> <span>prefix</span><span>(</span><span>v8i</span> <span>x</span><span>)</span> <span>{</span>
    <span>// x = 1, 2, 3, 4, 5, 6, 7, 8
</span><span></span>    <span>x</span> <span>=</span> <span>_mm256_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm256_slli_si256</span><span>(</span><span>x</span><span>,</span> <span>4</span><span>));</span>
    <span>x</span> <span>=</span> <span>_mm256_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm256_slli_si256</span><span>(</span><span>x</span><span>,</span> <span>8</span><span>));</span>
    <span>x</span> <span>=</span> <span>_mm256_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm256_slli_si256</span><span>(</span><span>x</span><span>,</span> <span>16</span><span>));</span> <span>// &lt;- this does nothing
</span><span></span>    <span>// x = 1, 3, 6, 10, 5, 11, 18, 26
</span><span></span>    <span>return</span> <span>s</span><span>;</span>
<span>}</span>
</code></pre></div><p>We still can use it to compute 4-element prefix sums twice as fast, but we’ll have to switch to 128-bit SSE when accumulating. Let’s write a handy function that computes a local prefix sum end-to-end:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>void</span> <span>prefix</span><span>(</span><span>int</span> <span>*</span><span>p</span><span>)</span> <span>{</span>
    <span>v8i</span> <span>x</span> <span>=</span> <span>_mm256_load_si256</span><span>((</span><span>v8i</span><span>*</span><span>)</span> <span>p</span><span>);</span>
    <span>x</span> <span>=</span> <span>_mm256_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm256_slli_si256</span><span>(</span><span>x</span><span>,</span> <span>4</span><span>));</span>
    <span>x</span> <span>=</span> <span>_mm256_add_epi32</span><span>(</span><span>x</span><span>,</span> <span>_mm256_slli_si256</span><span>(</span><span>x</span><span>,</span> <span>8</span><span>));</span>
    <span>_mm256_store_si256</span><span>((</span><span>v8i</span><span>*</span><span>)</span> <span>p</span><span>,</span> <span>x</span><span>);</span>
<span>}</span>
</code></pre></div><p>Now, for the accumulate phase, we will create another handy function that similarly takes the pointer to a 4-element block and also the 4-element vector of the previous prefix sum. The job of this function is to add this prefix sum vector to the block and update it so that it can be passed on to the next block (by broadcasting the last element of the block before the addition):</p>
<div><pre tabindex="0"><code data-lang="c++"><span>v4i</span> <span>accumulate</span><span>(</span><span>int</span> <span>*</span><span>p</span><span>,</span> <span>v4i</span> <span>s</span><span>)</span> <span>{</span>
    <span>v4i</span> <span>d</span> <span>=</span> <span>(</span><span>v4i</span><span>)</span> <span>_mm_broadcast_ss</span><span>((</span><span>float</span><span>*</span><span>)</span> <span>&amp;</span><span>p</span><span>[</span><span>3</span><span>]);</span>
    <span>v4i</span> <span>x</span> <span>=</span> <span>_mm_load_si128</span><span>((</span><span>v4i</span><span>*</span><span>)</span> <span>p</span><span>);</span>
    <span>x</span> <span>=</span> <span>_mm_add_epi32</span><span>(</span><span>s</span><span>,</span> <span>x</span><span>);</span>
    <span>_mm_store_si128</span><span>((</span><span>v4i</span><span>*</span><span>)</span> <span>p</span><span>,</span> <span>x</span><span>);</span>
    <span>return</span> <span>_mm_add_epi32</span><span>(</span><span>s</span><span>,</span> <span>d</span><span>);</span>
<span>}</span>
</code></pre></div><p>With <code>prefix</code> and <code>accumulate</code> implemented, the only thing left is to glue together our two-pass algorithm:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>void</span> <span>prefix</span><span>(</span><span>int</span> <span>*</span><span>a</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span> <span>+=</span> <span>8</span><span>)</span>
        <span>prefix</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>]);</span>
    
    <span>v4i</span> <span>s</span> <span>=</span> <span>_mm_setzero_si128</span><span>();</span>
    
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>4</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span> <span>+=</span> <span>4</span><span>)</span>
        <span>s</span> <span>=</span> <span>accumulate</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>],</span> <span>s</span><span>);</span>
<span>}</span>
</code></pre></div><p>The algorithm already performs slightly more than twice as fast as the scalar implementation but becomes slower for large arrays that fall out of the L3 cache — roughly at half the <a href="https://en.algorithmica.org/hpc/cpu-cache/bandwidth">two-way RAM bandwidth</a> as we are reading the entire array twice.</p>
<figure>
<img src="https://en.algorithmica.org/hpc/algorithms/img/prefix-simd.svg"/>
<figcaption></figcaption>
</figure>

<p>Another interesting data point: if we only execute the <code>prefix</code> phase, the performance would be ~8.1 GFLOPS. The <code>accumulate</code> phase is slightly slower at ~5.8 GFLOPS. Sanity check: the total performance should be $\frac{1}{ \frac{1}{5.8} + \frac{1}{8.1} } \approx 3.4$.</p>
<span id="blocking"></span>
<h3><a href="https://en.algorithmica.org/hpc/algorithms/prefix/#blocking">#</a>Blocking</h3><p>So, we have a memory bandwidth problem for large arrays. We can avoid re-fetching the entire array from the RAM if we split it into blocks that fit in the cache and process them separately. All we need to pass to the next block is the sum of the previous ones, so we can design a <code>local_prefix</code> function with an interface similar to <code>accumulate</code>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>const</span> <span>int</span> <span>B</span> <span>=</span> <span>4096</span><span>;</span> <span>// &lt;- ideally should be slightly less or equal to the L1 cache
</span><span></span>
<span>v4i</span> <span>local_prefix</span><span>(</span><span>int</span> <span>*</span><span>a</span><span>,</span> <span>v4i</span> <span>s</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>B</span><span>;</span> <span>i</span> <span>+=</span> <span>8</span><span>)</span>
        <span>prefix</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>]);</span>
    
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>B</span><span>;</span> <span>i</span> <span>+=</span> <span>4</span><span>)</span>
        <span>s</span> <span>=</span> <span>accumulate</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>],</span> <span>s</span><span>);</span>

    <span>return</span> <span>s</span><span>;</span>
<span>}</span>

<span>void</span> <span>prefix</span><span>(</span><span>int</span> <span>*</span><span>a</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
    <span>v4i</span> <span>s</span> <span>=</span> <span>_mm_setzero_si128</span><span>();</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span> <span>+=</span> <span>B</span><span>)</span>
        <span>s</span> <span>=</span> <span>local_prefix</span><span>(</span><span>a</span> <span>+</span> <span>i</span><span>,</span> <span>s</span><span>);</span>
<span>}</span>
</code></pre></div><p>(We have to make sure that $N$ is a multiple of $B$, but we are going to ignore such implementation details for now.)</p>
<p>The blocked version performs considerably better, and not just for when the array is in the RAM:</p>
<figure>
<img src="https://en.algorithmica.org/hpc/algorithms/img/prefix-blocked.svg"/>
<figcaption></figcaption>
</figure>

<p>The speedup in the RAM case compared to the non-blocked implementation is only ~1.5 and not 2. This is because the memory controller is sitting idle while we iterate over the cached block for the second time instead of fetching the next one — the <a href="https://en.algorithmica.org/hpc/cpu-cache/prefetching">hardware prefetcher</a> isn’t advanced enough to detect this pattern.</p>
<span id="continuous-loads"></span>
<h3><a href="https://en.algorithmica.org/hpc/algorithms/prefix/#continuous-loads">#</a>Continuous Loads</h3><p>There are several ways to solve this under-utilization problem. The obvious one is to use <a href="https://en.algorithmica.org/hpc/cpu-cache/prefetching">software prefetching</a> to explicitly request the next block while we are still processing the current one.</p>
<p>It is better to add prefetching to the <code>accumulate</code> phase because it is slower and less memory-intensive than <code>prefix</code>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>v4i</span> <span>accumulate</span><span>(</span><span>int</span> <span>*</span><span>p</span><span>,</span> <span>v4i</span> <span>s</span><span>)</span> <span>{</span>
    <span>__builtin_prefetch</span><span>(</span><span>p</span> <span>+</span> <span>B</span><span>);</span> <span>// &lt;-- prefetch the next block
</span><span></span>    <span>// ...
</span><span></span>    <span>return</span> <span>s</span><span>;</span>
<span>}</span>
</code></pre></div><p>The performance slightly decreases for in-cache arrays, but approaches closer to 2 GFLOPS for the in-RAM ones:</p>
<figure>
<img src="https://en.algorithmica.org/hpc/algorithms/img/prefix-prefetch.svg"/>
<figcaption></figcaption>
</figure>

<p>Another approach is to do <em>interleaving</em> of the two phases. Instead of separating and alternating between them in large blocks, we can execute the two phases concurrently, with the <code>accumulate</code> phase lagging behind by a fixed number of iterations — similar to the <a href="https://en.algorithmica.org/hpc/pipelining">CPU pipeline</a>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>const</span> <span>int</span> <span>B</span> <span>=</span> <span>64</span><span>;</span>
<span>//        ^ small sizes cause pipeline stalls
</span><span>//          large sizes cause cache system inefficiencies
</span><span></span>
<span>void</span> <span>prefix</span><span>(</span><span>int</span> <span>*</span><span>a</span><span>,</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
    <span>v4i</span> <span>s</span> <span>=</span> <span>_mm_setzero_si128</span><span>();</span>

    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>B</span><span>;</span> <span>i</span> <span>+=</span> <span>8</span><span>)</span>
        <span>prefix</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>]);</span>

    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>B</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span> <span>+=</span> <span>8</span><span>)</span> <span>{</span>
        <span>prefix</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>]);</span>
        <span>s</span> <span>=</span> <span>accumulate</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span> <span>-</span> <span>B</span><span>],</span> <span>s</span><span>);</span>
        <span>s</span> <span>=</span> <span>accumulate</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span> <span>-</span> <span>B</span> <span>+</span> <span>4</span><span>],</span> <span>s</span><span>);</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>n</span> <span>-</span> <span>B</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span> <span>+=</span> <span>4</span><span>)</span>
        <span>s</span> <span>=</span> <span>accumulate</span><span>(</span><span>&amp;</span><span>a</span><span>[</span><span>i</span><span>],</span> <span>s</span><span>);</span>
<span>}</span>
</code></pre></div><p>This has more benefits: the loop progresses at a constant speed, reducing the pressure on the memory system, and the scheduler sees the instructions of both subroutines, allowing it to be more efficient at assigning instruction to execution ports.</p>
<p>For these reasons the performance improves even on small arrays:</p>
<figure>
<img src="https://en.algorithmica.org/hpc/algorithms/img/prefix-interleaved.svg"/>
<figcaption></figcaption>
</figure>

<p>Finally, combining it with prefetching improves the performance even more:</p>
<figure>
<img src="https://en.algorithmica.org/hpc/algorithms/img/prefix-interleaved-prefetch.svg"/>
<figcaption></figcaption>
</figure>

<p>The total speedup we were able to achieve is between $\frac{4.2}{1.5} \approx 2.8$ for small arrays and $\frac{2.1}{1.2} \approx 1.75$ for large arrays.</p>
<p>The speedup may be higher for lower-precision data compared to the scalar code, as it is pretty much limited to executing one iteration per cycle regardless of the operand size, but it is still sort of “meh” when compared to some <a href="https://en.algorithmica.org/hpc/algorithms/argmin">other SIMD-based algorithms</a>. This is largely because there isn’t a full-register byte shift in AVX that would allow the <code>accumulate</code> stage to proceed twice as fast, let alone a dedicated prefix sum instruction.</p>
<span id="other-relevant-work"></span>
<h3><a href="https://en.algorithmica.org/hpc/algorithms/prefix/#other-relevant-work">#</a>Other Relevant Work</h3><p>You can read <a href="http://www.adms-conf.org/2020-camera-ready/ADMS20_05.pdf">this paper from Columbia</a> that focuses on the multi-core setting and AVX-512 (which <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=3037,4870,6715,4845,3853,90,7307,5993,2692,6946,6949,5456,6938,5456,1021,3007,514,518,7253,7183,3892,5135,5260,3915,4027,3873,7401,4376,4229,151,2324,2310,2324,591,4075,6130,4875,6385,5259,6385,6250,1395,7253,6452,7492,4669,4669,7253,1039,1029,4669,4707,7253,7242,848,879,848,7251,4275,879,874,849,833,6046,7250,4870,4872,4875,849,849,5144,4875,4787,4787,4787,3016,3018,5227,7359,7335,7392,4787,5259,5230,5230,5223,6438,488,483,6165,6570,6554,289,6792,6554,5230,6385,5260,5259,289,288,3037,3009,590,604,633,5230,5259,6554,6554,5259,6547,6554,3841,5214,5229,5260,5259,7335,5259,519,1029,515,3009,3009,3013,3011,515,6527,652,6527,6554,288&amp;text=_mm512_alignr_epi32&amp;techs=AVX_512">sort of</a> has a fast 512-bit register byte shift) and <a href="https://stackoverflow.com/questions/10587598/simd-prefix-sum-on-intel-cpu">this StackOverflow question</a> for a more general discussion.</p>
<p>Most of what I’ve described in this article was already known. To the best of my knowledge, my contribution here is the interleaving technique, which is responsible for a modest ~20% performance increase. There probably are ways to improve it further, but not by a lot.</p>
<p>There is also this professor at CMU, <a href="https://www.cs.cmu.edu/~blelloch/">Guy Blelloch</a>, who <a href="https://www.cs.cmu.edu/~blelloch/papers/sc90.pdf">advocated</a> for a dedicated prefix sum hardware back in the 90s when <a href="https://en.wikipedia.org/wiki/Vector_processor">vector processors</a> were still a thing. Prefix sums are very important for parallel applications, and the hardware is becoming increasingly more parallel, so maybe, in the future, the CPU manufacturers will revitalize this idea and make prefix sum calculations slightly easier.</p>
</article></div>
  </body>
</html>
