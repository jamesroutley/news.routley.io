<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antmicro.com/blog/2023/09/accelerating-digital-block-design-with-googles-xls/">Original</a>
    <h1>Accelerating digital block design with Google&#39;s open source Mid-Level Synthesis</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <p>
          <span>Published:</span>
          <time>Sep 17 2023</time>
        </p>
          <p>
            <span>Topics:</span>
            Open source tools, Open ASICs, Open FPGA</p>
      </div><div>
        <p>Digital circuits are becoming more and more complicated due to constant technology development and increasing user expectations. In response to this growing complexity, development tools that provide a higher level of abstraction for digital system designers have been rising in prominence.</p>

<p>Alongside HDL generators such as Chisel, SpinalHDL, Migen and Amaranth, which have been gaining some popularity among more software-minded developers, there are even newer approaches promising significant productivity increases like Google’s open source <a href="https://github.com/google/xls/">XLS</a> toolchain. Using an encode/decode accelerator that Antmicro has been developing and contributing to XLS as an example, this article will describe how XLS can be used to build, adapt and test digital designs. Of course XLS’ capabilities go beyond codec blocks, but given the framework’s origin in helping Google deliver efficient transcoding solutions, they serve as a good illustration of the strength of this approach.</p>

<p><img src="https://jvns.ca/blog/images/Accelerating-digital-block-design-with-Google%E2%80%99s-open-source-XLS-Mid-Level-Synthesis-tool--blog.svg" alt="Accelerating digital block design with Google’s XLS illustration"/></p>

<h3 id="xls-as-a-mid-level-synthesis-toolchain">XLS as a Mid-Level Synthesis toolchain</h3>

<p>XLS (standing for Accelerated Hardware Synthesis) is a fully open source toolchain created by Google that produces synthesizable designs from high-level descriptions of their functionality. Known limitations of standard High-Level Synthesis (HLS) approaches to non-trivial problems are well recognized, so XLS tries to strike a good balance between succinctness and flexibility, to the point of referring to itself as a “Mid-Level Synthesis” tool. This emphasizes that despite the provided level of abstraction, the user may configure low-level details of the flow to create designs that are both easy to reason about and efficient. XLS gives designers control over many properties in the circuit that traditional HLS solutions would abstract away without explaining what the tool did and why. XLS instead chooses to make decisions more explicit (being able to specify things like pipe stages explicitly, acceptable worst case throughput, explicitly determining what SRAMs are introduced / along which channels, surfacing detailed and transparent scheduling reports, etc.). The use of procs (single stateful XLS elements) lets you find a midpoint between always blocks you’d create in RTL vs. loops which you can’t be sure what the HLS tools will translate into, so you can add structure with procs as structured but multi-cycle concurrent elements as a kind of “always blocks on steroids”.</p>

<p>XLS uses  <a href="https://google.github.io/xls/dslx_reference/">DSLX</a>, a Rust-like DSL which the XLS team believes can offer significant productivity advantages. DSLX is converted to so-called <a href="https://google.github.io/xls/ir_overview/">XLS IR</a> which then gets compiled down to RTL.</p>

<p>The main objective of the XLS project is to enable productive collaboration between software and hardware engineers by creating a common methodology for designing digital circuits, based on a software-driven approach. As a result, the same design description can be used to generate a software model of the circuit and a final RTL description in Verilog or SystemVerilog. This kind of a common denominator approach allows both groups of engineers to cross their domain boundaries, understand each other’s cost models, and share knowledge and experience. XLS is thus meant to help level up the hardware development process with the velocity, composability, modularity and retargetability known from the software world.</p>

<h3 id="xls-use-cases">XLS use cases</h3>

<p>The benefits of XLS are particularly evident in the design of digital circuits with significant algorithmic complexity, since the provided layer of abstraction allows the user to focus more on the designed functionality, rather than low-level implementation details. Because of this, XLS is a great fit for designing circuits based on video encoding, <a href="https://github.com/google/xls/blob/main/xls/examples/sobel_filter.x">image processing</a>, <a href="https://github.com/google/xls/blob/main/xls/modules/aes/aes.x">encryption algorithms</a>, <a href="https://github.com/google/xls/blob/main/xls/modules/rle/rle_enc.x">compression algorithms</a>, or accelerating computation for AI processing.</p>

<p>However, XLS is not intended solely for complex designs. The <a href="https://github.com/google/xls/tree/main/xls/examples">examples</a> provided in the XLS repository demonstrate the toolchain’s versatility and show its many possible applications.</p>

<h3 id="xls-in-action">XLS in action</h3>

<p>In collaboration with Google, Antmicro has been working to demonstrate how XLS can be used for implementing compression algorithms such as <a href="https://en.wikipedia.org/wiki/Run-length_encoding">Run-Length Encoding (RLE)</a> and <a href="https://en.wikipedia.org/wiki/Dictionary_coder">Dictionary Based Encoding (DBE)</a> as open source ASIC-targeted blocks. The encoders and decoders were implemented in DSLX. The level of abstraction enabled by DSLX allowed for exploring different architectural choices, and incremental refinement in the implementation of the encoders. This resulting contribution is more general and parameterizable than traditional HDLs would allow without introducing significant complexity.</p>

<h3 id="implementing-rle">Implementing RLE</h3>

<p>Let’s look at the RLE block as an example. The <a href="https://github.com/google/xls/blob/main/xls/modules/rle/rle_enc.x">initial version</a> of the encoder, which was very simple to implement, used a proc to sequentially read incoming data and compress it into symbol-value pairs.</p>

<p>To enable more practical encoder designs, we then proceeded to add a more advanced version of the block capable of processing multiple symbols simultaneously. <a href="https://github.com/antmicro/xls/blob/5a7ead32b5384fbd5eaac1565d6e729f897002a0/xls/modules/rle/rle_enc_adv.x#L67">A subsequent reimplementation</a> includes four processes that communicate with each other, as detailed in the image below.</p>

<p>The first block - similar to the initial implementation - is responsible for taking the input and reducing it to pairs of symbols and the number of its occurrences. The second element of the encoder shifts the previously emitted pairs and adjusts them for further processing. Both of these elements have an empty state. The next block takes the prepared data and combines it with the information about previously processed symbols. The last element is responsible for adjusting the width of the output data to the receiver interface.</p>

<p>Overall, we can break down the data processing into four stages: reduction, alignment, compression, and output generation. The division of responsibility allowed the specialized blocks to efficiently process data and gave us a chance to thoroughly test each functionality separately.</p>

<p><img src="https://jvns.ca/blog/images/Accelerating-digital-block-design-with-Google%E2%80%99s-open-source-XLS-Mid-Level-Synthesis-tool--diagram--blog.svg" alt="Multisymbol Run Length Encoder diagram"/></p>

<h3 id="testing-and-verifying-the-design">Testing and verifying the design</h3>

<p>Together with the encoders, we created <a href="https://github.com/google/xls/blob/f8e2d3d84089b169d826d81f22966089e28fc787/xls/modules/rle/rle_enc.x#L154">multiple tests</a> to verify that the designs work correctly. Additionally, the <a href="https://google.github.io/xls/#stack-diagram-and-project-layout">internal verification mechanism built into XLS</a> ensured that the generated RTL sources correspond with the software-model that we tested thoroughly before. Later, to investigate the throughput of the core, we added support for the popular Python-based <a href="https://www.cocotb.org/">Cocotb framework</a> into the XLS toolset, which allowed us to create reusable Python tests examining real-life performance of the designs converted to RTL code.</p>

<h3 id="closer-to-silicon-with-sky130-and-asap7">Closer to silicon with SKY130 and ASAP7</h3>

<p>Since XLS is meant to enable production-grade block design for ASICs, another element of the project was to integrate open source physical design tooling into the XLS toolchain. This allowed for generating silicon layouts using the <a href="https://github.com/google/skywater-pdk/">SkyWater 130nm</a> and <a href="https://github.com/The-OpenROAD-Project/asap7">ASAP7</a> PDKs and closing the design loop, from software written in DSLX down to GDS. Having a fully open source flow is great for keeping the framework well-tested with readily available performance parameters that can be tracked over time.</p>

<p>The physical design flow uses <a href="https://github.com/YosysHQ/yosys">Yosys</a> for synthesis and <a href="https://github.com/The-OpenROAD-Project/OpenROAD">OpenROAD</a> for floorplanning, placement, clock tree synthesis and design routing. Every step in the process leverages standard cell definitions and design rules from the chosen PDK. The entire workflow is constructed as a collection of reusable rules for the Bazel build system which is used in the entire XLS project.</p>

<p>Below you can see the Run Length Encoder silicon design in Klayout and its visualization created with <a href="https://github.com/proppy/gds_viewer">gds_viewer</a>:</p>

<p><img src="https://jvns.ca/blog/images/Accelerating-digital-block-design-with-Google%E2%80%99s-open-source-XLS-Mid-Level-Synthesis-tool--blog4.png" alt="Visualization of Run Length Encoder in [gds_viewer](https://github.com/proppy/gds_viewer) "/></p>

<h3 id="renode-xls-integration">Renode XLS integration</h3>

<p>Since fabrication of high-end chips is expensive and time-consuming, and ultimately the final performance and usability of silicon is dependent on the software that runs on top of it, the ability to test the system in a practical HW/SW context from the very beginning is invaluable. Therefore, in parallel to the design itself, we decided to create a fully functional demonstrator showcasing the usage of the created encoders for real-life applications on a RISC-V platform. <a href="https://antmicro.com/blog/2023/01/cpu-rtl-co-simulation-in-renode/">Co-simulation of digital designs using Verilator</a> has been available in Antmicro’s <a href="https://renode.io/">Renode</a> simulator for some time, and was an inspiration for creating a similar integration for XLS. One of the features that convinced us to take this effort is the JIT compilation available in XLS that allows executing design models at native machine speed. The Renode-XLS integration is in progress and will be described in a future blog note.</p>

<h3 id="accelerating-digital-design-with-antmicro-and-xls">Accelerating digital design with Antmicro and XLS</h3>

<p>XLS is a framework focused on developer productivity and thanks to its flexibility and extensive verification capabilities it allows for rapid development of digital designs. The new RLE and DBE building blocks, together with contributions to the framework itself from Antmicro improve the XLS ecosystem for practical usage beyond its original authors. If you are interested in developing and testing digital designs targeting FPGAs or ASICs using SW-driven methodologies, contact Antmicro at <a href="mailto:contact@antmicro.com">contact@antmicro.com</a>.</p>

      </div></div>
  </body>
</html>
