<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lethain.com/agents-coordinators/">Original</a>
    <h1>Building an internal agent: Code-driven vs. LLM-driven workflows</h1>
    
    <div id="readability-page-1" class="page"><div><p>When I started this project, I knew deep in my heart that we could get an LLM
plus tool-usage to solve arbitrarily complex workflows.
I still believe this is possible, but I’m no longer convinced this is
actually a good solution. Some problems are just vastly simpler, cheaper,
and faster to solve with software.
This post talks about our approach to supporting both code and LLM-driven
workflows, and why we decided it was necessary.</p><p><em>This is part of the <a href="https://lethain.com/agents-series/">Building an internal agent</a> series.</em></p><h2 id="why-determinism-matters">Why determinism matters</h2><p>When I joined Imprint, we already had a channel where folks would share pull
requests for review. It wasn’t <em>required</em> to add pull requests to that channel,
but it was often the fastest way to get someone to review it, particularly for
cross-team pull requests.</p><p>I often start my day by skimming for pull requests that need a review in that channel,
and quickly realized that often a pull request would get reviewed and merged without
someone adding the <code>:merged:</code> reacji onto the chat. This felt inefficient, but also
extraordinarily minor, and not the kind of thing I want to complain about.
Instead, I pondered how I could solve it without requiring additional human labor.</p><p>So, I added an LLM-powered workflow to solve this. The prompt was straightforward:</p><ol><li>Get the last 10 messages in the Slack channel</li><li>For each one, if there was exactly one Github pull request URL, extract that URL</li><li>Use the Github MCP to check the status of each of those URLs</li><li>Add the <code>:merged:</code> reacji to messages where the associated pull request was merged or closed</li></ol><p>This worked so well! So, so well. Except, ahh, except that it sometimes decided to add <code>:merged:</code>
to pull requests that weren’t merged. Then no one would look at those pull requests.
So, it worked in concept–so much smart tool usage!–but in practice it actually didn’t
solve the problem I was trying to solve: erroneous additions of the reacji meant
folks couldn’t evaluate whether to look at a given pull request in the channel based on the reacji’s presence.</p><p>(As an aside, some people really don’t like the term <code>reacji</code>.
Don’t complain to me about it, this is <a href="https://docs.slack.dev/reference/methods/reactions.add/">what Slack calls them</a>.)</p><h2 id="how-we-implemented-support-for-code-driven-workflows">How we implemented support for code-driven workflows</h2><p>Our LLM-driven workflows are orchestrated by a software handler.
That handler works something like:</p><ol><li>Trigger comes in, and the handler selects which configuration corresponds with the trigger</li><li>Handler uses that configuration and trigger to pull the associated prompt, load the approved tools,
and generate the available list of virtual files (e.g. files attached to a Jira issue or Slack message)</li><li>Handler sends the prompt and available tools to an LLM, then coordinates tool calls based on the LLM’s
response, including e.g. making virtual files available to tools.
The handler also has termination conditions where it prevents excessive tool usage, and so on</li><li>Eventually the LLM will stop recommending tools, and the final response from the LLM will be
used or discarded depending on the configuration (e.g. configuration can determine whether the final response is sent to Slack)</li></ol><p>We updated our configuration to allow running in one of two configurations:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span># this is default behavior if omitted</span>
</span></span><span><span><span>coordinator</span>: <span>llm</span>
</span></span><span><span>
</span></span><span><span><span># this is code-driven workflow</span>
</span></span><span><span><span>coordinator</span>: <span>script</span>
</span></span><span><span><span>coordinator_script</span>: <span>scripts/pr_merged.py</span>
</span></span></code></pre></div><p>When the <code>coordinator</code> is set to <code>script</code>, then instead of using the handler to determine which tools are called,
custom Python is used. That Python code has access to the same tools, trigger data, and virtual files
as the LLM-handling code. It can use the <a href="https://lethain.com/agents-subagents/">subagent</a> tool to invoke an LLM where useful
(and that subagent can have full access to tools as well), but LLM control only occurs when explicitly desired.</p><p>This means that these scripts–which are being written and checked in by our software engineers, going through code review and so on–have
the same permission and capabilities as the LLM, although given it’s just code, any given commit could also introduce a new
dependency, etc.</p><h2 id="hows-it-working--next-steps">How’s it working? / Next steps?</h2><p>Altogether, this has worked very well for complex workflows. I would describe it as a “solution of frequent resort”,
where we use code-driven workflows as a progressive enhancement for workflows where LLM prompts and tools aren’t reliable
or quick enough.
We still start all workflows using the LLM, which works for many cases.
When we do rewrite, Claude Code can almost always rewrite the prompt into the code workflow
in one-shot.</p><p>Even as models get more powerful, relying on them narrowly in cases where we truly need intelligence,
rather than for iterative workflows, seems like a long-term addition to our toolkit.</p></div></div>
  </body>
</html>
