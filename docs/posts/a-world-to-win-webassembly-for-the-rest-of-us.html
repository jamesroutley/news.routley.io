<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.wingolog.org/archives/2023/03/20/a-world-to-win-webassembly-for-the-rest-of-us">Original</a>
    <h1>A world to win: WebAssembly for the rest of us</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Good day, comrades!</p><p>Today I&#39;d like to share the good news that WebAssembly is finally coming
for the rest of us weirdos.</p><div>

<p>WebAssembly for the rest of us</p>
<p>17 Mar 2023 – BOB 2023</p>
<p>Andy Wingo</p>
<p>Igalia, S.L.</p>
</div><p>This is a transcript-alike of a talk that I gave last week at <a href="https://bobkonf.de/2023/en/program.html">BOB
2023</a>, a gathering in Berlin of
people that are using &#34;technologies beyond the mainstream&#34; to get things
done: Haskell, Clojure, Elixir, and so on.  PDF slides <a href="https://wingolog.org/pub/2023-bobkonf-wasm-for-the-rest-of-us-slides.pdf">here</a>, and I&#39;ll link the video too when it becomes available.</p><div>
<h2>WebAssembly, the story</h2>
<p>WebAssembly is an exciting new universal compute platform</p>
</div><p>WebAssembly: what even is it?  Not a programming language that
you would write software in, but rather a compilation target: a sort of
assembly language, if you will.</p><div>
<h2>WebAssembly, the pitch</h2>
<p>Predictable portable performance</p>
<ul>
<li>Low-level</li>
<li>Within 10% of native</li>
</ul>
<p>Reliable composition via isolation</p>
<ul>
<li>Modules share nothing by default</li>
<li>No nasal demons</li>
<li>Memory sandboxing</li>
</ul>
<p>Compile your code to WebAssembly for easier distribution and composition</p>
</div><p>If you look at what the characteristics of WebAssembly are as an
abstract machine, to me there are two main areas in which it is an
advance over the alternatives.</p><p>Firstly it&#39;s &#34;close to the metal&#34; -- if you compile for example an
image-processing library to WebAssembly and run it, you&#39;ll get similar
performance when compared to compiling it to x86-64 or ARMv8 or what
have you.  (For image processing in particular, native still generally
wins because the SIMD primitives in WebAssembly are more narrow and
because getting the image into and out of WebAssembly may imply a copy,
but the general point remains.)  WebAssembly&#39;s instruction set covers a
broad range of low-level operations that allows compilers to produce
efficient code.</p><p>The novelty here is that WebAssembly is both portable while also being
successful.  We language weirdos know that it&#39;s not enough to do
something technically better: you have to also succeed in getting
traction for your alternative.</p><p>The second interesting characteristic is that WebAssembly is (generally
speaking) a principle-of-least-authority architecture: a WebAssembly
module starts with access to nothing but itself.  Any capabilities that
an instance of a module has must be explicitly shared with it by the
host at instantiation-time.  This is unlike DLLs which have access to
all of main memory, or JavaScript libraries which can mutate global
objects.  This characteristic allows WebAssembly modules to be reliably
composed into larger systems.</p><div>
<h2>WebAssembly, the hype</h2>
<p>It’s in all browsers! Serve your code to anyone in the world!</p>
<p>It’s on the edge! Run code from your web site close to your users!</p>
<p>Compose a library (eg: Expat) into your program (eg: Firefox), without risk!</p>
<p>It’s the new lightweight virtualization: Wasm is what containers were to VMs! Give me that Kubernetes cash!!!</p>
</div><p>Again, the remarkable thing about WebAssembly is that it is succeeding!
It&#39;s on all of your phones, all your desktop web browsers, all of the
content distribution networks, and in some cases it seems set to replace
containers in the cloud.  Launch the rocket emojis!</p><div>
<h2>WebAssembly, the reality</h2>
<p>WebAssembly is a weird backend for a C compiler</p>
<p>Only some source languages are having success on WebAssembly</p>
<p>
What about Haskell, Ocaml, Scheme, F#, and so on – what about <i>us</i>?
</p>
<p>Are we just lazy? (Well...)</p>
</div><p>So why aren&#39;t we there?  Where is Clojure-on-WebAssembly?  Where are the
F#, the Elixir, the Haskell compilers?  Some early efforts exist, but
they aren&#39;t really succeeding.  Why is that?  Are we just not putting in
the effort?  Why is it that Rust gets to ride on the rocket ship but Scheme does not?</p><div>
<h2>WebAssembly, the reality (2)</h2>
<p>WebAssembly (1.0, 2.0) is not well-suited to garbage-collected languages</p>
<p>Let’s look into why</p>
</div><p>As it turns out, there is a reason that there is no good Scheme
implementation on WebAssembly: the initial version of WebAssembly is a
terrible target if your language relies on the presence of a garbage
collector.  There have been some advances but this observation still
applies to the current standardized and deployed versions of
WebAssembly.  To better understand this issue, let&#39;s dig into the guts
of the system to see what the limitations are.</p><div>
<h2>GC and WebAssembly 1.0</h2>
<p>Where do garbage-collected values live?</p>
<p>For WebAssembly 1.0, only possible answer: linear memory</p>
<pre>(module
  (global $hp (mut i32) (i32.const 0))
  (memory $mem 10)) ;; 640 kB</pre>
</div><p>The primitive that WebAssembly 1.0 gives you to represent your data is
what is called <i>linear memory</i>: just a buffer of bytes to which you can
read and write.  It&#39;s pretty much like what you get when compiling
natively, except that the memory layout is more simple.  You can obtain
this memory in units of 64-kilobyte pages.  In the example above we&#39;re
going to request 10 pages, for 640 kB.  Should be enough, right?  We&#39;ll
just use it all for the garbage collector, with a bump-pointer
allocator.  The heap pointer / allocation pointer is kept in the mutable
global variable <tt>$hp</tt>.</p><div>
<pre>(func $alloc (param $size i32) (result i32)
  (local $ret i32)
  (loop $retry
    (local.set $ret (global.get $hp))
    (global.set $hp
      (i32.add (local.get $size) (local.get $ret)))

    (br_if 1
      (i32.lt_u (i32.shr_u (global.get $hp) 16)
                (memory.size))
      (local.get $ret))

    <b>(call $gc)</b>
    (br $retry)))
</pre>
</div><p>Here&#39;s what an allocation function might look like.  The allocation
function <tt>$alloc</tt> is like malloc: it takes a number of bytes and returns
a pointer.  In WebAssembly, a pointer to memory is just an offset, which
is a 32-bit integer (<tt>i32</tt>).  (Having the option of a 64-bit address
space is planned but not yet standard.)</p><p>If this is your first time seeing the text representation of a
WebAssembly function, you&#39;re in for a treat, but that&#39;s not the point of
the presentation :)  What I&#39;d like to focus on is the <tt>(call $gc)</tt> --
what happens when the allocation pointer reaches the end of the region?</p><div>
<h2>GC and WebAssembly 1.0 (2)</h2>
<p>
What hides behind <tt>(call $gc)</tt> ?
</p>
<p>Ship a GC over linear memory</p>
<p>Stop-the-world, not parallel, not concurrent</p>
<p>
But... <b>roots</b>.
</p>
</div><p>The first thing to note is that you have to provide the <tt>$gc</tt> yourself.
Of course, this is doable -- this is what we do when compiling to a
native target.</p><p>Unfortunately though the multithreading support in WebAssembly is
somewhat underpowered; it lets you share memory and use atomic
operations but you have to create the threads outside WebAssembly.  In
practice probably the GC that you ship will not take advantage of
threads and so it will be rather primitive, deferring all collection
work to a stop-the-world phase.</p><div>
<h2>GC and WebAssembly 1.0 (3)</h2>
<p>Live objects are</p>
<ul>
<li>the roots</li>
<li>any object referenced by a live object</li>
</ul>
<p>Roots are globals and locals in active stack frames</p>
<p>
<b>No way to visit active stack frames</b>
</p>
</div><p>What&#39;s worse though is that you have no access to roots on the stack.  A
GC has to keep live objects, as defined circularly as any object
referenced by a root, or any object referenced by a live object.  It
starts with the roots: global variables and any GC-managed object
referenced by an active stack frame.</p><p>But there we run into problems, because in WebAssembly (any version, not
just 1.0) you can&#39;t iterate over the stack, so you can&#39;t find active
stack frames, so you can&#39;t find the stack roots.  (Sometimes people want
to support this as a <a href="https://github.com/WebAssembly/exception-handling/issues/105">low-level
capability</a>
but generally speaking the consensus would appear to be that overall
performance will be better if the engine is the one that is responsible
for implementing the GC; but that is foreshadowing!)</p><div>
<h2>GC and WebAssembly 1.0 (3)</h2>
<p>Workarounds</p>
<ul>
<li>handle stack for precise roots</li>
<li>spill all possibly-pointer values to linear memory and collect conservatively</li>
</ul>
<p>Handle book-keeping a drag for compiled code</p>
</div><p>Given the noniterability of the stack, there are basically two
work-arounds.  One is to have the compiler and run-time maintain an
explicit stack of object roots, which the garbage collector can know for
sure are pointers.  This is nice because it lets you move objects.  But,
maintaining the stack is overhead; the state of the art solution is
rather to create a side table (a &#34;stack map&#34;) associating each potential
point at which GC can be called with instructions on how to find the
roots.</p><p>The other workaround is to spill the whole stack to memory.  Or,
possibly just pointer-like values; anyway, you conservatively scan all
words for things that might be roots.  But instead of having access to
the memory to which the WebAssembly implementation would spill your
stack, you have to do it yourself.  This can be OK but it&#39;s sub-optimal;
see <a href="https://wingolog.org/archives/2023/02/07/whippet-towards-a-new-local-maximum">my recent post on the Whippet garbage
collector</a>
for a deeper discussion of the implications of conservative
root-finding.</p><div>
<h2>GC and WebAssembly 1.0 (4)</h2>
<p>Cycles with external objects (e.g. JavaScript) uncollectable</p>
<p>A pointer to a GC-managed object is an offset to linear memory, need capability over linear memory to read/write object from outside world</p>
<p>No way to give back memory to the OS</p>
<p>Gut check: gut says no</p>
</div><p>If that were all, it would already be not so great, but it gets worse!
Another problem with linear-memory GC is that it limits the potential
for composing a number of modules and the host together, because the
garbage collector that manages JavaScript objects in a web browser knows
nothing about your garbage collector over your linear memory.  You can
easily create memory leaks in a system like that.</p><p>Also, it&#39;s pretty gross that a reference to an object in linear memory
requires arbitrary read-write access over all of linear memory in order
to read or write object fields.  How do you build a reliable system
without invariants?</p><p>Finally, once you collect garbage, and maybe you manage to compact
memory, you can&#39;t give anything back to the OS.  There are proposals in
the works but they are not there yet.</p><p>If the BOB audience had to choose between <a href="https://www.dreamsongs.com/WorseIsBetter.html">Worse is Better and The Right
Thing</a>, I think the BOB
audience is much closer to the Right Thing.  People like that feel
instinctual revulsion to ugly systems and I think GC over linear memory
describes an ugly system.</p><div>
<h2>GC and WebAssembly 1.0 (5)</h2>
<p>
<i>There is already a high-performance concurrent parallel compacting GC in the browser</i>
</p>
<p>Halftime: C++ N – Altlangs 0</p>
</div><p>The kicker is that WebAssembly 1.0 requires you to write and deliver a
terrible GC when there is already probably a great GC just sitting there
in the host, one that has hundreds of person-years of effort invested in
it, one that will surely do a better job than you could ever do.
WebAssembly as hosted in a web browser should have access to the
browser&#39;s garbage collector!</p><p>I have the feeling that while those of us with a soft spot for languages
with garbage collection have been standing on the sidelines, Rust and
C++ people have been busy on the playing field scoring goals.  Tripping
over the ball, yes, but eventually they do manage to make within
striking distance.</p><div>
<h2>Change is coming!</h2>
<p>Support for built-in GC set to ship in Q4 2023</p>
<p>With GC, the material conditions are now in place</p>
<p>
Let’s compile <i>our</i> languages to WebAssembly
</p>
</div><p>But to continue the sportsball metaphor, I think in the second half our
players will finally be able to get out on the pitch and give it the
proverbial 110%.  Support for garbage collection is coming to
WebAssembly users, and I think even by the end of the year it will be
shipping in major browsers.  This is going to be big!  We have a chance
and we need to sieze it.</p><div>
<h2>Scheme to Wasm</h2>
<p>Spritely + Igalia working on Scheme to WebAssembly</p>
<p>Avoid truncating language to platform; bring whole self</p>
<ul>
<li>
<b>Value representation</b>
</li>
<li>Varargs</li>
<li>Tail calls</li>
<li>Delimited continuations</li>
<li>Numeric tower</li>
</ul>
</div><p>Even with GC, though, WebAssembly is still a weird machine.  It would
help to see the concrete approaches that some languages of interest
manage to take when compiling to WebAssembly.</p><p>In that spirit, the rest of this article/presentation is a walkthough of
the approach that I am taking as I work on a WebAssembly compiler for
Scheme.  (Thanks to <a href="https://spritely.institute">Spritely</a> for supporting
this work!)</p><p>Before diving in, a meta-note: when you go to compile a language to,
say, JavaScript, you are mightily tempted to cut corners.  For example
you might implement numbers as JavaScript numbers, or you might omit
implementing continuations.  In this work I am trying to not cut
corners, and instead to implement the language faithfully.  Sometimes
this means I have to work around weirdness in WebAssembly, and that&#39;s
OK.</p><p>When thinking about Scheme, I&#39;d like to highlight a few specific areas
that have interesting translations.  We&#39;ll start with value
representation, which stays in the GC theme from the introduction.</p><div>
<h2>Scheme to Wasm: Values</h2>
<pre>;;       any  extern  func
;;        |
;;        eq
;;     /  |   \
;; <b>i31</b> <b>struct</b>  array
</pre>
<p>
The unitype: <tt>(ref eq)</tt>
</p>
<p>
Immediate values in <tt>(ref i31)</tt>
</p>
<ul>
<li>fixnums with 30-bit range</li>
<li>chars, bools, etc</li>
</ul>
<p>
Explicit nullability: <tt>(ref null eq)</tt> vs <tt>(ref eq)</tt>
</p>
</div><p>The GC extensions for WebAssembly are phrased in terms of a type system.
Oddly, there are three top types; as far as I understand it, this is the
result of a compromise about how WebAssembly engines might want to
represent these different kinds of values.  For example, an opaque
JavaScript value flowing into a WebAssembly program would have type
<tt>(ref extern)</tt>.  On a system with <a href="https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations">NaN
boxing</a>,
you would need 64 bits to represent a JS value.  On the other hand a
native WebAssembly object would be a subtype of <tt>(ref any)</tt>, and might
be representable in 32 bits, either because it&#39;s a 32-bit system or
because of pointer compression.</p><p>Anyway, three top types.  The user can define subtypes of <tt>struct</tt> and
<tt>array</tt>, instantiate values of those types, and access their fields.
The life cycle of reference-typed objects is automatically managed by
the run-time, which is just another way of saying they are
garbage-collected.</p><p>For Scheme, we need a common supertype for all values: <a href="https://medium.com/@samth/on-typed-untyped-and-uni-typed-languages-8a3b4bedf68c">the unitype, in
Bob Harper&#39;s memorable
formulation</a>.
We can use <tt>(ref any)</tt>, but actually we&#39;ll use <tt>(ref eq)</tt> -- this is the
supertype of values that can be compared by (pointer) identity.  So now
we can code up <tt>eq?</tt>:</p><pre>(func $eq? (param (ref eq) (ref eq))
           (result i32)
  (ref.eq (local.get a) (local.get b)))
</pre><p>Generally speaking in a Scheme implementation there are <i>immediates</i> and
<i>heap objects</i>.  Immediates can be encoded in the bits of a value,
whereas for heap object the bits of a value encode a reference (pointer)
to an object on the garbage-collected heap.  We usually represent small
integers as immediates, as well as booleans and other oddball values.</p><p>Happily, WebAssembly gives us an immediate value type, <tt>i31</tt>.  We&#39;ll
encode our immediates there, and otherwise represent heap objects as
instances of <tt>struct</tt> subtypes.</p><div>
<h2>Scheme to Wasm: Values (2)</h2>
<p>
Heap objects subtypes of <tt>struct</tt>; concretely:
</p>
<pre>(struct $heap-object
  (struct (field $tag-and-hash i32)))
(struct $pair
  (<b>sub $heap-object</b>
    (struct <b>i32</b> (ref eq) (ref eq))))
</pre>
<p>GC proposal allows subtyping on structs, functions, arrays</p>
<p>Structural type equivalance: explicit tag useful</p>
</div><p>We actually need to have a common struct supertype as well, for two
reasons.  One is that we need to be able to hash Scheme values by
identity, but for this we need an embedded lazily-initialized hash
code.  It&#39;s a bit annoying to take the per-object memory hit but it&#39;s a
reality, and the JVM does it this way, so it must not be so terrible.</p><p>The other reason is more subtle: WebAssembly&#39;s type system is built in
such a way that types that are &#34;structurally&#34; equivalent are
indistinguishable.  So a pair has two fields, besides the hash, but
there might be a number of other fundamental object types that have the
same shape; you can&#39;t fully rely on WebAssembly&#39;s dynamic type checks
(<tt>ref.test</tt> et al) to be able to query the type of a value.  Instead we
re-use the low bits of the hash word to include a type tag, which might
be 1 for pairs, 2 for vectors, 3 for closures, and so on.</p><div>
<h2>Scheme to Wasm: Values (3)</h2>
<pre>(func $cons (param (ref eq)
                   (ref eq))
            (result (ref $pair))
  (<b>struct.new_canon</b> $pair
    ;; Assume heap tag for pairs is 1.
    (i32.const 1)
    ;; Car and cdr.
    (local.get 0)
    (local.get 1)))

(func $%car (param <b>(ref $pair)</b>)
            (result (ref eq))
  (struct.get $pair 1 (local.get 0)))
</pre>
</div><p>With this knowledge we can define <tt>cons</tt>, as a simple call to
<tt>struct.new_canon pair</tt>.</p><p>I didn&#39;t have time for this in the talk, but there is a ghost haunting
this code: the ghost of nominal typing.  See, in a web browser at least,
every heap object will have its first word point to its &#34;hidden class&#34; /
&#34;structure&#34; / &#34;map&#34; word.  If the engine ever needs to check that a
value is of a specific shape, it can do a quick check on the map word&#39;s
value; if it needs to do deeper introspection, it can dereference that
word to get more details.</p><p>Under the hood, testing whether a <tt>(ref eq)</tt> is a pair or not should be
a simple check that it&#39;s a <tt>(ref struct)</tt> (and not a fixnum), and then a
comparison of its map word to the run-time type corresponding to
<tt>$pair</tt>.  If subtyping of <tt>$pair</tt> is allowed, we start to want inline
caches to handle polymorphism, but the checking the map word is still
the basic mechanism.</p><p>However, as I mentioned, we only have structural equality of types; two
<tt>(struct (ref eq))</tt> type definitions will define the same type and have
the same map word (run-time type / RTT).  Hence the <tt>_canon</tt> in the name of
<tt>struct.new_canon $pair</tt>: we create an instance of <tt>$pair</tt>, with the
<i>canonical</i> run-time-type for objects having <tt>$pair</tt>-shape.</p><p>In earlier drafts of the WebAssembly GC extensions, users could define
their own RTTs, which effectively amounts to nominal typing: not only
does this object have the right structure, but was it created with
respect to this particular RTT.  But, this facility was cut from the
first release, and it left ghosts in the form of these <tt>_canon</tt> suffixes
on type constructor instructions.</p><p>For the Scheme-to-WebAssembly effort, we effectively add back in a
degree of nominal typing via type tags.  For better or for worse this
results in a so-called &#34;open-world&#34; system: you can instantiate a
separately-compiled WebAssembly module that happens to define the same
types and use the same type tags and it will be able to happily access
the contents of Scheme values from another module.  If you were to use
nominal types, you would&#39;t be able to do so, unless there were some
common base module that defined and exported the types of interests, and
which any extension module would need to
<a href="https://github.com/WebAssembly/proposal-type-imports/blob/main/proposals/type-imports/Overview.md">import</a>.</p><div>
<pre>(func $car (param <b>(ref eq)</b>) (result (ref eq))
  (local (ref $pair))
  (block $not-pair
    (br_if $not-pair
      <b>(i32.eqz (ref.test $pair (local.get 0)))</b>)
    (local.set 1 (ref.cast $pair) (local.get 0))
    (br_if $not-pair
      <b>(i32.ne
        (i32.const 1)
        (i32.and
          (i32.const 0xff)
          (struct.get $heap-object 0 (local.get 1))))</b>)
    (return_call $%car (local.get 1)))

  (call $type-error)
  (unreachable))
</pre>
</div><p>In the previous example we had <tt>$%car</tt>, with a funny <tt>%</tt> in the name,
taking a <tt>(ref $pair)</tt> as an argument.  But in the general case (barring
compiler heroics) <tt>car</tt> will take an instance of the unitype <tt>(ref eq)</tt>.
To know that it&#39;s actually a pair we have to make two checks:  one, that
it is a struct and has the <tt>$pair</tt> shape, and two, that it has the right
tag.  Oh well!</p><div>
<h2>Scheme to Wasm</h2>
<ul>
<li>
<i>Value representation</i>
</li>
<li>
<b>Varargs</b>
</li>
<li>Tail calls</li>
<li>Delimited continuations</li>
<li>Numeric tower</li>
</ul>
</div><p>But with all of that I think we have a solid story on how to represent
values.  I went through all of the basic value types in Guile and
checked that they could <a href="https://gitlab.com/spritely/guile-hoot-updates/-/blob/main/examples/basic-types.wat">all be represented using GC
types</a>,
and it seems that all is good.  Now on to the next point: varargs.</p><div>
<h2>Scheme to Wasm: Varargs</h2>
<pre>(list &#39;hey)      ;; =&gt; (hey)
(list &#39;hey &#39;bob) ;; =&gt; (hey bob)</pre>
<p>Problem: Wasm functions strongly typed</p>
<pre>(func $list (param ???) (result (ref eq))
  ???)</pre>
<p>Solution: Virtualize calling convention</p>
</div><p>In WebAssembly, you define functions with a type, and it is impossible
to call them in an unsound way.  You must call <tt>$car</tt> exactly 2
arguments or it will not compile, and those arguments have to be of
specific types, and so on.  But Scheme doesn&#39;t enforce these
restrictions on the language level, bless its little miscreant heart.
You can call <tt>car</tt> with 5 arguments, and you&#39;ll get a run-time error.
There are some functions that can take a variable number of arguments,
doing different things depending on incoming argument count.</p><p>How do we square these two approaches to function types?</p><div>
<pre>;; &#34;Registers&#34; for args 0 to 3
(global $arg0 (mut (ref eq)) (i31.new (i32.const 0)))
(global $arg1 (mut (ref eq)) (i31.new (i32.const 0)))
(global $arg2 (mut (ref eq)) (i31.new (i32.const 0)))
(global $arg3 (mut (ref eq)) (i31.new (i32.const 0)))

;; &#34;Memory&#34; for the rest
(type $argv (array (ref eq)))
(global $argN (ref $argv)
        (array.new_canon_default
          $argv (i31.const 42) (i31.new (i32.const 0))))</pre>
<p>Uniform function type: argument count as sole parameter</p>
<p>Callee moves args to locals, possibly clearing roots</p>
</div><p>The approach we are taking is to virtualize the calling convention.  In
the same way that when calling an x86-64 function, you pass the first
argument in <tt>$rdi</tt>, then <tt>$rsi</tt>, and eventually if you run out of
registers you put arguments in memory, in the same way we&#39;ll pass the
first argument in the <tt>$arg0</tt> global, then <tt>$arg1</tt>, and eventually in
memory if needed.  The function will receive the number of incoming
arguments as its sole parameter; in fact, all functions will be of type
<tt>(func (param i32))</tt>.</p><p>The expectation is that after checking argument count, the callee will
load its arguments from globals / memory to locals, which the compiler
can do a better job on than globals.  We might not even emit code to
null out the argument globals; might leak a little memory but probably
would be a win.</p><p>You can imagine a world in which <tt>$arg0</tt> actually gets globally
allocated to <tt>$rdi</tt>, because it is only live during the call sequence;
but I don&#39;t think that world is this one :)</p><div>
<h2>Scheme to Wasm</h2>
<ul>
<li>
<i>Value representation</i>
</li>
<li>
<i>Varargs</i>
</li>
<li>
<b>Tail calls</b>
</li>
<li>Delimited continuations</li>
<li>Numeric tower</li>
</ul>
</div><p>Great, two points out of the way!  Next up, tail calls.</p><div>
<h2>Scheme to Wasm: Tail calls</h2>
<pre>;; Call known function
(return_call $f arg ...)

;; Call function by value
(return_call_ref $type callee arg ...)</pre>
</div><p>Friends -- I almost cried making this slide.  We Schemers are used to
working around the lack of tail calls, and I could have done so here,
but it&#39;s just such a relief that these functions are just going to be
there and I don&#39;t have to think much more about them.  Technically
speaking the <a href="https://github.com/WebAssembly/tail-call">proposal</a> isn&#39;t
merged yet; checking the <a href="https://github.com/WebAssembly/proposals">phases
document</a> it&#39;s at the last
station before headed to the great depot in the sky.  But, soon soon it
will be present and enabled in all WebAssembly implementations, and we
should build systems now that rely on it.</p><div>
<h2>Scheme to Wasm</h2>
<ul>
<li>
<i>Value representation</i>
</li>
<li>
<i>Varargs</i>
</li>
<li>
<i>Tail calls</i>
</li>
<li>
<b>Delimited continuations</b>
</li>
<li>Numeric tower</li>
</ul>
</div><p>Next up, my favorite favorite topic: delimited continuations.</p><div>
<h2>Scheme to Wasm: Prompts (1)</h2>
<p>Problem: Lightweight threads/fibers, exceptions</p>
<p>Possible solutions</p>
<ul>
<li>Eventually, built-in coroutines</li>
<li>
<a href="https://github.com/WebAssembly/binaryen">binaryen</a>’s asyncify (not yet ready for GC); see Julia
</li>
<li>
<b>Delimited continuations</b>
</li>
</ul>
<p>“Bring your whole self”</p>
</div><p>Before diving in though, one might wonder why bother.  Delimited
continuations are a building-block that one can use to build other, more
useful things, notably exceptions and light-weight threading / fibers.
Could there be another way of achieving these end goals without having
to implement this relatively uncommon primitive?</p><p>For fibers, it is possible to <a href="https://wingolog.org/archives/2018/05/16/lightweight-concurrency-in-lua">implement them in terms of a built-in
coroutine
facility</a>.
The standards body seems willing to include a coroutine primitive, but
it seems far off to me; not within the next 3-4 years I would say.  So
let&#39;s put that to one side.</p><p>There is a more near-term solution, to use <a href="https://github.com/WebAssembly/design/issues/1294#issuecomment-520231415">asyncify to implement
coroutines</a>
somehow; but my understanding is that asyncify is not ready for GC yet.</p><p>For the Guile flavor of Scheme at least, delimited continuations are
table stakes of their own right, so given that we will have them on
WebAssembly, we might as well use them to implement fibers and
exceptions in the same way as we do on native targets.  Why compromise
if you don&#39;t have to?</p><div>
<h2>Scheme to Wasm: Prompts (2)</h2>
<p>Prompts delimit continuations</p>
<pre>(define k
  (call-with-prompt ’foo
    ; body
    (lambda ()
      (+ 34 (abort-to-prompt &#39;foo)))
    ; handler
    (lambda (continuation)
      continuation)))

(k 10)       ;; ⇒ 44
(- (k 10) 2) ;; ⇒ 42</pre>
<p>
<tt>k</tt> is the <tt>_</tt> in <tt>(lambda () (+ 34 _))</tt>
</p>
</div><p>There are a few ways to implement <a href="https://wingolog.org/archives/2010/02/26/guile-and-delimited-continuations">delimited
continuations</a>,
but my usual way of thinking about them is that a delimited continuation
is a slice of the stack.  One end of the slice is the <i>prompt</i>
established by <tt>call-with-prompt</tt>, and the other by the continuation of
the call to <tt>abort-to-prompt</tt>.  Capturing a slice pops it off the stack,
copying it out to the heap as a callable function.  Calling that
function splats the captured slice back on the stack and resumes it
where it left off.</p><div>
<h2>Scheme to Wasm: Prompts (3)</h2>
<p>Delimited continuations are stack slices</p>
<p>Make stack explicit via minimal continuation-passing-style conversion</p>
<ul>
<li>Turn all calls into tail calls</li>
<li>Allocate return continuations on explicit stack</li>
<li>Breaks functions into pieces at non-tail calls</li>
</ul>
</div><p>This low-level intuition of what a delimited continuation is leads
naturally to an implementation; the only problem is that we can&#39;t slice
the WebAssembly call stack.  The workaround here is similar to the
varargs case: we virtualize the stack.</p><p>The mechanism to do so is a continuation-passing-style (CPS)
transformation of each function.  Functions that make no calls, such as
leaf functions, don&#39;t need to change at all.  The same goes for
functions that make only tail calls.  For functions that make non-tail
calls, we split them into pieces that preserve the only-tail-calls
property.</p><div>
<h2>Scheme to Wasm: Prompts (4)</h2>
<p>Before a non-tail-call:</p>
<ul>
<li>Push live-out vars on stacks (one stack per top type)</li>
<li>Push continuation as funcref</li>
<li>Tail-call callee</li>
</ul>
<p>Return from call via pop and tail call:</p>
<pre>(return_call_ref (call $pop-return)
                 (i32.const 0))</pre>
<p>After return, continuation pops state from stacks</p>
</div><p>Consider a simple function:</p><pre>(define (f x y)
  (+ x (g y))
</pre><p>Before making a non-tail call, a &#34;tailified&#34; function will instead push
all live data onto an explicitly-managed stack and tail-call the
callee.  It also pushes on the return continuation.  Returning from the
callee pops the return continuation and tail-calls it.  The return
continuation pops the previously-saved live data and continues.</p><p>In this concrete case, tailification would split <tt>f</tt> into two pieces:</p><pre>(define (f x y)
  (push! x)
  (push-return! f-return-continuation-0)
  (g y))

(define (f-return-continuation-0 g-of-y)
  (define k (pop-return!))
  (define x (pop! x))
  (k (+ x g-of-y)))
</pre><p>Now there are no non-tail calls, besides calls to run-time routines like
<tt>push!</tt> and <tt>+</tt> and so on.  This transformation is implemented by
<a href="https://git.savannah.gnu.org/gitweb/?p=guile.git;a=blob;f=module/language/cps/tailify.scm;h=f9ebb63d20b7ad736e74c39327d854de0fb798af;hb=refs/heads/wip-tailify">tailify.scm</a>.</p><div>
<h2>Scheme to Wasm: Prompts (5)</h2>
<p>
<tt>abort-to-prompt</tt>:
</p>
<ul>
<li>Pop stack slice to reified continuation object</li>
<li>Tail-call new top of stack: prompt handler</li>
</ul>
<p>Calling a reified continuation:</p>
<ul>
<li>Push stack slice</li>
<li>Tail-call new top of stack</li>
</ul>
<p>No need to wait for effect handlers proposal; you can have it all now!</p>
</div><p>The salient point is that the stack on which <tt>push!</tt> operates (in
reality, probably four or five stacks: one in linear memory or an array
for types like <tt>i32</tt> or <tt>f64</tt>, three for each of the managed top types
<tt>any</tt>, <tt>extern</tt>, and <tt>func</tt>, and one for the stack of return
continuations) are managed by us, so we can slice them.</p><p>Someone asked in the talk about whether the explicit memory traffic and
avoiding the return-address-buffer branch prediction is a source of
inefficiency in the transformation and I have to say, yes, but I don&#39;t
know by how much.  I guess we&#39;ll find out soon.</p><div>
<h2>Scheme to Wasm</h2>
<ul>
<li>
<i>Value representation</i>
</li>
<li>
<i>Varargs</i>
</li>
<li>
<i>Tail calls</i>
</li>
<li>
<i>Delimited continuations</i>
</li>
<li>
<b>Numeric tower</b>
</li>
</ul>
</div><p>Okeydokes, last point!</p><div>
<h2>Scheme to Wasm: Numbers</h2>
<p>Numbers can be immediate: fixnums</p>
<p>Or on the heap: bignums, fractions, flonums, complex</p>
<p>
Supertype is still <tt>ref eq</tt>
</p>
<p>Consider imports to implement bignums</p>
<ul>
<li>
On web: <tt>BigInt</tt>
</li>
<li>On edge: Wasm support module (mini-gmp?)</li>
</ul>
<p>Dynamic dispatch for polymorphic ops, as usual</p>
</div><p>First, I would note that sometimes the compiler can unbox numeric
operations.  For example if it infers that a result will be an inexact
real, it can use unboxed <tt>f64</tt> instead of library routines working on
heap flonums (<tt>(struct i32 f64)</tt>; the initial i32 is for the hash and
tag).  But we still need a story for the general case that involves
dynamic type checks.</p><p>The basic idea is that we get to have fixnums and heap numbers.  Fixnums
will handle most of the integer arithmetic that we need, and will avoid
allocation.  We&#39;ll inline most fixnum operations as a fast path and call
out to library routines otherwise.  Of course fixnum inputs may produce
a bignum output as well, so the fast path sometimes includes another
slow-path callout.</p><p>We want to minimize binary module size.  In an ideal
compile-to-WebAssembly situation, a small program will have a small
module size, down to a minimum of a kilobyte or so; larger programs can
be megabytes, if the user experience allows for the download delay.
Binary module size will be dominated by code, so that means we need to
plan for aggressive dead-code elimination, minimize the size of fast
paths, and also minimize the size of the standard library.</p><p>For numbers, we try to keep module size down by leaning on the platform.
In the case of bignums, we can punt some of this work to the host; on a
JavaScript host, we would use <tt>BigInt</tt>, and on a WASI host we&#39;d compile
an external bignum library.  So that&#39;s the general story: inlined fixnum
fast paths with dynamic checks, and otherwise library routine callouts,
combined with aggressive whole-program dead-code elimination.</p><div>
<h2>Scheme to Wasm</h2>
<ul>
<li>
<i>Value representation</i>
</li>
<li>
<i>Varargs</i>
</li>
<li>
<i>Tail calls</i>
</li>
<li>
<i>Delimited continuations</i>
</li>
<li>
<i>Numeric tower</i>
</li>
</ul>
</div><p>Hey I think we did it!  Always before when I thought about compiling
Scheme or Guile to the web, I got stuck on some point or another, was
tempted down the corner-cutting alleys, and eventually gave up before
starting.  But finally it would seem that the stars are aligned: we get
to have our Scheme and run it too.</p><div>
<h2>Miscellenea</h2>
<p>Debugging: The wild west of DWARF; prompts</p>
<p>
Strings: <tt>stringref</tt> host strings spark joy
</p>
<p>
JS interop: Export accessors; Wasm objects opaque to JS. <tt>externref</tt>.
</p>
<p>
JIT: <a href="https://wingolog.org/archives/2022/08/18/just-in-time-code-generation-within-webassembly">A whole ’nother talk!</a>
</p>
<p>AOT: wasm2c</p>
</div><p>Of course, like I said, WebAssembly is still a weird machine: as a
compilation target but also at run-time.  Debugging is a right proper
mess; perhaps some other article on that some time.</p><p>How to represent strings is a surprisingly gnarly question; there is
tension within the WebAssembly standards community between those that
think that <a href="https://github.com/WebAssembly/stringref/blob/main/proposals/stringref/Overview.md">it&#39;s possible for JavaScript and WebAssembly to share an
underlying string
representation</a>,
and those that think that it&#39;s a fool&#39;s errand and that copying is the
only way to go.  I don&#39;t know which side will prevail; perhaps more on
that as well later on.</p><p>Similarly the whole interoperation with JavaScript question is very much
in its early stages, with the current situation choosing to <a href="https://github.com/WebAssembly/gc/issues/279">err on the
side of nothing rather than the wrong
thing</a>.  You can pass a
WebAssembly <tt>(ref eq)</tt> to JavaScript, but JavaScript can&#39;t do anything
with it: it has no prototype.  The state of the art is to also ship a JS
run-time that wraps each wasm object, proxying exported functions from
the wasm module as object methods.</p><p>Finally, some language implementations really need JIT support, like
PyPy.  There, that&#39;s a whole &#39;nother talk!</p><p>WebAssembly has proven to have some great wins for C, C++, Rust, and so
on -- but now it&#39;s our turn to get in the game.  GC is coming and we as
a community need to be getting our compilers and language run-times
ready.  Let&#39;s put on the coffee and bang some bytes together; it&#39;s still
early days and there&#39;s a world to win out there for the language
community with the best WebAssembly experience.  The game is afoot: happy
consing!</p></div></div></div>
  </body>
</html>
