<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/12/30/quickly-checking-that-a-string-belongs-to-a-small-set/">Original</a>
    <h1>Quickly checking that a string belongs to a small set</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Suppose that I give you a set of reference strings (“ftp”, “file”, “http”, “https”, “ws”, “wss”). Given a new string, you want to quickly tell whether it is part of this set.</p>
<p>You might use a regular expression but it is unlikely to be fast:</p>
<pre>   <span>const</span> std<span>:</span><span>:</span>regex txt_regex<span>(</span><span>&#34;</span><span>(https)|(http)|(ftp)|(file)|(ws)|(wss)</span><span>&#34;</span><span>)</span><span>;</span>

   <span>// later...</span>
   <span>bool</span> match <span>=</span> std<span>:</span><span>:</span>regex_match<span>(</span>v<span>.</span>begin<span>(</span><span>)</span><span>,</span> v<span>.</span>end<span>(</span><span>)</span><span>,</span> txt_regex<span>)</span><span>;</span>
</pre>

<pre><span>static</span> <span>const</span> <span>std</span><span>::</span>unordered_set<span>&lt;</span><span>std</span><span>::</span>string_view<span>&gt;</span> special_set <span>=</span> <span>{</span>
    <span>&#34;</span><span>ftp</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>file</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>http</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>https</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>ws</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>wss</span><span>&#34;</span><span>}</span><span>;</span>

<span>bool</span> hash_is_special<span>(</span><span>std</span><span>::</span>string_view input<span>)</span> <span>{</span>
  <span>return</span> special_set<span>.</span><span>find</span><span>(</span>input<span>)</span> <span>!</span><span>=</span> special_set<span>.</span>end<span>(</span><span>)</span><span>;</span>
<span>}</span>
</pre>

<p>You might also be more direct about it, and just do several comparisons:</p>
<pre><span>bool</span> direct_is_special<span>(</span><span>std</span><span>::</span>string_view input<span>)</span> <span>{</span>
  <span>return</span> <span>(</span>input <span>=</span><span>=</span> <span>&#34;</span><span>https</span><span>&#34;</span><span>)</span> <span>||</span> <span>(</span>input <span>=</span><span>=</span> <span>&#34;</span><span>http</span><span>&#34;</span><span>)</span> <span>|</span><span>|</span> <span>(</span>input <span>=</span><span>=</span> <span>&#34;</span><span>ftp</span><span>&#34;</span><span>)</span> <span>|</span><span>|</span>
         <span>(</span>input <span>=</span><span>=</span> <span>&#34;</span><span>file</span><span>&#34;</span><span>)</span> <span>||</span> <span>(</span>input <span>=</span><span>=</span> <span>&#34;</span><span>ws</span><span>&#34;</span><span>)</span> <span>|</span><span>|</span> <span>(</span>input <span>=</span><span>=</span> <span>&#34;</span><span>wss</span><span>&#34;</span><span>)</span><span>;</span>
<span>}</span>
</pre>

<p>If you look at how the code gets compiled, you may notice that the compiler is forced to do comparisons and jumps, because it is not allowed to read in the provided string beyond its reported size.</p>
<p>You might be able to do slightly better if you can tell your compiler that the string you receive is ‘padded’ so that you can read eight bytes safely from it. I could not find a very elegant way to do it, but the following code works:</p>
<pre><span>static</span> <span>inline</span> uint64_t string_to_uint64<span>(</span><span>std</span><span>::</span>string_view view<span>)</span> <span>{</span>
  uint64_t val<span>;</span>
  <span>std</span><span>::</span><span>memcpy</span><span>(</span><span>&amp;</span>val<span>,</span> view<span>.</span>data<span>(</span><span>)</span><span>,</span> <span>sizeof</span><span>(</span>uint64_t<span>)</span><span>)</span><span>;</span>
  <span>return</span> val<span>;</span>
<span>}</span>

uint32_t string_to_uint32<span>(</span><span>const</span> <span>char</span> <span>*</span>data<span>)</span> <span>{</span>
  uint32_t val<span>;</span>
  <span>std</span><span>::</span><span>memcpy</span><span>(</span><span>&amp;</span>val<span>,</span> data<span>,</span> <span>sizeof</span><span>(</span>uint32_t<span>)</span><span>)</span><span>;</span>
  <span>return</span> val<span>;</span>
<span>}</span>


<span>bool</span> fast_is_special<span>(</span><span>std</span><span>::</span>string_view input<span>)</span> <span>{</span>
  uint64_t inputu <span>=</span> string_to_uint64<span>(</span>input<span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>(</span>inputu <span>&amp;</span> <span>0xffffffffff</span><span>)</span> <span>=</span><span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>https</span><span>\0</span><span>\0</span><span>\0</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> input<span>.</span>size<span>(</span><span>)</span> <span>=</span><span>=</span> <span>5</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>(</span>inputu <span>&amp;</span> <span>0xffffffff</span><span>)</span> <span>=</span><span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>http</span><span>\0</span><span>\0</span><span>\0</span><span>\0</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> input<span>.</span>size<span>(</span><span>)</span> <span>=</span><span>=</span> <span>4</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>uint32_t<span>(</span>inputu<span>)</span> <span>=</span><span>=</span> string_to_uint32<span>(</span><span>&#34;</span><span>file</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> input<span>.</span>size<span>(</span><span>)</span> <span>=</span><span>=</span> <span>4</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>(</span>inputu <span>&amp;</span> <span>0xffffff</span><span>)</span> <span>=</span><span>=</span> string_to_uint32<span>(</span><span>&#34;</span><span>ftp</span><span>\0</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> input<span>.</span>size<span>(</span><span>)</span> <span>=</span><span>=</span> <span>3</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>(</span>inputu <span>&amp;</span> <span>0xffffff</span><span>)</span> <span>=</span><span>=</span> string_to_uint32<span>(</span><span>&#34;</span><span>wss</span><span>\0</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> input<span>.</span>size<span>(</span><span>)</span> <span>=</span><span>=</span> <span>3</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>(</span>inputu <span>&amp;</span> <span>0xffff</span><span>)</span> <span>=</span><span>=</span> string_to_uint32<span>(</span><span>&#34;</span><span>ws</span><span>\0</span><span>\0</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> input<span>.</span>size<span>(</span><span>)</span> <span>=</span><span>=</span> <span>2</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</pre>

<p>Though I did not do it, you can extend the comparison so that it is case-insensitive (simply AND the input with the bytes 0xdf instead of the bytes 0xff).</p>
<p>You can use a faster approach if you can assume that the input string has been padded with zeros:</p>
<pre>  uint64_t inputu <span>=</span> string_to_uint64<span>(</span>input<span>)</span><span>;</span>
  uint64_t https <span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>https\0\0\0</span><span>&#34;</span><span>)</span><span>;</span>
  uint64_t http <span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>http\0\0\0\0</span><span>&#34;</span><span>)</span><span>;</span>
  uint64_t file <span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>file\0\0\0\0</span><span>&#34;</span><span>)</span><span>;</span>
  uint64_t ftp <span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>ftp\0\0\0\0\0</span><span>&#34;</span><span>)</span><span>;</span>
  uint64_t wss <span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>wss\0\0\0\0\0</span><span>&#34;</span><span>)</span><span>;</span>
  uint64_t ws <span>=</span> string_to_uint64<span>(</span><span>&#34;</span><span>ws\0\0\0\0\0\0</span><span>&#34;</span><span>)</span><span>;</span>
  <span>if</span><span>(</span><span>(</span>inputu <span>=</span><span>=</span> https<span>)</span> | <span>(</span>inputu <span>=</span><span>=</span> http<span>)</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>(</span><span>(</span>inputu <span>=</span><span>=</span> file<span>)</span> | <span>(</span>inputu <span>=</span><span>=</span> ftp<span>)</span> 
          | <span>(</span>inputu <span>=</span><span>=</span> wss<span>)</span> | <span>(</span>inputu <span>=</span><span>=</span> ws<span>)</span><span>)</span><span>;</span>
</pre>
<p>Observe how I have selected what I believe are the two most common cases (among URL protocols).</p>
<p>I am sure that there are faster and more clever alternatives!</p>
<p>In any case, how fast are my alternatives? Using GCC 11 on an Intel Ice Lake server, I get the following results:</p>
<table>
<tbody>
<tr>
<td>regex</td>
<td>360 ns/string</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>19 ns/string</td>
</tr>
<tr>
<td>direct</td>
<td>16 ns/string</td>
</tr>
<tr>
<td>fast</td>
<td>2.6 ns/string</td>
</tr>
<tr>
<td>faster</td>
<td>1.9 ns/string</td>
</tr>
</tbody>
</table>
<p>On an Apple M2 with LLVM 12, I get similar (but better) results:</p>
<table>
<tbody>
<tr>
<td>regex</td>
<td>450 ns/string</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>15 ns/string</td>
</tr>
<tr>
<td>direct</td>
<td>7 ns/string</td>
</tr>
<tr>
<td>fast</td>
<td>1.1 ns/string</td>
</tr>
<tr>
<td>faster</td>
<td>0.8 ns/string</td>
</tr>
</tbody>
</table>
<p>Care is needed when optimizing such small functions: whether and how the function gets inlined can be critical to the good performance. The results will depend also on the data source and on the compiler.</p>
<p><a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2022/12/29">My source code is available</a>.</p>
</div></div>
  </body>
</html>
