<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://typeclasses.substack.com/p/the-friendship-between-haskell-and">Original</a>
    <h1>The friendship between Haskell and C</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><span>If ever there were two programming languages said to be at odds with one another, it might be Haskell and C. But this is not so true as it seems; they can play quite nicely with one another. Haskell’s </span><em>foreign function interface</em><span> lets us write Haskell code that uses libraries of other languages — notably, C.</span></p><p><span>As a brief introduction to how Haskell FFI works, I’ll be talking about my </span><a href="https://hackage.haskell.org/package/memfd" rel="nofollow ugc noopener">memfd</a><span> package, which is available on Hackage. This article is part 1 of 2, laying out concepts and motivation. Part 2 will go over the </span><code>memfd</code><span> package, the Linux API that it uses, and how their friendly relationship is expressed in Haskell.</span></p><p>If you want to support my Haskell open source work, one great way is to subscribe to this publication.</p><p><span>The word ‘file’ arises because files are often used for persistent storage like papers in a cabinet. When a process </span><a href="https://hackage.haskell.org/package/unix-2.8.1.0/docs/System-Posix-IO-ByteString.html#g:3" rel="nofollow ugc noopener">opens a file</a><span>, it receives a file descriptor (FD). Conceptually, this is a reference to the file; literally, it is an integer. This integer — only within the context of the process that it belongs to, and only from the time the FD is opened until the time it is closed</span><em> —</em><span> refers to a particular file. The process uses the FD to </span><a href="https://hackage.haskell.org/package/unix-2.8.1.0/docs/System-Posix-IO-ByteString.html#g:4" rel="nofollow ugc noopener">read from or write to</a><span> the file.</span></p><p><span>But we must get past storage cabinets and learn to think of a file more abstractly as an inter-process communication channel. An FD is an integer that, within the context of a process, abstractly identifies </span><em>some resource</em><span>, and there are many kinds of resources. Some examples of file descriptors:</span></p><ul><li><p><span>The </span><a href="https://hackage.haskell.org/package/unix-2.8.1.0/docs/System-Posix-IO-ByteString.html#g:2" rel="nofollow ugc noopener">standard input, output, and error</a><span> streams (</span><code>stdin</code><span>, </span><code>stdout</code><span>, and </span><code>stderr</code><span>) that every process implicitly starts with as FDs 0, 1, and 2. Depending on how the process was initialized, each of these streams might represent a persistent file, or it might represent another process.</span></p></li><li><p><span>When a network client opens </span><a href="https://hackage.haskell.org/package/network-simple-0.4.5/docs/Network-Simple-TCP.html#g:4" rel="nofollow ugc noopener">a connection to a server</a><span>, the server process receives an FD representing the socket that it uses to </span><a href="https://hackage.haskell.org/package/network-simple-0.4.5/docs/Network-Simple-TCP.html#g:6" rel="nofollow ugc noopener">communicate with</a><span> the client.</span></p></li><li><p><span>When a </span><a href="https://wayland-book.com/" rel="nofollow ugc noopener">Wayland</a><span> graphical application starts, it first connects to a </span><a href="https://hackage.haskell.org/package/network-3.1.2.8/docs/Network-Socket.html#g:18" rel="nofollow ugc noopener">UNIX-domain socket</a><span> to initiate contact with the graphics server, receiving a socket FD it will use to send messages such as “a new frame is ready to display.”</span></p></li><li><p>The next thing a Wayland client does is open a file (creating another FD) into which it will write the image data that it wishes to display on screen.</p></li><li><p><span>It then </span><a href="https://hackage.haskell.org/package/network-3.1.2.8/docs/Network-Socket.html#v:sendFd" rel="nofollow ugc noopener">sends that FD over the socket</a><span> to the Wayland server. This results in the creation of yet another FD within the Wayland server process. Both FDs refer to the same file, thus establishing another form of inter-process communication (one that is faster than the socket for transmitting large amounts of graphical data).</span></p></li></ul><p><span>Sockets make the terminology awkward, because a socket is not a </span><em>file</em><span>, but an integer that we use to identify it to it is called a </span><em>file descriptor</em><span> anyway. A socket has a file descriptor that doesn’t correspond to a file. This state of affairs is said to be quite elegant, and perhaps it is, though the nomenclature is just painful.</span></p><p><span>My last three examples of file descriptors all pertained to Wayland because that was my motivation for writing the </span><a href="https://hackage.haskell.org/package/memfd" rel="nofollow ugc noopener">memfd</a><span> package, the discussion of which is forthcoming.</span></p><p><span>In the </span><a href="https://hackage.haskell.org/package/base/docs/System-Posix-Types.html" rel="nofollow ugc noopener">System.Posix.Types</a><span> module of the </span><a href="https://hackage.haskell.org/package/base" rel="nofollow ugc noopener">base</a><span> package, we find the following definition:</span></p><pre><code>newtype Fd = Fd CInt</code></pre><p><span>A file descriptor is, truly, only a number. This is a newtype for </span><a href="https://hackage.haskell.org/package/base/docs/Foreign-C-Types.html#t:CInt" rel="nofollow ugc noopener">CInt</a><span>, which is called a “C Int” because it corresponds to the “int” type in C. This is how we can start to see that Haskell and C are friends; Haskell’s standard library has definitions like this to let us talk about C using C’s own terms.</span></p><p><span>Side note: A </span><a href="https://hackage.haskell.org/package/base/docs/System-IO.html#t:Handle" rel="nofollow ugc noopener">Handle</a><span> is related to but not quite the same as a FD. The </span><code>Handle</code><span> type is what you will generally be using to write cross-platform code; it is in some ways more abstract. The </span><code>Fd</code><span> type is what we use for Unix-specific work. If you need to turn an </span><code>Fd</code><span> into a </span><code>Handle</code><span>, you can use </span><a href="https://hackage.haskell.org/package/unix-2.8.1.0/docs/System-Posix-IO-ByteString.html#g:10" rel="nofollow ugc noopener">fdToHandle</a><span>.</span></p><p><span>The fact that there is more than one type of file system rose to the attention of computer laypersons with the proliferation of floppy disks. When you bought a pack in the store, its label indicated whether it was formatted for PC or Mac (nobody cares about the Linux users). The magnetic disk didn’t come from the store in a truly blank state; it was set up with the initial structure that the computer needs to </span><em>see</em><span> that the disk is blank. Since Microsoft and Apple chose different file systems, slightly different disks were produced for each market segment. Linux users thought this was silly, why didn’t normal people just format the disk for themself when they got it home like we did, why are they outside having fun while we format our disks, and why did they not invite us.</span></p><p>The distinctions between PC/Mac file systems are somewhat trivial, merely differing in implementation details. The overall purpose of them is the same: to arrange data on the disk. If this is all a file system means to you, it’s time to broaden your mind to encompass other kinds:</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Tmpfs" rel="nofollow ugc noopener">tmpfs</a><span> looks like a normal disk file system, but it’s a mirage; this system is backed by volatile storage (RAM) rather than persistent storage. If you need to write a file temporarily but don’t need it file to persist indefinitely, </span><code>tmpfs</code><span> is appropriate because it’s faster. If you need the file to </span><em>not</em><span> persist indefinitely, tmpfs is appropriate because if you forget to clean up your garbage, it will always get cleaned up automatically next time the system restarts.</span></p></li><li><p><a href="https://en.wikipedia.org/wiki/SSHFS" rel="nofollow ugc noopener">sshfs</a><span> also looks like a normal file system, but it’s backed by another file system on another computer. If you can use SSH to access a remote computer, you can use </span><code>sshfs</code><span> to map the remote computer’s files into your own system’s directory tree to pretend like their stuff is yours. It’s pretty neat.</span></p></li><li><p><a href="https://en.wikipedia.org/wiki/Procfs" rel="nofollow ugc noopener">procfs</a><span> isn’t a general-purpose storage system at all, but rather a means of reading information about your computer. It appears in most systems as the </span><code>/proc</code><span> directory, which contains mostly a bunch of text files. For example, </span><code>/proc/meminfo</code><span> shows how much RAM you have, and </span><code>/proc/&lt;process id&gt;/environ</code><span> shows all the environment variables for a running process. I recommend poking around in there some time, because you can find a fascinating amount of stuff.</span></p></li></ul><p><span>Everything I have thus far described as a </span><em>file</em><span> has a file </span><em>path</em><span>. When we create a file, we create it within a directory and with a name. The directory and name together constitute an address by which we can open the file later. The association of a file, a name, and a directory is called a </span><strong>hard link</strong><span>.</span></p><p><span>A somewhat less-considered notion is that a file can have more than one hard link. You can use the </span><a href="https://en.wikipedia.org/wiki/Ln_(Unix)" rel="nofollow ugc noopener">ln</a><span> command-line utility to give a file additional hard links. Doing so does not copy the file, nor does it create a situation wherein one of the paths is the real one and the other merely a pointer (such a pointer is called a </span><em>symbolic</em><span> link). The file is simply linked into the file system in more than one place.</span></p><p><span>The association of a file, a name, and a directory is called a </span><em><strong>hard link</strong></em><span>.</span></p><p><span>One way to delete a file is to use </span><a href="https://en.wikipedia.org/wiki/Unlink_(Unix)" rel="nofollow ugc noopener">unlink</a><span>. (The </span><a href="https://en.wikipedia.org/wiki/Rm_(Unix)" rel="nofollow ugc noopener">rm</a><span> utility is more commonly taught because it has more features, including the ability to delete directories.) But this doesn’t necessarily result in the destruction of the file; it only removes a hard link. If there are other hard links, then the file still exists. Only once a file’s hard link count reaches 0 is the file really gone.</span></p><p><span>No, I lied — A file can exist without any hard links at all. I’ll give a quick demonstration. The following requires </span><a href="https://hackage.haskell.org/package/base" rel="nofollow ugc noopener">base</a><span>, </span><a href="https://hackage.haskell.org/package/directory" rel="nofollow ugc noopener">directory</a><span>, and </span><a href="https://hackage.haskell.org/package/filepath" rel="nofollow ugc noopener">filepath</a><span>.</span></p><pre><code>import Prelude
import System.Directory
import System.FilePath
import System.IO

main = do
    dir &lt;- getTemporaryDirectory      -- 1
    let file = dir &lt;/&gt; &#34;demo.txt&#34;

    h &lt;- openFile file ReadWriteMode  -- 2
    removeFile file

    start &lt;- hGetPosn h               -- 3
    hPutStrLn h &#34;Hello!&#34;

    hSetPosn start                    -- 4
    hGetContents h &gt;&gt;= putStrLn</code></pre><ol><li><p>Look up the system’s default temporary file location and construct a file path.</p></li><li><p><span>Create a file, </span><em>and then immediately unlink it.</em></p></li><li><p>Mark the position at the start of the file, then write a message.</p></li><li><p>Reset the file handle to the start to read back the message and print it.</p></li></ol><p><span>Thus we see that one can go on using a file even after it has been completely removed from the file system. So the real condition under which the operating system can garbage-collect a file is when it has no remaining hard links </span><em>and</em><span> no open file descriptors.</span></p><p><span>The first reason it matters to understand this is to understand the importance of not writing software with </span><a href="https://typeclasses.substack.com/p/what-is-a-leak" rel="nofollow ugc noopener">resource leaks</a><span>. If you have a long-running process that forgets to close a </span><a href="https://hackage.haskell.org/package/base/docs/System-IO.html#t:Handle" rel="nofollow ugc noopener">Handle</a><span> or two, you might think: How big a deal could that possibly be?</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg" rel="nofollow ugc noopener"><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg" width="367" height="243.688" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/a92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:415,&#34;width&#34;:625,&#34;resizeWidth&#34;:367,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;\&#34;It&#39;s one banana, Michael. What could it cost? $10?\&#34;&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;internalRedirect&#34;:null}" alt="&#34;It&#39;s one banana, Michael. What could it cost? $10?&#34;" title="&#34;It&#39;s one banana, Michael. What could it cost? $10?&#34;" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa92527b7-93fd-419a-97f2-163f50fd5490_625x415.jpeg 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p><span>If you were expecting that file to get deleted, what it could cost is however much space that file takes up. As long as you have an open </span><code>Handle</code><span>, the operating system has to keep the entire content of that file until your process ends.</span></p><p><span>That is a good reason to use </span><a href="https://hackage.haskell.org/package/resourcet" rel="nofollow ugc noopener">ResourceT</a><span> in any situation where you’re dealing with a file. (This is the focus of chapter 1 of </span><em><a href="http://typeclasses.com/books/sockets-and-pipes" rel="nofollow ugc noopener">Sockets and Pipes</a></em><span>.)</span></p><p>The second reason that anonymous files are interesting is that they’re not always accidents! Sometimes this is what you want. This is the case for the Wayland example described earlier. A Wayland client creates a file to store its graphics and then sends the file descriptor to the Wayland server. That file now functions as a shared memory region that the client writes to and the server reads from.</p><p><span>There is no reason for such a file to </span><em>ever</em><span> be hard linked!</span></p><p>A common pattern for Wayland applications is to do what I did in the silly example code earlier: Create a file and then immediately delete it. But this is unnecessary, because we can do better.</p><p>I’ll talk about how in part two.</p></div></div></div></article></div></div></div>
  </body>
</html>
