<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kiranrao.ca/2022/05/04/zero-downtime-migrations.html">Original</a>
    <h1>Zero downtime migrations</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
    <time>May 4, 2022</time>
    <p>As a backend developer at a mobile app company, a common task was migrating a database schema.
This could be to improve query performance, change column names/types, or adapt data to new use cases.
While this may seem like a straightforward set of SQL commands, it becomes a complex choreographed dance to be achieved with zero downtime.</p>

<p>The steps are as follows:</p>

<ol>
  <li>Create the new empty table</li>
  <li>Write to both old and new table</li>
  <li>Copy data (in chunks) from old to new</li>
  <li>Validate consistency</li>
  <li>Switch reads to new table</li>
  <li>Stop writes to the old table</li>
  <li>Cleanup old table</li>
</ol>

<p>This guide will go through the step-by-step process of migrating tables in PostgreSQL. While the examples are for a PostgreSQL table migration, the same steps can apply to almost any migration.</p>

<h2 id="background">Background</h2>

<h3 id="existing-schema">Existing Schema</h3>

<p>Let’s suppose we have an existing schema with a table named <code>old</code>, with an API that runs CRUD opretions against the table.</p>

<p><img src="https://kiranrao.ca/assets/migration-old-schema.svg" alt="Old" width="50%"/></p>

<div><div><pre><code><span>CREATE</span> <span>EXTENSION</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>&#34;uuid-ossp&#34;</span><span>;</span>

<span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>old</span> <span>(</span>
    <span>old_id</span> <span>uuid</span> <span>PRIMARY</span> <span>KEY</span> <span>DEFAULT</span> <span>uuid_generate_v4</span><span>(),</span>
    <span>data</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
</code></pre></div></div>

<div><div><pre><code><span>-- Create</span>
<span>INSERT</span> <span>INTO</span> <span>old</span> <span>(</span><span>data</span><span>)</span>
<span>VALUES</span> <span>(</span><span>?</span><span>)</span>
<span>RETURNING</span> <span>*</span><span>;</span>

<span>-- Read</span>
<span>SELECT</span> <span>*</span>
<span>FROM</span> <span>old</span>
<span>WHERE</span> <span>old_id</span> <span>=</span> <span>?</span><span>;</span>

<span>-- Update</span>
<span>UPDATE</span> <span>old</span>
<span>SET</span> <span>data</span> <span>=</span> <span>?</span>
<span>WHERE</span> <span>old_id</span> <span>=</span> <span>?</span><span>;</span>

<span>-- Delete</span>
<span>DELETE</span>
<span>FROM</span> <span>old</span>
<span>WHERE</span> <span>old_id</span> <span>=</span> <span>?</span><span>;</span>
</code></pre></div></div>

<h3 id="desired-schema">Desired schema</h3>

<p>The <code>data</code> column was type <code>TEXT</code> for flexibility.
It is now used exclusively for timestamps.
We then get a request from Product on a hot codepath to count all entries between 2 timestamps.
While this is possible with the current schema, we decided a better approach would be to update <code>data</code> to be of type <code>TIMESTAMP</code>.
In addition, <code>old</code> is no longer an accurate name, and that <code>new</code> would be a lot better.</p>

<p>Our desired schema is:</p>

<p><img src="https://kiranrao.ca/assets/migration-new-schema.svg" alt="New schema" width="50%"/></p>

<div><div><pre><code><span>CREATE</span> <span>EXTENSION</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>&#34;uuid-ossp&#34;</span><span>;</span>

<span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>new</span> <span>(</span>
    <span>new_id</span> <span>uuid</span> <span>PRIMARY</span> <span>KEY</span> <span>DEFAULT</span> <span>uuid_generate_v4</span><span>(),</span>
    <span>created_date</span> <span>TIMESTAMP</span> <span>WITH</span> <span>TIME</span> <span>ZONE</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
</code></pre></div></div>

<h3 id="migration-requirements">Migration Requirements</h3>

<p>We can further specify the requirements through the migration:</p>

<ul>
  <li>The system must fully respond to requests throughout the migration process</li>
  <li>No action can take a <a href="https://www.postgresql.org/docs/current/explicit-locking.html" target="\_blank">write lock</a> against a significant percentage of the table</li>
  <li>No <a href="https://leopard.in.ua/2016/09/20/safe-and-unsafe-operations-postgresql" target="\_blank">unsafe operations</a></li>
  <li>We must be able to roll back any changes to the previous step if we encounter issues</li>
</ul>

<h2 id="procedure">Procedure</h2>

<h3 id="create-a-new-empty-table">Create a new, empty table</h3>

<p><img src="https://kiranrao.ca/assets/migration-new-table.svg" alt="Create a new table" width="50%"/></p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>new</span> <span>(</span>
    <span>new_id</span> <span>uuid</span> <span>PRIMARY</span> <span>KEY</span> <span>DEFAULT</span> <span>uuid_generate_v4</span><span>(),</span>
    <span>created_date</span> <span>TIMESTAMP</span> <span>WITH</span> <span>TIME</span> <span>ZONE</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
</code></pre></div></div>

<h3 id="write-to-both-tables">Write to both tables</h3>

<p>Now that we have two tables, we write to both simultaneously. While the <code>old</code> table remains the source of truth, we are setting ourselves up to be <a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="\_blank">eventually consistent</a>.</p>

<p><img src="https://kiranrao.ca/assets/migration-write-both.svg" alt="Write to both tables" width="50%"/></p>

<div><div><pre><code><span>-- Create</span>
<span>WITH</span> <span>new_rows</span> <span>AS</span> <span>(</span>
    <span>INSERT</span> <span>INTO</span> <span>new</span> <span>(</span><span>created_date</span><span>)</span>
    <span>VALUES</span> <span>(</span><span>?</span><span>)</span>
    <span>RETURNING</span> <span>*</span>
<span>)</span>
<span>INSERT</span>
<span>INTO</span> <span>old</span> <span>(</span><span>old_id</span><span>,</span> <span>data</span><span>)</span>
<span>SELECT</span> <span>new_id</span><span>,</span> <span>CAST</span><span>(</span><span>created_date</span> <span>AS</span> <span>TEXT</span><span>)</span>
<span>FROM</span> <span>new_rows</span>
<span>RETURNING</span> <span>*</span><span>;</span>

<span>-- Update</span>
<span>UPDATE</span> <span>old</span>
<span>SET</span> <span>data</span> <span>=</span> <span>?</span>
<span>WHERE</span> <span>old_id</span> <span>=</span> <span>?</span><span>;</span>

<span>UPDATE</span> <span>new</span>
<span>SET</span> <span>created_date</span> <span>=</span> <span>?</span>
<span>WHERE</span> <span>new_id</span> <span>=</span> <span>?</span><span>;</span>


<span>-- Delete</span>
<span>DELETE</span>
<span>FROM</span> <span>old</span>
<span>WHERE</span> <span>old_id</span> <span>=</span> <span>?</span><span>;</span>

<span>DELETE</span>
<span>FROM</span> <span>new</span>
<span>WHERE</span> <span>new_id</span> <span>=</span> <span>?</span><span>;</span>
</code></pre></div></div>

<p>Note that our create operation appears slightly more complex than before.
We are creating a row in the new table, then using the record to populate the values of the old table.
This is all done in a single transaction to ensure our randomly generated UUIDs are in sync.</p>

<h3 id="copy-data-to-new-table">Copy data to new table</h3>

<p>Once we know that all new records will be replicated, we can start copy old records.</p>

<p><img src="https://kiranrao.ca/assets/migration-copy-data.svg" alt="Replicate data between tables" width="50%"/></p>

<div><div><pre><code><span>INSERT</span> <span>INTO</span> <span>new</span><span>(</span><span>new_id</span><span>,</span> <span>created_date</span><span>)</span>
<span>SELECT</span> <span>old_id</span><span>,</span> <span>CAST</span><span>(</span><span>data</span> <span>AS</span> <span>TIMESTAMP</span><span>)</span>
<span>FROM</span> <span>OLD</span>
<span>WHERE</span> <span>NOT</span> <span>EXISTS</span><span>(</span><span>SELECT</span> <span>*</span>
                 <span>FROM</span> <span>new</span>
                 <span>WHERE</span> <span>new_id</span> <span>=</span> <span>OLD</span><span>.</span><span>old_id</span><span>)</span>
<span>LIMIT</span> <span>1000</span>
<span>RETURNING</span> <span>*</span><span>;</span>
</code></pre></div></div>

<p>We are inserting values into the <code>new</code> table from the <code>old</code> table that don’t yet exist in <code>new</code>.
To keep the database responsive, we split the operation using <code>limit 1000</code>.
While chunk size can be tuned up or down depending on the table, I prefer smaller chunks to avoid large write locks.</p>

<h3 id="validate-consistency">Validate consistency</h3>

<p>The often overlooked step. Before we switch over the reads, we should ensure that our data is fully in sync between tables.
Here are a few sample queries to validate consistency between <code>old</code> and <code>new</code>.</p>

<p>Are we missing any records?</p>

<div><div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> <span>old</span>
    <span>FULL</span> <span>OUTER</span> <span>JOIN</span> <span>new</span> <span>ON</span> <span>old_id</span> <span>=</span> <span>new_id</span>
<span>WHERE</span> <span>new_id</span> <span>IS</span> <span>NULL</span>
   <span>OR</span> <span>old_id</span> <span>IS</span> <span>NULL</span>
</code></pre></div></div>

<p>Is any data inconsistent?</p>

<div><div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> <span>old</span>
    <span>INNER</span> <span>JOIN</span> <span>new</span> <span>ON</span> <span>old_id</span> <span>=</span> <span>new_id</span>
<span>WHERE</span> <span>CAST</span><span>(</span><span>data</span> <span>AS</span> <span>TIMESTAMP</span><span>)</span> <span>&lt;&gt;</span> <span>created_date</span>
</code></pre></div></div>

<h3 id="switch-reads">Switch reads</h3>

<p>This is usually the most burdensome step.
There are often dozens of different codepaths reading from the table.
Since that data is in sync between tables, we can take our time with this part of the migration.</p>

<p><img src="https://kiranrao.ca/assets/migration-switch-reads.svg" alt="Switch reads" width="50%"/></p>

<div><div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> <span>new</span>
<span>WHERE</span> <span>new_id</span> <span>=</span> <span>?</span><span>;</span>
</code></pre></div></div>

<p>This stage is where we’d update any views, foreign keys, triggers, etc to reference the new table.</p>

<h3 id="stop-writes">Stop writes</h3>

<p>Now that we’ve switched all reads over to the new system, we no longer need to update the old database.</p>

<p><img src="https://kiranrao.ca/assets/migration-drop-writes.svg" alt="Drop writes" width="50%"/></p>

<div><div><pre><code><span>-- Create</span>
<span>INSERT</span> <span>INTO</span> <span>new</span> <span>(</span><span>created_date</span><span>)</span>
<span>VALUES</span> <span>(</span><span>?</span><span>)</span>
<span>RETURNING</span> <span>*</span>

<span>-- Update</span>
<span>UPDATE</span> <span>new</span>
<span>SET</span> <span>created_date</span> <span>=</span> <span>?</span>
<span>WHERE</span> <span>new_id</span> <span>=</span> <span>?</span><span>;</span>

<span>-- Delete</span>
<span>DELETE</span>
<span>FROM</span> <span>new</span>
<span>WHERE</span> <span>new_id</span> <span>=</span> <span>?</span><span>;</span>
</code></pre></div></div>

<h3 id="cleanup-table">Cleanup table</h3>

<p>When we’re confident that our system no longer references the old table, we can drop it.</p>

<p><img src="https://kiranrao.ca/assets/migration-new-schema.svg" alt="New schema" width="50%"/></p>

<div><div><pre><code><span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>old</span><span>;</span>
</code></pre></div></div>

<h2 id="done">Done</h2>

<p>Congratulations! Migration Complete!</p>

<p><img src="https://kiranrao.ca/assets/its_done.gif" alt="It&#39;s done GIF"/></p>

<p>Now the most challenging part: explaining to Product why their seemingly small request took 3x longer than expected. If it helps you can send them this article. Good luck!</p>

  </article>
</div></div>
  </body>
</html>
