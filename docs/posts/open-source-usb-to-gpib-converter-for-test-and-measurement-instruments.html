<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/xyphro/UsbGpib">Original</a>
    <h1>Open source USB to GPIB converter (for Test and Measurement instruments)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">ðŸ“° <a href="https://github.com/xyphro/UsbGpib/blob/master/Updates.md">Latest updates</a>
</p>

<p dir="auto">For detailed visibility look under the Latest update link above!</p>
<p dir="auto">[30th Nov 2025]: <strong>Released new firmware version V2.2</strong>. See <a href="https://github.com/xyphro/UsbGpib/blob/master/Updates.md">Latest updates</a> section.
[23rd Nov 2025]: Added a User manual for UsbGPIB V2 under the Tutorial section</p>

<p dir="auto">As I have an outstanding Betatestprogram for V3 I want to share some updates - on this main page.</p>
<p dir="auto">Here the &#34;messy table view&#34; during some later software development :-)</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/xyphro/UsbGpib/blob/master/pictures/V3SneakPreview.png?raw=true"><img src="https://github.com/xyphro/UsbGpib/raw/master/pictures/V3SneakPreview.png?raw=true" width="60%"/></a></p>
<p dir="auto">The schedule slipped a bit while getting the V2 adapter ready for sale, but V3 is converging and nearing completion. A batch of prototypes has been ordered with CNC aluminum housings, anodizing, and laser marking.</p>
<p dir="auto">Progress:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Item</th>
<th>Comment &amp; State</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hardware</td>
<td>Optimized after two extra iterations; GPIB-compliant electrical characteristics; prevents back-powering from device GPIB bus</td>
</tr>
<tr>
<td>POE</td>
<td>Fully works. Challenging to get right, but finally working well and cost optimized</td>
</tr>
<tr>
<td>Mechanics</td>
<td>Six (!) 3D designs completed; 3D-printed housings with/without Ethernet; CNC machined housing prototypes ordered</td>
</tr>
<tr>
<td>GPIB stack</td>
<td>Fully up and running and &#34;ruggedized&#34;</td>
</tr>
<tr>
<td>USB Boot loader</td>
<td>Complete; UF2-like workflow for easy use without special software and tested functionality with Mac, Windows, Linux</td>
</tr>
<tr>
<td>USB high speed functionality</td>
<td>New MCU USB stack written from scratch for low latency and high throughput</td>
</tr>
<tr>
<td>USBTMC</td>
<td>USBTMC part fully works and passes several compliance / stress tests</td>
</tr>
<tr>
<td>Ethernet</td>
<td>Ethernet stack and low level driver is fully done and ready</td>
</tr>
<tr>
<td>VXI11 &amp; HiSlip</td>
<td>VXI11 mostly complete with ongoing optimizations; HiSlip near finalization with minor polish remaining</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">The prototypes will arrive approximately end of January.
Very keen on bringing them up and distributing!</p>
<hr/>

<p dir="auto">Tired of tinkering? Want to skip the hassle and get straight to using your GPIB setup?</p>
<ul dir="auto">
<li>Iâ€™ve teamed up with Elecrow to bring you ready-to-roll GPIB-USB converters â€“ perfect for those who want results, not a weekend project.</li>
<li>These adapters come fully assembled, programmed, housed, tested, and ready to go. No fuss. No build. Just plug it in and start working.</li>
<li>The Adapters match 100% the V2 version described in this repository.</li>
</ul>
<p dir="auto"><strong>Grab yours now:</strong> <a href="https://www.elecrow.com/xyphrolabs-gpibusb.html" rel="nofollow"></a><a href="https://www.elecrow.com/xyphrolabs-gpibusb.html" rel="nofollow">https://www.elecrow.com/xyphrolabs-gpibusb.html</a></p>
<p dir="auto">Let the data flow begin!</p>
<p dir="auto">This doesnâ€™t mean Iâ€™m going fully commercial - far from it.
Offering pre-built adapters is simply a convenience for those whoâ€™d rather skip the build and get straight to using their gear.</p>
<p dir="auto">All sharing, support, and collaboration will remain fully open, just as before.
This is about choice, not change!</p>
<p dir="auto">The full design files are located in this repository in case you want to build the devices yourself.</p>
<hr/>

<p dir="auto">Versatile, cheap, portable and robust USB to GPIB converter (USBTMC class based).</p>
<p dir="auto">You&#39;ll find many projects like this, but this one is special (ok, everybody will claim this) :-)</p>
<p dir="auto">V1 Hardware:
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/UsbGPIB.jpg"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/UsbGPIB.jpg" width="50%"/></a></p>
<p dir="auto">V2 Hardware:
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/Upcoming_Rev2.png"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/Upcoming_Rev2.png" width="50%"/></a></p>
<p dir="auto">If you have a lot of test equipment at home, you might know the issues: Lots of devices only have GPIB as interface and the GPIB adapters and GPIB cables on the market are very expensive and some of them even have many issues, when run under Windows 10 (device driver does not work). Or they e.g. are not able to be operated with VISA, because they are UART based, need special command sequences, ...</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/SizeComparison.jpg"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/SizeComparison.jpg" width="40%"/></a></p>
The adapters are also typically very long, such that they extend the overall length of your test equipment by at least 10cm (~4 inches).
<p dir="auto">Apart of the 2 very big manufacturers, other GPIB adapters, e.g. with Ethernet or also USB interface are not recognized by normal VISA providers or PyVisa, making the measurement control implementation specific for your GPIB adapter.</p>
<p dir="auto">I&#39;ve got frustrated and tried to turn it into something positive. Here a video showing the final device in action - click to view:</p>
<p dir="auto"><a href="https://www.youtube.com/watch?v=pZp1QZCXrF8" rel="nofollow"><img src="https://camo.githubusercontent.com/6a01fcdef70d3788cbed2fa56192ddc2237c0213b8bc6ff54af353611be19348/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f705a7031515a43587246382f302e6a7067" alt="" data-canonical-src="https://img.youtube.com/vi/pZp1QZCXrF8/0.jpg"/></a></p>
<p dir="auto">Some goals of the project were:</p>
<ul dir="auto">
<li>Work based on the standard USBTMC protocol. This allows the GPIB test equipment to look like a normal USB based measurement device and work flawless with e.g. NI VISA, Labview, Matlab or PyVisa.</li>
<li>Have a small length - otherwise my equipment has the risk of falling from the shelf :-) Also the USB cable should connect 90 degree angled, to make it very short. With V2 HW, the length got further reduced to the size of a GPIB connector.</li>
<li>It should be cheap but still versatile (you can build a single one of these for only 14 USD!)</li>
<li>It should support ALL my test equipment, from many different GPIB implementation generations and different GPIB flavors</li>
<li>The Firmware should be upgradeable over USB</li>
<li>It should be rock-solid (!) I don&#39;t want to end up in a very long measurement being interrupted because of a software issue of my USB GPIB converter.</li>
<li>It should support additional features like serial poll, remote enabling/disabling</li>
<li>If there is no GPIB device connected to the USBGpib converter, or the GPIB device is powered down, there should be no USB device visible on the PC.</li>
</ul>
<p dir="auto">All those goals are met.</p>
<hr/>


<p dir="auto">Although I typically would prefer nowadays an ARM Cortex M0/3/4/7 controller, there is an issue with it. Available devices support only max. 3.3V supply voltages, such that there would be a requirement for a level-shifter towards the GPIB Bus.
GPIB is based on 5V (not exactly true, but a first iteration).</p>
<p dir="auto">This limited the microcontroller choice to e.g. AVR or PIC controllers. Because of very good availability I ended up in ATMEGA32U4 controllers.
Apart of the device supporting 5V I/O voltages, it also does not require a regulator to be part of the application - it has an internal 3.3V regulator. This minimizes the full application schematic and BOM.</p>
<p dir="auto">Apart from that, there is an excellent USB stack available <a href="http://www.fourwalledcubicle.com/LUFA.php" rel="nofollow">http://www.fourwalledcubicle.com/LUFA.php</a>.</p>
<p dir="auto">The GPIB side of the schematic can be directly connected to the ATMega32U4 IO pins. The IO pins from the microcontroller side are only set to 2 different states: Tri-state (input) or output LOW, to talk over GPIB.</p>

<p dir="auto">All components are easy to source, so I only specify the potential critical ones:</p>
<ul dir="auto">
<li>16 MHz Crystal: Farnell 2853867 - MCSJK-7E-16.00-8-30-100-B-30</li>
<li>REV 1 GPIB connector: Farnell 2421095 - NORCOMP 112-024-113R001. For REV 2 use a straight 24P male solder type connector e.g. from AliExpress.</li>
<li>USB connector for V1 HW: Farnell 2668483 - Amphenol ICC 61729-1011BLF</li>
<li>USB connector for V2 HW: Best is to look on AliExpress for 57 series 24P connector as a starting point.</li>
</ul>

<p dir="auto">The PCB can be ordered at nearly any PCB pool production service (e.g. 10 PCBs for 2 USD + shipping). The gerber files are included in the &#34;HW/Gerber files&#34; subdirectory.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Mounting the PCB &amp; Flashing the firmware</h2><a id="user-content-mounting-the-pcb--flashing-the-firmware" aria-label="Permalink: Mounting the PCB &amp; Flashing the firmware" href="#mounting-the-pcb--flashing-the-firmware"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The PCB is available in 2 revisions.</p>
<ul dir="auto">
<li><a href="https://github.com/xyphro/UsbGpib/blob/master/HW/REV1/README.md">REV 1</a> is the most popularly used right now due to age. It has a USB Type-B connector and an L-shaped housing visible on a few photos of this page.</li>
<li><a href="https://github.com/xyphro/UsbGpib/blob/master/HW/REV2/README.md">REV 2</a> has some improvements like being smaller, better fit and USB Type-C connector.</li>
<li>A REV 3 is upcoming. It will be a major redesign with more speed, Ethernet and power over Ethernet support, but the same DNA: Standard protocols being used and ensure compatibility and stability!</li>
</ul>
<p dir="auto">Choose whatever you prefer. The software images, but also the external behavior is the same.</p>
<hr/>


<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/housing.png"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/housing.png" width="33%"/></a><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/housing_snap.png"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/housing_snap.png" width="50%"/></a></p>
<p dir="auto">I created a sophisticated 3D printable housing for this adapter. The design was made with Fusion 360. The project file + the STL files are included in the &#34;Housing&#34; sub directory.</p>
<p dir="auto">The PCB fits perfectly into it. Optionally it can be fixed with 2 mounting screws (the GPIB connector has 2 threads, use 2 times 4-40 UNC x 3/8) and the TOP cover snaps onto the housing base.</p>
<p dir="auto">I printed this using an Ender 5 3D printer with black PLA, 0.15mm layer height, 1mm wall thickness, no support.
Take care, that you rotate the TOP part of the housing by 180 degrees, so that the flat side is located on the printer bed.
Printing works fine, several iterations of the design were made to ensure good printability.
I printed so far 15 housings, without a single fail.</p>
<p dir="auto">More information on this REV 1 can be found here: <a href="https://github.com/xyphro/UsbGpib/blob/master/HW/REV1/README.md">REV 1</a>.
Note, that also the programming/build instructions moved to this location.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/Upcoming_Rev2.png"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/Upcoming_Rev2.png" width="40%"/></a></p>
<p dir="auto">The REV 2 housing is a lot smaller, but requires 2 screws.
The housing is quite important to be able to connect and disconnect the board without breaking anything. It is key for mechanical stability of the adapter.
When operating the device without housing, take very well care when plugging in and out the board in case the GPIB connector has a very tight fit.</p>
<p dir="auto">Information on how to build it can be found in the HW/REV 2 folder: <a href="https://github.com/xyphro/UsbGpib/blob/master/HW/REV2/README.md">REV 2</a>.
Note, that also the programming/build instructions moved to this location.</p>
<hr/>


<p dir="auto">The source code of the Boot loader (slightly modified LUFA MassStorage Boot loader) and the main USBGPIB converter are located in the &#34;SW&#34; subdirectory.
At the time of publication LUFA 170418 release was used, with GCC as compiler.</p>
<p dir="auto">Note: The Software is compatible with any HW revision in this repository. For REV 1 and REV 2 hardware you don&#39;t need different SW images.</p>

<p dir="auto">For those, that just want to create their own device, I&#39;ve included the binary output in the &#34;SW/binaries&#34; subdirectory.</p>
<hr/>


<p dir="auto">You might be surprised initially, that the device does not show up in your device manager (or lsusb), when you connect only the USB side. This is a feature, not a bug (really!).
Only, if a GPIB device is connected, you can see the device on your PC too.</p>
<p dir="auto">The reason behind the feature is simple: Instead of having a standard GPIB wiring, where you have a single GPIB controller and lots of GPIB devices interconnected, USBGPIB supports only a direct connection of the USBGPIB device to your measurement device. If you have like me e.g. 14 Instruments you don&#39;t want all to show up in the device manager, if the measurement device itself is powered down - you won&#39;t anyway be able to communicate with a powered down device.</p>
<p dir="auto">When USB and the GPIB side is connected, the device enumerates. The USBGPIB device reads out the ID of the instrument and constructs a unique USB Serial number out of it. It is thus easily possible to assiate multiple connected USBGPIB devices with the measurement instrument.</p>
<p dir="auto">The VISA ressource name is constructed from this USB Serial number. You can identify easily e.g. in NiMax, which device is connected:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/NiMaxExample.png"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/NiMaxExample.png" width="90%"/></a></p>
<p dir="auto">If you connect your USBGPIB device afterwards to another GPIB measurement device, it will disconnect and connect with a new serial number string, matching the other GPIB device *IDN? response again.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">GPIB settings on your measurement device</h2><a id="user-content-gpib-settings-on-your-measurement-device" aria-label="Permalink: GPIB settings on your measurement device" href="#gpib-settings-on-your-measurement-device"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">GPIBUSB does probe all GPIB primary addresses (and secondary address 0) for presence of a GPIB Talker/listener. It is thus not required to set a specific GPIB address - GPIBUSB will find it itself.</p>
<p dir="auto">The only importance setting on the measurement device is, that the GPIB interface is enabled, which is typically the case.</p>

<p dir="auto">The LED indicates different states:</p>
<p dir="auto">LED blinking: The USBGPIB converter is connected to a measurement instrument, it is powered off or its GPIB port is disabled. In this state, the device is also not connected to USB and will not show up in the device manager or lsusb.
LED on: The device is connected to a measurement device and GPIB communication possible. It is also accessible over USB
LED off: The device is not connected over USB, or the PC powered off :-)</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/towerOfGpib.jpg"><img src="https://raw.githubusercontent.com/xyphro/UsbGpib/master/pictures/towerOfGpib.jpg" width="30%"/></a></p>
<p dir="auto">As this converter implements the standard USBTMC Test and measurement class, you can control your instrument from ANY of the normal VISA tools. I tried so far R&amp;S VISA and NI Visa, using Python and Matlab to talk to the devices.</p>

<p dir="auto">This project is actively maintained since more than 6 years and I personally consider it as very stable. It is proven by multiple users to operate on MacOSX, Linux and Windows and measurement equipment from several decades.</p>
<p dir="auto">In general I take bug reports very serious and want to &#34;fix them all&#34;. In case you don&#39;t get an answer on-time on items you report in the issues section, please write me: <a href="mailto:Xyphro@gmail.com">Xyphro@gmail.com</a>.
I often miss seeing issue reports very quickly, as I don&#39;t get an email once they are filed.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Sucessfully tested measurement equipment:</h2><a id="user-content-sucessfully-tested-measurement-equipment" aria-label="Permalink: Sucessfully tested measurement equipment:" href="#sucessfully-tested-measurement-equipment"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Below list is equipment I mainly myself tested. Many other users have other measurement equipment proven in use already.</p>
<ul dir="auto">
<li>R&amp;S FSEM30</li>
<li>R&amp;S SMIQ03</li>
<li>R&amp;S CMU200</li>
<li>R&amp;S SMW200A</li>
<li>R&amp;S FSW</li>
<li>R&amp;S FSV</li>
<li>Keithley 199 multimeter</li>
<li>HP 34401 DMM from different generations / with different FW versions</li>
<li>HP 3325A synthesizer/frequency generator</li>
<li>HP 3457A multimeter</li>
<li>Agilent E4406A VSA transmitter tester</li>
<li>Tektronix TDS7104 Digital Phosphor Oscilloscope</li>
<li>HP 8596A spectrum analyzer</li>
<li>Agilent E3648A dual power supply</li>
</ul>

<ul dir="auto">
<li>It works under all popular operating systems like Windows 7 and 10, 11, Linux and MacOSX</li>
<li>USB1.1, USB2.0 and USB3.x ports tested, with and without USB HUB in between.</li>
<li>The connection stays responsive, when power cycling the PC, or hibernating/sleeping it</li>
<li>Different connection cycles (GPIB side connected first, USB side connected first, swapping GPIB side equipment, ...)</li>
<li>Extensive testing of timeout scenarious. E.g. making an illegal query and testing, if the USBTMC handles the timeouts properly. This was a very tricky part to get right.</li>
<li>Tested special transfer modes. E.g. capturing screenshots from different equipment is usually something, which will drive other GPIB adapters to the limits, because binary data of unknown length needs to be transported successfully.</li>
</ul>

<p dir="auto">The firmware version from 13th January 2024 onwards has the ability for human readable text base configuration of several parameters.
The previous methods are still supported, but won&#39;t be further documented. You can look them back in the history of this file.</p>
<p dir="auto">The command parser is quite simple. For that reason follow the exact syntax as shown below.
Don&#39;t add extra spaces or make other modifications or concatenate commands.</p>

<p dir="auto">While most GPIB interfaces use the hardware signal EOI to signal the end of a message, not all old equipment supports it. Some older instruments even don&#39;t have the EOI pin hardware wise wired and use \r or \n termination.</p>
<p dir="auto">The USB-TMC standard allows to set the read termination. While in firmware versions before &lt; 2.0 I did not enable that method, it is now finally supported with standard compliance.</p>
<p dir="auto">I document here the older method (using pulse indicator request), but I add also the newer methods which are 100% UsbTmc compliant and portable across different equipments. You can choose which ones to use, but in some cases pulse indicator requests can be difficult to issue, for which reason it is likely better to use the standard compliant method.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Set read termination to CR (\r):</h3><a id="user-content-set-read-termination-to-cr-r" aria-label="Permalink: Set read termination to CR (\r):" href="#set-read-termination-to-cr-r"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">(old method)</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term cr&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term cr&#39;)
</code></pre></div>
<p dir="auto">Above setting is volatile. To make this a permanent setting call the below mentioned &#34;!term store&#34; command.</p>
<p dir="auto">(prefered method) Alternatively you can set the termination directly with visa means, e.g. using PyVisa:</p>
<div data-snippet-clipboard-copy-content="dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR_EN, True)
dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR, ord(&#39;\r&#39;) )"><pre><code>dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR_EN, True)
dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR, ord(&#39;\r&#39;) )
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Set read termination to LF (\n):</h3><a id="user-content-set-read-termination-to-lf-n" aria-label="Permalink: Set read termination to LF (\n):" href="#set-read-termination-to-lf-n"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">(old method)</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term lf&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term lf&#39;)
</code></pre></div>
<p dir="auto">Above setting is volatile. To make this a permanent setting call the below mentioned &#34;!term store&#34; command.</p>
<p dir="auto">(prefered method) Alternatively you can set the termination directly with visa means, e.g. using PyVisa:</p>
<div data-snippet-clipboard-copy-content="dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR_EN, True)
dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR, ord(&#39;\n&#39;) )"><pre><code>dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR_EN, True)
dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR, ord(&#39;\n&#39;) )
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Set read termination to EOI only (default setting):</h3><a id="user-content-set-read-termination-to-eoi-only-default-setting" aria-label="Permalink: Set read termination to EOI only (default setting):" href="#set-read-termination-to-eoi-only-default-setting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">(old method)</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term eoi&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term eoi&#39;)
</code></pre></div>
<p dir="auto">Above setting is volatile. To make this a permanent setting call the below mentioned &#34;!term store&#34; command.</p>
<p dir="auto">(prefered method) Alternatively you can set the termination directly with visa means, e.g. using PyVisa:</p>
<div data-snippet-clipboard-copy-content="dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR_EN, False)
dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR, ord(&#39;\0&#39;) )"><pre><code>dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR_EN, False)
dev.set_visa_attribute(visa.constants.VI_ATTR_TERMCHAR, ord(&#39;\0&#39;) )
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Save readtermination setting in eeprom (make them non-volatile)</h3><a id="user-content-save-readtermination-setting-in-eeprom-make-them-non-volatile" aria-label="Permalink: Save readtermination setting in eeprom (make them non-volatile)" href="#save-readtermination-setting-in-eeprom-make-them-non-volatile"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term store&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!term store&#39;)
</code></pre></div>
<p dir="auto">Above relates to the &#34;old non prefered method&#34;. In general it is a good idea to set the read termination volatile and use the above suggested methods highlighted with (prefered method).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Query current termination setting from device</h3><a id="user-content-query-current-termination-setting-from-device" aria-label="Permalink: Query current termination setting from device" href="#query-current-termination-setting-from-device"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
print(dev.query(&#39;!term?&#39;))"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
print(dev.query(&#39;!term?&#39;))
</code></pre></div>
<p dir="auto">This returns a text string containing &#34;lf&#34;, &#34;cr&#34; or &#34;eoi&#34;</p>

<p dir="auto">Default wise the GPIB adapter tries during power on of the instrument to query using *IDN? or ID? commands the instrument name automatically.
This is used to build the USB serial number, which finally gets part of the VISA ressource string.</p>
<p dir="auto">Not all instruments support this *IDN / ID? query. For this reason this feature can be turned off.
The serial number will then be built based on the GPIB address of the instrument.</p>

<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid off&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid off&#39;)
</code></pre></div>
<p dir="auto">This setting is stored in eeprom = non volatile memory, so will survive a power cycle</p>

<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid on&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid on&#39;)
</code></pre></div>
<p dir="auto">This setting is stored in eeprom = non volatile memory, so will survive a power cycle</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">turn auto ID on with delay</h3><a id="user-content-turn-auto-id-on-with-delay" aria-label="Permalink: turn auto ID on with delay" href="#turn-auto-id-on-with-delay"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Some instruments need after turn on some seconds before GPIB is responsive.</p>
<p dir="auto">With below 3 settings you can set a delay which is applied before the instrument ID is queried after power on.
Note that it will take then also more time, before the USB device is recognized by the PC.</p>
<p dir="auto">Also this setting is non-volatile.</p>
<p dir="auto">Delay 5 seconds:</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid slow&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid slow&#39;)
</code></pre></div>
<p dir="auto">Delay 15 seconds:</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid slower&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid slower&#39;)
</code></pre></div>
<p dir="auto">Delay 30 seconds:</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid slowest&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!autoid slowest&#39;)
</code></pre></div>

<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # 
print(dev.query(&#39;!autoid?&#39;))"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # 
print(dev.query(&#39;!autoid?&#39;))
</code></pre></div>
<p dir="auto">Returns as text string either: &#34;off&#34;, &#34;on&#34;, &#34;slow&#34;, &#34;slower&#34; or &#34;slowest&#34;.</p>

<p dir="auto">Finally I implemented a command to query the USB adapters firmware version :-)</p>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
print(dev.query(&#39;!ver?&#39;))"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
print(dev.query(&#39;!ver?&#39;))
</code></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Shorten ressource strings (Matlab)</h2><a id="user-content-shorten-ressource-strings-matlab" aria-label="Permalink: Shorten ressource strings (Matlab)" href="#shorten-ressource-strings-matlab"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A user discovered that Matlab has a limitation in the VISA ressource string length and shared a pull request to reduce the length.
I expose this now first time in the baseline firmware with the following options.</p>
<p dir="auto">This setting is stored in eeprom = non volatile.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Limit the USB serial number to a length of 20 characters</h3><a id="user-content-limit-the-usb-serial-number-to-a-length-of-20-characters" aria-label="Permalink: Limit the USB serial number to a length of 20 characters" href="#limit-the-usb-serial-number-to-a-length-of-20-characters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!string short&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!string short&#39;)
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">disable limitation of USB serial number length (default behavior)</h3><a id="user-content-disable-limitation-of-usb-serial-number-length-default-behavior" aria-label="Permalink: disable limitation of USB serial number length (default behavior)" href="#disable-limitation-of-usb-serial-number-length-default-behavior"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!string normal&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
dev.write(&#39;!string normal&#39;)
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">query the string length setting.</h3><a id="user-content-query-the-string-length-setting" aria-label="Permalink: query the string length setting." href="#query-the-string-length-setting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
print(dev.query(&#39;!string?&#39;))"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); # USBTMC pulse indicator request (enables internal command processing)
print(dev.query(&#39;!string?&#39;))
</code></pre></div>
<p dir="auto">This returns as text string either &#34;normal&#34; or &#34;short&#34;.</p>

<div data-snippet-clipboard-copy-content="dev.control_in(0xa1, 0x40, 0, 0, 1); 
dev.write(&#39;!reset&#39;)"><pre><code>dev.control_in(0xa1, 0x40, 0, 0, 1); 
dev.write(&#39;!reset&#39;)
</code></pre></div>
<p dir="auto">Do a reset of the adapter. Note that due to the reset you have to close the visa session and start a new one as the device re-enumerates on the USB.</p>
<hr/>

<p dir="auto"><a href="https://ko-fi.com/J3J7WPWSQ" rel="nofollow"><img src="https://camo.githubusercontent.com/201ef269611db7eb6b5d08e9f756ab8980df3014b64492770bdf13a6ed924641/68747470733a2f2f6b6f2d66692e636f6d2f696d672f676974687562627574746f6e5f736d2e737667" alt="ko-fi" data-canonical-src="https://ko-fi.com/img/githubbutton_sm.svg"/></a></p>
<p dir="auto">Or support by buying a fully prebuilt adapter at: <a href="https://www.elecrow.com/xyphrolabs-gpibusb.html" rel="nofollow"></a><a href="https://www.elecrow.com/xyphrolabs-gpibusb.html" rel="nofollow">https://www.elecrow.com/xyphrolabs-gpibusb.html</a></p>
<p dir="auto">In general any email, post or feedback is also very valuable, and don&#39;t feel bad if you don&#39;t use the support options :-)
Feel free to contact me at <a href="mailto:Xyphro@gmail.com">Xyphro@gmail.com</a></p>
<hr/>
<p dir="auto">This page is from XyphroLabs UsbGpib project: <a href="https://github.com/xyphro/UsbGpib"></a><a href="https://github.com/xyphro/UsbGpib">https://github.com/xyphro/UsbGpib</a></p>
</article></div></div>
  </body>
</html>
