<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dotat.at/@/2022-06-27-tolower-swar.html">Original</a>
    <h1>tolower() in bulk at speed</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Here’s a fun bit of Monday optimization.</p>
<p>DNS servers often have to convert DNS names to their canonical lower
case form. BIND has to do so a bit more than most because it tries to
preserve the case of DNS names rather than canonicalizing them.</p>
<p>I was recently distracted by a cleanup oportunity: there were multiple
<code>maptolower</code> lookup tables in BIND, so I decided to make a home for
them so that we would only need one copy. Then I thought, surely there
are faster ways to implement <code>tolower()</code> than a lookup table.</p>
<h2 id="simd-within-a-register">SIMD within a register</h2>
<p>There’s an amazing amount of space in a 64-bit register for crunching
data in parallel. Many years ago I wrote about a bitsliced <a href="https://dotat.at/@/2008-09-04-faster-liar-life-in-a-register.html">Life In A
Register</a>, my link log has <a href="https://dotat.at/:/?q=twiddling">a collection of web pages about bit
twiddling hacks</a>, and my shelves are graced by a copy of
<a href="https://en.wikipedia.org/wiki/Hacker%27s_Delight">Hacker’s Delight</a>.</p>
<p>Code often needs to work with DNS names one label at a time (the
labels are the dot-separated parts), and labels are frequently less
than 8 bytes long, and therefore fit inside a 64-bit register. So it
probably isn’t worth dealing with the portability issues of working
with wide vector registers. (Especially since I could not find a quick
way to load an arbitrary number of bytes into a vector register with AVX2
nor with NEON.)</p>
<h2 id="bytewise-parallel-tolower-">bytewise parallel <code>tolower()</code></h2>
<p><a href="https://en.wikipedia.org/wiki/Hacker%27s_Delight">Hacker’s Delight</a> has a lot of discussion of this kind of
SWAR string processing code, but it does not directly tackle
<code>tolower()</code>. So, here’s how I adapted Hank Warren’s examples for my
purposes.</p>
<p>Our function is going to work on 8 ASCII bytes packed into a
<code>uint64_t</code>.</p>
<pre><code>uint64_t tolower8(uint64_t octets) {
</code></pre>
<p>For readability, it’s helpful to be able to replicate a single-byte
value to all 8 bytes in a word. To do so we can multiply by a constant
that has a 1 in each byte. The compiler’s constant propagation and
instruction selection will make this efficient for us.</p>
<pre><code>    uint64_t all_bytes = 0x0101010101010101;
</code></pre>
<p>We are going to steal the 0x80 bit in each byte to use as a flag for
various purposes.</p>
<pre><code>    uint64_t heptets = octets &amp; (0x7F * all_bytes);
</code></pre>
<p>The main trick we’ll use from Hank Warren is how to find out which
bytes are greater than a particular constant, such as <code>&#39;Z&#39;</code>. If we add
<code>0x7F</code> to any of our bytes, carries will propagate and the result will
overflow into our <code>0x80</code> flag bit only if the byte is greater than
zero. And because we cleared the flag bits, they act as fire breaks
stopping the carries from lower bytes messing up the calculations for
higher bytes.</p>
<p>To compare with a value other than zero, we can subtract it from <code>0x7F</code>:</p>
<pre><code>    uint64_t is_gt_Z = heptets + (0x7F - &#39;Z&#39;) * all_bytes;
</code></pre>
<p>To do a greater-than-or-equal comparison, we just need to add 1:</p>
<pre><code>    uint64_t is_ge_A = heptets + (0x80 - &#39;A&#39;) * all_bytes;
</code></pre>
<p>The flags we just calculated are only valid if the corresponding octet
is in the ASCII range of 0 to 127. So we need a clear flag for each
byte that is 128 or greater.</p>
<pre><code>    uint64_t is_ascii = ~octets;
</code></pre>
<p>We are now ready to identify which bytes contain upper case ASCII
letters:</p>
<pre><code>    uint64_t is_upper = is_ascii &amp; (is_ge_A ^ is_gt_Z);
</code></pre>
<p>The difference between corresponding upper case and lower case letters
in ASCII is 32, aka 0x20. So to get our conversion value, we need to
move our 0x80 flag bits to 0x20, and clear out the junk that our
calculations left behind in the other bits:</p>
<pre><code>    uint64_t to_lower = (is_upper &gt;&gt; 2) &amp; (0x20 * all_bytes);
</code></pre>
<p>All that’s left is to add our flag bits to the original word, so that
each byte that was an ASCII upper case letter has 32 added to change
it to lower case.</p>
<pre><code>    return (octets | to_lower);
}
</code></pre>
<p>That should compile down to about 9 instructions, which is not much
more than one instruction per byte. And these are the fastest kinds of
instructions :-)</p>
<h2 id="performance-numbers">performance numbers</h2>
<p>I ran some basic benchmarks on a million random bytes to see how this
code compares to one-byte-at-a-time <code>tolower()</code>:</p>
<pre><code>    0.098 ms memmove() copy
    0.399 ms tolower8() copy
    1.817 ms tolower() copy
    0.280 ms tolower8() compare
    2.090 ms tolower() compare
</code></pre>
<p>The <code>copy</code> lines are for making a new lower-case version of the
string. The <code>compare</code> lines are for testing two strings for
case-insensitive equality.</p>
<p>My <code>tolower8()</code> function is at its best when it has a lot to chew on;
it is not so good for really short strings. The crossover point, when
comparing two strings, is about 4 characters - conveniently, the same
length as <code>.com</code>. (There is a trick for 4-character strings: load them
both into the same register so they can both be converted to lower
case at the same time.)</p>
<p>So now you know how to convert strings to lower case at gigabytes per
second in a single thread.</p>

</div></div>
  </body>
</html>
