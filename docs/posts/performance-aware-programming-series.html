<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.computerenhance.com/p/table-of-contents">Original</a>
    <h1>Performance-Aware Programming Series</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p>This series is designed for programmers who know how to write programs, but don’t know how hardware runs those programs. It’s designed to bring you up to speed on how modern CPUs work, how to estimate the expected speed of performance-critical code, and the basic optimization techniques every programmer should know.</p><p>The course is broken into parts, with the first part (the “prologue”) being strictly a demonstration with no associated homework. Later parts feature weekly homework.</p><p><em><span>Q&amp;A session videos are posted every Monday. </span><strong>If you have a question you’d like answered, please put it in the comments of the most recent Q&amp;A video</strong><span>. Homework listings are available </span><a href="https://github.com/cmuratori/computer_enhance" rel="">from github</a><span>.</span></em></p><p><strong>Prologue: The Five Multipliers</strong><span> (3 1/2 hours, no homework)</span></p><p><em>This part of the course gives simple demonstrations of how seemingly minor code changes can produce dramatically different software performance, even for very simple operations.</em></p><ol><li><p><a href="https://www.computerenhance.com/p/welcome-to-the-performance-aware" rel="">Welcome to the Performance-Aware Programming Series!</a><span> (22:05)</span></p></li><li><p><a href="https://www.computerenhance.com/p/waste" rel="">Waste</a><span> (32:56)</span></p></li><li><p><a href="https://www.computerenhance.com/p/instructions-per-clock" rel="">Instructions Per Clock</a><span> (25:05)</span></p></li><li><p><a href="https://www.computerenhance.com/p/single-instruction-multiple-data" rel="">Single Instruction, Multiple Data</a><span> (35:31)</span></p></li><li><p><a href="https://www.computerenhance.com/p/caching" rel="">Caching</a><span> (22:55)</span></p></li><li><p><a href="https://www.computerenhance.com/p/multithreading" rel="">Multithreading</a><span> (32:11)</span></p></li><li><p><a href="https://www.computerenhance.com/p/python-revisited" rel="">Python Revisited</a><span> (36:22)</span></p></li></ol><p><strong>Interlude</strong><span> (1 hour, no homework)</span></p><ol><li><p><a href="https://www.computerenhance.com/p/the-haversine-distance-problem" rel="">The Haversine Distance Problem</a><span> (30:28)</span></p></li><li><p><a href="https://www.computerenhance.com/p/clean-code-horrible-performance" rel="">“Clean” Code, Horrible Performance</a><span> (22:40)</span></p></li></ol><p><strong>Part 1: Reading ASM </strong><span>(</span><em>7 hours, plus homework</em><span>)</span></p><p><em>This part of the course is designed to ensure that everyone taking the course has a solid understanding of how a CPU works at the assembly-language level.</em></p><ol><li><p><a href="https://www.computerenhance.com/p/instruction-decoding-on-the-8086" rel="">Instruction Decoding on the 8086</a><span> (28:28)</span></p></li><li><p><a href="https://www.computerenhance.com/p/decoding-multiple-instructions-and" rel="">Decoding Multiple Instructions and Suffixes</a><span> (43:51)</span></p></li><li><p><a href="https://www.computerenhance.com/p/opcode-patterns-in-8086-arithmetic" rel="">Opcode Patterns in 8086 Arithmetic</a><span> (20:01)</span></p></li><li><p><a href="https://www.computerenhance.com/p/8086-decoder-code-review" rel="">8086 Decoder Code Review</a><span> (1:17:49)</span></p></li><li><p><a href="https://www.computerenhance.com/p/using-the-reference-decoder-as-a" rel="">Using the Reference Decoder as a Shared Library</a><span> (8:48)</span></p></li><li><p><a href="https://www.computerenhance.com/p/simulating-non-memory-movs" rel="">Simulating Non-memory MOVs</a><span> (18:00)</span></p></li><li><p><a href="https://www.computerenhance.com/p/simulating-add-jmp-and-cmp" rel="">Simulating ADD, SUB, and CMP</a><span> (25:56)</span></p></li><li><p><a href="https://www.computerenhance.com/p/simulating-conditional-jumps" rel="">Simulating Conditional Jumps</a><span> (19:41)</span></p></li><li><p><a href="https://www.computerenhance.com/p/simulating-memory" rel="">Simulating Memory</a><span> (26:32)</span></p></li><li><p><a href="https://www.computerenhance.com/p/simulating-real-programs" rel="">Simulating Real Programs</a><span> (16:02)</span></p></li><li><p><a href="https://www.computerenhance.com/p/other-common-instructions" rel="">Other Common Instructions</a><span> (19:43)</span></p></li><li><p><a href="https://www.computerenhance.com/p/the-stack" rel="">The Stack</a><span> (26:58)</span></p></li><li><p><a href="https://www.computerenhance.com/p/estimating-cycles" rel="">Estimating Cycles</a><span> (23:56)</span></p></li><li><p><a href="https://www.computerenhance.com/p/from-8086-to-x64" rel="">From 8086 to x64</a><span> (26:21)</span></p></li><li><p><a href="https://www.computerenhance.com/p/8086-simulation-code-review" rel="">8086 Simulation Code Review</a><span> (33:05)</span></p></li></ol><p><strong>Part 2: Basic Profiling</strong><span> (</span><em>4 hours, plus homework</em><span>)</span></p><p><em>In this part of the course, we learn about how to measure time, and instrument programs to automatically determine where time is being spent.</em></p><ol><li><p><a href="https://www.computerenhance.com/p/generating-haversine-input-json" rel="">Generating Haversine Input JSON</a><span> (15:40)</span></p></li><li><p><a href="https://www.computerenhance.com/p/writing-a-simple-haversine-distance" rel="">Writing a Simple Haversine Distance Processor</a><span> (12:09)</span></p></li><li><p><a href="https://www.computerenhance.com/p/initial-haversine-processor-code" rel="">Initial Haversine Processor Code Review</a><span> (29:22)</span></p></li><li><p><a href="https://www.computerenhance.com/p/introduction-to-rdtsc" rel="">Introduction to RDTSC</a><span> (48:05)</span></p></li><li><p><a href="https://www.computerenhance.com/p/how-does-queryperformancecounter" rel="">How does QueryPerformanceCounter measure time?</a><span> (31:43)</span></p></li><li><p><a href="https://www.computerenhance.com/p/instrumentation-based-profiling" rel="">Instrumentation-Based Profiling</a><span> (18:01)</span></p></li><li><p><a href="https://www.computerenhance.com/p/profiling-nested-blocks" rel="">Profiling Nested Blocks</a><span> (26:12)</span></p></li><li><p><a href="https://www.computerenhance.com/p/profiling-recursive-blocks" rel="">Profiling Recursive Blocks</a><span> (30:44)</span></p></li><li><p><a href="https://www.computerenhance.com/p/a-first-look-at-profiling-overhead" rel="">A First Look at Profiling Overhead</a><span> (18:37)</span></p></li><li><p><a href="https://www.computerenhance.com/p/comparing-the-overhead-of-rdtsc-and" rel="">Comparing the Overhead of RDTSC and QueryPerformanceCounter</a><span> (13:00)</span></p></li></ol><p><strong>Part 3: Moving Data</strong><span> (</span><em>currently in progress</em><span>)</span></p><p><em>Using our knowledge from parts 1 and 2, in Part 3 we look at how data moves into the CPU, and how to estimate the upper performance limits of our software imposed by the need to move data.</em></p><ol><li><p><a href="https://www.computerenhance.com/p/measuring-data-throughput" rel="">Measuring Data Throughput</a><span> (21:54)</span></p></li><li><p><a href="https://www.computerenhance.com/p/repetition-testing" rel="">Repetition Testing</a><span> (27:57)</span></p></li><li><p><a href="https://www.computerenhance.com/p/monitoring-os-performance-counters" rel="">Monitoring OS Performance Counters</a><span> (20:25)</span></p></li><li><p><a href="https://www.computerenhance.com/p/page-faults" rel="">Page Faults</a><span> (38:52)</span></p><ol><li><p><a href="https://www.computerenhance.com/p/probing-os-page-fault-behavior" rel="">Probing OS Page Fault Behavior</a><span>* (33:05)</span></p></li><li><p><a href="https://www.computerenhance.com/p/four-level-paging" rel="">Four-Level Paging</a><span>* (31:23)</span></p></li><li><p><a href="https://www.computerenhance.com/p/analyzing-page-fault-anomalies" rel="">Analyzing Page Fault Anomalies</a><span>* (31:44)</span></p></li><li><p><a href="https://www.computerenhance.com/p/powerful-page-mapping-techniques" rel="">Powerful Page Mapping Techniques</a><span>* (39:20)</span></p></li><li><p><a href="https://www.computerenhance.com/p/faster-reads-with-large-page-allocations" rel="">Faster Reads with Large Page Allocations</a><span> (25:52)</span></p></li><li><p><a href="https://www.computerenhance.com/p/memory-mapped-files" rel="">Memory-Mapped Files</a><span>* (20:46)</span></p></li></ol></li><li><p><a href="https://www.computerenhance.com/p/inspecting-loop-assembly" rel="">Inspecting Loop Assembly</a><span> (32:31)</span></p></li><li><p><a href="https://www.computerenhance.com/p/intuiting-latency-and-throughput" rel="">Intuiting Latency and Throughput</a><span> (22:57)</span></p></li><li><p><a href="https://www.computerenhance.com/p/analyzing-dependency-chains" rel="">Analyzing Dependency Chains</a><span> (29:06)</span></p></li><li><p><a href="https://www.computerenhance.com/p/linking-directly-to-asm-for-experimentation" rel="">Linking Directly to ASM for Experimentation</a><span> (48:07)</span></p></li><li><p><a href="https://www.computerenhance.com/p/cpu-front-end-basics" rel="">CPU Front End Basics</a><span> (31:09)</span></p></li><li><p><a href="https://www.computerenhance.com/p/branch-prediction" rel="">Branch Prediction</a><span> (42:03)</span></p></li><li><p><a href="https://www.computerenhance.com/p/code-alignment" rel="">Code Alignment</a><span> (32:03)</span></p></li><li><p><a href="https://www.computerenhance.com/p/the-rat-and-the-register-file" rel="">The RAT and the Register File</a><span> (45:21)</span></p></li><li><p><a href="https://www.computerenhance.com/p/execution-ports-and-the-scheduler" rel="">Execution Ports and the Scheduler</a><span> (34:51)</span></p></li><li><p><a href="https://www.computerenhance.com/p/increasing-read-bandwidth-with-simd" rel="">Increasing Read Bandwidth with SIMD Instructions</a><span> (37:52)</span></p></li><li><p><a href="https://www.computerenhance.com/p/cache-size-and-bandwidth-testing" rel="">Cache Size and Bandwidth Testing</a><span> (34:00)</span></p></li><li><p><a href="https://www.computerenhance.com/p/non-power-of-two-cache-size-testing" rel="">Non-Power-of-Two Cache Size Testing</a><span> (35:15)</span></p></li></ol><p><em>* Entries with an asterisk were “bonus” entries that can be skipped.</em></p><p><em>Part 3 is still in progress - more videos will be added here as they are scheduled. Additional parts will follow after Part 3 is complete.</em></p><ol><li><p><a href="https://www.computerenhance.com/p/the-four-programming-questions-from" rel="">The Four Programming Questions from My 1994 Microsoft Internship Interview</a><span> (19:02)</span></p></li><li><p><a href="https://www.computerenhance.com/p/microsoft-intern-interview-question" rel="">Question #1: Rectangle Copy</a><span> (24:50)</span></p></li><li><p><a href="https://www.computerenhance.com/p/microsoft-intern-interview-question-ab7" rel="">Question #2: String Copy</a><span> (14:50)</span></p></li><li><p><a href="https://www.computerenhance.com/p/microsoft-intern-interview-question-a3f" rel="">Question #3: Flood Fill Detection</a><span> (23:58)</span></p></li><li><p><a href="https://www.computerenhance.com/p/efficient-dda-circle-outlines" rel="">Question #4: Outline a Circle</a><span> (1:09:01)</span></p></li></ol></div></div></div></article></div></div></div>
  </body>
</html>
