<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/lex/">Original</a>
    <h1>Weird Lexical Syntax</h1>
    
    <div id="readability-page-1" class="page">

<p>
Oct 31<sup>st</sup>, 2024 @ <a href="https://justine.lol/index.html">justine&#39;s web page</a>
</p>

<p><a href="https://worker.jart.workers.dev/lex/eldritch-horrors-white.png"><img src="https://justine.lol/lex/eldritch-horrors-white.png" alt="[picture of artistically drawn ringtailed lemur sitting in front of red rectangle saying &#39;eldritch horrors&#39; in white times new roman text]" width="360" height="234"/></a>
</p>

<p>
I just learned 42 programming languages this month to build a new syntax
highlighter for
<a href="https://github.com/Mozilla-Ocho/llamafile/">llamafile</a>. I
feel like I&#39;m up to my eyeballs in programming languages right now. Now
that it&#39;s halloween, I thought I&#39;d share some of the spookiest most
surprising syntax I&#39;ve seen.

</p><p>
The languages I decided to support are Ada, Assembly, BASIC, C, C#, C++,
COBOL, CSS, D, FORTH, FORTRAN, Go, Haskell, HTML, Java, JavaScript,
Julia, JSON, Kotlin, ld, LISP, Lua, m4, Make, Markdown, MATLAB, Pascal,
Perl, PHP, Python, R, Ruby, Rust, Scala, Shell, SQL, Swift, Tcl, TeX,
TXT, TypeScript, and Zig. That crosses off pretty much everything on
the <a href="https://www.tiobe.com/tiobe-index/">TIOBE Index</a>
except <a href="https://en.wikipedia.org/wiki/Scratch_%28programming_language%29">Scratch</a>,
which can&#39;t be highlighted, since it uses blocks instead of text.

</p><h2>How To Code a Syntax Highlighter</h2>

<p>
It&#39;s really not difficult to implement a syntax highlighter. You could
probably write one over the course of a job interview. My favorite tools
for doing this have been C++ and
<a href="https://www.gnu.org/software/gperf/">GNU gperf</a>. The hardest
problem here is avoiding the need to do a bunch of string comparisons to
determine if something is a keyword or not. Most developers would just
use a hash table, but gperf lets you create a perfect hash table. For
example:

</p><pre><span>%{</span>
#include &lt;string.h&gt;
<span>%}</span>
<span>%pic</span>
<span>%compare-strncmp</span>
<span>%language</span>=ANSI-C
<span>%readonly-tables</span>
<span>%define</span> <span>lookup-function-name</span> is_keyword_java_constant
<span>%%</span>
true
false
null
</pre>

<p>
gperf was originally invented for gcc and it&#39;s a great way to squeeze
out every last drop of performance. If you run the <code>gperf</code>
command on the above code above, it&#39;ll
<a href="https://justine.lol/lex/is_keyword_java_constant.c">generate this .c file</a>. You&#39;ll
notice its hash function only needs to consider a single character in in
a string to get a collision free lookup. That&#39;s what makes it perfect,
and perfect means better performance. I&#39;m not sure who wants to be able
to syntax highlight C at 35 MB per second, but I am now able to do so,
even though I&#39;ve defined
<a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/is_keyword_c_builtin.gperf">about
4,000 keywords</a> for the language. Thanks to gperf, those keywords
don&#39;t slow things down.

</p><p>
The rest just boils down to finite state machines. You don&#39;t really need
flex, bison, or ragel to build a basic syntax highlighter. You simply
need a <code>for</code> loop and a <code>switch</code> statement. At
least for my use case, where I&#39;ve really only been focusing on strings,
comments, and keywords. If I wanted to highlight things like C function
names, well, then I&#39;d probably need to do actual parsing. But focusing
on the essentials, we&#39;re only really doing lexing at most. See
<a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_ada.cpp">highlight_ada.cpp</a>
as an example.

</p><h2>Demo</h2>

<p>
All the research you&#39;re about to read about on this page, went into
making one thing, which is llamafile&#39;s new syntax highlighter. This is
probably the strongest advantage that llamafile has over ollama these
days, since ollama doesn&#39;t do syntax highlighting at all. Here&#39;s a demo
of it running on Windows 10, using the
<a href="https://huggingface.co/Mozilla/Llama-3.2-3B-Instruct-llamafile">Meta
LLaMA 3.2 3B Instruct</a> model. Please note, these llamafiles will run
on MacOS, Linux, FreeBSD, and NetBSD too.

</p><p>
<video id="video1" width="916" height="450" controls="" muted="" loop="" preload="none">
  <source src="https://storage.googleapis.com/justine-lol/llamafile-lex-demo.webm" type="video/webm"/>
  <source src="https://storage.googleapis.com/justine-lol/llamafile-lex-demo.mp4" type="video/mp4"/>
  [screencast of the Mozilla/Llama-3.2-3B-Instruct-llamafile LLM being
   used to generate code in various programming languages (FORTRAN,
   Rust, C++, Perl) for printing the first 100 prime numbers]
</video>


</p><p>
The new highlighter and chatbot interface has made llamafile so pleasant
for me to use, combined with the fact that open weights models
like <a href="https://huggingface.co/Mozilla/gemma-2-27b-it-llamafile">gemma
27b it</a> have gotten so good, that it&#39;s become increasingly rare that
I&#39;ll feel tempted to use Claude these days.

</p><h2>Examples of Surprising Lexical Syntax</h2>

<p>
So while writing this highlighter, let&#39;s talk about the kinds of lexical
syntax that surprised me.

</p><h3>C</h3>

<p>
The C programming language, despite claiming to be simple, actually has
some of the weirdest lexical elements of any language. For starters, we
have trigraphs, which were probably invented to help Europeans use C
when using keyboards that didn&#39;t
include <code>#</code>, <code>[</code>, <code>\</code>, <code>^</code>, <code>{</code>, <code>|</code>, <code>}</code>,
and <code>~</code>. You can replace those characters
with <code>??=</code>, <code>??(</code>, <code>??/</code>, <code>??)</code>, <code>??&#39;</code>, <code>??&lt;</code>, <code>??!</code>, <code>??&gt;</code>,
and <code>??-</code>. Intuitive, right? That means, for example, the
following is perfectly valid C code.

</p><pre><span>int</span>
<span>main</span>(<span>int</span> argc, <span>char</span>* argv<span>??(??)</span>)
<span>??&lt;</span>
    printf(&#34;hello world\n&#34;);
<span>??&gt;</span>
</pre>

<p>
That is, at least until trigraphs were removed in the C23 standard.
However compilers will be supporting this syntax forever for legacy
software, so a good syntax highlighter ought to too. But just because
trigraphs are officially dead, doesn&#39;t mean the standards committees
haven&#39;t thought up other weird syntax to replace it. Consider universal
characters:

</p><pre><span>int</span> <span>\uFEB2</span> = 1;
</pre>

<p>
This feature is useful for anyone who wants, for example, variable names
with arabic characters while still keeping the source code pure ASCII.
I&#39;m not sure why anyone would use it. I was hoping I could abuse this to
say:

</p><pre><span>int</span>
<span>main</span>(<span>int</span> argc, <span>char</span>* argv<span>\u005b\u005d</span>)
<span>\u007b</span>
    printf(<span>&#34;hello world\n&#34;</span>);
<span>\u007d</span>
</pre>

<p>
But alas, GCC raises an error if universal characters aren&#39;t used on the
specific UNICODE planes that&#39;ve been blessed by the standards committee.

</p><p>
This next one is one of my favorites. Did you know that a single line
comment in C can span multiple lines if you use backslash at the end of
the line?

</p><pre><span>//hi\
there</span>
</pre>

<p>
Most other languages don&#39;t support this. Even languages that allow
backslash escapes in their source code (e.g. Perl, Ruby, and Shell)
don&#39;t have this particular feature from C. The ones that do support this
too, as far as I can tell, are Tcl and GNU Make. Tools for syntax
highlighting oftentimes get this wrong, like Emacs and Pygments.
Although Vim seems to always be right about backslash.

</p><h3>Haskell</h3>

<p>
Every C programmers knows you can&#39;t embed a multi-line comment in a
multi-line comment. For example:

</p><pre><span>/*
 hello
 /* again */</span>
  nope nope nope
*/
</pre>

<p>
However with Haskell, you can. They finally fixed the bug. Although they
did adopt a different syntax.

</p><pre><span>-- Test nested comments within code blocks</span>
<span>let</span> result3 = <span>{- This comment contains
                   {- a nested comment -}
               -}</span> 10 - 5
</pre>

<h3>Tcl</h3>

<p>
The thing that surprised me most about Tcl, is that identifiers can have
quotes in them. For example, this program will print <code>a&#34;b</code>:

</p><pre><span>puts</span> a&#34;b
</pre>

<p>
You can even have quote in your variable names, however you&#39;ll only be
able to reference it if you use the <code>${a&#34;b}</code> notation, rather
than <code>$a&#34;b</code>.

</p><pre><span>set</span> <span>a&#34;b</span> doge
<span>puts</span> ${<span>a&#34;b</span>}
</pre>

<h3>JavaScript</h3>

<p>
JavaScript has a builtin lexical syntax for regular expressions. However
it&#39;s easy to lex it wrong if you aren&#39;t paying attention. Consider the
following:

</p><pre><span>var</span> foo = <span>/[/]/</span>g;
</pre>

<p>
When I first wrote my lexer, I would simply scan for the closing slash,
and assume that any slashes inside the regex would be escaped. That
turned out to be wrong when I highlighted some minified code. If a slash
is inside the square quotes for a character set, then that slash doesn&#39;t
need to be escaped!

</p><p>
Now onto the even weirder.

</p><p>
There&#39;s some invisible UNICODE characters called the LINE SEPARATOR
(u2028) and PARAGRAPH SEPARATOR (u2029). I don&#39;t know what the use case
is for these codepoints, but the ECMAScript
standard <a href="https://262.ecma-international.org/12.0/#sec-line-terminators">defines
them as line terminators</a>, which effectively makes them the same
thing as <code>\n</code>. Since these
are <a href="https://trojansource.codes/">Trojan Source</a> characters,
I configure my Emacs to render them as ↵ and ¶. However most software
hasn&#39;t been written to be aware of these characters, and will oftentimes
render them as question marks. Also as far as I know, no other language
does this. I was able to use that to my advantage for SectorLISP, since
it let me create C + JavaScript polyglots.

</p><pre><span>javascript syntax highlighting</span><span>//¶</span><span>`
<em>... C only code goes here ...</em>
//`</span>
</pre>

<p>
That&#39;s how I&#39;d insert C code into JavaScript files.

</p><pre><span>c syntax highlighting</span><span>//¶`</span>
<span>#if</span> 0
<span>//`</span>
<em>... JavaScript only code goes here ...</em>
<span>//¶`</span>
<span>#endif</span>
<span>//`</span>
</pre>

<p>
And that&#39;s how I&#39;d insert JavaScript into my C source code. An example
of a piece of production code where I did this
is <a href="https://justine.lol/sectorlisp2/lisp.js">lisp.js</a> which is what powers
my <a href="https://justine.lol/sectorlisp2/">SectorLISP blog post</a>. It both runs in
the browser, and you can compile it with GCC and run it locally too.
llamafile is able to correctly syntax highlight this stuff, but I&#39;ve yet
to find another syntax highlighter that does too. Not that it matters,
since I doubt an LLM would ever print this. But it sure is fun to think
about these corner cases.

</p><h3>Shell</h3>

<p>
We&#39;re all familiar with the heredoc syntax of shell scripts, e.g.

</p><pre>cat &lt;&lt;EOF
<span>this is kind of
a multi-line
string
EOF</span>
</pre>

<p>
The above syntax allows you to put <code>$foo</code> in your heredoc
string, although there&#39;s a quoted syntax which disables variable
substitution.

</p><pre>cat &lt;&lt;<span>&#39;END&#39;</span>
<span>this won&#39;t print the contents of $var
END</span>
</pre>

<p>
If you ever want to confuse your coworkers, then one great way to abuse
this syntax is by replacing the heredoc marker with an empty string, in
which case the heredoc will end on the next empty line. For example,
this program will print &#34;hello&#34; and &#34;world&#34; on two lines:

</p><pre>cat &lt;&lt;<span>&#39;&#39;</span>
<span>hello</span>

<span>echo</span> world
</pre>

<p>
It&#39;s also possible in languages that support heredocs (Shell, Ruby, and
Perl) to have multiple heredocs on the same line.

</p><pre>cat /dev/fd/3 3&lt;&lt; E1 /dev/fd/4 4&lt;&lt; E2
foo
E1
bar
E2
</pre>

<p>
Another thing to look out for with shell, is it&#39;s like Tcl in the sense
that special characters like #, which you might think would always begin
a comment, can actually be valid code depending on the context. For
example, inside a variable reference, # can be used to strip a prefix.
The following program will print &#34;there&#34;.

</p><pre><span>x</span>=hi-there
<span>echo</span> ${<span>x</span>#hi-}
</pre>


<h3>String Interpolation</h3>

<p>
Did you know that, from a syntax highlighting standpoint, a Kotlin
string can begin with &#34; but end with the { character? That&#39;s the way
it&#39;s string interpolation syntax works. Many languages let you embed
variable name references in strings, but TypeScript, Swift, Kotlin, and
Scala take string interpolation to the furthest extreme of encouraging
actual code being embedded inside strings.

</p><pre><span>val</span> s2 = <span>&#34;${</span>s1.replace(<span>&#34;is&#34;</span>, <span>&#34;was&#34;</span>)<span>}, but now is $<span>a</span>&#34;</span>
</pre>

<p>
So to highlight a string with Kotlin, Scala, and TypeScript, one must
count curly brackets and maintain a stack of parser states. With
TypeScript, this is relatively trivial, and only requires a couple
states to be added to your finite state machine. However with Kotlin and
Scala it gets real hairy, since they support both double quote and
triple quote syntax, and either one of them can have interpolated
values. So that ended up being about 13 independent states the FSM needs
for string lexing alone. Swift also supports triple quotes for its
<code>&#34;\(var)&#34;</code> interpolated syntax, however that only needed 10
states to support.

</p><h3>Swift</h3>

<p>
Swift has its own unique approach to the problem of embedding strings
inside a string. It allows &#34;double quote&#34;, &#34;&#34;&#34;triple quote&#34;&#34;&#34;, and
/regex/ strings to all be surrounded with an arbitrary number of #hash#
marks, which must be mirrored on each side. This makes it possible to
write code like the following:

</p><pre><span>let</span> threeMoreDoubleQuotationMarks = <span>#&#34;&#34;&#34;
Here are three more double quotes: &#34;&#34;&#34;
&#34;&#34;&#34;#</span>
<span>let</span> threeMoreDoubleQuotationMarks = <span>##&#34;&#34;&#34;
Here are three more double quotes: #&#34;&#34;&#34;#
&#34;&#34;&#34;##</span>
</pre>

<h3>C#</h3>

<p>
C# supports Python&#39;s triple quote multi-line string syntax, but with an
interesting twist that&#39;s unique to this language. The way C# solves the
&#34;embed a string inside a string&#34; problem, is they let you do quadruple
quoted strings, or even quintuple quoted strings if you want. However
many quotes you put on the lefthand side, that&#39;s what&#39;ll be used to
terminate the string at the other end.

</p><pre>Console.WriteLine(<span>&#34;&#34;</span>);
Console.WriteLine(<span>&#34;\&#34;&#34;</span>);
Console.WriteLine(<span>&#34;&#34;&#34;&#34;&#34;&#34;</span>);
Console.WriteLine(<span>&#34;&#34;&#34;&#34;&#34;&#34;</span>);
Console.WriteLine(<span>&#34;&#34;&#34; yo &#34;&#34; hi &#34;&#34;&#34;</span>);
Console.WriteLine(<span>&#34;&#34;&#34;&#34; yo &#34;&#34;&#34; hi &#34;&#34;&#34;&#34;</span>);
Console.WriteLine(<span>&#34;&#34;&#34;&#34;First
                  &#34;&#34;&#34;100 Prime&#34;&#34;&#34;
                  Numbers:
                  &#34;&#34;&#34;&#34;</span>);
</pre>

<p>
This is the way if you ask me, because it&#39;s actually simpler for a
finite state machine to decode. With classic Python triple quoted
strings, you need extra rules, to ensure it&#39;s either one double-quote
character, or exactly three. By letting it be an arbitrary number,
there&#39;s fewer rules to validate. So you end up with a more powerful
expressive language that&#39;s simpler to implement. This is the kind of
genius we&#39;ve come to expect from Microsoft.

</p><p>
What will they think of next?

</p><p>
<img alt="[Vince McMahon&#39;s reactions to C, C++, C#, C cubed, and C tesseract]" src="https://worker.jart.workers.dev/c.jpg" width="960" height="1385"/>

</p><h3>FORTH</h3>

<p>
Normally when code is simpler for a computer to decode, it&#39;s more
difficult for a human to understand, and FORTH is proof of that. FORTH
is probably the simplest language there is, because it tokenizes
everything on whitespace boundaries. Even the syntax for starting a
string is a token. For example:

</p><pre><span>c&#34; hello world&#34;</span>
</pre>

<p>
Would mean the same thing as saying <code>&#34;hello world&#34;</code> in every
other language.

</p><h3>FORTRAN and COBOL</h3>

<p>
One of the use cases I envision for llamafile is that it can help the
banking system not collapse once all the FORTRAN and COBOL programmers
retire. Let&#39;s say you&#39;ve just been hired to maintain a secretive
mainframe full of confidential information written in the COmmon
Business-Oriented Language. Thanks to llamafile, you can ask an
air-gapped AI you control,
like <a href="https://huggingface.co/Mozilla/gemma-2-27b-it-llamafile">Gemma
27b</a>, to write your COBOL and FORTRAN code for you. It can&#39;t print
punch cards, but it can highlight punch card syntax. Here&#39;s what FORTRAN
code looks like, properly syntax highlighted:

</p><pre><span>*
*     Quick return if possible.
*</span>
      <span>IF</span> ((M<span>.EQ.</span>0) <span>.OR.</span> (N<span>.EQ.</span>0) <span>.OR.</span>
     <span>+</span>    (((ALPHA<span>.EQ.</span>ZERO)<span>.OR.</span> (K<span>.EQ.</span>0))<span>.AND.</span> (BETA<span>.EQ.</span>ONE))) <span>RETURN</span>
<span>*
*     And if alpha.eq.zero.
*</span>
      <span>IF</span> (ALPHA<span>.EQ.</span>ZERO) <span>THEN</span>
          <span>IF</span> (BETA<span>.EQ.</span>ZERO) <span>THEN</span>
              <span>DO</span> <span>20</span> J = 1,N
                  <span>DO</span> <span>10</span> I = 1,M
                      C(I,J) = ZERO
   <span>10</span>             <span>CONTINUE</span>
   <span>20</span>         <span>CONTINUE</span>
          <span>ELSE</span>
              <span>DO</span> <span>40</span> J = 1,N
                  <span>DO</span> <span>30</span> I = 1,M
                      C(I,J) = BETA*C(I,J)
   <span>30</span>             <span>CONTINUE</span>
   <span>40</span>         <span>CONTINUE</span>
          <span>END IF</span>
          <span>RETURN</span>
      <span>END IF</span>
</pre>

<p>
FORTRAN has the following fixed column rules.

</p><ul>
<li>Putting *, c, or C in column 1 will make the line a comment
</li><li>Putting non-space in column 6 lets you extend a line past 80 characters
</li><li>Labels are created by putting digits in columns 1-5
</li></ul>

<p>
Now here&#39;s some properly syntax highlighted COBOL code.

</p><pre><span>000100</span><span>*Hello World in COBOL</span>
<span>000200</span> <span>IDENTIFICATION DIVISION</span>.
<span>000300</span> <span>PROGRAM-ID</span>. HELLO-WORLD.
<span>000400</span>
<span>000500</span> <span>PROCEDURE DIVISION</span>.
<span>000600</span>     <span>DISPLAY</span> <span>&#39;Hello, world!&#39;</span>.
<span>000700</span>     <span>STOP RUN</span>.
</pre>

<p>
With COBOL, the rules are:

</p><ul>
<li>Putting * in column 7 makes the line a comment
</li><li>Putting - in column 7 lets you extend a line past 80 characters
</li><li>Line numbers go in columns 1-6.
</li></ul>

<h3>Zig</h3>

<p>
Zig has its own unique solution for multi-line strings, which are
prefixed with two backslashes.

</p><pre><span>const</span> copyright =
    <span>\\ Copyright (c) 2024, Zig Incorporated
    \\ All rights reserved.</span>
    ;
</pre>

<p>
What I like about this syntax, is it eliminates that need we&#39;ve always
had for calling <code>textwrap.dedent()</code> with Python&#39;s triple
quoted strings. The tradeoff is that the semicolon is ugly. This is a
string syntax that really ought to be considered by one of the languages
that don&#39;t need semicolons, e.g. Go, Scala, Python, etc.

</p><h3>Lua</h3>

<p>
Lua has a very unique multi-line string syntax, and it uses an approach
similar to C# and Swift when it comes to solving the &#34;embed a string
inside a string&#34; problem. It works by using double square brackets, and
it lets you put an arbitrary number of equal signs inbetween them.

</p><pre><span>-- this is a comment</span>
<span>[[hi [=[]=] ]]</span> there
<span>[[hi [=[]=] ]]</span> there
<span>[==[hi [=[]=] ]==]</span> hello
<span>[==[hi  ]=]==]</span> hello
<span>[==[hi  ]===]==]</span> hello
<span>[====[hi  ]===]====]</span> hello
</pre>

<p>
What&#39;s really interesting is that it lets you do this with comments too.

</p><pre><span>--[[
comment #1
]]</span>
<span>print</span>(<span>&#34;hello&#34;</span>)

<span>--[==[
comment [[#2]]
]==]</span>
<span>print</span>(<span>&#34;world&#34;</span>)
</pre>

<h3>Assembly</h3>

<p>
One of the most challenging languages to syntax highlight is assembly,
due to the fragmentation of all its various dialects. I&#39;ve sought to
build something with llamafile that does a reasonably good job with
AT&amp;T, nasm, etc. syntax. Here&#39;s nasm syntax:

</p><pre><span>section</span> .data
    <span>message</span> db <span>&#39;Hello, world!&#39;</span>, 0xa <span>; The message string, ending with a newline</span>

<span>section</span> .text
    <span>global</span> _start

<span>_start</span>:
    <span>; Write the message to stdout</span>
    <span>mov</span> rax, 1      <span>; System call number for write</span>
    <span>mov</span> rdi, 1      <span>; File descriptor for stdout</span>
    <span>mov</span> rsi, message <span>; Address of the message string</span>
    <span>mov</span> rdx, 13     <span>; Length of the message</span>
    <span>syscall</span>

    <span>; Exit the program</span>
    <span>mov</span> rax, 60     <span>; System call number for exit</span>
    <span>xor</span> rdi, rdi    <span>; Exit code 0</span>
    <span>syscall</span>
</pre>

<p>
And here&#39;s AT&amp;T syntax:

</p><pre><span>/ syscall</span>

<span>.globl</span>	_syscall,csv,cret,cerror
<span>_syscall</span>:
	<span>jsr</span>	r5,csv
	<span>mov</span>	r5,r2
	<span>add</span>	<span>$04</span>,r2
	<span>mov</span>	<span>$9f</span>,r3
	<span>mov</span>	(r2)+,r0
	<span>bic</span>	<span>$!0377</span>,r0
	<span>bis</span>	<span>$sys</span>,r0
	<span>mov</span>	r0,(r3)+
	<span>mov</span>	(r2)+,r0
	<span>mov</span>	(r2)+,r1
	<span>mov</span>	(r2)+,(r3)+
	<span>mov</span>	(r2)+,(r3)+
	<span>mov</span>	(r2)+,(r3)+
	<span>mov</span>	(r2)+,(r3)+
	<span>mov</span>	(r2)+,(r3)+
	<span>sys</span>	0; 9f
	<span>bec</span>	<span>1</span>f
	<span>jmp</span>	cerror
<span>1</span>:	<span>jmp</span>	cret

	<span>.data</span>
<span>9</span>:	.=.+12.
</pre>

<p>
And here&#39;s GNU syntax:

</p><pre><span>/ setjmp() for x86-64</span>
<span>// this is a comment too</span>
<span>; so is this</span>
<span># this too!</span>
<span>! hello sparc</span>

<span>setjmp</span>:	<span>lea</span>	8(<span>%rsp</span>),<span>%rax</span>
	<span>mov</span>	<span>%rax</span>,(<span>%rdi</span>)
	<span>mov</span>	<span>%rbx</span>,8(<span>%rdi</span>)
	<span>mov</span>	<span>%rbp</span>,16(<span>%rdi</span>)
	<span>mov</span>	<span>%r12</span>,24(<span>%rdi</span>)
	<span>mov</span>	<span>%r13</span>,32(<span>%rdi</span>)
	<span>mov</span>	<span>%r14</span>,40(<span>%rdi</span>)
	<span>mov</span>	<span>%r15</span>,48(<span>%rdi</span>)
	<span>mov</span>	(<span>%rsp</span>),<span>%rax</span>
	<span>mov</span>	<span>%rax</span>,56(<span>%rdi</span>)
	<span>xor</span>	<span>%eax</span>,<span>%eax</span>
	<span>ret</span>
</pre>

<p>
With keywords I&#39;ve found the simplest thing is to just treat the
first identifier on the line (that isn&#39;t followed by a colon) as a
keyword. That tends to make most of the assembly I&#39;ve tried look pretty
reasonable.

</p><p>
The comment syntax is real hairy. I really like the original UNIX
comments which only needed a single slash. GNU as still supports those
to this date, but only if they&#39;re at the beginning of the line (UNIX
could originally put them anywhere, since <code>as</code> didn&#39;t have
the ability to do arithmetic back then). Clang doesn&#39;t support fixed
comments at all, so they&#39;re sadly not practical anymore to use in open
source code.

</p><p>
But this story gets even better. Another weird thing about the original
UNIX assembler is that it didn&#39;t use a closing quote on character
literals. So where we&#39;d say <code>&#39;x&#39;</code> to get 0x78 for x, in the
original UNIX source code, you&#39;d say <code>&#39;x</code>. This is another
thing GNU as continues to support, but sadly not LLVM. In any case,
since a lot of code exists that uses this syntax, any good syntax
highlighter needs to support it.

</p><p>
The GNU assembler allows identifiers to be quoted, so you can put pretty
much any character in a symbol.

</p><p>
Finally, it&#39;s not enough to just highlight assembly when highlighting
assembly. The assembler is usually used in conjunction with either the C
preprocessor, or m4. Trust me, lots of open source code does this.
Therefore lines starting with <code>dnl</code>, <code>m4_dnl</code>,
or <code>C</code> should be taken as comments too.

</p><h3>Ada</h3>

<p>
Ada is a remarkably simple language to lex, but there&#39;s one thing I
haven&#39;t quite wrapped my head around yet, which is its use of the single
quotation mark. Ada can have character literals like C,
e.g. <code>&#39;x&#39;</code>. But single quote can also be used to reference
attributes, e.g. <code>Foo&#39;Size</code>. Single quote even lets you embed
expressions and call functions. For example, the program:

</p><pre><span>with</span> Ada.Text_IO;

<span>procedure</span> main <span>is</span>
   S : String := Character&#39;(<span>&#39;)&#39;</span>)&#39;Image;
<span>begin</span>
   Ada.Text_IO.Put_Line(<span>&#34;The value of S is: &#34;</span> &amp; S);
<span>end</span> main;
</pre>

<p>
Will print out:

</p><pre>The value of S is: &#39;)&#39;
</pre>

<p>
Because we&#39;re declaring a character, giving it a value, and then sending
it through the <code>Image</code> function, which converts it to
a <code>String</code> representation.

</p><h3>BASIC</h3>

<p>
Let&#39;s talk about the Beginner&#39;s All-purpose Symbolic Instruction Code.
While digging through the repos I&#39;ve git cloned, I came across this old
Commodore BASIC program that broke many of my assumptions about syntax
highlighting.

</p><pre><span>10</span> <span>rem cbm basic v2 example</span>
<span>20</span> <span>rem comment with keywords: for, data</span>
<span>30</span> <span>dim</span> a$(20)
<span>35</span> <span>rem the typical space efficient form of leaving spaces out:</span>
<span>40</span> fort=0to15:poke646,t:<span>print</span><span>&#34;{revers on}     &#34;</span>;:<span>next</span>
<span>50</span> geta$:ifa$=<span>chr</span>$(0):<span>goto</span>40
<span>55</span> <span>rem it is legal to omit the closing &#34; on line end</span>
<span>60</span> <span>print</span><span>&#34;{white}&#34;</span>:<span>print</span><span>&#34;bye...</span>
<span>70</span> <span>end</span>
</pre>

<p>
We&#39;ll notice that this particular BASIC implementation didn&#39;t require a
closing quote on strings, variable names have these weird sigils, and
keywords like <code>goto</code> are lexed eagerly out of identifiers.

</p><p>
Visual BASIC also has this weird date literal syntax:

</p><pre><span>Dim</span> v <span>As</span> <span>Variant</span>    <span>&#39; Declare a Variant</span>
v = <span>#1/1/2024#</span>      <span>&#39; Hold a date</span>
</pre>

<p>
That&#39;s tricky to lex, because VB even has preprocessor directives.

</p><pre><span>#If DEBUG Then</span>
&lt;WebMethod()&gt;
<span>Public Function</span> <span>SomeFunction</span>() <span>As</span> <span>String</span>
<span>#Else</span>
&lt;WebMethod(CacheDuration:=86400)&gt;
<span>Public</span> <span>Function</span> <span>SomeFunction</span>() <span>As</span> <span>String</span>
<span>#End If</span>
</pre>

<h3>Perl</h3>

<p>
One of the trickier languages to highlight is Perl. It&#39;s exists in the
spiritual gulf between shells and programming languages, and inherits
the complexity of both. Perl isn&#39;t as popular today as it once was, but
its influence continues to be prolific. Perl made regular expressions a
first class citizen of the language, and the way regex works in Perl has
since been adopted by many other programming languages, such as Python.
However the regex lexical syntax itself continues to be somewhat unique.

</p><p>
For example, in Perl, you can replace text similar to sed as follows:

</p><pre><span>my</span> $<span>string</span> = <span>&#34;HELLO, World!&#34;</span>;
$<span>string</span> =~ s<span>/hello/Perl/</span>i;
print $<span>string</span>;  <span># Output: Perl, World!</span>
</pre>

<p>
Like sed, Perl also allows you to replace the slashes with an arbitrary
punctuation character, since that makes it easier for you to put slashes
inside your regex.

</p><pre>$<span>string</span> =~ s<span>!hello!Perl!</span>i;
</pre>

<p>
What you might not have known, is that it&#39;s possible to do this with
mirrored characters as well, in which case you need to insert an
additional character:

</p><pre>$<span>string</span> =~ s<span>{hello}{Perl}</span>i;
</pre>

<p>
However <code>s///</code> isn&#39;t the only weird thing that needs to be
highlighted like a string. Perl has a wide variety of other magic
prefixes.

</p><pre><span>/case sensitive match/</span>
<span>/case insensitive match/</span>i
y<span>/abc/xyz/</span>e
s<span>!hi!there!</span>
m<span>!hi!</span>i
m<span>;hi;</span>i
qr<span>!hi!</span>u
qw<span>!hi!</span>h
qq<span>!hi!</span>h
qx<span>!hi!</span>h
m<span>-hi-</span>
s<span>-hi-there-</span>g
s<span>&#34;hi&#34;there&#34;</span>g
s<span>@hi@there@</span> yo
s<span>{hi}{there}</span>g
</pre>

<p>
One thing that makes this tricky to highlight, is you need to take
context into consideration, so you don&#39;t accidentally think
that <code>y/x/y/</code> is a division formula. Thankfully, Perl makes
this relatively easy, because variables can always be counted upon to
have sigils, which are usually <code>$</code> for
scalars, <code>@</code> for arrays, and <code>%</code> for hashes.

</p><pre><span>my</span> $<span>greeting</span> = <span>&#34;Hello, world!&#34;</span>;

<span># Array: A list of names</span>
<span>my</span> @<span>names</span> = (<span>&#34;Alice&#34;</span>, <span>&#34;Bob&#34;</span>, <span>&#34;Charlie&#34;</span>);

<span># Hash: A dictionary of ages</span>
<span>my</span> %<span>ages</span> = (<span>&#34;Alice&#34;</span> =&gt; 30, <span>&#34;Bob&#34;</span> =&gt; 25, <span>&#34;Charlie&#34;</span> =&gt; 35);

<span># Print the greeting</span>
print <span>&#34;$greeting\n&#34;</span>;

<span># Print each name from the array</span>
<span>foreach my</span> $<span>name</span> (@<span>names</span>) {
    print <span>&#34;$name\n&#34;</span>;
}
</pre>

<p>
This helps us avoid the need for parsing the language grammar.

</p><p>
Perl also has this goofy convention for writing man pages in your source
code. Basically, any =word at the start of the line will get it going,
and <code>=cut</code> will finish it.

</p><pre><span>#!/usr/bin/perl</span>

<span>=pod

=head1 NAME

my_silly_script - A Perl script demonstrating =cut syntax

=head1 SYNOPSIS

 my_silly_script [OPTIONS]

=head1 DESCRIPTION

This script does absolutely nothing useful, but it showcases
the quirky =cut syntax for POD documentation in Perl.

=head1 OPTIONS

There are no options.

=head1 AUTHOR

Your Name &lt;your.email@example.com&gt;

=head1 COPYRIGHT

Copyright (c) 2023 Your Name. All rights reserved.

=cut</span>

print <span>&#34;Hello, world!\n&#34;</span>;
</pre>

<h3>Ruby</h3>

<p>
Of all the languages, I&#39;ve saved the best for last, which is Ruby. Now
here&#39;s a language whose syntax evades all attempts at understanding.
Ruby is the union of all earlier languages, and it&#39;s not even formally
documented. Their manual has a section
<a href="https://ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html">on
Ruby syntax</a>, but it&#39;s very light on details. Whenever I try to test
my syntax highlighting, by concatenating all the .rb files on my hard
drive, there&#39;s always another file that finds some way to break it.

</p><pre><span>def</span> `(command)
  <span>return</span> <span>&#34;just testing a backquote override&#34;</span>
<span>end</span>
</pre>

<p>
Since ruby supports backquote syntax like <code>var
= <span>`echo hello`</span></code>, I&#39;m not exactly sure how
to tell that the backquote above isn&#39;t meant to be highlighted as a
string. Another example is this:

</p><pre><span>when</span> <span>/\.*\.h/</span>
  options[<span>:includes</span>] &lt;&lt;arg; <span>true</span>
<span>when</span> <span>/--(\w+)=\&#34;?(.*)\&#34;?/</span>
  options[<span>$1</span>.to_sym] = <span>$2</span>; <span>true</span>
</pre>

<p>
Ruby has a <code>&lt;&lt;</code> operator, and it also supports heredocs
(just like Perl and Shell). So I&#39;m not exactly sure how to tell that the
code above isn&#39;t a heredoc. Yes that code actually exists in the wild.
Even Emacs gets this wrong. Out of all 42 languages I&#39;ve evaluated,
that&#39;s probably the biggest shocker so far. It might be the case that
Ruby isn&#39;t possible to lex without parsing. Even with parsing, I&#39;m still
not sure how it&#39;s possible to make sense of that.

</p><h2>Complexity of Supported Languages</h2>

<p>
If I were to rank the complexity of programming languages by how many
lines of code each one takes to syntax highlight, then FORTH would be
the simplest language, and Ruby would be the most complicated.

</p><pre>   125 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_forth.cpp">highlight_forth.cpp</a>       266 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_lua.cpp">highlight_lua.cpp</a>
   132 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_m4.cpp">highlight_m4.cpp</a>          282 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_csharp.cpp">highlight_csharp.cpp</a>
   149 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_ada.cpp">highlight_ada.cpp</a>         282 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_rust.cpp">highlight_rust.cpp</a>
   160 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_lisp.cpp">highlight_lisp.cpp</a>        297 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_python.cpp">highlight_python.cpp</a>
   163 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_test.cpp">highlight_test.cpp</a>        300 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_java.cpp">highlight_java.cpp</a>
   166 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_matlab.cpp">highlight_matlab.cpp</a>      321 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_haskell.cpp">highlight_haskell.cpp</a>
   186 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_cobol.cpp">highlight_cobol.cpp</a>       335 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_markdown.cpp">highlight_markdown.cpp</a>
   199 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_basic.cpp">highlight_basic.cpp</a>       337 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_js.cpp">highlight_js.cpp</a>
   200 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_fortran.cpp">highlight_fortran.cpp</a>     340 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_html.cpp">highlight_html.cpp</a>
   211 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_sql.cpp">highlight_sql.cpp</a>         371 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_typescript.cpp">highlight_typescript.cpp</a>
   216 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_tcl.cpp">highlight_tcl.cpp</a>         387 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_kotlin.cpp">highlight_kotlin.cpp</a>
   218 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_tex.cpp">highlight_tex.cpp</a>         387 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_scala.cpp">highlight_scala.cpp</a>
   219 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight.cpp">highlight.cpp</a>             447 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_asm.cpp">highlight_asm.cpp</a>
   220 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_go.cpp">highlight_go.cpp</a>          449 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_c.cpp">highlight_c.cpp</a>
   225 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_css.cpp">highlight_css.cpp</a>         455 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_swift.cpp">highlight_swift.cpp</a>
   225 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_pascal.cpp">highlight_pascal.cpp</a>      560 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_shell.cpp">highlight_shell.cpp</a>
   230 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_zig.cpp">highlight_zig.cpp</a>         563 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_perl.cpp">highlight_perl.cpp</a>
   235 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_make.cpp">highlight_make.cpp</a>        624 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_ruby.cpp">highlight_ruby.cpp</a>
   239 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_ld.cpp">highlight_ld.cpp</a>               
   263 <a href="https://github.com/Mozilla-Ocho/llamafile/blob/main/llamafile/highlight_r.cpp">highlight_r.cpp</a>                
</pre>

<h2 class="page" id="funding"><a href="#funding">Funding</a></h2>

<p>
  <a href="https://justine.lol/lemuria.png">
    <picture>
      <source srcset="//worker.jart.workers.dev/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="https://worker.jart.workers.dev/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
<a href="https://github.com/Mozilla-Ocho/llamafile/">llamafile</a> is a
<a href="https://huggingface.co/Mozilla">Mozilla</a> project who
sponsors me to work on it. My work on open source is also made possible
by my <a href="https://github.com/sponsors/jart">GitHub sponsors</a>
and <a href="https://www.patreon.com/jart">Patreon subscribers</a>.
Thank you for giving me the opportunity to serve you all these last four
years. Since you&#39;ve read this far, I&#39;d like to invite you to join both
the <a href="https://discord.gg/tzYWSZGV59">Mozilla AI Discord</a> and
the <a href="https://discord.gg/FwAVVu7eJ4">Redbean Discord</a> servers
where you can chat with me and other people who love these projects.

</p>
<img src="https://ipv4.games/claim?name=jart"/>
</div>
  </body>
</html>
