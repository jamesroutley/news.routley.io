<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.memc.rs">Original</a>
    <h1>Drop-In Replacement for Memcached</h1>
    
    <div id="readability-page-1" class="page"><div>
	
	



<p>There is more than enough written on the mechanics of and mitigations for the recent <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228">severe RCE in log4j</a>. On prevention, this is the most interesting widely-reshared <a href="https://twitter.com/yazicivo/status/1469349956880408583?s=21">insight</a> I have seen:</p>

<blockquote>
<p>Log4j maintainers have been working sleeplessly on mitigation measures; fixes, docs, CVE, replies to inquiries, etc. Yet nothing is stopping people to bash us, for work we aren&#39;t paid for, for a feature we all dislike yet needed to keep due to backward compatibility concerns.</p>
</blockquote>

<p>This is making the rounds because highly-profitable companies are using infrastructure they do not pay for. That is a worthy topic, but not the most interesting thing in this particular case because it would not clearly have contributed to preventing this bug. It is the second statement in this tweet that is worthy of attention: the <em>maintainers of log4j would have loved to remove this bad feature</em> long ago, but could not because of the backwards compatibility promises they are held to.</p>

<p>I am often heard to say that I love backwards compatibility, and that it is underrated. But what exactly do I mean? I don&#39;t mean that whenever I upgrade a dependency, I expect zero side effects. If a library function gets two times faster in an upgrade, that is a change in behavior that might break my software! But obviously the exact timings of functions can change between versions. In some extreme cases I need libraries to promise the algorithmic complexity of run time or memory usage, where I am providing extremely large inputs, or need constant-time algorithms to avoid timing attacks. But I don&#39;t need that from a logging library. So let me back up and describe what is important.</p>



<h2>I want to not spend much time upgrading a dependency</h2>

<p>The ideal version of this is I run my package manager&#39;s upgrade command, execute the tests, commit the output, and not think about it any more. This means the API/ABI stays similar enough that the compiler won&#39;t break, the behavior of the library routines is similar enough the tests will pass, and no other constraints, such as total binary size limits, are exceeded.</p>

<p>This is impossible in the general case. The only way to achieve it is to not make any changes at all. When we write down a promise, we leave lots of definitional holes in the promise. E.g. take the (generally excellent) <a href="https://go.dev/doc/go1compat">Go compatibility promise</a>:</p>

<blockquote>
<p>It is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification.</p>
</blockquote>

<p>Here &#34;correctly&#34; means according to the Go language specification and the API documentation. The spec and the docs do not cover run time, memory use, or binary size. The next version of Go can be 10x slower and be compatible! But I can assure you if that were the case I would fail my goal of not spending much time upgrading a dependency.</p>

<p>But the Go team know this, and work to the spirit of their promise. Very <em>very</em> occasionally they break things, for security reasons, and when they do I have to spend time upgrading a dependency for a really good reason: my program needs it.</p>

<h2>I want any problems caused by the upgrade to be caught early, not in production.</h2>

<p>If I want my program to work correctly I should write tests for all the behaviors I care about. But like all programmers, I am short on hours in the day to do all that needs doing, and never have enough tests. So whenever a change in behavior happens in an upstream library that my tests don&#39;t catch but makes it into production, my instinct is to blame upstream. This is of course unfair, the burden for releasing good programs is borne by the person pressing the release button. But it is an expression of a programming social contract that has taken hold: a good software project tries to break downstream as little as possible, and when we do break downstream, we should do our best to make the breakage obvious and easy to fix.</p>

<p>No compatibility promise I have seen covers the spirit of minimizing breakage and moving it to the right part of the process. As far as I can tell, engineers aren&#39;t taught this in school, and many have never heard the concept articulated. So much of best practice in releasing libraries is learned on the job and not well communicated (yet). Good upstream dependencies are maintained by people who have figured this out the hard way and do their best by their users. As a user, it is extremely hard to know what kind of library you are getting when you first consider a dependency, unless it is a very old and well established project.</p>

<h2>I want to be able to build knowledge of the library over a long time, to hone my craft</h2>

<p>This is where software goes wrong the most for me. I want, year after year, to come back to a tool and be able to apply the knowledge I acquired the last time I used it, to new things I learn, and build on it. I want to hone my craft by growing a deep understanding of the tools I use.</p>

<p>Some new features are additive. If I buy a new <a href="https://en.wikipedia.org/wiki/Speed_square">speed square</a> for framing, and it has a notch on it my old one didn&#39;t that I can use as a shortcut in marking up a beam, its presence does not invalidate my old knowledge. If the new interior notch replaces a marking that was on the outside of the square, then when I go to find my trusty marking I remember from years ago, and it&#39;s missing, I need to stop and figure out a new way to solve this old problem. Maybe I will notice the new feature, or, more likely, I&#39;ll pull out the tape measure measure I know how to use and find my mark that (slower) way. If someone who knew what they were doing saw me they could correct me! But like programming, I&#39;m usually making a mess with wood alone in a few spare hours on a Saturday.</p>

<p>When software &#34;upgrades&#34; invalidate my old knowledge, it makes me a worse programmer. I can spend time getting back to where I was, but that&#39;s time I am not spending improving on where I was. To give a concrete example: I will never be an expert at developing for macOS or iOS. I bounce into and out of projects for Apple devices, spending no more than 10% of my hours on their platform. Their APIs change constantly. The buttons in Xcode move so quickly I sometimes wonder if it&#39;s happening before my eyes. Try looking up some Swift syntax on stack overflow and you&#39;ll find the answers are constantly edited for the latest version of Swift. At this point, I assume every time I come back to macOS/iOS, that I know nothing and I am learning the platform for the first time.</p>

<p>Compare the shifting sands of Swift with the stability of awk. I have spent not a tenth of the time learning awk that I have spent relearning Swift, and yet I am about as capable in each language. An awk one-liner I learned 20 years ago still works today! When I see someone use awk to solve a problem, I&#39;m enthusiastic to learn how they did it, because I know that 20 years from now the trick will work.</p>



<p>By what backwards compatibility means to me, a project like log4j will break fewer people by removing a feature like the JNDI URLs than by marking an old API method with some mechanical deprecation notice that causes a build process&#39;s equivalent of <code>-Wall</code> to fail and moving it to a new name. They will in practice, break fewer people removing this feature than they would by slowing down a critical path by 10%, which is the sort of thing that can trivially slip into a release unnoticed.</p>

<p>But the spirit of compatibility promises appears to be poorly understood across our industry (as software updates demonstrate to me every week), and so we lean on the pseudo-legalistic wording of project documentation to write strongly worded emails or snarky tweets any time a project makes work for us (because most projects don&#39;t get it, so surely every example of a breakage must be a project that doesn&#39;t get it, not a good reason), and upstream maintainers become defensive and overly conservative. The result is now everyone&#39;s Java software is broken!</p>

<p>We as a profession misunderstand and misuse the concept of backwards compatibility, both upstream and downstream, by focusing on narrow legalistic definitions instead of outcomes.</p>



<p>This is a harder, longer topic that maybe I&#39;ll find enough clarity to write properly about one day. It should be easy to hack up code and share it! We should also be cautious about adding burdensome features. This particular bug feels impossibly strange to me, because my idea of a logging API is file descriptor number 2 with the <em>write</em> system call. None of the bells and whistles are necessary and we should be conservative about our core libraries. Indeed libraries like these are why I have been growing ever-more skeptical of using any depdendencies, and now force myself to read a big chunk of any library before adding it to a project.</p>

<p>But I have also written my share of misfeatures, as much as I would like to forget them. I am thankful my code I don&#39;t like has never achieved the success or wide use of log4j, and I cannot fault diligent (and unpaid!) maintainers doing their best under those circumstances.</p>

	</div></div>
  </body>
</html>
