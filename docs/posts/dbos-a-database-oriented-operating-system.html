<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dbos-project.github.io/blog/intro-blog.html">Original</a>
    <h1>DBOS: A database-oriented operating system</h1>
    
    <div id="readability-page-1" class="page"><div>

                            <p>
                            Today, most people develop applications on operating systems such as Linux which are more than thirty years old,
                            even though computing has changed a lot in the meantime.
                            Since Linux was first released in 1991, the size of application state and data has grown by several orders of magnitude,
                            many applications have moved to the cloud,
                            and the world has woken up to the critical importance of security and data governance.
                            Using powerful tools like Spark and Kubernetes, developers have adapted to the ever-growing scale of computing,
                            but these introduce a great deal of <a href="http://www.cs.unc.edu/techreports/86-020.pdf" target="_blank">accidental complexity</a>
                            into even basic operations.
                            To make developing at scale easier, we—<a href="https://dbos-project.github.io" target="_blank">a team of almost twenty people at Stanford, MIT, UW-Madison, Google, VMWare, and other institutions</a>—are drastically rethinking the way people build distributed applications.
                            We&#39;re proposing a <b>database-oriented operating system (DBOS)</b>: a new operating system that
                            natively supports large-scale distributed applications in the cloud.
                            </p>

                            <p>
                            We believe the next generation of operating systems should be database-oriented because databases 
                            are built to solve the hard problems of modern computing.
                            Databases today can manage petabytes of data, are distributed and increasingly cloud-native, and can secure and govern data with fine-grained access control and provenance tracking.
                            Equally important, modern distributed in-memory data stores like <a href="https://www.voltactivedata.com/" target="_blank">VoltDB</a> and <a href="https://www.foundationdb.org/" target="_blank">FoundationDB</a> are becoming extremely fast,
                            and we show later they are fast enough to efficiently run many OS services that traditional disk-based RDBMSs could not.
                            To leverage these capabilities, we propose building a database-oriented operating system around two principles:
                            </p>

                            <ol>
                                <li>Store all application and OS state in tables in a distributed database.</li>
                                <li>Access state only through database transactions.</li>
                            </ol>

                            <p>
                            We see <b>two major advantages</b> to adopting these principles:
                            </p><ul>
                            <li>First, many critical properties, such as atomicity, durability, availability, and consistency, can be implemented
                            once in the DBMS and automatically inherited by the OS and by applications, simplifying building applications at scale.
                            For example, a cluster scheduler could store information on tasks and workers in database tables and implement scheduling operations as database transactions that mix imperative code and SQL. 
                            This simplifies hard problems like concurrency control and failure recovery: database transactions manage concurrent access to shared worker and task state and guarantee the consistency and durability of scheduler state through failures.</li>
                            <li>
                            Second, we can use powerful database provenance and logging capabilities to track accesses and updates to application state,
                            simplifying analyzing, monitoring, debugging, and securing applications.
                            For example, if we discover some private data was accessed inappropriately, we can investigate if that data was exfiltrated by writing a SQL query to find all
                            operations done by processes that earlier accessed that private data.</li>
                            </ul>
                            

                            <p>
                            Our proposal for DBOS follows a four-level architecture:
                            </p>

                            <p>
                                <img src="https://dbos-project.github.io/images/dbos_diagram.png" width="80%" sizes="(max-width: 2100px) 100vw, 2100px" alt=""/>
                            </p>

                            <p>
                            At Level 1, a kernel provides low-level OS services such as device drivers and memory management.
                            At Level 2, a distributed DBMS runs on those services.
                            At Level 3, we build high-level OS services such as a distributed file system, cluster scheduler, and distributed inter-process communication (IPC) subsystem on top of the DBMS.
                            At Level 4, users write applications.  We hope to support the high-level languages and frameworks people use today, but interfacing with DBOS services
                            instead of making Linux system calls or depending on a cluster manager like Kubernetes.
                            We believe that by implementing DBMS-oriented abstractions for distributed operations like cluster scheduling or message passing in the OS,
                            we can simplify building distributed applications.
                        	</p>

                        	<p>
                        	We have been working on DBOS for over a year and have prototyped it in two phases.
                        	In the first phase, discussed in papers published in <a href="https://vldb.org/pvldb/vol15/p21-skiadopoulos.pdf" target="_blank">VLDB&#39;22</a>
                        	and <a href="https://www.cidrdb.org/cidr2022/papers/p26-li.pdf" target="_blank">CIDR&#39;22</a>,
                        	we prototyped proof-of-concept DBMS-oriented implementations of OS services such as a file system, scheduler, and IPC subsystem,
                        	demonstrating they were practical.
                        	In the second phase, discussed in an <a href="https://arxiv.org" target="_blank">arXiv paper</a> currently undergoing peer review,
                        	we built a programmable environment based on DBOS principles, implementing a function-as-a-service (FaaS) interface,
                            and showed it could run user applications (including <a href="https://arxiv.org/ftp/arxiv/papers/2208/2208.05101.pdf" target="_blank">ML applications</a>) at scale.
                        	</p>

                        	<p>
                        	Our prototypes have convinced us that DBOS is practical, so we are now planning the next phase of the project:
                        	implementing a complete database-oriented development stack for distributed applications.
                        	To make this possible, we have to solve several major challenges.
                        	The most pressing is the question of what database to use.
                            Based on our experiences building our prototypes, we believe that only a distributed in-memory database can give us the scalability and performance we need.
                            However, DBOS requires many features that existing such databases lack,
                            so we are must figure out how to implement them.
                            Members of our team are currently researching:
                        	</p>

                        	<ul>
                                <li>Better tradeoffs between local and distributed transactions in a distributed database,
                                	leveraging cutting-edge research on high-performance distributed transactions
                                	(see our <a href="https://www.vldb.org/pvldb/vol15/p2939-zhou.pdf" target="_blank">Lotus paper</a>, published in VLDB&#39;22).</li>
                                <li>Better ways to support multiple data stores and data models in the DBOS backend, enabling operations like analytics and file I/O for which traditional databases are inefficient.</li>
                                <li>New infrastructure leveraging data provenance to make debugging distributed applications easier.</li>
                                <li>Better support for larger-than-memory datasets in in-memory databases, building on prior work from members of our team such as <a href="https://www.vldb.org/pvldb/vol6/p1942-debrabant.pdf" target="_blank">anti-caching</a>.</li>
                                <li>More efficient auto-scaling and resource management in distributed in-memory databases.</li>
                                <li>Better support for multi-tenancy in the DBMS, including resource and performance isolation.</li>
                            </ul><p>

                            We&#39;re also still thinking through some core systems design questions, most notably:

                            </p><ul>
                            	<li>Which OS services should be implemented below the DBMS (i.e., in the kernel) and which should be programmed on top of it in a database-oriented manner?</li>
                            	<li>What programming interface should DBOS provide?  Should it have a function-as-a-service programming model like our prototype or something else?
                            </li></ul><p>

                            We&#39;re incredibly excited about DBOS and have come a long way, but there&#39;s still a long way to go.
                            We&#39;re interested in any feedback people can provide about the DBOS ideas and the challenges we&#39;ve outlined as we figure out how to build this huge system.
                            Stay tuned for more updates!

                        </p></div></div>
  </body>
</html>
