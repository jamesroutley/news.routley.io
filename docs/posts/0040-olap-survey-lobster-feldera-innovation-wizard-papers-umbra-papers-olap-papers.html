<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scattered-thoughts.net/log/0040/">Original</a>
    <h1>0040: olap survey, lobster, feldera, innovation, wizard papers, umbra papers, olap papers</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>I published <a href="https://www.scattered-thoughts.net/writing/a-shallow-survey-of-olap-and-htap-query-engines">a shallow survey of OLAP and HTAP query engines</a>. </p>
<p>The last 2/3rds or so of this post contains all the supporting notes. Also a lot of papers on strategies for low-latency compilation.</p>
<h2 id="lobster"><a href="https://strlen.com/lobster/">lobster</a></h2>
<p>A surprisingly neat little language, exploring a lot of ideas that I&#39;ve been pondering.</p>
<p>Performance is apparently somewhat better than lua atm but the language design seems like it should allow ocaml-ish performance.</p>
<p>Heavy use of non-escaping closures, with a cute pythonic syntax:</p>
<pre data-lang="lobster"><code data-lang="lobster"><span>def sierpinski(depth) -&gt; void:
</span><span>    if depth:
</span><span>        gl_scale 0.5:
</span><span>            for(directions) d:
</span><span>                gl_translate d:
</span><span>                    sierpinski(depth - 1)
</span><span>    else:
</span><span>        gl_polygon(directions)
</span></code></pre>
<p>Those closures can return to functions other than themselves. Return defaults to the nearest named block but can also specify a function name to return to. It&#39;s not clear how that actually works. But in the implemention of exceptions it kind of looks like it can scan the callstack at runtime to find the nearest <code>try</code> function to return to. I guess since closures can&#39;t escape the stack, and their usage is monomorphized, you can always figure out at compile time if the return is valid?</p>
<p>Also monomorphizes on both type and ownership (to improve refcount elision), which doesn&#39;t seem to hurt the compilation time much. Typechecks after monomorphization, like zig.</p>
<p>Memory model seems similar to julia - structs declared as immutable can be allocated inline / on the stack. </p>
<p>Includes a graphical debugger, which is wild.</p>
<p>Also worth watching <a href="https://www.youtube.com/watch?v=TOnhqoUxLy0&amp;list=PLAOytOz0HZbJzO8xwDTCQA4cubNzzc2mH&amp;index=3">this talk</a> about their use of lobster in their game engine.</p>
<h2 id="feldera"><a href="https://github.com/feldera/feldera">feldera</a></h2>
<p>I somehow failed to notice that <a href="https://arxiv.org/pdf/2203.16684.pdf">DBSP</a> became a startup earlier this year. </p>
<p>I poked around a bit inside the code but there is a lot of it.</p>
<pre><code><span>&gt; scc
</span><span>-------------------------------------------------------------------------------
</span><span>Language                 Files     Lines   Blanks  Comments     Code Complexity
</span><span>-------------------------------------------------------------------------------
</span><span>Java                       409     49833     4616     11228    33989       2914
</span><span>Rust                       373    154141    16441     20910   116790       6914
</span><span>TypeScript                 251     17924     1448      1910    14566       1629
</span><span>Python                     113     11168     1558      1525     8085        340
</span><span>Markdown                    55      6145     1352         0     4793          0
</span><span>LaTeX                       29     11674     1442       360     9872          0
</span><span>Shell                       21      1495      125       173     1197        102
</span><span>Plain Text                  20     10176        0         0    10176          0
</span><span>YAML                        19      1144      139       293      712          0
</span><span>TOML                        18       743       87        12      644          8
</span><span>gitignore                   15       155       28        29       98          0
</span><span>CSV                         11     27254        0         0    27254          0
</span><span>SQL                         11       498       32        52      414         15
</span><span>JSON                        10      1430        6         0     1424          0
</span><span>SVG                          9         9        0         0        9          0
</span><span>Dockerfile                   4       263       42        48      173         29
</span><span>JavaScript                   4       488        5        45      438         18
</span><span>TypeScript Typings           4        37        6         9       22          1
</span><span>BASH                         3       151       19        33       99         17
</span><span>License                      3        78       16         0       62          0
</span><span>Makefile                     3        85       14        22       49          0
</span><span>Patch                        3       105       11         0       94          0
</span><span>CSS                          2        38        4         0       34          0
</span><span>Freemarker Template          2       319       20        16      283          0
</span><span>HTML                         2        23        0         0       23          0
</span><span>Docker ignore                1        10        0         1        9          0
</span><span>Jupyter                      1       454        0         0      454          0
</span><span>Visual Basic for Ap.         1      2922        0         0     2922          1
</span><span>XML                          1       238        5        16      217          0
</span><span>-------------------------------------------------------------------------------
</span><span>Total                     1398    299000    27416     36682   234902      11988
</span></code></pre>
<p>The java seems to be from <a href="https://calcite.apache.org/">calcite</a>. I can see why they wouldn&#39;t want to boil that ocean (although in <a href="https://www.youtube.com/watch?v=iT4k5DCnvPU">this talk</a> they mention difficulties getting calcite to be compatible with other sql dialects, or to share semantics with feldera for constant evaluation). Having a whole separate java runtime hanging around is a bit clunky but seems fine if the intent is to be cloud-native from the start.</p>
<p>It looks like they&#39;re also jitting the query plans - <a href="https://github.com/feldera/feldera/blob/main/crates/dataflow-jit/">https://github.com/feldera/feldera/blob/main/crates/dataflow-jit/</a>. That <em>is</em> an ocean-boiling project but I can see the motivation - materialize pays a lot of interpreter overhead. But I suspect that query planning should be the first hill to die on - compilation won&#39;t save you from bad join ordering decisions, and we don&#39;t have a good theory for query planning for incremental maintenance yet.</p>
<p>No mention of storage, which I think was the most common feature demanded for materialize.</p>
<h2 id="innovation">innovation</h2>
<p><a href="https://newsletter.mollywhite.net/p/the-venture-capitalists-dilemma">https://newsletter.mollywhite.net/p/the-venture-capitalists-dilemma</a></p>
<blockquote>
<p>For all the talk of unbridled innovation, venture capital services only very specific types of innovation: those that stand to produce large exits for investors, and with relatively low risk, regardless of whether the business itself holds much promise or provides any societal benefit.</p>
</blockquote>
<p><a href="https://slate.com/technology/2023/03/silicon-valley-bank-rescue-venture-capital-calacanis-sacks-ackman-tantrum.html">https://slate.com/technology/2023/03/silicon-valley-bank-rescue-venture-capital-calacanis-sacks-ackman-tantrum.html</a></p>
<blockquote>
<p>For the past 10 years venture capitalists have had near-perfect laboratory conditions to create a lot of money and make the world a much better place. And yet, some of their proudest accomplishments that have attracted some of the most eye-watering sums have been: 1) chasing the dream of zeroing out labor costs while monopolizing a sector to charge the highest price possible (A.I. and the gig economy); 2) creating infrastructure for speculating on digital assets that will be used to commodify more and more of our daily lives (cryptocurrency and the metaverse); and 3) militarizing public space, or helping bolster police and military operations.</p>
</blockquote>
<h2 id="a-fast-in-place-interpreter-for-webassembly"><a href="https://arxiv.org/pdf/2205.01183.pdf">A fast in-place interpreter for WebAssembly</a></h2>
<p>Wasm wasn&#39;t designed with interpreting in mind. Other wasm interpreters, including <a href="https://github.com/wasm3/wasm3">wasm3</a>, first translate wasm to some internal bytecode that is easier to intepret. For large wasm modules this can hurt startup time and use a lot of extra memory. The interpreter in the paper instead augments wasm with some small metadata to speed up the interpreter.</p>
<p>Just eyeballing the graphs, the result is 2-3x slower than wasm3 but ~10x faster to start up and has ~5x less space overhead.</p>
<p>Branching instructions in wasm encode their destination in terms of relative nesting depth. They don&#39;t include information about where the next instruction is or how many values to pop from the stack. But that information is computed during validation, so the interpreter just needs to save it somewhere.</p>
<p>The lookup for that metadata needs to be fast and not use too much space, so neither a hastable or array (with the instruction pointer being the key) are suitable. The solution is neat: For branches that aren&#39;t taken, the next branch&#39;s metadata is always in the next slot. For branches that are taken, the metadata includes the relative offset for the next metadata.</p>
<p>Wasm is stack-oriented. For compilers this is usually just an encoding detail - the stack effects are all statically known so they&#39;re easy to map into dataflow. But an interpreter has to actually model the stack directly. Values are all stored unboxed in the stack. For the sake of the garbage collector a 1 byte type tag is added to distinguish gced pointers (precomputing stack maps would be too slow). Eliminating tags (eg if the gc extension is disabled) provided an 8% speedup. Stack overflow is detected by a guard page.</p>
<p>The interpreter is written in assembly and reserves a dedicated register for important variables.</p>
<p>Instructions are dispatched via 256-entry dispatch tables. Instructions are LEB-encoded, so any opcode that starts with a 1 dispatches to a special handler that decodes the LEB and then jumps back into a dispatch table, providing a 5% speedup over doing the decoding inline. </p>
<p>They implemented both direct and threaded dispatch. The latter provided a 14% speedup.</p>
<p>For profiling and setting breakpoints, a wasm opcode can be overwritten with a special instruction that causes the interpreter to execute a handler loaded from the probe table before continuing with the original bytecode. For debugging, a global flag can be set which causes the probe table to be used for every instruction.</p>
<h2 id="whose-baseline-compiler-is-it-anyway"><a href="https://arxiv.org/pdf/2305.13241.pdf">Whose baseline (compiler) is it anyway?</a></h2>
<p>An overview of baseline compilers for wasm, followed by a comparison to the authors new baseline compiler in Wizard.</p>
<p>(Reports that, anecdotally, the simplest baseline compilers often provide 3-10x runtime perf over an interpreter.)</p>
<p>Wasm is designed for single-pass compilation. Can maintain an abstract representation of the value stack, tracking register allocations and doing basic constant propagation (not just for constant-folding, but for better instruction selection eg using immediate operands).</p>
<p>The abstract representation for a value on the abstract stack is subtle. My first though would have been to write: </p>
<pre data-lang="zig"><code data-lang="zig"><span>union</span><span>(</span><span>enum</span><span>) { 
</span><span>  constant</span><span>: </span><span>Value</span><span>, 
</span><span>  register</span><span>: </span><span>Register</span><span>, 
</span><span>  stack</span><span>,
</span><span>}
</span></code></pre>
<p>But consider a sequence like <code>(local.get 0) (local.set 1) (local.get 1)</code>. If local 0 is loaded into <code>eax</code> and then written back in to the stack location for local 1, then the next <code>(local.get 1)</code> can just read from <code>eax</code> instead of issuing a store. So we actually want:</p>
<pre data-lang="zig"><code data-lang="zig"><span>union</span><span>(</span><span>enum</span><span>) { 
</span><span>  constant</span><span>: </span><span>Value</span><span>, 
</span><span>  register</span><span>: </span><span>Register</span><span>,
</span><span>  </span><span>// Has been saved to the stack but may also still be hanging around in a register
</span><span>  stack</span><span>: </span><span>?</span><span>Register</span><span>, 
</span><span>}
</span></code></pre>
<p>This seems like a minor point, but it provided 25% speedup on some benchmarks!</p>
<p>Loops are tricky. When we branch back to the start of the loop we&#39;re going to need to restore the current abstract environment. There is some tradeoff between how much we get to assume at the start of the loop vs how much work we have to do to restore those instructions. And because we&#39;re going single-pass, we don&#39;t even know which locals the loop body might use or change. To make life harder, wasm compilers also have to deal with adversarial input so it&#39;s important that all the merging and shuffling calculations don&#39;t have any expensive edge cases.</p>
<p>Supporting debugging is tricky. Most of the compilers studied simply don&#39;t. Wizard uses the same stack representation for both the interpreter and the compiler, so that when switching to the interpreter for debugging it&#39;s easy to display the values of variables.</p>
<p>Wizard uses value tagging for gc. Other compilers either don&#39;t support the wasm gc extension, or reuse the stack map support from a js engine. To reduce the overhead of writing tags, wizard only stores them at yield points. The overhead vs no tags at all varied between benchmarks, 0.9-4.9%. Whereas always storing tags could be up to 3x slower - this seems surprising, but I suppose it means a lot more stores compared to the values themselves which often stay in registers.</p>
<h2 id="harmonizing-classes-functions-tuples-and-type-parameters-in-virgil-iii"><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41446.pdf">Harmonizing Classes, Functions, Tuples, and Type Parameters in Virgil III</a></h2>
<p>The language that Wizard is written in.</p>
<p>Brief and tantalizing mention of staged compilation.</p>
<p>Primitives, arrays, tuples, functions, classes. Single inheritance. No interfaces. </p>
<p>Type cast operator for conversions and downcasts.</p>
<p>Tuples are immutable and so are covariant.</p>
<p>Classes and functions can take type parameters eg <code>List&lt;T&gt;</code>. Type parameters are stored for use in casts, rather than erased.</p>
<p>Object methods are bound to the object. Interfaces can be emulated by returning an object of bound methods. Since the interface object can be parameterized by types, this also emulates abstract datatypes.</p>
<p>Closed adhoc polymorphism can be emulated with type tests/casts. Open adhoc polymorphism can be emulated by a dynamic list of dispatch functions.</p>
<p>Sum types can be emulated by subtyping and type tests/casts (at the cost of not checking exhaustiveness).</p>
<p>Classes are invariant in type parameters (because the representation varies) but function variance can be used as a workaround.</p>
<p>Virgil doesn&#39;t distinguish between the types of <code>f(a: int, b: int)</code> and <code>g(a: (int, int))</code> which can lead to tricky calling conventions. Workaround is to make the calling convention unpacked scalars for all functions. A generalization of SROA. This requires monomorphization.</p>
<p>In their experience, monomorphization has not lead to too much code bloat. (But only ~100kloc of Virgil have ever been written).</p>
<p>Runtime and gc are also written in Virgil. (Presumably this relies on the absence of implicit heap allocation).</p>
<h2 id="everything-you-always-wanted-to-know-about-compiled-and-vectorized-queries-but-were-afraid-to-ask"><a href="https://www.vldb.org/pvldb/vol11/p2209-kersten.pdf">Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask</a></h2>
<p>The authors implemented a query compiler and vectorized interpreter in the same (toy) database system for an apples-to-apples comparison on (a subset of) TPC-H and SSB.</p>
<p>They verified that each implementation, despite being a toy, performs similarly to production-grade equivalents with the same strategy.</p>
<p>Overall performance is not that different. I wanted to compare codesize but it looks like they just manually typed out c++ that a compiler would have emitted, rather than actually writing the compiler. Also they only did this for 5 queries. (This makes sense as a cheap way to decide which strategy to use for their database, but wasn&#39;t super obvious from the paper itself).</p>
<p>The vectorized version:</p>
<ul>
<li>Produces more L1 misses because of materializing intermediates rather than keeping them in registers.</li>
<li>Has more speculation-friendly join loops, leading to fewer memory stalls.</li>
<li>Executes more instructions per row, due to additional loads/stores for intermediates.</li>
<li>Spends ~1.5% of cpu time in the interpreter itself - minimal overhead.</li>
<li>Performed best with vectors of 1000-4000 tuples.</li>
</ul>
<p>In microbenchmarks, using simd for selection (picking the rows for which there is a corresponding 1 in the selection bitvector) lead to speedups of 8.4x. But in TPC-H Q6 they observe only 1.4x speedup. With multiple filters, all filters after the first are operating on very sparse vectors. When the input vector is only 50% full, both simd and scalar versions are dominated by cache misses and perform the same.</p>
<p>For computing hashes, simd delivers 2.3x speedup. But for looking up hashes in the hashtable cache misses dominate again. By the time input data reaches 10s of mb, the scalar and simd implementations perform the same.</p>
<p>These simd experiments were done by hand. When they relied on compiler auto-vectorization instead they saw no speedups.</p>
<p>They note that simd may be more useful for lightweighht compression.</p>
<p>Both systems scaled equally well to 20 threads.</p>
<p>The above numbers are all in-memory. Reading data from an ssd instead reduced the performance difference between the two.</p>
<p>Aside from the experiments above, they note that:</p>
<ul>
<li>Compiled engines are more easily able to integrate user-defined operators.</li>
<li>Vectorized engines are much easier to profile and debug.</li>
<li>Vectorized engines pay a materialization cost for multi-column sorts.</li>
</ul>
<p>The approaches can be mixed. HyPer compiles queries but uses pre-compiled vectorized functions for scanning compressed columns. Peloton introduces materialization boundaries in compiled code to allow use of prefetching.</p>
<p>They don&#39;t give much attention to the problem of compilation latency, but in the next paper they ended up building their own low-latency compiler.</p>
<h2 id="tidy-tuples-and-flying-start-fast-compilation-and-fast-execution-of-relational-queries-in-umbra"><a href="https://link.springer.com/content/pdf/10.1007/s00778-020-00643-4.pdf">Tidy Tuples and Flying Start: fast compilation and fast execution of relational queries in Umbra</a></h2>
<p>Their previous database HyPer, now used in Tableau, sometimes hits multi-second compile times for queries when using the LLVM backend.</p>
<p>Their new compiler has lower compile times than their previous bytecode interpreter but has runtime performance almost as good as their LLVM-based compiler. On TCP-H it outperforms postgres/duckdb/monetdb even on small datasets (albeit using 20 threads), and outperforms their previous compiler except on the largest datasets.</p>
<p>On TPC-H vs LLVM O3 they trade 108x faster compilation for 1.2x slower runtime. Compile times get worse with the size of the query - on a 2000 table join theyt get ~0.03s vs ~150s for LLVM.</p>
<p>&#39;Tidy tuples&#39; takes query plans to IR. &#39;Flying start&#39; takes IR to native code.</p>
<p>Tidy tuples is written in abstract interpreter style. While it&#39;s built up in many layers, each layer is push-based - there is no materialization of intermediate IR. The api reflects ir/sql types into the cpp type system.</p>
<p>The IR is SSA. It&#39;s generation is mostly append-only per-block. The representation uses only three contiguous allocations, listing functions, basic blocks and instructions respectively. Instruction format is: opcode, result-type, operands (32 bit offsets).</p>
<p>The IR building does constant-folding and -deduplication at build time. A later pass does dead code elimination.</p>
<p>Checked arithmetic, array/struct access, null checks and a few other db-specific operations get dedicated IR instructions.</p>
<p>Flying start takes one pass to analyze value lifetimes (using the algorithm described <a href="https://dl.acm.org/doi/pdf/10.1145/330249.330250">here</a>) and one pass to generate code.</p>
<p>Register allocation prefers to give registers to values in the mostly deeply nested loops. Replacing this heuristic with Linear Scan hurt compile times more than it helped runtimes.</p>
<p>The lifetime analysis supporting the register allocation heuristic costs 45% of their runtime. (I wonder how this owuld compare to the greedy strategy used in wizard above, which is always willing to spill old values for new.) </p>
<p>The <code>getelementptr</code> instruction is folded into load/store instructions to produce a single <code>mov</code>. Comparison and branch instructions are fused where possible eg <code>if (x &lt; y) ...</code> can become a <code>cmp</code> followed by <code>jl</code>.</p>
<p>They use <a href="https://asmjit.com/">asmjit</a> to emit native code.</p>
<p>LOC:</p>
<ul>
<li>Tidy tuples ~= 22 kloc</li>
<li>IR ~= 3 kloc</li>
<li>Flying start ~= 4 kloc</li>
</ul>
<p>I&#39;m not surprised that the sql translation layer is where most of the effort went.</p>
<h2 id="bringing-compiling-databases-to-risc-architectures"><a href="https://db.in.tum.de/people/sites/gruber/p791-gruber.pdf?lang=en">Bringing Compiling Databases to RISC Architectures</a></h2>
<p>Adding an arm backend to the above compiler.</p>
<p>The IR doesn&#39;t support aggregate types. Instructions which need to return multiple values are paired with &#39;ghost instructions&#39; to retrieve values other than the first. This produces less instructions overall and makes isel easier later.</p>
<p>Notes the the linear scan lifetime analysis work because they avoid ever producing irreducible loops.</p>
<p>Register allocation is easier on arm: more general purpose registers, more 3-operand instructions.</p>
<p>Had to tweak IR to deal with weaker memory ordering and aligned accesses. </p>
<p>Isel has to fuse IR instructions to take advantage of arm instructions like multiply-add.</p>
<p>The arm backend adds another 8 kloc. Compare to their LLVM backend at 2.3 kloc or their IR interpreter at 2.6 kloc. Not a huge amount of extra effort for a much better point in the compile-time runtime tradeoff space.</p>
<p>Interesting that their interpreter isn&#39;t terrible either though - seems well within 5x the runtime of the llvm backend.</p>
<p>They post some impressive benchmarks vs duckdb, but don&#39;t mention how many threads they&#39;re using to outperform single-threaded duckdb.</p>
<h2 id="on-another-level-how-to-debug-compiling-query-engines"><a href="http://131.159.16.103/%7Ekersten/codegen_debugger.pdf">On Another Level: How to Debug Compiling Query Engines</a></h2>
<p>A simple and clever way to debug a compiler. When compiling the code they take a recording using rr. When debugging the generated code in gdb, every time the ip changes they ask rr to jump to the point in the compiler recording where that ip was emitted.</p>
<h2 id="data-blocks-hybrid-oltp-and-olap-on-compressed-storage-using-both-vectorization-and-compilation"><a href="http://131.159.16.103/downloads/publications/datablocks.pdf">Data Blocks: Hybrid OLTP and OLAP on Compressed Storage using both Vectorization and Compilation</a></h2>
<p>The in-memory format for HyPer. Trying to push both OLTP and OLAP performance.</p>
<p>Data is divided into blocks. Hot blocks are mutable. Cold blocks are compressed and immutable (except for setting &#39;deleted&#39; flags).</p>
<p>Value layout is columnar-per-block.</p>
<p>The compression method chosen can vary per block, between:</p>
<ul>
<li>Single-value eg all the values are null.</li>
<li>Dictionary encoding (order-preserving, so that range scans can be evaluated without dictionary lookup).</li>
<li>Truncation - replace <code>v</code> by <code>v - min</code> (if the range of values is small, they can now fit in a smaller integer type).</li>
</ul>
<p>Basic range scans can be evaluated without decompression. Values remain byte-addressable (no bit-weaving) so external indexes can point into the compressed block. This lightweight compression uses ~25% more space than the aggresive compression in vectorwise.</p>
<p>Each block records min/max values for each attribute and a &#39;Positional Small Materialized Aggregate&#39; - a lookup table mapping the most-significant non-zero byte of a value to the range in the block where it might be found. So for 8/16/32 bit values the PSMA takes up 2/4/8 kb.</p>
<p>Column scans use the psma to reduce the range they have to look at. But in the worst case it&#39;s still a vectorized scan of the whole block - not like tree indexes where the worst case is much slower than a full scan.</p>
<p>Scans are pre-compiled rather than inlined into the compiled query - the different compression schemes would generate too many code paths. Scans generate a vector of matching tuples which are the compiled query then loops over tuple-at-a-time.</p>
<p>Within each scan, each predicate is evaluated using simd instructions. The first predicate produces a bitmask, which is turned into a list of absolute positions using an 8-bit lookup table. Successive predicates operate only on the tuples identified by the absolute positions and the resulting bitmask is turned into a shuffle on the list using the same 8-bit lookup table. (The 8-bit lookup table is 8kb which fits in L1). The speedup on a single scan from simd varies between 5x on 8 bit values to ~1.5x on 64 bit values (but bear in mind that compression can reduce the size of values). The speedup for successive scans is much lower - cost is dominated by random access to the matching values.</p>
<p>On a dataset of 15m records, the cost of a scan vs an point index lookup on 15m records was as much as 7000x. But <em>if</em> the data happened to be sorted by the attribute in question this drops to 17x using the min/max values alone, or 4x using the PSMAs.</p>
<h2 id="seamless-integration-of-parquet-files-into-data-processing"><a href="https://dl.gi.de/server/api/core/bitstreams/9c8435ee-d478-4b0e-9e3f-94f39a9e7090/content">Seamless Integration of Parquet Files into Data Processing</a></h2>
<p>Want to run queries directly over remotely-stored parquet files without any conversion step.</p>
<p>The parquet format is flexible enough that writing the same data with different libraries can produce wildly different files eg varying between 20-33gb for the same data.</p>
<p>Reuse the db buffer manager to cache requests against the remote file.</p>
<p>Parquet files can contain useful metadata, but these are optional so the db needs a good fallback. Every time they touch a chunk of a parquet file, they update SMAs (for faster column scans) and hyperloglog sketches (for better query planning). So initial queries are typically whole-table scans but future queries can be smarter.</p>
<h2 id="mainlining-databases-supporting-fast-transactional-workloads-on-universal-columnar-data-file-formats"><a href="https://arxiv.org/pdf/2004.14471.pdf">Mainlining databases: Supporting fast transactional workloads on universal columnar data file formats</a></h2>
<p>Authors wanted to build an OLTP database with close-to-zero-cost interop with other tools that produce and consume Arrow. </p>
<p>(Why? They try exporting a 60m tuple table from postgres to pandas and it takes 284s minutes. In their Arrow-based db it takes 7-70s depending on the mutation rate.)</p>
<p>So just use Arrow internally? Problem is that Arrow is not well suited to mutable data. And also doesn&#39;t have anywhere to store row versions.</p>
<p>Cold blocks are just Arrow.</p>
<p>For hot blocks, they store pointers to version chains in an extra Arrow column which doesn&#39;t get exported. Each transaction as an undo buffer - the version chain contains pointers into this buffer. The buffer stores values row-wise so when querying hot blocks the query engine has to materialize everything into rows. </p>
<p>While hot, pointers to variable length data (eg strings) are allowed to point outside the block itself. Some additional metadata is needed to mark old data gaps in the original block. When a hot block is converted to cold all the latest value are repacked in contiguous memory.</p>
<p>Compacting hot blocks is expensive, so where possible they fill gaps by moving individual tuples in a transaction.</p>
<p>Compaction is potentially racy so it&#39;s modelled as a transaction itself.</p>
<p>Cold blocks can be exported directly. Exporting hot blocks requires materialization.</p>
<h2 id="a-deep-dive-into-common-open-formats-for-analytical-dbmss"><a href="https://www.vldb.org/pvldb/vol16/p3044-liu.pdf">A Deep Dive into Common Open Formats for Analytical DBMSs</a></h2>
<p>Comparing Arrow(/Feather), Parquet and ORC for internal database format (as opposed to converting at ingestion time).</p>
<p>Arrow and ORC require data to be fully loaded before queried. Parquet can stream data.</p>
<p>Encoding (without further compression): Parquet produces substantially better compression ratios on all data types. Results vary depending on the dataset, so allowing multiple compression methods like Data Blocks should dominate. Parquet does better than ORC/Feather on strings mostly because of it&#39;s larger chunk size.</p>
<p>Applying compression to the encoded format mostly reduces the differences. Feather is the exception because &#39;it lacks encoding support for integers&#39; - not sure what that means.</p>
<p>Serde perf: They measure using Arrow as the in-memory format, which seems like it gives Feather an unfair advantage. Deserialization is fastest for uncompressed Feather, since there&#39;s nothing to do, but this is totally defeated by having to read more data from the disk.</p>
<p>Projection: Feather does poorly because it has to read the entire chunk before projecting a single column. Except for string columns, where the cost is outweighed by the advantage of not having to dictionary-decode. Feather also spends way too much time in locking.</p>
<p>Selection: Only Parquet can skip individual rows, but the performance advantage is outweighed by it&#39;s slow deserialization.</p>
<p>They get substantial improvements on query perf (~100x) from modifying the access apis to allow querying data without decoding.</p>
<p>I&#39;d have liked to see the various design choices compared directly, without the massive complication of different compression strategies obscuring all the results.</p>
<p>Lessons:</p>
<ul>
<li>Allow varying encoding on a per-block basis. Different datasets work better with different encodings.</li>
<li>Support random access in all encodings (to allow querying encoded data). </li>
<li>Separate encoding (which can preserve random access) from compression. Avoid whatever mistakes Feather made that make it compress poorly.</li>
</ul>
<p>Basically just read the Data Blocks paper.</p>
<h2 id="cloud-native-transactions-and-analytics-in-singlestore"><a href="https://dl.acm.org/doi/pdf/10.1145/3514221.3526055">Cloud-Native Transactions and Analytics in SingleStore</a></h2>
<p>Trying to keep a bunch of specialized databases in sync is a pain in the ass. Would be nicer to have a single database that handles many workloads well.</p>
<p>Queries compiled to bytecode and then llvm. Starts out interpreting bytecode and swaps to compiled code when ready.</p>
<p>In-memory data in a row-oriented skiplist. MVCC for readers. Row locks for writers. Transaction log and background snapshots.</p>
<p>On-disk data in a column store. Batches of rows. Allows different encodings per segment. Metadata (including tombstones and SMAs) stored in-memory. Storing tombstones in-memory avoids the need to merge keys when reading from the lsm, which would suck for OLAP-style scans. Encodings all allow positional access (except LZ4, presumably). </p>
<p>On-disk segments form an LSM-tree with the in-memory store as level 0.</p>
<p>Optionally, cold data is periodically moved to a blob store. Since blob storage is cheap, they can typically keep months of snapshots.</p>
<p>In cloud setting, default is to not fsync - losing the node usually means losing the disk too.</p>
<p>Some query operators can be evaluated on encoded data.</p>
<p>Secondary indexes are two-level:</p>
<ol>
<li>A per-segment index maps values to a list of offsets.</li>
<li>A global index maps hashes of values to the entry in the per-segment index. (To guard against hash collisions they check the value in the per-segment index).</li>
</ol>
<p>The global index is itself an LSM-tree where each level is a hash-table. When segments are deleted, readers skip them. The lsm merge eventually removes references to deleted segments. This takes secondary index maintenance out of the critical path for writes.</p>
<p>Since lookups in the global index just produce a list of per-segment index entries, lookups against multiple secondary indexes can be combined easily even before looking at the segments themselves.</p>
<p>Multi-column indexes can be built on top of single-column indexes with another layer of indirection.</p>
<p>Secondary indexes can be used to enforce uniqueness constraints.</p>
<p>To update or delete a row, first it&#39;s moved in-memory. While the row-lock is held it&#39;s safe to mutate the corresponding tombstone bit in the metadata. (This design requires that all ongoing transaction data fits in memory. The transaction system couldn&#39;t be used for migrations as in the papers below.)</p>
<p>Query planning is adaptive. If probing the secondary indexes produces too many results then it will fall back to checking each segment. Filters are planned per-segment by timing the results on a small sample. Also the filters whose sampled selectivity is lowest are run first.</p>
<p>On both TPC-C and TPC-H they outperform their anonymous peers.</p>
<p>(Skipping the details of replication).</p>
<h2 id="bullfrog-online-schema-evolution-via-lazy-evaluation"><a href="https://dl.acm.org/doi/pdf/10.1145/3448016.3452842">BullFrog: Online Schema Evolution via Lazy Evaluation</a></h2>
<p>Represent the result of the migration as a view over the old database. While the migration is progressing, queries over the new table are converted into queries over the old table and the relevant tuples are migrated immediately. Any writes can then be performed against the migrated tuples.</p>
<p>I didn&#39;t go further into the implementation details because it seems really hard to predict which queries will be efficiently answerable through the view ie for which the set of relevant tuples in the old table isn&#39;t enormous.</p>
<h2 id="online-schema-evolution-is-almost-free-for-snapshot-databases"><a href="https://www.vldb.org/pvldb/vol16/p140-hu.pdf">Online Schema Evolution is (Almost) Free for Snapshot Databases</a></h2>
<p>The basic idea is to leverage MVCC. Store the schema in tables, and then schema changes can be done via regular transactions.</p>
<p>Done naively this would trash performance. A migration of a single table would conflict with any writes to that table. It&#39;s bad enough if the write gets aborted, but aborting and retrying an entire migration could be incredibly expensive. Also the write set for a migration would be huge.</p>
<p>Usually in MVCC each table has an indirection array mapping record ids to their version chain. In Tessaract, each schema version has it&#39;s own indirection array. While the migration is underway, other writes operate against the previous schema version. When the migration completes, the transaction log is scanned to find any writes that it missed.</p>
<p>To ensure that the log scanning doesn&#39;t trail behind forever, the migration first publishes a tentative version of the new schema and indirection array. Then it only has to process log entries between when migration started and when it finished with the old indirection array. (Concurrent transactions must check both the old and new indirection arrays to make sure they don&#39;t read rows which have been modified in the old but not migrated to the new).</p>
<p>Rather than maintaining a write set, the migration always reads the latest versions it can find and then copies their timestamp into the new indirection array.</p>
<p>Microbenchmarks on a toy implementation look reasonable.</p>
<h2 id="zng-specification"><a href="https://zed.brimdata.io/docs/formats/zng">ZNG Specification</a></h2>
<p>The row format for zed.</p>
<p>Roughly a superset of json, with first-class types. </p>
<p>The binary format includes an inline encoding of types. Later values of the same type can just refer to the type id.</p>
<p>A steam is a sequence of frames. Each frame contains either types, values or control data.</p>
<p>Frame starts with:</p>
<ul>
<li>1 bit version number</li>
<li>1 bit compression bit</li>
<li>2 bit type:
<ul>
<li>Types</li>
<li>Values</li>
<li>Control</li>
<li>End of stream</li>
</ul>
</li>
<li>Frame length in variable-length encoding (same as LEB?)</li>
</ul>
<p>If the compression bit is set, there is a compression header:</p>
<ul>
<li>8 bit format</li>
<li>Uncompressed size in variable-length encoding</li>
</ul>
<p>Types frames contain a list of type definitions. Type ids are variable length integers. Primtive types have predefined ids.</p>
<p>Values frames contain, uh, values. Each value starts with a type id.</p>
<p>Compound values are encoded as a tree of primitives. This tree can be decoded without knowing the type: Each value starts with a variable-length integer. Either 0 for null or <code>length+1</code> for other values, where length is the number of nested values.</p>
<p>Sets are sorted in byte-order. No mention of sorting for maps though.</p>
<p>Control frames are application dependent - the zng library passes them through directly.</p>
<p>Ids defined in a types frame are valid until end of stream. Chopping a large stream into smaller streams offers more opportunities for resychronization, at the cost of sending redundant type data.</p>
<p>First-class types embedded in data must be encoded in place - they cannot refer to type ids in the context or serialization would be context-dependent. (But it already is? The ids in the frame will vary depending on the context).</p>
<h2 id="vng-specification"><a href="https://zed.brimdata.io/docs/formats/vng">VNG Specification</a></h2>
<p>The columnar format for zed.</p>
<p>Encodes a stream of heterogenous values, each of which has a concrete type. </p>
<p>Already have <a href="https://zed.brimdata.io/docs/formats/zng">ZNG</a>, the row-oriented binary format. VNG is itself encoded in terms of ZNG.</p>
<p>To convert to ZNG, scan backwards from the end until find a record with type:</p>
<pre><code><span>{
</span><span>  magic:string,
</span><span>  type:string,
</span><span>  version:int64,
</span><span>  sections:[int64],
</span><span>  meta:{
</span><span>    skew_thresh:int64,
</span><span>    segment_thresh:int64,
</span><span>  },
</span><span>}
</span></code></pre>
<p>(How do we scan backwards? Is ZNG self-synchronizing?)</p>
<p>This is the trailer. It provides the sizes of the data and reassembly sections.</p>
<p>The data section is divided into segments. Each segment is a stream of primitive (ie non-compound) ZNG values. </p>
<p>There are no row groups. Different columns can cut their segments off at different lengths. This is intended to make scans of low-selectivity types efficient. </p>
<p>The reassembly section lists the unique concrete types of the values (types are first-class in ZNG).</p>
<p>For each type there is a &#39;reassembly map&#39; of type <code>&lt;any_column&gt;</code> where:</p>
<pre><code><span>&lt;any_column&gt; = ((
</span><span>    &lt;record_column&gt;,
</span><span>    &lt;array_column&gt;,
</span><span>    &lt;map_column&gt;,
</span><span>    &lt;union_column&gt;,
</span><span>    &lt;primitive_column&gt;,
</span><span>));
</span><span>
</span><span>&lt;record_column&gt; = |{
</span><span>  &lt;field_name&gt;, 
</span><span>  {
</span><span>    column:&lt;any_column&gt;,
</span><span>    // RLE bitvector indicating null values
</span><span>    presence:&lt;segmap&gt;,
</span><span>  },
</span><span>}|;
</span><span>
</span><span>&lt;array_column&gt; = {
</span><span>  values:&lt;any_column&gt;,
</span><span>  lengths:&lt;segmap&gt;,
</span><span>};
</span><span>
</span><span>&lt;map_column&gt; = {
</span><span>  key:&lt;any_column&gt;,
</span><span>  value:&lt;any_column&gt;,
</span><span>};
</span><span>
</span><span>&lt;union_column&gt; = {
</span><span>  columns:[&lt;any_column&gt;],
</span><span>  tags:&lt;segmap&gt;,
</span><span>};
</span><span>
</span><span>&lt;primitive_column&gt; = &lt;segmap&gt;;
</span><span>
</span><span>&lt;segmap&gt; = [
</span><span>  {
</span><span>    offset:uint64,
</span><span>    length:uint32,
</span><span>    mem_length:uint32,
</span><span>    compression_format:uint8,
</span><span>  }
</span><span>];
</span></code></pre>
<p>(Why does only <code>record_column</code> have a presence vector? Can arrays and maps not contain nulls?)</p>
<p>No details given on compression formats, but in the code the only option is LZ4.</p>
<p>Finally there is a single list of integers in [0,unique_type_count) determining the type of each value in the stream.</p>
<p>Thoughts:</p>
<ul>
<li>Entangling nulls with records seem unwise. Maybe a <code>&lt;nullable_column&gt; = {column:&lt;any_column&gt;, presence:&lt;segmap&gt;}</code>?</li>
<li>This format doesn&#39;t preserve random access which means we can&#39;t build secondary indexes on top of it.
<ul>
<li>Segments can be LZ4 compressed. This would have to be disabled.</li>
<li>There is no map from row index to &#39;row-of-type-T&#39; index. This could be solved by additional metadata, or by not preserving ordering.</li>
<li>The lack of row groups means that data for a single row can be scattered across the whole file - potentially many block reads to reconstruct.</li>
</ul>
</li>
<li>The lack of row groups may also make parallel scans difficult - potentially many redundant reads between workers. Possibly the intention is to only parallelize across streams rather than within? In which case the streams themselves act like row groups.</li>
</ul>
<p>Heterogenous data is an interesting challenge. Optimizing for materialization and parallel scans makes us want to group by rows, but optimizing for space and for type-specific scans makes us want to group by type.</p>
<h2 id="delta-lake-high-performance-acid-table-storage-over-cloud-object-stores"><a href="https://15721.courses.cs.cmu.edu/spring2023/papers/20-databricks/p975-armbrust.pdf">Delta Lake: High-Performance ACID Table Storage over Cloud Object Stores</a></h2>
<p>Storage layer for Databricks lakehouse product. (Lakehouse = structured query pipelines over unstructured data lake. Alternative to separate ETL pipeline.)</p>
<p>Structured layer over blob store eg S3. </p>
<p>Even for OLAP need writes for eg GDPR compliance. But blob stores typically provide no cross-key consistency guarantees. Early Databricks tried to get away without ACID but consistency and performance problems were half of their support workload.</p>
<p>Basic idea: Store WAL and metadata checkpoints in the blob store too. Background process compacts the log into immutable data files.</p>
<p>For best perf on blob stores, need large sequential io and lots of parallelism.</p>
<p>Data stored in parquet. WAL is json but checkpoints are parquet.</p>
<p>For (possibly stale) reads:</p>
<ol>
<li>Read last checkpoint.</li>
<li>List journal entries since last checkpoint.</li>
<li>Read journal entries from last checkpoint to most recent entry in list.</li>
<li>Read from data objects.</li>
</ol>
<p>Due to eventual consistency, some reads in 3 and 4 might have to wait until underlying objects become visible.</p>
<p>For writes, first write all data to new files. Then atomically CAS a new journal entry (or retry transaction on failure). Some blob stores provide a suitable atomic primitive, but on S3 they have to use a separate coordinator. Transaction throughput is poor, but good enough for OLAP.</p>
<p>They also reuse the WAL as a (high-latency) message bus.</p>
<p>Some schema migrations (eg adding a column) are just a WAL entry and can avoid rewriting old files.</p>
<p>WAL is per-table, so no cross-table transactions.</p>
<p>No mention of garbage collection. Seems tricky.</p>
<h2 id="photon-a-fast-query-engine-for-lakehouse-systems"><a href="https://15721.courses.cs.cmu.edu/spring2023/papers/20-databricks/sigmod_photon.pdf">Photon: A Fast Query Engine for Lakehouse Systems</a></h2>
<p>Query engine on top of Delta Lake.</p>
<p>Written in C++ because they hit limits with GC performance and JIT deopts in the JVM.</p>
<p>Chose vectorized over compiled. Easier to build. Easier debugging/profiling. Better support for adaptive execution. Can still get some benefits of specialization by having manually fused operators for common combinations.</p>
<p>Columnar data grouped by row. Pool of batches for reusing allocations. Variable-length data in a per-batch arena.</p>
<p>Operators switch implementation per-batch, depending on eg whether the batch contains nulls, whether the rows are sparse or dense, whether all strings are ascii-only.</p>

<p>Facebook has too many custom data systems. Typically the frontend and storage engine vary but the execution layers all look similar. Velox is a reusable execution layer.</p>
<p>Fairly standard type system. Serialization format that covers all types. Type system is extensible by clients.</p>
<p>Vectors are an extension of Arrow. More encoding options. Support random writes. Uses Umbra-style strings. </p>
<p>Lazy vectors to avoid eager materialization. (Can&#39;t find any details on their representation).</p>
<p>Decoded vector - uniform representation that can be cheaply built from any encoded vector (same as unified vector in duckdb?). Avoids having to specialize all operations over all encodings.</p>
<p>Adaptive execution: Reorder AND/OR to put most efficient filter first. Switch to ascii-only version of string operations.</p>
<p>Experimental support for compiling queries.</p>
<p>Wrapper that takes scalar function and flags for determinism and null behaviour. Produces an efficient vectorized function.</p>
<h2 id="duckdb">duckdb</h2>
<p>Couldn&#39;t find much written info so relying on these two talks:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=bZOvAKGkzpQ">https://www.youtube.com/watch?v=bZOvAKGkzpQ</a></li>
<li><a href="https://www.youtube.com/watch?v=MA0OsvYFGrc">https://www.youtube.com/watch?v=MA0OsvYFGrc</a></li>
</ul>
<p>Single-file embedded OLAP database for data-science. In addition to SQL exposes eg r/python dataframe api.</p>
<p>Arrow-based data in-memory. Co-designed with Velox team.</p>
<p>Encodings include a sequence type - useful for auto-increment keys.</p>
<p>Unified vector - values and selection vector - can be produced from any other vector with minimal copying. (Doesn&#39;t work for sequence vector?) Vectorized filters produce selection vectors anyway, so this is nice.</p>
<p>Struct/list/map types. Maps stored as list of kv structs. (How do these work with unified vector? Do only individual columns map to unified?)</p>
<p>Switched from pull-based to push-based: Easier to multi-thread (<a href="https://dl.acm.org/doi/pdf/10.1145/2588555.2610507">morsel-driven</a>). Can coaleasce small vectors between operations. Can share scans between operators (although complicated by projection/filter pushdown). Easier to suspend execution eg for async io or query cancellation.</p>
<p>Most operators not parallel-aware, only sinks and sources.</p>
<p>Sink interface:</p>
<ul>
<li><code>Sink</code> called once per vector. Pushes data into local state.</li>
<li><code>Combine</code> called once per thread. Pushes local state into global state.</li>
<li><code>Finalize</code> called once. Does any remaining work on global state.</li>
</ul>
<p>Operators return one of <code>NEED_MORE_INPUT</code>, <code>HAVE_MORE_OUTPUT</code> or <code>FINISHED</code>. In the case of <code>NEED_MORE_INPUT</code> the intermediate state is store locally in the operator.</p>
<p>Implement union operator by having two pipelines with the same sink. Schedule <code>Finalize</code> after both pipelines finish. Similarly for full outer join - schedule hash-table probe for nulls before scan of other side.</p>
<p>Two copies of header in data file for atomic writes. Separate WAL. MVCC in-memory only (like singlestore?).</p>
<p>Tables partitioned in row groups. Unit of checkpoints and execution parallelism.</p>
<p>More encoding options on disk. Encoding is per-column per-row-group.</p>
<p>No compaction yet.</p>
<p>Less need for UDFs because of zero-copy between duckdb and r/python/whatever.</p>
<p>Small core. Most functionality in extensions loaded at runtime. Extensions tied to internals, so must be correct database version.</p>
<p>Support for spilling to disk during execution. Aim to degrade gracefully rather than just switching algorithms. Eg radix-partitioned hash-joins.</p>
<h2 id="snowflake">snowflake</h2>
<p>Again not much written info. Relying on <a href="https://www.youtube.com/watch?v=bveqnSk15JQ">https://www.youtube.com/watch?v=bveqnSk15JQ</a>.</p>
<p>Columnar. Vectorized. Push-based.</p>
<p>Codegen via LLVM for serde between workers. </p>
<p>&#39;Semi-structured&#39; data. Dynamically typed data stored in binary blobs. Infers schemas where possible and maps to columnar views.</p>
<p>SMAs for pruning.</p>
<p>&#39;Unistore&#39; - similar to singlestore where transactions work against in-memory rows which are compacted to columnar files.</p>
<h2 id="amazon-redshift-re-invented"><a href="https://15721.courses.cs.cmu.edu/spring2023/papers/24-redshift/redshift-sigmod2022.pdf">Amazon Redshift Re-invented</a></h2>
<p>Columnar data. SMAs.</p>
<p>Push-based vectorized scans. Remainder of query is compiled to pull-based C++.</p>
<p>Before hash-table operators, builds a small buffer of tuples that fits in L1. Issue prefetches for probes when tuples enter the buffer so hopefully no cache miss when popping from the buffer.</p>
<p>Adaptive execution eg choosing bloom filter size at runtime based on amount of data seen.</p>
<h2 id="btrblocks-efficient-columnar-compression-for-data-lakes"><a href="https://www.cs.cit.tum.de/fileadmin/w00cfj/dis/papers/btrblocks.pdf">BtrBlocks: Efficient Columnar Compression for Data Lakes</a></h2>
<p>Everyone is trying to make data warehouse work on open formats, but as we&#39;ve seen in the papers above open formats have some design issues.</p>
<p>Parquet and ORC have poor lightweight compression, so they require heavyweight compression of entire files, which tanks decompression bandwidth.</p>
<p>BtrBlocks is a format for cold data (eg in S3, rather than for inside the execution engine). Unlike DataBlocks, doesn&#39;t try to maintain random access or evaluate queries directly over encoded data.</p>
<p>Uses only lightweight compression. Achieves compression ratios almost as good as parquet/orc+zstd, but with &gt;4x better decompression bandwidth and similar compression bandwidth. Outperforms parquet/orc-zstd on all fronts.</p>
<p>Leaves metadata/statistics/indices to a separate format. </p>
<p>Groups of 64k rows. Encoding can vary per group. Groups are unit of parallellism.</p>
<p>Supported encodings: </p>
<ul>
<li>RLE</li>
<li>Constant</li>
<li>Dictionary</li>
<li>Frequency: Use a bitmask for most common value</li>
<li>SIMD-FastPFOR/SIMD-FastBP128: Store values as delta to frame-of-reference. Store outliers separately.</li>
<li>FSST: Replace common 8-byte substrings with 1-byte index into 255-entry dictionary.</li>
<li>Roaring bitmaps: Compact encoding of bitmaps.</li>
<li>Pseudodecimal: Separate floats into integer and decimal exponent where possible. Use a bitmask for exceptions.</li>
</ul>
<p>These encodings can be stacked eg start with frequency, using roaring for the most-common bitmap and use FFST for the non-most-common values.</p>
<p>To choose encoding:</p>
<ol>
<li>Collect statistics (min, max, unique count, average run length)</li>
<li>Filter out non-viable encodings.</li>
<li>For each viable encoding, estimate compression ratio using sample of 10 runs of 64 values.</li>
<li>Pick the encoding with the best estimate.</li>
<li>If the output can be encoded further, go back to 1.</li>
</ol>
<p>Choosing process takes 1.2% of total compression time. By default, the maximum number of recursive encodings is 3.</p>
<p>This encoding set was tailored to the Public BI benchmark but also performs well out-of-sample on TPC-H.</p>
<p>The pseudodecimal scheme is novel. Previous work ignored compression of floats since most datasets used decimals, but data science and machine learning workloads tend to use floats.</p>
<p>Discusses various optimizations for decompression.</p>
<p>Notes that testing compression algorithms on synthetic datasets like TPC-H is dubious. Demonstrates that PBI has much more structure and compresses better. Eg contains urls instead of random strings, is less normalized so has fewer foreign key ids.</p>
<p>Their sampling strategy produced results within 2% of optimal for 77% of blocks, and average +3.3% vs optimal overall.</p>
<p>Outperforms several unnamed proprietary databases on compression ratio, but wasn&#39;t able to compare compression/decompression bandwidth.</p>
<p>Notes that decompression bandwidth is usually measured in terms of uncompressed bytes per second. But for reading over the network, compressed bytes per second is also relevant. For parquet+zstd this was 25gbps in their experiment, preventing them from saturating the 100gbps network.</p>
<p>Should they just extend parquet? The simd algorithms only explain 17% of their 147% improvement over parquet in decompression, so the cascading encodings are the main improvement. Adding these to parquet would effectively be an entirely new format.</p>
<p>Code is at <a href="https://github.com/maxi-k/btrblocks">https://github.com/maxi-k/btrblocks</a></p>
<h2 id="filter-representation-in-vectorized-query-execution"><a href="https://dl.acm.org/doi/pdf/10.1145/3465998.3466009">Filter Representation in Vectorized Query Execution</a></h2>
<p>The output of a filter scan can be represented by either a bitmap or a selection vector. </p>
<p>Selection vectors tend to be cheaper when the selectivity is very low, because iterating over a mostly-empty bitmap is wasteful.</p>
<p>For very cheap operations after a filter, it might be cheaper to ignore the filter and apply the operation to every tuple anyway.</p>
<p>For simd-friendly operations, there are decent gains from combining operations with the filter using either masking or gather ops.</p>
<p>For selection vectors, branching implementations are faster when brand misprediction is &lt;10%. </p>
<p>Overall, selection vectors with partial operations dominated for any operation that doesn&#39;t have an efficient simd implementation. For those that do, using bitmaps and ignoring the input filter was sometimes better. But it doesn&#39;t look like they compared with eager materialization using simd, which would allow for simd operations without selection logic but at the cost of extra memory traffic.</p>
<h2 id="dremel-interactive-analysis-of-web-scale-datasets"><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36632.pdf">Dremel: Interactive Analysis of Web-Scale Datasets</a></h2>
<p>Columnar storage of nested types. Each field gets it&#39;s own column which contains nullable values. Each value in the column also has:</p>
<ul>
<li>Repetition level - the last index in the path to this value which is not the first value in a repeated sequence. Yeah, that&#39;s a fun concept.</li>
<li>Definition level - up to which index in the path are the values not null.</li>
</ul>
<p>This isn&#39;t great for random access - to evaluate a single path <code>.links.backwards[3]</code> we have to stream through all the records in a block.</p>
<p>During evaluation we can start with scans on the nested columns and then aggregate the rep/def levels into the output of each expression in the query. So while the format is weird it has this closure property - operations on columnar nested data also produce columnar nested data. </p>
<p>The nulls seem crucial here. Eg if we want <code>select count(.links.backwards)</code> we want to be able to produce 0 for records with no backwards links, and we have to keep track of which record those zeroes belong to.</p>
<h2 id="cores-towards-scan-optimized-columnar-storage-for-nested-records"><a href="https://sci-hub.hkvisa.net/10.1145/3321704">CORES: Towards Scan-Optimized Columnar Storage for Nested Records</a></h2>
<p>Want to combine filters on nested columns without record reassembly.</p>
<p>Similar layout to duckdb/velox.</p>
<p>Maintain a bitset for some level. Can efficiently move up and down levels using rollup/drilldown operators. </p>
<p>Can do boolean operations on different levels using rollup/drilldown first, but worth specializing the combination.</p>

</article></div>
  </body>
</html>
