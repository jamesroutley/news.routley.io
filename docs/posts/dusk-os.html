<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://duskos.org/">Original</a>
    <h1>Dusk OS</h1>
    
    <div id="readability-page-1" class="page">

<p>Dusk OS is a 32-bit Forth and big brother to <a href="http://collapseos.org">Collapse OS</a>. Its
<a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/design/purpose.txt">primary purpose</a> is to be maximally useful during the <a href="http://collapseos.org/why.html">first
stage of civilizational collapse</a>, that is, when we can&#39;t produce
modern computers anymore but that there&#39;s still many modern computers around.</p>
<p>It does so by aggressively prioritizing <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/design/simple.txt">simplicity</a> at the
cost of <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/design/limits.txt">unorthodox constraints</a>, while also aiming to make
<a href="#operator">operators</a> happy.</p>
<p>Dusk OS innovates by having an <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/comp/c.txt">&#34;almost C&#34; compiler</a> allowing it to
piggy-back on UNIX C code, through a modest <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/design/port.txt">porting effort</a>, to
reach its goals and stay true to its design constraints with a minimal effort.</p>
<p>The end result is a system that has a very high &#34;power density&#34;, high enough to
issue a <a href="#challenge">challenge to the conventional software culture</a>.</p>
<p>You can read on for more details, but the impatient among you might prefer
taking the <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/tour.txt">Dusk Tour</a>.</p>
<h2>Status</h2>
<ul>
<li>Can run on:<ul>
<li>Bare metal on those CPUs:<ul>
<li>i386 (BIOS or EFI)</li>
<li>amd64 (EFI)</li>
<li>ARM</li>
<li>RISC-V</li>
<li>m68k</li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/deploy/README.md">List of supported targets</a></li>
</ul>
</li>
<li><a href="https://git.sr.ht/~vdupras/dusk-wasm">WebAssembly</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/usermode/README.md">At native speed on top of &#34;regular&#34; OSes</a></li>
</ul>
</li>
<li>Can read, write, create and boot from FAT12/FAT16 (no FAT32 for now) volumes.</li>
<li>Has an <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/comp/c.txt">&#34;almost C&#34; compiler</a> which, despite its &#34;almost&#34; qualifier,
  is capable of compiling quite complex &#34;real world&#34; code.</li>
<li>Very small footprint. Designed to run smoothly on 30 years old machines.
  Almost anything that has a 32-bit CPU in fact.</li>
<li>Simple and terse. For example, the total lines of code involved in having a
  fully booted bare metal i386 PC Dusk system running on a FAT16 with a C
  compiler, i386 assembler and a Grid text editor is less than 6000.</li>
<li>It completely self-hosts on all its targets. That is, a machine running Dusk
  OS has all the tools necessary to either improve itself or produce a media to
  run Dusk OS on another machine.</li>
<li>In order to bootstrap itself from something else than itself, it also has a
  <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/posix/README.md">POSIX-compatible VM</a> written in C that is able to generate images
  for all its targets.</li>
<li>Excluding the <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/oberon.txt">Oberon system (WIP)</a>, documented externally, has more
  documentation than code.</li>
<li>Licensed under CC0, effectively placing it in the public domain.</li>
</ul>
<p>List of ported codebases:</p>
<ul>
<li>The <code>puff()</code> algorithm from <a href="https://github.com/madler/zlib">zlib</a></li>
<li>DWC USB controller driver from Plan 9</li>
<li>Michael Schierl&#39;s RISC5 emulator allowing Dusk to run
  <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/oberon/README.md">Project Oberon</a>.</li>
</ul>
<p>List of homegrown applications:</p>
<ul>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/comp/c.txt">C Compiler</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/comp/oberon.txt">Oberon Compiler (WIP)</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/comp/lisp.txt">Some sort of a Lisp</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/text/ed.txt">Text editor</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/bin/gbe.txt">Binary editor</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/emul/uxn.txt">uxn</a> and <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/emul/varvara.txt">varvara</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/asm/x86.txt">i386/amd64 assembler</a> and <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/asm/x86d.txt">disassembler (i386-only for now)</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/asm/arm.txt">ARM assembler</a> and <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/asm/armd.txt">disassembler</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/asm/riscv.txt">RISC-V assembler</a></li>
<li><a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/emul/6502.txt">6502 emulator</a></li>
</ul>
<h2>How terse is that thing anyway?</h2>
<pre><code>$ git checkout v19
$ make dusk
$ ./dusk -f fs/home/codesz.fs
Kilobytes of code in Dusk OS
Everything except /doc /data /tests     728
Documentation                           714
Boot payload minus HAL                  50
C compiler                              49
Oberon compiler                         43
Oberon system                           98
Lisp                                    16
Text Editor                             13
All USB drivers                         62
EFI drivers                             14
This script                             3

CPU-specific... i386  amd64 arm   riscv m68k 
Assembler       11    same  5     14    5
Kernel          10    9     13    14    9
HAL             6     6     7     8     7
EFI interface   4     4
</code></pre>
<p>As a reference, running <code>wc -c *.c *.h lib/* include/*</code> on <a href="https://www.bellard.org/tcc/">TinyCC</a>
0.9.27&#39;s source code yields 1420 kilobytes of code.</p>
<h2>Getting Dusk</h2>
<p>Dusk OS&#39;s git repository is <a href="https://git.sr.ht/~vdupras/duskos">hosted on sourcehut</a>. The regular way of
getting it will be to clone the repository from there. You can try to run it
directly from the <code>master</code> branch or you can target one of its
<a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/CHANGELOG.md">releases</a> using the release tags (for example <code>v11</code>).</p>
<p>More information about how to build and run Dusk OS is available in the
<a href="https://git.sr.ht/~vdupras/duskos">root README</a> as well as in its <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc">documentation</a>.</p>
<p>Becoming a Dusk <a href="#operator">operator</a> is an involving process. It&#39;s possible
that you&#39;re interested in tasting a bit of Dusk&#39;s power before you dive into
this wonderful adventure of learning Forth and Dusk. You&#39;re in luck, there&#39;s
the <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/tour.txt">Dusk Tour</a> which doesn&#39;t require prior Forth knowledge and allows
you to dip your toes in it.</p>
<p>For deployments to actual machines, there&#39;s also the
<a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/deploy/README.md">Dusk OS Deployments collection</a> that can be of use.</p>
<p>There is also the option of building <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/usermode/README.md">Dusk Packages</a> on top of other
OSes. You can look at <a href="https://git.sr.ht/~vdupras/dusk-examples">Dusk Packages examples</a> for a quick start.</p>
<h2>Discuss Dusk</h2>
<p><a href="https://duskos.org/discuss.html">Details here</a></p>
<h2>Funding</h2>
<p>I began a sabbatical from working on modern technology in 2023, which I hope to
extend indefinitely. To that end, I&#39;ve put up a <a href="https://duskos.org/services.html">service offering</a>
that I hope might help me towards that goal. On that front, I have good reasons
to be optimistic as the <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/SPONSORS">sponsors</a> ball is already rolling!</p>
<p>Moreover, I believe that my work on Dusk OS and Collapse OS could be
significant enough to some people that it could end up being <a href="https://duskos.org/funding.html">philanthropically
funded</a>. If you&#39;re rich and inspired by this work, please consider it.</p>
<h2>Why build this OS?</h2>
<p>Most modern operating systems can do whatever we want them to do. Why do we
need another one? Simplicity.</p>
<p>It&#39;s difficult to predict post-collapse conditions, but we can suppose that
many <a href="#operator">operators</a> will need to use their machines in novel and
creative ways. Hackability of the operating system then becomes paramount. Open
source modern operating systems all can be modified to fit its user&#39;s needs,
but their complexity limits the likelihood that the user is able to do so. A
simpler OS increases this likelihood.</p>
<p>But we can&#39;t have our cake and eat it too, right? Either you have a simple toy
OS or a complex one. Well, maybe not?</p>
<p>Its instigator (and, I guess, some of its <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/AUTHORS">authors</a> and <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/SPONSORS">sponsors</a> too)
believes that in the history of computing, Forth has been under-explored. Its
approach to simplicity is, I think, revolutionary. It has significant
shortcomings when system specifications become more complex (Forth hates
complexity and doesn&#39;t manage it well), but I believe it possible to elegantly
marry it with languages that like complexity better.</p>
<p>This mix could provide the operator with computing powers rarely seen with
other approaches. We&#39;ve got to try it.</p>

<h3>A challenge to the conventional software culture</h3>
<p>While the primary purpose of this operating system is related to civilizational
collapse, it&#39;s also in big part a reaction to the modern software stack. That
stack is disgustingly complicated. It&#39;s a product of the compounded effect of a
software culture that breeds complexity and had the opportunity to build upon
itself over decades, unchecked and unchallenged, oozing its inscrutable pus at
every corner.</p>
<p>The further we let that culture creep out, the harder it is to get out of it.
Hardware follows it dutifully -- and in the same spirit of spurious complexity
-- making clean slate approaches more and more out of reach... but not
impossible yet!</p>
<p>Dusk OS has an amazing &#34;power density&#34;, that is, it packs a lot of power in a
very small package. This density allows it to do many things that the modern
stack can do at a fraction of the complexity cost.</p>
<p>It is partly intended as a wake up call to software developers: the regular way
to develop software today is stupid and wasteful and has been for the last 30
years. This stupidity and wastefulness feeds itself and makes us design bigger
and stupider<sup id="fnref:1"><a href="#fn:1">1</a></sup> hardware to cater to bigger and stupider software.</p>
<p>We don&#39;t need this. All this sweat, tears and blood (because yes, blood is
involved in having a global supply chain enabling these crazily complex
machines we produce) is futile because the conventional approach to computing is
an evolutionary dead end.</p>
<p>There are other ways and we urgently need to explore them. Forth is such a way.
It had a hard time adapting to bigger machines because of its affinity for
simplicity which makes it a bad fit to spurious hardware complexity.</p>
<p>Dusk OS aims to bridge that gap and be a Forth that, yes, is a bit more complex
than your run-of-the-mill Forth, but is careful to keep that very high &#34;power
density&#34; making Forth revolutionary and use that spurious power that modern
hardware gives us, thus competing better, feature-wise, with the modern software
stack.</p>
<h2>Features making Dusk OS special</h2>
<h3>A whole OS built from source on boot</h3>
<p>One thing that makes Dusk OS special is that it boots from a tiny kernel
weighting less than 4 <strong>kilobytes</strong>. From this tiny core, on boot, it
builds its way up, <em>from source code</em>, to a system that has a functional C
compiler, which then allows it to bootstrap itself some more, from source
code.</p>
<p>This peculiarity of Dusk OS has interesting properties. The nicest one, in my
humble opinion, is that this allows us to sidestep the <em>entire</em> problems of
binary compatibility and relocation and only deal with source compatibility.
So, no ELF, no binutils, only code that is designed to run from where it was
generated in the first place. This is so much simpler!</p>
<p>Object files? Global symbols? Nah. C functions are simple Forth words.</p>
<h3>Harmonized Assembly Layer</h3>
<p>Dusk features what we call the <a href="https://git.sr.ht/~vdupras/duskos/tree/master/item/fs/doc/hal.txt">Harmonized Assembly Layer</a> (HAL for short).
This is a cross-CPU assembler, on which the C compiler relies, which prioritizes
implementation and usage simplicity, but is also designed to generate efficient
native code.</p>
<h3>Shortest path to self-hosting for an &#34;almost C&#34; compiler</h3>
<p>Dusk OS self-hosts in about 500 lines of assembly and a few hundred lines of
Forth (the exact number depends on the target machine). From there, it
bootstraps to DuskCC, which is roughly 1200 lines of Forth code. To my
knowledge, Dusk OS is unique in that regard.</p>
<p>You can pick any C compiler that requires POSIX and it will automatically
require orders of magnitude more lines of code to bootstrap because you need
that POSIX system in addition to the C compiler. So even if you pick a small C
compiler such as tcc, you still need a POSIX system to build it, which is
usually in the millions of LOCs.</p>
<p>To be fair, Dusk OS is not the first project thinking of optimizing that path.
<a href="https://github.com/fosslinux/live-bootstrap">Efforts at making our modern software world bootstrappable</a>
lead to an &#34;almost C&#34;, <a href="https://git.sr.ht/~oriansj/M2-Planet">M2-Planet</a> with a feature set comparable to
DuskCC with very few lines of code. M2-Planet itself is about 5K lines of code
and the various stages that lead to it are generally a few hundred lines each.
The project initially ran on top of regular kernels (as in &#34;fat kernels with
lots of code&#34;), but some bare metal stages (<a href="https://github.com/ironmeld/builder-hex0">1</a>,
<a href="https://git.stikonas.eu/andrius/stage0-uefi">2</a>) were created and now this little chain end up being
comparable to Dusk in terms of lines of code. Still more than Dusk, but in the
same ballpark.</p>
<p>Although this path is short and technically leads you to an &#34;almost C&#34;
compiler, you can hardly use it because it has no &#34;real kernel&#34; (those bare
metal stages mentioned above are enough to compile M2-Planet, but really not
much else, they&#39;re extremely limited) and no shell. You&#39;ll need those if you
want to use your shiny compiler.</p>
<p>One of your best picks, should you try this path, would be <a href="https://www.fiwix.org">Fiwix</a>, a
minimal POSIX i386 kernel weighting less than 50K lines of C+asm. But then,
M2-Planet is not enough. You need to compile tcc (which M2-Planet can compile
after having applied a few patches) which weights 80K. Userspace is worse.
Bash+coreutils are 400K, even busybox is 190K. We still end up with a pretty
minimal and simple system, but it&#39;s still a lot more code than Dusk.</p>
<p>So, unless someone tells me about some option I don&#39;t know about, DuskCC is
quite innovative on the aspect of self-hosting path length.</p>
<h3>Dusk OS is pretty fast</h3>
<p>The code generated by Dusk OS holds pretty well to modern compilers with fancy
optimizations and millions of lines of code.</p>
<p>In a <a href="https://duskos.org/sieve.html">Byte Sieve benchmark done on a i386 NetBSD system</a>,
the DuskCC version of the sieve is almost as fast as GCC&#39;s unoptimized build and
the HAL&#39;s translation of the Sieve algorithm blows past GCC&#39;s unoptimized build
to nearly reach the speed of <code>GCC -O2</code>!</p>
<p>And it gets better! HAL&#39;s design allows efficiency to naturally &#34;bubble up&#34; to
higher level code with impressive results. For example, there&#39;s the
<a href="https://git.sr.ht/~vdupras/dusk-examples">&#34;charcount&#34; example</a> which pits Dusk&#39;s <code>rfind</code> against POSIX&#39;s
<code>regex(3)</code>. For this particular and simple use case (count occurrences of
characters range in a big file), Dusk is 15% faster than Debian bookworm amd64&#39;s
<code>regex(3)</code> implementation.</p>

<h2>Who is Dusk for?</h2>
<p>Dusk OS doesn&#39;t have users, but <em>operators</em>. What&#39;s the difference? Control.
You <em>use</em> a phone, you <em>use</em> a coffee machine, hell you even <em>use</em> a car these
days. But you <em>operate</em> a bulldozer, you <em>operate</em> a crane, you <em>operate</em> a
plane.</p>
<p>You <em>use</em> Linux, you <em>use</em> Windows. You <em>operate</em> Dusk OS.</p>
<p>Can you <em>operate</em> Linux? Sure, if you&#39;re some kind of god<sup id="fnref:2"><a href="#fn:2">2</a></sup>, in the same way
that you can <em>operate</em> a Tesla if you&#39;re a top Tesla engineer. But you&#39;re much
more likely to be able to <em>operate</em> a landmower than a Tesla.</p>
<p>When you <em>operate</em> a system, there is no problem that can arise that will make
you powerless. Sure, you can have a hardware failure that hopelessly breaks your
system, but at least you&#39;ll be able to identify that failure and know for sure
that there is no software solution or workaround. That&#39;s control.</p>
<p>The Dusk operator is someone who&#39;s <a href="http://collapseos.org/why.html#creative">creative</a>, close to hardware, can
read a datasheet. Dusk shines when one wants to poke around the hardware
without limit.</p>
<p>It compares favorably to other more complete OSes because there&#39;s no concurrent
process to mess with your poking and the driver structure is more approachable,
hackable due to its stricter scope and savvier target audience. Also, there is
no &#34;userland&#34;. Every tool that Dusk provides or that the operator builds can be
directly used on system memory. No middleman.</p>
<p>Let&#39;s use an example. Let&#39;s say you&#39;re on a notebook that runs on a chipset of
Intel&#39;s ICHn family. You read the datasheet and see &#34;oh, nice, there&#39;s an SPI
interface in there. Maybe that it&#39;s not hooked to anything on the notebook,
let&#39;s play with it.&#34;</p>
<p>Now, that chipset is very, very central to the computer. There are good chances,
on a BSD or Linux system, that if you begin poking around its registers, you&#39;ll
step on someone else toes and crash the system because, for example, of some
other process that needed to read from disk at the same time.</p>
<p>In Dusk, you could completely break the SATA controller, you&#39;ll still be golden
as long as you don&#39;t access mass storage. Because Dusk doesn&#39;t have
concurrency, you have tight control over what happen or doesn&#39;t happen on the
machine, so all you need to do is to avoid words that access mass storage. That
gives you ample wiggling space for your hacking session.</p>
<p>To be clear: this is also possible with a custom made BSD or Linux, but you&#39;re
going to have to strip a lot of pieces from your distro before you get there
and some of those pieces might be useful debugging tools which will be
difficult to retrofit because they need a wider system. You&#39;ll also need a
higher cognitive space to fit BSD/Linux wider abstractions in your mind.</p>
<h2>Linking to this website</h2>
<p>If you want to link to this website, please use <code>http://</code> links rather than
<code>https://</code> ones. While <code>http://</code> links are trivially &#34;upgradable&#34; to HTTPS, the
opposite is not.</p>
<p>Right now, this website is hosted on a service (sourcehut pages) that doesn&#39;t
offer the option of not using SSL, but eventually, it&#39;s possible that this
website ends up being served by a machine running Dusk OS. In that case, it
will not be served under SSL and all <code>https://</code> links will be broken.</p>
<h2>Related links</h2>
<ul>
<li><a href="http://tumbleforth.hardcoded.net">Tumble Forth, a Forth vulgarization blog</a></li>
<li><a href="https://wiki.osdev.org/">OSDev wiki</a></li>
<li><a href="http://www.osdever.net/FreeVGA/home.htm">FreeVGA</a></li>
<li><a href="http://www.cs.cmu.edu/~ralf/files.html">Ralf Brown&#39;s x86 interrupt list</a></li>
<li><a href="https://www.versalogic.com/wp-content/themes/vsl-new/assets/resources/support/pdf/69030BG.pdf">VGA BIOS OEM Reference Guide</a></li>
</ul>


</div>
  </body>
</html>
