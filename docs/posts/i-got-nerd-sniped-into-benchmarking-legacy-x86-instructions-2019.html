<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.acepace.net/2019-07-27-xlatb/">Original</a>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    <div>

      

      <article role="main">
        <p>It all started with a meme tweet:</p>

<p><img src="https://www.acepace.net/images/xlatb/meme.jpg" alt="twitter meme describing waves to extract values from an array in x64"/></p>

<p>Laugh, scroll past, then I started wondering, “what are the chances this obscure opcode is faster than optimized loads?” and I realized I had just been <a href="https://xkcd.com/356/">nerd sniped</a>. So I decided to dig up my half-remembered memories of how to benchmark opcodes and get to the bottom of this meme.</p>

<p>For those of us who do not recall every opcode that Intel dreamed up, the <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">Intel reference manual</a> is a useful reference and says the following:</p>

<p>XLAT/XLATB - <em>Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers</em></p>

<p>In other words, the instruction performs</p>

<figure><pre><code data-lang="nasm"><span>MOV</span> <span>AL</span><span>,[</span><span>EBX</span><span>+</span><span>AL</span><span>]</span><span>;</span></code></pre></figure>

<p>EBX is the array base and AL is the offset.</p>

<p>Which is exactly the core line of the last snippet in the meme.</p>

<p>My guess was <strong>the equivalent load opcode version would outperform xlatb</strong>. How I tested this simple question is worth writing up, if only to have a reference for micro benchmarking from end to end.</p>

<h3 id="technical-background">Technical background</h3>

<p><em>Feel free to skip this if you’re familiar with benchmarking, CISC vs RISC and why I guessed what I guessed</em></p>

<h4 id="benchmarking">Benchmarking</h4>

<p>What I did to test my guess is called micro benchmarking. The difference from regular benchmarking is in the focus and minimization of context. It helps in answering very small questions such as “What is the fastest way to sort an array of numbers in C”, and ignoring memory pressure, design and other considerations that are important in the real world of benchmarking.</p>

<p>The challenge in micro benchmarking is that there is a lot of noise in the process. Compilers, operating systems, CPU temperature and frequency changes can all serve to create large shifts in the performance of the benched code snippet.</p>

<p>Therefore, the goal is to define the problem as accurately as possible. For example</p>

<ul>
  <li>Minimize hardware considerations. This means removing frequency scaling, branching, any chance of the data being evicted from the cache.</li>
  <li>No interaction with the system. This means no system calls, but also no memory allocations and hopefully remove the role the runtime plays (for example if we’re benchmarking .NET code)</li>
</ul>

<p>These typically lead micro benchmarks to being written in assembly code and measuring runtime using the <a href="https://www.aldeid.com/wiki/X86-assembly/Instructions/rdtsc">rdtsc</a> opcode.</p>

<p>To understand this at a basic level, I really recommend the book <a href="https://nostarch.com/insidemachine.htm">Inside the Machine</a> (Jon Stokes), another option is <a href="http://www.lighterra.com/papers/modernmicroprocessors/">Modern Microprocessors in 90 minutes</a> but for more than that, the relatively up to date reference is <a href="https://www.realworldtech.com/cpu/">Real World Technologies</a> articles on CPU architecture.</p>

<p>The reference for nearly everything relating to opcode latency for Intel and AMD CPUs is <a href="https://www.agner.org/optimize/">Agners guides</a> and <a href="https://uops.info/table.html">uops.info</a>.</p>

<p>If you want to measure these latencies and what exactly a CPU is doing when executing an opcode, you need to read the Performance Measurement Counters embedded in the hardware. This gives us precisely numbers for (example) how many L1 cache hits and misses happened in a code block, how many branch mispredictions happened and so forth.</p>

<h4 id="xlat-and-cisc">XLAT and CISC</h4>

<p>Now, what the heck is XLAT and why does it exist?</p>

<p>The basic idea behind the XLAT instruction is the idea behind Complex Instruction Set Computers (CISC), that states hardware should implement common instruction sequences with dedicated instructions that perform the same task but faster. This is the idea behind many of the weird x86 instructions (or other CPUs).</p>

<p>However, since that time, all modern CPUs have turned RISC-like, by internally using a reduced instruction set and translating the ISA opcodes into internal commands, some implemented using CPU microcode. This also allows for different optimizations such as micro opcode fusion. Another note, CPU designers spend a lot of time optimizing the commonly use instructions, which makes them very fast (for example xor rax,rax is free) This leaves very little room for opcodes like xlatb to shine.</p>

<p>While we’re dunking on CISC, I came across the following great snippet on the difference between the good parts of CISC and the bad parts.</p>

<p><em>We should distinguish the “Complex” instructions of CISC CPUs - complicated, rarely used, and universally low performance, from the “Featureful” instructions common to both CISC and RISC CPUs, which combine a small sequence of operations, are commonly used, and high performance. - <a href="https://gist.github.com/erincandescent/8a10eeeea1918ee4f9d9982f7618ef68">erincandescent</a></em></p>

<h3 id="the-experiments">The experiments</h3>

<p>What I ended up doing was running the different code snippets in the Andreas Abel’s micro benchmarking harness, available on <a href="https://github.com/andreas-abel/nanoBench">GitHub</a>. The machine used for execution was a VM running on a Broadwell i7-5500U, Debian 9.9, kernel version 4.9 with the host CPU frequency governor set to disabled (max clock speed all the time).</p>

<p>The executed code snippets were as described in the table below.</p>

<table>
  <tbody><tr>
   <td>Snippet 0
   </td>
   <td>Snippet 1
   </td>
   <td>Snippet 2
   </td>
   <td>Snippet 3
   </td>
  </tr>
  <tr>
   <td>
   
<figure><pre><code data-lang="nasm"><span>push</span> <span>rcx</span>

<span>xor</span> <span>rcx</span><span>,</span><span>rcx</span>

<span>mov</span> <span>cl</span><span>,</span><span>al</span>

<span>add</span> <span>rcx</span><span>,</span><span>rbx</span>

<span>mov</span> <span>al</span><span>,</span> <span>[</span><span>rcx</span><span>]</span>

<span>pop</span> <span>rcx</span></code></pre></figure>

   </td>
   <td>
  
<figure><pre><code data-lang="nasm"><span>push</span> <span>rcx</span>

<span>movzx</span> <span>rcx</span><span>,</span><span>al</span>

<span>add</span> <span>rcx</span><span>,</span><span>rbx</span>

<span>mov</span> <span>al</span><span>,</span> <span>[</span><span>rcx</span><span>]</span>

<span>pop</span> <span>rcx</span></code></pre></figure>

   </td>
   <td>
   
<figure><pre><code data-lang="nasm">   <span>push</span> <span>rcx</span>

<span>movzx</span> <span>rcx</span><span>,</span><span>al</span>

<span>mov</span> <span>al</span><span>,</span> <span>[</span><span>rbx</span><span>+</span><span>rcx</span><span>]</span>
 
<span>pop</span> <span>rcx</span></code></pre></figure>

   </td>
   <td>
   
<figure><pre><code data-lang="nasm">   <span>xlatb</span>
   </code></pre></figure>

   </td>
  </tr>
</tbody></table>

<p>In order to remove as much variance as possible, it’s best to make sure all accesses are kept inside the L1 cache (code and data). For this reason, the following initializations are required</p>

<ul>
  <li>Aim RBX at RSP, making sure the array accessed is inside the L1 data cache</li>
  <li>Set RAX to 0</li>
</ul>

<p>In addition, this opcode sequence is small enough to be in the same L1 code cache line so no effort was required there (manually verified).</p>

<p>For this experiment, what matters is the number of cycles required to execute (which is a close approximation of time) and the cycles elapsed (wall time). In addition, I’ll also measure how many loads happened while executing this snippet, by tracking the <a href="https://download.01.org/perfmon/index/haswell.html">MEM_LOAD_UOPS_RETIRED.L1_HIT PMC</a>.</p>

<p>The command line I used when executing the benchmarks was</p>

<figure><pre><code data-lang="shell">./nanoBench.sh <span>-avg</span> <span>-n_measurements</span> 500 <span>-asm_init</span> <span>&#34;mov rbx, rsp;xor rax,rax;&#34;</span> <span>-asm</span> SNIPPET_HERE <span>-config</span> configs/cfg_Broadwell_common.txt</code></pre></figure>

<p>The results, summarized in a table:</p>

<table>
  <thead>
    <tr>
      <th>Snippet 0</th>
      <th>Snippet 1</th>
      <th>Snippet 2</th>
      <th>Snippet 3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RDTSC: 6.35</td>
      <td>RDTSC: 6.00</td>
      <td>RDTSC:  4.81</td>
      <td>RDTSC: 5.6</td>
    </tr>
    <tr>
      <td>Core cycles: 8.01</td>
      <td>Core cycles: 7.02</td>
      <td>Core cycles: 6.36</td>
      <td>Core cycles: 7.01</td>
    </tr>
    <tr>
      <td>Loads: 2</td>
      <td>Loads: 2</td>
      <td>Loads: 2</td>
      <td>Loads: 2</td>
    </tr>
  </tbody>
</table>

<p>There are a few things that stand out.</p>

<p>Foremost, xlatb is slower than the equivalent optimized x64 code.</p>

<p>Second, as is generally known, memory loads are the most expensive part of any algorithm, but once the data is in L1, the difference in number of loads doesn’t seem to matter. The xlatb sequence has only one data load yet is slower than the optimized x64 version.</p>

<p>Second, the core cycle count for the xlatb instruction precisely matches the <a href="https://www.agner.org/optimize/instruction_tables.pdf">Agner table</a> (page 229). Good to know our measurements line up with others :)</p>

<p>Last, note that reducing the amount of instructions used does not decrease time required linearly. Why? The number of instructions is not linearly correlated to the actions performed by the processor. A classic example is xor rcx,rcx. This opcode never actually executes. Instead, the CPU just updates a pointer in the register renaming file.</p>

<p>To examine these type of questions, another tool is required - the Intel Architecture Code Analyzer (<a href="https://software.intel.com/en-us/articles/intel-architecture-code-analyzer">IACA</a> - unfortunately now deprecated). This tool will look at the machine code and tell you how different Intel CPUs will execute them. Let’s look at one case in particular to see why removing instructions doesn’t always linearly save time. Attached are only the relevant parts of the output, which are the micro-op count.</p>

<p>* - instruction micro-ops not bound to a port</p>

<p>^ - Micro Fusion occurred</p>

<table>
  <thead>
    <tr>
      <th>Number of Uops</th>
      <th>opcodes</th>
      <th>Number of Uops</th>
      <th>opcodes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3^#</td>
      <td>push rcx</td>
      <td>3^#</td>
      <td>push rcx</td>
    </tr>
    <tr>
      <td>1*</td>
      <td>xor rcx,rcx</td>
      <td>1*</td>
      <td>movzx rcx,al</td>
    </tr>
    <tr>
      <td>1</td>
      <td>mov cl,al</td>
      <td>1</td>
      <td>add rcx, rbx</td>
    </tr>
    <tr>
      <td>1</td>
      <td>add rcx,rbx</td>
      <td>1</td>
      <td>mov al, byte ptr [rcx]</td>
    </tr>
    <tr>
      <td>1</td>
      <td>mov al, byte ptr [rcx]</td>
      <td>2^#</td>
      <td>pop [rcx]</td>
    </tr>
    <tr>
      <td>2^#</td>
      <td>pop rcx</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>The important bit is noting that in snippet 0, the opcodes xor rcx,rcx; mov cl,al takes up one execution unit (xor rcx rcx is not bound to an execution port).</p>

<p>In snippet 1, the opcode movzx rcx,al doesn’t take up an execution port at all.</p>

<p>You can also play around with llvm-mca which does something similar, and see the same results, by using Compiler Explorer (<a href="https://godbolt.org/z/6SjY_d">snippet link</a>).</p>

<h4 id="side-note-on-actually-running-the-experiments">Side note on actually running the experiments</h4>

<p>All my machines are Windows machines, where accessing the PMCs is not as fun or easy as it is on Linux. The proper reaction should be “so run it inside a VM”, but apparently Hyper-V doesn’t expose PMCs to guests by default and I couldn’t find a way to do it easily.</p>

<p>I ran into every possible frustration while searching for a cheap bare metal cloud machine, including Oracle gating the bare metal instances behind a request form that requires a human being to look at.</p>

<p>In the end, VMWare Workstation exposes PMCs to guests so a friend with power to spare gave me a VM to test.</p>

<h2 id="tldr">TL;DR</h2>

<p>The meme is wrong, no surprise. An optimized sequence of x64 instructions beats out a single complex instruction. This isn’t always true (POPCNT as a counter example) but some instructions are legacy for a reason. If LLVM doesn’t output the opcode, it’s probably for the best.</p>

<p>Also this was an opportunity to rediscover micro benchmarking. It’s quite likely I made some measurement mistakes, so if you found any, feel free to contact me.</p>

<h2 id="also-thanks-are-in-order-for-help-in-this-bit-of-fun">Also, thanks are in order for help in this bit of fun</h2>

<p><a href="https://twitter.com/wobel_">@wobel_</a> for providing the VM and therapy while I swore at cloud providers.</p>

<p><a href="https://twitter.com/damageboy">@damageboy</a> for generally knowing everything and in this case, for writing a series of blog posts on micro benchmarking .NET instructions available <a href="https://bits.houmus.org/2018-08-18/netcoreapp3.0-instrinsics-in-real-life-pt1">here</a> that pushed me to do this sort of stuff</p>

<p>And again to Andreas Abel for saving me a lot of time with his micro benchmarking harness available on <a href="https://github.com/andreas-abel/nanoBench">GitHub</a></p>


      </article>

      

      

      
      
    </div>
  </div>
</div></div>
  </body>
</html>
