<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philosophicalhacker.com/post/reading-sqlite-schema-tables-the-hard-way/">Original</a>
    <h1>Reading Sqlite Schema Tables the Hard Way</h1>
    
    <div id="readability-page-1" class="page"><article><p>Parsing a Sqlite database file is a nice way to brush up on data structures, bit manipulation, and recursion. I know this because I recently implemented the <code>read_schema_tables</code> function below such that the following test passes:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> sqlite3
</span></span><span><span>
</span></span><span><span><span>def</span> <span>test_read_table_names</span>(db_file):
</span></span><span><span>    con <span>=</span> sqlite3<span>.</span>connect(db_file)
</span></span><span><span>    <span>assert</span> list(con<span>.</span>execute(<span>&#34;SELECT * FROM sqlite_schema;&#34;</span>)) <span>==</span> list(read_schema_tables(db_file))
</span></span></code></pre></div><p><code>read_schema_tables</code> doesn’t use the <code>sqlite3</code> python package. That’d make for a trivial test case and would be too easy. For comp sci fun, we have to do it the hard way.</p>
<h2 id="recursing-through-sqlite-btree-pages">Recursing through Sqlite btree pages</h2>
<p>Sqlite stores data in pages. These pages are arranged in a generalization of a binary tree called a “btree” where nodes can have more than 2 children. The docs call non-leaf pages “internal pages.” All pages have cells, but cells of internal pages merely point to child pages. The cells of leaf pages, on the other hand, actually contain data.</p>
<p>Sometimes the tables from <code>sqlite_schema</code> fit on a single page. Sometimes they don’t. My calling code shouldn’t care:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Sqlitedatabase</span>:
</span></span><span><span>    <span>@property</span>
</span></span><span><span>    <span>def</span> <span>table_names</span>(self):
</span></span><span><span>        <span>return</span> Page<span>.</span>from_number(
</span></span><span><span>            self<span>.</span>file, <span>1</span>, <span># &lt;-- page # ...</span>
</span></span><span><span>        )<span>.</span>leaf_cells
</span></span></code></pre></div><p>An abstract class gives us a nice way of…well…abstracting this:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Page</span>(ABC):
</span></span><span><span>    <span>@property</span>
</span></span><span><span>    <span>@abstractmethod</span>
</span></span><span><span>    <span>def</span> <span>leaf_cells</span>(self):
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><p>Internal pages merely get child pages and recursively call <code>Page.leaf_cells</code> on their children:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>InternalPage</span>(Page):
</span></span><span><span>    <span>@property</span>
</span></span><span><span>    <span>def</span> <span>leaf_cells</span>(self):
</span></span><span><span>        <span>return</span> itertools<span>.</span>chain<span>.</span>from_iterable(
</span></span><span><span>            [
</span></span><span><span>                self<span>.</span>get_page(page_num)<span>.</span>leaf_cells
</span></span><span><span>                <span>for</span> page_num <span>in</span> self<span>.</span>page_nums
</span></span><span><span>            ]
</span></span><span><span>        )
</span></span><span><span>    
</span></span></code></pre></div><p>Leaf pages, on the other hand, actually have to read data:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>LeafPage</span>(Page):
</span></span><span><span>    <span>@property</span>
</span></span><span><span>    <span>def</span> <span>leaf_cells</span>(self):
</span></span><span><span>        result <span>=</span> []
</span></span><span><span>        <span>for</span> cell_idx <span>in</span> range(self<span>.</span>num_cells):
</span></span><span><span>            self<span>.</span>_seek_to_cell_contents(cell_idx)
</span></span><span><span>            <span># Skip # of bytes for now. We arent handling page overflow</span>
</span></span><span><span>            _ <span>=</span> self<span>.</span>_varintreader<span>.</span>read()                
</span></span><span><span>            <span># Skip the rowid for now</span>
</span></span><span><span>            _ <span>=</span> self<span>.</span>_varintreader<span>.</span>read()
</span></span><span><span>            header_size <span>=</span> self<span>.</span>_varintreader<span>.</span>read()
</span></span><span><span>            record <span>=</span> []
</span></span><span><span>            <span># subtract 1 because header_size is the number of bytes in the header including a size byte</span>
</span></span><span><span>            <span>for</span> type <span>in</span> self<span>.</span>_read_col_types(header_size <span>-</span> <span>1</span>):
</span></span><span><span>                record<span>.</span>append(self<span>.</span>_read_col(type))
</span></span><span><span>            result<span>.</span>append(tuple(record))
</span></span><span><span>            
</span></span><span><span>        <span>return</span> result
</span></span></code></pre></div><p>Up until this point, reading data from the Sqlite file is relatively straight-forward. There are some unexpected indirections and pointers to pointers, but it can all be handled by carefully reading the spec and seeking around the file. Reading table data, however, requires us to parse variable length integers called “varints” (as indicated by the above calls to <code>self._varintreader.read()</code>)</p>
<h2 id="parsing-sqlite-varints">Parsing Sqlite varints</h2>
<p>Varints are a clever way of saving space in the database. Here are the docs on how they work:</p>
<blockquote>
<p>A varint is between 1 and 9 bytes in length. The varint consists of either zero or more bytes which have the high-order bit set followed by a single byte with the high-order bit clear, or nine bytes, whichever is shorter. The lower seven bits of each of the first eight bytes and all 8 bits of the ninth byte are used to reconstruct the 64-bit twos-complement integer.</p>
</blockquote>
<p>Here’s an example test case:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>test_read_varint_reads_128</span>():
</span></span><span><span>    <span>assert</span> read_varint(to_int_list(<span>0b1000_0001_0000_0000</span><span>.</span>to_bytes(length<span>=</span><span>2</span>))) <span>==</span> <span>128</span>
</span></span></code></pre></div><p>128 can’t fit in a single byte varint because the first bit is reserved for indicating that there is another byte whose bits make up the integer. So, to say “128” in varint, we have</p>
<ul>
<li>a single byte with a continuation bit set and another bit set at the end of the byte which maps to 2^7 (even though its the 8th bit in the byte string)</li>
<li>a byte with the continuation bit clear followed by 7 0s</li>
</ul>
<p>Since we don’t want to assume the Sqlite database can fit in memory, we can create a generator function that reads through the file byte by byte:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>byte_by_byte</span>(file: BufferedReader):
</span></span><span><span>    byte <span>=</span> file<span>.</span>read(<span>1</span>)
</span></span><span><span>    <span>while</span> byte:
</span></span><span><span>        <span>yield</span> byte
</span></span><span><span>        byte <span>=</span> file<span>.</span>read(<span>1</span>)
</span></span></code></pre></div><p>We can iterate over that generator until we reach a byte without a continuation bit set:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>get_varint_bytes</span>(bytes: Generator) <span>-&gt;</span> List[int]:
</span></span><span><span>    result_bytes <span>=</span> []
</span></span><span><span>    <span>for</span> byte <span>in</span> bytes:
</span></span><span><span>        byte_as_int <span>=</span> int<span>.</span>from_bytes(byte)
</span></span><span><span>        result_bytes<span>.</span>append(byte_as_int)
</span></span><span><span>        <span>if</span> <span>not</span> byte_as_int <span>&amp;</span> <span>0b1000_0000</span>:
</span></span><span><span>            <span>break</span>
</span></span><span><span>    <span>return</span> result_bytes
</span></span></code></pre></div><p>If we have a list of bytes (as ints) that make up our varint, then converting it to a number can be done like this:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>read_varint</span>(bytes: List[int]) <span>-&gt;</span> int:
</span></span><span><span>    num <span>=</span> <span>0</span>
</span></span><span><span>    <span>for</span> i, byte <span>in</span> enumerate(bytes):
</span></span><span><span>        <span># clear continuation bit if needed</span>
</span></span><span><span>        byte <span>=</span> byte <span>^</span> <span>0b1000_0000</span> <span>if</span> i <span>&lt;</span> len(bytes) <span>-</span> <span>1</span> <span>else</span> byte 
</span></span><span><span>        <span># shift bits to the correct position</span>
</span></span><span><span>        byte <span>=</span> byte <span>&lt;&lt;</span> (<span>7</span> <span>*</span> (len(bytes) <span>-</span> i <span>-</span> <span>1</span>))
</span></span><span><span>        num <span>=</span> byte <span>|</span> num
</span></span><span><span>    <span>return</span> num
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>I’ve ommitted a bunch of relatively uninteresting code here, but my working implementation was less than 500 LoC including tests. Its a fun exercise. Try it. You don’t need anyting fancy like <a href="https://codecrafters.io/" target="_blank" rel="noopener noreferrer">Code Crafters</a> to do this, and writing your own test harness can be a plus for getting deep on your test framework.</p>
<h2 id="appendix-a-how-does-openais-o1-fare-at-this-task">Appendix A: How does OpenAI’s o1 fare at this task?</h2>
<p>o1 produced code that looked reasonable, but didn’t work initially. Here was the initial prompt:</p>
<blockquote>
<p>give me a script that’ll return the result of executing “SELECT * FROM sqlite_master;” without using the sqlite3 package</p>
</blockquote>
<p>Running the initial code gave me the following output:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>mattdupree@matts-air sqlite_python % pipenv run python ai_main.py
</span></span><span><span>Unsupported page type: <span>83</span>
</span></span><span><span>type | name | tbl_name | rootpage | sql
</span></span></code></pre></div><p>Then I asked it to fix the bug. Here’s its explanation for the bug:</p>
<blockquote>
<p>I’m sorry about the error you’re encountering. The issue arises because the script doesn’t account for the 100-byte database header in SQLite database files. SQLite files begin with a 100-byte header, and the actual page data starts immediately after this header.</p>
</blockquote>
<p>The new code gave the following output:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>mattdupree@matts-air sqlite_python % pipenv run python ai_main.py
</span></span><span><span>type | name | tbl_name | rootpage | sql
</span></span><span><span> | None |  |  |  | b<span>&#39;\x00&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> |  |  | b<span>&#39;&#39;</span> |  | b<span>&#39;&#39;</span> |  |  | b<span>&#39;&#39;</span> |  | b<span>&#39;&#39;</span> |  | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> |  | b<span>&#39;&#39;</span> |  |  |  | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> |  | None | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | None | None | None | None | b<span>&#39;&#39;</span> |  | None | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> |  | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> |  | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> | b<span>&#39;&#39;</span> |  | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None | None
</span></span></code></pre></div><p>After an hour or so with the debuggger, I found two errors that enabled the script to work for files where the sqlite_schema tables existed on a leaf page:</p>
<pre tabindex="0"><code>         for ptr in cell_pointers:
             cell_offset = ptr
-            payload_size, offset = read_varint(page, cell_offset)
+            payload_size, offset = read_varint(page, cell_offset - 100)
             cell_offset = offset
             rowid, offset = read_varint(page, cell_offset)
             cell_offset = offset
</code></pre><p>Here the code doesn’t account for that fact that in cases where you’re parsing a leaf page that happens to be the first page the page’s cell pointers are relative to the start of the file, not the start of the page data. I made this same mistake when coding manually. Subtracting 100 happened to work here since the database header is 100 bytes long.</p>
<p>Here’s the next bug fix:</p>
<pre tabindex="0"><code> 
             header_start = cell_offset
             types = []
-            while cell_offset &lt; header_start + header_size_varint:
+            while cell_offset &lt; header_start + header_size_varint - 1:
                 serial_type, offset = read_varint(page, cell_offset)
                 types.append(serial_type)
                 cell_offset = offset
</code></pre><p>This is an off-by-one error. The code doesn’t account for the fact that the header size varint “is the size of the header in bytes including the size varint itself.”</p>
<p>Running the AI genreated script on a file where the sqlite_schema table is spread across multiple pages didn’t work:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>mattdupree@matts-air sqlite_python % pipenv run python ai_main.py
</span></span><span><span>Page number <span>987407</span> is out of range.
</span></span><span><span>Page number <span>987407</span> is out of range.
</span></span><span><span>Unsupported page type: <span>50</span>
</span></span><span><span>No entries found in sqlite_master.
</span></span></code></pre></div><p>I couldn’t bring myself to track down the bug within <a href="https://gist.github.com/kmdupr33/27c1232cbb7e580f44098b33f27a620a" target="_blank" rel="noopener noreferrer">the AI-generated yucky code</a>. I told ChatGPT to rewrite the code so that it was more readable. I generated broken code again.</p>
<h2 id="appendix-b-hire-josh">Appendix B: Hire Josh</h2>
<p>While I have your attention, I’m winding down a startup I’ve been working on, which means that Josh, an awesome engineer, person, and friend – is on the market. I met Josh 8 years ago while working at another startup. It was immediately clear to me that he was a brilliant engineer. Software was a craft that he cared deeply about and he studied with a fervor that I’ve haven’t seen in anyone else in my decade long career.</p>
<p>I wrote more about him <a href="https://www.linkedin.com/posts/k-matthew-dupree-44672178_opentowork-activity-7247249132187172866-DV5D?utm_source=share&amp;utm_medium=member_desktop" target="_blank" rel="noopener noreferrer">here</a>. If you have any questions about him, feel free to email me at <a href="https://www.philosophicalhacker.com/cdn-cgi/l/email-protection#afc4c2cedbdbc7cad881cbdadfddcacaefc8c2cec6c381ccc0c2"><span data-cfemail="244f494550504c41530a405154564141644349454d480a474b49">[email protected]</span></a>. If you’d like to contact him directly, here’s <a href="https://www.linkedin.com/in/jshroyer/?lipi=urn%3Ali%3Apage%3Ad_flagship3_detail_base%3BH%2BUA4AVIRz6P2RlJBEjsFA%3D%3D" target="_blank" rel="noopener noreferrer">his LinkedIn</a>.</p>
</article></div>
  </body>
</html>
