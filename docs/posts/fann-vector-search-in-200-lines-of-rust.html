<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fennel.ai/blog/vector-search-in-200-lines-of-rust/">Original</a>
    <h1>FANN: Vector Search in 200 Lines of Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>But first, let&#39;s establish what vector search is.</p><h2 id="introduction-to-vectors-aka-embeddings">Introduction to Vectors (aka Embeddings)</h2><p>Complex unstructured data like docs, images, videos, are difficult to represent and query in traditional databases – especially if the query intent is to find &#34;similar&#34; items. So how can Youtube choose the best video to play next? Or Spotify customize the music queue according to your current song? </p><p>Advances in AI in early 2010s (starting with Word2Vec and GloVe) enabled us to build semantic representation of these objects in which they are represented as points in cartesian space. Say one video gets mapped to the point [0.1, -5.1, 7.55] and another gets mapped to the point [5.3, -0.1, 2.7]. The magic of these ML algorithms is that these representations are chosen such that they maintain semantic information –  more similar two videos, smaller the distance is between their vectors. </p><p>Note that these vectors (or more technically called as embeddings) don&#39;t have to be 3 dimensional - they could be and often are in higher dimensional spaces (say 128 dimensions or 750 dimensions). And the distance doesn&#39;t need to be euclidean distance either - other forms of distances, like dot products, also work. Either way, all that matters is the distances between them correspond to their similarities. </p><p>Now imagine that we have access to such vectors for all Youtube videos. How do we find the most similar video to a given starting video? Simple. Loop through all the videos, compute the distance between them and choose the video with the smallest distance - also known as finding the &#34;nearest neighbours&#34; of the query video. This will actually work. Except, as you can guess, a linear O(N) scan can be too costly. So we need a faster sub-linear way to find the nearest neighbours of any a query video. This is in general impossible - something has to give. </p><p>As it turns out, in practical situations, we don&#39;t need to find <em>the</em> nearest video - it&#39;d also be okay to find <em>near-enough</em> videos. And this is where approximate nearest neighbor search algorithms, also known as vector search come in. The goal is to sub-linearly (ideally in logarithmic time) find close enough nearest neighbours of any point in a space. So how to solve that?</p><h2 id="how-to-find-approximate-nearest-neighbours">How to Find Approximate Nearest Neighbours?</h2><p>The basic idea behind all vector search algorithms is the same – do some pre-processing to identify  points that are close enough to each other (somewhat akin to building an index). At the query time, use this &#34;index&#34; to rule out large swath of points. And do a linear scan within the small number of points that don&#39;t get ruled out.</p><p>However, there are lots of ways of approaching this simple idea. Several state-of-the-art vector search algorithms exist like <a href="https://github.com/nmslib/hnswlib?ref=fennel.ai">HNSW</a> (a graph that connects close-proximity vertices and also maintains long-distance edges with a fixed entry point). There exist open-source efforts like Facebook’s <a href="https://github.com/facebookresearch/faiss?ref=fennel.ai">FAISS</a> and several PaaS offerings for high-availability vector databases like <a href="https://www.pinecone.io/?ref=fennel.ai">Pinecone</a> and <a href="https://weaviate.io/?ref=fennel.ai">Weaviate</a>. </p><p>In this post, we will build a simplified vector search index over the given &#34;N&#34; points as follows:</p><ol><li>Randomly take 2 arbitrary available vectors A and B.</li><li>Calculate the midpoint between these 2 vectors, called C.</li><li>Build a hyperplane (analog of a &#34;line&#34; in higher dimensions) that passes through C and is perpendicular to the line segment connecting A and B. </li><li>Classify all the vectors as being either “above” or “below” the hyperplane, splitting the available vectors into 2 groups. </li><li>For each of the two groups: if the size of the group is higher than a configurable parameter “maximum node size”, recursively call this process on that group to build a subtree. Else, build a single leaf node with all the vector (or their unique ids)</li></ol><p>We thus use this randomized process to build a tree where every internal node is a hyperplane definition with the left subtree being all the vectors “below” the hyperplane and the right subtree being all the vectors “above”. The set of vectors are continuously recursively split until leaf nodes contain no more than “maximum node size” vectors. Consider the example in the following figure with five points:<br/></p><figure><img src="https://fennel.ai/blog/content/images/2023/06/data-src-image-050a1e4d-0798-44ef-b0e4-22974a071d5f.png" alt="" loading="lazy" width="1112" height="912" srcset="https://fennel.ai/blog/content/images/size/w600/2023/06/data-src-image-050a1e4d-0798-44ef-b0e4-22974a071d5f.png 600w, https://fennel.ai/blog/content/images/size/w1000/2023/06/data-src-image-050a1e4d-0798-44ef-b0e4-22974a071d5f.png 1000w, https://fennel.ai/blog/content/images/2023/06/data-src-image-050a1e4d-0798-44ef-b0e4-22974a071d5f.png 1112w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 1: Splitting Spaces with Random Hyperplanes </figcaption></figure><p>We randomly choose vectors A1=(4,2), B1=(5,7). Their midpoint is (4.5,4.5) and we build a line through the midpoint perpendicular to the line (A1, B1). That line is x + 5y=27 (drawn in blue) which gives us one group of 2 vectors, and one group of 4. Assume the “maximum node size” is configured to 2. We do not further split the first group but choose a new (A2, B2) from the latter to build the red hyperplane and so on. Repeated splits on a large dataset split up the hyperspace into several distinct regions as shown below. </p><figure><img src="https://fennel.ai/blog/content/images/2023/06/data-src-image-dc4255fb-a33d-4b52-aa2a-a4d73b9825d7.png" alt="" loading="lazy" width="1600" height="1229" srcset="https://fennel.ai/blog/content/images/size/w600/2023/06/data-src-image-dc4255fb-a33d-4b52-aa2a-a4d73b9825d7.png 600w, https://fennel.ai/blog/content/images/size/w1000/2023/06/data-src-image-dc4255fb-a33d-4b52-aa2a-a4d73b9825d7.png 1000w, https://fennel.ai/blog/content/images/2023/06/data-src-image-dc4255fb-a33d-4b52-aa2a-a4d73b9825d7.png 1600w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 2: Segmented Space After Many Hyperplanes</figcaption></figure><p>Each region here represents a leaf node and the intuition here is that points that are close enough are likely to end up in the same leaf node. So given a query point, we can traverse down the tree in logarithmic time to locate the leaf it belongs to and run a linear scan against all the (small number of) points in that leaf. This is obviously not foolproof - it&#39;s totally possible that points that are actually close enough get separated by a hyperplane and end up very far off from each other. But this problem can be tackled by building not one but many independent trees - that way if two points are close enough, they are far more likely to be in the same leaf node in at least some trees. At the query time, we traverse down all the trees to locate the relevant leaf nodes, take a union of all the candidates across all leaves, and do a linear scan on all of them.</p><p>Okay enough of theory. Let&#39;s start writing some code and first define some utilities for a Vector type in Rust below, for dot product, averaging, hashing, and squared L2 distance. Thanks to Rust&#39;s nice type system, we propagate the generic type parameter N to force all vectors in an index to be the same dimensionality at compile time.</p><pre><code>#[derive(Eq, PartialEq, Hash)]
pub struct HashKey&lt;const N: usize&gt;([u32; N]);

#[derive(Copy, Clone)]
pub struct Vector&lt;const N: usize&gt;(pub [f32; N]);
impl&lt;const N: usize&gt; Vector&lt;N&gt; {
    pub fn subtract_from(&amp;self, vector: &amp;Vector&lt;N&gt;) -&gt; Vector&lt;N&gt; {
        let mapped = self.0.iter().zip(vector.0).map(|(a, b)| b - a);
        let coords: [f32; N] = mapped.collect::&lt;Vec&lt;_&gt;&gt;().try_into().unwrap();
        return Vector(coords);
    }
    pub fn avg(&amp;self, vector: &amp;Vector&lt;N&gt;) -&gt; Vector&lt;N&gt; {
        let mapped = self.0.iter().zip(vector.0).map(|(a, b)| (a + b) / 2.0);
        let coords: [f32; N] = mapped.collect::&lt;Vec&lt;_&gt;&gt;().try_into().unwrap();
        return Vector(coords);
    }
    pub fn dot_product(&amp;self, vector: &amp;Vector&lt;N&gt;) -&gt; f32 {
        let zipped_iter = self.0.iter().zip(vector.0);
        return zipped_iter.map(|(a, b)| a * b).sum::&lt;f32&gt;();
    }
    pub fn to_hashkey(&amp;self) -&gt; HashKey&lt;N&gt; {
        // f32 in Rust doesn&#39;t implement hash. We use bytes to dedup. While it
        // can&#39;t differentiate ~16M ways NaN is written, it&#39;s safe for us
        let bit_iter = self.0.iter().map(|a| a.to_bits());
        let data: [u32; N] = bit_iter.collect::&lt;Vec&lt;_&gt;&gt;().try_into().unwrap();
        return HashKey::&lt;N&gt;(data);
    }
    pub fn sq_euc_dis(&amp;self, vector: &amp;Vector&lt;N&gt;) -&gt; f32 {
        let zipped_iter = self.0.iter().zip(vector.0);
        return zipped_iter.map(|(a, b)| (a - b).powi(2)).sum();
    }
}
</code></pre><p>With these core utilities built out, let&#39;s next focus on generating random hyper planes and building forest of nearest neighbour trees. How should we represent points within a tree? </p><div>
<p>
<h4>Join 1000+ others on our newsletter mailing list to get posts like this direct to your inbox!</h4>
</p>

<p>Please wait...</p>
<p>Please check your inbox and click the link</p>
<p>Please enter a valid email address!</p>
</div><p>We could directly store D-dimensional vectors inside leaf nodes. But that significantly fragments memory (major performance hit) for large D and also creates duplicate memory in a forest when multiple trees refer to the same vectors. Instead, we store vectors in a global contiguous location and hold `usize` indices (8 bytes on a 64-bit system instead of 4D, where f32 takes 4 bytes) at leaf nodes. Here are the data types used to represent inner and leaf nodes of the tree.</p><pre><code>enum Node&lt;const N: usize&gt; {
    Inner(Box&lt;InnerNode&lt;N&gt;&gt;),
    Leaf(Box&lt;LeafNode&lt;N&gt;&gt;),
}
struct LeafNode&lt;const N: usize&gt;(Vec&lt;usize&gt;);
struct InnerNode&lt;const N: usize&gt; {
    hyperplane: HyperPlane&lt;N&gt;,
    left_node: Node&lt;N&gt;,
    right_node: Node&lt;N&gt;,
}
pub struct ANNIndex&lt;const N: usize&gt; {
    trees: Vec&lt;Node&lt;N&gt;&gt;,
    ids: Vec&lt;i32&gt;,
    values: Vec&lt;Vector&lt;N&gt;&gt;,
}</code></pre><p>How do we actually find the right hyperplanes? </p><p>We sample two unique indexes for vectors A and B, calculate n = A - B, and find the midpoint of A and B (point_on_plane). Hyperplane is efficiently stored with structs of coefficients (vector n) and constant (dot product of n and point_on_plane) as n(x-x0) = nx - nx0. We can perform a dot product between any vector and n and subtract the constant to place the vector “above” or “below” the hyperplane. As internal nodes in our trees hold hyperplane definitions and leaf nodes hold vector IDs, we can type-check our tree with ADTs:</p><pre><code>impl&lt;const N: usize&gt; ANNIndex&lt;N&gt; {
    fn build_hyperplane(
        indexes: &amp;Vec&lt;usize&gt;,
        all_vecs: &amp;Vec&lt;Vector&lt;N&gt;&gt;,
    ) -&gt; (HyperPlane&lt;N&gt;, Vec&lt;usize&gt;, Vec&lt;usize&gt;) {
        let sample: Vec&lt;_&gt; = indexes
            .choose_multiple(&amp;mut rand::thread_rng(), 2)
            .collect();
        // cartesian eq for hyperplane n * (x - x_0) = 0
        // n (normal vector) is the coefs x_1 to x_n
        let (a, b) = (*sample[0], *sample[1]);
        let coefficients = all_vecs[a].subtract_from(&amp;all_vecs[b]);
        let point_on_plane = all_vecs[a].avg(&amp;all_vecs[b]);
        let constant = -coefficients.dot_product(&amp;point_on_plane);
        let hyperplane = HyperPlane::&lt;N&gt; {
            coefficients,
            constant,
        };
        let (mut above, mut below) = (vec![], vec![]);
        for &amp;id in indexes.iter() {
            if hyperplane.point_is_above(&amp;all_vecs[id]) {
                above.push(id)
            } else {
                below.push(id)
            };
        }
        return (hyperplane, above, below);
    }
}</code></pre><p>We can thus define our recursive process to build trees based on the index-time “maximum node size”:</p><pre><code>impl&lt;const N: usize&gt; ANNIndex&lt;N&gt; {
    fn build_a_tree(
        max_size: i32,
        indexes: &amp;Vec&lt;usize&gt;,
        all_vecs: &amp;Vec&lt;Vector&lt;N&gt;&gt;,
    ) -&gt; Node&lt;N&gt; {
        if indexes.len() &lt;= (max_size as usize) {
            return Node::Leaf(Box::new(LeafNode::&lt;N&gt;(indexes.clone())));
        }
        let (plane, above, below) = Self::build_hyperplane(indexes, all_vecs);
        let node_above = Self::build_a_tree(max_size, &amp;above, all_vecs);
        let node_below = Self::build_a_tree(max_size, &amp;below, all_vecs);
        return Node::Inner(Box::new(InnerNode::&lt;N&gt; {
            hyperplane: plane,
            left_node: node_below,
            right_node: node_above,
        }));
    }
}   </code></pre><p>Notice that building a hyperplane between two points requires those two points to be unique - i.e. we must deduplicate our vector set before indexing since the algorithm does not allow duplicates. </p><p>And thus entire index (forest of trees) can thus be built with:</p><pre><code>impl&lt;const N: usize&gt; ANNIndex&lt;N&gt; {
    fn deduplicate(
        vectors: &amp;Vec&lt;Vector&lt;N&gt;&gt;,
        ids: &amp;Vec&lt;i32&gt;,
        dedup_vectors: &amp;mut Vec&lt;Vector&lt;N&gt;&gt;,
        ids_of_dedup_vectors: &amp;mut Vec&lt;i32&gt;,
    ) {
        let mut hashes_seen = HashSet::new();
        for i in 1..vectors.len() {
            let hash_key = vectors[i].to_hashkey();
            if !hashes_seen.contains(&amp;hash_key) {
                hashes_seen.insert(hash_key);
                dedup_vectors.push(vectors[i]);
                ids_of_dedup_vectors.push(ids[i]);
            }
        }
    }

    pub fn build_index(
        num_trees: i32,
        max_size: i32,
        vecs: &amp;Vec&lt;Vector&lt;N&gt;&gt;,
        vec_ids: &amp;Vec&lt;i32&gt;,
    ) -&gt; ANNIndex&lt;N&gt; {
        let (mut unique_vecs, mut ids) = (vec![], vec![]);
        Self::deduplicate(vecs, vec_ids, &amp;mut unique_vecs, &amp;mut ids);
        // Trees hold an index into the [unique_vecs] list which is not
        // necessarily its id, if duplicates existed
        let all_indexes: Vec&lt;usize&gt; = (0..unique_vecs.len()).collect();
        let trees: Vec&lt;_&gt; = (0..num_trees)
            .map(|_| Self::build_a_tree(max_size, &amp;all_indexes, &amp;unique_vecs))
            .collect();
        return ANNIndex::&lt;N&gt; {
            trees,
            ids,
            values: unique_vecs,
        };
    }
}</code></pre><h3 id="query-time"></h3><p>Once index is built out, how can we use it to search for K approximate nearest neighbors of an input vector on a single tree? At non-leaf nodes, we store hyperplanes and so we can start with the tree’s root and ask: “is this vector above or below this hyperplane?”. This can be calculated in O(D) with a dot product. Based on the response, we can recursively search the left or right subtree until we hit a leaf node. Remember the leaf node stores at most “maximum node size” vectors which are in the approximate neighbourhood of the input vector (as they fall in the same partition of the hyperspace under all hyperplanes, see Figure 1(b)). If the number of vector indices at this leaf node exceeds K, we can now sort all these vectors by L2 distance to the input vector and return the closest K!<br/></p><p>Assuming our indexing leads to a balanced tree, for dimension D, number of vectors N, and maximum node size M &lt;&lt; N, search takes O(Dlog(N) + DM + Mlog(M)) - this constitutes the average worst-case log(N) hyperplane comparisons to find a leaf node (which is the height of the tree) where each comparison costs a O(D) dot product, calculating the L2 metric for all candidate vectors in a leaf node in O(DM) and finally sorting them to return the top K in O(Mlog(M)). </p><p>However, what happens if the leaf node we found has less than K vectors? This is possible if the maximum node size is too low or there is a relatively uneven hyperplane split leaving very few vectors in a subtree. To address this, we can add some simple backtracking capabilities to our tree search. For instance, we could make an additional recursive call at the interior node to visit the other branch if the returned number of candidates isn&#39;t sufficient. This is how it could look like:</p><pre><code>impl&lt;const N: usize&gt; ANNIndex&lt;N&gt; {
    fn tree_result(
        query: Vector&lt;N&gt;,
        n: i32,
        tree: &amp;Node&lt;N&gt;,
        candidates: &amp;mut HashSet&lt;usize&gt;,
    ) -&gt; i32 {
        // take everything in node, if still needed, take from alternate subtree
        match tree {
            Node::Leaf(box_leaf) =&gt; {
                let leaf_values = &amp;(box_leaf.0);
                let num_candidates_found = min(n as usize, leaf_values.len());
                for i in 0..num_candidates_found {
                    candidates.insert(leaf_values[i]);
                }
                return num_candidates_found as i32;
            }
            Node::Inner(inner) =&gt; {
                let above = (*inner).hyperplane.point_is_above(&amp;query);
                let (main, backup) = match above {
                    true =&gt; (&amp;(inner.right_node), &amp;(inner.left_node)),
                    false =&gt; (&amp;(inner.left_node), &amp;(inner.right_node)),
                };
                match Self::tree_result(query, n, main, candidates) {
                    k if k &lt; n =&gt; {
                        k + Self::tree_result(query, n - k, backup, candidates)
                    }
                    k =&gt; k,
                }
            }
        }
    }
}

</code></pre><p>Expanding this search to a forest of trees is trivial - simply collect top K candidates from all trees independently, sort them by the distance, and return the overall top K matches. Note that higher number of trees will have a linearly high memory footprint and linearly-scaled search-time but can lead to better “closer” neighbours since we collect candidates across different trees.</p><pre><code>impl&lt;const N: usize&gt; ANNIndex&lt;N&gt; {
    pub fn search_approximate(
        &amp;self,
        query: Vector&lt;N&gt;,
        top_k: i32,
    ) -&gt; Vec&lt;(i32, f32)&gt; {
        let mut candidates = HashSet::new();
        for tree in self.trees.iter() {
            Self::tree_result(query, top_k, tree, &amp;mut candidates);
        }
        candidates
            .into_iter()
            .map(|idx| (idx, self.values[idx].sq_euc_dis(&amp;query)))
            .sorted_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
            .take(top_k as usize)
            .map(|(idx, dis)| (self.ids[idx], dis))
            .collect()
    }
}</code></pre><p>This implementation is fairly simple for illustrative purposes – in fact it&#39;s so simple that we suspect it must be much worse than state of the art algorithms (despite being similar in the broader approach). Let&#39;s do some benchmarking to confirm our suspicision.</p><p>Algorithms can be evaluated for both latency and quality. Quality is often measured by recall - the % of actual closest neighbours (as obtained from linear scan) that are also obtained by the approximate nearest neighbour search. Some times the returned results are not technically in top K but they are so close to actual top K that it doesn&#39;t matter - to quantify that, we can also look at average euclidean distance of the neighbours and compare that with average distance with brute force search. </p><p>Measuring latency is simple - we can look at the time it takes to execute a query (we are often less interested in index build latencies).</p><p>All benchmarking results were run on a single-device CPU with a 2.3 GHz Quad-Core Intel Core i5 processor using the 999,994 Wiki-data FastText embeddings (<a href="https://dl.fbaipublicfiles.com/fasttext/vectors-english/wiki-news-300d-1M.vec.zip?ref=fennel.ai">https://dl.fbaipublicfiles.com/fasttext/vectors-english/wiki-news-300d-1M.vec.zip</a>) in 300 dimensions. We set the “top K” to be 20 for all our queries.</p><p>As a point of reference, we compare a FAISS HNSW Index (ef_search=16, ef_construction=40, max_node_size=15) against a small version of our Rust index (num_trees=3, max_node_size=15). We implemented exhaustive search in Rust, while the FAISS library has a C++ source for HNSW. Raw latency numbers reinforce the benefit of approximate search:</p><table><colgroup><col width="233"/><col width="233"/><col width="233"/></colgroup><thead><tr><th scope="col"><p dir="ltr"><span>Algorithm</span></p></th><th scope="col"><p dir="ltr"><span>Latency</span></p></th><th scope="col"><p dir="ltr"><span>QPS</span></p></th></tr><tr><th scope="col"><p dir="ltr"><span>Exhaustive Search</span></p></th><th scope="col"><p dir="ltr"><span>675.25ms</span></p></th><th scope="col"><p dir="ltr"><span>1.48</span></p></th></tr></thead><tbody><tr><td><p dir="ltr"><span>FAISS HNSW Index</span></p></td><td><p dir="ltr"><span>355.36μs</span></p></td><td><p dir="ltr"><span>2814.05</span></p></td></tr><tr><td><p dir="ltr"><span>Custom Rust Index</span></p></td><td><p dir="ltr"><span>112.02μs</span></p></td><td><p dir="ltr"><span>8926.98</span></p></td></tr></tbody></table><p>Both approximate nearest neighbor approaches are three orders of magnitude faster, which is good. And looks like our Rust implementation is 3x faster on this micro benchmark compared to HNSW. When analyzing quality, visually consider the first 10 nearest neighbors returned for the prompt “river”.<br/></p><table><colgroup><col width="111"/><col width="98"/><col width="111"/><col width="98"/><col width="95"/><col width="95"/></colgroup><tbody><tr><td colspan="2"><p dir="ltr"><span>Exhaustive Search</span></p></td><td colspan="2"><p dir="ltr"><span>FAISS HNSW Index</span></p></td><td colspan="2"><p dir="ltr"><span>Custom Rust Index</span></p></td></tr><tr><td><p dir="ltr"><span>Word</span></p></td><td><p dir="ltr"><span>Euclidean Distance</span></p></td><td><p dir="ltr"><span>Word</span></p></td><td><p dir="ltr"><span>Euclidean Distance</span></p></td><td><p dir="ltr"><span>Word</span></p></td><td><p dir="ltr"><span>Euclidean Distance</span></p></td></tr><tr><td><p dir="ltr"><span>river</span></p></td><td><p dir="ltr"><span>0</span></p></td><td><p dir="ltr"><span>river</span></p></td><td><p dir="ltr"><span>0</span></p></td><td><p dir="ltr"><span>river</span></p></td><td><p dir="ltr"><span>0</span></p></td></tr><tr><td><p dir="ltr"><span>River</span></p></td><td><p dir="ltr"><span>1.39122</span></p></td><td><p dir="ltr"><span>River</span></p></td><td><p dir="ltr"><span>1.39122</span></p></td><td><p dir="ltr"><span>creek</span></p></td><td><p dir="ltr"><span>1.63744</span></p></td></tr><tr><td><p dir="ltr"><span>rivers</span></p></td><td><p dir="ltr"><span>1.47646</span></p></td><td><p dir="ltr"><span>river-</span></p></td><td><p dir="ltr"><span>1.58342</span></p></td><td><p dir="ltr"><span>river.</span></p></td><td><p dir="ltr"><span>1.73224</span></p></td></tr><tr><td><p dir="ltr"><span>river-</span></p></td><td><p dir="ltr"><span>1.58342</span></p></td><td><p dir="ltr"><span>swift-flowing</span></p></td><td><p dir="ltr"><span>1.62413</span></p></td><td><p dir="ltr"><span>lake</span></p></td><td><p dir="ltr"><span>1.75655</span></p></td></tr><tr><td><p dir="ltr"><span>swift-flowing</span></p></td><td><p dir="ltr"><span>1.62413</span></p></td><td><p dir="ltr"><span>flood-swollen</span></p></td><td><p dir="ltr"><span>1.63798</span></p></td><td><p dir="ltr"><span>sea</span></p></td><td><p dir="ltr"><span>1.87368</span></p></td></tr><tr><td><p dir="ltr"><span>creek</span></p></td><td><p dir="ltr"><span>1.63744</span></p></td><td><p dir="ltr"><span>river.The</span></p></td><td><p dir="ltr"><span>1.68156</span></p></td><td><p dir="ltr"><span>up-river</span></p></td><td><p dir="ltr"><span>1.92088</span></p></td></tr><tr><td><p dir="ltr"><span>flood-swollen</span></p></td><td><p dir="ltr"><span>1.63798</span></p></td><td><p dir="ltr"><span>river-bed</span></p></td><td><p dir="ltr"><span>1.68510</span></p></td><td><p dir="ltr"><span>shore</span></p></td><td><p dir="ltr"><span>1.92266</span></p></td></tr><tr><td><p dir="ltr"><span>river.The</span></p></td><td><p dir="ltr"><span>1.68156</span></p></td><td><p dir="ltr"><span>unfordable</span></p></td><td><p dir="ltr"><span>1.69245</span></p></td><td><p dir="ltr"><span>brook</span></p></td><td><p dir="ltr"><span>2.01973</span></p></td></tr><tr><td><p dir="ltr"><span>river-bed</span></p></td><td><p dir="ltr"><span>1.68510</span></p></td><td><p dir="ltr"><span>River-</span></p></td><td><p dir="ltr"><span>1.69512</span></p></td><td><p dir="ltr"><span>hill</span></p></td><td><p dir="ltr"><span>2.03419</span></p></td></tr><tr><td><p dir="ltr"><span>unfordable</span></p></td><td><p dir="ltr"><span>1.69245</span></p></td><td><p dir="ltr"><span>River.The</span></p></td><td><p dir="ltr"><span>1.69539</span></p></td><td><p dir="ltr"><span>pond</span></p></td><td><p dir="ltr"><span>2.04376</span></p></td></tr></tbody></table><table><colgroup><col width="105"/><col width="95"/><col width="105"/><col width="95"/><col width="115"/><col width="93"/></colgroup><tbody><tr><td colspan="2"><p dir="ltr"><span>Exhaustive Search</span></p></td><td colspan="2"><p dir="ltr"><span>FAISS HNSW Index</span></p></td><td colspan="2"><p dir="ltr"><span>Custom Rust Index</span></p></td></tr><tr><td><p dir="ltr"><span>Word</span></p></td><td><p dir="ltr"><span>Euclidean Distance</span></p></td><td><p dir="ltr"><span>Word</span></p></td><td><p dir="ltr"><span>Euclidean Distance</span></p></td><td><p dir="ltr"><span>Word</span></p></td><td><p dir="ltr"><span>Euclidean Distance</span></p></td></tr><tr><td><p dir="ltr"><span>war</span></p></td><td><p dir="ltr"><span>0</span></p></td><td><p dir="ltr"><span>war</span></p></td><td><p dir="ltr"><span>0</span></p></td><td><p dir="ltr"><span>war</span></p></td><td><p dir="ltr"><span>0</span></p></td></tr><tr><td><p dir="ltr"><span>war--</span></p></td><td><p dir="ltr"><span>1.38416</span></p></td><td><p dir="ltr"><span>war--</span></p></td><td><p dir="ltr"><span>1.38416</span></p></td><td><p dir="ltr"><span>war--</span></p></td><td><p dir="ltr"><span>1.38416</span></p></td></tr><tr><td><p dir="ltr"><span>war--a</span></p></td><td><p dir="ltr"><span>1.44906</span></p></td><td><p dir="ltr"><span>war--a</span></p></td><td><p dir="ltr"><span>1.44906</span></p></td><td><p dir="ltr"><span>wars</span></p></td><td><p dir="ltr"><span>1.45859</span></p></td></tr><tr><td><p dir="ltr"><span>wars</span></p></td><td><p dir="ltr"><span>1.45859</span></p></td><td><p dir="ltr"><span>wars</span></p></td><td><p dir="ltr"><span>1.45859</span></p></td><td><p dir="ltr"><span>quasi-war</span></p></td><td><p dir="ltr"><span>1.59712</span></p></td></tr><tr><td><p dir="ltr"><span>war--and</span></p></td><td><p dir="ltr"><span>1.45907</span></p></td><td><p dir="ltr"><span>war--and</span></p></td><td><p dir="ltr"><span>1.45907</span></p></td><td><p dir="ltr"><span>war-footing</span></p></td><td><p dir="ltr"><span>1.69175</span></p></td></tr><tr><td><p dir="ltr"><span>war.It</span></p></td><td><p dir="ltr"><span>1.46991</span></p></td><td><p dir="ltr"><span>war.It</span></p></td><td><p dir="ltr"><span>1.46991</span></p></td><td><p dir="ltr"><span>check-mate</span></p></td><td><p dir="ltr"><span>1.74982</span></p></td></tr><tr><td><p dir="ltr"><span>war.In</span></p></td><td><p dir="ltr"><span>1.49632</span></p></td><td><p dir="ltr"><span>war.In</span></p></td><td><p dir="ltr"><span>1.49632</span></p></td><td><p dir="ltr"><span>ill-begotten</span></p></td><td><p dir="ltr"><span>1.75498</span></p></td></tr><tr><td><p dir="ltr"><span>unwinable</span></p></td><td><p dir="ltr"><span>1.51296</span></p></td><td><p dir="ltr"><span>unwinable</span></p></td><td><p dir="ltr"><span>1.51296</span></p></td><td><p dir="ltr"><span>subequent</span></p></td><td><p dir="ltr"><span>1.76617</span></p></td></tr><tr><td><p dir="ltr"><span>war.And</span></p></td><td><p dir="ltr"><span>1.51830</span></p></td><td><p dir="ltr"><span>war.And</span></p></td><td><p dir="ltr"><span>1.51830</span></p></td><td><p dir="ltr"><span>humanitary</span></p></td><td><p dir="ltr"><span>1.77464</span></p></td></tr><tr><td><p dir="ltr"><span>hostilities</span></p></td><td><p dir="ltr"><span>1.54783</span></p></td><td><p dir="ltr"><span>Iraw</span></p></td><td><p dir="ltr"><span>1.54906</span></p></td><td><p dir="ltr"><span>execution</span></p></td><td><p dir="ltr"><span>1.77992</span></p></td></tr></tbody></table><figure><img src="https://lh6.googleusercontent.com/WeUpm6elb7L1vfBJVLBMHVTvxrAmeoTO3I9Hsn0uL7CEWMjvZqxtcqpkDAn1BSxWNUl2tsO_fvPDFEDNeyCzi6fc2utGtZmHCpLRR8eoSdCu7I-ZlKGED8i2KJAKot5iQQhxEE6tI8tYsad9xJevwMM" alt="" loading="lazy" width="341" height="306"/></figure><p>The state-of-the-art HNSW Index does provide relatively closer neighbors than our example index with a mean and median distance of 1.31576 and 1.20230 respectively (compared to our example index’s 1.47138 and 1.35620). On a randomized 10,000-sized subset of the corpus, HNSW demonstrates a 58.2% recall for top K=20, while our example index yields various recall (from 11.465% to 23.115%) for different configurations (as discussed earlier, higher number of trees provide higher recall):</p><table><colgroup><col width="127"/><col width="127"/><col width="127"/><col width="127"/><col width="127"/></colgroup><tbody><tr><td><p dir="ltr"><span>num_trees</span></p></td><td><p dir="ltr"><span>max_node_size</span></p></td><td><p dir="ltr"><span>Average runtime</span></p></td><td><p dir="ltr"><span>QPS</span></p></td><td><p dir="ltr"><span>Recall</span></p></td></tr><tr><td><p dir="ltr"><span>3</span></p></td><td><p dir="ltr"><span>5</span></p></td><td><p dir="ltr"><span>129.48μs</span></p></td><td><p dir="ltr"><span>7723</span></p></td><td><p dir="ltr"><span>0.11465</span></p></td></tr><tr><td><p dir="ltr"><span>3</span></p></td><td><p dir="ltr"><span>15</span></p></td><td><p dir="ltr"><span>112.02μs</span></p></td><td><p dir="ltr"><span>8297</span></p></td><td><p dir="ltr"><span>0.11175</span></p></td></tr><tr><td><p dir="ltr"><span>3</span></p></td><td><p dir="ltr"><span>30</span></p></td><td><p dir="ltr"><span>114.48μs</span></p></td><td><p dir="ltr"><span>8735</span></p></td><td><p dir="ltr"><span>0.09265</span></p></td></tr><tr><td><p dir="ltr"><span>9</span></p></td><td><p dir="ltr"><span>5</span></p></td><td><p dir="ltr"><span>16.77ms</span></p></td><td><p dir="ltr"><span>60</span></p></td><td><p dir="ltr"><span>0.22095</span></p></td></tr><tr><td><p dir="ltr"><span>9</span></p></td><td><p dir="ltr"><span>15</span></p></td><td><p dir="ltr"><span>1.54ms</span></p></td><td><p dir="ltr"><span>649</span></p></td><td><p dir="ltr"><span>0.20985</span></p></td></tr><tr><td><p dir="ltr"><span>9</span></p></td><td><p dir="ltr"><span>30</span></p></td><td><p dir="ltr"><span>370.80μs</span></p></td><td><p dir="ltr"><span>2697</span></p></td><td><p dir="ltr"><span>0.16835</span></p></td></tr><tr><td><p dir="ltr"><span>15</span></p></td><td><p dir="ltr"><span>5</span></p></td><td><p dir="ltr"><span>35.45ms</span></p></td><td><p dir="ltr"><span>28</span></p></td><td><p dir="ltr"><span>0.29825</span></p></td></tr><tr><td><p dir="ltr"><span>15</span></p></td><td><p dir="ltr"><span>15</span></p></td><td><p dir="ltr"><span>7.34ms</span></p></td><td><p dir="ltr"><span>136</span></p></td><td><p dir="ltr"><span>0.28520</span></p></td></tr><tr><td><p dir="ltr"><span>15</span></p></td><td><p dir="ltr"><span>30</span></p></td><td><p dir="ltr"><span>2.19ms</span></p></td><td><p dir="ltr"><span>457</span></p></td><td><p dir="ltr"><span>0.23115</span></p></td></tr></tbody></table><h2 id="why-is-fann-so-fast">Why is FANN so fast?</h2><p>As you can see in numbers above, while FANN algorithm isn&#39;t competitive with state of art on quality, it is at least pretty fast. Why is that the case?</p><p>Honestly, as we were building this, we got carried away and started doing performance optimizations just for fun. Here are a few optimizations that made the most difference:</p><ul><li>Offloading document deduplication to the indexing cold path. Referencing vectors by index instead of a float array significantly speeds up search as finding unique candidates across trees requires hashing 8-byte indices (not 300-dim f32 data).</li><li>Eagerly hashing and finding unique vectors before adding items to global candidate lists and passing data by mutable references across recursive search calls to avoid copies across and within stack frames.</li><li>Passing N as a generic type parameter, which allows 300-dim data to be type-checked as a 300-length f32 array (and not a variable-length vector-type) to improve cache locality and reduce our memory footprint (vectors have an additional level of redirection to data on the heap).</li><li>We also suspect that inner operations (e.g. dot products) are getting vectorized by the Rust compiler but we didn&#39;t check.</li></ul><h2 id="more-real-world-considerations">More Real World Considerations</h2><p>There are several considerations this example skips over that are critical in productionizing vector search:</p><ul><li>Parallelizing when search involves multiple trees. Instead of collecting candidates sequentially, we can parallelize since each tree accesses distinct memory - each tree can run on a separate thread where candidates are continuously sent to the main process via messages down a channel. The threads can be spawned at indexing time itself and warmed with dummy searches (for sections of the tree to live in cache) to reduce overhead on search. Search will no longer scale linearly in the number of trees.</li><li>Large trees may not fit in RAM, needing efficient ways to read from disk - certain subgraphs may need to be on disk and algorithms designed to allow for search while minimizing file I/O. </li><li>Going further, if trees don’t fit on an instance’s disk, we need to distribute sub-trees across instances and have recursive search calls fire some RPC requests if the data isn’t available locally.</li><li>The tree involves many memory redirections (pointer-based trees are not L1 cache friendly). Balanced trees can be well-written with an array but our tree is only close-to-balanced with randomized hyperplanes - can we use a new data structure for the tree?</li><li>Solutions to the above issues should also hold when new data is indexed on-the-fly (potentially requiring re-sharding for large trees). Should trees be re-created if a certain sequence of indexing leads to a highly unbalanced tree?<br/></li></ul><h2 id="conclusion">Conclusion</h2><p>If you got here, congrats! You’ve just seen a simple vector search in ~200 lines of Rust as well as our ramblings on productionizing vector search for planet-scale applications. We hope you enjoyed the read and feel free to access the source code at <a href="https://github.com/fennel-ai/fann?ref=fennel.ai">https://github.com/fennel-ai/fann</a>.<br/></p><h2 id="about-fennel">About Fennel</h2><p>Fennel is a realtime feature engineering platform built in Rust. Check out Fennel <a href="https://docs.fennel.ai/?ref=fennel.ai">technical docs</a> to learn more or play around with it on your laptop by following this <a href="https://docs.fennel.ai/getting-started/quickstart/?ref=fennel.ai">quickstart tutorial</a>.</p>
</div></div>
  </body>
</html>
