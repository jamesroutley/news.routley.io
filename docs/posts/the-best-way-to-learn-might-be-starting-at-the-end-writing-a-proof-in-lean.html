<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/the-best-way-to-learn-might-be-starting-at-the-end/">Original</a>
    <h1>The Best Way to Learn Might Be Starting at the End: Writing a Proof in Lean</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

                <a href="https://interjectedfuture.com/tag/essays/">Essays</a>
            
                <p>AI leveraged learning lets you start with the application at the end. Curiosity guides what you learn, fundamentals backfill when you need them.</p>

            <div>
                <p><a href="https://interjectedfuture.com/author/wil/">
                                <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;d=mm&amp;r=x" alt="Wil Chung"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2025-10-17">17 Oct 2025</time>
                            <span><span>—</span> 16 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2025/10/ChatGPT-Image-Oct-17--2025--10_22_41-PM.jpg 320w,
                    /content/images/size/w600/2025/10/ChatGPT-Image-Oct-17--2025--10_22_41-PM.jpg 600w,
                    /content/images/size/w960/2025/10/ChatGPT-Image-Oct-17--2025--10_22_41-PM.jpg 960w,
                    /content/images/size/w1200/2025/10/ChatGPT-Image-Oct-17--2025--10_22_41-PM.jpg 1200w,
                    /content/images/size/w2000/2025/10/ChatGPT-Image-Oct-17--2025--10_22_41-PM.jpg 2000w" sizes="(max-width: 1200px) 100vw, 1120px" src="https://interjectedfuture.com/content/images/size/w1200/2025/10/ChatGPT-Image-Oct-17--2025--10_22_41-PM.jpg" alt="The Best Way to Learn Might Be Starting at the End: Writing a Proof in Lean"/>
    </figure>

        </header>

        <section>
            <p><em>AI leveraged learning lets you start with the application at the end. Curiosity guides what you learn, fundamentals backfill when you need them.</em></p><p>School teaches us progressively: the current lesson builds upon the previous one. Hence, most peoples&#39; inadvertent take-away is that prerequisites are requirements in learning. But this is just an artifact of constructing a curriculum for teaching tractably at an industrial scale. Prerequisites are often seen as gatekeepers, but it&#39;s better to see them as activation energy. AI collapses that activation barrier by acting as a bridge, making curiosity and critical thinking sufficient to start learning anything you care about.</p><p>I discovered this bridge over that barrier recently when learning Lean, a proof-assistant programming language, to prove a requirement in a system called DBSP<a><sup>[1]</sup></a>, a way to do incremental computation. In order to guarantee DBSP can represent incremental states that can be rolled back, it relies on a foundational assertion that must hold universally: The Z-set and the additive merge together must form an abelian group.</p><p>Surprisingly, many software engineers are allergic to math to the point of not using it as a precision tool in their work. The idea of proving a foundational core in their system is seen as too incomprehensible, too impractical, or too time consuming. But it doesn&#39;t have to be this way.</p><p>This piece demonstrates how I went about learning Lean to prove the assertion above, showing how previously inaccessible topics are now accessible with a bit of agency and critical thinking. The activation energy to learn new topics is now much lower because we can direct AI to collecting, summarizing, and adjusting the material to the learner. This distills learning a new subject to its naked core for the learner: working to deeply understand core concepts and how they connect.</p><h2 id="lowering-the-activation-energy">Lowering the Activation Energy</h2><p>If these words mean nothing to you, here&#39;s a short primer:</p><ul><li><strong>Z-set</strong>: Sets are a bag of unique elements. Z-sets are bags that can contain multiple instances of the same element. Think of it as a map/dictionary with keys as the elements, and integers as values. The integer indicates how many instances of the element exist in the Z-set.</li><li><strong>Additive Merge</strong>: It&#39;s an operation that merges two maps by summing values for shared keys. Non-shared keys are just copied over.</li><li><strong>Abelian Group</strong>: It&#39;s a set with an operation where five rules hold:<ol><li>you can combine any two elements with the binary operation and still get an element from the set (closure)</li><li>there’s an element that leaves the other element unchanged when using the binary operation (identity)</li><li>every element has an inverse that cancels it out into the identity (inverse)</li><li>the grouping of operations doesn&#39;t change the result (associativity)</li><li>the order of combining doesn&#39;t matter (commutativity)</li></ol></li></ul><p>In short, we&#39;re trying to prove that when we have an operation on this set of elements, these five properties always hold.</p><p>Basic definitions are a good starting point to ask AI for help. If these explanations are still opaque, it&#39;s a perfect chance to ask AI to adjust the explanation in understandable terms. Give it your background and domain of expertise, and it&#39;ll find ways to bridge these concepts back to concepts you already understand.</p><p>But the point of this article is to skip this step and go straight into the proof! Due to the constraints of the medium of the written word, it&#39;s impossible to write an article that reads comprehensibly without the right prerequisites in place.</p><p>When using AI to learn, this constraint doesn&#39;t exist. Instead of grinding through the foundations and prerequisites before finally getting to the proof, I did the following:</p><ol><li>I scoped the problem to &#34;prove Z-sets over additive merge form an abelian group&#34;</li><li>Then I asked AI: &#34;Generate a Lean tutorial for <strong>this</strong> exact problem&#34;</li><li>Following the tutorial that guides me towards a working proof, I ask it for explanations of concepts and jargon as I encounter them.</li><li>I can ask as many questions as I want for anything that doesn&#39;t make sense.</li><li>I get a working proof in a couple hours, and a sufficient understanding to extend it.</li></ol><p>This wasn&#39;t possible before, because there was no scalable way to produce bespoke education material for every possible topic a learner might be interested in. The options were to find a tutorial close to the application of interest or map the lessons for an unrelated tutorial into the application of interest.</p><p>Using almost any Wikipedia article about a technical topic to learn is useless, because it&#39;s written to be accurate, not for pedagogy. The experience is completely different with AI.</p><ul><li>If different level of explanation is required for comprehension, we can ask the AI to ELI5 (explain like I&#39;m five) for a bit to get the basics straight before asking it to raise the level of explanation again.</li><li>We can ask it to explain things in terms of already understood concepts. As we gain understanding, it can adjust to our current level of comprehension by refining and expanding its explanation.</li><li>Finally, the tone and style of teaching is adjustable. The AI can play the straight shooter with no fluff, so we&#39;re not distracted. Or it can help boost our confidence along with verbal encouragement.</li></ul><p>These are all the different ways we can leverage AI to lower the activation energy to learning a new domain. All we have to do is ask.</p><h2 id="prerequisites-for-skipping-prerequisites">Prerequisites for skipping prerequisites</h2><p>Though this piece is about skipping prerequisites for learning, this isn&#39;t for everyone and the method has prerequisites. It only works with basic knowledge in an adjacent field, vigilant critical thinking, a genuine curiosity about the specific problem, and a domain with relatively easy-to-verify answers.</p><p>It&#39;s well known that LLMs hallucinate facts and sound confident about it. Nowadays, this is tempered by grounding their context in source material. But that doesn&#39;t mean they can&#39;t sometime reach the wrong conclusion in their answers. I&#39;ve caught them a few times on saying things that were slightly wrong, or ill-informed.</p><p>First, it&#39;s an advantage to have expertise or training in an adjacent field. It&#39;s much easier to spot erroneous answers from the AI. If not caught, these errors can accumulate in our mental model of the world. Despite the effort to learn, we can actively make ourselves stupider.</p><p>Second, it has to be a habit of mind to ask questions about their answers, even as beginners in an unfamiliar domain. If something doesn&#39;t make sense, ask questions to clarify. Doubt the sycophantic agreement every step of the way. Double check their assertions by clicking on their quoted sources and doing independent searches. If anything is incongruent, confusing, or missing, ask questions about why.</p><p>Third, a genuine curiosity about the problem goes a long way. It&#39;s an infinite source of good questions to fuel critical thinking. Genuine curiosity will unearth all the hidden corners and edges of our current understanding, which makes for good questions to challenge the AI and sharpen our understanding. In addition, it&#39;s motivation to keep going when hitting a wall. The drive compels us to ask the AI to approach a new concept from different angles when one approach doesn&#39;t work. Sometimes, the breakthrough is a shift in perspective, and the trick is to persevere long enough to find it.</p><p>Lastly, it must be a domain with relatively easy-to-verify answers. The nice thing about mathematical proofs as a domain is that AI-generated answers are verifiable by the proof assistant. In other domains without such clear-cut verifiable truth <a><sup>[2]</sup></a>, we rely on consistency. The answers must be consistent within the conversation, consistent with what we know, and consistent with external independent sources.</p><p>Now, let&#39;s see how this worked in practice, for this example in Lean.</p><h2 id="example-defining-z-set-and-additive-merge">Example: Defining Z-set and additive merge</h2><p>The AI-generated tutorial started with the definition of Z-sets and the additive merge in Lean.</p><pre><code>-- ZSet is a function from elements to integers (coefficients)
def ZSet (α : Type) : Type :=
  α → Int

-- Additive merge: add coefficients pointwise
def ZSet.add {α : Type} (zs1 zs2 : ZSet α) : ZSet α := 
  fun x =&gt; zs1 x + zs2 x
</code></pre><p>Code from the ML-family of programming languages (Haskell, OCaml, Elm) can be unfamiliar and confusing. Beyond definitions, syntax is another area AI can easily help learners get up to speed. Again, due to the constraints of this medium, I&#39;ll give a little primer for what the AI would have replied to questions about syntax.</p><p>The first definition just says that Z-set is a type that maps <em>something of any type</em> (<code>α</code>) to an integer. It is denoted as <code>α → Int</code></p><p>The second definition just says, in order to additively merge two Z-sets, take the matching keys of each Z-set, and add them up.</p><p>Another way to understand is to leverage what we already know. Given more familiarity with Typescript than Haskell, we can ask the AI to rewrite the Lean code in Typescript. The Typescript code can now be used as a Rosetta Stone to read and interpret the Lean code.</p><pre><code>// ZSet&lt;A&gt; is a total function A -&gt; number (ℤ). Return 0 for “not present”.
export type ZSet&lt;A&gt; = (x: A) =&gt; number;

function add&lt;A&gt;(zs1: ZSet&lt;A&gt;, zs2: ZSet&lt;A&gt;, x: A): ZSet&lt;A&gt; {
  return (x: A) =&gt; zs1(x) + zs2(x);
}
</code></pre><p>As we read this code, we might notice an apparent incongruence. Earlier, in the explanation of a Z-set described it as a map. Here, the Typescript translation defines it as a function. Why is that?</p><p>This is where genuine curiosity kicks in and we can ask the AI to explain by asking, &#34;What&#39;s the equivalent of a map or dictionary in Lean?&#34; or &#34;Why is Z-set represented as a function of type <code>α → Int</code> instead of a Map?&#34; The AI might quip: &#34;In type theory, functions ARE maps.&#34;</p><p>If this is a new concept, it can be a bit of a perspective shift. Any pure function can be represented completely by a key-value store with infinite memory. In this view, functions are just simply key-value stores one can write down without needing an infinite sheet of paper (or memory) to write down the value of every key.</p><p>We didn&#39;t need to read introductions to type theory to happen upon this insight. We used questions that naturally arose from curiosity and practicality to learn concepts and conventions in Lean as well as a perspective shift on the equivalence of functions and maps.</p><h2 id="example-stating-the-abelian-group">Example: Stating the Abelian Group</h2><p>Next, the AI-generated tutorial has us define what an abelian group is in Lean.<a><sup>[3]</sup></a></p><pre><code>-- Define our own minimal abelian group structure as a typeclass
structure AbelianGroup (G : Type) where
  add : G → G → G
  zero : G
  neg : G → G

  add_zero : ∀ a : G, add a zero = a
  zero_add : ∀ a : G, add zero a = a
  add_inv : ∀ a : G, add a (neg a) = zero
  add_assoc : ∀ a b c : G, add (add a b) c = add a (add b c)
  add_comm : ∀ a b : G, add a b = add b a
</code></pre><p>Here, notice the two kinds of definition. The first group are function signatures for which we need to provide a definition. The second group are properties that must be proven. If we provide proofs for the properties, then for any example of <code>G</code> and <code>add</code>, we can use the proofs to check if they indeed form an abelian group.</p><p>While writing this post, I realized I had a gap in my knowledge I wasn&#39;t aware of before. In definition of an abelian group above, we require three functions to be implemented (<code>add</code>, <code>zero</code>, and <code>neg</code>). Yet, abelian groups are uniquely defined with just the carrier set <code>G</code> and an <code>add</code> method. Why do we need to implement <code>zero</code> and <code>neg</code>?</p><p>So I started asking those kinds of questions to the AI. It argued that while mathematicians set out to prove theorems with the smallest number of axioms, our goal is to build a program that&#39;s correct by construction. Hence, we don&#39;t need to derive everything axiomatically. If we can write down a definition from previously proven statements, then it&#39;s a functionally equivalent to deriving it axiomatically.</p><p>Is this true? This characterization of what mathematicians and engineers care about does align with my own experiences. And considering the nature of their jobs, the perspective seems goal aligned as well. Hence, it&#39;s likely that this is a sufficient answer.</p><p>How would we axiomatically get the inverse? We can start with <code>a + 0 = a</code> and <code>0 + a = a</code> to see if there&#39;s anything we can add to <code>a</code> that gives us <code>a</code> back again. If both are true, then an identity (<code>0</code>) exists. Then we can use <code>a + (-a) = 0</code> to see if there&#39;s anything we can add to <code>a</code> that gives us the identity. If so, the inverse (<code>-a</code>) exists.</p><p>But for us programmers, we just need a definition. How can we define the additive merge from what has already been proven? We can leverage the fact that integers are an abelian group, and define the negation of a Z-set as negating the integer value of every key.</p><pre><code>def ZSet.neg {α : Type} (zs : ZSet α) : ZSet α :=
  fun x =&gt; -(zs x)
</code></pre><p>While we&#39;re not sure if this will work in the proof yet, we don&#39;t need to start from just the identity and the additive merge to define the inverse/negation.</p><p>This kind of struggle is what forced a deeper understanding, and is the type of clarifying learning with an AI. Tutorials and youtube videos won&#39;t know what you don&#39;t know, so they can&#39;t fill in the gaps. Human teachers can, but they&#39;re far more expensive, and it might not be practical to get one for the domain.</p><p>As an exercise for the reader, here are other questions to ask the AI, if curiosity grabbed your attention:</p><ul><li>Are there set and operation pairs that don&#39;t form an abelian group? What are some examples?</li><li>An abelian group has five properties. Why are there two properties for the proof of identity, <code>add_zero</code> and <code>zero_add</code>? And why do we not prove the closure property?</li><li>Why these five properties? Why is it that these five properties together are significant enough to be given a name?</li><li>How come the identity function is named <code>zero</code>? Wouldn&#39;t it be a misnomer if our binary operation was integer multiplication?</li></ul><h2 id="example-proving-associativity">Example: Proving Associativity</h2><p>We&#39;re not going to prove every property in the abelian group for a Z-set. Doing one is good enough to demonstrate the learning process with AI. However, I&#39;ll attach the complete proof at the end. In the AI-generated tutorial, the proof of associativity is:</p><pre><code>instance : AbelianGroup (ZSet α)
where
  -- ... other definitions
  
  -- (a + b) + c = a + (b + c)
  add_assoc := by
    intro a b c
    ext x
    simp [ZSet.add, Int.add_assoc]
</code></pre><p>Here, there were a couple keywords I didn&#39;t understand, so again, here&#39;s a primer that AI would have said:</p><ul><li><code>by</code> enters into tactic mode, where I&#39;m telling Lean: &#34;I’ll construct this proof interactively, step by step.&#34;</li><li><code>intro</code> puts quantifiable variables into the local context where the goal is to prove <code>f(a, b, c)</code> for arbitrary <code>a</code>, <code>b</code>, and <code>c</code></li><li><code>ext</code> is the application of the <em>extensionality lemma</em>, which says &#34;Two functions are equal if they are equal at every argument.&#34;</li><li><code>simp</code> is for <em>simplification</em>, which just rewriting and substitution of <code>ZSet.add</code> and <code>Int.add_assoc</code> with their expanded definitions.</li></ul><p>When doing proofs on paper, the intermediate expressions are written down and the transformation is implied. When doing proofs in Lean, the method transformations are written down and the intermediate expressions are implied.</p><p>One can&#39;t just blindly apply proof tactics. For a proof this simple, the AI isn&#39;t going to get it wrong. Even if the AI writes a verifiable incorrect proof, the beauty of AI + proof assistants is that the AI can use the proof assistant to self-correct until it gets the proof right.</p><p>But that doesn&#39;t mean the proof should be accepted blindly, no more than professional developers should accept vibe coded programs blindly. To stand behind the results, understanding a correct proof teaches what to ask when the proof is wrong. Just as in code, while the results are technically correct, we might want it a different way for other reasons.</p><p>Initially, the AI proof used <code>ring</code> as a proof tactic. While correct, I wanted to understand why and what the alternative were. That&#39;s when I learned about <code>simp</code> along with its pros and cons. In the end, I chose <code>simp</code> for this article because it&#39;s more transparent and shows what&#39;s going on with less magic.</p><p>This is much harder than following a tutorial lockstep. This is why so many <a href="https://blog.boot.dev/education/vibe-coding-hell/?ref=interjectedfuture.com">young programmers can watch all do all the tutorials and watch all the Youtuber videos they want, and still not achieve proficiency</a>. The struggle of thinking about why something doesn&#39;t work and why needs to be experienced, in order for learning to actually take place.</p><p>However, the struggle is with the core concept, not just with trivia, like looking up what different keywords mean. We&#39;re doing real formal verification about a data structure from a real system, like DBSP. The activation energy collapsed from &#34;I&#39;ll never understand proof assistants&#34; to &#34;I have a working proof&#34; in one afternoon.</p><h2 id="a-phd-is-for-thinking-previously-unthinkable-thoughts">A PhD is for thinking previously unthinkable thoughts</h2><p>To be clear, I&#39;m not saying AI-based learning replaces a PhD when it comes to learning Lean-based math proofs. When people say &#34;you need a PhD to do X&#34;, people often mean it in two different, but conflated meanings:</p><ol><li><strong>Background collation:</strong> Months of reading papers, learning the jargon, and hunting down the prerequisites.</li><li><strong>Novel Research:</strong> Asking questions never asked, proving theorems never proven, and thinking previously unthinkable thoughts.</li></ol><p>Most of the time people say that phrase, they mean it in the first sense, to express the high activation energy required to get started on breaking into learning anything outside of their familiar domains. AI eliminates the barrier in the second sense, but not the first. You can&#39;t ask an AI to &#34;solve my novel research problem&#34;, but you can ask it to &#34;teach me formal verification for my specific problem.&#34;</p><p>What if you are doing novel research? That&#39;s where I make no claims of efficacy using AI to learn, except to warn that it&#39;s easy to fall into AI-induced psychosis. No matter how smart or careful you are, the easiest person to fool is yourself.</p><p>Here&#39;s an excerpt of a passage from a smart and accomplished founder:</p><blockquote>At the heart of physics is the idea of a frame of reference. A frame is a boundary, something that separates this from that. A frame of reference is a boundary which contains a decoder and codebook that are used to interpret the boundary’s flux as a description of the world.</blockquote><p>It goes on for a while in the same manner. A charitable interpretation is they&#39;re trying to express something we don&#39;t yet have words for. But this reads like someone who took shallow definitions from physics to construct a pet theory without precise definition and internal consistency.</p><p>This is why answer verifiability matters. In Lean, wrong proofs don&#39;t compile. In novel physics theorizing, AI will happily construct elaborate castles in the air with you. It&#39;s not yet clear how to best leverage AI for the second meaning of &#34;requiring a PhD&#34;. That&#39;s why one of the prerequisites for this method is to pick a domain where the answers are relatively easily verifiable. So for now, I&#39;d stick with the first when using AI to learn.</p><h2 id="trying-it-yourself">Trying it yourself</h2><p>You can use the following prompt to generate yourself a tutorial for the proof. Adjust according to your tastes.</p><div><p>Generate a Lean 4 tutorial for proving that Z-sets over additive merge form an abelian group. I&#39;m a programmer familiar with functional programming, but never used proof assistants. If you&#39;re using mathematical terms, explain them in terms a developer would understand. Explain any jargon and concepts in detail.</p></div><p>Then <a href="https://lean-lang.org/install/?ref=interjectedfuture.com">install Lean 4 and VSCode</a> or use the <a href="https://live.lean-lang.org/?ref=interjectedfuture.com">browser version</a> to work through the AI-generated tutorial.</p><p>Ask as many questions you can think of to clarify your understanding. When stuck, ask: &#34;Why did [X tactic] fail?&#34; or &#34;Explain [term] in context of this proof.&#34; Try different angles to understand the concepts, from generating code in a familiar language to explaining the concepts in a domain you already understand.</p><p>Here is my <a href="https://gist.github.com/iamwilhelm/532dec95c387751a6f5790454dacab37?ref=interjectedfuture.com">full proof that Z-sets over an additive merge is an abelian group</a>. It demonstrates all five properties of an abelian group: closure (by definition), the existence of identity and the inverse, associativity, and commutativity.</p><pre><code>variable {α : Type} [DecidableEq α]

-- Define our own minimal abelian group structure (no mathlib)
structure AbelianGroup (G : Type) where
  add : G → G → G
  zero : G
  neg : G → G
  add_assoc : ∀ a b c : G, add (add a b) c = add a (add b c)
  add_zero : ∀ a : G, add a zero = a
  zero_add : ∀ a : G, add zero a = a
  add_inv : ∀ a : G, add a (neg a) = zero
  add_comm : ∀ a b : G, add a b = add b a

-- Example that integers form our minimal abelian group:
example : AbelianGroup Int := {
  add := fun a b =&gt; a + b,
  zero := 0,
  neg := fun a =&gt; -a,
  add_assoc := Int.add_assoc,
  add_comm := Int.add_comm,
  add_zero := Int.add_zero,
  zero_add := Int.zero_add,
  add_inv := Int.add_right_neg,
}

-- ZSet is a function from elements to integers (coefficients)
def ZSet (α : Type) : Type :=
  α → Int

-- Register extensionality theorem for ZSet
-- This tells Lean: &#34;To prove two ZSets are equal, show they&#39;re equal pointwise&#34;
@[ext]
theorem ZSet.ext {α : Type} (f g : ZSet α) : (∀ x, f x  = g x) -&gt; f = g :=
  funext

-- empty ZSet (all coefs are 0)
def ZSet.empty {α : Type} : ZSet α :=
  fun _ =&gt; 0

-- Add an element with coefficient
def ZSet.single (a : α) (n : Int) : ZSet α :=
  fun x =&gt; if x = a then n else 0

-- Additive merge: add coefficients pointwise
def ZSet.add {α : Type} (zs1 zs2 : ZSet α) : ZSet α :=
  fun x =&gt; zs1 x + zs2 x
-- Enable `+` notation for ZSets
instance {α : Type} : Add (ZSet α) where
  add := ZSet.add

-- Additive inverse: negate all coefficients
def ZSet.neg {α : Type} (zs : ZSet α) : ZSet α :=
  fun x =&gt; -(zs x)
-- Enable `-` unary operator for ZSets
instance {α : Type} : Neg (ZSet α) where
  neg := ZSet.neg

-- Proof that ZSet under additive merge form an abelian group
instance : AbelianGroup (ZSet α)
where
  add := ZSet.add
  zero := ZSet.empty
  neg := ZSet.neg

  -- (a + b) + c = a + (b + c)
  add_assoc := by
    intro a b c
    ext x
    simp [ZSet.add, Int.add_assoc]

  -- a + b = b + a
  add_comm := by
    intro a b
    ext x
    simp [ZSet.add, Int.add_comm]

  -- a + 0 = a
  add_zero := by
    intro a
    ext x
    simp [ZSet.add, ZSet.empty]

  -- 0 + a = a
  zero_add := by
    intro a
    ext x
    simp [ZSet.add, ZSet.empty]

  -- a + (-a) = 0
  add_inv := by
    intro a
    ext x
    simp [ZSet.add, ZSet.neg, ZSet.empty]
    rw [Int.add_right_neg]

example : (ZSet.single &#34;a&#34; 3 + ZSet.single &#34;b&#34; 2) &#34;a&#34; = 3 := by rfl

example : (ZSet.single &#34;a&#34; 3 + ZSet.single &#34;a&#34; 2) &#34;a&#34; = 5 := by rfl

example : (ZSet.single &#34;a&#34; (-3) + ZSet.single &#34;a&#34; 2) &#34;a&#34; = -1 := by rfl

example : ZSet.neg (ZSet.single &#34;a&#34; 3) &#34;a&#34; = (-3) := by rfl
</code></pre><p>Compare it to yours. What are the differences? Why do it one way versus the other? Try and see if other sets and binary operations are abelian groups.</p><h2 id="what-this-enables">What this enables</h2><p>AI has already made a seismic shift in the way programmers work through vibe coding. It&#39;s increased the velocity of feature output and bug fixing by programmers that have figured out how to leverage it. But I hope that it also creates a different kind of shift; one where programmers aren&#39;t afraid to branch out to the edges of what academia has discovered to bring it into the realm of real-world applications.</p><p>Distributed systems PRs could include Lean proofs of safety properties. CRDT libraries could ship with formal verification of merge semantics, and not just unit tests. &#34;Formally verified&#34; no longer is something out of reach for the average backend engineer, and instead is a practical tool in their toolbox.</p><p>And I think this pattern generalizes across domains beyond formal verification. There are lots of specialized domains in programming, from GPU programming to embedded programming. The cross-pollination of programmers that can straddle between ecosystems also means that ideas in one domain can be tried in another, making good ideas spread faster. And if anything a wider breadth of experience will give more perspective, which usually give nuance and color when making decisions.</p><p>The bridge exists now where there was none before. We can cross it into adjacent domains to learn if we have the critical thinking, curiosity, and agency to try.</p><hr/><ol><li>DataBase Stream Processing, but also a pun on Digital Signal Processing <a>↩︎</a></li><li>Please don&#39;t write in about Godel&#39;s Incompleteness theorem. It doesn&#39;t apply here, because we&#39;re not reasoning about anything that references itself. <a>↩︎</a></li><li>An abelian group is already defined in Lean&#39;s standard library (mathlib), but for the point of exercise, we define it. But also, Lean 4 currently doesn&#39;t have tree shaking, so including the pre-written definition balloons the C executable by about 150+MBs <a>↩︎</a></li></ol>
        </section>

    </article>


</div></div>
  </body>
</html>
