<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2025-11-28-tale-of-four-fuzzers/">Original</a>
    <h1>A Tale of Four Fuzzers</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote>
<p>Charles Darnay observed that the gate was held by a mixed guard of
soldiers and patriots, the latter far outnumbering the former; and that
while ingress into the city for peasants’ carts bringing in supplies,
and for similar traffic and traffickers, was easy enough, egress, even
for the homeliest people, was very difficult.</p>
</blockquote>
<p>Some time ago we <a href="https://github.com/tigerbeetle/tigerbeetle/pull/2880">overhauled
TigerBeetle’s routing algorithm</a> to better handle varying network
topologies in a cluster. That turned out to be an interesting case study
of practical generative testing (or fuzzing) for non-trivial, real-world
code. We ended up adding not one, not even two, but four very different
new fuzzers to the system! Let’s talk about why just one fuzzer is not
enough.</p>
<p>This is a good moment to brew some tea, the journey will take us
awhile!</p>
<h2 id="replication"><a href="#replication" aria-hidden="true">Replication</a></h2>
<p>Although this post isn’t primarily about the new algorithm itself,
we’ll start by covering the basics of replication. TigerBeetle provides
transaction Atomicity, Consistency, Isolation and Durability (ACID). Out
of the four letters, the D, Durability, is the most consequential. For,
without Durability, there wouldn’t be any data at all to provide
guarantees for!</p>
<p>You can get a decent chunk of durability by writing the data to a
(single) hard drive. This works for many non-critical applications, but
might still fail if you repeat the procedure often enough. Disks are
faulty with non-zero probability, and it is fairly common to lose an
entire machine (floods, fires and tripping over the power supply
happen). If you <em>really</em> want your data to be durable, better to
store several copies of it on different machines, to replicate.</p>
<p>All data in TigerBeetle is ultimately derived from an append-only
hash-chained log of prepare messages, so the task of replication reduces
to distributing the prepares (a MiB each) across the six replicas of the
cluster.</p>
<p>The primary sends <code>.prepare</code> messages down to the backups;
they reply <code>.prepare_ok</code> back up once the prepare is locally
durable. When the primary receives a quorum of
<code>.prepare_ok</code>s, it knows that the message is globally
durable.</p>
<p>The most straightforward way to implement that is for the primary to
broadcast the prepare:</p>
<figure>
    
    <figcaption>Star Topology</figcaption>
</figure>

<p>The problem with this approach is that the primary uses 5x the
bandwidth of the backup. In other words, we are going only at 1/5th of
the optimal performance. For this reason, our V1 routing used a simple
ring topology, where most replicas need to send and receive one
message:</p>
<figure>
    
    <figcaption>Ring Topology</figcaption>
</figure>

<h2 id="adaptive-replication-routing"><a href="#adaptive-replication-routing" aria-hidden="true">Adaptive Replication Routing</a></h2>
<p>The ring replication is simple and balances the bandwidth nicely. It
served well for the first year of production use, despite some critical
issues!</p>
<p><em>First</em>, the fixed ring topology falls prey to one of the <a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">eight
fallacies of distributed computing</a>. The ring is fully static, and
assumes that network topology doesn’t change. But this is not true. For
example, if one replica crashes or becomes partitioned, it is a good
idea to proactively route around it, rather than rely on retries to
randomly pick a different replica.</p>
<p><em>Second</em>, the ring doesn’t have what I like to call “there’s
no (re)try” property. Most messages exchanged in the process of ring
replication are <em>critical</em>: if a single message is lost, then the
whole chain of replication unravels until the retry timeout kicks in.
This means that network errors are visible as elevated P100 latencies
(bad), and, when they happen, we have to run rarely-executed retry code
(worse!). Such “cold code” is the preferred habitat for bugs! Ideally, a
system should have built-in redundancy such that any operation completes
without tripping timeouts even in the presence of errors.</p>
<p>Thus, Adaptive Replication Routing (or, how we affectionately call
it, ARR) was born. It combines two ideas. <em>First</em>, while we keep
the ring as our replication topology, we place the primary into the
middle:</p>
<figure>
    
    <figcaption>ARR Topology</figcaption>
</figure>

<p>The small downside is slightly uneven network load, as the primary
sends two messages. The big upside is that none of the messages are
critical. If any single message is dropped, the prepare is still going
to be replicated to at least half of the cluster, allowing the primary
to commit without tripping timeouts (recall that TigerBeetle is using <a href="https://arxiv.org/pdf/1608.06696v1.pdf">Heidi Howard’s Flexible
Quorums</a>, so 3 of 6 as replication quorum is enough for safety
because the view change quorum, is 4 of 6, preserving the intersection
property).</p>
<p><em>The second trick</em> is that the ring itself is dynamic. At
runtime, the cluster picks the order of replicas that minimizes the
latency overall. If one replica becomes unreachable, the replicas are
reshuffled along the ring to move the missing one to the very end.</p>
<h2 id="picking-the-route"><a href="#picking-the-route" aria-hidden="true">Picking the Route</a></h2>
<p>How do you find the best route? One approach is to build a model of
the system. For example, replicas can exchange heartbeat messages, note
pairwise latencies, and then solve traveling salesman problem in the
resulting small six-node graph to find the most perfect route.</p>
<p>This works algorithmically, but relies on a pretty big assumption —
that our model of the world is faithful. But imagine, for example, a
network with a link with very low latency, but also very low throughput.
Using (small) heartbeat messages to measure the link quality would give
us a misleading model that breaks down for (much larger) prepares.</p>
<p>The problem here isn’t this particular case, but the entire class of
“out of the distribution” errors which make any <em>indirect</em>
measurement suspect (c.f. <a href="https://en.wikipedia.org/wiki/Goodhart%27s_law">Goodhart’s
Law</a>). As another example, consider a replica with a very slow disk.
Although the <code>ping</code> time for it is very fast, the replication
is going to be slow, as <code>.prepare_ok</code> is only sent once the
<code>.prepare</code> is durably persistent. Pings only measure network
latency, but we also care about storage latency (and throughput).</p>
<p>A different approach, inspired laterally by the <a href="https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-dong.pdf">PCC</a>
paper, is to avoid modeling altogether, and instead to just go and
<em>do</em> something, and then measure the relevant result directly,
Grace Hopper style. This is how ARR works: for every
<code>.prepare</code>, the primary tracks how long did it take to
replicate (via tracking <code>.prepare_ok</code> messages). Every once
in a while, it runs an experiment, where a prepare follows a different,
experimental route. If that experimental route is <em>measured</em> to
be better than the route we are currently using, the topology is
switched. Over time, the cluster converges to the optimal route.</p>
<p>That’s ARR in a nutshell: replication topology is a ring with the
primary in the middle, where the order of replicas in the ring is
adjusted dynamically based on how well each specific permutation
performs end-to-end.</p>
<h2 id="its-all-about-interfaces"><a href="#its-all-about-interfaces" aria-hidden="true">It’s All About Interfaces</a></h2>
<p>As promised, this post is <em>not</em> about ARR, so assume that
you’ve already implemented ARR for TigerBeetle. How would you apply
Deterministic Simulation Testing principles to it?</p>
<p>One approach is to leverage our existing <del><a href="https://sim.tigerbeetle.com">game</a></del> whole-system
simulation, VOPR. This actually gets you quite far, but it is always
possible to do better.</p>
<p><em>First</em>, whole system simulation might not be as efficient at
exercising deeper layers of the system. For every permutation of events
affecting the target layer, the simulator also needs to handle all other
events above and below. Furthermore, the permutations you get might be
restricted by the way the subsystem is used by the larger system. In
other words, the routing component might be working correctly if used in
the exact same way as in the real database, but it might still have bugs
under certain interactions of its public APIs.</p>
<p><em>Second</em>, while checking “it doesn’t crash” is easy enough
through the VOPR, asserting that the route is <em>good</em> is much
harder. Again, there’s just too much <em>other</em> stuff happening to
focus just on the contribution of routing.</p>
<p>That’s why the general principle in TigerBeetle is that, in addition
to the main whole-system fuzzer, each subsystem should also have a
targeted fuzzer, and ARR is no exception.</p>
<p>There’s a fairly general recipe for how to fuzz a subsystem in
isolation:</p>
<ul>
<li>Identify all the connections between the target and the rest of the
system,</li>
<li>abstract the connections behind an interface,</li>
<li>supply a stub implementation for fuzzing.</li>
</ul>
<p>With some ingenuity, you can even avoid modifying your source code at
all, instead leveraging runtime support to materialize interfaces out of
thin air. For example, you can use <code>LD_PRELOAD</code> tricks to
intercept all libc-mediated syscalls.</p>
<p>But there’s a catch! With a large and intricate interface, it might
be challenging to thoroughly explore the state space, especially as the
interface itself changes over time (and large and intricate things also
mysteriously <em>love</em> to be high-churn as well). For the long term,
it pays to start with the minimal possible interface.</p>
<p>Did you notice that I tricked you in the first paragraph in this
section? You don’t first build a system, and then add a fuzzer. The
process is almost the reverse — the starting point is sketching minimal
interfaces that yield themselves to efficient fuzzing. This is a bit
like Test Driven Design, though, not exactly. There’s relatively little
incrementality and iteration. Instead, fuzzer’s input on architecture is
felt at the very beginning, during “sketching on the mental napkin”
phase.</p>
<h2 id="arr-interface"><a href="#arr-interface" aria-hidden="true">ARR Interface</a></h2>
<p>Let’s do this for ARR. Again, the idea is that we observe timing
information during replication (the delay between sending
<code>.prepare</code> and receiving a set of <code>.prepare_ok</code>s)
and use that to gradually discover the best possible route, where the
route is a permutation of replicas with the current primary in the
middle.</p>
<p>Note how <em>little</em> in the above description is related to
TigerBeetle! This is a hint that the routing component <em>can</em> be
fully independent! This is the core interface of <code>Routing</code>
(simplified for the blog, but just a touch):</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> init(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    options<span>:</span> <span>struct</span> { replica<span>:</span> <span>u8</span><span>,</span> replica_count<span>:</span> <span>u8</span> }<span>,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>) Routing;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> op_prepare(</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    routing<span>:</span> <span>*</span>Routing<span>,</span> op<span>:</span> <span>u64</span><span>,</span> now<span>:</span> Instant) <span>void</span>;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> op_prepare_ok(</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    routing<span>:</span> <span>*</span>Routing<span>,</span> op<span>:</span> <span>u64</span><span>,</span> now<span>:</span> Instant<span>,</span> replica<span>:</span> <span>u8</span>) <span>void</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> op_next_hop(routing<span>:</span> <span>*</span>Routing<span>,</span> op<span>:</span> <span>u64</span>) []<span>const</span> <span>u8</span>;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> view_change(routing<span>:</span> <span>*</span>Routing<span>,</span> view<span>:</span> <span>u32</span>) <span>void</span>;</span></code></pre></div>
<p>To start routing, you need to know how many replicas are there, and
which one is you. <code>op_prepare</code> and <code>op_prepare_ok</code>
are for tracking timing. The contract is simple: <code>op_prepare</code>
is called once a <code>.prepare</code> is ready to be replicated, and
<code>op_prepare_ok</code> is called for every received
<code>.prepare_ok</code> response. That is, the happy path is six calls
to <code>op_prepare_ok</code> for every call to
<code>op_prepare</code>.</p>
<p>The <code>op_next_hop</code> is the actual routing — it tells which
replicas a freshly received prepare needs to be forwarded to. It might
return zero, one or two replicas.</p>
<p>Finally, routing needs to know which replica is the primary. When the
primary changes, so do the routes! The primary is uniquely defined by
the view, which can be changed via the <code>view_change</code>
method.</p>
<p>Note how minimal this interface is! We are just passing integers
around (<code>Instant</code> is a newtyped <code>u64</code>. It’s a
topic for a separate blog post why we newtype <code>Instant</code> but
not <code>view</code>…). But this is not natural, it’s a result of
deliberate design process!</p>
<p>For example, <code>Routing</code> routes <code>Prepare</code>s, so it
would be natural to pass in the whole <code>Prepare</code> structure
with all dependencies on the rest of the VSR framework. It takes <a href="https://www.computer.org/csdl/magazine/so/2019/01/08611447/17D45WaTkcK">intellectual
control</a> to know that <code>Routing</code> only cares about
<code>Prepare</code>’s identity, and that op number is a concise
representation of that identity.</p>
<p>Handling of time deserves an entire separate article (good thing that
we <em>did</em> <a href="https://tigerbeetle.com/blog/2025-10-21-clockless-time/">write
that up</a>). The source of time is ultimately a <code>Clock</code>
instance, so the most natural thing to do would be to inject
<code>Clock</code> dependency in the constructor. But a moment’s
thinking makes you realize that a fully general clock is unnecessary. We
only care about the time difference between a <code>.prepare</code> and
the corresponding <code>.prepare_ok</code>s, which you can get, simply,
by accepting an <code>Instant</code> — a <code>u64</code> number of
nanoseconds since an unspecified start of the epoch. This is a
<em>major</em> simplification for fuzzing, as time is notoriously tricky
to model, and here we get it essentially for free.</p>
<p>Finally, in order to downsize the interface, <code>view_change</code>
violates one of the best best practices. It adds the second source of
truth for the view number! The authority about the current view is the
<code>Replica</code> struct (<a href="https://github.com/tigerbeetle/tigerbeetle/blob/0.16.66/src/vsr/replica.zig#L387">this
lovely 12k sloc file</a>) with a <code>view: u32</code> field.</p>
<p><code>Routing</code> needs to be aware of the view, and the most
straightforward way to do that is to inject the entire
<code>Replica</code> in <code>init</code>, using banana-gorilla-jungle
pattern of Joe Armstrong. The textbook fix would be to abstract “thing
with a <code>get_view</code> method” behind an interface and inject
<em>that</em>. But that indirection makes the code more verbose and
harder to reason about. It also is not enough: not only
<code>Routing</code> needs to know the current view, it must actively
react to changes in the view! This can be fixed via Observer pattern,
but Observer is notorious for destroying readability of control flow and
bring a host of problems of its own, including complicated lifetime
management, non-deterministic order of execution and potential for
feedback loops.</p>
<p>It indeed is <em>much</em> simpler to just let <code>Routing</code>
have its own private copy of <code>view: u32</code>. And the risk of
views desynchronizing is easy to mitigate. We already have
<code>invariants</code> method on the <code>Replica</code> which is
called frequently to catch various violations, and it can check view
consistency as well:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> invariants(<span>self</span><span>:</span> <span>*</span><span>const</span> Replica) <span>void</span> {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>// ...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    assert(<span>self</span><span>.</span>view <span>==</span> <span>self</span><span>.</span>routing<span>.</span>view);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>You get the idea! The trick to making the code more easily fuzzable
is to minimize the interface. You want to get rid of accidental
dependencies and leave only the essential ones. And to do that, it helps
to apply data-oriented design principles — thinking in terms of input
data, output data, and the fundamental data transformation that the
system implements.</p>
<h2 id="fuzzer-1-exhausting-positive-space"><a href="#fuzzer-1-exhausting-positive-space" aria-hidden="true">Fuzzer #1: Exhausting Positive Space</a></h2>
<p>When the primary decides to switch the route after a successful
experiment, it needs to communicate the new route to the peers. It’s a
serialization/deserialization task. As there are at most six replicas in
the cluster, and a route is a permutation thereof, a route is encoded
compactly as an <code>u64</code>:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> route_encode(routing<span>:</span> <span>*</span><span>const</span> Routing<span>,</span> route<span>:</span> Route) <span>u64</span>;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> route_decode(routing<span>:</span> <span>*</span><span>const</span> Routing<span>,</span> code<span>:</span> <span>u64</span>) <span>?</span>Route;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> route_active(<span>self</span><span>:</span> <span>*</span><span>const</span> Replica) Route;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> route_activate(routing<span>:</span> <span>*</span>Routing<span>,</span> route<span>:</span> Route) <span>void</span>;</span></code></pre></div>
<p>Serialization is a favorite vehicle for explaining property based
testing: checking that serializing data and then deserializing it back
doesn’t lose a bit is an obvious thing to do
(<code>deserialize . serialize == id</code>, if you speak pointfree). So
we can generate a random permutation and assert that it round-trips the
encoding correctly:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_encode {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span>var</span> prng <span>=</span> stdx<span>.</span>PRNG<span>.</span>from_seed(std<span>.</span>testing<span>.</span>random_seed);</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span>const</span> replica_count <span>=</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        prng<span>.</span>range_inclusive(<span>u8</span><span>,</span> <span>1</span><span>,</span> constants<span>.</span>replicas_max);</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span>// Start with a trivial permutation, then shuffle it.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span>var</span> route<span>:</span> Route <span>=</span> <span>.</span>trivial(replica_count);</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    prng<span>.</span>shuffle(<span>u8</span><span>,</span> <span>&amp;</span>route<span>.</span>replicas);</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span>const</span> code <span>=</span> route_encode(route);</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span>const</span> route_decoded <span>=</span> route_decode(code)<span>.?</span>;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    assert(std<span>.</span>meta<span>.</span>eql(route<span>,</span> route_decoded));</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>And here’s <code>shuffle</code> for the reference, nothing fancy:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> shuffle(prng<span>:</span> <span>*</span>PRNG<span>,</span> T<span>:</span> <span>type</span><span>,</span> slice<span>:</span> []T) <span>void</span> {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (slice<span>.</span>len <span>&lt;=</span> <span>1</span>) <span>return</span>;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span>for</span> (<span>0</span><span>.</span><span>.</span>slice<span>.</span>len <span>-</span> <span>1</span>) <span>|</span>i<span>|</span> {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span>const</span> j <span>=</span> prng<span>.</span>range_inclusive(<span>u64</span><span>,</span> i<span>,</span> slice<span>.</span>len <span>-</span> <span>1</span>);</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        std<span>.</span>mem<span>.</span>swap(T<span>,</span> <span>&amp;</span>slice[i]<span>,</span> <span>&amp;</span>slice[j]);</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This already is a decent test, but we can make it even better. There
are at most six replicas in a cluster. That means there are
<code>1! + 2! + ... + 6!</code> routes in <em>total</em> we need to
check. This is a tiny number of routes, computer-wise, and we can easily
check them all in no time!</p>
<p>The only catch is that writing code to generate all permutations
needs somewhat tricky recursion, and then you need to also iterate over
number of replicas… But there’s a secret cheat code here. This is
it:</p>
<blockquote>
<p>If you wrote a function that takes a PRNG and generates a random
object, you <em>already</em> have a function capable of enumerating all
objects.</p>
</blockquote>
<p>Just imagine how the above function executes, from the perspective of
the PRNG. You are constantly being asked to generate random numbers,
which are used to shuffle the initial identity permutation. But what if
you always return zero? Well, the resulting permutation will be in some
sense trivial! And you can get the <em>next</em> permutation if you
change the last zero to be one. And then two. And, if, say, the last
number you are asked to generate needs to lie between zero and two, then
after two you wrap back to zero, but also increment the penultimate
number:</p>
<pre><code>0 0 0 0 0
0 0 0 0 1
0 0 0 0 2
0 0 0 1 0
0 0 0 1 1</code></pre>
<p>If you can generate all sequences of random numbers, you can turn a
function generating a random object into a function enumerating
<em>all</em> objects! And here’s how you can generate all random number
sequences:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>started<span>:</span> <span>bool</span> <span>=</span> <span>false</span><span>,</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>v<span>:</span> [<span>32</span>]<span>struct</span> { value<span>:</span> <span>u32</span><span>,</span> bound<span>:</span> <span>u32</span> } <span>=</span> <span>undefined</span><span>,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>p<span>:</span> <span>usize</span> <span>=</span> <span>0</span><span>,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>p_max<span>:</span> <span>usize</span> <span>=</span> <span>0</span><span>,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>const</span> Gen <span>=</span> <span>@This</span>();</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> done(g<span>:</span> <span>*</span><span>@This</span>()) <span>bool</span> {</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (<span>!</span>g<span>.</span>started) {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        g<span>.</span>started <span>=</span> <span>true</span>;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>false</span>;</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span>var</span> i <span>=</span> g<span>.</span>p_max;</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span>while</span> (i <span>&gt;</span> <span>0</span>) {</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        i <span>-=</span> <span>1</span>;</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span>if</span> (g<span>.</span>v[i]<span>.</span>value <span>&lt;</span> g<span>.</span>v[i]<span>.</span>bound) {</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            g<span>.</span>v[i]<span>.</span>value <span>+=</span> <span>1</span>;</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            g<span>.</span>p_max <span>=</span> i <span>+</span> <span>1</span>;</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>            g<span>.</span>p <span>=</span> <span>0</span>;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span>return</span> <span>false</span>;</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span>;</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span>fn</span> gen(g<span>:</span> <span>*</span>Gen<span>,</span> bound<span>:</span> <span>u32</span>) <span>u32</span> {</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    assert(g<span>.</span>p <span>&lt;</span> g<span>.</span>v<span>.</span>len);</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (g<span>.</span>p <span>==</span> g<span>.</span>p_max) {</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        g<span>.</span>v[g<span>.</span>p] <span>=</span> <span>.</span>{ <span>.</span>value <span>=</span> <span>0</span><span>,</span> <span>.</span>bound <span>=</span> <span>0</span> };</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        g<span>.</span>p_max <span>+=</span> <span>1</span>;</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    g<span>.</span>p <span>+=</span> <span>1</span>;</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    g<span>.</span>v[g<span>.</span>p <span>-</span> <span>1</span>]<span>.</span>bound <span>=</span> bound;</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span>return</span> g<span>.</span>v[g<span>.</span>p <span>-</span> <span>1</span>]<span>.</span>value;</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span>/// Public API, get a &#34;random&#34; number in bounds:</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> int_inclusive(g<span>:</span> <span>*</span>Gen<span>,</span> Int<span>:</span> <span>type</span><span>,</span> bound<span>:</span> Int) Int {</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>@intCast</span>(g<span>.</span>gen(<span>@intCast</span>(bound)));</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Makes no sense? For me too! Every time I look at this code, I need to
solve the puzzle afresh. Luckily, there’s a write up: <a href="https://matklad.github.io/2021/11/07/generate-all-the-things.html"><em>Generate
All The Things</em></a>.</p>
<p>The bottom line is that we can <em>just</em> wrap our existing random
test into a while loop, and magically get an exhaustive test for
<em>all</em> routes:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_encode {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span>var</span> prng<span>:</span> Gen <span>=</span> <span>.</span>{};</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span>while</span> (<span>!</span>prng<span>.</span>done()) {</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span>const</span> replica_count <span>=</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            prng<span>.</span>range_inclusive(<span>u8</span><span>,</span> <span>1</span><span>,</span> constants<span>.</span>replicas_max);</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span>// Start with a trivial permutation, then shuffle it.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span>var</span> route<span>:</span> Route <span>=</span> <span>.</span>trivial(replica_count);</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        prng<span>.</span>shuffle(<span>u8</span><span>,</span> <span>&amp;</span>route<span>.</span>replicas);</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span>const</span> code <span>=</span> route_encode(route);</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span>const</span> route_decoded <span>=</span> route_decode(code)<span>.?</span>;</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        assert(std<span>.</span>meta<span>.</span>eql(route<span>,</span> route_decoded));</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>That’s it! Testing <em>every</em> <code>replica_count</code>, and
every permutation of replicas!</p>
<p>This is our first fuzzer — we test serialization by encoding and
decoding a random route. We also notice that the total amount of routes
is small, and adapt our random code to exhaustively cover the entire
positive space, using a rigged PRNG.</p>
<h2 id="fuzzer-2-exploring-negative-space"><a href="#fuzzer-2-exploring-negative-space" aria-hidden="true">Fuzzer #2: Exploring Negative Space</a></h2>
<p>Testing <em>only</em> positive space is a common pitfall. We want to
check serialization and deserialization for routes. We do that by
round-tripping the route. We even make sure to check <em>every</em>
possible route, how can there be anything else left to test here?</p>
<p>This is an example of a positive space thinking, which sometimes
gives us false confidence that everything is thoroughly tested, while we
are failing to consider some cases off the happy path.</p>
<p>What we missed here is that not every code necessarily encodes a
valid route. We only feed “valid” data to deserialization routine, but
who knows what bytes you can receive through the TCP socket?</p>
<p>Now, this is tricky: actually, TigerBeetle only talks to other
TigerBeetle replicas, and all communication is protected by a strong
checksum. So it is actually correct to assume that the encoding is
valid, modulo bugs. But there <em>might</em> be bugs! And, if there’s a
bug somewhere which manifests itself as an invalid encoding, we want to
detect that and crash loudly, rather than silently misinterpret valid
data.</p>
<p>That’s why the decode function returns a nullable
<code>Route</code>…</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> route_decode(routing<span>:</span> <span>*</span><span>const</span> Routing<span>,</span> code<span>:</span> <span>u64</span>) <span>?</span>Route;</span></code></pre></div>
<p>but at the call-site the <code>Route</code> is unwrapped:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>const</span> route <span>=</span> <span>self</span><span>.</span>routing<span>.</span>route_decode(message<span>.</span>header<span>.</span>route)<span>.?</span>;</span></code></pre></div>
<p>This is offensive programming, we want to force bugs to jump into the
spotlight, and not to lie hidden on odd cold paths.</p>
<p>The most straightforward way to test the negative space here is to
run our test backwards, and to try deserialize and then serialize a
random code:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_decode {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span>var</span> prng <span>=</span> stdx<span>.</span>PRNG<span>.</span>from_seed(std<span>.</span>testing<span>.</span>random_seed);</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span>const</span> code <span>=</span> prng<span>.</span>int(<span>u64</span>);</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span>if</span> (route_decode(code)) <span>|</span>route<span>|</span> {</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span>const</span> code_encoded <span>=</span> route_encode(route);</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        assert(code <span>==</span> code_encoded);</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    } <span>else</span> {</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span>// Just make sure we don&#39;t crash!</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>There’s a subtle problem with a test above — the “then” branch of the
if is dead code, and we’ll never get there, even if we repeat the test a
hundred million times:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_decode {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span>var</span> prng <span>=</span> stdx<span>.</span>PRNG<span>.</span>from_seed(std<span>.</span>testing<span>.</span>random_seed);</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span>for</span> (<span>0</span><span>.</span><span>.</span><span>100_000_000</span>) <span>|</span>_<span>|</span> {</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span>const</span> code <span>=</span> prng<span>.</span>int(<span>u64</span>);</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span>if</span> (route_decode(code)) <span>|</span>_<span>|</span> {</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            assert(<span>false</span>);</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        } <span>else</span> {</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            <span>// Just make sure we don&#39;t crash!</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>$ t ./zig/zig build test --release -- route_decode

real 7.14s
cpu  7.16s (7.08s user + 76.41ms sys)
rss  34.97mb</code></pre>
<p>Our completely random encoding never manages to generate a valid
code!</p>
<p>As we have seen above, there are very few different routes, and,
therefore, very few valid encodings. But our code is <code>u64</code>.
The space of all possible codes is huge, but the subspace of all
<em>valid</em> codes is very sparse.</p>
<p>Is this a problem? We checked all valid codes, so it’s fine if we
only look at the invalid ones? No! Given just how rarefied our encoding
space is, purely random codes are going to be <em>obviously</em>
invalid. The decoding routine will reject them very quickly, and we are
likely to not exercise most of the logic there.</p>
<p>For effective fuzzing, you want to test the <em>boundary</em>: you
want to check a valid code, and a code which is <em>almost</em> the
same, but invalid.</p>
<p>For that, we <em>bias</em> our generator to prefer codes in the
neighborhood of valid encodings:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>var</span> code_bytes<span>:</span> [<span>8</span>]<span>u8</span> <span>=</span> <span>@splat</span>(<span>0</span>);</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>for</span> (<span>&amp;</span>code_bytes) <span>|*</span>byte<span>|</span> {</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    byte<span>.*</span> <span>=</span> <span>if</span> (prng<span>.</span>chance(ratio(replica_count <span>+</span> <span>1</span><span>,</span> <span>8</span>)))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        prng<span>.</span>int_inclusive(<span>u8</span><span>,</span> constants<span>.</span>replicas_max <span>+</span> <span>1</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span>else</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span>0</span><span>xFF</span>;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span>var</span> code<span>:</span> <span>u64</span> <span>=</span> <span>@bitCast</span>(code_bytes);</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span>if</span> (prng<span>.</span>chance(ratio(<span>1</span><span>,</span> <span>20</span>))) {</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    code <span>^=</span> prng<span>.</span>bit(<span>u64</span>);</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span>if</span> (prng<span>.</span>chance(ratio(<span>1</span><span>,</span> <span>20</span>))) {</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    code <span>=</span> prng<span>.</span>int(<span>u64</span>);</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The encoding is literally a permutation of replica indexes, where
each replica index is a byte, padded by <code>0xFF</code> bytes to
<code>u64</code>. We generate a random mish-mash of those bytes (which
just <em>might</em> generate a valid code), then, to spice thing up, we
randomly corrupt a single bit of code. Finally, to make sure we don’t
<em>just</em> generate almost valid code, sometimes we throw everything
away and fall back to fully random.</p>
<h2 id="non-deterministic-aside"><a href="#non-deterministic-aside" aria-hidden="true">Non-Deterministic Aside</a></h2>
<p>This <em>sounds</em> plausible, but is this actually true? Do we
<em>actually</em> hit the boundary here, generate both valid and invalid
codes? And how do we make sure that our negative-space fuzzer continues
to test interesting cases as the code itself evolves (it certainly looks
like we can optimize the encoding to be more compact…)?</p>
<p>A good pattern here is to repeat the test many times, counting all
the sad and happy cases, and assert that they are reasonable:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_decode {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span>const</span> Counts <span>=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span>struct</span> { total<span>:</span> <span>u32</span><span>,</span> valid<span>:</span> <span>u32</span><span>,</span> invalid<span>:</span> <span>u32</span> };</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span>var</span> prng <span>=</span> stdx<span>.</span>PRNG<span>.</span>from_seed(std<span>.</span>testing<span>.</span>random_seed);</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span>var</span> counts<span>:</span> Counts <span>=</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span>.</span>{ <span>.</span>total <span>=</span> <span>200_000</span><span>,</span> <span>.</span>valid <span>=</span> <span>0</span><span>,</span> <span>.</span>invalid <span>=</span> <span>0</span> };</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span>for</span> (<span>0</span><span>.</span><span>.</span>counts<span>.</span>total) <span>|</span>_<span>|</span> {</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span>//...</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span>if</span> (route_decode(code)) <span>|</span>_<span>|</span> {</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>            counts<span>.</span>valid <span>+=</span> <span>1</span>;</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>            <span>//...</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        } <span>else</span> {</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            counts<span>.</span>invalid <span>+=</span> <span>1</span>;</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    assert(counts<span>.</span>total <span>==</span> counts<span>.</span>valid <span>+</span> counts<span>.</span>invalid);</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    assert(counts<span>.</span>valid <span>&gt;</span> <span>50</span>);</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    assert(counts<span>.</span>invalid <span>&gt;</span> <span>100_000</span>);</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Due to randomness, we can’t check the exact values of counters, but
we can assert that <em>most</em> of the encodings are invalid, and that
at least some are valid (remember, our initial test generated zero valid
encodings out of 100 000 000 attempts).</p>
<p>This brings me to another topic I want to cover — treatment of
determinism in tests. “Thy tests shall be deterministic” is a reasonable
commandment, but not an absolute one. I see that often people try to
avoid randomness in tests at all costs, and always initialize PRNG with
a hard-coded seed of 42. I don’t like that, for two reasons.</p>
<p><em>The practical reason</em> is that, over its lifetime, the test is
going to be re-run many thousand times over, and it is wasteful to
<em>not</em> take advantage of that to explore more of the state space
eventually, while keeping each individual test run very fast.</p>
<p><em>The purity reason</em> is that, if there exists a seed value that
makes the test fail, the test (or the code) is buggy and needs to be
fixed! Sure, it’s unfortunate if you discover that bug while working on
an unrelated change, but it is <em>less</em> unfortunate than not
knowing about the bug at all!</p>
<p>However, <em>just</em> using genuinely random seeds for tests is
pretty bad:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_decode {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span>const</span> seed <span>=</span> std<span>.</span>crypto<span>.</span>random<span>.</span>int(<span>u64</span>);</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The problem with the above is that, when a test fails, you don’t know
the seed! And, if it is one-in-a-million failure, it can be very a
frustrating experience to reproduce it. This can be helped by printing
the seed on failure, but <em>that</em> A) requires writing more code per
test and, B) doesn’t work if the failure is not graceful. Imagine
getting a mystery segfault on some random CI run, and then not being
able to reproduce it because the process dies before the seed is
printed!</p>
<p>Zig I think has the best design in this space. It provides you with
the <code>std.testing.random_seed</code> value, which is a ready-to-use
random seed that is different per run. Crucially, the seed is generated
outside of the test process itself and is passed to it on the CLI. It
doesn’t matter what happens with the test process. It can explode
completely, but the parent process will still print the seed on failure.
Conveniently, the seed is printed as a part of a CLI invocation which
you can immediately paste into your shell!</p>
<pre><code>$ ./zig/zig build test

test
+- run test-vsr failure
thread 2285 panic: reached unreachable code
...
error: while executing test &#39;vsr.test.routing.route_decode&#39;
error: the following command terminated with signal 6:

.zig-cache/o/14db484/test-vsr --seed=0x737929ed</code></pre>
<p>So that’s why we’ve been using
<code>PRNG.from_seed(testing.random_seed)</code> throughout! And it has
been working perfectly, up until now. Here’s the problem:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>var</span> prng <span>=</span> stdx<span>.</span>PRNG<span>.</span>from_seed(std<span>.</span>testing<span>.</span>random_seed);</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>//...</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>assert(counts<span>.</span>total <span>==</span> counts<span>.</span>valid <span>+</span> counts<span>.</span>invalid);</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>assert(counts<span>.</span>valid <span>&gt;</span> <span>50</span>);</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>assert(counts<span>.</span>invalid <span>&gt;</span> <span>100_000</span>);</span></code></pre></div>
<p>The seed <em>is</em> random, so, sooner or later, our assert will
fire. We can make the probability of that negligible by increasing
<code>total</code> and increasing our tolerance, but that is
unsatisfactory. Larger iteration count slows down each individual test
run. And relaxing asserts tells us <em>less</em> about the average case,
what we actually care about. And we don’t know what’s the actual
probability of hitting the assert! It might be that the actual
probability is small, but not infinitesimal, such that you’ll be
debugging a random “failure” five years from now! <a href="https://github.com/tigerbeetle/tigerbeetle/issues/1876">One in a
billion events do happen in CI!</a></p>
<p>A nice pattern here is to run the test twice: once with a hard-coded
seed to capture the “average” distribution and assert statistics, and
once with a truly random seed for coverage:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>test</span> route_decode {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span>const</span> T <span>=</span> <span>struct</span> {</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span>const</span> Counts <span>=</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>            <span>struct</span> { total<span>:</span> <span>u32</span><span>,</span> valid<span>:</span> <span>u32</span><span>,</span> invalid<span>:</span> <span>u32</span> };</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span>fn</span> check(seed<span>:</span> <span>u64</span>) Counts {</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>            <span>// ...</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span>const</span> counts <span>=</span> T<span>.</span>check(<span>92</span>);</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    assert(counts<span>.</span>total <span>==</span> counts<span>.</span>valid <span>+</span> counts<span>.</span>invalid);</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    assert(counts<span>.</span>valid <span>&gt;</span> <span>50</span>);</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    assert(counts<span>.</span>invalid <span>&gt;</span> <span>100_000</span>);</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    _ <span>=</span> T<span>.</span>check(std<span>.</span>testing<span>.</span>random_seed);</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This is our second fuzzer — testing for negative space by probing
obviously invalid values, and then specifically values that cross the
valid/invalid boundary, while collecting and asserting coverage
information.</p>
<p>For this particular scenario, it would’ve been better to use a real
coverage-guided fuzzer like libFuzzer, but, at the time of writing, Zig
is only at the start of its fuzzing journey. It already has
<code>std.testing.fuzz</code>, but I wasn’t able to get that working on
my machine. Anyway the implementation of the fuzzer is a detail. What
matters is the principle of explicit testing of negative space, the
boundary space, and verifying that both ins and outs get tested!</p>
<p>Moreover, just like we got exhaustive test by driving PRNG interface
via exhaustive enumeration from inside, we can drive a PRNG through a
fuzzer. You can combine the best of both worlds: highly structured
complex inputs of property based testing and introspective guided
program state exploration of coverage-guided fuzzers. This again is
worth a separate blog post, but I really need to do more research before
it is ready. However, I’ll be sharing what I got so far on 1000x world
tour on December 3 in Lisbon next week. Come, say hello if you are
around: <a href="https://luma.com/7d47f4et">https://luma.com/7d47f4et</a>!</p>
<h2 id="fuzzer-3-qualitative-fuzzing"><a href="#fuzzer-3-qualitative-fuzzing" aria-hidden="true">Fuzzer #3: Qualitative Fuzzing</a></h2>
<p>Ok, the warmup is over! Serialization was a simple and boring part of
Adaptive Replication Routing. Let’s tackle the actual logic. Similarly,
we’ll start with a positive space, checking that ARR indeed converges to
the best route in a scenario approximating what we <em>expect</em> to
see in the real world.</p>
<p>This is going to be interesting, because it is not a <em>local</em>
correctness property. We want to check that six instances of ARR on six
different physical machines work in concert, such that, e.g., everyone
agrees which operations are experiments, and what is the route of each
experiment.</p>
<p>Here’s the plan. We arrange six replicas into a virtual ring, such
that the network delay between replicas is proportional to the distance
along the ring. The order of replicas is random, and correctly
implemented ARR must be able to “unscramble” the permutation in the end.
Each “replica” is just a <code>Routing</code> instance. This is the
entire idea behind <del>The Matrix</del> focused fuzzing, we don’t need
to simulate anything else!</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>const</span> T <span>=</span> <span>struct</span> {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    replica_count<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    permutation<span>:</span> []<span>u8</span><span>,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    view<span>:</span> <span>u32</span><span>,</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    primary<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    prepare_ok_count<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    replicas<span>:</span> []Routing<span>,</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span>const</span> T <span>=</span> <span>@This</span>();</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span>pub</span> <span>fn</span> init(gpa<span>:</span> Allocator<span>,</span> seed<span>:</span> <span>u64</span>) T { <span>...</span> }</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span>pub</span> <span>fn</span> deinit(t<span>:</span> <span>*</span>T<span>,</span> gpa<span>:</span> Allocator) <span>void</span> { <span>...</span> }</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> ring_index(t<span>:</span> <span>*</span><span>const</span> T<span>,</span> replica<span>:</span> <span>u8</span>) <span>i8</span> {</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>@intCast</span>(t<span>.</span>permutation[replica]);</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> distance(t<span>:</span> <span>*</span><span>const</span> T<span>,</span> a<span>:</span> <span>u8</span><span>,</span> b<span>:</span> <span>u8</span>) <span>u8</span> {</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span>const</span> a2b <span>=</span> @abs(t<span>.</span>ring_index(b) <span>-</span> t<span>.</span>ring_index(a));</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        <span>const</span> b2a <span>=</span> t<span>.</span>replica_count <span>-</span> a2b;</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>@min</span>(a2b<span>,</span> b2a);</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>An optimal route enumerates replicas in the order of
<code>permutation</code> in either of two directions (there are two
optimal routes!). We can check that by summing up pairwise
distances:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> route_total_distance(t<span>:</span> <span>*</span><span>const</span> T<span>,</span> route<span>:</span> Route) <span>u8</span> {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span>var</span> result<span>:</span> <span>u8</span> <span>=</span> <span>0</span>;</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span>for</span> (</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        route<span>.</span>replicas[<span>0</span> <span>..</span> t<span>.</span>replica_count <span>-</span> <span>1</span>]<span>,</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        route<span>.</span>replicas[<span>1</span><span>.</span><span>.</span>t<span>.</span>replica_count]<span>,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    ) <span>|</span>a<span>,</span> b<span>|</span> {</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        result <span>+=</span> t<span>.</span>distance(a<span>,</span> b);</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> result;</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span>fn</span> route_optimal(t<span>:</span> <span>*</span><span>const</span> T<span>,</span> route<span>:</span> Route) <span>bool</span> {</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span>return</span> t<span>.</span>total_route_distance(route) <span>==</span> t<span>.</span>replica_count <span>-</span> <span>1</span>;</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The overall flow of the fuzzer is as follows. We send prepares one by
one. For each prepare, we run the simulation until the primary collects
<code>prepare_ok</code> messages from everybody.
<code>prepare_ok_count</code> field tells us when we should start with
the next prepare. Submitting a prepare is modeled via sending a message
to the primary. When a set number of prepares is dealt with, we check
that the final route is optimal.</p>
<p>Note that this is <em>not</em> how the real replication works,
reality is pipelined, and multiple prepares are in flight at the same
time. However, the purpose of this particular fuzzer isn’t to check a
“realistic” scenario, the purpose is to check the idealized scenario,
but be very strict in the acceptance criteria (that the route really is
optimal).</p>
<p>The full code is a bit too much for this article, but the core logic
of simulating replication process is this <code>message_delivered</code>
function. It models what happens when replica <code>target</code>
receives a <code>message</code> from <code>source</code>. Which is,
forward the message along the ring, and reply with
<code>.prepare_ok</code> to the primary.</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> message_delivered(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    t<span>:</span> <span>*</span>T<span>,</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    source<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    target<span>:</span> <span>u8</span><span>,</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    message<span>:</span> <span>union</span>(<span>enum</span>) { prepare<span>:</span> <span>u64</span><span>,</span> prepare_ok<span>:</span> <span>u64</span> }<span>,</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>) <span>void</span> {</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span>switch</span> (message) {</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span>.</span>prepare <span>=&gt;</span> <span>|</span>op<span>|</span> {</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>            <span>// The initial prepare is injected by the fuzzer.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>            <span>if</span> (target <span>==</span> t<span>.</span>primary) {</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>                assert(source <span>==</span> t<span>.</span>primary);</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>                assert(t<span>.</span>prepare_ok_count <span>==</span> <span>0</span>);</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>                t<span>.</span>replicas[t<span>.</span>primary]<span>.</span>op_prepare(op<span>,</span> t<span>.</span>now());</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>            <span>// Inform the primary that we got the prepare.</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>            t<span>.</span>send(<span>.</span>{</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>                <span>.</span>source <span>=</span> target<span>,</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>                <span>.</span>target <span>=</span> t<span>.</span>primary<span>,</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>                <span>.</span>message <span>=</span> <span>.</span>{ <span>.</span>prepare_ok <span>=</span> op }<span>,</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            });</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>            <span>// Forward prepare along the current replication ring.</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            <span>for</span> (t<span>.</span>replicas[target]<span>.</span>op_next_hop(op)) <span>|</span>target_next<span>|</span> {</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>                assert(target_next <span>&lt;</span> t<span>.</span>replica_count);</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>                t<span>.</span>send(<span>.</span>{</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>                    <span>.</span>source <span>=</span> target<span>,</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>                    <span>.</span>target <span>=</span> target_next<span>,</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>                    <span>.</span>message <span>=</span> <span>.</span>{ <span>.</span>prepare <span>=</span> op }<span>,</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>                });</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        <span>.</span>prepare_ok <span>=&gt;</span> <span>|</span>op<span>|</span> {</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>            assert(target <span>==</span> t<span>.</span>primary);</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>            t<span>.</span>prepare_ok_count <span>+=</span> <span>1</span>;</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>            t<span>.</span>replicas[t<span>.</span>primary]<span>.</span>op_prepare_ok(op<span>,</span> t<span>.</span>now()<span>,</span> source);</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>What’s fascinating about this fuzzer is not the implementation, but
rather the bugs it was able to find. Writing the fuzzer was a relatively
mechanical and mindless process, other than the initial idea of modeling
a physical ring of replicas. But the two failures it found revealed my
misunderstanding of the problem, and forced me to apply deeper thinking
where I thought I understood everything.</p>
<p>To explain that, I need to talk about the ARR cost function. After an
ARR experiment, the primary somehow needs to measure the quality of a
the experimental route. The <em>data</em> we have are
<code>.prepare_ok</code> latencies for all replicas — a vector of six
integers.</p>
<p>My initial cost function was a pair of the median and the maximum
value of the vector, with some fuzz factor:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>Cost<span>.</span>of(<span>.</span>{</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span>.</span>ms(<span>31</span>)<span>,</span> <span>.</span>ms(<span>178</span>)<span>,</span> <span>.</span>ms(<span>148</span>)<span>,</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span>.</span>ms(<span>92</span>)<span>,</span> <span>.</span>ms(<span>144</span>)<span>,</span> <span>.</span>ms(<span>50</span>)<span>,</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>}) <span>==</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span>.</span>{ <span>.</span>median <span>=</span> <span>.</span>ms(<span>92</span>)<span>,</span> <span>.</span>maximum <span>=</span> <span>.</span>ms(<span>178</span>) }</span></code></pre></div>
<p>The median tracks the moment in time when a half of the cluster
acknowledged the prepare, which, due to flexible quorums, is the moment
where it is safe to commit prepare. The median replication time is a
proxy for user-visible latency, and it is the primary number we are
optimizing for.</p>
<p>After we replied to the user, we still want to replicate the prepare
to the rest of the cluster, to maximize durability. The maximum
replication time directly tracks full replication, and it’s the second
most important metric to optimize.</p>
<p>Finally, we don’t want the cluster to oscillate between two nearly
identical routes simply due to random delay noise, so we also add a fuzz
factor and consider close enough numbers to be equal for comparison
purposes.</p>
<p>Can you see the bug here? I didn’t, but the fuzzer I wrote did. After
running for a short time, the fuzzer found the case where ARR failed to
converge to the optimal path. Here’s the path that that run ended up
with:</p>
<figure>
    
    <figcaption>Not Quite Optimal Route</figcaption>
</figure>

<p>This is indeed an optimal path in terms of median,maximum cost
function. The median is two hops, the maximum is three. But it is not
<em>actually</em> optimal, because replicas <em>between</em> median and
maximum take longer time to replicate, and we care about that as well,
as that’s a proxy for us selecting the most efficient route for each
replica. It doesn’t affect important latencies, but it still sends the
electrons further away than they’d otherwise need to go.</p>
<p>The fix is easy — add a third component to the cost function, the sum
of all latencies.</p>
<p>The problem was fixed, but, after a few iterations more, I got
another example that failed to converge to an optimal route. It took me
an embarrassingly long time to debug that, but the explanation was
really simple. My fuzz factor was too fuzzy, and made two different
routes look the same. This fix also was simple, just tighten up the
“almost equal” condition.</p>
<p>But what bugged me is that, in my mental model, the old fuzz factor
was fuzzy enough as is. So I tried to explain <em>why</em> it didn’t
work, and realized that I had a completely wrong mental image of
replication routes. And, yes, <em>all</em> the illustrations I’ve drawn
so far also have this bug. Do you see it?</p>
<p>This is what the actual replication route looks like:</p>
<figure>
    
    <figcaption>Replication With ACKs</figcaption>
</figure>

<p>Prepares flow forward along the ring, but acknowledgements always
flow directly to the primary, in a star topology. When the primary
measures the replication latency, it captures <em>both</em> the time to
send the <code>.prepare</code> forward and the time to get the
corresponding <code>.prepare_ok</code> back. And the time to receive all
<code>.prepare_ok</code> is independent of the route!</p>
<p>In other words, changing the route can affect only half of the
observed latencies, which makes relative difference between the routes
smaller, and justifies tighter tolerances.</p>
<p>This was a huge shift in the mental model for me! I didn’t realize
that we only observe latencies through the glass, darkly! I hadn’t
thought about that myself, but the fuzzer did!</p>
<p>This is our third fuzzer. It is a whole subsystem positive space
fuzzer. It’s actually an exuberantly optimistic fuzzer, as it sets up an
ideal lab environment with extremely predictable network latencies.
While not realistic, this setup ensures that there’s a clear answer to
the question of which route is the best, and that allows us to verify
that the algorithm is exactly correct, and not merely crash free. This
is the catch — in the real system with faults and variants, the notion
of optimal route is ill-defined and constantly changes. The acceptance
criteria has to be fuzzy in a realistic simulation, but can be very
strict in the lab.</p>
<h2 id="fuzzer-4-sweet-dreams-mansons-version"><a href="#fuzzer-4-sweet-dreams-mansons-version" aria-hidden="true">Fuzzer #4: Sweet Dreams (Manson’s Version)</a></h2>
<p>Finally, the fourth fuzzer. You might guess it, we’ll go for negative
space this time. We no longer care about how the Routing <em>should</em>
be used by the replica, we are trying to break it.</p>
<p>The fundamental difference here is that, for positive space, we
modeled all six “replicas” at the same time messages flowing between
them. But any model of that sort necessarily restricts us to executions
possible in the cluster. Now we won’t be trying to model anything in
particular. We’ll have just a single instance of <code>Routing</code>
and will be calling all public methods in random order, only obeying the
documented invariants:</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>// Simulate the entire cluster:</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span>const</span> PositiveSpace <span>=</span> <span>struct</span> {</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    replicas<span>:</span> []Routing<span>,</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span>// ...</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span>// Hammer a single replica, hard:</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span>const</span> NegativeSpace <span>=</span> <span>struct</span> {</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    replica<span>:</span> Routing<span>,</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span>// ...</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>There isn’t <em>much</em> we can check here, but we can check
<em>something</em>. At minimum, we should never crash. Additionally, we
can check that whatever route we have, it “connects”. That is, if we
follow the chain of <code>next_hop</code>s, we’ll visit each replica
exactly once.</p>
<p>The code isn’t particularly illuminating here, but the overall shape
looks similar to the technique described in the <a href="https://tigerbeetle.com/blog/2025-04-23-swarm-testing-data-structures/"><em>Swarm
Testing Data Structures</em></a>.</p>
<p>That’s it for today! This was a tale of four fuzzers!</p>
<h2 id="fuzzer-5-can-i-count-no"><a href="#fuzzer-5-can-i-count-no" aria-hidden="true">Fuzzer #5: Can I Count? No.</a></h2>
<p>Yeah… At Fuzzer #3, I realized that we actually wrote five fuzzers
for ARR, but the title and the Dickens quote had really grown on me by
that time. Sorry for this, here’s a bonus fuzzer for you!</p>
<p>Our positive space ARR fuzzer explores a really specific network
topology, which is roughly as far from a realistic scenario as the
negative space fuzzer, but in the opposite direction — everything’s too
good, no one’s crashing, the network gives stable latencies.</p>
<p>What we are missing is the realistic fuzzer between the two extremes.
A fuzzer that runs in a somewhat flaky network, and checks that the
route is roughly optimal (or at least not bad). But that is the VOPR! As
a whole system fuzzer, it is capable of simulating somewhat realistic
distributions of network faults and delays.</p>
<p>Historically, VOPR was biased towards faulting as much things as hard
as possible, as we want TigerBeetle to be correct and fast, in that
order. Now that we started optimization work, we implemented
<code>--performance</code> mode for VOPR.</p>
<p>In the default mode, VOPR uses swarm testing to generate distribution
of faults (during fuzzing, you generate random events. The idea of swarm
testing is to also generate the distribution itself at random). In the
performance mode, fault parameters are fixed to “realistic” values, and
the drastic faults (replicas crashing or becoming partitioned) are
strictly controlled (e.g., you can request exactly one crash per
run):</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> options_swarm(prng<span>:</span> <span>*</span>stdx<span>.</span>PRNG) Simulator<span>.</span>Options</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span>fn</span> options_performance() Simulator<span>.</span>Options</span></code></pre></div>
<p>Furthermore, in performance mode VOPR tracks statistics about the
number of network messages exchanged. ARR was verified by running
different performance VOPR scenarios with and without ARR, and checking
that ARR is an improvement across the board:</p>
<pre><code>λ ./zig/zig build vopr -- --performance --replica-missing=2

          SEED=1044607978391563277

          replicas=6
          clients=4
          one_way_delay_mean=50ms ticks
          one_way_delay_min=0ns ticks
          packet_loss_probability=0
          path_maximum_capacity=10 messages
          packet_replay_probability=0
          crash_probability=0
          crash_stability=500 ticks
          restart_probability=0
          ...

Messages:
prepare                     1881    1.23MiB
prepare_ok                  1575  393.75KiB
request_prepare              795  198.75KiB
request                      730  510.08KiB
ping                         550  275.00KiB
reply                        503  363.76KiB
request_headers              466  116.50KiB
pong                         440  110.00KiB
headers                      328  320.75KiB
commit                       285   71.25KiB
start_view                    85  224.25KiB
do_view_change                25   12.50KiB
request_start_view            10    2.50KiB
total                       7673    3.77MiB


          PASSED (1741 ticks)</code></pre>
<p>It’s a bit hard to turn these manual experiments into tests that fail
<em>only</em> if there are bugs (and not due to randomness or unrelated
code choices), but just tinkering with the setup is a great way to
quickly test ideas. VOPR runs <em>much</em> faster than a real-world
cluster would, so you can use it to collect a fairly long performance
trace.</p>
<h2 id="recap"><a href="#recap" aria-hidden="true">Recap</a></h2>
<p>This was a long one, wasn’t it? Although it’s just one system and
five fuzzers, no two fuzzers are alike, each illuminates its own corner
of the design space. If you want a closer looks, here’s the <a href="https://github.com/tigerbeetle/tigerbeetle/blob/0.16.66/src/vsr/routing.zig">source
code</a>, it’s almost exactly a thousand lines for the implementation
plus the fuzzers.</p>
<p>To jolt the ideas back into the short term (and, who knows, maybe a
long term) memory:</p>
<ul>
<li>You want both a whole system fuzzer AND subsystem (minor) fuzzers.
Main fuzzer works out the seams between components, while minor fuzzers
divide&amp;conquerer the resulting combinatorial explosion.</li>
<li>Good fuzzing is tantamount to good interfaces.</li>
<li>Interfaces can be extracted mechanically, by introducing indirection
whenever a dependency happens.</li>
<li>But such a mechanical interface extraction risks ossifying
accidental dependencies.</li>
<li>Long-term more efficient approach is to think in terms of
fundamental input and output data. Sometimes a little copying is better
than a little dependency!</li>
<li>Data interfaces tend to be non-incremental. The best time to capture
an interface is <em>before</em> the first line of code is written.</li>
<li>Fuzz positive space and negative space.</li>
<li>Given a PRNG <em>interface</em>, its easy to explore structured
search space.</li>
<li>If the search space is small, you can use the <em>same</em> PRNG
interface to walk it thoroughly and exhaustively.</li>
<li>And you can plug the <em>same</em> PRNG interface into coverage
guided fuzzer.</li>
<li><code>deserialize . serialize</code> is positive space,
<code>serialize . deserialize</code> can be negative space.</li>
<li>Hard to breath in rarefied air! Purely random inputs can be
uniformly boring and bounce off the edges of the system.</li>
<li>For negative space testing, you want to hew close to the
valid/invalid boundary, poking out from <em>both</em> sides.</li>
<li>You still want some amount of purely random inputs, just in
case.</li>
<li>You want to <em>assert</em> that both positive and negative cases
actually happen with non-negligible probability.</li>
<li>Run fuzzer once with a fixed seed (I use <code>92</code>), to sanity
check the count of good and bad cases.</li>
<li>Run fuzzer again with a genuinely random seed to accumulate coverage
over time.</li>
<li>Make sure to generate the seed <em>outside</em> of the test process
itself, lest it gets lost during crash.</li>
<li>Mind the time! You want to make each individual CI run as quick as
possible, while racking up the total fuzzing time over multiple
runs.</li>
<li>Another quick and dirty way to check fuzzer coverage is adding
<code>unreachable</code> to various branches and check seeing if it
crashes.</li>
<li>Fuzzers can test fairly sophisticated invariants (e.g., optimality
of the routing), but that might require setting up a particularly
favorable environment.</li>
<li>Writing a fuzzer is mostly boring mechanical work. However, not only
fuzzers do find bugs, some bugs lead to large, fundamental mental
shifts, and a deeper understanding of the domain!</li>
<li>Don’t write fuzzers to find bugs in the code, write fuzzers to find
bugs in your understanding of the problem.</li>
<li>Positive space fuzzing tries to be realistic, negative space fuzzing
tries to be un-realistic.</li>
<li>Simulate a real cluster for the positive space, simulate a single
peer in a radioactive room for the negative space.</li>
<li>It might be hard to get intricate, flake-free assertions from the
whole system fuzzer.</li>
<li>But whole-system fuzzer is still invaluable as an exploration
tool.</li>
<li>You can fuzz for performance, at least on the high level protocol
level (# messages exchanged).</li>
<li>Come to TigerBeetle 1000X to Lisbon (or the city nearest to you): <a href="https://tigerbeetle.com/event/1000x">https://tigerbeetle.com/event/1000x</a></li>
</ul>
<p>Até já!</p>
  </div></div>
  </body>
</html>
