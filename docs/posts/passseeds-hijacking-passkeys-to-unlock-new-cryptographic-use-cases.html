<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://backalleycoder.com/posts/passseeds-an-experiment-in-hijacking-passkeys-to-unlock-cryptographic-use-cases/">Original</a>
    <h1>PassSeeds – hijacking Passkeys to unlock new cryptographic use cases</h1>
    
    <div id="readability-page-1" class="page"><article id="article"> <p>In my time at Microsoft, I worked on the team responsible for the development and standardization of Passkeys. <a href="https://www.passkeys.io/">Passkeys</a> have made standard, secure, cryptographic authentication <a href="https://www.passkeys.io/who-supports-passkeys">accessible to all users</a>, but the model is tightly restricted to website/app login.</p>
<p>Even with a deep, code-level understanding of passkeys and WebAuthn, it wasn’t until now, six years later, that I realized a set of properties and behaviors present within Passkeys could be hijacked to make this post possible. This ‘feature’ was sitting right there and feels so obvious in retrospect. It just goes to show if you remain curious and turn over every rock, you can bend technology to do new and interesting things.</p>
<p>PassSeeds is a hack that explores this question: can we hijack the capabilities and UX of passkeys for use cases that stretch beyond their rigid login model and limited key-type support? The status quo of many Web-based use cases involving long-held cryptographic keys is often users pasting key material into sites/apps or buying special hardware devices that are difficult for less technical folks to use.</p>
<h2 id="booting-up-on-passkeys">Booting Up On Passkeys</h2>
<p>To understand PassSeeds, it helps to have some awareness of the underlying Passkey technology they are based on.</p>
<figure><img alt="Passkey Logo" loading="lazy" decoding="async" fetchpriority="auto" width="600" height="197" src="https://backalleycoder.com/_astro/passkey-logo.DGQ2v-2E_6pRoQ.webp"/></figure>
<p>Passkeys are asymmetric key pairs formatted as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API">WebAuthn credentials</a>, typically used to replace passwords for website logins. A key pair is created on the user’s device for a website and stored in a secure hardware module. Access to and usage of these key pairs is scoped to the <a href="https://developer.mozilla.org/en-US/docs/Glossary/Origin">origin</a> of the site they were created on (for example: <code>example.com</code>, <code>other.example.com</code>, <code>test.com</code>). Passkeys are replicated across a user’s devices by the platform (iCloud Keychain, Google Password Manager, Windows Hello, etc.) via an end-to-end encrypted sync process. Below is a basic overview of the two primary UX flows for generating a passkey and using one for login:</p>
<figure><img alt="Passkey generation and signing flows" loading="lazy" decoding="async" fetchpriority="auto" width="948" height="1050" src="https://backalleycoder.com/_astro/passkey-flows.dlKNLi2q_ZrdLt1.webp"/><figcaption>Passkey generation and signing flows</figcaption></figure>
<h3 id="key-points-pun-intended">Key Points (pun intended)</h3>
<p>There are several attributes of Passkeys to keep in mind that are critical to the PassSeed mechanism detailed in this post:</p>
<ul>
<li>Passkeys are key pair + metadata bundles that are securely stored and synced across a user’s devices by OS/platform</li>
<li>The private and <em>public</em> key are both stored and synced across devices as one highly sensitive bundle</li>
<li>If you never store it at generation time and do not allow signatures from its private key out of the generating origin’s boundary, no API, metadata, or side-channel reveals the <em>public</em> key.</li>
</ul>
<p>Given these attributes of the Passkey model, even <em>public</em> keys in the system behave like a natively provisioned, hardware-secured, synced secret, even though cryptography does not require them to be secret. This is a rare and valuable set of properties many products, services, and protocols find highly desirable.</p>
<h2 id="introducing-passseeds">Introducing PassSeeds</h2>
<figure><img alt="Passkey Logo" loading="lazy" decoding="async" fetchpriority="auto" width="1379" height="485" src="https://backalleycoder.com/_astro/passseed-logo.Dtrp9Ve4_Z12MY6B.webp"/></figure>
<p>Passkeys provide biometrically gated use of cryptographic keys, but they were created specifically for authentication signing in centralized website login flows. Meanwhile, web apps that need cryptographic material and curves that passkeys don’t support (<code>secp256k1</code> for Bitcoin, <code>BLS12-381</code> for ZKPs, etc.) remain primitive and convoluted. Users copy 12–24 words, stash JSON keystores, or paste raw keys across apps. PassSeeds introduces a novel approach: treat the passkey’s P‑256 public key itself as seed material and retrieve it on demand through ECDSA public‑key recovery. The authenticator still keeps the private key and user‑verification requirements, but the recovered public‑key bytes become the deterministic PassSeed that can serve as the foundation for other cryptographic use cases.</p>
<p>(If you don’t want to understand how it works, you can skip to the <a href="https://backalleycoder.com/passseeds/">DEMO</a>)</p>
<h2 id="passseed-generation">PassSeed Generation</h2>
<p><strong>Assumptions:</strong> you have created a passkey, did not export the public key anywhere at generation time, and do not allow any signatures from the passkey outside of the generating origin’s local boundary.</p>
<p><strong>Initial Generation</strong></p>
<ol>
<li>Call <code>navigator.credentials.create()</code> with <code>userVerification: required</code> to mint a P-256 passkey scoped to the generating origin’s RP ID.</li>
<li>The initial passkey creation operation is the only API call where the platform returns the public key, but DO NOT export the public key, as it is effectively the private seed value of the PassSeed and can be recovered later through cryptographic means.</li>
<li>Use the returned public key to generate the cryptographic seed bytes.</li>
</ol>
<p><strong>Regeneration via ECDSA Key Recovery</strong></p>
<ol>
<li>When a PassSeed is needed (for example, to sign a Bitcoin transaction, sign a decentralized social media post, or generate/verify a zero-knowledge proof), craft a message (for example, <code>PassSeed ${nonce}</code>) for signing with the passkey.</li>
<li>Ask the user to sign the message twice via <code>navigator.credentials.get()</code> using the same message and RP scope each time.</li>
<li>Each assertion returns a P-256 ECDSA signature. Because both signatures are over the same message, client code can perform ECDSA public key recovery using the two signatures to derive the unique P-256 public key of the passkey. No private material leaves the authenticator, and the app receives only the public key bytes.</li>
<li>The recovered public key (in compressed or uncompressed form) is the PassSeed. It is reproducible on-demand by repeating the double-sign ECDSA recovery flow, with no exportation of the PassSeed public key at any time.</li>
</ol>
<p><img alt="ECDSA Public Key Recovery" loading="lazy" decoding="async" fetchpriority="auto" width="1200" height="771" src="https://backalleycoder.com/_astro/ecdsa-recovery.DWaS_t0s_Z7pUCF.webp"/></p>
<p><strong>Recovery / Rotation</strong></p>
<h2 id="converting-a-passseed-to-a-mnemonic-phrase">Converting a PassSeed to a Mnemonic Phrase</h2>
<p>To make the PassSeed user-friendly, the implementation converts the 32-byte PassSeed into a standard BIP-39 mnemonic. In practice, the PassSeed is the SHA-256 hash of the recovered public key, represented as 32 bytes. Users can write down the phrase to ensure that even if something happens to their PassSeed (e.g. they accidentially delete it), they can retain access to the keys it is capable of producing. Rerunning the ECDSA recovery process with the same passkey deterministically yields the same phrase.</p>
<p><img alt="Mnemonic Phrase Generation" loading="lazy" decoding="async" fetchpriority="auto" width="1475" height="433" src="https://backalleycoder.com/_astro/mnemonic-phrases.CQPmAFbU_RBJFC.webp"/></p>
<h2 id="deriving-other-keys-from-the-passseed">Deriving Other Keys from the PassSeed</h2>
<p>Once you have the PassSeed (public key bytes or its mnemonic-derived entropy), you can deterministically derive other cryptographic material:</p>
<ul>
<li>Bitcoin signing: use an HKDF with a domain-separated label to produce 32 bytes, clamped to the secp256k1 field, and treat it as a private key for transaction signing.</li>
<li>App/protocol-specific keys: derive additional context-labeled keys for different apps and protocols that use keys as identifiers (decentarlized social media), all from the same seed material.</li>
<li>ZKP credentials: derive scalar material for <code>BLS12-381</code> or other proving curves, enabling deterministic prover keys or presentation keys for zero-knowledge credentials.</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>The following are the code snippets for the core methods from the PassSeed TypeScript implementation, avaiable in the <a href="https://github.com/csuwildcat/passseeds">PassSeed Github repo</a>. Some of the methods reference helpers that are contained in the module, but are not shown here, for brevity.</p>
<h3 id="passseedcreate">PassSeed.create()</h3>
<p>This method orchestrates the complete WebAuthn credential creation flow, extracts the credential’s P-256 public key from the CBOR attestation object, and returns a hex-encoded SHA-256 hash of the public key bytes.</p>
<div data-collapse-height="20rem" data-collapse-label="Show All"><pre tabindex="0" data-language="typescript"><code><span><span>static async </span><span>create</span><span>(</span></span>
<span><span>  options: { user?</span><span>:</span><span> string; seedName</span><span>?:</span><span> string } </span><span>=</span><span> {}</span></span>
<span><span>): </span><span>Promise</span><span>&lt;</span><span>string</span><span>&gt;</span><span> {</span></span>
<span><span>  const now </span><span>=</span><span> new</span><span> Date</span><span>();</span></span>
<span><span>  const {</span></span>
<span><span>    user </span><span>=</span><span> &#34;</span><span>anon</span><span>&#34;</span><span>,</span></span>
<span><span>    seedName </span><span>=</span><span> `</span><span>PassSeed Seed - </span><span>${</span><span>now</span><span>.</span><span>getMonth</span><span>()</span><span> +</span><span> 1</span><span>}</span><span>/</span><span>${</span><span>now</span><span>.</span><span>getDate</span><span>()</span><span>}</span><span>/</span><span>${</span><span>now</span><span>.</span><span>getFullYear</span><span>()</span><span>}</span><span>`</span></span>
<span><span>  } = options;</span></span>
<span><span>  // Step 1: Initiate WebAuthn credential creation</span></span>
<span><span>  const credential </span><span>=</span><span> await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span><span>({</span></span>
<span><span>    publicKey</span><span>:</span><span> {</span></span>
<span><span>      challenge</span><span>:</span><span> crypto</span><span>.</span><span>getRandomValues</span><span>(</span><span>new</span><span> Uint8Array</span><span>(</span><span>32</span><span>))</span><span>,</span></span>
<span><span>      rp</span><span>:</span><span> { name</span><span>:</span><span> &#34;</span><span>PassSeed</span><span>&#34;</span><span> }</span><span>,</span></span>
<span><span>      user</span><span>:</span><span> {</span></span>
<span><span>        id</span><span>:</span><span> crypto</span><span>.</span><span>getRandomValues</span><span>(</span><span>new</span><span> Uint8Array</span><span>(</span><span>16</span><span>))</span><span>,</span></span>
<span><span>        name</span><span>:</span><span> seedName</span><span>,</span></span>
<span><span>        displayName</span><span>:</span><span> user</span></span>
<span><span>      }</span><span>,</span></span>
<span><span>      pubKeyCredParams</span><span>:</span><span> [{ type</span><span>:</span><span> &#34;</span><span>public-key</span><span>&#34;</span><span>,</span><span> alg</span><span>:</span><span> -</span><span>7</span><span> }]</span><span>,</span></span>
<span><span>      authenticatorSelection</span><span>:</span><span> {</span></span>
<span><span>        authenticatorAttachment</span><span>:</span><span> &#34;</span><span>platform</span><span>&#34;</span><span>,</span></span>
<span><span>        userVerification</span><span>:</span><span> &#34;</span><span>preferred</span><span>&#34;</span></span>
<span><span>      }</span><span>,</span></span>
<span><span>      timeout</span><span>:</span><span> 60000</span><span>,</span></span>
<span><span>      attestation</span><span>:</span><span> &#34;</span><span>direct</span><span>&#34;</span></span>
<span><span>    }</span></span>
<span><span>  }) </span><span>as</span><span> PublicKeyCredential</span><span>;</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>!</span><span>credential</span><span>)</span><span> {</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;</span><span>Credential creation cancelled</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // Step 2: Extract the public key from the attestation object</span></span>
<span><span>  const attestationObject </span><span>=</span><span> (</span><span>credential</span><span>.</span><span>response</span><span> as</span><span> AuthenticatorAttestationResponse</span><span>)</span><span>.</span><span>attestationObject</span><span>;</span></span>
<span><span>  const publicKey </span><span>=</span><span> extractPublicKeyFromAttestation</span><span>(attestationObject);</span></span>
<span><span>  const publicKeyBytes </span><span>=</span><span> concatBytes</span><span>(</span><span>new</span><span> Uint8Array</span><span>([</span><span>0x04</span><span>])</span><span>,</span><span> publicKey</span><span>.</span><span>x</span><span>,</span><span> publicKey</span><span>.</span><span>y</span><span>);</span></span>
<span></span>
<span><span>  return </span><span>seedStringFromPublicKeyBytes</span><span>(</span><span>publicKeyBytes</span><span>)</span><span>;</span></span>
<span><span>}</span></span></code></pre></div>
<h3 id="passseedget">PassSeed.get()</h3>
<p>This method retrieves an existing passkey (optionally by credential ID), performs two WebAuthn signatures over the same challenge, reconstructs the public key via ECDSA recovery by intersecting candidate points from both signatures, and returns the hex-encoded PassSeed string.</p>
<div data-collapse-height="20rem" data-collapse-label="Show All"><pre tabindex="0" data-language="typescript"><code><span><span>static async </span><span>get</span><span>(options: PassSeedGetOptions </span><span>=</span><span> {}): </span><span>Promise</span><span>&lt;</span><span>string</span><span>&gt;</span><span> {</span></span>
<span><span>  if</span><span> (</span><span>options</span><span> != </span><span>null</span><span> &amp;&amp; </span><span>typeof</span><span> options</span><span> !== </span><span>&#34;</span><span>object</span><span>&#34;</span><span>)</span><span> {</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;</span><span>PassSeed.get expects an options object when parameters are provided</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span><span>  const { credentialId</span><span>,</span><span> onBeforeSecondSignature } = options ?? {};</span></span>
<span><span>  // Step 1: Prepare a single challenge that both assertions will sign</span></span>
<span><span>  const challenge </span><span>=</span><span> crypto</span><span>.</span><span>getRandomValues</span><span>(</span><span>new</span><span> Uint8Array</span><span>(</span><span>32</span><span>));</span></span>
<span><span>  </span></span>
<span><span>  const assertionOptions</span><span>:</span><span> CredentialRequestOptions </span><span>=</span><span> {</span></span>
<span><span>    publicKey</span><span>:</span><span> {</span></span>
<span><span>      challenge</span><span>:</span><span> challenge</span><span>,</span></span>
<span><span>      timeout</span><span>:</span><span> 60000</span><span>,</span></span>
<span><span>      userVerification</span><span>:</span><span> &#34;</span><span>preferred</span><span>&#34;</span></span>
<span><span>    }</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  // If credentialId is provided, target that specific credential</span></span>
<span><span>  if</span><span> (credentialId) {</span></span>
<span><span>    assertionOptions.publicKey!.allowCredentials </span><span>=</span><span> [{</span></span>
<span><span>      type</span><span>:</span><span> &#34;</span><span>public-key</span><span>&#34;</span><span>,</span></span>
<span><span>      id</span><span>:</span><span> toArrayBuffer</span><span>(</span><span>base64urlnopad</span><span>.</span><span>decode</span><span>(credentialId))</span></span>
<span><span>    }];</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // Step 2: First signature - collect authenticator response</span></span>
<span><span>  const assertion1 </span><span>=</span><span> await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span><span>(assertionOptions) </span><span>as</span><span> PublicKeyCredential</span><span>;</span></span>
<span><span>  </span></span>
<span><span>  if</span><span> (</span><span>!</span><span>assertion1) {</span></span>
<span><span>    throw new </span><span>Error</span><span>(</span><span>&#34;</span><span>User cancelled authentication</span><span>&#34;</span><span>)</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  const response1 </span><span>=</span><span> assertion1</span><span>.</span><span>response</span><span> as</span><span> AuthenticatorAssertionResponse</span><span>;</span></span>
<span><span>  const signature1 </span><span>=</span><span> response1</span><span>.</span><span>signature</span><span>;</span></span>
<span><span>  const authenticatorData1 </span><span>=</span><span> response1</span><span>.</span><span>authenticatorData</span><span>;</span></span>
<span><span>  const clientData1 </span><span>=</span><span> response1</span><span>.</span><span>clientDataJSON</span><span>;</span></span>
<span></span>
<span><span>  // Capture the credential ID from the first assertion if not already provided</span></span>
<span><span>  const usedCredentialId </span><span>=</span><span> credentialId</span></span>
<span><span>    ?</span><span> toArrayBuffer</span><span>(</span><span>base64urlnopad</span><span>.</span><span>decode</span><span>(credentialId))</span></span>
<span><span>    :</span><span> assertion1</span><span>.</span><span>rawId</span><span>;</span></span>
<span></span>
<span><span>  if</span><span> (onBeforeSecondSignature) {</span></span>
<span><span>    await </span><span>onBeforeSecondSignature</span><span>()</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // Step 3: Second signature over the same challenge</span></span>
<span><span>  assertionOptions</span><span>.</span><span>publicKey</span><span>!</span><span>.</span><span>challenge</span><span> =</span><span> challenge;</span></span>
<span><span>  assertionOptions</span><span>.</span><span>publicKey</span><span>!</span><span>.</span><span>allowCredentials</span><span> =</span><span> [{</span></span>
<span><span>    type</span><span>:</span><span> &#34;</span><span>public-key</span><span>&#34;</span><span>,</span></span>
<span><span>    id</span><span>:</span><span> usedCredentialId</span></span>
<span><span>  }];</span></span>
<span></span>
<span><span>  const assertion2 </span><span>=</span><span> await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span><span>(assertionOptions) </span><span>as</span><span> PublicKeyCredential</span><span>;</span></span>
<span><span>  </span></span>
<span><span>  if</span><span> (</span><span>!</span><span>assertion2) {</span></span>
<span><span>    throw new </span><span>Error</span><span>(</span><span>&#34;</span><span>User cancelled second authentication</span><span>&#34;</span><span>)</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  const response2 </span><span>=</span><span> assertion2</span><span>.</span><span>response</span><span> as</span><span> AuthenticatorAssertionResponse</span><span>;</span></span>
<span><span>  const signature2 </span><span>=</span><span> response2</span><span>.</span><span>signature</span><span>;</span></span>
<span><span>  const authenticatorData2 </span><span>=</span><span> response2</span><span>.</span><span>authenticatorData</span><span>;</span></span>
<span><span>  const clientData2 </span><span>=</span><span> response2</span><span>.</span><span>clientDataJSON</span><span>;</span></span>
<span></span>
<span><span>  // Step 4: Recover the public key from both signatures and intersect candidates</span></span>
<span><span>  const clientHash1 </span><span>=</span><span> sha256</span><span>(</span><span>new</span><span> Uint8Array</span><span>(clientData1));</span></span>
<span><span>  const signedData1 </span><span>=</span><span> concatBytes</span><span>(</span><span>new</span><span> Uint8Array</span><span>(authenticatorData1)</span><span>,</span><span> clientHash1);</span></span>
<span><span>  const messageHash1 </span><span>=</span><span> sha256</span><span>(signedData1);</span></span>
<span></span>
<span><span>  const clientHash2 </span><span>=</span><span> sha256</span><span>(</span><span>new</span><span> Uint8Array</span><span>(clientData2));</span></span>
<span><span>  const signedData2 </span><span>=</span><span> concatBytes</span><span>(</span><span>new</span><span> Uint8Array</span><span>(authenticatorData2)</span><span>,</span><span> clientHash2);</span></span>
<span><span>  const messageHash2 </span><span>=</span><span> sha256</span><span>(signedData2);</span></span>
<span></span>
<span><span>  const { r</span><span>:</span><span> r1</span><span>,</span><span> s</span><span>:</span><span> s1 } </span><span>=</span><span> decodeDerSignature</span><span>(signature1);</span></span>
<span><span>  const { r</span><span>:</span><span> r2</span><span>,</span><span> s</span><span>:</span><span> s2 } </span><span>=</span><span> decodeDerSignature</span><span>(signature2);</span></span>
<span></span>
<span><span>  const candidates1 </span><span>=</span><span> recoverPublicKeys</span><span>(r1</span><span>,</span><span> s1</span><span>,</span><span> messageHash1);</span></span>
<span><span>  const candidates2 </span><span>=</span><span> recoverPublicKeys</span><span>(r2</span><span>,</span><span> s2</span><span>,</span><span> messageHash2);</span></span>
<span></span>
<span><span>  const candidateMap </span><span>=</span><span> new</span><span> Map</span><span>&lt;</span><span>string</span><span>,</span><span> NoblePoint</span><span>&gt;();</span></span>
<span><span>  for</span><span> (const candidate </span><span>of</span><span> candidates1) {</span></span>
<span><span>    candidateMap.set(</span><span>pointToKey</span><span>(</span><span>candidate</span><span>)</span><span>,</span><span> candidate);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  const intersection: NoblePoint[] </span><span>=</span><span> [];</span></span>
<span><span>  for</span><span> (const candidate </span><span>of</span><span> candidates2) {</span></span>
<span><span>    const key </span><span>=</span><span> pointToKey</span><span>(candidate);</span></span>
<span><span>    if</span><span> (</span><span>candidateMap.has(</span><span>key</span><span>)</span><span>) {</span></span>
<span><span>      intersection</span><span>.</span><span>push</span><span>(candidate);</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  if</span><span> (</span><span>intersection</span><span>.</span><span>length</span><span> !==</span><span> 1</span><span>) {</span></span>
<span><span>    throw new </span><span>Error</span><span>(</span><span>&#34;</span><span>Unable to recover a unique public key from signatures</span><span>&#34;</span><span>)</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  const publicKeyBytes </span><span>=</span><span> intersection[</span><span>0</span><span>]</span><span>.</span><span>toBytes</span><span>(</span><span>false</span><span>);</span></span>
<span><span>  return </span><span>seedStringFromPublicKeyBytes</span><span>(publicKeyBytes);</span></span>
<span><span>}</span></span></code></pre></div>
<h3 id="passseedtomnemonic">PassSeed.toMnemonic()</h3>
<p>This method converts a 32-byte PassSeed (as bytes or hex) into a human-readable BIP-39 mnemonic phrase for backup and recovery, optionally truncating to 16 bytes for a 12-word phrase before handing entropy to <code>bip39.entropyToMnemonic</code> with the English wordlist.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>static async </span><span>toMnemonic</span><span>(passSeed: Uint8Array </span><span>|</span><span> string</span><span>,</span><span> wordCount: </span><span>12</span><span> |</span><span> 24</span><span> =</span><span> 24</span><span>): </span><span>Promise</span><span>&lt;</span><span>string</span><span>&gt;</span><span> {</span></span>
<span><span>  const passSeedBytes </span><span>=</span><span> typeof</span><span> passSeed </span><span>===</span><span> &#34;</span><span>string</span><span>&#34;</span><span> ?</span><span> PassSeed</span><span>.</span><span>hexToBytes</span><span>(passSeed) </span><span>:</span><span> passSeed;</span></span>
<span><span>  if</span><span> (</span><span>passSeedBytes.length !== 32</span><span>)</span><span> {</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;</span><span>PassSeed must be exactly 32 bytes</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span><span>  if</span><span> (</span><span>wordCount</span><span> !== 12 &amp;&amp; </span><span>wordCount</span><span> !== 24</span><span>)</span><span> {</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;</span><span>Mnemonic word count must be 12 or 24</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  const entropyBytes </span><span>=</span><span> wordCount </span><span>===</span><span> 12</span><span> ?</span><span> passSeedBytes</span><span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span><span> 16</span><span>) </span><span>:</span><span> passSeedBytes;</span></span>
<span><span>  const entropyHex </span><span>=</span><span> bytesToHex</span><span>(entropyBytes);</span></span>
<span><span>  return bip39.entropyToMnemonic(entropyHex</span><span>,</span><span> bip39.wordlists.english);</span></span>
<span><span>}</span></span></code></pre>
<h2 id="threat-model-and-constraints">Threat Model and Constraints</h2>
<p>The authenticator still enforces RP binding and user verification before issuing signatures, so phishing resistance mirrors standard passkeys. The host page sees two signatures and the recovered public key, values one must assume the host can exfiltrate. Because the same message is signed twice, replay risk is mitigated by including nonces, RP ID, and a strict prefix so signatures cannot be repurposed. Syncable passkeys inherit the platform’s end-to-end encrypted sync features.</p>
<h2 id="why-not-use-the-webauthns-prf-or-large-blob-features">Why not use the WebAuthn’s PRF or Large Blob features?</h2>
<p>The WebAuthn specification has defined a <a href="https://w3c.github.io/webauthn/#test-vectors-extensions-prf">PRF extension</a> for deterministically generating per-credential secrets, and a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions#largeblob">Large Blob extension</a>, which can be used to encrypt and save a randomly generated secret that is synced across the user’s devices, both of which could achieve the desired ends. The problem is API support: PRF and Large Blob features are not implemented across browsers today, and there is no signal that either will be in the near future. That makes it hard to rely on in production if you need your app to work everywhere.</p>
<p>PassSeeds can even be used to create a polyfill for the PRF feature: by deterministically recovering a stable cryptographic value from the passkey signature flow (the public key), you can use that value to generate deterministic, cryptographic values based on input values, which will regenerate the same value for the same input, every time. If the tradeoffs of PassSeeds are acceptable, you can integrate PRF-reliant use cases in apps today, across all browsers. I plan on writing a PRF polyfill soon, so stay tuned.</p>
<h2 id="demo--npm-package">Demo &amp; NPM Package</h2>
<p>The following is a demo page that allows you to create PassSeeds, reload the page to test regeneration (via the ECDSA recovery process), and view the Mnemonic phrase of PassSeeds you’ve created: <a href="https://backalleycoder.com/passseeds/">PassSeeds Demo</a></p>
<p>You can also include PassSeeds in your Web apps via NPM: <a href="https://www.npmjs.com/package/passseeds">PassSeeds NPM Package</a></p> </article></div>
  </body>
</html>
