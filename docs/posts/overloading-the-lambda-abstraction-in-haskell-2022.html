<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://acatalepsie.fr/posts/overloading-lambda.html">Original</a>
    <h1>Overloading the lambda abstraction in Haskell (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><header><p><time>Dec 10, 2022</time></p></header><p>About two years ago, I started working on a little embedded
domain-specific language (EDSL) called <a href="https://acatalepsie.fr/projects/achille">achille</a>, using Haskell. Because this EDSL
has its own notion of <em>morphisms</em> <code>Recipe m a b</code> from
<code>a</code> to <code>b</code>, I was looking for a way to let users
write such morphisms using regular Haskell functions and the syntax for
lambda abstraction, <code>\x -&gt; ...</code>.</p>
<p>As recently as 5 days ago, I was still convinced that there was no
way to do such a thing without requiring a lot of engineering effort,
either through GHC compiler plugins or with Template Haskell — two
things I’d rather stay far away from.</p>
<p>Indeed,</p>
<ul>
<li><p><a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Arrow.html">Haskell’s
<code>Arrow</code> abstraction</a> and the related <a href="https://www.haskell.org/arrows/syntax.html"><code>proc</code>
notation</a> are supposed to enable just that, but they don’t work as
intended. It’s a difficult thing to <a href="https://github.com/tomjaguarpaw/Arrows2/issues/1">implement
properly</a> and <a href="https://github.com/lexi-lambda/ghc-proposals/blob/constraint-based-arrow-notation/proposals/0000-constraint-based-arrow-notation.md">if
proposals to fix it</a> have been discussed at large, nothing made it
upstream.</p>
<p>But even if the notation worked properly (and was convenient to use),
it is quite common to work with morphisms <code>k a b</code> that cannot
possibly embed <em>all</em> Haskell functions <code>a -&gt; b</code>,
preventing us to use this notation as we would like, simply because we
cannot define a suitable instance of <code>Arrow k</code>.</p>
<p>There are <em>solutions</em> to this, like the great <a href="https://hackage.haskell.org/package/overloaded-0.3.1">overloaded</a>
package, that fixes the <code>proc</code> notation and crucially makes
it available to many categories that are not <code>Arrow</code>s. This
may very well be exactly what you — the reader — need to resolve this
problem.</p>
<p>However, I want to avoid making my library rely on compiler plugins
at all cost, and think the <code>proc</code> notation, while way better
than raw <code>Arrow</code> combinators, is still too verbose and
restrictive. <em>I want to write lambdas</em>, and <em>I want to apply
my morphisms just like any other Haskell function</em>. So no
luck.</p></li>
</ul>
<ul>
<li><p>There is also this wonderful paper from Conal Elliott: <a href="http://conal.net/papers/compiling-to-categories/">“Compiling to
Categories”</a>.</p>
<p>This is very cool, but also an experimental research project. It’s
very unstable and unreliable. It’s not packaged on Hackage so fairly
difficult to install as a library, and looks hard to maintain precisely
because it’s a compiler plugin.</p>
<p>And again, not every category is cartesian-closed, especially if
exponentials <em>have to be plain Haskell functions</em> — which <a href="https://github.com/compiling-to-categories/concat">concat</a>
enforces.</p></li>
</ul>
<p><strong>However</strong>, 5 days ago I stumbled upon some paper by
sheer luck. And well, I’m happy to report that <strong>“overloading” the
lambda abstraction is <em>completely doable</em></strong>. Not only
that: it is actually <em>very easy</em> and doesn’t require any advanced
Haskell feature, nor any kind of metaprogramming. No. library.
needed.</p>
<p>I cannot emphasize enough how powerful the approach appears to
be:</p>
<ul>
<li><p>You can define your very own <code>proc</code> notation for
<em>any</em> category you desire.</p></li>
<li><p>That is, as soon as you can provide an instance for
<code>Category k</code>, you can <em>already</em> overload the lambda
abstraction to write your morphisms. Even if your category isn’t an
instance of <code>Arrow</code> because of this <code>arr</code>
function. <em>You do not have to be able to embed pure Haskell functions
in your category</em>.</p></li>
<li><p>The resulting syntax is way more intuitive than the
<code>proc</code> notation, simply because you can manipulate morphims
<code>k a b</code> of your category as <em>plain old Haskell
functions</em>, and therefore compose them and apply them to variables
just as any other Haskell function, using the same syntax.</p></li>
<li><p>Implementing the primitives for overloading the lambda
abstraction is a matter of about 10 lines of Haskell.</p></li>
</ul>
<p>It’s in fact so simple that I suspect it must already be documented
<em>somewhere</em>, but for the life of me I couldn’t find anything. So
here you go. I think this will be very useful for EDSL designers out
here.</p>
<h2 id="a-toy-dsl-for-flow-diagrams">A toy DSL for flow diagrams</h2>
<p>So let’s say our EDSL is supposed to encode flow diagrams, with boxes
and wires. Boxes have distinguished inputs and outputs, and wires flow
from outputs of boxes to inputs of other boxes.</p>
<p>We can encode <em>any</em> flow diagram using the following
operations:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Flow</span> a b <span>where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span>-- just a wire</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span>Id</span><span> ::</span> <span>Flow</span> a a</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span>-- putting two boxes one after the other</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span>Seq</span><span> ::</span> <span>Flow</span> a b <span>-&gt;</span> <span>Flow</span> b c <span>-&gt;</span> <span>Flow</span> a c</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span>-- putting two boxes one next to the other</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span>Par</span><span> ::</span> <span>Flow</span> a b <span>-&gt;</span> <span>Flow</span> c d <span>-&gt;</span> <span>Flow</span> (a, c) (b, d)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span>-- box that duplicates its input</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span>Dup</span><span> ::</span> <span>Flow</span> a (a, a)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span>-- box that gets rid of its input</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span>Void</span><span> ::</span> <span>Flow</span> a ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span>-- box that projects on first input</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span>Fst</span><span> ::</span> <span>Flow</span> (a, b) a</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span>-- box that projects on second input</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span>Snd</span><span> ::</span> <span>Flow</span> (a, b) b</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span>-- finally, we embed any pure function into a box</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span>Embed</span><span> ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>Flow</span> a b</span></code></pre></div>
<p>There are probably enough constructors here to claim it is a
cartesian category, but I didn’t double check and it doesn’t really
matter here.</p>
<p>I think we can agree that although this may very well be the right
abstraction to internally transform and reason about diagrams, what an
<strong>awful</strong>, <strong>awful</strong> way to write them. Even
if we provided a bunch of weird infix operators for some of the
constructors, only few Haskellers would be able to make sense of this
gibberish.</p>
<p>What <em>I</em> want is a way to write these diagrams down using
lambda abstractions and variable bindings, that get translated to this
internal representation.</p>
<p>We <em>can</em> give an instance for both <code>Category Flow</code>
and <code>Arrow Flow</code>:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Control.Category</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Control.Arrow</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Category</span> <span>Flow</span> <span>where</span> <span>id</span> <span>=</span> <span>Id</span> ; g <span>.</span> f <span>=</span> <span>Seq</span> f g</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Arrow</span> <span>Flow</span> <span>where</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  arr     <span>=</span> <span>Embed</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  first f <span>=</span> <span>Par</span> f <span>id</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  second  <span>=</span> <span>Par</span> <span>id</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  (<span>***</span>)   <span>=</span> <span>Par</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  f <span>&amp;&amp;&amp;</span> g <span>=</span> <span>Seq</span> <span>Dup</span> (<span>Par</span> f g)</span></code></pre></div>
<p>We can even give a custom implementation for every <code>Arrow</code>
operation. And yet, we’re left with nothing more than disappointment
when we attempt to use the <code>proc</code> notation: Haskell’s
desugarer for the <code>proc</code> notation is <em>really
dumb</em>.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>{-# LANGUAGE Arrows #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>t ::</span> <span>Flow</span> (a, b) (b, a)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>t <span>=</span> proc (x, y) <span>-&gt;</span> returnA <span>-&lt;</span> (y, x)</span></code></pre></div>
<p>If you print the term, you get something like this:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>Seq</span> (<span>Embed</span>(_)) (<span>Seq</span> (<span>Embed</span>(_)) (<span>Embed</span>(_)))</span></code></pre></div>
<p>We just wrote <code>swap</code>. But Haskell <em>doesn’t even
try</em> to use the operations we’ve just defined in
<code>Arrow Flow</code>, and just lifts pure Haskell functions using
<code>arr</code>. The terms you get are <strong>not
inspectable</strong>, they are black boxes. Not. good. Granted,
morphisms <code>Fst</code> and <code>Snd</code> are not part of the
interface of <code>Arrow</code>, so this example is a bit unfair. But if
you’ve used the <code>proc</code> notation at all, you know this isn’t
an isolated incident, and <code>arr</code> eventually always shows
up.</p>
<p>What I’m gonna show you is how to enable the following,
<em>straight-to-the-point</em> syntax:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>t ::</span> <span>Flow</span> (a, b) (b, a)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>t <span>=</span> flow \(<span>Tup</span> x y) <span>-&gt;</span> <span>Tup</span> y x</span></code></pre></div>
<p>That reduces to the following term:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>t <span>=</span> <span>Seq</span> <span>Dup</span> (<span>Par</span> (<span>Seq</span> <span>Id</span> <span>Snd</span>) (<span>Seq</span> <span>Id</span> <span>Fst</span>))</span></code></pre></div>
<p>How beautiful! <em>Sure</em>, it’s not the most <em>optimal</em>
representation, and a traversal over the term could simplify it by
removing <code>Seq Id</code>, but at the very least it’s fully
<em>inspectable</em>.</p>
<h2 id="the-solution">The solution</h2>
<p>Now my solution stems from this truly <em>amazing</em> paper from
Jean-Philippe Bernardy and Arnaud Spiwack: <a href="https://arxiv.org/abs/2103.06195v2">Evaluating Linear Functions to
Symmetric Monoidal Categories</a> (SMCs).</p>
<p>In this paper, they explain that if CCCs are models of the simply
typed lambda calculus, it is “well-known” that SMCs are models of the
<em>linear</em> simply-typed lambda calculus. And thus, they show how
they are able to <em>evaluate</em> linear functions (as in, Linear
Haskell linear functions) into arrows in any target SMC of your
choice.</p>
<p>They even released a library for that: <a href="https://hackage.haskell.org/package/linear-smc-1.0.1">linear-smc</a>.
I implore you to go and take a look at both the paper and the library,
it’s very <em>very</em> smart. Sadly, it seems to have gone mostly
unnoticed.</p>
<p><em>This</em> paper was the tipping point. Because my target category
is cartesian (ergo, I can duplicate values), I suspected that I could
remove almost all the complex machinery they had to employ to go from a
free cartesian category over a SMC to the underlying SMC. I was hopeful
that I could ditch Linear Haskell, too.</p>
<p>And, relieved as I am, I can tell you that yes: not only can all of
this be simplified (if you don’t care about SMCs or Linear Haskell), but
everything can be implemented in a handful lines of Haskell code.</p>
<h3 id="interface">Interface</h3>
<p>So, the first thing we’re gonna look at is the <em>interface</em>
exposed to the users of your EDSL. These are the magic primitives that
we will have to implement.</p>

<p>First there is this (abstract) type <code>Port r a</code>. It is
meant to represent the <strong>output</strong> of a box (in our flow
diagrams) carrying information of type <code>a</code>.</p>
<p>Because the definition of <code>Port r a</code> is <em>not</em>
exported, there is crucially <em>no way</em> for the user to retrieve a
value of type <code>a</code> from it. Therefore, to use a “port
variable” in any meaningful way, they can <strong>only</strong> use the
operations on ports that <em>you</em> — the library designer —
export.</p>
<p>And now, the two other necessary primitives:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>encode ::</span> <span>Flow</span> a b <span>-&gt;</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>decode ::</span> (<span>forall</span> r<span>.</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b) <span>-&gt;</span> <span>Flow</span> a b</span></code></pre></div>
<ul>
<li><p><code>encode</code> transforms a morphism from your category —
here a diagram <code>Flow a b</code> — into a Haskell functions <em>on
ports</em>. By exporting this function, you enable users to apply any
morphism <em>in your category</em> to the “port variables” they have at
their disposal. And precisely <em>only</em> those operations.</p></li>
<li><p><code>decode</code> does the <em>reverse</em> translation. It
takes any Haskell function <em>on ports</em>, and converts it back into
a morphism in your category. Well, not <em>any</em> function. Only
functions that are <em>closed</em> with respect to port variables.
That’s why there is this type variable <code>r</code> in
<code>Port r a</code>. Because all the operations on ports exported by
this interface share the same <code>r</code> between all inputs and
outputs, there is <em>no way</em> to use a port variable defined outside
of a function over ports, and still have the function be quantified over
this <code>r</code>.</p>
<p>The same kind of trick, I believe, is used in <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Monad-ST.html">Control.Monad.ST</a>.
This is really really neat.</p></li>
</ul>
<hr/>
<p><code>encode</code> and <code>decode</code> can be defined for any
<code>Category k</code>. But if <code>k</code> is <em>also</em>
cartesian, we can provide the following additional primitives:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>pair ::</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b <span>-&gt;</span> <span>Port</span> r (a, b)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>unit ::</span> <span>Port</span> r ()</span></code></pre></div>
<p>And… that’s all you need!</p>
<hr/>
<p>Now of course you’re free to include in your API your own morphisms
converted into functions over ports. This would allow you to fully hide
from the world your internal representation of diagrams. And to do that,
you only need to use the previous primitives:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>flow <span>=</span> decode</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>fst</span><span> ::</span> <span>Port</span> r (a, b) <span>-&gt;</span> <span>Port</span> r a</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>fst</span> <span>=</span> encode <span>Fst</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span>snd</span><span> ::</span> <span>Port</span> r (a, b) <span>-&gt;</span> <span>Port</span> r b</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span>snd</span> <span>=</span> encode <span>Snd</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>split ::</span> <span>Port</span> r (a, b) <span>-&gt;</span> (<span>Port</span> r a, <span>Port</span> r b)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>split p <span>=</span> (<span>fst</span> p, <span>snd</span> p)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span>pattern</span> <span>Tup</span> x y <span>&lt;-</span> (split <span>-&gt;</span> (x, y))</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span>where</span> <span>Tup</span> x y <span>=</span> pair x y</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span>void ::</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r ()</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>void <span>=</span> encode <span>Void</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span>box ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>box f <span>=</span> encode (<span>Embed</span> f)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span>(&gt;&gt;) ::</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b <span>-&gt;</span> <span>Port</span> r b</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>x <span>&gt;&gt;</span> y <span>=</span> <span>snd</span> (pair x y)</span></code></pre></div>
<p>You can see I use <code>PatternSynonyms</code> and
<code>ViewPatterns</code> to define this <code>Tup</code> syntax that
appeared earlier. Because I defined this <code>(&gt;&gt;)</code>
operator to discard its first port, we can use <code>QualifiedDo</code>
to have an even nicer syntax for putting all ports in parallel and
discard all but the last one:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>box1 ::</span> <span>Port</span> r <span>Text</span> <span>-&gt;</span> <span>Port</span> r (<span>Int</span>, <span>Int</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>box2 ::</span> <span>Port</span> r <span>Text</span> <span>-&gt;</span> <span>Port</span> r <span>Bool</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>box3 ::</span> <span>Port</span> r <span>Int</span> <span>-&gt;</span> <span>Port</span> r ()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>box4 ::</span> <span>Port</span> r <span>Int</span> <span>-&gt;</span> <span>Port</span> r ()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span>diag ::</span> <span>Flow</span> (<span>Text</span>, <span>Text</span>) <span>Bool</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>diag <span>=</span> flow \(<span>Tup</span> x y) <span>-&gt;</span> Flow.do</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>Tup</span> a b <span>=</span> box1 x</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  box3 a</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  box4 b</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  box2 y</span></code></pre></div>
<p>Because <code>(&gt;&gt;)</code> is defined in such a way,
<code>box1</code>, <code>box3</code> and <code>box4</code> <em>will
appear</em> in the resulting diagram even though their output gets
discarded. Were we to define <code>x &gt;&gt; y = y</code>, they would
simply disappear altogether. This technique gives a lot of control over
how the translation should be specified.</p>
<p>Finally and most importantly, <code>box</code> is the
<strong>only</strong> way to introduce pure Haskell functions
<code>a -&gt; b</code> into a black box in our diagram. For this reason,
we can be sure that <code>Embed</code> will never show up if
<code>box</code> isn’t used explicitely by the user. If your category
has no embedding of Haskell functions, or does <em>not</em> export it,
it’s impossible to insert them, ever.</p>
<h3 id="implementation">Implementation</h3>
<p>And now, the big reveal… <code>Ports r a</code> are just morphisms
from <code>r</code> to <code>a</code> in your category!</p>
<p><strong>This</strong> is the implementation of the primitives from
earlier.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Port</span> r a <span>=</span> <span>P</span> {<span> unPort::</span> <span>Flow</span> r a }</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span>encode ::</span> <span>Flow</span> a b <span>-&gt;</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>encode f (<span>P</span> x) <span>=</span> <span>P</span> (f <span>.</span> x)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span>decode ::</span> (<span>forall</span> r<span>.</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b) <span>-&gt;</span> <span>Flow</span> a b</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>decode f <span>=</span> unPort (f (<span>P</span> <span>id</span>))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span>pair ::</span> <span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b <span>-&gt;</span> <span>Port</span> r (a, b)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>pair (<span>P</span> x) (<span>P</span> y) <span>=</span> <span>P</span> (x <span>&amp;&amp;&amp;</span> y)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span>unit ::</span> <span>Port</span> r ()</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>unit <span>=</span> <span>P</span> <span>Void</span></span></code></pre></div>
<p>And indeed, if you consider <code>Port r a</code> to represent paths
from some input <code>r</code> to output <code>a</code> in a diagram,
then by squinting your eyes a bit the <em>meaning</em> (in your
category) of this interface makes sense.</p>
<ul>
<li><p>For <code>encode</code>, surely if you know how to go from
<code>a</code> to <code>b</code>, and from <code>r</code> to
<code>a</code>, then you know how to go from <code>r</code> to
<code>b</code>: that’s just composition, hence
<code>(.)</code>.</p></li>
<li><p>For <code>decode</code>, you have as assumption that from any
point <code>r</code> in a diagram, you know how to transform a path from
<code>r</code> to <code>a</code> into a path from <code>r</code> to
<code>b</code>. In particular, because this holds for any
<code>r</code>, this holds for <code>a</code>. And you know a path from
<code>a</code> to <code>a</code>, it’s the identity! This gets you a
path from <code>a</code> to <code>b</code>.</p></li>
</ul>
<p>It would appear <code>encode</code> and <code>decode</code> being
inverse of one another is yet another instance of the Yoneda lemma, but
I’m not a categorician so I will not attempt to explain this any more
than that, apologies.</p>
<p>Still, the sheer simplicity of this technique is mesmerizing to me.
It kinda looks like doing CPS, but it <em>isn’t</em> CPS. Quoting the
paper:</p>
<blockquote>
<p>the encoding from <code>k a b</code> to
<code>P k r a ⊸ P k r b</code> can be thought of as a transformation to
continuation-passing-style (cps), albeit reversed — perhaps a
“prefix-passing-style” transformation.</p>
</blockquote>
<p>Apparently it is <em>the dual of CPS</em> or something.</p>
<p>And you can double-check that in order to implement
<code>encode</code> and <code>decode</code> you just need
<code>id</code> and <code>(.)</code>. Now to allow more stuff than just
composing morphisms as functions, more primitives can be added, like
<code>pair</code> using <code>(&amp;&amp;&amp;)</code>, and
<code>unit</code> using <code>Void :: Flow a ()</code> — which may or
may not be available, dependending on the kind of categories you’re
working with.</p>
<hr/>
<h3 id="some-things-to-be-wary-of">Some things to be wary of</h3>
<p>Ok, so now we’ve seen how to successfully “overload” the lambda
abstraction. But there is one quirk that I think you should be aware
of.</p>
<h4 id="preventing-too-much-duplication-in-the-diagram">Preventing (too
much) duplication in the diagram</h4>
<p>If you look at the definition of <code>split p</code>, you can see
that the input <code>p</code> gets duplicated in the two output ports.
If both of them are used in a given diagram, <code>p</code> will appear
at least <em>twice</em> in this diagram. Now in the abstract setting of
category theory, duplication in your diagram doesn’t matter because of
the equivalences and laws that equate diagrams.</p>
<p>However, we’re trying to encode <em>useful</em> things. My original
motivation for going to this deep end was modeling flow diagrams of
<em>effectful computations</em>, for the new version of <a href="https://acatalepsie.fr/projects/achille">achille</a>. You could imagine changing the
<code>Embed</code> constructor of <code>Flow</code> to the
following:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>Embed</span><span> ::</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> <span>Flow</span> a b</span></code></pre></div>
<p>From then on, encoded flow diagrams are meant to be <em>executed</em>
— and even parallelised for free, how neat — but I hope you see now why
we should <strong>never ever</strong> duplicate any such
<code>Embed</code> box anymore. In the paper, that’s why they argue it’s
important to restrict yourself to monoidal categories and linear
functions, and make <code>copy</code> an explicit operation in your
syntax.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>copy ::</span> <span>Port</span> r a <span>%</span><span>1</span> <span>-&gt;</span> (<span>Port</span> r a, <span>Port</span> r a)</span></code></pre></div>
<p>Indeed, the type system will prevent you to use a variable more than
once without explicitly inserting <code>copy</code>. However, everything
has to be made linear and this has huge implications on the
user-friendliness of the overall syntax. I’ve also found error messages
from Linear Haskell to be pretty uninformative — and <code>let</code>
bindings are <em>not</em> linear, <strong>what??</strong>.</p>
<p>Instead, I came up with a solution I’m fairly happy with. There is a
trick: we introduce a new primitive.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>(&gt;&gt;=) ::</span> <span>Port</span> r a <span>-&gt;</span> (<span>Port</span> r a <span>-&gt;</span> <span>Port</span> r b) <span>-&gt;</span> <span>Port</span> r b</span></code></pre></div>
<p>Now of course, you could just implement it as
<code>x &gt;&gt;= f = f x</code>, but that’s precisely what we want to
<em>avoid</em>. No, instead, I force the evaluation of <code>x</code>,
and <em>then</em> evaluate <code>f</code> applied to a box that simply
returns the pre-computed value, <em>side-effect free</em>. So a box gets
duplicated, sure, but this box does <em>nothing</em>. What I am now
noticing while writing this down, is that introducing this
<code>Bind</code> operator makes the diagram non-inspectable again,
oops. I can still run it of course, but this is a problem for future
me.</p>
<p>Anyway, the benefit of this <code>(&gt;&gt;=)</code> operator is that
it’s very convenient with <code>QualifiedDo</code>:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>diag ::</span> <span>Flow</span> <span>FilePath</span> <span>Bool</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>diag <span>=</span> flow \src <span>-&gt;</span> Flow.do</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span>Tup</span> a b <span>&lt;-</span> box1 src</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  box3 a</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  box4 (box2 b)</span></code></pre></div>
<p>You just have to stop using <code>let</code> and you’re good to go.
What’s <em>remarkable</em> in the syntax is that these
<em>effectful</em> boxes are used as plain old
<strong>functions</strong>. Therefore there is <em>no need</em> to
clutter the syntax with <code>&lt;$&gt;</code>, <code>&gt;&gt;=</code>,
<code>pure</code>, <code>-&lt;</code>, <code>returnA</code> and a bind
for every single arrow like in the <code>proc</code> notation: you just
compose and apply them like regular functions — even when they are
effectful.</p>
<h4 id="compile-vs.-evaluate">Compile vs. Evaluate</h4>
<p>Now the paper is called “Evaluating […]” and says there is a runtime
cost to pay for the translation. Considering how simple <em>this</em>
implementation is, and how the target is fully first-order (well,
without <code>(&gt;&gt;=)</code>), I wouldn’t be surprised if GHC is
actually able to fully unfold and translate to category morphisms at
compile-time. But I’m not an expert Haskell developer by any means and
have no clue how one would go about checking this, so if anyone does, <a href="mailto:lucas@escot.me">please tell me</a>!</p>
<h4 id="expressive-power">Expressive power</h4>
<p>I’m very curious to see which kind of categories you can “compile”
Haskell functions to using this technique. I didn’t expect converting to
cartesian category’s morphisms to be so straightforward, and I’m looking
forward to see whether there is any fundamental limitation preventing us
to do the same for CCCs.</p>
<h4 id="recursive-morphisms-and-infinite-structures">Recursive morphisms
and infinite structures</h4>
<p><a href="https://www.reddit.com/r/haskell/comments/zi9mxp/comment/izqh96d/?utm_source=share&amp;utm_medium=web2x&amp;context=3">Someone
asked on Reddit</a> whether recursive morphisms can be written out using
this syntax, <em>wihtout</em> making <code>decode</code> loop forever.
I’ve thought about it for a bit, and I think precisely because this is
not <em>CPS</em> and we construct morphisms <code>k a b</code> rather
than Haskell functions, <code>decode</code> should not be a problem. It
<em>should</em> produce recursive morphisms where recursive occurences
are guarded by constructors. Because of laziness, looping is not a
concern.</p>
<p>But I haven’t tried this out yet. Since in <a href="https://acatalepsie.fr/projects/achille">achille</a> recursive <em>recipes</em> can be
quite useful, I want to support them, and so I will <em>definitely</em>
investigate further.</p>
<hr/>
<p>Thank you for reading! I hope this was or will be useful to some of
you. I am also very grateful for Bernardy and Spiwack’s fascinating
paper and library, it quite literally made my week.</p>
<p>Feel free to go on <a href="https://www.reddit.com/r/haskell/comments/zi9mxp/overloading_the_lambda_abstraction_in_haskell/">the
r/haskell thread</a> related to this post.</p>
<p>Till next time, perhaps when I manage to release the next version of
<a href="https://acatalepsie.fr/projects/achille">achille</a>, using this very trick that I
had been desperately looking for in the past 2 years.</p></div></div>
  </body>
</html>
