<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rybicki.io/blog/2023/06/27/rust-crate-into-typescript-library.html">Original</a>
    <h1>Using WebAssembly to turn Rust crates into fast TypeScript libraries</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Hi there - my name’s Chris.
I’m an avid software engineer that enjoys building things.</p>

<p>In this post, I’ll walk through how you can create an <a href="https://www.npmjs.com/">npm</a> package that re-exports the APIs of a Rust crate for use in TypeScript or JavaScript.
For demonstration I’ll use a Apache-2.0 / MIT licensed crate named <a href="https://crates.io/crates/annotate-snippets">annotate-snippets</a>, which provides an API for pretty-printing error diagnostics like the one shown below - though the technique can be applied to any crate.</p>

<p>Here’s an example the final library being used, and the formatted diagnostic it prints out:</p>

<div><div><pre><code><span>import</span> <span>{</span> <span>annotateSnippet</span> <span>}</span> <span>from</span> <span>&#34;</span><span>annotate-snippets</span><span>&#34;</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>annotateSnippet</span><span>({</span>
  <span>label</span><span>:</span> <span>&#34;</span><span>mismatched types</span><span>&#34;</span><span>,</span>
  <span>id</span><span>:</span> <span>&#34;</span><span>E0308</span><span>&#34;</span><span>,</span>
  <span>annotationType</span><span>:</span> <span>&#34;</span><span>error</span><span>&#34;</span><span>,</span>
<span>},</span> <span>[],</span> <span>[{</span>
  <span>source</span><span>:</span> <span>`) -&gt; Option&lt;String&gt; {
    for ann in annotations {
        match (ann.range.0, ann.range.1) {
            (None, None) =&gt; continue,
            (Some(start), Some(end)) if start &gt; end_index =&gt; continue,
            (Some(start), Some(end)) if start &gt;= start_index =&gt; {
                let label = if let Some(ref label) = ann.label {
                    format!(&#34; {}&#34;, label)
                } else {
                    String::from(&#34;&#34;)
                };

                return Some(format!(
                    &#34;{}{}{}&#34;,
                    &#34; &#34;.repeat(start - start_index),
                    &#34;^&#34;.repeat(end - start),
                    label
                ));
            }
            _ =&gt; continue,
        }
    }`</span><span>,</span>
  <span>lineStart</span><span>:</span> <span>51</span><span>,</span>
  <span>origin</span><span>:</span> <span>&#34;</span><span>src/format.rs</span><span>&#34;</span><span>,</span>
  <span>fold</span><span>:</span> <span>false</span><span>,</span>
  <span>annotations</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>label</span><span>:</span> <span>&#34;</span><span>expected `Option&lt;String&gt;` because of return type</span><span>&#34;</span><span>,</span>
      <span>annotationType</span><span>:</span> <span>&#34;</span><span>warning</span><span>&#34;</span><span>,</span>
      <span>range</span><span>:</span> <span>[</span><span>5</span><span>,</span> <span>19</span><span>],</span>
    <span>},</span>
    <span>{</span>
      <span>label</span><span>:</span> <span>&#34;</span><span>expected enum `std::option::Option`</span><span>&#34;</span><span>,</span>
      <span>annotationType</span><span>:</span> <span>&#34;</span><span>error</span><span>&#34;</span><span>,</span>
      <span>range</span><span>:</span> <span>[</span><span>26</span><span>,</span> <span>724</span><span>],</span>
    <span>}</span>
  <span>]</span>
<span>}],</span> <span>{</span>
  <span>color</span><span>:</span> <span>true</span><span>,</span>
  <span>anonymizedLineNumbers</span><span>:</span> <span>false</span><span>,</span>
<span>}));</span>
</code></pre></div></div>

<p>(This API isn’t beautiful, but it gets the job done.)</p>

<p>And here’s the diagnostic it prints out:</p>

<div><div><pre><code>error[E0308]: mismatched types
  --&gt; src/format.rs:51:6
   |
51 |   ) -&gt; Option&lt;String&gt; {
   |        -------------- expected `Option&lt;String&gt;` because of return type
52 |       for ann in annotations {
   |  _____^
53 | |         match (ann.range.0, ann.range.1) {
54 | |             (None, None) =&gt; continue,
55 | |             (Some(start), Some(end)) if start &gt; end_index =&gt; continue,
56 | |             (Some(start), Some(end)) if start &gt;= start_index =&gt; {
57 | |                 let label = if let Some(ref label) = ann.label {
58 | |                     format!(&#34; {}&#34;, label)
59 | |                 } else {
60 | |                     String::from(&#34;&#34;)
61 | |                 };
62 | |
63 | |                 return Some(format!(
64 | |                     &#34;{}{}{}&#34;,
65 | |                     &#34; &#34;.repeat(start - start_index),
66 | |                     &#34;^&#34;.repeat(end - start),
67 | |                     label
68 | |                 ));
69 | |             }
70 | |             _ =&gt; continue,
71 | |         }
72 | |     }
   | |____^ expected enum `std::option::Option`
</code></pre></div></div>

<p>The main idea will be to use <a href="https://webassembly.org/">WebAssembly</a>, a binary instruction format that can be run on many platforms, including browsers and most JavaScript runtimes.
Rust’s compiler natively supports compiling Rust programs into WebAssembly. By doing so, we can reuse the capabilities of a Rust crate inside of any JavaScript code - whether it’s in the browser, or on another JavaScript runtime like Node.js - without having to rewrite all of the Rust code in a new language.</p>

<h2 id="scaffolding-the-library">Scaffolding the library</h2>

<p>First, start by checking you have recent <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="https://nodejs.org/en/download">Node</a> installations.</p>

<p>Next, create a new directory and add the following files:</p>

<h3 id="packagejson"><code>package.json</code></h3>

<p>This defines our JavaScript package metadata:</p>

<div><div><pre><code><span>{</span><span>
  </span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;my-library&#34;</span><span>,</span><span>
  </span><span>&#34;author&#34;</span><span>:</span><span> </span><span>&#34;Your name &lt;yourname@example.com&gt;&#34;</span><span>,</span><span>
  </span><span>&#34;version&#34;</span><span>:</span><span> </span><span>&#34;0.1.0&#34;</span><span>,</span><span>
  </span><span>&#34;description&#34;</span><span>:</span><span> </span><span>&#34;My WebAssembly bindings&#34;</span><span>,</span><span>
  </span><span>&#34;main&#34;</span><span>:</span><span> </span><span>&#34;lib/index.js&#34;</span><span>,</span><span>
  </span><span>&#34;types&#34;</span><span>:</span><span> </span><span>&#34;lib/index.d.ts&#34;</span><span>,</span><span>
  </span><span>&#34;files&#34;</span><span>:</span><span> </span><span>[</span><span>
    </span><span>&#34;lib/**/*.js&#34;</span><span>,</span><span>
    </span><span>&#34;lib/**/*.d.ts&#34;</span><span>,</span><span>
    </span><span>&#34;pkg/**/*.js&#34;</span><span>,</span><span>
    </span><span>&#34;pkg/**/*.d.ts&#34;</span><span>,</span><span>
    </span><span>&#34;pkg/**/*.wasm&#34;</span><span>,</span><span>
    </span><span>&#34;pkg/**/*.wasm.d.ts&#34;</span><span>
  </span><span>],</span><span>
  </span><span>&#34;keywords&#34;</span><span>:</span><span> </span><span>[],</span><span>
  </span><span>&#34;license&#34;</span><span>:</span><span> </span><span>&#34;MIT&#34;</span><span>,</span><span>
  </span><span>&#34;scripts&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;build:wasm-pack&#34;</span><span>:</span><span> </span><span>&#34;wasm-pack build --target nodejs --out-name index --out-dir ./pkg&#34;</span><span>,</span><span>
    </span><span>&#34;build:typescript&#34;</span><span>:</span><span> </span><span>&#34;tsc -b&#34;</span><span>,</span><span>
    </span><span>&#34;build&#34;</span><span>:</span><span> </span><span>&#34;npm run build:wasm-pack &amp;&amp; npm run build:typescript&#34;</span><span>,</span><span>
    </span><span>&#34;package&#34;</span><span>:</span><span> </span><span>&#34;npm pack&#34;</span><span>
  </span><span>},</span><span>
  </span><span>&#34;devDependencies&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;typescript&#34;</span><span>:</span><span> </span><span>&#34;5.1.3&#34;</span><span>,</span><span>
    </span><span>&#34;wasm-pack&#34;</span><span>:</span><span> </span><span>&#34;0.12.0&#34;</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div></div>

<h3 id="tsconfigjson"><code>tsconfig.json</code></h3>

<p>This defines our TypeScript configuration:</p>

<div><div><pre><code><span>{</span><span>
  </span><span>&#34;compilerOptions&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;target&#34;</span><span>:</span><span> </span><span>&#34;esnext&#34;</span><span>,</span><span>
    </span><span>&#34;lib&#34;</span><span>:</span><span> </span><span>[</span><span>&#34;esnext&#34;</span><span>,</span><span> </span><span>&#34;dom&#34;</span><span>],</span><span>
    </span><span>&#34;module&#34;</span><span>:</span><span> </span><span>&#34;commonjs&#34;</span><span>,</span><span>
    </span><span>&#34;declaration&#34;</span><span>:</span><span> </span><span>true</span><span>,</span><span>
    </span><span>&#34;forceConsistentCasingInFileNames&#34;</span><span>:</span><span> </span><span>true</span><span>,</span><span>
    </span><span>&#34;strict&#34;</span><span>:</span><span> </span><span>true</span><span>,</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div></div>

<p>For this post I’ll be compiling to “CommonJS” (a standard for packaging JavaScript modules that was designed for NodeJS), although it should be noted that <a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules</a> is a more recent standard that works across more JavaScript runtimes.</p>

<h3 id="cargotoml"><code>Cargo.toml</code></h3>

<p>This defines our Rust library information:</p>

<div><div><pre><code><span>[package]</span>
<span>name</span> <span>=</span> <span>&#34;my-library&#34;</span>
<span>version</span> <span>=</span> <span>&#34;0.1.0&#34;</span>
<span>edition</span> <span>=</span> <span>&#34;2021&#34;</span>

<span>[lib]</span>
<span># required to compile to WebAssembly</span>
<span>crate-type</span> <span>=</span> <span>[&#34;cdylib&#34;]</span>

<span>[dependencies]</span>
<span>wasm-bindgen</span> <span>=</span> <span>&#34;0.2.87&#34;</span>
<span>annotate-snippets</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;0.9.1&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[&#34;color&#34;]</span> <span>}</span>
<span>serde</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;1.0&#34;</span><span>,</span> <span>features</span> <span>=</span> <span>[&#34;derive&#34;]</span> <span>}</span>
<span>serde-wasm-bindgen</span> <span>=</span> <span>&#34;0.4&#34;</span>
</code></pre></div></div>

<p>If you wanted to create bindings for a different Rust crate, you could easily swap <code>annotate-snippets</code> with</p>

<h3 id="gitignore"><code>.gitignore</code></h3>

<p>So we don’t commit unnecessary stuff to git.</p>

<div><div><pre><code>/target
/Cargo.lock
/node_modules
*.tgz
</code></pre></div></div>

<h3 id="srclibrs"><code>src/lib.rs</code></h3>

<p>The entrypoint of our Rust project, initialized with a placeholder function that is exported to WebAssembly:</p>

<div><div><pre><code><span>use</span> <span>wasm_bindgen</span><span>::</span><span>prelude</span><span>::</span><span>*</span><span>;</span>

<span>#[wasm_bindgen]</span>
<span>pub</span> <span>fn</span> <span>add</span><span>(</span><span>x</span><span>:</span> <span>usize</span><span>,</span> <span>y</span><span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>usize</span> <span>{</span>
    <span>x</span> <span>+</span> <span>y</span>
<span>}</span>
</code></pre></div></div>

<h3 id="libindexts"><code>lib/index.ts</code></h3>

<p>The entrypoint of our TypeScript library, that uses the placeholder function.</p>

<div><div><pre><code><span>import</span> <span>{</span> <span>add</span> <span>}</span> <span>from</span> <span>&#34;</span><span>../pkg</span><span>&#34;</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>add</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>));</span>
</code></pre></div></div>

<h3 id="tying-it-all-together">Tying it all together</h3>

<p>First, you’ll want to build the Rust project by running <code>cargo build</code>.
Then, install all of the npm dependencies (including TypeScript and <a href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a>) by running <code>npm install</code>.
Finally, you can generate the WebAssembly bindings and compile the TypeScript library by running <code>npm run build</code>.</p>

<p>If everything’s working correctly, when you run <code>node lib/index.js</code>, it will run the compiled JavaScript code and print out the sum of 3 + 5 calculated in WebAssembly (generated from Rust source code), still fortunately 8.</p>

<h2 id="exposing-the-rust-crate-through-webassembly-bindings">Exposing the Rust crate through WebAssembly bindings</h2>

<p>Every WebAssembly module defines a set of exports that can be accessed by the host environment.
For our example, we just need to export a single function that will generate a pretty-printed diagnostic.</p>

<p>In Rust, we can do this by exporting a function with the <code>pub</code> keyword and annotating it with the <code>#[wasm_bindgen]</code> macro.
Since we’re using <code>#[wasm_bindgen]</code>, we need to make sure the function’s parameters and return values have types that Rust compiler knows how to compile into a WebAssembly representation - so no fancy higher-kinded types here.
A full list of supported types are described <a href="https://rustwasm.github.io/wasm-bindgen/reference/types.html">here</a>.</p>

<p>The crate I’m using, <code>annotate-snippets</code>, has a simple API.
It expects a set of options for specifying a code snippet and its annotations, and it can produce a Rust <code>String</code> as output.
Here’s what the using the API in Rust looks like:</p>

<div><div><pre><code><span>let</span> <span>snippet</span> <span>=</span> <span>Snippet</span> <span>{</span>
    <span>title</span><span>:</span> <span>Some</span><span>(</span><span>Annotation</span> <span>{</span>
        <span>label</span><span>:</span> <span>Some</span><span>(</span><span>&#34;mismatched types&#34;</span><span>),</span>
        <span>id</span><span>:</span> <span>Some</span><span>(</span><span>&#34;E0308&#34;</span><span>),</span>
        <span>annotation_type</span><span>:</span> <span>AnnotationType</span><span>::</span><span>Error</span><span>,</span>
    <span>}),</span>
    <span>footer</span><span>:</span> <span>vec!</span><span>[</span><span>Annotation</span> <span>{</span>
        <span>label</span><span>:</span> <span>Some</span><span>(</span>
            <span>&#34;expected type: `snippet::Annotation`</span><span>\n</span><span>   found type: `__&amp;__snippet::Annotation`&#34;</span><span>,</span>
        <span>),</span>
        <span>id</span><span>:</span> <span>None</span><span>,</span>
        <span>annotation_type</span><span>:</span> <span>AnnotationType</span><span>::</span><span>Note</span><span>,</span>
    <span>}],</span>
    <span>slices</span><span>:</span> <span>vec!</span><span>[</span><span>Slice</span> <span>{</span>
        <span>source</span><span>:</span> <span>&#34;        slices: vec![</span><span>\&#34;</span><span>A</span><span>\&#34;</span><span>,&#34;</span><span>,</span>
        <span>line_start</span><span>:</span> <span>13</span><span>,</span>
        <span>origin</span><span>:</span> <span>Some</span><span>(</span><span>&#34;src/multislice.rs&#34;</span><span>),</span>
        <span>fold</span><span>:</span> <span>false</span><span>,</span>
        <span>annotations</span><span>:</span> <span>vec!</span><span>[</span><span>SourceAnnotation</span> <span>{</span>
            <span>label</span><span>:</span> <span>&#34;expected struct `annotate_snippets::snippet::Slice`, found reference&#34;</span><span>,</span>
            <span>range</span><span>:</span> <span>(</span><span>21</span><span>,</span> <span>24</span><span>),</span>
            <span>annotation_type</span><span>:</span> <span>AnnotationType</span><span>::</span><span>Error</span><span>,</span>
        <span>}],</span>
    <span>}],</span>
    <span>opt</span><span>:</span> <span>FormatOptions</span> <span>{</span>
        <span>color</span><span>:</span> <span>true</span><span>,</span>
        <span>..</span><span>Default</span><span>::</span><span>default</span><span>()</span>
    <span>},</span>
<span>};</span>

<span>let</span> <span>dl</span> <span>=</span> <span>DisplayList</span><span>::</span><span>from</span><span>(</span><span>snippet</span><span>);</span>
<span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>dl</span><span>);</span>
</code></pre></div></div>

<p>To make a WebAssembly binding for this, I’ll write a function named <code>annotate_snippet</code> that expects the options of the <code>Snippet</code> as parameters (title, footer, slices, and formatting options), and returns a <code>String</code>.</p>

<p>To model the options, we can use an opague type called <code>JsValue</code>, and then do some parsing to check the values have the expected structure.</p>

<div><div><pre><code><span>use</span> <span>wasm_bindgen</span><span>::</span><span>prelude</span><span>::</span><span>*</span><span>;</span>

<span>#[wasm_bindgen]</span>
<span>pub</span> <span>fn</span> <span>annotate_snippet</span><span>(</span>
    <span>title</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>footer</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>slices</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>options</span><span>:</span> <span>JsValue</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>String</span> <span>{</span>
    <span>todo!</span><span>()</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s start with parsing the first parameter, <code>options</code>, which we’ll expect to be provided as a plain JavaScript object with fields that match <code>annotate_snippets::FormatOptions</code>.
The way we can achieve this is by creating own structs that match the structure of <code>FormatOptions</code> that implement the serde <code>Serialize</code> and <code>Deserialize</code> traits on them.
<code>serde</code> is a library that lets you automatically perform conversions between Rust structs and serialized formats.</p>

<blockquote>
  <p>Note: We need to create our own structs because Rust <a href="https://rust-lang.github.io/chalk/book/clauses/coherence.html">does not allow you to implement foreign traits on foreign types</a>.</p>
</blockquote>

<p>Here are the structs I added:</p>

<div><div><pre><code><span>use</span> <span>serde</span><span>::{</span><span>Deserialize</span><span>,</span> <span>Serialize</span><span>};</span>

<span>#[derive(Serialize,</span> <span>Deserialize,</span> <span>Debug)]</span>
<span>struct</span> <span>MyFormatOptions</span> <span>{</span>
    <span>color</span><span>:</span> <span>bool</span><span>,</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;anonymizedLineNumbers&#34;</span><span>)]</span>
    <span>anonymized_line_numbers</span><span>:</span> <span>bool</span><span>,</span>
    <span>margin</span><span>:</span> <span>Option</span><span>&lt;</span><span>MyMargin</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>#[derive(Serialize,</span> <span>Deserialize,</span> <span>Debug)]</span>
<span>struct</span> <span>MyMargin</span> <span>{</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;whitespaceLeft&#34;</span><span>)]</span>
    <span>whitespace_left</span><span>:</span> <span>usize</span><span>,</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;spanLeft&#34;</span><span>)]</span>
    <span>span_left</span><span>:</span> <span>usize</span><span>,</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;spanRight&#34;</span><span>)]</span>
    <span>span_right</span><span>:</span> <span>usize</span><span>,</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;labelRight&#34;</span><span>)]</span>
    <span>label_right</span><span>:</span> <span>usize</span><span>,</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;columnWidth&#34;</span><span>)]</span>
    <span>column_width</span><span>:</span> <span>usize</span><span>,</span>
    <span>#[serde(rename</span> <span>=</span> <span>&#34;maxLineLen&#34;</span><span>)]</span>
    <span>max_line_len</span><span>:</span> <span>usize</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>For some fields, I’ve added a macro that renames the field.
The purpose is so that in our TypeScript library, we can use camelCase fields as is the convention in the TypeScript ecosystem, while still representing the fields in Rust using snake_case.</p>

<p>Next, we need to write some glue code for converting these structs back into the corresponding types from the <code>annotate-snippets</code> crate.
The idiomatic way to achieve this in Rust by using the <code>From</code> trait:</p>

<div><div><pre><code><span>use</span> <span>annotate_snippets</span><span>::</span><span>display_list</span><span>::{</span><span>FormatOptions</span><span>,</span> <span>Margin</span><span>};</span>

<span>impl</span> <span>From</span><span>&lt;</span><span>MyFormatOptions</span><span>&gt;</span> <span>for</span> <span>FormatOptions</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span><span>options</span><span>:</span> <span>MyFormatOptions</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>FormatOptions</span> <span>{</span>
            <span>color</span><span>:</span> <span>options</span><span>.color</span><span>,</span>
            <span>anonymized_line_numbers</span><span>:</span> <span>options</span><span>.anonymized_line_numbers</span><span>,</span>
            <span>margin</span><span>:</span> <span>options</span><span>.margin</span><span>.map</span><span>(|</span><span>m</span><span>|</span> <span>m</span><span>.into</span><span>()),</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>From</span><span>&lt;</span><span>MyMargin</span><span>&gt;</span> <span>for</span> <span>Margin</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span><span>margin</span><span>:</span> <span>MyMargin</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Margin</span><span>::</span><span>new</span><span>(</span>
            <span>margin</span><span>.whitespace_left</span><span>,</span>
            <span>margin</span><span>.span_left</span><span>,</span>
            <span>margin</span><span>.span_right</span><span>,</span>
            <span>margin</span><span>.label_right</span><span>,</span>
            <span>margin</span><span>.column_width</span><span>,</span>
            <span>margin</span><span>.max_line_len</span><span>,</span>
        <span>)</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Finally we can use these structs in our <code>annotate_snippet</code> function to parse the <code>JsValue</code>:</p>

<div><div><pre><code><span>#[wasm_bindgen]</span>
<span>pub</span> <span>fn</span> <span>annotate_snippet</span><span>(</span>
    <span>title</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>footer</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>slices</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>options</span><span>:</span> <span>JsValue</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>String</span> <span>{</span>
    <span>let</span> <span>options</span><span>:</span> <span>FormatOptions</span> <span>=</span> <span>match</span> <span>serde_wasm_bindgen</span><span>::</span><span>from_value</span><span>::</span><span>&lt;</span><span>MyFormatOptions</span><span>&gt;</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>Ok</span><span>(</span><span>config</span><span>)</span> <span>=&gt;</span> <span>config</span><span>.into</span><span>(),</span>
        <span>Err</span><span>(</span><span>_</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>return</span> <span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;Error&#34;</span><span>);</span>
        <span>}</span>
    <span>};</span>

    <span>todo!</span><span>()</span>
<span>}</span>
</code></pre></div></div>

<h3 id="error-handling">Error handling</h3>

<p>This is great, but if there is a parsing error, it would be nice to give more specific information to the user.</p>

<p>Let’s define an external function that will let our Rust code call back into JavaScript and throw an error…</p>

<div><div><pre><code><span>#[wasm_bindgen(inline_js</span> <span>=</span> <span>&#34;exports.error = function(s) { throw new Error(s) }&#34;</span><span>)]</span>
<span>extern</span> <span>&#34;C&#34;</span> <span>{</span>
    <span>fn</span> <span>error</span><span>(</span><span>s</span><span>:</span> <span>String</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>…and update the code from <code>annotate_snippet</code> so we use the <code>Err</code> value:</p>

<div><div><pre><code><span>#[wasm_bindgen]</span>
<span>pub</span> <span>fn</span> <span>annotate_snippet</span><span>(</span>
    <span>title</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>footer</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>slices</span><span>:</span> <span>JsValue</span><span>,</span>
    <span>options</span><span>:</span> <span>JsValue</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>String</span> <span>{</span>
    <span>let</span> <span>options</span><span>:</span> <span>FormatOptions</span> <span>=</span> <span>match</span> <span>serde_wasm_bindgen</span><span>::</span><span>from_value</span><span>::</span><span>&lt;</span><span>MyFormatOptions</span><span>&gt;</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>Ok</span><span>(</span><span>config</span><span>)</span> <span>=&gt;</span> <span>config</span><span>.into</span><span>(),</span>
        <span>Err</span><span>(</span><span>err</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>error</span><span>(</span><span>err</span><span>.to_string</span><span>());</span>
            <span>return</span> <span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;Error&#34;</span><span>);</span>
        <span>}</span>
    <span>};</span>

    <span>todo!</span><span>()</span>
<span>}</span>
</code></pre></div></div>

<p>Nicely done!</p>

<p>Next, we just have to repeat this process for the <code>title</code>, <code>footer</code>, and <code>slices</code> parameters.
The details are a little bit tedious, but the rest of the code is available on GitHub <a href="https://github.com/Chriscbr/annotate-snippets/blob/main/src/lib.rs">here</a>.</p>

<p>When you’re finished, you can run <code>npm run build</code> to check that it compiles to WebAssembly successfully.</p>

<h2 id="wrapping-the-webassembly-bindings-in-typescript">Wrapping the WebAssembly bindings in TypeScript</h2>

<p>At this point, the JavaScript bindings are fully functional.
Here’s an example of calling them in <code>lib/index.ts</code>:</p>

<div><div><pre><code><span>import</span> <span>{</span> <span>annotate_snippet</span> <span>}</span> <span>from</span> <span>&#34;</span><span>../pkg</span><span>&#34;</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>annotate_snippet</span><span>({</span>
  <span>label</span><span>:</span> <span>&#34;</span><span>mismatched types</span><span>&#34;</span><span>,</span>
  <span>id</span><span>:</span> <span>&#34;</span><span>E0308</span><span>&#34;</span><span>,</span>
  <span>annotationType</span><span>:</span> <span>&#34;</span><span>error</span><span>&#34;</span><span>,</span>
<span>},</span> <span>[],</span> <span>[{</span>
  <span>source</span><span>:</span> <span>`) -&gt; Option&lt;String&gt; {
    for ann in annotations {
        match (ann.range.0, ann.range.1) {
            (None, None) =&gt; continue,
            (Some(start), Some(end)) if start &gt; end_index =&gt; continue,
            (Some(start), Some(end)) if start &gt;= start_index =&gt; {
                let label = if let Some(ref label) = ann.label {
                    format!(&#34; {}&#34;, label)
                } else {
                    String::from(&#34;&#34;)
                };

                return Some(format!(
                    &#34;{}{}{}&#34;,
                    &#34; &#34;.repeat(start - start_index),
                    &#34;^&#34;.repeat(end - start),
                    label
                ));
            }
            _ =&gt; continue,
        }
    }`</span><span>,</span>
  <span>lineStart</span><span>:</span> <span>51</span><span>,</span>
  <span>origin</span><span>:</span> <span>&#34;</span><span>src/format.rs</span><span>&#34;</span><span>,</span>
  <span>fold</span><span>:</span> <span>false</span><span>,</span>
  <span>annotations</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>label</span><span>:</span> <span>&#34;</span><span>expected `Option&lt;String&gt;` because of return type</span><span>&#34;</span><span>,</span>
      <span>annotationType</span><span>:</span> <span>&#34;</span><span>warning</span><span>&#34;</span><span>,</span>
      <span>range</span><span>:</span> <span>[</span><span>5</span><span>,</span> <span>19</span><span>],</span>
    <span>},</span>
    <span>{</span>
      <span>label</span><span>:</span> <span>&#34;</span><span>expected enum `std::option::Option`</span><span>&#34;</span><span>,</span>
      <span>annotationType</span><span>:</span> <span>&#34;</span><span>error</span><span>&#34;</span><span>,</span>
      <span>range</span><span>:</span> <span>[</span><span>26</span><span>,</span> <span>724</span><span>],</span>
    <span>}</span>
  <span>]</span>
<span>}],</span> <span>{</span>
  <span>color</span><span>:</span> <span>true</span><span>,</span>
  <span>anonymizedLineNumbers</span><span>:</span> <span>false</span><span>,</span>
<span>}));</span>
</code></pre></div></div>

<p>The only problem is that by default, all of these fields will be typed as <code>any</code> in TypeScript. This means anyone calling the API won’t know what fields can be passed in, unless they go to the Rust documentation for the original crate or look at our source code.</p>

<p>We can do better by providing a typed API that shows all of the available fields for each parameter of the <code>annotate_snippet</code> function.</p>

<p>Here’s our updated TypeScript module in <code>lib/index.ts</code>.
All of the types are TypeScript equivalents of the types
from our Rust code (for example, <code>bool</code> becomes <code>boolean</code>, <code>Option&lt;String&gt;</code> becomes optional <code>string</code>’s, and simple enums become <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">string literal types</a>).</p>

<div><div><pre><code><span>export</span> <span>type</span> <span>AnnotationType</span> <span>=</span> <span>&#34;</span><span>error</span><span>&#34;</span> <span>|</span> <span>&#34;</span><span>warning</span><span>&#34;</span> <span>|</span> <span>&#34;</span><span>info</span><span>&#34;</span> <span>|</span> <span>&#34;</span><span>note</span><span>&#34;</span> <span>|</span> <span>&#34;</span><span>help</span><span>&#34;</span><span>;</span>

<span>export</span> <span>interface</span> <span>Annotation</span> <span>{</span>
  <span>id</span><span>?:</span> <span>string</span><span>;</span>
  <span>label</span><span>?:</span> <span>string</span><span>;</span>
  <span>annotationType</span><span>:</span> <span>AnnotationType</span><span>;</span>
<span>}</span>

<span>export</span> <span>interface</span> <span>Slice</span> <span>{</span>
  <span>source</span><span>:</span> <span>string</span><span>;</span>
  <span>lineStart</span><span>:</span> <span>number</span><span>;</span>
  <span>origin</span><span>?:</span> <span>string</span><span>;</span>
  <span>annotations</span><span>:</span> <span>SourceAnnotation</span><span>[];</span>
  <span>fold</span><span>:</span> <span>boolean</span><span>;</span>
<span>}</span>

<span>export</span> <span>interface</span> <span>SourceAnnotation</span> <span>{</span>
  <span>range</span><span>:</span> <span>[</span><span>number</span><span>,</span> <span>number</span><span>];</span>
  <span>label</span><span>:</span> <span>string</span><span>;</span>
  <span>annotationType</span><span>:</span> <span>AnnotationType</span><span>;</span>
<span>}</span>

<span>export</span> <span>interface</span> <span>FormatOptions</span> <span>{</span>
  <span>color</span><span>:</span> <span>boolean</span><span>;</span>
  <span>anonymizedLineNumbers</span><span>:</span> <span>boolean</span><span>;</span>
  <span>margin</span><span>?:</span> <span>Margin</span><span>;</span>
<span>}</span>

<span>export</span> <span>interface</span> <span>Margin</span> <span>{</span>
  <span>whitespaceLeft</span><span>:</span> <span>number</span><span>;</span>
  <span>spanLeft</span><span>:</span> <span>number</span><span>;</span>
  <span>spanRight</span><span>:</span> <span>number</span><span>;</span>
  <span>labelRight</span><span>:</span> <span>number</span><span>;</span>
  <span>columnWidth</span><span>:</span> <span>number</span><span>;</span>
  <span>maxLineLen</span><span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>export</span> <span>function</span> <span>annotateSnippet</span><span>(</span>
  <span>title</span><span>:</span> <span>Annotation</span> <span>|</span> <span>undefined</span><span>,</span>
  <span>footer</span><span>:</span> <span>Annotation</span><span>[],</span>
  <span>slices</span><span>:</span> <span>Slice</span><span>[],</span>
  <span>options</span><span>:</span> <span>FormatOptions</span><span>,</span>
<span>)</span> <span>{</span>
  <span>return</span> <span>bindings</span><span>.</span><span>annotate_snippet</span><span>(</span><span>title</span><span>,</span> <span>footer</span><span>,</span> <span>slices</span><span>,</span> <span>options</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Run <code>npm run build</code> again to check everything works.</p>

<h2 id="conclusion">Conclusion</h2>

<p>That’s it! We’ve successfully wrapped a Rust crate in WebAssembly and TypeScript.</p>

<p>You can see the full source code of the library on GitHub here: <a href="https://github.com/Chriscbr/annotate-snippets">https://github.com/Chriscbr/annotate-snippets</a>.</p>

<p>If you have any questions or comments, feel free to reach out to me on <a href="https://twitter.com/rybickic">Twitter</a> or <a href="https://github.com/Chriscbr">GitHub</a>.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
