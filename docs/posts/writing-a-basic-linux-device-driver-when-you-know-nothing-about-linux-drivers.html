<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://crescentro.se/posts/writing-drivers/">Original</a>
    <h1>Writing a basic Linux device driver when you know nothing about Linux drivers</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>A couple of months ago I bought the <a href="https://nanoleaf.me/en-EU/products/pegboard-desk-dock/?size=1">Nanoleaf Pegboard Desk Dock</a>, the latest and greatest in USB-hub-with-RGB-LEDs-and-hooks-for-gadgets technology. This invention unfortunately only supports the <em>real gamer</em> operating systems of Windows and macOS, which necessitated the development of a Linux driver.</p>
<hr/>
<p>Over the past few posts I’ve set up a <a href="https://crescentro.se/posts/windows-vm-nixos/">Windows VM with USB passthrough</a>, and attempted to <a href="https://crescentro.se/posts/wireshark-usb/">reverse-engineer the official drivers</a>,  As I was doing that, I also thought I’d message the vendor and ask them if they could share any specifications or docs regarding their protocol. To my surprise, Nanoleaf tech support responded to me within 4 hours, with a full description of the protocol that’s used both by the Desk Dock as well as their RGB strips. The docs mostly confirmed what I had already discovered independently, but there were a couple of other minor features as well (like power and brightness management) that I did not know about, which was helpful.</p>
<p>Today, we’re going to take a crack at writing a driver based on the (reverse-engineered) protocol, while also keeping <a href="https://nanoleaf.atlassian.net/wiki/spaces/nlapid/pages/2615574530/Nanoleaf+USB+Lightstrip+Communication+Protocol">the official documentation</a> at hand. One small problem, though: I’ve never written a Linux device driver before, nor interacted with any USB device as anything else but a user.</p>

<h2 id="starting-from-scratch">Starting from scratch</h2>
<p>Most Linux distros ship with <a href="https://www.man7.org/linux/man-pages/man8/lsusb.8.html"><code>lsusb</code></a>, a simple utility that will enumerate all USB devices connected to the system. Since I had no clue where to start from, I figured I might as well run this to see if the device appears in the listing.</p>
<pre><code><span>$ lsusb
</span><span>&lt;snip&gt;
</span><span>Bus 001 Device 062: ID 37fa:8201 JW25021301515 Nanoleaf Pegboard Desk Dock
</span></code></pre>
<p>Well, good news, it’s definitely there. But, how can the kernel know that what I have plugged in is the “Nanoleaf Pegboard Desk Dock”? The kernel (presumably) has no knowledge of this device’s existence, yet the second I plug it in to my computer it receives power, turns on and gets identified by the kernel.</p>
<p>As it turns out, we actually already have a driver! It’s just a very stupid one. If we run <code>lsusb</code> in verbose mode and request the information just for this specific device, we will get a lot more details about it:</p>

<pre><code>$ lsusb -d 37fa:8201 -v

Bus 001 Device 091: ID 37fa:8201 JW25021301515 Nanoleaf Pegboard Desk Dock
Negotiated speed: Full Speed (12Mbps)
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               1.10
  bDeviceClass            0 [unknown]
  bDeviceSubClass         0 [unknown]
  bDeviceProtocol         0 
  bMaxPacketSize0        64
  idVendor           0x37fa JW25021301515
  idProduct          0x8201 Nanoleaf Pegboard Desk Dock
  bcdDevice            1.09
  iManufacturer           1 JW25021301515
  iProduct                2 Nanoleaf Pegboard Desk Dock
  iSerial                 3 &lt;snip&gt;
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength       0x0029
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          4 Nanoleaf Pegboard Desk Dock
    bmAttributes         0xa0
      (Bus Powered)
      Remote Wakeup
    MaxPower               70mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           2
      bInterfaceClass         3 Human Interface Device
      bInterfaceSubClass      0 [unknown]
      bInterfaceProtocol      0 
      iInterface              5 Nanoleaf Pegboard Desk Dock
        HID Device Descriptor:
          bLength                 9
          bDescriptorType        33
          bcdHID               1.00
          bCountryCode            0 Not supported
          bNumDescriptors         1
          bDescriptorType        34 (null)
          wDescriptorLength      34
          Report Descriptors: 
            ** UNAVAILABLE **
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x82  EP 2 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               1
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x02  EP 2 OUT
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               1
Device Status:     0x0000
  (Bus Powered)
</code></pre>
<p>This is a <em>lot</em> of information, so we need to take a quick USB class.</p>
<h2 id="a-quick-usb-class">A quick USB class</h2>
<p>The USB spec is long, complicated and mainly aimed at low-level implementations (think kernel developers, device vendors, and so on). You can, of course, still read it if you enjoy being bored. But, thankfully, a kind soul collected the good parts into <a href="https://www.beyondlogic.org/usbnutshell/usb1.shtml">USB in a NutShell</a>.</p>
<p>To summarize the summary, a USB device can have multiple <strong>configurations</strong>, which usually explain the power requirements for the device. Most devices will have just one.</p>
<p>Each of those configurations can have multiple <strong>interfaces</strong>. So for example, a camera might serve as a file storage device as well as a webcam.</p>
<p>Finally, each interface can have multiple <strong>endpoints</strong>, whcih describe how the data is transferred. Perhaps the camera has an “isochronous” (continuous) transfer for a webcam feed, and a “bulk” transfer for moving image files over.</p>
<p>Going back to our device, we can see that it exposes one interface, which is a <em>Human Interface Device</em>. HIDs are a class of USB devices that covers things like keyboards, mice or gamepads, and each of those categories is a separate <em>sub-class</em>. The kernel contains a generic driver for USB HIDs - <a href="https://github.com/torvalds/linux/blob/master/drivers/hid/usbhid/hid-core.c">here it is</a> in all of its C glory.</p>
<p>This is why the kernel developers do not need to write specific drivers for each individual keyboard and mouse on the market. Vendors will label their device with one of the well-known HID sub-classes, then use a common protocol to implement the functionality.</p>

<p>Unfortunately there’s no HID specification for an RGB LED… thing (well, there’s an “LED” specification, but it’s mainly for things like status LEDs, not color LEDs) so our device is just a plain old generic HID with an interface sub-class of <code>0</code>. This means that the kernel recognizes it and powers it correctly, but it doesn’t really know what to do with it, so it just lets it sit there.</p>
<p>There are two options that we have at this point:</p>
<ol>
<li>We could write a kernel driver that follows the <a href="https://docs.kernel.org/leds/leds-class.html">kernel standard</a> and exposes each individual LED as 3 devices (one per color) under <code>/sys/class/leds</code>. Interacting with the kernel devs sounds scary (yes I realize I’m a grown-ass adult man), but even if it wasn’t, I question the utility of trying to merge drivers for a very niche product into the kernel. Also, <code>/sys/class/leds</code> feels like it’s intended for status LEDs and not <mark>gamer colors</mark> anyway.</li>
<li>We could write a userspace driver through <a href="https://github.com/libusb/libusb">libusb</a>, thus defining our own way of controlling LEDs and reducing the quality bar from “Linus Torvalds might send you a strongly worded letter if you fuck up” to “fuck it, we ball”.</li>
</ol>
<p>Given that I have no idea what I am doing, I’m gonna go for option 2, but if one of you brave souls goes for option 1, please let me know and I will print out a photo of you and frame it on my wall.</p>
<h3 id="side-quest-udev-rules">Side quest: udev rules</h3>
<p>To do anything fun on Linux, you need to be <code>root</code>. This is also the case when talking to USB devices. You could always run your drivers as <code>root</code>, thus sidestepping the problem. But we all know that’s bad form. And if I am to distribute this driver, most people would expect to run it without privilege escalation.</p>
<p>Linux generally relies on <a href="https://wiki.archlinux.org/title/Udev"><code>udev</code></a> to manage handlers for hardware events. I will spare you the long story this time and just give you the magic incantation: to make your device accessible to users, you need to create a file at  <code>/etc/udev/rules.d/70-pegboard.rules</code> with the following contents:</p>
<pre><code><span>ACTION==&#34;add&#34;, SUBSYSTEM==&#34;usb&#34;, DRIVERS==&#34;usb&#34;, ATTRS{idVendor}==&#34;37fa&#34;, ATTRS{idProduct}==&#34;8201&#34;, MODE=&#34;0770&#34;, TAG+=&#34;uaccess&#34;
</span></code></pre>
<p>where <code>ATTRS{idVendor}</code> and <code>ATTRS{idProduct}</code> are the vendor and product IDs you got from <code>lsusb</code>, and <code>TAG+=&#34;uaccess&#34;</code> is the spell that grants the currently active user permissions to manage the device. Then, unplug your device and plug it back in.</p>
<details>
  <summary>Keep reading if you&#39;re using NixOS, and feel free to skip if you go outside sometimes.</summary>
  <div>
    <p>You can name the <code>.rules</code> file whatever you want, but, obviously, it <a href="https://github.com/systemd/systemd/issues/4288#issuecomment-348166161">needs to come before <code>73</code> alphabetically</a>. This is because fuck you, that’s why. This poses an interesting challenge on NixOS, which, in its eternal wisdom, <a href="https://nixos.org/manual/nixos/stable/options#opt-services.udev.extraRules">provide only one way of adding custom rules, which writes to <code>99-local.rules</code></a>. The solution to that is to make a custom package that defines the rule at the desired location, and then extend <code>services.udev.packages</code> with your new package. Thankfully, this is easily doable with the <code>pkgs.writeTextFile</code> helper, like so:</p>
<pre data-lang="nix"><code data-lang="nix"><span><span>services</span><span>.</span><span>udev</span><span>.</span><span>packages</span> <span>=</span> <span>[</span>
</span><span>    <span>(</span><span>pkgs</span><span>.</span><span>writeTextFile</span> <span>{</span>
</span><span>        <span>name</span> <span>=</span> <span><span>&#34;</span>pegboard_udev<span>&#34;</span></span><span>;</span>
</span><span>        <span>text</span> <span>=</span> <span><span>&#39;&#39;</span>
</span></span><span><span>          ACTION==&#34;add&#34;, SUBSYSTEM==&#34;usb&#34;, DRIVERS==&#34;usb&#34;, ATTRS{idVendor}==&#34;37fa&#34;, ATTRS{idProduct}==&#34;8201&#34;, MODE=&#34;0770&#34;, TAG+=&#34;uaccess&#34;
</span></span><span><span>        <span>&#39;&#39;</span></span><span>;</span>
</span><span>        <span>destination</span> <span>=</span> <span><span>&#34;</span>/etc/udev/rules.d/70-pegboard.rules<span>&#34;</span></span><span>;</span>
</span><span>    <span>}</span><span>)</span>
</span><span>  <span>]</span><span>;</span>
</span></code></pre>

  </div>
</details>
<h2 id="writing-a-basic-driver">Writing a basic driver</h2>
<p>Okay, enough yapping. Let’s start with a basic Rust binary and immediately add the <a href="https://crates.io/crates/rusb"><code>rusb</code></a> crate, which will serve as a binding to <code>libusb</code>.</p>
<pre data-lang="bash"><code data-lang="bash"><span><span><span>cargo</span></span><span> new gamer-driver</span>
</span><span><span><span>cd</span></span><span> gamer-driver</span>
</span><span><span><span>cargo</span></span><span> add rusb</span>
</span></code></pre>
<p>To get going, we can try to get a handle on the device and get basic information about it, just like <code>lsusb</code>. This is explained pretty well in the crate readme, so I will not dwell on it too much. We’ll need a <code>Context</code>, which gives us a handy <code>open_device_with_vid_pid</code> method that we can use to get a handle to a device.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>rusb<span>::</span></span><span><span>{</span>Context<span>,</span> UsbContext</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span>const</span> <span>VENDOR</span><span>:</span> <span>u16</span> <span>=</span> <span>0x37fa</span><span>;</span>
</span><span><span>const</span> <span>DEVICE</span><span>:</span> <span>u16</span> <span>=</span> <span>0x8201</span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> context <span>=</span> <span>Context<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>cannot open libusb context<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> device <span>=</span> context
</span></span></span><span><span><span>        <span>.</span><span>open_device_with_vid_pid</span><span><span>(</span><span>VENDOR</span><span>,</span> <span>DEVICE</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>cannot get device<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> descriptor <span>=</span> device
</span></span></span><span><span><span>        <span>.</span><span>device</span><span><span>(</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>device_descriptor</span><span><span>(</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>cannot describe device<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{descriptor:#?}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>$ cargo run
</span><span>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running `target/debug/gamer-driver`
</span><span>DeviceDescriptor {
</span><span>    bLength: 18,
</span><span>    bDescriptorType: 1,
</span><span>    bcdUSB: 272,
</span><span>    bDeviceClass: 0,
</span><span>    bDeviceSubClass: 0,
</span><span>    bDeviceProtocol: 0,
</span><span>    bMaxPacketSize: 64,
</span><span>    idVendor: 14330,
</span><span>    idProduct: 33281,
</span><span>    bcdDevice: 265,
</span><span>    iManufacturer: 1,
</span><span>    iProduct: 2,
</span><span>    iSerialNumber: 3,
</span><span>    bNumConfigurations: 1,
</span><span>}
</span></code></pre>
<h2 id="the-joy-of-debugging">The joy of debugging</h2>
<p>Now that we have access to the device, we want to write a simple payload to it. For that, we first need to claim an interface. Recall that interfaces are essentially capabilities of the device, and through <code>lsusb</code> we learned that we only have one interface with the ID (<code>bInterfaceNumber</code>) of <code>0</code>. Thankfully, there’s an obvious <code>claim_interface</code> method on a <code>Device</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span>const</span> <span>INTERFACE</span><span>:</span> <span>u8</span> <span>=</span> <span>0x0</span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    device
</span></span></span><span><span><span>        <span>.</span><span>claim_interface</span><span><span>(</span><span>INTERFACE</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to claim interface<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>$ cargo run
</span><span>   Compiling gamer-driver v0.1.0 (/home/ivan/Code/gamer-driver)
</span><span>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.21s
</span><span>     Running `target/debug/gamer-driver`
</span><span>
</span><span>thread &#39;main&#39; panicked at src/main.rs:15:10:
</span><span>unable to claim interface: Busy
</span><span>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre>
<p>Ah.</p>
<p>So, what you just experienced is the joy of <code>libusb</code> error messages. This message, at 4 characters, is in fact pretty generous - you might be greeted with a message that only says <code>Io</code>, and good luck debugging that. In general, <code>Busy</code> means that something is already holding the device open, so you cannot do anything with it. However, you won’t actually be told what is holding it open.</p>
<p>The secret is that the device is, of course, being held open by the kernel. This is the generic driver I talked about earlier. And the secret solution is to release the kernel driver, if it is currently active on the device.</p>
<p>This requires you to have write access to the device, so if you did not do the <code>udev</code> song and dance from earlier in this article, prepare to prefix all future invocations of your driver with <code>sudo</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>if</span> device
</span></span></span><span><span><span>        <span>.</span><span>kernel_driver_active</span><span><span>(</span><span>INTERFACE</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>cannot get kernel driver<span>&#34;</span></span></span><span><span>)</span></span>
</span></span></span><span><span><span>    <span><span>{</span>
</span></span></span></span><span><span><span><span>        device
</span></span></span></span><span><span><span><span>            <span>.</span><span>detach_kernel_driver</span><span><span>(</span><span>INTERFACE</span></span><span><span>)</span></span>
</span></span></span></span><span><span><span><span>            <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>cannot detach kernel driver<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    device
</span></span></span><span><span><span>        <span>.</span><span>claim_interface</span><span><span>(</span><span>INTERFACE</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to claim interface<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Note that the kernel driver won’t be reattached automatically, so you might want to call <code>device.attach_kernel_driver(INTERFACE)</code> if, for some reason, you need it back.</p>
<h2 id="sending-data-to-the-device">Sending data to the device</h2>
<p>Surely, <em>now</em> we are ready to write out some bytes to a device?</p>
<p>Well, almost! If we try to naively start typing out something like <code>device.write</code>, the IDE will helpfully suggest three options: <a href="https://docs.rs/rusb/latest/rusb/struct.DeviceHandle.html#method.write_bulk"><code>write_bulk</code></a>, <a href="https://docs.rs/rusb/latest/rusb/struct.DeviceHandle.html#method.write_control"><code>write_control</code></a> and <a href="https://docs.rs/rusb/latest/rusb/struct.DeviceHandle.html#method.write_interrupt"><code>write_interrupt</code></a>. This corresponds to three out of four possible types of endpoints that the USB standard supports. Once again, <a href="https://www.beyondlogic.org/usbnutshell/usb4.shtml">USB in a NutShell</a> comes in clutch with an explanation of what each of the endpoint types mean. Thankfully, we can mostly skip over the implementation details, as we can once again refer to the <code>lsusb</code> readout from earlier:</p>
<pre><code><span>      Endpoint Descriptor:
</span><span>        bEndpointAddress     0x82  EP 2 IN
</span><span>        bmAttributes            3
</span><span>          Transfer Type            Interrupt
</span><span>          Usage Type               Data
</span><span>        wMaxPacketSize     0x0040  1x 64 bytes
</span><span>        bInterval               1
</span><span>      Endpoint Descriptor:
</span><span>        bEndpointAddress     0x02  EP 2 OUT
</span><span>        bmAttributes            3
</span><span>          Transfer Type            Interrupt
</span><span>          Usage Type               Data
</span><span>        wMaxPacketSize     0x0040  1x 64 bytes
</span><span>        bInterval               1
</span></code></pre>
<p>In USB parlance, <code>IN</code> is always something that the device sends to the host, and <code>OUT</code> is always something that the host sends to the device. Basically, since this interface has two endpoints, and only one of them is an <code>OUT</code> endpoint, it’s safe to assume we’re looking to <code>write_interrupt</code> on endpoint <code>0x02</code>. The peculiarities of Interrupt endpoints will absolutely come back to bite us in a couple of minutes, but for now we can keep them out of sight and out of mind.</p>
<p>For testing purposes, I want to make the pegboard show a solid red color. According to my earlier investigation, this means that I need to send <code>02 00 c0</code>, followed by 64 repeats of <code>0f ff 0f</code>, to an endpoint at <code>0x02</code>. In addition, <code>rusb</code> only exposes the blocking API of <code>libusb</code>, so we will also need to define a timeout after which <code>libusb</code> will give up and error out.</p>

<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>std<span>::</span></span><span>time<span>::</span></span>Duration<span>;</span>
</span><span>
</span><span></span><span><span>const</span> <span>ENDPOINT_OUT</span><span>:</span> <span>u8</span> <span>=</span> <span>0x02</span><span>;</span>
</span><span><span>const</span> <span>ENDPOINT_IN</span><span>:</span> <span>u8</span> <span>=</span> <span>0x82</span><span>;</span>
</span><span><span>const</span> <span>TIMEOUT</span><span>:</span> Duration <span>=</span> <span>Duration<span>::</span></span>from_secs<span><span>(</span><span>1</span></span><span><span>)</span></span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    device
</span></span></span><span><span><span>        <span>.</span><span>claim_interface</span><span><span>(</span><span>INTERFACE</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to claim interface<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>let</span> command<span>:</span> <span><span>[</span><span>u8</span><span>;</span> <span>3</span><span>]</span></span> <span>=</span> <span><span>[</span><span>0x02</span><span>,</span> <span>0x00</span><span>,</span> <span>0xc0</span><span>]</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> color<span>:</span> <span><span>[</span><span>u8</span><span>;</span> <span>3</span><span>]</span></span> <span>=</span> <span><span>[</span><span>0x0f</span><span>,</span> <span>0xff</span><span>,</span> <span>0x0f</span><span>]</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> body<span>:</span> <span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span></span> <span>=</span> command
</span></span></span><span><span><span>        <span>.</span><span>into_iter</span><span><span>(</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>chain</span><span><span>(</span>color<span>.</span><span>into_iter</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>cycle</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>take</span><span><span>(</span><span>192</span></span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>collect</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    device
</span></span></span><span><span><span>        <span>.</span><span>write_interrupt</span><span><span>(</span><span>ENDPOINT_OUT</span><span>,</span> <span>&amp;</span>body<span>,</span> <span>TIMEOUT</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to write to device<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>$ cargo run
</span><span>   Compiling gamer-driver v0.1.0 (/home/ivan/Code/gamer-driver)
</span><span>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</span><span>     Running `target/debug/gamer-driver`
</span></code></pre>
<p>And… just like that, the pegboard now shows a solid red color! We didn’t need to worry about manually splitting packets or any of the underlying implementation, just open up a pipe and write to it! It’s that easy.</p>
<p>Let’s run it again to make sure it was not a fluke!</p>
<h2 id="so-about-those-interrupts">So, about those interrupts…</h2>
<p>Yeah, so if you happen to be following along, and you ran the same binary twice, you’ll notice that the firmware of the pegboard crashes unceremoniously, and shortly after reverts to its default animation. And if I go back to the original packet capture - or the official docs - it’s pretty obvious why: the device sends us back a response, but we never read it.</p>
<p>It turns out that “interrupts” are named as such for a reason, and we should probably handle them as they come in. However, the USB spec defines that the <strong>host</strong> must poll for interrupts. A device cannot interrupt the host by itself.</p>
<p>For our simple “driver”, this means we want to poll the device right after we write to it. Thankfully, <code>rusb</code> gives us a <code>read_interrupt</code> method, and we have already sneakily defined the <code>ENDPOINT_IN</code> constant. Let’s do just that:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    device
</span></span></span><span><span><span>        <span>.</span><span>write_interrupt</span><span><span>(</span><span>ENDPOINT_OUT</span><span>,</span> <span>&amp;</span>body<span>,</span> <span>TIMEOUT</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to write to device<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> buf <span>=</span> <span><span>[</span><span>0_</span><span>u8</span><span>;</span> <span>64</span><span>]</span></span><span>;</span>
</span></span></span><span><span><span>    device
</span></span></span><span><span><span>        <span>.</span><span>read_interrupt</span><span><span>(</span><span>ENDPOINT_IN</span><span>,</span> <span>&amp;</span><span>mut</span> buf<span>,</span> <span>TIMEOUT</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to read from device<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>buf</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>

<p>Running this, we see that the contents of <code>buf</code> are <code>[130, 0, 1, 0...]</code>, which corresponds to <code>0x82 0x00 0x01</code> I got from the research. And since we clear the interrupt buffer every time now, we can run this binary many times to define a single solid color on the device. Neat!</p>
<h2 id="making-this-better">Making this better</h2>
<p>Of course, this is… not really what you want. The device may issue more interrupts. For example, there’s a single button on the desk dock, which can be clicked, double-clicked or long-clicked, and each of those will issue a different interrupt. So what we <strong>really</strong> want is a background task of sort that will actively poll the device for interrupts and process them as they come in.</p>
<p>This is where you can get wild with async Rust, <code>tokio</code>, channels, and other fun stuff. That would certainly be the <em>right way</em> to do it in an actual, serious driver. But to avoid getting into complexities of async Rust, let’s keep it vanilla and use <a href="https://doc.rust-lang.org/std/thread/fn.scope.html"><code>std::thread::scope</code></a>.</p>
<p>We’ll also adjust the timeout for reading interrupts to be 1 millisecond, as requested by the device (the <code>bInterval</code> value in the <code>lsusb</code> readout). This doesn’t mean we will get an interrupt every millisecond, just that the device <em>can</em> send one at that rate. If the device sends nothing (i.e., we get  <code>Err(Timeout)</code>), we will just continue with the loop.</p>
<p>Put together, that might look something like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>std<span>::</span></span>thread<span>;</span>
</span><span></span><span><span>const</span> <span>WRITE_TIMEOUT</span><span>:</span> Duration <span>=</span> <span>Duration<span>::</span></span>from_secs<span><span>(</span><span>1</span></span><span><span>)</span></span><span>;</span>
</span><span><span>const</span> <span>READ_TIMEOUT</span><span>:</span> Duration <span>=</span> <span>Duration<span>::</span></span>from_millis<span><span>(</span><span>1</span></span><span><span>)</span></span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>	</span></span></span><span><span><span>    <span>thread<span>::</span></span>scope<span><span>(</span><span><span><span>|</span></span></span><span><span><span>s</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        s<span>.</span><span>spawn</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>            </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>            device
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>                <span>.</span><span>write_interrupt</span><span><span>(</span><span>ENDPOINT_OUT</span><span>,</span> <span>&amp;</span>body<span>,</span> <span>WRITE_TIMEOUT</span></span><span><span>)</span></span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>                <span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>unable to write to device<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        s<span>.</span><span>spawn</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>            </span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>            <span>loop</span> <span><span>{</span>
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span>                <span>let</span> <span>mut</span> buf <span>=</span> <span><span>[</span><span>0_</span><span>u8</span><span>;</span> <span>64</span><span>]</span></span><span>;</span>
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span>                <span>match</span> device<span>.</span><span>read_interrupt</span><span><span>(</span><span>ENDPOINT_IN</span><span>,</span> <span>&amp;</span><span>mut</span> buf<span>,</span> <span>READ_TIMEOUT</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>                    <span>Ok</span><span><span>(</span><span>_</span></span><span><span>)</span></span> <span>=&gt;</span> <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Interrupt: <span>{}</span><span>&#34;</span></span></span><span><span>,</span> buf<span><span>[</span><span>0</span><span>]</span></span><span>)</span></span><span>,</span>
</span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>                    <span>Err</span><span><span>(</span><span>rusb<span>::</span></span><span>Error<span>::</span></span>Timeout</span><span><span>)</span></span> <span>=&gt;</span> <span>continue</span><span>,</span>
</span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>                    <span>Err</span><span><span>(</span>e</span><span><span>)</span></span> <span>=&gt;</span> <span>panic!</span><span><span>(</span><span><span>&#34;</span>{e:?}<span>&#34;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span>                </span><span><span>}</span></span>
</span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span>        </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>    </span><span><span>}</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>$ cargo run
</span><span>   Compiling gamer-driver v0.1.0 (/home/ivan/Code/gamer-driver)
</span><span>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
</span><span>     Running `target/debug/gamer-driver`
</span><span>Interrupt: 130
</span><span>^C
</span></code></pre>
<p>This… works! Of course, we send no more color frames to the device, so we won’t get any more interrupts, but we now have two threads, one which we can use to change the colors shown, and another which we can use to read the interrupts.</p>
<p>There are some quirks with this device: it seems to require a steady stream of color frames, otherwise it reverts to “offline mode” as it does not receive any new frames from the host, and the first frame’s brightness is significantly lower than the brightness of future frames. Not to mention that, despite what the official protocol documentation would have you believe, the colors seem to be in GRB instead of RGB format, and if you make the device <em>too bright</em>, it will just hard-reset after a couple of seconds. That is, I suppose, a part of the joy of coding.</p>
<p>But this small proof of concept shows that writing simple device drivers is not all that hard, and that 50 lines of code can bring you quite far. Over the next few weeks I hope to polish up my proof of concept, make a small GUI for it, pack it up and share it with the two other Linux users who own this dumb thing. And I’m happy to have learned the basics of reverse-engineering a simple USB device driver, and using that as a foundation for writing my own. Even if I could have just asked for the spec earlier and not fussed with it.</p>

  </div></div>
  </body>
</html>
