<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.nelhage.com/post/advent-of-templates/">Original</a>
    <h1>Advent of Code in C&#43;&#43; Template Metaprogramming</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>This December, the imp of the perverse struck me, and I decided to see how many days of Advent of Code I could do purely in compile-time C++ metaprogramming.</p>
<p>As of this writing, I‚Äôve done two days, and I‚Äôm not sure I‚Äôll make it any further. However, that‚Äôs one more day than I planned to do as of yesterday, which is in turn further than I thought I‚Äôd make it after my first attempt. So we‚Äôll see how it goes.</p>
<p>That said, Day 1 was interesting enough to post a short writeup. You can <a href="https://github.com/nelhage/aoc2023">find the code on GitHub</a>, but I‚Äôll also do an annotated walkthrough of day 1!</p>
<h2 id="basic-types">Basic types¬†<a href="#basic-types"><i>	üîóÔ∏é</i></a> </h2>
<p>We‚Äôll start by defining a basic compile-time <code>list</code> type, and we‚Äôll also use a <code>literal&lt;v&gt;</code> in order to lift values into the type system I decided that we‚Äôd eschew <code>constexpr</code>, since that makes things too easy, but permit ourselves to use basic arithmetic and compile-time integers and booleans.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span>... Elts<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>list</span> {};
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>auto</span> v<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>literal</span> {
</span></span><span><span>    <span>constexpr</span> <span>static</span> <span>auto</span> value <span>=</span> v;
</span></span><span><span>};
</span></span></code></pre></div><h2 id="preamble-reading-input">Preamble: Reading input¬†<a href="#preamble-reading-input"><i>	üîóÔ∏é</i></a> </h2>
<p>Ideally, I would read input using the new <a href="https://thephd.dev/finally-embed-in-c23">C++23</a> <a href="https://thephd.dev/finally-embed-in-c23"><code>#embed</code></a> <a href="https://thephd.dev/finally-embed-in-c23">directive</a>, for maximum purity; but as of this writing it seems hard to find a compiler that supports one. Thus, I fell back to a polyfill using <code>xxd -i</code>. We can run <code>xxd -i &lt; input.txt &gt; input.i</code>, and then include our input using <code>#include</code> and a variadic template. We‚Äôll also use a bit of preprocessor trickery to pass the input file in using a <code>-D</code> compiler flag.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>auto</span>... Elt<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>read_input</span> {
</span></span><span><span>    <span>using</span> type <span>=</span> list<span>&lt;</span>literal<span>&lt;</span><span>char</span>(Elt)<span>&gt;</span>...<span>&gt;</span>;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>#define _QUOTED(x) #x
</span></span></span><span><span><span>#define QUOTED(x) _QUOTED(x)
</span></span></span><span><span><span></span>
</span></span><span><span><span>#ifndef INPUT
</span></span></span><span><span><span></span><span>// Default value to keep my IDE environment happy
</span></span></span><span><span><span></span><span>#define INPUT /dev/null
</span></span></span><span><span><span>#endif
</span></span></span><span><span><span></span>
</span></span><span><span><span>using</span> problem <span>=</span> read_input<span>&lt;</span>
</span></span><span><span><span>#include</span> <span>QUOTED(INPUT)</span><span>
</span></span></span><span><span><span></span><span>&gt;::</span>type;
</span></span></code></pre></div><h2 id="folds">Folds¬†<a href="#folds"><i>	üîóÔ∏é</i></a> </h2>
<p>C++ template metaprogramming is very much a functional language, and so it‚Äôs natural that the main operation we‚Äôll define over lists will be <code>fold</code>.  This is a relatively standard construction:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn,
</span></span><span><span>    <span>typename</span> Init, <span>typename</span> List<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>fold</span> {};
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn,
</span></span><span><span>    <span>typename</span> Init<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>fold</span><span>&lt;</span>Fn, Init, list<span>&lt;&gt;&gt;</span> {
</span></span><span><span>    <span>using</span> type <span>=</span> Init;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn,
</span></span><span><span>          <span>typename</span> Init, <span>typename</span> El1, <span>typename</span>... Elts<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>fold</span><span>&lt;</span>Fn, Init, list<span>&lt;</span>El1, Elts...<span>&gt;&gt;</span> {
</span></span><span><span>    <span>using</span> type <span>=</span> fold<span>&lt;</span>
</span></span><span><span>        Fn,
</span></span><span><span>        <span>typename</span> Fn<span>&lt;</span>Init, El1<span>&gt;::</span>type,
</span></span><span><span>        list<span>&lt;</span>Elts...<span>&gt;&gt;::</span>type;
</span></span><span><span>};
</span></span></code></pre></div><h2 id="some-more-helpers">Some more helpers¬†<a href="#some-more-helpers"><i>	üîóÔ∏é</i></a> </h2>
<p>We‚Äôll introduce a few more helpers, and then we‚Äôre almost ready for Part 1. We‚Äôll add a <code>nil</code> sentinel, a basic <code>if</code> conditional, and an <code>or_else</code> function that takes the first non-nil of its arguments:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>struct</span> <span>nil</span>;
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> T<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>is_nil</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span>false<span>&gt;</span>; };
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;&gt;</span>
</span></span><span><span><span>struct</span> <span>is_nil</span><span>&lt;</span>nil<span>&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span>true<span>&gt;</span>; };
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> Cond, <span>typename</span> Then, <span>typename</span> Else<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>if_else</span> {};
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> Then, <span>typename</span> Else<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>if_else</span><span>&lt;</span>literal<span>&lt;</span>true<span>&gt;</span>, Then, Else<span>&gt;</span> { <span>using</span> type <span>=</span> Then; };
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> Then, <span>typename</span> Else<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>if_else</span><span>&lt;</span>literal<span>&lt;</span>false<span>&gt;</span>, Then, Else<span>&gt;</span> { <span>using</span> type <span>=</span> Else; };
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> L, <span>typename</span> R<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>or_else</span> { <span>using</span> type <span>=</span> L; };
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> R<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>or_else</span><span>&lt;</span>nil, R<span>&gt;</span> { <span>using</span> type <span>=</span> R; };
</span></span></code></pre></div>
<p>If you‚Äôre not doing Advent of Code, a quick refresher for the problem statement: For each line in the input file, we need to find the <strong>first</strong> and <strong>last</strong> digit in that line, and then concatenate them into a two-digit number (the ‚Äúcalibration number‚Äù), and output the sum of every calibration number in the file.</p>
<p>We‚Äôll implement this using a single <code>fold</code> over the input for efficiency. As we go, we‚Äôll track state consistent of a tuple of <code>(sum so far, first digit in current line, last digit seen so far in line)</code>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> Accum, <span>typename</span> FirstDigit, <span>typename</span> LastDigit<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>State</span> {
</span></span><span><span>    <span>using</span> accum <span>=</span> Accum;
</span></span><span><span>    <span>using</span> first <span>=</span> FirstDigit;
</span></span><span><span>    <span>using</span> last <span>=</span> LastDigit;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>using</span> empty_state <span>=</span> State<span>&lt;</span>literal<span>&lt;</span><span>0</span><span>&gt;</span>, nil, nil<span>&gt;</span>;
</span></span></code></pre></div><p>The fold function advances the state using some simple rules:</p>
<ul>
<li>If the character is a newline,  we compute this line‚Äôs calibration value, add it in to the accumulator, and reset the per-line state.</li>
<li>If the character is a digit, we update the ‚Äúlast digit‚Äù to this digit unconditionally
<ul>
<li>And also update the first digit, if we haven‚Äôt already seen a digit this line.</li>
</ul>
</li>
</ul>
<p>These are all fairly straightforward applications of existing helpers:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> T<span>&gt;</span>
</span></span><span><span><span>using</span> as_digit <span>=</span> if_else<span>&lt;</span>
</span></span><span><span>    literal<span>&lt;</span>T<span>::</span>value <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> T<span>::</span>value <span>&lt;=</span> <span>&#39;9&#39;</span><span>&gt;</span>,
</span></span><span><span>    literal<span>&lt;</span>T<span>::</span>value <span>-</span> <span>&#39;0&#39;</span><span>&gt;</span>,
</span></span><span><span>    nil<span>&gt;</span>;
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> In, <span>typename</span> Char<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>Fn</span> {
</span></span><span><span>    <span>using</span> digit <span>=</span> as_digit<span>&lt;</span>Char<span>&gt;::</span>type;
</span></span><span><span>
</span></span><span><span>    <span>struct</span> <span>IfNewline</span> {
</span></span><span><span>        <span>using</span> type <span>=</span> State<span>&lt;</span>
</span></span><span><span>            literal<span>&lt;</span>In<span>::</span>accum<span>::</span>value <span>+</span> <span>10</span> <span>*</span> In<span>::</span>first<span>::</span>value <span>+</span> In<span>::</span>last<span>::</span>value<span>&gt;</span>,
</span></span><span><span>            nil,
</span></span><span><span>            nil<span>&gt;</span>;
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>using</span> type <span>=</span> if_else<span>&lt;</span>
</span></span><span><span>        literal<span>&lt;</span>Char<span>::</span>value <span>==</span> <span>&#39;\n&#39;</span><span>&gt;</span>,
</span></span><span><span>        IfNewline,
</span></span><span><span>        if_else<span>&lt;</span>
</span></span><span><span>            <span>typename</span> is_nil<span>&lt;</span>digit<span>&gt;::</span>type,
</span></span><span><span>            In,
</span></span><span><span>            <span>typename</span> if_else<span>&lt;</span>
</span></span><span><span>                <span>typename</span> is_nil<span>&lt;</span><span>typename</span> In<span>::</span>first<span>&gt;::</span>type,
</span></span><span><span>                State<span>&lt;</span><span>typename</span> In<span>::</span>accum, digit, digit<span>&gt;</span>,
</span></span><span><span>                State<span>&lt;</span><span>typename</span> In<span>::</span>accum, <span>typename</span> In<span>::</span>first, digit<span>&gt;</span>
</span></span><span><span>                <span>&gt;::</span>type
</span></span><span><span>            <span>&gt;&gt;::</span>type<span>::</span>type;
</span></span><span><span>};
</span></span></code></pre></div><p>One bit of trickiness is that, in order to make the outer <code>if_else</code> lazy, we evaluate <code>::type</code> on its <strong>result</strong>, instead of on its arguments. This results in the compiler evaluating whichever of the consequent or the alternate is actually selected.</p>

<p>For convenience, we‚Äôll allow a tiny bit of runtime behavior to print the result:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    <span>using</span> answer <span>=</span> solve<span>&lt;</span>problem<span>&gt;::</span>type;
</span></span><span><span>    printf(<span>&#34;%d</span><span>\n</span><span>&#34;</span>, answer<span>::</span>value);
</span></span><span><span>}
</span></span></code></pre></div><p>Armed with that, we can now verify the initial test case included in the problem body:</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ xxd -i &lt; test.txt &gt; test.i <span>&amp;&amp;</span> <span>\
</span></span></span><span><span><span></span>  c++ -DINPUT=test.i -std=c++20 part1.cc -o out/part1 &amp;&amp; \
</span></span><span><span>  out/part1
</span></span><span><span>142
</span></span></code></pre></div><p>But if we try the real input, we run into issues:</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ xxd -i &lt; input.txt &gt; input.i <span>&amp;&amp;</span> <span>\
</span></span></span><span><span><span></span>  c++ -DINPUT=input.i -std=c++20 part1.cc -o out/part1 &amp;&amp; \
</span></span><span><span>  out/part1
</span></span><span><span><span>
</span></span></span><span><span><span></span>part1.cc:8:1: fatal error: recursive template instantiation exceeded maximum depth of 1024
</span></span><span><span>using as_digit = if_else&lt;
</span></span><span><span><span>
</span></span></span><span><span><span></span> [cut C++ template spew]
</span></span><span><span><span>
</span></span></span><span><span><span></span>part1.cc:8:1: note: use -ftemplate-depth=N to increase recursive template instantiation depth
</span></span></code></pre></div><p>The basic problem here is that our <code>fold</code> needs to recurse for each character in the input, and the provided test case is over 20,000 characters long! We can try increasing <code>-ftemplate-depth</code>, per the provided suggestion; On my machine we <strong>can</strong> make the program compile with a large-enough value, but clang gives scary warnings about stack capacity and is very slow ‚Äì compiling takes 90s or more.</p>
<p>We‚Äôll need a different approach.</p>
<h2 id="optimizing-fold">Optimizing <code>fold</code>¬†<a href="#optimizing-fold"><i>	üîóÔ∏é</i></a> </h2>
<p>The problem here is fairly fundamental; recursive template expansion is basically <strong>the</strong> game in town for template metaprogramming. However, it turns out that there is one option we have up our sleeve.</p>
<p><code>list&lt;&gt;</code> is a variadic template, which means we can manipulate its entire contents as a C++ <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">parameter pack</a>. As long as we can keep the arguments as a parameter pack, we can use relatively fast paths inside the compiler, and work much more efficiently.</p>
<p>Poring over the above cppreference page, we notice that C++17 added ‚Äúfold expressions‚Äù ‚Äî a way of turning a parameter pack into an expression that folds a user-chosen operator over the pack! This is suspiciously similar to what we‚Äôre trying to do, but it operates on the <strong>value</strong> level, using value-level operators.</p>
<p>However, it turns out that with some judicious use of <code>auto</code>, <code>decltype</code>, and a wrapper struct, this poses no problem ‚Äî we can construct types that perform our type-level computation in the process of typechecking the fold expression.</p>
<p>The compiler will still have to deal with a massively nested <strong>expression</strong>, but in my testing that‚Äôs much more efficient than a 20,000-deep template:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span><span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>fold_helper</span> {
</span></span><span><span>    <span>template</span> <span>&lt;</span><span>typename</span> T<span>&gt;</span>
</span></span><span><span>    <span>struct</span> <span>F</span> {
</span></span><span><span>        <span>using</span> type <span>=</span> T;
</span></span><span><span>
</span></span><span><span>        <span>template</span> <span>&lt;</span><span>typename</span> R<span>&gt;</span>
</span></span><span><span>        <span>auto</span> <span>operator</span><span>&lt;&lt;</span>(F<span>&lt;</span>R<span>&gt;</span>) {
</span></span><span><span>            <span>return</span> F<span>&lt;</span><span>typename</span> Fn<span>&lt;</span>T, R<span>&gt;::</span>type<span>&gt;</span>{};
</span></span><span><span>        };
</span></span><span><span>    };
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn,
</span></span><span><span>          <span>typename</span> Init, <span>typename</span>... Elts<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>fold</span><span>&lt;</span>Fn, Init, list<span>&lt;</span>Elts...<span>&gt;&gt;</span> {
</span></span><span><span>    <span>template</span> <span>&lt;</span><span>typename</span> T<span>&gt;</span>
</span></span><span><span>    <span>using</span> F <span>=</span> fold_helper<span>&lt;</span>Fn<span>&gt;::</span><span>template</span> F<span>&lt;</span>T<span>&gt;</span>;
</span></span><span><span>
</span></span><span><span>    <span>using</span> type <span>=</span> <span>decltype</span>((F<span>&lt;</span>Init<span>&gt;</span>{} <span>&lt;&lt;</span> ... <span>&lt;&lt;</span> F<span>&lt;</span>Elts<span>&gt;</span>{}))<span>::</span>type;
</span></span><span><span>};
</span></span></code></pre></div><p>The struct <code>fold_helper&lt;Fn&gt;::F</code> translates our type-level function into one that can be evaluated via an expression-level operator. The expression <code>fold_helper&lt;Fn&gt;::F&lt;A&gt;{} &lt;&lt; fold_helper&lt;Fn&gt;::F&lt;B&gt;{}</code> will evaluate to a value of type <code>Fn&lt;A, B&gt;::type</code>. Once we have that, we expand the list elements into a fold expression using that translation, and use <code>decltype</code> to access the type of the output. At no point will any code actually be emitted or ‚Äî horrors! ‚Äî evaluated.</p>
<p>And this works! With this <code>fold</code> implementation, the part 1 solution above compiles iin about a second on my M1 Air, and gives the correct answer!</p>
<div><pre tabindex="0"><code data-lang="console"><span><span>$ xxd -i &lt; input.txt &gt; input.i <span>&amp;&amp;</span> <span>\
</span></span></span><span><span><span></span>  time c++ -fbracket-depth=25000 -DINPUT=input.i -std=c++20 \
</span></span><span><span>    part1.cc -o out/part1 &amp;&amp; \
</span></span><span><span>  out/part1
</span></span><span><span>c++ -fbracket-depth=25000 -DINPUT=input.i -std=c++20 part1.cc -o out/part1  1.10s user 0.06s system 101% cpu 1.141 total
</span></span><span><span>54390
</span></span></code></pre></div>
<p>For part 2, digits may now be spelled out ‚Äì <code>seven82683</code> has a calibration value of ‚Äú73.‚Äù</p>
<p>We‚Äôll start by introducing a short abstraction. Handling newlines in our fold worked, but was a bit annoying. We can write a helper that abstracts the splitting on newlines and lets us worry about individual lines.</p>
<p>The interface will take the form of a <code>fold</code> over <strong>lines,</strong> instead of, say, materializing a list-of-lists; keeping our processing streaming in this fashion is very important for performance. The helper is, itself, a fairly straightforward application of <code>fold</code>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> Head, <span>typename</span> Tail<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>pair</span> {
</span></span><span><span>    <span>using</span> head <span>=</span> Head;
</span></span><span><span>    <span>using</span> tail <span>=</span> Tail;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn, <span>typename</span> Delim<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>fold_lines_f</span> {
</span></span><span><span>    <span>template</span> <span>&lt;</span><span>typename</span> In, <span>typename</span> Elt<span>&gt;</span>
</span></span><span><span>    <span>struct</span> <span>F</span>{
</span></span><span><span>        <span>using</span> type <span>=</span> pair<span>&lt;</span>
</span></span><span><span>            <span>typename</span> append<span>&lt;</span><span>typename</span> In<span>::</span>head, Elt<span>&gt;::</span>type,
</span></span><span><span>            <span>typename</span> In<span>::</span>tail
</span></span><span><span>            <span>&gt;</span>;
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>template</span> <span>&lt;</span><span>typename</span> A<span>&gt;</span>
</span></span><span><span>    <span>struct</span> <span>F</span><span>&lt;</span>A, Delim<span>&gt;</span>{
</span></span><span><span>        <span>using</span> type <span>=</span> pair<span>&lt;</span>
</span></span><span><span>            list<span>&lt;&gt;</span>,
</span></span><span><span>            <span>typename</span> Fn<span>&lt;</span><span>typename</span> A<span>::</span>tail, <span>typename</span> A<span>::</span>head<span>&gt;::</span>type
</span></span><span><span>            <span>&gt;</span>;
</span></span><span><span>    };
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>template</span><span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span>, <span>typename</span><span>&gt;</span> <span>typename</span> Fn,
</span></span><span><span>         <span>typename</span> Init, <span>typename</span> L,
</span></span><span><span>         <span>typename</span> Delim <span>=</span> literal<span>&lt;</span><span>&#39;\n&#39;</span><span>&gt;&gt;</span>
</span></span><span><span><span>struct</span> <span>fold_lines</span> {
</span></span><span><span>    <span>using</span> type <span>=</span> fold<span>&lt;</span>
</span></span><span><span>        fold_lines_f<span>&lt;</span>Fn, Delim<span>&gt;::</span><span>template</span> F,
</span></span><span><span>        pair<span>&lt;</span>list<span>&lt;&gt;</span>, Init<span>&gt;</span>,
</span></span><span><span>        L<span>&gt;::</span>type<span>::</span>tail;
</span></span><span><span>};
</span></span></code></pre></div><p>Now that we have that, we need to compute calibration values within a single line‚Ä¶</p>
<h2 id="manually-compiling-a-state-machine">Manually compiling a state machine¬†<a href="#manually-compiling-a-state-machine"><i>	üîóÔ∏é</i></a> </h2>
<p>We‚Äôre going to once again implement calibration using a single <code>fold</code> over each line.</p>
<p>In order to match each of the possible digits, we‚Äôll maintain a finite-state-machine matcher, and write transition rules for each &lt;state, character&gt; pair ‚Äî this is essentially the DFA that <a href="https://swtch.com/~rsc/regexp/regexp1.html">some regular expression implementations</a> would produce under the hood. We‚Äôll name states by the ‚Äúrelevant‚Äù substring we‚Äôve seen so far; so, for instance, <code>Sseve</code> means we just saw ‚Äúseve‚Äù; in this case, if we encounter an <code>n</code> then we‚Äôve found the digit <code>7</code>.</p>
<p>Note that many digits contain letters which can start another digit, and we‚Äôll need to handle these in our transitions; for instance, if we‚Äôre in state <code>Sseve</code> and we see an <code>i</code>, we need to move into <code>Sei</code> because we might be looking at the string ‚Äúseveight‚Äù and need to handle the <code>eight</code>. Fortunately, no two digits have more-complex overlaps, so the state machine remains fairly simple.</p>
<p>We‚Äôll start with state definitions, using <code>S0</code> to mean ‚Äúno relevant prefix‚Äù:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>struct</span> <span>S0</span> {};
</span></span><span><span>
</span></span><span><span><span>// one
</span></span></span><span><span><span></span><span>struct</span> <span>So</span> {};
</span></span><span><span><span>struct</span> <span>Son</span> {};
</span></span><span><span><span>// two
</span></span></span><span><span><span></span><span>struct</span> <span>St</span> {};
</span></span><span><span><span>struct</span> <span>Stw</span> {};
</span></span><span><span><span>// three
</span></span></span><span><span><span></span><span>struct</span> <span>Sth</span> {};
</span></span><span><span><span>struct</span> <span>Sthr</span> {};
</span></span><span><span><span>struct</span> <span>Sthre</span> {};
</span></span><span><span><span>// four
</span></span></span><span><span><span></span><span>struct</span> <span>Sf</span> {};
</span></span><span><span><span>struct</span> <span>Sfo</span> {};
</span></span><span><span><span>struct</span> <span>Sfou</span> {};
</span></span><span><span><span>// five
</span></span></span><span><span><span></span><span>struct</span> <span>Sfi</span> {};
</span></span><span><span><span>struct</span> <span>Sfiv</span> {};
</span></span><span><span><span>// six
</span></span></span><span><span><span></span><span>struct</span> <span>Ss</span> {};
</span></span><span><span><span>struct</span> <span>Ssi</span> {};
</span></span><span><span><span>// seven
</span></span></span><span><span><span></span><span>struct</span> <span>Sse</span> {};
</span></span><span><span><span>struct</span> <span>Ssev</span> {};
</span></span><span><span><span>struct</span> <span>Sseve</span> {};
</span></span><span><span><span>// eight
</span></span></span><span><span><span></span><span>struct</span> <span>Se</span> {};
</span></span><span><span><span>struct</span> <span>Sei</span> {};
</span></span><span><span><span>struct</span> <span>Seig</span> {};
</span></span><span><span><span>struct</span> <span>Seigh</span> {};
</span></span><span><span><span>// nine
</span></span></span><span><span><span></span><span>struct</span> <span>Sn</span> {};
</span></span><span><span><span>struct</span> <span>Sni</span> {};
</span></span><span><span><span>struct</span> <span>Snin</span> {};
</span></span></code></pre></div><p>And we can define the transition rules. We‚Äôll make liberal use of wildcards, and rely on relative specificity of the partial specializations to pick the correct rule.</p>
<p>If no other rule matches, we go back to <code>S0</code>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> St, <span>typename</span> El<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>next_state</span> { <span>using</span> type <span>=</span> S0; };
</span></span></code></pre></div><p>And if we see the first letter for any digit ‚Äî and no more-specific rule matched ‚Äî we can move directly into that state.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// Initial letters
</span></span></span><span><span><span></span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;o&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> So; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;t&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> St; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;f&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sf; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;s&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Ss; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Se; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;n&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sn; };
</span></span></code></pre></div><p>Then we define the transitions within and between rules. Most of these are straightforward ‚Äî e.g. <code>(So,</code> <code>&#39;``n``&#39;``) ‚Üí Son</code>, but we have to be careful of the ones where we might jump ‚Äúmidway‚Äù into matching another digit.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// one
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>So,    literal<span>&lt;</span><span>&#39;n&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Son; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Son,   literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Se; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Son,   literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sni; };
</span></span><span><span><span>// two
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>St,    literal<span>&lt;</span><span>&#39;w&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Stw; };
</span></span><span><span><span>// three
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>St,    literal<span>&lt;</span><span>&#39;h&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sth; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sth,   literal<span>&lt;</span><span>&#39;r&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sthr; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sthr,  literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sthre; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sthre, literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sei; };
</span></span><span><span><span>// four
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sf,    literal<span>&lt;</span><span>&#39;o&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sfo; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sfo,   literal<span>&lt;</span><span>&#39;u&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sfou; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sfo,   literal<span>&lt;</span><span>&#39;n&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Son; };
</span></span><span><span><span>// five
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sf,    literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sfi; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sfi,   literal<span>&lt;</span><span>&#39;v&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sfiv; };
</span></span><span><span><span>// six
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Ss,    literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Ssi; };
</span></span><span><span><span>// seven
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Ss,    literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sse; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sse,   literal<span>&lt;</span><span>&#39;v&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Ssev; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sse,   literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sei; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Ssev,  literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sseve; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sseve, literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sei; };
</span></span><span><span><span>// eight
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Se,    literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sei; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sei,   literal<span>&lt;</span><span>&#39;g&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Seig; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Seig,  literal<span>&lt;</span><span>&#39;h&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Seigh; };
</span></span><span><span><span>// nine
</span></span></span><span><span><span></span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sn,    literal<span>&lt;</span><span>&#39;i&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Sni; };
</span></span><span><span><span>template</span><span>&lt;&gt;</span> <span>struct</span> <span>next_state</span><span>&lt;</span>Sni,   literal<span>&lt;</span><span>&#39;n&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> Snin; };
</span></span></code></pre></div><p>We haven‚Äôt yet defined when we ‚Äúmatch‚Äù a rule, or what to do when we do; It turns out, for this problem, that defining ‚Äúsuccessful match‚Äù as a separate function from our state transition makes both functions much simpler. If you like to be technical, we‚Äôre essentially implementing what EEs would call <a href="https://en.wikipedia.org/wiki/Mealy_machine">a Mealy state machine</a> for this matcher.</p>
<p>The <code>match_digit</code> function will will have a similar signature to <code>next_state</code> ‚Äî <code>state, input ‚Üí digit | nil</code> ‚Äì and tells us which digit (if any) matched at any particular position:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> State, <span>typename</span> El<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>match_digit</span> { <span>using</span> type <span>=</span> nil; };
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Son,   literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>1</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Stw,   literal<span>&lt;</span><span>&#39;o&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>2</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Sthre, literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>3</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Sfou,  literal<span>&lt;</span><span>&#39;r&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>4</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Sfiv,  literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>5</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Ssi,   literal<span>&lt;</span><span>&#39;x&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>6</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Sseve, literal<span>&lt;</span><span>&#39;n&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>7</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Seigh, literal<span>&lt;</span><span>&#39;t&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>8</span><span>&gt;</span>; };
</span></span><span><span><span>template</span> <span>&lt;&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>Snin,  literal<span>&lt;</span><span>&#39;e&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>9</span><span>&gt;</span>; };
</span></span><span><span>
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;0&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>0</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;1&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>1</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;2&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>2</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;3&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>3</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;4&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>4</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;5&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>5</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;6&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>6</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;7&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>7</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;8&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>8</span><span>&gt;</span>; };
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span> S<span>&gt;</span> <span>struct</span> <span>match_digit</span><span>&lt;</span>S, literal<span>&lt;</span><span>&#39;9&#39;</span><span>&gt;&gt;</span> { <span>using</span> type <span>=</span> literal<span>&lt;</span><span>9</span><span>&gt;</span>; };
</span></span></code></pre></div><p>(We could replace the last 10 specializations with a conditional inside the primary definition, but I find this version somewhat more straightforward, if a bit verbose).</p>
<p>With these types in place, we can now do a very similar fold as in part 1 to compute the calibration value for a single line. Compared to that one, we no longer need to track the overall accumulator ‚Äî we‚Äôll use <code>fold_lines</code> to push that to an outer loop ‚Äî but we do need to keep the matcher state, and so our state class looks very similar:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> MatchState, <span>typename</span> First, <span>typename</span> Last<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>CalibrationState</span> {
</span></span><span><span>    <span>using</span> state <span>=</span> MatchState;
</span></span><span><span>    <span>using</span> first <span>=</span> First;
</span></span><span><span>    <span>using</span> last <span>=</span> Last;
</span></span><span><span>};
</span></span></code></pre></div><p>To advance one element, we compute the output state, and the matched digit (if any). We‚Äôll also use some of our helpers to simplify the ‚Äúfirst / last seen digit‚Äù computation:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> State, <span>typename</span> El<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>LineF</span> {
</span></span><span><span>    <span>using</span> new_state <span>=</span> next_state<span>&lt;</span><span>typename</span> State<span>::</span>state, El<span>&gt;::</span>type;
</span></span><span><span>    <span>using</span> digit <span>=</span> match_digit<span>&lt;</span><span>typename</span> State<span>::</span>state, El<span>&gt;::</span>type;
</span></span><span><span>
</span></span><span><span>    <span>using</span> type <span>=</span> CalibrationState<span>&lt;</span>
</span></span><span><span>        new_state,
</span></span><span><span>        <span>typename</span> or_else<span>&lt;</span><span>typename</span> State<span>::</span>first, digit<span>&gt;::</span>type,
</span></span><span><span>        <span>typename</span> or_else<span>&lt;</span>digit, <span>typename</span> State<span>::</span>last<span>&gt;::</span>type
</span></span><span><span>        <span>&gt;</span>;
</span></span><span><span>};
</span></span></code></pre></div><p>With the fold function in place, computing calibration values is easy:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span><span>&lt;</span><span>typename</span> Line<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>calibration</span> {
</span></span><span><span>    <span>using</span> acc <span>=</span> fold<span>&lt;</span>LineF, CalibrationState<span>&lt;</span>S0, nil, nil<span>&gt;</span>, Line<span>&gt;::</span>type;
</span></span><span><span>    <span>using</span> type <span>=</span> literal<span>&lt;</span>acc<span>::</span>first<span>::</span>value<span>*</span><span>10</span> <span>+</span> acc<span>::</span>last<span>::</span>value<span>&gt;</span>;
</span></span><span><span>};
</span></span></code></pre></div><p>We can even write some quick test cases ‚Äî C++ template metaprogramming has excellent support for in-line tests.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>static_assert</span>(is_same<span>&lt;</span>
</span></span><span><span>              <span>typename</span> calibration<span>&lt;</span><span>typename</span> read_input<span>&lt;</span>
</span></span><span><span>              <span>&#39;s&#39;</span>, <span>&#39;e&#39;</span>, <span>&#39;v&#39;</span>, <span>&#39;e&#39;</span>, <span>&#39;n&#39;</span>, <span>&#39;8&#39;</span>, <span>&#39;2&#39;</span>, <span>&#39;6&#39;</span>, <span>&#39;8&#39;</span>, <span>&#39;3&#39;</span>
</span></span><span><span>              <span>&gt;::</span>type<span>&gt;::</span>type,
</span></span><span><span>              literal<span>&lt;</span><span>73</span><span>&gt;&gt;::</span>value);
</span></span></code></pre></div><h2 id="putting-it-all-together">Putting it all together¬†<a href="#putting-it-all-together"><i>	üîóÔ∏é</i></a> </h2>
<p>The fold over lines is a simple sum of calibration values ‚Äî almost trivial, at this point.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span><span>&lt;</span><span>typename</span> State, <span>typename</span> Line<span>&gt;</span>
</span></span><span><span><span>struct</span> <span>Fn</span> {
</span></span><span><span>    <span>using</span> lineval <span>=</span> calibration<span>&lt;</span>Line<span>&gt;::</span>type;
</span></span><span><span>
</span></span><span><span>    <span>using</span> type <span>=</span> literal<span>&lt;</span>State<span>::</span>value <span>+</span> lineval<span>::</span>value<span>&gt;</span>;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>using</span> answer <span>=</span> fold_lines<span>&lt;</span>Fn, literal<span>&lt;</span><span>0</span><span>&gt;</span>, problem<span>&gt;::</span>type;
</span></span></code></pre></div><p>It works! And, on my laptop, it‚Äôs ‚Äúonly‚Äù ~1.5s to compile!</p>

<p>I‚Äôve done a bit of C++ template metaprogramming here and there in the past ‚Äî for instance, I wrote <a href="https://github.com/nelhage/bemu/blob/master/x86.h">a simple x86 assembler for C++, once</a> ‚Äî but this was my first really encounter with C++17 TMP and with truly going down the deep end.</p>
<p>And, I‚Äôve heard this sentiment before, but after working through this problem ‚Ä¶ honestly I have to admit that modern C++ templates are a pretty passable functional programming language, even with some nice features! And I was pleasantly surprised to discover the fold-expression trick, which even allows for relatively-efficient list processing.</p>
<p>I‚Äôm ‚Ä¶ still not sure how many more days I will do, or how much more C++ I will have cause to write, but I ended up quite enjoying the exercise!</p>


</div></div>
  </body>
</html>
