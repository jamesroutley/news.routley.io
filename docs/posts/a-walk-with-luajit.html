<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.polarsignals.com/blog/posts/2024/11/13/lua-unwinding">Original</a>
    <h1>A Walk with LuaJIT</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p></div><p>The following is a chronicle of implementing a general purpose zero-instrumentation <a href="https://ebpf.io/what-is-ebpf/">BPF</a> based profiler for <a href="http://www.luajit.org/">LuaJIT</a>. Some assumptions are made about what this entails and it may be helpful to read some of our other work in this <a href="https://www.polarsignals.com/blog/posts/2023/10/04/profiling-python-and-ruby-with-ebpf">area</a>. One major change from prior efforts is that instead of working with the original <a href="http://www.parca.dev/">Parca</a> unwinder we are now working with the <a href="https://github.com/parca-dev/opentelemetry-ebpf-profiler">OpenTelemetry eBPF profiler</a>. If you missed that announcement you can read about it <a href="https://www.polarsignals.com/blog/posts/2024/08/13/parca-opentelemetry-bright-future">here</a>. The TLDR is that a tiny BPF program scrapes the minimal information needed from the stack and passes it off to a userland program that flushes out all the required scaffolding and metadata extraction.  </p><p><a>Lua</a> is a dynamic general purpose scripting language that&#39;s been around since the 90s. Lua is very small, by way of comparison a stripped Lua binary is only ~230kb on AMD64, while a recent version of python is over 5mb! Lua is commonly used for game scripting but you&#39;ll also find it in text editors like <a href="https://lite-xl.com/">Lite</a> and <a href="https://howl.io/">Howl</a> and even commercial image editing programs like <a href="https://developer.adobe.com/lightroom-classic/">Adobe Lightroom (Classic)</a>. Another example is Redis/Valkey which supports Lua scripting as an escape value for keeping the database simple yet extensible (&#34;hey I want feature XYZ, no way buddy, use Lua!&#34;), if some niche feature can be done via a Lua script it doesn&#39;t need to be built-in. Similar to how a browser uses JavaScript and Emacs uses LISP, these programs use Lua as a dynamic plugin framework so that the programs can be extended and customized in a much easier and safer way than using C/C++. But that&#39;s Lua, we&#39;re here to talk about LuaJIT!</p><p>Polar Signals&#39; interest in <a href="http://www.luajit.org/">LuaJIT</a> stems from its use in the <a href="http://www.openresty.org/">OpenResty</a> web framework which combines Nginx and LuaJIT with a suite of modules for connecting to various back end systems and doing general dynamic web application work. You may be using LuaJIT and OpenResty without knowing it already if you use the <a href="https://apisix.apache.org/">Apache APISIX API</a> gateway. LuaJIT came on the scene in 2005 when Mike Pall released the first version. This was back in the dynamic language interpreter dark ages before <a href="http://v8.dev/">v8</a>, <a href="http://spidermonkey.dev/">SpiderMonkey</a>, <a href="https://webkit.org/blog/214/introducing-squirrelfish-extreme/">SquirrelFish</a>, <a href="https://en.wikipedia.org/wiki/Tamarin_(software)">Tamarin</a> et. al when there was some question about whether a JIT for dynamic languages made any sense. Java had shown JITs can do amazing things for static languages but like what&#39;s the point of generating code to use an add instruction to add two integers when you have to dedicate hundreds of instructions to hash table lookups and type wrangling to even get the two integers into registers in the first place? Turns out you can get rid of a lot of dynamic variable lookups and make educated guesses about types and have fallback code handle the edge cases and get massive speedups. LuaJIT also has a high performance interpreter and it sports an extremely powerful <a href="https://luajit.org/ext_ffi.html">FFI layer</a>.  LuaJIT can be 6 to 20 times faster than Lua on simple benchmarks. Performance is probably close to what you&#39;d get with a modern JavaScript engine. However the most unique thing about LuaJIT is the tracing JIT.</p><div><p><span><img alt="This one goes to 0xB" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p><span>This one goes to 0xB</span></p></div><p>LuaJIT isn&#39;t a traditional (i.e. method based) JIT like you&#39;ll find in the JVM or CLR. A trace based JIT has machinery to detect frequently repeated loops and when one is detected it starts to record instructions (by storing instructions executed in a side buffer) and then when the loop completes JITs that &#34;trace&#34; of instructions and jumps to the JIT&#39;d code instead of interpreting. The trace can traverse many functions and all the branches not taken are left out of the trace. The trick is the trace just needs to make sure if any of the conditions on the hot path change then it has to exit the trace and fall back to the interpreter. This basically boils down to aggressive inlining but only the parts of the code that get executed, not like traditional inlining where whole methods are lifted. Frequently in low level languages you&#39;ll see code like this:</p><pre><pre><p><span>func</span><span> </span><span>doit</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>if</span><span> common_case </span><span>{</span><span></span></p><p><span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>doit_general_slow</span><span>(</span><span>)</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span></p></pre></pre><p>We avoid function call overhead on the common case and fallback to the slow path otherwise (since <code>doit</code> is a small function it would typically be inlined in a static native language). Tracing JITs generalize this concept to an arbitrary set of &#34;common_case&#34; conditions and arbitrary amount of code which can be hoisted into the fast path. This is a level of optimization that method-based JITs can&#39;t really match, even if they employ aggressive inlining they will always pay a higher price in instruction cache penalties because they can&#39;t jettison the code for branches not taken. Tracing JITs spend all their time on code that matters so your JIT dollar goes much further. So what&#39;s the catch? </p><p>Trace based JITs aren&#39;t very common, LuaJIT might be the only one to ever get widespread adoption. The catch is the problem called &#34;trace explosion&#34;. If your program has many different hot loops the JIT will eat a lot of time and space JIT&#39;ing an immense variety of paths through your code that can exhaust the memory resources of the target machine. Think about recursion and many arm&#39;d switch statements and for loops with lots of nested if/else clauses. One trick is to limit the size of traces and have the ability to stitch traces together so that what may start out as one trace that has many side exits to the interpreter and over time those side exits can be patched to jump to new traces as new hot loops are detected. Lots more heuristics can be used to make the trace &#34;space&#34; not blow up but at the end of the day having a fast interpreter to fall back on, a very fast JIT and the ability to efficiently garbage collect old cold traces is very important. Method based JITs don&#39;t have this problem, they JIT a function once and it&#39;s done so they typically don&#39;t have to worry about code memory consumption. Anyways great effort was made trying to make trace based JITs for other languages that never got much traction, see <a href="https://dl.acm.org/doi/10.1145/1542476.1542528">this paper</a> and <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2010/03/techreport2.pdf">this one</a> for some gory details. Adobe even tried to build <a href="https://wiki.mozilla.org/Tamarin:Tracing">one</a> for ActionScript that went the way of the dodo bird. Tracing JITs may have not gone mainstream but a lot of the techniques discovered by tracing JIT research live on in today&#39;s JavaScript engines and tracing JITs will go down in history as helping to dispel the idea that JITing dynamic languages isn&#39;t worth it. Maybe tracing JITs just need more context about what code is important to optimize, like profiling information...</p><p>Oh wait, that&#39;s what we&#39;re here to talk about! So, how do we profile LuaJIT programs? Specifically, how do we implement a zero instrumentation profiler that works with any version of LuaJIT one may find in the myriad versions of OpenResty that are in common use? Basically we just have to walk the stack and detect where native code jumps into Lua code and walk the Lua stack and detect all Lua call frames and report them in the context of the native call frames above and below. Nothing to it!</p><p>The obvious first step is to ask your favorite AI agent &#34;How do I write an eBPF unwinder for LuaJIT?&#34;. Joking but I actually did this and the answer was kinda like a politician talking about science, a couple little nuggets of sensical things surrounded by reams of non-sense. The real first thing to do is examine all prior art and see what we can learn. The main ones that came to mind are <code>perf</code>, poor man&#39;s profiling (i.e. <code>gdb</code> sampling), and LuaJIT&#39;s own built-in profiler.</p><p>First up is <code>perf</code>, the trusty tool already built into Linux that aims to be able to profile anything. And here&#39;s what you get:</p><pre><pre><p><span>Samples: 10K of event &#39;cpu_core/cycles:P/&#39;, Event count (approx.): 8554628639</span></p><p><span>Children Self Command Shared Object Symbol</span></p><p><span>- 31.64% 31.64% luajit [JIT] tid 3107635 [.] TRACE_3::/home/tpr/projects/lua/deep.lua:3</span></p><p><span>TRACE_3::/home/tpr/projects/lua/deep.lua:3</span></p><p><span>- 28.39% 28.37% luajit [JIT] tid 3107635 [.] TRACE_17::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_17::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 6.54% 6.52% luajit [JIT] tid 3107635 [.] TRACE_12::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_12::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 5.96% 5.95% luajit [JIT] tid 3107635 [.] TRACE_18::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_18::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 4.54% 4.54% luajit [JIT] tid 3107635 [.] TRACE_5::/home/tpr/projects/lua/deep.lua:5</span></p><p><span>TRACE_5::/home/tpr/projects/lua/deep.lua:5</span></p><p><span>- 4.16% 4.16% luajit [JIT] tid 3107635 [.] TRACE_4::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_4::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 3.52% 3.50% luajit [JIT] tid 3107635 [.] TRACE_19::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_19::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 3.30% 3.30% luajit [JIT] tid 3107635 [.] TRACE_6::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_6::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 2.86% 2.86% luajit [JIT] tid 3107635 [.] TRACE_13::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_13::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 2.56% 2.56% luajit [JIT] tid 3107635 [.] TRACE_10::/home/tpr/projects/lua/deep.lua:5</span></p><p><span>TRACE_10::/home/tpr/projects/lua/deep.lua:5</span></p><p><span>- 1.98% 1.97% luajit [JIT] tid 3107635 [.] TRACE_14::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_14::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 1.61% 1.61% luajit [JIT] tid 3107635 [.] TRACE_20::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_20::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 0.97% 0.97% luajit [JIT] tid 3107635 [.] TRACE_8::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_8::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>- 0.93% 0.93% luajit [JIT] tid 3107635 [.] TRACE_15::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>TRACE_15::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>0.48% 0.48% luajit [JIT] tid 3107635 [.] TRACE_21::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>0.34% 0.34% luajit [JIT] tid 3107635 [.] TRACE_16::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>0.16% 0.16% luajit [JIT] tid 3107635 [.] TRACE_11::/home/tpr/projects/lua/deep.lua:7</span></p><p><span>0.06% 0.00% luajit [unknown] [.] 0xffffffff8ce00f0b</span></p><p><span>0.06% 0.00% luajit [unknown] [.] 0xffffffff8cd207cb</span></p><p><span>0.06% 0.00% luajit [unknown] [.] 0xffffffff8bca04ef</span></p><p><span>0.06% 0.00% luajit [unknown] [.] 0xffffffff8bdee806</span></p><p><span>0.06% 0.00% luajit [unknown] [.] 0xffffffff8bded8bf</span></p><p><span>0.03% 0.00% luajit [unknown] [.] 0xffffffff8be05132</span></p><p><span>0.03% 0.00% luajit [unknown] [.] 0xffffffff8be050ea</span></p><p><span>0.03% 0.00% luajit [unknown] [.] 0xffffffff8be04f77</span></p><p><span>0.03% 0.00% luajit [unknown] [.] 0xffffffff8bdf2370</span></p><p><span>0.02% 0.02% luajit luajit [.] gc_onestep</span></p><p><span>0.02% 0.02% luajit luajit [.] lj_BC_TGETS</span></p><p><span>0.02% 0.00% luajit [unknown] [.] 0xffffffff8bf6da77</span></p><p><span>0.02% 0.00% luajit [unknown] [.] 0xffffffff8bf6d74b</span></p><p><span>0.02% 0.00% luajit [unknown] [.] 0xffffffff8bf78c4a</span></p></pre></pre><p>This is what <code>perf</code> output looks like if you compile with <code>LUAJIT_USE_PERFTOOLS</code> which will write out a special file to help <code>perf</code> convert PC (program counter) values into file name/line numbers. Well this isn&#39;t super helpful because all we see is the top frame and <code>perf</code> doesn&#39;t show any call structure. Why is that? Because perf doesn&#39;t know how to unwind over LuaJIT JIT frames because LuaJIT doesn&#39;t emit frame pointers to make this possible. I suppose if you know your code well and if your call stacks are simple, knowing the PC of the top frame could be helpful. But these days code bases can get complicated and you often need a deeper understanding of &#34;how did I get here&#34; to know what your best optimization strategies are. Okay so short of a time machine to go back 20 years and convincing Mr. Pall that frame pointers are worth burning a register for perf doesn&#39;t help us much. </p><div><p><span><img alt="Message from B. Gregg to M. Pall" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p><span>Message from B. Gregg to M. Pall</span></p></div><p>And even if <code>perf</code> could navigate up to the next frame it would just be the native frame that called the Lua interpreter and not unpack anything about where in the Lua application you were. In some languages like Go/Java/.Net each native frame roughly corresponds to a source language method frame but Lua (like other interpreters) has its own stack separate from the native stack so to profile Lua you need the ability to walk native frames and the frames on the Lua stack.</p><p>What about DWARF, we know how to unwind code with dwarf unwinding information, could that help? Actually it turns out Lua has &#34;external&#34; unwinder support which emits runtime dwarf information for the benefit of <a href="https://maskray.me/blog/2020-12-12-c++-exception-handling-abi">C++ exception handling</a> so one might think that could be used to walk a Lua stack but this runtime unwinding feature is buried in arcane memory structures and tricky to get at at runtime (not as easy as reading dwarf information from an executable&#39;s debug sections). Furthermore that information is only available if Lua is compiled with LUAJIT_UNWIND_EXTERNAL defined which some configurations don&#39;t, having to deal with C++ exceptions just isn&#39;t as run of the mill on Linux server environments like it is in Windows environments. If you want to see how Lua does this (not for the faint of heart!) you could start <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_err.c#L559">here</a>.</p><p>But wait, LuaJIT comes with a profiler! Surely that will be helpful. Helpful but turns out to not be exactly what we&#39;re looking for. LuaJIT&#39;s profiler <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_profile.c#L319">throws away</a> all the JIT code because the sampling technique is a cooperative one. Basically the Lua profiler is &#34;hook&#34; based and not interrupt based like eBPF samplers are. The profiler runs a timer in the background that just sets a bit and profiling works by having the Lua interpreter inject hooks that check for this bit being set and only sample the stack when the bit is set. JIT code by default doesn&#39;t bother to check this bit, so when you enable profiling all JIT code has to be regenerated to inject these checks. That&#39;s a party foul when the goal is zero instrumentation! We want to profile the exact running all the time with absolute fidelity to whats running sans profiling (well as close as we can get anyways). Zero-instrumentation is important for production profiling!</p><p>So let&#39;s do what any sane person would do and poke around with GDB (yes the venerable<a href="https://poormansprofiler.org/"> poor man&#39;s profiler</a> is still a thing). In a lot of ways eBPF profilers are the new and improved poor man&#39;s profiler for today (rich man&#39;s profiler?). No instrumentation or tools required! So here&#39;s what&#39;s stopping LuaJIT in the middle of a simple CPU burning toy program looks like in gdb:</p><pre><pre><p><span>Program received signal SIGINT, Interrupt.</span></p><p><span>0x00005555679cfec1 in ?? ()</span></p><p><span>(gdb) bt</span></p><p><span>#0 0x00005555679cfec1 in ?? ()</span></p><p><span>#1 0x00007ffff7e6e890 in ?? ()</span></p><p><span>#2 0x0000000000000000 in ?? ()</span></p></pre></pre><p>Oh dear. GDB is confused. You get what you pay for I guess. What is 0x5555679cfec1? Well as we saw in <code>perf</code> above it is JIT&#39;d code, here&#39;s the proc mappings:</p><pre><pre><p><span>0x555555554000 0x55555555c000 0x8000 0x0 r--p /home/tpr/src/luajit2/src/luajit</span></p><p><span>0x55555555c000 0x5555555c7000 0x6b000 0x8000 r-xp /home/tpr/src/luajit2/src/luajit</span></p><p><span>0x5555555c7000 0x5555555e0000 0x19000 0x73000 r--p /home/tpr/src/luajit2/src/luajit</span></p><p><span>0x5555555e0000 0x5555555e3000 0x3000 0x8b000 r--p /home/tpr/src/luajit2/src/luajit</span></p><p><span>0x5555555e3000 0x5555555e4000 0x1000 0x8e000 rw-p /home/tpr/src/luajit2/src/luajit</span></p><p><span>0x5555555e4000 0x555555605000 0x21000 0x0 rw-p [heap]</span></p><p><span>0x5555679c0000 0x5555679d0000 0x10000 0x0 r-xp</span></p></pre></pre><p>The last one is where gdb stopped our program. Not surprising, GDB got confused because as we already learned DWARF and frame pointer unwinding don&#39;t work. But in addition to external unwinding LuaJIT has an extension to address this, LUAJIT_USE_GDBJIT. Unfortunately nobody turns this on in production so it is only helpful for information purposes. Here&#39;s what the crux of that <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_gdbjit.c#L598">looks like</a>. Basically you teach GDB how to walk the trace frames using DWARF FDE&#39;s just like GDB normally does with .eh_frame sections from executable files.</p><p>Not surprisingly things get complicated when you want to profile JIT code so lets back up a step and start by just looking at the interpreter. If we run that same program with the JIT disabled (-joff) GDB does better:</p><pre><pre><p><span>Program received signal SIGINT, Interrupt.</span></p><p><span>0x000055555555f05b in lj_BC_CALL ()</span></p><p><span>(gdb) bt</span></p><p><span>#0 0x000055555555f05b in lj_BC_CALL ()</span></p><p><span>#1 0x0000555555573889 in lua_pcall (L=L@entry=0x7ffff7e6c380, nargs=nargs@entry=0, nresults=nresults@entry=-1, errfunc=errfunc@entry=2) at lj_api.c:1121</span></p><p><span>#2 0x000055555555c8bb in docall (L=L@entry=0x7ffff7e6c380, narg=narg@entry=0, clear=clear@entry=0) at luajit.c:122</span></p><p><span>#3 0x000055555555db42 in handle_script (argx=&lt;optimized out&gt;, L=0x7ffff7e6c380) at luajit.c:292</span></p><p><span>#4 pmain (L=0x7ffff7e6c380) at luajit.c:550</span></p><p><span>#5 0x000055555555f8f6 in lj_BC_FUNCC ()</span></p><p><span>#6 0x00005555555738e1 in lua_cpcall (L=L@entry=0x7ffff7e6c380, func=func@entry=0x55555555d350 &lt;pmain&gt;, ud=ud@entry=0x0) at lj_api.c:1178</span></p><p><span>#7 0x000055555555c71e in main (argc=3, argv=0x7fffffffe188) at luajit.c:581</span></p></pre></pre><p>Now we can see that these functions lj_BC_CALL and lj_BC_FUNCC are probably related to the interpreter (BC == bytecode) so maybe we can use these things to know where to run our unwinder. So how do we do that? Well turns out those aren&#39;t functions, those are just labels in the interpreter (i.e. jump targets). We have to know the exact bounds of the interpreter to know when the program is executing Lua. For ruby/python it is just a symbol lookup on the interpreter symbol which is the function that contains the interpreter. So what function contains those labels? Turns out there isn&#39;t one. LuaJIT&#39;s interpreter isn&#39;t a function. Here&#39;s what LuaJIT&#39;s <a href="https://github.com/openresty/luajit2/blob/7952882d/src/vm_x64.dasc">interpreter source</a> looks like. This is basically high level assembly code templating system. LuaJIT comes with its own homegrown assembler called &#34;dynasm&#34; to turn these &#34;.dasc&#34; files into a C program that when run generates an assembly file that the compiler/linker can turn into an object file and be linked into your program. LuaJIT eschews the classic interpreter techniques of using computed GOTO&#39;s and other compiler tricks to write a fast interpreter in C and takes C out of the equation entirely. Of course the penalty is that each architecture needs its own VM implementation. Here&#39;s what one bytecode instruction looks like:</p><pre><pre><p><span>case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:</span></p><p><span>| ins_arith add, addsd</span></p><p><span>break;</span></p></pre></pre><p>ins_arith is a generic arithmetic template that expands into a prologue (bytecode decoding, stack-&gt;register motion, type checking) an arithmetic instruction (addsd) and an epilogue (store result, go to next instruction). The instruction is a 32bit value that has 4 parts: OP (ADDVN) A, B, C and it means do A = B + C where A and B are stack slots and C is a constant offset. In the end you get this (for amd64 with some helpful commentary):</p><pre><pre><p><span>luajit`lj_BC_ADDVN:</span></p><p><span>luajit[0xa28d] &lt;+0&gt;: movzbl %ah, %ebp         ; move B stack offset to ebp</span></p><p><span>luajit[0xa290] &lt;+3&gt;: movzbl %al, %eax         ; move C constant offset to eax</span></p><p><span>luajit[0xa293] &lt;+6&gt;: movq (%rdx,%rbp,8), %r11 ; move B stack value to r11</span></p><p><span>luajit[0xa297] &lt;+10&gt;: sarq $0x2f, %r11        ; shift right 47 bits to expose type</span></p><p><span>luajit[0xa29b] &lt;+14&gt;: cmpl $-0xe, %r11d       ; compare type to NUM type</span></p><p><span>luajit[0xa29f] &lt;+18&gt;: jae 0xc052 ; lj_vmeta_arith_vn ; bail on type check fail</span></p><p><span>luajit[0xa2a5] &lt;+24&gt;: movsd (%rdx,%rbp,8), %xmm0 ; move stack B value to fp reg</span></p><p><span>luajit[0xa2aa] &lt;+29&gt;: addsd (%r15,%rax,8), %xmm0 ; add constant C to variable</span></p><p><span>luajit[0xa2b0] &lt;+35&gt;: movsd %xmm0, (%rdx,%rcx,8) ; move result to stack slot A</span></p><p><span>luajit[0xa2b5] &lt;+40&gt;: movl (%rbx), %eax          ; load next instruction to eax</span></p><p><span>luajit[0xa2b7] &lt;+42&gt;: movzbl %ah, %ecx           ; load next A to ecx</span></p><p><span>luajit[0xa2ba] &lt;+45&gt;: movzbl %al, %ebp           ; load OP to ebp</span></p><p><span>luajit[0xa2bd] &lt;+48&gt;: addq $0x4, %rbx            ; advance PC 4</span></p><p><span>luajit[0xa2c1] &lt;+52&gt;: shrl $0x10, %eax           ; shift 16 so eax has two high bytes</span></p><p><span>luajit[0xa2c4] &lt;+55&gt;: jmpq *(%r14,%rbp,8)        ; jump to address of next instruction</span></p></pre></pre><p>Astute readers will wonder, what&#39;s with the 47 bits thing and why are we doing floating point math? Lua stack values are 64 bit NaN encoded floating point numbers, if the first 13 bits of a double floating point are 1 it&#39;s a NaN, ASCII art to the <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_obj.h#L248">rescue</a>:</p><pre><pre><p><span>**                  ------MSW------.------LSW------</span></p><p><span>** primitive types |1..1|itype|1..................1|</span></p><p><span>** GC objects      |1..1|itype|-------GCRef--------|</span></p><p><span>** number           ------------double-------------</span></p></pre></pre><p>So if you try to add a primitive (false, true, nil etc) or an object reference to a number it will fail (yeah type safety! shakes fist at Mr Eich). Lua doesn&#39;t have raw integers because floating point units are pretty fast these days and with double&#39;s you get 52 bits of mantissa which can represent a lot of integers accurately. <del>Who needs 64 bit integers anyways (pro-tip: don&#39;t write crypto code in Lua). Fine for a scripting engine.</del>  Correction: LuaJIT does support 64 bit integers using the &#34;LL&#34; type suffix, this puts full 64bit values behind a boxed pointer.</p><p>So to summarize we move a value from the stack into a register, move a value from a constant pool to a register, type check the stack value and add them with addsd instruction and move the result back to the lua stack and jump to the next instruction. Getting this level of interpreter optimization from the C language is very difficult (impossible?). 15 instructions for one bytecode is impressive! For comparison the written in C classic switch dispatch interpreter for plain Lua uses about 25 instructions for ADD (not a perfect comparison as they don&#39;t use the exact same bytecode format but close enough). For reference a simple fibonacci recursive calculator runs 2x in LuaJIT (w/ JIT off) vs plain Lua.</p><p>Anyways all these operator implementations are packed together in one contiguous blob by the assembler and the addresses of each instruction is stored in a DISPATCH table that hangs off a global. When we want to go to the next instruction we index the DISPATCH by the next OP code and jump there. This is called a direct threaded interpreter, no need to switch on the OP code. A full list of byte codes can be found <a href="https://github.com/tarantool/tarantool/wiki/LuaJIT-Bytecodes">here</a>.</p><p>So the unwinder works by registering a span of addresses and saying, use unwinder X for a particular span. Again for <a href="https://github.com/parca-dev/opentelemetry-ebpf-profiler/blob/6c9cad62d8fdcea4e1c224e37371dd28310b2550/interpreter/python/python.go#L761">python</a> this is easy:</p><pre><pre><p><span>interpRanges</span><span>,</span><span> err </span><span>:=</span><span> info</span><span>.</span><span>GetSymbolAsRanges</span><span>(</span><span>&#34;_PyEval_EvalFrameDefault&#34;</span><span>)</span></p></pre></pre><p>For LuaJIT there is a C variable for this code blob, it&#39;s called &#34;<code>lj_vm_asm_begin</code>&#34; but it doesn&#39;t help us because it&#39;s just the start address and we can&#39;t lookup that symbol if the library is stripped which it frequently is. To get the extents there&#39;s really no direct way. Luckily if we examine the .<code>eh_frame</code> symbols for LuaJIT we can find it as these aren&#39;t stripped. One of these things is not like the others (this is dwarfdump -F output):</p><pre><pre><p><span>&lt; 12&gt;&lt;0x00009e60:0x0000def5&gt;&lt;&gt;&lt;cie offset 0x00000020::cie index 1&gt;&lt;fde offset 0x00000074 length: 0x00000018&gt;</span></p><p><span>&lt;eh aug data len 0x0&gt;</span></p><p><span>0x00009e60: &lt;off cfa=80(r7) &gt; &lt;off r3=-24(cfa) &gt; &lt;off r6=-16(cfa) &gt; &lt;off r14=-40(cfa) &gt; &lt;off r15=-32(cfa) &gt; &lt;off r16=-8(cfa) &gt;</span></p></pre></pre><p>This is the information GDB used to walk the stack above so pretty safe bet it&#39;s accurate. Breaking out the calculator, <code>0xdef5</code> - <code>0x9e60</code>, thats a 16k function with one dwarf FDE (frame descriptor entry), that&#39;s orders of magnitude larger than any other function and we can gain more confidence that this is the interpreter by noticing that the <code>0x80</code> offset for the stack pointer (<code>r7</code>) is <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_frame.h#L176">CFRAME_SIZE</a>. That&#39;s still a little loosey goosey for a production code so we take the added measure of looking for the <code>lj_vm_asm_begin</code> address and cross-checking against that when debug information hasn&#39;t been stripped (and we run unit tests against every version we can get our hands on to make sure they all work).</p><p>Cool, so now if our profiler hits a stack frame with a PC in that range we know we&#39;re executing the interpreter!</p><p>Now what about those pesky JIT frames? Here we need to help the unwinder out by manually adjusting the stack pointer. Turns out by default most traces have a fixed stack frame size but some traces need more space and this is stored in the <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_jit.h#L282">trace metadata</a>. So to find the stack frame size we have to add the stack adjustment &#34;<code>spadjust</code>&#34; value to the <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_frame.h#L178"><code>CFRAME_SIZE_JIT</code></a> constant.</p><p>Okay so now we know how to jump over a JIT frame to continue unwinding on the other side but how do we register the addresses for the machine code? We take the low tech approach of just looking at the proc maps and registering the entire virtual address span for any anonymous/executable regions. This is a half measure though as when we get a hit we don&#39;t know a priori what the stack adjustment is, so we guess it&#39;s 0 and make an attempt to unwind. If after unwinding the Lua frames we fail to walk to the rest of the C stack we&#39;ll report a truncated stack. But if we successfully get our context we&#39;ll report that back to user land and then in user land we poke around using <a href="https://man7.org/linux/man-pages/man2/process_vm_writev.2.html">remote memory accesses</a> to record each trace&#39;s exact machine code boundaries and stack adjustment. More on this later, before we get into how that works we need some context.</p><p>Context is everything!</p><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p></div><p>So how do we, a poor little eBPF program, find our context? For other interpreters we rely on the fact that there can only be one and usually read the VM context pointer out of a global (Ruby) or a thread local (python). Well that&#39;s no fun, what if there are multiple instances of LuaJIT in the same process (i.e. separate LuaJIT instances per application or per user)? That happens in practice and furthermore Lua doesn&#39;t put anything in any public global or thread local variables we can bank on, remember LuaJIT is meant to be embedded, it doesn&#39;t make any assumptions about the process like other languages that assume they are the only show in town. Anyways every Lua instance has some global state (heap allocated, doesn&#39;t exist until &#34;<code>lua_open</code>&#34; is called) usually referred to as &#34;G&#34;. There&#39;s also a runtime or execution context, called &#34;L&#34;, that roughly means &#34;thread&#34;. Multiple Ls are needed to support co-routines (another cool Lua <a href="https://www.lua.org/pil/9.html">feature</a>) but there&#39;s no built-in concurrency support for real threading. If we can find &#34;L&#34; we can get &#34;G&#34; and if we can get &#34;G&#34; we can get the currently executing &#34;L&#34; so either one will do.</p><p>So how do we get the G or L? Always important to explore the solution space! One approach that was used by <a href="https://github.com/apache/apisix-profiler">the APISIX profiler</a> is to use uprobes on the <code>lua_call</code>/<code>lua_resume</code> functions and record &#34;L&#34; before we get to the interpreter. But uprobes come with their own baggage and overhead we don&#39;t want to enjoin. In practice they work pretty well but customers are gun shy about uprobes and we&#39;d rather only rely on them if there was no other choice. But this is software, there are always other choices! For interpreter frames this is easy, there&#39;s an L pointer that&#39;s always (well extremely frequently, there are always edge cases with arbitrary interrupt sampling, i.e. function prologue/epilogues) at a constant offset from the <a href="https://github.com/openresty/luajit2/blob/7952882d/src/vm_x64.dasc#L118">stack pointer</a>.</p><p>Okay easy enough what about the JIT. This is harder because JIT doesn&#39;t stash the L pointer on the stack, instead we have to poke around in the generated JIT code and see where it gets the context when it needs it. Turns out lj_gc_step_jit is a frequently called internal function in JIT traces that does just this, looks like this:</p><pre><pre><p><span>64c3c112fe8c lea rdi, [r14-0xfa8]</span></p><p><span>64c3c112fe93 call 0x64c3b1b634d0	-&gt;lj_gc_step_jit</span></p></pre></pre><p>In a JIT frame r14 holds the dispatch table which is the direct threaded jump table containing the addresses of bytecode operator implementations. It&#39;s a &#34;global&#34; and can be used to find other global things with a constant offset that suits our purposes nicely. So how do we know that the offset is <code>0xfa8</code>? Well it isn&#39;t always, it varies depending on LuaJIT version, platform etc. In order to find this offset it would be nice to just lookup symbols and calculate the offset via symbol offset math. Lua&#39;s global state looks like this:</p><pre><pre><p><span>struct GG_State {</span></p><p><span>  lua_State L;</span></p><p><span>  global_State g;</span></p><p><span>  jit_State J;</span></p><p><span>  HotCount hotcount[64];</span></p><p><span>  ASMFunction dispatch[243];</span></p><p><span>  BCIns bcff[57];</span></p><p><span>}</span></p></pre></pre><p>For the version of LuaJIT above on amd64 <code>0xfa8</code> is the distance from the dispatch address to the <code>global_State</code> pointer &#34;g&#34;. So if we had symbols we could just do something like:</p><pre><pre><p><span>(gdb) p/x (char*)&amp;((GG_State*)0)-&gt;dispatch - (char*)&amp;((GG_State*)0)-&gt;g</span></p><p><span>$3 = 0xfa8</span></p></pre></pre><p>But we don&#39;t always have debug information. Back to the drawing board. What if we could analyze the LuaJIT code for a public function that we know has did this g to dispatch math? The idea is to walk the instructions until we find the math we&#39;re looking for. But walking instructions is dicey and compilers change and compiler switches change and inline decisions change so we want to find the the simplest case possible. Running &#39;nm -UD&#39; on libluajit&#39;s shared library shows we have 152 candidates! By brute force and ignorance we stumbled upon &#34;<code>luaopen_jit</code>&#34; which as the first thing it does calls a function called &#34;<code>jit_init</code>&#34; which does very little except call this function call &#34;<code>lj_dispatch_update</code>&#34; which has this line:</p><pre><pre><p><span>ASMFunction *disp = G2GG(g)-&gt;dispatch;</span></p></pre></pre><p>So given a global_State pointer &#34;g&#34; derive GG address and dereference &#34;dispatch&#34;. Looks promising, what&#39;s the assembly look like?</p><pre><pre><p><span>libluajit-5.1.so[0x16d4e] &lt;+94&gt;: leaq 0xfa8(%rdx), %r10</span></p></pre></pre><p>So can we rip through the instructions for &#34;<code>lj_dispatch_update</code>&#34; and find this lea (load effective address) instruction? This is at offset 94 so we don&#39;t have a ton of lead up instructions to throw us off. That&#39;s important for two reasons, it limits the chances the compiler will so something tricky (like stash rdx on the stack and read it back later) and it avoids issues with Golangs incomplete x86 disassembler (to be fair x86 is a complicated beast). Here&#39;s the function we&#39;re dealing with:</p><pre><pre><p><span>void lj_dispatch_update(global_State *g)</span></p></pre></pre><p>So we know &#34;g&#34; will be in the rdi register (where first arg goes in Linux amd64 calling conventions) but because compilers do what compilers do it&#39;s in the <code>rdx</code> register by the time we get to our <code>lea</code>. So can we track where &#34;g&#34; goes and look for a <code>lea</code> instruction? It turns out in all versions of LuaJIT finding the first lea of a g relative address works to find this offset. The code looks like <a href="https://github.com/parca-dev/opentelemetry-ebpf-profiler/blob/1bcbda5a06ad5449f27a47745c7b5f4e99189454/interpreter/luajit/extractor_x86.go#L103">this</a>. Hot bananas! Did you read it? Pretty simple actually, so nice of the Go folks to include a disassembler, batteries included indeed.</p><p>Turns out to walk Lua completely we only need to find 2 offsets in such a manner, the &#34;g&#34; to &#34;<code>dispatch</code>&#34; offset and the &#34;g&#34; to &#34;<code>traces</code>&#34; offset which is a field in the <code>jit_State</code> we need to find all the LuaJIT traces so we can look up their machine addresses and &#34;<code>spadjust</code>&#34; values to calculate the frame size.</p><p>The only piece missing left is how do we walk the Lua frames?</p><p>Lua has its own stack that is stored on the Lua &#34;L&#34; pointer. The start of the stack is stored in &#34;stack&#34; and the top of the stack (ie the currently executing function) is stored at &#34;base&#34;. Base is the start of the the stack for the top frame, so base + 0 is stack slot zero. The frame information is stored before that. It looks like <a href="https://github.com/openresty/luajit2/blob/7952882d/src/lj_frame.h#L62">this</a>:</p><pre><pre><p><span>** base-2 base-1       | base base+1 ...</span></p><p><span>** [func  PC/delta/ft] | [slots ...]</span></p><p><span>**        ^-- frame    | ^-- base ^-- top</span></p></pre></pre><p>So at base-1 is a PC pointer return address (i.e. the address of the next instruction after the call instruction) and a function pointer that we called. So to &#34;walk&#34; the stack we need two additional bits of information, what is the PC of the &#34;top&#34; function and what is the &#34;delta&#34; between frames? The PC for the top frame is stored in the interpreter native stack frame at a constant offset so that&#39;s easy to get (and conveniently also maintained by the JIT) and the delta between two frames is stored in the CALL instruction which can be found by looking at call instruction at PC - 1. Of course there&#39;s lots of &#34;details&#34; like a Lua call frames can be a native function call (i.e. an FFI call) and things are a little different in those cases but we won&#39;t go into that here.</p><p>So for an eBPF program that&#39;s trying to do as little work as possible in eBPF and just send the minimal amount of information back to user land what&#39;s the minimal amount of work we need to do? I mean we could just snapshot the entire Lua stack and send that over and have the user land process that. But because of LuaJIT&#39;s FFI support we have to allow for Lua calling out to native code and because Lua&#39;s FFI supports a &#34;callback&#34; mode where a Lua function can be wrapped in a C function call we have to also support arbitrary C frames calling back into Lua. Here&#39;s an example of Lua&#39;s FFI capabilities:</p><pre><pre><p><span>local ffi = require &#34;ffi&#34;</span></p><p><span>ffi.cdef[[</span></p><p><span>long random();</span></p><p><span>void qsort(void *base, size_t nel, size_t width, int (*compar)(const long *, const long *));</span></p><p><span>]]</span></p><p><span>function compare(a, b)</span></p><p><span>return a[0] - b[0]</span></p><p><span>end</span></p><p><span>local callback = ffi.cast(&#34;int (*)(const long *, const long *)&#34;, compare)</span></p><p><span>local n = 20</span></p><p><span>local arr = ffi.new(&#34;long[?]&#34;, n)</span></p><p><span>for i=0,n-1 do</span></p><p><span>arr[i] = ffi.C.random()</span></p><p><span>end</span></p><p><span>ffi.C.qsort(arr, n, ffi.sizeof(&#34;long&#34;), callback)</span></p><p><span>for i=0,n-1 do</span></p><p><span>print(arr[i])</span></p><p><span>end</span></p></pre></pre><p>By the time the &#34;compare&#34; function is called the stack frame is a tangled weave of different types of calls:</p><pre><pre><p><span>frame #5: 0x000055555555f8f6 luajit`lj_BC_FUNCC + 68</span></p><p><span>frame #6: 0x00007ffff7c49940 libc.so.6`msort_with_tmp(p=0x00007fffffffd790, b=0x00007ffff7e7a928, n=2) at qsort.c:239:8</span></p><p><span>frame #7: 0x00007ffff7c49715 libc.so.6`msort_with_tmp [inlined] msort_with_tmp(n=2, b=0x00007ffff7e7a928, p=0x00007fffffffd790) at qsort.c:201:6</span></p><p><span>frame #8: 0x00007ffff7c49707 libc.so.6`msort_with_tmp(p=0x00007fffffffd790, b=0x00007ffff7e7a928, n=5) at qsort.c:209:3</span></p><p><span>frame #9: 0x00007ffff7c49715 libc.so.6`msort_with_tmp [inlined] msort_with_tmp(n=5, b=0x00007ffff7e7a928, p=0x00007fffffffd790) at qsort.c:201:6</span></p><p><span>frame #10: 0x00007ffff7c49707 libc.so.6`msort_with_tmp(p=0x00007fffffffd790, b=0x00007ffff7e7a928, n=10) at qsort.c:209:3</span></p><p><span>frame #11: 0x00007ffff7c49715 libc.so.6`msort_with_tmp [inlined] msort_with_tmp(n=10, b=0x00007ffff7e7a928, p=0x00007fffffffd790) at qsort.c:201:6</span></p><p><span>frame #12: 0x00007ffff7c49707 libc.so.6`msort_with_tmp(p=0x00007fffffffd790, b=0x00007ffff7e7a928, n=20) at qsort.c:209:3</span></p><p><span>frame #13: 0x00007ffff7c49c0d libc.so.6`__GI___qsort_r [inlined] msort_with_tmp(n=20, b=0x00007ffff7e7a928, p=0x00007fffffffd790) at qsort.c:201:3</span></p><p><span>frame #14: 0x00007ffff7c49c08 libc.so.6`__GI___qsort_r(pbase=0x00007ffff7e7a928, total_elems=20, size=8, cmp=&lt;unavailable&gt;, arg=&lt;unavailable&gt;) at qsort.c:393:7</span></p><p><span>frame #15: 0x0000555555561d62 luajit`lj_vm_ffi_call + 132</span></p><p><span>frame #16: 0x00005555555a7f45 luajit`lj_ccall_func(L=&lt;unavailable&gt;, cd=&lt;unavailable&gt;) at lj_ccall.c:1402:5</span></p><p><span>frame #17: 0x0000555555588dfd luajit`lj_cf_ffi_meta___call(L=0x00007ffff7e6c380) at lib_ffi.c:230:15</span></p><p><span>frame #18: 0x000055555555f8f6 luajit`lj_BC_FUNCC + 68</span></p><p><span>frame #19: 0x0000555555573889 luajit`lua_pcall(L=0x00007ffff7e6c380, nargs=0, nresults=-1, errfunc=2) at lj_api.c:1150:12</span></p><p><span>frame #20: 0x000055555555c8bb luajit`docall(L=0x00007ffff7e6c380, narg=0, clear=0) at luajit.c:122:12</span></p><p><span>frame #21: 0x000055555555db42 luajit`pmain [inlined] handle_script(argx=&lt;unavailable&gt;, L=0x00007ffff7e6c380) at luajit.c:292:14</span></p><p><span>frame #22: 0x000055555555dac6 luajit`pmain(L=0x00007ffff7e6c380) at luajit.c:550:17</span></p><p><span>frame #23: 0x000055555555f8f6 luajit`lj_BC_FUNCC + 68</span></p><p><span>frame #24: 0x00005555555738e1 luajit`lua_cpcall(L=0x00007ffff7e6c380, func=0x0000000000009350, ud=0x0000000000000000) at lj_api.c:1178:12</span></p><p><span>frame #25: 0x000055555555c71e luajit`main(argc=2, argv=0x00007fffffffe178) at luajit.c:581:12</span></p><p><span>frame #26: 0x00007ffff7c2a1ca libc.so.6`__libc_start_call_main(main=(luajit`main at luajit.c:570:1), argc=2, argv=0x00007fffffffe178) at libc_start_call_main.h:58:16</span></p><p><span>frame #27: 0x00007ffff7c2a28b libc.so.6`__libc_start_main_impl(main=(luajit`main at luajit.c:570:1), argc=2, argv=0x00007fffffffe178, init=&lt;unavailable&gt;, fini=&lt;unavailable&gt;, rtld_fini=&lt;unavailable&gt;, stack_end=0x00007fffffffe168) at libc-start.c:360:3</span></p><p><span>frame #28: 0x000055555555c795 luajit`_start + 37</span></p></pre></pre><p>So our unwinder needs to know when these special frames are called and jump back to the native unwinder at the right times. As if that weren&#39;t enough LuaJIT will also JITs the code to implement these callbacks. In order to call a Lua function from a C function all the arguments have to be converted, i.e. convert C strings into Lua strings, convert native ints into Lua NaN encoded doubles etc. You can start to see why LuaJIT is so popular for embedding, it makes calling back and forth between the host and Lua extremely easy and efficient.</p><p>So back to what to record, the choices are to record the raw <code>GCfunc</code> pointers we find on the stack or we can unpack them to their <a href="https://github.com/openresty/luajit2/blob/7952882d9c233e895276017d9ec1a5946b75e536/src/lj_obj.h#L372"><code>GCproto</code></a> which is where the meat of the function is stored (bytecode, line number info). In order to keep the userland unwind code as uncoupled from LuaJIT internals as possible we choose the later.</p><p>Okay so we know how to find the LuaJIT context pointers, walk across the LuaJIT JIT frames and how to walk the Lua language stack. So how to do we put it all together into a profiler? First we need to discuss how we get from registering the entire anonymous executable to knowing the addresses of each trace and what the specific stack delta adjustment is.</p><p>Normally PC lookups in unwinders are done via a binary search on a sorted list of the start addresses. This works well, although typically in order to avoid too many loops and hitting eBPF instruction count limits they need to be two level lookups. But there&#39;s another option that works particularly well for our use case, longest prefix match tries. Frequently used for IP addresses (internet protocol, not instruction pointer) an LPM trie lets us register overlapping addresses which doesn&#39;t work with the binary search approach. Luckily eBPF has LPM tries <a href="https://docs.ebpf.io/linux/map-type/BPF_MAP_TYPE_LPM_TRIE/">built in</a>. The eBPF map lets us have an arbitrary node value with each entry so we can stuff the stack adjustment in there. Furthermore in order to circumvent that pesky problem with relying on the DISPATCH register (remember r14) we can stuff the &#34;g&#34; context pointer in there as well (machine code isn&#39;t shared across LuaJIT instances). I glossed over it earlier but the sampler may fire when the JIT has called some internal helper (like the GC step helper we saw earlier) and we can&#39;t rely on <code>r14</code> holding the &#34;DISPATCH&#34; pointer. So by passing &#34;g&#34; in the LPM tree value we can move away from assuming r14 is the dispatch address and that the stack adjustment is zero. This is important because unlike traditional JITs tracing JITs are continuously creating new traces and deleting unused ones. It&#39;s also possible for LuaJIT to add new virtual address regions for additional traces. And LuaJIT can also expand the existing regions (ie &#34;realloc&#34;). Accounting for all this gets a little tricky, no problem, best way to deal with tricky bits like that is throw some <a href="https://github.com/parca-dev/opentelemetry-ebpf-profiler/blob/1bcbda5a06ad5449f27a47745c7b5f4e99189454/interpreter/luajit/mappings_test.go#L69">unit tests</a> at them.</p><p>How do we deal with trace garbage collection? Our unwinder can tell when we get triggered by a PC falling in the entire anonymous executable VM range vs when it gets triggered by the machine code span for a specific trace. We use that as a trigger to send an event to user land which will <a href="https://github.com/parca-dev/opentelemetry-ebpf-profiler/blob/1bcbda5a06ad5449f27a47745c7b5f4e99189454/interpreter/luajit/luajit.go#L244">re-sync our mappings</a>. Once we&#39;re synced up the event won&#39;t fire until new traces come into existence.</p><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p></div><p>The final detail to clear up is how do we get actual function names, file names and line numbers. You&#39;d think this would be easy but again Lua as a pure functional language there&#39;s a bit of work. A function in Lua is an object with no inherent name, in bytecode defining a looks like this:</p><pre><pre><p><span>0001 FNEW 0 0 ; func.lua:1</span></p><p><span>0002 GSET 0 1 ; &#34;func&#34;</span></p></pre></pre><p>So in order to report stack frames with function names we have to do a bit of guess work. Essentially we look at call sites and find the &#34;name&#34; used to lookup the function:</p><pre><pre><p><span>0003 GGET 0 1 ; &#34;func&#34;</span></p><p><span>0004 CALL 0 1 1</span></p></pre></pre><p>Okay so that&#39;s the theory, how do we deal with it in practice?  In practice each frame must have these minimal pieces of information to be &#34;symbolized&#34;.</p><ul><li>PC of currently executing frame</li><li>Offset of that PC from the start of the bytecode for the function. We need this because the bytecode is co-allocated with the <code>GCproto</code>, meaning the bytecode starts at the end of the <code>GCproto</code> struct. So <code>PC - Offset_From_Start = GCproto* + 1</code> in C pointer math speak.  So if we have the offset and we know the size of <code>GCproto</code> we can calculate the <code>GCproto</code> address.</li><li>PC of calling function so that we can walk the bytecode and gin up a name for the callee.</li><li>Offset of that PC from start so we can get the caller&#39;s <code>GCproto</code></li></ul><p>So to summarize the answer to the question how do you write an unwinder in Lua (or at least the PolarSignals answer):</p><ul><li>Register hooks on interpreter code boundaries and any anonymous executable regions to go to our unwinder</li><li>Get context pointers from stack for interpreter frames and <code>DISPATCH</code> register for freshly seen JIT frames and from LPM entry for &#34;known&#34; traces.</li><li>Walk Lua stack but bail to native unwinder if we see any FFI callback frames and report PC and <code>GCproto</code> address for each frame back to userland.</li><li>In userland convert each frame to function, file name and line number using <code>GCproto</code> fields and bytecode walking to derive function name.</li><li>Periodically and under signal from unwinder revisit LuaJIT executable/anonymous virtual regions and trace definitions to make sure LPM map entries are up to date.</li></ul><div><p><span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p></div><p>It&#39;s that easy! The AI agents didn&#39;t do a very good job with helping figure any of this out so maybe the AI prognosticators that theorize programmers will all have to become farmers soon are wrong! Darn. Honestly though this is a cleaned up &#34;revisionist history&#34; that mostly only talks about the final design. In reality weeks were spent single stepping (forwards and backwards, thank you <a href="https://rr-project.org/">RR</a>!) through the LuaJIT engine trying to piece together what was going on and coming up with solutions that didn&#39;t work and throwing them out. Oh well, history is written by the victors!</p><p>So what does it look like in practice?  Check it out below!  There&#39;s still some rough edges to sort out but it mostly works.</p><p>Swing over to <a href="http://www.parca.dev/">Parca</a> central if you want to give it a whirl and hop on to our Discord if you need any help!</p></article></div>
  </body>
</html>
