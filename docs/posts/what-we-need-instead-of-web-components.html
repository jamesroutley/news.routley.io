<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.carlana.net/post/2023/web-component-alternative-futures/">Original</a>
    <h1>What We Need Instead of &#34;Web Components&#34;</h1>
    
    <div id="readability-page-1" class="page"><section><p>It seems like Web Components are always just on the cusp of finally catching on. They’re like <a href="https://www.howtogeek.com/676963/why-desktop-linux-still-matters/">the year of Linux on the desktop</a> for frontend nerds. I keep reading the latest articles about Web Components as they bubble up on my social media feeds, just hoping that there is something that I missed out on and now they have more substance, but I always end up feeling disappointed. I wrote up my thoughts on Web Components <a href="https://blog.carlana.net/post/2020/web-components/">back in 2020</a>, and it doesn’t feel like the conversation has progressed in all that time. It’s like an <a href="https://en.wikipedia.org/wiki/Eternal_September">Eternal September</a> with people constantly going back to the original promise of Web Components, in spite of the reality having long since shown itself to have fallen short.</p><h2 id="what-went-wrong">What went wrong</h2><p>To TL;DR my earlier piece:</p><blockquote><p>The pitch is “get <strong>semantic elements</strong> from <strong>across the web</strong><i>!</i>” But those are <strong>wrong problems</strong> to try to solve.</p></blockquote><ul><li>Custom elements <strong>aren’t “semantic”</strong> because search engines don’t know what they mean.</li><li>“From across the web” is always going to be <strong>worse for end user performance</strong> than using one coherent, progressive enhancement compatible JavaScript framework per site.</li><li><code>customElements.define</code> is an extremely <strong>clunky API</strong>.</li><li><code>&lt;template&gt;</code> and <code>&lt;slot&gt;</code> are fine, but not a sufficient substitute for a <strong>real templating language</strong>.</li><li>Shadow DOM is also very clunky and solves an <strong>extremely niche</strong> problem.</li></ul><p>Okay, those are the basics, can we all just agree on that?</p><p>Yes, there are circumstances where using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements">customElement API</a> is a convenient way to namespace things and ensure that lazy loaded elements have their constructors called, but they are mostly useful for things like rendering third party embeds in a rich text content well. That doesn’t add up to the name “Web Components” referring to a meaningful thing.</p><p>If you put the name “Web Components” on your collection of JavaScript widgets powered by a lightweight framework, more people will check it out than if you had called them something else. In the end though, it’s just a marketing name for a couple of clunky DOM APIs and a dream that we all wish really existed. The dream is that you could just mix and match widgets regardless of what framework each widget is written in, but the truth is the only way to do that is by paying the full price of including a framework for each web component you include on the page. It’s never going to be a practical choice for sites where end user performance matters.</p><h2 id="browser-makers-to-the-rescue">Browser makers to the rescue</h2><p>The good news is that even though “Web Components” aren’t really A Thing, the browser makers do eventually solve real problems the right way, but sometimes it takes them a while.</p><p>As I <a href="https://blog.carlana.net/post/2020/web-components/">wrote about Shadow DOM</a> at the time:</p><blockquote><p>The fundamental thing that Shadow DOM does is to allow an element of the page to have its own CSS reset. There’s no reason we couldn’t have that as part of CSS itself instead (perhaps by changing the rules for <code>@import</code> to allow it to be nested instead of only at the top level).</p></blockquote><p>As it turns out, that is exactly what happened, so there won’t really be much reason to use Shadow DOM anymore once browser support for <a href="https://css.oddbird.net/scope/explainer/">donut scoping</a> becomes sufficiently widespread. Use CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@scope">scope selectors</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@layer">import layers</a> to create a CSS reset scoped just to your component, and you get all the benefits of Shadow DOM with none of the goth language about “light DOM styles piercing the shadow root” and whatnot.</p><p>So, what should browser makers do instead of pouring more effort into Web Components per se?</p><p>I think everyone agrees that the best example of <a href="https://en.wikipedia.org/wiki/Desire_path">paving the desire lines</a> in the history of the DOM is the relationship between jQuery and querySelectorAll. In 2003, Simon Willison put together <a href="https://simonwillison.net/2003/Mar/25/getElementsBySelector/">a demo version of <code>document.getElementsBySelector</code></a>. <a href="https://jquery.com">JQuery</a> took the idea and made it into the once ubiquitous <code>$(&#34;&#34;)</code> API. The browser makers took that and turned it into <code>document.querySelectorAll</code> which made it faster and universally available without linking to jQuery.</p><p>This is the ideal scenario for the evolution of the web: developers worked collectively over a series of years to <strong>find a solution to a recurring problem</strong> and then browser makers <strong>took that solution and made it native</strong> so that it would be universally available and more performant. By contrast, the <code>customElement</code> and Shadow DOM APIs come from <a href="https://en.wikipedia.org/wiki/Web_Components#History">about a decade ago</a> and predate many of the modern techniques for JavaScript frameworks. As a result, they ended up solving the wrong problems, just due to the inexperience that we as an industry had at that time with building large JavaScript application frameworks.</p><p>Instead of trying to improve Web Components as they exist now, what the browser makers should focus on is to find new areas where we can standardize the things developers are already doing. I have three suggestions for what they should look at.</p><h2 id="reactivity">Reactivity</h2><p>Recently, Nolan Lawson wrote <a href="https://nolanlawson.com/2023/12/02/lets-learn-how-modern-javascript-frameworks-work-by-building-one/">Let’s learn how modern JavaScript frameworks work by building one</a>. In the article, Lawson defines “modern” frameworks as having three components:</p><blockquote><ol><li>Using reactivity (e.g. <a href="https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob">signals</a>) for DOM updates.</li><li>Using cloned templates for DOM rendering.</li><li>Using modern web APIs like <code>&lt;template&gt;</code> and <code>Proxy</code>, which make all of the above easier.</li></ol></blockquote><p>To be honest, I started drafting this blog post before Lawson’s came out, so I was happy to see that he highlighted some of the same aspects of modern frameworks that I was planning to write about here. The <code>&lt;template&gt;</code> and <code>Proxy</code> APIs are fine, and don’t especially need to be improved by browser makers. But there is a lot of room for improving reactivity/signals and DOM rendering. Let’s talk about reactivity first.</p><p>The basic idea of reactivity is that if you have a simple component like a todo item, you want to know when <code>todo.done</code> goes from <code>false</code> to <code>true</code> so that you can trigger changes to other data like <code>todos.count</code> which will go from N to N+1. In <a href="https://blog.carlana.net/post/2020/web-components/">my 2020 post</a>, I called this “the data lifecycle.”</p><p>In Lawson’s article, he creates a <a href="https://codepen.io/nolanlawson-the-selector/pen/qBgKywJ">quick and dirty reactivity system</a> with only about 50 lines of JavaScript, but more realistic reactivity systems like <a href="https://github.com/salesforce/observable-membrane">observable-membrane</a>, <a href="https://www.npmjs.com/package/@vue/reactivity">@vue/reactivity</a>, and <a href="https://github.com/preactjs/signals">@preact/signals</a> are significantly larger and more complex.</p><p>Shifting the core of these systems out of JavaScript libraries and into the browser will allow for significant optimization of the tree of dependencies between reactive data elements. It takes a lot of code to ship a performance optimized algorithm for marking nodes as dirty. For a simple todo app with only a handful of reactive elements, the complexity of the reactivity engine easily swamps the complexity of the application itself. But if the browser were tackling this problem directly, it would be possible to have this code written in C++ or Rust and made maximally efficient because it wouldn’t need to be packaged up, sent to clients, and interpreted from scratch on every page load. The cost could be paid once by a browser team and the benefits enjoyed by web developers and end users everywhere.</p><p>This is clearly a problem that has been solved independently by multiple frameworks. It’s time for the browser to tackle it too.</p><p><em>Update: <a href="https://daverupert.com">Dave Rupert</a> has <a href="https://mastodon.social/@davatron5000/111620826173161008">pointed out on Mastodon</a> that there is <a href="https://github.com/webcomponents-cg/community-protocols/issues/43">a W3C proposal to add reactive signals</a> to JavaScript that is in the process of being forwarded to TC39. I wish them luck in the proposal process.</em></p><h2 id="morph-dom--virtual-dom">Morph DOM / Virtual DOM</h2><p>Another aspect of modern frameworks that is begging for optimization is DOM rendering. In Lawson’s article, he spends a significant amount of time explaining how to translate proxy calls into efficient DOM updates. For my part, I don’t think it would make sense for the browser makers to enter into the templating wars. The existing <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literal syntax</a> in JavaScript is sufficient to allow developers to create templating systems that make sense to them, or they can keep using solutions like JSX to make templating a compile time feature of their framework. What is needed is an efficient way of merging the HTML results of the template system with the existing browser DOM of a page. If you just have some simple HTML to replace, then writing <code>node.innerHTML = newHTML;</code> is reasonably performant. The problems come if your nodes have event handlers (which can be partially mitigated by delegating to handlers higher in the DOM) or state which need to be preserved across renderings. For example, if you have an input element, using <code>node.innerHTML</code> on one of its parent elements will wipe out the state of the input and lose any text entered into the box. All systems for templating an interactive page need a way to prevent these kinds of problems from happening on each render and only overwriting state that is supposed to be overwritten.</p><p>React famously works around this problem by using a <a href="https://legacy.reactjs.org/docs/faq-internals.html">Virtual DOM</a> that is then reconciled with the browser DOM, but even frameworks that are server focused like <a href="https://htmx.org">HTMX</a> need <a href="https://github.com/bigskysoftware/htmx/blob/master/src/htmx.js#L1023">a solution for swapping out DOM nodes</a> without wiping out the current element state. Another solution in this vein is <a href="https://www.npmjs.com/package/morphdom">MorphDOM</a> which is eight years old. More recently, <a href="https://alpinejs.dev/">Caleb Porzio</a> has been working on <a href="https://alpinejs.dev/plugins/morph">@alpinejs/morph</a> as a solution to the problem, and he occasionally <a href="https://notesonwork.transistor.fm">podcasts</a> about the issues he runs into with difficult edge cases. Svelte works around the problem of reconciling VDOMs by pushing as much of the reconciliation process into its compiler as possible, but even for Svelte, there are limitations on what’s possible to do in advance and some things need to be <a href="https://github.com/sveltejs/svelte/blob/b8f3c49e5ff7378df2196d0c9ae24a58e282bb0a/packages/svelte/src/internal/client/render.js#L1519">done on the client</a>. In any event, while compiler side solutions are good, it is also good to have solutions that can work even without a build step.</p><p>However you tackle it, creating a diff between two DOM trees can be an extremely complex process due to the difficulties inherent in figuring out if a node has been entirely replaced or just moved to another place in the tree. There are lots of corner cases to consider and tradeoffs to think about. This is another area really ripe for consolidation by browser makers. If the browser had an API that was capable of reconciling two DOM trees, it could be faster and more efficient. Having this as a browser API would let frameworks stop trying to differentiate themselves on <a href="https://krausest.github.io/js-framework-benchmark/">rendering performance</a> and instead focus on differentiating based on the convenience of their APIs and the depth of their ecosystems. It’s another well tread field that is ready to be paved.</p><h2 id="self-sizing-iframes">Self-sizing iframes</h2><p>Let’s talk about another common developer need not mentioned in Lawson’s article and a technology that I think has fallen off the radars of a lot of developers because it is seen as being a legacy technique.</p><p>The humble <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">iframe</a> may date back to Internet Explorer 4, but it is actually more powerful than the Shadow DOM because they have stronger style isolation and some <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#allow">real security guarantees</a>. As a result, while iframes have basically no role in modern JavaScript frameworks, they are still extremely common in <a href="https://blog.carlana.net/post/2020/article-bits/">my field of online news publishing</a>. If you have a content well and you want to be able to put some kind of widget in the middle of it and have it work across <a href="https://kinsta.com/knowledgebase/content-management-system/">CMSes</a> and future redesigns, you use an iframe. The examples of this include everything from charts by <a href="https://www.datawrapper.de">DataWrapper</a> and <a href="https://flourish.studio">Flourish</a> to videos from <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">YouTube</a> and <a href="https://vimeo.com">Vimeo</a>.</p><p>The big problem with iframes is that there isn’t a way in CSS to tell an iframe to take on the height of its content. There are good reasons for this. For example, if a host page could learn whether you’re logged into your banking site by just adding an iframe and seeing if it’s the height of the logged in page or the logged out page, that would be bad. As a result, the best way to make a responsively sized iframe is to use JavaScript to pass a message from the contained page to the host page that tells the host the size of the contained page so that the host can then resize the iframe appropriately. There are various libraries that people use to do this, like NPR’s <a href="https://blog.apps.npr.org/pym.js/">Pym.js</a> and <a href="https://apps.npr.org/sidechain/">SideChain</a> or <a href="https://www.npmjs.com/package/@newswire/frames">@newswire/frames</a>.</p><p>In spite of the security concerns, I think this could be worked around with a native solution in which the framing and framed pages use an <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options header</a> or a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">CSP</a> to tell the browser which sites want to cooperate on allowing a dynamic frame height. Moving this out of JavaScript and into the browser would fix a lot of little glitches that come from polling for window size changes or contained pages with a <code>vh</code> CSS style, and make life easier for anyone who has to create or use an embed. It would also make it possible to use responsive iframes even in contexts where JavaScript isn’t allowed or needs to be heavily restricted.</p><h2 id="wrapping-it-up">Wrapping it up</h2><p>I hope you all understand what I’m arguing for. The dream of Web Components is a good one, but we need new solutions to match the problems encountered by contemporary web developers, not just a continued retreading of a path laid out a decade ago.</p><p>I asked <a href="https://claude.ai/">Claude</a> to write a stunning conclusion to this blog post, and here’s what it came up with:</p><blockquote><p>The promise of “Web Components” capturing imaginations across the web has fallen short. Instead of trying to retrofit new APIs onto old problems, we should look to the future - following the desire lines that developers are already tracing out.</p><p>Reactivity, virtual DOM reconciliation, and self-sizing iframes are all areas where developers have put in hard work over years to find solutions. Now it’s time for browser makers to pave those roads - taking the best of what developers have created and making it faster, more efficient, and universally available.</p><p>This is how real progress happens on the web - not starting from lofty top-down ideas, but from real solutions emerging organically to meet actual needs. If browser makers can shift to enabling what developers are already doing, we’ll wind up with better tools for everyone. The solutions won’t always be sexy, but they’ll be grounded in practicality.</p><p>So let’s learn from the past, meet the present where it lives, and build the web we need - not the one we imagine. The pieces are already coming together if we have the vision to see them.</p></blockquote><p>On that note, let’s keep blazing new trails for the future of the web, before the coming AI-powered coding robots inevitably <a href="https://www.gocomics.com/nancy/2022/11/05">put us all out of work</a>.</p><p><em>P.S. This is the first blog post I’ve published under the name Carlana. <a href="https://tech.lgbt/@carlana/111523437780760674">See here for details</a>.</em></p></section></div>
  </body>
</html>
