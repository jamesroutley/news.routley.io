<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sqlite.org/partialindex.html">Original</a>
    <h1>SQLite – Partial Indexes</h1>
    
    <div id="readability-page-1" class="page"><div>







<p>
A partial index is an index over a subset of the rows of a table.
</p>

<p>
In ordinary indexes, there is exactly one entry in the index for every
row in the table.  In partial indexes, only some subset of the rows in the
table have corresponding index entries.  For example, a partial index might
omit entries for which the column being indexed is NULL.  When used 
judiciously, partial indexes can result in smaller database files and
improvements in both query and write performance.
</p>



<p>
Create a partial index by adding a WHERE clause to the end of an 
ordinary <a href="https://www.sqlite.org/lang_createindex.html">CREATE INDEX</a> statement.
</p>

<p><b><a href="https://www.sqlite.org/syntax/create-index-stmt.html">create-index-stmt:</a></b>
</p>
 <div id="x2304">
 <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 907.43 232.632">
<circle cx="5" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="32,17 20,21 20,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17L26,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M47,32L100,32A15 15 0 0 0 116 17A15 15 0 0 0 100 2L47,2A15 15 0 0 0 32 17A15 15 0 0 0 47 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="74" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">CREATE</text>
<path d="M167,56L222,56A15 15 0 0 0 237 41A15 15 0 0 0 222 26L167,26A15 15 0 0 0 152 41A15 15 0 0 0 167 56Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="194" y="41" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">UNIQUE</text>
<path d="M288,32L327,32A15 15 0 0 0 342 17A15 15 0 0 0 327 2L288,2A15 15 0 0 0 273 17A15 15 0 0 0 288 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="307" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">INDEX</text>
<polygon points="194,17 183,21 183,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M116,17L188,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="273,17 261,21 261,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M194,17L267,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="152,41 140,45 140,37" style="fill:rgb(0,0,0)"></polygon>
<path d="M116,17 L 123,17 Q 131,17 131,29 Q 131,41 138,41 L 146,41" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M237,41 L 244,41 Q 252,41 252,29 Q 252,17 256,17 L 261,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="378,17 367,21 367,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M342,17L372,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M393,32A15 15 0 0 0 408 17A15 15 0 0 0 393 2A15 15 0 0 0 378 17A15 15 0 0 0 393 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="393" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">IF</text>
<polygon points="431,17 420,21 420,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M408,17L426,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M447,32L467,32A15 15 0 0 0 482 17A15 15 0 0 0 467 2L447,2A15 15 0 0 0 431 17A15 15 0 0 0 447 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="457" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">NOT</text>
<polygon points="505,17 493,21 493,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M482,17L499,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M520,32L565,32A15 15 0 0 0 580 17A15 15 0 0 0 565 2L520,2A15 15 0 0 0 505 17A15 15 0 0 0 520 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="542" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">EXISTS</text>
<polygon points="194,71 206,67 206,76" style="fill:rgb(0,0,0)"></polygon>
<path d="M342,17 L 350,17 Q 357,17 357,32 L 357,56 Q 357,71 342,71 L 215,71 L 200,71" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="505,71 516,67 516,76" style="fill:rgb(0,0,0)"></polygon>
<path d="M580,17 L 601,17 Q 616,17 616,32 L 616,56 Q 616,71 601,71 L 526,71 L 511,71" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M505,71L273,71" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="28,109 17,113 17,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M273,71 L 20,71 Q 5,71 5,86 L 5,94 Q 5,109 14,109 L 23,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M43,124L140,124A15 15 0 0 0 155 109A15 15 0 0 0 140 94L43,94A15 15 0 0 0 28 109A15 15 0 0 0 43 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="92" y="109" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">schema-name</text>
<polygon points="178,109 166,113 166,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M155,109L172,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M193,124A15 15 0 0 0 208 109A15 15 0 0 0 193 94A15 15 0 0 0 178 109A15 15 0 0 0 193 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="193" y="109" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">.</text>
<polygon points="244,109 233,113 233,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M208,109L238,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M259,124L338,124A15 15 0 0 0 353 109A15 15 0 0 0 338 94L259,94A15 15 0 0 0 244 109A15 15 0 0 0 259 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="299" y="109" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">index-name</text>
<polygon points="376,109 364,113 364,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M353,109L370,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M391,124L400,124A15 15 0 0 0 415 109A15 15 0 0 0 400 94L391,94A15 15 0 0 0 376 109A15 15 0 0 0 391 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="395" y="109" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">ON</text>
<polygon points="438,109 427,113 427,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M415,109L432,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M453,124L528,124A15 15 0 0 0 543 109A15 15 0 0 0 528 94L453,94A15 15 0 0 0 438 109A15 15 0 0 0 453 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="491" y="109" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">table-name</text>
<polygon points="567,109 555,113 555,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M543,109L561,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M582,124A15 15 0 0 0 597 109A15 15 0 0 0 582 94A15 15 0 0 0 567 109A15 15 0 0 0 582 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="582" y="109" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">(</text>
<polygon points="633,109 621,113 621,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M597,109L627,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M633,124L777,124L777,94L633,94Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="705" y="109" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">indexed-column</text>
<polygon points="813,109 802,113 802,105" style="fill:rgb(0,0,0)"></polygon>
<path d="M777,109L808,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M828,124A15 15 0 0 0 844 109A15 15 0 0 0 828 94A15 15 0 0 0 813 109A15 15 0 0 0 828 124Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="828" y="109" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
<path d="M705,162A15 15 0 0 0 720 147A15 15 0 0 0 705 132A15 15 0 0 0 690 147A15 15 0 0 0 705 162Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="705" y="147" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">,</text>
<polygon points="720,147 732,142 732,151" style="fill:rgb(0,0,0)"></polygon>
<path d="M777,109 L 785,109 Q 792,109 792,124 L 792,132 Q 792,147 777,147 L 741,147 L 726,147" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M690,147 L 625,147 Q 610,147 610,132 L 610,124 Q 610,109 617,109 L 625,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="92,139 80,144 80,135" style="fill:rgb(0,0,0)"></polygon>
<path d="M5,94 L 5,124 Q 5,139 20,139 L 71,139 L 86,139" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M92,139 L 205,139 Q 220,139 220,124 L 220,124 Q 220,109 227,109 L 235,109" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M684,230L733,230A15 15 0 0 0 748 215A15 15 0 0 0 733 200L684,200A15 15 0 0 0 669 215A15 15 0 0 0 684 230Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="709" y="215" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">WHERE</text>
<polygon points="772,215 760,219 760,211" style="fill:rgb(0,0,0)"></polygon>
<path d="M748,215L766,215" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M772,230L821,230L821,200L772,200Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="796" y="215" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">expr</text>
<polygon points="898,215 886,219 886,211" style="fill:rgb(0,0,0)"></polygon>
<path d="M821,215L892,215" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<circle cx="901" cy="215" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="859,147 854,135 863,135" style="fill:rgb(0,0,0)"></polygon>
<path d="M844,109 L 851,109 Q 859,109 859,124 L 859,126 L 859,141" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M859,147 L 859,200 Q 859,215 872,215 L 886,215" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="705,177 717,173 717,181" style="fill:rgb(0,0,0)"></polygon>
<path d="M859,147 L 859,162 Q 859,177 844,177 L 726,177 L 711,177" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="669,215 657,219 657,211" style="fill:rgb(0,0,0)"></polygon>
<path d="M705,177 L 661,177 Q 646,177 646,192 L 646,200 Q 646,215 654,215 L 663,215" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
</svg>
</p>
<p><b><a href="https://www.sqlite.org/syntax/expr.html">expr:</a></b>
</p>
 
<p><b><a href="https://www.sqlite.org/syntax/indexed-column.html">indexed-column:</a></b>
</p>
 
</div>


<p>
Any index that includes the WHERE clause at the end is considered to be
a partial index.  Indexes that omit the WHERE clause (or indexes that
are created by UNIQUE or PRIMARY KEY constraints inside of CREATE TABLE
statements) are ordinary full indexes.
</p>

<p>
The expression following the WHERE clause may contain operators,
literal values, and names of columns in the table being indexed.
The WHERE clause may <em>not</em> contain subqueries, references to other
tables, <a href="https://www.sqlite.org/deterministic.html">non-deterministic functions</a>, or <a href="https://www.sqlite.org/lang_expr.html#varparam">bound parameters</a>.</p>

<p>
Only rows of the table for which the WHERE clause evaluates to true
are included in the index.  If the WHERE clause expression evaluates 
to NULL or to false for some rows of the table, then those rows are omitted 
from the index.
</p>

<p>
The columns referenced in the WHERE clause of a partial index can be
any of the columns in the table, not just columns that happen to be
indexed.  However, it is very common for the WHERE clause
expression of a partial index to be a simple expression on the column
being indexed.  The following is a typical example:</p>

<div><pre>CREATE INDEX po_parent ON purchaseorder(parent_po) WHERE parent_po IS NOT NULL;
</pre></div>

<p>In the example above, if most purchase orders do not have a &#34;parent&#34;
purchase order, then most parent_po values will be NULL.  That means only
a small subset of the rows in the purchaseorder table will be indexed.
Hence the index will take up much less space.  And changes to the original
purchaseorder table will run faster since the po_parent index only needs
to be updated for those exceptional rows where parent_po is not NULL.
But the index is still useful for querying.  In particular, if one wants
to know all &#34;children&#34; of a particular purchase order &#34;?1&#34;, the query
would be:

</p><div><pre>SELECT po_num FROM purchaseorder WHERE parent_po=?1;
</pre></div>

<p>The query above will use the po_parent index to help find the answer,
since the po_parent index contains entries for all rows of interest.
Note that since po_parent is smaller than a full index, the query will
likely run faster too.</p>

<h2 id="unique_partial_indexes"><span>2.1. </span>Unique Partial Indexes</h2>

<p>A partial index definition may include the UNIQUE keyword.  If it
does, then SQLite requires every entry <em>in the index</em> to be unique.
This provides a mechanism for enforcing uniqueness across some subset of
the rows in a table.</p>

<p>For example, suppose you have a database of the members of a large
organization where each person is assigned to a particular &#34;team&#34;.  
Each team has a &#34;leader&#34; who is also a member of that team.  The
table might look something like this:</p>

<div><pre>CREATE TABLE person(
  person_id       INTEGER PRIMARY KEY,
  team_id         INTEGER REFERENCES team,
  is_team_leader  BOOLEAN,
  -- other fields elided
);
</pre></div>

<p>The team_id field cannot be unique because there are usually multiple people
on the same team.  One cannot make the combination of team_id and is_team_leader
unique since there are usually multiple non-leaders on each team.  The
solution to enforcing one leader per team is to create a unique index
on team_id but restricted to those entries for which is_team_leader is
true:</p>

<div><pre>CREATE UNIQUE INDEX team_leader ON person(team_id) WHERE is_team_leader;
</pre></div>

<p>Coincidentally, that same index is useful for locating the team leader
of a particular team:</p>

<div><pre>SELECT person_id FROM person WHERE is_team_leader AND team_id=?1;
</pre></div>



<p>Let X be the expression in the WHERE clause of a partial
index, and let W be the WHERE clause of a query that uses the
table that is indexed.  Then, the query is permitted to use 
the partial index if W⇒X, where the ⇒ operator
(usually pronounced &#34;implies&#34;) is the logic operator 
equivalent to &#34;X or not W&#34;.
Hence, determining whether or not a partial index
is usable in a particular query reduces to proving a theorem in
first-order logic.</p>

<p>SQLite does <u>not</u> have a sophisticated theorem
prover with which to determine W⇒X.  Instead, SQLite uses 
two simple rules to find the common cases where W⇒X is true, and
it assumes all the other cases are false.  The rules used by SQLite
are these:

</p><ol>
<li><p>If W is AND-connected terms and X is
OR-connected terms and if any term of W
appears as a term of X, then the partial index is usable.</p>

<p>For example, let the index be
</p><div><pre>CREATE INDEX ex1 ON tab1(a,b) WHERE a=5 OR b=6;
</pre></div>
<p>And let the query be:
</p><div><pre>SELECT * FROM tab1 WHERE b=6 AND a=7; <i>-- uses partial index</i>
</pre></div>
<p>Then the index is usable by the query because the &#34;b=6&#34; term appears
in both the index definition and in the query.  Remember: terms in the
index should be OR-connected and terms in the query should be AND-connected.</p>

<p>The terms in W and X must match exactly.  SQLite does not
do algebra to try to get them to look the same.
The term &#34;b=6&#34; does not match &#34;b=3+3&#34; or &#34;b-6=0&#34; or &#34;b BETWEEN 6 AND 6&#34;.
&#34;b=6&#34; will match to &#34;6=b&#34; as long as &#34;b=6&#34; is on the index and &#34;6=b&#34; is
in the query.  If a term of the form &#34;6=b&#34; appears in the index, it will
never match anything.</p>

</li><li><p>If a term in X is of the form &#34;z IS NOT NULL&#34; and if a term in
       W is a comparison operator on &#34;z&#34; other than &#34;IS&#34;, then those
       terms match.</p>

<p>Example:  Let the index be
</p><div><pre>CREATE INDEX ex2 ON tab2(b,c) WHERE c IS NOT NULL;
</pre></div>
<p>Then any query that uses operators =, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;,
IN, LIKE, or GLOB on column &#34;c&#34; 
would be usable with the partial index because those
comparison operators are only true if &#34;c&#34; is not NULL.  So the following
query could use the partial index:
</p><div><pre>SELECT * FROM tab2 WHERE b=456 AND c&lt;&gt;0;  <i>-- uses partial index</i>
</pre></div>
<p>But the next query can not use the partial index:
</p><div><pre>SELECT * FROM tab2 WHERE b=456;  <i>-- cannot use partial index</i>
</pre></div>
<p>The latter query can not use the partial index because there might be
rows in the table with b=456 and where c is NULL.  But those rows would
not be in the partial index.
</p></li></ol>

<p>These two rules describe how the query planner for SQLite works as of
this writing (2013-08-01).  And the rules above will always be honored.
However, future versions of SQLite might incorporate a better theorem prover
that can find other cases where W⇒X is true and thus may
find more instances where partial indexes are useful.</p>



<p>
Partial indexes have been supported in SQLite since <a href="https://www.sqlite.org/releaselog/3_8_0.html">version 3.8.0</a>
(2013-08-26).
</p>

<p>Database files that contain partial indices are not readable or writable
by versions of SQLite prior to 3.8.0.  However, a database file created
by SQLite 3.8.0 is still readable and writable by prior versions as long
as its schema contains no partial indexes.  A database that is unreadable
by legacy versions of SQLite can be made readable simply by running
<a href="https://www.sqlite.org/lang_dropindex.html">DROP INDEX</a> on the partial indexes.</p>
<p><small><i>This page last modified on  <a href="https://sqlite.org/docsrc/honeypot" id="mtimelink" data-href="https://sqlite.org/docsrc/finfo/pages/partialindex.in?m=ffe857a745620026d">2022-01-20 21:38:08</a> UTC </i></small></p>

</div></div>
  </body>
</html>
