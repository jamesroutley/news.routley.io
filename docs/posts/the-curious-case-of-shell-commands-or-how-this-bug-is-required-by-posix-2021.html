<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.volution.ro/v1/2021/01/notes/502e747f/">Original</a>
    <h1>The curious case of shell commands, or how &#34;this bug is required by POSIX&#34; (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="some-context">Some context</h2><p>(For those interested only in the <code>glibc</code> and POSIX issues, see <a href="#the-1000-bonus-points-bug">at the end</a>.)</p><p>I use Linux almost everywhere, from laptops and desktops to servers and routers, and over the course of many years I&#39;ve written quite a few <code>bash</code> scripts that ease my interaction with all of these.</p><p>The usual &#34;stack&#34; that ties all of these together is composed of:</p><ul><li><code>bash</code>, obviously for scripting;</li><li><code>ssh</code>, for remote execution;</li><li><code>i3</code>, the window manager for desktop environments;</li><li><code>screen</code>, for terminal multiplexing;</li><li><code>tmux</code>, for terminal multiplexing;</li><li><code>dtach</code>, for launching processes in background while still being able to access them if needed;</li><li>(among many other tools like <code>coreutils</code> and friends, <code>grep</code>, <code>sed</code>, <code>sort</code>, <code>find</code>, <code>xargs</code>, <code>rsync</code>, plus other smaller C, Go or Rust based tools; but all of these are not the subject of this article;)</li></ul><p>What do all of the former have in common? They all provide some sort of functionality, but by themselves they don&#39;t actually do anything; they are meant to delegate the actual work to other tools.</p><p>So what is the problem you ask? Nothing really... Everything is fine... No planes are falling from the sky... Nobody is running around screaming while on fire...
Everything is business as usual, <strong>unless you want to write some wrapper scripts that takes arbitrary user input and delegates that to one of these, and many other, broken tools</strong>...</p><p>And just for completeness I&#39;ll throw in some other tools that fit the bill:</p><ul><li><code>make</code> (and any other variant or derivate), for build systems;</li><li><code>ninja</code>, my favorite build system, and lightweight DAG job scheduler and executer;</li></ul><h2 id="root-of-all-evil">Root of all evil</h2><p>As many of you have guessed, because we live in a UNIX world, many of these tools delegate the actual tool execution to the <code>glibc</code> <code><a id="link-168bad72" href="https://man7.org/linux/man-pages/man3/system.3.html" target="_blank">system(3)</a></code> function,
which ends-up calling <code><a id="link-58c82849" href="https://man7.org/linux/man-pages/man1/sh.1p.html" target="_blank">sh(1p)</a></code> (most likely <code>bash</code>) with the <code>-c</code> argument.
As opposed to doing the correct thing and just calling <code><a id="link-592625ee" href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank">execve(2)</a></code>...</p><p>BTW, this is not something Linux specific. Unfortunately it is a trait inherited from the UNIX ancestry by almost all operating systems, including all BSD variants plus OSX;
and, for some tools, this behavior is even seen when running on Windows.
But I digress...</p><h6 id="excerpts-from-linux-system3-man-page">Excerpts from Linux <code>system(3)</code> man page</h6><p>Let&#39;s quote from the Linux <code><a id="link-168bad72" href="https://man7.org/linux/man-pages/man3/system.3.html" target="_blank">system(3)</a></code> man page:</p><blockquote><p>The <code>system(3)</code> library function uses <code>fork(2)</code> to create a child
process that executes the shell command specified in command
using <code>execl(3)</code> as follows:</p><pre tabindex="0"><code>execl(&#34;/bin/sh&#34;, &#34;sh&#34;, &#34;-c&#34;, command, (char *) NULL);
</code></pre><p>[...]</p><p>Any user input that is employed as part of command should be
carefully sanitized, to ensure that unexpected shell commands or
command options are not executed. Such risks are especially
grave when using <code>system()</code> from a privileged program.</p></blockquote><ul><li>So far the warning doesn&#39;t sound very comforting...
But hey, we are all responsible developers...</li></ul><h6 id="excerpts-from-posix-system3p-man-page">Excerpts from POSIX <code>system(3p)</code> man page</h6><p>Let&#39;s quote from the POSIX <code><a id="link-f16d6942" href="https://man7.org/linux/man-pages/man3/system.3p.html" target="_blank">system(3p)</a></code> man page:</p><ul><li>Hmm... Strange... There is nothing to quote from this manual about warnings, issues or sanitization...
(Except perhaps the warning for set-UID or set-GID processes against using this function, due to potential privilege escalation issues.)</li></ul><h6 id="excerpts-from-posix-sh1p-man-page">Excerpts from POSIX <code>sh(1p)</code> man page</h6><p>How about quoting from the POSIX <code><a id="link-58c82849" href="https://man7.org/linux/man-pages/man1/sh.1p.html" target="_blank">sh(1p)</a></code> man page regarding the <code>-c</code> flag:</p><blockquote><p><code>-c</code> -- Read commands from the command_string operand. Set the
value of special parameter 0 (see Section 2.5.2,
Special Parameters) from the value of the command_name
operand and the positional parameters (<code>$1</code>, <code>$2</code>, and so
on) in sequence from the remaining argument operands.
No commands shall be read from the standard input.</p></blockquote><ul><li>OK... Still nothing about warnings, issues or sanitization...</li></ul><h6 id="excerpts-from-bash1-man-page">Excerpts from <code>bash(1)</code> man page</h6><p>Perhaps we&#39;ll have more luck quoting from the <code><a id="link-82b717c1" href="https://man7.org/linux/man-pages/man1/bash.1.html" target="_blank">bash(1)</a></code> man page:</p><blockquote><p><code>-c</code> -- If the <code>-c</code> option is present, then commands are read from
the first non-option argument command_string. If there
are arguments after the <code>command_string</code>, the first argument
is assigned to <code>$0</code> and any remaining arguments are assigned
to the positional parameters. The assignment to <code>$0</code> sets
the name of the shell, which is used in warning and error
messages.</p></blockquote><ul><li>Hmm... Perhaps sanitization isn&#39;t that a big of an issue?</li></ul><h6 id="partial-conclusion">Partial conclusion</h6><p>For now let&#39;s remember that initial remark:</p><blockquote><p>Any user input [...] part of command should be [...] sanitized [...].</p></blockquote><p>Aside from that, perhaps this &#34;shell command&#34; business I&#39;m crying about isn&#39;t such a big of an issue?
Else the POSIX manuals for <code>system(3p)</code> (~2K words) and <code>sh(1p)</code> (~8K words)
-- that I assume were written by legions of committee members -- would have certainly spared at least a few words about this issue...
Right?</p><h2 id="unintended-consequences">Unintended consequences</h2><p>So why do we care about <code>system(3)</code> and <code>sh -c</code>?</p><p>Because as said in the beginning, many tools accept as arguments commands which in the end are passed to <code>sh -c</code> via the <code>system(3)</code> function.</p><p>Therefore when we write our scripts and tools we need to be aware of this situation and be prepared to escape and quote our commands and arguments accordingly,
else we&#39;ll be subject to <a id="link-78b06a91" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection" target="_blank">shell injections</a>... (For more scarry stuff one can read about <a id="link-b844b12d" href="https://en.wikipedia.org/wiki/Shellshock_%28software_bug%29" target="_blank">shellshock</a>.)</p><h6 id="a-harmless-example">A harmless example...</h6><p>For example say we want to write a script that takes exactly two arguments, a command and a single argument (that we store in the <code>_command</code> and <code>_argument</code> variables):</p><pre tabindex="0"><code>if test &#34;${#}&#34; -ne 2 ; then
    printf -- &#39;[ee] invalid arguments!\n&#39; &gt;&amp;2
fi
_command=&#34;${1}&#34;
_argument=&#34;${2}&#34;
shift -- 2
</code></pre><p>And after some initial setup we want pass our command to a tool such as <code><a id="link-cd08f2d2" href="https://man7.org/linux/man-pages/man1/watch.1.html" target="_blank">watch</a></code>, <code><a id="link-640eb6ea" href="https://github.com/sharkdp/hyperfine" target="_blank">hyperfine</a></code>, <code>ssh</code> and many others, as in <code>tool &#34;command argument&#34;</code>.</p><p>Thus one would quickly write the following:</p><pre tabindex="0"><code>tool &#34;${_command} ${_argument}&#34;
</code></pre><p>(Granted <code>watch</code> does have the <code>-x</code> flag that solves this issue, however it is not the default; moreover <code>ssh</code>, <code>hyperfine</code> and many other tools don&#39;t have this option.)</p><h6 id="-with-interesting-failure-modes">... with interesting failure modes</h6><p>If one has written the delegation as above, then one would be in a bit of surprise, because trying to use a command or argument that:</p><ul><li><strong>contains a space</strong> -- would yield the wrong command (if the space is in the command) or multiple arguments (in any case);</li><li><strong>contains a quote or backspace</strong> -- most likely would result in an invalid syntax due to mismatched quotes;</li><li><strong>contains a special character</strong> like <code>$</code>, <code>*</code>, <code>?</code>, etc. -- environment and glob expansion would take place, yielding wrong arguments;</li><li><strong>contains a special character or token</strong> like <code>;</code>, <code>{</code>, <code>}</code>, <code>(</code>, <code>)</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>&amp;</code>, etc. -- would basically result in the equivalent of an SQL injection;</li><li><strong>contains a backquote</strong> -- sub-command expansion would take place, yet another equivalent of an SQL injection;</li><li>basically anything that is not a number or letter will definitively break something...</li></ul><p>Thus one asks himself, what is the right solution?</p><h2 id="proper-solution">Proper solution</h2><p>The proper solution would be dropping that broken tool immediately,
securely erasing it from your hard-drive,
then running and screaming that tool&#39;s name out-loud in shame...
(Something akin to Game of Throne&#39;s walk of atonement...)</p><p>I&#39;m not kidding...
This kind of broken tools are the cause of many stupid bugs,
ranging from the funny <a id="link-88acb5de" href="https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/issues/123" target="_blank">ups-rm-with-spaces</a> (i.e. <code>rm -Rf / some folder with spaces /some-file</code>),
to serious security issues like the formerly mentioned <a id="link-b844b12d" href="https://en.wikipedia.org/wiki/Shellshock_%28software_bug%29" target="_blank">shellshock</a>...</p><p>So, you say someone holds you at gun point, thus you must use that tool?
Check if the broken tool doesn&#39;t have a flag that disables calling <code>sh -c</code>, and instead properly executes the given command and arguments directly via <code><a id="link-592625ee" href="https://man7.org/linux/man-pages/man2/execve.2.html" target="_blank">execve(2)</a></code>.
(For example <code>watch</code> has the <code>-x</code> flag as mentioned.)</p><p>Alternatively, given that most likely the tool in question is an open-source project written by someone in his spare time,
perhaps open a feature request describing the issue,
and if possible contribute with a patch that solves it.</p><p>Still no luck?
Make some popcorn and prepare for the latest block-buster &#34;convoluted solutions for simple problems in UNIX town&#34;...</p><h2 id="convoluted-solutions">Convoluted solutions</h2><p>However if we are forced to use that <strong>broken</strong> tool, we&#39;ll need to apply the following countermeasures...</p><p>Yes, I&#39;ve written &#34;countermeasures&#34;, because now we have to think like an attacker and see how we can break our own script,
then with each attempt we&#39;ll build layers upon layers of countermeasures.
And if our eyes start hurting, it might be because of the onion we&#39;ve created with all these convoluted layers...</p><p><strong>Please note that none of the following are the correct solution. Instead they are just steps in building towards the correct solution.</strong></p><p><strong>Also, please note that most likely I&#39;ve gotten half of it wrong!</strong></p><h3 id="convoluted-step-1----quoting-the-command-and-arguments">Convoluted step 1 -- quoting the command and arguments</h3><p>A first step is to use the <code>bash</code> specific <code>@Q</code> expansion modifier that properly quotes a string according to the <code>sh</code> rules:</p><pre tabindex="0"><code>broken-tool &#34;${_command@Q} ${_argument@Q}&#34;
</code></pre><p>In case we have multiple arguments, as in <code>_arguments=( &#34;${@}&#34; )</code>, then one could use the following:</p><pre tabindex="0"><code>broken-tool &#34;${_command@Q} ${_arguments[*]@Q}&#34;
</code></pre><p>In case we don&#39;t need the extra variables, we could simply just write:</p><pre tabindex="0"><code>broken-tool &#34;${*@Q}&#34;
</code></pre><h3 id="convoluted-step-2----using-exec-before-the-command">Convoluted step 2 -- using <code>exec</code> before the command</h3><p>What would happen if our command happens to be named just like a <code>bash</code> built-in, like for example <code>kill</code> or <code>time</code> which are not compatible with our arguments?
Did you know that there are executables, in the default distribution, that are named <code>if</code>, <code>echo</code>, <code>printf</code> and even <code>test</code> or <code>[</code>? (Just try it out with <code>type -P if</code>.)</p><p>In order to make sure that we are actually executing the command as available from the <code>$PATH</code> environment variable,
we should prefix it with an <code>exec</code>:</p><pre tabindex="0"><code>broken-tool &#34;exec ${_command@Q} ${_arguments[*]@Q}&#34;
</code></pre><h3 id="convoluted-step-3----using----after-exec">Convoluted step 3 -- using <code>--</code> after <code>exec</code></h3><p>What would happen if our command happens to start with a hyphen, like for example <code>-strange-command</code>?</p><p>In order to make sure that the command isn&#39;t by mistake interpreted as a flag to <code>exec</code> itself,
we should also add an <code>--</code> between <code>exec</code> and the command:</p><pre tabindex="0"><code>broken-tool &#34;exec -- ${_command@Q} ${_arguments[*]@Q}&#34;
</code></pre><p>Please note that not all <code>sh</code> implementations actually support the <code>exec --</code> variant.</p><h3 id="final-convoluted-solution">Final convoluted solution</h3><pre tabindex="0"><code>broken-tool &#34;exec -- ${_command@Q} ${_arguments[*]@Q}&#34;
</code></pre><p>In fact many tools accept themselves the <code>--</code> argument to denote the end of all &#34;options&#34; and the beginning of &#34;arguments&#34;,
thus my favorite final variant would be:</p><pre tabindex="0"><code>broken-tool -- &#34;exec -- ${_command@Q} ${_arguments[*]@Q}&#34;
</code></pre><h2 id="the-road-paved-with-good-intentions">The road paved with good intentions</h2><p>So now you ask yourself, which are the tools that should be treated with such great care?</p><h6 id="case-study----watch1-man-page">Case study -- <code>watch(1)</code> man page</h6><p>Let&#39;s look at the <code><a id="link-cd08f2d2" href="https://man7.org/linux/man-pages/man1/watch.1.html" target="_blank">watch(1)</a></code> manual:</p><ul><li>at the beginning we encounter <code>watch [options] command</code>, thus it hints that it might be the case;</li><li>however later it gives examples such as <code>watch -n 60 from</code> and <code>watch -d ls -l</code>, which suggests it might not be the case?</li><li>our first hint is another example such as <code>watch -d &#39;ls -l | fgrep joe&#39;</code>, that not only suggests it would use <code>system(3)</code> to execute our tool, but in fact it encourages us to use full sized <code>sh</code> scripts;</li><li>finally the <code>-x</code> (or <code>--exec</code>) flag gives the final response:</li></ul><blockquote><p>Pass command to exec(2) instead of sh -c which reduces the
need to use extra quoting to get the desired effect.</p></blockquote><h6 id="case-study----ssh1-man-page">Case study -- <code>ssh(1)</code> man page</h6><p>Let&#39;s look at the <code><a id="link-09583cc9" href="https://man7.org/linux/man-pages/man1/ssh.1.html" target="_blank">ssh(1)</a></code> manual:</p><ul><li>at the beginning we encounter <code>ssh [...] destination [command]</code>, thus it hints that it might be the case;</li><li>however, strangely enough for such a complex tool, we have no examples regarding its invocation;</li><li>thus the manual is &#34;silent&#34; about any such detail...</li></ul><p>However by trying various experiments, we guess it might not be the case?</p><ul><li><code>ssh user@remote echo a b c</code>;</li><li><code>ssh user@remote cat /etc/passwd</code>;</li></ul><p>Spoiler: <code>ssh</code> is one of the tools that not only should be handled with great care, they even lack a flag that would disable this dangerous behavior...</p><h6 id="case-study----i3-and-i3-msg">Case study -- <code>i3</code> and <code>i3-msg</code></h6><p>Let&#39;s look at the <code><a id="link-e6261eef" href="https://i3wm.org/docs/userguide.html" target="_blank">i3</a></code> and <code><a id="link-0981d513" href="https://manpages.debian.org/unstable/i3-wm/i3-msg.1.en.html" target="_blank">i3-msg</a></code> manuals; from <code>i3-msg</code> we have:</p><blockquote><p><code>i3-msg</code> <code>[-q]</code> <code>[-v]</code> <code>[-h]</code> <code>[-s socket]</code> <code>[-t type]</code> <code>[message]</code></p><p><code>command</code> -- The payload of the message is a command for i3 (like the commands you can bind to keys in the configuration file) and will be executed directly after receiving it.</p></blockquote><p>From <code>i3</code> we have:</p><ul><li><code>exec [--no-startup-id] &lt;command&gt;</code> (as syntax)</li><li><code>exec --no-startup-id xdotool key --clearmodifiers ctrl+v</code> (as example)</li><li><code>exec --no-startup-id import /tmp/latest-screenshot.png</code> (as example)</li><li>finally in a later section the manual states:</li></ul><blockquote><p><code>exec [--no-startup-id] &lt;command&gt;</code></p><p>The <code>exec</code> command starts an application by passing the command you specify to a shell.</p></blockquote><h6 id="the-common-thread">The common thread...</h6><p>All of these tools behave in a misleading way:</p><ul><li>they usually <strong>expect</strong> a single &#34;command&#34; that is in fact an <code>sh</code> script;</li><li>however they accept multiple &#34;arguments&#34; that are joined together by spaces to form the final command;</li><li>their manuals are quite expeditive when it comes to the &#34;command&#34; syntax and handling;</li></ul><h6 id="some-experiments">Some experiments...</h6><p>Let&#39;s experiment for example with <code>printf</code> (not the <code>bash</code> builtin, but the executable, thus the full path used):
<code>/usr/bin/printf .%q. argument-1 argument-2</code>
would print out its arguments, quoted according to <code>sh</code> syntax, and joined by dots, as in:</p><pre tabindex="0"><code>&gt; /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;
.&#39;1 2&#39;..&#39;; a&#39;..&#39;b ;&#39;..&#39;c ; d&#39;.

&gt; /usr/bin/printf .%q. &#34;&#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;&#34;
.&#39;&#39;\&#39;&#39;1 2&#39;\&#39;&#39; &#39;\&#39;&#39;; a&#39;\&#39;&#39; &#39;\&#39;&#39;b ;&#39;\&#39;&#39; &#39;\&#39;&#39;c ; d&#39;\&#39;&#39;&#39;.

&gt; /usr/bin/printf .%q. &#39;&#34;1 2 &#39; &#39; 3 4&#34;&#39;
.&#39;&#34;1 2 &#39;..&#39; 3 4&#34;&#39;.
</code></pre><p>Now let&#39;s try that through <code>ssh</code>:</p><ul><li>quoting the entire command, yields the correct outcome:</li></ul><pre tabindex="0"><code>&gt; ssh user@remote &#34;/usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;&#34;
.&#39;1 2&#39;..&#39;; a&#39;..&#39;b ;&#39;..&#39;c ; d&#39;.
</code></pre><ul><li>quoting only the last three arguments, yields the same outcome as above,
although the arguments are different (see the previous <code>printf</code> experiment):</li></ul><pre tabindex="0"><code>&gt; ssh user@remote /usr/bin/printf .%q. &#34;&#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;&#34;
.&#39;1 2&#39;..&#39;; a&#39;..&#39;b ;&#39;..&#39;c ; d&#39;.
</code></pre><ul><li>getting more creative with quotes, and now the arguments are merged into a single one:</li></ul><pre tabindex="0"><code>&gt; ssh user@remote /usr/bin/printf .%q. &#39;&#34;1 2 &#39; &#39; 3 4&#34;&#39;
.&#39;1 2   3 4&#39;.
</code></pre><ul><li>forgetting the quotes, and now disaster strikes:</li></ul><pre tabindex="0"><code>&gt; ssh user@remote /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;
.1..2.
bash: a: command not found
bash: c: command not found
bash: d: command not found
</code></pre><ul><li>basically <code>ssh</code> just takes your arguments, joins them with spaces (regardless of what they contain),
and shove them into <code>sh -c</code> on the remote server...</li><li>thus the last example, the one that everybody would expect to be correct, and which can be found in many examples (sans the spaces), is actually the wrong one...</li></ul><p>Finally let&#39;s try that through <code>i3-msg</code>:</p><pre tabindex="0"><code>&gt; i3-msg -t command -- exec urxvt -hold -e /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;
ERROR: Your command: exec urxvt -hold -e /usr/bin/printf .%q. 1 2 ; a b ; c ; d
ERROR:                                                              ^^^^^^^^^^^
</code></pre><pre tabindex="0"><code>&gt; i3-msg -t command -- exec &#34;urxvt -hold -e /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;&#34;
ERROR: Your command: exec urxvt -hold -e /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;
ERROR:                                                                 ^^^^^^^^^^^^^^^^
</code></pre><pre tabindex="0"><code>&gt; i3-msg -t command -- &#34;exec \&#34;urxvt -hold -e /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;\&#34;&#34;
# the expected outcome
</code></pre><pre tabindex="0"><code>&gt; i3-msg -t command -- &#34;exec \&#34;exec -- urxvt -hold -e /usr/bin/printf .%q. &#39;1 2&#39; &#39;; a&#39; &#39;b ;&#39; &#39;c ; d&#39;\&#34;&#34;
# the expected outcome
</code></pre><ul><li>basically there are two &#34;layers of interpreters&#34;;</li><li>first there is the <code>i3</code> command parser, which fails in the first two examples;</li><li>then there is the <code>sh -c</code> command parser, which handles the last two examples;</li></ul><h2 id="lessons-learned">Lessons learned</h2><p>First of all we should stop using the any tool or library that uses <code>system(3)</code>, <code>sh -c</code>, or equivalent.</p><p>If we can&#39;t replace those tools or libraries, then we should be careful and:</p><ul><li>always properly quote and escape the executable and arguments;</li><li>always prefix our commands with <code>exec --</code>;</li><li>always try to provide a full or relative path to the executable (as resolved from <code>$PATH</code> environment variable);</li><li>always try to &#34;fuzz&#34; our scripts and tools to see if we&#39;ve covered all the corner cases;</li><li>always ask ourselves if there aren&#39;t multiple layers of parsers (like in the case of <code>i3</code>, <code>tmux</code>, and other tools);</li></ul><p>Second, we should create a &#34;wall of shame&#34; for those important tools that provide no alternative.
Among these, at the top of the list in large-bold-red font I would definitively include OpenSSH, which given it&#39;s high profile, is perhaps responsible for countless hidden bugs that have their root cause in the way commands are handled.</p><p>In the end I acknowledge that that the &#34;technical&#34; fault is not with these tools but with their users.
But in the end their developers should know better, and try to be as safe as possible...</p><hr/><h2 id="wall-of-shame">Wall of shame</h2><ul><li>OpenSSH -- it takes any number of &#34;command arguments&#34;, just joins them with spaces, and shoves the outcome in <code>sh -c</code> on the remote node;</li><li>Ruby&#39;s <a id="link-05cb8a3f" href="https://ruby-doc.org/core-3.0.0/Kernel.html#method-i-60" target="_blank">backtick</a> feature -- provides easy access to <code>system(3)</code>;</li><li>Ruby&#39;s <a id="link-139951cd" href="https://ruby-doc.org/core-3.0.0/Kernel.html#method-i-system" target="_blank">system</a> function -- provides easy access to <code>system(3)</code> when one provides a single string as &#34;command&#34;; (what if I have no arguments? how can I disable the &#34;shell&#34; behavior?)</li><li>Python&#39;s <a id="link-c2710028" href="https://docs.python.org/3/library/os.html#os.system" target="_blank">os.system</a> and <a id="link-e16b546d" href="https://docs.python.org/3/library/os.html#os.popen" target="_blank">os.popen</a> functions -- simple wrappers for <code>system(3)</code>;</li><li>Node&#39;s <a id="link-3f553396" href="https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback" target="_blank">child_process.exec</a> function -- simple wrapper for <code>system(3)</code> which unfortunately has a misleading name tricking one into thinking it is a <code>execve(2)</code> replacement;</li><li>any other programming language module or function that exposes <code>system(3)</code> without safety measures;</li><li>to-be-continued;</li></ul><h2 id="wall-of-fame">Wall of fame</h2><ul><li>Go&#39;s <a id="link-28123de6" href="https://golang.org/pkg/os/exec/" target="_blank">os/exec</a> module -- that clearly states at the beginning:</li></ul><blockquote><p>Unlike the &#34;system&#34; library call from C and other languages, the os/exec package intentionally does not invoke the system shell and does not expand any glob patterns or handle other expansions, pipelines, or redirections typically done by shells. The package behaves more like C&#39;s &#34;exec&#34; family of functions.</p></blockquote><ul><li><p>Rust&#39;s <a id="link-d67a9d1e" href="https://doc.rust-lang.org/std/process/" target="_blank">std::process</a> module -- that like Go doesn&#39;t even provide the facility of calling <code>system(3)</code>;</p></li><li><p>Python&#39;s <a id="link-75ee482b" href="https://docs.python.org/3/library/subprocess.html" target="_blank">subprocess</a> module -- that provides safe defaults:</p></li></ul><blockquote><p><code>args</code> is required for all calls and should be a string, or a sequence of program arguments. Providing a sequence of arguments is generally preferred, as it allows the module to take care of any required escaping and quoting of arguments (e.g. to permit spaces in file names). If passing a single string, either <code>shell</code> must be <code>True</code> (see below) or else the string must simply name the program to be executed without specifying any arguments.</p></blockquote><ul><li>to-be-continued;</li></ul><hr/><h2 id="the-1000-bonus-points-bug">The 1000 bonus points bug</h2><h3 id="prologue-for-the-1000-bonus-points-bug">Prologue for the 1000 bonus points bug</h3><p>So I don&#39;t know how to say this... But I think I&#39;m going mad...
Although I&#39;m a careful <code>bash</code> &#34;programmer&#34; and I&#39;ve used <code>bash -c &#39;some-script&#39;</code> countless times, I would have never guessed the following situation...</p><p>Let&#39;s look more closely once more at the Linux <code><a id="link-168bad72" href="https://man7.org/linux/man-pages/man3/system.3.html" target="_blank">system(3)</a></code> man page:</p><blockquote><pre tabindex="0"><code>execl(&#34;/bin/sh&#34;, &#34;sh&#34;, &#34;-c&#34;, command, (char *) NULL);
</code></pre></blockquote><p>Then let&#39;s look more closely once more at the <code><a id="link-82b717c1" href="https://man7.org/linux/man-pages/man1/bash.1.html" target="_blank">bash(1)</a></code> man page:</p><blockquote><p><code>-c</code> -- If the <code>-c</code> option is present, then commands are read from
the first non-option argument command_string. [...]</p></blockquote><p>Now let&#39;s suppose one has a tool named <code>-x</code>.</p><p>Why is it called <code>-x</code>? Because it is not a forbidden file name by the file-system, and for that matter by any existing standards.
Moreover attackers are not &#34;nice people&#34; and if they can, most likely they will create such an executable...</p><p>Now let&#39;s suppose we want to call that tool from Python without any arguments:</p><pre tabindex="0"><code>import os
os.system(&#34;-x&#34;)
</code></pre><p>Also let&#39;s supposed we want to call that tool with two arguments:</p><pre tabindex="0"><code>import os
os.system(&#34;-x a b&#34;)
</code></pre><h3 id="surprise-for-the-1000-bonus-points-bug">Surprise for the 1000 bonus points bug</h3><p>Care to guess the outcome of those previous two snippets?</p><p>No, let&#39;s first <code>strace</code> that:</p><pre tabindex="0"><code>&gt; strace -e execve -f -- python2 -c &#39;import os; os.system(&#34;-x&#34;)&#39;
[...]
execve(&#34;/bin/sh&#34;, [&#34;sh&#34;, &#34;-c&#34;, &#34;-x&#34;], ...) = 0
[...]

&gt; strace -e execve -f -- python2 -c &#39;import os; os.system(&#34;-x a b&#34;)&#39;
[...]
execve(&#34;/bin/sh&#34;, [&#34;sh&#34;, &#34;-c&#34;, &#34;-x a b&#34;], ...) = 0
[...]
</code></pre><p>Now can you guess the outcome?</p><p>No, let&#39;s just try it out (I&#39;ve put both the Python and the plain <code>sh -c</code> invocations):</p><pre tabindex="0"><code>&gt; python2 -c &#39;import os; os.system(&#34;-x&#34;)&#39;
&gt; sh -c -x
sh: -c: option requires an argument
</code></pre><pre tabindex="0"><code>&gt; python2 -c &#39;import os; os.system(&#34;-x a b&#34;)&#39;
&gt; sh -c &#39;-x a b&#39;
sh: - : invalid option
[...]
</code></pre><p>(!!! Lots of censored swear words... !!!)</p><h3 id="reasons-for-the-1000-bonus-points-bug">Reasons for the 1000 bonus points bug</h3><p>What (more censored swear words) happened?</p><p>Well <code>-c</code> uses as argument not the <strong>immediately following argument</strong>, but instead the <strong>first non-option argument</strong>.
In this case there is no non-option argument because our <code>-x</code> or <code>-x a b</code> looks like an option argument...</p><p>What would be the proper solution?</p><p>Well the <code>system(3)</code> implementation should actually be:</p><pre tabindex="0"><code>execl(&#34;/bin/sh&#34;, &#34;sh&#34;, &#34;-c&#34;, &#34;--&#34;, command, (char *) NULL);
</code></pre><h3 id="epilogue-for-the-1000-bonus-points-bug">Epilogue for the 1000 bonus points bug</h3><p>What have I done about the problem?</p><p>As a good open-source citizen, I&#39;ve opened the following bug reports (one lead to another):</p><ul><li>at <code>glibc</code>, about the <code>system(3)</code> implementation -- <a id="link-2b13d1f5" href="https://sourceware.org/bugzilla/show_bug.cgi?id=27143" target="_blank">bug report #27143</a>;</li><li>at Linux man pages, about a warning to the <code>system(3)</code> manual -- <a id="link-4bf2327f" href="https://bugzilla.kernel.org/show_bug.cgi?id=211029" target="_blank">bug report #211029</a>;</li><li>at POSIX &#34;Austin Group&#34;, about &#34;fixing&#34; the specification -- <a id="link-6e69204a" href="https://www.austingroupbugs.net/view.php?id=1440" target="_blank">bug report #1440</a> -- because it seems that the <code>system(3p)</code> specification requires explicitly on how to call <code>sh(1)</code>;</li></ul><p>So in the end, let me quote one of the <code>glibc</code> developers (the emphasis is mine):</p><blockquote><p>Unfortunately, <strong>this bug is required by POSIX</strong>, which requires passing the string as an argument to the <code>-c</code> option of the shell.</p></blockquote><p>I&#39;m tired... I&#39;m going to sleep... I need a saner job...</p></div></div>
  </body>
</html>
