<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.answer.ai/posts/2025-10-01-solveit-full.html">Original</a>
    <h1>Solveit – A course and platform for solving problems with code</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-content">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main id="quarto-document-content">




<blockquote>
<p><strong>tldr from Jeremy:</strong> “How to Solve it With Code” is a course in iterative problem solving, and a platform (‘Solveit’) to make that easier. The course shows how to use AI in small doses to help learn as you build, but doesn’t rely on AI at all – you can totally avoid AI if you prefer. The approach we teach is based on decades of research and practice from Eric Ries and I, the founders of Answer.AI. It’s basically the opposite of “vibe coding”; it’s all about small steps, deep understanding, and deep reflection. We wrote the platform because we didn’t find anything else sufficient for doing work the “solveit way”, so we made something for ourselves, and then decided to make it available more widely. You can follow the approach without using our platform, although it won’t be as smooth an experience.</p>
<p>The platform combines elements of all these: ChatGPT; Jupyter Notebook + nbdev; Bits of vscode/cursor (we embed the same Monaco editor and add similar optional AI and non-AI autocompletion); a VPS (you get your own persistent full VPS running Linux with a URL you can share for public running applications); Claude Code (all the same tools are available); a persistent terminal. Then there’s some bits added that don’t exist elsewhere AFAIK: something like MCP, but way simpler, where any Python function can be instantly used as an AI tool; the ability to refer directly to any live Python variable in AI context (but optional, so it doesn’t eat up your context window); full metaprogramming of the environment (you can through code or AI tools modify the environment itself or the dialog); context editing (you can – and should – directly edit AI responses instead of tell the AI it’s wrong); collaborative notebook coding (multiple people can edit the dialog, run code, etc, and all see live updates).</p>
</blockquote>
<p>It’s a strange time to be a programmer. It’s easier than ever to get started, but also easier than ever to let AI steer you into a situation where you’re overwhelmed by code you don’t understand. We’ve got an antidote that we’ve been using ourselves with 1000 preview users for the last year. It’s changed our lives at Answer.AI, and <a href="https://solve.it.com/testimonials">hundreds of our users</a> say the same thing. Now we’re ready to share it with you. <a href="https://solve.it.com">Signups are open</a>, and will remain so until October 20th. Over five weeks, we’ll give you a taste of how our new approach and platform, “Solveit”, can be applied to everything from programming challenges, web development, and system administration to learning, writing, business, and more.</p>
<p>OK, let’s explain what on earth we’re talking about!…</p>
<p>At the end of last year, Jeremy Howard (co-founder of fast.ai, Answer.AI, Kaggle, Fastmail, creator of the first LLM…) and I ran a small trial course titled “How To Solve It With Code”. The response was so overwhelming that we had to close signups after just one day. 1000 keen beans joined us for a deep dive into our general approach to solving problems. The first few lessons were taught via the vehicle of the ‘Advent of Code’ programming challenges and run in a new, purpose-built tool called <strong>solveit</strong>. As the course progressed, we had lots of fun exploring web development, AI, business, writing and more. And the solveit tool became an extremely useful test-bed for ideas around AI-assisted coding, learning and exploration.</p>
<p>In the year since, we’ve continued to refine and expand both the process and the platform. We now basically live in the solveit platform. We do all our sysadmin work in it (Solveit itself is hosted on a new horizontally scalable multi-server platform we built and run entirely using Solveit!), host production apps in it (e.g all students in the course can use a Discord AI bot “Discord Buddy” that’s running inside a Solveit dialog!), develop most of our software in it, our legal team does contract drafting in it, we iterate on GUIs in it, and in fact we do the vast majority of our day to day work of all kinds in it.</p>
<div>
<figure>
<p><img src="https://www.answer.ai/posts/createinstance.png" width="400"/></p>
<figcaption>Real example of Jeremy and I using Solveit to setup a server farm for deploying Solveit</figcaption>
</figure>
</div>
<p>From October 20th for five weeks, Jeremy and I will show you how to use the solveit approach, and give you full access to the platform that powers it (and you’ll have the option to continute to access the lessons and platform afterwards too). Also <a href="https://en.wikipedia.org/wiki/Eric_Ries">Eric Ries</a> will join us for lessons about building startups that don’t just make money, but that stick to your vision for how you want to impact the world. You’ll be amongst the first people in the world to have the opportunity to read his new unreleased book.</p>
<p>But what IS “the solveit approach”? It isn’t some new AI thing, but actually is based on ideas that are at least 80 years old… To learn more, read on, or watch this video Jeremy and I recorded a few weeks ago.</p>
<p><iframe data-external="1" src="https://www.youtube.com/embed/DgPr3HVp0eg" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></p>
<section id="inspiration-from-polya">
<h2 data-anchor-id="inspiration-from-polya">Inspiration from Polya</h2>
<p>George Polya was a Hungarian mathematician who wrote the influential book “How to Solve It” in 1945. In it, he shares his philosophies on education (focus on active learning, heuristic thinking, and careful questioning to guide students towards discovering answers for themselves) and outlines a four-step problem-solving framework:</p>
<ol type="1">
<li>Understand the Problem: identify what you’re being asked to do; restate the problem</li>
<li>Devise a Plan: draw on similar problems; break down into manageable parts; consider working backward; simplify the problem</li>
<li>Carry Out the Plan: verify each step</li>
<li>Look Back and Reflect: consider alternatives; extract lessons learned</li>
</ol>
<p>He was focused on mathematics, but as Jeremy and I realized, these ideas translate far beyond maths! It turns out that it actually works great for coding, writing, reading, learning…</p>
<p>Of course, you can often just have AI code and write for you. But <em>should</em> you?</p>
<p>In most cases, we argue the answer is “no”.</p>
<p>There’s a myriad of problems waiting for you if you go down that path: - If you didn’t know the foundations of how to do it before, you don’t now either. You’ve learned nothing - If you keep working this way, you build up more and more code you don’t understand, creating technical and understanding debt that will eventually become crippling - You won’t be building up a foundation to solve harder tasks that neither humans nor AI can one-shot. So you’re limiting yourself to only solving problems that everyone else can trivially solve too. This is not a recipe for personal or organizational success!</p>
<p>On the other hand, if you build a discipline of always working to improve your understanding and expertise, you’ll discover that something delightful and amazing happens. Each time you tackle a task, you’ll find it’s a little easier than the last one. These improvements in understanding and capability will multiply, and you’ll find that your own skills develop even faster than AI improves. You’ll focus on using AI to help you dramatically increase your own productivity and abilities, instead of focusing on helping the AI improve its productivity and abilities!</p>
</section>
<section id="application-to-coding-iterative-exploratory-coding-in-notebook-like-environments.">
<h2 data-anchor-id="application-to-coding-iterative-exploratory-coding-in-notebook-like-environments.">Application to Coding: iterative, exploratory coding in notebook-like environments.</h2>
<p>Let’s consider a quick example of coding the solveit way (without even any AI yet). For 2024’s Advent of Code, Day 1’s solution involves comparing two lists, sorted by value (there’s a whole backstory involving elves, which you can <a href="https://adventofcode.com/2024/day/1">read if you like</a>). Let’s imagine we’ve considered the problem, and are now focused on a small sub-task: extracting the first (sorted) list. We start with the sample data provided:</p>
<div><div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span>=</span> <span>&#39;3   4</span><span>\n</span><span>4   3</span><span>\n</span><span>2   5</span><span>\n</span><span>1   3</span><span>\n</span><span>3   9</span><span>\n</span><span>3   3&#39;</span></span></code></pre></div></div>
<p>Our plan might be:</p>
<ul>
<li>Split into a list of lines</li>
<li>Grab the first number from each line</li>
<li>Sort</li>
</ul>
<p>After thinking through the plan, we begin working on individual steps. We aim to write no more than a few lines of code at a time, with each piece giving some useful output that you can use to <strong>verify</strong> that you’re on the right track:</p>
<div><div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>lines <span>=</span> x.splitlines()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>lines</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> [<span>&#39;3   4&#39;</span>, <span>&#39;4   3&#39;</span>, <span>&#39;2   5&#39;</span>, <span>&#39;1   3&#39;</span>, <span>&#39;3   9&#39;</span>, <span>&#39;3   3&#39;</span>]</span></code></pre></div></div>
<p>Now we build up a list comprehension to get the first elements. We might start with <code>[o for o in lines]</code> and then add bits one at a time, inspecting the output, building up to:</p>
<div><div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>l1 <span>=</span> [<span>int</span>(o.split()[<span>0</span>]) <span>for</span> o <span>in</span> lines]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>l1</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> [<span>3</span>, <span>4</span>, <span>2</span>, <span>1</span>, <span>3</span>, <span>3</span>]</span></code></pre></div></div>
<p>Now sorting:</p>
<div><div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>sorted</span>(l1)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>3</span>, <span>3</span>, <span>4</span>]</span></code></pre></div></div>
<p>Now that we’ve run all the pieces individually, and checked that the outputs are what we’d expect, we can stack them together into a function:</p>
<div><div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>def</span> get_list(x):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    lines <span>=</span> x.splitlines()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    l1 <span>=</span> [<span>int</span>(o.split()[<span>0</span>]) <span>for</span> o <span>in</span> lines]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>sorted</span>(l1)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>get_list(x)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> [<span>1</span>, <span>2</span>, <span>3</span>, <span>3</span>, <span>3</span>, <span>4</span>]</span></code></pre></div></div>
<p>At this point, you’d reflect on the solution, think back to the larger plan, perhaps ask yourself if there are better ways you could do it. You may be thinking that this is far too much work for <code>sorted(int(line.split()[0]) for line in x.splitlines())</code> – as your skill increases you can tailor the level of granularity, but the idea remains the same: working on small pieces of code, checking the outputs, only combining them into larger functions once you’ve tried them individually, and constantly reflecting back on the larger goal.</p>
<p>(We’ll come back to this shortly – but also consider for a moment how integrated AI can fit into the above process. Any time you don’t know how to do something, you can ask for help with just that one little step. Any time you don’t understand how something works, or why it doesn’t, you can have AI help you with that exact piece.)</p>
</section>
<section id="the-power-of-fast-feedback-loops">
<h2 data-anchor-id="the-power-of-fast-feedback-loops">The Power of Fast Feedback Loops</h2>
<p>The superpower that this kind of live, iterative coding gives you is near-instant feedback loops. Instead of building your giant app, waiting for the code to upload, clicking through to a website and then checking a debug console for errors – you’re inspecting the output of a chunk of code and seeing if it matches what you expected. It’s still possible to make mistakes and miss edge cases, but it is a LOT easier to catch most mistakes early when you code in this way.</p>
<p>This idea of setting things up so that you get feedback as soon as possible pops up again and again. Our cofounder Eric Ries talks about this in his book ‘The Lean Startup’, where getting feedback from customers is valuable for quick iteration on product or business ideas. Kaggle pros talk about the importance of fast evals – if you can test an idea in 5 minutes, you can try a lot more ideas than you could if each experiment requires 12 hours of model training.</p>
</section>
<section id="ai-shared-context-is-key">
<h2 data-anchor-id="ai-shared-context-is-key">AI: Shared Context is Key</h2>
<p>So far so good – sounds like we’re describing the style of exploratory/literate programming taught in the fast.ai course, and used with tools like NBDev. Aren’t we in a new era though? Where is the AI?!</p>
<p>Well, it turns out that by building code in this way, with planning, notes and tests mixed in with the source code, you’re also building the perfect context for an AI to help with the code too. Solveit can see everything you can see. We’ve discovered that this actually transforms “AI+Human” capabilities in ways that surprised even us.</p>
<p>It’s become a key foundation of all our work at Answer.AI now: the AI should be able to see everything exactly as the human does, and vice versa, and both human and AI must be able to use the same tools. This makes the AI a true iterative partner to bounce ideas off, try experiments, and learn together with.</p>
<p>You can also feed additional context to Solveit by referencing specific variables, or having it use its built-in search and URL-reading tools. And any python function becomes a tool that you can ask solveit to use, making it easy to give it everything it needs to fetch more context or take “agentic” actions to give better responses.</p>
<div>

<p>This idea of having an AI that can see everything that you can see, in a shared environment, is put to good use in our beloved <a href="https://www.answer.ai/posts/2024-12-05-introducing-shell-sage.html">shell sage</a> tool too!</p>
</div>
</section>
<section id="ai-dialog-engineering-keeps-context-useful">
<h2 data-anchor-id="ai-dialog-engineering-keeps-context-useful">AI: Dialog Engineering Keeps Context Useful</h2>
<p>One issue with current chat-based models is that once they go off the rails, it’s hard to get back on track. The model is now modelling a language sequence that involves the AI making mistakes – and more mistakes are likely to follow! If you’ve used language models much, then you’ve no doubt experienced this problem many times.</p>
<p>There is an interesting mathematical reason that this occurs. The vast majority of language model training is entirely about getting a neural network to predict the next word in a sentence – they are <em>auto-regressive</em>. Although they are later fine-tuned to do more than this, they are still at their heart really wanting to predict the next word of a sentence. In the documents used for training, there are plenty of examples of poor-quality reasoning and mistakes.Therefore, once an AI sees some mistakes in a chat, the most likely next tokens are going to be mistakes as well. That means that every time you are correcting the AI, you are making it more likely for the AI to give bad responses in the future!</p>
<p>Because solveit dialogs are fluid and editable, it’s much easier to go back and edit/remove mistakes, dead ends, and unrelated explorations. You can even edit past AI responses, to steer it into the kinds of behaviour you’d prefer. Combine this with the ability to easily hide messages from the AI or to pin messages to keep them in context even as the dialog grows beyond the context window and starts to be truncated, and you have a recipe for continued AI helpfulness as time goes on. We’ve been talking about this as “dialog engineering” for a <a href="https://youtu.be/qO-YqJm0Q1U?si=j7JLf0yk_hmOrWzY&amp;t=3689">long time</a> – and it really is key to having AI work sessions that <strong>improve</strong> as time goes on, rather than degrading.</p>
<p>Of course, this is all useful for humans too! The discipline of keeping things tidy, using (collapsible) headings to organise sections, writing notes on what you’re doing or aiming for, and even past questions+answers with the AI all make it a pleasure to pick back up old work.</p>
</section>
<section id="building-an-app-for-collaboration-not-replacement">
<h2 data-anchor-id="building-an-app-for-collaboration-not-replacement">Building an App for Collaboration not Replacement</h2>
<p>One thing is still (intentionally) hard in solveit though, and that is getting the AI to actually write all of your code in a hands-off way. We’ve made various choices to gently push towards the human remaining in control. Things like:</p>
<ul>
<li>Solveit defaults to code inputs</li>
<li>AI outputs code in fenced blocks, but these are not added to your code or run until you choose to do so. There are shortcuts to add them, but this extra step encourages you to read + refactor before mindlessly running</li>
<li>In ‘Learning’ mode especially, the AI will gently guide you to writing small steps rather than providing a big chunk of code, unless you really specifically ask it to do so.</li>
<li>In ‘Learning’ mode, the AI ‘ghost text’ auto-complete suggestions don’t show unless you trigger them with a keyboard shortcut.</li>
</ul>
<p>Even the choice to have the editor be fairly small and down at the bottom emphasizes that this is a REPL/dialog, optimised for building small, understandable pieces. It’s entirely possible to practice the solveit approach in other tools, but we’ve also found that a combination of these intentional choices and the extra affordances for dialog engineering rapidly feel indispensible.</p>
</section>
<section id="learning-trajectory">
<h2 data-anchor-id="learning-trajectory">Learning Trajectory</h2>
<p>This brings us back to a foundational piece of the solveit approach: a learning mindset. It’s great that we can ask AI to fill in the gaps of our knowledge, or to save some time with fiddly pieces like matplotlib plots or library-specific boilerplate. But when the AI suggests something you don’t know, it is important not to skip it and move on – otherwise that new piece will never be something you learn!</p>
<p>We try to build the discipline to stop and explore anytime something like this comes up. Fortunately, it’s really easy to do this – you can add new messages trying out whatever new thing the AI has shown you, asking how it works, getting demo code, and poking it until you’re satisfied. And then the evidence of that side-quest can be collapsed below a heading (for later ref) or deleted, leaving you back in the main flow but with a new piece of knowledge in your brain.</p>
<p>Like many programmers, I’ve had my share of existential worries given the rapid rise in AI’s coding ability. What if AI keeps getting better and better, to the point where there’s little point for the average person actually learning to master any of these skills? If you assume your coding skills stay static, and imagine the AI continuing to get better, you may feel kinda bleak. The thing is, skill doesn’t have to be static! And as both you and the AI you’re carefully using get better, you will learn faster and be able to accomplish more and more.</p>
</section>
<section id="mastery-requires-deliberate-practice">
<h2 data-anchor-id="mastery-requires-deliberate-practice">Mastery Requires Deliberate Practice</h2>
<p>This is all hard work. It’s like exercise, or practicing a musical instrument. And like any pursuit of mastery, I don’t know that it’s for everyone. But as we’ve seen from all of the students who invested their time into the first cohort, the effort is well worth it in the end. Just take a look at the <a href="https://solveit-project-showcase.pla.sh/">project showcase</a> featuring a few hundred (!) things our community has made.</p>
</section>
<section id="sign-up-for-solveit">
<h2 data-anchor-id="sign-up-for-solveit">Sign up for Solveit</h2>
<p>If you’re interested in joining us to learn how to use the Solveit approach yourself, head over to our site and sign up: <a href="https://solve.it.com">solve.it.com</a>, Signups are open until October 20th, but may close earlier if we fill up, so don’t wait too long!</p>


</section>

</main> <!-- /main -->

</div></div>
  </body>
</html>
