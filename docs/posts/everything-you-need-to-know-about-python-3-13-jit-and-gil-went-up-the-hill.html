<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://drew.silcock.dev/blog/everything-you-need-to-know-about-python-3-13/">Original</a>
    <h1>Everything you need to know about Python 3.13 ‚Äì JIT and GIL went up the hill</h1>
    
    <div id="readability-page-1" class="page"><article> <p>On October 2<sup>nd</sup>, 2024, the Python core developers and community will release <a href="https://docs.python.org/3.13/whatsnew/3.13.html">CPython v3.13.0</a> ‚Äì and it‚Äôs a doozy.</p>
<p>So what makes this release different, and why should you care about it?</p>
<p>In short, there are two big changes being made to how Python runs at a core level which have the potential to radically change the performance profile of Python code in the future.</p>
<p>Those changes are:</p>
<ul>
<li>A ‚Äúfree-threaded‚Äù version of CPython which allows you to disable the Global Interpreter Lock (GIL), and</li>
<li>Support for experimental Just-in-Time (JIT) compilation.</li>
</ul>
<p>So what are these new features and what impact will they have on you?</p>
<a href="#global-interpreter-lock-gil">#</a><h2 id="global-interpreter-lock-gil">Global Interpreter Lock (GIL)</h2>
<a href="#what-is-the-gil">#</a><h3 id="what-is-the-gil">What is the GIL?</h3>
<p>From the inception of the Python programming language by Guido Van Rossum in a science park in East Amsterdam in the late ‚Äô80s, it was designed and implemented as a single-threaded interpreted language. What exactly does this mean?</p>
<p>You‚Äôll commonly hear that there are 2 types of programming languages ‚Äì interpreted and compiled. So which is Python? The answer is: <strong>yes</strong>.</p>
<p>You will very rarely find a programming language which is purely interpreted from source by an interpreter. For interpreted languages, the human-readable source code is almost always compiled into some kind of intermediary form, called bytecode. The interpreter then looks at the bytecode and executes the instructions one-by-one.</p>
<p>The ‚Äúinterpreter‚Äù here is commonly called a ‚Äúvirtual machine‚Äù, especially in other languages like Java which does the same thing as Python re. <a href="https://en.wikipedia.org/wiki/Java_bytecode">Java bytecode</a> and <a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">Java VMs</a>. In Java and <a href="https://kotlinlang.org/">friends</a>, it‚Äôs much more common to ship the compiled bytecode itself, whereas Python applications are usually distributed as source code (although, having said that, packages are often deployed as <a href="https://packaging.python.org/en/latest/discussions/package-formats/#what-is-a-wheel">wheels</a> as well as <a href="https://packaging.python.org/en/latest/discussions/package-formats/#what-is-a-source-distribution">sdist</a> nowadays).</p>
<p>Virtual machines in this meaning of the word come up in all kinds of unexpected places, like in the PostScript format (PDF files are essentially compiled PostScript) and in font rendering<sup><a href="#user-content-fn-font-rendering" id="user-content-fnref-font-rendering" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>.</p>
<p>If you‚Äôve ever noticed a bunch of <code>*.pyc</code> files in your Python projects, this is the compiled bytecode for your application. You can decompile and explore <code>pyc</code> files in exactly the same way you can find Java class files.</p>
<p><span data-astro-cid-mrmim4ef="">üí°</span> <span data-astro-cid-mrmim4ef=""> <p><strong>Python vs CPython</strong></p><p>I can already hear a chorus of pedantic Pythonistas shouting ‚ÄúPython isn‚Äôt the same as CPython!‚Äù, and they‚Äôre right. And this is an important distinction to make.</p><p>Python is the programming language, which is essentially a specification saying what the language should do.</p><p>CPython is the <em>reference implementation</em> of this language specification, and what we‚Äôre talking about here is mostly about the CPython implementation. There are other Python implementations, like <a href="https://pypy.org/">PyPy</a> which has always used JIT compilation, <a href="https://www.jython.org/">Jython</a> which runs on the JVM and <a href="https://ironpython.net/">IronPython</a> which runs on the .NET CLR.</p><p>Having said that, pretty much everyone just uses CPython and so I think it‚Äôs reasonable to talk about ‚ÄúPython‚Äù when we‚Äôre really talking about CPython. If you disagree, go ahead and get in the comments or write me a strongly worded email with an aggressive font (maybe <a href="https://www.google.com/search?q=impact+font">Impact</a>; I‚Äôve always thought <a href="https://www.google.com/search?q=comic+sans">Comic Sans</a> has a subtly threatening aura).</p> </span> </p> 
<p>So when we run Python, the <code>python</code> executable will generate the bytecode which is a stream of instructions, then the interpreter will read and execute the instructions one-by-one.</p>
<p>If you try to spin up multiple threads, what happens then? Well, the threads all share the same memory (apart from their local variables) and so they can all access and update the same objects. Each thread will be executing its own bytecode using its own stack and instruction pointer.</p>
<p>What happens if multiple threads try to access / edit the same object at the same time? Imagine one thread is trying to add to a dict while another is trying to read from it. There are two options here:</p>
<ul>
<li>Make the implementation of dict (and all the other objects) thread-safe, which takes a lot of effort and will make it slower for a single-threaded application, or</li>
<li>Create a global mutual exclusion lock (a.k.a. mutex) which allows only one thread to be executing bytecode at any one time.</li>
</ul>
<p>This latter option is the GIL. The former option is what the Python developers are calling ‚Äúfree-threading‚Äù mode.</p>
<p>It‚Äôs also worth mentioning that the GIL makes garbage collection much simpler and faster. We don‚Äôt have time to go into the depths of garbage collection here as it‚Äôs a whole big topic in itself, but a simplified version is that Python keeps a count of how many references there are to a particular object, and when that count reaches zero, Python knows that it can safely delete that object. If there are multiple threads concurrently creating and dropping references to different objects, this can lead to race conditions and memory corruptions, so any free-threaded version needs to use atomically counted references for all objects.</p>
<p>The GIL also makes it much easier to develop C extensions for Python (e.g. using the confusingly named <a href="https://cython.org/">Cython</a>) as you can make assumptions about thread safety that make your life much easier, check out the <a href="https://py-free-threading.github.io/porting">py-free-threading guide for porting C extensions</a> for more details on this.</p>
<a href="#why-does-python-have-a-gil">#</a><h3 id="why-does-python-have-a-gil">Why does Python have a GIL?</h3>
<p>Despite having a surge in popularity over the last few years, it‚Äôs not a particularly new language ‚Äì it was conceived in the late ‚Äô80s, with the first release on 20<sup>th</sup> February 1991 (making it slightly older than me). Back then, computers looked very different. Most programs were single-threaded and the performance of individual cores was increasing exponentially (see good old <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore‚Äôs Law</a>). In this environment, it didn‚Äôt make much sense to compromise single-threaded performance for thread safety when most programs would not be utilising multiple cores.</p>
<p>Also, implementing thread safety obviously takes a lot of work.</p>
<p>This isn‚Äôt to say that you can‚Äôt utilise multiple cores in Python. It just means that instead of using threading, you have to utilise multiple processes (i.e. <a href="https://docs.python.org/3/library/multiprocessing.html"><code>multiprocessing</code></a> module).</p>
<p>Multi-processing differs from multi-threading because each process is its own Python interpreter with its own separate memory space. This means that multiple processes can‚Äôt access the same objects in memory but instead you have to use special constructs and communication to share data (see <a href="https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes">‚ÄúSharing state between processes‚Äù</a> and <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue"><code>multiprocessing.Queue</code></a>).</p>
<p>It‚Äôs worth mentioning that there is a bit more overhead in using multiple processes as opposed to multiple threads, in addition to it being more difficult to share data.</p>
<p>Using multiple threads is sometimes not as bad as people commonly assume, however. If Python is doing I/O like reading from files or making network calls, it will release the GIL so that other threads can run. This means that if you‚Äôre doing lots of I/O, multi-threading will often be as fast as multi-processing. It‚Äôs when you are CPU-bound that the GIL becomes a big issue.</p>
<a href="#ok-so-why-are-they-removing-the-gil-now">#</a><h3 id="ok-so-why-are-they-removing-the-gil-now">Ok, so why are they removing the GIL now?</h3>
<p>The removal of the GIL has been something that certain people have been pushing for for several years now, but the main reason it‚Äôs not been done is not the amount of work it takes but instead is the corresponding performance degradation that would come with it for single-threaded programs.</p>
<p>Nowadays, the incremental improvements in single-core performance of computers doesn‚Äôt change too much from year to year (although big advances are being made with custom processor architectures, e.g. Apple Silicon chips) while the number of cores in a computer continues to increase. This means it‚Äôs much more common for programs to utilise multiple cores and hence the inability of Python to properly utilise multi-threading is becoming more and more of an issue.</p>
<p>Fast forward to 2021 and <a href="https://github.com/colesbury">Sam Gross</a> implemented a <a href="https://lwn.net/ml/python-dev/CAGr09bSrMNyVNLTvFq-h6t38kTxqTXfgxJYApmbEWnT71L74-g@mail.gmail.com/">no-GIL Proof of Concept implementation</a> that spurred the <a href="https://github.com/python/steering-council">Python Steering Council</a> to propose a vote on <a href="https://peps.python.org/pep-0703/">PEP 703 ‚Äì Making the Global Interpreter Lock Optional in CPython</a>. The outcome of the vote was positive, resulting in the Steering Council <a href="https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474">accepting the proposal</a> as part of a <a href="https://discuss.python.org/t/pep-703-making-the-global-interpreter-lock-optional-in-cpython-acceptance/37075">gradual rollout</a> in three phases:</p>
<ul>
<li><strong>Phase 1</strong>: Free-threading mode is an experimental build-time option that is not the default.</li>
<li><strong>Phase 2</strong>: Free-threading mode is officially supported but still not the default.</li>
<li><strong>Phase 3</strong>: Free-threading mode is the default.</li>
</ul>
<p>From reading the discussions, there‚Äôs a strong desire to not ‚Äúsplit‚Äù Python into two separate implementations ‚Äì one with the GIL and one without ‚Äì with the intention being that eventually after free-threading mode has been the default for a while, the GIL will be removed entirely and the free-threading mode will be the only mode.</p>
<p>While all this GIL vs. no-GIL stuff has been going on the last few years, there has been a parallel effort called the ‚ÄúFaster CPython‚Äù project. This has been <a href="https://lwn.net/ml/python-dev/CAGr09bSrMNyVNLTvFq-h6t38kTxqTXfgxJYApmbEWnT71L74-g@mail.gmail.com/">funded by Microsoft</a> and led by <a href="https://us.pycon.org/2023/speaker/profile/81/index.html">Mark Shannon</a> and <a href="https://gvanrossum.github.io/">Guido van Rossum</a> himself, both of whom work at Microsoft.</p>
<p>The effort this team have been making has produced some very impressive results, particularly for <a href="https://docs.python.org/3/whatsnew/3.11.html#faster-cpython">3.11</a> which boasted significant performance boosts over 3.10.</p>
<p>With the combination of community / council support, increasing ubiquity of multi-core processors and the Faster CPython effort, the time was ripe for the beginning of Phase 1 of the GIL adoption plan.</p>
<a href="#what-does-the-performance-look-like">#</a><h3 id="what-does-the-performance-look-like">What does the performance look like?</h3>
<p>I‚Äôve run a few benchmarks on both my machine ‚Äì MacBook Pro with Apple M3 Pro (CPU has 6 performance cores and 6 efficiency cores) ‚Äì and on a quiet EC2 instance ‚Äì t3.2xlarge (8 vCPUs).</p>
<p>The graphs below show a comparison of the runtime performance of a CPU-intensive task (converging Mandelbrot set) between Python 3.12 and Python 3.13 with and without the GIL.</p>
<img src="https://drew.silcock.dev/_astro/bench-comparison-m3-dark.B6MCcmGa_96BpF.webp" alt="Performance comparison for Apple M3 Pro" width="2400" height="800" loading="lazy" decoding="async"/>
<img src="https://drew.silcock.dev/_astro/bench-comparison-m3-light.CBPn1teC_Z1H6EDr.webp" alt="Performance comparison for Apple M3 Pro" width="2400" height="800" loading="lazy" decoding="async"/>
<img src="https://drew.silcock.dev/_astro/bench-comparison-ec2-dark.DsCVDY3z_2hOeU1.webp" alt="Performance comparison for t3.2xlarge EC2 instance" width="2400" height="800" loading="lazy" decoding="async"/>
<img src="https://drew.silcock.dev/_astro/bench-comparison-ec2-light.ojc_JmYg_Z1h2QNH.webp" alt="Performance comparison for t3.2xlarge EC2 instance" width="2400" height="800" loading="lazy" decoding="async"/>
<p>(These graphs aren‚Äôt the most readable, I know ‚Äì I‚Äôll improve on them when I get some time.)</p>
<p>To explain what these runtimes mean:</p>
<ul>
<li><code>3.12.6</code> ‚Äì Python version 3.12.6.</li>
<li><code>3.13.0rc2</code> ‚Äì the default build of Python 3.13.0 release candidate 2 (the latest version at the time of writing).</li>
<li><code>3.13.0rc2t</code> ‚Äì the Python 3.13.0 release candidate 2 with experimental free-threading enabled at build-time, run without additional arguments (i.e. GIL disabled).</li>
<li><code>3.13.0rc2t-g1</code> ‚Äì the Python 3.13.0 release candidate 2 with experimental free-threading enabled at build-time, run with the <code>-X gil=1</code> argument, thereby ‚Äúre-enabling‚Äù the GIL at runtime.</li>
</ul>
<p>A few caveats to this:</p>
<ul>
<li>I didn‚Äôt use a proper well established benchmark, just a simple iterative algorithm. You can find the code for running the benchmarks and graphing the results at: <a href="https://github.com/drewsilcock/gil-perf">github.com/drewsilcock/gil-perf</a>. Try it out for yourself!</li>
<li>I used <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> to run the benchmarks, which is a really good tool, but these aren‚Äôt proper scientific benchmarks running on dedicated hardware. My MacBook is running a whole bunch of things and even the EC2 instance will have stuff going on in the background, although not nearly as much.</li>
<li>These benchmarks are really interesting and fun to talk about, but do bear in mind that in the real world, most libraries that do CPU-intensive work use <a href="https://cython.readthedocs.io/en/latest/src/userguide/nogil.html">Cython</a> or similar¬†‚Äì very few people use raw Python for very compute-intensive tasks. Cython has the ability to release the GIL temporarily during execution and has had for a while. These benchmarks aren‚Äôt representative of this use case.</li>
</ul>
<p>With that in mind, we can already make a few observations:</p>
<ul>
<li>The performance degradation when Python is built with free-threading support is significant ‚Äì around 20%.</li>
<li>It doesn‚Äôt matter whether you re-enable the GIL via the <code>-X gil=1</code> argument, the performance degradation is the same.</li>
<li>Multi-threading shows a significant boost with GIL disabled, as expected.</li>
<li>Multi-threading with GIL enabled is slower than single-threading, as expected.</li>
<li>Multi-threading with GIL disabled is about the same as multi-processing. Then again, this is a pretty noddy example where you don‚Äôt need to do much real work.</li>
<li>Apple Silicon chips really are quite impressive. Single-threaded performance on my M3 Pro is about 4x faster than single-threaded performance on the t3.2xlarge. I mean, I know t3 are designed to be cheap and burstable, but even so! It‚Äôs even more impressive if you consider the insane battery life you get out of these things<sup><a href="#user-content-fn-apple-sponsorship" id="user-content-fnref-apple-sponsorship" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>.</li>
</ul>
<a href="#how-do-i-try-out-free-threaded-python">#</a><h3 id="how-do-i-try-out-free-threaded-python">How do I try out free-threaded Python?</h3>
<p>At the time of writing, Python 3.13 is still in release candidate and hasn‚Äôt been officially released. Having said that, today is Saturday 28<sup>th</sup> and the release is scheduled for 2<sup>nd</sup> October which is Wednesday, so its not far away.</p>
<p>If you want to try it out ahead of time, you‚Äôre out of luck with <a href="https://rye.astral.sh/">rye</a> which only seems to ship deployed versions and <a href="https://docs.astral.sh/uv/">uv</a> which includes the 3.13.0rc2 build but not the 3.13.0rc2t build. Luckily, <a href="https://github.com/pyenv/pyenv">pyenv</a> supports both 3.13.0rc2 and 3.13.0rc2t. To try it out for yourself:</p>
<div><figure><pre data-language="shell"><code><div><div><p>1</p></div><p><span># If you&#39;re reading this from the future, rye may have it:</span></p></div><div><div><p>2</p></div></div><div><div><p>3</p></div></div><div><div><p>4</p></div><p><span># uv may also have it</span></p></div><div><div><p>5</p></div><p><span>$</span><span> </span><span>uv</span><span> </span><span>python</span><span> </span><span>list</span><span> </span><span>|</span><span> </span><span>rg</span><span> </span><span>-F</span><span> </span><span>cpython-3.13</span></p></div><div><div><p>6</p></div></div><div><div><p>7</p></div><p><span># pyenv should have it, though.</span></p></div><div><div><p>8</p></div><p><span>$</span><span> </span><span>pyenv</span><span> </span><span>install</span><span> </span><span>--list</span><span> </span><span>|</span><span> </span><span>rg</span><span> </span><span>&#39;^\s+3\.13&#39;</span></p></div><div><div><p>9</p></div></div><div><div><p>10</p></div><p><span># Take 3.13.0rc2t for a spin</span></p></div><div><div><p>11</p></div><p><span>$</span><span> </span><span>pyenv</span><span> </span><span>install</span><span> </span><span>3.13.0rc2t</span></p></div><div><div><p>12</p></div><p><span>$</span><span> </span><span>pyenv</span><span> </span><span>local</span><span> </span><span>3.13.0rc2t</span></p></div><div><div><p>13</p></div></div><div><div><p>14</p></div><p><span>$</span><span> </span><span>python</span><span> </span><span>-VV</span></p></div><div><div><p>15</p></div><p><span>Python</span><span> </span><span>3.13.0rc2</span><span> </span><span>experimental</span><span> </span><span>free-threading</span><span> </span><span>build</span><span> (main, </span><span>Sep</span><span> </span><span>18</span><span> </span><span>2024,</span><span> </span><span>16:41:38</span><span>) [Clang </span><span>15.0.0</span><span> (clang</span><span>-</span><span>1500</span><span>.</span><span>3</span><span>.</span><span>9</span><span>.</span><span>4</span><span>)]</span></p></div><div><div><p>16</p></div></div><div><div><p>17</p></div><p><span>$</span><span> </span><span>python</span><span> </span><span>-c</span><span> </span><span>&#39;import sys;print(&#34;GIL enabled üîí&#34; if sys._is_gil_enabled() else &#34;GIL disabled üòé&#34;)&#39;</span></p></div><div><div><p>18</p></div><p><span>GIL</span><span> </span><span>disabled</span><span> </span><span>üòé</span></p></div><div><div><p>19</p></div></div><div><div><p>20</p></div><p><span># GIL can be re-enabled at runtime</span></p></div><div><div><p>21</p></div><p><span>$</span><span> </span><span>python</span><span> </span><span>-X</span><span> </span><span>gil=</span><span>1</span><span> </span><span>-c</span><span> </span><span>&#39;import sys;print(&#34;GIL enabled üîí&#34; if sys._is_gil_enabled() else &#34;GIL disabled üòé&#34;)&#39;</span></p></div><div><div><p>22</p></div><p><span>GIL</span><span> </span><span>enabled</span><span> </span><span>üîí</span></p></div></code></pre></figure></div>
<p>Just a heads up if you are trying free-threading Python ‚Äì if you don‚Äôt specify either <code>-X gil=0</code> or <code>-X gil=1</code>, the GIL will be disabled by default but simply importing a module which does not support running without the GIL will cause the GIL to be re-enabled. I found this when running the benchmarks because I imported matplotlib, which results in the GIL being re-enabled and all my benchmarks coming out rubbish. If you manually specify <code>-X gil=0</code>, the GIL will not be sneakily re-enabled, even if a package does not mark itself as supporting GIL-free running.</p>
<a href="#jit-just-in-time-compiler">#</a><h2 id="jit-just-in-time-compiler">JIT (Just-in-Time) Compiler</h2>
<p>It‚Äôs not just the GIL that‚Äôs a big change in this Python release ‚Äì there‚Äôs also the addition into the Python interpreter of an experimental JIT compiler.</p>
<a href="#what-is-a-jit">#</a><h3 id="what-is-a-jit">What is a JIT?</h3>
<p>JIT stands for Just in Time and is a compilation technique where machine code is produced just in time to execute it, as opposed to ahead of time (AOT) like your traditional C compiler like gcc or clang.</p>
<p>We already talked about bytecode and the interpreter earlier. The important thing is that, before Python 3.13, the interpreter would look at each bytecode instruction one at a time and turn each one into native machine code before executing it. With the introduction of the JIT compiler, it is now possible for bytecode to be ‚Äúinterpreted‚Äù into machine code once and updated as necessary, instead of being re-interpreted every time.</p>
<p>It‚Äôs important to point out that this kind of JIT that has been <a href="https://github.com/python/cpython/pull/113465">introduced in 3.13</a> is what‚Äôs called <a href="https://en.wikipedia.org/wiki/Copy-and-patch">‚Äúcopy-and-patch‚Äù JIT</a>. This is a very recent idea introduced in 2021 in an article called <a href="https://dl.acm.org/doi/10.1145/3485513">‚ÄúCopy-and-patch compilation: a fast compilation algorithm for high-level languages and bytecode</a>. The core idea behind copy-and-patch as opposed to more advanced JIT compilers is that there is a simple list of pre-generated templates ‚Äì the JIT compiler will pattern match for bytecode that matches one of the pre-defined templates and if it does, it will patch in pre-generated native machine code.</p>
<p>Traditional JIT compilers will be massively more advanced that this and also massively more memory intensive, especially if you compare it to heavily JIT-compiled languages like Java or C#. (That‚Äôs part of the reason Java programs take up so much memory.)</p>
<p>What‚Äôs great about JIT compilers is that they can adapt to your code as its running. For instance, as your code runs, the JIT compiler will keep track of how ‚Äúhot‚Äù each piece of code is. JIT compilers can perform incremental optimisations as the code get hotter and hotter and even use information about how the program is actually running to inform the optimisations it is making (like how Profile-Guided Optimisation does for AOT compilers). This means that JIT doesn‚Äôt waste time optimising some code which is only running once but the really hot sections of code can have heavy run-time informed optimisations done on them.</p>
<p>Now, the JIT compiler in Python 3.13 is relatively simple and won‚Äôt be doing any crazy at this stage, but it‚Äôs a really exciting development for the future of Python performance.</p>
<a href="#what-difference-will-the-jit-make-to-me">#</a><h3 id="what-difference-will-the-jit-make-to-me">What difference will the JIT make to me?</h3>
<p>In the short term, the introduction of the JIT is unlikely to make any difference to how you write or run your Python code. But it‚Äôs an exciting internal change to the way that the Python interpreter operates that could lead to much more significant performance improvements being made to Python performance in the future.</p>
<p>In particular, it opens up the way for incremental performance improvements to be made over time which could gradually bump up Python‚Äôs performance to be more competitive with other languages. Having said that, this is still early stages and the copy-and-patch JIT technique is both new and lightweight, so there‚Äôs more big changes needed before we start seeing significant benefits from the JIT compiler.</p>
<a href="#how-do-i-try-out-the-jit">#</a><h3 id="how-do-i-try-out-the-jit">How do I try out the JIT?</h3>
<p>The JIT compilers is ‚Äúexperimental‚Äù in 3.13 and isn‚Äôt built with support out of the box (at least not when I downloaded 3.13.0rc2 using pyenv). You can enable experimental JIT support by doing:</p>
<div><figure><pre data-language="shell"><code><div><div><p>1</p></div><p><span>$</span><span> </span><span>PYTHON_CONFIGURE_OPTS=&#34;--enable-experimental-jit&#34;</span><span> </span><span>pyenv</span><span> </span><span>install</span><span> </span><span>3.13-dev</span></p></div><div><div><p>2</p></div><p><span>python-build:</span><span> </span><span>use</span><span> </span><span>openssl@3</span><span> </span><span>from</span><span> </span><span>homebrew</span></p></div><div><div><p>3</p></div><p><span>python-build:</span><span> </span><span>use</span><span> </span><span>readline</span><span> </span><span>from</span><span> </span><span>homebrew</span></p></div><div><div><p>4</p></div><p><span>Cloning</span><span> </span><span>https://github.com/python/cpython...</span></p></div><div><div><p>5</p></div><p><span>Installing</span><span> </span><span>Python-3.13-dev...</span></p></div><div><div><p>6</p></div><p><span>python-build:</span><span> </span><span>use</span><span> </span><span>tcl-tk</span><span> </span><span>from</span><span> </span><span>homebrew</span></p></div><div><div><p>7</p></div><p><span>python-build:</span><span> </span><span>use</span><span> </span><span>readline</span><span> </span><span>from</span><span> </span><span>homebrew</span></p></div><div><div><p>8</p></div><p><span>python-build:</span><span> </span><span>use</span><span> </span><span>ncurses</span><span> </span><span>from</span><span> </span><span>homebrew</span></p></div><div><div><p>9</p></div><p><span>python-build:</span><span> </span><span>use</span><span> </span><span>zlib</span><span> </span><span>from</span><span> </span><span>xcode</span><span> </span><span>sdk</span></p></div><div><div><p>10</p></div><p><span>Installed</span><span> </span><span>Python-3.13-dev</span><span> </span><span>to</span><span> </span><span>/Users/drew.silcock/.pyenv/versions/3.13-dev</span></p></div><div><div><p>11</p></div><p><span>$</span><span> </span><span>python</span><span> </span><span>-c</span><span> </span><span>&#39;import sysconfig;print(&#34;JIT enabled üöÄ&#34; if &#34;-D_Py_JIT&#34; in sysconfig.get_config_var(&#34;PY_CORE_CFLAGS&#34;) else &#34;JIT disabled üòí&#34;)&#39;</span></p></div><div><div><p>12</p></div><p><span>JIT</span><span> </span><span>enabled</span><span> </span><span>üöÄ</span></p></div></code></pre></figure></div>
<p>There are additional configure options which you can read about <a href="https://discuss.python.org/t/pep-744-jit-compilation/50756">on the PEP 744 discussion page</a> (like enabling the JIT but requiring it be enabled by running <code>-X jit=1</code> at runtime, etc.).</p>
<p>The test here only checks for whether the JIT was enabled at built-time, not whether it‚Äôs currently running (e.g. has been disabled at runtime). It is possible to check at runtime whether the JIT is enabled, but it‚Äôs a bit more tricky. Here‚Äôs a script you can use to figure it out (taken from the <a href="https://discuss.python.org/t/pep-744-jit-compilation/50756/53">PEP 744 discussion page</a>)[^jit-deps]:</p>
<div><figure><pre data-language="python"><code><div><div><p>1</p></div><p><span>import</span><span> _opcode</span></p></div><div><div><p>2</p></div><p><span>import</span><span> types</span></p></div><div><div><p>3</p></div></div><div><div><p>4</p></div></div><div><div><p>5</p></div><p><span>def</span><span> </span><span>is_jitted</span><span>(f: types.FunctionType) -&gt; </span><span>bool</span><span>:</span></p></div><div><div><p>6</p></div><p><span>    </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(</span><span>0</span><span>, </span><span>len</span><span>(f.</span><span>__code__</span><span>.co_code), </span><span>2</span><span>):</span></p></div><div><div><p>7</p></div><p><span>        </span><span>try</span><span>:</span></p></div><div><div><p>8</p></div><p><span><span>            </span></span><span>_opcode.get_executor(f.</span><span>__code__</span><span>, i)</span></p></div><div><div><p>9</p></div><p><span>        </span><span>except</span><span> </span><span>RuntimeError</span><span>:</span></p></div><div><div><p>10</p></div><p><span>            </span><span># This isn&#39;t a JIT build:</span></p></div><div><div><p>11</p></div><p><span>            </span><span>return</span><span> </span><span>False</span></p></div><div><div><p>12</p></div><p><span>        </span><span>except</span><span> </span><span>ValueError</span><span>:</span></p></div><div><div><p>13</p></div><p><span>            </span><span># No executor found:</span></p></div><div><div><p>14</p></div><p><span>            </span><span>continue</span></p></div><div><div><p>15</p></div><p><span>        </span><span>return</span><span> </span><span>True</span></p></div><div><div><p>16</p></div><p><span>    </span><span>return</span><span> </span><span>False</span></p></div><div><div><p>17</p></div></div><div><div><p>18</p></div></div><div><div><p>19</p></div><p><span>def</span><span> </span><span>fibonacci</span><span>(n):</span></p></div><div><div><p>20</p></div><p><span><span>    </span></span><span>a, b </span><span>=</span><span> </span><span>0</span><span>, </span><span>1</span></p></div><div><div><p>21</p></div><p><span>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>range</span><span>(n):</span></p></div><div><div><p>22</p></div><p><span><span>        </span></span><span>a, b </span><span>=</span><span> b, a </span><span>+</span><span> b</span></p></div><div><div><p>23</p></div><p><span>    </span><span>return</span><span> a</span></p></div><div><div><p>24</p></div></div><div><div><p>25</p></div></div><div><div><p>26</p></div><p><span>def</span><span> </span><span>main</span><span>():</span></p></div><div><div><p>27</p></div><p><span><span>    </span></span><span>fibonacci(</span><span>100</span><span>)</span></p></div><div><div><p>28</p></div><p><span>    </span><span>if</span><span> is_jitted(fibonacci):</span></p></div><div><div><p>29</p></div><p><span>        </span><span>print</span><span>(</span><span>&#34;JIT enabled üöÄ&#34;</span><span>)</span></p></div><div><div><p>30</p></div><p><span>    </span><span>else</span><span>:</span></p></div><div><div><p>31</p></div><p><span>        </span><span>print</span><span>(</span><span>&#34;Doesn&#39;t look like the JIT is enabled ü•±&#34;</span><span>)</span></p></div><div><div><p>32</p></div></div><div><div><p>33</p></div></div><div><div><p>34</p></div></div><div><div><p>35</p></div><p><span>if</span><span> </span><span>__name__</span><span> </span><span>==</span><span> </span><span>&#34;__main__&#34;</span><span>:</span></p></div><div><div><p>36</p></div><p><span><span>    </span></span><span>main()</span></p></div></code></pre></figure></div>
<p>The PEP 744 discussion has mention of both <code>PYTHON_JIT=0/1</code> and <code>-X jit=0/1</code> ‚Äì I did not find that the <code>-X</code> option did anything at all, but the environment variable seems to do the trick.</p>
<div><figure><pre data-language="shell"><code><div><div><p>1</p></div><p><span>$</span><span> </span><span>python</span><span> </span><span>is-jit.py</span></p></div><div><div><p>2</p></div><p><span>JIT</span><span> </span><span>enabled</span><span> </span><span>üöÄ</span></p></div><div><div><p>3</p></div><p><span>$</span><span> </span><span>PYTHON_JIT=</span><span>0</span><span> </span><span>python</span><span> </span><span>is-jit.py</span></p></div><div><div><p>4</p></div><p><span>Doesn</span><span>&#39;t look like the JIT is enabled ü•±</span></p></div></code></pre></figure></div>
<p>[^jit-deps] I also found a few people online talking about how you could use <code>sysconfig.get_config_var(&#34;JIT_DEPS&#34;)</code> but I did not found that this worked at all for me.</p>
<a href="#conclusion">#</a><h2 id="conclusion">Conclusion</h2>
<p>Python 3.13 is a big release in introducing some exciting new concepts and features to the runtime. It‚Äôs unlikely to make any immediate different to how you write and run your Python, but it‚Äôs likely that over the next few months and years as both free-threading and JIT become more mature and well established, they‚Äôll begin to have more and more of an impact on the performance profile of Python code, particularly for CPU-bound tasks.</p>
<a href="#further-reading">#</a><h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://peps.python.org/pep-0703/">PEP 703 ‚Äì Making the Global Interpreter Lock Optional in CPython</a></li>
<li><a href="https://py-free-threading.github.io/">py-free-threading</a></li>
<li><a href="https://tonybaloney.github.io/posts/python-gets-a-jit.html">Python 3.13 gets a JIT ‚Äì Anthony Shaw</a></li>
<li><a href="https://peps.python.org/pep-0744/">PEP 744 ‚Äì JIT Compilation</a></li>
<li><a href="https://discuss.python.org/t/pep-744-jit-compilation/50756">Discuss ‚Äì PEP 744: JIT Compilation</a></li>
</ul>
   </article></div>
  </body>
</html>
