<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jennyjams.net/blog/cpp-mixin/">Original</a>
    <h1>A C&#43;&#43; Mixin System</h1>
    
    <div id="readability-page-1" class="page">
    
    
    
<p>I&#39;ve had this idea in the back of my head for a while of pervasively using mixins to add code and logic for more high level concepts, although this gets somewhat close to Rust style traits (and C++ concepts). This has existed in the back of my head for a long time as a way to model a framework or standard library implementaiton while also providing it for user types.</p>
<p>I think the big asterick to all of this design is that my ideal framework would not look like standard C++ but like a slightly weirder Rust stdlib:</p>
<ul>
<li>Errors are signified through a <code>Result&lt;&gt;</code> or <code>Option&lt;&gt;</code> like class, and both can handle reference like payload -- instead of exceptions, you can abort threads or the entire program.</li>
<li>All constructors that aren&#39;t default, copy or move are &#39;data constructors&#39; (each parameter is simply initializing the equivalent field)</li>
<li>Non-trivial object creation is all done via a <code>create()</code> factory funtion (or <code>make()</code>, or w.e.) that returns an <code>Result</code> value.</li>
<li>All non-trivial objects that can be moved or copied have a default constructor that initializes objects into a <a href="https://en.wikipedia.org/wiki/Null_object_pattern">NOP</a> like state -- C++ sort of implicitly requires them for a lot of stuff, so I think owning this and making it more of a first class concept would be nice.</li>
<li>Any non-trivial interaction with an object in a NOP state will trigger an assertion error.</li>
<li>Most methods that can fail but you&#39;d like to go for happy path (like <code>clone()</code> or <code>serialize()</code> below) will abort if an error occurs, and they will have associated <code>cloneTry()</code> or <code>serializeTry()</code> methods that return an <code>Result</code> -- implicitly i&#39;m imaging most inner plubming methods return these.</li>
<li>Aside from function paramters, pointers are wrapped in &#34;utility types&#34; which are just newtypes that better tie in what their semantics are (e.g. pointer to unsized array) that could allow the &#39;default&#39; expected behavior for moving them.</li>
</ul>
<p>I&#39;m writing these down because I don&#39;t ever expect to implement this but my dream can at least be expressed in prose :).</p>
<p><a href="https://en.wikipedia.org/wiki/Mixin">Mixins</a> are a way to add code to an object or class without going through the normal inheritance system. I think viewed through that lens what I&#39;m doing specifically isn&#39;t, but it feels close enough to make it &#39;count&#39;?</p>
<h2 id="my-example-a-clone-trait">My example: a <code>Clone</code> trait</h2>
<p>Borrowing an idea from <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Rust</a> where objects which represent handles to resources (including memory resources) can&#39;t be deep copied without explicit usage.</p>
<p>So the requiresments here are:</p>
<ul>
<li>A <code>clone()</code> method that creates a new vesion of an object.</li>
</ul>
<p>Bonuses:</p>
<ul>
<li>Ability to assert at compile time that a class implements this interface</li>
<li>A standalone <code>clone()</code> function, more as a demonstration than anything.</li>
</ul>
<p>I think the standard C++ interface method would look like this:</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>class</span> </span><span><span>IClone</span></span><span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span><span>public</span><span>:</span>
</span></span></span><span><span><span>    <span>virtual</span> <span><span>~IClone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>=</span> <span>default</span></span><span>;</span>
</span></span></span><span><span><span>    <span>virtual</span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>clone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> Clone<span>*</span> <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span><span>
</span><span><span><span>class</span> </span><span><span>String</span></span><span><span>:</span>
</span></span><span><span>    <span>public</span> <span>IClone</span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    <span><span>String</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span><span>:</span> <span>data_</span><span><span>(</span></span><span><span>nullptr</span></span><span><span>)</span></span></span><span><span><span>{</span></span></span><span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>String</span></span><span><span><span>(</span></span></span><span><span><span>const</span> <span>char</span><span>*</span> <span>data</span><span>)</span></span></span><span><span>:</span>
</span></span></span></span><span><span><span><span>        <span>data_</span><span><span>(</span></span><span>data</span><span><span>)</span></span>
</span></span></span></span><span><span><span><span>    </span><span><span><span>{</span></span></span><span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>    <span><span>String</span></span><span><span><span>(</span></span></span><span><span><span>const</span> String<span>&amp;</span><span>)</span></span></span><span> <span>=</span> <span>delete</span></span><span>;</span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span><span>String</span></span><span><span><span>(</span></span></span><span><span>String<span>&amp;&amp;</span> <span>other</span><span>)</span></span></span><span>
</span></span></span></span><span><span><span><span>    </span><span><span><span>{</span></span></span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>this</span><span>-&gt;</span><span>data_</span> <span>=</span> other<span>.</span><span>data_</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        other<span>.</span><span>data_</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span></span><span><span><span>}</span></span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>static</span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>create</span></span><span><span><span>(</span></span></span><span><span><span>const</span> <span>char</span><span>*</span> <span>data</span><span>)</span></span></span><span> <span>-&gt;</span></span> Result<span>&lt;</span>String<span>&gt;</span>
</span></span></span><span><span><span>    <span><span><span>{</span></span></span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>auto</span><span>*</span> new_data <span>=</span> <span>std<span>::</span><span>strdup</span><span><span>(</span></span></span><span><span>data</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>return</span> Result<span>&lt;</span>String<span>&gt;</span><span><span>::</span><span>makeOk</span><span><span>(</span></span></span><span><span><span><span>String</span><span><span>(</span></span></span><span><span>new_data</span></span><span><span><span>)</span></span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>virtual</span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>clone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> String<span>*</span> <span><span><span>{</span></span></span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>return</span> <span>new</span> <span><span>String</span><span><span>(</span></span></span><span><span><span>std<span>::</span><span>strdup</span><span><span>(</span></span></span><span><span><span>this</span><span>-&gt;</span><span>data_</span></span></span><span><span><span>)</span></span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span><span>protected</span><span>:</span>
</span></span></span><span><span><span>    <span>char</span><span>*</span> data_<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></code></pre>
<p>But this does opt us into having a vtable (which is fine, honestly?). My idea uses the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP pattern</a>.</p>
<p>One other issue: child classes implementing <code>auto clone() -&gt; Clone*</code> <em>must</em> return a pointer or reference, and not any other class -- this is because of C++&#39;s rule on overloading functions, which only allow covariance in function return types if they are returning pointers (see <a href="https://eli.thegreenplace.net/2018/covariance-and-contravariance-in-subtyping/">this blog post</a>).</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>template</span><span>&lt;</span></span><span><span>typename</span> T</span><span><span>&gt;</span></span>
</span><span><span><span>class</span> </span><span><span>MClone</span></span><span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>auto</span> <span><span>impl_clone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> std<span>::</span>optional<span>&lt;</span>T<span>&amp;</span><span>&gt;</span> <span><span><span>{</span></span></span><span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>clone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> T<span>&amp;</span>
</span></span></span><span><span><span>    <span><span><span>{</span></span></span><span><span>
</span></span></span></span></span><span><span><span><span><span>        reutrn <span>static_cast</span><span>&lt;</span>T<span>*</span><span>&gt;</span><span><span>(</span><span>this</span><span>)</span></span><span>-&gt;</span><span>impl_clone</span><span>.</span><span><span>value</span><span><span>(</span></span></span><span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></code></pre>
<p>And then implmenetation may look like:</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>class</span> </span><span><span>String</span></span><span><span>:</span>
</span></span><span><span>    <span>public</span> <span>MClone</span><span>&lt;</span>String<span>&gt;</span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span><span>public</span><span>:</span>
</span></span></span><span><span><span><span>protected</span><span>:</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>auto</span> <span><span>impl_clone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> std<span>::</span>optional<span>&lt;</span>String<span>&amp;</span><span>&gt;</span> <span><span><span>{</span></span></span><span></span><span><span><span>}</span></span></span>
</span></span></span><span><span><span>    <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>return</span> <span><span>make_optional</span><span><span>(</span></span></span><span><span><span>*</span><span>new</span> <span><span>String</span><span><span>(</span></span></span><span><span><span>this</span><span>-&gt;</span><span>data_</span></span></span><span><span><span>)</span></span></span></span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span><span><span><span><span>    <span>}</span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>char</span><span>*</span> data_<span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
<p>Right now, the differences between these are fairly small, but the CRTP method gives you a few cool options:</p>
<ul>
<li>
<p>Since the code isn&#39;t instantiated until template expansion occurs, it almost acts as a lazily instantiated way of introspecting a class</p>
</li>
<li>
<p>Since your using a (implicitly always safe!) static downcast to the child class, you could make the implementation method virtual if you expect the class to be substyped -- but non-virtual (and thus avoid vtable overhead) if you don&#39;t!</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>class</span> </span><span><span>SomeClass</span></span><span><span>:</span> <span>public</span> <span>MClone</span><span>&lt;</span>SomeClass<span>&gt;</span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>virtual</span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>impl_clone</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> std<span>::</span>optional<span>&lt;</span>SomeClass<span>&gt;</span> <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></code></pre>
</li>
<li>
<p>You can something similar to <a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">Rust&#39;s associated types</a> by checking for a child class type:</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>template</span><span>&lt;</span></span><span><span>typename</span> T</span><span><span>&gt;</span></span>
</span><span><span><span>class</span> </span><span><span>MClone</span></span><span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>auto</span> <span><span>clone_impl</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> T<span>::</span>RetType
</span></span></span><span><span><span>    <span><span><span>{</span></span></span><span><span><span>...</span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></code></pre>
</li>
<li>
<p>If you&#39;re implementation requires any state, you can essentially add the utility added by virtual inheritance without necessarily adding the overhead!</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>template</span><span>&lt;</span></span><span><span>typename</span> T</span><span><span>&gt;</span></span>
</span><span><span><span>class</span> </span><span><span>MRefCounted</span></span><span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>auto</span> <span><span>impl_refcount</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> <span>uint32_t</span><span>&amp;</span> <span><span><span>{</span></span></span><span><span><span>...</span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>auto</span> <span><span>impl_release</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> <span>void</span> <span><span><span>{</span></span></span><span><span><span>...</span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>increment</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> <span>void</span> <span><span><span>{</span></span></span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>auto</span><span>&amp;</span> val <span>=</span> static_downcast<span>&lt;</span>T<span>*</span><span>&gt;</span><span><span>(</span><span>this</span><span>)</span></span><span>-&gt;</span><span><span>impl_refcount</span><span><span>(</span></span></span><span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        val<span>++</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span></span><span><span><span>}</span></span></span>
</span></span></span><span><span><span>    <span>auto</span> <span><span>decrement</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> <span>-&gt;</span></span> <span>void</span> <span><span><span>{</span></span></span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>auto</span><span>&amp;</span> val <span>=</span> static_downcast<span>&lt;</span>T<span>*</span><span>&gt;</span><span><span>(</span><span>this</span><span>)</span></span><span>-&gt;</span><span><span>impl_refcount</span><span><span>(</span></span></span><span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>if</span> <span><span>(</span>val <span>==</span> <span>1</span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            val<span>--</span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            static_downcast<span>&lt;</span>T<span>*</span><span>&gt;</span><span><span>(</span><span>this</span><span>)</span></span><span>-&gt;</span><span><span>impl_release</span><span><span>(</span></span></span><span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        <span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        val<span>--</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    </span></span><span><span><span>}</span></span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></code></pre>
</li>
<li>
<p>It explicitly annotates at the class level (which is like, the opposite of mixins normally): this means you could add the appropriate static_asserts that some type implements an interface. You could add this as an added trait:</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>#include</span> <span><span>&lt;</span>type_traits<span>&gt;</span></span>
</span></span><span><span><span>template</span><span>&lt;</span></span><span><span>typename</span> T</span><span><span>&gt;</span></span>
</span><span><span><span>struct</span> </span><span><span>is_clone</span></span><span>
</span></span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    <span>static</span> <span>constexpr</span> <span>bool</span> value <span>=</span> std<span>::</span>is_base_of<span>&lt;</span>MClone<span>&lt;</span>T<span>&gt;</span><span>,</span> T<span>&gt;</span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span><span>;</span>
</span></code></pre>
<p>and as an example of using it:</p>
<pre data-lang="cpp"><code data-lang="cpp"><span><span><span>template</span><span>&lt;</span></span><span><span>typename</span> T</span><span><span>&gt;</span></span>
</span><span><span>auto</span> <span><span><span>clone</span></span></span><span><span><span>(</span></span></span><span><span><span>const</span> T<span>&amp;</span> <span>value</span><span>)</span></span></span><span> <span>-&gt;</span></span> Result<span>&lt;</span>T<span>&gt;</span>
</span><span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    <span>static_assert</span><span><span>(</span></span><span>
</span></span></span></span><span><span><span><span>        is_clone<span>&lt;</span>T<span>&gt;</span><span>::</span>value <span>==</span> <span>true</span><span>,</span>
</span></span></span></span><span><span><span><span>        <span><span>&#34;</span>Type must implement Clone<span>&#34;</span></span>
</span></span></span></span><span><span><span><span>    </span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>return</span> value<span>.</span><span><span>clone</span><span><span>(</span></span></span><span></span><span><span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre>
</li>
</ul>
<h2 id="but-what-about-implementing-this-for-other-classes">But what about implementing this for other classes?</h2>
<p>I don&#39;t have a good answer for this, but an option may be something like Abseil&#39;s <a href="https://abseil.io/tips/218">FTADLE Extension Points</a>?</p>
<h2 id="is-this-worth-it">Is this worth it?</h2>
<p>I don&#39;t know, probably not!</p>
<p>A lot of this is already sort of done by the C++ standard library with <a href="https://en.cppreference.com/w/cpp/keyword/concept">concepts</a>, so I mostly just think it&#39;s Neat and something you could add to earlier C++ versions.</p>
<p>It&#39;s also something I think can show off the utilities of what the CRTP pattern can do.</p>


    


</div>
  </body>
</html>
