<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2024-05-31-benchmarking-go-error-handling/">Original</a>
    <h1>Go: Sentinel errors and errors.Is() slow your code down by 3000%</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p>In this blog post, we benchmark different strategies for handling errors in Go and discuss their
relative performance and other tradeoffs. The difference in performance between different strategies
was very surprising to us, and we&#39;d like to share the results.</p>
<p><em>The original publication of this blog overstated the difference in performance between error
handling strategies due to poorly configured benchmarks. The author regrets the error.</em></p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/a63b33203afcd1fa51f21671f88a2990/73926/dolt_heart_go.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="dolt loves go" title="" src="https://www.dolthub.com/blog/static/a63b33203afcd1fa51f21671f88a2990/73926/dolt_heart_go.png" srcset="/blog/static/a63b33203afcd1fa51f21671f88a2990/a48b3/dolt_heart_go.png 214w,
/blog/static/a63b33203afcd1fa51f21671f88a2990/73926/dolt_heart_go.png 415w" sizes="(max-width: 415px) 100vw, 415px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>In particular, we were shocked to learn that <strong>naively using the sentinel error pattern combined
with errors.Is() slows your code down by over 5x</strong>.</p>

<p>I wrote several different fake object stores with similar methods to retrieve an object, with
different method signatures and different ways to represent the value being not found. Here&#39;s one of
them, which follows a common recommendation in the Go community to use a sentinel error to represent
the &#34;value not found&#34; condition.</p>
<div data-language="go"><pre><code><span>var</span> notFoundErr <span>=</span> errors<span>.</span><span>New</span><span>(</span><span>&#34;not found&#34;</span><span>)</span>

<span>type</span> resultType <span>struct</span> <span>{</span><span>}</span>

<span>type</span> errStore <span>struct</span> <span>{</span><span>}</span>


<span>func</span> <span>(</span>b <span>*</span>errStore<span>)</span> <span>GetValue</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>error</span><span>)</span> <span>{</span>
	<span>if</span> found <span>{</span>
		<span>return</span> <span>&amp;</span>resultType<span>{</span><span>}</span><span>,</span> <span>nil</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> notFoundErr
	<span>}</span>
<span>}</span></code></pre></div>
<p>Then I set up a benchmark that calls this function over and over, testing both the case where the
value is found and where it&#39;s not found, in the same way a client calling this method would need to
do.</p>
<div data-language="go"><pre><code><span>func</span> <span>BenchmarkNotFoundErrEqual</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>if</span> err <span>==</span> notFoundErr <span>{</span>
			
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundErrEqual</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>if</span> err <span>==</span> notFoundErr <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected found&#34;</span><span>)</span>
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Let&#39;s look at the results.</p>

<p>Here&#39;s the raw benchmark output:</p>
<div data-language="sh"><pre><code>$ go <span>test</span> not_found_test.go  <span>-run</span><span>=</span><span>&#39;.*&#39;</span> <span>-bench</span><span>=</span>. <span>-count</span><span>=</span><span>10</span> <span>&gt;</span> benchresults.txt
$ benchstat benchresults.txt
goos: linux
goarch: amd64
cpu: AMD EPYC <span>7571</span>
                              │ benchresults.txt │
                              │      sec/op      │
NotFoundBool-16                      <span>3</span>.423n ± <span>0</span>%
NotFoundErrorsIs-16                  <span>19</span>.35n ± <span>0</span>%
NotFoundErrorsIsNilCheck-16          <span>19</span>.34n ± <span>0</span>%
NotFoundErrEqual-16                  <span>7</span>.366n ± <span>1</span>%
NotFoundErrEqualNilCheck-16          <span>8</span>.293n ± <span>0</span>%
NotFoundWrappedErr-16                <span>1.374</span>µ ± <span>0</span>%
NotFoundWrappedErrNilCheck-16        <span>1.375</span>µ ± <span>0</span>%
NotFoundWrappedBool-16               <span>11</span>.69n ± <span>0</span>%
NotFoundPanic-16                     <span>241</span>.5n ± <span>1</span>%
FoundBool-16                         <span>3</span>.050n ± <span>2</span>%
FoundErrorsIs-16                     <span>18</span>.04n ± <span>1</span>%
FoundErrorsIsNilCheck-16             <span>2</span>.939n ± <span>2</span>%
FoundErrEqual-16                     <span>3</span>.240n ± <span>2</span>%
FoundErrEqualNilCheck-16             <span>2</span>.994n ± <span>1</span>%
FoundWrappedErr-16                   <span>23</span>.77n ± <span>2</span>%
FoundWrappedErrNilCheck-16           <span>9</span>.877n ± <span>0</span>%
FoundWrappedBool-16                  <span>9</span>.082n ± <span>0</span>%
FoundPanic-16                        <span>12</span>.77n ± <span>0</span>%
geomean                              <span>17</span>.22n</code></pre></div>
<p>We&#39;ll look in depth at each of these strategies in a moment. The tables below list the error
handling strategies from fastest to slowest. We break the results down into the &#34;found&#34; and &#34;not
found&#34; scenarios, since their relative performance is different in each one.</p>
<p>First, here&#39;s the speed and relative performance of each strategy when the value is not found:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Speed (less is better)</th>
<th>Multiple of fastest strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bool</td>
<td>3.423 ns/op</td>
<td>1.00</td>
</tr>
<tr>
<td>ErrEqual</td>
<td>7.366 ns/op</td>
<td>2.15</td>
</tr>
<tr>
<td>ErrEqualNilCheck</td>
<td>8.293 ns/op</td>
<td>2.42</td>
</tr>
<tr>
<td>ErrorsIs</td>
<td>19.35 ns/op</td>
<td>5.65</td>
</tr>
<tr>
<td>ErrorsIsNilCheck</td>
<td>19.34 ns/op</td>
<td>5.65</td>
</tr>
<tr>
<td>Panic</td>
<td>241.5 ns/op</td>
<td>70.55</td>
</tr>
</tbody>
</table>
<p>And here&#39;s the same performance data when the value is found:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Speed (less is better)</th>
<th>Multiple of fastest strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>ErrorsIsNilCheck</td>
<td>2.939 ns/op</td>
<td>1.00</td>
</tr>
<tr>
<td>ErrEqualNilCheck</td>
<td>2.994 ns/op</td>
<td>1.02</td>
</tr>
<tr>
<td>Bool</td>
<td>3.05 ns/op</td>
<td>1.04</td>
</tr>
<tr>
<td>ErrEqual</td>
<td>3.24 ns/op</td>
<td>1.10</td>
</tr>
<tr>
<td>Panic</td>
<td>12.77 ns/op</td>
<td>4.35</td>
</tr>
<tr>
<td>ErrorsIs</td>
<td>18.04 ns/op</td>
<td>6.14</td>
</tr>
</tbody>
</table>
<p>As you can see, it matters quite a lot for performance how you you design your APIs and handle
errors in Go.</p>
<p>Let&#39;s examine each strategy, going in order from fastest to slowest.</p>

<p>The fastest way to handle a &#34;not found&#34; condition in Go is to not represent it as an error. This is
labled as the <code>Bool</code> strategy above. Here&#39;s how it&#39;s implemented:</p>
<div data-language="go"><pre><code><span>type</span> boolStore <span>struct</span> <span>{</span><span>}</span>


<span>func</span> <span>(</span>b <span>*</span>boolStore<span>)</span> <span>GetValue</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>bool</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
	<span>if</span> found <span>{</span>
		<span>return</span> <span>&amp;</span>resultType<span>{</span><span>}</span><span>,</span> <span>true</span><span>,</span> <span>nil</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> <span>false</span><span>,</span> <span>nil</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>As you can see, this method does not return an error when the value isn&#39;t found, instead returning a
boolean <code>found</code> result. Here&#39;s how it&#39;s benchmarked:</p>
<div data-language="go"><pre><code><span>func</span> <span>BenchmarkNotFoundBool</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> bs boolStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> found<span>,</span> err <span>:=</span> bs<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span> <span>else</span> <span>if</span> found <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not found&#34;</span><span>)</span>
		<span>}</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundBool</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> bs boolStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> found<span>,</span> err <span>:=</span> bs<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span> <span>else</span> <span>if</span> <span>!</span>found <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected found&#34;</span><span>)</span>
		<span>}</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>This strategy performs the best in both scenarios, where the value is found and where it&#39;s
not. Technically speaking this isn&#39;t even an &#34;error handling&#34; strategy, since no error is
returned. Rather, it&#39;s a baseline to serve as a point of comparison for other strategies that do
return errors.</p>

<p>This strategy uses classic Go sentinel errors to represent the &#34;value not found&#34; condition. It looks
like this (duplicated from the &#34;Methodology&#34; section above).</p>
<div data-language="go"><pre><code><span>type</span> errStore <span>struct</span> <span>{</span><span>}</span>


<span>func</span> <span>(</span>b <span>*</span>errStore<span>)</span> <span>GetValue</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>error</span><span>)</span> <span>{</span>
	<span>if</span> found <span>{</span>
		<span>return</span> <span>&amp;</span>resultType<span>{</span><span>}</span><span>,</span> <span>nil</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> notFoundErr
	<span>}</span>
<span>}</span></code></pre></div>
<p>When we benchmark this strategy, we use direct <code>==</code> comparison with an <code>error</code> constant to detect
the not found condition.</p>
<div data-language="go"><pre><code><span>func</span> <span>BenchmarkNotFoundErrEqual</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>if</span> err <span>==</span> notFoundErr <span>{</span>
			
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundErrEqual</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>if</span> err <span>==</span> notFoundErr <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected found&#34;</span><span>)</span>
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>In the &#34;not found&#34; scenario, this approach is about 2x slower than using boolean existence
checks. For the case where the value is found, it performs the same.</p>
<p>Note that checking for sentinel errors with <code>==</code> is no longer recommended for correctness reasons,
more details in following sections.</p>

<p>There are two roughly equally idiomatic ways to check for a sentinel error in Go. The first is more
common in our experience, and is what&#39;s done in the <code>ErrEqual</code> strategy:</p>
<div data-language="go"><pre><code>		<span>if</span> err <span>==</span> notFoundErr <span>{</span>
			
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span></code></pre></div>
<p>So you begin by checking for all sentinel error values you want to handle, either in a switch or an
<code>if / else</code> chain, and then if the error isn&#39;t one of the handled types, pass the error up the
stack, panic, or otherwise handle it.</p>
<p>Alternately, you can perform the above logic conditionally after first checking if the error is
non-nil. This code is slightly longer and more indented, and is what the <code>ErrEqualNilCheck</code> does.</p>
<div data-language="go"><pre><code><span>func</span> <span>BenchmarkNotFoundErrEqualNilCheck</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>if</span> err <span>==</span> notFoundErr <span>{</span>
				
			<span>}</span> <span>else</span> <span>{</span>
				b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
			<span>}</span>
		<span>}</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundErrEqualNilCheck</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>if</span> err <span>==</span> notFoundErr <span>{</span>
				b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected found&#34;</span><span>)</span>
			<span>}</span> <span>else</span> <span>{</span>
				b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
			<span>}</span>
		<span>}</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>This stategy is slightly worse than the previous one in the &#34;not found&#34; case because of the added
cost of the <code>nil</code> check, weighing in at about 2.5x slower than boolean existence checks. But in the
(usually more common) case when the value is found, it&#39;s also performs just as well as the boolean
strategy.</p>

<p>The original sentinel error pattern using <code>==</code> caused problems when other parts of a library wanted
to wrap the original error in their own error type to add additional information, which causes the
equality check to fail. Many linters will warn about using <code>==</code> for sentinel errors, and my
JetBrains IDE puts a yellow squiggly under it for the same reason.</p>
<p>Modern best practice is to instead use <a href="%7Bhttps://pkg.go.dev/errors#example-Is">errors.Is()</a> for
sentinel error checks, which correctly detects wrapped errors.</p>
<p>In our benchmarks, this strategy looks like this:</p>
<div data-language="go"><pre><code><span>func</span> <span>BenchmarkNotFoundErrorsIs</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>if</span> errors<span>.</span><span>Is</span><span>(</span>err<span>,</span> notFoundErr<span>)</span> <span>{</span>
			
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundErrorsIs</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>if</span> errors<span>.</span><span>Is</span><span>(</span>err<span>,</span> notFoundErr<span>)</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected found&#34;</span><span>)</span>
		<span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
		<span>}</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Unfortunately, this strategy has bad performance, at 5.5x slower than the <code>Bool</code> strategy when the
value is not found, and 6x slower when it is.</p>

<p>Just as we saw with <code>ErrEqualNilCheck</code>, we can avoid a large performance penalty in the case that
the value is found by only calling <code>errors.Is()</code> after first determining the error is
non-nil. Here&#39;s the benchmark code:</p>
<div data-language="go"><pre><code><span>func</span> <span>BenchmarkNotFoundErrorsIsNilCheck</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>if</span> errors<span>.</span><span>Is</span><span>(</span>err<span>,</span> notFoundErr<span>)</span> <span>{</span>
				
			<span>}</span> <span>else</span> <span>{</span>
				b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
			<span>}</span>
		<span>}</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundErrorsIsNilCheck</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es errStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		val<span>,</span> err <span>:=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>if</span> errors<span>.</span><span>Is</span><span>(</span>err<span>,</span> notFoundErr<span>)</span> <span>{</span>
				b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected found&#34;</span><span>)</span>
			<span>}</span> <span>else</span> <span>{</span>
				b<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
			<span>}</span>
		<span>}</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Just as with <code>ErrEqualNilCheck</code>, this strategy does very slightly worse for the not found scenario
at about 5.5x slower than <code>Bool</code>, but is just as fast as <code>Bool</code> when the value is found.</p>

<p>Usually errors in Go are returned as values, but there is also another technique: you can <code>panic</code>
instead, then <code>recover</code> that panic at a higher layer of the stack. Most people don&#39;t recommend doing
this as an error handling technique, and we don&#39;t either. But there are some limited cases where it
<a href="https://www.dolthub.com/blog/2023-04-14-keep-calm-and-panic/">can be more performant than returning
errors</a>. That&#39;s not the case for this
benchmark though. Panic performs the worst of any strategy. Here&#39;s what it looks like:</p>
<div data-language="go"><pre><code><span>type</span> panicStore <span>struct</span><span>{</span><span>}</span>


<span>func</span> <span>(</span>b <span>*</span>panicStore<span>)</span> <span>GetValue</span><span>(</span>found <span>bool</span><span>)</span> <span>*</span>resultType <span>{</span>
	<span>if</span> found <span>{</span>
		<span>return</span> <span>&amp;</span>resultType<span>{</span><span>}</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>panic</span><span>(</span>notFoundErr<span>)</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkNotFoundPanic</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es panicStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		<span>var</span> val <span>*</span>resultType 
		<span>func</span><span>(</span><span>)</span> <span>{</span>
			<span>defer</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
				
				err <span>:=</span> <span>recover</span><span>(</span><span>)</span>
				<span>if</span> err <span>==</span> <span>nil</span> <span>{</span>
					b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected panic&#34;</span><span>)</span>
				<span>}</span>
			<span>}</span><span>(</span><span>)</span>
			val <span>=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&lt;</span> <span>0</span><span>)</span>
		<span>}</span><span>(</span><span>)</span>
		<span>if</span> val <span>!=</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>BenchmarkFoundPanic</span><span>(</span>b <span>*</span>testing<span>.</span>B<span>)</span> <span>{</span>
	<span>var</span> es panicStore
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>N<span>;</span> i<span>++</span> <span>{</span>
		<span>var</span> val <span>*</span>resultType
		<span>func</span><span>(</span><span>)</span> <span>{</span>
			<span>defer</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
				
				err <span>:=</span> <span>recover</span><span>(</span><span>)</span>
				<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
					b<span>.</span><span>Fatal</span><span>(</span><span>&#34;unexpected panic&#34;</span><span>)</span>
				<span>}</span>
			<span>}</span><span>(</span><span>)</span>
			val <span>=</span> es<span>.</span><span>GetValue</span><span>(</span>i <span>&gt;=</span> <span>0</span><span>)</span>
		<span>}</span><span>(</span><span>)</span>
		<span>if</span> val <span>==</span> <span>nil</span> <span>{</span>
			b<span>.</span><span>Fatal</span><span>(</span><span>&#34;expected not nil&#34;</span><span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>This code is 240x slower than boolean return results in the not found case, and 13x slower in the
found case. So in addition to being risky (can halt your program if you forget to recover), panics
are generally slower than any other error handling strategy.</p>

<p>These are microbenchmarks specifically engineered to zero in on the differences between the error
handling strategies. But real application code looks very different. One of the biggest differences
is that errors are typically passed through several layers of the stack in between other pieces of
business logic. I was curious to know how this difference impacted the benchmarks. Specifically, I
wanted to know how the practice of error wrapping impacted the performance of sentinel errors, and
how it related to the Boolean return strategy.</p>
<p>So I wrote two additional implementations of object stores that simulate an error deeper in the
stack, getting wrapped at every layer. Here&#39;s what it looks like:</p>
<div data-language="go"><pre><code><span>type</span> wrappedErrStore <span>struct</span><span>{</span><span>}</span>


<span>func</span> <span>(</span>b <span>*</span>wrappedErrStore<span>)</span> <span>GetValue</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>error</span><span>)</span> <span>{</span>
	result<span>,</span> err <span>:=</span> b<span>.</span><span>queryValueStore</span><span>(</span>found<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> fmt<span>.</span><span>Errorf</span><span>(</span><span>&#34;GetValue couldn&#39;t get a value: %w&#34;</span><span>,</span> err<span>)</span>
	<span>}</span>
	<span>return</span> result<span>,</span> <span>nil</span>
<span>}</span>


<span>func</span> <span>(</span>b <span>*</span>wrappedErrStore<span>)</span> <span>queryValueStore</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>error</span><span>)</span> <span>{</span>
	result<span>,</span> err <span>:=</span> b<span>.</span><span>queryDisk</span><span>(</span>found<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> fmt<span>.</span><span>Errorf</span><span>(</span><span>&#34;queryValueStore couldn&#39;t get a value: %w&#34;</span><span>,</span> err<span>)</span>
	<span>}</span>
	<span>return</span> result<span>,</span> <span>nil</span>
<span>}</span>


<span>func</span> <span>(</span>b <span>*</span>wrappedErrStore<span>)</span> <span>queryDisk</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>error</span><span>)</span> <span>{</span>
	result<span>,</span> err <span>:=</span> b<span>.</span><span>readValueFromDiskFake</span><span>(</span>found<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> fmt<span>.</span><span>Errorf</span><span>(</span><span>&#34;queryDisk couldn&#39;t get a value: %w&#34;</span><span>,</span> err<span>)</span>
	<span>}</span>
	<span>return</span> result<span>,</span> <span>nil</span>
<span>}</span>


<span>func</span> <span>(</span>b <span>*</span>wrappedErrStore<span>)</span> <span>readValueFromDiskFake</span><span>(</span>found <span>bool</span><span>)</span> <span>(</span><span>*</span>resultType<span>,</span> <span>error</span><span>)</span> <span>{</span>
	<span>if</span> found <span>{</span>
		<span>return</span> <span>&amp;</span>resultType<span>{</span><span>}</span><span>,</span> <span>nil</span>
	<span>}</span> <span>else</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> notFoundErr
	<span>}</span>
<span>}</span></code></pre></div>
<p>I also have another identical implementation that returns a boolean value to indicate presence or
absence of the value, rather than <code>notFoundErr</code> (omitted for brevity), symmetrical to the <code>Bool</code>
strategy. When I run the same benchmarks on these two implementations, I get the following results.</p>
<p>When the value is not found:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Speed (less is better)</th>
<th>Multiple of fastest strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>WrappedBool</td>
<td>11.69 ns/op</td>
<td>1.00</td>
</tr>
<tr>
<td>WrappedErr</td>
<td>1374 ns/op</td>
<td>117.54</td>
</tr>
<tr>
<td>WrappedErrNilCheck</td>
<td>1375 ns/op</td>
<td>117.62</td>
</tr>
</tbody>
</table>
<p>When the value is found:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Speed (less is better)</th>
<th>Multiple of fastest strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>WrappedBool</td>
<td>9.082 ns/op</td>
<td>1.00</td>
</tr>
<tr>
<td>WrappedErrNilCheck</td>
<td>9.877 ns/op</td>
<td>1.09</td>
</tr>
<tr>
<td>WrappedErr</td>
<td>23.77 ns/op</td>
<td>2.62</td>
</tr>
</tbody>
</table>
<p>As you can see, wrapped errors severely degrade the performance of tihs strategy, making sentinel
error checks 120x slower than the boolean check when the error is non-nil. That&#39;s bad! Much of the
difference in time on this benchmark doesn&#39;t come directly from errors.Is() (although it is slower
for wrapped errors, that&#39;s to be expected). Instead, this difference primarily reflects the fact
that creating the wrapped errors is itself expensive. But this is a fair comparison, since in
practice your code must also wrap errors to use this strategy.</p>
<p>On the other hand, the difference in strategies is partially smeared by the introduction of more
stack layers in the case the object exists, to the point that the nil-guarded <code>errors.Is()</code> check is
only 10% slower than boolean checks.</p>

<p>If you want to reproduce this result or variations of it yourself, you can find the full source
<a href="https://gist.github.com/zachmu/00d0410431f9d8d314155361836eecdd">here</a>.</p>
<p>So what&#39;s the takeaway from all this? There are four main points in my view:</p>
<ol>
<li><code>errors.Is()</code> is expensive. If you use it, check the error is non-nil first to avoid a pretty big
performance penalty on the happy path.</li>
<li>Using <code>==</code> to check for sentinel errors is likewise expensive, but less so. If you do this, check
the error is non-nil first to make it cheaper on the happy path. But because of error wrapping,
you probably shouldn&#39;t do this at all.</li>
<li>Error wrapping makes using sentinel errors much more expensive, including making <code>errors.Is()</code>
more expensive when the error is non-nil.</li>
<li>Using sentinel errors is as performant as other techniques on the happy path if you take the
above precautions, but unavoidably much more expensive on the error path.</li>
</ol>
<p>So the main takeaway is really that sentinel errors can be expensive, and you should consider this
when deciding whether to use them.</p>
<p>The standard caveat for performance-based arguments applies here: measure what difference it
actually makes in your case, and don&#39;t sweat stuff that isn&#39;t on the hot path most of the time. We
are talking about nanoseconds here, and it takes a lot of those to add up to something
noticeable. If sentinel errors are measurably slow for you in practice, it&#39;s probably because the
ones you&#39;re using are some combination of commonly triggered and expensive to construct. YMMV. That
said: we have found expensive-to-construct, commonly triggered sentinel errors when profiling our
database, and we changed the code to remove them, squeezing several percentage points improvement in
the process.</p>
<p>But there are also non-performance reasons you might want to avoid sentinel errors, which are more
philosophical or aesthetic in nature.</p>
<p>Earlier this month I kicked the hornet&#39;s nest by suggesting that <a href="https://www.dolthub.com/blog/2024-05-10-ok-considered-harmful/">you shouldn&#39;t name boolean map
check variables <code>ok</code></a>. It got picked
up a few places in the Golang world and generated a lot of discussion on Reddit and elsewhere, which
I had expected. But I hadn&#39;t expected that so much of the conversation would focus on an almost
tangential point I made about API design, specifically about an API returning a <code>NotFound</code> sentinel
error:</p>
<blockquote>
<p>Separating out an existence check from an error condition is a good thing, actually. You never
want to force clients to check for a particular error type in business logic.</p>
<p>...</p>
<p>An error should by default be considered non-recoverable, to be returned when something goes very
wrong. Semantically, a table not existing isn&#39;t really an error, it&#39;s something you expect to
happen all the time. An interface that returns an error in the course of normal operation forces
clients to understand a lot of details to use the interface correctly (looking at you,
<code>io.EOF</code>). And errors can be expensive to construct and examine, so you don&#39;t want them
constructed or interpreted on your hot path.</p>
</blockquote>
<p>I had thought this was a commonly understood nugget of best practice wisdom, but this opinion got <em>a
lot</em> of pushback. People said some very hurtful, arguably accurate things about my character. Here&#39;s
one of the more thoughtful examples from <a href="https://lobste.rs/s/lnav33/ok_considered_harmful">the discussion on
Lobste.rs</a>:</p>
<p><span>
      <a href="https://www.dolthub.com/blog/static/ebb0d9337d67e663f77f6c1c3be92bbf/5a791/lobsters-errors.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="lobste.rs discussion" title="" src="https://www.dolthub.com/blog/static/ebb0d9337d67e663f77f6c1c3be92bbf/ad12c/lobsters-errors.png" srcset="/blog/static/ebb0d9337d67e663f77f6c1c3be92bbf/a48b3/lobsters-errors.png 214w,
/blog/static/ebb0d9337d67e663f77f6c1c3be92bbf/47730/lobsters-errors.png 428w,
/blog/static/ebb0d9337d67e663f77f6c1c3be92bbf/ad12c/lobsters-errors.png 856w,
/blog/static/ebb0d9337d67e663f77f6c1c3be92bbf/5a791/lobsters-errors.png 1248w" sizes="(max-width: 856px) 100vw, 856px" loading="lazy" decoding="async"/>
  </a>
    </span></p>
<p>Now, obviously I disagree. And I think these numbers pretty clearly refute the classical view of
sentinel error handling in Go, summarized by the comment above:</p>
<blockquote>
<p>Errors are normal outcomes of any operation. They aren’t special and aren’t any more or less
expensive to deal with than any other type. They are, classically, just values.</p>
</blockquote>
<p>The problem is that sentinel errors, as typically and idiomatically used, in fact <em>are</em> special, and
<em>are</em> more expensive to deal with than other values. My suggestion to use boolean values outperforms
them by <em>a lot</em>, 6x in fairly common idiomatic usage and potentially much more if they&#39;re expensive
to construct.</p>
<p>And performance considerations aside, sentinel errors have a lot of other issues.</p>
<p>I&#39;m not the first person to note this. Here&#39;s <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Dave Cheney back in 2016 on this
topic</a>:</p>
<blockquote>
<p>My advice is to avoid using sentinel error values in the code you write. There are a few cases
where they are used in the standard library, but this is not a pattern that you should emulate.</p>
</blockquote>
<p>Instead, he recommends never inspecting the details of an error:</p>
<blockquote>
<p>Now we come to the third category of error handling. In my opinion this is the most flexible error
handling strategy as it requires the least coupling between your code and caller.</p>
<p>I call this style opaque error handling, because while you know an error occurred, you don’t have
the ability to see inside the error. As the caller, all you know about the result of the operation
is that it worked, or it didn’t.</p>
<p>This is all there is to opaque error handling – just return the error without assuming anything
about its contents.</p>
</blockquote>
<p>Dave didn&#39;t invent this advice. Going back further, lots of luminaries and philosophers in the field
have given the same advice in other contexts and for other languages: don&#39;t use errors for control
flow. I&#39;m old enough to have seen Josh Bloch in person at a Java conference, where he was something
of a celebrity. He gave this advice on error handling in <a href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997/">Effective
Java</a> way back in 2001:</p>
<blockquote>
<p>Exceptions are, as their name implies, to be used only for exceptional conditions; they should
never be used for ordinary control flow.</p>
<p>...</p>
<p>This principle also has implications for API design. A well-designed API must not force its
clients to use exceptions for ordinary control flow. A class with a “state-dependent” method that
can be invoked only under certain unpredictable conditions should generally have a separate
“state-testing” method indicating whether it is appropriate to invoke the state-dependent method.</p>
</blockquote>
<p>Now obviously Exceptions in Java are not the same as errors in Go. But just as obviously, they serve
the same purpose. Functionally and semantically, there is not much difference between these two code
snippets:</p>
<div data-language="java"><pre><code><span>try</span> <span>{</span>
    val <span>=</span> store<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>NotFoundException</span> e<span>)</span> <span>{</span>
    
<span>}</span></code></pre></div>
<div data-language="go"><pre><code>val<span>,</span> err <span>:=</span> store<span>.</span><span>GetValue</span><span>(</span><span>)</span>
<span>if</span> errors<span>.</span><span>Is</span><span>(</span>err<span>,</span> notFoundErr<span>)</span> <span>{</span>
    
<span>}</span></code></pre></div>
<p>They&#39;re both workable and idiomatic. But they also both have serious drawbacks, for different but
related reasons. And they&#39;re both improved by changing the API to eliminate the need for the client
to interpret the not found case as an error during normal operation. Here the two languages diverge:
because Java lacks multiple return values, it&#39;s not ergonomic to add additional metadata like a
<code>found</code> boolean into the return result in most cases, so you tend to do something like this instead:</p>
<div data-language="java"><pre><code><span>if</span> <span>(</span>store<span>.</span><span>hasValue</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    val <span>=</span> store<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Bloch anticipates that people might be tempted to use exceptions for control flow for performance
reasons:</p>
<blockquote>
<p>More generally, use standard, easily recognizable idioms in preference to overly clever techniques
that purport to offer better performance.</p>
</blockquote>
<p>After all, it really is more expensive to call two methods (<code>Has()</code>, <code>Get()</code>) than one (<code>Get()</code>),
even with caching. But because Go does have multiple return values, you don&#39;t have to make this
tradeoff the way you do in Java. You can just return more information and save yourself the extra
method call, while not forcing clients to examine the error value.</p>
<div data-language="go"><pre><code>val<span>,</span> found<span>,</span> err <span>:=</span> store<span>.</span><span>GetValue</span><span>(</span><span>)</span>
<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
    <span>return</span> err 
<span>}</span>
<span>if</span> <span>!</span>found <span>{</span>
    
<span>}</span></code></pre></div>
<p>Some people are bothered by the fact that a method named <code>GetValue()</code> may not succeed in getting a
value. If that sounds like you, then name it <code>MaybeGetValue()</code> instead. Other people are bothered by
the code overhead of a <code>found</code> boolean in the return. If that sounds like you, you might be able to
get away with using a <code>nil</code> return value instead (as long as <code>nil</code> isn&#39;t a valid object in your
API). Either way, understand that inspecting errors for business logic can come at a substantial
performance cost.</p>

<p>We&#39;re building <a href="https://doltdb.com">Dolt</a>, the world&#39;s first version-controlled SQL database. We
have been writing it for over five years now, and our codebase has quite a few sentinel errors, many
of which we inherited from other libraries, but some of which we wrote ourselves. These days we
avoid sentinel errors and generally treat all errors as opaque. We also wrap errors very sparingly,
prefering to <a href="https://www.dolthub.com/blog/2023-11-10-stack-traces-in-go/">use stack traces instead</a>
where appropriate.</p>
<p>Have questions or comments about Go error handling? Or maybe you are curious about the world&#39;s first
version-controlled SQL database? <a href="https://discord.gg/gqr7K4VNKe">Join us on Discord</a> to talk to our
engineering team and other Dolt users.</p></div></div>
  </body>
</html>
