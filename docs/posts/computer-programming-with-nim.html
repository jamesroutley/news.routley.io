<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ssalewski.de/nimprogramming.html">Original</a>
    <h1>Computer Programming with Nim</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<div id="preamble">
<div>
<div>
<blockquote>
<p>When you are not able to explain it with words, you may have to add pictures.
And when you even do not manage it with pictures, you can still make a video.</p>
</blockquote>
</div>
</div>
</div>
<div>
<h2 id="_about_this_book">About this book</h2>
<div>
<p>In the year 1970 Prof. Niklaus Wirth invented the <span>Pascal</span> programming language to teach
his students the fundamentals of computer programming. While the initial core Pascal
language was designed for teaching purposes only, it was soon expanded by commercial
vendors and got some popularity. Later, Wirth presented the language <span>Modula-2</span>
with improved syntax and support of modules for larger projects, and the
<span>Oberon</span> language family with additional support for <span>Object-Oriented
Programming</span>.</p>
<p>The <span>Nim</span> programming language can be seen in this tradition, as it is
basically an easy language suited for beginners with no prior programming experience,
but at the same time is not restricted in any way. Nim offers all the concepts of
modern and powerful programming languages in combination with high performance and
some sort of universality — Nim can be used to create programs for tiny microcontroller as well
as large desktop apps and web applications.</p>
<p>Most books about programming languages concentrate on the language itself and assume
that the reader is already familiar with the foundations of computer hardware and
already has some programming experience. This is generally a valid approach, as today
most people are taught this fundamental knowledge, sometimes called <span>Computer
Science</span> (CS) in school. But still, there are people who missed this introduction in
school for various reasons and decide later that they need some programming skills,
maybe for a technical job. And there may exist some children that are not satisfied
with the introduction to computer science taught at school. So we have decided to
start this book with a short introduction to fundamental concepts — most people can
skip that part. In part II we explain the basics of computer programming step by step
in a way which should enable even children to learn independently. In this part we may repeat
some of the stuff which we already mentioned in part I. We do that by intent, as some
people may skip part I, and because it is generally not a bad idea to support the learning
process of the reader with some repetitions.
Part III will give
you an overview of the Nim standard library, and part IV will introduce some useful
external packages. Part V will introduce advanced concepts like <span>asynchronous
operations</span>, <span>threading</span> and <span>parallel processing</span>, and <span>macros</span>
and <span>meta-programming</span>. Nim macros are very powerful but difficult at first.
Part VI may finally present some advanced examples.</p>
<p>This book is basically a traditional text book, a very simple one with detailed
explanations, so that kids from 14 years upwards can read and understand it
on their own, with no, or only minimal help from adults. The English language
may still be a problem for many kids not born in a country with a good
English language tradition unfortunately. But luckily automatic
translations are already supported for some languages, and maybe we
will be able to offer some translated editions later, maybe a Chinese
and a German translation?</p>
<p>In the last decades for the area of computer programming
traditional text books have partly been replaced by videos and &#34;Crash course&#34; and &#34;Learning
by doing&#34; books. Well, maybe a good video may indeed help you starting with a new
language, and a video may enable people with problems reading printed texts or with
problems concentrating on a topic for a few minutes to learn a programming language.
Unfortunately the quality of most videos is very bad, some are made by kids just having
learned the first steps of computer programming themselves. And of course
watching videos does not improve the reading and concentration problems that people have.
&#34;Crash course&#34; and &#34;Learning by doing&#34;
books may give you a good start, but for that we already have a lot of textual tutorials.
The problem with these kinds of books is, that they may help you with solving some common tasks, but they do not
really support a deeper understanding. The idea of a &#34;Crash course&#34; and &#34;Learning by doing&#34; may not be that bad in general, but in computer
science starting with a larger example application may be a overwhelming process, as you have to learn
a lot of stuff in parallel. It may work for you, but there is the danger that you forget all the details very quickly again.
And these kinds of books are not very helpful when you have to look up something.
The other problem with &#34;Learning by doing&#34; in computer science is, that learning materials
may have only examples which you may not really be interesting in: Of course we can create
a simple chat application, a simple Twitter clone and do some basic web scraping using
async/await. Or create a basic game, or a simple GUI with one of the dozen available tool-kits.
But what when you are not interested in chatting and twittering, and that single selected toolkit?
We think that for such a case, reading the detailed examples can be very frustrating. So we
would recommend that after reading the first tutorial, and maybe a few pages of this book, you just start
coding with stuff you are interested in. Maybe together with some friends? Whenever you should
need some concrete help, you should find it on the internet, using search engines, Wikipedia or
a discussion platform of your choice.
And if you have really no idea whatsoever for a project with which you can start,
then maybe computer programming is just not the right profession for you.</p>
<p>While Nim has a JavaScript backend and so supports web related development well, this
book concentrates on native code generation using the C and C++ backends. We will
discuss some peculiarities of the JavaScript backend in the second half of the book,
and we may give some complete examples for the use of the JavaScript backend in the
final part VI of the book. If you are strongly interested in web development and the
JavaScript backend, then you may also consult the book <span>Nim in Action</span> of
Dominik Picheta, which gives some detailed examples for the development of web based
software with the Nim programming language, including a simple chat application and
the skeleton of a microblogging and social networking service. And you may consult
the tutorials and manuals of Nim web packages like <span>Karax</span>,
<span>Jester</span> or <span>basolato</span>.</p>
<p>This book will not try to explain things that are already explained well elsewhere or
that should have been explained well elsewhere — at least not in this first edition, where
we still have so much other important stuff. So what we will leaf out for now is the installation
of the compiler, installing and using text editors or IDEs with special Nim support, using
Nim package managers like nimble, nimph or others, using the foreign function interface (FFI)
to create bindings to C libraries, and internal compiler details like the various
memory management options, all the pragmas and similar. Also we do not intend to
fill the book up with redundant stuff, like tables listing all the Nim keyword or Nim’s
primitive data types and such, as you can find all that in the compiler manual easily.</p>
<p>While creating graphical user interfaces (GUIs) is an important topic, we can not
give much details for that due to various reasons: Nim has not yet the one and only
accepted GUI library, but more than 20 attempts — from pure Nim ones like xnim or fidget, over
wrapped libs like GTK or QML, or GUIs that try to provide a native look for various operating systems like xwidgets or nigui,
to web based GUIs. And for each of these, at least for the more
serious ones, we could write a separate GUI book. So we will give only a few minimal examples
for some of them in part IV of the book.</p>
<p>Also we will not explain game programming, as game programming is
a broad area, and there are already a lot of tutorials available. Maybe in later editions of the
book we will add some of this topics, e.g. game programming, as so many people like it.
But we will always have to ensure that a possible printed book version will not get
more than 500 pages, so we may then leave out some stuff in the printed version.</p>
<p>General when learning a new programming language, people start with some short
tutorials before really learning the language following a book. This way is indeed a good start.
So we recommend you to read the short official tutorials part 1 and 2 and maybe also
some of the other tutorials freely available online. Tutorials generally only scratch the topics, so you may not be able to understand all
really well, but this way you get already a feeling for the language.
There exists also
some video tutorials, for the case that you have problems reading, but in that case
this book will not be of much use for you at all.
When you know already some computer science and have already experience
with other languages like C++, Haskell or Rust, then the tutorials and the Nim compiler manual
may be fully sufficient for you, and you may not need this book at all.</p>
<p>This book is based on the Nim reference implementation of the team around
Mr. A. Rumpf.
While the first pages of this book have been written already in spring 2020, it should be mostly up to date
with the current stable version Nim v1.6. We will try to keep the book up to date with further Nim
releases, as a 1.8 or maybe already a 2.0 release with planned support for incremental compilation.</p>


</div>
</div>

<div>
<p>
For using computers and writing computer programs, you initially do not have to know
many details. It is basically like driving a car: Although a car is a powerful and
complicated tool, kids generally can drive it after a 3-minute introduction. Still,
good racing drivers generally need a much broader insight into the inner working of
all the technical components, and finally, a lot of practice.
</p>
</div>
<div>
<h2 id="_what_is_a_computer">What is a Computer?</h2>
<div>
<p>A computer is primarily a device which can run computer programs, by following
instructions about how to manipulate data.</p>
<p>Nearly all of the
computers currently in use, from the tiny ones integrated in electronic gadgets, the
well known desktop computers (PCs), to large and powerful super computers filling out
entire rooms, work internally with digital data only. Digital data are basically integer (whole) numbers encoded in
binary form, which are represented by sequences of the symbols <span>0</span> and <span>1</span>. We
will discuss the term digital in the next section in more detail.</p>
<p>The most important part of a digital computer is the <span>CPU</span>, the
<span>Central Processing Unit</span>. That tiny device is built of digital electronic
circuits and can perform very basic mathematical and logical operations on numbers,
like adding two numbers or deciding if a number is larger or smaller than another
number. Most computer CPU’s can only store very few numbers internally, and forget
the numbers when the power is switched off. So the CPU is generally electrically
connected to a <span>RAM</span> module, a <span>Random Access Memory</span>, which can store
many more numbers and allow fast access to these numbers, and to a <span>Harddisk</span>
or <span>SSD</span> device which can permanently store the numbers, but does not allow
such fast access. The stored numbers are most often called just <span>data</span> — basically that data is nothing more than numbers, but it can be interpreted in many
different ways, such as pictures, sounds and much more.</p>
<p>The traditional hard disk drives (HDD), which store data electro-mechanical on rotating magnetic disks, as
well as the more modern variants, the solid-state-devices (SDD), which store data using modern semiconductor
technologies, can store data persistently for longer time periods, even when no electric power
supply is available. Both, SSDs and HDDs, can be optionally split into multiple partitions, e.g. one or multiple OS partitions
for executable programs or pure data partition for passive data like text files or pictures.
Before used, each partition is generally formatted and a file system (FS) is created. These two steps
create an internal structure on the storage device, which allows us to store and retrieve individual data
blocks like programs, text files or pictures.</p>
<p>Nearly all of today’s desktop computers, and even most notebooks and cellphones
contain not only a single CPU, but multiple CPUs, also called &#34;Cores&#34;, so they can
run different programs in parallel, or a single program can run parts of it on
different CPUs, to increase performance or reduce total execution time. The so called
super computers can contain thousands of CPUs. Beside CPUs most computers have also
at least one <span>GPU</span>, a <span>Graphic Processing Unit</span>, that can be used to
display data on a screen or monitor, maybe for doing animations in games or for
playing video. The distinction between CPU and GPU is not really sharp; generally a
CPU can also display data on screens and monitors, and GPUs can do also some data
processing that CPUs can do. But GPUs are optimized for the data display task.</p>
<p>More visible to the ordinary computer user are the peripheral devices like keyboard,
mouse, screen and maybe a printer. These enable human interaction with the computer,
but are in no way a core component of it; the computer can run well without them. In
notebook or laptop computers or in cellphones, the peripheral devices are closely
integrated with the core components. All the physical parts of a computer are also
called <span>hardware</span>, while the programs running on that hardware are called
<span>software</span>.</p>
<p>A less visible but also very important class of computers are <span>microcontroller</span> and so
called <span>embedded devices</span>, tiny pieces with generally a hull of black plastic
with some electrical contacts. The devices generally contain all necessary elements,
that is the CPU, some RAM and a persistent storage that can store programs when no
electric power supply is available. These devices may be restricted in computing
power and the amount of data that they can store and process, but they are contained
in many devices. They control your washing machine, refrigerator, television and
radio and much more. Some devices in your home may even contain multiple microcontrollers and
often the microcontrollers can already communicate with each other by RF (Radio-Frequency), or
access by WLAN the internet, which is sometimes called <span>Internet of Things</span>
(IoT).</p>
<p>Another class of large and very powerful digital computers are called
<span>mainframe computers</span> or <span>super computers</span>, which are optimized to
process large amount of data very fast. The key to their gigantic computing power is
that many fast CPUs work in parallel — the problem or task is split into many small
parts that are solved by one CPU each, and the final result is then the combination
of all the solved sub-tasks. Unfortunately it is not always possible to split large
problems into smaller sub-tasks.</p>
<p>Digital computers are generally driven by a clock signal that pulses at a certain
frequency. The CPU can do simple operations like the addition of two integers at
each pulse of the clock signal. For more complicated operations like a multiplication
or a division it may need more clock pulses.</p>
<p>So a rough measure for the performance of a computer is the clock rate, that is the
number of clock pulses per second, divided by the number of pulses that the CPU needs
to perform a basic operation, multiplied by the number of CPUs or Cores that the
computer can use.</p>
<p>A totally different kind of computers are <span>Quantum Computers</span>, large,
expensive high-tech devices, which use the rules of <span>quantum mechanics</span> to
calculate many computations in parallel. Today only a few of them exist, for research
at universities and some large commercial institutes. Quantum computers may at some
time in the future fundamentally change computing and our whole world, but they are
not the topic of this book.</p>
</div>
</div>
<div>
<h2 id="_analog_and_digital">Analog and Digital</h2>
<div>
<p>Whenever we measure a quantity based on one tiny base unit, then we work in the
digital area, we measure with some granularity. Our ordinary money is digital in some
way, as the cent is the smallest base unit; you will never pay a fraction of a cent
for something. Time can be seen as a digital quantity as long as we accepts the
second as the smallest unit. Even on so called analogue watches the second hand will
generally jump forwards in steps of a second, so you can not measure fractions of a
second with that watch.</p>
<p>An obvious analogue property is the thermodynamic temperature and its classic
measurement device is the well known capillary thermometer consisting of a glass
capillary filled with alcohol or liquid mercury. When temperature increases the
liquid in a reservoir expand more than the surrounding glass and partly fills the
capillary. That filling rate is an analogue measure for the temperature.</p>
<p>While the hourglass works digitally (you can count the tiny sand stones), the sundial
does not.</p>
<p>Most of the quantities in our real world seem analog, and digital quantities seem to
be some sort of arbitrary approximation.</p>
<p>But <span>quantum mechanics</span> has taught us that many quantities in our world really
have a granularity. Physically quantities like energy or momentum are indeed
multiplies of the tiny <span>planck constant</span>. Or consider electric charge, which
is always a multiple of the <span>elementary charge unit</span> of one electron. Whenever
an electrical current is flowing through an electrically conducting wire, an ionized
gas or an electrolyte like salt water, there are flowing multiplies of the elementary
charge only, never fractions of it. And of course light and electromagnetic radiation
also has some form of granularity, which the photoelectric effect as well as compton
scattering proves.</p>
<p>An important and useful property of digital signals and digital data, is that they map
directly to integral numbers.</p>
<p>The simplest form of digital data is binary data, which can have only two distinct
values. When you use a mechanical switch to turn the light bulb in your house on, or
of, you change the binary state of the bulb. And your neighbor, when watching your
house, receives binary signals.</p>
<p>Digital computers are generally using binary electric states internally — voltage or
current <span>on</span> or <span>off</span>. Such an on/off state is called a bit. We will
learn more about bits and binary logic later. One bit can store obviously only two
states, which we may map to the numbers <span>0</span> and <span>1</span>. Larger integer
numbers can be represented by a sequence of multiple bits.</p>
<p>The <span>morse code</span> was an early application to transmit messages encoded in
binary form.</p>
<p>A very important property of digital encoded numbers (data) is that they can be
copied and transmitted exactly without loss of precision. The reason for this is that digital numbers have a
well defined clean state, there is no noise which overlays the data and may
accumulate when the data is copied multiple times. Well, that statement is not really
true — under bad conditions the noise can become so large that it changes the binary
state of signals. Imagine we try to transfer some whole numbers encoded in binary
form, maybe by binary states encoded as voltage level <span>0 Volt</span> and <span>5
Volt</span>, over an electric wire and a long distance. It is clear that the long wire can
pick up some electromagnetic noise that can change the true <span>0</span> Volt data to a voltage
that is closer to <span>5</span> Volt than to the true <span>0</span> Volt level, so it is received
incorrectly. To catch such types of transmission errors <span>checksums</span> are added
to the actual data. A checksum is derived by a special mathematical formula from the
original data and transferred with it. The receiver applies the same formula to the
received data and compares the result with the received checksum. If it does not
match, then it is clear that data transmission is corrupted, and a resend is
requested.</p>
<p>The opposite of digital is generally called analogue, a term which is used for data
which have or seems to have no granularity. For example we speak of an analogue
voltage when the voltage can have each value in a given range and when the voltage
does not &#34;jump&#34; but change continuous.
For observing analogue voltages or currents, one can use a moving coil meter, a device
where the current flows through a coil in a magnetic field and the magnetic force
moves the hand/pointer.</p>
<p>We said in the previous section that nearly all of our current computers work with
digital data only. Basically that is that they work internally with integer numbers,
stored in sequences of binary bits. All input for computers must have the form of
integer numbers, and all output has the form of integer numbers. Whenever we want to
feed computers with some sort of analogue data, like an analogue voltage, we have to
convert it into a digital approximation. For that task special devices called
<span>analog to digital converters</span> (ADC) exists. And in some cases we have to
convert the digital output data of computers to analogue signals, like when a
computer plays music: The computer output in form of digital data is then converted
by a device called <span>digital to analog converter</span> (DAC) into an analogue
voltage, that generates an analogue current through a coil in the speakers of our
sound box, and that electric current in the coil generates a magnetic field which
exercise mechanical forces and moves the membrane of the speaker, resulting in
oscillating motions, which generates air pressure variations that our ear can detect
and that we finally hear as sound.</p>
</div>
</div>
<div>
<h2 id="_what_is_an_operating_system">What is an Operating System?</h2>
<div>
<p>Most computers, from cellphones to large super computers, use an <span>operating system</span> (OS).
A well known OS is the GNU/Linux kernel. Operating Systems can be seen as the initial
program that is loaded and started when we switch the computer on and that works as
some kind of supervisor: it can load other
programs and it distributes resources like CPU cores or RAM between multiple running
programs. It also controls user input by keyboard and mouse, displays output data on
the screen — as text or graphics, controls how data is loaded and stored to
nonvolatile storage media like hard-disk or SSD, manages all the network traffic and
many more tasks. An important task of the OS is to allow user programs to access all
the various hardware components from different vendors in a uniform high level
manner. An OS can be seen as an intermediate layer between user programs like a text
processor or a game, and the hardware of the computer. The OS allows user programs to
work on a higher level of abstraction, so they do not need to know much about the low
level hardware details.</p>
<p>Computer operating systems have generally a close relation to software libraries, which
are collections of data types and functions working with that data types. Libraries can
be a part of the OS, or can be more or less independent of the OS. Libraries are software
components that provide data types and functions with a well defined interface
 (API, Application Programming Interface) and behaviour.</p>
<p>Libraries can be used as shared libraries, which are single binary files stored on the file system of a computer,
often with the file extension <span>.so</span> or <span>.dll</span>, which can be accessed from different computer programs simultaneously,
or as static libraries which are part of single programs. Shared libraries have some advantages: we need only one
instance on the file system of the computer, and the library is loaded only once into the computer memory (RAM), even when
it is used by different apps simultaneously. This saves space, and when the library has serious errors, it is in principle possible to
replace the library with a corrected version, which is then used by all the software on the computer. Shared libraries come often in
numbered versions, where a higher number denotes a newer, improved or extended library version. Sometimes some of the
programs we use may need still an older library version, while other software needs already a never one. In that case
our file system has to provide multiple versions of a shared library, which can be used independently.
On the other hand, statically linked libraries are directly glued with a single computer program.
That makes the distribution of the program easier, as it can be shipped as a single entity,
and we do not have to ensure that all the needed dynamic libraries are available on the destination computer.
But if a statically linked library has serious errors, then we have to replace all the programs that are linked
statically with that corrupted library.</p>
<p>Small microcontrollers and embedded devices often do not need to use an operating system, as they generally
run only one single user program and because they usually do not have a large variety
of hardware components to support.</p>
</div>
</div>
<div>
<h2 id="_what_is_computer_programming">What is Computer Programming?</h2>
<div>
<p>Computer programming includes the creation, testing and optimizing of computer
programs.</p>
</div>
</div>
<div>
<h2 id="_what_is_a_computer_program">What is a Computer Program?</h2>
<div>
<p>A computer program is basically a sequence of numbers, which make some sense to a
computer CPU, in such a way that the CPU recognizes the numbers as so called
<span>instructions</span> or <span>numeric machine code</span>, maybe the instruction to add
two numbers.</p>
<p>The first computers, built in the 1950’s, were indeed programmed by feeding sequences
of plain numbers to the device. The numbers were stored on so called <span>punch
cards</span>, consisting of strong paper where the numbers were encoded by holes in the
cards. The holes could be recognized by electrical contacts to feed the numbers into
the CPU. As plain numbers do not match well human thinking, soon more abstract codes
where used. A very direct code, which matches numerical instructions to symbols, is
the <span>assembly language</span>. In that language for example the character sequence
&#34;add A0, $8&#34; may map directly to a sequence of numbers which instructs the CPU to add
the constant integer number 8 to CPU register A0, where A0 is a storage area in the
CPU where numbers can be stored. As there exist many different types of CPUs, all
with their own instruction sets, there exists many different assembly instruction
sets, with similar, but not identical instructions. The rules that describe how these
basic instructions have to look are called the <span>syntax</span> of the assembly
language.</p>
<p>The numerical machine code, or the corresponding assembly language, is the most basic
instruction set for a CPU. Every instruction which a CPU can execute maps to a
well-defined assembly instruction. So each operation that a computer may be able to
perform can be expressed in a sequence of assembly instructions. But complicated
tasks may require millions of assembly instructions, which would take humans very
long to write, and even much longer to modify, proof and debug.</p>
<p>Just a few years after the invention of the first computers, people recognized that
they would need even more abstract instruction sets, like repeated execution,
composed conditionals, or other data types than plain numbers as operands. So higher
level programming languages like Algol, Fortran, C, Pascal or Basic were created.</p>
</div>
</div>
<div>
<h2 id="_what_is_an_algorithm">What is an Algorithm?</h2>
<div>
<p>An <span>algorithm</span> is a detailed sequence of more or less abstract instructions to
solve a specific task, or to reach a goal. Cooking recipe books and car repair
instructions are examples of algorithms.</p>
<p>The basic math operations kids learn in
school — to add, multiply or divide two numbers with paper and pencil — are algorithms
too. Even starting a car follows an algorithm — when the temperature is below zero,
and snow covers the vehicle, than you first have to clean the windows and lights. And
when you first drive again after a longer break, you would have to check the tires
before you start the engine. Algorithm can be carried out by strictly following the
instructions — it is not necessary to really understand how and why it works.</p>
<p>So an algorithm is a perfect fit for a computer, as computers are really good at
following instructions without really understanding what they are trying to
accomplish.</p>
<p>A math algorithm to sum up the first 100 natural numbers may look like:</p>
<div>
<div>
<pre><code>use two integer variables called i and sum
assign the value 0 to both variables

while i is less than 100 do:
  increase i by one
  add value of i to sum

optionally print the final value of sum</code></pre>
</div>
</div>
</div>
</div>
<div>
<h2 id="_what_is_a_programming_language">What is a Programming Language?</h2>
<div>
<p>Most traditional programming languages were created to map algorithms to elementary
CPU instructions. Algorithms generally contain nested conditionals, repetition, math
operations, recovery from errors and maybe plausibility checks. A more complicated algorithm
generally can be split into various separate logical parts, which may include reading in data at one point,
multiple processing steps at another, and storing, or displaying data as plain text, graphic or
animation at yet another point. This splitting into parts is mapped to programming languages by grouping
tasks into subroutines, functions or procedures which accept a set of input
parameters and can return a result.</p>
<p>As algorithms often work not only with numbers,
but also with text, it makes sense to have a form of textual data type in a
programming language too. And all the data types can be grouped in various ways, for
example, as sequences of multiple data of the same type, like lists of numbers or
names. Or as collections of different types, like name, age and profession of a
citizen in an income tax database. For all these use cases programming languages
provide some sort of support.</p>
</div>
</div>
<div>
<h2 id="_compilers_and_interpreters">Compilers and Interpreters</h2>
<div>
<p>We already learned that the CPU in the computer can execute only simple instructions,
which we call numeric machine code or assembly instructions.</p>
<p>To run a program written in a high level language with many abstractions, we need some
sort of a converter to transform that program into the basic instructions that the CPU can
execute. For the conversion process we have basically two options: We can convert the
whole program into machine code, store it to disk, and than run it on the CPU. Or we
can convert it in small portions, maybe line by line, and run each portion whenever
we have converted it. Tools that convert the whole program first are called
compilers. <span>Compilers</span> process the program that we have written, include other
source code like needed library modules, check the code for obvious errors and then
generate and store the machine code that we then can run.</p>
<p>Tools that process the
source code in small portions, like single statements, are called
<span>interpreters</span>. They read in a line of source code, investigate it to check if
it is a valid statement, and then feed the CPU with corresponding instructions to
execute it. It is similar to picking strawberries: you can pick one and eat it at
once, or you can put them all into a basket and eat them later. Both interpreters and
compilers have advantages and disadvantages for special use cases. Compilers can
already detect errors before the program is run, and compiled programs generally run
fast, as all the instructions are already available when the programs runs. The
compiling step takes some time of course, at least a few seconds, but for some
languages and large programs it may take much longer. That can make the software
development process slow because as you add or change code, you have to compile it
before you can execute and test your program. That may be inconvenient for unskilled
programmers as they may have to do much testing. Some use a programming style that
is: change a tiny bit of the source code, then run it and see what is does. But a
more common practice is that you think about the problem first and then write the
code, that then in most cases does nearly that what you intended. For this style of
programming, you do not have to compile and execute your code that often. Compilers
have one important benefit: they can detect many bugs, mostly typing errors, already
in the compile phase, and they give you a detailed error message. Interpreters have
the advantage that you can modify your code and immediately execute it without delay.
That is nice for learning a new language and for some fast tests, but even simple
typing errors can only be detected when they are encountered while running the
program. If your test does not try to run a faulty statement, there will be no error,
but it may occur later. Generally interpreted program execution is much slower than
running compiled executables, as the interpreter has to continually process the
source code in real-time as it’s being run, while the compiler does it only once before the program is run. At the
end of this section, a few additional notes:</p>
<p>Compilers are sometimes supported by so
called linkers. In that case the compiler converts the source code, that can be
stored in multiple text files, each in a sequence of machine code instructions, and
finally the linker joins all these machine code files to the final executable. Some
compilers do not need the linking step or call the linker automatically. And some
interpreters convert the textual source code in one very fast, initial pre-processing
step (&#34;on the fly&#34;) to so called byte code, that can then be interpreted faster. The
languages Ruby and Python do that. Some languages, like Java, can compile and optimize
the source code while the program is running. For that process a so called virtual
machine is used, which builds an intermediate layer between the hardware and the user
program.</p>
</div>
</div>
<div>
<h2 id="_types_of_programming_languages">Types of Programming Languages</h2>
<div>
<p>There are many different styles that software can be written in. A programming paradigm
is a fundamental style of writing software, and each programming language supports
a different set of paradigms. You’re probably already familiar with one, or more
of them, and at the very least you know what object-oriented programming (OOP) is,
because it’s taught as part of many computer science courses.</p>
<p>We already mentioned the assembly languages, which provide only the basic operations
that the CPU can perform. Assembly languages provide no abstractions, so maybe we
should not even call them programming languages at all. Then there are low level
languages like Fortran or C, with some basic abstractions which still work close to
the hardware and which are mostly designed for high performance and low resource
consumption (RAM) but not to detect and prevent programming errors or to make life
easy for programmers. These languages already support some higher order data types,
like floating point numbers or text (strings), and homogeneous, fixed size containers
(called arrays in C) or heterogeneous fixed size containers (called structs in C).</p>
<p>A different approach is taken by languages like Python or Ruby, which try to make
writing code easier by offering many high level abstractions and which have better
protection against errors, but are not as efficient. These languages support also
dynamic containers which can grow and shrink, or advanced data structures like hash
tables (maps) or support for textual pattern matching by regular expressions (regex).</p>
<p>Another way to differentiate programming languages is if they are statically, or
dynamically typed. Ruby, Python and JavaScript are all examples of dynamically typed languages,
that is, they use variables which can store any data type, so the variable’s type
of data that it accepts can therefore dynamically change during program execution. That seems comfortable for the user, and
sometimes it is, especially for short programs which may be written for one-time use
only and are sometimes called scripts. But dynamic typing makes discovery of logical
errors harder — an illegal addition of a number to a letter may be detected only at
run-time. And dynamically typed languages generally waste a lot of memory and their
performance is not that great.
It is as we would own a set of large, equally sized moving boxes, and we
would store all of our goods in it, each piece in one box.</p>
<p>For statically typed languages, each variable has a well defined data type like
integer number, real number, a single letter, a text element and many more. The data
type is either assigned by the author of the program with a type declaration, or is detected
by the compiler itself when processing the program source code, called type inference, and
the variable’s type does never change. In this way, the compiler can check for logical
errors early in the compile process, and the compiler can reserve memory blocks
exactly customized to the variables that we want to store, so total memory
consumption and performance can be optimized. Referring again to our boxes example,
statically typing is like using customized boxes for all your goods.</p>
<p>All these types of programming languages are often called imperative programming
languages, as the program describes detailed what to do. There are other types of
programming languages too, for example languages like Prolog, which try to give only
a set of rules and then let the computer try to solve a problem with these rules. And
of course there are the new concepts of <span>artificial intelligence</span> (AI) and
<span>machine learning</span> (ML), which are less based on algorithms and more on neural
nets which are trained with a lot of data until it can provide the desired results. Nim,
the computer language this book is about, is an imperative language, so we will focus
on the imperative programming style in this book. But of course, Nim can be used to
create AI applications.</p>
<p>Further still, we can differentiate between languages like C, C++, Rust, Nim and many more
that compile to native executables and can run directly on the hardware of the
computer, contrasted with languages like Java, Scala, Julia and some more, that use a large
<span>Virtual Machine</span> (VM) as an intermediate layer between the program and the
hardware, and interpreted languages like Ruby and Python. Languages using a virtual
machine generally need some startup time when a program is invoked, as the VM must be
loaded and initialized, and interpreted languages are generally not very
fast. The distinction between languages that compile
to native executables, and those that are executed on a virtual machine, is not really sharp.
For example Kotlin and Julia where executed on a virtual machine initially, but now
can compile the source code to native executables.</p>
<p>An important class of programming languages are the so called <span>Object-Oriented-Programming</span> (OOP)
languages, which uses inheritance and dynamic dispatch, and become popular in the
1990’s. For some time it was assumed that Object-Oriented-Programming was the ultimate solution to manage
and structure really large programs. Java was the most prominent example of the OOP
languages. Java forces the programmer to use OOP design, and languages like C++,
Python or Ruby strongly push programmer to use the OPP design. Practice has shown that
OOP design is not the ultimate solution for all computing problems, and OPP design
may prevent optimal performance. So newer languages, like Go, Rust and Nim, support
some form of OOP programming, but use it only as one paradigm among many other.</p>
<p>Another popular and important class of programming languages is JavaScript and its
more modern cousins like TypeScript, Kotlin or Dart and others. JavaScript was
designed to run in web browsers to support interactive web pages and programs and
games running in the browser. In this way the program became nearly independent from
the native operating system of the computer. Note that unlike the name may indicate,
JavaScript is not closely related to the Java language. Nim can compile to a
JavaScript backend, so it supports web development well.</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Language</th>
<th>Type System</th>
<th>Runtime</th>
<th>Memory Management</th>
<th>Generics</th>
<th>Macros</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Nim</p></td>
<td><p>static, strong</p></td>
<td><p>native binaries</p></td>
<td><p>GC, Destructors, manual</p></td>
<td><p>Yes</p></td>
<td><p>AST based, hygenic</p></td>
</tr>
</tbody>
</table>

</div>
</div>
<div>
<h2 id="_why_nim">Why Nim?</h2>
<div>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
In this section we are using a lot of new Computer Science (CS) expressions but
do not explain them. That is intentional — when you already know them you may get a
better feeling of what Nim is, and when you do not know them, you will at least learn
that we can describe Nim with fancy-sounding terms.
</td>
</tr>
</tbody></table>
</div>
<p>Three well known traditional programming languages are C, Java and Python. C is
basically a simple, close-to-the-hardware language created in 1972, for which
compilers can generate fast, highly optimized native machine code, but it has cryptic
syntax, some strange semantics, and is missing higher concepts of modern languages.
Java, created in 1995, forces you strongly to the object-orientated style of
programming (OOP) and runs on a virtual machine, which makes it unsuitable for
embedded systems and microcontrollers. Python, created in 1991, is generally interpreted instead
of compiled, which makes program execution not very fast, and it does not really
allow writing low level code which operates close to the hardware. As many libraries
of the Python language are written in highly optimized C, Python can appear really fast
if a standard task, like sorting of data, processing of CSV or JSON files or web site crawling
is performed. So Python is not a bad solution when we use it mostly for calling library
functions, but it reveals its low performance when we have to write some actual Python
code in order to solve a problem.
Of course there
are many more programming languages, each with its own advantages and disadvantages — with some optimized for special use cases.</p>
<p>Nim is a state-of-the-art programming language well suited for systems and
application programming. Its clean Python-like syntax makes programming easy and fun
for beginners, without applying any restrictions to experienced systems programmers.
Nim combines successful concepts from mature languages like Python, Ada and Modula
with a few established features of the latest research. It offers high performance
with type and memory safety while keeping the source code short and readable. The
compiler itself and the generated executables support all major platforms including
Windows, Linux, BSD and Mac OS X. Cross-compiling to Android and other mobile and embedded devices and microcontrollers is possible, and
the JavaScript backend allows to create web apps and to run programs in web browsers.
The custom package managers, Nimble or Nimph, makes
use and redistribution of programs and libraries easy and secure. Nim supports
various &#34;backends&#34; to generate the final code. The C, C++ and LLVM-based backends
allow easy OS library calls without additional glue code, while the JavaScript
backend generates high quality code for web applications. The integrated
&#34;Read/Eval/Print Loop&#34; (REPL), &#34;Hot code reloading&#34;, incremental compilation (expected for version 1.8), and
support of various development environments including debugging and language server
protocols makes working with Nim productive and enjoyable.</p>
<div>
<h3 id="_some_facts_about_nim">Some Facts About Nim</h3>
<div>
<ul>
<li>
<p>Nim is a multi-paradigm programming language. Unlike some popular programming
languages, Nim doesn’t focus on the OOP paradigm. It’s mainly a imperative and procedural
programming language, with varying support for OOP, data-orientated, functional, declarative, concur-
rent, and other programming styles. Nim supports common OOP features, including inheritance,
polymorphism, and dynamic dispatch.</p>
</li>
<li>
<p>The generated executables are dependence free and small: a simple
chess program with a plain GTK-based graphical user interface is only 100 kB in size
and the size of the Nim compiler executable itself is about 6.5 MB. It is possible to
shrink the executable size of &#34;Hello World&#34; programs to about 10 kB for use on tiny
microcontrollers.</p>
</li>
<li>
<p>Nim is fast. Generally performance is very close to other
high-performance languages such as C or C++. There are some exceptions still: other
languages may have libraries or applications that have been tuned for performance for
many years, while similar Nim applications are so far less tuned for performance, or
maybe are more written with a priority of short and clean code or run-time safety.</p>
</li>
<li>
<p>Clean Python-like syntax with significant white-space, no need for block delimiters like
<span>{}</span> or <span>begin/end</span> keywords, and no need for statement delimiters like
<span>;</span></p>
</li>
<li>
<p>Safety: Nim programs are type- and memory-safe — memory corruption is prevented by
the compiler as long as unsafe low level constructs like casts, pointers and the addr operator
or the {.union.} pragma are not used.</p>
</li>
<li>
<p>Fast compiler. The Nim compiler can compile itself and other medium-size packages
in less than 10 seconds, and upcoming incremental compilation will increase that
speed further.</p>
</li>
<li>
<p>Nim is statically typed: each object and each variable has a well-defined type,
which catches most programming errors already at compile time, prevents run-time
errors, and ensures highest performance. At the same time the statically typing
makes it easier to understand and to maintain larger code bases.</p>
</li>
<li>
<p>Nim supports various memory management strategies, including manually
allocations for critical low-level tasks as well as various garbage collectors
including a destructor based, fully deterministic memory manager.</p>
</li>
<li>
<p>Nim produces native, highly optimized executables and can also generate
JavaScript output for web applications.</p>
</li>
<li>
<p>Nim has a clean module concept which helps to structure large projects.</p>
</li>
<li>
<p>Nim has a well-designed library which supports many basic programming tasks.
The full source code of the library is included and can be viewed easily from within
the HTML-based API documentation.</p>
</li>
<li>
<p>Library modules like the OS module provides OS independent abstractions, which allows
to compile and run the same program on different operating system without modifications.</p>
</li>
<li>
<p>The Nim standard library is supported by more than 1000 external packages for a broad range
of use cases.</p>
</li>
<li>
<p>Asynchronous operation, threading and parallel processing is supported.</p>
</li>
<li>
<p>Nim supports all popular operating systems like Linux, Windows, MacOS and Android.</p>
</li>
<li>
<p>Usage of external libraries written in C is easy and and occurs directly
without any glue code, and Nim can even work together with code written in other
languages, for example there are some Nim &lt;-&gt; Python interfaces available.</p>
</li>
<li>
<p>Many popular editors have support for Nim syntax highlighting and other
IDE functionality like on-the-fly checking for errors and displaying detailed
information about imported functions and data types.</p>
</li>
<li>
<p>In the last few years Nim has reached some important milestones: Version 1.0
with some stability promises was released, and with the ARC and ORC
memory management strategies and full destructor support fully deterministic
memory management comparable to memory management in C++ or Rust
is available. So problems of conventional garbage collectors like delayed memory
deallocation or longer pausing of programs due to the GC process are gone. And some
larger companies have started using Nim in production, the most important
may be currently the Status Corp. with their Etherium client development.</p>
</li>
</ul>
</div>
</div>
<div>
<h3 id="_nim_supports_many_programming_styles">Nim supports many programming styles</h3>
<p>We mentioned already that
Nim is a multi-paradigm programming language, that supports
various programming styles. While we may regard Nim in
first line as an imperative, procedural programming language, it supports the popular functional
and object-orientated programming styles well.</p>
<p>In classical OOP programming languages, we have the concept of <span>classes</span> with <span>attributes</span>, and methods that are very closely bound to
the classes, as in Python:</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>User</span><span>:</span>
  <span>def</span> <span>say</span><span>(</span><span>self</span><span>):</span>
    <span>print</span><span>(</span><span>&#34;It does not work!&#34;</span><span>)</span>

<span>user</span> <span>=</span> <span>User</span><span>()</span>
<span>user</span><span>.</span><span>say</span><span>()</span></code></pre>
</div>
</div>
<p>In this Python snippet, we declare a class User, with a custom method named <span>say()</span>
bound to this class. Then we create an instance variable of this class and call
its say() method.</p>
<p>This tight bounding of methods to classes is not very flexible, e.g. extending the set
of methods of a class may be difficult or impossible. Another problem with such a class concept
is, that it is not always clear to which class a method belongs when more than just one single
class is involved: Imagine that we need a method that appends a single character to a text string.
Is that method a member of the character class, or a member of the text string class?</p>
<p>Nim avoids such a strict class concept, while its generalized <span>method call syntax</span> allows us
to use a class like syntax for all of our data types: e.g. to get the length of a string variable, we can
write len(myString) in classic procedural notation, or we can use the method syntax myString.len()
or just myString.len. The compiler regards all these notations as equivalent, so we have
the method syntax available without the restrictions of the class concept. The method call syntax
can be used in Nim for all data types, even for plain numbers — so the notations abs(myNum)
is fully equivalent with myNum.abs.</p>
<p>The Python code from
above may look in Nim like</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span> <span>User</span> <span>=</span> <span>object</span>

<span>proc </span><span>say</span><span>(</span><span>self</span><span>:</span> <span>User</span><span>)</span> <span>=</span>
  <span>echo</span> <span>(</span><span>&#34;It does not work!&#34;</span><span>)</span>

<span>let</span> <span>user</span> <span>=</span> <span>User</span><span>()</span>
<span>user</span><span>.</span><span>say</span><span>()</span></code></pre>
</div>
</div>
<p>Instead of the classes we use object types in Nim, and we define procedures and methods
that can work on objects or other data types.</p>
<p>As an example for the functional programming style in Nim we may
look at some code fragment from a real world app that has to generate
a string from four numbers, separated by commas. Using the mapIt()
procedure imported from the <span>sequtils</span> module and
the fmt() macro from the <span>strformat</span> module, we may write
that in functional programming style in this way:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>strutils</span> <span>import</span> <span>join</span>
<span>from</span> <span>sequtils</span> <span>import</span> <span>mapIt</span>
<span>from</span> <span>strformat</span> <span>import</span> <span>fmt</span>
<span>const</span> <span>DefaultWorldRange</span> <span>=</span> <span>[</span><span>0.0</span><span>,</span> <span>0</span><span>,</span> <span>800</span><span>,</span> <span>600</span><span>]</span>
<span>let</span> <span>str</span> <span>=</span> <span>DefaultWorldRange</span><span>.</span><span>mapIt</span><span>(</span><span>fmt</span><span>(</span><span>&#34;{it:g}&#34;</span><span>)).</span><span>join</span><span>(</span><span>&#34;, &#34;</span><span>)</span>
<span>echo</span> <span>str</span> <span># &#34;0, 0, 800, 600&#34;</span></code></pre>
</div>
</div>
<p>In the imperative, procedural style we would write it like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>str</span><span>:</span> <span>string</span>
<span>for</span> <span>i</span><span>,</span> <span>x</span> <span>in</span> <span>pairs</span><span>(</span><span>DefaultWorldRange</span><span>):</span>
  <span>str</span><span>.</span><span>add</span><span>(</span><span>fmt</span><span>(</span><span>&#34;{x:g}&#34;</span><span>))</span>
  <span>if</span> <span>i</span> <span>&lt;</span> <span>DefaultWorldRange</span><span>.</span><span>high</span><span>:</span>
    <span>str</span><span>.</span><span>add</span><span>(</span><span>&#34;, &#34;</span><span>)</span></code></pre>
</div>
</div>
</div>
<div>
<h3 id="_nim_is_efficient">Nim is Efficient</h3>
<p>Nim is a compiled and statically-typed language. While for interpreted,
dynamically-typed languages like Python we have to run every statement to check even
for trivial errors, the Nim compiler checks for most errors during the compile
process. The static typing together with the well-designed Nim type system allows the
compiler to catch most errors already in the compile phase, like the undefined
addition of a number and a letter, and to report the errors in the terminal window or
directly in the editor or IDE. When no errors are found or all errors have been
fixed, then the compiler generates highly optimized dependency free executables. And
this compilation process is generally really fast, for example the compiler compiles
itself in maybe 10 to 30 seconds on a typical modern PC.</p>
<p>Modern concepts like zero-overhead iterators, compile-time evaluation of user-defined
functions and cross-module inlining in combination with the preference of
value-based, stack-located data types leads to extremely efficient code.
Multi-threading, asynchronous input/output operations (async IO), parallel processing
and SIMD instructions including GPU execution are supported. Various memory
management strategies exists: selectable and tuneable high performance
<span>Garbage Collectors</span> (GC), including a new fully deterministic destructor
based GC, are supported for automatic memory management. These can be disabled for
manual memory management. This makes Nim a good choice for application development
and close-to-the-hardware system programming at the same time. The unrestricted
hardware access, small executables and optional GC will make Nim a perfect solution
for embedded systems, hardware driver and operating system development.</p>
</div>
<div>
<h3 id="_nim_is_expressive_and_elegant">Nim is Expressive and Elegant</h3>
<p>Nim offers a modern type system with templates, generics and type inference. Built-in
advanced data types like dynamic containers, sets, and strings with full UTF support
are completed by a large collection of library types like hash tables and regular
expressions. While the traditional Object-Oriented-Programming programming style with inheritance and
dynamic dispatch is supported, Nim does not enforce this programming paradigm and
offers modern concepts, like procedural and functional programming.
The optional method call syntax allows to use all data types and functions in
an OOP like fashion, e.g. instead of len(myStr) we can also use the OOP style myStr.len.
The powerful
AST-based hygienic macro system offers nearly unlimited possibilities for the
advanced programmer. This macro and meta-programming system allows compiler-guided
code generation at compile time, so the Nim core language can be kept small and
compact, while many advanced features are enabled by user defined macros. For example
the support of asynchronous IO operations has been created with these forms of
meta-programming, as well as many Domain Specific Language (DSL) extensions.</p>
</div>
<div>
<h3 id="_nim_is_open_and_free">Nim is Open and Free</h3>
<p>The Nim compiler and all modules of the standard library are implemented in Nim. All source
code is available under the less restricted MIT license.</p>
</div>
<div>
<h3 id="_nim_has_a_friendly_and_helpful_growing_community">Nim has a friendly and helpful growing community</h3>
<p>The Nim forum is hosted at:</p>

<p>and the software running the forum is coded in Nim.</p>
<p>Real-time chat is supported by IRC, Gitter, Discord, Telegram and others.</p>
<p>Nim is also supported by Reddit.com and Stackoverflow.com:</p>

</div>
<div>
<h3 id="_nim_has_a_encouraging_future">Nim has a encouraging future</h3>
<p>Started more than 12 years ago as a small community project of some bright CS
students led by <span>Mr. A. Rumpf</span>, it is now considered as one of the most
interesting and promising programming languages, supported by countless individuals
and leading companies of the computer industry, for instance, it’s actively used in the areas of application, game, web
and crypto-currency development. Nim has made a large amount of progress in the last few years:
it reached version Nim v1.6 with some stability guarantees and a new deterministic memory
management system was introduced, which will improve support of parallel processing
and the use of Nim in the area of embedded systems development.</p>
</div>
<div>
<h3 id="_why_is_nim_not_a_popular_mainstream_language_yet">Why is Nim not a popular mainstream language yet?</h3>
<p>Nim was created by Mr. A. Rumpf in 2008, supported by a few volunteers. Finally, in
2018 Nim got some significant monetary support by <span>Status Corp.</span> and in 2019
the stable Nim version 1.0 was released. But still Nim is developed by a small core team
and some volunteers, while some other languages like Java, C#, Go, or Rust are
supported by large companies, or like C and C++ have a very long history and
well-trained users. And finally there are many competing languages, some with a
longer history, and some maybe better suited for special purposes, like JavaScript,
Dart or Kotlin for web development, Julia or R for numeric applications, or Zig, C and
Assembly for the tiny 8-bit microcontrollers with a small amount of RAM.</p>
<p>Nim is already supported by more than 1000 external packages which cover many
application areas, but that number is still small compared to really popular
languages like Python, Java or JavaScript. And some Nim packages can currently not
really compare with the libraries of other languages, which have been optimized for
years by hundreds or thousands of full-time developers.</p>
<p>Indeed the future of Nim is not really secure. Core developers may vanish, financial
support may stop, or maybe a better language may appear. But even if the development
of Nim should stop some day, you will still be able to use it, and many concepts that
you may have learned with Nim can be used with other modern languages too.</p>
</div>
<div>
<h3 id="_is_nim_a_good_choice_as_first_language_for_a_beginner">Is Nim a good choice as first language for a Beginner?</h3>
<p>When you use C as your first language, you may learn well how computers
really work, but the learning experience is not that nice, progress is slow and
C lacks many concepts of modern programming languages. C++, Rust or
Haskell are really too difficult for beginners. So currently many starts with Python.
While you can learn high level concepts well with Python and you get useful results fast,
you learn not much about the internal working of computers. So you may never
understand why your code is slow and consumes so much resources, and you
will have no idea how to improve the program or how you could run
it successfully on restricted hardware.
It’s like learning
to drive a car, without any knowledge about how a combustion engine, the
transmission, or the brakes really work. Nim has none of these restrictions, as
we have high level concepts available like in Python, but we have access to
low level stuff too, so we can really understand the internal workings, if we want.
Learning resources for Nim are still not that good as for mainstream languages,
but there exists some nice tutorials already, and hopefully this book will help beginners also a bit.</p>
</div>
<div>
<h3 id="_is_nim_really_a_good_teaching_language">Is Nim really a good teaching language?</h3>
<p>Generally yes, in the same way as Pascal was in the 1980’s, and Modula/Oberon were
at the end of the last century. But Nim still has the same problems
as the wirthian languages: They do not really help with finding a job. When we teach
the kids some JavaScript or C, they may find at least a simple employment when they
have to leave the intended education path early for some reason. With niche languages
this is unfortunately not the case, so teachers should know about their responsibility.
And of course teaching against the interests of the kids makes not much sense. When
they want to learn some JavaScript to make some visual effects or whatever easily, then it
is hard to teach another language which may be not immediately available on the PC at home or
their smartphone.</p>
</div>
<div>
<h3 id="_so_is_nim_really_the_best_start_for_me">So is Nim really the best start for me?</h3>
<p>Maybe not. When you intend to learn a programming language today
and make a great video game tomorrow, then definitely not. This
is just not possible. While there are nice libs for making games
with Nim already available, there exists easier solutions
in other languages. With some luck you may find some source code
for that languages, so that you can patch a few strings
and maybe modify some colors and the background music and call it your game.</p>
</div>
<div>
<h3 id="_after_learning_nim_will_i_still_have_to_learn_other_programming_languages">After learning Nim, will I still have to learn other programming languages?</h3>
<p>Nim is a quite universal language, so it is a good candidate for
someone who intends to learn only one single language. But of course it
is always a good idea to learn a few other languages later. Generally we can not
really avoid learning C, as so much C code exists world wide. Most algorithm that have
ever been invented are available as a C implementation somewhere, and most
libraries are written in C or have at least a C API, which you can use from other languages including
Nim. As C is a small language without difficult language constructs, some minimal C
knowledge is generally sufficient to convert a C program to another language. Often that
conversion process is supported by tools, like the Nim c2nim tool. So learning some C later
is really a good idea, and when you have some basic understanding of Nim and CS in general,
learning some C is an easy task. Learning C before Nim would be an option still, as for
C more learning resources exists. So years ago some people recommended learning C or Python
before Nim. But Nim has enough learning resources now, so we recommend indeed starting with
Nim directly.</p>
</div>
<div>
<h3 id="_why_should_i_not_use_nim">Why should I not use Nim?</h3>
<p>Maybe it is just not the ideal solution for you. A racing bicycle or a mountain bike are
both great devices, but for cycling a few hundred meters to the bakers shop both may
be not the perfect solution. A plain old bicycle would do better. Even as Nim
seems to join the benefits of a racing bicycle and a mountain bike well — high performance and
robust design — and is not expensive, it is just not the optimal solution for everybody.
People who write only tiny scripts and have not to care about performance can continue
using Python. People who are only interested in special applications, maybe only
in web development or only in tiny 8 bit microcontrollers may not really need Nim. Nim can
do this and much more well, but for special use cases better suited languages may still
exist. And someone who has managed to learn C++ really well over a period of
many years may decide to continue with C++ also. Currently another possible reason for not using Nim
can be missing libraries. When you need some important libraries for your project, and
these are currently not available for Nim, this can be of course a big problem in the case that you
have not the skills or the time to write them from scratch or at least create high level bindings
to a C library.</p>
</div>
</div>
</div>
<div>
<h2 id="_our_first_nim_program">Our first Nim Program</h2>
<div>
<p>To keep our motivation, we will present a first tiny Nim program now. Actually we
should have delayed this section until we have installed the Nim compiler on our
computer, but we can already run and test the program by just copying it into one of
the available Nim online playgrounds like</p>

<p>In the section <a href="#_what_is_an_algorithm">What is an Algorithm?</a> we described an algorithm to sum up the
first 100 natural numbers. Converting that algorithm into a Nim program is
straightforward and results in the text file below. You can copy it into the
playground and run it now if you want. The program is built using some elementary Nim
instructions for which we will give only a very short description here. Everything is
explained in much more detail in the next part of this book.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>sum</span><span>:</span> <span>int</span>
<span>var</span> <span>i</span><span>:</span> <span>int</span>
<span>sum</span> <span>=</span> <span>0</span>
<span>i</span> <span>=</span> <span>0</span>
<span>while</span> <span>i</span> <span>&lt;</span> <span>100</span><span>:</span>
  <span>inc</span><span>(</span><span>i</span><span>,</span> <span>1</span><span>)</span>
  <span>inc</span><span>(</span><span>sum</span><span>,</span> <span>i</span><span>)</span>
<span>echo</span> <span>sum</span></code></pre>
</div>
</div>
<p>We write Nim programs with an editor tool in the form of plain text files, and you will learn how to
create them soon. We call these text files the <span>source code</span> of the program.
The source code is the input for the compiler. The compiler processes the source
code, checks it for obvious errors and then generates an executable file, which
contains the final CPU instructions and can be run. Executable files are sometimes
called executables or binary files. The term binary is misleading, as all files on
computers are indeed stored as binary data, but the expression &#34;binary&#34; is used to
differentiate the executable program from text files like the Nim source code which
we can read, print and edit in an editor. Don’t try to load the executable files
generated by the Nim compiler into a text editor, as the content is not plain text,
but numeric machine code that may confuse the editor. On the Windows OS, executable
files generally get a special name extension <span>.exe</span>, but on Linux no special
name extensions are used.</p>
<p>Nim source code files are processed by the Nim compiler from the top to the bottom, and
for the generated executable the program execution also starts in principle at the top.
But for the program execution there exists some exceptions, e.g. program code enclosed in functions
is not immediately executed where it appears in the program source code file, but later
when the function is called. And the program execution is not a linear process — we can use
conditional expressions to skip parts of the program, or various loop constructs to repeat
the execution of some program segments. Generally the program execution in Nim is more
similar to languages like Python or Ruby than to the C language: A C program always
needs a main() function with exactly this name, and the execution of a C program
always starts by a compiler generated call of this function.</p>
<p>Elementary entities of computer programs are variables, which are basically named
storage areas in the computer. As Nim is a compiled and statically-typed language, we
have to declare each variable before we can use it. We do that by choosing a
meaningful name for the variable and specifying its data type. To tell the compiler
about our intention to declare a variable, we start the line with the <span>var</span>
keyword, followed by the chosen name, a colon and the data type of our variable. The
first line of our program declares a new variable named <span>sum</span> of data type <span>int</span>. Int is
short for integer and indicates, that our variable should be able to store negative or
positive integer numbers. The <span>var</span> at the start of the line is a
<span>keyword</span>. Keywords are reserved symbols which have a special meaning for the
compiler. Var indicates that we want to introduce a new variable. The compiler will
recognize that and will reserve a memory location in the RAM of the computer which
can store the actual value of the variable.</p>
<p>The second line is nearly identical to the first line: we declare another variable
again with <span>int</span> type and plain name <span>i</span>. Variable names like i, j, k are often used when
we have no idea for a meaningful name and when we intend to use that variable as a
counter in a loop.</p>
<p>In the lines 3 and 4 of our program we initialize the variables, that is, we give
them a well-defined initial value. To do that we use the <span>=</span> operator to
assign it a value. Operators are special symbols like <span>+</span>, <span>-</span>,
<span>*</span> or <span>/</span> to indicate our desire to do an addition, a subtraction, a
multiplication or a division. Note that the <span>=</span> operator is used in Nim like
in many other programming languages for assignment, and not like in traditional
mathematics as an equality test. The reason for that is that in computer programming,
assignments occur more often than equality tests. Some early languages like Pascal
use the compound <span>:=</span> operator for assignment, which may be closer to
mathematics use, but is more difficult to type on a keyboard and looks not too nice
for most people. An expression like <span>x = y</span> assigns the content of variable y
to x, that is, x gets the value of y, the former value of x is overwritten and lost,
and the content of y remains unchanged. After that assignment, x and y contain the
same value. In the above example we do not assign the content of a variable to the
destination, but instead use a literal numeric constant with value <span>0</span>. When the
computer has executed lines 3 and 4 the variables sum and i each contain the start
value <span>0</span>.</p>
<p>Line 5 is much more interesting: it contains a <span>while</span> condition. The line
starts with the term <span>while</span>, which is again a reserved keyword, followed by
the logical expression <span>i &lt; 100</span> and a colon. An expression in Nim is
something which has a result, like a math expression as <span>2 + 2</span> which has the
result 4 of type integer. A logical expression has no numerical result, but a logical (boolean)
one, which can be <span>true</span> or <span>false</span>. The logical expression <span>i &lt;
100</span> depends on the actual content of variable <span>i</span>. The two lines following
the line with the <span>while</span> keyword are each indented by two spaces, meaning
that these lines start with two spaces more than the line before. That form of
indentation is used in Nim (and Python) to indicate blocks. Blocks are grouped statements. The
complete while loop consists of the line containing the <span>while</span> keyword followed by a
block of statements. The block after the <span>while</span> condition is executed as long as the
<span>while</span> condition evaluates to the logical value <span>true</span>. For the first loop iteration <span>i</span> has the
initial value <span>0</span>, the condition <span>i &lt; 100</span> evaluates to the boolean value <span>true</span>
and the block after the <span>while</span> condition is executed for the first time. In
the following block we have the <span>inc()</span> instruction. <span>inc</span> is short
for increment. <span>inc(a, b)</span> increases the value of <span>a</span> by <span>b</span>, <span>b</span> remains unchanged. So
in the above block <span>i</span> is increased by one, and after that <span>sum</span> is
increased by the current value of <span>i</span>. So when that block has been executed for the
first time <span>i</span> has the value <span>1</span> and <span>sum</span> also has the value
<span>1</span>. At the end of that block execution starts again at the line with the
<span>while</span> condition, now testing the expression <span>i &lt; 100</span> with <span>i</span>
containing the value <span>1</span>. Again it evaluates to <span>true</span>, the block is
executed again, <span>i</span> gets the new value <span>2</span>, and <span>sum</span> gets the
value <span>3</span>. This process continues until <span>i</span> has the value <span>100</span>,
so the condition <span>i &lt; 100</span> evaluates to <span>false</span> and execution proceeds
with the first instruction after the <span>while</span> block. That instruction is an
<span>echo</span> statement, which is used in Nim to write values to the terminal or
screen of the computer. Some other languages use the term <span>print</span> or
<span>put</span> instead of <span>echo</span>.</p>
<p>Don’t worry if you have not understood much of this short explanation, we will
explain all that in much more detail later.</p>

</div>
</div>
<div>
<h2 id="_binary_numbers">Binary Numbers</h2>
<div>
<p>When we write numbers in ordinary life we generally use the decimal system with base
10 and the 10 available digits 0, 1, …​ 9. To get the value of a decimal number we
multiply each digit with powers of 10 depending on the position of the digit and sum
the individual terms. The rightmost digit is multiplied with 10^0, the next digit
with 10^1, and so on. A literal decimal number like 7382 has then the numerical
value <span>2 * 10^0 + 8 * 10^1 + 3 * 10^2 + 7 * 10^3</span>. We have used here the
exponential operator <span>^</span> — with <span>10^3 = 10 * 10 * 10</span>. Current
computers use binary representation internally for numbers. Generally we do not care
much about that fact, but it is good to know some facts about binary numbers. Binary
numbers work nearly identically to decimal numbers. The distinction is that we have
only two available digits, which we write as <span>0</span> and <span>1</span>. A number in
binary representation is a sequence of these two digits. Like in the decimal system,
the numerical value results from the individual digits and their position: The binary
number <span>1011</span> has the numerical value <span>1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1
* 2^3</span>, which is 11 in decimal notation. For binary numbers the base is 2, so we
multiply the binary digits by powers of two. Formally addition of two binary numbers
works like we know it from the decimal system: we add the matching digits and take
carry into account: <span>1001 + 1101 = 10110</span> because we start by adding the two
least significant digits of each number, which are both 1. That addition 1+1 results
in a carry and result 0. The next two digits are both zero, but we have to take the
carry from the former operation into account, so result is 1. For the next position
we have to add 0 and 1, which is just 1 without a carry. And finally we have 1 + 1,
which results in 0 with a carry. The carry generates one more digit, and we are done.
In the decimal system with base 10 a multiplication with 10 is easily calculated by
just shifting all digits one place to the left and writing a 0 at the now empty
rightmost position. For binary numbers it is very similar: a multiplication by the
base, which is two in the binary system, is just a shift left, with the rightmost
position getting digit 0.</p>
<p>In the binary system we call the digits often <span>bits</span>, and we number the bits
from right to left, starting with 0 for the rightmost bit — we say that the binary
number 10010101 is an 8-bit number because writing that number in binary
representation needs 8 digits. Often we imagine the individual bits as small bulbs, a
1 bit is imagined as a lit bulb, and a 0 bit is imagined as a dark bulb. For lit
bulbs we say also that the bit is set, meaning that in the binary number 10010101,
bits 0, 2, 4 and 7 are set, and the other bits are unset or cleared.</p>
<p>Groups of 8 bits are called a <span>byte</span>, and sometimes 4 bits are called a
<span>nibble</span>.</p>
<p>One, two, four or 8 bytes are sometimes called a <span>word</span>, where a word is an
entity which the computer can process in one single instruction. When we have a CPU
with 8 byte word size this means that the computer can for example add two variables,
each 8 byte in size, in one single instruction.</p>
<p>Let us investigate some basic properties of binary numbers. Let us assume that we
have an 8-bit word (a byte). An 8-bit word can have 2^8 different states, as each bit
can be set or unset independently from the other bits. That corresponds to numbers 0
up to 255 — we assume that we work with positive numbers only for now, we will come
to negative numbers soon. An important property of binary numbers in computers is the
wrapping around, which is a consequence of the fact that we have only a limited set
of bits available to store the number. So when we continuously add 1 to a number, at
some point all bits are set, which corresponds to the largest number that can be
stored with that number of bits. When we then add again 1, we get an overflow. The
run-time system may catch that overflow, so we get an overflow error, or the number
is just reset to zero, as it may happen in our car when we manage to drive one
million miles, or when the ordinary clock jumps from 23:59 to 00:00 of the next day.
An useful property of binary numbers is the fact that we can easily invert all bits,
that is replace set bits by unset ones and vice versa. Let us use the prefix
<span>!</span> to indicate the operation of bit inversion, then <span>!01001100</span> is
<span>10110011</span>. It is an obvious and useful fact that for each number x we get a
number with all bits set when we add x and !x. That is <span>x + !x = 11111111</span>
when we consider a 8 bit word. And when we ignore overflow, then it follows that
<span>x + !x + 1 = 0</span> for each number x. That is a useful property, which we can
use when we consider negative numbers.</p>
<p>Now let us investigate how we can encode negative numbers in binary form. In the
binary representation we have only two states available, 0 or 1, a set bit or an
unset bit. But we have no unitary minus sign. We could encode the sign of a number in
the topmost bit of a word — when the topmost bit is set that indicates that the
number is regarded as negative. Generally a modified version of this encoding is used,
called <span>two’s complement</span>: a negative number is constructed by first inverting all the
bits — a 0 bit is transferred into a 1 bit and vice versa — and finally the number
1 is added. That encoding simplifies the CPU construction, as subtraction can be
replaced by addition in this way:</p>
<p>Consider the case that we want to do a subtraction of two binary encoded numbers. The
operation has the symbolic notation A - B for arbitrary numbers A and B. The
subtraction is by definition the inverse operation of the addition, that is A + B - B
= A for each number A and B, or in other words, B - B = 0 for each number B.</p>
<p>Assume we have a CPU that can do additions and that can invert all the bits of a
number. Can we do subtraction with that CPU? Indeed we can. Remember the fact that
for each number X <span>X + !X + 1 = 0</span> as long as we ignore overflow. If that
relation is true for each number, than it is obviously true for each B in the
expression A - B, and we can write A - B = A + (B + !B + 1) - B = A + (!B + 1) when
we use the fact that in mathematics addition and subtraction is associative, that is
we can group the terms as we want. But the term in the parenthesis is just the
two’s complement, which we get when we invert all bits of B and add 1. So to do a subtraction
we have to invert the bits of B, and then add A and !B and 1 ignoring overflow. That
may sound complicated, but bit inversion is a very cheap operation in a CPU, which is
always available, and adding 1 is also a very simple operation. The advantage is that
we do not need separate hardware for the subtraction operation. Generally
subtraction in this way is not slower than addition because the bit inversion and the
addition of 1 can be performed at the same time in the CPU as an ordinary addition.</p>
<p>From the equation above indicating A - B = A + (!B + 1) it is obvious that we
consider the two’s complement (!B + 1) as the negative of B. Note that the two’s complement of zero
is again zero, and two’s complement of 00000001 is 11111111. All negative numbers in this
system have a bit set to 1 at the leftmost position. This restrict all positive
numbers to all the bit combinations where the leftmost bit is unset. For an 8-bit
word this means that positive numbers are restricted to the bits 00000000 to
01111111, which is the range 0 to 127 in decimal notation. The two’s complement of decimal
127 is 10000001. Seems to be fine so far, but note there exists also the bit pattern
10000000 which is -128 in decimal. For that bit pattern there exists no positive
value. If we try to build the two’s complement of that bit pattern, we would get the same
pattern again. This is an asymmetry of two’s complement representation, which can not be
avoided. It generally is no problem, with one exception. We can never invert the sign
of the smallest available integer; that operation would result in a run-time
error.</p>
<p>Summary: when we work only with positive numbers, we can store in an 8-bit word,
which is generally called a byte, numbers from 0 up to 255. In a 16-bit word we could
store values from 0 up to 2^16 - 1, which is 65535. When we need numbers which can be
also negative we have for 8-bit words the range from -128 to 127 available, which is
-2^7 up to 2^7 - 1. For a signed 16-bit word the range would be -2^15 up to 2^15 - 1.</p>
<p>While we can work with 8 or 16-bit words, for PC programming the CPU usually supports
32 or 64 bit words, so we have a much larger number range available. But when we
program microcontrollers or embedded devices we may indeed have only 8 or 16-bits words
available, or we may use such small words size intentionally on a PC to fit all of
our data into a smaller memory area.</p>
<p>One important note at the end of this section: whenever we have a word with a
specific bit pattern stored in the memory of our computer, then we can not decide
from the bit pattern directly what type of data it is. It can be a positive or a
negative number, but maybe it is not a number at all but a letter or maybe something
totally different. As an example consider this 8 bit word: 10000001. It could be 129
if we have stored intentionally positive numbers in that storage location, or could
be -127 if we intentionally stored a negative value. Or it could be not a number at
all. Is that a problem? No it is not as long as we use a programming language like
Nim which use static typing. Whenever we are using variables we declare their type
first, and so the compiler can do bookkeeping about the type of each variable stored
in the computer memory. The benefit is, that we can use all the available bits to
encode our actual data, and we do not have to reserve a few bits to encode the actual
data type of variables. For languages without static typing that is not the case. In
languages like Python or Ruby we can use variables without a static type, so we can
assign whatever we want to it. That seems to be comfortable at first, but can be
confusing when we write larger programs and the Python or Ruby interpreter has to do
all the bookkeeping at run-time, which is slow and wastes memory for the bookkeeping.</p>
<p>To say it again in other words: for deciding if an operation is valid, it is
generally sufficient to know the data type of the operands only. We do not have to
know the actual content. The only exception is if we invert the sign of the most
negative integer number or if we do an operation with causes an overflow, as there
are not enough bits available to store the result — we may get a run-time error for
that case. In a
statically-typed language each variable has a well-defined type, and the compiler can
ensure at compile time that all operations on that variables are valid. If an
operation is not valid then the compiler will give an error message. Then when these
operations are executed at run-time they are always valid operations, and the actual
content, like the actual numeric value, does not matter.</p>
</div>
</div>
<div>
<h2 id="_hexadecimal_numbers">Hexadecimal Numbers</h2>
<div>
<p>These number type with base 16 is by far not that important than the binary numbers,
and it has not really a technical justification to exist, but you may get in touch
with these numbers from time to time. Hexadecimal numbers are mostly a legacy from
early days of computers, where computer programming was done not in real programming
languages but with numeric codes. To represent the 16 hexadecimal digits the 10
decimal digits are supported by the characters &#39;A&#39; .. &#39;F&#39;. The most important
property of a hexadecimal digit is that it can represent four bits, a unit halve of a
byte which is called sometimes a nibble. In old times when it was necessary to type
in binary numbers it was sometimes easier to encode a nibble with a hexadecimal
digit:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Decimal</th>
<th>Binary</th>
<th>Hexadecimal</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>0000</p></td>
<td><p>00</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>0001</p></td>
<td><p>01</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>0010</p></td>
<td><p>02</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>0011</p></td>
<td><p>03</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>0100</p></td>
<td><p>04</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>0101</p></td>
<td><p>05</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>0110</p></td>
<td><p>06</p></td>
</tr>
<tr>
<td><p>7</p></td>
<td><p>0111</p></td>
<td><p>07</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>1000</p></td>
<td><p>08</p></td>
</tr>
<tr>
<td><p>9</p></td>
<td><p>1001</p></td>
<td><p>09</p></td>
</tr>
<tr>
<td><p>10</p></td>
<td><p>1010</p></td>
<td><p>0A</p></td>
</tr>
<tr>
<td><p>11</p></td>
<td><p>1011</p></td>
<td><p>0B</p></td>
</tr>
<tr>
<td><p>12</p></td>
<td><p>1100</p></td>
<td><p>0C</p></td>
</tr>
<tr>
<td><p>13</p></td>
<td><p>1101</p></td>
<td><p>0D</p></td>
</tr>
<tr>
<td><p>14</p></td>
<td><p>1110</p></td>
<td><p>0E</p></td>
</tr>
<tr>
<td><p>15</p></td>
<td><p>1111</p></td>
<td><p>0F</p></td>
</tr>
</tbody>
</table>
<p>The only location where we hear about hexadecimal characters again in this book
should be when we introduce the character and string data types — there control
characters like a newline character are sometimes specified in hexadecimal form like
&#34;\x0A&#34; for a newline character.</p>
</div>
</div>
<div>
<h2 id="_installation_of_the_compiler">Installation of the Compiler</h2>
<div>
<p>We will not describe in too much detail how you can install the Nim compiler, because
that strongly depends on your operating system, and because the install instructions
may change in the future. We assume that you have a computer with an installed
operating system and internet access, and you are able to do at least very basic
operations with your computer, such as switching it on, log in and and opening a web
browser or a terminal window. If that is not the case then you really should ask
someone for help for this basic step, and maybe for some more help for other basic
tasks.</p>

<p>If you are using a Linux operating system, then your system generally provides a
package manager, which should make the installation very easy.</p>
<p>For example for a Gentoo Linux system you would open a root terminal and simple type
<span>emerge -av nim</span>. That command would install Nim including all necessary dependencies
for you. It may take a few minutes as Gentoo compiles all packages fresh from source
code, but then you are done. Similar commands exist for most other Linux
distributions.</p>
<p>Another solution, which is preferable when you want to ensure that you get the most
recent Nim compiler, is compiling directly from the latest git sources. That process
is also easy and is described here: <a href="https://github.com/nim-lang/Nim">https://github.com/nim-lang/Nim</a>. But before you
can follow those instructions you have to ensure that the git software and a working
C compiler is available on your computer.</p>
</div>
</div>
<div>
<h2 id="_creation_of_source_code_files">Creation of Source Code Files</h2>
<div>
<p>Nim source code, as most source code of other programming languages, is based on text
files. Text files are documents saved on your computer that contain only ordinary
letters which you can type on your keyboard. No images or videos, no HTML content
with fancy CSS styling. Generally source code should contain only ordinary ASCII
text, that is no umlauts or unicode characters.</p>
<p>To create source code we generally use a text editor, which is a tool designed for
creating and modifying of plain text files. If you do not have a text editor yet you
may also use a word processor for writing some source code, but then you have to
ensure that the file is finally saved as plain ASCII text. Editors generally support
syntax highlighting, that is keywords, numbers and such are displayed with a unique
color or style to make it easier to recognize the content. Some editors support
advanced features like checking for errors while you type the program source code.</p>

<p>If you do not want to use a special editor now, then for Linux gedit or at least
<span>nano</span> should be available. For Windows maybe something like notepad.</p>
<p>Generally we store our Nim source code files in its own directory, that is a separate
section of your hard-disk. If you work on Linux in a terminal window, then you can
type</p>
<div>
<div>
<pre>cd
mkdir mynimfiles
cd mynimfiles
gedit test.nim</pre>
</div>
</div>
<p>You type these commands in the terminal window and press the <span>return</span> key
after each of the above lines — that is you type <span>cd</span> on your keyboard and
then press the <span>return</span> key to execute that command. The same for the next
three commands. What you have done is this: you go to your default working area
(home directory), then create a subarea named mynimfiles, then you go into that
subarea and finally you launch the gedit editor — the argument test.nim tells gedit
that you want to create a new file called test.nim. If gedit is not available, or if
you work on a computer without a graphical user interface, then you may replace the
gedit command by nano. While gedit opens a new window with a graphical interface,
nano opens only a very simple interface in the current terminal. An interesting
editor without a GUI is vim or neovim. That is a very powerful editor, but it is
difficult to learn and it is a bit strange as you have a command mode and an ordinary
text input mode available. For neovim there is very good Nim support available.</p>
<p>If you do not want to work from a terminal, or if you are using Windows or MAC OS,
then you should have a graphical user interface which enables you also to create a
directory and to launch an editor.</p>
<p>When the editor is opened, you can type in the Nim source code from our previous
example and save it to a file named test.nim. Then you can terminate the editor.</p>
<p>Note that the <span>return</span> key behaves differently in editors than in the terminal
window: In the terminal window you type in a command and finally press the return key
to &#34;launch&#34; or execute the command. In an editor the return key is not that special:
if you press ordinary keys in your editor, than that key is inserted and the cursor
moves one position to the right. And when you press the return key then an invisible
newline character is inserted and the cursor moves to the start of the next line.</p>
</div>
</div>
<div>
<h2 id="_launching_the_compiler_and_running_the_program">Launching the compiler and running the program</h2>
<div>
<p>If you are working from a Linux terminal then you can type</p>

<p>That is you first show the content of your directory with the ls command and then
display the content of the Nim source code file that you just have typed in with the
cat command.</p>
<p>Now type</p>

<p>That invokes the Nim compiler and instructs it to compile your source code. The &#34;c&#34;
letter is called an option, it tells the Nim compiler to compile your program and to
use the C backend to generate an executable.</p>
<p>The compiler should display nearly immediately a success message. If it displays some
error messages instead, then you launch gedit or nano again, fix your typing error,
save the modified file and call the compiler again.</p>
<p>Finally, when the source text is successfully compiled, you can run your program by
typing</p>

<p>In your terminal window you see a number now, which is the sum of the numbers 1 to
100.</p>

<p>If you have not managed to open a terminal where you can invoke the compiler — well
maybe then you should install some of the advanced editors like VS-Code. They should
be able to launch the compiler and run the program from within the editor directly.</p>
<p>The command</p>

<p>is the most basic compiler invocation. The extension .nim is optional, the compiler
can infer that file extension. This command compiles our program in default debug mode, it
uses the C compiler back end and generates a native executable. Debug mode means,
that the generated executable contains a lot of checks, like array index checks,
range checks, nil dereference checks and many more. The generated executable will run
not very fast and it will be large, but when your program has bugs then the program
will give you a meaningful error message in most cases. Only after you have tested
your program carefully you may consider compiling it without debug mode. You may do
that with</p>
<div>
<div>
<pre>nim c -d:release test.nim

nim c -d:danger test.nim</pre>
</div>
</div>
<p>The compiler option -d:release removes most checks and debugging code and enables the
backend optimization by passing the option &#34;-O3&#34; to the C compiler backend, giving a
very fast and small executable file. The option -d:danger removes all checks, it
includes -d:release. You should be aware that compiling with -d:danger means that
your program may crash without any useful information, or even bad, may run, but
contain uncatched errors like overflows and so may give you wrong results. Generally
you should compile your program with plain <span>nim c</span> first. When you have tested
it well and you may need the additional performance, you may switch to -d:release
option. For games, benchmarks or other uncritical stuff you may try -d:danger.</p>
<p>There exists many more compiler options, you can find them explained in the Nim
manual or you may use the command nim --help and nim --fullhelp to get them
displayed. One important new option is --gc:arc to enable the new deterministic
memory management. You may combine --gc:arc with -d:useMalloc to disable Nim’s own
memory allocator, this reduces the executable size and enables the use of Valgrind to
detect memory leaks. Similar to --gc:arc is the option --gc:orc which can deal with
cyclic data structures. Finally a very powerful option is --passC:-flto. This option
is for the C compiler backend and enables link time optimization (LTO). LTO enables
inlining for all procedure calls and can significantly reduce the final program size.
For a recent Nim compiler version instead of --passC:-flto also -d:lto can be used.
We should mention that you can also try the C++ compiler backend with the cpp command
instead of plain c command, and that you may compile with clang backend instead of
default gcc backend with the --cc:clang option. You can additional specify the option
-r to immediately run the program after successful build. For testing small scripts
the compiler invocation in the form &#34;nim r myfile.nim&#34; can be used to compile and run
a program without generation of a permanent executable file. Here is an example how
we use all these options:</p>
<div>
<div>
<pre>nim c -d:release --gc:arc -d:useMalloc --passC:-flto --passC:-march=native board.nim</pre>
</div>
</div>
<p>In this example we additional pass -march=native to the C compiler backend to enable
use of the most efficient CPU instructions of our computer, which may result in an
executable that will not run on older hardware. Of course we can save all these
parameters in configuration files, so that we don’t have to actual type then for each
compiler invocation. You may find more explanations to all the compiler options in
the Nim manual or in later sections of this book, this includes the options for the
JavaScript backend.</p>
</div>
</div>

<div>
<p>
In this part we will introduce the most important constructs of the Nim programming
language, like statements and expression, conditional and repeated execution,
functions and procedures, iterators, templates, exceptions and we will discuss
various basic data types including the basic container types array, sequence and
string.
</p>
</div>
<div>
<h2 id="_declarations">Declarations</h2>
<div>
<p>We can declare constants, variables, procedures or our custom data types.
Declarations are used to give information to the compiler, for example about the type
of a variable that we intend to use.</p>
<p>We will explain type and procedure declarations in later sections. Currently only
constant and variable declarations are important.</p>
<p>A constant declaration in its simplest form maps a symbolic name to a value, like</p>

<p>We use the reserved word <span>const</span> to tell the compiler that we want to declare a
constant which we have named Pi and we assign it the numeric decimal value 3.1415.
Nim has a small set of reserved words like <span>var, const, proc, while</span> and
others, to tell the compiler that we want to declare a variable, a constant, a
procedure or that we want to use a while loop for some repeated execution.
Reserved words in Nim are special symbols that have a special meaning for the compiler, and we should
avoid using these symbols as names for other entities like variables, constants or functions, as that
would confuse the compiler.
The
<span>=</span> is the assignment operator in Nim, it assigns the value or expression on the
right side of it to the symbol on the left. You have to understand that it is
different from the equal sign we may use in mathematics. Some languages like Pascal
initially used the compound operator <span>:=</span> for assignments, but that is not
easy to type on the keyboard and looks a bit angry for sensible people. And source
code usually contains a lot of assignments, so use of <span>=</span> makes some sense. We
call <span>=</span> an operator. Operators are symbols which perform some basic operation,
like <span>+</span> for the addition of two numbers, or <span>=</span> for the assignment of a
value to a symbol. With the above constant declaration we can use the symbol
<span>Pi</span> in our program’s source code and don’t have to remember or retype the
exact sequence of digits. Using named constants like our Pi above makes it easy to
modify the value — if we notice that we need more precision, we can look up the
exact value of Pi and change the constant at one place in our source code, we don’t
have to search for the digit sequence 3.14 in all our source code files.</p>
<p>For numeric constants like our <span>Pi</span> value the compiler will do a substitution in the
source code when the program is compiled, so where we write the symbol <span>Pi</span>
the actual numeric value is used.</p>
<p>For constant declarations it must be possible to determine its value at compile time.
Expressions assigned to constants can contain simple operations like basic math, but
some functions calls may be not allowed.</p>
<p>Variable declarations are more complicated, as we ask the compiler to reserve a named
storage location for us:</p>

<p>Here we put the reserved keyword <span>var</span> at the beginning of the line to tell the
compiler that we want to declare a variable, then we give our chosen name for that
variable followed by a colon and the data type of the variable. The int type is a
predefined numeric type indicating a signed integer type. The storage capacity of an
integer variable depends on the operating system of your computer. On 32-bit systems
32 bits are used, and on 64-bit systems 64 bits are used to store one single integer
variable. That is enough for even large signed integer numbers: the range is <span>-2^31</span>
up to <span>2^31 - 1</span> for 32 bit systems and <span>-2^63</span> up to <span>2^63 - 1</span> for 64-bit systems.</p>
<p>For variables we generally use lower case names, but names of constants may start
with an upper case letter.</p>

</div>
</div>
<div>
<h2 id="_statements">Statements</h2>
<div>
<p>Statements, or instructions are a core component of Nim programs: they tell the
computer what it shall do. Often statements are procedure calls, like the call of the
<span>echo()</span> or <span>inc()</span> procedure which we have already seen in part I of
the book. We will learn what procedures exactly are we will learn in later sections. For now, we
just regard procedures as entities that perform a well defined task for us when we
call (or invoke) them. We call them by just writing their name in our source file, followed
by a list of parameters, also called arguments. When we write <span>echo 7</span> then
echo is the procedure which we call, and 7 is the argument, an integer literal in
this case. When the parameter list has more than one argument, then we separate
the arguments with a comma each, and generally we put an optional space after that comma.
The effect of our procedure call is that the decimal number 7 is written
to the terminal when we run the program after compilation. While in languages like
C the parameter list has to be always enclosed in brackets, in Nim we can often leave the
brackets out, which is called command invocation syntax.</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span> <span>SquareOfFive</span> <span>=</span> <span>5</span> <span>*</span> <span>5</span>
<span>echo</span><span>(</span><span>5</span> <span>*</span> <span>5</span><span>,</span> <span>SquareOfFive</span><span>)</span> <span># ordinary procedure call</span>
<span>echo</span> <span>5</span> <span>*</span> <span>5</span><span>,</span> <span>SquareOfFive</span> <span># command invocation syntax</span></code></pre>
</div>
</div>
<p>The command invocation syntax is often used with the <span>echo()</span> procedure,
or when a procedure has only one single argument. For multiple
arguments, or when the argument is a complicated expression, the use
of brackets may be preferable. Some coding styles of other programming
languages, like C, sometimes put a space between the procedure name and
the opening bracket. For Nim we should not do that, the reason will become clear
when we later explain the tuple data type. A few procedures have no parameters at all.
When we call these functions, we have to use always the syntax <span>myProc()</span> with an empty
pair of brackets, to make it for the compiler clear that we want to call that function.
<span>res = myProc()</span> assigns the result of the <span>proc</span> call to <span>a</span>, while
<span>res = myProc</span> would assign the <span>proc</span> itself to <span>a</span>, which is very different.</p>
<p>A special form of
procedures are functions, that are procedures which perform operations to return a value, or a result. In
mathematics, sin() or cos() would be functions — we pass an angle as argument and
get the sine, or cosine as a result.</p>
<p>Let’s look at this minimal Nim program:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>:</span> <span>int</span>
<span>a</span> <span>=</span> <span>2</span> <span>+</span> <span>3</span>
<span>echo</span> <span>a</span>
<span>echo</span><span>(</span><span>cos</span><span>(</span><span>0</span><span>)</span> <span>+</span> <span>2</span><span>)</span></code></pre>
</div>
</div>
<p>The Nim program above consists of a variable declaration and three statements: in the
first line we declare the variable we want to use. In the next line we assign the
value <span>2 + 3</span> to it, and finally in line 3 we use the procedure
<span>echo()</span> to display the content of our variable in the terminal window.
In the last line we use again the <span>echo</span> procedure with an ordinary parameter list
enclosed in brackets. The parameter list has only one parameter, which is the
sum of a function call and the literal value <span>2</span>. Here the compiler would first
call <span>cos(0)</span> and then add the literal value <span>2</span> to that result, before finally the sum
is passed to the <span>echo</span> proc to print the value.</p>
<p>Nim programs are generally processed from top to bottom by the compiler, and when we
execute the program after successful compilation, then it also executes from top to
button. A consequence of this is that we have to write the lines of above program
exactly in that order. If we moved the variable declaration down, then the compiler
would complain about an undeclared variable because the variable is used before it
has been declared. If we exchanged lines 2 and 3, then the compiler would be still
satisfied, and we would be able to compile and run the program. But we would get a
very different result, because we would first try to display the value of variable <span>a</span>,
and later assign a value to it.</p>
<p>When we have to declare multiple constants or variables, then we can use a block,
that is we write the keyword <span>var</span> or <span>const</span> on its own line, followed by the actual
declarations like in</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span>
  <span>Pi</span> <span>=</span> <span>3.1415</span>
  <span>Year</span> <span>=</span> <span>2020</span>
<span>var</span>
  <span>sum</span><span>:</span> <span>int</span>
  <span>age</span><span>:</span> <span>int</span></code></pre>
</div>
</div>
<p>These blocks are also called sections, .e.g. const section or var section, as known from the wirthian languages.
Note the indentation — the lines after <span>const</span> and <span>var</span> start with some space
characters, so they build a block which allows the compiler to detect where the
declaration ends. Generally we use two spaces for each level of indentation. Other
numbers would work also, but the indentation scheme should be consistent. Two spaces
is the general recommendation, as it is clearly recognizable for humans in the source
code, and because it doesn’t waste too much space, that is, it would not generate
long lines which may not fit onto the screen.</p>
<p>Also note that in Nim we generally write each statement onto its own line. The line
break indicates to the compiler that the statement has ended. There are a few
exceptions — long mathematical expressions can continue on the next line (see the
Nim manual for details). We can also put multiple statements on a single line when we
separate them by a semicolon:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>:</span> <span>int</span>
<span>echo</span> <span>a</span><span>;</span> <span>inc</span><span>(</span><span>a</span><span>)</span> <i data-value="1"></i><b>(1)</b>
<span>a</span> <span>=</span> <span>2</span> <span>*</span> <span>a</span> <span>+</span> <i data-value="2"></i><b>(2)</b>
  <span>a</span> <span>*</span> <span>a</span></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>two statements separated by a semicolon on a single line</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>a longer math expression split over multiple lines. An operator as last character on a line indicates
that the expression continues on the next, indented line.</td>
</tr>
</tbody></table>
</div>
<p>We can also declare multiple variables of the same type in one single declaration,
like</p>

<p>or we can assign an initial start value to a variable like in</p>

<p>Finally, for variable declarations we can use type inference when we assign an
initial start value, that is we can write</p>

<p>The compiler recognizes in this case that we assign an integer literal to that
variable and so silently gives the variable the <span>int</span> type for us. Type inference can
be comfortable, but may make it harder for readers to understand the code, or the
type inference may not always do exactly what we want. For example in the above code
year gets the type int, which is a signed 4 or 8 byte number. But maybe we would
prefer an unsigned number, or a number which occupies only two bytes in memory. So
use type inference with some caution.</p>
<p>Note: For integral data we mostly use the int data type in Nim, which is a signed
type with 4 or 8-byte size. It usually does not make sense to use many different
integral types — signed, unsigned, and types of different byte size. Mixing them in
numerical expressions can be confusing and maybe even decrease performance, because
the computer may have to do type conversion before it can do the math operation. For
unsigned types, another problem is that math operations on unsigned operands could
have a negative result. Consider the following example where we use a hypothetical
data type &#34;unsigned int&#34; to indicate unsigned integers:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>unsigned</span> <span>int</span>
<span>a</span> <span>=</span> <span>3</span>
<span>b</span> <span>=</span> <span>7</span>
<span>a</span> <span>=</span> <span>a</span> <span>-</span> <span>b</span></code></pre>
</div>
</div>
<p>The true result would be <span>-4</span>, but <span>a</span> is of unsigned type and can never contain a
negative content. So what should happen — an incorrect result or a program
termination?</p>
<p>Related to variable declarations is the initial start value of variables. Nim clears
for us all the bits of our variables when we declare them, that is, numbers get
always the initial start value zero if we do not assign a different value in the
variable declaration.</p>
<p>In this declaration</p>

<p>both variables get the initial value zero.</p>
<p>There exists a variant for variable declarations which uses the <span>let</span> keyword
instead of the <span>var</span> keyword. Let is used when we need a variable which only once gets
a value assigned, while var is used when we want to change the content of the
variable during program execution. Let seems to be similar to <span>const</span>, but in <span>const</span>
declarations we can use only values that are known at compile time. Let allows us to
assign to variables values that are only available at program run time, maybe because
the value is a result of a prior calculation. But let indicates, at the same time, that
the assignment occurs only once, the content does not change later, during the program’s execution. We say that the
variable is immutable. Use of the <span>let</span> keyword may help the human reader of the
source code with understanding what is going on, and it may also help the compiler doing
optimizations to get faster, or more compact code. For now, we can just ignore <span>let</span>
declarations and use <span>var</span> instead — later ,we may use <span>let</span> where appropriate, and the
compiler will tell us when <span>let</span> will not work and we have to use <span>var</span>.</p>

<p>With what we have learned in this section we can rewrite our initial Nim example from
part I in this form:</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span>
  <span>Max</span> <span>=</span> <span>100</span>
<span>var</span>
  <span>sum</span><span>,</span> <span>i</span><span>:</span> <span>int</span>
<span>while</span> <span>i</span> <span>&lt;</span> <span>Max</span><span>:</span>
  <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>inc</span><span>(</span><span>sum</span><span>,</span> <span>i</span><span>)</span>
<span>echo</span> <span>sum</span></code></pre>
</div>
</div>
<p>In the code above we declare both variables of type <span>int</span> in a single line and take
advantage of the fact that the compiler will initialize them with <span>0</span> for us. And we
use a named constant for the upper loop boundary. Another tiny fix is that we write
<span>inc(i)</span> instead of <span>inc(i, 1)</span>. We can do that because there exists
multiple procedures with the name <span>inc()</span> — one which takes two arguments,
and one which takes only one argument and always increases that argument by one.
Procedures with the same name but different parameter lists are called overloaded procedures.
Instead of <span>inc(i)</span> we could have written also <span>i = i + 1</span> and instead
of <span>inc(sum, i)</span> we could write <span>sum = sum + i</span>. That would generate
identical code in the executable, so we can use whatever we like better.</p>
</div>
</div>
<div>
<h2 id="_input_and_output">Input and Output</h2>
<div>
<p>We have already used the <span>echo()</span> procedure for displaying textual output in the terminal
window. In the code examples of the previous sections we always passed arguments of integer
type to the <span>echo</span> <span>proc</span>, and the <span>echo</span> <span>proc</span> automatically converted the integer numbers
to a textual sequence of decimal digits, so that we could read it in the terminal. In the Nim programming language text is a predefined, built in
data type that is called <span>string</span>. We will learn all the details of the string data type in the next section,
for now it is sufficient that it exists and that we can use the <span>echo()</span> p[.]<mark>roc</mark> to print text strings.
The <span>echo()</span> <span>proc</span> has the ability to convert other data types like numbers or the boolean data type (true/false)
automatically to human readable text strings,
so that we can read the output in the terminal. Recall that most data types are stored internally in our computer
as bits and bytes, which have no true human readable representation by default. Numbers, as most other data
types stored in the computer, are actual abstract entities. We have learned already that all data in the computer
is internally stored in binary form, that is as a bit pattern of <span>0</span> and <span>1</span>. But even that bit pattern is still an abstraction, we would
need a procedure that prints a <span>0</span> for each unset bit and a <span>1</span> for each set bit to display the content of an internally stored
number in binary form in the terminal or elsewhere. In the same way we need a procedure to print an internally stored number
as a human readable sequence of decimal digits.
Even text strings are internally stored as abstract bit patterns, and we need
conversion <span>procs</span> to print the content for us as ordinary text. All that can be done by the <span>echo</span> <span>proc</span>,
but we do not care for the actual details at this point of the book.</p>
<p>For our further experiments we may also want to be able to enter some user data
in the terminal. As we do not know much about the various available data types and the
<span>procs</span> that can be used to read them in, we will just present a procedure that can read in
a text string that the user has typed in the terminal window.
We use a function with the name
<span>readLine()</span> for this task.</p>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>&#34;Please enter some text&#34;</span>
<span>var</span> <span>mytext</span> <span>=</span> <span>readLine</span><span>(</span><span>stdin</span><span>)</span>
<span>echo</span> <span>&#34;you entered: &#34;</span><span>,</span> <span>mytext</span></code></pre>
</div>
</div>
<p>Note that you have to press the <span>return</span> key after you have entered your text.</p>
<p>The first line of our program show how we can print a text literal string
with the <span>echo()</span> <span>proc</span>. To mark text literals unambiguously and to separate them
from other literals like numeric literals or from variables, the string literals have to
be enclosed in quotation marks.
In
the second line of our example program we use the <span>readLine()</span> function to read textual user input.
Note that we call <span>readLine()</span> a function, not a procedure, to emphasize that it returns a value.
The <span>readLine()</span> function needs one parameter to know from where it should read — from the terminal window or from a file for example. The <span>stdin</span> parameter
indicates that it should read from the current terminal window — <span>stdin</span> is a global
variable of the <span>system</span> (<span>io</span>) module and indicates the standard input stream. Finally
in line 3 we use again the <span>echo()</span> procedure to print some text. In this case
we pass two arguments to <span>echo()</span>, a literal text enclosed in quotes, and then
separated by a comma, the <span>mytext</span> variable. The <span>mytext</span> variable has
the data type <span>string</span>. We used type inference in this example to declare that data
type: the <span>readLine()</span> procedure always returns a <span>string</span>, the
compiler knows that, so our <span>mytext</span> variable is automatically declared with
type <span>string</span>. We will learn more about the data type <span>string</span> and other
useful predefined data types in the next section.</p>

<p>When you try the example code from above, you may want a variant of it that does read
in the textual input not on its own line, but directly after the prompt like &#34;What is your name: Nimrod&#34;.
As the <span>echo</span> <span>proc</span> writes always a newline character after the last argument has been written, we have
to use a different function to get the input prompt on the same line. We can use the <span>write()</span> <span>proc</span>
from the <span>system</span> module for this. As <span>write()</span> can not only write to the terminal, but also to files,
it needs an additional parameter which specifies the destination. We can pass the variable <span>stdout</span>
from the <span>system</span> module to indicate that write() should write to our terminal window. Another desire of beginners is generally,
to have the ability to read single character input without the need to press additional the return key.
For that we can use the getch() function from the <span>terminal</span> module — that functions waits (blocks) until
a key is pressed and returns the ASCII character of the pressed key:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>terminal</span> <span>import</span> <span>getch</span>

<span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;May you tell me your name: &#34;</span><span>)</span>
<span>var</span> <span>answer</span> <span>=</span> <span>readLine</span><span>(</span><span>stdin</span><span>)</span>
<span>if</span> <span>answer</span> <span>!=</span> <span>&#34;no&#34;</span><span>:</span>
  <span>echo</span> <span>&#34;Nice to meet you, &#34;</span><span>,</span> <span>answer</span>
<span>echo</span> <span>&#34;Press any key to continue&#34;</span>
<span>let</span> <span>c</span> <span>=</span> <span>getch</span><span>()</span>
<span>echo</span> <span>&#34;OK, let us continue, you pressed key:&#34;</span><span>,</span> <span>c</span></code></pre>
</div>
</div>
<p>Don’t get confused by the fact that the first <span>write()</span> call and the following <span>readline()</span>
call does not appear on the same line in our example. The actual format of our source code
does in this case not influence the program output. We could write both function calls
on a single line, separated with a semicolon. But that would make no difference for the program
output. The significant difference of the code above is just, that write() prints the text, but does not move the
cursor in the terminal window to the next line, while echo() moves the cursor to the next line when all
arguments have been printed. We say that echo prints automatically a &#34;\n&#34; character, which we call newline
character, after all the arguments have been printed.</p>
</div>
</div>
<div>
<h2 id="_data_types">Data types</h2>
<div>
<p>The most fundamental data type — in real life and in computer science — are integer (whole) numbers.
All other numeric data types, like fractional, floating point or complex numbers,
and other fundamental types like the boolean type with its two values <span>true</span> and <span>false</span>, or character and
text string types, can be represented as integers. For that reason the early computers built in the 1950’s
as well as today’s tiniest microcontrollers work internally only with integer numbers. As all CPUs are
able to do basic bit operations like setting or clearing individual bits, and as bit patterns
map well to mathematical sets, set data types are well supported by all CPUs, and so
<span>set</span> operations are generally very efficient.
Advanced computers
built in the 1980’s got support for the important class of floating point numbers by special
floating point processors for fast numerical computations. These floating point units are
today generally integrated into the CPU, and GPUs can even process many floating point operations in parallel,
where the precision is often restricted to ranges needed for games and graphics animation, that is 32 or even 16 bit.
Modern CPUs have often also some form of support for vector data types to process multiple
values in one instruction (SIMD, Single instruction, multiple data).</p>
<p>None numeric types like characters or text strings are internally represented by integer numbers — in the C language the data type to present text strings is called char, but it is indeed only a 8 bit
integer type which supports all the mathematical operations defined for ordinary int types. In Nim and
the wirthian languages most math operations are not directly allowed for the <span>char</span> data type,
which should prevent misuse and allows to catch logical errors by the compiler.</p>
<p>Nim supports also
some built in homogeneous container types like arrays and sequences, and many built in derived types
like enums, sub-ranges and slices, distinct types and view types (experimental).
The built in inhomogeneous container types object and tuple, which allow
to group other types, are supported by a variant type container, which allows
instances of that type to contain different child types at runtime. These inhomogeneous container types
are similar as the struct and union types from the C programming language.</p>
<p>Other basic and advanced data types like complex and fractional numbers, types with arbitrary-precision arithmetic as well as
hash sets and hash tables, dynamically linked list or tree structures are available through the Nim standard library
or external packages. And of course we are able to define our own custom data types with our own operators, functions and
procedures working on them.</p>
<p>Note that all the data types that are build into the language, like the primitive types int, float or char, as well
as the built in container types like tuple, object, seq and string, are written in lower case, while
data types that are defined by the Nim standard library or that we define our self, by convention starts
with a capital letter like the CountTables type defined in the <span>tables</span> module. Some people may regard this as an inconsistency,
some may say that in this way we can differentiate built in types from types defined by libraries. At least we may agree
that using capital notation for common types as in Int, Float or String would be more difficult to type and
would look not that nice.</p>
<div>
<h3 id="_integer_types">Integer types</h3>
<p>We have already used the <span>int</span> data type, which indicates a signed integer
type of <span>4</span> or <span>8</span> byte size, depending on the operating system. The reason why the size of that type depends on the
word size of the OS will become clear later, when we explain what references and
pointers are.</p>
<p>Beside the <span>int</span> data type, Nim has some more data types for signed and unsigned
integers: <span>int8</span>, <span>int16</span>, <span>int32</span> and <span>int64</span> are signed
types with well-defined bit and byte size, and <span>uint8</span>, <span>uint16</span>,
<span>uint32</span> and <span>uint64</span> are the unsigned equivalents. The number at the
end of the type name is the bit size; we get the byte size when we divide that value
by <span>8</span>. Additional we have the type <span>uint</span>, which corresponds to <span>int</span>
and has same size, but stores unsigned numbers only. 
Generally we should try to use the <span>int</span> type for all integral numbers, but sometimes it
can make sense to use the other types. For example, when you have to work with a
large collection of numbers, you know that each number is not very big, and your RAM
is not really that large, then you may decide for example to use <span>int16</span> for
all your numbers. Or when you know that your numbers will be really big and will not
fit in a 4 byte integer, then you may use the <span>int64</span> type to ensure that the
numbers fit in that type even when your program is compiled and executed on a
computer with a 32 bit OS.</p>
<p>For integer numbers we have the predefined operators <span>+</span>, <span>-</span> and <span>*</span>
available for addition, subtraction and multiplication. Basically these operations
works as we may expect, but we have to remember that we may get overflows. For signed
ints we get compile- or run-time errors in that case, while unsigned ints just wrap
around, see example at the end of this section. For division of integers we have the
operators <span>div</span>, <span>mod</span>, and <span>/</span> available. The <span>div</span> operator
does an integer division ignoring the remainder, <span>mod</span> is short for modulus and
gives us the remainder of the division, and <span>/</span> finally is currently only
predefined for the signed int type and gives us a fractional result of data type
<span>float</span>.  That type is introduced in the next section.</p>
<p>Remembering how <span>div</span> and <span>mod</span> behaves when the divisor or dividend are
negative can be confusing, and it may differ for other programming languages. You may
find a detailed justified explanation for the concrete behaviour in the Nim manual and at Wikipedia.</p>
<div>
<div>
<pre>Result of i div j
   -4 -3 -2 -1  0  1  2  3  4
-4  1  1  2  4    -4 -2 -1 -1
-3  0  1  1  3    -3 -1 -1  0
-2  0  0  1  2    -2 -1  0  0
-1  0  0  0  1    -1  0  0  0
 0  0  0  0  0     0  0  0  0
 1  0  0  0 -1     1  0  0  0
 2  0  0 -1 -2     2  1  0  0
 3  0 -1 -1 -3     3  1  1  0
 4 -1 -1 -2 -4     4  2  1  1

Result of i mod j
   -4 -3 -2 -1  0  1  2  3  4
-4  0 -1  0  0     0  0 -1  0
-3 -3  0 -1  0     0 -1  0 -3
-2 -2 -2  0  0     0  0 -2 -2
-1 -1 -1 -1  0     0 -1 -1 -1
 0  0  0  0  0     0  0  0  0
 1  1  1  1  0     0  1  1  1
 2  2  2  0  0     0  0  2  2
 3  3  0  1  0     0  1  0  3
 4  0  1  0  0     0  0  1  0</pre>
</div>
</div>
<p>When performance matters we generally should try to use the &#34;CPU native&#34; number type
what for Nim is the <span>int</span> type. And we should try to avoid using math expressions with
different types, as the CPU may have to do type conversion in that case before the
math operation can be applied. Adding two <span>int8</span> types can on some CPU’s be slower than
adding two <span>ints</span>, because the CPU may have to size extend the operands before the math
operation is performed. But this depends on the actual CPU, and there are important
exceptions: Multiplying two ints would result in an int128 result if int size is 64
bit, which can be slow when the CPU does not support that operation well. Another
important point to consider for maximum performance is the cache usage. If you are
performing operations on a large set of data, then you may get a significant
performance gain when large fractions of your data fits in the caches of your
computer, as cache access is much faster than ordinary RAM access. So using smaller
data types, i.e. <span>int32</span> instead Nim’s default <span>int</span> which is int64 on a 64 bit OS may
increase performance in this special application.</p>
<p>When we use Nim on tiny microcontrollers, maybe even on 8-bit controllers like the popular AVR
devices, it may be best to use only integers of well defined size like <span>int8</span>.</p>
<p>When we write integer literal numbers, then we use generally our common decimal
notation, as in <span>var i = 100</span>.
To increase the readability for long number literals we can use the underscore character
as in <span>1_000</span>, that underscore character is just ignored by the compiler.
We can also write integer literals in binary, octal or
hexadecimal notation. For that we prefix the literal value with <span>0b</span>, <span>0o</span> or <span>0x</span>. The leading
zero is necessary, and the next letter indicates binary, octal or hexadecimal encoding.
But such integer literal notation is very rarely used.</p>
<p>More important is the actual size of integer literals, in particular when we use type inference.
Ordinary integer literals have the <span>int</span> type, but integer literals not fitting
in 32 bit have <span>int64</span> type. We can also specify the type of integer literals by appending
the literal with <span>i8</span>, <span>i16</span>, <span>i32</span> or <span>i64</span> for signed types and with <span>u</span>, <span>u8</span>, <span>u16</span>, <span>u32</span> or <span>u64</span> for
unsigned types. We can separate the actual number and the suffix with a <span>&#39;</span> character,
but that is not necessary for the integer literals.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>a</span> <span>=</span> <span>100</span> <span># int literal in decimal notation</span>
  <span>b</span> <span>=</span> <span>1234567890000</span> <span># int64</span>
  <span>c</span> <span>=</span> <span>5&#39;i8</span> <span># 8 bit integer</span>
  <span>d</span> <span>=</span> <span>7u16</span> <span># unsigned integer with 2 byte size</span>
  <span>e</span> <span>=</span> <span>0b1111</span> <span># ordinary integer in binary notation, value is 15 in decimal notation</span>
  <span>f</span> <span>=</span> <span>0o77</span> <span># integer in octal notation, value is 7 * 8^0 + 7 * 8^1 in decimal notation</span>
  <span>g</span> <span>=</span> <span>0xFF</span> <span># integer in hexadecimal notation</span>

<span>echo</span> <span>g</span><span>,</span> <span>typeof</span><span>(</span><span>g</span><span>)</span></code></pre>
</div>
</div>
<p>In arithmetic expressions integer types of different sizes are generally compatible
when all the types are signed or unsigned, e.g.
in the example code from above we could write <span>echo a + b + c</span>, and
typeof(a + b + c) is int64, that is the expression is propagated to
the largest type of all the involved operands. But <span>echo a + b + c + d</span>
would not compile, as for such a mix of signed and unsigned operands it is
not clear if signed or unsigned arithmetic should be used.
Also note that
even on a 64 bit OS <span>echo typeof(a) is typeof(b)</span> would print <span>false</span>.</p>
<p>An important property of the current Nim implementation of A. Rumpf used with the C
backend is the fact that unsigned integers does not generate overflow errors but
simple wrap around:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>x</span><span>:</span> <span>int8</span> <span>=</span> <span>0</span>

<span>while</span> <span>true</span><span>:</span>
  <span>inc</span><span>(</span><span>x</span><span>)</span>
  <span>echo</span> <span>x</span></code></pre>
</div>
</div>
<p>Above code would print the numbers <span>0</span> up to <span>127</span> and then terminate program execution
due to an overflow error. But when we change the data type to <span>uint8</span> we would get a
continues sequence of the numbers <span>0</span> up to <span>255</span>. After the value <span>255</span> is reached, the
value wraps around to <span>0</span> again and the process continues. This behavior can lead to
strange bugs and is the reason that the Nim team generally recommends to avoid
unsigned integers.</p>
<p>For compatibility with external libraries Nim has also the integer types <span>cint</span> and
<span>cuint</span>, which exactly match the C types <span>int</span> and <span>uint</span> when we compile for the C or
C++ backend. For the JavaScript backend, the LLVM backend or other backends these
types may be also available, for details you should consult the compiler
documentation. For most operating system and C compilers the <span>int</span> and <span>uint</span> types in C are 4 bytes
in size, but there can be exceptions, so we better should not write code that depends
on the actual byte size of the types. The Nim types <span>cint</span> and <span>cuint</span> are generally only
used for parameter lists of © library functions. To match other integer types like
C <span>char</span>, <span>short</span>, <span>long</span>, <span>longlong</span> Nim supports these types when we put a c letter in
front of the name like clong. Again you should consult the Nim compiler manual when
you need more details, i.e. when you create bindings to external libraries.</p>
</div>
<div>
<h3 id="_floating_point_types">Floating point types</h3>
<p>Another important numeric data type is <span>float</span>, for floating point numbers. Floats are
an approximation of real numbers. They can also store fractions, and are most often
printed in the decimal system with a decimal point, or in scientific notation with an
exponent. Examples for the use of variables of <span>float</span> data type are</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>mean</span> <span>=</span> <span>3.0</span> <span>/</span> <span>7.9</span>
  <span>x</span><span>:</span> <span>float</span> <span>=</span> <span>12</span>
  <span>y</span> <span>=</span> <span>1.2E3</span></code></pre>
</div>
</div>
<p>The variable <span>mean</span> is assigned the result of the division of two
<span>float</span> literals — the result has again the data type <span>float</span>,
and so the compiler can infer for the type of variable <span>mean</span> that same type.
If we printed the result of the division there
would be a decimal point and some digits following it. For variable <span>x</span> we specify the
<span>float</span> type explicitly and assign the value <span>12</span>. We could use type inference if we
assigned <span>12.0</span>, because the compiler can recognize by the decimal point that we want a
<span>float</span>, not an <span>int</span> variable. In line 3 we use scientific notation for the float literal that we
assign to <span>y</span>, and the assigned value is <span>1.2 * 10^3 = 1200.0</span>. Literal values like
<span>2E3</span> are also valid <span>float</span> literals — the value would be <span>2000.0</span>. But
literals with a decimal point and no digits before or after the point — <span>1.</span> or <span>.2</span> — are not valid in Nim.</p>
<p>In the current Nim implementation <span>float</span> variables always occupy 64 bits. Nim has also the
data type <span>float64</span> which is currently identical to plain <span>float</span>, and <span>float32</span> which can
store only smaller numbers and has less precision. Floats can store values up to a magnitude of approximately
<span>1E308</span> with a positive or negative sign, and floats have a typical precision
of 16 digits. That is, when you do a division of two arbitrary floats and print the
result, you will get up to 16 valid digits.
If you would try to print more than 16 significant digits, then the additional decimal places
would be just some form of random garbage.
Note: The number of significant digits of a floating point number is the
total number of digits before and after the decimal point, but possible leading zero
digits would not be counted. The reason that leading zeros are not significant is
just that in the ordinary notation of numbers we always assume that there is just nothing
before the first non zero digit. For our car odometer
<span>001234.5 km</span> is identical to <span>1234.5 km</span>. And if we give our body size as
<span>1.80 m</span> or <span>180 cm</span> makes no difference, both values have 3 significant digits.</p>
<p>Generally we use floats whenever integers are not sufficient for some reason. For
example when we have to do complicated mathematical operations which include
fractional operands like <span>Pi</span>, or when we have to do divisions and need the exact
fractional value.</p>
<p>The <span>float</span>, <span>float32</span> and <span>float64</span> data types provides the <span>+</span>, <span>-</span>, <span>*</span>
and <span>/</span> operators for addition, subtraction, multiplication and division. Unlike
for the <span>int</span> types, for the <span>float</span> types we get never overflow or underflow errors, and
also no error for a division by zero. But the result of an operation of two <span>float</span>
operands can be a special value like system.Inf, system.NegInf or system.NaN. The
first two indicate an over- or underflow, and NaN (Not a Number) indicates that the result of an
operation is not a valid number at all, for example the result of a division by zero
or the result of calculating the square root of a negative number. This behaviour is
sometimes called saturated arithmetic. When a variable has one of these special
values, and we apply further math operations, then this value is kept. So we can
detect at the end of a longer mathematical calculation if something went wrong — we
have not to check after each single operation.
An interesting property of floating point numbers is, that
when we test two variables of <span>float</span> type for equality, and one has the value <span>NaN</span>, then the test is always false.
That is the test <span>a == NaN</span> is always false.
When we forget this fact, we may initialize a <span>float</span> variable to the value
<span>NaN</span> and later test with <span>if a == NaN:</span> to check if we have already assigned a value,
which is not what we really had in mind, as that test has always a negative result.
The actual test for the value <span>NaN</span> is <span>a == a</span>, which is only false when <span>a</span> has the value <span>NaN</span>,
or we may use math.isNaN().
More useful constants and functions for the <span>float</span> data types can be found in the
<span>std/fenv</span> module, and functions working with floats like the trigonometric ones
are available from the <span>std/math</span> module.</p>
<p>For floats we have the operators <span>+</span>, <span>-</span>, <span>*</span> and <span>/</span>
for addition, subtraction, multiplication and division. For powers with integral
exponents you can use the <span>^</span> operator, but you have to import it from the
<span>std/math</span> module. The expression <span>x ^ 3</span> is the same as <span>x * x
* x</span>. The <span>math</span> module contains many more functions like <span>sin()</span> or
<span>cos()</span>, <span>sqrt()</span> and <span>pow()</span>. The function name <span>sqrt()</span> is short for
square-root, and <span>pow()</span> stands for power, so <span>pow(x, y)</span> is <span>x</span> to the power of <span>y</span>,
when both operands have type float. For performance critical code you should always
keep in mind that <span>pow()</span> is an actual function call, maybe a call of an dynamic library which can not be inlined,
so a call of <span>pow(x, 2)</span> may be a lot
slower than a plain <span>x * x</span>. And even when using the <span>^</span> operator as in <span>x ^ 3</span>
we should be a bit critical. But of course we always hope that the compiler will
optimize all that for us.</p>
<p>The operators <span>+</span>, <span>-</span>, <span>*</span> and <span>/</span> can be used also when
one operand is a <span>float</span> variable and the other operand is an <span>int</span> literal.
In that case the compiler knows that we really intend to do a float operation and
converts the int literal automatically to float type.
But when one
operand is a <span>float</span> variable and the other is an <span>int</span> variable, then an explicit type conversion
is necessary like in <span>float(myIntVal) * myFloatVal</span>.
One explanation why in this case the int value is not automatically converted to float is,
that this may mean a loss in precision, as large int64 values can not be presented as an float.
Well, for int32 this reason does not really apply, but still there is no automatic conversion.
But indeed as Nim is used as a systems programming language, it seems to be a good
decision to need explicit conversions in this case, as it makes it more clear what really is intended.
And generally we should try to avoid to use a lot operations with mixed types, as
that may make type conversions necessary, which may cost performance.
If we really do not care, we may import the module
<span>std/lenientOps</span>, which defines the arithmetic operations for mixed operands.</p>
<p>Float literals have the float data type by default, but as for integer literals we can also
explicitly specify the data type: The suffixes <span>f</span> and <span>f32</span> specify a 32 bit float type, and
<span>d</span> and <span>f64</span> specify a 64 bit type. We can separate the suffix from the actual number
with a <span>&#39;</span> character, but that is not required as long as there is no ambiguity. We can also
specify float literals in binary, octal or hexadecimal notation, when we append one of these
suffixes. In case of hexadecimal notation, the <span>&#39;</span> is obviously needed to separate the suffix, as
<span>f</span> and <span>d</span> are valid hex digits.</p>
<p>As for integer variables Nim supports also the compatible types <span>cfloat</span> and <span>cdouble</span>
which match the C types float and double when the C backend is enabled. For most C
compilers C float matches Nim’s float32 and C double matches Nim’s float64.</p>

<p>Two important properties of floats are that not all numbers can be represented
exactly and that math operations are not absolutely accurate.
Recall that in our decimal system, some fractions like <span>1/2</span> can be represented exactly
as <span>0.5</span> in decimal notation, while others like <span>1/3</span> can be only approximated as <span>0.3333…​</span>
As all data, floats are stored internally in binary form following the
<span>IEEE Standard for Floating-Point Arithmetic (IEEE 754)</span>.
In that format some values, e.g. the value <span>0.1</span>, can not be represented exactly.
As a result, some simple arithmetic operations, executed in the computer, will
give us not exactly that result that we may expect. As we should really remember this
important fact, we will investigate this behaviour with a small example program where we
divide a few small integer numbers after conversion to float by another to float converted integer n
and sum the result n times:</p>
<div>
<div>
<pre><code data-lang="nim"><span>for</span> <span>i</span> <span>in</span> <span>1</span> <span>..</span> <span>10</span><span>:</span>
  <span>echo</span> <span>&#34;--&#34;</span>
  <span>for</span> <span>j</span> <span>in</span> <span>2</span> <span>..</span> <span>9</span><span>:</span>
    <span>let</span> <span>a</span> <span>=</span> <span>i</span><span>.</span><span>float</span> <span>/</span> <span>j</span><span>.</span><span>float</span>
    <span>var</span> <span>sum</span><span>:</span> <span>float</span>
    <span>for</span> <span>k</span> <span>in</span> <span>1</span> <span>..</span> <span>j</span><span>:</span>
      <span>sum</span> <span>+=</span> <span>a</span>
    <span>echo</span> <span>sum</span></code></pre>
</div>
</div>
<p>which generates this output:</p>
<div>
<div>
<pre>--
1.0
1.0
1.0
1.0
0.9999999999999999
0.9999999999999998
1.0
1.0
--
2.0 # for all iterations!
--
3.0 # for all iterations!
--
4.0
4.0
4.0
4.0
4.0
3.999999999999999
4.0
4.000000000000001
--
5.0
5.0
5.0
5.0
5.0
5.0
5.0
4.999999999999999
--
6.0
6.0
6.0
6.0
6.0
5.999999999999999
6.0
6.0
--
7.0
7.0
7.0
7.0
7.000000000000001
7.0
7.0
7.0
--
8.0
8.0
8.0
8.0
7.999999999999999
7.999999999999998
8.0
8.000000000000002
--
9.0 # for all iterations!
--
10.0
10.0
10.0
10.0
10.0
10.0
10.0
9.999999999999998</pre>
</div>
</div>
<p>The <span>echo()</span> procedure prints up to 16 significant digits for a <span>float</span> value, and so the
accumulated tiny arithmetic errors become visible. After our remarks above that
should be not surprising any more, the general solution is to round results to
less than 16 decimal digits before printing. Various ways to do that will be shown
later in the book. A related issue of float arithmetic is caused by scaling and extinction.
When we add numbers with very different magnitudes, the result may be just
the value of the largest number, as in <span>echo 1.0 == 1.0 + 1e-16</span> which prints <span>true</span>.
The tiny summand is just too small to actually chance the result, that is as when you
switch on a torch on a sunny day, it will not really become brighter.
Maybe more surprising is, that calling <span>echo()</span> with some simple <span>float</span> literals
will print a different value, like <span>echo 66.04</span> which gives <span>66.04000000000001</span>
for Nim v1.6, while with Python3 we get <span>66.04</span> exactly. But indeed that is only
surprising for people who do not understand well what a statement like
<span>echo 66.04</span> really does: We know already, that the value <span>66.04</span> is converted
by the compiler to an internally binary representation, and then converted
back to a decimal string when we run the program. So it is not that surprising that
in this process some tiny inaccuracies can accumulate. Actually it is possible to
get exact 16 digits precision when a very smart conversion routine like the
<span>ryu</span> or <span>dragonbox</span> algorithm is used.</p>
<p>From the discussions above it should be clear that testing two floats for
equality is often problematic. Instead for just testing for equality we may better
define a small epsilon value like <span>eps = 1e-14</span> and then write <span>(a - b).abs &lt; eps</span>.
Seems to be not bad, and can be seen often and works often, but not always.
Imagine you write a program which processes chemical elements and you work
with atomic mass and radii. So maybe the result with above test is that all the
atoms of the periodic table have equal mass and equal size, at least when
you should use the SI system with meter and kilogram as base units. So a equality test like</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span> <span>eps</span> <span>=</span> <span>1e-16</span> <span># an arbitrary relative precision</span>
<span>if</span> <span>(</span><span>a</span> <span>==</span> <span>0</span> <span>and</span> <span>b</span> <span>==</span> <span>0</span><span>)</span> <span>or</span> <span>(</span><span>a</span> <span>-</span> <span>b</span><span>).</span><span>abs</span> <span>/</span> <span>(</span><span>a</span><span>.</span><span>abs</span> <span>+</span> <span>b</span><span>.</span><span>abs</span><span>)</span> <span>&lt;</span> <span>eps</span><span>:</span> <span># avoid div by zero</span>

<span>if</span> <span>(</span><span>a</span> <span>-</span> <span>b</span><span>).</span><span>abs</span> <span>/</span> <span>(</span><span>a</span><span>.</span><span>abs</span> <span>+</span> <span>b</span><span>.</span><span>abs</span> <span>+</span> <span>1e-32</span><span>)</span> <span>&lt;</span> <span>eps</span><span>:</span> <span># a similar check, avoiding also a div by zero</span></code></pre>
</div>
</div>
<p>may be a better solution in the general case.
Whenever you need a general equality test you should think about the problem
and do some tests — the code above are just untested possible examples.</p>
<p>At the end of this sections some remarks about the performance of float data types
compared to plain ints: On modern hardware like the popular x86 systems
for the basic operations
performance of floats and ints is very similar, addition, subtraction and even multiplication is basically done in
only one clock cycle, and division may be a bit slower. Even operations like sqrt() which have
been regarded as slow in the past are now close to a plain addition on modern hardware.
As the CPU does its float arithmetic internally with 64 or even with 80 bit, float32
is not faster than float 64, as long as the operations are not memory bound, that
is large data sets are processed, so that it is an advantage when the data types are smaller so that more
of it fits into the cache. For tiny microcontrollers and embedded devices things are very different, as these devices
generally have no floating point units. So the compiler has to emulate all the float arithmetic,
maybe by use of libraries. This is very slow and produces large executables. So when
writing software for modern desktop PCs, there is no reason to try to avoid float math, when
solving the problem with float is easier. When the data extends a very width range, e.g. from
nm to millions of km, or when operations like square root or trigonometric functions are needed,
then there is generally no way and reason to avoid float.
In the case that float or ints may work both, it is generally a good strategy to try to use
ints as first try. Ints may still provide better performance for SIMD, threading and parallel processing,
as ints may avoid the expensive saving of floating point CPU registers. For restricted hardware we should better
try to avoid float math. But all this is a difficult topic, and these advice can give you only some
simple recommendations, which may be wrong for a concrete case. So finally you have to decide yourself,
and as always it is a good idea to do some performance tests.</p>
<p>References:</p>

</div>
<div>
<h3 id="_distinct_types">Distinct types</h3>
<p>Before we continue with subrange types we should introduce the distinct types. In the
real world we have a lot of quantities for which the set of meaningful math
operations is restricted and which should not be mixed with quantities of other
types. For example we may have the quantities time and distance measured in seconds
and meters and mapped to the float or int data type. While adding seconds and adding
meters is a valid operation, adding seconds to meters makes no sense and would be a
program bug if it should occur in the program code. But again dividing a distance by
a time period resulting in the average speed would be a valid operation. Nim provides
the distinct keyword which allows us to define new data types that are based on
existing types, but that are not compatible with them or with other distinct types.
And the new defined distinct types have no predefined operations, we have to define
all desired operations our self.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Time</span> <span>=</span> <span>distinct</span> <span>float</span> <span># in seconds</span>
  <span>Distance</span> <span>=</span> <span>distinct</span> <span>float</span> <span># in meters</span>

<span>var</span> <span>t</span><span>:</span> <span>time</span> <span>=</span> <span>0.2</span> <span># not allowed</span>
<span>var</span> <span>t</span><span>:</span> <span>Time</span> <span>=</span> <span>Time</span><span>(</span><span>0.2</span><span>)</span></code></pre>
</div>
</div>
<p>For distinct types we have to define all the allowed operations our self. We can
convert distinct types to the base types and then use operations of the base type or
we can borrow operations from the base type by use of the {.borrow.} pragma. Using
distinct types can be complicated when the new type should support many operations,
but it can make our code more save. For some data type with a very limited set of
operations distinct types can be used easily. Distinct types are explained in detail
in the Nim manual, we may explain then in more detail in later sections. For now it
is enough that we know about their existence.</p>
</div>
<div>
<h3 id="_subrange_types">Subrange types</h3>
<p>Sometimes it makes sense to limit the range of numeric variables to only a sub-range.
For this Nim uses the <span>range</span> keyword with this notation: <span>range[LowVal
.. HighVal]</span>. Values of this type can never be smaller than LowVal or larger than
HighVal. For Nim v1.6 we can define range types also by leaving out the <span>range[]</span>, that is
by just two constants separated by <span>..</span>.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Year</span> <span>=</span> <span>range</span><span>[</span><span>2020</span> <span>..</span> <span>2023</span><span>]</span> <span># software update required at least for 2024!</span>
  <span>Month</span> <span>=</span> <span>range</span><span>[</span><span>1</span> <span>..</span> <span>12</span><span>]</span>
  <span>Day</span> <span>=</span> <span>1</span> <span>..</span> <span>31</span> <span># same as range[1 .. 31]</span>

<span>var</span> <span>a</span><span>:</span> <span>int</span> <span>=</span> <span>0</span>
<span>var</span> <span>d</span><span>:</span> <span>Day</span> <span>=</span> <span>1</span> <span># OK</span>
<span>d</span> <span>=</span> <span>0</span> <span># compile time error</span>
<span>d</span> <span>=</span> <span>a</span> <span># run time test and error</span>
<span>echo</span> <span>d</span></code></pre>
</div>
</div>
<p>For the above example the base type of the defined ranges is int, so the ranges are
compatible with the predefined int type, we can assign values of int type to our
range types and vice versa. In our example the size of the range types is the size of the int base type,
but of course we could use other base types, like <span>type Weekday = 1.int8 .. 7.int8</span>.
If we try to assign to a range type a value that falls not into the allowed range
then we get a compile-time or run-time range error. This can help us to prevent or to
discover errors in our programs.
Note that whenever we use range types, the compiler may have to add additional
checks to ensure that variables are always restricted to the specified range.
This check is active in debug mode and also when we compile with option <span>-d:release</span>,
and is only ignored when we compile with <span>-d:danger</span> or explicitly disable range checks.
So using a lot of range types may increase code size and decrease performance. For the example
above, the line with the assignment <span>d = a</span> generates a runtime check. An important and often used
range type is the data type Natural defined as <span>range[0 .. int.high]</span>. That type is compatible with the int type and
does not wraps around as <span>uint</span> would do. It is often used as type for procedure parameters when
the arguments has to be not negative. In the <span>proc</span> body we sometimes copy arguments of natural type
to an ordinary integer — that way we can ensure a none negative start value, and can avoid many
range checks in the procedure body.</p>
<p>We can also declare sub-range types with float base
types like <span>type Probability = range[0.0 .. 1.0]</span>.</p>
<p>Note that we can still mix different sub-range type:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>d</span><span>:</span> <span>Day</span> <span>=</span> <span>13</span>
<span>var</span> <span>m</span><span>:</span> <span>Month</span> <span>=</span> <span>3</span>
<span>d</span> <span>=</span> <span>d</span> <span>+</span> <span>m</span></code></pre>
</div>
</div>
<p>Such an operation is generally a bug, to prevent it we can put the distinct keyword
in front of our ranges. But then again we have to define the allowed operations our
self or to borrow them from the base type.</p>
</div>
<div>
<h3 id="_enums">Enums</h3>
<p>While enums in C are nothing more than integers with some special syntax for
creation, Nim’s enums are more complex.</p>
<p>In Nim <span>enums</span> can be used whenever some form of symbols are needed like the colors
red, yellow and green of a traffic light or the directions north, south, east and
west for a map or a game.</p>
<p>Most of the time we declare an enum type and the corresponding values by simple
listing them like</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>TrafficLight</span> <span>=</span> <span>enum</span>
    <span>red</span><span>,</span> <span>yellow</span><span>,</span> <span>green</span></code></pre>
</div>
</div>
<p>We can use variables of type TrafficLight then like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>tl</span><span>:</span> <span>TrafficLight</span>
<span>tl</span> <span>=</span> <span>green</span>
<span>if</span> <span>tl</span> <span>==</span> <span>red</span><span>:</span>
  <span>tl</span> <span>=</span> <span>...</span></code></pre>
</div>
</div>
<p>Enums support assignment, plain tests for (un)-equality and for smaller or greater.
Additional the functions <span>succ()</span> and <span>pred()</span> are defined for <span>enums</span> to get the successor
or predecessor of an enum, <span>ord()</span> or <span>int()</span> deliver the corresponding integer number
and the <span>$</span> operator can be used to get the name of an enum. We can also iterate over
enums, so we can print all the colors of our TrafficLight by</p>
<div>
<div>
<pre><code data-lang="nim"><span>for</span> <span>el</span> <span>in</span> <span>TrafficLight</span><span>:</span>
  <span>echo</span> <span>el</span><span>.</span><span>ord</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>$</span><span>el</span></code></pre>
</div>
</div>
<p>Ordinary enums start at <span>0</span> and uses continues numbers for the internal numeric value,
so that enums can be used as array indices.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>A</span> <span>=</span> <span>array</span><span>[</span><span>TrafficLight</span><span>,</span> <span>string</span><span>]</span>

<span>var</span> <span>a</span><span>:</span> <span>A</span>
<span>a</span><span>[</span><span>red</span><span>]</span> <span>=</span> <span>&#34;Rot&#34;</span>
<span>echo</span> <span>a</span><span>[</span><span>red</span><span>]</span></code></pre>
</div>
</div>
<p>But we can also assign custom numbers like</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>TrafficLigth</span> <span>=</span> <span>enum</span>
    <span>red</span> <span>=</span> <span>-</span><span>1</span><span>,</span> <span>yellow</span> <span>=</span> <span>3</span><span>,</span> <span>green</span> <span>=</span> <span>8</span></code></pre>
</div>
</div>
<p>We should avoid that, as these &#34;enums with holes&#34; generate some problems for the
compiler and may be later deprecated. For example array indexing or iterating is
obviously not possible for enums with holes.</p>
<p>It is also possible to set the string that the stringify operator <span>$</span> returns, like in</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>TrafficLigth</span> <span>=</span> <span>enum</span>
    <span>red</span> <span>=</span> <span>&#34;Stop&#34;</span>
    <span>yellow</span> <span>=</span> <span>(</span><span>2</span><span>,</span> <span>&#34;Caution&#34;</span><span>)</span>
    <span>green</span> <span>=</span> <span>(</span><span>&#34;Go&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>Here the assigned numerical values should be 0, 2 and 3. Currently the enums numerical values
must be specified in ascending order always.</p>
<p>When we have many enums in a program then name conflicts may occur, for example we
may have an additional enum type named BaseColor which also has red and green
members. For that case the {.pure.} pragma exists:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>BaseColor</span> <span>{.</span><span>pure</span><span>.}</span> <span>=</span> <span>enum</span>
    <span>red</span><span>,</span> <span>green</span><span>,</span> <span>blue</span></code></pre>
</div>
</div>
<p>With the pure pragma applied we can use the full qualified enum name when necessary,
like BaseColor.red. But we can still use unqualified names like blue when there is no
name conflict.</p>
</div>
<div>
<h3 id="_boolean_types">Boolean types</h3>
<p>Boolean types are used to store the result of logic operations. The type is called
<span>bool</span> in Nim and can store only two values, <span>false</span> and <span>true</span>. Although we have only two
distinct states for a boolean variable and so one single bit would suffice to store a
<span>bool</span>, generally a whole byte (8 bits) is used for storing a boolean variable. Most
other programming languages including C do the same. The reason is that most CPU’s
can not access single bits in the RAM — the smallest entity that can be directly
accessed in RAM is a byte. The default initial state of a boolean variable is <span>false</span>,
corresponding to a byte with all bits cleared.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>age</span> <span>=</span> <span>17</span>
  <span>adult</span><span>:</span> <span>bool</span> <span>=</span> <span>age</span> <span>&gt;</span> <span>17</span>
  <span>iLikeNim</span> <span>=</span> <span>true</span>
  <span>iLikeOtherLangaugeBetter</span> <span>=</span> <span>false</span><span>.</span></code></pre>
</div>
</div>
<p>In line three we assign to the variable adult the result of a logical comparison. The
next two lines assign the boolean constants <span>true</span> and <span>false</span> to the
variables, with their type <span>bool</span> inferred.</p>
<p>Variables of type <span>bool</span> support the operators <span>not</span>, <span>and</span>,
<span>or</span> and <span>xor</span>. <span>Not</span> inverts the logic value, <span>a and b</span> is only
true when both values are true, and false otherwise. And <span>a or b</span> is true when
at least one of the values is true, and only false when both values are false.
<span>Xor</span> is not used that often. It is called <span>exclusive or</span>, <span>a xor b</span> is
false when both values have the same logic state, that is when both are true, or both
are false. When the values are not the same, than the result of the xor operator is
true. The <span>xor</span> operator makes more sense for bit operations, which we will
learn later — for the boolean type, <span>a xor b</span> is identical to <span>a != b</span>.</p>
<p>When using conditional execution, some people like to write expressions like
<span>if myBoolExp == false:</span>, which is identical to <span>if not myBoolExp:</span>.
Well they may do, but please never write <span>if myBoolExp == true:</span>, that looks
really too stupid.</p>
<p>Sometimes it is useful to know that <span>false</span> is mapped to the int value <span>0</span>, and <span>true</span>
to the int value <span>1</span>. That is similar to the C language, but C has not a bool type, instead
the numerical value <span>0</span> is interpreted as <span>false</span> in conditional expressions, and all
none zero values are interpreted as true.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>:</span> <span>int</span> <span>=</span> <span>0</span>
<span>if</span> <span>cond</span><span>:</span>
  <span>a</span> <span>=</span> <span>7</span>

<span>a</span> <span>=</span> <span>7</span> <span>*</span> <span>cond</span><span>.</span><span>int</span></code></pre>
</div>
</div>
<p>The effect of the last line is identical to the <span>if</span> statement above. In very, very rare cases
working with the actual int value of boolean variables may make sense, but generally we should
avoid that. Later in the book there is a section about <span>branchless code</span> where we will
present a <span>proc</span> that actually may get faster by using such a trick.</p>
</div>
<div>
<h3 id="_characters">Characters</h3>
<p>The data type for single characters is called <span>char</span> in Nim. A variable of type <span>char</span>
has 8 bits and can store single characters. Indeed it stores 8-bit integers which are
mapped to characters. The mapping is described by the ASCII table. For example the
integer value <span>65</span> in decimal is mapped to the character <span>A</span>. When we use single
character literals, then we have to enclose the letter in single quotes. As only 8
bits are used to store characters, we only have 256 different values, including upper
and lower case letters, punctuation characters and some characters with a special
meaning like a newline character to move the cursor in the terminal to the next line,
or a backspace character to move the cursor one position backwards. Single characters
are not used that often since we generally group them in sequences called strings to
build text.</p>
<p>The initial ASCII table contains only the characters with numbers 0 up to 127, here
is an overview generated with the small program listed in the appendix:</p>
<div>
<div>
<pre>Visible ASCII Characters

      +0   +1   +2   +3   +4   +5   +6   +7   +8   +9  +10  +11  +12  +13  +14  +15
  0
 16
 32        !    &#34;    #    $    %    &amp;    &#39;    (    )    *    +    ,    -    .    /
 48   0    1    2    3    4    5    6    7    8    9    :    ;    &lt;    =    &gt;    ?
 64   @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O
 80   P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _
 96   `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o
112   p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~</pre>
</div>
</div>
<p>The position in the table is the sum of the number on the left and the number on the
top, i.e, character <span>A</span> has position <span>64+1=65</span>, which is the value the Nim standard
function <span>ord(&#39;A&#39;)</span> or <span>int(&#39;A&#39;)</span> would return. The characters with a
decimal value less than 32 can not be printed and are called <span>control characters</span>, like
linefeed, carriage return, backspace, audible beep and such. Character 127 is also
not printable, and is called DEL. An important property of this table is the fact
that decimal digits and upper- and lower-case letters form contiguous blocks. So to
test for example if a characters is an uppercase letter we can use this simple
condition: <span>c &gt;= &#39;A&#39; and c &lt;= &#39;Z&#39;</span>.</p>
<p>Characters with <span>ord() &gt; 127</span> are so called umlauts, exotic characters of other
languages, and some special characters. But these characters may be different on
different computers, as the characters depend on the active <span>code-page</span>, which maps
position to actual character, and there are multiple code pages. When we need more
than the plain ASCII characters, then we use strings in Nim, which display many more
glyphs by using UTF-8 encoding.</p>
<p>The control characters with a decimal value less than 32 can not be typed on the
keyboard directly and for some characters with decimal value greater than 126 it can
be difficult to enter them on some keyboards. For these characters as well as for all
other characters escape sequences can be used. Escape sequences start with the
backslash character, and the following characters are interpreted in a special way:
The backslash can follow a numeric value in decimal or hexadecimal encoding, or a
letter which is interpreted in a special way. We mentioned already that the character
&#39;A&#39; is mapped to the decimal value 65, which is its position in the ASCII table. So
instead of &#39;A&#39; we could use the escape sequence &#39;\65&#39; for this character. Or, as
decimal 65 is 41 in hexadecimal notation <span>(4 * 16^1 + 1 * 16^0)</span> we can use
&#39;\x41&#39; where the x indicates that the following digits are hexadecimal. For common,
often used control characters it is not easy to remember their numeric value, so
another notation with a letter following the backslash can be used. For the important
newline character we can use the decimal numeric value &#39;\10&#39;, the hexadecimal value
&#39;\xA&#39; or the symbolic form &#39;\n&#39;. Here the letter n stands for newline.</p>
<p>We can regard the backslash character, which introduces escape sequences, as a special
hinting symbol for the compiler: <span>Caution, the following characters must be interpreted in a special
way</span>.</p>
<p>It is important that you understand that all these escape sequences are only
a way to help the programmer to enter these invisible control characters — the
compiler replaces the control sequences immediately with the correct 8 bit
value from the ASCII table, so in the final compiled executable &#39;\65&#39; or &#39;\n&#39;
are both only a plain 8 bit integer value:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>char</span>
<span>a</span> <span>=</span> <span>&#39;A&#39;</span>
<span>b</span> <span>=</span> <span>&#39;</span><span>\65</span><span>&#39;</span>
<span>echo</span> <span>a</span><span>,</span> <span>ord</span><span>(</span><span>a</span><span>),</span> <span>b</span><span>,</span> <span>ord</span><span>(</span><span>b</span><span>)</span> <span># if you don&#39;t know the output, read again this section and run this code.</span></code></pre>
</div>
</div>
<p>The following
table lists a few important control characters:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Decimal</th>
<th>Hexadecimal</th>
<th>Symbolic</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>10</p></td>
<td><p>xA</p></td>
<td><p>\n, \l</p></td>
<td><p>newline or linefeed — move cursor one position down</p></td>
</tr>
<tr>
<td><p>12</p></td>
<td><p>xC</p></td>
<td><p>\f</p></td>
<td><p>formfeed</p></td>
</tr>
<tr>
<td><p>9</p></td>
<td><p>x9</p></td>
<td><p>\t</p></td>
<td><p>tabulator</p></td>
</tr>
<tr>
<td><p>11</p></td>
<td><p>xB</p></td>
<td><p>\v</p></td>
<td><p>vertical tabulator</p></td>
</tr>
<tr>
<td><p>92</p></td>
<td><p>x5C</p></td>
<td><p>\\</p></td>
<td><p>backslash</p></td>
</tr>
<tr>
<td><p>39</p></td>
<td><p>x27</p></td>
<td><p>\&#39;</p></td>
<td><p>single quote, apostrophe</p></td>
</tr>
<tr>
<td><p>7</p></td>
<td><p>x7</p></td>
<td><p>\a</p></td>
<td><p>alert, audible beep</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>x8</p></td>
<td><p>\b</p></td>
<td><p>backspace</p></td>
</tr>
<tr>
<td><p>27</p></td>
<td><p>x1B</p></td>
<td><p>\e</p></td>
<td><p>Escape, [ESC]</p></td>
</tr>
<tr>
<td><p>13</p></td>
<td><p>xD</p></td>
<td><p>\r, \c</p></td>
<td><p>return or carriage return — move cursor at the beginning of the line</p></td>
</tr>
</tbody>
</table>
<p>The hexadecimal numbers after the <span>\x</span> character can be upper or lower case
and can have one or two hexadecimal digits. For symbolic control characters like &#39;\a&#39;
for alert the upper case variant &#39;\A&#39; seems to be identical currently. The single
quote entered as <span>&#39;&#39;&#39;</span> does give an error message, so you have to escape it as <span>&#39;\&#39;&#39;</span>.
Unfortunately by supporting this form of escaping it becomes impossible to enter a
backslash character directly, so we have to escape the backslash character as <span>&#39;\\&#39;</span> to
print a single backslash.</p>
<p>For Nim the most important control character is <span>&#39;\n&#39;</span> which is used to start the
output in a terminal window at the beginning of a new line. But <span>&#39;\n&#39;</span> is generally not
used as a single character but embedded in <span>strings</span>, that is sequences of characters.
We will learn more about strings soon. Note that the <span>echo()</span> function inserts a
newline character automatically after each printed line, but the <span>write()</span> function
does not:</p>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>&#39;N&#39;</span><span>,</span> <span>&#39;i&#39;</span><span>,</span> <span>&#39;m&#39;</span>
<span>stdout</span><span>.</span><span>write</span> <span>&#39;N&#39;</span><span>,</span> <span>&#39;i&#39;</span><span>,</span> <span>&#39;m&#39;</span><span>,</span> <span>&#39;</span><span>\n</span><span>&#39;</span></code></pre>
</div>
</div>
<p>What may be a bit confusing is the fact that we use the backslash character as escape
symbol, and at the same time above table has an entry <span>&#39;\e&#39;</span> which is also called
[ESC]. These <span>&#39;\e&#39;</span> control character with decimal value <span>27</span> is fully unrelated to the
backslash character that we use to type in control characters. [ESC] is a different special
character to start control sequences, it was used in the past to send special
commands to printers or modems, and can be used to control font style or colors in
terminal windows.</p>
<p>Nim’s control characters should, with few exceptions, be identical with control
characters of the C language, so you may also consult C literature for more details.</p>
</div>
<div>
<h3 id="_ordinal_types">Ordinal types</h3>
<p>In Nim integers, enumerations, characters and the boolean types are ordinal types.
Ordinal types are countable and ordered, and for each of these types a lowest and
largest member exists. The integer ordinal types supports the inc() and dec()
operations to get the next larger or next smaller value, and the other ordinal types
use succ() and pred() for this operation. These operations can produce overflow or
underflow like errors if applied to largest or smallest value. The function ord() can
be used on ordinal types to get the corresponding integer value. Note that unsigned
integers are currently not called ordinal types in Nim, and that these unsigned types
wrap around instead of generation overflow and underflow errors.</p>
</div>
<div>
<h3 id="_sets">Sets</h3>
<p>From mathematics we know that sets are some form of unordered collection for which we
can test membership (x is included in mySet) and we can perform general set
operations like union of multiple sets. In Nim we can have sets of all the ordinal
types and the unsigned integer types, but due to memory restrictions integer
types larger than two bytes can not be used as set base types.
All elements in a set must have the same base type. A set can be empty, or it
can contain one or multiple elements. For a specific element it can be contained in a
given set or it can be not contained, but it can be never contained multiple times.
One very basic set operation is the test if an element is contained in a set or is
not contained in it. Sets are unordered data types, that is sets containing the same
elements are always equal, it does not matter in which sequence we added the
elements. Important set operations are building the union and building the
difference of two sets with the same base type: The union of set <span>a</span> and set <span>b</span> is a set which contains all the elements
that are contained in set <span>a</span> or in set <span>b</span> (or in both). The intersection of set <span>a</span> and set <span>b</span>
is a set which contains only elements which are contained in set <span>a</span> and in set <span>b</span>.</p>
<p>The mathematical concept of sets maps well to words and bits of computers, as most
CPU’s have instructions to set and clear single bits and to test if a bit is set or
unset. And CPU’s can do <span>and</span>, <span>or</span> and <span>xor</span> operations which
corresponds to the union and intersection operation in mathematical set.</p>
<p>Nim supports sets with base type bool, enum, char, int8, uint8, int16 and uint16.
Note that we need a bit in the computer memory for each member of the base type. The
types char, int8 and uint8 are 8 bit types and can have 2^8 = 256 distinct values, so
we need 256 bits in the computer memory to represent such a set. That would be 32
bytes or four 64 bit words. To represent a set of the base type uint16 or int16 we
need already 2^16 bits, that is 2^13 bytes or 2^10 words on a 64 bit CPU. So it
becomes clear that supporting base types with more than 16 bit makes not much sense.</p>
<p>While testing if an element is included or is not included in a set with the <span>in</span> or
<span>notin</span> operators is always a very fast operation, other
operations like building the intersection or union and set comparison operations
may be not that fast when we use the int16 or uint16 base types, as for
these operations the whole set, that is 2^10 words on a 64 bit CPU, has
to be processed.</p>
<p>We will start our explanation with sets with character base type as these sets are
very easy to understand and at the same time very useful. Let us assume that we have
a variable of character type and we want to test if that variable is alphanumeric,
that is if it is a lower or upper case letter or a digit. A traditional test would be
<span>(x &gt;= a and x &lt;=+z) or (x +&gt;= A and x &lt;= Z) or (x &gt;= 0 and x &lt;= 9)</span>. Using Nim’s set
notation we can write that in a simpler form:</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span>
  <span>AlphaNum</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span> <span>=</span> <span>{</span><span>&#39;a&#39;</span> <span>..</span> <span>&#39;z&#39;</span><span>,</span> <span>&#39;A&#39;</span> <span>..</span> <span>&#39;Z&#39;</span><span>,</span> <span>&#39;0&#39;</span> <span>..</span> <span>&#39;9&#39;</span><span>}</span>

<span>var</span> <span>x</span><span>:</span> <span>char</span> <span>=</span> <span>&#39;s&#39;</span>
<span>echo</span> <span>x</span> <span>in</span> <span>AlphaNum</span></code></pre>
</div>
</div>
<p>Here we defined a constant of <span>set[char]</span> type which contains lower and upper case
letters and the decimal digits. We used the range notation to save us a lot of typing
({&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, …​}). It works in this case only, as we know that all the lowercase
letters, the upper case letters and the decimal digits built an uninterrupted range
in the ASCII table.</p>
<p>With that definition we can use a simple test with the <span>in</span> keyword. These test
is equivalent to the procedure call AlphaNum.contains(x). In compiled languages (most) set
operations are generally very fast as they map well to CPU instructions.</p>
<p>Older languages like C have not a dedicated set data type, but as sets are so useful
and efficient, C emulates these operations by using bit-wise <span>and</span> and <span>or</span>
operations in conjunction with bit shifts.</p>
<p>Two important operations for sets are building the union and the intersection:</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span>
  <span>AlphaNum</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span> <span>=</span> <span>{</span><span>&#39;a&#39;</span> <span>..</span> <span>&#39;z&#39;</span><span>,</span> <span>&#39;A&#39;</span> <span>..</span> <span>&#39;Z&#39;</span><span>,</span> <span>&#39;0&#39;</span> <span>..</span> <span>&#39;9&#39;</span><span>}</span>
  <span>MathOp</span> <span>=</span> <span>{</span><span>&#39;+&#39;</span><span>,</span> <span>&#39;-&#39;</span><span>,</span> <span>&#39;*&#39;</span><span>,</span> <span>&#39;/&#39;</span><span>}</span> <span># set[char]</span>

  <span>ANMO</span> <span>=</span> <span>AlphaNum</span> <span>+</span> <span>MathOp</span> <span># union</span>
  <span>Empty</span> <span>=</span> <span>AlphaNum</span> <span>*</span> <span>MathOp</span> <span># intersection</span></code></pre>
</div>
</div>
<p>The constant ANMO would now contain all the characters from AlphaNum and from MathOp,
that is letters, digits and math operators. The constant Empty would get all the
characters that are at the same time contained in set AlphaNum and in set MathOp. As
there is not a single common characters, the set Empty is indeed empty. Remembering
the two operators <span>+</span> and <span>*</span> for union and intersection is not easy. For
the intersection operator <span>*</span> it may help when we imagine the set members as
bits, and we assume that we multiply the bits of both operands bitwise, that is we
multiply the set or unset bits at corresponding position each. The resulting bit
pattern would get set bits only for positions where both arguments have set bits.</p>
<p>We can use the functions <span>incl()</span> and <span>excl()</span> to add or remove single set members:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span>
<span>s</span> <span>=</span> <span>{}</span> <span># empty set</span>
<span>s</span> <span>=</span> <span>{</span><span>&#39;a&#39;</span> <span>..</span> <span>&#39;d&#39;</span><span>,</span> <span>&#39;_&#39;</span><span>}</span>
<span>s</span><span>.</span><span>excl</span><span>(</span><span>&#39;d&#39;</span><span>)</span>
<span>s</span><span>.</span><span>incl</span><span>(</span><span>&#39;?&#39;</span><span>)</span></code></pre>
</div>
</div>
<p>The result is a <span>set</span> with letters <span>a</span>, <span>b</span>, <span>c</span> and the characters <span>_</span> and <span>?</span>. Note that
calling <span>incl()</span> has no effect when the value is already included in the set, and
calling <span>excl()</span> has no effect when the value is not contained in the set at all.</p>
<p>Another operation is the difference of two sets — <span>a - b</span> is a set which
contains only the elements of <span>a</span> which are not contained in <span>b</span>. In Nim there is
currently no operator for the complement or the symmetric difference of sets
available. We can produce a set complement by using a fully filled set and then
removing the elements of which we want the complement. For a character set that would
look like <span>{&#39;\0&#39;..&#39;\255&#39;} - s</span>, where <span>s</span> is the set to complement. And the symmetric
difference of set <span>a</span> and set <span>b</span> can be generated by the operation <span>(a+b) -
(a*b)</span> or by <span>(a-b) + (b-a)</span>.</p>
<p>As the <span>not</span> operator binds more tightly than the <span>in</span> operator, we have to use brackets
for the inverted membership test like <span>not(x in a)</span> or we can use the <span>notin</span>
operator and write <span>x notin a</span>. We can test for equality of sets <span>a</span> and <span>b</span> like
<span>a == b</span> and for subset relation <span>a &lt; b</span> or <span>a &lt;= b</span>. <span>a &lt;= b</span>
indicates that <span>b</span> contains at least all members of <span>a</span>, and <span>a &lt; b</span> that <span>b</span>
contains all members of <span>a</span> and at least one more element.</p>
<p>Finally we can use the function <span>card()</span> to get the cardinality of a <span>set</span> variable, that
is the number of contained members.</p>
<p>We should also mention that we can have character sets which are restricted to a
range of characters:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>CharRange</span> <span>=</span> <span>set</span><span>[</span><span>&#39;a&#39;</span> <span>..</span> <span>&#39;f&#39;</span><span>]</span>

<span># var y: CharRange = {&#39;x&#39;} #invalid</span>

<span>var</span> <span>y</span><span>:</span> <span>CharRange</span> <span>=</span> <span>{</span><span>&#39;b&#39;</span><span>,</span> <span>&#39;d&#39;</span><span>}</span>
<span>echo</span> <span>&#39;c&#39;</span> <span>in</span> <span>y</span></code></pre>
</div>
</div>
<p>In the code above the compiler detects the assignment to variable <span>y</span> as invalid.</p>
<p>Set of numbers work in principle in the same way as sets of characters. One problem
is that in Nim integer numbers are generally 4 or 8 bytes large, but sets can contain
only numbers with 1 or 2 byte size. So we have to specify the type of set members
explicitly:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>ChessPos</span> <span>=</span> <span>set</span><span>[</span><span>0&#39;i8</span> <span>..</span> <span>63&#39;i8</span><span>]</span>

<span>var</span> <span>baseLine</span><span>:</span> <span>ChessPos</span> <span>=</span> <span>{</span><span>0.</span><span>int8</span> <span>..</span> <span>7.</span><span>int8</span><span>}</span>
<span>var</span> <span>p</span><span>:</span> <span>int8</span>
<span>echo</span> <span>p</span> <span>in</span> <span>baseLine</span></code></pre>
</div>
</div>
<p>In the code above we defined a set type which can contain <span>int8</span> numbers in the range <span>0</span>
to <span>63</span>.</p>
<p>We can use also another notation for numeric sets when we define an explicit range
type like in</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>ChessSquare</span> <span>=</span> <span>range</span><span>[</span><span>0</span> <span>..</span> <span>63</span><span>]</span>
  <span>ChessSquares</span> <span>=</span> <span>set</span><span>[</span><span>ChessSquare</span><span>]</span>

<span>const</span> <span>baseLine</span> <span>=</span> <span>{</span><span>0.</span><span>ChessSquare</span> <span>..</span> <span>7.</span><span>ChessSquare</span><span>}</span>
<span># or</span>
<span>const</span> <span>baseLineExplicit</span><span>:</span> <span>ChessSquares</span> <span>=</span> <span>{</span><span>0.</span><span>ChessSquare</span> <span>..</span> <span>7.</span><span>ChessSquare</span><span>}</span>
<span>assert</span> <span>baseLine</span> <span>==</span> <span>baseLineExplicit</span></code></pre>
</div>
</div>
<p>What may be a bit surprising is the fact that Nim’s sets work also for negative
numbers:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>XPos</span> <span>=</span> <span>set</span><span>[-</span><span>3&#39;i8</span> <span>..</span> <span>+</span><span>2&#39;i8</span><span>]</span>

<span>var</span> <span>xp</span><span>:</span> <span>XPos</span> <span>=</span> <span>{</span><span>-</span><span>3.</span><span>int8</span> <span>..</span> <span>1.</span><span>int8</span><span>}</span>
<span>var</span> <span>pp</span><span>:</span> <span>int8</span> <span>=</span> <span>-</span><span>1</span></code></pre>
</div>
</div>
<p>Enum sets are also very useful and can be used to represent multiple boolean
properties in a single set variable instead of using multiple boolean variables for
this purpose:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>CompLangFlags</span> <span>=</span> <span>enum</span>
    <span>compiled</span><span>,</span> <span>interpreted</span><span>,</span> <span>hasGC</span><span>,</span> <span>isOpenSource</span><span>,</span> <span>isSelfHosted</span>
   <span>CompLangProp</span> <span>=</span> <span>set</span><span>[</span><span>CompLangFlags</span><span>]</span>

<span>const</span> <span>NimProp</span><span>:</span>  <span>CompLangProp</span> <span>=</span> <span>{</span><span>compiled</span><span>,</span> <span>hasGC</span><span>,</span> <span>isOpenSource</span><span>,</span> <span>isSelfHosted</span><span>}</span></code></pre>
</div>
</div>
<p>Enum sets can be used to interact with functions of C libraries where for flag
variables often or’ed ints are used. For example for the gintro C bindings there is
this definition:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>DialogFlag</span><span>*</span> <span>{.</span><span>size</span><span>:</span> <span>sizeof</span><span>(</span><span>cint</span><span>),</span> <span>pure</span><span>.}</span> <span>=</span> <span>enum</span>
    <span>modal</span> <span>=</span> <span>0</span>
    <span>destroyWithParent</span> <span>=</span> <span>1</span>
    <span>useHeaderBar</span> <span>=</span> <span>2</span>

  <span>DialogFlags</span><span>*</span> <span>{.</span><span>size</span><span>:</span> <span>sizeof</span><span>(</span><span>cint</span><span>).}</span> <span>=</span> <span>set</span><span>[</span><span>DialogFlag</span><span>]</span></code></pre>
</div>
</div>
<p>Here the {.size.} pragma is used to ensure that the byte size of that set type
matches the size of integers in C languages.</p>
<p>When we define set of enums in this way to generate bindings to C libraries, then we
have to ensure that the enum values start with zero, otherwise Nim’s definition will
not match with the C definition. For example in the gdk.nim module we have</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>AxisFlag</span><span>*</span> <span>{.</span><span>size</span><span>:</span> <span>sizeof</span><span>(</span><span>cint</span><span>),</span> <span>pure</span><span>.}</span> <span>=</span> <span>enum</span>
    <span>ignoreThisDummyValue</span> <span>=</span> <span>0</span>
    <span>x</span> <span>=</span> <span>1</span>
    <span>y</span> <span>=</span> <span>2</span>
    <span>pressure</span> <span>=</span> <span>3</span>
    <span>xtilt</span> <span>=</span> <span>4</span>
    <span>ytilt</span> <span>=</span> <span>5</span>
    <span>wheel</span> <span>=</span> <span>6</span>
    <span>distance</span> <span>=</span> <span>7</span>
    <span>rotation</span> <span>=</span> <span>8</span>
    <span>slider</span> <span>=</span> <span>9</span>

  <span>AxisFlags</span><span>*</span> <span>{.</span><span>size</span><span>:</span> <span>sizeof</span><span>(</span><span>cint</span><span>).}</span> <span>=</span> <span>set</span><span>[</span><span>AxisFlag</span><span>]</span></code></pre>
</div>
</div>
<p>The first enum with ordinal value zero was automatically added by the bindings
generator script to ensure type matching. Nim devs sometimes recommend to use plain
(distinct) integer constants for C enums. That may be easier, but integer constants
provide no name spaces, so names may be aFlagWheel instead of AxisFlag.wheel or plain
wheel when there is no name conflict for pure enums. And with integer constants we
have to combine flags by or operation like (aFlagWheel or aFlagSlider) instead of
clean {AxisFlag.wheel, slider}.</p>
<p>Can we print sets easily? As sets are an unordered type, it is not fully trivial, but
we can iterate over the full base type and check if the element is contained in our
set like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span> <span>=</span> <span>{</span><span>&#39;d&#39;</span> <span>..</span> <span>&#39;f&#39;</span><span>,</span> <span>&#39;!&#39;</span><span>}</span>

<span>for</span> <span>c</span> <span>in</span> <span>0.</span><span>char</span> <span>..</span> <span>255.</span><span>char</span><span>:</span>
  <span>if</span> <span>c</span> <span>in</span> <span>s</span><span>:</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>c</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
<span>echo</span> <span>&#39; &#39;</span></code></pre>
</div>
</div>

<p>We will learn how the for loop work soon. Note that the sequence in which the set
members are printed is determined by our query loop, not by the set content itself,
as sets are unordered types.</p>
</div>
<div>
<h3 id="_strings">Strings</h3>
<p>The <span>string</span> data type is a sequence of characters. It is used whenever a textual input
or output operation is performed. Usually it is a sequence of ASCII-only characters,
but multiple characters in the string can be interpreted as so called utf-8 unicode
characters, that allow displaying nearly unlimited symbols as long as all the needed
fonts are installed on your computer and you manage to enter them — unicode
characters may be not accessible by a simple keystroke. For now we will only use
ASCII characters, as they are simpler and work everywhere. String literals must be
enclosed in double quotes. Nim strings are similar to the Nim seq data types: both
are homogeneous variable-size containers. That means that a string or a seq expands
automatically when you append or insert characters or other strings. Don’t confuse
short strings with only one character with single characters: A string is a non
trivial entity with internal state like data buffer (the actual contained
characters), length and storage capacity why a variable of <span>char</span> type is nothing more than a
single byte interpreted in a special way. So a string like <span>&#34;x&#34;</span> is fully different
from <span>&#39;x&#39;</span>.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>str</span><span>:</span> <span>string</span> <span>=</span> <span>&#34;Hello&#34;</span>
  <span>name</span><span>:</span> <span>string</span>
<span>echo</span> <span>&#34;Please tell me your name&#34;</span>
<span>name</span> <span>=</span> <span>readLine</span><span>(</span><span>stdin</span><span>)</span>
<span>add</span><span>(</span><span>str</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
<span>echo</span> <span>str</span><span>,</span> <span>name</span></code></pre>
</div>
</div>
<p>In the above example code we declare a variable called <span>str</span> and assign it the initial
literal value <span>&#34;Hello&#34;</span>. We use the <span>echo()</span> procedure to ask the user
for his name, and use the <span>readLine()</span> procedure to read the user input from
the terminal. To show how we can add characters to existing <span>string</span> variables we call
the <span>add()</span> procedure to append a space character to our <span>str</span> variable, and
finally call the <span>echo()</span> procedure to print the hello message and the name to
the screen. Note that the <span>echo()</span> procedure automatically terminates each
output operation with a jump to the next line. If you want an output operation
without a newline, you can use the similar <span>write()</span> procedure. But write()
needs an additional first parameter, for which we use the special variable
<span>stdout</span> when we want to write to the terminal window.</p>
<p>So we could substitute the last two lines of the above code by</p>
<div>
<div>
<pre><code data-lang="nim"><span>write</span><span>(</span><span>stdout</span><span>,</span> <span>str</span><span>)</span>
<span>write</span><span>(</span><span>stdout</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
<span>echo</span> <span>name</span></code></pre>
</div>
</div>
<p>The Nim standard library provides a lot of functions for creating and modifying
strings, most of these functions are collected in the <span>system</span> and in the <span>strutils</span>
module. The most important procedures for strings are <span>len()</span> and <span>high()</span>. The <span>len()</span>
procedure returns the length of a string, that is the number of ASCII characters or
bytes that the string currently contains. The empty string <span>&#34;&#34;</span> has length zero. Note
that the plain <span>len()</span> function returns the number of 8-bit characters, not the number
of unicode glyphs when the string should be interpreted as unicode text. To determine
the number of glyphs of unicode strings you should use some of the <span>unicode</span> modules.
The <span>high()</span> function is very similar to the <span>len()</span> function, it returns the index of
the last character in the string. For each string <span>s</span> <span>high(s) == len(s) -1</span>,
so <span>high(&#34;&#34;)</span> is <span>-1</span>.
Remember
that Nim supports method call syntax, so we can also write <span>s.len</span> instead of <span>len(s)</span>.</p>
<p>The most important operators for strings are the subscript operator <span>[]</span> which
allows access to individual characters of strings, and the <span>..</span> slice operator
which allows access to sub-strings. The first character in a string has always the
index zero. For concatenation of string literals or string variables Nim uses the
<span>&amp;</span> operator.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span> <span>=</span> <span>&#34;We hate &#34;</span> <span>&amp;</span> <span>&#34;Nim?&#34;</span>
<span>s</span><span>[</span><span>3</span> <span>..</span> <span>6</span><span>]</span> <span>=</span> <span>&#34;like&#34;</span>
<span>s</span><span>[</span><span>s</span><span>.</span><span>high</span><span>]</span> <span>=</span> <span>&#39;!&#39;</span></code></pre>
</div>
</div>
<p>In the example above we define the string variable <span>s</span> by use of two literal strings to show the
use of the concatenation operator. In line two we use the slice operator to replace
the sub-string <span>&#34;hate&#34;</span>, that is the characters with index position 3 up to 6, with the string literal <span>&#34;like&#34;</span>. In
this case the replacement has exactly that many characters as the text to replace,
but that is not necessary: We can replace sub-strings with longer or shorter strings,
which includes the empty string <span>&#34;&#34;</span> to delete a text area. In the last line of above
example we use the subscript operator <span>[]</span> to replace the single character <span>&#39;?&#39;</span>
at the end of our string with an exclamation mark. For subscript and slice operators
Nim supports also a special notation which indicates indexing from the end of the
string. Python and Ruby use negative integers for this purpose, while Nim uses the
<span>^</span> character. So <span>[^1]</span> is the last character, <span>[^2]</span> the one before
the last. So we could have written <span>s[^1] = &#39;!&#39;</span> for the last line of our code
fragment above. The reason that Nim does not use negative integers for this purpose
is that Nim arrays don’t have to start at index zero, but can start with an arbitrary
index including negative indices, so for negative indices it may be not always clear
if a regular index or a position from the end of the string is desired. The term
<span>s[^x]</span> is equivalent to <span>s[s.len - x]</span>. We will learn some more
details about the slice operator in a later section when we have introduced arrays
and sequences.</p>
<p>Another important operator for strings is the &#34;toString&#34; or stringify operator
<span>$</span>. It can be applied to variables of nearly all data types
and returns its string representation
which can then be printed. Some procedures like <span>echo()</span> apply this operator on its
arguments automatically. When we define our own data types then it can make some
sense to define the <span>$</span> for them, in case we need a textual representation of
our data — maybe only for debugging purpose. Note that applying the <span>$</span>
operator on a string directly has no effect and is ignored, as the result would not
change.</p>
<p><span>Strings</span> can contain all characters of the <span>char</span> data type including the control
characters. The most important control character for strings is the newline character
<span>&#39;\n&#39;</span> which is used at the end or sometimes also in the middle of strings to start a new line. For
strings Nim also supports the virtual character <span>&#34;\p&#34;</span> to encode an OS dependent line
break. When compiled for Windows, <span>&#34;\p&#34;</span> is automatically converted to <span>&#34;\r\n&#34;</span>, and to
a plain <span>&#39;\n&#39;</span> on Linux. Note that <span>&#34;\p&#34;</span> can be used in strings, but not as single
character, as it is two byte on Windows. <span>&#34;\p&#34;</span> is only needed to support very old
Windows version or maybe other exotic operating system, as modern Windows recognizes plain <span>&#39;\n&#39;</span>
well.</p>
<p>As strings support utf-8 unicode, an escape sequence starting with <span>&#34;\u&#34;</span> is supported
to insert unicode codepoints. The <span>&#34;\u&#34;</span> follows exactly 4 hexadecimal digits or an
arbitrary number of hex digits enclosed in curly braces {}.</p>
<p>As string literals are enclosed in quotation marks, it follows that strings can not
directly contain this character, we have to escape it as in <span>&#34;\&#34;Hello\&#34;, she
said&#34;</span>.</p>
<p>Maybe we should mention that Nim strings use copy semantics for assignment. As we
have not yet introduced references or pointers, copy semantics is what you should
expect — strings behave just like all the other simple data types we used before
like integer or float numbers or enums and characters:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>s1</span><span>:</span> <span>string</span>
  <span>s2</span><span>:</span> <span>string</span>
<span>s1</span> <span>=</span> <span>&#34;Nim&#34;</span>
<span>s2</span> <span>=</span> <span>s1</span>
<span>s1</span><span>.</span><span>add</span><span>(</span><span>&#34; is easy!&#34;</span><span>)</span>
<span>echo</span> <span>s1</span> <span>&amp;</span> <span>&#34;</span><span>\n</span><span>&#34;</span> <span>&amp;</span> <span>&#34;s2&#34;</span></code></pre>
</div>
</div>
<p>The output is</p>

<p>The assignment <span>s2 = s1</span> creates a copy of <span>s1</span>, so the subsequent <span>add()</span>
operation does only modify <span>s1</span> but not <span>s2</span>. Probably not surprising for you, but other
programming languages may behave differently, i.e. the assignment may not copy the
textual content but create only a reference to the first string, so that modifying
one of then also effect the other. We will learn more about the concept of references
when we introduce the object data type.</p>
<div>
<h4 id="_entering_unicode_characters">Entering Unicode Characters</h4>


<p>In Nim we have four ways to enter unicode characters: As hexadecimal digits following
the &#34;\x&#34;, as unicode codepoint following the &#34;\u&#34; or we can type the unicode sequence
directly on our keyboard, as one single keystroke when our keyboard layout supports
that, or as a special OS dependent sequence of keystrokes:</p>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>&#34;</span><span>\xe2\x99\x9A</span><span> </span><span>\xe2\x99\x94</span><span>&#34;</span>
<span>echo</span> <span>&#34;\u265A \u2654&#34;</span>
<span>echo</span> <span>&#34;\u{265A} \u{2654}&#34;</span> <span># {} is only necessary for more than 4 hex digits</span>
<span>echo</span> <span>&#34;♚ ♔&#34;</span></code></pre>
</div>
</div>
<p>The code above shows three ways to print the symbol for a black and a white king of a
chess game. In the first line we typed the unicode sequence directly as hexadecimal
digits, this method is rarely used today. In the second line we used &#34;\u&#34; to enter
the codepoint directly, we get the code from
<a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters">https://en.wikipedia.org/wiki/List_of_Unicode_characters</a>. And finally we entered the
glyph directly in an editor. For some Linux editors like gedit we can hold down shift
and control key and then type u, release all keys and type the unicode digits like
265a and a space. See <a href="https://en.wikipedia.org/wiki/Unicode_input">https://en.wikipedia.org/wiki/Unicode_input</a> for details and
other operating system.</p>
</div>
<div>
<h4 id="_the_cstring_data_type">The CString data type</h4>
<p>In the C programming language strings are just pointers to sequences of characters of fixed
length. The end of such a C string is generally marked with the character <span>&#39;\x0&#39;</span> — a null byte with all bits cleared.
C functions like <span>printf()</span> needs these <span>&#34;\x0&#34;</span> characters to determine the end of the C
string. While Nim strings are complex entities that store its current size and other
properties, and can grow dynamically, the character sequence of Nim strings has also
a hidden terminating <span>&#39;\x0&#39;</span> character at the end to make them compatible with C
strings. Nim has also the data type cstring, called &#34;compatible string&#34; in modern
Nim, which matches the strings in C language if we compile as usual with the C backend.
Cstrings are used in bindings definitions for C libraries, but as cstrings can not
grow and do support only few string operations, they are only used in rare cases in
ordinary Nim source code. The Nim compiler passes automatically the zero terminated
data buffer of Nim strings to C libraries whenever we call a C library, so there is
no expensive type conversion involved. But the other way is much more expensive: When
you have an existing cstring and need a Nim string with same content, then a simple
conversion is not possible as a Nim string is a different, more complex entity. So we
have to create a Nim string and copy the content, you can use the stringify operator
<span>$</span> for this like in <span>myNimStr = $myCString</span>. Generally string creation
is an expensive operation compared to plain operations like adding two numbers, so
when performance matters one should try to avoid unnecessary string creation and also
unnecessary string operations. This is mostly important in loops, which are executed
often. We will explain more about the internal of strings and why string creation and
dynamically allocating memory is expensive in later sections of the book.</p>

</div>
<div>
<h4 id="_escape_sequences_in_strings">Escape Sequences in Strings</h4>
<p>We learned about control characters already in the section about characters, and
earlier in this section we mentioned that strings can also contain control
characters. As the use of control characters may be not really easy to understand, we
will explain their use in strings in some more detail and give a concrete example.</p>
<p>The most important control characters for strings is the newline character, which
moves the cursor in the terminal window to the beginning of the next line. The
<span>echo()</span> procedure prints that character automatically after each output
operation. Indeed it can be important to terminate each output operation with that
character, as the output can be buffered, and writing just a string without a
termination newline may not appear at once on the screen, but can be delayed. That is
bad when the user is asked something and should respond, but the message is still
buffered and not yet visible.</p>
<p>The problem with special characters like backspace or newline is that we can not
enter them directly with the keyboard. To solve
that problem, escape sequences were introduced for most programming languages. An
escape sequence is a special sequence of characters, that the compiler can discover
in strings and then replace with a single special character. Whenever we want a
newline in a string we type it as <span>&#34;\n&#34;</span>, that is, the backslash character
followed by an ordinary letter n, n for newline.</p>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
<span>echo</span> <span>&#34;Hello</span><span>\n</span><span>Hello</span><span>\n</span><span>Hello&#34;</span></code></pre>
</div>
</div>
<p>The first line prints two empty lines — two because the <span>\n</span> generates a jump
to next the line, and because <span>echo()</span> always adds one more jump to the next line. The
second line prints three lines which each contains the word <span>Hello</span>, and the cursor is
moved below the last <span>Hello</span>, because <span>echo()</span> automatically adds one more
newline character.</p>
<p>Older Windows versions used generally a sequence of two control characters to start a
new line, one <span>&#39;\r&#39;</span> (carriage-return) to move to the start of the line, and one <span>&#39;\l&#39;</span>
(linefeed) to move down. You may still find these two characters in old Windows text
files at the end of each line. Old printers used these combination too, so it was
possible to send that text files to old printers directly. Nim also has the special
escape sequence <span>&#34;\p&#34;</span> which is called platform dependent newline and maps to <span>&#34;\c\l&#34;</span> on
Windows. That is when we compile our program on Windows, then the compiler replaces
<span>&#34;\p&#34;</span> in our strings with a carriage-return and a linefeed character, and when we
compile on Linux then the compiler replaces <span>&#34;\p&#34;</span> only with a newline character. But
modern Windows supports <span>&#39;\n&#39;</span>, so we generally can use that.</p>
</div>
<div>
<h4 id="_raw_strings_and_multi_line_strings">Raw Strings and multi-line Strings</h4>
<p>In rare situations you may want to print exactly what you have typed, so you do not
want the compiler to replaces a <span>&#39;\n&#39;</span> by a newline character. You can do that in two
ways: You can escape the escape character, that is you put in front of the backslash
one more backslash. When you print the string <span>&#34;\\n&#34;</span> you will get a backslash and the
<span>n</span> character in your terminal. Or you can use so called raw strings, that is you put
the character <span>r</span> immediately in front of your string like</p>

<p>Multi-line strings are also raw strings, that is contained escape-sequences are not
interpreted by the compiler, and additional multi-line strings, as the name implies,
can extend over multiple lines of the source text. Multi-line texts starts and ends
with three quotes like in</p>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>&#34;&#34;&#34;this is
three lines
of text&#34;&#34;&#34;</span>

<span>echo</span> <span>&#34;this is</span><span>\n</span><span>three lines</span><span>\n</span><span>of text&#34;</span></code></pre>
</div>
</div>
<p>Both echo() commands above generates exactly the same machine code!</p>
</div>
</div>
<div>

<p>Comments are not really a data type, but they are also important. Ordinary comments
starts with the hashtag character <span>#</span> and extend to the end of the line. The <span>\</span>#
character itself and all following characters up to the line end are ignored by the
compiler. You can also start the comment with <span>\</span>\##, then it is a documentation comment.
It is also ignored by the compiler, but can be processed when you use later tools to
generate documentation for your code. Documentation comments are only allowed at
certain places, often they are inserted at the beginning of a procedure body to
explain its use. There are also multi-line comments, which starts with the two
characters #[ and ends with ]#. These form of comment can extend over multiple
lines and can be nested, that is multi-line comments can contain again plain or multi-line
comments.</p>
<div>
<div>
<pre><code data-lang="nim"><span># this is comment</span>
<span>## important note for documentation</span>
<span>#[ a longer</span>
<span>but</span> <span>useless</span> <span>comment</span>
<span>#]</span></code></pre>
</div>
</div>
<p>Multi-line documentation comments also exists and can also be nested.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>even</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span>
  <span>##[ This procedure</span>
  <span>returns</span> <span>true</span> <span>if</span> <span>the</span> <span>integer</span> <span>argument</span> <span>is</span>
  <span>even</span> <span>and</span> <span>false</span> <span>otherwise</span><span>.</span>
  <span>]</span><span>##</span>
  <span>return</span> <span>i</span> <span>mod</span> <span>2</span> <span>==</span> <span>0</span></code></pre>
</div>
</div>
<p>You can also use the #[ comment ]# notation to insert comments everywhere in the
source code at places where a white-space character is allowed, but these form of in
source comments is rarely used.</p>
</div>
<div>
<h3 id="_other_data_types">Other data types</h3>
<p>There exists some more predefined types like the container types <span>array</span> and <span>seq</span>, which
can contain multiple elements of the same type, or the <span>tuple</span> and the <span>object</span>  type which can contain data of
different types. Nim tuples and objects are
similar to C structs, they are not so verbose as Java classes. We will learn more
about all these types in later sections of the book.</p>
</div>
</div>
</div>
<div>
<h2 id="_nim_source_code">Nim Source Code</h2>
<div>
<p>You have already seen a few examples of simple Nim source code. The code is basically
a plain text file consisting of ASCII characters, that is the ordinary characters
which you can type on your keyboard. Generally Nim source code can also contain
unicode utf-8 characters, so instead of using names consisting of ASCII characters
for your symbol names, you could just use single unicode characters or sequences of
unicode characters. But generally that makes not much sense, entering unicode is not
that easy with a keyboard, and it is displayed only correctly on the screen or in the
terminal when the editor or terminal supports unicode properly and when all necessary
fonts are installed. That may be the case for your local computer, but what when
someone other may edit your source code?</p>
<p>Starting with Nim version 1.6 we got some support for unicode operators, which may
be useful for some applications. For details please see the Nim compiler manual.</p>
<p>Nim currently does not allow to insert tabular characters (tabs) in your source code,
so you have to do the indentation of blocks by spaces only. Generally we use two
spaces for each indentation level. Other numbers work also but you should stick to a
fixed value.</p>
<p>Names in Nim, as used for modules, variables, constants, procedures, user defined
types and other symbols may contain lower and upper case letters, digits, unicode
characters and additional underscores. But the names are not allowed to start with
digits or to start or end with an underscore, and one underscore may not follow
directly after another underscore.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>pos2</span><span>:</span> <span>int</span> <span># OK</span>
  <span>leftMargin</span><span>:</span> <span>int</span> <span># OK</span>
  <span>next_right_margin</span><span>:</span> <span>int</span> <span># OK</span>
  <span>_privat: int # illegal</span>
  <span>custom</span><span>_: int # illegal</span>
  <span>strange</span><span>__error: int # illegal</span></code></pre>
</div>
</div>
<p>Generally we use camel case like <span>leftMargin</span> for variable names, not snake case like
<span>left_margin</span>.</p>
<p>Current Nim has the special property that names are case insensitive and that
underscores are simple ignored by the compiler. The only exception is the first
letter of a name, that letter is case sensitive. So the names <span>leftMargin</span>, <span>leftmargin</span>
and <span>left_margin</span> are identical for the compiler. But <span>LeftMargin</span> is different to all
the others, because it starts with a capital letter. This may sound a bit strange at
first, but works well in practice. One advantage is, that a library author may use
<span>snake_case</span> in his library for names, but the users of the library can freely decide
if they prefer <span>camelCase</span>. But still you may think that all this generates confusion.
In practice it does not, it prevents confusion. Imagine a conventional programming
language, fully case sensitive and not ignoring underscores: In a larger program we
may then have names like <span>nextIteration</span> and <span>next_Iteration</span> or <span>keymap</span> and <span>keyMap</span>. What
when both names are visible in current scope, and we type the wrong one. The compiler
may not detect it when types match, but the program may do strange things. Nim would
not allow that similar looking names, as the compiler would regard them as identical
and would complain about a name redefinition.</p>
<p>You may ask why the first letter is case sensitive. That is to allow for user defined
types to use capital type names and then write something like <span>var window:
Window</span>. So we can declare a variable named <span>window</span> of a user defined data type named
<span>Window</span>. That is a common practice.</p>
<p>The case insensitivity and the ignoring of underscores may be not the greatest
invention of Nim, but it does not really hurt. The only exception is when we make
bindings to C libraries, where leading or trailing underscores are used, that can
make some renamings necessary.</p>
<p>The only minor disadvantage of Nim’s fuzzy names is when you use tools like grep or
your editor search functionality: You could not be sure if a search for &#34;KdTree&#34;
would give you all results, you would have to try &#34;Kd_Tree&#34; or &#34;KDTree&#34; and maybe
some more variants too. For that task Nim provides a tool called nimgrep that does a
case- and style-insensitive search. And maybe your editor supports that type of
search also. You can also enforce a consistent naming scheme when you call the
compiler with the command line argument <span>--styleCheck:error</span> or
<span>--styleCheck:hint</span>.</p>

<div>
<h3 id="_blocks_scopes_visibility_locality_and_shadowing">Blocks, Scopes, Visibility, Locality and Shadowing</h3>
<p>Like most other programming languages, Nim has the concept of <span>code blocks</span> or scopes.
The body of procedures, functions, iterators and templates, as well as the body of various loop constructs
or code following conditional statements builds an indented block and creates a new scope.
In this new scope we can define variables, named constants, or types
with the <span>var</span>, <span>let</span>, <span>const</span> and <span>type</span> keywords which
are local to this block.
These symbols are only visible in this scope, and
local variables that need storage are actually created when the program
executes the block, and destroyed when the block is left. Well, in principle, and at least for
ordinary stack allocated value variables, for references and pointer
variables, things are a bit more complicated, we will discuss that in more
detail when we introduce references.
Here we have used the term code block, to clearly separate them from the <span>const</span>, <span>var</span>,
<span>type</span> and <span>import</span> sections which are a different form of indented blocks.
Remember that the compiler processes our program code from the top to the bottom, so
we have always to define symbols before we can actually use them.
When we define an entity
in a code block, and a symbol with that name was already declared before
outside of this block, then that symbol is shadowed, that is the prior
declaration gets temporary invisible.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>doSomething</span> <span>=</span>
  <span>type</span> <span>NumType</span> <span>=</span> <span>int</span>
  <span>const</span> <span>Seven</span> <span>=</span> <span>7</span>
  <span>var</span> <span>a</span><span>:</span> <span>NumType</span> <span>=</span> <span>Seven</span>
  <span>var</span> <span>b</span><span>:</span> <span>bool</span> <span>=</span> <span>true</span>
  <span>if</span> <span>b</span><span>:</span>
    <span>echo</span> <span>a</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>b</span> <span># variables of outer scope are visible</span>
    <span>var</span> <span>a</span><span>,</span> <span>sum</span><span>:</span> <span>float</span> <span># now outer a is shadowed</span>
    <span>a</span> <span>=</span> <span>2.0</span>
    <span>sum</span> <span>=</span> <span>a</span> <span>*</span> <span>a</span> <span>+</span> <span>1</span>
    <span>echo</span> <span>a</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>sum</span> <span># local data only visible in if block</span>

  <span>echo</span> <span>a</span> <span># initial int variable with value 7 become visible again</span>

<span>doSomething</span><span>()</span></code></pre>
</div>
</div>
<p>While we have not officially introduced procedures as units
to structure our program code yet, we have put the above code
this time by intend into the body of a <span>proc</span> called <span>doSomething()</span>.</p>
<p>This way we can guarantee that the two variables <span>a</span> and <span>b</span> defined
in that <span>proc</span> are really stack allocated. Actually in real life programs
nearly all of the program code is embedded in <span>procs</span>. We will discuss
the peculiarity of global code later. In the <span>proc</span> body from above the
two variables <span>a</span> and <span>b</span> are local to the <span>proc</span> <span>doSomething()</span> — they are
created on the stack when the procedure is called, that is when we ask
to start it execution by a statement like <span>doSomething()</span>. These two
variables are never visible in code outside of this <span>proc</span>, and the
storage for these two variables is automatically released when execution
of that procedure ends, in this case when the last line of the <span>proc</span> is reached.
In the body of the <span>proc</span> we define although a new custom type and a named constant — just to show that it is possible. Both symbols are also local to this <span>proc</span> and invisible outside.</p>
<p>The indented block following the <span>if b:</span> statement is sometimes called a <span>&#34;if then&#34;</span> block
or just <span>if</span> block — in that block
we define
two other variables called <span>a</span> and <span>sum</span> of <span>float</span> type, which are also
stack allocated.
If these two variables are already allocated when the
proc starts its execution, or only when the <span>then</span> block following the <span>if</span> statements
is executed, is actually an implementation detail. As the variable <span>a</span> of <span>float</span> type in the
<span>if</span> then block has the same name as the outer variable of <span>int</span> type, that integer variable
is shadowed in the <span>if</span> block — the outer value gets temporary invisible
as soon as the new symbol is declared.
Other symbols of outer scopes remain visible.
In the <span>if then block</span> as well as in most other indented code blocks we could also define
named constants or custom types, these would be visible only in this block.
Indented code blocks can be nested — in one block we can have more indented block, for which all
declared symbols are again local and invisible outside.
The last <span>echo()</span> statement in our code example from above is already below the <span>if then
block</span>, so the initial variable a of integer type becomes again visible.</p>
</div>
<div>
<h3 id="_global_code">Global code</h3>
<p>In the introducing sections of the book we have generally used program
code at a global level, not embedded in a <span>proc</span> body.
We did that for simplicity and as we had not already introduced <span>procs</span>.
Global code is sometimes used in small scripts or for
special purposes, like program initialization. But for larger
programs most of the code is generally grouped in procedures.
For variables defined in global code it is not that well defined
where they are stored, it may depend on the actual Nim compiler implementation
and the compiler backend. The performance of global code can be
worse than code enclosed in <span>proc</span> bodies, so when performance maters we should
put our code in <span>procs</span>. One reason for the not optimal performance of global code is, that
global variables are not located on the stack,but in the global BSS segment of the program,
and that the backend can not optimize global code that well, e.g. global variables
may not be cached in CPU registers. Note that variables that have to exists and keep it value
for the whole runtime of the program, and not only for the duration of the execution of
a single <span>proc</span>, has to be defined as globals. The same holds obviously for global variables that
are used from code of different <span>procs</span>, like the stdout and stdin variables of the <span>system</span> module.
An alternative to the use of global variables when a variable used in a <span>proc</span> should keep its value
between different <span>proc</span> calls is to attach the {.global.} pragma to a <span>proc</span> local variable.
This way that variable is still only visible in that <span>proc</span> where the variable is declared, but
the variable is stored in the BSS segment instead on the stack and so its value is preserved
between <span>proc</span> calls.</p>
<p>Note that structured named constants, e.g. constant strings, are stored also in the BSS
segment, even when they are only defined local to a <span>proc</span>. So large structured constants
can increase the executable size, as the BSS segment is a part of the program executable.</p>
</div>
<div>
<h3 id="_white_space_punctuation_and_operators">White space, punctuation and operators</h3>
<p>The space character with decimal ASCII value <span>32</span> is used in Nim program code
to indent code blocks and to separate different symbols from each other. Nim keywords
are always separated with leading and trailing white-space from other symbols, while
other symbols are most often separated by punctuation and an additional optional space character.
Whenever the syntax allows a space, we can also insert multiple spaces or a comment
enclosed in #[ ]# in the source code. Tabulator characters are not allowed in the Nim source code, but we
can use them in comments and of course in string literals. We mentioned already,
that spaces can make a difference how operators or function parameters are handled.
In expressions like <span>a+b</span> or <span>a + b</span> the <span>+</span> operator is regarded as an infix operator, but
in <span>a + -b</span> the minus sign is regarded as unary operator bound to <span>b</span>.
This way asymmetric expressions like <span>a +b</span> or <span>a &lt;b</span> would be invalid,
as the operators are interpreted as unary ones attached to <span>b</span>, and then there
is no infix operator between the two variables.
A <span>proc</span> call like
<span>echo(1, 2)</span> is interpreted as a call of <span>echo()</span> with two integer literal arguments, while
a call like <span>echo (1, 2)</span> with a space after the <span>proc</span> name is interpreted in command invocation syntax as a call with a
tuple argument. While in C code it is not uncommon to always insert a space
between the function name and it parameter list, we should avoid that in Nim for the described reason.
We will learn more about <span>proc</span> calls and the tuple data type later.</p>
</div>
<div>
<h3 id="_operators">Operators</h3>
<p>Nim uses the following punctuation characters as operators:</p>
<div>
<div>
<pre>=, +, -, *, /, &lt;, &gt;, @, $, ~, &amp;, %, |, !, ?, ^, ., :, \</pre>
</div>
</div>
<p>These symbols can be used as single entities or in combination, and we can
define our own operators or redefine existing operators.
All these symbols can be used as infix operators between two arguments,
or as unary prefix operators, but Nim does not support unary postfix
operators, so a notation like <span>i++</span> as known from the C language is not possible in Nim.
There exists a few combinations
of these punctuation characters that have a special meaning, we will
learn more about that and how we can define our own operators later in the book.</p>
<p>In Nim these keywords are also used as operators:</p>
<div>
<div>
<pre>and, or, not, xor, shl, shr, div, mod, in, notin, is, isnot, of, as, from.</pre>
</div>
</div>
<p>Operators have different priorities, e.g. <span>*</span> and <span>/</span> have a higher
priority than <span>+</span> and <span>-</span>. In most cases the priority is just as we would
expect, maybe with a few exceptions. If we are unsure, we can group terms with
brackets, or consult the compiler manual for details.</p>
<p>Since version 1.6 Nim also allows to define and use a few unicode operators, but these
are still considered experimental. For details you should consult the compiler manual.</p>
</div>
<div>
<h3 id="_order_of_execution">Order of Execution</h3>
<p>Global program code or code in called <span>procs</span> is generally executed from top to the
bottom and from left to the right, as long as control structures do not enforce a different order.
To demonstrate this, we use here a set of four different <span>procs</span>, which contain an echo() statement each, and
return a numeric expression. Well, we have not yet formally introduced procedures, so if you should
feel too uncomfortable with the code below, just skip this section for now and come back when you have read the
section about <span>procs</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>a</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>echo</span> <span>&#34;a&#34;</span>
  <span>i</span> <span>*</span> <span>2</span>

<span>proc </span><span>b</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>echo</span> <span>&#34;b&#34;</span>
  <span>i</span> <span>*</span> <span>i</span>

<span>proc </span><span>c</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>echo</span> <span>&#34;c&#34;</span>
  <span>i</span> <span>*</span> <span>i</span> <span>*</span> <span>i</span>

<span>proc </span><span>d</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>echo</span> <span>&#34;d&#34;</span>
  <span>i</span> <span>+</span> <span>1</span>

<span>echo</span> <span>a</span><span>(</span><span>1</span><span>);</span> <span>echo</span> <span>b</span><span>(</span><span>1</span><span>)</span>
<span>echo</span> <span>b</span><span>(</span><span>2</span><span>)</span> <span>+</span> <span>d</span><span>(</span><span>c</span><span>(</span><span>3</span><span>))</span> <span># (2 * 2) + ((3*3*3) + 1)</span>
<span>echo</span> <span>&#34;--&#34;</span>
<span>echo</span> <span>a</span><span>(</span><span>1</span><span>)</span> <span>&lt;</span> <span>0</span> <span>and</span> <span>b</span><span>(</span><span>1</span><span>)</span> <span>&gt;</span> <span>0</span>
<span>echo</span> <span>a</span><span>(</span><span>1</span><span>)</span> <span>&gt;</span> <span>0</span> <span>or</span> <span>b</span><span>(</span><span>1</span><span>)</span> <span>&gt;</span> <span>0</span></code></pre>
</div>
</div>
<p>It should be no real surprise, that the first three echo() statements produce this output:</p>

<p>For the term <span>d(c(3))</span> it is obvious that the inner expression c(3) has
to be evaluated first, before that result can be used to call <span>proc</span> <span>d()</span>.</p>
<p>The last two lines demonstrate the so called short-cut-evaluation for expressions
with the boolean <span>and</span> or <span>or</span> operators. As the expression <span>a() and b()</span> is always <span>false</span>
when <span>a()</span> is <span>false</span>, for this case <span>b()</span> has not to be evaluated at all. In a similar way, as
the expression <span>a() or b()</span> is always <span>true</span> when <span>a()</span> is <span>true</span>, for that case <span>b()</span> has not to be evaluated at all.
So in the last two lines of above code <span>b()</span> is never called at all, and the output is just</p>

<p>Note that in Nim as in most other programming languages the assignment operator <span>=</span> behaves
different compared to ordinary operators like <span>+</span> or <span>*</span>, as in assignments like <span>let a = b + c()</span>
obviously the right side has to be evaluated before the result can be actually assigned to variable <span>a</span>.</p>
</div>
</div>
</div>
<div>
<h2 id="_control_structures">Control Structures</h2>
<div>
<p>Larger computer programs generally consists not only of code that is executed in a linear fashion, but contain
code for conditional or repeated execution.</p>
<p>The most important control structures of Nim are the <span>if</span> statement for conditional
execution, the related <span>case</span> statement and the <span>while</span> and <span>for</span> loops for repetitions.
All these statements controls the actual program execution at program runtime. Syntactically very similar to the <span>if</span>
statement is Nim’s <span>when</span> statement, which is already evaluated at compile time, and can be
used to adapt our program code for various operating system or to compile our code with special
options, e.g. for debugging or testing purposes.</p>
<p>All these control structures can be nested in arbitrary ways, so we can have in one <span>if</span> branch
other <span>if</span> conditions or <span>while</span> loops, and in <span>while</span> loops again other control structures
including other loops.</p>
<div>
<h3 id="_if_statement_and_if_expression">If Statement and If Expression</h3>
<p>The <span>if</span> statement with multiple optional <span>elif</span> branches and an optional <span>else</span> branch evaluates a sequence of
boolean conditions at program runtime. As soon as one condition evaluates as true the corresponding statement
block is executed, and after that the program execution continues after the whole <span>if</span>
construct. That is at most one branch is executed. If none of the conditions after
the <span>if</span> or <span>elif</span> keywords evaluates to <span>true</span>, then the <span>else</span> branch is executed if it
exists. A complete <span>if</span> statement consists of one <span>if</span> condition, an arbitrary number of <span>elif</span>
conditions and one optional <span>else</span> part:</p>
<div>
<div>
<pre><code data-lang="nim"><span>if</span> <span>condition1</span><span>:</span>
  <span>statement1a</span>
  <span>statement1b</span>
  <span>...</span>
<span>elif</span> <span>condition2</span><span>:</span>
  <span>statement2a</span>
  <span>statement2b</span>
  <span>...</span>
<span>elif</span> <span>condition3</span><span>:</span>
  <span>statement3a</span>
  <span>statement3b</span>
  <span>...</span>
<span>elif</span> <span>...:</span>
  <span>...</span>
<span>else</span><span>:</span>
  <span>statementa</span>
  <span>statementb</span>
  <span>...</span></code></pre>
</div>
</div>
<p>The most simple form of an if statement is</p>

<div>
<div>
<pre><code data-lang="nim"><span>if</span> <span>age</span> <span>&gt;</span> <span>17</span><span>:</span>
  <span>echo</span> <span>&#34;you may drink and smoke, but better avoid it!&#34;</span></code></pre>
</div>
</div>
<p>Note that the branches are indented by spaces, we use two spaces generally, but
other numbers work as well. And note that it is <span>elif</span>, not elsif like in
Ruby, and that there is a colon after the condition. Instead of a single statement we
can use multiple in each branch, all on its own line and all indented in the same way.</p>

<p>When there is no <span>elif</span> and no <span>else</span> part, then we can also write the conditional
code direct after the colon, like</p>
<div>
<div>
<pre><code data-lang="nim"><span>if</span> <span>age</span> <span>&gt;</span> <span>17</span><span>:</span> <span>echo</span> <span>&#34;you may drink and smoke, but better avoid it!&#34;</span></code></pre>
</div>
</div>
<p>With an <span>elif</span> and an <span>else</span> branch the example from above may look like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>age</span><span>:</span> <span>int</span> <span>=</span> <span>7</span>
<span>if</span> <span>age</span> <span>==</span> <span>1</span><span>:</span>
  <span>echo</span> <span>&#34;you are really too young to drive&#34;</span>
<span>elif</span> <span>age</span> <span>&lt;</span> <span>6</span><span>:</span>
  <span>echo</span> <span>&#34;you may drive a kids car&#34;</span>
<span>elif</span> <span>age</span> <span>&gt;</span> <span>17</span> <span>and</span> <span>age</span> <span>&lt;</span> <span>75</span><span>:</span>
  <span>echo</span> <span>&#34;you can drive a car&#34;</span>
<span>else</span><span>:</span>
  <span>echo</span> <span>&#34;drive carefully&#34;</span></code></pre>
</div>
</div>
<p>Note that we perform the age tests in ascending order — it would not make much sense
to first test for a condition <span>age &lt; 6</span>, and later to test for <span>age &lt; 4</span>, as the <span>if</span> statement
is evaluated from top to bottom, and as soon as one condition is evaluated as <span>true</span>, that branch
is executed and then the program execution continues after the whole <span>if</span> construct.
So a later test <span>age &lt; 4</span> would be useless, when that condition is already covered by a prior test <span>age &lt; 6</span>.</p>
<p>As the various conditions of the if statement are processed from top to bottom until one condition
evaluates to true, it can be a good idea to put the most likely conditions first for optional performance, as
then the unlikely conditions have not to be evaluated in most cases. Another strategy for larger if/elif
constructs is to put the most simple and fast tests to the top when possible.</p>
<p>We can also have if/else expressions which returns a value like in</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>speed</span><span>:</span> <span>float</span> <span>=</span> <span>if</span> <span>time</span> <span>&gt;</span> <span>0</span><span>:</span> <span>delta</span> <span>/</span> <span>time</span> <span>else</span><span>:</span> <span>0.0</span> <span># prevent div by zero error</span></code></pre>
</div>
</div>
<p>In C for a similar construct the ternary ? operator is used.</p>
<p>In languages like C or Ruby the assignment operator &#34;=&#34; is an expression which returns
the assigned value, so in C we can write code like</p>
<div>
<div>
<pre><code data-lang="c"><span>while</span> <span>(</span><span>char</span> <span>c</span> <span>=</span> <span>getChar</span><span>())</span> <span>{</span> <span>process</span><span>(</span><span>c</span><span>)}</span></code></pre>
</div>
</div>
<p>In Nim the assignment operator is not an expression with a result, but we can group
multiple statements in round brackets separated by semicolon, and when the last
statement in the bracket is an expression, than the whole bracket has the same value.
So we can use conditional terms like</p>
<div>
<div>
<pre><code data-lang="nim"><span>while</span> <span>(</span><span>let</span> <span>c</span> <span>=</span> <span>getChar</span><span>();</span> <span>c</span> <span>!=</span> <span>&#39;</span><span>\0</span><span>&#39;</span><span>):</span>
  <span>process</span><span>(</span><span>c</span><span>)</span></code></pre>
</div>
</div>
<p>If we declare a variable in this way using the <span>var</span> or <span>let</span> keyword then that variable
is only visible in the bracket expression itself and in the following indented block.</p>
<p>Note that if-expressions must always return a well defined value, so they must
always contain an <span>else</span> branch. A plain <span>if</span>, without an <span>else</span>, or an if/elif without an <span>else</span> does not
work. And as Nim is a statically typed language and all variables have a strictly well defined
type, the if-expression must return the same type for all branches!</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>:</span> <span>int</span>
<span>var</span> <span>b</span><span>:</span> <span>bool</span>
<span>a</span> <span>=</span> <span>if</span> <span>b</span><span>:</span> <span>1</span> <span>elif</span> <span>a</span> <span>&gt;</span> <span>0</span><span>:</span> <span>7</span> <span>else</span><span>:</span> <span>0</span> <span># OK</span>
<span>a</span> <span>=</span> <span>if</span> <span>b</span><span>:</span> <span>1</span> <span>elif</span> <span>a</span> <span>&gt;</span> <span>0</span><span>:</span> <span>7</span> <span># invalid</span>
<span>a</span> <span>=</span> <span>if</span> <span>b</span><span>:</span> <span>1</span> <span># invalid</span>
<span>a</span> <span>=</span> <span>if</span> <span>b</span><span>:</span> <span>1</span> <span>else</span><span>:</span> <span>0.0</span> <span># invalid, different types!</span></code></pre>
</div>
</div>
</div>
<div>
<h3 id="_the_when_statement">The When Statement</h3>
<p>The <span>when</span> statement is syntactically very similar to the <span>if</span> statement,
but while all the boolean conditions are evaluated during the program run time for the
<span>if</span> statement, for the <span>when</span> construct all the when/elif/else conditions have to be
constant expressions and are already evaluated at compile time.
In ordinary program code the <span>when</span> statement is not used that often, but it is
useful when we write bindings to C libraries and low level code.
Common use cases for the <span>when</span> statement are the <span>isMainModule</span> condition test and the
test for defined symbols like <span>defined(windows)</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>when</span> <span>not</span> <span>defined</span><span>(</span><span>gcDestructors</span><span>):</span>
  <span>echo</span> <span>&#34;You may try to compile your code with option --gc:arc&#34;</span>
<span>when</span> <span>isMainModule</span><span>:</span>
  <span>doAllTheTests</span><span>()</span></code></pre>
</div>
</div>
<p>The value <span>isMainModule</span> is only true for a source code file, when that file is compiled
directly as main module, that is when it is not indirectly compiled because it is imported by other modules.
This way we can include easily test code to our library modules — that test code is ignored when
the module is used as library, but active when we compile the module direct for testing.</p>
<p>A <span>when defined()</span> construct can be used to test for predefined or our own custom options, e.g. we may
give the optional option <span>-d:gintroDebug</span> to the compiler and test in the code of that module
for this option, like <span>when defined(gintroDebug):</span>.</p>
<p>One difference of the <span>when</span> to the <span>if</span> statement is, that the &#34;then&#34; branches do not open a new scope, so
variables which we define there are still visible after the construct has been processed:</p>
<div>
<div>
<pre><code data-lang="nim"><span>when</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span> <span>==</span> <span>2</span><span>:</span>
  <span>var</span> <span>intSize</span> <span>=</span> <span>2</span>
  <span>echo</span> <span>&#34;running on a 16 bit system!&#34;</span>
<span>elif</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span> <span>==</span> <span>4</span><span>:</span>
  <span>var</span> <span>intSize</span> <span>=</span> <span>4</span>
  <span>echo</span> <span>&#34;running on a 32 bit system!&#34;</span>
<span>elif</span> <span>sizeof</span><span>(</span><span>int</span><span>)</span> <span>==</span> <span>8</span><span>:</span>
  <span>var</span> <span>intSize</span> <span>=</span> <span>8</span>
  <span>echo</span> <span>&#34;running on a 64 bit system!&#34;</span>
<span>else</span><span>:</span>
  <span>echo</span> <span>&#34;cannot happen!&#34;</span>

<span>echo</span> <span>intSize</span> <span># variable is visible here!</span></code></pre>
</div>
</div>
<p>Another peculiarity of the <span>when</span> statement is, that it can be used inside object definitions — we will
show an example for that in a later section of the book when we introduce the <span>object</span>  data type.
In the same way as the <span>if</span> construct, <span>when</span> can also be used as an expression.</p>
</div>
<div>
<h3 id="_the_case_statement">The Case Statement</h3>
<p>The case statement is not used that often, but it can be useful when we have many
similar conditions:</p>
<div>
<div>
<pre><code data-lang="nim"><span>case</span> <span>inputChar</span>
<span>of</span> <span>&#39;x&#39;</span><span>:</span> <span>deleteWord</span><span>()</span>
<span>of</span> <span>&#39;v&#39;</span><span>:</span> <span>pastWord</span><span>()</span>
<span>of</span> <span>&#39;q&#39;</span><span>,</span> <span>&#39;e&#39;</span><span>:</span> <span>quitProgram</span><span>()</span>
<span>else</span><span>:</span> <span>echo</span> <span>&#34;unknown keycode&#34;</span></code></pre>
</div>
</div>
<p>To enable optimizations the case construct has some restrictions compared to a more
flexible if/elif statement:</p>
<p>The variable after the <span>case</span> keyword must have a so called ordinal type like
int, char or string, while float would not work. And the values after each
<span>of</span> keyword must be constant, that is a single constant value, multiple
constant values or a constant range like <span>&#39;a&#39; .. &#39;d&#39;</span> for the 4 first lower
case letters. Of course these constants must have a type compatible to the type of
the variable after the case keyword. A case statement must cover all possible cases,
so most of the time an else branch is necessary.</p>
<p>For Nim version 1.6 the case statement can contain also optional elif branches
with arbitrary boolean conditions. This was not the case in the wirthian languages
Pascal, Modula and Oberon, and makes Nim’s case construct now very similar
to the ordinary if/elif/else.</p>
<p>Unless the similar switch statement in C the case statement needs no break after each
branch. If a condition after a <span>of</span> keyword is true, then the corresponding
statement or statement sequence is executed, and after that program execution
continues after the whole case construct.</p>
<p>The case construct can also be used as an expression like in</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>j</span><span>:</span> <span>int</span>
<span>var</span> <span>i</span><span>:</span> <span>int</span> <span>=</span>
  <span>case</span> <span>j</span>
    <span>of</span> <span>0</span> <span>..</span> <span>3</span><span>:</span> <span>1</span>
    <span>of</span> <span>4</span><span>,</span> <span>5</span><span>:</span> <span>2</span>
    <span>of</span> <span>9</span><span>:</span> <span>7</span>
    <span>else</span><span>:</span> <span>0</span></code></pre>
</div>
</div>
<p>Here an else is necessary to cover all cases. And as you see we can also indent the
block after the case keyword if we want.</p>
</div>
<div>
<h3 id="_the_while_loop">The While Loop</h3>
<p>The <span>while</span> loop is used when we want to do conditional repetitions, that is,
if we want to check a condition and want to execute a block of statements only as
long, as the condition is <span>true</span>. If the condition is <span>false</span> in advance, or becomes <span>false</span>
after some repetitions, then the program execution proceeds after the indented loop body block.</p>
<p>A basic <span>while</span> loop has this shape:</p>
<div>
<div>
<pre>while condition:
  statement1
  statementN
firstStatementAfterTheWhileLoop</pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>repetitions</span> <span>=</span> <span>3</span>
<span>while</span> <span>repetitions</span> <span>&gt;</span> <span>0</span><span>:</span>
  <span>echo</span> <span>&#34;Nim is easy!&#34;</span>
  <span>repetitions</span> <span>=</span> <span>repetitions</span> <span>-</span> <span>1</span></code></pre>
</div>
</div>
<p>That loop would print the message three times. Like the condition in the <span>if</span> clause
the condition is terminated with a colon. Note that the condition must change during
execution of the loop, otherwise, when the condition is <span>true</span> for the first iteration,
it would remain <span>true</span> and the loop would never terminate. We decrease the loop counter
<span>repetitions</span> in the loop, so at some point the condition will become <span>false</span> and the
loop will terminate and program execution will continue with the first statement
after the loop body. Note how we decrement the loop counter: The right site of the
assignment operator is evaluated, after that is done, the new value is assigned to
the counter.</p>
<p>There exists two rarely used variants of a while loop: the loop body can contain a
<span>break</span> or a <span>continue</span> statement, which each consists only of this
single keyword. A <span>break</span> in the body stops execution of the loop immediately and
continues execution after the loop body. And a <span>continue</span> statement in the body skips
the following statements in the body and starts at the top again, the <span>while</span> condition
is evaluated again.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>input</span> <span>=</span> <span>&#34;&#34;</span>
<span>while</span> <span>input</span> <span>!=</span> <span>&#34;quit&#34;</span><span>:</span>
  <span>input</span> <span>=</span> <span>readLine</span><span>(</span><span>stdin</span><span>)</span>
  <span>if</span> <span>input</span> <span>==</span> <span>&#34;&#34;</span><span>:</span>
    <span>continue</span>
  <span>if</span> <span>input</span> <span>==</span> <span>&#34;exit&#34;</span><span>:</span>
    <span>break</span></code></pre>
</div>
</div>
<p>Above code used the <span>==</span> and the <span>!=</span> operators. The <span>==</span> operator does a
test for equality, and <span>!=</span> test for inequality. Both operator work for most data types
like integer, floats, characters and strings. The literal value of an empty string is
written <span>&#34;&#34;</span>. In line 2 we test if the variable named <span>input</span> has not the value <span>&#34;quit&#34;</span>,
and in line 4 we test of that variable is empty, that it contains no text at all.</p>
<p>Using of <span>break</span> and <span>continue</span> destroys the expected flow in loops, it can make
understanding loops harder. So we generally avoid their use, but sometimes <span>break</span> or
<span>continue</span> are really helpful. For example when an unexpected error occurs, maybe by
invalid user input.</p>
<p>There in no repeat loop as in Pascal in Nim, which does the first check at the end of
the loop when it was executed already for the first time. Repeat loops are not used
that much in Pascal, and they are some sort of dangerous, because they check the
condition after the first execution of the body, so maybe the body is executed with
invalid data for the first iteration. Later, we will see how we can use Nim macros to
extend Nim by a repeat loop that can be used as it would be part of Nim core
functionality.</p>
</div>
<div>
<h3 id="_the_block_statement">The Block Statement</h3>
<p>The block statement can be used to create a new indented block, which
creates a new scope, in the same way as a <span>when true:</span> statement would do:</p>
<div>
<div>
<pre>block: # create a new scope
  var i = 7
echo i # would not compile, as variable i is undefined</pre>
</div>
</div>
<p>Blocks can be useful to structure large code segments, when there are no better ways, as
splitting the code in multiple <span>procs</span>, available. For testing purposes blocks can be useful
too, to keep symbol in a local scope. But actually most useful are blocks, when the blocks
get attached names, and we use the break statement in a <span>while</span> or <span>for</span> loop to <span>break</span> out
of a nested loop:</p>
<div>
<div>
<pre>let names = [&#34;Nim&#34;, &#34;Julia&#34;, &#34;?&#34;, &#34;Rust&#34;]
block check:
  for n in names:
    for c in n:
      if c notin {&#39;a&#39; .. &#39;z&#39;, &#39;A&#39; .. &#39;Z&#39; }:
        echo &#34;invalid character in name&#34;
        break check
echo &#34;we continue&#34;</pre>
</div>
</div>
<p>The <span>break check</span> statement would immediately leave the nested loops and
continue with the first statement after the block, which is the last line
in the code segment above. Using <span>break</span> in such a way is not very nice, as
it may make it harder to understand the code structure, but sometimes
it can be very useful.</p>
</div>
<div>
<h3 id="_for_loops_and_iterators">For Loops and Iterators</h3>
<p>These are very useful and important in Nim and other programming languages. <span>For</span> loops are most
often used to iterate over containers or collections. We have not discussed the
important <span>array</span> and <span>seq</span> containers yet, but we know already the <span>string</span> container.</p>
<p>A <span>string</span> contains characters, the characters are numbered starting with <span>0</span>, and we can
access single characters of a <span>string</span> with the subscript operator <span>[]</span>, which
gets the position of the desired character as argument. So we could print the single
characters of a <span>string</span>, in this way:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>s</span> <span>=</span> <span>&#34;Nim is not always that easy?&#34;</span>
<span>pos</span> <span>=</span> <span>0</span>
<span>while</span> <span>s</span><span>[</span><span>pos</span><span>]</span> <span>!=</span> <span>&#39;?&#39;</span><span>:</span>
  <span>echo</span> <span>&#34;--&gt;&#34;</span><span>,</span> <span>s</span><span>[</span><span>pos</span><span>]</span>
  <span>inc</span><span>(</span><span>pos</span><span>)</span></code></pre>
</div>
</div>
<p>It is obvious that the <span>pos</span> variable is some sort of annoying here — we want to
process all the characters in the <span>string</span> in sequence, so why would we have to use a
position variable to do that. And this way is susceptible to errors, maybe we forget
increasing the <span>pos</span> variable in the loop body. So most modern languages provide us
with iterators for this purpose:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>s</span> <span>=</span> <span>&#34;Nim is not always that easy?&#34;</span>
<span>for</span> <span>ch</span> <span>in</span> <span>items</span><span>(</span><span>s</span><span>):</span>
  <span>echo</span> <span>&#34;--&gt;&#34;</span><span>,</span> <span>ch</span></code></pre>
</div>
</div>
<p>That is obvious shorter. The <span>for</span> construct may appear a bit strange, and it is
indeed, but it is a common way to write iterators, it is used in Python too. Ruby
uses something like s.each{|ch| …​} instead.</p>
<p><span>For</span> loops in Nim iterates over containers or collections, and pics each element in
sequence in this process. The variable after the <span>for</span> keyword is used to access or to
reference the single elements. That variable has automatically the right type, which
is the type of the elements in the container, and get in each iteration the value of
the next element in the container, starting by the first element in the container and
stopping when there is no element left. <span>Items()</span> is here the actual iterator,
which allows us to access the individual characters in sequence. It exists the
convention in Nim that an <span>items()</span> iterator is automatically called in a <span>for</span> loop
construct when no iterator name is explicitly given, so we could also write shorter
<span>for ch in s:</span> in this use case.</p>
<p>You may recognize that the output of the above <span>for</span> loop is not identical to the
output of the previous <span>while</span> loop. The <span>while</span> loop stops when the last character,
that is <span>&#39;?&#39;</span>, is reached, while the <span>for</span> loop processes this last character still. That
is intended for the <span>for</span> loop, its general purpose is to process all the elements in
containers or collections.</p>
<p>The above <span>for</span> loop does a read access to the string, that is, we get basically a copy
of each character, and we can not modify the actual <span>string</span> in this way. When we want
to modify the <span>string</span>, there is a variant available.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>s</span> <span>=</span> <span>&#34;Nim is not always that easy?&#34;</span>
<span>for</span> <span>ch</span> <span>in</span> <span>mitems</span><span>(</span><span>s</span><span>):</span>
  <span>if</span> <span>ch</span> <span>==</span> <span>&#39;?&#39;</span><span>:</span>
    <span>ch</span> <span>=</span> <span>&#39;!&#39;</span></code></pre>
</div>
</div>
<p>Here we use <span>mitems()</span> instead of the plain <span>items()</span>, the leading &#34;m&#34; stands for mutable.
In the loop body we can assign different values to the actual content.</p>
</div>
</div>
</div>
<div>
<h2 id="_objects">Objects</h2>
<div>
<p>We have worked with basic data types like numbers, characters and strings already.
Often it makes sense to join some variables of these basic data types to more complex
entities. Assume you want to build an online store to sell computers, and you want to
built a database for them. The database should contain the most important data of
each device type, like type of CPU, RAM and SSD size, power consumption,
manufacturer, quantity available, and actual selling price.</p>
<p>We can create a custom object data type with fields containing the desired data for
this purpose:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Computer</span> <span>=</span> <span>object</span>
    <span>manufacturer</span><span>:</span> <span>string</span>
    <span>cpu</span><span>:</span> <span>string</span>
    <span>powerConsumption</span><span>:</span> <span>float</span>
    <span>ram</span><span>:</span> <span>int</span> <span># GB</span>
    <span>ssd</span><span>:</span> <span>int</span> <span># GB</span>
    <span>quantity</span><span>:</span> <span>int</span>
    <span>price</span><span>:</span> <span>float</span></code></pre>
</div>
</div>
<p>We have to use the <span>type</span> keyword to tell the compiler that we want to define
a new custom type. Writing the <span>type</span> keyword on its own line begins a type section
where we can declare one or more custom data types. All type declarations in a type
section must be indented. In the next line we write our type name, an equal sign and
the keyword <span>object</span>. That indicates that we want to declare a new object type
named Computer. Here Computer is a type name, in Nim we use the convention that user
defined type names start with a capital letter. In the following indented block we
specify the desired fields, each line contains the name of a field, and a colon
followed by the needed data type. That is similar like a plain variable declaration.</p>
<p>Objects in Nim are similar to structs in C. Unlike classes in Java Nim objects
contain only the fields, sometimes also called member variables, but no procedures,
functions or methods, and no initializers or destructors as in C++. In Nim we keep
the data objects, and the procedures, functions, methods and also optional
initializers and destructors that work with that data objects separated.</p>
<p>Now that we have defined our own new object type, we can declare variables of that
type and store content in its fields.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>computer</span><span>:</span> <span>Computer</span>

<span>computer</span><span>.</span><span>manufacturer</span> <span>=</span> <span>&#34;bananas&#34;</span>
<span>computer</span><span>.</span><span>cpu</span> <span>=</span> <span>&#34;x7&#34;</span>
<span>computer</span><span>.</span><span>powerConsumption</span> <span>=</span> <span>17</span>
<span>computer</span><span>.</span><span>ram</span> <span>=</span> <span>32</span>
<span>computer</span><span>.</span><span>ssd</span> <span>=</span> <span>1024</span>
<span>computer</span><span>.</span><span>quantity</span> <span>=</span> <span>3</span>
<span>computer</span><span>.</span><span>price</span> <span>=</span> <span>499.99</span></code></pre>
</div>
</div>
<p>Of course in real applications we would fill the fields not in this way, but we would
maybe read the data from a file, from terminal or maybe from a graphical user
interface.</p>
<p>It may look a bit ugly that we have to write <span>computer.</span> before each field
when we access the fields. Indeed in recent Nim versions that is not necessary, you
may use the <span>with</span> construct now instead.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>with</span>
<span>var</span>
  <span>computer</span><span>:</span> <span>Computer</span>
<span>with</span> <span>computer</span><span>:</span>
	<span>manufacturer</span> <span>=</span> <span>&#34;bananas&#34;</span>
	<span>cpu</span> <span>=</span> <span>&#34;x7&#34;</span>
	<span>powerConsumption</span> <span>=</span> <span>17</span>
	<span>ram</span> <span>=</span> <span>32</span>
	<span>ssd</span> <span>=</span> <span>1024</span>
	<span>quantity</span> <span>=</span> <span>3</span>
	<span>price</span> <span>=</span> <span>499.99</span></code></pre>
</div>
</div>
<p>We can use the fields like ordinary variables:</p>
<div>
<div>
<pre><code data-lang="nim"><span>computer</span><span>.</span><span>quantity</span> <span>=</span> <span>computer</span><span>.</span><span>quantity</span> <span>-</span> <span>1</span> <span># we sold one piece</span>
<span>echo</span> <span>computer</span><span>.</span><span>quantity</span></code></pre>
</div>
</div>
<p>As you already know, the right side of the assignment operator is evaluated first,
then the result is stored in the variable on the left side. But we can also just
write <span>computer.quantity -= 1</span> or <span>dec(computer.quantity)</span>.</p>
<p>Generally a computer store would offer many different types of computers, so it would
make sense to store all the different devices in a container like a sequence, called
short <span>seq</span> in Nim.</p>
</div>
</div>
<div>
<h2 id="_arrays_and_sequences">Arrays and Sequences</h2>
<div>
<p>Sequences and arrays are homogeneous containers, they can contain multiple other
elements of the same data type, while a plain variable like a <span>float</span> or an <span>int</span> only
contains a single value. In some way we could regard <span>objects</span> also as containers,
because objects contain multiple fields. The same holds for <span>tuples</span> — tuples are a
very simple, restricted form of objects and also contain fields. But more typical
container data types are the built in arrays and sequences, or for example hash
tables which are provided by the Nim standard library. Arrays, sequences and hash
tables can contain multiple elements, but all elements must have the same data type,
which we call the base type. The data type of the base type is not restricted, it can be even
again array or sequence types, so we can built multidimensional matrices in this way.
Arrays have a fixed, predefined size, they can not grow or shrink during runtime of
our program. Sequences and hash tables can grow and shrink.</p>
<p>Arrays and sequences appear very similar, a sequence appears even more powerful
because it can change its size, that is the number of elements that it contains, at
runtime, while an array has a fixed size. So why do we have arrays at all? The reason
is mostly efficiency and performance. An array is a plain block of memory in the RAM
of the computer, which can be accessed very fast and needs not much care by the
runtime system. Sequences take much more effort, especially when we add elements and
the sequence has to grow. When we create sequences, we can specify how many elements
should fit in it at least and the runtime system reserves a block of RAM of the
appropriate size. But when our estimation was too small, and we want to append or
insert even more elements, then the runtime system may have to allocate a larger
block of memory first, copy the already existing elements at the new location, and
then release the old, now unnecessary memory block. And this is an relative slow
operation. The reason why this process can be necessary is, that the initially
allocated memory block may not increase in size because the neighborhood in the RAM
is already occupied by other data. Now let us see what we can do with arrays and
sequences:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>a</span><span>:</span> <span>array</span><span>[</span><span>8</span><span>,</span> <span>int</span><span>]</span>
  <span>v</span> <span>=</span> <span>1</span>
<span>for</span> <span>el</span> <span>in</span> <span>mitems</span><span>(</span><span>a</span><span>):</span>
  <span>el</span> <span>=</span> <span>v</span>
  <span>inc</span><span>(</span><span>v</span><span>)</span>
<span>for</span> <span>el</span> <span>in</span> <span>mitems</span><span>(</span><span>a</span><span>)</span>
  <span>el</span> <span>=</span> <span>el</span> <span>*</span> <span>el</span>
<span>for</span> <span>square</span> <span>in</span> <span>a</span><span>:</span>
  <span>echo</span> <span>square</span></code></pre>
</div>
</div>
<p>In the second line of the code above we declare a variable named <span>a</span> of <span>array</span> type — we want to use an array with exactly <span>8</span> elements, and each element should have the
data type <span>int</span>. To declare a variable of <span>array</span> data type we use the <span>array</span> keyword
followed in square brackets by the number of the elements, and separated by a comma,
the data type of the elements. We can also specify the range of the indices
explicitly by specifying a range like array[0 .. 7, int] or array[-4 .. 3, int]. The
first specification is identical to the one in above example program, and the second
one would allow us to access array elements with index positions from <span>-4</span> up to
<span>3</span>. or [int, 8].
It may help to remember that for plain variables the data type comes last also like
in var i: int.]</p>
<p>The first <span>for</span> loop of above program fills our <span>array</span> — that is for each of the <span>8</span>
storage places in the array we fill in some well defined data. We use the
<span>mitems()</span> iterator here, because we want to modify the content of our <span>array</span> — we fill in numbers <span>1 .. 8</span>. In the next <span>for</span> loop we square each storage location,
and finally we print the content. In the last <span>for</span> loop we do not modify the content,
so a plain <span>items()</span> instead of <span>mitems()</span> would work, but we already learned that we
have not to write the plain <span>items()</span> at all in this case.</p>
<p>Sequences work very similar like arrays, but they can grow:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>v</span> <span>=</span> <span>0</span>
<span>while</span> <span>v</span> <span>&lt;</span> <span>8</span><span>:</span>
  <span>inc</span><span>(</span><span>v</span><span>)</span>
  <span>add</span><span>(</span><span>s</span><span>,</span> <span>v</span><span>)</span>
<span>for</span> <span>el</span> <span>in</span> <span>mitems</span><span>(</span><span>s</span><span>)</span>
  <span>el</span> <span>=</span> <span>el</span> <span>*</span> <span>el</span>
<span>for</span> <span>square</span> <span>in</span> <span>s</span><span>:</span>
  <span>echo</span> <span>square</span></code></pre>
</div>
</div>
<p>We start with an empty <span>seq</span> here, and use the <span>add()</span> procedure to append
elements. After that we can iterate over the <span>seq</span> as we did for the <span>array</span>.</p>
<p>In the same way as we access single characters of a <span>string</span> with the subscript
operator <span>[]</span>, we can use that operator to access single elements of an <span>array</span> or a <span>seq</span> like in a[myPos]. The
slice operator is available for arrays and sequences too and can be used to extract
sub-ranges or to replace multiple elements. As arrays have a fixed length, the slice
operator can only replace elements in arrays, but not remove or insert ranges. The
first element position is generally <span>0</span> for arrays and sequences. Arrays can even be
defined in a way that the index position starts with an arbitrary value, but that is
not used that often. Whenever you use the subscript or slice operator you have to
ensure that you access only valid positions, that is positions that really exists.
<span>a[8]</span> or <span>s[8]</span> would be invalid in our above example — the array has only places
numbered <span>0 .. 7</span>, and for the <span>seq</span> we have added <span>8</span> values which now occupy positions <span>0
.. 7</span> also, position <span>8</span> in the <span>seq</span> is still undefined. We would get a runtime error if
we would try to access position <span>8</span> or above, as well when we would try to access negative
positions. You might think that an assignment for a <span>seq</span> like <span>s[s.length] = 9</span> is the
same as <span>s.add(9)</span>, but only the <span>add()</span> operation works in this case.</p>
<p>Note that in some languages like <span>Julia</span> arrays start at position <span>1</span>.
Nim arrays can have
an arbitrary integral start position, including negative start positions, but start
position as well as highest subscript position are determined in the program source
code and can not change at runtime. We say that arrays have fixed compile-time
bounds. Sequences starts always at position <span>0</span>, we can specify an initial size, and we can
always add more elements at runtime.</p>
<p>Arrays and sequences allow fast access to its elements: All the elements are stored
in a continues memory block in RAM, and the start location of that memory block is
well known. As all the elements have the same byte size, it is an easy operation to
find the memory location of each element. The compiler uses the start location of the
<span>array</span> or <span>seq</span>, and adds the product of subscript index and element byte size. The
result is the memory location of the desired element, which was selected by the index
used in the subscript operator. When the array should not start at position <span>0</span>, then
the compiler would have to adjust the index, by subtraction of the well known start
index. This operation takes not much time, but still arrays starting at position <span>0</span>
may be a bit faster. We said that the compiler has to do a multiplication of index position and
element size — that is an integer multiplication, which is very fast. When the
element size is a power of two, then the compiler can even optimize the
multiplication by using a simple shift operation, which may be even faster, depending
on your CPU.</p>
<p>It should be not surprising that the internal structure of sequences are a bit more
involved than arrays. Arrays are indeed nothing more than a block of memory,
generally allocated on the stack for local data or allocated in the BSS segment for
global data. Don’t worry when you have not yet an idea what the stack, the heap and a
BSS segment is, we will learn that soon. The Nim <span>seq</span> data type has a variable size,
so it is clear that it needs not only a storage location for its elements, but also a
counter to store how many elements it currently contains, and another counter how
many it could contain at most. The element counter must be updated when we add or
delete elements, and when the counters tells that there is currently no more space
available for more elements, then a new block of memory must be allocated, and the
existing elements must be copied from the old location into the newly allocated
memory region, before the old memory region can be released. Due to this additional
effort appending elements to a <span>seq</span> by using the <span>add()</span> procedure is not extremely
fast. You may wonder why we have not to save a size information for arrays. Well
arrays have fixed size, so it is obvious that we never have to adjust something like
a size counter, simple because size would never change. But would we have to save the
desired initial size of the array? Well, in some way yes. But it is a constant value.
During the compile process the compiler can catch some errors already for us — when
we have an array as above with size 8, then the compiler would be able already at
compile time to recognize some invalid access to array elements — a[9] would be a
compile time error for sure. But at runtime, when we execute our program, access to
not existing index position may occur, for example by constructs like <span>var i = 9; a[i]
= 1</span> when the array is declared as <span>var a: array[8, int]</span>. For catching that type of
error the compiler has to store the fixed array size somewhere and to check against
that value when an array access by using the subscript operator with a non constant
argument occurs, as the <span>a[i]</span> above. One related remark: Accessing array elements is
as fast as ordinary variable access when we use a constant value as index, that is a
constant literal or a named constant. The reason for this is, that when the index is
a constant, then the compiler just knows the exact position of that array element in
memory, just as it knows the address of plain variables, so there is no need for
address calculations at runtime. Actually, to access an array element with a given constant index
position, the compiler only has to add a constant value to the current stack pointer, as
arrays are stored on the stack. To access a constant position in a <span>seq</span>, the compiler would
have to add a constant to the base address of the memory block that contains the <span>seq</span> data.</p>
<p>We said that appending elements to sequences is not extremely fast — indeed it is a few
times slower than access to an <span>array</span> element by its index using the subscript
operator. So when we know that our <span>seq</span> will have to contain at least an initial
amount of elements, then it can be useful for maximum performance, that we allocate
the <span>seq</span> from the beginning for this size and than fill in the content by use of the
subscript operator instead that we append all the elements one by one. Here is one
example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span> <span>newSeq</span><span>[</span><span>int</span><span>]</span><span>(</span><span>8</span><span>)</span>
<span>var</span> <span>i</span><span>:</span> <span>int</span>
<span>while</span> <span>i</span> <span>&lt;</span> <span>8</span><span>:</span>
  <span>s</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>i</span> <span>*</span> <span>i</span>
  <span>inc</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>We use the <span>newSeq()</span> procedure to initialize the sequence for us, the content of the square
brackets tells the <span>newSeq()</span> procedure that we want a sequence with base type <span>int</span>, and
the number <span>8</span> as argument tells it that the newly created sequence should have <span>8</span> elements
with default value (0). This procedure is a so called generic procedure, it needs
additional information, which is the data type that the elements should have. Don’t
confuse the square bracket in the <span>newSeq[int]()</span> call with the subscript operator <span>a[i]</span>
which we have used for <span>array</span> access, both are completely unrelated. Note that the
initialization of the <span>seq</span> above does not restrict its use in any way, we can still
use it like an uninitialized seq, that is we can use the add() operator to add more
elements, we can insert or delete elements and all that.</p>
<p>Deleting elements from an array or from a sequence can be very slow.
It is slow
when we use the naive approach and move all the elements located after the element that should be removed
one position forward. This would obtain the order in the container, so sometimes this
is the only solution, but of course moving all the entries is expensive for large containers.
Nim’s standard library provides the <span>delete()</span> function for this order maintaining delete
operation. A much faster way to delete an entry in a <span>seq</span> or <span>array</span> is to remove the last entry
and replace the one that should be deleted with that last entry. This operation moves the last entry
to the front, so order of elements in not maintained. Nim’s standard library provides the <span>del()</span> function
for this faster, but order changing delete operation. Of course, whenever the order is not important,
we should use <span>del()</span>. The <span>delete()</span> and <span>del()</span> functions are actually only available for sequences, as
arrays have a fixed size — but in principle we could do similar operations with arrays as well, we have just to store
the actual used size somewhere.
</p>

<div>
<h3 id="_some_details">Some details</h3>
<p>Let us investigate at the end of this section some internal details about arrays and
sequences. Beginners not yet familiar with the concept of pointers should better skip
this subsection, and maybe come back later. We could consult the Nim language manual
or the compiler source code to learn more details about arrays and sequences. Or we
can write some code to test properties and behavior. Let us start investigating an
array:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>a</span><span>:</span> <span>array</span><span>[</span><span>4</span><span>,</span> <span>uint64</span><span>]</span>
  <span>echo</span> <span>sizeof</span><span>(</span><span>a</span><span>)</span>
  <span>a</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>7</span>
  <span>echo</span> <span>a</span><span>[</span><span>0</span><span>]</span>
  <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>a</span><span>)</span>
  <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>a</span><span>[</span><span>0</span><span>]</span><span>)</span>

  <span>var</span> <span>a2</span> <span>=</span> <span>a</span>
  <span>a</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>3</span>
  <span>echo</span> <span>a2</span><span>[</span><span>0</span><span>]</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we run this program we get this output:</p>
<div>
<div>
<pre>32
7
140734216410384
140734216410384
7</pre>
</div>
</div>
<p>The size of the whole array is 32, as we have 4 elements each 8 byte in size. And the
address of the array itself as well as the address of its first element is identical.
Remember that the actual address values will be different for each run of our
program, and they may be totally different on different computers, as it is some
random choice of the OS which free memory area is used to run our program. This
result is expected as the array is a plain block of memory stored on the stack. And
indeed the array has copy semantic, when we create a copy called <span>a2</span> and later modify
<span>a</span>, then the content of <span>a2</span> is unchanged. That was not really surprising, so let us
investigate a sequence:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>dummy</span><span>:</span> <span>int</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int64</span><span>]</span>
  <span>echo</span> <span>sizeof</span><span>(</span><span>seq</span><span>)</span>
  <span>echo</span> <span>sizeof</span><span>(</span><span>s</span><span>)</span>
  <span>s</span><span>.</span><span>add</span><span>(</span><span>7</span><span>)</span>
  <span>echo</span> <span>s</span><span>[</span><span>0</span><span>]</span>
  <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>dummy</span><span>)</span>
  <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>s</span><span>)</span>
  <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>s</span><span>[</span><span>0</span><span>]</span><span>)</span>

  <span>var</span> <span>s2</span> <span>=</span> <span>s</span>
  <span>s</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>3</span>
  <span>echo</span> <span>s2</span><span>[</span><span>0</span><span>]</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we run above code we get:</p>
<div>
<div>
<pre>8
8
7
140732171249104
140732171249112
140463681433696
7</pre>
</div>
</div>
<p>The first two lines of the output may confuse us, as a size of only 8 byte may
indicate a plain pointer value on a 64 bit system. Indeed the sequence is not a large
object that contains size and capacity fields, but only a tiny object that contains a
single pointer to the data storage of that sequence. We know that it is not a plain
pointer or ref by the fact that we can not assign nil or test for nil for sequences.
(But an object which contains only a pointer is basically identically to a plain
pointer, as Nim objects have no overhead as long as we do not use inheritance and
when no padding to word size is needed for tiny fields like int8.) Capacity and
length are stored also in the memory block that is allocated for the elements as long
as the sequence is not empty. So empty sequences don’t wast much memory when we have
a lot of them, i.e. arrays or sequences of sequences (matrices). We use the dummy
int variable in the code above as we know that plain ints are stored on the stack,
and when we compare the addresses of our dummy variable and our sequence, then we see
that the addresses indicate close neighborhood, so the <span>seq</span> object is also stored on
the stack. But the address of <span>s[0]</span> is very different, indicating that the data buffer
is stored in a different memory region, which is the heap. If we would continuously
add elements to the <span>seq</span>, then the address <span>s[0]</span> would change at some point, while the
address of <span>s</span> would remain always unchanged. That is because the capacity of the data
buffer would become exhausted at some point and a new data buffer with a different
address would be used. Finally we see again that the sequence has also copy semantic,
as the content of the copy <span>s2</span> remains unchanged when we modify the initial sequence
<span>s</span>. We could try to discover some more details of the internals of Nim’s sequences,
i.e. we could try to detect where the capacity and size is stored. But that are
internal details which should not really interest us and which may change with new
compiler version or different compilers.</p>
<p>But OK, you may still not believe what we said, so let us go one layer deeper. We
strongly assume that a <span>seq</span> needs a length and a capacity field. And we assume that
its data type should be <span>int</span>. We said that both fields should be adjacent to the
buffer of the seq elements, that means at the start or at the end. Obviously we can
not access the end as long as we do not know the capacity, so capacity field should
be at the start, and then length field also. We may find out which one is which by
observing the content when seq grows. So let us write some code:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span>
    <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int64</span><span>]</span> <span>=</span> <span>newSeqOfCap</span><span>[</span><span>int64</span><span>]</span><span>(</span><span>4</span><span>)</span>
    <span>s2</span><span>:</span> <span>seq</span><span>[</span><span>int64</span><span>]</span>
    <span>p</span><span>:</span> <span>ptr</span> <span>int</span>

  <span>var</span> <span>h</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>int</span><span>]</span><span>(</span><span>addr</span> <span>s2</span><span>)</span> <span># prove that an uninitialized seq is indeed a pointer with nil (0) value</span>
  <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>h</span><span>)</span> <span># address on stack</span>
  <span>echo</span> <span>h</span><span>[]</span> <span># value (0)</span>
  <span>echo</span> <span>&#34;&#34;</span>

  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>8</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>i</span><span>)</span>
    <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>s</span><span>[</span><span>0</span><span>]</span><span>)</span>
    <span>p</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>int</span><span>]</span><span>(</span><span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>s</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>-</span> <span>8</span><span>)</span> <span># capacity</span>
    <span>echo</span> <span>p</span><span>[]</span>
    <span>p</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>int</span><span>]</span><span>(</span><span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span> <span>s</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>-</span> <span>16</span><span>)</span> <span># length</span>
    <span>echo</span> <span>p</span><span>[]</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Output when we run the program is:</p>
<div>
<div>
<pre>140725732630192
0

140251431497824
4
1
140251431497824
4
2
140251431497824
4
3
140251431497824
4
4
140251431506016
8
5
140251431506016
8
6
140251431506016
8
7
140251431506016
8
8
140251431510112
16
9</pre>
</div>
</div>
<p>Don’t worry when you do not understand the program and the output yet. You will
better understand it when you have read the sections about references, pointers and
memory management. The first two output lines shows us that an uninitialized <span>seq</span> is
just a pointer pointing to <span>nil</span>. And the remaining output lines show us the address of
the first <span>seq</span> element, the capacity and the length of the <span>seq</span> whenever we add an
element. We started with a <span>seq</span> with initial capacity of <span>4</span>, so address and capacity
is constant while we add the first 4 elements. Then the capacity of the allocated
buffer is exhausted. A new buffer with different address and doubled capacity is
allocated, the already contained elements are silently copied to the start of the new
buffer and so on.</p>
</div>
</div>
</div>
<div>
<h2 id="_slices">Slices</h2>
<div>
<p>Nim slices are objects of type <span>Slice</span> that contain a lower <span>a</span> and an
upper bound <span>b</span>. The <span>system</span> module defines also the <span>HSlice</span> object called
heterogeneous slice for which the lover and and upper bound can have different data types:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>HSlice</span><span>*[</span><span>T</span><span>,</span> <span>U</span><span>]</span> <span>=</span> <span>object</span>   <span>## &#34;Heterogeneous&#34; slice type.</span>
    <span>a</span><span>*</span><span>:</span> <span>T</span>                  <span>## The lower bound (inclusive).</span>
    <span>b</span><span>*</span><span>:</span> <span>U</span>                  <span>## The upper bound (inclusive).</span>
  <span>Slice</span><span>*[</span><span>T</span><span>]</span> <span>=</span> <span>HSlice</span><span>[</span><span>T</span><span>,</span> <span>T</span><span>]</span> <span>## An alias for `HSlice[T, T]`.</span></code></pre>
</div>
</div>
<p>As the <span>Slice</span> and <span>Slice</span> objects are not a builtin type, their Names
start with capital letters. Slices are not used that often directly, but mostly indirectly with
the range operator, e.g. to access sub-ranges of strings and other containers.</p>
<p>One example for its direct use from the
<span>system</span> module is</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>contains</span><span>*[</span><span>U</span><span>,</span> <span>V</span><span>,</span> <span>W</span><span>]</span><span>(</span><span>s</span><span>:</span> <span>HSlice</span><span>[</span><span>U</span><span>,</span> <span>V</span><span>]</span><span>,</span> <span>value</span><span>:</span> <span>W</span><span>):</span> <span>bool</span> <span>{.</span><span>noSideEffect</span><span>,</span> <span>inline</span><span>.}</span> <span>=</span>
  <span>result</span> <span>=</span> <span>s</span><span>.</span><span>a</span> <span>&lt;=</span> <span>value</span> <span>and</span> <span>value</span> <span>&lt;=</span> <span>s</span><span>.</span><span>b</span></code></pre>
</div>
</div>
<p>Slices are used by functions of the standard library
or by user defined functions to access sub-ranges of strings, arrays and sequences.
Applied on these container data types slices look syntactically like sub-ranges:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>m</span> <span>=</span> <span>&#34;Nim programming is difficult.&#34;</span>
<span>m</span><span>[</span><span>19</span> <span>..</span> <span>28</span><span>]</span> <span>=</span> <span>&#34;not easy.&#34;</span>
<span>echo</span> <span>m</span>
<span>echo</span> <span>&#34;Indeed &#34;</span> <span>&amp;</span> <span>m</span><span>[</span><span>0</span> <span>..</span> <span>18</span><span>]</span> <span>&amp;</span> <span>&#34;is much fun!&#34;</span></code></pre>
</div>
</div>
<p>In line three we use the slice to replace the sub-string &#34;is difficult.&#34; which starts
at position 19 with another string. Note that the replacement can be a longer or a
shorter string, that is the slice supports not only overwriting characters, but also
inserting or deleting operations. In the last line we use the slice to access a
sub-string and create a new string with it. As we learned earlier in the strings
section already, we can use the <span>^</span> operator to access elements counted from the
end of the container, so we could have written line three also as <span>m[19 .. ^1]
= &#34;not easy.&#34;</span>.</p>
<p>Slices can be used in a similar way for arrays, strings and sequences. But we have to
remember that slices are only objects with a lower and an upper bound, so there must
be always a procedure that accepts the container and the slice as arguments to do the
real work.</p>
<p>When we care for utmost performance, then we have to be a bit carefully with slices,
as slices can generate copies. Consider this example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span>
    <span>s</span> <span>=</span> <span>newSeq</span><span>[</span><span>O</span><span>]</span><span>(</span><span>1000000</span><span>)</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>(</span><span>1000000</span> <span>-</span> <span>1</span><span>):</span>
    <span>s</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>O</span><span>(</span><span>i</span><span>:</span> <span>i</span><span>)</span>

  <span>var</span> <span>sum</span> <span>=</span> <span>0</span>
  <span>for</span> <span>x</span> <span>in</span> <span>s</span><span>[</span><span>1</span> <span>..</span> <span>^</span><span>1</span><span>]</span><span>:</span>
    <span>sum</span> <span>+=</span> <span>x</span><span>.</span><span>i</span></code></pre>
</div>
</div>
<p>Here we use the slice operator to exclude the first element from our summing
operation. Unfortunately in current Nim v1.6 use of the slice operation in this way
creates a copy of our sequence, which increases the run-time and memory consumption.
We may try to use the new toOpenArray() expression and try a construct like</p>
<div>
<div>
<pre><code data-lang="nim">  <span>for</span> <span>x</span> <span>in</span> <span>items</span><span>(</span><span>s</span><span>.</span><span>toOpenArray</span><span>(</span><span>1</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)):</span></code></pre>
</div>
</div>
<p>but that does currently not compile.</p>
<p>One option is currently that we create a custom iterator like</p>
<div>
<div>
<pre><code data-lang="nim"><span>iterator</span> <span>span</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>:</span> <span>openArray</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>j</span><span>,</span> <span>k</span><span>:</span> <span>Natural</span><span>):</span> <span>T</span> <span>{.</span><span>inline</span><span>.}</span> <span>=</span>
  <span>assert</span> <span>k</span> <span>&lt;</span> <span>a</span><span>.</span><span>len</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span> <span>=</span> <span>j</span>
  <span>while</span> <span>i</span> <span>&lt;=</span> <span>k</span><span>:</span>
    <span>yield</span> <span>a</span><span>[</span><span>i</span><span>]</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>and use</p>
<div>
<div>
<pre><code data-lang="nim"><span>for</span> <span>x</span> <span>in</span> <span>s</span><span>.</span><span>span</span><span>(</span><span>1</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>):</span></code></pre>
</div>
</div>
<p>Or we may do the summing in a procedure and pass that <span>proc</span> an openArray created with
toOpenArray() like</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>sum</span><span>(</span><span>x</span><span>:</span> <span>openArray</span><span>[</span><span>O</span><span>]</span><span>):</span> <span>int</span> <span>=</span>
  <span>for</span> <span>el</span> <span>in</span> <span>x</span><span>:</span>
    <span>inc</span><span>(</span><span>result</span><span>,</span> <span>el</span><span>.</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>sum</span><span>(</span><span>s</span><span>.</span><span>toOpenArray</span><span>(</span><span>1</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>))</span></code></pre>
</div>
</div>
<p>But this is work in progress, so the situation may improve, see</p>


</div>
</div>
<div>
<h2 id="_value_objects_and_references">Value Objects and References</h2>
<div>
<p>We have already used different types of variables — integers, floats, or the custom
Computer object, and some more. We said that variables are named memory regions,
where the content of our variables is stored. We call this type of variables also
value objects.</p>
<p>Value objects always implies copies when we do an assignment</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span>
<span>i</span> <span>=</span> <span>7</span>
<span>j</span> <span>=</span> <span>i</span>
<span>i</span> <span>=</span> <span>3</span>
<span>echo</span> <span>i</span><span>,</span> <span>j</span></code></pre>
</div>
</div>
<p>Here we have 3 assignments, first we assign the integer literal <span>7</span> to variable <span>i</span>, then
we assign the content of variable <span>i</span> to variable <span>j</span>, and finally we overwrite the old
content of variable <span>i</span> with the new literal value <span>3</span>. The output of the <span>echo()</span> statement
should be <span>3</span> and <span>7</span>, because in line 3 we copy the content of variable <span>i</span>, which is
currently the value <span>7</span>, into variable <span>j</span>. The new assignment in line 4 in no way
touched the content of variable <span>j</span>.</p>
<p>Maybe that is not too surprising, but when we would have references instead of plain
variables, then the situation would be different, as we will see soon.</p>
<p>Whenever possible we should use this simple form of variables, as they are fast and
easy to use.</p>
<p>But there exist situations where we need some sort of indirection, and then
references and pointers come into play. For example when the data entities depend in
some form on each other, the elements may build linked lists, trees or other
structures. The entities may have some neighborhood relation, also called some one to
many relation.</p>
<p>Indeed value objects and references occur in real life also:</p>
<p>Imagine you have baked a cake for your family, and you know that your friendly
neighbor loves cakes too. As you have still a lot of all necessary ingredients and
because the oven is still hot, you make one more identical cake to give it later to
your neighbor. We can think of the cake as a value type, and your second cake can be
considered as a copy. When you give the copy to your neighbor, then you have still
your own, and when you or the neighbor eats the cake, then the other one still exist.</p>
<p>Now imagine that you know a good car repair shop. You can give the telephone number
or location of that car repair shop to your neighbor, so he can use that shop too. So
you gave him a reference to the shop, but you gave him not a copy. You can also give
some of your other friends each a reference to that shop, which is nearly no effort
for you. While backing a cake for all of them would be some effort.</p>
<p>You can regard names of persons as some sort of reference too. Imagine you have a
list with the names of all the people you intend to invite to your birthday party,
and another list with names of people who owe you money. Some names may be on both
list, this is it refers to the same person.</p>
<p>In computers the dynamic storage, called RAM, consists of consecutive, numbered
storage locations, called words. Each individual word has its address, which is a
number generally starting at zero and extending to a value which is defined by the
amount of memory available in your computer. These addresses can be used to access
the storage locations, that is to store a value at that address, or to read the
content again. Reading generally does not modify the content, you can read it many
times and will always get the same value. When your write another value to that
storage location, then reads will give you that new value.</p>
<p>Basically for all the data that you use in your program you need in some form its
address in the RAM, without the address you can not access it. But what is with all
the plain, value object variables we have used before, we have never used addresses?
That is true — we used only names to access our variables, and the compiler mapped
our chosen name to the actual address of the variables in memory whenever we accessed
the variable. For most simple cases this is the best way to access variables. Now let
us assume we have such value object type of variable declared in our program, can we
access it without using its name? When we have declared it, it should reside
somewhere in the RAM when the program is executed. Well, when we do really not want
to access it by variable name, then there is still one chance: We can search in the
whole RAM for the desired content. In practice we would never do that, as it is
stupid and would take very long, but we could do. But how can we detect our variable?
How can we be sure that it is indeed ours? Generally we can not. Even when we are
sure that the variable must reside somewhere in the RAM, generally the variable is
marked in no way of course. Even when we would know the value which is stored in that
variable, we would only know what bit pattern it should have, so for most words of
the RAM with a different bit pattern we could say for sure that it can not be our
variable, but whenever we find the expected bit pattern than it can be just a
coincidence, there can be many more words in RAM with that content. In some way it is
as you would search a person and you know that that person lives in a long road with
numbered houses. If you only know that the person wears brown shoes but you know not
the number of the house nor the name of the person and no other unique property of
that person, then you have not much luck.</p>
</div>
</div>
<div>
<h2 id="_references_and_pointers">References and Pointers</h2>
<div>
<div>
<h3 id="_introduction_to_pointers">Introduction to Pointers</h3>
<p>In Nim references are some form of smart or managed pointers, we will learn more
about references later. The plain pointer data type is nothing more than a memory
address, it is similar to a (unsigned) integer number. We say that a pointer points
to an entity when the pointer contains the memory address of that entity.</p>
<p>Beside the <span>pointer</span> data type, which is only some RAM address, we have also the <span>ptr</span>
entity. <span>Ptr</span> is not a datatype for its own, it is always used in conjunction with
another data type:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
 <span>p</span><span>:</span> <span>pointer</span>
 <span>ip</span><span>:</span> <span>ptr</span> <span>int</span></code></pre>
</div>
</div>
<p>Here the variable <span>p</span> is of type <span>pointer</span>, we could use it to point to some arbitrary
memory address. The variable <span>ip</span> is of type <span>ptr int</span>, which indicates that it
should only point to memory addresses where a variable with data type <span>int</span> resides. So
a <span>ptr</span> is a pointer that is bound to a specific data type. Generally we speak only
about pointers, if we are referring to an untyped <span>pointer</span> or a typed <span>ptr</span> is generally
clear from the context.</p>
<p>When we only declare pointers but do not assign a value then the pointers have the
value <span>nil</span>, what indicates that they are regarded to point to nothing.
Exactly speaking a pointer can never point to nothing in the same way as an integer
variable can not contain no number. As an integer variable always contains a bit
pattern, a pointer also always contains a bit pattern. But we are free to define a
special pattern as <span>nil</span>, and whenever a pointer has this special value, then we know
that it does not really point to something useful. In C instead of <span>nil</span> NULL was
chosen for the same purpose. In practice <span>nil</span> and NULL are generally mapped to <span>0</span>, that
is a word with all bits cleared. But that is more or less an arbitrary decision.</p>
<p>So how can we give our pointers above a useful value?</p>
<p>One possibility would be to use Nim’s <span>addr()</span> function, which gives us the memory
address of each ordinary variable.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
 <span>number</span><span>:</span> <span>int</span> <span>=</span> <span>7</span>
 <span>p</span><span>:</span> <span>pointer</span>
 <span>ip</span><span>:</span> <span>ptr</span> <span>int</span>
<span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>p</span><span>)</span>
<span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>ip</span><span>)</span>
<span>p</span> <span>=</span> <span>addr</span><span>(</span><span>number</span><span>)</span>
<span>ip</span> <span>=</span> <span>addr</span><span>(</span><span>number</span><span>)</span>
<span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>p</span><span>)</span>
<span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>ip</span><span>)</span></code></pre>
</div>
</div>
<p>First we declare an ordinary integer variable called <span>number</span> which will reside
somewhere in memory when we execute the program, and then we use the <span>addr()</span> function
to assign the address of that variable to <span>p</span> and <span>ip</span>. The <span>addr()</span> function is a low
level function provided by the compiler, it can be used to determine the memory
address of variables and some other entities known to the
compiler. We used the <span>echo()</span> procedure to show us the numeric
decimal value of the addresses in the terminal. As it generally makes not too much
sense to print addresses, <span>echo()</span> would refuse to print it, so we have used the
construct <span>cast[int](someValue)</span> to tell that <span>echo()</span> should regard our pointers as
plain integer and print it. That operation is called casting, we generally should
avoid it, as it destroys type safety, but for learning purposes it is OK to use it.
We will learn more about casts and related type conversion later.</p>
<p>The first two <span>echo</span> statements should print the decimal value <span>0</span>, as the pointers have
the initial default value <span>nil</span>.</p>
<p>The <span>echo()s</span> in the last two lines should print a value different from <span>0</span>, as we have
assigned the valid address of an ordinary variable that resides somewhere in the RAM
when the program is executed. Both outputs should be identical, as we have assigned
for both pointers <span>addr(number)</span> each.</p>
<p>Maybe a funny fact is, that when you run the program multiple times the output of the
last two <span>echo()</span> statements print different values. But that is not really surprising — whenever you launch the program, then for our variable <span>number</span> a storage location
in RAM is reserved. And that location can differ for each new program execution. For
your next holiday in the same hotel, you may get a different room also.</p>
<p>So when we have the pointer <span>ip</span> pointing to a valid address, can we recover the
content of that memory region? Sure, we use the de-reference operator <span>[]</span> for that
purpose. Whenever we have a typed pointer <span>x</span> we can use <span>x[]</span> to get the content of the
memory location where the pointer is pointing to. Note that the operator <span>[]</span> is not
really related to the subscript operator <span>[pos]</span> which we used earlier for <span>array</span>, <span>seq</span>
and <span>string</span> access. Nim uses ASCII characters for its operators, and that set is not
very large. And maybe it would even be confusing when we would have a different
symbol for each operator. We can consider <span>[]</span> as some form of content access operator — <span>mystring[pos]</span> gives us the character at that position, and <span>ip[]</span> gives us the
content of the memory location where <span>ip</span> points to.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
 <span>number</span><span>:</span> <span>int</span> <span>=</span> <span>7</span>
 <span>ip</span><span>:</span> <span>ptr</span> <span>int</span>
<span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>ip</span><span>)</span>
<span>ip</span> <span>=</span> <span>addr</span><span>(</span><span>number</span><span>)</span>
<span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>ip</span><span>)</span>
<span>echo</span> <span>ip</span><span>[]</span></code></pre>
</div>
</div>
<p>What do you expect as output for the last <span>echo()</span> statement? Note that for the last <span>echo()</span>
statement we do not need a cast, as <span>ip[]</span> has a well defined type: <span>ip</span> has type <span>ptr
int</span>, so <span>ip[]</span> is of well defined type <span>int</span> and <span>echo()</span> can print the content.</p>
<p>Now let us investigate how we can use pointers to modify the content of variables:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
 <span>number</span><span>:</span> <span>int</span> <span>=</span> <span>7</span>
 <span>ip</span><span>:</span> <span>ptr</span> <span>int</span>
<span>ip</span> <span>=</span> <span>addr</span><span>(</span><span>number</span><span>)</span>
<span>echo</span> <span>ip</span><span>[]</span>
<span>ip</span><span>[]</span> <span>=</span> <span>3</span>
<span>echo</span> <span>ip</span><span>[]</span>
<span>echo</span> <span>number</span></code></pre>
</div>
</div>
<p>What do you expect for the output of the last <span>echo()</span> statement? Well remember, <span>ip</span>
points to the location where variable <span>number</span> is stored in RAM. So echo <span>ip[]</span> gave us
the content of <span>number</span>. Now <span>ip[] = 3</span> is an assignment, the right site of the
assignment operator is the literal number <span>3</span>, which is a value type. Earlier we said
that for value types an assignment is a copy operation, the right site of the
assignment operator is copied into the variable on the left site. Now <span>ip[]</span> stands
exactly for the same content as the name <span>number</span>, and so assigning to <span>ip[]</span> is the same
as assigning to <span>number</span>.</p>
</div>
<div>
<h3 id="_pointer_arithmetic">Pointer Arithmetic</h3>
<p>In low level programming languages pointer arithmetic can be useful. For example old
C code often iterates with pointer arithmetic over arrays by use of constructs like
<span>sum += *(myIntPtr++)</span>. This was done to maximize performance. Modern C
compiler generally understands statements like <span>sum += el[i]; i++</span> well and
generates very good assembly instructions for it. So pointer arithmetic is not
necessary in C that often today.</p>
<p>Nim does not provide math operations for pointers directly, but we can always cast
pointers to integers and do arbitrary math. And of course we could define our own
operators for that purpose, but generally we should avoid that, as it is dangerous,
error prone and generally not necessary. As an example let us sum up some array
elements:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span>
    <span>a</span><span>:</span> <span>array</span><span>[</span><span>8</span><span>,</span> <span>int</span><span>]</span> <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>]</span>
    <span>sum</span> <span>=</span> <span>0</span>
  <span>var</span> <span>p</span><span>:</span> <span>ptr</span> <span>int</span> <span>=</span> <span>addr</span><span>(</span><span>a</span><span>[</span><span>0</span><span>]</span><span>)</span>
  <span>for</span> <span>i</span> <span>in</span> <span>a</span><span>.</span><span>low</span> <span>..</span> <span>a</span><span>.</span><span>high</span><span>:</span>
    <span>echo</span> <span>p</span><span>[]</span>
    <span>sum</span> <span>+=</span> <span>p</span><span>[]</span>
    <span>echo</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>p</span><span>)</span>
    <span>var</span> <span>h</span> <span>=</span> <span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>p</span><span>);</span> <span>h</span> <span>+=</span> <span>sizeof</span><span>(</span><span>a</span><span>[</span><span>0</span><span>]</span><span>);</span> <span>p</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>int</span><span>]</span><span>(</span><span>h</span><span>)</span>
    <span>#cast[var int](p) += sizeof(a[0]) # this compiles but does not work currently</span>

  <span>echo</span> <span>sum</span>
  <span>echo</span> <span>typeof</span><span>(</span><span>sizeof</span><span>(</span><span>a</span><span>[</span><span>0</span><span>]</span><span>))</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we do pointer arithmetic or similar math to calculate the address of variables
in the computer memory, then memory addresses are used like integer numbers, and so
it makes same sense that Nim’s integers have the same byte size as pointers.</p>
<p>References:</p>

</div>
<div>
<h3 id="_allocating_objects">Allocating Objects</h3>
<p>In the previous section we learned the basics about pointers. We used the <span>addr()</span>
operator to initialize the pointer by assigning the address of an already existing
object. This is in practice not that often done, and it can be a bit dangerous, as it
is not always guaranteed that the variable on which we applied <span>addr()</span> will exist as
long as our pointer exist. So the pointer may point later to a memory location that
is already freed or used by a totally different object already. So the use of <span>addr()</span>
is more reserved for advanced programmers who know well what they do, and most of the
time <span>addr()</span> is not necessary at all or is only necessary for really low level code,
maybe when interfacing with external libraries written in C. Instead of using <span>addr()</span>
to assigning to pointers a valid address, often procedures like <span>alloc()</span> or <span>create()</span>
are used to reserve a block of memory:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>ip</span><span>:</span> <span>ptr</span> <span>int</span>
<span>ip</span> <span>=</span> <span>create</span><span>(</span><span>int</span><span>)</span>
<span>ip</span><span>[]</span> <span>=</span> <span>13</span>
<span>echo</span> <span>ip</span><span>[]</span> <span>*</span> <span>3</span>
<span>var</span> <span>ip2</span><span>:</span> <span>ptr</span> <span>int</span>
<span>ip2</span> <span>=</span> <span>ip</span>
<span>echo</span> <span>ip2</span><span>[]</span> <span>*</span> <span>3</span>
<span>dealloc</span><span>(</span><span>ip</span><span>)</span></code></pre>
</div>
</div>
<p>Here the procedure <span>create()</span> is used to reserve a block of memory, the <span>int</span> parameter
ensures that the block has the size of an integer value. After <span>ip</span> has a valid value,
we can store a value in that memory location and read it again. Note that multiple
pointers can point to the same memory location: We declared one more <span>int ptr</span> called
<span>ip2</span>. But for that pointer we do not allocate a new block, but we assign the old block
that we allocated for <span>ip</span> to <span>ip2</span>. Now both pointers points to the same object, the <span>int</span>
value <span>13</span>. We may call <span>ip2</span> an alias, as it is a different way to access the same
object.</p>
<p>When we use <span>alloc()</span> or <span>create()</span> to allocate memory blocks, then we have to deallocate
them when we need them not any more. Otherwise that memory blocks couldn’t be reused.
If we would continuously allocate memory blocks and never deallocate, that is free
them, then at some point in time all memory would be occupied — not only for our own
program, but for all programs running currently on the same computer. We had to
terminate our program — when a program is terminated then all resources get freed
automatically by the OS.</p>
<p>The use of procedure pairs like <span>alloc()</span> and <span>dealloc()</span> is common practice in low level
programming languages like C, but it is inconvenient and dangerous: We can forget to
call <span>dealloc()</span> and waste resources, or we may even deallocate memory blocks but still
use it by our pointers. The later would at some point of time crash our program, as
we would use memory blocks which are already released and may be used for other
variables — from our own program or from other programs. Note that in the source
code above there is only one single <span>dealloc()</span> call. The reason for that is, that we
only allocated one single memory block in one single <span>create()</span> call, <span>ip2</span> is only one
more pointer that points to that block. If we would have used an additional
<span>dealloc(ip2)</span> call, then that would be a so called double free error.</p>
<p>As you see, using pointers is inconvenient and dangerous. But still there are
situations where plain value type variables do not suffice. The solution of many
higher level programming languages to this problem is a <span>Garbage-Collector</span> (GC). The
GC does the dangerous and inconvenient task of deallocating unused memory blocks for
us automatically.</p>
<p>To distinct the GC managed &#34;pointers&#34; cleanly from the manually managed ones, we call
them in Nim <span>references</span>, in some other languages they are called traced
pointers. References are always typed like <span>ptr</span>, there is no equivalent to the untyped
<span>pointer</span> type for references.</p>
<p>For References we have still to do the allocation our self, then we can use the
references, and when we are not using them any more, then the GC frees the
corresponding memory block. A typical scenario is that we use references in a
procedure or in an otherwise limited block of code: We declare the reference in that
code block, allocated and use it, and when the code block is left the GC frees the
allocated memory for us. You may think that the fact that we still have to allocate
the memory for our references our self is still a problem, as we may forget that
step. Well it is not that dangerous, when we forget the allocation step, we would use
a reference with value <span>nil</span>, which would immediate result in a runtime error. So we
would see the problem immediately. Other pointer errors, like missing de-allocation
or use after free are not that obvious and more dangerous.</p>
<p>With references we can rewrite our previous example code in this way:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>ip</span><span>:</span> <span>ref</span> <span>int</span>
<span>new</span><span>(</span><span>ip</span><span>)</span>
<span>ip</span><span>[]</span> <span>=</span> <span>13</span>
<span>echo</span> <span>ip</span><span>[]</span> <span>*</span> <span>3</span>
<span>var</span> <span>ip2</span><span>:</span> <span>ref</span> <span>int</span>
<span>ip2</span> <span>=</span> <span>ip</span>
<span>echo</span> <span>ip2</span><span>[]</span> <span>*</span> <span>3</span></code></pre>
</div>
</div>
<p>We have replaced <span>ptr</span> by <span>ref</span>, and instead of <span>alloc()</span> or <span>create()</span> we are using the
<span>new()</span> <span>proc</span> which gets the uninitialized <span>ref</span> as a parameter and allocates a managed
memory block for it, that is after the <span>new()</span> call <span>ip</span> has a well defined value
referring to a managed memory block that can store an integer value. Again, we can
use one more <span>ref</span> and assign that <span>ref</span> the value of the other, so now both references
the same memory block. The advantage here is that we don’t have to care about
freeing that block, the GC will do that when appropriate.</p>
<p>To verify that in the example code above both references really reference the same
object in memory, we could add two more lines of code:</p>
<div>
<div>
<pre><code data-lang="nim"><span>ip2</span><span>[]</span> <span>=</span> <span>7</span>
<span>echo</span> <span>ip</span><span>[]</span>
<span>echo</span> <span>ip2</span><span>[]</span></code></pre>
</div>
</div>
<p>Here we are using the reference <span>ip2</span> to assign to the memory block the literal value
<span>7</span>. After that assignment both echo statements would display that new content.</p>
<p>Using references and pointers to store basic data types like integers is not done
that often, in most cases we work with larger objects, and we create some relations
between the objects. We will try that in the next section.</p>
</div>
<div>
<h3 id="_references_to_objects">References to Objects</h3>
<p>You should still wonder for what references are really useful — they seem to be only
a more complicated version of plain value type variables.</p>
<p>Now let us assume we want to create a list of things or persons, maybe a list of our
previously used Computer data type, or maybe a list of persons we will invite to our
next party. We will create the party list for now, as the Computer data type we used
before has already many fields, and filling all the fields would be some effort, so
let us use a new <span>Friend</span> data type which should store only the friends name for the
beginning — we may add more fields later when necessary. So we may have</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Friend</span> <span>=</span> <span>object</span>
    <span>name</span><span>:</span> <span>string</span></code></pre>
</div>
</div>
<p>With that declaration we could declare a few friends variables like</p>
<div>
<div>
<pre><code data-lang="nim">  <span>var</span> <span>harry</span><span>,</span> <span>clint</span><span>,</span> <span>eastwood</span><span>:</span> <span>Friend</span></code></pre>
</div>
</div>
<p>But that is not what we want, we would need a list with all of our friends that we
would like to invite to our party, we would want to add friends to the list, and
maybe we would want to delete friends also. You may think we could use Nim’s sequence
data type for that, and you are right. But let us assume we could not use that
predefined Nim data type for some reason. Then we could create a list of linked
references to Person.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Friend</span> <span>=</span> <span>ref</span> <span>object</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>next</span><span>:</span> <span>Friend</span></code></pre>
</div>
</div>
<p>Now our <span>Friend</span> data type is a reference to an <span>object</span> , and the <span>object</span>  itself has an
additional <span>next</span> field which is again of type <span>Friend</span>.</p>
<p>That is some sort of recursion. If that should appear as too strange, then imagine
you have some numbered paper cards, each with two fields: One field name, one field
next: In the name field you can fill in a name of a friend, in the next field you
fill in the number of the next card. The last card in the chain gets no entry in the
next field.</p>

<p>Now we create a small Nim program which reads in names of our friends from the
terminal, creates a list of all friends, and finally prints the list.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Friend</span> <span>=</span> <span>ref</span> <span>object</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>next</span><span>:</span> <span>Friend</span>

<span>var</span>
  <span>f</span><span>:</span> <span>Friend</span> <span># the head of our list</span>
  <span>n</span><span>:</span> <span>string</span> <span># name or &#34;quit&#34; to terminate the input process</span>

<span>while</span> <span>true</span><span>:</span>
  <span>write</span><span>(</span><span>stdout</span><span>,</span> <span>&#34;Name of friend: &#34;</span><span>)</span>
  <span>n</span> <span>=</span> <span>readline</span><span>(</span><span>stdin</span><span>)</span>
  <span>if</span> <span>n</span> <span>==</span> <span>&#34;&#34;</span> <span>or</span> <span>n</span> <span>==</span> <span>&#34;quit&#34;</span><span>:</span>
    <span>break</span>
  <span>var</span> <span>node</span><span>:</span> <span>Friend</span> <i data-value="1"></i><b>(1)</b>
  <span>new</span><span>(</span><span>node</span><span>)</span>
  <span>node</span><span>.</span><span>name</span> <span>=</span> <span>n</span>
  <span>node</span><span>.</span><span>next</span> <span>=</span> <span>f</span>
  <span>f</span> <span>=</span> <span>node</span>

<span>while</span> <span>f</span> <span>!=</span> <span>nil</span><span>:</span>
  <span>echo</span> <span>f</span><span>.</span><span>name</span>
  <span>f</span> <span>=</span> <span>f</span><span>.</span><span>next</span></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The actual name for this temporary
variable is arbitrary, we could have used <span>el</span> for element maybe.</td>
</tr>
</tbody></table>
</div>
<p>This example code seems to be not that easy. But it is not really difficult, and when
you have understood it, you can call yourself a Nim programmer already. Maybe you
should think about the code above for a few minutes before reading the explanations
below.</p>
<p>First let us summarize what our program should do: It should read in some names of
our friends which we would like to invite to our next party. Of course when entering
the names, we would need a way to tell that we are done. In our program we can do
that in two ways, we can enter an empty name by just pressing the return key, or we
can enter the text &#34;quit&#34; to stop the loop. Unfortunately that means that we can
never invite a friend with that name to our parties. When we have terminated the
input loop, then the next loop prints all the entries to the terminal.</p>
<p>Let us start with the type and variable declarations: We use a user defined type
named <span>Friend</span> which is a reference to an <span>object</span> , that object type has a field <span>name</span> of
type <span>string</span>, and a field <span>next</span> which is again a reference to the same data type.</p>
<p>We are using two variables, one called <span>n</span> of type <span>string</span> to read in a name or the quit
command from terminal, and a variable called <span>f</span> of type <span>Friend</span>. The variable <span>f</span> seems
to match only to one single friend, but as the type of <span>f</span> has a <span>next</span> field it can be a
whole list of friends, with <span>f</span> being the start or head of that list.</p>
<p>In the code above we are using a special <span>while</span> loop — special because the construct
<span>while true:</span> and because the loop contains a <span>break</span> statement. Earlier we said
that we should avoid the <span>break</span> statement in loops, because it interrupts the control
flow and can make it more difficult to understand and proof the flow. But in this
case that form makes some sense: For the first loop we have to first read in a name
from terminal and then we can decide what to do, so we can not really evaluate a
condition after the <span>while</span> statement at the top. So we use the simple constant
condition <span>true</span>, which would never terminate the loop. We need a <span>break</span> inside the loop
body to terminate the loop.</p>
<p>Let us investigate the second loop first as it is really easy: In the <span>while</span> condition
we check if current value of <span>f</span> is <span>nil</span>, that is if there are no more entries in our
list. For that case we terminate the loop, as we are done. If <span>f</span> has not the value
<span>nil</span>, than <span>f</span> points to a valid content, that is there is at least a valid name, which
we access by the field access operator and print it with <span>echo f.name</span>. Note that in
Nim the field access operator <span>.</span> works in the same way for value objects types
as well as for <span>ref</span> objects types. For <span>ref</span> objects types we could also write <span>f[].name</span>
instead of plain <span>f.name</span>, that is we first apply <span>[]</span> to <span>f</span> to get the content, and then
use the <span>.</span> operator to access the <span>name</span> field. In some other languages like C we would have to use
a special operator -&gt; to access fields of pointer or reference types.</p>
<p>The most interesting statement in the output loop is <span>f = f.next</span>. We assign the
content of <span>f.next</span> to <span>f</span> and proceed with that new content. The content could be a
valid reference to one more <span>Friend</span> object, or it could be <span>nil</span>, indicating that our
loop should terminate.</p>
<p>The input loop is also not that complicated: To make the process of adding more
friends to the list easy, we always add the new names at the beginning. First we ask
the user to enter a name. We use <span>write(stdout)</span> for this, as <span>echo()</span> always generates a
newline, but we want to read in the name on the same line. If the name is empty or
has the special value &#34;quit&#34; then we terminate the input loop. In the loop we are
using a temporary variable called <span>node</span> of type <span>Friend</span>, we allocate a memory block for
it with <span>new()</span>. Then we assign the read in friend’s name <span>n</span> to the <span>name</span> field. The last two
statements of the loop body are a bit demanding: First we assign to <span>node.next</span> the
value of <span>f</span>. Now <span>node</span> is basically the start of our list, and its <span>next</span> field refers to
the first element of the current list. Fine, but we said that the node variable is
only a temporary variable, we do not intend to use it longer as necessary. But
currently <span>node</span> is so useful, it is the head of our list. On the other hand, the
former list start <span>f</span> is now useless, current <span>f</span> is identical with <span>node.next</span>. So the
trick is, we just assign to <span>f</span> the value of <span>node</span>. Now <span>f</span> is the complete list, and we
do not need <span>node</span> any more. The <span>node</span> variable can be used in the next loop iteration
again, but we have to allocate a new memory block for the <span>node</span> reference, as the
previous memory block is still in use, it contains the name which we just entered and
also a reference to the next object in the list.</p>
<p>Note that we add the new elements at the top of the list in this way. We have done it
that way because it is very easy in this way. For adding at the end of the list, we
would have to use one more reference variable which allows us always access to the
current end of the list, or we would have to traversal the list from head to tail
whenever we would like to add elements at the tail.</p>
<p>For one more exercise let us consider deleting entries in our list. Basically that
operation is very easy, we would just skip one entry. Lets adds this code to the
program above:</p>
<div>
<div>
<pre><code data-lang="nim"><span>while</span> <span>f</span> <span>!=</span> <span>nil</span><span>:</span>
  <span>write</span><span>(</span><span>stdin</span><span>,</span> <span>&#34;Name to delete: &#34;</span><span>)</span>
  <span>n</span> <span>=</span> <span>readline</span><span>(</span><span>stdin</span><span>)</span>
  <span>if</span> <span>n</span> <span>==</span> <span>&#34;&#34;</span> <span>or</span> <span>n</span> <span>==</span> <span>&#34;quit&#34;</span><span>:</span>
    <span>break</span>
  <span>if</span> <span>f</span><span>.</span><span>name</span> <span>==</span> <span>n</span><span>:</span>
    <span>f</span> <span>=</span> <span>f</span><span>.</span><span>next</span>
  <span>else</span><span>:</span>
    <span>while</span> <span>f</span><span>.</span><span>next</span> <span>!=</span> <span>nil</span><span>:</span>
      <span>if</span> <span>f</span><span>.</span><span>next</span><span>.</span><span>name</span> <span>==</span> <span>n</span><span>:</span>
        <span>f</span><span>.</span><span>next</span> <span>=</span> <span>f</span><span>.</span><span>next</span><span>.</span><span>next</span>
        <span>break</span>
      <span>f</span> <span>=</span> <span>f</span><span>.</span><span>next</span></code></pre>
</div>
</div>
<p>Here we are using again an outer <span>while</span> loop to read in the names which we want to
delete. That loop uses the condition <span>while f != nil:</span> because when the list is empty
we should stop of course.</p>
<p>In the loop body we have an <span>if</span> statement, and in the <span>else</span> branch of the <span>if</span> statement
we have one more loop. The reason why we need the <span>if</span> statement is, that the case
that our name to delete is the first in the list is some sort of special. Let us
investigate the inner loop first. That loop assumes that there are at least 2
elements in the list, <span>f</span> and <span>f.next</span>. We compare the name of the next entry with <span>n</span>. If
they match then we would have to skip the next entry. We can do that by the statement
<span>f.next = f.next.next</span>. That is we replace the reference from the current element <span>f</span> to
the next list entry, that is <span>f.next</span>, by the next entry of the next element, which is
<span>(n.next).next</span>. We do not have to write the parenthesis. The <span>n.next.next</span> entry can be
<span>nil</span>, in that case it is the end of the list. If we found a matching name then we
terminate the inner loop with a <span>break</span> statement, and we are done. Otherwise we assign
to <span>f</span> the value of <span>f.next</span> and continue the loop execution. Now to the special case
that the name to delete is the first in the list. We need the first <span>if</span> branch for
that — if already the first element matches the name to delete than we just skip the
first element by setting the head of the list to the next entry, which may or may not
be <span>nil</span>.</p>
<p>This is one way to solve the task, for operations on lists there exist in most cases
various solutions, some optimized to easy or short code, some for performance. You
may copy the code segment above to the end of the former code, and maybe add one more
copy of our printing loop at the end again. Then you should have a program that reads
in a list, prints the contents, then ask for names to delete, and finally prints the
resulting list. Maybe you can improve the code, or maybe you can detect special
corner cases where it may fail. What is for example when some of your friends have
the same name? May the program fail in that case? Or you may add more fields to your
<span>Friend</span> data type. Maybe a textual field with content male or female, and you can
report the ratio of male to female. And maybe remove males from the list when we
have more males then females?</p>
<p>For references to objects the assignment operator <span>=</span> copies the references, but
not the object. In the same way the operator <span>==</span> for equality test compares the
references, but not the content of the objects to which the references point. If you
want to compare the content of the objects, you can apply the dereference operator
<span>[]</span> on both references:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>RO</span> <span>=</span> <span>ref</span> <span>object</span>
    <span>i</span><span>:</span> <span>int</span>

<span>var</span>
  <span>ro1</span> <span>=</span> <span>RO</span><span>(</span><span>i</span><span>:</span> <span>1</span><span>)</span>
  <span>ro2</span> <span>=</span> <span>RO</span><span>(</span><span>i</span><span>:</span> <span>1</span><span>)</span>
  <span>ro3</span> <span>=</span> <span>ro1</span>

<span>echo</span> <span>ro1</span> <span>==</span> <span>ro2</span> <span># false</span>
<span>echo</span> <span>ro1</span><span>[]</span> <span>==</span> <span>ro2</span><span>[]</span> <span># true</span>
<span>echo</span> <span>ro1</span> <span>==</span> <span>ro3</span> <span># true</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div>
<h2 id="_procedures_and_functions">Procedures and Functions</h2>
<div>
<p>Procedures and functions, called <span>proc</span> and <span>func</span> in Nim, are the most common way to
structure, or break larger programs into smaller, dedicated tasks which are to be performed.</p>
<p>The terms procedure
and function were used in Pascal and the other languages of Wirth already, while C
uses the term function only, and Fortran generally uses the term subroutine instead.
And finally, Python and Ruby are using the really strange terms <span>def</span> and <span>fun</span> for it.</p>
<p>Nim’s procedures are basically similar, but much more advanced than its equally named cousins
in the wirthian languages, or the plain functions in the C language: Nim’s procedures support generics and overloading, named parameters and default values,
the special parameter types varargs and openArray,
various ways to return a result and finally multiple calling conventions including the
method and command calling conventions.</p>
<div>
<h3 id="_introduction">Introduction</h3>
<p>We call or invoke a <span>proc</span> by just writing its name followed by a parameter list
enclosed in parenthesis. The parameter list can be empty. When we call a <span>proc</span>, then
the program execution continues with that procedure, and when the execution of the
procedure terminates, then the next statement after that <span>proc</span> call is executed.
Sometimes we say that we jump into a procedure and jump back when that procedure
terminates.</p>
<p>In Nim functions are a special form of procedures that return a result and do not
modify the current state of the program. Modifying a global variable or performing an input/output
operation would be examples for modifying the state. We have already used some
predefined procedures like <span>echo()</span> for output operations, <span>add()</span> for appending single
characters to strings, and <span>readLine()</span> for reading in textual user input. And we
talked about math functions like <span>sin()</span>, <span>cos()</span>, <span>pow()</span> — these are functions as they
accept one or two arguments and return a result but do not change a state — calling
them again with the same arguments would always give the same result. <span>ReadLine()</span> is
only a <span>proc</span>, not a function, as the result may be different for each call, and as we
pass a file variable as argument, which may change its state for each call, maybe
because the file end is reached. A function is only a special sub-type of a
procedure, the <span>func</span> keyword indicates to the reader of the code and to the compiler
some special properties, that is that a result is returned and that global state is
not changed. Whenever the <span>func</span> keyword is used a <span>proc</span> would do as well, and in this
text we generally speak about procedures, even when a function would do.</p>
<p>Let us start with a very simple function called <span>sqr()</span> for square.</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>sqr</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>i</span> <span>*</span> <span>i</span></code></pre>
</div>
</div>
<p>A procedure declaration consists of the keyword <span>proc</span>, a user selected name, a
optional parameter list enclosed in parenthesis and an optional colon followed by the result
data type. For a function declaration we use the keyword func instead of <span>proc</span>, and
as functions does always returns a result, we have always to specify the result
data type.</p>
<p>Note that this is only a declaration so far — the compiler could recognize the
construct, its parameters and its result type. Sometimes we call this construct a
procedure-header.</p>
<p>Generally we do not only declare a function, but we define it, that is we add an equal
sign to the procedure header and add an indented procedure body that contains the
code that is performed for each invocation.</p>
<p>Pure <span>proc</span> declarations can be necessary in rare situations, maybe when two procedures
call each other. In this case the procedure defined first would call the other
procedure, which is not already defined, so the compiler may complain about a unknown
procedure. We could solve that problem by first declaring the second procedure, so
that the compiler would know about it existence. We would then define that second
procedure later, that is closer to the end of the program file.</p>
<p>The <span>sqr()</span> <span>proc</span> above accepts an integer argument and returns its square of same data
type. We would call that <span>proc</span> like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>j</span><span>:</span> <span>int</span>
<span>j</span> <span>=</span> <span>7</span>
<span>echo</span> <span>sqr</span><span>(</span><span>j</span><span>)</span></code></pre>
</div>
</div>
<p>Earlier in this book we said that the compiler processes our source code from top to
bottom, and that the final program is executed from top to bottom too. The first
statement is indeed true, for that reason it can be necessary to declare a function
at the top, and define it below, as we can not call a <span>proc</span> before it is declared or
defined.</p>
<p>For the program execution we have to know that <span>procs</span> are only executed when we call
them. That is, when we write a <span>proc</span> at the top of our source code, then that <span>proc</span> is
processed by the compiler, but it is not executed during program runtime before we
call it. Actually, as the Nim compiler supports &#34;death code removal&#34;, code of
procedures that we never call would not make it in to our final executable at all.</p>

<p>Parameter lists of procedures consist of one or more lists of parameter names, separated with commas, followed by a colon and
the data type of the parameters. The sub-lists with same data type are separated by semicolons:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p</span><span>(</span><span>i</span><span>,</span> <span>j</span><span>,</span> <span>k</span><span>:</span> <span>int</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>float</span><span>;</span> <span>s</span><span>:</span> <span>string</span><span>)</span></code></pre>
</div>
</div>
<p>While the wirthian languages would require semicolons to separate
the parameter blocks, in Nim we could also use plain commas for that.
For the data types of <span>proc</span> parameters all of Nim’s data types are allowed, including
structured types, ref, pointer and container types, and we can pass literal values, named constants or variables.</p>
<p>When we call such a <span>proc</span> with multiple arguments, we have to specify the arguments
in the order as they are listed in the <span>proc</span> header, separated with commas, and the arguments must have compatible data types:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span><span>:</span> <span>int</span> <span>=</span> <span>7</span><span>;</span> <span>x</span><span>:</span> <span>float</span> <span>=</span> <span>3.1415</span>
<span>p</span><span>(</span><span>i</span><span>,</span> <span>13</span><span>,</span> <span>19</span><span>,</span> <span>x</span><span>,</span> <span>2.0</span><span>,</span> <span>&#34;We call proc p() with a lot of parameters&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>Here compatible data types means, that for the <span>i</span>, <span>j</span>, and <span>k</span> parameters which are specified as <span>int</span> type
in the <span>proc</span> definition, variables of smaller <span>int</span> types like <span>int16</span> would work. For the two parameters
of <span>float</span> type, we would have to pass floating point variables or a <span>float</span> literal. As a special case an <span>int</span> literal
would work also, as the compiler knows the desired data type and automatically converts the <span>int</span> literal into a <span>float</span>
for us, as long as that is possible without loss of precision. We could pass <span>2</span> instead of <span>2.0</span>, but
passing a very long <span>int</span> literal with more than 16 digits may fail at compile time:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p</span><span>(</span><span>i</span><span>,</span> <span>j</span><span>,</span> <span>k</span><span>:</span> <span>int</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>float</span><span>;</span> <span>s</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>echo</span> <span>s</span>

<span>var</span>
  <span>n</span><span>:</span> <span>int16</span>
  <span>m</span><span>:</span> <span>int</span> <span># int64 would not compile</span>
  <span>z</span><span>:</span> <span>float32</span>
<span>p</span><span>(</span><span>n</span><span>,</span> <span>n</span><span>,</span> <span>m</span><span>,</span> <span>1234567890</span><span>,</span> <span>z</span><span>,</span> <span>&#34;&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>Actually <span>float32</span> types and <span>int</span> literals up to ten digits seems to work for <span>float</span> parameters, but even on 64
bit systems the <span>int64</span> data type is not allowed for <span>int</span> parameters. As you see from the example above, it is
possible to pass the same variable multiple times as a parameter, and empty string literals are of course allowed too.</p>
<p>Nim does also support default values for <span>proc</span> parameters and named parameters, that is that we can leave parameters unspecified
and use the default value, or
use the actual parameter names like in an variable
assignment when we call a <span>proc</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>;</span> <span>x</span><span>:</span> <span>float</span><span>;</span> <span>s</span><span>:</span> <span>string</span> <span>=</span> <span>&#34;&#34;</span><span>)</span> <span>=</span> <span>echo</span> <span>i</span><span>.</span><span>float</span> <span>*</span> <span>x</span><span>,</span> <span>s</span>
<span>p</span><span>(</span><span>x</span> <span>=</span> <span>2.0</span><span>,</span> <span>i</span> <span>=</span> <span>3</span><span>)</span></code></pre>
</div>
</div>
<p>Here we used named parameters when calling the <span>proc</span> <span>p()</span>, this way we can freely order the parameters, and as parameter <span>s</span> has a default value, we
can let it unspecified and just use the default value.</p>
<p>Functions always return a result, and procedures can return a result, but they don’t have to.
In the C language function results can just be ignored, but in Nim whenever there is a result, then we have to
use it at the call site, that is we have to assign the returned value to a variable or we have to use it in an expression.
Nim enforces this, as generally the returned value is important, the returned value may be the actual
result as in a <span>sin()</span> call, or it may give us additional information, like the number of read characters
when we do text processing or maybe an error indication, like end of file. For the rare conditions when we
really intend to ignore the result of a function call, we can call that function as <span>discard myProcWithResult(a, b,…​)</span>.
Another solution is to apply the {.discardable.} pragma to the function definition, we will learn more about pragmas later.
When a procedure should not return a result, then we can use the <span>void</span> return type or just leave the return type out — the later is recommended, <span>void</span> types are used only rarely in Nim. When the <span>proc</span> has no parameters at all, then we can even leave out
the empty parameter list in the <span>proc</span> definition:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p1</span><span>()</span> <span>=</span>
  <span>echo</span> <span>&#34;Hello and goodbye&#34;</span>

<span>proc </span><span>p2</span> <span>=</span>
  <span>echo</span> <span>&#34;Hello and goodbye&#34;</span>

<span>proc </span><span>p3</span><span>:</span> <span>void</span> <span>=</span>
  <span>echo</span> <span>&#34;Hello and goodbye&#34;</span></code></pre>
</div>
</div>
<div>
<h4 id="_calling_procedures">Calling Procedures</h4>
<p>When we call a procedure or a function, that is when we intend to execute it, then we have
always to specify a parameter list enclosed in brackets, but the parameter list can be empty:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span> <span>=</span> <span>myFunc</span><span>(</span><span>7</span><span>)</span>
<span>var</span> <span>j</span> <span>=</span> <span>myF</span><span>()</span>
<span>var</span> <span>p</span> <span>=</span> <span>myF</span> <span># not a function call, but assignment of the proc to variable p</span></code></pre>
</div>
</div>
<p>Note that the last line in above code is not a call of <span>myF()</span>, but an assignment of that function to
the variable <span>p</span>. Will will discuss this use case soon.</p>
<p>We have already learned, that we can also use the method call syntax, like 7.myFunc instead of myFunc(7),
and we can use the command invocation syntax like in <span>echo &#34;Hello&#34;</span> and that we should avoid putting a space
between the <span>proc</span> name and the opening bracket as that would be interpreted as a call with a tuple argument.
When the function or <span>proc</span> expects multiple arguments, then we separate the arguments with commas, and
we put generally a space after each comma:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p</span><span>(</span><span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span><span>)</span> <span>=</span> <span>i</span> <span>+</span> <span>j</span>
<span>echo</span> <span>p</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span># ordinary proc call</span>
<span>echo</span> <span>1.</span><span>p</span><span>(</span><span>2</span><span>)</span> <span># method call syntax</span>
<span>echo</span> <span>p</span> <span>1</span><span>,</span> <span>2</span> <span># command invocation syntax</span>
<span>echo</span> <span>p</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span># argument looks like a tuple, so this would not compile</span></code></pre>
</div>
</div>
<p>For the <span>proc</span> definition above we wrote the body statement directly after the equal sign — that
is possible, and used sometimes for very short <span>procs</span>. And indeed, here <span>p()</span> is a function.</p>
<p>In the examples above we have passed plain integers as parameters to procedures, but
of course <span>proc</span> parameters can have any type, we can pass strings, array, objects and all that.
The way we pass the parameters to the <span>procs</span> is sometimes called &#34;pass by value&#34;, an old term
introduced for the Pascal language, used to indicate that the passed parameter seems to be copied
to the <span>proc</span>, the <span>proc</span> is not able to modify the original instance. In the next section we will
learn about the <span>var</span> parameter type, which is used when we want to allow the <span>proc</span> to modify the
original instance. In the wirthian languages the procedure parameters actually get copied, so
inside the <span>proc</span> we could modify it, but we modified only the copy, the original instance remained unchanged.
In Nim it is a bit different. When we pass parameters by value to a <span>proc</span>, we can not modify it at all
in the <span>proc</span> body. When we need a mutable copy, we have to generate that copy our self in the <span>proc</span> body.
This allows some optimizations: Nim needs not really to copy the proc parameters, as they are immutable, Nim can just
work with pointers to the original instances internally. Actually there are rumors, that for parameters
smaller than <span>3 * sizeof(float)</span> Nim copies the instances, but for larger instances Nim works internally
with pointers to the original value. But this is an implementation detail — data copied to the <span>procs</span>
stack allow fastest access, but on the other hand the initial copy process can be expensive, so it is a compromise.</p>
</div>
<div>
<h4 id="_procedure_parameters_of_var_type">Procedure Parameters of Var Type</h4>
<p>Our <span>sqr()</span> function above accepts only one parameter and that parameter is a value
type, which indicates that we can not modify it in the procedure body. That fact is
useful to know for the caller of a <span>proc</span>, as one can be sure that the passed parameter
is not modified and is available unchanged after the <span>proc</span> call.
But of course there
are situations where we may want that a passed parameter is modified. Let us assume that
we want to &#34;frame&#34; a passed string, for example we want to pass in the string &#34;Hello&#34;
and want to change it to &#34;* Hello *&#34;. Further let us assume that we may sometimes
want to use other characters instead of the asterisk, maybe a <span>+</span> sign.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>frame</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>string</span><span>;</span> <span>c</span><span>:</span> <span>char</span> <span>=</span> <span>&#39;*&#39;</span><span>)</span> <span>=</span>
  <span>var</span> <span>cs</span> <span>=</span> <span>newString</span><span>(</span><span>2</span><span>)</span>
  <span>cs</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>c</span>
  <span>cs</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>&#39; &#39;</span>
  <span>insert</span><span>(</span><span>s</span><span>,</span> <span>cs</span><span>)</span>
  <span>add</span><span>(</span><span>s</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
  <span>add</span><span>(</span><span>s</span><span>,</span> <span>c</span><span>)</span>

<span># we can call that proc like</span>
<span>var</span> <span>message</span> <span>=</span> <span>&#34;Hello World&#34;</span>
<span>frame</span><span>(</span><span>message</span><span>)</span>
<span>echo</span> <span>message</span></code></pre>
</div>
</div>

<p>The frame <span>proc</span> above accepts two parameters and returns no result. The first
parameter has the type <span>string</span>, it is not a value parameter but a <span>var</span> parameter, which
is indicated by the <span>var</span> keyword between the colon and the type of the parameter. Note
that we use here again the keyword <span>var</span> that we used earlier to declare variables. The
main reason that we use again the same keyword is that we do not want to use a new
one — <span>var</span> <span>proc</span> parameters are different from <span>var</span> declarations. Parameters of <span>var</span> type can
be modified in the procedure body, and that modification is visible after the <span>proc</span>
call. The second <span>proc</span>
parameter is a plain value type, it is a character which has the default value &#39;*&#39;.
To specify a default value for a parameter, we write an equal sign after the parameter type followed by the
actual default value, like we would do it in an assignment. Indeed as in an assignment, we can even leave out the
colon with the data type in this case, at least for the case that the compiler can infer the correct data type from the assigned default value.
Default values are useful for parameters that have in most cases the same value, but
can be different sometimes. The advantage is, that when calling that <span>proc</span> we can just
leave that parameter out. For default values we have to be a bit careful, only value
parameter can have default values, and when we call a <span>proc</span> with many parameters with
default values it may be not always clear which parameter we pass and for which
parameter we want a default value.</p>
<p>To generate the frame around the passed in <span>string</span> we have to insert two characters at
the front of the <span>string</span>, and to append two more characters. Inserting in strings is not a
very cheap operation, as it involves moving all following characters. So we try not
to insert two single characters, but we first create a short <span>string</span> consisting of the
passed <span>c</span> character and a white-space character, and then insert that two character
<span>string</span> at the front of the passed string. We use the standard procedure <span>newString()</span>
with parameter <span>2</span> to create a new <span>string</span> of length <span>2</span> with undefined content, and then
fill in the content by using the subscript operator. We could have used the <span>add()</span>
proc to add that two characters to an empty <span>string</span>, but that is a bit slower. Then we
use the standard procedure <span>insert()</span> to insert our two character <span>string</span> at the front
of our passed string. Finally we add a white-space and the <span>c</span> character to the passed
string. The passed string is now modified, it is 4 characters longer. That
modification is noticeable for the caller of that <span>proc</span>, that is <span>echo()</span> will print the
modified version.</p>

<p>When we call a <span>proc</span> or function with multiple arguments, then we have to pass the
arguments in the same order as they are specified in the <span>proc</span> declaration.</p>
<p>Our <span>frame()</span> <span>proc</span> above modifies the passed <span>string</span>. We could have instead decided that
the <span>proc</span> should not modify the <span>string</span>, but should return a new <span>string</span> consisting of
the frame and the passed <span>string</span> in the center. Generally when creating <span>procs</span> we have
to decide what is more useful — modifying a passed value or returning a modified
copy. And sometimes we have to regard efficiency too. Returning newly created large
data types like strings may be expensive. A <span>string</span> is not a trivial structure, as it
contains the dynamic buffer for the <span>string</span> content, which has to be allocated. On the
other hand, for the passed <span>var</span> <span>string</span> we inserted characters, which involves moving
characters and is also not a really cheap operation, and maybe when we insert a lot,
the string buffer must be even enlarged, which is again expensive. So for this use
case it is not really clear what approach is better — we used the <span>var</span> parameter
mainly to introduce <span>var</span> parameters. OK, let us investigate how a function that
returns a modified string may look:</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>framed</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>;</span> <span>c</span><span>:</span> <span>char</span> <span>=</span> <span>&#39;*&#39;</span><span>):</span> <span>string</span> <span>=</span>
  <span>var</span> <span>res</span> <span>=</span> <span>newStringOfCap</span><span>(</span><span>s</span><span>.</span><span>len</span> <span>+</span> <span>4</span><span>)</span>
  <span>add</span><span>(</span><span>res</span><span>,</span> <span>c</span><span>)</span>
  <span>add</span><span>(</span><span>res</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
  <span>add</span><span>(</span><span>res</span><span>,</span> <span>s</span><span>)</span>
  <span>add</span><span>(</span><span>res</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
  <span>add</span><span>(</span><span>res</span><span>,</span> <span>c</span><span>)</span>
  <span>return</span> <span>res</span>

<span># we can call that proc like</span>
<span>echo</span> <span>framed</span><span>(</span><span>&#34;Hello World&#34;</span><span>)</span>
<span>echo</span> <span>framed</span><span>(</span><span>&#34;Hello World&#34;</span><span>,</span> <span>&#39;#&#39;</span><span>)</span></code></pre>
</div>
</div>
<p>Above code is one possible solution. We can use the keyword <span>func</span> instead of <span>proc</span> here
as we only return a result but modify no states. We pass the initial <span>string</span> and the
character for the frame both as plain value parameters and return a newly created
framed <span>string</span>. In the function body we start with an optimized version of the
procedure <span>newString()</span> from the <span>system</span> module, called <span>newStringOfCap()</span>. Like
<span>newString()</span> that procedure creates an empty <span>string</span> variable, but it ensures that the
data buffer of the new string has exactly the specified size. That is an
optimization, which makes sense in our use case, as we know that our newly created
<span>string</span> will have <span>4</span> characters more than the passed <span>string</span>. So we can avoid that the
result <span>string</span> has to be enlarged while we add characters or the initial <span>string</span>, and
we ensure at the same time that no space is wasted — the data buffer size of the new
<span>string</span> will be a perfect fit for the desired result. The rest of the function body
is not really interesting, we just <span>add()</span> what is needed and return the result. Well,
earlier we said that <span>add()</span> is not extremely fast. So when you have to frame millions
of strings each day you may consider avoiding <span>add()</span>, and you know already enough
about Nim to do it. Just try it. You may start with a <span>string</span> of right size
containing undefined content created by <span>newString(s.len + 4)</span> and then you may copy in
the required data in a loop character for character. Or you may use the slice
operator to insert the passed <span>string</span> into the new <span>string</span>.</p>
<details>
<summary>Click to see a possible solution</summary>
<div>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>framed</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>;</span> <span>c</span><span>:</span> <span>char</span> <span>=</span> <span>&#39;*&#39;</span><span>):</span> <span>string</span> <span>=</span>
  <span>var</span> <span>res</span> <span>=</span> <span>newString</span><span>(</span><span>s</span><span>.</span><span>len</span> <span>+</span> <span>4</span><span>)</span>
  <span>res</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>c</span>
  <span>res</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>&#39; &#39;</span>
  <span>res</span><span>[</span><span>2</span> <span>..</span> <span>s</span><span>.</span><span>high</span> <span>+</span> <span>2</span><span>]</span> <span>=</span> <span>s</span> <span># we may insert the string by using the slice operator or</span>
  <span># for p in 0 .. s.high: # we can use a for loop and</span>
  <span>#   res[p + 2] = s[p] # the subscript operator</span>
  <span>res</span><span>[</span><span>^</span><span>2</span><span>]</span> <span>=</span> <span>&#39; &#39;</span>
  <span>res</span><span>[</span><span>^</span><span>1</span><span>]</span> <span>=</span> <span>c</span>
  <span>return</span> <span>res</span></code></pre>
</div>
</div>
</div>
</details>
<p>The situation that we may need a procedure that works on a <span>var</span> parameter in one case
and returns a modified copy in another case is not that rare. So for example Nim’s
standard library contains a procedure called <span>sort()</span> which can sort container data
types in place, and a procedure called <span>sorted()</span> which returns a sorted copy. This
code duplication is not really that nice. Of course <span>sorted()</span> is the more universal
solution, as we can always replace <span>sort(data)</span> with <span>data = sorted(data)</span>. But the
later creates a temporary copy, which may not be optimal for performance. Since Nim
version 1.2 a <span>dup()</span> macro is available from <span>sugar</span> module which creates copies of
variables and then applies one or multiple in place <span>procs</span> on the copy. So the <span>procs</span>
<span>sorted()</span> or our <span>proc</span> <span>framed()</span> would be unnecessary. We can use <span>dup()</span> as in this
example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>sugar</span> <span>import</span> <span>dup</span>

<span>proc </span><span>frame</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>string</span><span>;</span> <span>c</span><span>:</span> <span>char</span> <span>=</span> <span>&#39;*&#39;</span><span>)</span> <span>=</span>
  <span>var</span> <span>cs</span> <span>=</span> <span>newString</span><span>(</span><span>2</span><span>)</span>
  <span>cs</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>c</span>
  <span>cs</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>&#39; &#39;</span>
  <span>insert</span><span>(</span><span>s</span><span>,</span> <span>cs</span><span>)</span>
  <span>add</span><span>(</span><span>s</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
  <span>add</span><span>(</span><span>s</span><span>,</span> <span>c</span><span>)</span>

<span>echo</span> <span>&#34;Hello World&#34;</span><span>.</span><span>dup</span><span>(</span><span>frame</span><span>)</span>
<span>echo</span> <span>&#34;Hello World&#34;</span><span>.</span><span>dup</span><span>(</span><span>frame</span><span>,</span> <span>frame</span><span>)</span>
<span>echo</span> <span>&#34;Hello World&#34;</span><span>.</span><span>dup</span><span>(</span><span>frame</span><span>(</span><span>&#39;#&#39;</span><span>))</span></code></pre>
</div>
</div>
<p>Note that we apply <span>frame()</span> two times in the line before the last one — in the same
way we could apply a sequence of different <span>procs</span>. The result of above program is</p>
<div>
<div>
<pre>* Hello World *
* * Hello World * *
# Hello World #</pre>
</div>
</div>
</div>
<div>
<h4 id="_returning_from_a_procedure_and_the_implicit_result_variable">Returning from a Procedure and the implicit Result variable</h4>
<p>The execution of a procedure terminates when the last statement of the procedure body
has been processed. We can also terminate a procedure earlier when we specify a
<span>return</span> statement somewhere.</p>
<p>Functions and procedures which return a result can also terminate with the last
expression of the procedure body, or earlier with a return expression like
<span>return i * i</span>. Functions and procedures with a result declare automatically a mutable
<span>result</span> variable for us, which is of the function’s return type and which we may use or just ignore. So for our previous <span>sqr()</span>
function we have various ways to write it:</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>sqr1</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>i</span> <span>*</span> <span>i</span>

<span>func</span> <span>sqr2</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>result</span> <span>=</span> <span>i</span> <span>*</span> <span>i</span>

<span>func</span> <span>sqr3</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>return</span> <span>i</span> <span>*</span> <span>i</span></code></pre>
</div>
</div>
<p>For short and simple procedures the first form is often used. For longer procedures
where the result is constructed in multiple steps, like some <span>string</span> operations, using
the <span>result</span> variable makes sense. And finally, when there exist multiple points where
we may jump back using <span>return</span> statements may make sense. One use case is an early
error check, maybe we want to <span>return -1</span> as some form of error indication when we
write a procedure that should calculate the square root of an integer value. (Well in
Nim we have other and sometimes better ways to catch errors, we will learn about that
later.)</p>
<p>Generally we should avoid writing something like</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>sqr</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>result</span> <span>=</span> <span>i</span>
  <span>i</span> <span>*</span> <span>i</span></code></pre>
</div>
</div>
<p>as it may be unclear in this case if the expression <span>i * i</span> is returned or the <span>result</span>
variable with value <span>i</span>. For Nim v1.6 we will get a warning or an error message in such
a case.</p>
<p>For the performance of our code, it may have a tiny benefit to only use the
result variable and fully avoiding return statements, as in this case for
a function call like <span>var i = sqr(j)</span> the result variable may be just an alias for the
actual result i here, so that the compiler can optimize the code and avoid temporary copies.
But that are rumors, and may depend on the actual compiler version.</p>
</div>
<div>
<h4 id="_var_return_type">Var Return Type</h4>
<p>A procedure, converter, or iterator may return a <span>var</span> type, which can be modified by the caller.
The Nim compiler manual provides this basic example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>g</span> <span>=</span> <span>0</span>
<span>proc </span><span>writeAccessToG</span><span>():</span> <span>var</span> <span>int</span> <span>=</span>
  <span>result</span> <span>=</span> <span>g</span>
<span>writeAccessToG</span><span>()</span> <span>=</span> <span>6</span>
<span>assert</span> <span>g</span> <span>==</span> <span>6</span></code></pre>
</div>
</div>
<p>This way we can call a <span>proc</span> and immediately assign a new value to the result.
In the above example this works, as the result is an alias for the global variable <span>g</span>.</p>
<p>Actually used are <span>var return types</span> for iterators like <span>mitems()</span> or <span>mpairs()</span>,
which allows to modify the yielded results. For details and restrictions
of the <span>var return type</span> you should consult the Nim compiler manual:</p>
<p>References:</p>

</div>
<div>
<h4 id="_proc_name_overloading">Proc name overloading</h4>
<p>Note that we used the <span>proc</span> names <span>sqr1</span>, <span>sqr2</span> and <span>sqr3</span> above. Using the same name with
the same argument types multiple times would result in a redefinition error, as the
compiler could not know what <span>proc</span> body should be executed when that <span>proc</span> name is
called.</p>
<p>But Nim supports so called <span>proc</span> overloading, that is we can use the same name when
the parameter list is different, as the compiler can select from the parameters in
the <span>proc</span> call which <span>proc</span> has to be called:</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>sqr</span><span>(</span><span>i</span><span>:</span> <span>real</span><span>):</span> <span>real</span> <span>=</span>
  <span>i</span> <span>*</span> <span>i</span></code></pre>
</div>
</div>
<p>We have only changed the parameter and result data type. Now there is no conflict
with the <span>proc</span> with same name which we defined for integers. Note that Nim use only
the parameter list for overload resolution, but not the result type of a <span>proc</span> or
function. The reason for that is that Nim supports type inference, and that would not
work when we would have two <span>procs</span> with same name each accepting an <span>int</span> parameter but
one returning an <span>int</span> and one returning a <span>float</span> number.</p>
<p>Nim does also support named arguments in <span>proc</span> calls, that is we could invoke the <span>proc</span>
above with sqr(i = 2.0). Named arguments can be useful when <span>procs</span> or functions have
many arguments, maybe some with default values, and we do not remember the order of
parameters or when we want to specify only a few.</p>
</div>
<div>
<h4 id="_objects_and_ref_objects_as_procedure_parameters">Objects and Ref Objects as Procedure Parameters</h4>
<p>In the previous section we learned that we have to pass <span>var</span> parameters when the
procedure should be able to mutate the variable permanently. This is also valid when
the parameters are objects. When a procedure should modify fields of an object
parameter, then we have to pass that object as a <span>var</span> parameter. In the following
example <span>proc</span> <span>t1</span> gives a compiler error because that procedure tries to modify a field
of an <span>object</span> while the <span>object</span> instance is not passed as a <span>var</span> parameter. If we
remove <span>proc</span> <span>t1</span> then we can compile and run the example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span> <span>O</span> <span>=</span> <span>object</span>
  <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>t1</span><span>(</span><span>o</span><span>:</span> <span>O</span><span>)</span> <span>=</span>
  <span>o</span><span>.</span><span>i</span> <span>=</span> <span>7</span> <span># Error: &#39;o.i&#39; cannot be assigned to</span>

<span>proc </span><span>t2</span><span>(</span><span>o</span><span>:</span> <span>var</span> <span>O</span><span>)</span> <span>=</span>
  <span>o</span><span>.</span><span>i</span> <span>=</span> <span>13</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>x</span> <span>=</span> <span>O</span><span>(</span><span>i</span><span>:</span> <span>3</span><span>)</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>
  <span>t2</span><span>(</span><span>x</span><span>)</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The output is:</p>

<p>Proc <span>t2</span> gets a <span>var</span> parameter and can modify fields of the passed <span>object</span>. Here we
used the expression <span>echo x.repr</span> to print the whole object. Strings and sequences are
value objects in Nim, so you have to pass them as <span>var</span> parameters when you want to
change their length or when you want to modify elements. This code would give you
compile errors, unless you add the <span>var</span> keyword to make the <span>proc</span> parameters mutable:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>t1</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>s</span><span>.</span><span>setLen</span><span>(</span><span>7</span><span>)</span>
  <span>s</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;x&#39;</span>

<span>proc </span><span>t2</span><span>(</span><span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>s</span><span>.</span><span>setLen</span><span>(</span><span>7</span><span>)</span>
  <span>s</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>13</span></code></pre>
</div>
</div>
<p>This was not really surprising. But what when we use a reference to an <span>object</span> and
pass that to procedures as value and as <span>var</span> parameter? In the code below <span>proc</span> <span>t1</span>
gets a variable of type <span>ref object</span> and the procedure can modify fields of the passed
instance. That can be indeed surprising. In this case passing the <span>ref object</span> without
use of the <span>var</span> keyword means only that we can not mutate the <span>ref</span> value itself in the
procedure, but we are allowed to modify the fields of the object. For <span>proc</span> <span>t2</span> we
pass a <span>var</span> parameter. As always we can modify a <span>var</span> parameter in the procedure, so we
can assign it a newly created instance.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span> <span>O</span> <span>=</span> <span>ref</span> <span>object</span>
  <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>t1</span><span>(</span><span>o</span><span>:</span> <span>O</span><span>)</span> <span>=</span>
  <span>o</span><span>.</span><span>i</span> <span>=</span> <span>7</span>

<span>proc </span><span>t2</span><span>(</span><span>o</span><span>:</span> <span>var</span> <span>O</span><span>)</span> <span>=</span>
  <span>o</span> <span>=</span> <span>O</span><span>(</span><span>i</span> <span>:</span> <span>11</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>x</span> <span>=</span> <span>O</span><span>(</span><span>i</span> <span>:</span> <span>3</span><span>)</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>
  <span>t1</span><span>(</span><span>x</span><span>)</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>
  <span>t2</span><span>(</span><span>x</span><span>)</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we compile and run above code we get:</p>
<div>
<div>
<pre>ref 0x7f054a904050 --&gt; [i = 3]

ref 0x7f054a904050 --&gt; [i = 7]

ref 0x7f054a904070 --&gt; [i = 11]</pre>
</div>
</div>
<p>For a <span>ref object</span> the <span>repr()</span> function gives us the address of the <span>object</span> instance in
memory and the contents of its fields. The first two <span>echo()</span> statements shows the same
address, indicating that <span>proc</span> <span>t1</span> has modified only a field of our instance, the
instance itself (its address in memory) was not changed. But <span>proc</span> <span>t2</span> has created a
new instance and assigned that value to the variable <span>x</span> in the <span>main()</span> procedure. We
notice this as the address of variable <span>x</span> has changed. The old instance variable with
address <span>0x7f054a904050</span> is now unused and will be freed by the Nim memory management.</p>
</div>
</div>
<div>
<h3 id="_special_argument_types_openarray_and_varargs">Special Argument Types: OpenArray and Varargs</h3>
<p>The <span>openArray</span> and <span>varargs</span> data types can be used only in parameter lists. <span>OpenArray</span>
is a type which allows to pass arrays and sequences to the procedure or function.
Allowing that makes sense as arrays as well as sequences store their content in a block of
memory, which can be processed uniformly. Although arrays generally do not have to
start with index number <span>0</span>, when passed as <span>openArray</span> the first element is mapped to
index <span>0</span>, and the index of the last element is available by using the <span>high()</span> function
on the passed array parameter. Whenever we write a procedure that accepts an array or
a sequence, we should consider using the <span>openArray</span> parameter type to allow passing in
both data types. <span>Strings</span> can be passed also to <span>procs</span> accepting <span>openArrays</span> with <span>char</span>
base type. Note that a <span>proc</span> with <span>openArray</span> parameter type can not change the length
of a passed <span>seq</span>, as for the <span>openArray</span> parameter type sequences are handled like
arrays. So in the code below <span>proc</span> <span>t1</span> generates a compiler error while <span>t2</span> compiles
and works fine.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>t1</span><span>(</span><span>x</span><span>:</span> <span>var</span> <span>openarray</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>x</span><span>.</span><span>setLen</span><span>(</span><span>7</span><span>)</span>

<span>proc </span><span>t2</span><span>(</span><span>x</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>x</span><span>.</span><span>setLen</span><span>(</span><span>7</span><span>)</span></code></pre>
</div>
</div>
<p>The <span>varargs</span> parameter type is similar to the <span>openArray</span> type, but it additional allows
passing an arbitrary number of single arguments. The compiler automatically collects
the single arguments into an array for us, so in the <span>proc</span> body we can use it like an
array, e.g. iterating over it.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>print</span><span>(</span><span>s</span><span>:</span> <span>varargs</span><span>[</span><span>string</span><span>]</span><span>)</span> <span>=</span>
  <span>for</span> <span>el</span> <span>in</span> <span>s</span><span>:</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>el</span><span>)</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;, &#34;</span><span>)</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>

<span>print</span><span>(</span><span>&#34;Hello&#34;</span><span>,</span> <span>&#34;World&#34;</span><span>)</span> <span># compiler builds the array for us</span>
<span>print</span><span>(</span><span>[</span><span>&#34;Hello&#34;</span><span>,</span> <span>&#34;World&#34;</span><span>]</span><span>)</span> <span># we generate the array our self</span></code></pre>
</div>
</div>
<p>There exists a variant of the <span>varargs</span> argument type that performs a type conversion
automatically by applying a <span>proc</span> on all arguments. For example <span>varargs[string, <code>$</code>]</span>
would apply the stringify operation on the passed arguments automatically. That is
what <span>echo()</span> does.</p>
<p><span>Varargs</span> arguments may be only allowed for the last argument in a parameter list.</p>
<p>Finally we may wonder if it makes sense to specify a parameter of type <span>var varargs</span>.
If we try to pass a constant string this will obviously not work, and if the compiler
generates an <span>array</span> for us it does also not work, the automatically generated <span>array</span>
seems to behave like a constant <span>array</span>. But may we pass an <span>array</span> variable? Let us try:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>print</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>varargs</span><span>[</span><span>string</span><span>]</span><span>)</span> <span>=</span>
  <span>s</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#34;Goodbye&#34;</span>
  <span>for</span> <span>el</span> <span>in</span> <span>s</span><span>:</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>el</span><span>)</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;, &#34;</span><span>)</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>

<span>var</span> <span>msg</span> <span>=</span> <span>[</span><span>&#34;Hello&#34;</span><span>,</span> <span>&#34;World&#34;</span><span>]</span>
<span>print</span><span>(</span><span>msg</span><span>)</span></code></pre>
</div>
</div>
<p>Surprisingly that does not compile, while it works when we replace <span>varargs</span> with
<span>openArray</span>.</p>
</div>
<div>
<h3 id="_procedures_bound_to_a_data_type">Procedures bound to a Data Type</h3>
<p>In some other programming languages like Python or Ruby we can define class methods
or static methods which are bound to a class or type and can be called as
MyType.myProc. In Nim we can do something similar by use of the <span>typedesc</span> <span>proc</span>
parameter type:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
    <span>Factory</span> <span>=</span> <span>object</span>
        <span>name</span><span>:</span> <span>string</span>

<span>proc </span><span>start</span><span>(</span><span>t</span><span>:</span> <span>typedesc</span><span>[</span><span>Factory</span><span>]</span><span>)</span> <span>=</span>
    <span>echo</span> <span>&#34;Factory.start&#34;</span>

<span>Factory</span><span>.</span><span>start</span></code></pre>
</div>
</div>
<p>Here we used the method call syntax instead of <span>start(Factory)</span>. We will learn more
about the <span>typedesc</span> data type later.</p>
</div>
<div>
<h3 id="_scoping_visibility_and_locality">Scoping , Visibility and Locality</h3>
<p>Scoping, visibility and locality is an important concept in computer programming to
keep the source code clean. Imagine that a variable which we declare at some point in
our program would be visible everywhere. That would even for medium size programs
generate a lot of confusion — whenever we would need a variable we would have to
carefully check which names are already in use. And for performance it would be bad
also, as all variables declared somewhere would reside permanently in memory.</p>
<p>So most programming languages including Nim support the concept of locality — names
declared inside of a procedure body or inside another form of block are only visible
there and can only be used there. We say that they are only visible in that scope.
For Nim we can say that whenever Nim’s syntax requires a new level of indentation,
that is a new statement block, then all symbols declared in that block are only
visible in that block and in sub-blocks of this block, but not outside of that block.
Nim has another important concept of visibility, which is called modules and allows
separation of our code in logically separated text files with well defined visibility
rules, we will discuss modules later.</p>
<p>Visibility is really a simple concept, let us regard this useless example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>e</span><span>:</span> <span>float</span> <span>=</span> <span>2.7</span>

<span>proc </span><span>p1</span> <span>=</span>
  <span>var</span> <span>x</span><span>:</span> <span>float</span> <span>=</span> <span>3.1415</span>
  <span>if</span> <span>x</span> <span>&gt;</span> <span>1.0</span><span>:</span>
    <span>var</span> <span>y</span> <span>=</span> <span>2.0</span> <span>*</span> <span>x</span>
    <span>echo</span> <span>y</span> <span># OK</span>
  <span>echo</span> <span>x</span> <span># OK</span>
  <span>echo</span> <span>y</span> <span># compile error, y is not visible</span>
  <span>echo</span> <span>e</span> <span># OK, e is declared globally, so it is visible everywhere</span>

<span>echo</span> <span>e</span> <span># OK</span>
<span>echo</span> <span>x</span> <span># ?</span>
<span>echo</span> <span>y</span> <span># ?</span></code></pre>
</div>
</div>
<p>In line one we declare a so called global variable, that one is visible after
declaration, that is below the line where it is declared, in the whole program. The
variables declared in the <span>proc</span> <span>p1</span> are called local variables, they are not visible
outside of that <span>proc</span> <span>p1</span>. The variable <span>x</span> is declared at the start of the <span>proc</span> body and
is visible in the whole <span>proc</span> everywhere, while variable <span>y</span> is declared in the <span>if</span> block
and is visible only there. So it should be clear if the last two echo statements for
<span>x</span> and <span>y</span> compile fine? Remember that symbols that we define inside of a new scope
may shadow symbols that were visible outside of the actual block, e.g. by defining a variable
named <span>e</span> of arbitrary type in the <span>proc</span> <span>p1</span> from above would shadow the global variable <span>e</span>, that is the global variable <span>e</span>
would become invisible until execution of <span>proc</span> <span>p1</span> terminates. We discussed shadowing
already in the introducing section <a href="#Blocks">Scopes, Visibility, Locality and Shadowing</a>.</p>
<p>Related to visibility of variables is their lifetime, that is the duration how long
they exist and how long they can store a value. Global variables exist for the whole
program runtime — when you have assigned a value to it that value can be used
everywhere as long as the program runs, and as long as you do not assign a different
value of course. Global variables are generally stored in a special memory region
that is called the BSS region.</p>
<p>Variables of value type defined locally inside a procedure or function do exist only
for the execution time of that <span>proc</span>, that is they are created when the <span>proc</span> is
invoked and vanish when the <span>proc</span> terminates, that is when execution continues with
the statement following on the <span>proc</span> call.</p>
<p>Local variables declared in a <span>proc</span> reside in a special memory region of the RAM which
is called the stack. The stack is nothing more than an arbitrary part of the hole RAM
that is used in some clever fashion: The memory words in it are used in consecutive
order. A so called stack pointer is used to indicate the address of the first free
area in that stack. So when a <span>proc</span> is called, which may have <span>n</span> bytes of local
variables, then the compiler can use the area where the stack pointer points to for
that variables, and when the <span>proc</span> is called then the stack pointer is increased by
that size. So the stack pointer points again to the next free area of the stack, and
another <span>proc</span> can be called in the same way from within the current <span>proc</span>. Whenever a
proc terminates, the stack pointer is set back to the value which it had when the
proc starts execution. This method of memory management is simple and fast, but it
does only work when the total amount of memory that the local variables in a <span>proc</span>
needs is known at compile time, so that the compiler can adjust the stack pointer
accordingly. It does not work for dynamically sized data types like strings or
sequences.</p>
<p>Note that pointers and references are value types itself, we can regard pointers and
references as a plain integer variable interpreted in a special way — as a memory
location. But the memory blocks to which the pointers and references may point and
that is allocated by <span>alloc()</span> or <span>new()</span> is different: That memory blocks are not
allocated on the stack, but in the ordinary RAM which we call heap to separate it
from the stack.</p>
<p>So why can the stack not be used for memory blocks which <span>alloc()</span> or <span>new()</span> provides
for us: An important fact for the use of the stack to store variables is that the
total size which is needed by a <span>proc</span> for all the static variables must be a compile
time constant. The stack pointer is adjusted by that amount when the <span>proc</span> starts and
all the local variables are accessed with a fixed offset to that stack pointer then.
When we use <span>alloc()</span> or <span>new()</span> in a <span>proc</span>, then we may call that multiple times like we
did in our previous list example, and for <span>alloc()</span> an additional fact is that the byte
size that <span>alloc()</span> should reserve can be a runtime value. So the total amount of RAM
that <span>alloc()</span> or <span>new()</span> would allocate is a runtime value, and we can not use the stack
for it. Instead <span>alloc()</span> and <span>new()</span> allocates block of memory in a more dynamic
fashion, which is basically that they ask the OS for a free block of right size
somewhere in the available RAM. That block is later given back to the OS for reuse by
functions like <span>dealloc()</span> or automatically by the GC.</p>
<p>Let us at the end of this section investigate some special cases:</p>
<p>While in languages like C we have always a well defined <span>main()</span> function and all
program code is contained in this function or in other functions which are called
from this main function, in Nim we have also global code as in scripting languages
Ruby or Python:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span><span>:</span> <span>int</span>
<span>while</span> <span>i</span> <span>&lt;</span> <span>100</span><span>:</span>
  <span>var</span> <span>j</span><span>:</span> <span>int</span>
  <span>j</span> <span>=</span> <span>i</span> <span>*</span> <span>i</span>
  <span>echo</span> <span>j</span>
  <span>inc</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>It should be clear that the global variable <span>i</span> resides in the BSS segment. But what is
with the variable <span>j</span> declared in the body of the <span>while</span> statement? It is clear that
that variable is only visible inside of the body of the <span>while</span> statement. But does <span>j</span>
reside on the stack? There seems to be no <span>proc</span> involved so there may be no stack? The
variable <span>j</span> may reside in the BSS segment too? That is not really clear and may be
different for different Nim compilers maybe. But why should we care for that detail
at all? Well it may be important for performance. Local <span>proc</span> variables allocated on
the stack are generally optimal for performance, and they are optimized by the
compiler very well. We will learn more about the reasons for that later when we
discuss the data cache. For now we should only remember that it may be a good idea to
avoid global code and put all code in <span>procs</span>. We may have an arbitrary named <span>main()</span>
proc then and call that from global scope only. At least for the current Nim v1.6
that seems to be a good idea, maybe later versions or other implementations will
automatically move all global code into a hidden <span>proc</span> for us.</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
For optimal performance put all your code in procedures or functions and avoid
global code and when possible global variables.
</td>
</tr>
</tbody></table>
</div>
<p>Let us discuss above while loop again, but this time in the body of a <span>proc</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p</span> <span>=</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>100</span><span>:</span>
    <span>let</span> <span>j</span><span>:</span> <span>int</span> <span>=</span> <span>i</span> <span>*</span> <span>i</span>
    <span>echo</span> <span>j</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>When we carefully investigate that <span>proc</span> within the while loop we may wonder about two
points. First we said earlier that we can and should use the <span>let</span> keyword instead of
<span>var</span> when there is only one assignment to a variable, so the variable can be regarded
as immutable. But the loop is executed 100 times, so how can we say there is only a
single assignment to variable <span>j</span>? The trick is, that <span>j</span> is locally to the <span>while</span> loop,
and that <span>j</span> is virtually newly created and initialized to <span>0</span> for each iteration. So let
is OK and the compiler does not complain.</p>
<p>We can test that fact with this simple program:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>10</span><span>:</span>
    <span>var</span> <span>a</span><span>:</span> <span>int</span>
    <span>a</span> <span>=</span> <span>a</span> <span>+</span> <span>1</span>
    <span>echo</span> <span>a</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The output is <span>1</span> for each loop iteration, as variable <span>a</span> is virtually newly created for
each loop iteration.</p>
<p>We said virtually newly created, because we can not be sure how the compiler may
handle it internally. Is storage for variable <span>a</span> already allocated when the <span>proc</span> is
invoked, that is in the same way as storage for the loop counter variable <span>i</span> is
allocated on the stack when the <span>proc</span> is called. Or is storage for variable <span>a</span> reserved
for each loop iteration by increasing the stack pointer at the start of the loop and
resetting it at the end of the loop. We can not be sure without reading the compiler
source code, but finally we should not care, as it does not really matter.</p>
</div>
<div>
<h3 id="_generics">Generics</h3>
<p>In the previous section we defined a <span>sqr()</span> <span>proc</span> for <span>ints</span> and one for <span>float</span> numbers.
Both <span>procs</span> look nearly identical, only the data types differ. For that case we can
use so called generic procedures.</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>sqr</span><span>[</span><span>T</span><span>]</span><span>(</span><span>v</span><span>:</span> <span>T</span><span>):</span> <span>T</span> <span>=</span>
  <span>var</span> <span>p</span><span>:</span> <span>T</span>
  <span>p</span> <span>=</span> <span>v</span> <span>*</span> <span>v</span>
  <span>return</span> <span>p</span>

<span>echo</span> <span>sqr</span><span>(</span><span>2</span><span>)</span>
<span>echo</span> <span>sqr</span><span>(</span><span>3.1415</span><span>)</span></code></pre>
</div>
</div>
<p>We put a square bracket after the function name which includes a symbolic name, and
that name is then used instead of concrete types in the <span>proc</span> header or in the <span>proc</span>
body.</p>
<p>We can now call that <span>proc</span> with parameters of different types including <span>int</span> and <span>float</span>
types. You may wonder why that works — Nim is a statically typed language, so how
can the parameter of function <span>sqr()</span> as well accept an integer as a floating point number? Is
there a hidden type conversion involved? No, the trick is that whenever we call that
generic <span>proc</span> with a different type, then a new <span>proc</span> or function is instantiated. As
we called the generic <span>sqr()</span> <span>proc</span> with an <span>int</span> and a <span>float</span> parameter, during compile
time the compiler creates machine code for two separate functions, one which is called
when an <span>int</span> is passed as parameter, and one which is called when a <span>float</span> is passed.
If we would call that <span>proc</span> name again with an <span>int</span> or <span>float</span> parameter, than one of the
two existing <span>procs</span> would be used. But for a different, still unused data type like
<span>float32</span> again a new <span>proc</span> would be instantiated. In this way generics <span>procs</span> can lead
to some code bloat. Note that calling the generic function with a data type like a
character or a <span>string</span> would fail, as that types do not support multiplication with
itself.</p>
<p>A slightly different notation is available by so called <span>or</span> types:</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>sqr</span><span>(</span><span>v</span><span>:</span> <span>int</span> <span>or</span> <span>float</span><span>):</span> <span>auto</span> <span>=</span>
  <span>var</span> <span>p</span><span>:</span> <span>typeof</span><span>(</span><span>v</span><span>)</span>
  <span>p</span> <span>=</span> <span>v</span> <span>*</span> <span>v</span>
  <span>return</span> <span>p</span>

<span>echo</span> <span>sqr</span><span>(</span><span>2</span><span>)</span>
<span>echo</span> <span>sqr</span><span>(</span><span>3.1415</span><span>)</span></code></pre>
</div>
</div>
<p>Here we have limited the parameter types to the <span>int</span> type or the <span>float</span> type. We could
have defined also a custom type first, like <span>type MyNum = int or float</span> and use that
type for the type of our <span>sqr()</span> <span>proc</span>. These <span>or types</span> are also called
<span>type classes</span>. Instead of keyword <span>or</span> the <span>|</span> character can be
used for defining type classes. Again the compiler would instantiate two separate
functions for the both data types. As we had not the symbolic type T available here,
we have used the keyword <span>auto</span> as return type, and for the type of variable <span>p</span> we used
the macro <span>typeof()</span>. The type <span>auto</span> for the return type works as long as the function
returns a well defined type. Note that we can not decide at runtime what a type the
function should return, so a construct like <span>if cond: return 2 else: return 3.1415</span>
would not work, at least not when the values are variables of different type. For the
literal value it may work, as the compiler may be smart and guess that we want to
return the <span>float</span> literal <span>2.0</span>.</p>
<p>A bit care is needed when we define <span>procs</span> for mutable <span>or types</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span># proc t(s: var seq[uint8] | var seq[char]) =</span>
<span>proc </span><span>t</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>(</span><span>seq</span><span>[</span><span>uint8</span><span>]</span> <span>|</span> <span>seq</span><span>[</span><span>char</span><span>]</span><span>))</span> <span>=</span></code></pre>
</div>
</div>
<p>Here we try to define a <span>proc</span> called <span>t</span> which should accept a mutable <span>seq[uint8]</span> or a
mutable <span>seq[char]</span> as parameter. While the first line compiles fine, the <span>seq[char]</span>
would be immutable. The correct notation is shown in the second line. This behavior
was labeled &#34;won’t fix&#34; in github issue tracker, so we have to remember this case,
see <a href="https://github.com/nim-lang/Nim/issues/15063#issue-665553657">https://github.com/nim-lang/Nim/issues/15063#issue-665553657</a>.</p>
<p>Let us assume that you want to define a <span>proc</span> that accepts two numbers of type <span>int</span> or
<span>float</span> and that returns a <span>float</span>. You may write it in one of this ways:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>sqrsum</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>int</span> <span>|</span> <span>float</span><span>):</span> <span>float</span> <span>=</span>
  <span>(</span><span>x</span> <span>*</span> <span>x</span><span>).</span><span>float</span> <span>+</span> <span>(</span><span>y</span> <span>*</span> <span>y</span><span>).</span><span>float</span>

<span>proc </span><span>sqrsum2</span><span>[</span><span>T</span><span>]</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>:</span> <span>T</span><span>):</span> <span>float</span> <span>=</span>
  <span>(</span><span>x</span> <span>*</span> <span>x</span><span>).</span><span>float</span> <span>+</span> <span>(</span><span>y</span> <span>*</span> <span>y</span><span>).</span><span>float</span>

<span>proc </span><span>sqrsum3</span><span>[</span><span>T1</span><span>,</span> <span>T2</span><span>]</span><span>(</span><span>x</span><span>:</span> <span>T1</span><span>;</span> <span>y</span><span>:</span> <span>T2</span><span>):</span> <span>float</span> <span>=</span>
  <span>(</span><span>x</span> <span>*</span> <span>x</span><span>).</span><span>float</span> <span>+</span> <span>(</span><span>y</span> <span>*</span> <span>y</span><span>).</span><span>float</span>

<span>var</span> <span>i</span><span>:</span> <span>int</span> <span>=</span> <span>2</span>
<span>var</span> <span>x</span><span>:</span><span>float</span> <span>=</span> <span>3.0</span>

<span>echo</span> <span>sqrsum</span><span>(</span><span>i</span><span>,</span> <span>x</span><span>)</span>
<span>#echo sqrsum2(i, x)</span>
<span>echo</span> <span>sqrsum2</span><span>(</span><span>x</span><span>,</span> <span>2</span><span>)</span>
<span>#echo sqrsum2(2, x)</span>
<span>echo</span> <span>sqrsum3</span><span>(</span><span>i</span><span>,</span> <span>x</span><span>)</span></code></pre>
</div>
</div>
<p>The commented out lines would give you a compiler error. The reason for this is that
the <span>proc</span> <span>sqrsum2[T]</span> defines a generic <span>proc</span>, but the compiler enforces that both
parameters have the same type. The expression <span>sqrsum2(x, 2)</span> compiles fine,
as due to the first parameter <span>x</span> the compiler instantiates a <span>proc</span> for a <span>float</span>
parameter type, and then converts the second parameter, which is an integer literal,
to <span>float</span> automatically. This automatic conversion is only done for literal numbers,
not for variables. The expression <span>sqrsum2(2, x)</span> does not compile, as due to
the first parameter, which is an integer literal, a <span>proc</span> for integer parameters is
instantiated, and the second <span>x</span> parameter of [.type]float type is not compatible with the
instantiated <span>proc</span>.</p>
<p>Generics can become a bit complicated, as we may use multiple different generic types
for different <span>proc</span> parameters. And we can use generics also for object types, we may
for example create lists like we did for our names list that work not only for
<span>strings</span>, but that can work with other data types like numbers or sequences in a very
similar way. We may explain that in more detail later.</p>
</div>
<div>
<h3 id="_example_for_the_use_of_generics">Example for the use of Generics</h3>
<p>Generics are used a lot in Nim’s standard library. Most container types like sequences or tables
accept generic types, and generic procedures like <span>sort()</span> are provided which can easily sort
arbitrary data types and objects. We have only to provide a <span>cmp()</span> <span>proc</span> for our user defined
data types which <span>sort()</span> can call to compare the values during the sorting process.</p>
<p>We will demonstrate the use of generics for library modules with a few tiny examples: Assume
we create a library which should be able to store and process arbitrary data types. The stored values
may have well defined relations, which enables ordering or much more complicated spatial
relations. Triangulation of spatial data points or grouping the data in structures like
<span>RTrees</span> for fast point location as well as geometric processing with algorithm like
finding the convex hull are some examples. To make our example simple and compact, we define
a generic container type which can store only two values of arbitrary data type. The container allows to sort
the elements by size. The following code example defines a generic container called <span>MyGenericContainer</span>,
a <span>proc</span> to <span>add()</span> data objects into the container instance and a <span>sortBySize()</span> <span>proc</span> to sort the two elements:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span> <span>=</span> <span>object</span>
    <span>storage</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>T</span><span>]</span>

<span>proc </span><span>add</span><span>[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>x</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>y</span>

<span># sort by direct field access</span>
<span>proc </span><span>sortBySize</span><span>[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>.</span><span>size</span> <span>&gt;</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>.</span><span>size</span><span>:</span>
    <span>swap</span><span>(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span># a simple stringify proc for our container data type</span>
<span>proc </span><span>`$`</span><span>[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>string</span> <span>=</span>
  <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>&amp;</span> <span>&#34;, &#34;</span> <span>&amp;</span> <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span>type</span>
  <span>TestObj1</span> <span>=</span> <span>object</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>size</span><span>:</span> <span>int</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>TestObj1</span><span>]</span>
  <span>var</span> <span>a</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>size</span><span>:</span> <span>162</span><span>)</span>
  <span>var</span> <span>b</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Bob&#34;</span><span>,</span> <span>size</span><span>:</span> <span>184</span><span>)</span>

  <span>add</span><span>(</span><span>c</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>)</span>
  <span>echo</span> <span>c</span>
  <span>c</span><span>.</span><span>sortBySize</span>
  <span>echo</span> <span>c</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The <span>sortBySize()</span> <span>proc</span> of the above examples accesses the size field of our data objects directly, so we can
use the container for arbitrary data types as long as the data types have a size field and as long as
a <span>&gt;</span> <span>proc</span> is defined for the data type of the size field. In the above example we have defined a <span>$</span> procedure
to convert instances of our container to a <span>string</span>, which allows us to call the <span>echo()</span> function on it.
The output of our program looks like</p>
<div>
<div>
<pre>(name: &#34;Bob&#34;, size: 184), (name: &#34;Alice&#34;, size: 162)
(name: &#34;Alice&#34;, size: 162), (name: &#34;Bob&#34;, size: 184)</pre>
</div>
</div>
<p>We can avoid the restriction of a matching field name when we provide getter and setter procedures
which the library <span>procs</span> can use to access the important fields:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span> <span>=</span> <span>object</span>
    <span>storage</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>T</span><span>]</span>

<span>proc </span><span>add</span><span>[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>x</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>y</span>

<span>proc </span><span>sortBySize</span><span>[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>.</span><span>size</span> <span>&gt;</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>.</span><span>size</span><span>:</span>
    <span>swap</span><span>(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span>proc </span><span>`$`</span><span>[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>string</span> <span>=</span>
  <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>&amp;</span> <span>&#34;, &#34;</span> <span>&amp;</span> <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span>type</span>
  <span>TestObj1</span> <span>=</span> <span>object</span> <span># arbitrary field names</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>length</span><span>:</span> <span>int</span>

<span># this getter proc enables sorting</span>
<span>proc </span><span>size</span><span>(</span><span>t</span><span>:</span> <span>TestObj1</span><span>):</span> <span>int</span> <span>=</span>
  <span>t</span><span>.</span><span>length</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>TestObj1</span><span>]</span>
  <span>var</span> <span>a</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>length</span><span>:</span> <span>162</span><span>)</span>
  <span>var</span> <span>b</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Bob&#34;</span><span>,</span> <span>length</span><span>:</span> <span>184</span><span>)</span>

  <span>add</span><span>(</span><span>c</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>)</span>
  <span>echo</span> <span>c</span>
  <span>c</span><span>.</span><span>sortBySize</span>
  <span>echo</span> <span>c</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>In the example above our <span>TestObj1</span> data type has no field with a name matching for the
<span>sortBySize()</span> <span>proc</span>, but we define a <span>size()</span> <span>proc</span> for our data type which that library function
can use. This solution is more flexible, and when we add the inline pragma to the used <span>size()</span> <span>proc</span>
or when we compile with link time optimization (LTO) enabled, then the overhead should be negligible.
The two examples above are located in a single file each, but of course for practical use
we would use separate modules for the library and the application part as in</p>
<div>
<div>
<pre><code data-lang="nim"><span>#module t3.nim</span>
<span>type</span>
  <span>MyGenericContainer</span><span>*[</span><span>T</span><span>]</span> <span>=</span> <span>object</span>
    <span>storage</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>T</span><span>]</span>

<span>proc </span><span>add</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>x</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>y</span>

<span>proc </span><span>sortBySize</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>.</span><span>size</span> <span>&gt;</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>.</span><span>size</span><span>:</span>
    <span>swap</span><span>(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span>proc </span><span>`$`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>string</span> <span>=</span>
  <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>&amp;</span> <span>&#34;, &#34;</span> <span>&amp;</span> <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>t3</span>

<span>type</span>
  <span>TestObj1</span> <span>=</span> <span>object</span> <span># arbitrary field names</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>length</span><span>:</span> <span>int</span>

<span>proc </span><span>size</span><span>(</span><span>t</span><span>:</span> <span>TestObj1</span><span>):</span> <span>int</span> <span>=</span>
  <span>t</span><span>.</span><span>length</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>TestObj1</span><span>]</span>
  <span>var</span> <span>a</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>length</span><span>:</span> <span>162</span><span>)</span>
  <span>var</span> <span>b</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Bob&#34;</span><span>,</span> <span>length</span><span>:</span> <span>184</span><span>)</span>

  <span>add</span><span>(</span><span>c</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>)</span>
  <span>echo</span> <span>c</span>
  <span>c</span><span>.</span><span>sortBySize</span>
  <span>echo</span> <span>c</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The example with direct field access would look for different modules like this:</p>
<div>
<div>
<pre><code data-lang="nim"><span># module t4.nim</span>
<span>type</span>
  <span>MyGenericContainer</span><span>*[</span><span>T</span><span>]</span> <span>=</span> <span>object</span>
    <span>storage</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>T</span><span>]</span>

<span>proc </span><span>add</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>x</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>y</span>

<span>proc </span><span>sortBySize</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>.</span><span>size</span> <span>&gt;</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>.</span><span>size</span><span>:</span>
    <span>swap</span><span>(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span>proc </span><span>`$`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>string</span> <span>=</span>
  <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>&amp;</span> <span>&#34;, &#34;</span> <span>&amp;</span> <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>t4</span>

<span>type</span>
  <span>TestObj1</span> <span>=</span> <span>object</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>size</span><span>:</span> <span>int</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>TestObj1</span><span>]</span>
  <span>var</span> <span>a</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>size</span><span>:</span> <span>162</span><span>)</span>
  <span>var</span> <span>b</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Bob&#34;</span><span>,</span> <span>size</span><span>:</span> <span>184</span><span>)</span>

  <span>add</span><span>(</span><span>c</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>)</span>
  <span>echo</span> <span>c</span>
  <span>c</span><span>.</span><span>sortBySize</span>
  <span>echo</span> <span>c</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>You may wonder why we do not have to export the <span>size</span> field of our <span>TestObj1</span> (or maybe the object itself also) as
it is used from code defined in a different module. The reason why we do not need export markers is that
the <span>sortBySize()</span> is defined in the library module, but as it is a generic procedure, it is
instantiated and executed in the application module. For the same reason we had not to export the
<span>size()</span> getter procedure before.</p>
<p>Finally one more way to use generic library modules is by passing procedure variables
to the library functions. The passed in procedures may provide access to
properties or attributes of the stored objects, or they may offer relations between the
objects. The later is often used for sorting purposes:</p>
<div>
<div>
<pre><code data-lang="nim"><span># module tx.nim</span>
<span>type</span>
  <span>MyGenericContainer</span><span>*[</span><span>T</span><span>]</span> <span>=</span> <span>object</span>
    <span>storage</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>T</span><span>]</span>

<span>proc </span><span>add</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>x</span><span>,</span> <span>y</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>x</span>
  <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>y</span>

<span>proc </span><span>sortBy</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>var</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>smaller</span><span>:</span> <span>proc</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>T</span><span>):</span> <span>bool</span><span>)</span> <span>=</span>
  <span>if</span> <span>smaller</span><span>(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>):</span>
    <span>swap</span><span>(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span>

<span>proc </span><span>`$`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>string</span> <span>=</span>
  <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>&amp;</span> <span>&#34;, &#34;</span> <span>&amp;</span> <span>`</span><span>$</span><span>`(</span><span>c</span><span>.</span><span>storage</span><span>[</span><span>1</span><span>]</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tx</span>

<span>type</span>
  <span>TestObj1</span> <span>=</span> <span>object</span>
    <span>name</span><span>:</span> <span>string</span>
    <span>size</span><span>:</span> <span>int</span>

<span>proc </span><span>smaller</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>TestObj1</span><span>):</span> <span>bool</span> <span>=</span>
  <span>a</span><span>.</span><span>size</span> <span>&lt;</span> <span>b</span><span>.</span><span>size</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>c</span><span>:</span> <span>MyGenericContainer</span><span>[</span><span>TestObj1</span><span>]</span>
  <span>var</span> <span>a</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Alice&#34;</span><span>,</span> <span>size</span><span>:</span> <span>162</span><span>)</span>
  <span>var</span> <span>b</span> <span>=</span> <span>TestObj1</span><span>(</span><span>name</span><span>:</span> <span>&#34;Bob&#34;</span><span>,</span> <span>size</span><span>:</span> <span>184</span><span>)</span>

  <span>add</span><span>(</span><span>c</span><span>,</span> <span>b</span><span>,</span> <span>a</span><span>)</span>
  <span>echo</span> <span>c</span>
  <span>c</span><span>.</span><span>sortBy</span><span>(</span><span>smaller</span><span>)</span>
  <span>echo</span> <span>c</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Here we have modified the <span>sort()</span> <span>proc</span> of our library module in a way that it takes
an additional procedure parameter. In this case we use a procedure signature that takes two object instances
and returns a boolean value indicating if the first parameter is smaller than the second.
In our application module we define a matching procedure and pass that one to the <span>sortBy()</span>
procedure. Again we get the desired sorted output:</p>
<div>
<div>
<pre>(name: &#34;Bob&#34;, size: 184), (name: &#34;Alice&#34;, size: 162)
(name: &#34;Alice&#34;, size: 162), (name: &#34;Bob&#34;, size: 184)</pre>
</div>
</div>
<p>This last method is used often in Nim’s standard library, e.g. for sorting
sequences with custom objects. Unfortunately this way can introduce some performance
regression, as the procedure variable has to be passed to the called <span>proc</span> and so
inlining of that passed <span>proc</span> is not possible for the compiler. </p>
</div>
<div>
<h3 id="_method_call_syntax">Method Call Syntax</h3>
<p>A useful coding style introduced by OPP languages is the method call syntax, which
was initially used in OOP programming style for objects, and later applied by
languages like Ruby to all data types. Ruby in some way regards all data as objects.</p>
<p>Method call syntax means, that for example for a variable <span>s</span> of data type <span>string</span> we do
write <span>s.add(c)</span> instead of <span>add(s, c)</span>. Or for an integer variable <span>i</span> we may write <span>i.abs</span>
instead of <span>abs(i)</span>. That is we put the first parameter of the <span>proc</span> parameter list in
front of the <span>proc</span> name, and separate that parameter from the <span>proc</span> name by a period.
The compiler regards both notation as equivalent. The advantage of the method call
syntax is that we may save a character and that it is more clear with what &#34;object&#34;
we are working, as it stands in front of the expression.</p>
<p>Most OOP languages allows that notation only for a class, for example the string
class may declare all possible operations that can be done with strings, and the
method call syntax is used for that operations. One problem is, that it can be
difficult to add more operations which can be used in that style, as often all that
operations are defined in the class scope. Ruby fixed that restriction by allowing so
called reopen of classes, that is user can later add more operations.</p>
<p>Nim simple allows that notation generally, as did the D language, but D used the term
<span>Uniform Function Call Syntax</span> (UFCS) for it.</p>
</div>
<div>
<h3 id="_procedure_variables">Procedure Variables</h3>
<p>Procedures and functions are not always fully static entities. We can assign
procedures and functions to variables, and we can pass whole procedures or functions
as parameters to other procedures or functions. And functions can even generate and
return new functions. Let us investigate how procedure variables work:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span>
  <span>p</span><span>:</span> <span>proc</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span>

<span>proc </span><span>p1</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>i</span> <span>+</span> <span>i</span>

<span>proc </span><span>p2</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>i</span> <span>*</span> <span>i</span>

<span>p</span> <span>=</span> <span>p1</span>
<span>echo</span> <span>p</span><span>(</span><span>7</span><span>)</span>
<span>p</span> <span>=</span> <span>p2</span>
<span>echo</span> <span>p</span><span>(</span><span>7</span><span>)</span></code></pre>
</div>
</div>
<p>The output of the two <span>echo</span> statements should be <span>14</span> and <span>49</span> — we called in both cases
the same <span>proc</span> variable with the same parameter, but the <span>proc</span> variable <span>p</span> was in the
first call an alias for <span>p1</span>, and in the second call an alias for <span>p2</span>. Note, when we
assign a <span>proc</span> to a <span>proc</span> variable we do only write the name of that <span>proc</span>, there is no
<span>()</span> involved. That is because we assign that <span>proc</span> to the <span>proc</span> variable, but we do not
call the <span>proc</span> in this case. Of course, when we assign a <span>proc</span> to a <span>proc</span> variable then
the <span>proc</span> signatures have to match, that is the parameter list and the result have to
be compatible.</p>
<p>Now we use a function as a <span>proc</span> argument.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>EchoProc</span> <span>=</span> <span>proc</span> <span>(</span><span>x</span><span>:</span> <span>float</span><span>)</span>

<span>proc </span><span>t</span><span>(</span><span>ep</span><span>:</span> <span>EchoProc</span><span>;</span> <span>x</span><span>:</span> <span>float</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;The value is&#34;</span>
  <span>ep</span><span>(</span><span>x</span><span>)</span>

<span>proc </span><span>ep1</span><span>(</span><span>x</span><span>:</span> <span>float</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;==&gt; &#34;</span><span>,</span> <span>x</span>

<span>proc </span><span>ep2</span><span>(</span><span>x</span><span>:</span> <span>float</span><span>)</span> <span>=</span>
  <span>echo</span> <span>x</span>

<span>t</span><span>(</span><span>ep1</span><span>,</span> <span>3.1415</span><span>)</span>
<span>t</span><span>(</span><span>ep2</span><span>,</span> <span>3.1415</span><span>)</span></code></pre>
</div>
</div>
<p>A common use case for a function as a <span>proc</span> parameter is sorting. We can use the same
sort procedure for different data types when we provide a <span>cmp()</span> <span>proc</span> that can compare
that data type.</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>algorithm</span> <span>import</span> <span>sort</span>

<span>proc </span><span>cmp</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>if</span> <span>a</span> <span>&lt;</span> <span>b</span><span>:</span>
    <span>-</span><span>1</span>
  <span>elif</span> <span>a</span> <span>==</span> <span>b</span><span>:</span>
    <span>0</span>
  <span>else</span><span>:</span>
    <span>1</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>a</span> <span>=</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>]</span>
  <span>a</span><span>.</span><span>sort</span><span>(</span><span>cmp</span><span>)</span>
  <span>for</span> <span>i</span> <span>in</span> <span>a</span><span>:</span>
    <span>echo</span> <span>i</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The <span>sort()</span> procedure is provided by the <span>algorithm</span> module. The <span>sort()</span> <span>proc</span> accepts an
array or a sequence, and a <span>cmp()</span> <span>proc</span> that gets two parameters of the same type as the
elements in the passed array, and that returns -1, 0, or 1 as the result of the
comparison. We could easily sort other data types like strings or our custom objects
by an arbitrary key, as long as we can provide a matching <span>cmp()</span> <span>proc</span>. For the <span>cmp()</span>
proc it is important that it returns a well defined result based on the input, and
when both parameters are equal it should really return <span>0</span>. If you would exchange the
return values <span>1</span> and <span>-1</span> in the <span>cmp()</span> <span>proc</span> above, you would invert the sort order.</p>
</div>
<div>
<h3 id="_nested_procedures_and_closures">Nested Procedures and Closures</h3>
<p>While in C all functions must be defined in top level scope and nesting of functions
is not allowed, in Nim procedures can contain other procedures. A special case occurs
when the sub-procedures do access variables of the outer scope. In this case the
sub-procedure is called a closure:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>digitScanner</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>)</span> <span>=</span>

  <span>var</span> <span>pos</span> <span>=</span> <span>0</span>
  <span>proc </span><span>nextDigit</span><span>:</span> <span>char</span> <span>=</span>
    <span>while</span> <span>pos</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span> <span>and</span> <span>s</span><span>[</span><span>pos</span><span>]</span> <span>notin</span> <span>{</span><span>&#39;0&#39;</span> <span>..</span> <span>&#39;9&#39;</span><span>}:</span>
      <span>inc</span><span>(</span><span>pos</span><span>)</span>
    <span>if</span> <span>pos</span> <span>==</span> <span>s</span><span>.</span><span>len</span><span>:</span>
      <span>return</span> <span>&#39;\x0&#39;</span>
    <span>result</span> <span>=</span> <span>s</span><span>[</span><span>pos</span><span>]</span>
    <span>inc</span><span>(</span><span>pos</span><span>)</span>

  <span>var</span> <span>c</span><span>:</span> <span>char</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>c</span> <span>=</span> <span>nextDigit</span><span>()</span>
    <span>if</span> <span>c</span> <span>==</span> <span>&#39;\x0&#39;</span><span>:</span>
      <span>break</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>c</span><span>)</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>

<span>digitScanner</span><span>(</span><span>&#34;ad5f2eo73q9st&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>When you run this program the output should be</p>

<p>This program is not that easy, but when you think about it a bit you should be able
to understand it. The task is to extract from a string all the digits and to ignore
the other characters.</p>
<p>To get the digits, we use a local procedure that uses the <span>pos</span> variable of the
enclosing procedure, and also access the parameter <span>s</span> of the enclosing procedure. The
closure <span>nextDigit()</span> checks if the position in the <span>string</span> is still valid, that is if
it is still smaller than the length of the <span>string</span>, and also checks if the current
character is a digit. The first check uses the standard procedure <span>len()</span> which return
the length of a passed <span>string</span> parameter, that is how many characters the <span>string</span>
contains. We have used the method call syntax here instead of using the ordinary <span>proc</span>
call <span>len(s)</span>. The next check test if the current character is not a decimal digit. For
that test we could use a series of compares like <span>if c == &#39;0&#39; or c == &#39;1&#39; or …​ or c
== &#39;9&#39;.</span> But to make such tests easier and faster, Nim offers one more data type, the
<span>set</span> type. And the <span>notin</span> operator tests if an value is not contained in a <span>set</span> constant.
An important point for the expression after the <span>while</span> statement is, that it is
processed from left to right. That fact is here important, because we have first to
check if <span>pos</span> is still a valid position, before we can use the subscript operator <span>[]</span>
to access the current character and test if it is not contained in the <span>set</span>. If the
check for the valid position would not come first, then we may access an invalid
position in the string and we would get a runtime range error.</p>
<p>While the position is still valid but the current character is not a digit we
increase the position. The <span>while</span> loop can end by two conditions: Either the current
character is a digit, or we have reached the end of the <span>string</span> and we have to stop.
For the last case we use a special stop mark, we return a special character which we
have entered in escape notation as <span>&#39;\x0&#39;</span>. That is a very special character, that is
used in C to mark the end of strings. It is the first character in the ASCII table
and has the decimal value <span>0</span>. We said earlier that characters are encoded in 8 bit
and correspond to the unsigned integer numbers <span>0</span> up to <span>255</span>. <span>&#39;\x0&#39;</span> is just a special
notation for the first character which corresponds to integer value <span>0</span>. Well, when the
end of the <span>string</span> is reached then we return that character. Otherwise we return the
current character. Remember, from the while condition we know that the <span>string</span> end is
reached, or current character is a digit. As we tested for the <span>string</span> end before, we can
only have the case that the current character is a digit now. But can we return that
character immediately now? If we would, <span>s[pos]</span> would be a digit, and we would get
exactly the same character for the next <span>proc</span> call! So we have to move to the next
character by increasing <span>pos</span> before we return that character. For this the
pre-declared <span>result</span> variable is useful. We assign the current character to the <span>result</span>
variable, and then increase <span>pos</span>. As the last statement in our <span>proc</span> is not a
expression but a plain <span>inc()</span> statement, the content of the <span>result</span> variable is
returned. The other <span>while</span> loop in the outer procedure is very simple, we just call
the closure in the body of the <span>while</span> loop and terminate the loop when we get the
special <span>Null</span> character.</p>
<p>And finally an example where one <span>proc</span> returns another procedure:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>addN</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>):</span> <span>auto</span> <span>=</span> <span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span> <span>x</span> <span>+</span> <span>n</span><span>)</span>

<span>let</span> <span>add2</span> <span>=</span> <span>addN</span><span>(</span><span>2</span><span>)</span>
<span>echo</span> <span>add2</span><span>(</span><span>7</span><span>)</span></code></pre>
</div>
</div>
<p>The output of <span>echo()</span> would be <span>9</span> in this case. This construct is sometimes named
currying.</p>
</div>
<div>
<h3 id="_anonymous_procedures">Anonymous Procedures</h3>
<p>In the section <a href="#_module_sequtils">Module sequtils</a> in part III of the book we will introduce a few functions
which are often used in the functional programming style like <span>map()</span> or <span>filter()</span>.
These functions get procedures as arguments that determine how container data types
are converted. We can pass a regular named procedure as second argument to <span>procs</span> like
<span>map()</span> and <span>filter</span>, or in simple cases we can just pass an anonymous <span>proc</span> or use the <span>⇒</span>
operator provided by the <span>sugar</span> module:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span><span>,</span> <span>sugar</span>

<span>proc </span><span>primeFilter</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span>
  <span>x</span> <span>in</span> <span>{</span><span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>13</span><span>}</span>

<span>var</span> <span>s</span> <span>=</span> <span>(</span><span>0</span> <span>..</span> <span>9</span><span>).</span><span>toSeq</span> <span># @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>

<span>echo</span> <span>s</span><span>.</span><span>filter</span><span>(</span><span>primeFilter</span><span>)</span> <span># @[3, 5, 7]</span>
<span>echo</span> <span>s</span><span>.</span><span>filter</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span> <span>(</span><span>x</span> <span>and</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span># @[0, 2, 4, 6, 8]</span>

<span>echo</span> <span>s</span><span>.</span><span>map</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span> <span>x</span> <span>*</span> <span>x</span><span>)</span> <span># always @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span>echo</span> <span>s</span><span>.</span><span>map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span> <span>*</span> <span>x</span><span>)</span> <span># from sugar module</span></code></pre>
</div>
</div>
<p>Here we use the <span>toSeq()</span> template to create our initial sequence with numbers <span>0</span> up to <span>9</span> — just to have not to type all the number in, we will explain templates soon.
Then we apply the <span>filter()</span> <span>proc</span> to that sequence. The <span>filter()</span> <span>proc</span> expects as second argument a function
with an argument of the seq’s base type returning a boolean value. We can pass the named
function <span>primeFilter()</span>, or we can just pass an anonymous <span>proc</span> explicitly.</p>
<p>In the last two lines of our example, we use the <span>map()</span> function to convert the data of our sequence.
<span>Map()</span> expects as second argument a <span>proc</span> with a parameter of the seq’s base type returning a result of the same type.
In the line before the last one, we specify an anonymous <span>proc</span> as parameter, while in the last
line we use the <span>⇒</span> operator from the <span>sugar</span> module to just specify the actual conversion.</p>
</div>
<div>
<h3 id="_compile_time_proc_execution">Compile time proc execution</h3>
<p>When a function is called only with constant arguments, then the compiler can execute it
already at compile time:</p>
<div>
<div>
<pre><code data-lang="nim"><span>func</span> <span>genSep</span><span>(</span><span>l</span><span>:</span> <span>int</span><span>):</span> <span>string</span> <span>=</span>
  <span>debugecho</span> <span>&#34;Generating separator string&#34;</span>
  <span>for</span> <span>i</span> <span>in</span> <span>1</span> <span>..</span> <span>l</span><span>:</span>
    <span>result</span><span>.</span><span>add</span><span>(</span><span>&#39;=&#39;</span><span>)</span>

<span>const</span> <span>Sep</span> <span>=</span> <span>genSep</span><span>(</span><span>80</span><span>)</span> <span># function is executed at compile time</span>

<span>echo</span> <span>Sep</span></code></pre>
</div>
</div>
<p>Here we used a function called <span>genSep()</span> to create a <span>string</span> constant at compile time.
When we compile above program, we get the message &#34;Generating separator string&#34;. As that
proc is not executed at program runtime, it is not included in the final executable program.
Here we had to use the <span>debugEcho()</span> <span>proc</span> instead of the ordinary <span>echo()</span>, because
<span>echo()</span> is not really a pure function, and the compiler would complain when we use
<span>echo()</span> in a pure function. <span>DebugEcho()</span> is not really pure as well, but the compiler ignores that
fact, which is OK for debugging purposes. We could even make <span>gesSep()</span> a plain <span>proc</span> and then use
<span>echo()</span>, the compiler would not complain. But it would complain, if for instance we would access
global variables from inside the <span>genSep()</span> <span>proc</span>.</p>
</div>
<div>
<h3 id="_inlining_procedures">Inlining Procedures</h3>
<p>Calling procedures and functions is always some overhead — <span>proc</span> parameters may have to put on the stack or loaded into CPU registers, some CPU or FPU registers may have to
be saved, the stack pointer and the program counter have to be updated and finally the instruction cache
has to be filled with new instructions.</p>
<p>So for tiny <span>procs</span> actually calling the <span>proc</span> may take more time than processing the actual code inside of the
proc. To avoid this additional effort, procedures and functionss can be inlined. The compiler may do this automatically for us, but we
can support it by applying the {.inline.} prama to tiny <span>procs</span>.
For inlined <span>procs</span> the code
is just inserted directly at the callsite. This may increase the total executable size, when the <span>proc</span> is used often.
So we should use the inline pragma with some care. Another option is to just compile the whole program
with link time optimization passing the option -d:lto to the compiler, that way the C backend
can automatically inline all <span>proc</span> code, even <span>procs</span> from imported modules. One more option is to use
templates instead of tiny <span>procs</span> — templates do always a plain code substitution, so templates may behave
very similar to inline <span>procs</span>. We will discuss templates later. The following example show how we can apply
the inline pragma to procedures and functionss:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>max</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>{.</span><span>inline</span><span>.}</span> <span>=</span>
  <span>if</span> <span>a</span> <span>&lt;</span> <span>b</span><span>:</span> <span>b</span> <span>else</span><span>:</span> <span>a</span></code></pre>
</div>
</div>
<p>Note that functions from shared libraries can not be in lined, so calling external C functions, directly or indirectly,
may be slower than expected.</p>
</div>
<div>
<h3 id="_recursion">Recursion</h3>
<p>Procedures and functions can call them self in a repetive manner, which is called recursion.
Obviously there must exist some condition that finally stops the recursion, without the
proc would call itself again and again, for each call some data would have to be stored on the stack, at least the
proc return address, so finally the stack would overflow and the program would crash.
Generally recursion should be used only for cases where it really helps to simplify the algorithm.
In part V of the book, in the section about various sorting algorithm, we will discover some useful
applications for recursion. In most cases a plain iterative algorithm is faster than a recursive one,
because all the overhead with many <span>proc</span> calls is avoided for plain iterative solutions. But sometimes
recursive algorithm are easier to understand, or programming an iterative solution may be really complicated.</p>
<p>As one of the most simple algorithm we will present here the recursive fac() function:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>fac</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>if</span> <span>i</span> <span>&lt;</span> <span>2</span><span>:</span>
    <span>1</span>
  <span>else</span><span>:</span>
    <span>i</span> <span>*</span> <span>fac</span><span>(</span><span>i</span> <span>-</span> <span>1</span><span>)</span></code></pre>
</div>
</div>
<p>That function should terminate, as we only call itself again with a decreased argument.
Of course, using recursion here is not really smart, it should be easy for you to convert
the <span>proc</span> into an iterative solution without recursion. Note that recursive <span>procs</span> can never be inlined!</p>
</div>
<div>
<h3 id="_converters">Converters</h3>
<p>Nim’s converters are a special variant of functions that are called automatically by
the compiler when argument types do not match.</p>
<div>
<div>
<pre><code data-lang="nim"><span>converter</span> <span>myIntToBool</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span>
  <span>if</span> <span>i</span> <span>==</span> <span>0</span><span>:</span>
    <span>false</span>
  <span>else</span><span>:</span>
    <span>true</span>

<span>proc </span><span>processBool</span><span>(</span><span>b</span><span>:</span> <span>bool</span><span>)</span> <span>=</span>
  <span>if</span> <span>b</span><span>:</span>
    <span>echo</span> <span>&#34;true&#34;</span>
  <span>else</span><span>:</span>
    <span>echo</span> <span>&#34;false&#34;</span>

<span>var</span> <span>i</span> <span>=</span> <span>7</span>
<span>processBool</span><span>(</span><span>i</span><span>)</span>
<span>if</span> <span>i</span><span>:</span>
  <span>echo</span> <span>&#34;true&#34;</span>
<span>else</span><span>:</span>
  <span>echo</span> <span>&#34;false&#34;</span></code></pre>
</div>
</div>
<p>With above converter we can pass an integer to a <span>proc</span> that expects a boolean parameter,
and we can even use an integer as a logical expression in an <span>if</span> condition in the same
way as it is done in C language. Converters do work only in a direct way, that is
automatic chaining is not supported: If we have one converter from character to integer
and one from <span>int</span> to boolean, that does not mean that we can pass a character to a
proc that expects a boolean. We would have to declare one more converter that
directly converts character to boolean.</p>
<p>Whenever we do consider using converters we should think twice — converters may be
confusing, may have some strange effects and may increase compile time.</p>
<p>Maybe you wondered why we wrote above converter in such a verbose way? Well it was
done intentionally, but you are right of course, we can write it just as</p>
<div>
<div>
<pre><code data-lang="nim"><span>converter</span> <span>myIntToBool</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span>
  <span>i</span> <span>!=</span> <span>0</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div>
<h2 id="_object_orientated_programming_and_inheritance">Object-Orientated Programming and Inheritance</h2>
<div>
<p>Object-Orientated Programming and Inheritance became very popular in the early
nineties of the last century. Java is a prominent representative of that programming
paradigm, but most languages created in the nineties of the last century support it,
like C++, Ruby and Python.</p>
<p>The idea of OOP is that objects and procedures working on that objects are grouped to
classes, and that classes can be extended with additional data fields and with
additional procedures. In OOP procedures and function are often called methods and
data fields are called members. Sometimes the members are completely hidden and are
accessed only by so called getter and setter methods. That is called encapsulation.
Encapsulation allows hiding implementation details, so that that details may change
when necessary, without that the change of internal details become visible to users
of that class, so that the users can use the class without noticing the change.
Getters and setters also help hiding internal details and they ensure that the class
is always in a consistent and valid state.</p>
<p>An important property of OOP is dynamic dispatch: When we create various sub-classes
of a common parent class, and we have defined methods for all the sub-classes, then
we can have collections of instances of different sub-classes, and the compiler can
automatically ensure that always the matching method for each instance is called.</p>
<p>A classical example is a drawing program, where we have different geometrical shapes
like rectangle, circle and many more. All the geometrical objects are stored is some
form of list, and when we want to draw all of them on the screen then we have to call
only an unspecific draw() method, and the compiler ensures that for each shape the
matching draw method is called. In Nim that may look like</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Shape</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>

  <span>Rectangle</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Shape</span>
    <span>x</span><span>,</span> <span>y</span><span>,</span> <span>width</span><span>,</span> <span>height</span><span>:</span> <span>float</span>

  <span>Circle</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Shape</span>
    <span>x</span><span>,</span> <span>y</span><span>,</span> <span>radius</span><span>:</span> <span>float</span>

  <span>LineSegment</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Shape</span>
    <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>

<span>method</span> <span>draw</span><span>(</span><span>s</span><span>:</span> <span>Shape</span><span>)</span> <span>{.</span><span>base</span><span>.}</span> <span>=</span>
  <span># override this base method</span>
  <span>quit</span> <span>&#34;to override!&#34;</span>

<span>method</span> <span>draw</span><span>(</span><span>r</span><span>:</span> <span>Rectangle</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;drawing a rectangle&#34;</span>

<span>method</span> <span>draw</span><span>(</span><span>r</span><span>:</span> <span>Circle</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;drawing a circle&#34;</span>

<span>method</span> <span>draw</span><span>(</span><span>r</span><span>:</span> <span>LineSegment</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;drawing a line segment&#34;</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>l</span><span>:</span> <span>seq</span><span>[</span><span>Shape</span><span>]</span>
  <span>l</span><span>.</span><span>add</span><span>(</span><span>Rectangle</span><span>(</span><span>x</span><span>:</span> <span>0</span><span>,</span> <span>y</span><span>:</span> <span>0</span><span>,</span> <span>width</span><span>:</span> <span>100</span><span>,</span> <span>height</span><span>:</span> <span>50</span><span>))</span>
  <span>l</span><span>.</span><span>add</span><span>(</span><span>Circle</span><span>(</span><span>x</span><span>:</span> <span>60</span><span>,</span> <span>y</span><span>:</span> <span>20</span><span>,</span> <span>radius</span><span>:</span> <span>50</span><span>))</span>
  <span>l</span><span>.</span><span>add</span><span>(</span><span>LineSegment</span><span>(</span><span>x1</span><span>:</span> <span>20</span><span>,</span> <span>y1</span><span>:</span> <span>20</span><span>,</span> <span>x2</span><span>:</span> <span>50</span><span>,</span> <span>y2</span><span>:</span> <span>50</span><span>))</span>

  <span>for</span> <span>el</span> <span>in</span> <span>l</span><span>:</span>
    <span>draw</span><span>(</span><span>el</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The output of that program is</p>
<div>
<div>
<pre>drawing a rectangle
drawing a circle
drawing a line segment</pre>
</div>
</div>
<p>So we can have a sequence of the base type, add various sub-types and then iterate
over the list to draw all the various sub-types. Of course in the same way we could
do many more task like moving, rotating or storing all the objects in one call. The
compiler does the right dynamic dispatching for us, we have just to provide all
necessary methods. The need of the base method seems to be a bit strange, some other
OOP languages do not need that. The base method is marked by a {.base.} pragma, we
will discuss the purpose of pragmas later. In the example we have used only one level
of sub-classing, but of course we can use many levels, for example we can again
subclass the Circle by a FilledCircle with a color field.</p>
<p>The OOP coding style can be very convenient for some tasks, one important use case
could be graphical user interfaces where the graphical elements like labels, buttons,
frames built in natural way a hierarchical structure. Another typical use case are
drawing applications with code similar to our basic example.</p>
<p>Note that the OOP style only works with ref objects, but not with value objects. The
obvious reason is that we can have collections of different sub-types stored in
arrays or sequences only for ref objects, as in arrays and sequences all element types
have to have equal size. For references that is the case, as references are basically
pointers. But different value types would have different size. Linked lists would be
no better solution, as again we can not built lists with value objects.</p>
<p>For maximum performance OOP code with ref objects is generally not optimal, as the
dispatching itself needs some time, and as the ref objects are not contained in a
single block of memory, but are distributed in the whole RAM, which is not cache
friendly.</p>
</div>
</div>
<div>
<h2 id="_other_builtin_data_types">Other Builtin Data Types</h2>
<div>
<div>
<h3 id="_tuple_types">Tuple Types</h3>
<p>Tuples are heterogeneous container types similar to
the struct type in C. As Nim’s <span>object</span> type creates no overhead
as long as we use no inheritance and so also directly corresponds to the C
struct type, tuples are very similar to Nim’s objects.
The biggest advantage of tuples is, that we can create anonymous
tuples, and that Nim supports the automatic unpacking of <span>tuple</span> variables
into ordinary unstructured variables.</p>
<p>Compared to objects, tuples do support no inheritance at all, all the <span>tuple</span> fields
are always visible, and different <span>tuple</span> types are regarded as identical, when
all the field names and field data types match. Remember that two different object
types are always distinct in Nim, even when the actual type definition looks identical.</p>
<p>We can define tuple types in the same way as we define objects, or we can
use the <span>tuple[]</span> constructor. Additional we can define anonymous tuples just
by enclosing its field types in round brackets. The fields of <span>tuple</span> types
can be accessed by field names as we do it for objects, or we can access
the fields with constant indices starting at zero.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Move</span> <span>=</span> <span>tuple</span> <span># the object definition syntax</span>
    <span>from</span><span>:</span> <span>int</span>
    <span>to</span><span>:</span> <span>int</span>
    <span>check</span><span>:</span> <span>bool</span>

<span>type</span> <span>Move</span> <span>=</span> <span>tuple</span><span>[</span><span>from</span><span>:</span> <span>int</span><span>,</span> <span>to</span><span>:</span> <span>int</span><span>,</span> <span>check</span><span>:</span> <span>bool</span><span>]</span> <span># equivalent tuple constructor syntax</span>

<span>proc </span><span>findBestNextMove</span><span>():</span> <span>(</span><span>dest</span><span>:</span> <span>int</span><span>;</span> <span>check</span><span>:</span> <span>bool</span><span>)</span> <span>=</span>
  <span>...</span>

<span>let</span> <span>(</span><span>dst</span><span>,</span> <span>check</span><span>)</span> <span>=</span> <span>findBestNextMove</span><span>()</span></code></pre>
</div>
</div>
<p>In the code example above we show two equivalent ways to define a tuple type,
but actually we
do not use that type at all but return an anonymous <span>tuple</span> from our <span>proc</span>, that is a
pair of an <span>int</span> and a <span>bool</span>.</p>
<p>Using automatic <span>tuple</span> unpacking
and type inference our <span>dst</span> and <span>check</span> variables gets the data types <span>int</span> and <span>bool</span>.</p>
<p>Tuples are also useful when a function has to return a value and also an error state,
or if it may not be able to return something at all in a special case. For reference types
we could return <span>nil</span> then, but for results of value type like <span>int</span> or <span>float</span> we may not have a well
defined error indicating constant, so we can return a <span>tuple</span> with an additional <span>bool</span> indicating success or error.
But of course we could use exceptions instead, or we could use Nim’s option type instead. We
will learn more about that later.</p>
<p>Here are two examples which uses a <span>tuple</span> as a <span>proc</span> parameter:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>p1</span><span>(</span><span>x</span><span>:</span> <span>tuple</span><span>[</span><span>i</span><span>:</span> <span>int</span><span>,</span> <span>j</span><span>:</span> <span>int</span><span>]</span><span>):</span> <span>int</span> <span>=</span>
  <span>x</span><span>.</span><span>i</span> <span>+</span> <span>x</span><span>.</span><span>j</span>

<span>echo</span> <span>p1</span><span>((</span><span>7</span><span>,</span> <span>7</span><span>))</span>

<span>proc </span><span>p2</span><span>(</span><span>x</span><span>:</span> <span>(</span><span>int</span><span>,</span> <span>int</span><span>)):</span> <span>int</span> <span>=</span>
  <span>x</span><span>[</span><span>0</span><span>]</span> <span>+</span> <span>x</span><span>[</span><span>1</span><span>]</span>

<span>echo</span> <span>p2</span><span>((</span><span>7</span><span>,</span> <span>7</span><span>))</span></code></pre>
</div>
</div>
<p>Proc <span>p1()</span> creates a tuple type using the <span>tuple</span> constructor syntax with named fields, so
in the <span>proc</span> body we can access the fields by its names, while <span>proc</span> <span>p2()</span> uses an
anonymous tuple, and so has to access the fields by constant indices. Both <span>procs</span> are called with
an anonymous <span>tuple</span> parameter.</p>
</div>
<div>
<h3 id="_object_variants">Object Variants</h3>
<p>Nim’s object variants, sometimes also called sum types or abstract data types (ADT),
are an advanced and type save variant of the union type known from C. The basic idea
is that we may use value types that may store similar, but not identical data.
Untyped languages like Ruby or Python allow that of course, and we can do it in Nim
with ref types and inheritance too, as we showed in a previous section with our <span>Shape</span>
base type and various geometric shapes. We could store that ref types in arrays or
sequences or linked list and use dynamic dispatch for processing the various
sub-types. That is convenient but gives not maximum performance due to dynamic
dispatch at runtime and due to bad cache use. So we may like to have a value type
with different content, so that we can store all the value types in a <span>seq</span> and all
entities reside in a compact block of memory for good cache use.</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>ShapeKind</span> <span>=</span> <span>enum</span>
    <span>line</span><span>,</span> <span>rect</span><span>,</span> <span>circ</span>

  <span>Shape</span> <span>=</span> <span>object</span>
    <span>visible</span><span>:</span> <span>bool</span>
    <span>case</span> <span>kind</span><span>:</span> <span>ShapeKind</span>
    <span>of</span> <span>line</span><span>:</span>
      <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>
    <span>of</span> <span>rect</span><span>:</span>
      <span>x</span><span>,</span> <span>y</span><span>,</span> <span>width</span><span>,</span> <span>height</span><span>:</span> <span>float</span>
    <span>of</span> <span>circ</span><span>:</span>
      <span>x0</span><span>,</span> <span>y0</span><span>,</span> <span>radius</span><span>:</span> <span>float</span>

<span>proc </span><span>draw</span><span>(</span><span>el</span><span>:</span> <span>Shape</span><span>)</span> <span>=</span>
  <span>if</span> <span>el</span><span>.</span><span>kind</span> <span>==</span> <span>line</span><span>:</span>
    <span>echo</span> <span>&#34;process line segment&#34;</span>
  <span>elif</span> <span>el</span><span>.</span><span>kind</span> <span>==</span> <span>rect</span><span>:</span>
    <span>echo</span> <span>&#34;process rectangle&#34;</span>
  <span>elif</span> <span>el</span><span>.</span><span>kind</span> <span>==</span> <span>circ</span><span>:</span>
    <span>echo</span> <span>&#34;process circle&#34;</span>
  <span>else</span><span>:</span>
    <span>echo</span> <span>&#34;unknown shape&#34;</span>

<span>var</span>
  <span>s</span><span>:</span> <span>seq</span><span>[</span><span>Shape</span><span>]</span>
<span>s</span><span>.</span><span>add</span><span>(</span><span>Shape</span><span>(</span><span>kind</span><span>:</span> <span>circ</span><span>,</span> <span>x0</span><span>:</span> <span>0</span><span>,</span> <span>y0</span><span>:</span><span>0</span><span>,</span> <span>radius</span><span>:</span> <span>100</span><span>,</span> <span>visible</span><span>:</span> <span>true</span><span>))</span>
<span>for</span> <span>el</span> <span>in</span> <span>s</span><span>:</span>
  <span>draw</span><span>(</span><span>el</span><span>)</span></code></pre>
</div>
</div>
<p>Objects variants can have common fields like the boolean state visible above, but the
other fields are not allowed to use the same names, so we had to use <span>x0</span> and <span>y0</span> for
the names of the center coordinates in the circle variant.</p>
<p>As you can see we can store all the different object variants as value objects in a
sequence and iterate over it. Note that object variants may waste some storage, as
all variants are silently enlarged to have the exact same size, so that all variant
types can be stored in an array or sequences and can be passed as <span>proc</span> parameters in
the same way to the same <span>proc</span>.</p>
</div>
</div>
</div>
<div>
<h2 id="_iterators">Iterators</h2>
<div>
<p>In section <a href="#_for_loops_and_iterators">For Loops and Iterators</a> we used a <span>for</span> loop to iterate over the
individual characters of a <span>string</span>. <span>For</span> loops are useful for various
iteration purposes, e.g. to iterate over container types like <span>strings</span>,
<span>arrays</span>, and sequences, or over a numeric <span>range</span>, and other countable
entities. We could do the same with a <span>while</span> loop, but using a <span>for</span>
loop is often more convenient and less error prone — we do not have to care for
increasing a loop variable and for the stop condition.</p>
<p>Nim’s <span>for</span> loops are built on <span>iterators</span>, that is whenever a
<span>for</span> loop is executed an <span>iterator</span> is used under the hood.  Some
<span>iterators</span> are used explicitly in <span>for</span> loops, e.g. <span>countup()</span>
of Nim’s standard library, others like <span>items()</span> or <span>pairs()</span> are
executed implicitly when no explicit <span>iterator</span> name is specified.</p>
<p>The creation and use of <span>iterators</span> is very easy in Nim. Before we will discuss
all the details and some restrictions of <span>iterators</span>, and the important
differences between inline and closure <span>iterators</span>, we will give a small
example:</p>
<p>We have already used some of Nim’s standard <span>iterators</span> to iterate over the
characters of a <span>string</span> or the content of a sequence.</p>
<p>In an earlier section of the book we declared a procedure that extracts all the
decimal digits from a <span>string</span>. We can do the same with an <span>iterator</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>iterator</span> <span>decDigits</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>):</span> <span>char</span> <span>=</span>
  <span>var</span> <span>pos</span> <span>=</span> <span>0</span>
  <span>while</span> <span>pos</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span><span>:</span>
    <span>if</span> <span>s</span><span>[</span><span>pos</span><span>]</span> <span>in</span> <span>{</span><span>&#39;0&#39;</span> <span>..</span> <span>&#39;9&#39;</span><span>}:</span>
      <span>yield</span><span>(</span><span>s</span><span>[</span><span>pos</span><span>]</span><span>)</span>
    <span>inc</span><span>(</span><span>pos</span><span>)</span>

<span>for</span> <span>d</span> <span>in</span> <span>decDigits</span><span>(</span><span>&#34;df4j6dr78sd31tz&#34;</span><span>):</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>d</span><span>)</span>
<span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span></code></pre>
</div>
</div>
<p>The definition of an <span>iterator</span> is very similar to the definition of a
<span>proc</span> or function, but while a function returns a result only once to the
caller, an iterator uses the <span>yield</span> statement to give data back to the call
site multiple times, instead of returning just once.</p>
<p>Whenever a <span>yield</span> statement is reached in the body of the <span>iterator</span>,
the yielded data is bound to the <span>for</span> loop variable(s), the body of the for
loop is executed, and at the end of the <span>for</span> loop body control returns to the
iterator, that is execution continues direct after the <span>yield</span> statement.  The
<span>iterator’s</span> local variables and execution state are automatically saved
between calls.  The iteration process continues until the end of the body of the
iterator declaration is reached and the iterator terminates.</p>
<p><span>Iterators</span> are used in <span>for</span> loops to iterate over containers,
<span>ranges</span> or other data.  After the <span>for</span> keyword we specify one or more
arbitrary variable names, which we then can use in the body of the <span>for</span> loop
to access the yielded value(s).  The data type of this iteration variable(s) is
inferred from the iterators return type, and its scope is limited to the body of the
<span>for</span> loop.</p>
<p>Nim’s standard library defines for container types like <span>strings</span>,
<span>array</span> and sequences <span>iterators</span> named <span>items()</span> and
<span>pairs()</span> — <span>items()</span> is the default name when a <span>for</span> loop with
only one variable is used, and <span>pairs()</span> is the default name when two
variables are used, e.g. the index position and the character when iterating over a
<span>string</span>.</p>
<p>In Nim’s standard library you may find <span>items()</span> and <span>pairs()</span>
<span>iterators</span> like these two:</p>
<div>
<div>
<pre><code data-lang="nim"><span>iterator</span> <span>items</span><span>(</span><span>a</span><span>:</span> <span>string</span><span>):</span> <span>char</span> <span>=</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>a</span><span>):</span>
    <span>yield</span> <span>a</span><span>[</span><span>i</span><span>]</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>

<span>iterator</span> <span>pairs</span><span>(</span><span>a</span><span>:</span> <span>string</span><span>):</span> <span>tuple</span><span>[</span><span>key</span><span>:</span> <span>int</span><span>,</span> <span>val</span><span>:</span> <span>char</span><span>]</span> <span>=</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>a</span><span>):</span>
    <span>yield</span> <span>(</span><span>i</span><span>,</span> <span>a</span><span>[</span><span>i</span><span>]</span><span>)</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>

<span>var</span> <span>s</span> <span>=</span> <span>&#34;Nim is nice.&#34;</span>
<span>for</span> <span>c</span> <span>in</span> <span>items</span><span>(</span><span>s</span><span>):</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>c</span><span>,</span> <span>&#39;*&#39;</span><span>)</span>
<span>echo</span> <span>&#34;&#34;</span>
<span>for</span> <span>i</span><span>,</span> <span>c</span> <span>in</span> <span>pairs</span><span>(</span><span>s</span><span>):</span>
  <span>echo</span> <span>i</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>c</span></code></pre>
</div>
</div>
<p>In the example above we specified the <span>iterator</span> names <span>items()</span> and
<span>pairs()</span> explicitly in the <span>for</span> statement, but as these names are the
defaults, we can just write <span>for c in s:</span> and <span>for i, c in s:</span>.</p>
<p>The two <span>iterators</span> in the example code from above use as argument a value type
and return the single characters as value type. This way we can not modify the
<span>string</span> content. When we intent to modify the content of a container by use
of an <span>iterator</span>, we have to pass the container as <span>var</span> parameter, and
return the elements as <span>var</span> also. By convention for iterating over mutable
containers the iterator names <span>mitems()</span> and <span>mpairs()</span> are used, where
the leading <span>m</span> stands for mutable.  We have to specify these names explicitly:</p>
<div>
<div>
<pre><code data-lang="nim"><span>iterator</span> <span>mitems</span><span>(</span><span>a</span><span>:</span> <span>var</span> <span>string</span><span>):</span> <span>var</span> <span>char</span> <span>=</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>a</span><span>):</span>
    <span>yield</span> <span>a</span><span>[</span><span>i</span><span>]</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>

<span>iterator</span> <span>mpairs</span><span>(</span><span>a</span><span>:</span> <span>var</span> <span>string</span><span>):</span> <span>tuple</span><span>[</span><span>key</span><span>:</span> <span>int</span><span>,</span> <span>val</span><span>:</span> <span>var</span> <span>char</span><span>]</span> <span>=</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>a</span><span>):</span>
    <span>yield</span> <span>(</span><span>i</span><span>,</span> <span>a</span><span>[</span><span>i</span><span>]</span><span>)</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>

<span>from</span> <span>strutils</span> <span>import</span> <span>toLowerAscii</span>
<span>var</span> <span>s</span> <span>=</span> <span>&#34;NIM&#34;</span>
<span>for</span> <span>i</span><span>,</span> <span>c</span> <span>in</span> <span>mpairs</span><span>(</span><span>s</span><span>):</span>
  <span>if</span> <span>i</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>c</span> <span>=</span> <span>toLowerAscii</span><span>(</span><span>c</span><span>)</span>
<span>echo</span> <span>s</span> <span># Nim</span></code></pre>
</div>
</div>
<p>Whenever we iterate over a container, we should not delete, insert or append elements
to the container, as that may confuse the loop inside of the <span>iterator</span> body.
<span>Iterators</span> of Nim’s standard library check the length of the container and
generate an exception when the length changes during the iteration.</p>
<p>Nim differentiate between inline and closure <span>iterators</span>. When a <span>for</span>
loop uses an inline <span>iterator</span>, then the actual <span>iterator</span> loop is
inlined in the <span>for</span> loop body in a way that for each <span>yield</span> statement
in the <span>iterator</span> body the body of the <span>for</span> loop is executed.  Actually
the <span>for c in items(s): stdout.write(c, &#39;*&#39;)</span> in our example from above is
rewritten by the compiler into a code block like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span> <span>=</span> <span>0</span>
<span>while</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>a</span><span>):</span>
  <span>var</span> <span>c</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span>
  <span>echo</span> <span>c</span><span>,</span> <span>&#39;*&#39;</span>
  <span>inc</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>That is, the body of the <span>for</span> loop is inlined into the loop of the
<span>iterator</span>.</p>
<p>This results in very fast code with no overhead, but similar to the use of
<span>templates</span>, this increases the total code size.  Actually, when the
<span>iterator</span> should use multiple <span>yield</span> statements, then the code of the
body of the <span>for</span> loop is inserted for each <span>yield</span> statement.</p>
<p>Inline <span>iterators</span> are currently the default <span>iterator</span> type, so the
<span>iterators</span> of the examples above are all inline <span>iterators</span>.</p>
<p>Closure <span>iterators</span> behave more like procedures, the <span>iterator</span> is
actually invoked, which costs some performance. We can use all the <span>iterators</span>
of the examples from above as closure <span>iterators</span> by applying the closure
pragma as in <span>iterator items(a: string): char {.closure.} =</span>.</p>
<p>Closure <span>iterators</span> behaves like <span>objects</span>, we can assign instances of
inline <span>iterators</span> to variables, and then call the instances explicitly:</p>
<div>
<div>
<pre><code data-lang="nim"><span>iterator</span> <span>myCounter</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>{.</span><span>closure</span><span>.}</span> <span>=</span>
  <span>var</span> <span>i</span> <span>=</span> <span>a</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>b</span><span>:</span>
    <span>yield</span> <span>i</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>

<span>for</span> <span>x</span> <span>in</span> <span>myCounter</span><span>(</span><span>3</span><span>,</span> <span>5</span><span>):</span> <span># ordinary use of the operator</span>
  <span>echo</span> <span>x</span>

<span>echo</span> <span>&#34;---&#34;</span>
<span>var</span> <span>counter</span> <span>=</span> <span>myCounter</span> <span># use of an iterator instance</span>
<span>while</span> <span>true</span><span>:</span>
  <span>echo</span> <span>counter</span><span>(</span><span>5</span><span>,</span> <span>7</span><span>)</span>
  <span>if</span> <span>counter</span><span>.</span><span>finished</span><span>:</span>
    <span>break</span></code></pre>
</div>
</div>
<p>which gives us this output:</p>

<p>Here we have used the <span>finished()</span> function to check if the <span>iterator</span>
is done.</p>
<p>Actually <span>finished()</span> returns <span>true</span> only, when the <span>iterator</span> has
already failed to <span>yield</span> a valid value, and not already when the last valid
value was yielded. That is, why we get in the example above as last value the invalid
value zero.</p>
<p>We can avoid this behaviour, when we rewrite the loop as</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>counter2</span> <span>=</span> <span>myCounter</span>
<span>while</span> <span>true</span><span>:</span>
  <span>let</span> <span>v</span> <span>=</span> <span>counter2</span><span>(</span><span>5</span><span>,</span> <span>7</span><span>)</span>
  <span>if</span> <span>counter2</span><span>.</span><span>finished</span><span>:</span>
    <span>break</span> <span># v is invalid</span>
  <span>echo</span> <span>v</span></code></pre>
</div>
</div>
<p>Closure <span>iterators</span> are resumable functions and so one has to provide the
arguments to every call. To get around this limitation one can capture parameters of
an outer factory
proc:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>mycount</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>):</span> <span>iterator</span> <span>():</span> <span>int</span> <span>=</span>
  <span>result</span> <span>=</span> <span>iterator</span> <span>():</span> <span>int</span> <span>=</span>
    <span>var</span> <span>i</span> <span>=</span> <span>a</span>
    <span>while</span> <span>i</span> <span>&lt;</span> <span>b</span><span>:</span>
      <span>yield</span> <span>i</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span>

<span>var</span> <span>c1</span> <span>=</span> <span>mycount</span><span>(</span><span>5</span><span>,</span> <span>7</span><span>)</span>
<span>for</span> <span>i</span> <span>in</span> <span>c1</span><span>():</span>
  <span>echo</span> <span>i</span>

<span>echo</span> <span>&#34;---&#34;</span>

<span>var</span> <span>c2</span> <span>=</span> <span>mycount</span><span>(</span><span>2</span><span>,</span> <span>5</span><span>)</span>
<span>while</span> <span>true</span><span>:</span>
  <span>let</span> <span>v</span> <span>=</span> <span>c2</span><span>()</span>
  <span>if</span> <span>c2</span><span>.</span><span>finished</span><span>:</span>
    <span>break</span> <span># v is invalid</span>
  <span>echo</span> <span>v</span></code></pre>
</div>
</div>
<p>In this example from the compiler manual the <span>proc</span> <span>mycount()</span>
captures the bound for the counter.  When we compile and run the code above we get:</p>

<p>At the end of this section we will list some properties of <span>iterators</span>:
<span>Iterators</span> have their own name space, so we can freely use for <span>procs</span>
and <span>iterators</span> the same names. <span>Iterators</span> have no predefined
<span>result</span> variable, and do not support recursion.  Inline <span>iterators</span> can
be used only inside of <span>for</span> loops, and can not be forward declared, because
the compiler must be able to inline an <span>iterator</span>.  (This restriction will be
gone in a future version of the compiler.) And <span>iterators</span> do not support
recursion.  Closure iterator are not supported by the JS backend, and cannot be
executed at compile time.  Inline iterators are second class citizens; They can be
passed as parameters only to other inlining code facilities like templates, macros,
and other inline iterators. In contrast to that, a closure iterator can be passed
around more freely.</p>
</div>
</div>
<div>
<h2 id="_templates">Templates</h2>
<div>

<p>Nim <span>templates</span> are a simple, parameterized code substitution mechanism,
and are used in a similar way
as procedures.
The syntax to <span>invoke</span> a <span>template</span> is the same as calling a procedure.
But while procedures built a single block of code that is then
called multiple times, <span>templates</span> work more like C macros as a (textual) code substitution. Wherever
we invoke a <span>template</span> the <span>template</span> source code is inserted at the call site.
In this way Nim <span>templates</span>
have indeed some similarity to C macros. But while C macros are executed by the C pre-processor and
can do only plain source text substitutions, Nim <span>templates</span>
operates on Nim’s abstract syntax trees,
are processed
in the semantic pass of the compiler,
integrate well with the rest of the language, and share none of C’s pre-processor macros flaws.</p>
<p>In some way Nim <span>templates</span> are a simplified application  of Nim’s powerful <span>macro</span> and meta-programming
system which we will discuss in detail in part VI of the book.</p>
<p>In C we could use the &#34;#define&#34; pre-processur directive to define two simple C macros.</p>
<div>
<div>
<pre><code data-lang="c"><span>#define PI 3.1416
#define SQR(x) (x)*(x)</span></code></pre>
</div>
</div>
<p>The C pre-processor would then replace the symbol <span>PI</span> in the C source code with the <span>float</span> literal <span>3.1416</span>.
And as the C pre-processor can recognize some simple form of parameters, it would
replace <span>SQR(a + b)</span> with <span>(a+b)*(a+b)</span>.</p>
<p>In Nim we would define a <span>const</span> for <span>PI</span> and use a generic <span>proc</span> or a <span>template</span> for <span>SQR()</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span> <span>PI</span> <span>=</span> <span>3.1416</span>
<span>proc </span><span>sqr1</span><span>[</span><span>T</span><span>]</span><span>(</span><span>x</span><span>:</span> <span>T</span><span>):</span> <span>T</span> <span>=</span> <span>x</span> <span>*</span> <span>x</span>
<span>template</span> <span>sqr2</span><span>(</span><span>x</span><span>:</span> <span>typed</span><span>):</span> <span>typed</span> <span>=</span> <span>x</span> <span>*</span> <span>x</span></code></pre>
</div>
</div>
<p>Here the <span>sqr2()</span> <span>template</span> uses the special <span>typed</span> parameter, which specifies
that the parameter has a well defined type in the <span>template</span> body, but that
arbitrary data types are accepted. So <span>sqr1()</span> and <span>sqr2()</span> would work for all
numeric types and also for other data types for which we have
defined a <span><strong></strong></span><strong> operation. When there is no <span></span></strong> operator defined for the passed  data
type, the compiler will give an error message.</p>
<p>Nim <span>templates</span> accept like <span>procs</span> all of Nim’s ordinary data types, and additional
the abstract meta-types <span>typed</span> and <span>untyped</span>.
The abstract data types <span>typed</span> and <span>untyped</span> can be used only for the types of
<span>template</span> and <span>macro</span> parameters, but not for parameters of procedures, functions,
iterators, or to define variables.</p>
<p>We will explain the differences between <span>typed</span>
and <span>untyped</span> in detail later in this section — the short version of the explanation is, that
<span>typed</span> <span>template</span> parameters must have a well defined data type when we pass it to the <span>template</span>,
while <span>untyped</span> parameters can be passed as still undefined symbolic name also.</p>
<p>So we can in principle replace each procedure or function definition with a <span>template</span>.
The important difference between procedures and <span>templates</span> is, that ordinary
<span>procs</span> are instantiated only once, generic <span>procs</span> may be instantiated for each data type with which
they are used, but <span>templates</span> are instantiated for each invocation of the <span>template</span>.
The compiler creates for each defined <span>proc</span> some machine code, which is executed whenever
the <span>proc</span> is called. But for <span>templates</span> the compiler does some code substitution — the source
code of the <span>template</span> is inserted where the <span>template</span> is invoked. This avoids the need for an
actual jump to a different machine code block when a procedure is called, but increases the
total code size for each use of a <span>template</span>. So we would generally avoid <span>templates</span>
that contain a lot code and are used often.</p>
<p>For each ordinary <span>proc</span> one block of machine code instructions is generated, and
when the <span>proc</span> is called, program executions has to jump to this block, and back
when the <span>proc</span> execution is done. This jumping involves some minimal overhead, which
is noticeable for tiny <span>procs</span> called often. To avoid this overhead we may use a <span>template</span> instead,
or we may use inlined <span>procs</span>, which we discussed in the previous section. <span>Proc</span>
inlining can be done by the compiler automatically when the <span>proc</span> is defined in
the source code file where it is used, or when we mark the <span>proc</span> with the <span>inline</span> pragma.
Additional, when we compile our program with <span>-d:lto</span>, the compiler can inline all procedures and functions.
Generally the compiler should know well when inlining makes sense, so in most
cases it makes not much sense to just use <span>templates</span> instead of (small) procs
just to avoid the <span>proc</span> call overhead.</p>
<p><span>Templates</span> can be used as some form of alias. Sometimes we have nested data structures,
and would like to have a shorter alias for the access of fields:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Point</span> <span>=</span> <span>object</span>
    <span>x</span><span>,</span> <span>y</span><span>:</span> <span>int</span>

  <span>Circle</span> <span>=</span> <span>object</span>
    <span>center</span><span>:</span> <span>Point</span>

<span>template</span> <span>x</span><span>(</span><span>c</span><span>:</span> <span>Circle</span><span>):</span> <span>int</span> <span>=</span> <span>c</span><span>.</span><span>center</span><span>.</span><span>x</span>

<span>template</span> <span>`</span><span>x</span><span>=</span><span>`(</span><span>c</span><span>:</span> <span>var</span> <span>Circle</span><span>;</span> <span>v</span><span>:</span> <span>int</span><span>)</span> <span>=</span> <span>c</span><span>.</span><span>center</span><span>.</span><span>x</span> <span>=</span> <span>v</span>

<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>Circle</span>

<span>a</span><span>.</span><span>center</span><span>.</span><span>x</span> <span>=</span> <span>7</span>
<span>echo</span> <span>a</span><span>.</span><span>center</span><span>.</span><span>x</span>

<span>b</span><span>.</span><span>x</span> <span>=</span> <span>7</span>
<span>echo</span> <span>b</span><span>.</span><span>x</span></code></pre>
</div>
</div>
<p>The two <span>templates</span> simplify the access of field <span>x</span>, and as <span>templates</span> are pure
code substitution, the use of them costs no performance. Since version 1.6
Nim has also the <span>with</span> <span>macro</span>, which can be also used to save some typing.
Note that in the second <span>template</span> we have called the second <span>int</span> parameter <span>v</span> — calling them <span>x</span> would give some trouble:</p>
<div>
<div>
<pre>Error: in expression &#39;b.center.7&#39;: identifier expected, but found &#39;7&#39;</pre>
</div>
</div>
<p>Nim’s <span>system</span> module uses <span>templates</span> to define some operators like</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>`</span><span>!=</span><span>`</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>not</span> <span>(</span><span>a</span> <span>==</span> <span>b</span><span>)</span></code></pre>
</div>
</div>
<p>This way <span>!=</span> is always the opposite of <span>==</span>, so when we define the <span>==</span> operator
for our own custom data types, <span>!=</span> is available for free.</p>
<p>In some situations using <span>templates</span> instead of <span>procs</span> can avoid some overhead.
Let us investigate a <span>log()</span> <span>template</span>, that can print messages to <span>stdout</span>
when a global boolean constant is set to <span>true</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span>
  <span>debug</span> <span>=</span> <span>true</span>

<span>template</span> <span>log</span><span>(</span><span>msg</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>if</span> <span>debug</span><span>:</span> <span>stdout</span><span>.</span><span>writeLine</span><span>(</span><span>msg</span><span>)</span>

<span>var</span>
  <span>x</span> <span>=</span> <span>4</span>
<span>log</span><span>(</span><span>&#34;x has the value: &#34;</span> <span>&amp;</span> <span>$</span><span>x</span><span>)</span></code></pre>
</div>
</div>
<p>Here <span>log()</span> is called with the constructed argument <span>(&#34;x has the value: &#34; &amp; $x)</span>
which implies a <span>string</span> concatenation operation at runtime. As we use a <span>template</span>, the
invocation of <span>log(&#34;x has the value: &#34; &amp; $x)</span> is actually replaced by the compiler with code like</p>
<div>
<div>
<pre><code data-lang="nim">  <span>if</span> <span>debug</span><span>:</span> <span>stdout</span><span>.</span><span>writeLine</span><span>(</span><span>&#34;x has the value: &#34;</span> <span>&amp;</span> <span>$</span><span>x</span><span>)</span></code></pre>
</div>
</div>
<p>So when <span>debug</span> is set to <span>false</span>, absolutely no code is generated. For an ordinary, not inlined
<span>proc</span> the situation is different, the expensive <span>string</span> concatenation operation would always have to be
performed, but the <span>log()</span> <span>proc</span> would immediately return for <span>debug == false</span>. What exactly would happen
when <span>log()</span> is an inlined <span>proc</span> may depend on the actual used compiler backend.</p>
<p>Note that the delayed (lazy) parameter evaluation for <span>template</span> parameters can have disadvantages:
When we modify the <span>log()</span> <span>template</span> like</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>log</span><span>(</span><span>msg</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>2</span><span>:</span>
    <span>stdout</span><span>.</span><span>writeLine</span><span>(</span><span>msg</span><span>)</span>

<span>var</span> <span>x</span> <span>=</span> <span>4</span>
<span>log</span><span>(</span><span>&#34;x has the value: &#34;</span> <span>&amp;</span> <span>$</span><span>x</span><span>)</span></code></pre>
</div>
</div>
<p>the expensive <span>string</span> concatenation operation would be done in principle three times
in the <span>template</span> body.
While for a <span>proc</span> the already evaluated parameter would be passed.
So when we access a parameter multiple times inside of a <span>template</span>, it can make sense to
assign the parameter to a local variable and then use that variable only.</p>
<p><span>Templates</span> can inject entities defined in the <span>template</span> body into the surrounding scope.
By default variables defined in the <span>template</span> body are not injected in the surrounding scope, but
<span>procs</span> are:</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>gen</span> <span>=</span>
  <span>var</span> <span>a</span><span>:</span> <span>int</span>
  <span>proc </span><span>maxx</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
    <span>if</span> <span>a</span> <span>&gt;</span> <span>b</span><span>:</span> <span>a</span> <span>else</span><span>:</span> <span>b</span>

<span>gen</span><span>()</span>
<span>echo</span> <span>maxx</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span>
<span># echo a</span></code></pre>
</div>
</div>
<p>The call <span>echo maxx(2, 3)</span> compiles and works, while <span>echo a</span> complains about an undefined symbol.</p>
<p>A very special property of <span>templates</span> and <span>macros</span> is, that we can pass to them code blocks
when we use <span>untyped</span> for the type of the last parameter:</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>withFile</span><span>(</span><span>f</span><span>:</span> <span>untyped</span><span>;</span> <span>filename</span><span>:</span> <span>string</span><span>;</span> <span>actions</span><span>:</span> <span>untyped</span><span>)</span> <span>=</span>
  <span>var</span> <span>f</span><span>:</span> <span>File</span>
  <span>if</span> <span>open</span><span>(</span><span>f</span><span>,</span> <span>filename</span><span>,</span> <span>fmWrite</span><span>):</span>
      <span>actions</span>
      <span>close</span><span>(</span><span>f</span><span>)</span>

<span>withFile</span><span>(</span><span>myTextFile</span><span>,</span> <span>&#34;thisIsReallyNotAnExistingFileWithImportantContent.txt&#34;</span><span>):</span>
  <span>myTextFile</span><span>.</span><span>writeLine</span><span>(</span><span>&#34;line 1&#34;</span><span>)</span>
  <span>myTextFile</span><span>.</span><span>writeLine</span><span>(</span><span>&#34;line 2&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>The <span>template</span> <span>withFile()</span> from the above example has three parameters — a parameter <span>f</span> of <span>untyped</span> type, a <span>filename</span> of <span>string</span> type, and as
last parameter one more <span>untyped</span> parameter which we call actions.
For these last <span>untyped</span> actions parameter we can pass an indented code block.</p>
<p>When we invoke the <span>withFile()</span> <span>template</span>, we pass the first two parameters in the
well know way by putting them in a parameter list enclosed in round brackets. But
instead of passing this way also the final actions parameter, we put a colon after
the parameter list, and pass this way the following indented code block as last <span>untyped</span> parameter.
In the body of above <span>template</span> we have a <span>open()</span> call which opens a file with the specified
filename and the <span>fmWrite</span> mode, then executes the passed code block, and finally closes
the file. The first parameter of our <span>withFile()</span> <span>template</span> has also a special property:
As we use <span>untyped</span> for the <span>f</span> parameter, we can pass the still undefined symbol
<span>myTextFile</span> to the <span>template</span>. In the <span>template</span> body this symbol is used as variable
name, and our two <span>writeLine()</span> <span>proc</span> calls can use it to refer to the file variable.</p>
<p>As Nim <span>templates</span> are hygienic, the instance of the file variable created in the body
of our <span>template</span> can be used by the passed code block, but it actually
exists only in the <span>template</span>, and pollutes not the global name space of our program.</p>
<p>We can use <span>templates</span> to create new <span>procs</span>. An example is lifting <span>procs</span> like <span>math.sqrt()</span>
that accepts a scalar parameter and returns a scalar value, to work with <span>arrays</span>
and sequences. The following example is taken from the official <span>tut2</span> tutorial:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>std</span><span>/</span><span>math</span> <span>import</span> <span>sqrt</span>

<span>template</span> <span>liftScalarProc</span><span>(</span><span>fname</span><span>)</span> <span>=</span>
  <span>proc </span><span>fname</span><span>[</span><span>T</span><span>]</span><span>(</span><span>x</span><span>:</span> <span>openarray</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>auto</span> <span>=</span>
    <span>var</span> <span>temp</span><span>:</span> <span>T</span>
    <span>type</span> <span>outType</span> <span>=</span> <span>typeof</span><span>(</span><span>fname</span><span>(</span><span>temp</span><span>))</span>
    <span>result</span> <span>=</span> <span>newSeq</span><span>[</span><span>outType</span><span>]</span><span>(</span><span>x</span><span>.</span><span>len</span><span>)</span>
    <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>x</span><span>.</span><span>high</span><span>:</span>
      <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>fname</span><span>(</span><span>x</span><span>[</span><span>i</span><span>]</span><span>)</span>

<span>liftScalarProc</span><span>(</span><span>sqrt</span><span>)</span>   <span># make sqrt() work for sequences</span>
<span>echo</span> <span>sqrt</span><span>(</span><span>@[</span><span>4.0</span><span>,</span> <span>16.0</span><span>,</span> <span>25.0</span><span>,</span> <span>36.0</span><span>]</span><span>)</span>   <span># =&gt; @[2.0, 4.0, 5.0, 6.0]</span></code></pre>
</div>
</div>
<p>The <span>template</span> called <span>liftScalarProc()</span> creates a generic
<span>proc</span>, that accept as parameter an <span>openArray[T]</span>
and returns a <span>seq[T]</span>. Well, we should be able to understand the
basic ideas used in that code, but it is still fascinating that it really works.</p>
<div>
<h3 id="_typed_vs_untyped_parameters">Typed vs untyped parameters</h3>
<p>Parameters passed to <span>templates</span> can have all the data types
that we can use for <span>procs</span> including special types like <span>openarray</span> and <span>varargs</span>, and we
can use as types additional the symbols <span>untyped</span>, <span>typed</span> or <span>typedesc</span>.</p>
<p>The <span>typedesc</span> type can be used to pass type information to the <span>template</span>, e.g.
when we want to create a variable of a special data type. The &#34;meta-types&#34;
<span>typed</span> and <span>untyped</span> are used, when we want to create some form of generic
<span>template</span>, that can accept different data types. Actually the distinction
between <span>typed</span> and <span>untyped</span> parameters is not that difficult and important
for <span>templates</span> as it is for <span>macros</span>, in most cases it is just clear if we need the <span>typed</span> or
<span>untyped</span> parameter type for a <span>template</span>, or both work fine. We discuss
the differences between <span>typed</span> and <span>untyped</span> in much more detail in part VI of
the book, when we discuss <span>macros</span> and meta-programming.</p>
<p>The following example demonstrates the use of the <span>untyped</span> and the <span>typedesc</span> parameter:</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>declareInt</span><span>(</span><span>n</span><span>:</span> <span>untyped</span><span>)</span> <span>=</span>
  <span>var</span> <span>n</span><span>:</span> <span>int</span>

<span>declareInt</span><span>(</span><span>i</span><span>)</span>
<span>i</span> <span>=</span> <span>3</span>
<span>echo</span> <span>i</span>

<span>template</span> <span>declareVar</span><span>(</span><span>n</span><span>:</span> <span>untyped</span><span>;</span> <span>t</span><span>:</span> <span>typedesc</span><span>)</span> <span>=</span>
  <span>var</span> <span>n</span><span>:</span> <span>t</span>

<span>declareVar</span><span>(</span><span>x</span><span>,</span> <span>float</span><span>)</span>
<span>x</span> <span>=</span> <span>3.0</span>
<span>echo</span> <span>x</span></code></pre>
</div>
</div>
<p>As the parameter <span>n</span> is <span>untyped</span>, the compiler allows us to pass
an undefined symbol to the <span>template</span>. If we would change the parameter
type to <span>typed</span> the compiler would complain with a message like
<span>Error: undeclared identifier: &#39;i&#39;</span></p>
<p>For the second <span>template</span> called <span>declareVar()</span> we use an additional parameter
of <span>typedesc</span> type, so that the <span>template</span> can create for us a variable of just the passed
data type.</p>

</div>
<div>
<h3 id="_passing_a_code_block_to_a_template">Passing a code block to a template</h3>
<p>In the <span>withFile()</span> example above we showed that we
can pass a block of statements as the last argument to a <span>template</span> following the special <span>:</span> syntax.
To demonstrate the difference between code blocks of <span>typed</span> and <span>untyped</span> data type
we will cite the compiler manual, see <a href="https://nim-lang.org/docs/manual.html#templates-passing-a-code-block-to-a-template">https://nim-lang.org/docs/manual.html#templates-passing-a-code-block-to-a-template</a>:</p>
<p>Usually, to pass a block of code to a <span>template</span>, the parameter that accepts the block needs to be of type <span>untyped</span>.
Because symbol lookups are then delayed until <span>template</span> instantiation time:</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>t</span><span>(</span><span>body</span><span>:</span> <span>typed</span><span>)</span> <span>=</span>
  <span>proc </span><span>p</span> <span>=</span> <span>echo</span> <span>&#34;hey&#34;</span>
  <span>block</span><span>:</span>
    <span>body</span>

<span>t</span><span>:</span>
  <span>p</span><span>()</span>  <span># fails with &#39;undeclared identifier: p&#39;</span></code></pre>
</div>
</div>
<p>The above code fails with the error message that <span>p</span> is not declared. The reason for this is that the <span>p()</span>
body is type-checked before getting passed to the body parameter and type checking in Nim implies symbol lookups.
The same code works with <span>untyped</span> as the passed body is not required to be type-checked:</p>
<div>
<div>
<pre><code data-lang="nim"><span>template</span> <span>t</span><span>(</span><span>body</span><span>:</span> <span>untyped</span><span>)</span> <span>=</span>
  <span>proc </span><span>p</span> <span>=</span> <span>echo</span> <span>&#34;hey&#34;</span>
  <span>block</span><span>:</span>
    <span>body</span>

<span>t</span><span>:</span>
  <span>p</span><span>()</span>  <span># compiles</span></code></pre>
</div>
</div>
</div>
<div>
<h3 id="_passing_operators_to_templates">Passing operators to templates</h3>
<p>One more use case for <span>templates</span> with <span>untyped</span> parameters is the generation
of math operations for custom data types. Let us assume that we have created
a custom <span>Vector</span> <span>object</span>, for which we have to define addition and subtractions
operations. Instead of writing code for both cases, we can use a <span>template</span>
and pass the actual math operator as <span>untyped</span> parameter:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Vector</span> <span>=</span> <span>object</span>
    <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>:</span> <span>int</span>

<span>template</span> <span>genOp</span><span>(</span><span>op</span><span>:</span> <span>untyped</span><span>)</span> <span>=</span>
  <span>proc </span><span>`op`</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>Vector</span><span>):</span> <span>Vector</span> <span>=</span>
    <span>Vector</span><span>(</span><span>x</span><span>:</span> <span>`</span><span>op</span><span>`(</span><span>a</span><span>.</span><span>x</span><span>,</span> <span>b</span><span>.</span><span>x</span><span>),</span> <span>y</span><span>:</span> <span>`</span><span>op</span><span>`(</span><span>a</span><span>.</span><span>y</span><span>,</span> <span>b</span><span>.</span><span>y</span><span>),</span> <span>z</span><span>:</span> <span>`</span><span>op</span><span>`(</span><span>a</span><span>.</span><span>z</span><span>,</span> <span>b</span><span>.</span><span>z</span><span>))</span>

<span>genOp</span><span>(`</span><span>+</span><span>`)</span>
<span>genOp</span><span>(`</span><span>-</span><span>`)</span>

<span>echo</span> <span>`</span><span>+</span><span>`(</span><span>2</span><span>,</span> <span>3</span><span>)</span> <span># 5</span>

<span>var</span> <span>p</span> <span>=</span> <span>Vector</span><span>(</span><span>x</span><span>:</span> <span>1</span><span>,</span> <span>y</span><span>:</span> <span>1</span><span>,</span> <span>z</span><span>:</span> <span>1</span><span>)</span>
<span>var</span> <span>p2</span> <span>=</span> <span>p</span> <span>+</span> <span>p</span>
<span>echo</span> <span>p2</span> <span># (x: 2, y: 2, z: 2)</span></code></pre>
</div>
</div>
<p>This works, because for operators math like <span>1+2</span> can be written as <span><code>+</code>(1, 2)</span> and because
we can pass such an operator as <span>untyped</span> parameter to a <span>template</span>.</p>
</div>
<div>
<h3 id="_advanced_template_use">Advanced template use</h3>
<p>For the advanced <span>template</span> stuff you should consult the compiler manual.</p>
<p>This includes the symbol binding rules, identifier construction in <span>templates</span>,
lookup rules for <span>template</span> parameters, hygiene in <span>templates</span>, use of the <span>inject</span> pragma, and
limitations of the method call syntax.</p>
<p>All this is explained well in the compiler manual, so it makes no sense to repeat it here.
And it makes more sense to read it when you actually have problems with the (default)
behaviour of <span>templates</span> in special situations.</p>
</div>
</div>
</div>
<div>
<h2 id="_casts_and_type_conversion">Casts and Type Conversion</h2>
<div>
<p>While we have various types of casts in C++, we have only one cast and type
conversions in Nim. In Nim <span>cast</span> just reinterpret the same bit pattern for another
data type. For example the boolean value <span>false</span> is internally encoded as a <span>byte</span> with
all bits cleared, and <span>true</span> is encoded as a <span>byte</span> with all bits but the least
significant one cleared. We could <span>cast</span> a <span>bool</span> to an <span>int8</span> of same size and would get a
number with decimal value <span>0</span> or <span>1</span>. Casting is not a real operation at all, as nothing is really
done. We watch the same bit pattern just from a different perspective. But casting is
dangerous, it violates the safe type system of the language, and it can go very
wrong: Can we cast between <span>float64</span> and <span>int64</span>? Well they have same size, and both are
numbers. We can <span>cast</span>, but the result would be far away from what we may expect.
While <span>int64</span> has the well known and simple value encoding, that is rightmost bit
stands for <span>2^0</span>, next bit for <span>2^1</span> and so far, the encoding of floating point numbers is much more
difficult and has not such a simple scheme. In <span>floats</span> some bits represent the so
called mantissa and some bits represent the exponent. When we <span>cast</span> we may again get a
number, but the value is not easy predictable. We have to be very carefully when
we <span>cast</span> between types of different size. Nim may permit that but we have to think
what may really happen. When we <span>cast</span> between a <span>bool</span> and an <span>int64</span>, in one direction 7
bytes have to be ignored, and in the other direction for 7 missing bytes there is
some padding necessary. We do a <span>cast</span> by writing after the keyword <span>cast</span> in square
brackets the desired type followed by parenthesis enclosing the source variable:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span><span>:</span> <span>uint8</span> <span>=</span> <span>cast</span><span>[</span><span>unint8</span><span>]</span><span>(</span><span>myBoolVar</span><span>)</span></code></pre>
</div>
</div>
<p>Totally different to casting is type conversion. We can convert integers to floating point numbers
without problems, for the conversion we use the type like a <span>proc</span> call, that is
<span>int(myfloat)</span> or <span>float(myInt)</span> — of course we could use method call syntax like
<span>myInt.float</span> instead. Type conversion is some effort for the CPU, but most advanced
CPUs should have fast instructions for basic conversion.</p>
<p>Nim generally only allows type conversions that involve not too much effort. So we
should not expect <span>var i =&#34;1234&#34;; echo i.int * 7</span> to be available. Such a conversion is
expensive, at runtime it costs many CPU cycles as we would have to extract the
digits, multiply with it weight and sum them up. So for that operation functions like
<span>parseInt()</span> are available from the Nim standard library that accept a <span>string</span> as
argument and return an <span>int</span>. There exists different variants of <span>parseInt()</span>, one may
raise exceptions for invalid input, the other may return a boolean.</p>
</div>
</div>
<div>
<h2 id="_bitwise_operations">Bitwise Operations</h2>
<div>
<p>All systems programming languages, and most other languages, have support for
bit manipulation operations, which includes querying and setting individual bits
of variables, and combining the bits of two or more variables. As the CPU hardware
supports these operations directly, these operations are very efficient. In the
C programming language operators like <span>&amp;</span>, <span>|</span>, <span>&lt;&lt;</span>, <span>&gt;&gt;</span>, <span>^</span>, <span>~</span> are used
for bit-wise <span>and</span> and <span>or</span> operations, for shifting all the bits of a variable to the left or to
the right, and for the process of inverting all the bits and for applying the exclusive-or operation
on the bits of two operands. Actually, for the right shift operation, we have to distinct between a
logical and an arithmetic shift: For a logical shift the bit pattern is only moved right, and
the leftmost bit is always cleared. But for an arithmetic shift, the leftmost bit may stay set when
it was set before, indicating a negative number in case of a numeric variable. In C the actual
behaviour for a <span>&gt;&gt;</span> shift right operation may be implementation dependent.</p>
<p>Nim prefers to use textual operators instead of cryptic symbols,
so the logical operators <span>and</span>, <span>or</span> and <span>not</span> have overloads to work on the actual bit pattern of integer
variables instead of on boolean values, and for logical left and right shifts the operators are called
<span>shr</span> and <span>shl</span>. For <span>shl</span> shifted in bits from the right are always cleared, while
 <span>shr</span> shifts in cleared bits from the left for unsigned arguments, but preserved the
leftmost set bit for signed arguments, which corresponds to an arithmetic shift operation.
The Nim standard library provides also an <span>ashr()</span> function for arithmetic shifts, but that
one seems to be a legacy.</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>strutils</span> <span>import</span> <span>toBin</span>
<span>var</span> <span>i</span> <span>=</span> <span>1.</span><span>int8</span> <span># 0b00000001</span>
<span>i</span> <span>=</span> <span>i</span> <span>shl</span> <span>7</span> <span># 0b10000000</span>
<span>i</span> <span>=</span> <span>i</span> <span>shr</span> <span>2</span> <span># 0b11100000 as sign is preserved</span>
<span>echo</span> <span>i</span><span>.</span><span>toBin</span><span>(</span><span>8</span><span>)</span>
<span>var</span> <span>j</span><span>:</span> <span>uint8</span> <span>=</span> <span>0b11111111</span>
<span>j</span> <span>=</span> <span>j</span> <span>shr</span> <span>2</span> <span># 0b00111111, div 4 for unsigned int</span>
<span>echo</span> <span>j</span><span>.</span><span>int8</span><span>.</span><span>toBin</span><span>(</span><span>8</span><span>)</span></code></pre>
</div>
</div>
<p>The bit-wise operators <span>and</span>, <span>or</span> and <span>not</span> behave very similar
to the boolean ones, but the operation is performed for all the bit values instead for two boolean operands.
The shift operators require a right hand operand specifying how many positions the
bit pattern of the integer variable on the left should be moved. As the <span>shr</span> operator preserves the leftmost sign bit for
each individual shift when applied to an signed integer argument, we gets a value with the three leftmost bits set in above example.
For showing the bit pattern, we used the <span>toBin()</span> function in above code, the second
parameter determines how many bits are actually printed.
Remember, that for
unsigned numbers <span>shl</span> by one position is a multiplication by two, and shr by one position is a division by two.
Negative numbers are not allowed for the number of bits to shift — <span>i = i shl -1</span> does compile, but the result is
always zero. For all the shift operations, n shifts each by one position would give the same result as one single shift
by n positions. For most modern CPU hardware, all the bit shifting operations are very fast and generally take only one clock
cycle, independent of how many positions we move the bit pattern and independent if it is a logical or an arithmetic shift operation.</p>
<p>We can use the <span>and</span> and the <span>or</span> operator to extract single bits, or to set single bits:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span> <span>=</span> <span>3</span> <span># two rightmost bits, at position 0 and 1 are set</span>
<span>var</span> <span>b</span> <span>=</span> <span>a</span> <span>and</span> <span>2</span> <span># extract bit 1, so b gets the value 2</span>
<span>b</span> <span>=</span> <span>a</span> <span>and</span> <span>4</span> <span># extract bit 3, which is unset, so result is 0</span>
<span>b</span> <span>=</span> <span>a</span> <span>or</span> <span>(</span><span>4</span> <span>+</span> <span>8</span><span>)</span> <span># result is \b00001111, decimal 15</span></code></pre>
</div>
</div>
<p>This should be enough to teach you the most basic bit operations.
Actually we need these operations not that often, but we should be aware of their
existence. The overloading of the <span>and</span>, the <span>or</span> and the <span>not</span> operator for signed and unsigned
integer numbers may be convenient, but it may sometimes lead to confusion, when
we intend to do boolean operations but instead actually do operations on bit patterns.
It was suggested to call the operators bitand, bitor and bitand instead, and
indeed the <span>bitops</span> module of Nim’s standard library defines operators with these names and
provide additional more useful bit operations, including counting the number of set bits in
a variable or determining the number of leading zero bits. These operations are not
needed that often, but sometimes they can be very useful, and they are supported by fast CPU
instructions on modern PC hardware. Note that while we have shown these bit operations
on integer numbers only, you can always cast other data types to integers and then
apply these operations as well.</p>
</div>
</div>
<div>
<h2 id="_exceptions">Exceptions</h2>
<div>
<p>When we execute our code, sometimes something can go wrong: We may have an unexpected
division by zero or an overflow, or we get some invalid user input. There exists
various strategies to handle such situations. One is to terminate our program, we may
do that by a plain <span>assert()</span> or <span>quit()</span> statements. If we have absolutely no idea how
to recover from an error then that may be our best option. The user may restart the
program, or the program may be restarted by some sort of supervisor program. For more
expectable errors some sort of error indicator may be a better solution, for example
a parseInt() procedure may return a boolean value for success. As we have to return
the result for success also, the parseInt() <span>proc</span> may return a tuple, or may get a var
parameter in which the result is returned. Another solutions are exceptions as known
from C++.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>charToInt</span><span>(</span><span>c</span><span>:</span> <span>char</span><span>):</span> <span>int</span> <span>=</span>
  <span>if</span> <span>c</span> <span>in</span> <span>{</span><span>&#39;0&#39;</span> <span>..</span> <span>&#39;9&#39;</span><span>}:</span>
    <span>return</span> <span>ord</span><span>(</span><span>c</span><span>)</span> <span>-</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>)</span>
  <span>raise</span> <span>newException</span><span>(</span><span>OSError</span><span>,</span> <span>&#34;parse error&#34;</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;Please enter a single decimal digit: &#34;</span><span>)</span>
    <span>let</span> <span>s</span> <span>=</span> <span>stdin</span><span>.</span><span>readline</span>
    <span>try</span><span>:</span>
      <span>echo</span> <span>&#34;Fine, the number is: &#34;</span><span>,</span> <span>charToInt</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>)</span>
    <span>except</span><span>:</span>
      <span>if</span> <span>s</span><span>.</span><span>len</span> <span>==</span> <span>0</span><span>:</span>
        <span>break</span>
      <span>echo</span> <span>&#34;Try again&#34;</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>This section has to be extended…​</p>
</div>
</div>
<div>
<h2 id="_destructors">Destructors</h2>
<div>
<p>Destructors and finalizers are used for automatic resource management.
For example files can be closed automatically when a file variable goes out of scope,
or when we create high level Nim bindings to C libraries we can use
finalizers or destructors to deallocate entities of the C libs when a corresponding
Nim (proxy) object is freed. Libraries like the gintro GTK bindings make use of this.</p>
<p>Finalizers are procedures that can be passed as a second optional parameter to the
system <span>new()</span> <span>proc</span>. That way the finalizer <span>proc</span> is attached to the data type of the variable which
we pass as first parameter to <span>new()</span> and that finalizer <span>proc</span> is
automatically called whenever that variable is freed by the Nim memory management system.
As finalizers are passed as a parameter to a <span>new()</span> call, and <span>new()</span> is only used for
references, finalizers work only for <span>ref</span> data types.</p>
<p>Destructors do not have this restriction. We define the destructor for a value type, but
it is also called for reference types by the compiler.</p>
<p>Starting with version 1.4 Nim got scope based resource management when
the program is compiled with <span>--gc:arc</span> or <span>--gc:orc</span>. In that case
variables are immediately deallocated when they go out of scope, and if
a destructor was defined for the data type of that variable it is called automatically.</p>
<p>For the programming language C++ it is a common practice that resources like files are closed and released
automatically by destructors when they go out of scope, and now this is also
possible for Nim. To make use of destructors for our own data types we
have to define a <span>proc</span> called <span>=destroy</span> which gets an instance of our data type passed as
a var value object:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>`=destroy`</span><span>(</span><span>o</span><span>:</span> <span>var</span> <span>O</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;destroying O&#34;</span>

<span>import</span> <span>random</span>

<span>proc </span><span>test</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>5</span><span>:</span>
    <span>if</span> <span>rand</span><span>(</span><span>9</span><span>)</span> <span>&gt;</span> <span>1</span><span>:</span>
      <span>var</span> <span>o</span><span>:</span> <span>O</span>
      <span>o</span><span>.</span><span>i</span> <span>=</span> <span>rand</span><span>(</span><span>100</span><span>)</span>
      <span>echo</span> <span>o</span><span>.</span><span>i</span> <span>*</span> <span>o</span><span>.</span><span>i</span>

<span>randomize</span><span>()</span>
<span>test</span><span>()</span></code></pre>
</div>
</div>
<p>In the for loop we enter a new scope when the <span>if</span> condition is evaluated to <span>true</span>,
and at the end of the <span>if</span> block we leaf the scope and the destructor is called automatically.
Inside the destructor <span>proc</span> we could do some cleanup tasks, close files and release resources.
Destructors are also called when <span>ref</span> objects go out of scope:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>`=destroy`</span><span>(</span><span>o</span><span>:</span> <span>var</span> <span>typeof</span><span>(</span><span>O</span><span>()</span><span>[]</span><span>))</span> <span>=</span>
  <span>echo</span> <span>&#34;destroying O&#34;</span>

<span>import</span> <span>random</span>

<span>proc </span><span>test</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>5</span><span>:</span>
    <span>if</span> <span>rand</span><span>(</span><span>9</span><span>)</span> <span>&gt;</span> <span>1</span><span>:</span>
      <span>var</span> <span>o</span><span>:</span> <span>O</span> <span>=</span> <span>O</span><span>()</span> <span># new O</span>
      <span>o</span><span>.</span><span>i</span> <span>=</span> <span>rand</span><span>(</span><span>100</span><span>)</span>
      <span>echo</span> <span>o</span><span>.</span><span>i</span> <span>*</span> <span>o</span><span>.</span><span>i</span>

<span>randomize</span><span>()</span>
<span>test</span><span>()</span></code></pre>
</div>
</div>
<p>To use destructors we have to compile with the option <span>--gc:arc</span> or <span>--gc:orc</span>, otherwise
the specified destructor <span>procs</span> are just ignored. In our code we can test for working destructors with
a construct like <span>when defined(gcDestructors):</span>.</p>
<p>Note that destructors do not work for plain pointer types:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>i</span><span>:</span> <span>int</span>
  <span>OP</span> <span>=</span> <span>ptr</span> <span>O</span>

<span>proc </span><span>`=destroy`</span><span>(</span><span>o</span><span>:</span> <span>var</span> <span>O</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;destroying O&#34;</span>

<span>import</span> <span>random</span>

<span>proc </span><span>test</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>5</span><span>:</span>
    <span>if</span> <span>rand</span><span>(</span><span>9</span><span>)</span> <span>&gt;</span> <span>1</span><span>:</span>
      <span>var</span> <span>o</span><span>:</span> <span>OP</span> <span>=</span> <span>create</span><span>(</span><span>O</span><span>)</span> <span># new O</span>
      <span>o</span><span>.</span><span>i</span> <span>=</span> <span>rand</span><span>(</span><span>100</span><span>)</span>
      <span>echo</span> <span>o</span><span>.</span><span>i</span> <span>*</span> <span>o</span><span>.</span><span>i</span>

<span>randomize</span><span>()</span>
<span>test</span><span>()</span></code></pre>
</div>
</div>
<p>So using destructors to release data from C libraries directly is not possible.
But at least for Nim &gt;= v1.6 destructors work for distinct pointer types:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>i</span><span>:</span> <span>int</span>
  <span>OP1</span> <span>=</span> <span>ptr</span> <span>O</span>
  <span>OP</span> <span>=</span> <span>distinct</span> <span>ptr</span> <span>O</span>

<span>proc </span><span>`=destroy`</span><span>(</span><span>o</span><span>:</span> <span>var</span> <span>OP</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;destroying OP&#34;</span>

<span>import</span> <span>random</span>

<span>proc </span><span>test</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>5</span><span>:</span>
    <span>if</span> <span>rand</span><span>(</span><span>9</span><span>)</span> <span>&gt;</span> <span>1</span><span>:</span>
      <span>var</span> <span>o</span><span>:</span> <span>OP</span> <span>=</span> <span>OP</span><span>(</span><span>create</span><span>(</span><span>O</span><span>))</span> <span># new O</span>
      <span>OP1</span><span>(</span><span>o</span><span>).</span><span>i</span> <span>=</span> <span>rand</span><span>(</span><span>100</span><span>)</span>
      <span>echo</span> <span>OP1</span><span>(</span><span>o</span><span>).</span><span>i</span> <span>*</span> <span>OP1</span><span>(</span><span>o</span><span>).</span><span>i</span>

<span>randomize</span><span>()</span>
<span>test</span><span>()</span></code></pre>
</div>
</div>
<div>
<div>
<pre>81
destroying OP
3600
destroying OP
2401
destroying OP
9025
destroying OP</pre>
</div>
</div>
<p>So using destructors to destroy data from C libraries should be possible now.</p>
<div>
<h3 id="_destructors_and_inheritance">Destructors and Inheritance</h3>
<p>When we use OOP style programming with subclassing of ref objects, then
it is useful to know that for subclassed ref objects the destructor of the
parent class is automatically invoked when we do not define our own one
for our subclassed type. This works also when we import the parent
type from another module, at least since Nim v1.6:</p>
<div>
<div>
<pre><code data-lang="nim"><span># module tt.nim</span>
<span>type</span>
  <span>O1</span><span>*</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Rootref</span>
    <span>i</span><span>*</span><span>:</span> <span>int</span>

<span>when</span> <span>defined</span><span>(</span><span>gcDestructors</span><span>):</span> <span># check not really needed, as =destroy call is just ignored when condition is false</span>
  <span>proc </span><span>`=destroy`</span><span>*</span><span>(</span><span>o1</span><span>:</span> <span>var</span> <span>typeof</span><span>(</span><span>O1</span><span>()</span><span>[]</span><span>))</span> <span>=</span>
    <span>echo</span> <span>&#34;destroy O1 &#34;</span><span>,</span> <span>typeof</span><span>(</span><span>o1</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span># module t.nim</span>
<span>import</span> <span>tt</span>

<span>type</span>
  <span>O2</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>tt</span><span>.</span><span>O1</span>
    <span>j</span><span>:</span> <span>int</span>

<span>type</span>
  <span>O3</span> <span>=</span> <span>ref</span> <span>object</span>
    <span>o1</span><span>:</span> <span>tt</span><span>.</span><span>O1</span>

<span>type</span>
  <span>O4</span> <span>=</span> <span>object</span>
    <span>o1</span><span>:</span> <span>tt</span><span>.</span><span>O1</span>

<span>type</span>
  <span>O5</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>tt</span><span>.</span><span>O1</span>
    <span>x</span><span>:</span> <span>float</span>

<span>when</span> <span>defined</span><span>(</span><span>gcDestructors</span><span>):</span>
  <span>proc </span><span>`=destroy`</span><span>(</span><span>o5</span><span>:</span> <span>var</span> <span>typeof</span><span>(</span><span>O5</span><span>()</span><span>[]</span><span>))</span> <span>=</span>
    <span>echo</span> <span>&#34;destroy O5 &#34;</span><span>,</span> <span>typeof</span><span>(</span><span>o5</span><span>)</span>
    <span>tt</span><span>.`</span><span>=</span><span>destroy</span><span>`(</span><span>o5</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>o1</span><span>:</span> <span>tt</span><span>.</span><span>O1</span>
  <span>new</span> <span>o1</span>
  <span>echo</span> <span>o1</span><span>.</span><span>i</span>

  <span>var</span> <span>o2</span><span>:</span> <span>O2</span>
  <span>new</span> <span>o2</span>
  <span>echo</span> <span>o2</span><span>.</span><span>j</span>

  <span>var</span> <span>o3</span><span>:</span> <span>O3</span>
  <span>new</span> <span>o3</span>
  <span>new</span> <span>o3</span><span>.</span><span>o1</span>

  <span>var</span> <span>o4</span><span>:</span> <span>O4</span>
  <span>new</span> <span>o4</span><span>.</span><span>o1</span>

  <span>var</span> <span>o5</span><span>:</span> <span>O5</span> <span>=</span> <span>O5</span><span>(</span><span>x</span><span>:</span> <span>3.1415</span><span>)</span>
  <span>echo</span> <span>o5</span><span>.</span><span>x</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we compile module t.nim with --gc:arc or --gc:orc and run it, we get this output:</p>
<div>
<div>
<pre>0
0
3.1415
destroy O5 O5:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType</pre>
</div>
</div>
<p>So when our variables o1 to o5 go out of scope, then the destructors are called.
Module tt.nim defines a ref object type, but the destructor <span>proc</span> takes a var value
parameter. The destructor is called when a value object or a ref object goes out of scope.
Our variable o1 has type tt.O1, so it was indeed expected that its destructor from module tt.nim
is called. Variable o2 is a ref object with parent O1, as we define no destructor for this type, the destructor
of the parent type is called. The variables o3 and o4 are of ref object and of value object types, each with
a field of type O1, and for that field the destructor for O1 is called. Finally for type O5 we define
our own destructor, which then additional calls the destructor of module tt.</p>
<p>Destructors are mostly used for library implementations, e.g. for a file data type which is
automatically closed when a file variable goes out of scope. As you may never have to use
destructors yourself, it is not necessary to remember all these details. But it is good to know
that destructors behave in a way as we may have expected, and when you later wants to use
a destructor in your own code, you can consult again this section or maybe better the Nim
manual.</p>
<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_finalizers">Finalizers</h2>
<div>
<p>In Nim finalizers are procedures, that we can specify as an optional second parameter
when we call the system <span>new()</span> <span>proc</span> to allocate heap memory for a reference type variable.
That specified finalizer <span>proc</span> is then later called by the Nim memory management system
when the <span>ref</span> variable is freed:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>finO</span><span>(</span><span>o</span><span>:</span> <span>O</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;finalize O&#34;</span>

<span>proc </span><span>newO</span><span>:</span> <span>O</span> <span>=</span>
  <span>new</span><span>(</span><span>result</span><span>,</span> <span>finO</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>o</span> <span>=</span> <span>newO</span><span>()</span>
  <span>var</span> <span>o2</span> <span>=</span> <span>new</span><span>(</span><span>O</span><span>)</span>
  <span>var</span> <span>o3</span> <span>=</span> <span>O</span><span>(</span><span>i</span><span>:</span> <span>7</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<div>
<div>
<pre>finalize O
finalize O
finalize O</pre>
</div>
</div>
<p>The output of above program is really surprising at first: Only for variable <span>o</span> we call the
proc <span>newO()</span> to initialize it, which then calls <span>new()</span> by passing a finalizer <span>proc</span> named <span>finO()</span>.
For <span>o2</span> and <span>o3</span> we allocate memory as usual, without use of a finalizer <span>proc</span>.
But when <span>o2</span> and <span>o3</span> goes out of scope, even for these two variables the finalizer <span>proc</span> <span>finO()</span>
is called. The reason for this is, that the system <span>proc</span> <span>new()</span> binds the optional finalizer <span>proc</span>
to the data type of the passed <span>ref</span> variable. This binding process occurs for the first
call with a passed finalizer <span>proc</span> and can not be reverted. We can later call <span>new()</span> without
finalizer or use the similar <span>O()</span> call to initialize the <span>ref</span> variable, but that can not undo the binding. And using a
different finalizer <span>proc</span> for the same data type would not work any more. Passing the same finalizer
proc multiple times is OK and may be a common use case, but it has no real effect, as the first call
did the binding already.</p>
<p>This behaviour of finalizers in Nim is indeed a bit confusing and error prone. Maybe somewhere
in a large program we pass a finalizer <span>proc</span> to <span>new()</span> and forget about it. Later, we use
<span>new ()</span> without a finalizer or use the <span>O()</span> notation to reserve the memory for our <span>ref</span> variable.
So we think that no finalizer is involved, but as a finalizer was used somewhere at least once,
it is now bound to all of our allocations of that data type. That can easily lead to bugs
as the unintended called finalizers may do things that it should not do with our data.</p>
<p>Finalizer <span>procs</span> have to be defined always in the same module as the type for
which the finalizer shall be used is defined:</p>
<div>
<div>
<pre><code data-lang="nim"><span># module tt.nim</span>
<span>type</span>
  <span>O</span><span>*</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>i</span><span>:</span> <span>int</span>

<span>proc </span><span>fin</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>o</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;finalize T&#34;</span>

<span>proc </span><span>newO</span><span>*</span><span>:</span> <span>O</span> <span>=</span>
  <span>new</span><span>(</span><span>result</span><span>,</span> <span>fin</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tt</span>

<span>type</span>
  <span>OO</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>tt</span><span>.</span><span>O</span>
    <span>x</span><span>:</span> <span>float</span>

<span>proc </span><span>finn</span><span>[</span><span>T</span><span>]</span><span>(</span><span>o</span><span>:</span> <span>T</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;finalize O&#34;</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>oo</span><span>:</span> <span>OO</span>
  <span>new</span><span>(</span><span>oo</span><span>,</span> <span>finn</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>We import module <span>tt.nim</span> and subclass the <span>ref object</span> type <span>tt.O</span>.
While module <span>tt.nim</span> defines a generic finalizer <span>proc</span> <span>fin()</span>, we can
not use that one for our subclased type <span>OO</span>, but have to copy it
from module <span>tt.nim</span> into our main module and we may have even to use a different
proc name. Otherwise we get the compiler message</p>
<div>
<div>
<pre>Error: type bound operation `fin` can be defined only in the same module with its type (OO:ObjectType)</pre>
</div>
</div>
<p>Whenever we should really need a finalizer or a destructor, we should prefer destructors
when we can compile our code with the compiler options --gc:arc or --gc:orc.</p>
</div>
</div>
<div>
<h2 id="_modules">Modules</h2>
<div>
<p>Modules are Nim’s way to divide multiple source codes in clearly separated units and
to hide implementation details. Nim use a module concept which is very similar to
Modula-2 or Oberon. All the Nim standard libraries are divided into modules which
collect and logically group data types and the related procedures. In some way
modules are Nim’s classes.</p>
<p>In Nim each module directly corresponds to one text file. Sub-modules as known from
Ruby, that divide a single text file in multiple modules are not supported by Nim
currently.</p>
<p>Every text file with Nim source code is basically a module, and that module can be
imported and used by other modules. But all symbols like data types or procedures
have to be exported to make them visible and usable by other modules. That is done
like in Oberon by appending an asterisk character to all names that should be
exported. These restricted exports allows to hide implementation details — all
symbols not exported are private to that module and can be changed and improved at
any time without noticing the importing module. Note that when we append the asterisk
to the name of an object to export that type, the objects fields are still hidden and can not
be accessed from within the importing module. You may append an asterisk to selected field
names as well, or you may provide exported getter and setter <span>procs</span> for the field access.
A read-only export es known from the Oberon language is currently not possible with Nim.</p>
<p>We can import whole modules, that is all symbols that are marked for export by the
asterisk, or we can import only the symbols that we need by specifying their names.
Let us create a module that declares a single procedure to remove all characters from
a string that are not letters:</p>
<div>
<div>
<pre><code data-lang="nim"><span># save this textfile with name mystrops.nim</span>
<span>proc </span><span>remNoneLetters</span><span>*</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>):</span> <span>string</span> <span>=</span>
  <span>result</span> <span>=</span> <span>newString</span><span>(</span><span>s</span><span>.</span><span>len</span><span>)</span>
  <span>var</span> <span>pos</span> <span>=</span> <span>0</span>
  <span>for</span> <span>c</span> <span>in</span> <span>s</span><span>:</span>
    <span>if</span> <span>c</span> <span>in</span> <span>{</span><span>&#39;a&#39;</span> <span>..</span> <span>&#39;z&#39;</span><span>,</span> <span>&#39;A&#39;</span> <span>..</span> <span>&#39;Z&#39;</span><span>}:</span>
      <span>result</span><span>[</span><span>pos</span><span>]</span> <span>=</span> <span>c</span>
      <span>inc</span><span>(</span><span>pos</span><span>)</span>
  <span>result</span><span>.</span><span>setLen</span><span>(</span><span>pos</span><span>)</span></code></pre>
</div>
</div>
<p>We save above text file with our Nim source code with name mystrops.nim.
Note the export marker after the <span>proc</span> name.
We can import and use that module like</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>mystrops</span>

<span>echo</span> <span>remNoneLetters</span><span>(</span><span>&#34;3h7.5g:8h&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>When we import modules, then we put the import statement generally at the top of the
importing module, that way it is easy to see what modules are imported. The imported symbols
can be used in the code after the import statement.
Module names should be lower case and may as other Nim symbols only contain letters,
decimal digits and the underscore character.
We can import multiple modules with a single import statement when we separate the module names with commas.
Starting with Nim v1.6 it is recommended to import modules from Nim’s standard library with the <span>std</span>
prefix as in <span>import std/math</span> or <span>import std/[strutils, sequtils]</span>.
Importing the same module multiple times is not a problem, and does not increase the
code file of the final executable.
Note that in the import statement
the module names have to be used literally, so this would not work:</p>
<div>
<div>
<pre><code data-lang="nim"><span>const</span> <span>strfuncs</span> <span>=</span> <span>&#34;stringutils&#34;</span>
<span>import</span> <span>strfuncs</span></code></pre>
</div>
</div>
<p>Instead of importing whole modules we can
import only single symbols with the <span>from x import y, z</span> syntax like</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>mystrops</span> <span>import</span> <span>remNoneLetters</span>

<span>echo</span> <span>remNoneLetters</span><span>(</span><span>&#34;3h7.5g:8h&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>Both forms are an unqualified import, that is we can refer to the proc by only its
name, we do not need the qualified form with module name prefix like
<span>mystrops.remNoneLetters()</span> as long as there are no name conflicts. But whenever we
want we can use the qualified form also.</p>
<p>Nim programmer generally prefer importing whole modules and use unqualified names,
while that is considered bad style in some other languages like Python. In untyped
languages like Python unqualified imports may indeed pollute the name space and
generate many name conflicts, but in statically typed languages like Nim unqualified
imports seems to generate name conflicts only in very rare cases. Procedures with the
same name generally have different parameter lists, so the overload resolution of the
compiler can decide what <span>proc</span> is to be used. And when really a name conflict occurs
then the compiler will tell us, and we can easily fix it by prefixing the <span>proc</span> name
with its module name.</p>
<p>For data types, constants or enums chances for name conflicts may be not that tiny,
so we may have to use qualified names.</p>
<p>We can also enforce a fully qualified import in Nim by a notation like</p>

<p>In this case we can use all symbols from that module only in qualified form. But
that does not always work that well in Nim, as Nim has not classes like Java, so a
qualified use of method call syntax or qualified use of user defined or overloaded
operators is difficult. Imagine strutils.add(s, &#39;\n&#39;), how should that look with
method call syntax?</p>
<p>For imports we have also the except keyword, so we may do something like</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span> <span>except</span> <span>toUpper</span></code></pre>
</div>
</div>
<p>The except keyword can be used to prevent possible name conflicts without having to
use qualified names.</p>
<p>Note that the system module is imported automatically, we should not import it
directly. Also note that Nim always imports only what is really needed in the final
executable, so importing only a few symbols from a module has no code size benefit
over importing the whole module. Still it may improve readability of your code when
you import only single symbols when you are sure that you need not more. Maybe like
<span>from math import Pi</span>. Note that you can even in that case access other symbols of that
module by fully qualified names like <span>math.sin()</span>.</p>
<p>With the growing standard library it may occur that module names of the standard
library interfere with your own module names. So Nim now allows and recommends
qualified import of modules from the standard library like <span>import std/strutils</span>. And
for external packages installed by the nimble package manager imports in the form
<span>import package/[mod1, mod2, mod3]</span> are permitted.</p>
<p>Finally you can also import modules under another name using the <span>as</span> keyword
like</p>

<p>With the recent Nim compiler you can also enforce full qualified import and use of an
alternate module name by using an import statement like</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>tables</span> <span>as</span> <span>maps</span> <span>import</span> <span>nil</span></code></pre>
</div>
</div>
<p>With this import statement you could access symbols from the <span>tables</span> module only by
use of the <span>maps</span> module prefix like <span>maps.newTable()</span>.</p>
<p>Finally with the <span>export</span> keyword one library module can export other modules, which it
imports itself. This may simplify the use of connected modules. As an example, when
using the <span>gintro</span> bindings for GTK4, we import all the needed modules generally like
<span>import gintro/[glib, gobject, gtk4]</span>. We may decide to simplify that import statement
by creating one more module called <span>gtkplus</span> that consists only of these two lines:</p>
<div>
<div>
<pre><code data-lang="nim"><span># module gtkplus</span>
<span>import</span> <span>gintro</span><span>/[</span><span>glib</span><span>,</span> <span>gobject</span><span>,</span> <span>gtk4</span><span>]</span>
<span>export</span> <span>glib</span><span>,</span> <span>gobject</span><span>,</span> <span>gtk4</span></code></pre>
</div>
</div>
<p>Then a user of <span>gintro</span> could just write <span>import gtkplus</span> to have access to all
the modules. Actually for GTK this is not really a good idea, we will tell you more
about the <span>gintro</span> module and maybe about one more of Nim’s GUI libraries in the second half of the book.</p>
<div>
<h3 id="_cyclic_imports">Cyclic Imports</h3>
<p>Generally we try to arrange our own modules in a tree-like bottom-up structure. A module <span>x</span> may define basic
types and simple functions working with these types, and a higher level module <span>y</span> may import all symbols
from module <span>x</span> and extend the functionality. But in rare cases it may be necessary that the modules <span>x</span> and <span>y</span>
import each other, as <span>x</span> has to use types or functions of module <span>y</span>, and vice versa. This case is called cyclic import and is
currently not supported by Nim. Indeed we should generally try to avoid cyclic imports when possible, as cyclic imports
make the software design difficult. But sometimes we can not really avoid these cycles. In that case currently the best solution is,
to put all the concerned data types in a separate low level module, which is then imported from both other modules.
The planned Nim version 2.0 may allow cyclic imports, so this restriction may vanish in the future.</p>
</div>
</div>
</div>
<div>
<h2 id="_include">Include</h2>
<div>
<p>The <span>include</span> statement should be not confused with the <span>import</span> statement. <span>Include</span> just
insert a text file at the position where the <span>include</span> statement occurs. <span>Include</span> can be
used to split very large modules in smaller entities.</p>
</div>
</div>

<div>
<p>
In this part of the book we will introduce you to some of the most important
modules of the Nim standard library. This includes modules for common operations
like the serialization of Nim data types to write them
to external nonvolatile storage and read them back into the program later, or handling command
line options and parameters for programs launched from within a terminal window.
Further we will introduce you to important container data types like hash tables
(sometimes called hash maps in other programming languages) and and various kinds
of set data types. We will also introduce modules for working with regular expressions,
and we will show how simple modules like the times or the random module can
be used. Most modules mentioned in this part will be from the Nim standard library, so that
you will not have to install external packages for that. But there may be some exceptions, e.g. for
some external nimble packages with a very useful functionality and an easy user interface.
</p>
</div>
<div>
<h2 id="_command_line_arguments">Command Line Arguments</h2>
<div>
<p>When we launch a program from inside the terminal window, we can pass it
some additional parameters, e.g. the name of a file to process or option
parameters to influence the behaviour of the program. We have done so
already when we launched the Nim compiler or maybe a text editor from inside our terminal
window. Using command line parameters is convenient when we work from inside a terminal
and there are parameters that we know in advance. A more interactive way to collect
parameters is reading in input while the program is already running, as we did in part II of the
book when processing the list of our friends. We will learn some more details of this interactive
processing of input in the next section.</p>
<p>Nim allows to process command line arguments in the same basic way as all C programs do it,
but Nim’s standard library and some external packages allow also much more advanced handling
of command line arguments. For simple cases the C-like way is sufficient. For C programs
the command line arguments are even coupled very closely to the language itself, the
number of arguments and the list of parameters are the two typical parameters
of the C main() function and are used in this way:</p>
<div>
<div>
<pre><code data-lang="c"><span>// C program expecting one command line argument</span>
<span>// Compile with gcc t.c</span>
<span>#include &lt;stdio.h&gt;
</span><span>int</span> <span>main</span><span>(</span> <span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>*</span><span>argv</span><span>[]</span> <span>)</span> <span>{</span>
  <span>printf</span><span>(</span><span>&#34;Executing program %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>0</span><span>]);</span>
  <span>if</span><span>(</span> <span>argc</span> <span>==</span> <span>2</span> <span>)</span> <span>{</span>
     <span>printf</span><span>(</span><span>&#34;The argument supplied is %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>1</span><span>]);</span>
  <span>}</span>   <span>else</span> <span>if</span><span>(</span> <span>argc</span> <span>&gt;</span> <span>2</span> <span>)</span> <span>{</span>
     <span>printf</span><span>(</span><span>&#34;Too many arguments supplied.</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>}</span>
  <span>else</span> <span>{</span>
     <span>printf</span><span>(</span><span>&#34;One argument expected.</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>}</span>
<span>}</span></code></pre>
</div>
</div>
<p>Here <span>argc</span> is the number of available arguments, and <span>argv</span> is an <span>array</span> containing the
actual arguments in form of strings. These values are passed to each C program by the
OS when the program is launched from inside a terminal. Actually the value of <span>argc</span> is the number
of passed arguments plus one, that is when we specify no arguments at all, <span>argc</span> has the value one.
And <span>argv[0]</span> is always the name of the executed program. We have to know that command line arguments
passed to a program are separated by white space, that is at least by one space or tab character. For this
reason we have to enclose single arguments containing white space in double quotes:</p>
<div>
<div>
<pre>$ gcc t.c -o t
$ ./t Nim two
Executing program ./t
Too many arguments supplied.
$ ./t &#34;Nim two&#34;
Executing program ./a.out
The argument supplied is Nim two</pre>
</div>
</div>
<p>In Nim we have the same functionality available by use of the <span>paramCount()</span>
and <span>paramStr()</span> <span>procs</span>, which we have to import from the <span>os</span> module.
But <span>paramCount()</span> gives us the actual number of parameters, so
when we call our program on the command line without any arguments, <span>paramCount()</span>
will return the value zero. The symbol <span>paramStr()</span> is not a global <span>array</span> variable, but a procedure.
ParamStr(0) gives us the name of our executable, and with arguments greater zero
we get the passed arguments as <span>strings</span> in ascending order. Using an index number
for an argument that was not provided will cause <span>paramStr()</span> to raise an exception.</p>
<p>A argument evaluation similar to our C program from above may look like</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>os</span> <span>import</span> <span>paramCount</span><span>,</span> <span>paramStr</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>echo</span> <span>&#34;Executing program &#34;</span><span>,</span> <span>paramStr</span><span>(</span><span>0</span><span>)</span>
  <span>let</span> <span>argc</span> <span>=</span> <span>paramCount</span><span>()</span> <span>+</span> <span>1</span>
  <span>if</span> <span>argc</span> <span>==</span> <span>2</span><span>:</span>
    <span>echo</span> <span>&#34;The argument supplied is &#34;</span><span>,</span> <span>paramStr</span><span>(</span><span>1</span><span>)</span>
    <span>if</span> <span>paramStr</span><span>(</span><span>1</span><span>)</span> <span>in</span> <span>[</span><span>&#34;-d&#34;</span><span>,</span> <span>&#34;--debug&#34;</span><span>]</span><span>:</span>
      <span>echo</span> <span>&#34;Running in debug mode&#34;</span>
  <span>elif</span> <span>argc</span> <span>&gt;</span> <span>2</span><span>:</span>
    <span>echo</span> <span>&#34;Too many arguments supplied.&#34;</span>
  <span>else</span><span>:</span>
    <span>echo</span> <span>&#34;One argument expected.&#34;</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Using this plain API is OK when we expect one or two arguments, maybe a file name
and an option, like the <span>-d</span> or <span>--debug</span> parameter used in the code above. For more command
line arguments, things get complicated fast, as arguments can be passed in arbitrary orders and
combinations. So you should try one of the available libraries for that case.</p>
<p>References:</p>

</div>
</div>
<div>
<h2 id="_reading_data_from_the_terminal">Reading data from the terminal</h2>
<div>
<p>While using command line arguments is convenient for data like file names or
options that we already know when we launch a program from the terminal window,
often we have to provide textual user input while the program is already running.
Functions for this task are provided by the <span>io</span> module, which is part of the <span>system</span> module,
and which we have not to import explicitly. In one of the introducing sections of the
book we used already the <span>readLine()</span> and the <span>getch()</span> <span>procs</span> for reading in a line of text from the terminal
and for waiting on a single key press event.</p>
<p>For input and output operations in a terminal window the <span>io</span> module defines the three
variables <span>stdin</span>, <span>stdout</span> and <span>stderr</span> of <span>File</span> data type. We will discuss file-based input and output
operations in more detail in part III of the book. Many <span>procs</span> of the <span>io</span> module expects
as first parameter a variable of <span>file</span> type. We can explicitly open a named file to write data
to external media like the SSD, or we can just use the <span>stdin</span> and <span>stdout</span> variables
to read data from the keyboard and to write text to the terminal window. Unlike other named
files, we do not have to call <span>open()</span> or <span>close()</span> on <span>stdin</span> and <span>stdout</span>
to open or close the files, and some other file operations like <span>setFilePos()</span> may not work for
these file variables:</p>
<div>
<div>
<pre>var s: string = stdin.readLine()
stdout.write(s)
stdout.flushFile</pre>
</div>
</div>
<p>We mentioned already, that the <span>readline()</span> function let you type
textual user input, including spaces, and that you have to terminate
your input by pressing the return key to pass the input string to the OS
which forwards the input to our program. This form of input is sometimes
called blocking, as for the time that we wait for user input, our program is really
waiting, it can not do other work til the user has pressed the return key.
For single character input, without the need for pressing actually the return
key, e.g. for a simple <span>yes/no</span> input, you may use the <span>getch()</span> function, which
is also blocking. In a latter section of the book we may show how
we can use threading to actually do some useful work, while we wait for user input.
In the literature <span>stdin</span>, <span>stdout</span> and <span>stderr</span> are often called streams, where <span>stderr</span>
can be used instead of <span>stdout</span> for writing error message. This can be useful
in special cases, when we have an application where we want to redirect
error messages to a file or to separate regular output and error messages.
For more details about these stream or file variables and the use of the <span>stderr</span> variable
you may consult external literature, if you should really need that info.</p>
<p>The <span>io</span> module does not provide read functions for other basic data types like numeric or
boolean types. So we should use <span>readLine()</span> to read the user input in <span>string</span> form, which we can convert
by functions like <span>parseInt()</span>, <span>parseFloat()</span> or similar functions to numeric data. Note that parsing <span>procs</span>
like <span>parseInt()</span> are provided by the module <span>strutils</span> as well as by the module <span>parseutils</span> — one function raises an exception for invalid input,
while the other one returns a boolean value indicating conversion success. Of course we should
handle textual user input always carefully and never just assume that the input is actually valid data.
Some of the modules that can be used for converting textual input data into other data types
like the <span>strutils</span>, <span id="parseutils# and [">strscans</span> modules are described in more detail at the end of this part
of the book.</p>
<p>For advanced user input processing, like cursor movement, colored
display or displaying progress bars, you may also consult the <span>terminal</span> module.
And finally, to create fancy textual user interfaces (TUIs) we recommend to
try external packages like the <span>illwill</span> library.</p>
<p>References:</p>

</div>
</div>
<div>
<h2 id="_writing_text_to_the_terminal_window">Writing text to the terminal window</h2>
<div>
<p>In previous sections we have used the <span>echo()</span> function to write variables
of various data types to the terminal window. The <span>echo()</span> function accepts
multiple arguments, writes the string representation of the passed arguments
to the terminal window and terminates the action by writing the <span>\n</span> character
to move the cursor to the beginning of the next line in the terminal window.
We have already used the <span>write()</span> function from the <span>io</span> module for
the case that we want to write a single <span>string</span> to the terminal without
a terminating newline character. The <span>io</span> module contains some overloaded <span>write()</span>
functions for other basic data types like <span>int</span>, <span>float</span> or <span>bool</span>, and a variant with
a <span>varargs</span> parameter and applied stringify operator, so that <span>write()</span> can be used
like <span>echo</span>, as long as we pass <span>stdout</span> as first parameter. For the actual output operation the C library function <span>fprintf()</span> is used.
Note that write operations to <span>stdout</span> are generally buffered, so the result
of <span>write()</span> operations may remain invisible until we write a <span>string</span> containing
a newline character or until we call the <span>flushfile()</span> function to enforce
the writing of the buffer.</p>
</div>
</div>
<div>
<h2 id="_serializationstoring_data_permanently_on_external_storage">Serialization — storing data permanently on external storage</h2>
<div>
<p>When you start writing larger programs, these programs may create data which you may want to
store permanently on external nonvolatile storage like SSDs or traditional hard disks of your computer.
For textual data this is very easy, as you basically only has to write and read a stream
of unstructured bytes. But when your program deals with object instances, container data
types like sequences or references, things become more complicated. Writing the data
is always easy — you can just convert all the fields of your object data type to strings
and write them to a stream or a file. But the reading back part is much more difficult: You would
have to read in the data as strings and then process each string — maybe converting to a <span>float</span> number — and then assign to the matching field of an object instance.</p>
<p>When your data consists only of value objects and no references, then you may consider
just writing that data in plain binary form to a file and read it back. This strategy seems
to be simple and it is very fast, as no type conversion steps are involved. But at the same time it has some
drawbacks: The stored data can not be checked with tools like a text editor, it can generally not
be used from other programs, and when you should change the data types used in your program, you could
not read back stored files any more.</p>
<p>So we will explain how you can store Nim data types in a human readable text format first.
Two popular text formats are <span>JSON</span> and <span>YAML</span>. JSON is a simple format, which is easy to parse, but not
very good readable for humans. YAML is more complicated, but more flexible and is very good
readable for humans.</p>
<p>For Nim we have already many modules which we can use for storing data in JSON or YAML format available.
The Nim standard library includes the <span>marshal</span> and the <span>json</span> module. The <span>marshal</span> module uses like
the <span>json</span> module the json data file format, is easy to use and simple, but is not really designed
to generate human readable data files, as the stored data is not stored as a sequence of individual lines.
So we will describe and use the <span>json</span> module in this section, which is also easy to use, but has some larger
set of functionality and can generate real human readable text files by use of the pretty() function.</p>
<p>Other available external packages for data serialization are the nim-serialization module set from (<a href="https://github.com/status-im/nim-serialization">https://github.com/status-im/nim-serialization</a>)
and the very powerful but complicated NimYaml implementation (<a href="https://nimyaml.org/">https://nimyaml.org/</a>). We may describe these packages
in part V of the book.</p>
<p>When we have to store and read back Nim data to nonvolatile storage media, we have some serious
points to consider: First we have to handle various data types like integers, floats, strings, objects — and
even the container types like sequences. And we may have to support reference types and maybe also inherited types
and containers filled with heterogeneous, subclassed reference objects. The <span>json</span> module supports all Nim data types
including containers and references, but not heterogeneous sequences.</p>
<p>For our first json example let us assume that we have written a small tool that
let the user create some geometrical shapes, and we want to store the shapes
to a file and read it back. For that we generally use an intermediate step, which
converts the data to a string and the string back to the data object. The string is
then written to a file or stream and read back. Let us start with the string conversion — storing that string and reading it back from the file will be explained soon.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>json</span>

<span>type</span>
  <span>Line</span> <span>=</span> <span>object</span>
    <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>

  <span>Circ</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>x0</span><span>,</span> <span>y0</span><span>:</span> <span>float</span>
    <span>radius</span><span>:</span> <span>float</span>

  <span>Data</span> <span>=</span> <span>object</span>
    <span>lines</span><span>:</span> <span>seq</span><span>[</span><span>Line</span><span>]</span>
    <span>circs</span><span>:</span> <span>seq</span><span>[</span><span>Circ</span><span>]</span>

<span>var</span>
  <span>l1</span> <span>=</span> <span>Line</span><span>(</span><span>x1</span><span>:</span> <span>0</span><span>,</span> <span>y1</span><span>:</span> <span>0</span><span>,</span> <span>x2</span><span>:</span> <span>5</span><span>,</span> <span>y2</span><span>:</span> <span>10</span><span>)</span>
  <span>c1</span> <span>=</span> <span>Circ</span><span>(</span><span>x0</span><span>:</span> <span>7</span><span>,</span> <span>y0</span><span>:</span> <span>3</span><span>,</span> <span>radius</span><span>:</span> <span>20</span><span>)</span>
  <span>d1</span><span>,</span> <span>d2</span><span>:</span> <span>Data</span>

<span>d1</span><span>.</span><span>lines</span><span>.</span><span>add</span><span>(</span><span>l1</span><span>)</span>
<span>d1</span><span>.</span><span>circs</span><span>.</span><span>add</span><span>(</span><span>c1</span><span>)</span>
<span>d1</span><span>.</span><span>lines</span><span>.</span><span>add</span><span>(</span><span>Line</span><span>(</span><span>x1</span><span>:</span> <span>3</span><span>,</span> <span>y1</span><span>:</span> <span>2</span><span>,</span> <span>x2</span><span>:</span> <span>7</span><span>,</span> <span>y2</span><span>:</span> <span>9</span><span>))</span>
<span>d1</span><span>.</span><span>circs</span><span>.</span><span>add</span><span>(</span><span>Circ</span><span>(</span><span>x0</span><span>:</span> <span>9</span><span>,</span> <span>y0</span><span>:</span> <span>7</span><span>,</span> <span>radius</span><span>:</span> <span>2</span><span>))</span>

<span>let</span> <span>str1</span> <span>=</span> <span>pretty</span><span>(</span><span>%*</span> <span>d1</span><span>)</span> <span># convert the content of variable d1 to a string</span>
<span>echo</span> <span>str1</span> <span># let us see how the strings looks</span>
<span>d2</span> <span>=</span> <span>to</span><span>(</span><span>parseJson</span><span>(</span><span>str1</span><span>),</span> <span>Data</span><span>)</span> <span># read the string back into a data instance</span>
<span>let</span> <span>str2</span> <span>=</span> <span>pretty</span><span>(</span><span>%*</span> <span>d2</span><span>)</span> <span># and verify that we got back the original content</span>
<span>echo</span> <span>str2</span>

<span># assert d1 == d2 would fail</span>
<span>assert</span> <span>str1</span> <span>==</span> <span>str2</span></code></pre>
</div>
</div>
<p>When we run the program we would get this output:</p>
<div>
<div>
<pre>{
  &#34;lines&#34;: [
    {
      &#34;x1&#34;: 0.0,
      &#34;y1&#34;: 0.0,
      &#34;x2&#34;: 5.0,
      &#34;y2&#34;: 10.0
    },
    {
      &#34;x1&#34;: 3.0,
      &#34;y1&#34;: 2.0,
      &#34;x2&#34;: 7.0,
      &#34;y2&#34;: 9.0
    }
  ],
  &#34;circs&#34;: [
    {
      &#34;x0&#34;: 7.0,
      &#34;y0&#34;: 3.0,
      &#34;radius&#34;: 20.0
    },
    {
      &#34;x0&#34;: 9.0,
      &#34;y0&#34;: 7.0,
      &#34;radius&#34;: 2.0
    }
  ]
}
{
  &#34;lines&#34;: [
    {
      &#34;x1&#34;: 0.0,
      &#34;y1&#34;: 0.0,
      &#34;x2&#34;: 5.0,
      &#34;y2&#34;: 10.0
    },
    {
      &#34;x1&#34;: 3.0,
      &#34;y1&#34;: 2.0,
      &#34;x2&#34;: 7.0,
      &#34;y2&#34;: 9.0
    }
  ],
  &#34;circs&#34;: [
    {
      &#34;x0&#34;: 7.0,
      &#34;y0&#34;: 3.0,
      &#34;radius&#34;: 20.0
    },
    {
      &#34;x0&#34;: 9.0,
      &#34;y0&#34;: 7.0,
      &#34;radius&#34;: 2.0
    }
  ]
}</pre>
</div>
</div>
<p>As you can see we converted the instance <span>d1</span> of type <span>Data</span> to a <span>string</span> and then we convert
that string back to variable <span>d2</span> with matching content. We have made intentionally
the <span>Circ</span> a <span>ref</span> <span>object</span>, so we can see that the conversion works for value and reference objects.
In the example program we applied the %* macro to our data instance <span>d1</span> to get a <span>JsonNode</span>, and
finally use the <span>pretty()</span> function to get a nice multi-line string. To fill the variable <span>d2</span> with
the content stored in <span>str1</span>, we first have to apply <span>parseJson()</span> on the <span>string</span> and then use <span>to()</span> to
unmarshal the json node into the matching <span>object</span> type.</p>
<p>Now let us investigate what happens when we try to use the <span>json</span> module with
a container with heterogeneous <span>ref</span> <span>objects</span>. For that we subclass the <span>Disc</span> type
creating a new <span>Arc</span> type:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>json</span>
<span>from</span> <span>math</span> <span>import</span> <span>PI</span>

<span>type</span>
  <span>Line</span> <span>=</span> <span>object</span>
    <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>

  <span>Circ</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>x0</span><span>,</span> <span>y0</span><span>:</span> <span>float</span>
    <span>radius</span><span>:</span> <span>float</span>

  <span>Arc</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Circ</span>
    <span>startAngle</span><span>,</span> <span>endAngle</span><span>:</span> <span>float</span>

  <span>Data</span> <span>=</span> <span>object</span>
    <span>lines</span><span>:</span> <span>seq</span><span>[</span><span>Line</span><span>]</span>
    <span>circs</span><span>:</span> <span>seq</span><span>[</span><span>Circ</span><span>]</span>

<span>var</span>
  <span>d1</span><span>,</span> <span>d2</span><span>:</span> <span>Data</span>

<span>d1</span><span>.</span><span>lines</span><span>.</span><span>add</span><span>(</span><span>Line</span><span>(</span><span>x1</span><span>:</span> <span>0</span><span>,</span> <span>y1</span><span>:</span> <span>0</span><span>,</span> <span>x2</span><span>:</span> <span>5</span><span>,</span> <span>y2</span><span>:</span> <span>10</span><span>))</span>
<span>d1</span><span>.</span><span>circs</span><span>.</span><span>add</span><span>(</span><span>Circ</span><span>(</span><span>x0</span><span>:</span> <span>7</span><span>,</span> <span>y0</span><span>:</span> <span>3</span><span>,</span> <span>radius</span><span>:</span> <span>20</span><span>))</span>
<span>d1</span><span>.</span><span>lines</span><span>.</span><span>add</span><span>(</span><span>Line</span><span>(</span><span>x1</span><span>:</span> <span>3</span><span>,</span> <span>y1</span><span>:</span> <span>2</span><span>,</span> <span>x2</span><span>:</span> <span>7</span><span>,</span> <span>y2</span><span>:</span> <span>9</span><span>))</span>
<span>d1</span><span>.</span><span>circs</span><span>.</span><span>add</span><span>(</span><span>Arc</span><span>(</span><span>x0</span><span>:</span> <span>9</span><span>,</span> <span>y0</span><span>:</span> <span>7</span><span>,</span> <span>radius</span><span>:</span> <span>2</span><span>,</span> <span>startAngle</span><span>:</span> <span>0</span><span>,</span> <span>endAngle</span><span>:</span> <span>PI</span><span>))</span>

<span>echo</span> <span>d1</span><span>.</span><span>circs</span><span>[</span><span>1</span><span>]</span> <span>of</span> <span>Arc</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>Arc</span><span>(</span><span>d1</span><span>.</span><span>circs</span><span>[</span><span>1</span><span>]</span><span>).</span><span>endAngle</span>

<span>let</span> <span>str1</span> <span>=</span> <span>pretty</span><span>(</span><span>%*</span> <span>d1</span><span>)</span>
<span>d2</span> <span>=</span> <span>to</span><span>(</span><span>parseJson</span><span>(</span><span>str1</span><span>),</span> <span>Data</span><span>)</span>
<span>let</span> <span>str2</span> <span>=</span> <span>pretty</span><span>(</span><span>%*</span> <span>d2</span><span>)</span>
<span>echo</span> <span>str2</span>
<span>echo</span> <span>d2</span><span>.</span><span>circs</span><span>[</span><span>1</span><span>]</span> <span>of</span> <span>Arc</span></code></pre>
</div>
</div>
<p>The output of that program looks like this:</p>
<div>
<div>
<pre>true 3.141592653589793
{
  &#34;lines&#34;: [
    {
      &#34;x1&#34;: 0.0,
      &#34;y1&#34;: 0.0,
      &#34;x2&#34;: 5.0,
      &#34;y2&#34;: 10.0
    },
    {
      &#34;x1&#34;: 3.0,
      &#34;y1&#34;: 2.0,
      &#34;x2&#34;: 7.0,
      &#34;y2&#34;: 9.0
    }
  ],
  &#34;circs&#34;: [
    {
      &#34;x0&#34;: 7.0,
      &#34;y0&#34;: 3.0,
      &#34;radius&#34;: 20.0
    },
    {
      &#34;x0&#34;: 9.0,
      &#34;y0&#34;: 7.0,
      &#34;radius&#34;: 2.0
    }
  ]
}
false</pre>
</div>
</div>
<p>While our initial instance <span>d1</span> contains a run-time value of <span>Arc</span> type and so we can access
the <span>endAngle</span> field, we get <span>false</span> as result for the <span>of Arc</span> test for the <span>d2</span> instance. So run-time type
information is lost.</p>
<p>When we have to store different data types in one container, then one solution is to use
object variants, which should work with the <span>json</span> module. Another obvious possibility is
to just copy the data into containers with the appropriate static type before storing to
an external medium and copy them back when we read the data back from external storage.
Will will show an example for that now:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>json</span>
<span>from</span> <span>math</span> <span>import</span> <span>PI</span>

<span>type</span>
  <span>Line</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>

  <span>Circ</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>RootRef</span>
    <span>x0</span><span>,</span> <span>y0</span><span>:</span> <span>float</span>
    <span>radius</span><span>:</span> <span>float</span>

  <span>Arc</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Circ</span>
    <span>startAngle</span><span>,</span> <span>endAngle</span><span>:</span> <span>float</span>

  <span>Data</span> <span>=</span> <span>object</span>
    <span>elements</span><span>:</span> <span>seq</span><span>[</span><span>RootRef</span><span>]</span>

  <span>Storage</span> <span>=</span> <span>object</span>
    <span>lines</span><span>:</span> <span>seq</span><span>[</span><span>Line</span><span>]</span>
    <span>circs</span><span>:</span> <span>seq</span><span>[</span><span>Circ</span><span>]</span>
    <span>arcs</span><span>:</span> <span>seq</span><span>[</span><span>Arc</span><span>]</span>

<span>const</span>
  <span>DataFileName</span> <span>=</span> <span>&#34;MyJsonTest.json&#34;</span>

<span>var</span>
  <span>d1</span><span>,</span> <span>d2</span><span>:</span> <span>Data</span>
  <span>storage1</span><span>,</span> <span>storage2</span><span>:</span> <span>Storage</span>
  <span>outFile</span><span>,</span> <span>inFile</span><span>:</span> <span>File</span>

<span>d1</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>Line</span><span>(</span><span>x1</span><span>:</span> <span>0</span><span>,</span> <span>y1</span><span>:</span> <span>0</span><span>,</span> <span>x2</span><span>:</span> <span>5</span><span>,</span> <span>y2</span><span>:</span> <span>10</span><span>))</span>
<span>d1</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>Circ</span><span>(</span><span>x0</span><span>:</span> <span>7</span><span>,</span> <span>y0</span><span>:</span> <span>3</span><span>,</span> <span>radius</span><span>:</span> <span>20</span><span>))</span>
<span>d1</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>Line</span><span>(</span><span>x1</span><span>:</span> <span>3</span><span>,</span> <span>y1</span><span>:</span> <span>2</span><span>,</span> <span>x2</span><span>:</span> <span>7</span><span>,</span> <span>y2</span><span>:</span> <span>9</span><span>))</span>
<span>d1</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>Arc</span><span>(</span><span>x0</span><span>:</span> <span>9</span><span>,</span> <span>y0</span><span>:</span> <span>7</span><span>,</span> <span>radius</span><span>:</span> <span>2</span><span>,</span> <span>startAngle</span><span>:</span> <span>0</span><span>,</span> <span>endAngle</span><span>:</span> <span>PI</span><span>))</span>

<span>for</span> <span>el</span> <span>in</span> <span>d1</span><span>.</span><span>elements</span><span>:</span>
  <span>if</span> <span>el</span> <span>of</span> <span>Arc</span><span>:</span>
    <span>storage1</span><span>.</span><span>arcs</span><span>.</span><span>add</span><span>(</span><span>Arc</span><span>(</span><span>el</span><span>))</span>
  <span>elif</span> <span>el</span> <span>of</span> <span>Circ</span><span>:</span>
    <span>storage1</span><span>.</span><span>circs</span><span>.</span><span>add</span><span>(</span><span>Circ</span><span>(</span><span>el</span><span>))</span>
  <span>elif</span> <span>el</span> <span>of</span> <span>Line</span><span>:</span>
    <span>storage1</span><span>.</span><span>lines</span><span>.</span><span>add</span><span>(</span><span>Line</span><span>(</span><span>el</span><span>))</span>
  <span>else</span><span>:</span>
    <span>assert</span><span>(</span><span>false</span><span>)</span>

<span>let</span> <span>str1</span> <span>=</span> <span>pretty</span><span>(</span><span>%*</span> <span>storage1</span><span>)</span>

<span>if</span> <span>not</span> <span>open</span><span>(</span><span>outFile</span><span>,</span> <span>DataFilename</span><span>,</span> <span>fmWrite</span><span>):</span>
  <span>echo</span> <span>&#34;Could not open file for storing data&#34;</span>
  <span>quit</span><span>()</span>
<span>outFile</span><span>.</span><span>write</span><span>(</span><span>str1</span><span>)</span>
<span>outFile</span><span>.</span><span>close</span>

<span>if</span> <span>not</span> <span>open</span><span>(</span><span>inFile</span><span>,</span> <span>DataFilename</span><span>,</span> <span>fmRead</span><span>):</span>
  <span>echo</span> <span>&#34;Could not open file for recovering data&#34;</span>
  <span>quit</span><span>()</span>
<span>let</span> <span>str2</span> <span>=</span> <span>inFile</span><span>.</span><span>readAll</span><span>()</span>
<span>inFile</span><span>.</span><span>close</span>

<span>assert</span> <span>str1</span> <span>==</span> <span>str2</span>

<span>storage2</span> <span>=</span> <span>to</span><span>(</span><span>parseJson</span><span>(</span><span>str2</span><span>),</span> <span>Storage</span><span>)</span>

<span>for</span> <span>el</span> <span>in</span> <span>storage2</span><span>.</span><span>lines</span><span>:</span>
  <span>d2</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>el</span><span>)</span>
<span>for</span> <span>el</span> <span>in</span> <span>storage2</span><span>.</span><span>circs</span><span>:</span>
  <span>d2</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>el</span><span>)</span>
<span>for</span> <span>el</span> <span>in</span> <span>storage2</span><span>.</span><span>arcs</span><span>:</span>
  <span>d2</span><span>.</span><span>elements</span><span>.</span><span>add</span><span>(</span><span>el</span><span>)</span>

<span>for</span> <span>el</span> <span>in</span> <span>d2</span><span>.</span><span>elements</span><span>:</span>
  <span>if</span> <span>el</span> <span>of</span> <span>Arc</span><span>:</span>
    <span>echo</span> <span>&#34;found arc with endAngle: &#34;</span><span>,</span> <span>Arc</span><span>(</span><span>el</span><span>).</span><span>endAngle</span></code></pre>
</div>
</div>
<p>For this example program we use OOP programming style and keep all the geometric object instances as
references in a single sequence. Note that doing this is not always a good idea, as this OOP style with
the use of references and dynamic run-time dispatch can be slower due to many small heap allocations for
each <span>ref</span> <span>object</span> and due to the dynamic dispatch (<span>if</span> el <span>of</span> …​) overhead. Using multiple, homogeneous sequences with value types for each of our
data types can be a better solution, and in that way you have more control whenever you process the data, for drawing
them on the screen or user interaction for example. Maybe you want to draw all the lines first?
But there can be situations where we really need to have all the objects as references in a single container.
A typical situation is, that we use an <span>RTree</span> for fast object location. <span>RTrees</span> are data structures, that can store
two dimensional or multidimensional geometric object and their rectangular bounding boxes in a tree-like fashion
for fast object location. This may be used in a drawing program, so that coordinates of a user mouse click can be fast
matched to an object. For such a use case we would really prefer to have all the object instances available in one single <span>RTree</span>,
and not use one <span>RTree</span> data structure for each object shape.</p>
<p>Our program defines an additional <span>Storage</span> data type, which contains homogeneous sequences for each possible geometric shape.
We then copy all our <span>ref</span> <span>objects</span> from the elements sequence in the matching sequences of the storage object using the
dynamic <span>of</span> type query to select the exactly matching sequence.</p>
<p>After that we can use the already known json functions to serialize the storage object into a <span>string</span>, store the string
to a file, read it back and deserialize the data again into a different variable of <span>Storage</span> data type. Finally we use a simple <span>for</span> loop
to copy the <span>ref</span> <span>objects</span> from the temporary storage <span>object</span> into a <span>Data</span> variable called d2. For storing the data to a external
nonvolatile medium we use the <span>File</span> data type and the related functions <span>open()</span>, close, <span>write()</span> and <span>read()</span>. Their use should be
obvious: We pass a uninitialized variable of <span>File</span> data type, a file name and a file mode to <span>open()</span>, use <span>write()</span> to write
the whole string, and use <span>readAll()</span> to read the data back. When done with each file we use <span>close()</span> to close the file.
The <span>File</span> data type is part of the <span>io</span> module, which is again part of module <span>system</span>, so we don’t have to import these modules.
We could have used as an alternative also the <span>streams</span> module. We will learn some more details about the <span>File</span> data type
and the <span>streams</span> module in later sections of the book.</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
We should mention that unfortunately live is not always that easy, as sometimes we can not
freely select the textual output format. Imagine that you create a CAD (computer aided design) tool
that should be compatible with another existing tool. In this case the textual storage format
is already defined by the existing tool, and generally that format does not match the json or
yaml file format. Even when the format should be one of these, matching it exactly would be difficult.
While writing out own data in that foreign format is still not really difficult, as we can just write
single matching strings, reading in the textual data is more complicated: Generally we would read the input file line by line and
we would have to inspect and interpret each input string, maybe by use of regular expressions or a custom parser.
That generally includes handling of missing or invalid data.
</td>
</tr>
</tbody></table>
</div>
<p>References:</p>

</div>
</div>
<div>
<h2 id="_streams_and_files">Streams and Files</h2>
<div>
<p>In the previous section we learned how we can store structured data like
a sequence of objects in human readable form to nonvolatile media
by use of the <span>json</span> module.</p>
<p>Text in form of a single <span>string</span> or in form of a container holding
multiple <span>strings</span> is some kind of unstructured data which we can
write directly to nonvolatile storage, and later read it back.
We can do the same with containers of basic, unstructured data types
like integer or floating point numbers, and with some restrictions we can even
write <span>tuples</span> or objects directly as raw bits and bytes to external storage and read
it back later. Of course this way the stored data is a binary blob, which can not
be read or modified by other tools like a text editor. But that may be not
intended or advantageous at all, maybe we do scientific data processing with
a single tool, and we just want to temporary store the data and continue
with the processing later.</p>
<div>
<h3 id="_files">Files</h3>
<p>For storing unstructured data Nim provides the <span>io</span> module with the <span>File</span>
data type and related <span>procs</span>, and the <span>streams</span> module with the <span>Stream</span> data type
and related <span>procs</span>. While a <span>File</span> in Nim is currently only a pointer to a C file, the <span>streams</span>
module has a higher abstraction level. Although the Nim language does not directly support
interfaces, the <span>Stream</span> data type of the <span>streams</span> module is some form of an interface,
which is implemented by a <span>StringStream</span> and a <span>FileStream</span> data type. Internally this interface
concept is realized by storing a set of function pointers in the <span>Stream</span> instance.</p>
<p>When we have to store unstructured data like text it is not always clear if we better should use
<span>Files</span> or <span>Streams</span>. <span>Streams</span> may be the better choice when we (also) want to use a <span>string</span> as data source like a file
or when we need the <span>peek()</span> functions of the <span>streams</span> module to access data without advancing the position
in the stream.</p>
<p>We will use the <span>File</span> data type of the <span>io</span> module first. As the <span>io</span> module is part of the <span>system</span> module, we do
not have to import it before we can use it. The principle usage of files is, that we call the function <span>open()</span> to open
a file with given name, call some <span>procs</span> to write or read data, and finally <span>close()</span> the file.
While Nim support destructors when we compile with --gc:arc or --gc:orc, the <span>io</span> module
does not yet use them, so we should actually call close() to close the file.</p>

<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>os</span> <span>import</span> <span>fileExists</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>const</span> <span>FN</span> <span>=</span> <span>&#34;NoImportantData&#34;</span>
  <span>if</span> <span>os</span><span>.</span><span>fileExists</span><span>(</span><span>FN</span><span>):</span>
    <span>echo</span> <span>&#34;File exists, we may overwrite important data&#34;</span>
    <span>quit</span><span>()</span>
  <span>var</span> <span>f</span><span>:</span> <span>File</span> <span>=</span> <span>open</span><span>(</span><span>FN</span><span>,</span> <span>fmWrite</span><span>)</span>
  <span>f</span><span>.</span><span>write</span><span>(</span><span>&#34;Hello &#34;</span><span>)</span>
  <span>f</span><span>.</span><span>writeLine</span><span>(</span><span>&#34;World!&#34;</span><span>)</span>
  <span>f</span><span>.</span><span>writeLine</span><span>(</span><span>3.1415</span><span>)</span>
  <span>f</span><span>.</span><span>close</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Running that program will create a text file with this content in the current working directory:</p>

<p>At the start of our function we check if a file with that name already exists in the current working directory by using the function <span>os.fileExists()</span>
to ensure that we do not overwrite important data.</p>
<p>Module <span>io</span> provides multiple overloaded <span>open()</span> <span>procs</span>. We use here a variant
which returns a file, and raises an exception for the unlikely case of an error.
We provide a file name and a file mode as parameters. We use mode <span>fmWrite</span> as we want
to create a new file. Note that <span>fmWrite</span> would clear the content of an existing file, so
we can not use <span>fmWrite</span> to append data to an existing file. We would have to use
<span>fmReadWriteExisting</span> or <span>fmAppend</span> to append data to an already existing file.
As this <span>open()</span> <span>proc</span> can raise an exception, it may make sense to enclose it
in a try/except block, or we could use a <span>open()</span> variant which returns a boolean value to indicate success instead.
When the file is successfully opened, we can use <span>procs</span> like <span>write()</span> or <span>writeLine()</span> to
write text <span>strings</span> to the file. Both <span>procs</span> accept multiple arguments and apply the stringify operator
<span>$</span> on them before writing the content. <span>WriteLine()</span> writes a <span>&#39;\n&#39;</span> after the last argument to start a new line.
When done we call <span>close()</span> to close the file. The operating system would close the file for us when our program terminates, so
calling close is not that important, but when we open many files without closing them we may get
errors from the operating system finally about too many open files and our program may fail or terminate.</p>
<p>The <span>close()</span> <span>proc</span> gets passed the file not as a var parameter, so it can not set the file
to value nil. When the file has the value nil, then the <span>close()</span> call is ignored, but when we would call
<span>close()</span> multiple times with a non <span>nil</span> argument we get a program crash.
We may use the try/finally or the defer construct to ensure that we really close the file when done.</p>
<p>The <span>io</span> module provides some <span>procs</span> like <span>writeBuffer()</span>, <span>writeBytes()</span> or <span>writeChars()</span> which gives us
as return value the actual number of bytes written. This return value should generally match
the requested number of bytes to write, but can be smaller when the write operation fully
or partially failed, e.g. because the storage medium had no capacity left.</p>
<p>When performance really matters, we should note that passing non-string arguments
to <span>write()</span> or <span>writLine()</span> <span>procs</span> using their optional auto-stringify for us, involves
allocation of new <span>strings</span> and cost some performance. When we have in our program already
a <span>string</span> variable available, it can be faster to convert our data into that variable first and then pass
that variable to the <span>write()</span> or <span>writeLine()</span> <span>procs</span>.</p>
<p>Reading <span>strings</span> from a file works very similar:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>f</span><span>:</span> <span>File</span>
  <span>try</span><span>:</span>
    <span>f</span> <span>=</span> <span>open</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>fmRead</span><span>)</span>
    <span>echo</span> <span>f</span><span>.</span><span>readLine</span>
    <span>echo</span> <span>f</span><span>.</span><span>readLine</span>
  <span>finally</span><span>:</span>
    <span>if</span> <span>f</span> <span>!=</span> <span>nil</span><span>:</span> <span># test for nil not really necessary, close() would ignore the call for f == nil</span>
      <span>f</span><span>.</span><span>close</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The <span>readLine()</span> <span>proc</span> reads in a line of text. The LF, CR or CRLF line end markers
are not part of the returned text string. Of course we may get an
empty string with length zero back when we read a line which
immediately starts with LF, CR or CRLF, or we may get back a <span>string</span>
with no visible characters but only a few spaces or tabulator characters <span>&#39;\t&#39;</span>
when a line contains only white space.
When our <span>read()</span> operations have moved the actual file io position to the
end of the file, and we try to read more content, then an exception is raised.</p>
<p>The <span>io</span> module provides a <span>readLine()</span> <span>proc</span> that returns a newly allocated <span>string</span>,
and one that takes an existing <span>string</span> as <span>var</span> parameter. The later may be a bit faster,
as it can avoid the allocation of a new buffer when the passed <span>string</span> has already enough capacity.</p>
<p>The <span>io</span> module provides a function called <span>endOfFile()</span> with a boolean result
which we can use to check if the end of file position is already reached.
The provided functions <span>readBuffer()</span>, <span>readBytes()</span> or <span>readChars()</span> return
the actual number of bytes read, which can be smaller than the requested value when
the end of the file is reached earlier. Currently <span>readChars()</span> checks if the passed
<span>openArray[char]</span> has enough capacity for the request, but <span>readBytes()</span> does no
check!</p>
<p>We can use also the <span>lines()</span> iterator to iterate over the lines of a text file, or use the <span>readLines()</span>
proc to read the content line by line.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>f</span><span>:</span> <span>File</span>
  <span>f</span> <span>=</span> <span>open</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>fmRead</span><span>)</span>
  <span>for</span> <span>str</span> <span>in</span> <span>f</span><span>.</span><span>lines</span><span>:</span> <span># iterator</span>
    <span>echo</span> <span>str</span>
  <span>f</span><span>.</span><span>setFilePos</span><span>(</span><span>0</span><span>)</span> <span># read again from start index 0</span>
  <span>var</span> <span>s</span><span>:</span> <span>string</span>
  <span>while</span> <span>f</span><span>.</span><span>readLine</span><span>(</span><span>s</span><span>):</span> <span># proc</span>
    <span>echo</span> <span>s</span>
  <span>f</span><span>.</span><span>close</span>
  <span>var</span> <span>sq</span> <span>=</span> <span>readLines</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>2</span><span>)</span> <span># read lines to seq of strings</span>
  <span>echo</span> <span>sq</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>As iterating over the whole file line by line moves
the actual file position to the end of the file we called <span>setFilePos()</span> to move again to the start position.
The <span>readLines()</span> <span>proc</span> takes a filename
and the number of lines to read as parameters and returns a <span>seq</span> of <span>strings</span>. When the
file does not contain at least the number of requested lines an EOF exception is raised.
Another provided <span>proc</span> is <span>readAll()</span> which reads the whole file content into a returned <span>string</span> variable.
For <span>readAll()</span> to work the actual file position has to be the the start of the file. In case of an
error an exception is raised.</p>
<p>We can also write and read binary data directly to a file, without converting it
to (human readable) strings first:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>f</span><span>:</span> <span>File</span>
  <span>f</span> <span>=</span> <span>open</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>fmWrite</span><span>)</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span> <span>=</span> <span>123</span>
  <span>var</span> <span>x</span><span>:</span> <span>float</span> <span>=</span> <span>3.1415</span>
  <span>assert</span> <span>f</span><span>.</span><span>writeBuffer</span><span>(</span><span>addr</span><span>(</span><span>x</span><span>),</span> <span>sizeof</span><span>(</span><span>x</span><span>))</span> <span>==</span> <span>sizeof</span><span>(</span><span>x</span><span>)</span>
  <span>assert</span> <span>f</span><span>.</span><span>writeBuffer</span><span>(</span><span>addr</span><span>(</span><span>i</span><span>),</span> <span>sizeof</span><span>(</span><span>i</span><span>))</span> <span>==</span> <span>sizeof</span><span>(</span><span>i</span><span>)</span>
  <span>f</span><span>.</span><span>close</span>
  <span>f</span> <span>=</span> <span>open</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>fmRead</span><span>)</span>
  <span>assert</span> <span>f</span><span>.</span><span>readBuffer</span><span>(</span><span>addr</span><span>(</span><span>x</span><span>),</span> <span>sizeof</span><span>(</span><span>x</span><span>))</span> <span>==</span> <span>sizeof</span><span>(</span><span>x</span><span>)</span>
  <span>assert</span> <span>f</span><span>.</span><span>readBuffer</span><span>(</span><span>addr</span><span>(</span><span>i</span><span>),</span> <span>sizeof</span><span>(</span><span>i</span><span>))</span> <span>==</span> <span>sizeof</span><span>(</span><span>i</span><span>)</span>
  <span>f</span><span>.</span><span>close</span>
  <span>echo</span> <span>i</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>x</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Of course these are low level, dangerous operations. While <span>writeBuffer()</span> should never crash
our program, <span>readBuffer()</span> can do that easily when we specify wrong sizes or destination addresses, as that may overwrite
other data unintentionally. So we would generally not use these <span>procs</span> directly but write more safe
helper <span>procs</span>, when we really need or want this form of binary file access. Fast storing big data sets with restricted hardware may
be an use case, e.g. storing a <span>float32</span> takes only 4 bytes on the storage medium and file io is fast, while
that number as human readable digits may need more than 8 bytes (1.234567E3) and converting to
<span>string</span> and and parsing back costs some time.</p>
<p>In the same way we can use <span>writeBuffer()</span> and <span>readBuffer()</span> to store <span>tuples</span>, <span>objects</span> and <span>arrays</span>
or sequences of these directly in binary form:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>x</span><span>:</span> <span>float</span>
    <span>i</span><span>:</span> <span>int</span>
    <span>b</span><span>:</span> <span>bool</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>O</span><span>]</span>
  <span>s</span><span>.</span><span>add</span><span>(</span><span>O</span><span>(</span><span>x</span><span>:</span> <span>3.1415</span><span>,</span> <span>i</span><span>:</span> <span>12</span><span>,</span> <span>b</span><span>:</span> <span>true</span><span>))</span>
  <span>var</span> <span>f</span><span>:</span> <span>File</span>
  <span>f</span> <span>=</span> <span>open</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>fmWrite</span><span>)</span>
  <span>assert</span> <span>f</span><span>.</span><span>writeBuffer</span><span>(</span><span>addr</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>),</span> <span>sizeof</span><span>(</span><span>O</span><span>)</span> <span>*</span> <span>s</span><span>.</span><span>len</span><span>)</span> <span>==</span> <span>sizeof</span><span>(</span><span>O</span><span>)</span> <span>*</span> <span>s</span><span>.</span><span>len</span>
  <span>f</span><span>.</span><span>close</span>
  <span>f</span> <span>=</span> <span>open</span><span>(</span><span>&#34;NoImportantData&#34;</span><span>,</span> <span>fmRead</span><span>)</span>
  <span>var</span> <span>s2</span> <span>=</span> <span>newSeq</span><span>[</span><span>O</span><span>]</span><span>(</span><span>1</span><span>)</span>
  <span>assert</span> <span>f</span><span>.</span><span>readBuffer</span><span>(</span><span>addr</span><span>(</span><span>s2</span><span>[</span><span>0</span><span>]</span><span>),</span> <span>sizeof</span><span>(</span><span>O</span><span>)</span> <span>*</span> <span>s2</span><span>.</span><span>len</span><span>)</span> <span>==</span> <span>sizeof</span><span>(</span><span>O</span><span>)</span> <span>*</span> <span>s2</span><span>.</span><span>len</span>
  <span>f</span><span>.</span><span>close</span>
  <span>echo</span> <span>s2</span><span>[</span><span>0</span><span>]</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Output should look like</p>
<div>
<div>
<pre>(x: 3.1415, i: 12, b: true)</pre>
</div>
</div>
<p>But of course this is dangerous and fragile. We just show that example as beginner
generally ask about it, and may want to try it at least once. Obviously this can
only
work when the <span>tuples</span> or <span>objects</span> contain only plain data types, that is no <span>string</span>, no
references and of course no other nested container types like sequences or tables. And reading back
data may fail when we use a different OS or a different compiler version.</p>
<p>The <span>io</span> module provides the <span>File</span> variables <span>stdin</span>, <span>stdout</span> and <span>stderr</span>,
which are the standard input, output and error streams.
Sometimes we use
<span>stdout.write()</span> instead of the common <span>echo()</span> <span>proc</span> when we want to write
something to the terminal window without moving the cursor to the next line already.</p>
<p>An important function of the <span>io</span> module is <span>flushFile()</span>, which is used to ensure that
all buffer content of buffered files is actually written to the file. This is important
when we use the <span>stdout</span> <span>File</span> variable, maybe to ask the user a question in the terminal window.
We would call <span>sdtout.flushFile()</span> to ensure that the user really sees the text on the screen
immediately. The <span>echo()</span> <span>proc</span> calls <span>flushFile()</span> automatically after each output operation.
When we close a file <span>flushFile()</span> should be called automatically, but when
our program is terminated without calling <span>close()</span> it may depend on the actual implementation and operating system</p>
<p>The <span>io</span> module provides some more useful procedures, but we will
stop this introducing section here and continue with the <span>streams</span> module in the next section.</p>
<p>References:</p>

</div>
<div>
<h3 id="_streams">Streams</h3>
<p>A stream is an abstract interface for performing certain I/O operations, which was introduced
by languages like C or Modula-2 decades ago. The <span>streams</span> module of the Nim standard library
provides a <span>FileStream</span> and a <span>StringStream</span> implementation, which behaves very similar.
Nim’s <span>streams</span> module provides similar functions as the <span>io</span> module with its <span>File</span> data type,
but it can operate on <span>strings</span> instead of on <span>Files</span>, and it provides a set of <span>peek()</span> functions
to access data at the current read position without moving forward. And some functions are
more robust, for example closing a stream multiple times does not crash the program,
as the first <span>close()</span> call sets the file variable of file streams to <span>nil</span>, so that following <span>close()</span> calls are ignored.
Currently the <span>streams</span> module does not support automatically closing of streams when
they go out of scope.</p>
<p>We can create a new <span>FileStream</span> by calling the overloaded <span>procs</span> <span>newFileStream()</span>
with an already opened file or a filename as parameter, or we can use <span>openFileStream()</span>.
The later raises an exception when the stream can not be opened, while the former <span>procs</span>
just return nil. We can write and read textual data with the <span>streams</span> module in a very similar way as we did it with the
<span>io</span> module and the <span>File</span> data type:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>os</span> <span>import</span> <span>fileExists</span>
<span>import</span> <span>streams</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>const</span> <span>SN</span> <span>=</span> <span>&#34;NoImportantData&#34;</span> <span># stream name</span>
  <span>if</span> <span>os</span><span>.</span><span>fileExists</span><span>(</span><span>SN</span><span>):</span>
    <span>echo</span> <span>&#34;File exists, we may overwrite important data&#34;</span>
    <span>quit</span><span>()</span>
  <span>var</span> <span>fstream</span> <span>=</span> <span>newFileStream</span><span>(</span><span>SN</span><span>,</span> <span>fmReadWrite</span><span>)</span>
  <span>if</span> <span>fstream</span> <span>!=</span> <span>nil</span><span>:</span>
    <span>fstream</span><span>.</span><span>write</span><span>(</span><span>123</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
    <span>fstream</span><span>.</span><span>writeLine</span><span>(</span><span>3.1415</span><span>)</span>
    <span>fstream</span><span>.</span><span>setPosition</span><span>(</span><span>0</span><span>)</span>
    <span>let</span> <span>l</span> <span>=</span> <span>fstream</span><span>.</span><span>readLine</span><span>()</span>
    <span>fstream</span><span>.</span><span>close</span><span>()</span>
    <span>assert</span> <span>l</span> <span>==</span> <span>&#34;123 3.1415&#34;</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>We test again if a file with that name already exists. Then we try to create a
new <span>FileStream</span> by using file mode <span>fmReadWrite</span>, so that we can write and
read from that file. Finally we write two numbers, which are automatically
converted to <span>strings</span>, set the file position back to the beginning and verify
what we wrote by reading it in again, before we close the stream.</p>
<p>In a very similar way we can write to and read from <span>string</span> streams</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>streams</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>stream</span> <span>=</span> <span>newStringStream</span><span>()</span>
  <span>stream</span><span>.</span><span>write</span><span>(</span><span>123</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
  <span>stream</span><span>.</span><span>writeLine</span><span>(</span><span>3.1415</span><span>)</span>
  <span>stream</span><span>.</span><span>setPosition</span><span>(</span><span>0</span><span>)</span>
  <span>let</span> <span>l</span> <span>=</span> <span>stream</span><span>.</span><span>readLine</span><span>()</span>
  <span>stream</span><span>.</span><span>close</span><span>()</span>
  <span>assert</span> <span>l</span> <span>==</span> <span>&#34;123 3.1415&#34;</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>In the example above we do not test if the stream variable is not <span>nil</span>, as
<span>newStringStream()</span> should never fail.</p>
<p>For buffered streams we can call <span>flush()</span> to ensure that the buffer content (of file streams) is written,
similar as we can do it for plain <span>Files</span> of the <span>io</span> module.
Instead of <span>io.endofFile()</span> we use the <span>proc</span> <span>atEnd()</span> to test if the current stream position
is already at the end of the stream. Functions <span>getPosition()</span> and <span>setPosition()</span> are
available to query or set the actual position in the stream. While the <span>io</span> module
with its <span>File</span> data type supports for <span>io.setFilePos()</span> although position modes relative to the actual position or relative to the file end,
<span>streams.setPosition()</span> use always absolute values, that is positions measured from the beginning of the stream.
The <span>streams</span> module provides also the low level <span>procs</span> <span>readData()</span> and <span>readDataStr()</span>
which reads data to a memory region or into a <span>string</span> and returns the actual number of bytes read
to indicate success. And as for the <span>io</span> module a <span>proc</span> <span>readAll()</span> is available to read all data
of a stream into the returned <span>string</span> variable.</p>
<p>The <span>procs</span> <span>writeLine()</span> writes the passed arguments always as <span>strings</span>. The overloaded <span>write()</span>
<span>procs</span> with <span>varargs</span> arguments write the passed values as <span>strings</span> and apply the stringify operator <span>$</span>
if necessary. The same does the <span>writeLine()</span> <span>proc</span>, but it writes a newline character
when all passed variables have been written. One more overloaded write <span>proc</span> for single string parameters exist.</p>
<p>But for single non string arguments a generic <span>write()</span> <span>proc</span> is used, which writes numbers
(and other data types like boolean types or single characters) directly in binary form without converting them to <span>strings</span>.</p>
<p>To read the binary numbers back we can use functions like <span>readFloat64()</span> which have a
well defined return type and read a fixed number of bytes. Or we can use the generic <span>read()</span> <span>proc</span>
which accepts a <span>var</span> parameter which defines the data type that we intend to read in binary form.
Additional to the various <span>read()</span> <span>procs</span> the <span>streams</span>
module provides a set of <span>peek()</span> <span>procs</span> which reads data in without moving the actual
position in the stream forward. This may be useful for parsing of files, as we can
read the same information multiple times easily. Internally the <span>peek()</span> functions uses
a call of <span>setPosition()</span> to save the current position and one more call of <span>setPosition()</span>
to set back the old position to the initial value, so <span>peek()</span> has some overhead.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>streams</span>
<span>from</span> <span>os</span> <span>import</span> <span>getFileSize</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>const</span> <span>SN</span> <span>=</span> <span>&#34;NoImportantData&#34;</span> <span># stream name</span>
  <span>var</span> <span>fstream</span> <span>=</span> <span>newFileStream</span><span>(</span><span>SN</span><span>,</span> <span>fmReadWrite</span><span>)</span>
  <span>if</span> <span>fstream</span> <span>!=</span> <span>nil</span><span>:</span>
    <span>fstream</span><span>.</span><span>write</span><span>(</span><span>&#34;012&#34;</span><span>)</span> <span># write a 3 byte string</span>
    <span>var</span> <span>pi</span><span>:</span> <span>float64</span> <span>=</span> <span>3.1415</span>
    <span>fstream</span><span>.</span><span>write</span><span>(</span><span>pi</span><span>)</span> <span># write as 8 byte binary blob</span>
    <span>fstream</span><span>.</span><span>setPosition</span><span>(</span><span>0</span><span>)</span> <span># prepare for reading from start</span>
    <span>var</span> <span>i16</span><span>:</span> <span>int16</span>
    <span>i16</span> <span>=</span> <span>fstream</span><span>.</span><span>peekint16</span> <span># read first 2 bytes as int16, do not change actual position</span>
    <span>assert</span> <span>i16</span> <span>==</span> <span>&#39;0&#39;</span><span>.</span><span>ord</span> <span>+</span> <span>&#39;1&#39;</span><span>.</span><span>ord</span> <span>*</span> <span>256</span>
    <span>var</span> <span>i8</span><span>:</span> <span>int8</span>
    <span>i8</span> <span>=</span> <span>fstream</span><span>.</span><span>readInt8</span> <span># read back one byte</span>
    <span># fstream.read(i8) # does work also</span>
    <span>assert</span> <span>i8</span> <span>==</span> <span>&#39;0&#39;</span><span>.</span><span>ord</span> <span># char(0) has position 48 in ASCII table</span>
    <span>assert</span> <span>i8</span> <span>==</span> <span>48</span>
    <span>var</span> <span>buffer</span><span>:</span> <span>array</span><span>[</span><span>2</span><span>,</span> <span>char</span><span>]</span>
    <span>fstream</span><span>.</span><span>read</span><span>(</span><span>buffer</span><span>)</span>
    <span>let</span> <span>x</span> <span>=</span> <span>fstream</span><span>.</span><span>readFloat64</span> <span># read back in binary form</span>
    <span>assert</span> <span>x</span> <span>==</span> <span>3.1415</span>
    <span>fstream</span><span>.</span><span>close</span><span>()</span>
    <span>assert</span> <span>buffer</span> <span>==</span> <span>[</span><span>&#39;1&#39;</span><span>,</span> <span>&#39;2&#39;</span><span>]</span>
    <span>assert</span> <span>os</span><span>.</span><span>getFileSize</span><span>(</span><span>SN</span><span>)</span> <span>==</span> <span>3</span> <span>+</span> <span>8</span> <span># 3 byte string and a float64</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>In the example above we write a three byte long string and a <span>float64</span> to the file stream.
We call <span>setPosition(0)</span> to read the stream from the beginning again, and then
read in an <span>int16</span> with the function <span>peekint16()</span> without moving the actual position
forward, followed from <span>readInt8()</span>, which moves the actual position one byte forward.
(Instead of <span>readInt8()</span> we could also call <span>read()</span> with variable <span>i8</span> as passed <span>var</span> parameter.)
Then we read in two bytes and finally the <span>float64</span> value at the end of the stream.
Finally we check by use of the function <span>getFileSize()</span> from the <span>os</span> module if
the file has really the expected size.</p>
<p>The <span>streams</span> module provides many functions, and the possible writing data
as <span>strings</span> or in binary form can make using that module a bit daunting at first.
But most <span>procs</span> have examples in the API docs which helps you using it.</p>

<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_string_processing">String Processing</h2>
<div>
<p><span>string</span> processing is a wide area. Nim’s standard library provides various modules
like <span>strutils</span>, <span>parseutils</span> and <span>strscans</span> for supporting this task, and external packages
supports more advanced operation like <span>string</span> pattern matching with regular expressions (regex).
We will start with the <span>strutils</span> module, which is one of the mostly used modules of
the Nim standard library. Then we will introduce some more specialized modules like
<span>strscans</span>, <span>parsecvs</span>, <span>parseutils</span>, <span>strformat</span>, and finally we will give an introduction to use of regular expressions
(regex) and to the use of the parsing expression grammar (PEG). While we describe generally
only modules of Nim’s standard library in this part III of the book, we will make an exception
for regex and PEG. The reason for this is, that regex and PEG use is closely related to
basic string processing and that very powerful external packages exists, which are not
too difficult to use and so needs not too much introductory explanations.</p>
<p>Whenever we do string processing in Nim we should care a bit for performance,
as some <span>string</span> operations can be slow by design. For simple tasks we should
prefer to use functions from the simple modules like <span>strutils</span> when possible, and
use regex or PEG only when really necessary or when performance is uncritical.
And even when we use elementary simple functions like a <span>string</span> split, it is
generally good to have a feeling how the requested operations may work.
Whenever <span>string</span> functions return a <span>string</span> as a result, this implies an allocation, which
takes some time and consumes some memory. An example is the <span>split()</span> operation
which return a sequence of multiple <span>strings</span>. The <span>split()</span> function is easy to use, so
it is often the first choice when we read in lines of text from files and want to process
it. But as for each section of the split line a string is allocated, it may be not as fast as desired.
In some cases the compiler may be able to optimize the slitting process, but
it may be also a good idea to think about other ways to extract the data, maybe by
applying <span>procs</span> from the <span>strscans</span> module which can parse lines directly into passed <span>var</span>
parameters avoiding unnecessary allocations.</p>

<div>
<h3 id="_basic_string_operations">Basic string operations</h3>
<p>We discussed Nim’s <span>string</span> data type already in part II of the book. Remember that a <span>string</span>
in Nim is a variable size container for ASCII characters. <span>strings</span> can be plain ASCII <span>strings</span>, or
the bytes of the <span>string</span> can be interpreted as unicode glyphs. Nim has also a <span>cstring</span> data type,
which was initially introduced to be compatible with the character arrays used in C libraries
as <span>strings</span>, but is now called compatible string as <span>cstrings</span> do also support the JavaScript backend.
Nim <span>strings</span> can be passed directly to C libs, as a Nim <span>string</span> contains a Null terminated buffer
for the actual data, which is identical to a C language <span>string</span>. So whenever we convert a Nim <span>string</span> to a C language <span>string</span>
or pass a Nim <span>string</span> to a C library, this is free of costs, while converting a C <span>string</span> to a Nim <span>string</span> always
means allocating a new Nim <span>string</span> and coping the data content. Technically for a Nim <span>string</span> <span>s</span>
<span>addr s[0]</span> is the C <span>string</span> pointer, called * char in C language. Whenever we pass <span>strings</span> to
C libraries we have to care for the fact that Nim’s garbage collector may deallocate the <span>string</span>
automatically. Most C libs create copies of passed <span>strings</span> when the libs use the <span>string</span> for
a longer time span. GTK for example does this with text for its widgets. But when the
C lib does not copy the <span>string</span> but use it directly for a longer time, then it can occur that
the Nim code frees the <span>string</span>, as the only one Nim variable referring to the <span>string</span> goes
out of scope, but the C library still uses the <span>string</span>. For that rare case we may call
<span>GC_ref()</span> on the <span>string</span> to prevent garbage collection, but that may generate memory leaks then.
For the case that C libs create <span>strings</span>, they provide generally also a function to deallocate the
<span>string</span>. When we use such a C function, it is generally the best solution that we copy
the <span>string</span> from the C lib to a Nim <span>string</span> and immediately deallocate the C <span>string</span> by a
call of the provided <span>free()/dealloc()</span> function. For most C libs there exist good high level bindings
which do not have this issues, so we generally can use the C libs like pure Nim libs.</p>
<p>Nim&#39; s <span>system</span> module provides already some basic <span>string</span> operation like accessing single
characters by the subscript operator <span>[]</span>, accessing slices of multiple adjacent characters, or
joining multiple strings with the <span>&amp;</span> operator. The overloaded <span>add()</span> functions to
append single characters or other <span>strings</span> to existing <span>string</span> variables are also provided by
the <span>system</span> module.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span><span>:</span> <span>string</span> <span>=</span> <span>&#34;I like&#34;</span>
<span>s</span> <span>&amp;=</span> <span>&#34; Nim.&#34;</span>
<span>s</span><span>[</span><span>^</span><span>1</span><span>]</span> <span>=</span> <span>&#39;!&#39;</span>
<span>s</span><span>[</span><span>0</span> <span>..</span> <span>4</span><span>]</span> <span>=</span> <span>&#34;We low&#34;</span> <span># result is: &#34;We love Nim!&#34;</span></code></pre>
</div>
</div>
<p>We start above example by assigning to the <span>string</span> variable <span>s</span> a string literal,
then we append one more <span>string</span> literal, and finally replace the last character
and the first five characters by another character and by another <span>string</span>.
Note that by using the slice operator we can not only replace character ranges, but we can also
replace slices of different length. This way we can also delete ranges in the <span>string</span>
by replacing it with the empty <span>string</span> <span>&#34;&#34;</span>.</p>
<p>The <span>system</span> module also defines the stringify operator <span>$</span>, which converts
expressions to the <span>string</span> presentation when we put it in from of it. <span>procs</span>
like <span>echo()</span> apply the stringify operator automatically on all of its arguments when necessary.
And the <span>system</span> module provides the <span>contains()</span> function which we can use to
test if a <span>string</span> contains a character. Instead of contains we can also use the in operator.</p>
<div>
<div>
<pre>echo $7
echo &#34;Nim&#34;.contains(&#39;i&#39;)
echo &#39;i&#39; in &#34;Nim&#34;</pre>
</div>
</div>
<p>The <span>system</span> module also provides the <span>procs</span> <span>newString()</span> and <span>newStringOfCap()</span>
which are mostly used for optimizing purposes. The function <span>newString(n)</span> creates a <span>string</span>
of length <span>n</span>, but with uninitialized content. We would have to assign characters
to the positions <span>0 .. n-1</span> to create a valid <span>string</span>. Function <span>newStringOfCap()</span> creates
a <span>string</span> with length zero, but with a buffer capacity of <span>n</span> characters.
When we know the needed buffer capacity, or at least a lower bound of it, it makes sense
to create the <span>string</span> with <span>newStringOfCap()</span> with optimal buffer size to avoid reallocations.
Of course we could still append more data, Nim would allocate a larger buffer and copy content.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s1</span> <span>=</span> <span>newString</span><span>(</span><span>&#39;z&#39;</span><span>.</span><span>ord</span> <span>-</span> <span>&#39;a&#39;</span><span>.</span><span>ord</span> <span>+</span> <span>1</span><span>)</span>
<span>for</span> <span>c</span> <span>in</span> <span>items</span><span>(</span><span>&#39;a&#39;</span> <span>..</span> <span>&#39;z&#39;</span><span>):</span>
  <span>s1</span><span>[</span><span>c</span><span>.</span><span>ord</span> <span>-</span> <span>&#39;a&#39;</span><span>.</span><span>ord</span><span>]</span> <span>=</span> <span>c</span>

<span>var</span> <span>s2</span> <span>=</span> <span>newStringOfCap</span><span>(</span><span>32</span><span>)</span> <span># we intend to append not more than 32 characters, but we could do.</span>
<span>for</span> <span>c</span> <span>in</span> <span>&#39;a&#39;</span> <span>..</span> <span>&#39;z&#39;</span><span>:</span>
  <span>s2</span><span>.</span><span>add</span><span>(</span><span>c</span><span>)</span>
<span># s1, s2 is abcdefghijklmnopqrstuvwxyz</span></code></pre>
</div>
</div>
<p>Filling in characters into an existing <span>string</span> by use of the subscript operator
<span>[]</span> is faster than appending single characters with the <span>add()</span> function, because
the <span>add()</span> function has to check if the <span>string</span> has still enough capacity and because
<span>add()</span> has to increase the actual <span>string</span> length by one for each call.</p>
<p>Note that a single character like <span>&#39;a&#39;</span> is very different from a <span>string</span> with only
one character like <span>&#34;a&#34;</span>. A character in Nim is nothing more than a single byte, while
a <span>string</span> — even one with only one character or an empty one — is an opaque entity with length, capacity and a pointer to a data buffer.
When a single character is sufficient, we should
use that and not a <span>string</span> containing a single character. A function call like <span>s.add(&#34;a&#34;)</span>
may produce less optimized code than <span>s.add(&#39;a&#39;)</span>, but maybe the compiler optimized
the former for us. When we consider optimization we may wonder if
in</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span> <span>=</span> <span>&#34;Hello!&#34;</span>
<span>echo</span> <span>s</span>
<span>s</span> <span>=</span> <span>&#34;Bye.&#34;</span>
<span>echo</span> <span>s</span></code></pre>
</div>
</div>
<p>line 3 allocates a new <span>string</span> or just copies the <span>string</span> literal <span>&#34;Bye.&#34;</span>
in the existing data area. Well we would hope for the later of course.</p>
<p>Another interesting question is if in</p>
<div>
<div>
<pre>var s = &#34;Result is: &#34;
var x = 12.34
echo s, x
echo s &amp; $x</pre>
</div>
</div>
<p>we should better use line 3 or line 4. Line 3 looks more clear and we assume that
it also would produce better code, as the actual append operation is avoided.</p>
<p>Often used functions are <span>len()</span> and <span>setLen()</span> to query and set
the length of a <span>string</span>. While <span>len()</span> looks like a function call,
it is a compiler intern function, so calls are fully optimized. So it is OK to write</p>
<div>
<div>
<pre><code data-lang="nim"><span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>s</span><span>.</span><span>len</span><span>():</span>
  <span>echo</span> <span>&#39;*&#39;</span></code></pre>
</div>
</div>
<p>It is not necessary to introduce a temporary variable like let <span>l = s.len()</span> to avoid
many function calls. In C this is different, as in C a call of function <span>strLen()</span> would not only
imply a function call, but that function would really have to count all characters up to
the terminating <span>&#39;\x0&#39;</span> as C <span>strings</span> have no length field.
The function <span>setLen()</span> is generally used to truncate <span>strings</span>. A call like <span>s.setLen(0)</span>
makes <span>s</span> look like a newly allocated <span>string</span>, but its data buffer can be reused. Reusing
<span>strings</span> is generally better for performance than allocating many new <span>strings</span>.
The <span>setLen()</span> function is rarely used to increase the <span>string</span> length — in that case an allocation
of a larger data buffer can occur, and the <span>string</span> would still look the same
as initially all the new <span>string</span> positions would still contain the default binary zero content.
We would have to fill in actual characters by use of the <span>[]</span> subscript operator.
To get the lowest and highest character index of a <span>string</span> we can use <span>s.low</span> and <span>s.high</span>.
<span>s.low</span> should be always return zero, and <span>high()</span> is identical to <span>len() - 1</span>, so <span>high()</span> is
<span>-1</span> for an empty <span>string</span>. Note that while calling <span>high()</span> and <span>len()</span> on a Nim <span>string</span>
has no costs, this may be different to C <span>strings</span> as these have no length field.</p>
<p>The <span>system</span> module provides the overloaded <span>&amp;</span> operator which we can use
to concatenate <span>chars</span> and <span>strings</span>, the <span>&amp;=</span> operator to append a new <span>string</span> to an existing <span>string</span>, and
the <span>add()</span> functions to append characters or <span>strings</span> to an existing <span>string</span>. For
best performance we should try to use always the most simple, &#34;native&#34; operations,
at least as that does not make the code ugly or we know for sure that the compiler optimizes
it for us.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span> <span>=</span> <span>&#34;Ni&#34;</span>
<span>s</span> <span>=</span> <span>s</span> <span>&amp;</span> <span>&#34;m&#34;</span> <span># maybe not a good idea for optimal performance</span>
<span>s</span><span>.</span><span>add</span><span>(</span><span>&#39;m&#39;</span><span>)</span> <span># better</span></code></pre>
</div>
</div>
<p>The function <span>add()</span> can be also used to add a <span>cstring</span> to a <span>string</span>, and the JS backend
allows even to append one <span>cstring</span> to another one by <span>add()</span> calls.</p>
<p>Module <span>system</span> also exports a <span>substr()</span> <span>proc</span> which copies and return a <span>slice</span> of a <span>string</span>.
Overloads with optional first index with default <span>0</span> and optional last index with default
<span>s.high</span> exists.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s</span> <span>=</span> <span>&#34;Hello!&#34;</span>
<span>assert</span> <span>s</span><span>.</span><span>substr</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span> <span>==</span> <span>s</span><span>[</span><span>2</span> <span>..</span> <span>3</span><span>]</span>

<span>s</span> <span>=</span> <span>&#34;ABC&#34;</span>
<span>echo</span> <span>s</span><span>[</span><span>0</span> <span>..</span> <span>5</span><span>]</span> <span># fail</span>
<span>echo</span> <span>s</span><span>.</span><span>substr</span><span>(</span><span>0</span><span>,</span> <span>5</span><span>)</span> <span># index is clipped to s.high</span>
<span>s</span><span>[</span><span>0</span> <span>..</span> <span>5</span><span>]</span> <span>=</span> <span>&#34;&#34;</span> <span># fail</span></code></pre>
</div>
</div>
<p>And of course <span>==</span> and <span>!=</span> operators for <span>string</span> comparison are provided.
To test if a <span>string</span> is empty we can compare with an empty <span>string</span> literal
or test if <span>len()</span> is zero. The later is guaranteed to have best performance, but
the former is a bit shorter and should be not bad performance wise. Some other languages
provide an <span>empty()</span> test function for this, we may define our own when we really want.</p>
<div>
<div>
<pre><code data-lang="nim"><span>if</span> <span>s</span> <span>!=</span> <span>&#34;&#34;</span><span>:</span>
<span>if</span> <span>s</span><span>.</span><span>len</span> <span>!=</span> <span>0</span><span>:</span></code></pre>
</div>
</div>
<p>When we pass a <span>string</span> to a <span>proc</span> that does no operations with it, maybe
it only calls <span>echo()</span> or <span>stdout.write()</span> to print it, then it may have
a tiny performance advantage to pass it as <span>cstring</span>. This is similar
as we may pass sequences as <span>openArray</span> to functions, which
also avoids one level of indirection. Also note, that while a Nim <span>string</span> is
a value type, so we can not test it for <span>nil</span> or return <span>nil</span> from a <span>proc</span>
that shall return a <span>string</span>, this restriction does not hold for <span>cstrings</span>.</p>
</div>
<div>
<h3 id="_module_stringutils">Module stringutils</h3>
<p>Module <span>stringutils</span> provides a set of functions (120 currently) and a few iterators
for simple <span>string</span> operations. Using that functions and iterators is simple in most cases and
generally well explained in the API docs. Remembering which functions exists, their exact name
and the function arguments can be a bit difficult at first. We will introduce in this section some of the
most used or more difficult functions, and give some warnings when the actual performance
may be not as good as expected.</p>
<p>Performance critical operations are generally that one which has to allocate new <span>strings</span> or that has
to shift many characters, like text inserting operations. Note that some functions of this module
like <span>toUpperAscii()</span> work only with the lower and upper ASCII letters. For unicode operations
we may need the <span>unicode</span> module.</p>

<p>The <span>stringutils</span> module support string interpolation by use of the <span>%</span> operator.</p>
<div>
<div>
<pre><code data-lang="nim"><span>echo</span> <span>&#34;The </span><span>$1</span><span> programming language is </span><span>$2</span><span>.&#34;</span> <span>%</span> <span>[</span><span>&#34;best&#34;</span><span>,</span> <span>&#34;Nim&#34;</span><span>]</span>
<span>echo</span> <span>&#34;The </span><span>$#</span><span> programming languages are </span><span>$#</span><span>.&#34;</span> <span>%</span> <span>[</span><span>&#34;most difficult&#34;</span><span>,</span> <span>&#34;C++, Rust and Haskell&#34;</span><span>]</span>
<span>echo</span> <span>&#34;A </span><span>$adj</span><span> programming language is </span><span>$lang</span><span>.&#34;</span> <span>%</span> <span>[</span><span>&#34;adj&#34;</span><span>,</span> <span>&#34;low level&#34;</span><span>,</span> <span>&#34;lang&#34;</span><span>,</span> <span>&#34;assembly&#34;</span><span>]</span>
<span>echo</span> <span>&#34;Let&#39;s learn </span><span>$#</span><span>&#34;</span> <span>%</span> <span>&#34;Nim!&#34;</span>
<span>echo</span> <span>format</span><span>(</span><span>&#34;I know </span><span>$#</span><span> programming languages.&#34;</span><span>,</span> <span>2</span><span>)</span></code></pre>
</div>
</div>
<p>We can use <span>$1</span> up to <span>$9</span> to mark positions where <span>string</span> <span>n</span> from the array should be inserted, or
just <span>$</span> to insert the <span>strings</span> in the order as they appear in the <span>array</span>. We can also use
named insert markers and specify name-value <span>string</span> pairs in the <span>array</span>. For a single
<span>string</span> we can omit the <span>array</span> and pass just as <span>string</span>, and finally we can use the <span>format()</span>
proc to enable stringify for the parameters.</p>
<p>We mentioned already the useful but performance critical set of <span>split()</span> functions:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>let</span> <span>str</span> <span>=</span> <span>&#34;Zero, first, second, third&#34;</span>
<span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>string</span><span>]</span> <span>=</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#34;, &#34;</span><span>)</span>
<span>echo</span> <span>s</span>
<span>echo</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#34;, &#34;</span><span>,</span> <span>0</span><span>)</span>
<span>echo</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#34;, &#34;</span><span>,</span> <span>1</span><span>)</span>
<span>echo</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#34;, &#34;</span><span>,</span> <span>3</span><span>)</span>
<span>echo</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#34;, &#34;</span><span>,</span> <span>4</span><span>)</span></code></pre>
</div>
</div>
<div>
<div>
<pre>@[&#34;Zero&#34;, &#34;first&#34;, &#34;second&#34;, &#34;third&#34;]
@[&#34;Zero, first, second, third&#34;]
@[&#34;Zero&#34;, &#34;first, second, third&#34;]
@[&#34;Zero&#34;, &#34;first&#34;, &#34;second&#34;, &#34;third&#34;]
@[&#34;Zero&#34;, &#34;first&#34;, &#34;second&#34;, &#34;third&#34;]</pre>
</div>
</div>
<p>We used the <span>split()</span> variant which accepts a <span>string</span> as split marker. This function
accepts one optional parameter for the number of splits to execute and returns
a sequence containing the single <span>strings</span>. The split marker <span>string</span>, also called separator,
is removed from the <span>strings</span>. The default value for the number of splits is <span>-1</span> indicating
that we want a split at each separator position. If we specify a positive number <span>n</span>, then only
<span>n</span> splits are executed and the last element of the returned sequence will contain the remainder
of the <span>string</span>. When we specify for the intended splits a value which is larger than the number of contained
split markers, then we get a full split.</p>
<p>The reason why this function is not very fast is that it has to allocate a sequence for the return value
and a new <span>string</span> for each split and one more for the last <span>string</span> or the remainder. For the case that we
do need only the first few <span>strings</span> of the split, it is a good idea to specify the number of actual splits
to increase performance.</p>
<p>The <span>strutils</span> module provides overloaded functions which use single characters as separators or
which accepts a set of characters as separators, so we may split at space, tabulator, comma or semicolon
with {&#39; &#39;, &#39;\t&#39;, &#39;,&#39;, &#39;;&#39;}. And a
function <span>splitWhitespace()</span> is available to split at whitespace like spaces and tabulators, which
removes all the whitespace between the strings. Notice that the <span>split()</span> function for <span>strings</span> or single characters does
one split for each separator, so we can get empty strings as result as in</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>let</span> <span>str</span> <span>=</span> <span>&#34;Zero___first_second__third&#34;</span>
<span>let</span> <span>str2</span> <span>=</span> <span>&#34;Zero first</span><span>\t</span><span>second           third&#34;</span>
<span>echo</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#39;_&#39;</span><span>)</span>
<span>echo</span> <span>str2</span><span>.</span><span>splitWhiteSpace</span><span>()</span>
<span># @[&#34;Zero&#34;, &#34;&#34;, &#34;&#34;, &#34;first&#34;, &#34;second&#34;, &#34;&#34;, &#34;third&#34;]</span>
<span># @[&#34;Zero&#34;, &#34;first&#34;, &#34;second&#34;, &#34;third&#34;]</span></code></pre>
</div>
</div>
<p>An interesting behavior of <span>splitWhiteSpace()</span> is that whitespace at the start or
end of a <span>string</span> is just ignored, while the <span>split()</span> function returns additional empty strings
when the string to split starts or ends with the separator:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>let</span> <span>str</span> <span>=</span> <span>&#34;_Zero_first_second_third_&#34;</span>
<span>let</span> <span>str2</span> <span>=</span> <span>&#34;   Zero first</span><span>\t</span><span>second           third   &#34;</span>
<span>echo</span> <span>str</span><span>.</span><span>split</span><span>(</span><span>&#39;_&#39;</span><span>)</span>
<span>echo</span> <span>str2</span><span>.</span><span>splitWhiteSpace</span><span>()</span>
<span># @[&#34;&#34;, &#34;Zero&#34;, &#34;first&#34;, &#34;second&#34;, &#34;third&#34;, &#34;&#34;]</span>
<span># @[&#34;Zero&#34;, &#34;first&#34;, &#34;second&#34;, &#34;third&#34;]</span></code></pre>
</div>
</div>
<p>Another function is <span>splitLines()</span> which splits a string at CR, LF or CR-LF characters.</p>
<p>For these splitting functions also iterator variants exists, which behave
like the functions with same name. When we limit for the iterators
the number of splits to perform, we may get as last returned value
the remained <span>string</span>. You may consult the API docs for details if necessary.</p>
<p>Functions with names <span>rsplit()</span> are also available which behave like <span>split()</span> but start
the splitting process from the end of the <span>string</span>, so we can get the file extension of
a file name with something like <span>filename.rsplit(1)[^1]</span>.</p>
<p>The functions <span>removePrefix()</span> and <span>removeSuffix()</span> can sometimes help to avoid
expensive split operations. There is an overloaded function that removes all single characters,
all characters from a set or a single string:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>var</span> <span>s</span> <span>=</span> <span>&#34;NNimmm Language&#34;</span>
<span>s</span><span>.</span><span>removePrefix</span><span>(</span><span>&#39;N&#39;</span><span>);</span> <span>echo</span> <span>s</span> <span># immm Language</span>
<span>s</span><span>.</span><span>removePrefix</span><span>({</span><span>&#39;N&#39;</span><span>,</span> <span>&#39;i&#39;</span><span>,</span> <span>&#39;m&#39;</span><span>,</span> <span>&#39; &#39;</span><span>});</span> <span>echo</span> <span>s</span> <span># Language</span>
<span>s</span><span>.</span><span>removePrefix</span><span>(</span><span>&#34;Langu&#34;</span><span>);</span> <span>echo</span> <span>s</span> <span># age</span>
<span>s</span><span>.</span> <span>removeSuffix</span><span>(</span><span>&#34;ge&#34;</span><span>);</span> <span>echo</span> <span>s</span> <span># a</span></code></pre>
</div>
</div>
<p>Other useful functions are <span>startsWith()</span> and <span>endsWith()</span> which accept a single character or a <span>string</span>
and return a boolean value:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>var</span> <span>s</span> <span>=</span> <span>&#34;Nim Language&#34;</span>
<span>echo</span> <span>s</span><span>.</span><span>startsWith</span><span>(</span><span>&#39;N&#39;</span><span>)</span> <span># true</span>
<span>echo</span> <span>s</span><span>.</span><span>startsWith</span><span>(</span><span>&#34;Nim&#34;</span><span>)</span> <span># true</span>
<span>echo</span> <span>s</span><span>.</span><span>endsWith</span><span>(</span><span>&#39;e&#39;</span><span>)</span> <span># true</span>
<span>echo</span> <span>s</span><span>.</span><span>endsWith</span><span>(</span><span>&#34;Programming&#34;</span><span>)</span> <span># false</span></code></pre>
</div>
</div>
<p>An efficient function similar to <span>find()</span> is <span>continuesWith()</span> used like <span>&#34;Nim Language&#34;.continuesWith(&#34;Lang&#34;, 4)</span>
which tests is a <span>string</span> contains a substring at position <span>n</span>.</p>
<p>We can use the <span>join()</span> <span>proc</span> to join <span>strings</span> in <span>arrays</span> or sequences to single <span>strings</span> with an optional glue string. <span>Join()</span> works
also when the elements are not already <span>strings</span> — in that case the stringify operator is applied first:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>var</span> <span>a</span> <span>=</span> <span>[</span><span>&#34;Nim&#34;</span><span>,</span> <span>&#34;Rust&#34;</span><span>,</span> <span>&#34;Julia&#34;</span><span>]</span>
<span>var</span> <span>s</span> <span>=</span> <span>a</span><span>.</span><span>join</span><span>(</span><span>&#34;, &#34;</span><span>)</span>
<span>echo</span> <span>s</span>
<span>echo</span> <span>s</span><span>.</span><span>split</span><span>(</span><span>&#34;, &#34;</span><span>).</span><span>join</span><span>(</span><span>&#34;; &#34;</span><span>)</span>
<span>echo</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>.</span><span>join</span><span>(</span><span>&#34;; &#34;</span><span>)</span>
<span># Nim, Rust, Julia</span>
<span># Nim; Rust; Julia</span>
<span># 1; 2; 3</span></code></pre>
</div>
</div>
<p>The overloaded <span>find()</span> functions accepts optional <span>start</span> and <span>end</span> positions and returns
the index position of the first match or <span>-1</span> when the search gave no result:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strutils</span>
<span>var</span> <span>s</span> <span>=</span> <span>&#34;Nim Language&#34;</span>
<span>echo</span> <span>s</span><span>.</span><span>find</span><span>(</span><span>&#39;L&#39;</span><span>)</span> <span># 4</span>
<span>echo</span> <span>s</span><span>.</span><span>find</span><span>({</span><span>&#39; &#39;</span><span>,</span> <span>&#39;a&#39;</span><span>})</span> <span># 3</span>
<span>echo</span> <span>s</span><span>.</span><span>find</span><span>(</span><span>&#34;age&#34;</span><span>)</span> <span># 9</span>
<span>echo</span> <span>s</span><span>.</span><span>find</span><span>(</span><span>&#34;Rust&#34;</span><span>)</span> <span># -1</span></code></pre>
</div>
</div>
<p>The <span>contains()</span> function can be used to test if a character, a set of characters or a substring
in contained in a <span>string</span>. Instead of <span>contains(s, sub)</span> we can write <span>sub in s</span>. Note that a function variant for
single characters is defined in the <span>system</span> module.</p>
<p>The <span>replace()</span> function can be used to replace all occurrences of a character or a substring
in a <span>string</span> and to return the new <span>string</span>. We can use <span>replace()</span> with an empty replacement to delete a substring.
The also available <span>delete()</span> function is used to delete a range specified by two indices in place.</p>
<p>Additional a <span>replaceWord()</span> function exists, which does only replaces whole words, i.e. words that
are surrounded by word boundary characters like spaces, tabulators or newlines.</p>
<p>The function <span>multiReplace()</span> is a variant that can replace multiple substring/replacement pairs passed as <span>tuples</span> in one pass.</p>
<p>The function <span>strip()</span> can be used to remove multiple characters from a set at the start and the end of a <span>string</span>. The default
character set is whitespace, and per default strip removes characters at both ends of the string. The function <span>stripLineEnd()</span>
removes a single line end marker as \r, \n, \r\n, \f, \v from the end of the string, but only once.</p>
<p>Sometimes useful is the boolean function <span>isEmptyOrWhitespace()</span> which checks if a string is empty or contains
only whitespace. Also useful can be the function <span>repeat()</span> which returns a <span>string</span> that contains the passed
character or the passed <span>string</span> <span>n</span> times, and the function <span>spaces()</span> which returns a <span>string</span> containing only <span>n</span> spaces.</p>
<p>For single character tests we have functions like <span>isDigit()</span>, <span>isUpperAscii()</span>, <span>isLowerAscii()</span>, <span>isSpaceAscii</span>,
<span>isAlphaNumeric()</span>.
Function <span>isDigit()</span> test for characters &#39;0&#39;..&#39;9&#39;, <span>isUpperAscii()</span> for &#39;A&#39;..&#39;Z&#39;, <span>islowerAscii()</span> for &#39;a&#39;..&#39;z&#39;, <span>isSpaceAsccii()</span> for ASCII whitespace (&#39; &#39;, &#39;\t&#39;)
and <span>isAlphaNumeric()</span> test for lower or upper case ASCII letter or a decimal digit.</p>
<p>Function <span>toLowerAscii()</span> convert all the characters &#39;A&#39;..&#39;Z&#39; to lower case, and <span>toUpperAscii()</span> converts all the characters
&#39;a&#39;..&#39;z&#39; to upper case. The function argument can be a <span>string</span> or just a single character. With <span>capitalizeAscii()</span> we can
convert the first ASCII character of a <span>string</span> to upper case.</p>
<p>The overloaded functions <span>count()</span> can be used to count the characters or substrings in a <span>string</span>, and
<span>countLines()</span> is available to count the number of lines, where lines are separated by CR, LF or CR-LF.</p>
<p>Sometimes we may also need functions like <span>formatFloat()</span>, <span>formatBiggestFloat()</span> or <span>formatEng()</span> to
format <span>float</span> numbers for output purposes. You would have to consult the <span>strutils</span> API docs
for all the format details. An <span>intToStr()</span> function with an argument to specify the minimal <span>string</span>
length is also available. The string may get leading zeros for alignment.</p>
<p>Finally some important functions are the parsing functions like <span>parseFloat()</span> or <span>parseInt()</span> which converts
<span>strings</span> to <span>float</span> or integer numbers. Both raises an exception when the <span>string</span> does not contain a valid number.</p>
<p>The <span>strutils</span> module contains some more not that often used function, like functions to
convert data to hexadecimal, octal or binary representation, or to parse numbers back from that
string representation into numbers. Other functions like <span>align()</span>, <span>center()</span> and <span>indent()</span> are available
for <span>string</span> positioning. We will not try to describe these seldom used functions here, as it is hard
to remember the detailed behavior. You should skim the API docs and consult them
when you need one of the exotic functions or when you have forgotten how to use a concrete
function.</p>
</div>
<div>
<h3 id="_module_parseutils">Module parseutils</h3>
<p>The module <span>parseutils</span> provides a set of functions for
efficient and fast parsing of <span>strings</span>. The functions avoids the allocation
of new <span>strings</span> by passing back results in <span>var</span> <span>string</span> parameters and by
returning the number of processed characters. The module <span>parseutils</span> is a good choice
when we need efficient parsing of <span>strings</span> and the input <span>strings</span> have
a simple structure. For more complicated input data we may have to use
RegEx or PEGs. Let us assume that we have a set of library names which
includes the version numbers, but we need the plain names. The function
<span>parseWhile()</span> is a good candidate for this task:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>parseutils</span>
<span>var</span> <span>libs</span> <span>=</span> <span>[</span><span>&#34;libdconf.so.1.0.0&#34;</span><span>,</span> <span>&#34;libnice.so.10.11.0&#34;</span><span>,</span> <span>&#34;libwebkit2gtk-5.0.so.0.0.0&#34;</span><span>]</span>
<span>var</span> <span>l</span> <span>=</span> <span>newStringOfCap</span><span>(</span><span>128</span><span>)</span>
<span>for</span> <span>s</span> <span>in</span> <span>libs</span><span>:</span>
  <span>echo</span> <span>s</span><span>.</span><span>parseUntil</span><span>(</span><span>l</span><span>,</span> <span>{</span><span>&#39;.&#39;</span><span>,</span> <span>&#39;-&#39;</span><span>})</span>
  <span>echo</span> <span>l</span>
  <span>echo</span> <span>s</span><span>.</span><span>parseWhile</span><span>(</span><span>l</span><span>,</span> <span>{</span><span>&#39;a&#39;</span><span>..</span><span>&#39;z&#39;</span><span>})</span>
  <span>echo</span> <span>l</span></code></pre>
</div>
</div>
<p>First we allocate a <span>string</span> with enough capacity, so that the <span>parse()</span> functions
can use it without having to do allocations. As we want to receive the plain names,
using <span>parseWhile()</span> with a charset as last parameter may be a possible solution.
But as we see this will not really work for <span>webkit2gtk</span> which contains a digit in its
name:</p>
<div>
<div>
<pre>8
libdconf
8
libdconf
7
libnice
7
libnice
13
libwebkit2gtk
9
libwebkit</pre>
</div>
</div>
<p>We can fix this by passing the extended char set {&#39;a&#39;..&#39;z&#39;, &#39;0&#39;..&#39;9&#39;} to <span>parseWhile()</span> or by use of <span>parseUntil()</span>
with a character set that does not belong to a name.
Both functions return the number of processed characters and provide the captured string
in the passed var parameter. Not the we can use the slice operator .. to specify character ranges for the charset parameter when
the characters build a continues sequence in the ASCII table.</p>
<p>A related function is <span>skipUntil()</span>, which we may use when we are more interested in
the version numbers after the name:</p>
<div>
<div>
<pre><code data-lang="nim">  <span>let</span> <span>p</span> <span>=</span> <span>s</span><span>.</span><span>skipUntil</span><span>({</span><span>&#39;.&#39;</span><span>,</span> <span>&#39;-&#39;</span><span>})</span>
  <span>echo</span> <span>s</span><span>[</span><span>p</span> <span>..</span> <span>^</span><span>1</span><span>]</span></code></pre>
</div>
</div>
<p>All these functions accept an optional start parameter as last argument.
A common use case is to use an integer position variable initialized with zero,
which we increase by the returned value so that the parsing can continue
at the current position in the string. The next example will use this strategy.
For <span>parseUntil()</span>
overloaded functions are available which gets not a char set but a single character or a substring
as parameter. These functions stops parsing when the character or the substring is found and return
that position.</p>
<p>Functions like <span>parseInt()</span> and <span>parseFloat()</span> can be used to extract numbers from strings:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>parseutils</span>
<span>var</span> <span>s</span> <span>=</span> <span>&#34;In the year 2020 I gain 2.5 kg more fat.&#34;</span>
<span>var</span> <span>year</span><span>:</span> <span>int</span>
<span>var</span> <span>value</span><span>:</span> <span>float</span>
<span>var</span> <span>p</span> <span>=</span> <span>s</span><span>.</span><span>skipUntil</span><span>({</span><span>&#39;0&#39;</span><span>..</span><span>&#39;9&#39;</span><span>})</span>
<span>p</span> <span>+=</span> <span>parseUtils</span><span>.</span><span>parseInt</span><span>(</span><span>s</span><span>,</span> <span>year</span><span>,</span> <span>p</span><span>)</span>
<span>p</span> <span>+=</span> <span>s</span><span>.</span><span>skipUntil</span><span>({</span><span>&#39;0&#39;</span><span>..</span><span>&#39;9&#39;</span><span>},</span> <span>p</span><span>)</span>
<span>p</span> <span>+=</span> <span>parseUtils</span><span>.</span><span>parseFloat</span><span>(</span><span>s</span><span>,</span> <span>value</span><span>,</span> <span>p</span><span>)</span>
<span>echo</span> <span>year</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>value</span> <span># 2020: 2.5</span></code></pre>
</div>
</div>
<p>In above example we used the module prefix as <span>strutils</span> contains also a <span>parseInt()</span> and a <span>parseFloat()</span> function.
The functions <span>parseBin()</span>, <span>parseOct()</span> and parseHex() behave in a similar way. Returned is the number
of processed characters. We add the returned value to the start position so that parsing can continue
at the new position.</p>
<p>There are some more functions available in this module, which we will not discuss further. It is enough
that you know that this module exists and provides some efficient parsing functions. Whenever you
should really need one of these <span>procs</span> you would have to consult the API documentation for details.</p>
</div>
<div>
<h3 id="_module_strscans">Module strscans</h3>
<p>The <span>strscans</span> module provides a <span>scanf()</span> macro
which can be used to extract substrings from textual user input. The content of the substrings is automatically
converted to Nim variables of matching data types.</p>
<p>Processing of well defined <span>strings</span> is easy, and with user defined matcher functions even
text input with less strict shape can be processed.</p>
<p>Let us start with a simple example: We may have to create a program where the user should be able
to create rectangles by entering the coordinates of two opposite corners in the form</p>

<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>strscans</span>

<span>var</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>
<span>var</span> <span>name</span><span>:</span> <span>string</span>

<span>let</span> <span>input</span> <span>=</span> <span>&#34;Rect 10.0,20.0,100,200&#34;</span>

<span>if</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;</span><span>$w</span><span> </span><span>$f</span><span>,</span><span>$f</span><span>,</span><span>$f</span><span>,</span><span>$f</span><span>&#34;</span><span>,</span> <span>name</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>):</span>
  <span>echo</span> <span>name</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>x1</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>y1</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>x2</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>y2</span> <span># Rect 10.0 20.0 100.0 200.0</span></code></pre>
</div>
</div>
<p>The first parameter for the <span>scanf()</span> macro is the user input <span>string</span>, and the second
parameter is a pattern <span>string</span> that specifies how the input <span>string</span> should be processed. The following
parameters are variables that gets the results of the input evaluation.
The second parameter has some similarity with a regular expression. The letters
after the dollar sign specifies the data type of the substrings, $i or $f ask to process
an integer or a floating point number, and $w requests to process an ASCII identifier. Other
characters are captured verbatim, that is the space character after $w has to match a space
in the input <span>string</span>, and the comma characters that separates the $f has to match commas
in the input string. The <span>scanf()</span> macro supports capturing of some more data types, i.e. $c for an arbitrary character
or $s for optional white space. The optional white space is not captured, just ignored. With the use of $s
our program allows already a more flexible input string:</p>
<div>
<div>
<pre><code data-lang="nim"><span>let</span> <span>input</span> <span>=</span> <span>&#34;Rect10.0,    20.0,100,200&#34;</span>

<span>if</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;</span><span>$w$s$f</span><span>,</span><span>$s$f</span><span>,</span><span>$s$f</span><span>,</span><span>$s$f</span><span>&#34;</span><span>,</span> <span>name</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>):</span>
  <span>echo</span> <span>name</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>x1</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>y1</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>x2</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>y2</span> <span># Rect 10.0 20.0 100.0 200.0</span></code></pre>
</div>
</div>
<p>To allow to process even more flexible input strings
it is possible to use user definable matchers in form of Nim <span>procs</span>
with a well defined parameter signature. There are two different types of matcher
<span>procs</span> supported — matchers to just skip a part of the input string, and capturing matchers.
For the next example we will use a <span>proc</span> which can skip various separators like comma, semicolon or
white space. And we will use a capturing matcher <span>proc</span> for the object name.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>strscans</span>

<span>proc </span><span>sep</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>seps</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span> <span>=</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;,&#39;</span><span>,</span><span>&#39;;&#39;</span><span>}):</span> <span>int</span> <span>=</span>
  <span>while</span> <span>start</span> <span>+</span> <span>result</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>in</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>}:</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>
  <span>if</span> <span>start</span> <span>+</span> <span>result</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>in</span> <span>{</span><span>&#39;;&#39;</span><span>,</span><span>&#39;,&#39;</span><span>}:</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>
  <span>while</span> <span>start</span> <span>+</span> <span>result</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>in</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>}:</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>

<span>proc </span><span>stt</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>strVal</span><span>:</span> <span>var</span> <span>string</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>n</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>if</span> <span>input</span><span>[</span><span>start</span> <span>..</span> <span>start</span> <span>+</span> <span>&#34;Rect&#34;</span><span>.</span><span>high</span><span>]</span> <span>==</span> <span>&#34;Rect&#34;</span><span>:</span>
    <span>strVal</span> <span>=</span> <span>&#34;Rect&#34;</span>
    <span>result</span> <span>=</span> <span>&#34;Rect&#34;</span><span>.</span><span>len</span>

<span>var</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>:</span> <span>float</span>
<span>var</span> <span>name</span><span>:</span> <span>string</span>

<span>let</span> <span>input</span> <span>=</span> <span>&#34;Rect 10.0    ;20.0,100  ,  200&#34;</span>

<span>if</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;${stt(0)}</span><span>$s$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>&#34;</span><span>,</span> <span>name</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>):</span>
  <span>echo</span> <span>name</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>x1</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>y1</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>x2</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>y2</span> <span># Rect 10.0 20.0 100.0 200.0</span></code></pre>
</div>
</div>
<p>The use of our user definable matcher <span>sep()</span> allows to separate the four numbers
with a colon or a semicolon with arbitrary leading or trailing white space, or with
only white space. Multiple colons or semicolons between two numbers resulting
from a typo would be not permitted.</p>
<p>The signature for this matcher <span>proc</span> has this shape:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>sep</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>seps</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span> <span>=</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;,&#39;</span><span>,</span><span>&#39;;&#39;</span><span>}):</span> <span>int</span> <span>=</span></code></pre>
</div>
</div>
<p>The first parameter is the <span>string</span> to process, and the second parameter is
the position at which the processing should start. (Or in other words, the second
parameter of integer type is the actual position in the input <span>string</span>, that position
moves during the whole capering process from the start of the input <span>string</span> to
its end. The end may not be reached if the capering fails at some point.)
The last parameter
has always the type <span>set[char]</span> with a default value indication which
characters that <span>proc</span> can process. Actually a default value seems to be necessary, but the
actual value seems not to matter.
The <span>proc</span> returns the number of
characters that should be skipped. Zero is a valid return value, so
we can support optional separators. In most cases separators are
necessary to process the input <span>string</span>, but we can imagine input
formats where separators are optional, e.g. when an integer number
is followed by a name. A name never starts with a digit, so the boundary
between the two values is well defined. This none capturing matcher <span>proc</span> is called by use of
$[sep] in the pattern <span>string</span>.</p>
<p>The signature of the capturing matcher <span>proc</span> has this shape:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>stt</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>strVal</span><span>:</span> <span>var</span> <span>string</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>n</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span></code></pre>
</div>
</div>
<p>That <span>proc</span> also gets as parameters the input <span>string</span> and the start position, and has to
return the number of processed characters. But additional a <span>var</span> parameter of arbitrary data type
is used to return the result of the capture, and the last parameter with arbitrary data type can
influence the capturing process. One possible use of the last parameter is to use an integer value
to limit the maximum number of characters to process. This <span>proc</span> is called in the pattern <span>string</span>
by using curly braces like ${stt(0)}.</p>
<p><span>Scanf()</span> returns true when all the parameters match, for that case all the passed in variables get
assigned a value. Currently <span>scanf()</span> does not support the capturing of optionally data, as the whole
processing stops when one capture fails, i.e. when $i is used to request the capture of an integer value
but the input string does not contain decimal digits at the current capture position. In the
same way the whole capturing process stops when a user defined capturing matcher returns zero
as no capturing is possible. So intermediate optional arguments are currently not supported.
When the processing stops due to missing arguments, <span>scanf()</span> returns <span>false</span>, but the already processed captures
still have a valid value assigned. In this way we can use at least optional trailing arguments.</p>
<p>As next example for the use of the <span>scanf()</span> macro we will give a real world example: A simple CAD (Computer Aided Design) program
has a PCB (Printed Circuit Board) mode, in which the user can create new PCB pads by entering the pad data in a text entry widget.
A PCB pad is a rectangular shaped copper field which has an associated number and a name and maybe rounded corners.
The user should be able to enter two 2D coordinates, the corner radius, an optional x/y translation for the
next pad of same size, followed by the number of pads to create and the pad number and name. That is</p>
<div>
<div>
<pre>pad x1 y1 x2 y2 r dx dy n num name</pre>
</div>
</div>
<p>The first five arguments are mandatory, the rest is optional with default values. The user should
be able to separate the arguments with white space or with a colon or a semicolon. Additional
the values <span>x2</span> and  <span>y2</span> can be preceded with a  <span>+</span> character to indicate that the  <span>x2</span>,  <span>y2</span>
<span>tuple</span> is not
an absolute coordinate value but the width and high of the pad.</p>
<p>A program fragment to process this form of user input may look like</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>strscans</span>

<span>proc </span><span>jecho</span><span>(</span><span>x</span><span>:</span> <span>varargs</span><span>[</span><span>string</span><span>,</span> <span>`</span><span>$</span><span>`</span><span>]</span><span>)</span> <span>=</span>
  <span>for</span> <span>el</span> <span>in</span> <span>x</span><span>:</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>el</span> <span>&amp;</span> <span>&#34; &#34;</span><span>)</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>
  <span>stdout</span><span>.</span><span>flushfile</span>

<span>proc </span><span>stt</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>strVal</span><span>:</span> <span>var</span> <span>string</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>n</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>if</span> <span>input</span><span>[</span><span>start</span> <span>..</span> <span>start</span> <span>+</span> <span>&#34;pad&#34;</span><span>.</span><span>high</span><span>]</span> <span>==</span> <span>&#34;pad&#34;</span><span>:</span>
    <span>strVal</span> <span>=</span> <span>&#34;pad&#34;</span>
    <span>result</span> <span>=</span> <span>&#34;pad&#34;</span><span>.</span><span>len</span>

<span>proc </span><span>pls</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>plusVal</span><span>:</span> <span>var</span> <span>int</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>n</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>if</span> <span>input</span><span>[</span><span>start</span><span>]</span> <span>==</span> <span>&#39;+&#39;</span><span>:</span>
    <span>plusVal</span> <span>=</span> <span>1</span> <span># bool</span>
    <span>result</span> <span>=</span> <span>1</span>

<span>proc </span><span>sep</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>seps</span><span>:</span> <span>set</span><span>[</span><span>char</span><span>]</span> <span>=</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;,&#39;</span><span>,</span><span>&#39;;&#39;</span><span>}):</span> <span>int</span> <span>=</span>
  <span>while</span> <span>start</span> <span>+</span> <span>result</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>in</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>}:</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>
  <span>if</span> <span>start</span> <span>+</span> <span>result</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>in</span> <span>{</span><span>&#39;;&#39;</span><span>,</span><span>&#39;,&#39;</span><span>}:</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>
  <span>while</span> <span>start</span> <span>+</span> <span>result</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>in</span> <span>{</span><span>&#39; &#39;</span><span>,</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>}:</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>

<span>proc </span><span>plus</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>plusVal</span><span>:</span> <span>var</span> <span>int</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>n</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>result</span> <span>=</span> <span>sep</span><span>(</span><span>input</span><span>,</span> <span>start</span><span>)</span>
  <span>if</span> <span>input</span><span>[</span><span>start</span> <span>+</span> <span>result</span><span>]</span> <span>==</span> <span>&#39;+&#39;</span><span>:</span>
    <span>plusVal</span> <span>=</span> <span>1</span> <span># bool</span>
    <span>result</span> <span>+=</span> <span>1</span>

<span>var</span> <span>st</span><span>:</span> <span>string</span>
<span>var</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>:</span> <span>float</span>
<span>var</span> <span>px2</span><span>,</span> <span>py2</span><span>:</span> <span>int</span> <span># bool</span>
<span>var</span> <span>n</span><span>:</span> <span>int</span>
<span>var</span> <span>number</span><span>,</span> <span>name</span><span>:</span> <span>string</span>

<span>(</span><span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span> <span>=</span> <span>(</span><span>&#34;pad&#34;</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span> <span>0</span><span>,</span> <span>NaN</span><span>,</span> <span>0</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span> <span>0</span><span>,</span> <span>&#34;&#34;</span><span>,</span> <span>&#34;&#34;</span><span>)</span> <span># defaults</span>

<span>var</span> <span>res</span><span>:</span> <span>bool</span>
<span>var</span> <span>input</span> <span>=</span> <span>&#34;pad 10.0, 10   12 +12.0 ;20 0 8 Num Name&#34;</span>

<span># unfortunately the input start with &#34;pad&#34; is needed for unpatched strscan!</span>

<span># using the pls matcher, this fails when there is no &#39;+&#39;</span>
<span>res</span> <span>=</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;${stt(0)}$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]${pls(0)}</span><span>$f</span><span>$[sep]${pls(0)}</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$i</span><span>$[sep]</span><span>$w</span><span>$[sep]</span><span>$w</span><span>&#34;</span><span>,</span> <span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span>
<span>jecho</span><span>(</span><span>res</span><span>,</span> <span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span>

<span># using the plus matcher, so the &#39;+&#39; is optional</span>
<span>res</span> <span>=</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;${stt(0)}$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>${plus(0)}</span><span>$f</span><span>${plus(0)}</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$i</span><span>$[sep]</span><span>$w</span><span>$[sep]</span><span>$w</span><span>&#34;</span><span>,</span> <span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span>
<span>jecho</span><span>(</span><span>res</span><span>,</span> <span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span>

<span>input</span> <span>=</span> <span>&#34;pad 10.0, 10   12 +12.0&#34;</span> <span># test with missing optional values</span>
<span>(</span><span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span> <span>=</span> <span>(</span><span>&#34;pad&#34;</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span> <span>0</span><span>,</span> <span>NaN</span><span>,</span> <span>0</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span> <span>NaN</span><span>,</span> <span>0</span><span>,</span> <span>&#34;&#34;</span><span>,</span> <span>&#34;&#34;</span><span>)</span> <span># defaults</span>
<span># using the plus matcher, so the &#39;+&#39; is optional</span>
<span>res</span> <span>=</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;${stt(0)}$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>${plus(0)}</span><span>$f</span><span>${plus(0)}</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$f</span><span>$[sep]</span><span>$i</span><span>$[sep]</span><span>$w</span><span>$[sep]</span><span>$w</span><span>&#34;</span><span>,</span> <span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span>
<span>jecho</span><span>(</span><span>res</span><span>,</span> <span>st</span><span>,</span> <span>x1</span><span>,</span> <span>y1</span><span>,</span> <span>px2</span><span>,</span> <span>x2</span><span>,</span> <span>py2</span><span>,</span> <span>y2</span><span>,</span> <span>dx</span><span>,</span> <span>dy</span><span>,</span> <span>n</span><span>,</span> <span>number</span><span>,</span> <span>name</span><span>)</span></code></pre>
</div>
</div>
<p>When we compile and run this program we get this output:</p>
<div>
<div>
<pre>false pad 10.0 10.0 0 nan 0 nan nan nan 0
true pad 10.0 10.0 0 12.0 1 12.0 20.0 0.0 8 Num Name
false pad 10.0 10.0 0 12.0 1 12.0 nan nan 0</pre>
</div>
</div>
<p>The first  <span>scanf()</span> call uses the sequence $[sep]${pls(0)} which fails when the  <span>float</span> value has no leading  <span>+</span> sign, so this call
is of no real use. The second and third  <span id="scanf()# call uses instead a ${plus(0)} call">plus()</span> <span>proc</span> processes
the separators as well as the optional  <span>+</span> character, so that <span>proc</span> has never to return zero, and the capturing process continues.
For the last  <span>scanf()</span> call we give as input only five values, so  <span>scanf()</span> returns false, but the first five values gets assigned values, and the
rest has default values. One restriction of above code is, that we have always to start the input string with  <span>pad</span>, otherwise
the processing stops immediately. As  <span>scanf()</span> does not support the capture of boolean values, we uses the integer data type
for the variables  <span>px2</span> and  <span>py2</span>. The value zero means that there is no  <span>+</span> prefix, and  <span>1</span> indicates that there is a plus prefix.</p>
<p>The next tiny example shows how we can use the last parameter of the user defined matcher <span>proc</span> to
control the matching process:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strscans</span>

<span>proc </span><span>ndigits</span><span>(</span><span>input</span><span>:</span> <span>string</span><span>;</span> <span>intVal</span><span>:</span> <span>var</span> <span>int</span><span>;</span> <span>start</span><span>:</span> <span>int</span><span>;</span> <span>n</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>var</span> <span>i</span><span>,</span> <span>x</span><span>:</span> <span>int</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>n</span> <span>and</span> <span>i</span> <span>+</span> <span>start</span> <span>&lt;</span> <span>input</span><span>.</span><span>len</span> <span>and</span> <span>input</span><span>[</span><span>i</span> <span>+</span> <span>start</span><span>]</span> <span>in</span> <span>{</span><span>&#39;0&#39;</span><span>..</span><span>&#39;9&#39;</span><span>}:</span>
    <span>x</span> <span>=</span> <span>x</span> <span>*</span> <span>10</span> <span>+</span> <span>input</span><span>[</span><span>i</span> <span>+</span> <span>start</span><span>]</span><span>.</span><span>ord</span> <span>-</span> <span>&#39;0&#39;</span><span>.</span><span>ord</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span># only overwrite if we had a match</span>
  <span>if</span> <span>i</span> <span>==</span> <span>n</span><span>:</span>
    <span>result</span> <span>=</span> <span>n</span>
    <span>intVal</span> <span>=</span> <span>x</span>

<span>var</span> <span>input</span> <span>=</span> <span>&#34;1234&#34;</span>
<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span>

<span>if</span> <span>scanf</span><span>(</span><span>input</span><span>,</span> <span>&#34;${ndigits(2)}</span><span>$s</span><span>${ndigits(2)}$.&#34;</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>):</span>
  <span>echo</span> <span>&#34;Input is OK:&#34;</span><span>,</span> <span>a</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>b</span></code></pre>
</div>
</div>
<p>We want to capture two integer values, each with one or two decimal digits.
By passing the upper limit of digits to the <span>ndigits()</span> <span>proc</span>, we get the intended result
even when the user does not separate the two numbers with white space. Additional
we have used $. at the end of the pattern string. The $. matches only when the end of the input
string is reached, so that <span>scanf()</span> would return false if there are more characters in
the input <span>string</span> left.</p>
<p>The latest version of the <span>strscans</span> module provides also a variant of the <span>scanf()</span> macro
called <span>scanTuple()</span> which returns a <span>tuple</span>. We could use it in this way in our example above:</p>
<div>
<div>
<pre><code data-lang="nim"><span>let</span> <span>(</span><span>res</span><span>,</span> <span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>scanTuple</span><span>(</span><span>input</span><span>,</span> <span>&#34;${ndigits(2)}</span><span>$s</span><span>${ndigits(2)}$.&#34;</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>)</span>
<span>echo</span> <span>res</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>a</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>b</span></code></pre>
</div>
</div>
<p>So we have not to declare the capering variables in advance. The final result of the
scan process is returned in an additional boolean variable. When we use user defined matchers
as above, we have to specify the data types of the returned values as additional parameters
after the pattern string.</p>
<p>Additional the <span>strscans</span> module provides a <span>scanp()</span> macro which works somewhat similar as
PEG or RegEx libraries. We will not try to explain the <span>scanp()</span> macro, as its use may be too
difficult for a beginner book. And when we really have to process text <span>strings</span> with
regular expression grammars, then we can use the available RegEx or PEG modules
which have no restrictions and work for Nim in a similar way as for other programming languages.
We will introduce the Nim RegEx and PEG modules later in the book — maybe we will compare
the scanp() macro there.</p>
</div>
<div>
<h3 id="_module_strformat">Module strformat</h3>
<p>With the <span>fmt()</span> macro from the <span>strformat</span> module we can format and interpolate <span>strings</span> similar as Python3 with its f-strings.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strformat</span>
<span>from</span> <span>strutils</span> <span>import</span> <span>`</span><span>%</span><span>`</span>
<span>var</span> <span>lang</span> <span>=</span> <span>&#34;C&#34;</span>
<span>var</span> <span>year</span> <span>=</span> <span>1972</span>
<span>stdout</span><span>.</span><span>write</span> <span>&#34;The programming language &#34;</span><span>,</span> <span>$</span><span>lang</span><span>,</span> <span>&#34; was created in &#34;</span><span>,</span> <span>$</span><span>year</span><span>,</span> <span>&#34;.</span><span>\n</span><span>&#34;</span>
<span>echo</span> <span>&#34;The programming language &#34;</span> <span>&amp;</span> <span>$</span><span>lang</span> <span>&amp;</span> <span>&#34; was created in &#34;</span> <span>&amp;</span> <span>$</span><span>year</span><span>,</span> <span>&#34;.&#34;</span>
<span>echo</span> <span>&#34;The programming language </span><span>$#</span><span> was created in </span><span>$#</span><span>.&#34;</span> <span>%</span> <span>[$</span><span>lang</span><span>,</span> <span>$</span><span>year</span><span>]</span>
<span>echo</span> <span>fmt&#34;The programming language {lang} was created in {year}.&#34;</span>
<span># The programming language C was created in 1972.</span></code></pre>
</div>
</div>
<p>From the four ways to print some text the last one with <span>fmt()</span> is the shortest and maybe the cleanest.
As <span>fmt()</span> is a macro which is processed at compile time there is no unnecessary run-time
overhead involved. A small restriction of <span>fmt()</span> is, that it’s argument is regarded as
a generalized raw <span>string</span> literal. So we can not use escape sequences like <span>&#34;\n&#34;</span> in the <span>string</span> literal.
But the <span>strformat</span> API docs mention various solutions for this: We can use the unary <span>&amp;</span> operator instead of the <span>fmt()</span> call,
or we can use the notations <span>{&#39;\n&#39;}</span>, <span>fmt()</span> or <span>&#34;&#34;.fmt</span>.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strformat</span>
<span>var</span> <span>lang</span> <span>=</span> <span>&#34;Fortran&#34;</span>
<span>var</span> <span>year</span> <span>=</span> <span>1957</span>
<span>stdout</span><span>.</span><span>write</span> <span>&amp;</span><span>&#34;The programming language {lang} was created in {year}.</span><span>\n</span><span>&#34;</span>
<span>stdout</span><span>.</span><span>write</span> <span>fmt&#34;The programming language {lang} was created in {year}.{&#39;\n&#39;}&#34;</span>
<span>stdout</span><span>.</span><span>write</span> <span>fmt</span><span>(</span><span>&#34;The programming language {lang} was created in {year}.</span><span>\n</span><span>&#34;</span><span>)</span>
<span>stdout</span><span>.</span><span>write</span> <span>&#34;The programming language {lang} was created in {year}.</span><span>\n</span><span>&#34;</span><span>.</span><span>fmt</span>
<span># The programming language Fortran was created in 1957.</span></code></pre>
</div>
</div>
<p>The <span>fmt()</span> macro works also with multi-line raw <span>strings</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strformat</span>
<span>echo</span> <span>fmt&#34;</span><span>&#34;</span><span>&#34;This is a {1 + 1 + 1} lines</span><span>
</span><span>multiline</span><span>
</span><span>string.&#34;&#34;&#34;</span></code></pre>
</div>
</div>
<p>The <span>fmt()</span> macro accept a few directives for the formatting of integer and floating point numbers like</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strformat</span>
<span>var</span> <span>pi</span> <span>=</span> <span>3.1415</span>
<span>var</span> <span>people</span> <span>=</span> <span>123</span>
<span>echo</span> <span>fmt&#34;The number{pi:&gt;8.2f} is called PI by {people:&gt;8} people.&#34;</span></code></pre>
</div>
</div>
<p>The basic pattern is, that the numeric variable is followed by a colon
and the total number of desired characters. We can precede the number with a
&lt; or &gt; to indicate left or right alignment, and for floating point numbers
we can use a notation similar as used for printf() in the C language:
n.mf stands for a <span>float</span> formatted with <span>n</span> characters total and <span>m</span> decimal places.
As in C we can use <span>e</span> instead of <span>f</span> to indicate scientific notation. If the value which specifies
the total number of characters starts with a zero digit, then the formatted
number uses zeros instead spaces for leading digits. And <span>X</span> after the colon
generates hexadecimal value for integer numbers.</p>
<p>A useful property of the <span>fmt()</span> macro is, that we can put an equal sign into the curly braces
to get the initial expression both as <span>string</span> and as interpolated value, as in</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strformat</span>
<span>var</span> <span>pi</span> <span>=</span> <span>3.1415</span>
<span>echo</span> <span>fmt&#34;{2 * pi = }&#34;</span> <span># 2 * pi = 6.283</span></code></pre>
</div>
</div>
<p>This is similar as the <span>dump()</span> macro from the <span>sugar</span> module and is mostly used for debugging purposes.</p>
<p>To use curly braces as literals in a <span>fmt()</span> argument we can use character literals with a backslash
as we did to include a newline character, or we can use an extended <span>fmt()</span> macro with two additional
arguments which specifies the two characters that should be used instead of {} to mark the
expression which should be interpolated:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>strformat</span>
<span>echo</span> <span>fmt&#34;{2} curly braces {&#39;\{&#39;} {&#39;\}&#39;}.&#34;</span> <span># 2 curly braces { }.</span>
<span>echo</span> <span>&#34;three time three is &lt;3 * 3&gt;&#34;</span><span>.</span><span>fmt</span><span>(</span><span>&#39;&lt;&#39;</span><span>,</span> <span>&#39;&gt;&#39;</span><span>)</span> <span># three time three is 9</span></code></pre>
</div>
</div>
<p>We will
not try to explain all these various formatting options in detail, as it is
really hard to remember. It is enough that you know that these options exists, so
you can consult the API docs for details when you would need it.</p>
<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_arrays_and_sequences_2">Arrays and Sequences</h2>
<div>
<p>Together with <span>strings</span> <span>arrays</span> and sequences are the most important built-in containers for the Nim language.
While <span>arrays</span> have a fixed size defined already at compile time, sequences are like <span>strings</span> of dynamic size and
can grow when we append more elements. As <span>arrays</span> have fixed size they can be allocated on the stack, while
due to the dynamic size of sequences the actual data buffer has to be allocated on the heap. We explained some details
about sequences already in part II of the book. One important aspect was that sequences use a continues data
buffer with a fixed capacity to store the actual elements. When that data buffer is fully occupied, and we try to
add more elements, then a new larger buffer is allocated on the heap and the contained elements have
to been copied from the old to the new larger buffer before the old buffer can be deallocated.</p>
<p>When we pass <span>arrays</span> or sequences to <span>procs</span>, then we can use the special data type <span>openArray</span> when we define the <span>proc</span> to
allow passing both arrays and sequences. Note that this is very different from generic <span>procs</span>: When we define
a generic <span>proc</span>, then the compiler creates a new <span>proc</span> instance for each of the generic data type that we use, so when we
call a generic <span>proc</span> which accepts floats and signed and unsigned integers, and we call it a few times
with <span>float</span> and with signed integer arguments, then the compiler has to create two distinct instances of the
proc. For <span>openArray</span> parameters all the time only one <span>proc</span> instance is necessary as sequences behave like <span>arrays</span>
in many ways. Both use a continues block of memory where the elements are stored, and the position of an
entry is given by the start address of this memory block and an offset given by the index multiplied with the size
of an <span>array</span> element. So when passing the actual parameter to the <span>proc</span>, the compiler passes the <span>array</span> and the data
section of the sequence in the same manner. Both can be passed by copy or by address. The compiler passes
also the actual size, the lower index is always zero for <span>openArrays</span>. Of course when we pass a <span>seq</span> as <span>openArray</span>,
there are some restrictions, e.g. we could not add elements in the <span>proc</span> as the passed variable behaves like an array.</p>
<p>Memory layout of sequences and <span>strings</span> is very similar, both have length, capacity and a data buffer on the heap,
and some <span>procs</span> that work on the data structure has the same names like <span>add()</span>, <span>len()</span> and <span>setlen()</span> and both support
operators like <span>[]</span>, <span>&amp;</span> and <span>..</span> for access to single elements, and for concatenation and slicing.</p>
<p>Some often used functions and operators for sequences and <span>arrays</span> are defined in the <span>system</span> module, like creating
new sequences, converting <span>arrays</span> to sequences, joining sequences or adding elements to it.
Other important functions, operators and iterators are defined in the <span>sequtils</span> module which we
describe in the next section.</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s0</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
<span>var</span> <span>s1</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span> <span>newSeqOfCap</span><span>[</span><span>int</span><span>]</span><span>(</span><span>2</span><span>)</span>
<span>var</span> <span>s2</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span> <span>newSeq</span><span>[</span><span>int</span><span>]</span><span>(</span><span>2</span><span>)</span>

<span>s0</span><span>.</span><span>add</span><span>(</span><span>3</span><span>)</span>
<span>s0</span><span>.</span><span>add</span><span>(</span><span>5</span><span>)</span>
<span>s1</span><span>.</span><span>add</span><span>(</span><span>3</span><span>)</span>
<span>s1</span><span>.</span><span>add</span><span>(</span><span>5</span><span>)</span>
<span>s2</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>3</span>
<span>s2</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>5</span>
<span>echo</span> <span>s0</span><span>;</span> <span>echo</span> <span>s1</span><span>;</span> <span>echo</span> <span>s2</span> <span># @[3, 5] for each</span></code></pre>
</div>
</div>
<p>We can initialize sequences by a call of <span>newSeq()</span>, <span>newSeqOfCap()</span> or not at all.
When we use <span>newSeq(n)</span> we get a <span>seq</span> with <span>n</span> elements initialized to binary zero each, and
we then can just overwrite the elements by use of the subscript operator <span>[]</span>
which is faster than appending elements with <span>add()</span> to an empty <span>seq</span>.
With <span>newSeqOfCap()</span> we can allocate a <span>seq</span> of size zero but with a buffer size
of that specified capacity. We can append elements by calling the <span>add()</span>
function, and as long we append not more elements as specified in the
<span>newSeqOfCap()</span> call we can avoid reallocations of the internal <span>seq</span> buffer. When performance
in not that critical we can just use a uninitialized <span>seq</span> and <span>add()</span> elements — when the default capacity is exhausted a reallocation occurs, generally with
doubled data buffer size.</p>
<p>We can use the overloaded <span>add()</span> <span>proc</span> to append single elements or to append
an whole array to a <span>seq</span>, and the <span>&amp;</span> operator is available to join two sequences:</p>
<div>
<div>
<pre><code data-lang="nim"><span>s0</span><span>.</span><span>add</span><span>(</span><span>[</span><span>7</span><span>,</span> <span>9</span><span>]</span><span>)</span>
<span>s0</span> <span>&amp;=</span> <span>s1</span>
<span>s1</span> <span>=</span> <span>s0</span> <span>&amp;</span> <span>s2</span>
<span>echo</span> <span>s1</span> <span># @[3, 5, 7, 9, 3, 5, 3, 5]</span></code></pre>
</div>
</div>
<p>We can use <span>len()</span> to query the length of a <span>seq</span> and <span>setLen()</span> to set a new length.
In most cases <span>setLen(n)</span> is used to shorten a <span>seq</span>, that is to keep the first <span>n</span>
elements, but we can also use <span>setLen()</span> to increase the length of a <span>seq</span>. In that
case the new entries get the value binary zero as default and we can use the subscript
operator <span>[]</span> to fill in actual content. Increasing the length with <span>setLen()</span> may cause
a reallocation if the current capacity is not sufficient. Functions <span>low()</span> and <span>high()</span> are
available to get the lowest and the highest index position of an <span>array</span> or a <span>seq</span>.
As arrays can have negative indices, <span>low()</span> can be less than zero for <span>arrays</span>, but for
sequences and <span>openArray</span> <span>proc</span> parameters <span>low()</span> is always zero.</p>
<p>Module <span>system</span> provides also the <span>@</span> <span>array</span> to <span>seq</span> operator:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span> <span>=</span> <span>7</span>
<span>var</span> <span>j</span> <span>=</span> <span>9</span>
<span>var</span> <span>s0</span> <span>=</span> <span>@[</span><span>1</span><span>,</span> <span>2</span><span>]</span>
<span>s0</span> <span>=</span> <span>s0</span> <span>&amp;</span> <span>@[</span><span>i</span><span>,</span> <span>j</span><span>]</span> <span># don&#39;t use this variant!</span>
<span>s0</span><span>.</span><span>add</span><span>(</span><span>[</span><span>i</span><span>,</span> <span>j</span><span>]</span><span>)</span> <span># faster</span>
<span>echo</span> <span>s0</span> <span># @[1, 2, 7, 9, 7, 9]</span></code></pre>
</div>
</div>
<p>Note that the code in line 4 would be really slow as that would have to allocate a temporary <span>seq</span>.
Using <span>add()</span> to add a temporary array to the seq should be faster.</p>
<p>Slicing is also supported by the <span>system</span> module:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>s0</span> <span>=</span> <span>@[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span>
<span>var</span> <span>s1</span> <span>=</span> <span>s0</span><span>[</span><span>1</span> <span>..</span> <span>2</span><span>]</span> <span># @[3, 5]</span>
<span>for</span> <span>el</span> <span>in</span> <span>s0</span><span>[</span><span>1</span> <span>..</span> <span>2</span><span>]</span><span>:</span> <span># may create a copy of the seq</span>
  <span>echo</span> <span>el</span></code></pre>
</div>
</div>
<p>Note that line three may create a temporary copy of the sequence,
which may be not that nice for optimal performance. We discussed that
topic already in part II of the book, Nim 2.0 may improve the situation further by
introducing views which create no copies. Beside the <span>s[a .. b]</span> slice operator which includes
the elements at position <span>a</span> and <span>b</span>, there is <span>s[a ..&lt; b]</span> which does not include position <span>b</span> and and <span>s[a .. ^b]</span>
where position <span>b</span> is taken from the end of the <span>seq</span> or <span>array</span>, e.g. <span>^1</span> is the last position, <span>^2</span> the second last.</p>
<p>For deleting elements from a sequence we have <span>del()</span> which replaces the element at the specified position with the
last element of the <span>seq</span> and reduces the <span>seq</span> length by one, and the <span>delete()</span> function which shifts all elements after
the specified position one step forward. Obviously the later is slower, but it preserves the order of elements.
The function <span>pop()</span> deletes and returns the last item of a <span>seq</span>. For using <span>pop()</span> on an empty seq we may
expect a raised exception. With insert we can insert an item at the specified position by moving all the elements
after this position upwards.
Note that <span>del()</span>, <span>delete()</span>, <span>pop()</span> and <span>insert()</span> are not available for <span>arrays</span>.</p>
<p>Comparison of two <span>arrays</span> or sequences by the <span>==</span> operator returns <span>true</span> when the length as well as all
contained items matches.</p>
<p>With the function <span>contains()</span> we can test if an item is contained in a <span>seq</span> or an <span>array</span>. We can also use the operators
<span>a in b</span> and <span>a notin b</span> instead. The elements are tested from the start of the container until a match is found
or the last position in the container is reached, so this is a O(n) operation.</p>
<div>
<h3 id="_module_sequtils">Module sequtils</h3>
<p>This module defines some useful <span>procs</span>, iterators and templates for working with <span>arrays</span> and sequences.
Some functions of module <span>sequtils</span> use an generic <span>openArray</span> parameter and so can be used for <span>strings</span> as well.
While the <span>max()</span> and <span>min()</span> <span>procs</span> are available from the <span>system</span> module, the <span>minIndex()</span> and <span>maxIndex()</span>
<span>procs</span> are provided by <span>sequtils</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>var</span> <span>s</span> <span>=</span> <span>@[</span><span>7</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span>
<span>echo</span> <span>s</span><span>.</span><span>min</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>s</span><span>.</span><span>max</span> <span># 3 7</span>
<span>echo</span> <span>s</span><span>.</span><span>minIndex</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>s</span><span>.</span><span>maxIndex</span> <span># 1 0</span></code></pre>
</div>
</div>
<p>Sometimes we may need a <span>minmax()</span> <span>proc</span> which gives us both values, but that one is currently not available.
We have to create it our self if needed, when performnce is not that critical we can call <span>min()</span> and <span>max()</span>
separately.</p>
<p>The functions <span>minIndex()</span> and <span>maxIndex()</span> as well as <span>count()</span> or <span>deduplicate()</span> can work with strings also:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>var</span> <span>s</span> <span>=</span> <span>@[</span><span>3</span><span>,</span> <span>5</span><span>,</span> <span>1</span><span>,</span> <span>7</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>]</span>
<span>echo</span> <span>s</span><span>.</span><span>count</span><span>(</span><span>5</span><span>)</span> <span># 2</span>
<span>echo</span> <span>s</span><span>.</span><span>deduplicate</span> <span># @[3, 5, 1, 7]</span>
<span>echo</span> <span>&#34;abc&#34;</span><span>.</span><span>maxIndex</span><span>()</span> <span>#2</span></code></pre>
</div>
</div>
<p>The function name <span>deduplicate()</span> may be irritating, as the function does not work in place,
we may expect the name deduplicated() as for <span>sort()</span> and <span>sorted()</span>. Other programming languages
use the name <span>uniq()</span> instead. Deduplication is easy when the elements are sorted, as for that case
we can just iterate over the seq and ignore equal adjacent items. That is why <span>deduplicate()</span> accepts
an optional boolean parameter indicating if the <span>seq</span> is sorted. If the <span>seq</span> is not sorted, it may be necessary
to create a temporary set to store the already seen items so that they can be ignored the next time
when they occur again in the seq.</p>
<p>The function <span>concat()</span> can join multiple sequences (yes only sequences, it does not work with <span>arrays</span> currently),
maybe that is more efficient than using the <span>&amp;</span> operator.
And <span>insert()</span> can insert a new value at a position by shifting following items, and <span>delete()</span>
allows to remove a range of items from the <span>seq</span> when we specify two index positions:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
<span>s</span> <span>=</span> <span>concat</span><span>(</span><span>@[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>,</span> <span>@[</span><span>3</span><span>,</span> <span>4</span><span>]</span><span>,</span> <span>@[</span><span>5</span><span>,</span> <span>6</span><span>]</span><span>)</span>
<span>echo</span> <span>s</span> <span># @[1, 2, 3, 4, 5, 6]</span>
<span>echo</span> <span>@[</span><span>1</span><span>,</span> <span>2</span><span>]</span> <span>&amp;</span> <span>@[</span><span>3</span><span>,</span> <span>4</span><span>]</span> <span>&amp;</span> <span>@[</span><span>5</span><span>,</span> <span>6</span><span>]</span> <span># @[1, 2, 3, 4, 5, 6]</span>
<span>s</span><span>.</span><span>insert</span><span>(</span><span>7</span><span>,</span> <span>2</span><span>)</span>
<span>s</span><span>.</span><span>delete</span><span>(</span><span>3</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)</span>
<span>echo</span> <span>s</span> <span># @[1, 2, 7]</span></code></pre>
</div>
</div>
<p>Proc <span>repeat()</span> is used to create a <span>seq</span> which contains a single value multiple times, and <span>cycle()</span>
repeats the items of an existing <span>seq</span> multiple times:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>echo</span> <span>2.</span><span>repeat</span><span>(</span><span>4</span><span>)</span> <span># @[2, 2, 2, 2]</span>
<span>echo</span> <span>@[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>.</span><span>cycle</span><span>(</span><span>3</span><span>)</span> <span># @[1, 2, 1, 2, 1, 2]</span></code></pre>
</div>
</div>
<p>A bit more complicated but really useful are functions like <span>map()</span>, <span>filter()</span>, <span>keep()</span> and the corresponding <span>…​It()</span> templates:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span><span>,</span> <span>sugar</span>
<span>var</span> <span>s</span> <span>=</span> <span>(</span><span>0</span> <span>..</span> <span>9</span><span>).</span><span>toSeq</span>
<span>echo</span> <span>s</span><span>.</span><span>map</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span> <span>x</span> <span>*</span> <span>x</span><span>)</span> <span># always @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span>echo</span> <span>s</span><span>.</span><span>map</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span> <span>*</span> <span>x</span><span>)</span> <span># from sugar module</span>
<span>echo</span> <span>s</span><span>.</span><span>mapIt</span><span>(</span><span>it</span> <span>*</span> <span>it</span><span>)</span>

<span>echo</span> <span>s</span><span>.</span><span>mapIt</span><span>(</span><span>&#34;*&#34;</span> <span>&amp;</span> <span>$</span><span>it</span> <span>&amp;</span> <span>&#34;*&#34;</span><span>)</span> <span># @[&#34;*0*&#34;, &#34;*1*&#34;, &#34;*2*&#34;, &#34;*3*&#34;, &#34;*4*&#34;, &#34;*5*&#34;, &#34;*6*&#34;, &#34;*7*&#34;, &#34;*8*&#34;, &#34;*9*&#34;]</span>

<span>echo</span> <span>s</span><span>.</span><span>filter</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span> <span>(</span><span>x</span> <span>and</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span># both @[0, 2, 4, 6, 8]</span>
<span>echo</span> <span>s</span><span>.</span><span>filterIt</span><span>((</span><span>it</span> <span>and</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span></code></pre>
</div>
</div>
<p>The map variants return a new <span>seq</span>, with an operation performed on all items.
The returned <span>seq</span> can have a different base type. In line 4 we used the <span>⇒</span> operator from
the <span>sugar</span> module for a simpler notation</p>
<p>The <span>filter()</span> variants apply a <span>proc</span> with boolean result type on the <span>seq</span> items and
return the items for which the result is true. Remembering if the elements for
which the <span>procs</span> gives a <span>true</span> result are returned or removed from the initial
<span>seq</span> may be not easy. It helps to remember that <span>filter()</span> behaves like the <span>keepIf()</span> <span>procs</span> — items with positive result survive.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span><span>,</span> <span>sugar</span>
<span>var</span> <span>s</span> <span>=</span> <span>(</span><span>0</span> <span>..</span> <span>9</span><span>).</span><span>toSeq</span>
<span>var</span> <span>s1</span> <span>=</span> <span>s</span>
<span>s1</span><span>.</span><span>apply</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span> <span>*</span> <span>x</span><span>)</span> <span># @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span>s1</span> <span>=</span> <span>s</span>
<span>s1</span><span>.</span><span>keepIf</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span> <span>(</span><span>x</span> <span>and</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span># @[0, 2, 4, 6, 8]</span></code></pre>
</div>
</div>
<p>In above code we used <span>toSeq()</span> with a slice argument to create
an initial sequence with continues integers from the slice.
The <span>apply()</span> function performs a transformation operation on all the items,
and <span>keepIf()</span> preserve only the items for which a boolean predicate evaluates to <span>true</span>.</p>
<p>Two useful predicate functions are <span>any()</span> and <span>all()</span> to check if at least one item fulfills
a condition or if all items fulfill a condition:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>var</span> <span>s</span> <span>=</span> <span>(</span><span>0</span> <span>..</span> <span>9</span><span>).</span><span>toSeq</span>
<span>echo</span> <span>s</span><span>.</span><span>all</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span> <span>x</span> <span>&lt;</span> <span>10</span><span>)</span> <span># true</span>
<span>echo</span> <span>s</span><span>.</span><span>any</span><span>(</span><span>proc</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>bool</span> <span>=</span> <span>x</span> <span>*</span> <span>x</span> <span>==</span> <span>25</span><span>)</span> <span># true</span></code></pre>
</div>
</div>
<p>With <span>zip()</span> we can join the items of two sequences to tuples, and with <span>unzip()</span> we
can separate the tuple items again in two separate sequences:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>var</span> <span>s</span> <span>=</span> <span>(</span><span>0</span> <span>..</span> <span>9</span><span>).</span><span>toSeq</span>
<span>var</span> <span>s1</span> <span>=</span> <span>s</span><span>.</span><span>mapIt</span><span>(</span><span>it</span> <span>*</span> <span>it</span><span>)</span>
<span>var</span> <span>z</span> <span>=</span> <span>zip</span><span>(</span><span>s</span><span>,</span> <span>s1</span><span>)</span>
<span>echo</span> <span>z</span>
<span>echo</span> <span>z</span><span>.</span><span>unzip</span>
<span># @[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)]</span>
<span># (@[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</span></code></pre>
</div>
</div>
<p>Finally sometimes the templates <span>foldl()</span> and <span>foldr()</span> can be useful for folding a sequence, that
is to generate one final value from all the items. The fold templates uses the variables <span>a</span> and <span>b</span>
to generate the result, a + b would sum all the items. <span>Foldl()</span> performs the operation
from left to right, returning the accumulation and accepts an optional start value, while
<span>foldr()</span> starts from right, i.e. with the item at the end of the <span>seq</span>.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span>
<span>var</span> <span>s</span> <span>=</span> <span>(</span><span>0</span> <span>..</span> <span>9</span><span>).</span><span>toSeq</span>
<span>echo</span> <span>s</span><span>.</span><span>foldl</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>,</span> <span>100</span><span>)</span> <span># 145</span>
<span>echo</span> <span>s</span><span>.</span><span>foldr</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>#45</span></code></pre>
</div>
</div>
<p>The <span>sequtils</span> module contains some more <span>procs</span>, templates and macros that are not needed that often.
It would not make much sense to mention all of them here, as it is already not easy to remember
the ones that we have introduced above. You should skim the <span>sequtils</span> API docs from time to time
to remember what is available.</p>
<p>Maybe you have missed the difference of two sequences which some other programming languages
provide:</p>
<div>
<div>
<pre><code data-lang="nim"><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>5</span><span>]</span> <span>-</span> <span>[</span><span>2</span><span>,</span> <span>4</span><span>]</span> <span># [1, 3, 5]</span></code></pre>
</div>
</div>
<p>Well that is an expensive operation, O(n^2) if implemented in a naive way, as it may iterate for all
items in the second <span>seq</span> over the whole first <span>seq</span> to remove the unwanted items.
A better approach is to convert the items in the second <span>seq</span> to a temporary (hash) <span>set</span> to allow faster query:</p>
<p>A fast on the fly solution is this, as suggested by someone in the Nim forum:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span><span>,</span> <span>sets</span><span>,</span> <span>sugar</span>
<span>let</span> <span>a</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>,</span> <span>7</span><span>,</span> <span>0</span><span>]</span>
<span>let</span> <span>b</span> <span>=</span> <span>[</span><span>7</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>7</span><span>]</span>
<span>let</span> <span>bSet</span> <span>=</span> <span>b</span><span>.</span><span>toHashSet</span><span>()</span>
<span>echo</span> <span>a</span><span>.</span><span>filter</span><span>((</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>notin</span> <span>bSet</span><span>)</span> <span># @[2, 5, 2, 9, 0]</span></code></pre>
</div>
</div>
<p>When we should need this operation often, we may define our own <span>proc</span> like</p>
<div>
<div>
<pre><code data-lang="nim"><span># https://ruby-doc.org/core-2.6/Array.html#method-i-2D</span>
<span># Array Difference</span>
<span>import</span> <span>sets</span>

<span>proc </span><span>`-`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>openArray</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>seq</span><span>[</span><span>T</span><span>]</span> <span>=</span>
  <span>let</span> <span>s</span> <span>=</span> <span>b</span><span>.</span><span>toHashSet</span>
  <span>result</span> <span>=</span> <span>newSeq</span><span>[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>.</span><span>len</span><span>)</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>for</span> <span>el</span> <span>in</span> <span>a</span><span>:</span>
    <span>if</span> <span>el</span> <span>notin</span> <span>s</span><span>:</span>
      <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>el</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>result</span><span>.</span><span>setLen</span><span>(</span><span>i</span><span>)</span>

<span>proc </span><span>`-=`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>b</span><span>:</span> <span>openArray</span><span>[</span><span>T</span><span>]</span><span>)</span> <span>=</span>
  <span>let</span> <span>s</span> <span>=</span> <span>b</span><span>.</span><span>toHashSet</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>var</span> <span>j</span> <span>=</span> <span>0</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>a</span><span>.</span><span>len</span><span>:</span>
    <span>if</span> <span>a</span><span>[</span><span>i</span><span>]</span> <span>notin</span> <span>s</span><span>:</span>
      <span>a</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span>
      <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>a</span><span>.</span><span>setLen</span><span>(</span><span>a</span><span>.</span><span>len</span> <span>-</span> <span>(</span><span>i</span> <span>-</span> <span>j</span><span>))</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>let</span> <span>a</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>,</span> <span>7</span><span>,</span> <span>0</span><span>]</span>
  <span>let</span> <span>b</span> <span>=</span> <span>[</span><span>7</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>7</span><span>]</span>
  <span>echo</span> <span>a</span> <span>-</span> <span>b</span>
  <span>echo</span> <span>b</span> <span>-</span> <span>a</span>

  <span>var</span> <span>x</span> <span>=</span> <span>@</span><span>a</span>
  <span>x</span> <span>-=</span> <span>b</span>
  <span>echo</span> <span>x</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<div>
<div>
<pre>@[2, 5, 2, 9, 0]
@[4, 10]
@[2, 5, 2, 9, 0]</pre>
</div>
</div>
<p>Note that this preserves the order in the first <span>seq</span>, which is often requested. If order is not
important, then we could convert both sequences to a <span>set</span> and build the <span>set</span> difference — but when order does not matter we may use sets instead of sequences from the beginning.</p>
<p>Maybe you missed also a <span>shift()</span> function which other container types or programming languages may provide, that is
used similar to <span>pop()</span>, but deletes and returns the the first item of a <span>seq</span>? Well it should be obvious why a
<span>shift()</span> is not provided by default and why such a function would generally be avoided — the function
name gives you already a good hint. And if you should need such a function it should be no problem
to implement one if efficiency is really not important. But maybe in that case it would be better to
use a different container type, maybe the double-ended queue provided by the <span>deques</span> module.</p>
<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_random_numbers">Random Numbers</h2>
<div>
<p>Most computer programs work fully deterministic, that is one input data set
generates exactly one well defined output data set. This behavior is not
desired when we create games or simulations: The actions of computer controlled characters
should not do exactly the same again and again when we restart the game, and maybe
the computer generated landscape in the game should look different when we restart the game too.</p>
<p>To generate such an unpredictable behavior we use random number generators, which can generate
sequences of random number of integer or <span>float</span> type. The most important property of true random numbers is
that we can not predict the next one from the sequence of all values seen before. Random number sources have no memory!
Children often think they have. If a child got value six in a dice game tree times in sequence, its often assumes that it is extremely
unlikely that next roll will give again the value 6. But as the dice has no memory, chance to get a specific number is always
1/6, as we have 6 possible values all with same probability. At least when the dice is not manipulated.
Another important property of random numbers is the distribution of the possible values. For most random
number sources we would expect a uniform distribution of all possible values: For a dice with numbers 1 .. 6 we
would expect that we get all these numbers with nearly the same total quantity when we roll the dice for a long time again and again.
But of course not all random quantities are distributes uniformly. The distribution can have different shapes. An important non uniform
distribution is the Gauss distribution, where the final result depends on many random decisions. So an average value
is more likely than extreme values. You may know the marble nail board with multiple slots as an example: Marbles are thrown in at the
top, and whenever they hit a nail, they get distracted to the left or right.</p>
<p>To built a perfect random generator we would have to use some physical noise sources like photons emitted by a thermal light source
falling on a light detector with single photon resolution (Photo-multiplier), radioactive decay, thermal noise or similar physical entropy sources. But using real physically
sources for random numbers is difficult and the random number generation is slow. So in computer programming
we generally use so called pseudo-random-numbers, which are sequences of numbers calculated based on a given starting
number. A mathematical function gets the last n numbers seen before and generates the next one from that. If that function uses a
smart mathematical expression, its results looks really like random numbers. For games the generated sequences are generally good enough,
for cryptographic applications they may be not good enough. So what we need for a random number generator is
a sequence of start numbers, and a mathematical function with internal state. For each call of that
function a new random number is returned and the internal stage is changed so that next call
will result in a different number. When we use always the same sequence of starting numbers, then
our generator would generate always the same sequence of random numbers. Sometimes this is desired, e.g. when we want
a behavior that looks random, but is reproducible, maybe for debugging tasks. But in most cases we would use
starting numbers that are different for each program start. To get well suited start numbers we can just use the current
time with nanosecond resolution which most computer hardware do provide.</p>
<p>Most simple and fast random number generators use for its internal state two integer numbers. From these
two numbers the next random value is calculated and then the numbers representing the
internal state are modified also, to ensure that the next generated number is again different.</p>
<p>Nim uses in its <span>random</span> module an implementation of the xoroshiro128+ (xor/rotate/shift/rotate) library.
A <span>Rand</span> object with two integer fields is used to store the actual state, and some simple and fast
logic operations as bit shift, logical xor and addition is used to update state and to generate the
next number:</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
<span>when</span> <span>defined</span><span>(</span><span>js</span><span>):</span>
  <span>type</span> <span>Ui</span> <span>=</span> <span>uint32</span>
  <span>const</span> <span>randMax</span> <span>=</span> <span>4_294_967_295u32</span>
<span>else</span><span>:</span>
  <span>type</span> <span>Ui</span> <span>=</span> <span>uint64</span>

  <span>Rand</span><span>*</span> <span>=</span> <span>object</span> <span># State of a random number generator.</span>
    <span>a0</span><span>,</span> <span>a1</span><span>:</span> <span>Ui</span>

<span>proc </span><span>rotl</span><span>(</span><span>x</span><span>,</span> <span>k</span><span>:</span> <span>Ui</span><span>):</span> <span>Ui</span> <span>=</span>
  <span>result</span> <span>=</span> <span>(</span><span>x</span> <span>shl</span> <span>k</span><span>)</span> <span>or</span> <span>(</span><span>x</span> <span>shr</span> <span>(</span><span>Ui</span><span>(</span><span>64</span><span>)</span> <span>-</span> <span>k</span><span>))</span>

<span>proc </span><span>next</span><span>*</span><span>(</span><span>r</span><span>:</span> <span>var</span> <span>Rand</span><span>):</span> <span>uint64</span> <span>=</span>
  <span>let</span> <span>s0</span> <span>=</span> <span>r</span><span>.</span><span>a0</span>
  <span>var</span> <span>s1</span> <span>=</span> <span>r</span><span>.</span><span>a1</span>
  <span>result</span> <span>=</span> <span>s0</span> <span>+</span> <span>s1</span>
  <span>s1</span> <span>=</span> <span>s1</span> <span>xor</span> <span>s0</span>
  <span>r</span><span>.</span><span>a0</span> <span>=</span> <span>rotl</span><span>(</span><span>s0</span><span>,</span> <span>55</span><span>)</span> <span>xor</span> <span>s1</span> <span>xor</span> <span>(</span><span>s1</span> <span>shl</span> <span>14</span><span>)</span> <span># a, b</span>
  <span>r</span><span>.</span><span>a1</span> <span>=</span> <span>rotl</span><span>(</span><span>s1</span><span>,</span> <span>36</span><span>)</span> <span># c</span></code></pre>
</div>
</div>
<p>The <span>Rand</span> object stores the internal state, <span>rotl()</span> is a helper function which
updates the state for each call, and <span>next()</span> is the actual generator procedure
returning an <span>uint64</span> value. Note that the addition used in <span>next()</span> does
wraps around instead of giving an overflow error as unsigned integers
are used. The numbers returned by the <span>rand()</span> <span>proc</span> are the foundation for
all the other random number types provided by the <span>random</span> module.
To get integers with reduced numeric range, we can just use the modulo
operation, and to get <span>float</span> results we may convert the integer value to float and apply
some basic mathematical operations like division for range reduction.</p>
<p>The most basic functions provided by the <span>random</span> module are the overloaded <span>rand()</span>
functions. <span>Rand()</span> called with an integer parameter <span>n</span> gives us integer random numbers in the
range from <span>0</span> up to <span>n</span>, and <span>rand()</span> called with a <span>float</span> parameter <span>x</span> will give us
random <span>float</span> numbers in the range <span>0 .. x</span>. When we just use the rand() functions in this way
we would get the same sequence of numbers for each run of our program, as the generator
always starts with the same well defined initial state. We can call
the <span>proc</span> <span>randomize()</span> before calling <span>rand()</span> to initialize the generator to a different
state based on the current time. Then <span>rand()</span> will provide us with different
number sequences for each start of our program.</p>
<p>Generally it is a good idea to not use the one internal global state of the <span>random</span> module
for generation our random number, but to use our own state variable. That way we
prevent conflicts with other modules which may use the <span>random</span> module as well. Imagine that
we want to get the same sequence of random numbers for each run of our program
as we are debugging our game, but another module initialize the internal state
of module <span>random</span> with a value based on the current time.</p>
<p>So the module <span>random</span> provides overloaded <span>rand()</span> functions that gets a state variable:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>times</span> <span>import</span> <span>getTime</span><span>,</span> <span>toUnix</span><span>,</span> <span>nanosecond</span>
<span>import</span> <span>random</span>

<span>let</span> <span>now</span> <span>=</span> <span>getTime</span><span>()</span>
<span>var</span> <span>rstate</span> <span>=</span> <span>initRand</span><span>(</span><span>now</span><span>.</span><span>toUnix</span> <span>*</span> <span>1_000_000_000</span> <span>+</span> <span>now</span><span>.</span><span>nanosecond</span><span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>5</span><span>:</span>
  <span>echo</span> <span>rstate</span><span>.</span><span>rand</span><span>(</span><span>5</span><span>)</span> <span>+</span> <span>1</span> <span># dice roll</span>

<span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>2</span><span>:</span>
  <span>echo</span> <span>rstate</span><span>.</span><span>rand</span><span>(</span><span>100.0</span><span>)</span> <span># float random number in range 0.0 .. 100.0</span></code></pre>
</div>
</div>
<p>Unfortunately the <span>initRand()</span> call to initialize it with a current time value is a bit complicated, as
we have to provide the current time value directly. Note that you generally should call
<span>initRand()</span> only once in your program. A common mistake of beginners is to call
<span>initRand()</span> each time directly in from of the <span>rand()</span> call. That is not only not needed and
slows down the generation process, it also can lead to strange number sequences.</p>
<p>At the end of this section we will discuss the problem of filling a container with random but unique
numbers. For example assume that we want to generate a sequence of <span>100</span> random numbers in the range <span>1 .. 100</span>,
with the restriction that each number should occur exactly once in the sequence. Of course a code
segment like <span>s[i] = (rand(99) + 1)</span> would not work, as the same numbers could be generated multiple times
or not at all. The obvious solution for this task is to fill an array first with consecutive numbers <span>1</span> to <span>100</span> and
then exchange the initial positions with destination positions determined by <span>rand(99)</span>
The <span>random module provides the [.func]#shuffle()</span> function for this shaking of a container.
A related function is <span>sample()</span>, which is used to randomly select an element from an <span>openArray</span> or a <span>set</span>.</p>
<p>References:</p>

</div>
</div>
<div>
<h2 id="_timers">Timers</h2>
<div>
<p>Sometimes we may want to measure the execution time of a code segment of
our program. For this the Nim standard library provides various modules
including the larger <span>times</span> module and the <span>monotimes</span> module.
The <span>times</span> module provides many functions and data types for handling
dates and times, while the small <span>monotimes</span> module is more specialized for measuring
of time intervals. For our first test we will use the <span>times.cpuTime()</span> function and
the <span>monotimes.getMonoTime()</span> function. The former gives us time values as seconds
in <span>float</span> format, while the later returns an <span>int64</span> nanosecond value. To measure execution
times of code segments we ask for the current time at the start and at the end of that segment and
build the difference. Actually we will try to measure the time needed for a <span>float</span> square root calculation.
In the past calculating square roots was considered a relatively slow operation, slow compared to
a plain floating point math operation like multiplication or division. But on most modern hardware
square root calculation is really fast actually as we will see.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>random</span><span>,</span> <span>times</span><span>,</span> <span>monotimes</span><span>]</span>
<span>from</span> <span>std</span><span>/</span><span>math</span> <span>import</span> <span>sqrt</span>

<span>proc </span><span>warmup</span> <span>=</span>
  <span>var</span> <span>x</span><span>:</span> <span>float</span>
  <span>for</span> <span>i</span> <span>in</span> <span>1</span> <span>..</span> <span>1e10.</span><span>int</span><span>:</span>
    <span>x</span> <span>+=</span> <span>1.0</span> <span>/</span> <span>i</span><span>.</span><span>float</span>
  <span>echo</span> <span>x</span>

<span>proc </span><span>main1</span> <span>=</span>
  <span>let</span> <span>x</span> <span>=</span> <span>rand</span><span>(</span><span>3.0</span><span>)</span>
  <span>let</span> <span>y</span> <span>=</span> <span>rand</span><span>(</span><span>7.0</span><span>)</span>
  <span>let</span> <span>start</span> <span>=</span> <span>cpuTime</span><span>()</span>
  <span>let</span> <span>res</span> <span>=</span> <span>sqrt</span><span>(</span><span>x</span><span>)</span> <span>+</span> <span>y</span>
  <span>let</span> <span>stop</span> <span>=</span> <span>cpuTime</span><span>()</span>
  <span>echo</span> <span>stop</span> <span>-</span> <span>start</span>
  <span>echo</span> <span>res</span>

<span>proc </span><span>main2</span> <span>=</span>
  <span>let</span> <span>x</span> <span>=</span> <span>rand</span><span>(</span><span>3.0</span><span>)</span>
  <span>let</span> <span>y</span> <span>=</span> <span>rand</span><span>(</span><span>7.0</span><span>)</span>
  <span>let</span> <span>start</span> <span>=</span> <span>getMonoTime</span><span>()</span>
  <span>let</span> <span>res</span> <span>=</span> <span>sqrt</span><span>(</span><span>x</span><span>)</span> <span>+</span> <span>y</span>
  <span>let</span> <span>stop</span> <span>=</span> <span>getMonoTime</span><span>()</span>
  <span>echo</span> <span>stop</span> <span>-</span> <span>start</span>
  <span>echo</span> <span>res</span>

<span>randomize</span><span>()</span>
<span>warmup</span><span>()</span>
<span>main1</span><span>()</span>
<span>main2</span><span>()</span></code></pre>
</div>
</div>
<p>To get meaningful results we have to take some care: Most important is, that
the code segment that we want to measure is really executed. This may sound odd, but
assume that the code produces no noticeable result at all. In that case the compiler may just remove
that code fragment from the generated executable, as it is not needed for correct program execution. Or assume
that the code fragment uses only data which is already known at compile time. Then
the compiler may do all of the calculations already at compile time, and the whole
code fragment is removed again and replaced by the pre-calculated values. And finally we
have to remember that our computer may execute other task at the same time or may be in
various power saving states with reduced CPU clock frequency, from which it takes some time to wake up. To take care of this we
try to execute some warmup code before our actual timing task, and we do use the <span>rand()</span> function
from the
<span>random</span> module to provide input values for our code that are not known during compile time.
Finally we output the result of the calculation by use of an <span>echo()</span> statement to make clear
to the
compiler that the result of the calculation is really needed. Now let us compile and run this program.
We compile with option -d:release or -d:danger to enable optimizations and avoid generation of debugging code
that may distort our timing. The result is still a bit surprising:</p>
<div>
<div>
<pre>$ ./t1
23.6030665949975
4.98999998654881e-07
4.676567857718999
42 nanoseconds
8.527354349689125</pre>
</div>
</div>
<p>Lines tree and five are the results of our timing attempt. Both values are obvious too large and do
not match. The reason for the wrong results is the overhead by the function calls itself. That overhead seems
to be much larger for the <span>cpuTime()</span> call, as we get result of about <span>500</span> nanoseconds. Maybe the reason for this is
that <span>cpuTime()</span> works with <span>floats</span> internally. At least we see that <span>getMonoTime()</span> can measure time intervals
in the range of a few hundred nanoseconds. When we run the program a few times the printed time intervals
may vary. The reason for that are internal processes in the CPU like clock rate and state changes. Generally the
smallest time value of multiple program executions is the most important for us, as that is the minimal
time which is actually needed for the program execution. With this example we have learned how we can measure
time differences in our program, and that measuring really small time intervals is difficult.</p>
<p>Fortunately measuring such tiny time intervals is supported by the criterion package, which we may describe
in later sections of the book.</p>
<p>For now we will present another example program, where we measure program code with longer running times.
For that we create a loop that is executed many times. So the offset of the timer functions calls can be neglected
compared to the actual running time of the loop, and due to the longer running time the printed time values get
more reliable with low variations:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>random</span><span>,</span> <span>times</span><span>,</span> <span>monotimes</span><span>]</span>
<span>from</span> <span>std</span><span>/</span><span>math</span> <span>import</span> <span>sqrt</span>

<span>proc </span><span>main3</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>array</span><span>[</span><span>64</span> <span>*</span> <span>1024</span><span>,</span> <span>float</span><span>]</span>
  <span>var</span> <span>res</span><span>:</span> <span>float</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>s</span><span>.</span><span>high</span><span>:</span>
    <span>s</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>rand</span><span>(</span><span>100.0</span><span>)</span>
  <span>let</span> <span>start</span> <span>=</span> <span>getMonoTime</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>s</span><span>.</span><span>high</span><span>:</span>
    <span>res</span> <span>+=</span> <span>sqrt</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>)</span>
  <span>let</span> <span>stop</span> <span>=</span> <span>getMonoTime</span><span>()</span>
  <span>echo</span> <span>stop</span> <span>-</span> <span>start</span>
  <span>echo</span> <span>res</span>

<span>proc </span><span>main4</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>array</span><span>[</span><span>64</span> <span>*</span> <span>1024</span><span>,</span> <span>float</span><span>]</span>
  <span>var</span> <span>res</span><span>:</span> <span>float</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>s</span><span>.</span><span>high</span><span>:</span>
    <span>s</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>rand</span><span>(</span><span>100.0</span><span>)</span>
  <span>let</span> <span>start</span> <span>=</span> <span>cpuTime</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>s</span><span>.</span><span>high</span><span>:</span>
    <span>res</span> <span>+=</span> <span>sqrt</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>)</span>
  <span>let</span> <span>stop</span> <span>=</span> <span>cpuTime</span><span>()</span>
  <span>echo</span> <span>stop</span> <span>-</span> <span>start</span>
  <span>echo</span> <span>res</span>

<span>randomize</span><span>()</span>
<span>main3</span><span>()</span>
<span>main4</span><span>()</span></code></pre>
</div>
</div>
<p>For this example program we first fill an array with 64k random <span>float</span> numbers and than sum the square root of these numbers.
As the total running time of our loops is not that tiny, we do not need a special warmup
function which is executed in front of the timed code. The output of our program show that
both timing functions match well for longer time periods:</p>
<div>
<div>
<pre>$ ./t2
112 microseconds and 701 nanoseconds
436909.89897942
0.0001135580000000001 # 114 microseconds
437222.3001038401</pre>
</div>
</div>
<p>The float result in line 4 is 114 microseconds which matches well with the 112 microseconds
from line two. When you run this program multiple times you may notice that you may
get sometimes much lager results for both or for only one of the two values. That is not
surprising, as the computer is processing not only our program but many more, and due to task
switching our program may be suspended for some time. When we divide that 114 microseconds
by the number of loop iterations (64 * 1024) we get 1.7 nanoseconds, which is really surprising fast
for a square root calculation. The concrete value is for a modern Intel I7 CPU. Of course these 1.7
nanoseconds is not only the time needed for the square root calculation, but it includes
the operations with the loop counter and the time needed to fetch and to access the actual array elements.</p>
<p>As timing code segments is not an uncommon use case, there exists some external package which
improve or simplify these operations, like the criterion or benchy package. A related task is profiling
our program to find the part which takes the most CPU time, so that we can concentrate on these parts
to improve the total performance of our program. For profiling various tools like the Linux perf tool
are available, which we will discuss in more detail later in this book.</p>
<p>References:</p>

</div>
</div>
<div>
<h2 id="_hash_tables">Hash Tables</h2>
<div>
<p>A common task in computer programming is the storing and retrieving of
data records. The situation is very easy whenever each data record is directly
mapped to
continuous integer number n0, n0+1, n0+2, …​, n0+M. In that case we can
use that numbers as index keys to access the data records and store the data as objects
or references to objects in a sequence, or maybe when the data set in small and the maximal
number of entries is known at compile time in an array.</p>
<p>In the past it was a common practice to give hardware parts in a shop and even customers
an unique id number from a continues range, so that storing and fast access in indexed containers
is possible. This works well when we really use the numbers as keys. But actually we generally
work with data which is already labeled by names expressed as sequences of ASCII character:
Customers in a hardware store, food in a super marked. Assigning id numbers to people is possible, but generally
people do not like to have to remember the assigned id number when they want to buy something
in a online shop.</p>
<p>So let us investigate how we can store and retrieve data objects without the use of continues
numbers as key. Assume we have a customer data base</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Customer</span> <span>=</span> <span>object</span>
    <span>lastName</span><span>:</span> <span>string</span>
    <span>firstName</span><span>:</span> <span>string</span>
    <span>age</span><span>:</span> <span>int</span>
    <span>postalAdress</span><span>:</span> <span>string</span>
    <span>phone</span><span>:</span> <span>string</span>
    <span>credit</span><span>:</span> <span>float</span></code></pre>
</div>
</div>
<p>Of course we can store the customers just in a seq, and do a linear search when we want to
access a person by name:</p>
<div>
<div>
<pre><code data-lang="nim"><span>customers</span><span>:</span> <span>seq</span><span>[</span><span>Customer</span><span>]</span>

<span># ...</span>

<span>var</span> <span>found</span> <span>=</span> <span>false</span>
<span>for</span> <span>c</span> <span>in</span> <span>customers</span><span>:</span>
  <span>if</span> <span>c</span><span>.</span><span>lastName</span> <span>==</span> <span>queryName</span><span>:</span>
    <span>found</span> <span>=</span> <span>true</span>
    <span>echo</span> <span>&#34;Person &#34;</span><span>,</span> <span>queryName</span><span>,</span> <span>&#34; has a credit limit of &#34;</span><span>,</span> <span>c</span><span>.</span><span>credit</span>
<span>if</span> <span>not</span> <span>found</span><span>:</span>
  <span>echo</span> <span>queryName</span><span>,</span>  <span>&#34;not found&#34;</span></code></pre>
</div>
</div>
<p>Such a plain linear search is not very fast of course. An obvious improvement would
be to sort the customers by names, as we can do a so called binary search in that case
as we did long time ago in printed telephone registers: Open the telephone book somewhere
in the middle, and when the names on that page are all greater than our friends name, then continue the
search in the first half of the book, otherwise in the last half. We continue the halving strategy
until we find the name. As we half the data set in each step this way, we say that the algorithm has
log2(N) cost, where log2 is the logarithm with base two and N is the size of the data set.</p>
<p>A similar solution would be to use some form of an ordered binary tree, which has also
log2(N) costs for retrieving operations. We will learn more about sorting sequences,
doing a binary search in a sorted seq and about tree structures later in the book.</p>
<p>A hash table, called only table in Nim, is a homogeneous resizable container that behaves similar
as the Nim sequences, but releases the restriction that for direct accessing an element its position in
the sequence has to be known.</p>
<p>The idea of a hash table is to use an arbitrary data type to directly access
objects stored in a container in a similar way as we can do it for arrays and
sequences with integer keys. The first step is to use a so called hash function to
map key objects, which are not already of integer type, to the integer type.
We would try to use a hash function which can be evaluated fast and which
maps our data to integer values distributed to the whole integer value space
without clustering. The integers generated by a hash function look in some way like
random numbers, they are distributed over the full integer value range without
an obvious order or systematic. Mapping arbitrary objects to integers is generally not
difficult. For as string a first attempt would be to use the characters of a string
in the same way as we calculate the value of a number literal by summing up
the digits each multiplied with powers of ten given by the position. For
a string that may look like</p>
<div>
<div>
<pre><code data-lang="nim"><span>intVal</span> <span>=</span> <span>uint</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>*</span> <span>256</span><span>^</span><span>0</span> <span>+</span> <span>uint</span><span>(</span><span>s</span><span>[</span><span>1</span><span>]</span><span>)</span> <span>*</span> <span>256</span><span>^</span><span>1</span> <span>+</span> <span>uint</span><span>(</span><span>s</span><span>[</span><span>2</span><span>]</span><span>)</span> <span>*</span> <span>256</span><span>^</span><span>2</span> <span>+</span> <span>...</span></code></pre>
</div>
</div>
<p>We multiply with powers of 256 as we have 256 different ASCII characters.</p>
<p>That would be not really a good hash function, as all short strings would be mapped
to low integer values, not distributed over the full value range. But similar, smarter
has functions are available.</p>
<p>So a hash function can map arbitrary data types to integers. But what we really want
is a sequence of continues integer values, which the hash functions does not provide
by design. But that is no real problem: In the same way as we can do a range reduction
for a random number generator function generating random numbers using the full
integer range by just applying a modulo operation, we can apply the modulo
operation on the value returned by a hash function.</p>
<p>Range reduction by modulo gives us smaller integer numbers, which may
already be some form of index values for an array or a seq. With two
restrictions: Index collisions can occur, as applying the hash function and the modulo range reduction on
different <span>strings</span> may give us the same index value. And some index values may be never generated.
The later is not that serious, some positions in the container would be remain unpopulated.
Collisions are much more serious of course, we have to handle them somehow. One solution
is, that we make each storage location in our container again a sequence, which can store
all the colliding data sets. That way our hash table would be a sequence, where each element is again
a short sequence containing all the colliding data record. For a data retrieving operation applying
the hash function with modulo data reduction would give us the position in the larger seq, and we
then would have to check all the elements in the short seq to find the actual record. In best case
the short seq contains only one entry, when no collision has occurred. For a customer data
base this strategy may be indeed the best solution, as in rare cases multiple different customers
may have exactly the same name. So it would be nice if for query operations in that case
a list of all customers with exactly that name is returned.</p>
<p>In practice often a modified strategy is applied preventing the seq in seq container type: We use
only one loosely populated seq, and whenever a collision occur, we just put the colliding data
record at some free index position after the position determined by the hash index value.
That way data retrieving starts by the position given by the hash key and then checks the data record
at that position and the following positions, until a matching record or an empty position is
found, the later case indicates that the queried data record is not contained in the data base.
Storing data records works similar: When the position given by the hash key is void, then the
new entry is stored at that position. If the index position is already occupied, then following
positions are examined until a void one is found and the data is stored there.</p>
<p>Hash tables work well generally when they are not too dense populated. Generally
we make the number of available index position double the size as the number
of expected entries. Then the change of collisions is not too large, and when a collisions
occurs, then chances are high that one of the next positions are still unpopulated.</p>
<p>When by inserting more and more data records the population density becomes too high, then generally
a new, larger table is allocated and the data records are moved from the old to the new table, in a similar
way as it is done for plain sequences when all capacity is occupied.</p>
<p>Now let us see how we can us the <span>tables</span> module of the Nim standard library to store the customer
record we introduced above:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>tables</span>

<span>type</span>
  <span>Customer</span> <span>=</span> <span>object</span>
    <span>lastName</span><span>:</span> <span>string</span>
    <span>firstName</span><span>:</span> <span>string</span>
    <span>yearOfBirth</span><span>:</span> <span>int</span>
    <span>postalAdress</span><span>:</span> <span>string</span>
    <span>phone</span><span>:</span> <span>string</span>
    <span>credit</span><span>:</span> <span>float</span>

<span>var</span> <span>customers</span><span>:</span> <span>Table</span><span>[</span><span>string</span><span>,</span> <span>Customer</span><span>]</span>

<span>proc </span><span>addNewCustomers</span> <span>=</span>
  <span>var</span> <span>c</span><span>:</span> <span>Customer</span>
  <span>c</span> <span>=</span> <span>Customer</span><span>(</span><span>lastName</span><span>:</span> <span>&#34;Turing&#34;</span><span>,</span> <span>firstName</span><span>:</span> <span>&#34;Alan&#34;</span><span>)</span>
  <span>c</span><span>.</span><span>postalAdress</span> <span>=</span> <span>&#34;England&#34;</span>
  <span>c</span><span>.</span><span>yearOfBirth</span> <span>=</span> <span>1912</span>
  <span>customers</span><span>[</span><span>&#34;Turing, Alan&#34;</span><span>]</span> <span>=</span> <span>c</span>

  <span>c</span> <span>=</span> <span>Customer</span><span>(</span><span>lastName</span><span>:</span> <span>&#34;Zuse&#34;</span><span>,</span> <span>firstName</span><span>:</span> <span>&#34;Konrad&#34;</span><span>)</span>
  <span>c</span><span>.</span><span>postalAdress</span> <span>=</span> <span>&#34;Germany&#34;</span>
  <span>c</span><span>.</span><span>yearOfBirth</span> <span>=</span> <span>1910</span>
  <span>customers</span><span>[</span><span>&#34;Zuse, Konrad&#34;</span><span>]</span> <span>=</span> <span>c</span>

<span>proc </span><span>queryCustomer</span><span>(</span><span>key</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>if</span> <span>customers</span><span>.</span><span>hasKey</span><span>(</span><span>key</span><span>):</span>
    <span>echo</span> <span>&#34;known customer:&#34;</span>
    <span>echo</span> <span>customers</span><span>[</span><span>key</span><span>]</span>
  <span>else</span><span>:</span>
    <span>echo</span> <span>&#34;customer key not found in data base&#34;</span>

<span>addNewCustomers</span><span>()</span>

<span>queryCustomer</span><span>(</span><span>&#34;Zuse, Konrad&#34;</span><span>)</span>
<span>queryCustomer</span><span>(</span><span>&#34;Gates, Bill&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>The basic usage of Nim tables is very similar to the use of sequences. While we have to specify only the
base type for a Nim <span>seq</span>, we have to specify the type of the key and the type of the stored entities
for a hash <span>Table</span>. The line <span>var customers: Table[string, Customer]</span> defines a variable with a generic <span>Table</span> type.
The table uses <span>strings</span> as keys and stores <span>Customer</span> objects. We can then use the <span>[]</span> subscript operator
to store <span>Customer</span> objects in the <span>Table</span>. As we created a <span>Table</span> with <span>string</span> key type, we have to specify <span>strings</span>
when we use the subscript operator or other functions to access entries of our table. For the query operation
we first call the function <span>hasKey()</span> to check if the customer with that name is contained in the data base and
then use again the subscript operator to access the data record.</p>
<p>The <span>tables</span> module of the Nim standard library provides many more functions for interacting with <span>Tables</span>.
Most are easy to understand and use. When you inspect the API docs of the <span>tables</span> module you will
discover that beside the <span>Table</span> data type also a <span>TableRef</span> exists. The <span>Table</span> type has value semantics, that
is if you copy a whole table instance, then the whole content is copied. <span>TableRef</span> instances have reference semantics,
the content is not copied when you assign one instance of a <span>TableRef</span> to another variable.</p>
<p>In the example above we called <span>hasKey()</span> to check if a data record is available before we accessed that record.
Access with the subscript operator <span>[]</span> would raise an exception when an entity is not available in the table.
<span>HasKey()</span> and <span>[]</span> both would have to locate the data record. A faster way to access data record when we are not sure
if they exists in the table is the <span>getOrDefault()</span> <span>proc</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>let</span> <span>dummy</span> <span>=</span> <span>Customer</span><span>()</span>
<span>let</span> <span>query</span> <span>=</span> <span>customers</span><span>.</span><span>getOrDefault</span><span>(</span><span>name</span><span>,</span> <span>dummy</span><span>)</span>
<span>if</span> <span>query</span><span>.</span><span>lastName</span><span>.</span><span>len</span> <span>==</span> <span>0</span><span>:</span> <span># we know all entries in the database have a lastName, so we got the dummy default value</span>
  <span>echo</span> <span>name</span><span>,</span> <span>&#34;not found&#34;</span>
<span>else</span><span>:</span>
  <span>process</span><span>(</span><span>query</span><span>)</span></code></pre>
</div>
</div>
<p>A useful variant of the <span>Table</span> data type is the <span>CountTable</span>, which we can use to count data object, maybe words in a text:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tables</span>
<span>var</span> <span>ct</span><span>:</span> <span>CountTable</span><span>[</span><span>string</span><span>]</span>
<span>ct</span><span>.</span><span>inc</span><span>(</span><span>&#34;Nim&#34;</span><span>)</span>
<span>ct</span><span>.</span><span>inc</span><span>(</span><span>&#34;Rust&#34;</span><span>)</span>
<span>ct</span><span>.</span><span>inc</span><span>(</span><span>&#34;Nim&#34;</span><span>)</span>

<span>echo</span> <span>ct</span><span>[</span><span>&#34;Nim&#34;</span><span>]</span>
<span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>ct</span><span>:</span>
  <span>echo</span> <span>k</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>v</span></code></pre>
</div>
</div>
<p>A <span>Table</span> instance stores entries not in the order of insertion. When we iterate over the <span>table</span>,
we get the results not back in the order of insertion. If we really should need to preserve
the insertion order we may use the <span>OrderedTable</span> variant. Note that an <span>OrderedTable</span>
does not sort its entries, it remembers insertion order. Ordered <span>Tables</span> have some internal
overhead, so we should use them only when necessary.</p>
<p>For all the various table variants we can use <span>procs</span> like <span>clear()</span>, <span>len()</span> or <span>del()</span> to remove all entries
from a table, to check for the number of entries or to delete entries. Note that some functions
may throw exceptions when we try to access entries that are not available. And note that
the subscript operator <span>=[]</span> overwrites already existing entries.</p>
<p>For our initial customer data base the current table implementation may still be not optimal, as
it is not clear how to handle different customers with the same name. But customer data
bases are really special cases, in most cases different things have different names.</p>
<div>
<h3 id="_user_defined_hash_values">User defined hash values</h3>
<p>The <span>tables</span> module uses the <span>hashes</span> module to calculate the hash value for the keys that
we use to access table content. For many data types the <span>hashes</span> module already defines
a hash function. When we would like to use <span>tuples</span> or <span>object</span> data types as keys for table access, then we would have to
define a hash function for that key objects first. The API documentation of the <span>tables</span> module
contains an example for this, where as key an object data type with firstName and lastName fields is used
to store salary entries in the table. While firstName and lastName are strings, and for single <span>strings</span> a predefined
hash function is available, we have to declare another hash function for objects with two strings:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tables</span><span>,</span> <span>hashes</span>

<span>type</span>
  <span>Person</span> <span>=</span> <span>object</span>
    <span>firstName</span><span>,</span> <span>lastName</span><span>:</span> <span>string</span>

<span>proc </span><span>hash</span><span>(</span><span>x</span><span>:</span> <span>Person</span><span>):</span> <span>Hash</span> <span>=</span>
  <span>## Piggyback on the already available string hash proc.</span>
  <span>##</span>
  <span>## Without this proc nothing works!</span>
  <span>result</span> <span>=</span> <span>x</span><span>.</span><span>firstName</span><span>.</span><span>hash</span> <span>!&amp;</span> <span>x</span><span>.</span><span>lastName</span><span>.</span><span>hash</span>
  <span>result</span> <span>=</span> <span>!$</span><span>result</span>

<span>var</span>
  <span>salaries</span> <span>=</span> <span>initTable</span><span>[</span><span>Person</span><span>,</span> <span>int</span><span>]</span><span>()</span>
  <span>p1</span><span>,</span> <span>p2</span><span>:</span> <span>Person</span>

<span>p1</span><span>.</span><span>firstName</span> <span>=</span> <span>&#34;Jon&#34;</span>
<span>p1</span><span>.</span><span>lastName</span> <span>=</span> <span>&#34;Ross&#34;</span>
<span>salaries</span><span>[</span><span>p1</span><span>]</span> <span>=</span> <span>30_000</span></code></pre>
</div>
</div>
<p>The hash generation is a bit cryptic: First we mix various existing hash values using the <span>!&amp;</span> operator, and finally
we use the <span>!$</span> operator to generate the final hash value. For details please see the API documentation of the <span>hashes</span> module.</p>
<p>Hash tables can be seen as a way to attach arbitrary data to other data. The above example attaches a &#34;salary&#34; to
a person object. In most cases we would just create one more object field when we have to store more data, but sometimes
that is not easily possible. One example is when we use a low level C library, which gives us some C objects back. Maybe
we use an advanced C or C++ math library like CGAL, and we get some abstract low level objects from it, maybe circles
with center coordinate and diameter. As that objects are not Nim object, but C or C++ entities, we can not easily subclass
them to attach more properties like a color attribute. But as each entity has a unique address, we can just use a
table with key type address and all the needed values like color as data. That would be some overhead of course, as
each color lookup would mean a table access, but it is a simple solution.</p>
<p>We can even attach properties to plain data types this way:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tables</span>

<span>var</span> <span>t</span><span>:</span> <span>Table</span><span>[</span><span>float</span><span>,</span> <span>string</span><span>]</span>

<span>let</span> <span>PI</span> <span>=</span> <span>3.1415</span>
<span>t</span><span>[</span><span>PI</span><span>]</span> <span>=</span> <span>&#34;Pi&#34;</span>
<span>t</span><span>[</span><span>2.0</span><span>]</span> <span>=</span> <span>&#34;two&#34;</span>

<span>echo</span> <span>t</span><span>[</span><span>PI</span><span>]</span>
<span>echo</span> <span>t</span><span>[</span><span>2.0</span><span>]</span>
<span>echo</span> <span>t</span><span>[</span><span>5.0</span> <span>-</span> <span>3.0</span><span>]</span></code></pre>
</div>
</div>
<p>For <span>floats</span> a predefined hash function is available, so the code above should work. But <span>floats</span> as keys are a bit fragile due
to the fact that <span>float</span> math is not really exact. So the last line in above code may raise an exception due to
access of a non existent entry, as the difference <span>5.0 - 3.0</span> may not exactly be identical to the value <span>2.0</span>.</p>
<p>Hash tables can be even useful containers, when we already have numeric data as possible keys for indices in a
sequence: In mathematics we could have a two dimensional array, that is an <span>array</span> of <span>array</span> in Nim, to store matrices.
This is OK when the matrix is really populated, that is most entries have meaningful non trivial values. But for
very large, loosely populated matrices, with mostly just zero or one entries, storing the whole matrix
as a table using a row, column tuple as key, may save a lot of RAM.</p>
</div>
<div>
<h3 id="_equality_and_identity">Equality and Identity</h3>
<p>When we use objects or references to objects as keys for tables, we have to remember
how Nim compares value and reference types:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tables</span><span>,</span> <span>hashes</span>

<span>type</span>

  <span>O</span> <span>=</span> <span>object</span>
    <span>i</span><span>:</span> <span>int</span>

  <span>R</span> <span>=</span> <span>ref</span> <span>object</span>
    <span>j</span><span>:</span> <span>int</span>

<span>proc </span><span>hash</span><span>(</span><span>o</span><span>:</span> <span>O</span><span>):</span> <span>Hash</span> <span>=</span> <span>hash</span><span>(</span><span>o</span><span>.</span><span>i</span><span>)</span>

<span>proc </span><span>hash</span><span>(</span><span>r</span><span>:</span> <span>R</span><span>):</span> <span>Hash</span> <span>=</span> <span>hash</span><span>(</span><span>cast</span><span>[</span><span>int</span><span>]</span><span>(</span><span>addr</span><span>(</span><span>r</span><span>[]</span><span>)))</span>

<span>var</span> <span>o1</span> <span>=</span> <span>O</span><span>(</span><span>i</span><span>:</span> <span>7</span><span>)</span>
<span>var</span> <span>o2</span> <span>=</span> <span>O</span><span>(</span><span>i</span><span>:</span> <span>7</span><span>)</span>
<span>var</span> <span>r1</span> <span>=</span> <span>R</span><span>(</span><span>j</span><span>:</span> <span>13</span><span>)</span>
<span>var</span> <span>r2</span> <span>=</span> <span>R</span><span>(</span><span>j</span><span>:</span> <span>13</span><span>)</span>

<span>echo</span> <span>o1</span> <span>==</span> <span>o2</span>
<span>echo</span> <span>r1</span> <span>==</span> <span>r2</span>

<span>var</span> <span>t1</span><span>:</span> <span>Table</span><span>[</span><span>O</span><span>,</span> <span>float</span><span>]</span>
<span>t1</span><span>[</span><span>o1</span><span>]</span> <span>=</span> <span>3.1415</span>
<span>echo</span> <span>t1</span><span>.</span><span>hasKey</span><span>(</span><span>o2</span><span>)</span>

<span>var</span> <span>t2</span><span>:</span> <span>Table</span><span>[</span><span>R</span><span>,</span> <span>float</span><span>]</span>
<span>t2</span><span>[</span><span>r1</span><span>]</span> <span>=</span> <span>2.7</span>
<span>echo</span> <span>t2</span><span>.</span><span>hasKey</span><span>(</span><span>r2</span><span>)</span></code></pre>
</div>
</div>
<p>The output of above program is</p>

<p>By default the <span>==</span> operator compares content for value <span>objects</span>, but the instance addresses for references.
Because of this it makes sense to define hash functions for <span>object</span> types and <span>ref</span> <span>object</span> types
in a compatible way: We use the hash value of the single integer field of our value object as hash result
for the whole object, and we use the address of the instance for the hash value of the reference object.
As different instances of <span>ref</span> objects have always different addresses, the hasKey() does return false
when we use as argument a different instance variable, independent on the content of its fields.</p>
<p>For special use cases we may redefine the <span>==</span> operator, but we have to ensure that the defined hash function
matches the <span>==</span> operator: When <span>a == b</span> is true, then <span>hash(a)</span> has to be identical to <span>hash(b)</span>! The reason is
that tables first compare the hash value of query key with key of entities in the table, and only for matching
hash value do comparison of the actual data content.</p>
</div>
<div>
<h3 id="_performance">Performance</h3>
<p>Hash table lookup is fast. We say that hash table lookup is a O(1) operation, which shall indicate that
the time needed for doing a table lookup does not depend on the total number of entries stored in the table.
The reason for that is that for a lookup it is necessary to calculate the hash value, do the modulo operation and
access the table content and maybe a few of the following table entries in the case that the first entry is not a match.
Storing data is also an O(1) operation, as it works very similar, as long as the table is not already too dense populated
so that a recreation is necessary. In that case that single storing operation is obviously very slow, but that
occurs very rarely, and maybe not at all when we use a large enough table from the beginning.
Still small tables are much faster than larger tables due to cache effects. For small tables
all data may fit into the caches of the CPU, while for large tables most data is located outside of caches in RAM, and RAM
access is magnitudes slower than cache access.</p>
<p>And hash table lookup is slower than <span>array</span> or <span>seq</span> access. To access an element from an <span>array</span> or <span>seq</span>
we have only to multiply the index value with the byte size of the stored elements type and maybe
to add an offset when the <span>array</span> does not start at index <span>0</span>. For tables we have to calculate the hash value,
do the modulo operation, access some elements at the calculated position, and most importantly, to compare
the content at that positions with the actual key data. If the key is a <span>string</span>, a few <span>string</span> comparisons (at least one) are necessary
to determine if the query element is available in the table. So while <span>array</span> access may take less than a nanosecond on modern hardware,
table lookup may take a few dozens of nanoseconds. Lookup with <span>string</span> keys is generally slower than for
other key types likes integer, as for string comparison it may be necessary to compare many characters to get a result
and because strings generates some memory indirection by the fact that string content is stored somewhere in the heap
outside of any cache.</p>
</div>
<div>
<h3 id="_tuples_or_other_containers_as_keys">Tuples or other containers as Keys</h3>
<p>At the end of our introduction to hash tables we will present a very useful, but maybe not
that obvious property of hash tables: The keys used for table access don’t have to be simple data types,
but can be container types like <span>tuples</span> or <span>arrays</span>. Imagine you have a map in 2d with a set of points on that
map each presented by an <span>x</span>, <span>y</span> coordinate pair. That points could be cities, and some cities may have a direct connection
by a road. So how can we test if two cities are directly connected and get the distance between the two cities?
With a hash table using a tuple of two city coordinates as key it is easy:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>tables</span><span>,</span> <span>math</span>

<span>const</span>
  <span>InvalidFloat</span> <span>=</span> <span>1e30</span> <span># arbitrary marker that in not a valid value</span>
  <span>InvalidCoord</span> <span>=</span> <span>(</span><span>InvalidFloat</span><span>,</span> <span>InvalidFloat</span><span>)</span>

<span>type</span>
  <span>Coord</span> <span>=</span> <span>tuple</span>
    <span>x</span><span>:</span> <span>float</span>
    <span>y</span><span>:</span> <span>float</span>

  <span>Cities</span> <span>=</span> <span>Table</span><span>[</span><span>string</span><span>,</span> <span>Coord</span><span>]</span>
  <span>Distances</span> <span>=</span> <span>Table</span><span>[</span><span>(</span><span>Coord</span><span>,</span> <span>Coord</span><span>),</span> <span>float</span><span>]</span>

<span>var</span> <span>cities</span><span>:</span> <span>Cities</span>
<span>var</span> <span>distances</span><span>:</span> <span>Distances</span>

<span>proc </span><span>insertCity</span><span>(</span><span>name</span><span>:</span> <span>string</span><span>;</span> <span>coord</span><span>:</span> <span>Coord</span><span>)</span> <span>=</span>
  <span>cities</span><span>[</span><span>name</span><span>]</span> <span>=</span> <span>coord</span>

<span>proc </span><span>insertDist</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>var</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>if</span> <span>a</span> <span>&gt;</span> <span>b</span><span>:</span> <span>swap</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>let</span> <span>ca</span> <span>=</span> <span>cities</span><span>[</span><span>a</span><span>]</span> <span># caution, will raise an exception if name is not a know city</span>
  <span>let</span> <span>cb</span> <span>=</span> <span>cities</span><span>[</span><span>b</span><span>]</span>
  <span>distances</span><span>[</span><span>(</span><span>ca</span><span>,</span> <span>cb</span><span>)</span><span>]</span> <span>=</span> <span>math</span><span>.</span><span>hypot</span><span>(</span><span>ca</span><span>.</span><span>x</span> <span>-</span> <span>cb</span><span>.</span><span>x</span><span>,</span> <span>ca</span><span>.</span><span>y</span> <span>-</span> <span>cb</span><span>.</span><span>y</span><span>)</span>

<span>proc </span><span>checkDirectConnection</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>string</span><span>):</span> <span>float</span> <span>=</span>
  <span>var</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>if</span> <span>a</span> <span>&gt;</span> <span>b</span><span>:</span> <span>swap</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>let</span> <span>ca</span> <span>=</span> <span>cities</span><span>.</span><span>getOrDefault</span><span>(</span><span>a</span><span>,</span> <span>InvalidCoord</span><span>)</span>
  <span>let</span> <span>cb</span> <span>=</span> <span>cities</span><span>.</span><span>getOrDefault</span><span>(</span><span>b</span><span>,</span> <span>InvalidCoord</span><span>)</span>
  <span>if</span> <span>ca</span> <span>==</span> <span>InvalidCoord</span> <span>or</span> <span>cb</span> <span>==</span> <span>InvalidCoord</span><span>:</span>
    <span>return</span> <span>-</span><span>1</span> <span># marker when cities are unknown</span>
  <span>result</span> <span>=</span> <span>distances</span><span>.</span><span>getOrDefault</span><span>((</span><span>ca</span><span>,</span> <span>cb</span><span>),</span> <span>InvalidFloat</span><span>)</span>

<span>insertCity</span><span>(</span><span>&#34;aTown&#34;</span><span>,</span> <span>(</span><span>2.0</span><span>,</span> <span>7.0</span><span>))</span>
<span>insertCity</span><span>(</span><span>&#34;bTown&#34;</span><span>,</span> <span>(</span><span>2.0</span><span>,</span> <span>11.0</span><span>))</span>
<span>insertCity</span><span>(</span><span>&#34;cTown&#34;</span><span>,</span> <span>(</span><span>17.0</span><span>,</span> <span>23.0</span><span>))</span>

<span>insertDist</span><span>(</span><span>&#34;aTown&#34;</span><span>,</span> <span>&#34;bTown&#34;</span><span>)</span>

<span>var</span> <span>d</span> <span>=</span> <span>checkDirectConnection</span><span>(</span><span>&#34;aTown&#34;</span><span>,</span> <span>&#34;bTown&#34;</span><span>)</span>
<span>if</span> <span>d</span> <span>==</span> <span>-</span><span>1</span><span>:</span>
  <span>echo</span> <span>&#34;query for unknown town&#34;</span>
<span>elif</span> <span>d</span> <span>==</span> <span>InvalidFloat</span><span>:</span>
  <span>echo</span> <span>&#34;Cities have no direct connection&#34;</span>
<span>else</span><span>:</span>
  <span>echo</span> <span>&#34;Distance: &#34;</span><span>,</span> <span>d</span>

<span>echo</span> <span>checkDirectConnection</span><span>(</span><span>&#34;bTown&#34;</span><span>,</span> <span>&#34;aTown&#34;</span><span>)</span> <span># 4, same as above</span>
<span>echo</span> <span>checkDirectConnection</span><span>(</span><span>&#34;aTown&#34;</span><span>,</span> <span>&#34;cTown&#34;</span><span>)</span> <span># 1e30</span>
<span>echo</span> <span>checkDirectConnection</span><span>(</span><span>&#34;aTown&#34;</span><span>,</span> <span>&#34;xTown&#34;</span><span>)</span> <span># -1</span></code></pre>
</div>
</div>
<p>For the <span>procs</span> <span>insertDist()</span> and <span>checkDirectConnection()</span> we use a trick to get the same
results when we exchange the names: We sort the names alphabetically when we insert
the distances and also when we query the distances. So we get the same result.
Of course we could insert the tuple also twice instead, but as distances is the same
in both direction sorting and inserting only ones makes some sense. Note that
we used tuples for the coordinate pairs in the distances tables. Maybe the more obvious
data type would be an <span>array</span> with two entries, as the <span>array</span> type is a container for
homogeneous data, while a <span>tuple</span> can also contain different data types. But currently
Nim supports tuples better in some situations, e.g. for automatic <span>tuple</span> unpacking.
So often we use <span>tuples</span> when <span>array</span> would be the first choice maybe. <span>array</span> type would have
the benefit of iteration over elements at runtime, while tuples have the benefit
that we can access elements by names and by an integer constant. For performance <span>array</span>
or <span>tuple</span> should make no difference here.</p>
<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_regular_expressions"><span>Regular Expressions</span></h2>
<div>
<p>A <span>regular expression</span>, shortened as <span>regex</span> or <span>regexp</span>, is a
sequence of characters that specifies a search pattern, which is used to find or
replace parts of a string or of a whole text document, or just to validate it. It is
a technique developed in theoretical computer science and formal language theory,
introduced in the 1950s, when the American mathematician Stephen Cole Kleene
formalized the description of a regular language. The use of regular expressions
became popular with Unix text-processing utilities like <span>sed</span>, <span>grep</span>
and <span>awk</span>, were used in early text editors like <span>vi</span> and <span>emacs</span>
for pattern matching, and are commonly used in modern text editors and word
processing programs in <span>find</span> and <span>find and replace</span> dialogs.
Different syntaxes for writing regular expressions have existed since the 1980s, one
being the POSIX standard and another, widely used, being the Perl syntax.</p>
<p>To demonstrate a first simple example for the usefulness of regular expressions, we
will start with a <span>sed</span> call that can be used to replace all snake case symbols
in a text file with camel case, e.g convert the symbolic name <span>line_width</span> into
<span>lineWidth</span>:</p>
<div>
<div>
<pre>sed -i -E &#39;s/_([a-z])/\U\1/g&#39; myfile.txt</pre>
</div>
</div>
<p>Here the option <span>-E</span> tells the <span>sed</span> program to use the <span>extended
regular expressions</span> rather than basic regular expressions, and option <span>-i</span>
specifies to work in place, instead to just print the modified text in the terminal
window. The pattern <span>s/a/b</span> tells it to substitute pattern <span>a</span> by
expression <span>b</span>, and the final <span>/g</span> stands for <span>global</span> and tells
<span>sed</span> to do substitutions in the whole file. The actual interesting part is
the search pattern <span>_[a-z]</span>, which specifies the actual underscore character
followed by a single lower case letter. Whenever such a pattern is found, it is
replaced with a capitalized version of the found letter. The <span>/U</span> tells
<span>sed</span> to convert to upper case, and <span>\1</span> refers to the captured text
segment. You may still wonder why <span>[a-z]</span> is enclosed in braces — well matches
enclosed in braces are actually captured, so we can refer to the captured letter
later, in this case we refer to the first captured match with <span>/1</span> and apply
<span>/U</span> on it to convert it to upper case.</p>
<p>As you see, regular expressions are useful, but difficult to understand and to
remember.</p>
<p>Some programming languages like Perl or Ruby have built in support for regular
expressions, and others use external libraries. For interpreted languages like Perl,
Python or Ruby it makes a lot sense to use regular expressions for parsing strings,
as the regex engines of these languages are generally written in C language, which
leads to the fact that even for very basic string operations like spitting strings
into single tokens or doing simple character replacements, the use of regexes can be
faster than doing it with multiple statements in the interpreted program code. For
compiled languages like Nim the situation is very different — using regexes is fast,
but doing simple things directly in the compiled languages is still much faster. And
Nim provides many other libraries like <span>strscans</span> or <span>parseutils</span>, which
can do even advanced string operations much faster than by use of regular
expressions.</p>
<p>So actually the use of regular expressions in Nim is very limited, in most cases
there exists other, simpler and faster solutions. As learning the use of regexes is
not that easy, and it is hard to remember all the details, we may hesitate to try it
at all. But actually for text processing tools like <span>sed</span> and <span>grep</span>,
and for the use in text editors and word processors regexes are very useful, so it
makes some sense to learn at least the basic use of regular expressions. And when we
learn to use regexes at all, then we can use them in Nim as well.</p>
<p>Each character in a regular expression (that is, each character in the string
describing its pattern) is either a
metacharacter, having a special
meaning, or a regular character that has a literal meaning. For example, in the
regex <span>b.</span>, <span>b</span> is a literal character that matches just &#39;b&#39;, while
<span>.</span> is a metacharacter that matches every character except a newline.
Therefore, this regex matches, for example, <span>b%</span>, or <span>bx</span>, or <span>b5</span>.
Together, metacharacters and literal characters can be used to identify text of a
given pattern or process a number of instances of it. Pattern matches may vary from a
precise equality to a very general similarity, as controlled by the metacharacters.
For example, <span>.</span> is a very general pattern, <span>[a-z]</span> (match all lower
case letters from &#39;a&#39; to &#39;z&#39;) is less general and <span>b</span> is a precise pattern
(matches just &#39;b&#39;). The metacharacter syntax is designed specifically to represent
prescribed targets in a concise and flexible way to direct the automation of text
processing of a variety of input data, in a form easy to type using a standard ASCII
keyboard.</p>
<p>In this section we will not try to explain all the details of the syntax and semantic
of regular expressions, but only show you how the <span>regex</span> module is used in principle,
and give a few examples for its use. For details you should consult the API
documentation of the <span>regex</span> module, and for concrete use cases you may
additional consult the Wikipedia article and the various internet resources.</p>
<p>The Nim standard library provides two modules for the use of regular expressions,
called <span>re</span> and <span>nre</span>, which both are wrappers for the <span>PCRE</span>
<span>(Perl Compatible Regular Expressions)</span> C library. Additional, a module called
<span>regex</span> is available as an external package, which is fully written in Nim
language. These three modules are similar, but their API is different. When you
intent to use <span>re</span> and <span>nre</span> you have to ensure that the PCRE C library
is also installed on your computer. As the external <span>regex</span> module is written
in pure Nim and is of high quality, we will actually use that one for our examples — actually if using one of the two others, it would be not easy to decide which to use.
You may wonder why we present the <span>regex</span> module already here, as it is not part of the
Nim standard library? Well, a regex library is am important part of each programming
languages, and <span>re</span> and <span>nre</span> are actually included in Nim’s standard
library. Due to Nim’s package managers like nimble, using external packages is very
easy, we just have to execute</p>

<p>We will start to demonstrate the use of the <span>regex</span> module with a very simple example:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>regex</span>

<span>let</span> <span>r</span><span>:</span> <span>Regex</span> <span>=</span> <span>re&#34;\w\d&#34;</span>
<span>let</span> <span>t1</span><span>:</span> <span>string</span> <span>=</span> <span>&#34;a1&#34;</span>
<span>let</span> <span>t2</span> <span>=</span> <span>&#34;nim&#34;</span>
<span>var</span> <span>m</span><span>:</span> <span>RegexMatch</span>
<span>if</span> <span>match</span><span>(</span><span>t1</span><span>,</span> <span>r</span><span>,</span> <span>m</span><span>):</span>
  <span>echo</span> <span>&#34;match t1&#34;</span>

<span>if</span> <span>match</span><span>(</span><span>t2</span><span>,</span> <span>r</span><span>,</span> <span>m</span><span>):</span>
  <span>echo</span> <span>&#34;match t2&#34;</span></code></pre>
</div>
</div>
<p>We use the <span>re()</span> function with the search pattern as argument to generate an
instance of a <span>Regex</span> variable. Then we can use the <span>match()</span> function
to match a textual string against this regex. The last argument of the match function
is a variable of <span>RegexMatch</span> type, which captures the matched terms, so that
we can use them later.</p>
<p>In our pattern <span>&#34;\w\d&#34;</span> the <span>\w</span> stand for a word character which
includes upper and lower case ASCII letters, and the <span>\d</span> stands for a decimal
digit. So the string <span>t1</span> matches that pattern, but the string <span>t2</span> does
not, as there is no decimal digit following the first letter. In the example from
above we actually check only if a string matches the pattern, but we do not capture
the matches. So we do not need the RegexMatch variable <span>m</span> at all and could
call the <span>match()</span> function without that parameter. To actually capture a
match, we would have to enclose the subpattern in braces like &#34;\w(\d)&#34; to capture the
digit in case of a successful match.</p>
<p>As next simple example let us match a string starting with the capital letter A,
followed by an arbitrary number of letters, followed by an integer number. We want to
capture the integer in case of a match:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>regex</span>

<span>let</span> <span>r</span><span>:</span> <span>Regex</span> <span>=</span> <span>re&#34;A[a-z, A-Z]*(\d+)&#34;</span>
<span>let</span> <span>t1</span><span>:</span> <span>string</span> <span>=</span> <span>&#34;Alex77&#34;</span>
<span>let</span> <span>t2</span> <span>=</span> <span>&#34;nim&#34;</span>
<span>var</span> <span>m</span><span>:</span> <span>RegexMatch</span>
<span>if</span> <span>match</span><span>(</span><span>t1</span><span>,</span> <span>r</span><span>,</span> <span>m</span><span>):</span>
  <span>echo</span> <span>&#34;captured: &#34;</span><span>,</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>,</span> <span>t1</span><span>)</span>

<span>if</span> <span>match</span><span>(</span><span>t2</span><span>,</span> <span>r</span><span>,</span> <span>m</span><span>):</span>
  <span>echo</span> <span>&#34;captured: &#34;</span><span>,</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>,</span> <span>t2</span><span>)</span></code></pre>
</div>
</div>
<p>To understand the regex pattern, we have to know that we can use <span>*</span>
to specify an arbitrary number of repetitions, and <span>+</span> to specify one or
more repetitions. The initial <span>A</span> is not a metacharacter and stand for the
literal <span>A</span>. The content of the square brackets specifies a character class,
<span>a-z</span> specifies the range of lower case letters, <span>A-Z</span> the range of upper
case letters, and the following <span>*</span> indicates an arbitrary number of
repetitions. Finally, the <span>\d</span> stands for a decimal digit, and <span>+</span>
specifies one or more repetitions. As we enclosed the last subpattern in braces, that
group is captured. For a successful match we can access the capture with the
<span>group()</span> function(, where we have to specify the index number of the capture,
and the actual text string that was used for the match. The fact that we have to
specify the initial text may look a bit strange indeed. For string <span>t1</span> we get
a successful capture with the result @[&#34;7&#34;]. So our actual captured string is
contained in a seq, which is useful when multiple (nested) strings are captured. In
the code from above we could have used <span>groupFirstCapture()</span> instead to get
directly the first captured string.</p>
<div>
<h3 id="_greedy_matching">Greedy matching</h3>
<p>Whenever we create regex patterns, we have to care for the fact if sub-matches should
be greedy or not. In most cases greedy is the default, and we have to take some care
when we need none-greedy behaviour. Greedy means just, that the regex engine captures
as many characters as possible, while none-greedy capturing stops the capturing
process early. Indeed these greedy/none-greedy capturing can be one of the most
demanding tasks when we create larger and complicated patterns. Imagine that for our
above example, we would have used the pattern re&#34;A\w*(\d+)&#34;. For the same string
&#34;Alex77&#34; we would then get the output @[&#34;7&#34;]. The reason for that is, that
<span>\w*</span> does a greedy processing, eating all but the last decimal digit, which it
left to satisfy <span>/d+</span>. From the API documentation of the <span>regex</span> module
we learn that we can specify <span>\w*?</span> instead to get a none-greedy processing, so
both digits are left for <span>\d+</span> and we get again @[&#34;77&#34;] as output.</p>
</div>
<div>
<h3 id="_escape_sequences">Escape sequences</h3>
<p>The use of escape sequences in regex patterns is another difficulty for beginners.
The first problem can be that the Nim compiler may process the escape sequences
already itself, while we intent to left them for the regex engine. We can avoid that
when we use Nim’s raw strings, e.g. we can use triple quotes when we construct the
pattern from individual strings as done in our next example. In an regex, we can use
escape sequences to specify special literal characters, we may use <span>\t</span> for a
literal tabulator for example. And finally, we may have to escape some punctuation
characters like <span>*</span>, <span>+</span> or <span>?</span> that have a special meaning for the
regex engine when we intent to use that character as an ordinary literal. For
example, to match a letter followed by a question mark, we have to use a pattern like
<span>&#34;[a-z]\?&#34;</span> or <span>&#34;[a-z][?]&#34;</span>. Inside of a square bracket we can use the
punctuation characters without the need to escape them.</p>
<p>As next example, let us assume that we have to process a text file in which each
lines starts with a name consisting of lower case letters, and three decimal numbers.
The name and the three numbers can be separated by spaces, or by commas or
semicolons:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>regex</span>

<span>let</span> <span>h</span> <span>=</span> <span>&#34;&#34;&#34;\s*[,;]?\s*(\d+)&#34;&#34;&#34;</span>
<span>let</span> <span>r</span><span>:</span> <span>Regex</span> <span>=</span> <span>re</span><span>(</span><span>&#34;[a-z]+&#34;</span> <span>&amp;</span> <span>h</span> <span>&amp;</span> <span>h</span> <span>&amp;</span> <span>h</span><span>)</span>
<span>let</span> <span>t1</span><span>:</span> <span>string</span> <span>=</span> <span>&#34;nim 12;8  ,   17&#34;</span>

<span>var</span> <span>m</span><span>:</span> <span>RegexMatch</span>
<span>if</span> <span>match</span><span>(</span><span>t1</span><span>,</span> <span>r</span><span>,</span> <span>m</span><span>):</span>
  <span>echo</span> <span>&#34;captured: &#34;</span><span>,</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>,</span> <span>t1</span><span>),</span> <span>&#34; &#34;</span><span>,</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>1</span><span>,</span> <span>t1</span><span>),</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>2</span><span>,</span> <span>t1</span><span>)</span></code></pre>
</div>
</div>
<p>To understand the pattern that we use in the above code, we have to know that we can
use <span>\s</span> for a white-space character, so <span>\s</span> matches a single space or a
tabular character. We could have used just a space literal instead, or the [ ]
character class containing just a single space. And we have to know that we can use
<span>?</span> to specify an optional entity. We have split the total pattern into two
parts, where the variable called <span>h</span> stands for the sequence of any number of
white-space, followed optionally by a single comma or a single semicolon, followed
again by any amount of white-space, that is finally followed by at least one decimal
digit. As we want to capture the decimal numbers, the sequence of decimal digits is
enclosed in round brackets. The total regex pattern is constructed by the
subexpression <span>[a-z]</span> for at least one letter, followed three times by the
integer pattern with the allowed separators. Note that we allow any amount of spaces
or tabulators, but only a single comma or semicolon between the different entities.
Note that the <span>match()</span> function of the <span>regex</span> module does always a full match,
so a single space at the beginning or end of the text string would make the match
fail. We could compensate for that by starting and ending the regex pattern with
&#34;\s*&#34;. Or we could use instead of <span>match()</span> the <span>find()</span> function,
which search through the string looking for the first location where there is a
match. When we use <span>find()</span>, we may use the special characters <span>^</span> and
<span>$</span> to match the start or end of the string, that is with <span>find()</span> and
<span>re&#34;\s+$&#34;</span> we could find all strings which have trailing white-space. Note
that <span>find(text, re&#34;^regex$&#34;, m)</span> is the equivalent to the <span>match()</span>
function.</p>
<p>The <span>regex</span> module provides us also with two <span>replace()</span> functions,
which we can use to replace matched patterns with literal strings or captured and
modified strings. The first <span>replace()</span> function uses as third argument a
string, which is used for replacements and in which we can refer to captured groups
with the symbols <span>$N</span>, where <span>N</span> is the index of the captured group
starting at one. The second <span>replace()</span> function uses a function as third
argument, that function gets an instance of the <span>RegexMatch</span> type as first
parameter and returns the string replacement. We will use both variants of the
<span>replace()</span> function to create a tiny app that we can use to fix typos in
program and text files: Text files can contain typing errors, which includes two or
more spaces between adjacent words, unneeded trailing white-space at the end of
lines, and the use of <span>a</span> instead of <span>an</span> in front of words starting with
a vocal. And program source code may use snake case for names instead of camelCase,
e.g. <span>line_counter</span> instead of <span>lineCounter</span>. We will create a tool that
can fix these four issues — ignoring the fact that an actual <span>a/an</span>
replacement may corrupt program source code. To demonstrate the four issues, we have
created this small test file — line three contains two unneeded spaces, and the last
line has some unwanted trailing white space:</p>
<div>
<div>
<pre># this is a example
var   line_width:  int

echo        line_width</pre>
</div>
</div>
<p>We will fix these four issues independent of each other, so we will try to find a
regex that matches for each issue, and then use the <span>replace()</span> function to
fix it.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>regex</span><span>,</span> <span>strutils</span>
<span>let</span> <span>fileName</span> <span>=</span> <span>&#34;test.nim&#34;</span>
<span>let</span> <span>trail</span> <span>=</span> <span>re&#34;\s+$&#34;</span>
<span>let</span> <span>aan</span> <span>=</span> <span>re&#34;a(\s+[AEIOUaeiou])&#34;</span>
<span>let</span> <span>space</span> <span>=</span> <span>re&#34;(\S\s)\s+(\S)&#34;</span>
<span>let</span> <span>snake</span> <span>=</span> <span>re&#34;_([a-z])&#34;</span>

<span>proc </span><span>toUpper</span><span>(</span><span>m</span><span>:</span> <span>RegexMatch</span><span>,</span> <span>s</span><span>:</span> <span>string</span><span>):</span> <span>string</span> <span>=</span>
  <span>when</span> <span>defined</span><span>(</span><span>debugThis</span><span>):</span>
    <span>echo</span> <span>&#34;a: &#34;</span><span>,</span> <span>s</span>
    <span>echo</span> <span>&#34;b: &#34;</span><span>,</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>)</span>
    <span>echo</span> <span>&#34;c: &#34;</span><span>,</span> <span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>)</span><span>[</span><span>0</span><span>]</span>
    <span>echo</span> <span>&#34;d: &#34;</span><span>,</span> <span>s</span><span>[</span><span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>)</span><span>[</span><span>0</span><span>]]</span>
    <span>echo</span> <span>&#34;e: &#34;</span><span>,</span> <span>strutils</span><span>.</span><span>toUpperAscii</span><span>(</span><span>s</span><span>[</span><span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>)</span><span>[</span><span>0</span><span>]]</span><span>)</span>
  <span>return</span> <span>strutils</span><span>.</span><span>toUpperAscii</span><span>(</span><span>s</span><span>[</span><span>m</span><span>.</span><span>group</span><span>(</span><span>0</span><span>)</span><span>[</span><span>0</span><span>]]</span><span>)</span>

<span>for</span> <span>l</span> <span>in</span> <span>filename</span><span>.</span><span>lines</span><span>:</span>
  <span>var</span> <span>h</span> <span>=</span> <span>l</span><span>.</span><span>replace</span><span>(</span><span>trail</span><span>,</span> <span>&#34;&#34;</span><span>)</span>
  <span>h</span> <span>=</span> <span>h</span><span>.</span><span>replace</span><span>(</span><span>aan</span><span>,</span> <span>&#34;an</span><span>$1</span><span>&#34;</span><span>)</span> <span># caution, this is for text files!</span>
  <span>h</span> <span>=</span> <span>h</span><span>.</span><span>replace</span><span>(</span><span>space</span><span>,</span> <span>&#34;</span><span>$1$2</span><span>&#34;</span><span>)</span>
  <span>h</span> <span>=</span> <span>h</span><span>.</span><span>replace</span><span>(</span><span>snake</span><span>,</span> <span>toUpper</span><span>)</span>
  <span>echo</span> <span>h</span></code></pre>
</div>
</div>
<p>We process our file with the issues line by line, using the <span>lines()</span> iterator
to which we pass a file name and which gives us the individual lines of the file. We
will start with the simplest task, that is removing trailing white-space. The search
pattern for this issue is obviously <span>&#34;\s+$&#34;</span>, that is at least one white-space
at the line end, which we have to replace with an empty string. So we pass this regex
pattern called <span>trail</span> and an empty string literal to the <span>replace()</span>
function. Replacing <span>a</span> by <span>an</span> is also easy — we search for an
<span>a</span> followed by white-space and a vocal, for which the regex pattern is the
<span>aan</span> variable in above code. In this case we have to preserve the actual
white-space and the vocal, so we enclose these in brackets to capture it. The
replacing string is <span>&#34;an$1&#34;</span>, where <span>$1</span> stands for the captured
white-space and the captured vocal. Replacing too much inter-word space is a bit
more difficult. The actual issue is one white-space followed by one or more
white-space, for which a possible match pattern is &#34;\s\s+&#34;. But actually we do not
want to remove all white-space consisting of more than one character, but only
white-space between words. So multiple white-space at the beginning of a line should
be preserved. One solution is, that we use the metacharacter <span>\S</span>, which
matches all none-white-space characters, and then use this search pattern:
<span>&#34;(\S\s)\s+(\S)&#34;</span>. The pattern starts with a none white-space character,
followed by a white-space, then at least one more whites-space character, and finally
a none white-space character. We capture the two first characters, and the last one.
This way we can replace the whole match with the two captures and we are done.
Finally, we have to replace underscore characters followed by a lowercase letter with
the capitalized letter. Some tools like <span>sed</span> provides the <span>\U</span> to
capitalize a capture, but this is not available for the <span>regex</span> module. So we
use the <span>replace()</span> variant which uses a <span>proc</span> as last parameter — to that
proc the capture and the original string is passed, and that function should return
the replacement string. The capture which we have to use to catch a snake element is
obvious just &#34;_([a-z])&#34;. We call the converter <span>proc</span> <span>toUpper()</span>, its
parameters and its return type is specified by the <span>regex</span> API docs. But
unfortunately the actual structure of the passed <span>RegexMatch</span> instance is not
that detailed described. So we created some conditional <span>echo()</span> statements
inside the body of our <span>toUpper()</span> <span>proc</span> to show us the structure of the
parameters. When we compile our program with the <span>-d:debugThis</span> option, and
run it, we get this output:</p>
<div>
<div>
<pre>nim c -d:debugThis t.nim

$ ./t test.nim
# this is an example
a: var line_width: int
b: @[9 .. 9]
c: 9 .. 9
d: w
e: W
var lineWidth: int

a: echo line_width
b: @[10 .. 10]
c: 10 .. 10
d: w
e: W
echo lineWidth</pre>
</div>
</div>
<p>So the last string parameter is always the whole string that was passed as first
argument to <span>replace()</span>, and <span>m.group(0)</span> is a sequence of slices for
the first capture. We need only the first element of this seq, as we have only one
capture, and we use that slice to extract the captured sub-string by use of
<span>s[m.group(0)[0]]</span>. Finally we apply <span>strutils.toUpperAscii()</span> on this
sub-string to capitalize it, and return that result.</p>
<p>When you run above program, you should get a text file with all issues fixed. You
may redirect the output to a file with <span>&#34;\.t test.nim &gt; newtest.nim&#34;</span> and load
<span>newtest.nim</span> into an editor to proof that the trailing white-space is removed
as well.</p>
</div>
<div>

<p>The use of regular expressions is not that easy, and makes in most cases not much
sense in Nim. Maybe the largest problem of regular expressions is, that it is hard
to understand patterns that we created some years ago, or that have been created by
other people. And it is difficult to modify that patterns later. Maybe you should
play a bit with regexes yourself now, and come back to this topic when you think that
you need them. In this book we were only able to give a tiny introduction into the
stuff — you will have to carefully study the API docs of the <span>regex</span> module
and a lot of other resources in the Internet when you should intent to seriously use
them. We should also mention, that while regexes are very powerful, for some tasks
they work not that well, e.g. parsing math expressions with nested braces, or just
skipping nested comments in some source code can be very difficult or even
impossible.</p>
<p>References:</p>

</div>
</div>
</div>

<div>
<p>
In this section we will present a few simple programming exercises.
</p>
</div>
<div>
<h2 id="_sorting">Sorting</h2>
<div>
<p>Sorting a sequence or an <span>array</span> of numbers is generally a component of
each computer programming course. While we would not really
code sorting algorithm for the actual software that we write, but use
the generic sorting algorithm from the standard library, sorting
algorithm can teach us some basic programming skills. When we
sort a small number of items manually, we would generally use selection or
insertion sort intuitively: For selection sort we pick the smallest element and
move it at position one, then pick next smallest item and move it at position two.
This strategy is easy to implement and works not bad for small quantities. For larger
containers algorithm like quicksort or mergesort gives better performance.</p>
<div>
<h3 id="_selection_sort">Selection Sort</h3>
<div>
<div>
<pre><code data-lang="nim"><span>#[ &lt;--s.len</span>
<span>5</span>
<span>7</span> <span>&lt;--</span> <span>i</span>
<span>4</span> <span>&lt;--</span> <span>k</span><span>,</span> <span>x</span> <span>==</span> <span>4</span>
<span>6</span> <span>&lt;--</span> <span>j</span>
<span>3</span>
<span>2</span> <span>first</span> <span>tree</span> <span>entries</span> <span>are</span> <span>already</span> <span>sorted</span>
<span>1</span>
<span>]</span><span>#</span>

<span>proc </span><span>selectionSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span> <span># used to step through the still unsorted range</span>
  <span>var</span> <span>j</span> <span>=</span> <span>0</span> <span># lower bound for still unsorted range</span>
  <span>var</span> <span>k</span><span>:</span> <span>int</span> <span># position of currently smallest candidate</span>
  <span>var</span> <span>x</span><span>:</span> <span>int</span> <span># and its value</span>

  <span>while</span> <span>j</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span><span>:</span> <span># while there is an unsorted section left</span>
    <span>i</span> <span>=</span> <span>j</span> <span># start with i one above the already sorted range</span>
    <span>x</span> <span>=</span> <span>s</span><span>[</span><span>i</span><span>]</span><span>;</span> <span>k</span> <span>=</span> <span>i</span> <span># assume first element is the smallest</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span> <span># continue with next one in the still unsoprted range</span>
    <span>while</span> <span>i</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span><span>:</span> <span># while there are unchecked candidates</span>
      <span>if</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>:</span> <span># that one is smaller than current candidate</span>
        <span>x</span> <span>=</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span># remember its value</span>
        <span>k</span> <span>=</span> <span>i</span> <span># and remember its position</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span> <span># examine next candidate</span>
    <span>swap</span><span>(</span><span>s</span><span>[</span><span>j</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>k</span><span>]</span><span>)</span> <span># exchange smallest value with the one currently at position k</span>
    <span>inc</span><span>(</span><span>j</span><span>)</span> <span># sorted range increased by one</span>

<span>import</span> <span>random</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>100</span><span>))</span>
  <span>s</span><span>.</span><span>selectionSort</span>
  <span>echo</span> <span>s</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The comment on the top of the above example shows a partly sorted list of <span>7</span> integer
numbers. The lowest three positions already contains the sorted numbers <span>1</span> to <span>3</span>. The
next four positions are still unsorted. For the sorting process we need the three indices
<span>i</span>, <span>j</span>, <span>k</span> and the variable <span>x</span> to store an actual value for the comparison. The index <span>j</span>
is the lower bound for the still unsorted range, <span>j</span> starts at zero obviously.
The variable <span>x</span> stores the currently smallest value of the still unsorted range, and <span>k</span> is
the index position of that value. Finally <span>i</span> is a counter that is used to step through all
the values of the unsorted range. The outer loop is executed as long as <span>j</span> is smaller than the length of
the sequence that we want to sort. We set <span>i</span> to the value of <span>j</span>, <span>k</span> to the same value and assume initially
that <span>s[i]</span> is the smallest value from the still unsorted range. That value is stored in <span>x</span>.
Then we execute the inner while loop until we have processed all elements of the
still unsorted range. Whenever we find an element that is smaller than <span>x</span>, we store that position
in <span>k</span> and the value in <span>x</span>. When the inner loop has finished, we exchange the smallest value
with the first element of the still unsorted range. This way the sorted range increases, and the unsorted
range decreases by one.</p>
<p>To test our sorting procedure we generate some random numbers, sort them and print the result.
Selection sort is said to be of order O(n^2), with <span>n</span> being the number of values to sort. So the effort
increases quadratic with the number of values. This is because we have to test all the still unsorted
values just to increase the number of sorted values by one. Selection sort has a natural behavior,
that is for an already sorted array the test <span>s[i] &lt; x</span> would be always false and we would have
to do no movement of values in that case. So performance is best for an already sorted or partly sorted list,
and the sorting is stable in the sense that we do not move elements when it is not really necessary.
In one of the following sections we will discuss the quicksort algorithm, which is not a
stable sorting method: Elements with equal value may be move with quicksort. For plain
numbers that does not really matter for the result, as numbers are indistinguishable. But
when we sort objects, maybe persons by age, persons of same age would be exchanged
by quicksort, which may not be desired.</p>
<p>Note that the code above is not really optimized for performance yet. One possible improvement
may be to iterate the two loops not from zero to <span>s.len</span>, but in the opposite direction.
In that way comparison of loop indices with a constant value, zero in this case, could
be used to terminate the loop. Comparison with constants can be faster than comparison with
actual variables, and comparison with zero is generally fastest. Note that we compared indices with <span>s.len()</span>
in above code, which is not that bad, as <span>len()</span> is a field in the <span>seq</span> data structure, so the compiler should be smart
and replace <span>s.len</span> with just a field access without <span>proc</span> call overhead.</p>

</div>
<div>
<h3 id="_insertion_sort">Insertion Sort</h3>
<p>Insertion sort is another simple sorting method, which some
card players like to use:
They hold two sets of cards in their hand, one unsorted set, and one sorted which
is initially empty. They pick one card from the unsorted set and insert it at the right
position in the already sorted set. That action is repeated until the unsorted set is empty.
For our next example we sort our data not in place as we did it in the previous
example, but we generate a new sorted copy:</p>
<div>
<div>
<pre><code data-lang="nim"><span>#[</span>
<span>unsorted</span>     <span>sorted</span>
<span>&lt;--</span> <span>k</span>
<span>4</span>
<span>7</span>                     <span>3</span> <span>&lt;--</span> <span>result</span><span>.</span><span>high</span>
<span>5</span>                     <span>2</span>
<span>6</span>                     <span>1</span>
<span>]</span><span>#</span>

<span>proc </span><span>insertionSort</span><span>(</span><span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>):</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span>
  <span>var</span> <span>j</span><span>:</span> <span>int</span> <span># current position in the new, sorted range</span>
  <span>var</span> <span>k</span> <span>=</span> <span>s</span><span>.</span><span>len</span> <span># index one above the still unprocessed range</span>
  <span>var</span> <span>x</span><span>:</span> <span>int</span> <span># the value we have to insert next</span>
  <span>while</span> <span>k</span> <span>&gt;</span> <span>0</span><span>:</span> <span># as long as we have still unprocessed entries</span>
    <span>dec</span><span>(</span><span>k</span><span>)</span>
    <span>x</span> <span>=</span> <span>s</span><span>[</span><span>k</span><span>]</span>
    <span>j</span> <span>=</span> <span>result</span><span>.</span><span>high</span> <span># top of sorted range</span>
    <span>result</span><span>.</span><span>setLen</span><span>(</span><span>result</span><span>.</span><span>len</span> <span>+</span> <span>1</span><span>)</span> <span># reserve space for one more entry</span>
    <span>while</span> <span>j</span> <span>&gt;=</span> <span>0</span> <span>and</span> <span>x</span> <span>&lt;</span> <span>result</span><span>[</span><span>j</span><span>]</span><span>:</span> <span># move the already sorted entries up</span>
      <span>result</span><span>[</span><span>j</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>result</span><span>[</span><span>j</span><span>]</span>
      <span>dec</span><span>(</span><span>j</span><span>)</span>
    <span>result</span><span>[</span><span>j</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>x</span> <span># insert x</span>

<span>import</span> <span>random</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>100</span><span>))</span>
  <span>echo</span> <span>s</span><span>.</span><span>insertionSort</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The commented code in front of the above program code shows at the left the
still unsorted numbers and at the right <span>3</span> already sorted numbers. For the sorting
process we need two index variables <span>j</span> and <span>k</span>, and one variable to store the actual value that we have to
insert called <span>x</span>. The variable <span>k</span> is used as the index of the top entry of the still unsorted range.
To insert the value <span>x</span> in the already sorted result, we first reserve space for one more entry by
calling <span>setLen()</span> and then iterate over the sorted values and move them one place to the top.
We do that moving to the top as long as we have not already reached the bottom of the sorted range
and as long as the current entry is larger than the value <span>x</span> which we want to insert.
We take the values from the top of the unsorted range, as that is convenient, but of course we could pick
an arbitrary element from the unsorted range.</p>
<p>Insertion sort has O(n^2) cost, as for each element that we take from the unsorted range we have to
iterate over the sorted range to insert it. As we have to move elements before we can insert an element, insertion
sort is slow for larger containers. Selection sort, which is also of O(n^2) should be faster, as it does not
use an expensive shift of many elements.</p>
<p>When you look at the example code you may immediately find two possible improvements:
We do not really need the variable <span>x</span>, as we can just use <span>s[k]</span> instead. The compiler should optimize the
code so that the subscript operator is not executed multiple time for the same index <span>k</span>, so use of <span>s[k]</span> or <span>x</span>
should make no difference for performance. And we call <span>setLen()</span> in the outer loop to increase the
capacity of the result sequence by one each. Of course setting capacity only one time to the value
of <span>s</span> would suffer, as obviously result has the same length as out input data. Another possible optimization would be to
take advantage of the fact that the destination sequence is sorted, so that we would not have to do linear search to find
the insertion position, but we could use a binary search. But that would be more complicated and the benefit would be
not large.</p>
</div>
<div>
<h3 id="_quick_sort">Quick Sort</h3>
<p>As the name implies this sorting method is one of the fastest. We will explain it in
some detail with various variants as it can teach us two important concepts:
Recursion and avoiding recursion by use of a stack container.</p>
<p>The idea of the QuickSort algorithm is simple, and the code is also simple and short, but we have to care for some details
like exact index stop positions. Generally sorting seems to be a O(n^2) operation, at least from the two traditional
sorting methods, Insertion- and Selection-Sort it seems to be the case. So doubling the container size seems to increase
the needed sorting time by a factor of four, which is really bad for large <span>arrays</span> or sequences. The trick
of QuickSort is, that instead of sorting a container with <span>n</span> elements, we just sort the first half and the second
half separately, each with approx <span>n / 2</span> entries. This would be faster, as <span>2 * (n/2)^2</span> is only half of <span>(n)^2</span>. And we
do apply this trick in a recursive manner on each halved range, until the range is reduced to only one
or two entries. But to make this work we have to partition the full range in the first half <span>r1</span> so that all
entries of range <span>r1</span> are smaller or equal to a median value <span>x</span>, and so that all entries in the second half
<span>r2</span> are all greater or equal to the median <span>x</span>. Let us consider an example with six numbers:</p>

<p>To partition that set of numbers we have only to exchange the numbers <span>5</span> and <span>1</span>, with the value <span>5</span> or <span>4</span>
being a possible median. Exchanging numbers in an <span>array</span> or a <span>seq</span> is a fast O(n) operation, we
have to iterate the container only once. The problem is finding the median. For picking a perfect
median we would need a sorted container so that we could pick the center entry. But of course
our container is unsorted, if it would be sorted our work would be done already. Note that
even summing up all entries and dividing by <span>n</span> would give only the average value, not the median.
Average and median can be very different, e.g. for many small numbers and a few very large ones.
But in practice picking an estimation for the median, maybe picking one by random from the whole
range or picking the center entry is good enough. That choice will not really half the whole
range in each step, but on average it splits the range in two parts with not too different size.
This works really well when the input data looks like random numbers, but it may work bad
in some unlikely cases when all the input numbers are equal or are already sorted.
Already sorted can indeed occur — for that case picking the center elements of the range gives
the perfect median, so we will choose that strategy.</p>
<p>Partitioning the full range is basically very simple: We move from the left to right with index <span>i</span> and stop
when we find a value <span>s[i]</span> that is not smaller than our median <span>x</span>. And we do the same from the right to the
left with index <span>j</span> until we find a value that is not greater than median <span>x</span>. After we have done that,
we can just exchange the values at <span>s[i]</span> and <span>s[j]</span> and continue. We continue until <span>i</span> is close to <span>j</span>. The difficult part
is to handle this terminating condition exactly, that is to stop exactly at the right position so
that the first half really contains all entries with value less or equal to median <span>x</span>, and that the second half contains only
entries with value equal or greater than median <span>x</span>. To make it more clear: Such a partition decouples the two
ranges. Sorting the whole range would result in the same state as sorting first and second range on its own.</p>
<p>For writing our actual sorting function we use the fact that Nim like most modern programming languages support
recursion, that is a function can call itself again. We saw at the beginning of the book a few examples for that.
So we can pass our function the initial full container, then the function can partition the container in
first and second half and call itself again on the two parts. This way the actual size of the ranges to sort
decreases, and finally recursion stops when the range contains only one or two elements. For size one
we have to do nothing at all, but for size two we may have to exchange the two elements if order is wrong.</p>
<p>A naive implementation may create for each function call two new sequences for the two parts, partition
the initial sequence by inserting the values in one of the new shorter sequences, call itself
on both parts and finally join the parts and return it — as result or as var parameter.
But that would be really slow. A much simpler and faster solution is, when we work all the
time on the same container, and just tell the function which range the function has to work on.
So we pass to the function the whole sequence and two integers <span>a</span> and <span>b</span> which tell it the range to process:
s[a], s[a +1] .. s[b].</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>algorithm</span> <span>import</span> <span>isSorted</span><span>,</span> <span>sort</span>
<span>import</span> <span>std</span><span>/</span><span>monotimes</span>

<span>proc </span><span>qsort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>;</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>)</span> <span>=</span>
  <span>assert</span> <span>a</span> <span>&gt;=</span> <span>0</span> <span># a .. b is the range that we have to sort</span>
  <span>assert</span> <span>b</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span>
  <span>assert</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span> <span># it may work for smaller intervals, but this is the intended use case</span>
  <span>let</span> <span>x</span> <span>=</span> <span>s</span><span>[</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span><span>]</span> <span># use element from center of range</span>
  <span># var x = s[a] div 2 + s[b] div 2 # bad, x may be smaller than smallest entry in range</span>
  <span># x = s[a .. b].min # worst case test!</span>
  <span>var</span> <span>i</span> <span>=</span> <span>a</span>
  <span>var</span> <span>j</span> <span>=</span> <span>b</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>while</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>:</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span>
    <span>while</span> <span>s</span><span>[</span><span>j</span><span>]</span> <span>&gt;</span> <span>x</span><span>:</span>
      <span>dec</span><span>(</span><span>j</span><span>)</span>
    <span>if</span> <span>i</span> <span>&lt;</span> <span>j</span><span>:</span>
      <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span>
      <span>dec</span><span>(</span><span>j</span><span>)</span>
    <span>else</span><span>:</span>
      <span>break</span>
  <span>dec</span><span>(</span><span>i</span><span>)</span>
  <span>inc</span><span>(</span><span>j</span><span>)</span>
  <span>assert</span> <span>i</span> <span>&gt;=</span> <span>a</span>
  <span>assert</span> <span>j</span> <span>&lt;=</span> <span>b</span>
  <span>if</span> <span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>:</span> <span># still more than 2 entries</span>
    <span>qsort</span><span>(</span><span>s</span><span>,</span> <span>a</span><span>,</span> <span>i</span><span>)</span>
  <span>elif</span> <span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>0</span><span>:</span> <span># two entries</span>
    <span>if</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>s</span><span>[</span><span>a</span><span>]</span><span>:</span> <span># wrong order</span>
      <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>a</span><span>]</span><span>)</span>
  <span>if</span> <span>b</span> <span>-</span> <span>j</span> <span>&gt;</span> <span>1</span><span>:</span> <span># and the same for the other half</span>
    <span>qsort</span><span>(</span><span>s</span><span>,</span> <span>j</span><span>,</span> <span>b</span><span>)</span>
  <span>elif</span> <span>b</span> <span>-</span> <span>j</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>if</span> <span>s</span><span>[</span><span>b</span><span>]</span> <span>&lt;</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>:</span>
      <span>swap</span><span>(</span><span>s</span><span>[</span><span>b</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>

<span>proc </span><span>quickSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>==</span> <span>2</span> <span>and</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>:</span> <span>swap</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>)</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>&gt;</span> <span>2</span><span>:</span>
    <span>qsort</span><span>(</span><span>s</span><span>,</span> <span>0</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)</span>

<span>import</span> <span>random</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>var</span> <span>start</span><span>:</span> <span>MonoTime</span>
  <span>randomize</span><span>()</span> <span># give us different random numbers for each program run</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e5.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>shuffle</span>
    <span>s</span><span>.</span><span>quickSort</span>
    <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e7.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>quickSort</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>s</span><span>.</span><span>shuffle</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>sort</span><span>()</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The function <span>qsort()</span> does the whole work. It is called from function <span>quicksort()</span>
passing it the whole sequence and the interval to sort. For the first
call the interval is the whole content of the <span>seq</span>, from <span>s.low</span> to <span>s.high</span>.
Function <span>qsort()</span> first asserts that the range is valid, that is that
<span>b &gt; a</span> and that both indices are valid positions in the sequence s. That
check makes it easier to find stupid errors, the assert is automatically
removed when we compile finally with -d:release.
We set the iterating indices <span>i</span> and <span>j</span> to the interval boundaries <span>a</span> and <span>b</span> and
enter an outer loop. In that outer loop we let run <span>i</span> and <span>j</span> to the center of the interval
as long as the actual entry at the position <span>i</span> or <span>j</span> belongs in the range. If both
inner loops have stopped, we swap the entries at position <span>i</span> and <span>j</span>. As
positions <span>i</span> and <span>j</span> contain now again valid entries, we can move both indices
one step further to the center. If <span>i</span> and <span>j</span> becomes the same we are done.
Unfortunately both may stop too late, so we move both one position back
after the outer loop has terminated.
You may create a small example with pen and paper to recognize
how the indices behave in detail and why fixing by one is necessary.
The remainder of the <span>qsort()</span> <span>proc</span> is really easy: For both partitions we check if the interval size is
still larger than two entries, in that case we call <span>qsort()</span> again to continue with
partition and sorting. But if the size is two entries, then we just <span>swap()</span> them if the order is
wrong. If the size of the range is just one, we have nothing to do at all.</p>
<p>We test our <span>quicksort()</span> <span>proc</span> by calling it from another <span>proc</span> called <span>main()</span>.
In that <span>main()</span> we fill a <span>seq</span> with random integer values, and <span>shuffle()</span>
and <span>sort()</span> it a few times. <span>Shuffle()</span> reorders the entries by random. After our call
of <span>quicksort()</span> we call <span>isSorted()</span> from Nim’s standard library to check the success
of our sorting. After these tests, which does some warmup of the CPU for us, we
add more random entries and again sort and test it, while we record the needed time
with module <span>monotimes</span> as we did before in the Timers section. To get a feeling
about the performance of our sorting <span>proc</span> we <span>shuffle()</span> again and sort this time
with the <span>sort()</span> <span>proc</span> from Nim’s <span>algorithm</span> module. <span>Sort()</span> from <span>algorithm</span> module
uses currently another sorting method called merge sort, which has the advantage that
it is a stable sorting algorithm, but it may be a bit slower than quicksort. And <span>sort()</span>
from algorithm may pass a <span>cmp()</span> <span>proc</span> around, which may cost some performance, while
our plain, non generic <span>proc</span> compares entries directly with &lt; and &gt; operators. So it is not
surprising that our <span>proc</span> is a bit faster.</p>
<p>You may wonder if it is really necessary to pass the sequence <span>s</span> for each call of <span>qsort()</span>, as
for all time the same <span>seq</span> is used. Indeed Nim support nested <span>procs</span>, so we could just make
<span>qsort()</span> <span>proc</span> local to <span>quicksort()</span> <span>proc</span> and let <span>qsort()</span> work (as a closure) on the s variable
of <span>proc</span> <span>quicksort()</span>. But this does not compile currently, sequences can not be used by
closure <span>procs</span>. But actually passing the sequence to <span>proc</span> <span>qsort()</span> should be only a minimal overhead.</p>
<p>One general problem of QuickSort is that the sort is not stable. When we sort an already sorted
sequence again, entries with same value may move. For plain numbers that is not really a problem,
we do not really notice it, as we can’t mark a number in some way, plain numbers are
indistinguishable just as elementary particles like electrons and protons are. But when we sort a container
with objects by some field, then we notice that objects with same value for sorting may move.
The other problem of QuickSort is a generally problem of recursive algorithm: Each new call of a
proc generates some stack usage, as <span>proc</span> parameters may be passed on the stack and because
the <span>proc</span> may allocate its local data variables on the stack. So many nested calls may need a very
large stack, the program may fail with a stack overflow error. Generally, we have no real problem with
stack overflow, as for each partition the size of the two new partition is nearly halved, so
that process stops soon. But imagine someone prepares a special data set for our sort <span>proc</span>. That
data may be prepared in such a fashion that at the center of each range, where we pick the estimated median value from,
always an extreme values is stored. So our partition would work very badly, in each step we would get a new range with only
one element, and one with <span>n - 1</span> elements. So the recursion dept would go very deep, and the performance would
be very bad also. Preparing such a data set would be difficult, but possible in theory. One way to protect
us from that attack would be to select the median by random. But unfortunately all strategies different from
picking the leftmost, the center, or the rightmost entry as median are not very fast and
make the whole sorting significantly slower. Note that the strategy of not picking a single element
as median, but calculating a median value, works generally, but has some shortcomings:
<span>s[a] div 2 + s[b] div 2</span> would not work when both values are odd, as we then would get a value
that can be smaller than all of our entries and our function would fail. We would have to add
one to the average value when both summands are odd, and that fix cost performance again.
And calculating the average by <span>(s[a] + s[b]) div 2</span> could generate an overflow when both summands are large.</p>
<p>Because of the stack size restrictions we have a good motivation to show how we can
replace recursion with plain iteration, when we provide a &#34;buffer&#34; variable that acts as a data stack.
For each new partition of our data we have to put only the two bounds <span>a</span> and <span>b</span> on that data stack, which
is not that much as a recursive <span>proc</span> would put on the real computer stack. The modifications to our code
from above are tiny:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>algorithm</span> <span>import</span> <span>isSorted</span><span>,</span> <span>sort</span>
<span>import</span> <span>std</span><span>/</span><span>monotimes</span>

<span>proc </span><span>qsort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>var</span> <span>stack</span><span>:</span> <span>seq</span><span>[</span><span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span><span>]</span>
  <span>var</span> <span>maxStackLen</span><span>:</span> <span>int</span>
  <span>stack</span><span>.</span><span>add</span><span>((</span><span>s</span><span>.</span><span>low</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>))</span>
  <span>while</span> <span>stack</span><span>.</span><span>len</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>if</span> <span>stack</span><span>.</span><span>len</span> <span>&gt;</span> <span>maxStackLen</span><span>:</span>
      <span>maxStackLen</span> <span>=</span> <span>stack</span><span>.</span><span>len</span>
    <span>var</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>stack</span><span>.</span><span>pop</span>
    <span>assert</span><span>(</span><span>a</span> <span>&gt;=</span> <span>0</span> <span>and</span> <span>b</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span> <span>and</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>)</span>
    <span>let</span> <span>x</span> <span>=</span> <span>s</span><span>[</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span><span>]</span>
    <span>var</span> <span>(</span><span>i</span><span>,</span> <span>j</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>while</span> <span>true</span><span>:</span>
      <span>while</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>:</span>
        <span>inc</span><span>(</span><span>i</span><span>)</span>
      <span>while</span> <span>s</span><span>[</span><span>j</span><span>]</span> <span>&gt;</span> <span>x</span><span>:</span>
        <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>if</span> <span>i</span> <span>&lt;</span> <span>j</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>
        <span>inc</span><span>(</span><span>i</span><span>)</span> <span>;</span> <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>else</span><span>:</span>
        <span>break</span>
    <span>dec</span><span>(</span><span>i</span><span>);</span> <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span># assert(i &gt;= a and j &lt;= b) caution, this is not always true!</span>
    <span>if</span> <span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>:</span>
      <span>stack</span><span>.</span><span>add</span><span>((</span><span>a</span><span>,</span> <span>i</span><span>))</span>
    <span>elif</span> <span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>0</span><span>:</span>
      <span>if</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>s</span><span>[</span><span>a</span><span>]</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>a</span><span>]</span><span>)</span>
    <span>if</span> <span>b</span> <span>-</span> <span>j</span> <span>&gt;</span> <span>1</span><span>:</span>
      <span>stack</span><span>.</span><span>add</span><span>((</span><span>j</span><span>,</span> <span>b</span><span>))</span>
    <span>elif</span> <span>b</span> <span>-</span> <span>j</span> <span>&gt;</span> <span>0</span><span>:</span>
      <span>if</span> <span>s</span><span>[</span><span>b</span><span>]</span> <span>&lt;</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>b</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>
  <span>echo</span> <span>&#34;Max Stack Length: &#34;</span><span>,</span> <span>maxStackLen</span>

<span>proc </span><span>quickSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>==</span> <span>2</span> <span>and</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>:</span> <span>swap</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>)</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>&gt;</span> <span>2</span><span>:</span>
    <span>qsort</span><span>(</span><span>s</span><span>)</span>

<span>import</span> <span>random</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>var</span> <span>start</span><span>:</span> <span>MonoTime</span>
  <span>randomize</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e5.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>shuffle</span>
    <span>s</span><span>.</span><span>quickSort</span>
    <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e7.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>quickSort</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>s</span><span>.</span><span>shuffle</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>sort</span><span>()</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>We added a variable called <span>stack</span> which is a <span>seq</span> which stores integer <span>tuples</span>.
The <span>qsort()</span> <span>proc</span> first stores the borders of the whole <span>seq</span> on the <span>stack</span>,
and then executes a loop which takes in each iteration a set of two
borders from the <span>stack</span> and processes that range. It may sound a bit strange that we
start by putting the whole range onto the stack and then took it from <span>stack</span>
immediately at the start of the loop. But that makes more sense when we look at the
bottom of the <span>qsort()</span> <span>proc</span>. Instead of recursively calling <span>qsort()</span> again, we just put
the borders of the two new partitions on the stack and continue. The whole process
terminates when the stack becomes empty, as then all partitions are processed.
Note that the actual partition code and the <span>main()</span> <span>proc</span> are still unchanged.
We added a <span>maxStackLen</span> variable to get a feeling how large our stack has to be.
Actually not that large, as the partition size shrinks in a logarithmic way.
So we could replace the <span>seq</span> that we use now as stack with a plain <span>array</span>, as
sequences have same overhead and the <span>add()</span> is slower than plain index access.
But how can we prepare for worst case attacks? Indeed there exists a simple
solution: Worst case occurs, when first we put a tiny one element range on the <span>stack</span> and then
the large one, as we would continue with the large one in the same way in the next loop
iteration. The other way round would be fine. If we put the tiny range on the stack last, next iteration would pick that
one and iteration would stop immediately or at least very soon, as ranges drops to two or one entries.
When an iteration for a range stops, all ranges pushed to the <span>stack</span> are removed already again, so
total <span>stack</span> size will never become large. So the trick is to just sort the partitions in a way that we
put the larger partition first on the stack, and the smaller partition second. So next
iteration picks the smaller one and the whole process stops soon. This way a stack <span>array</span>
of <span>64</span> entries should be enough, as max needed <span>stack</span> size should be <span>log2(2^64)</span> to sort
a <span>seq</span> with <span>2^64</span> entries.</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>algorithm</span> <span>import</span> <span>isSorted</span><span>,</span> <span>sort</span>
<span>import</span> <span>std</span><span>/</span><span>monotimes</span>

<span>proc </span><span>qsort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>var</span> <span>stack</span><span>:</span> <span>array</span><span>[</span><span>64</span><span>,</span> <span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span><span>]</span>
  <span>var</span> <span>stackPtr</span><span>:</span> <span>int</span>
  <span>var</span> <span>maxStackLen</span><span>:</span> <span>int</span>
  <span>stack</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>(</span><span>s</span><span>.</span><span>low</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)</span>
  <span>while</span> <span>stackPtr</span> <span>&gt;=</span> <span>0</span><span>:</span>
    <span>if</span> <span>stackPtr</span> <span>&gt;</span> <span>maxStackLen</span><span>:</span>
      <span>maxStackLen</span> <span>=</span> <span>stackPtr</span>
    <span>let</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>stack</span><span>[</span><span>stackPtr</span><span>]</span><span>;</span> <span>dec</span><span>(</span><span>stackPtr</span><span>)</span>
    <span>assert</span><span>(</span><span>a</span> <span>&gt;=</span> <span>0</span> <span>and</span> <span>b</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span> <span>and</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>)</span>
    <span>let</span> <span>x</span> <span>=</span> <span>s</span><span>[</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span><span>]</span>
    <span>var</span> <span>(</span><span>i</span><span>,</span> <span>j</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>while</span> <span>true</span><span>:</span>
      <span>while</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>:</span>
        <span>inc</span><span>(</span><span>i</span><span>)</span>
      <span>while</span> <span>s</span><span>[</span><span>j</span><span>]</span> <span>&gt;</span> <span>x</span><span>:</span>
        <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>if</span> <span>i</span> <span>&lt;</span> <span>j</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>
        <span>inc</span><span>(</span><span>i</span><span>);</span> <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>else</span><span>:</span>
        <span>break</span>
    <span>dec</span><span>(</span><span>i</span><span>);</span> <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span># assert(i &gt;= a and j &lt;= b) caution, this is not always true!</span>
    <span>var</span> <span>c</span><span>,</span> <span>d</span><span>:</span> <span>int</span>
    <span>for</span> <span>u</span> <span>in</span> <span>0</span> <span>..</span> <span>1</span><span>:</span>
      <span>if</span> <span>(</span><span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>b</span> <span>-</span> <span>j</span><span>)</span> <span>==</span> <span>(</span><span>u</span> <span>==</span> <span>0</span><span>):</span>
        <span>(</span><span>c</span><span>,</span> <span>d</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>i</span><span>)</span>
      <span>else</span><span>:</span>
        <span>(</span><span>c</span><span>,</span> <span>d</span><span>)</span> <span>=</span> <span>(</span><span>j</span><span>,</span> <span>b</span><span>)</span>
      <span>if</span> <span>d</span> <span>-</span> <span>c</span> <span>&gt;</span> <span>1</span><span>:</span>
        <span>inc</span><span>(</span><span>stackPtr</span><span>)</span> <span># inc before push!</span>
        <span>stack</span><span>[</span><span>stackPtr</span><span>]</span> <span>=</span> <span>(</span><span>c</span><span>,</span> <span>d</span><span>)</span>
      <span>elif</span> <span>d</span> <span>-</span> <span>c</span> <span>&gt;</span> <span>0</span><span>:</span>
        <span>if</span> <span>s</span><span>[</span><span>c</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>d</span><span>]</span><span>:</span>
          <span>swap</span><span>(</span><span>s</span><span>[</span><span>c</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>d</span><span>]</span><span>)</span>
  <span>echo</span> <span>&#34;Max Stack Length: &#34;</span><span>,</span> <span>maxStackLen</span>

<span>proc </span><span>quickSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>==</span> <span>2</span> <span>and</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>:</span> <span>swap</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>)</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>&gt;</span> <span>2</span><span>:</span>
    <span>qsort</span><span>(</span><span>s</span><span>)</span>

<span>import</span> <span>random</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>var</span> <span>start</span><span>:</span> <span>MonoTime</span>
  <span>randomize</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e5.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>shuffle</span>
    <span>s</span><span>.</span><span>quickSort</span>
    <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e7.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>quickSort</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>s</span><span>.</span><span>shuffle</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>sort</span><span>()</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Instead of processing the two new partitions at the end of the
<span>qsort()</span> <span>proc</span> each, we apply only one processing code block
now, which we execute in a loop that is executed two times.
At the start of that loop we assign the actual interval boundaries
to the variables <span>c</span> and <span>d</span>. That assignment depends on the actual loop index <span>u</span>,
so that we push the larger range always first on the stack.
You may modify the condition <span>u == 0</span> to <span>u != 0</span> and observe what happens
to the maximum used stack dept. We could write that condition also with
a boolean loop variable and a <span>xor</span> operator like</p>
<div>
<div>
<pre><code data-lang="nim">    <span>for</span> <span>u</span> <span>in</span> <span>[</span><span>false</span><span>,</span> <span>true</span><span>]</span><span>:</span>
      <span>if</span> <span>(</span><span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>b</span> <span>-</span> <span>j</span><span>)</span> <span>xor</span> <span>u</span><span>:</span></code></pre>
</div>
</div>
<div>
<h4 id="_we_should_not_believe_all_what_we_think">We should not believe all what we think</h4>
<p>And what seems to be correct. Our nonrecursive function seems to be fine, and indeed inverting the
<span>== (u == 0)</span> condition makes a difference for random data, so it is correct?
Well when we think about it again the next day we may get some doubts. The outer loop
pops one entry from the stack, but in the loop we may push two new entries. Pushing the
smaller interval helps, as we continue with the smaller interval in the next iteration
and remove it so from the stack. But the net effect is still that we push one interval
onto the stack for each iteration, and for the worst case that interval shrinks only by one
in each iteration. So it should still not work.</p>
<p>But well, there are rumors that solutions exists. When we think about it, we may ask
our self if we can just continue with one interval in a loop and push only the other one
on the <span>stack</span>. And indeed, that is possible, and this time we did testing for worst case
scenario:</p>
<div>
<div>
<pre><code data-lang="nim"><span>from</span> <span>algorithm</span> <span>import</span> <span>isSorted</span><span>,</span> <span>sort</span>
<span>import</span> <span>std</span><span>/</span><span>monotimes</span>

<span>proc </span><span>qsort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>var</span> <span>stack</span><span>:</span> <span>array</span><span>[</span><span>64</span><span>,</span> <span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span><span>]</span>
  <span>var</span> <span>stackPtr</span><span>:</span> <span>int</span> <span>=</span> <span>-</span><span>1</span> <span># empty</span>
  <span>var</span> <span>maxStackLen</span><span>:</span> <span>int</span>
  <span>var</span> <span>a</span> <span>=</span> <span>s</span><span>.</span><span>low</span>
  <span>var</span> <span>b</span> <span>=</span> <span>s</span><span>.</span><span>high</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>if</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>1</span><span>:</span> <span># done with actual interval, but we may have to swap()</span>
      <span>if</span> <span>s</span><span>[</span><span>a</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>a</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>)</span>
    <span>if</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>:</span> <span># interval has still more than two entries, so continue</span>
      <span>discard</span>
    <span>elif</span> <span>stackPtr</span> <span>&gt;=</span> <span>0</span><span>:</span> <span># get next interval from stack</span>
      <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>stack</span><span>[</span><span>stackPtr</span><span>]</span><span>;</span> <span>dec</span><span>(</span><span>stackPtr</span><span>)</span>
    <span>else</span><span>:</span>
      <span>break</span> <span># all done</span>
    <span>if</span> <span>stackPtr</span> <span>&gt;</span> <span>maxStackLen</span><span>:</span>
      <span>maxStackLen</span> <span>=</span> <span>stackPtr</span>
    <span>assert</span><span>(</span><span>a</span> <span>&gt;=</span> <span>0</span> <span>and</span> <span>b</span> <span>&lt;</span> <span>s</span><span>.</span><span>len</span> <span>and</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>)</span>
    <span>let</span> <span>x</span> <span>=</span> <span>s</span><span>[</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span><span>]</span>
    <span># let x = s[a .. b].max # worst case test! Slow, test with smaller container size.</span>
    <span>var</span> <span>(</span><span>i</span><span>,</span> <span>j</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>while</span> <span>true</span><span>:</span>
      <span>while</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>:</span>
        <span>inc</span><span>(</span><span>i</span><span>)</span>
      <span>while</span> <span>s</span><span>[</span><span>j</span><span>]</span> <span>&gt;</span> <span>x</span><span>:</span>
        <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>if</span> <span>i</span> <span>&lt;</span> <span>j</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>
        <span>inc</span><span>(</span><span>i</span><span>);</span> <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>else</span><span>:</span>
        <span>break</span>
    <span>dec</span><span>(</span><span>i</span><span>);</span> <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span># assert(i &gt;= a and j &lt;= b) caution, this is not always true!</span>
    <span>if</span> <span>(</span><span>i</span> <span>-</span> <span>a</span> <span>&lt;</span> <span>b</span> <span>-</span> <span>j</span><span>):</span> <span># put large interval on stack and cont. directly with the small</span>
      <span>swap</span><span>(</span><span>i</span><span>,</span> <span>b</span><span>)</span>
      <span>swap</span><span>(</span><span>a</span><span>,</span> <span>j</span><span>)</span>
    <span>if</span> <span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>:</span> <span># interval has more than two entries, needs further processing</span>
      <span>inc</span><span>(</span><span>stackPtr</span><span>)</span> <span># inc before push!</span>
      <span>stack</span><span>[</span><span>stackPtr</span><span>]</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>i</span><span>)</span>
    <span>elif</span> <span>i</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>0</span><span>:</span> <span># two entries, we may have to swap()</span>
      <span>if</span> <span>s</span><span>[</span><span>a</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>i</span><span>]</span><span>:</span>
        <span>swap</span><span>(</span><span>s</span><span>[</span><span>a</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>i</span><span>]</span><span>)</span>
    <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>(</span><span>j</span><span>,</span> <span>b</span><span>)</span> <span># the smaller interval, we continue with that one</span>
  <span>echo</span> <span>&#34;Max Stack Length: &#34;</span><span>,</span> <span>maxStackLen</span>

<span>proc </span><span>quickSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>==</span> <span>2</span> <span>and</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>:</span> <span>swap</span><span>(</span><span>s</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>1</span><span>]</span><span>)</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>&gt;</span> <span>2</span><span>:</span>
    <span>qsort</span><span>(</span><span>s</span><span>)</span>

<span>import</span> <span>random</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>var</span> <span>start</span><span>:</span> <span>MonoTime</span>
  <span>randomize</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e5.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>shuffle</span>
    <span>s</span><span>.</span><span>quickSort</span>
    <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e7.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>quickSort</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>s</span><span>.</span><span>shuffle</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>sort</span><span>()</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The modifications to the code are again tiny. We use an outer <span>while true:</span> loop, which
continues with interval <span>a .. b</span> until its size is less than three entries. Then its
<span>pops()</span> a new interval from the stack.
At the end of that outer loop, we put only one interval on the stack and directly
continue with the other interval. But which interval should we push on the stack and which
one should we process directly further in the outer loop?
The solution is to process the smaller interval in the outer loop further, as we are soon
done with it. For processing that smaller interval, we may push some more ranges
onto the <span>stack</span>, but we come to interval sizes of less than three soon and then we start popping
intervals from the <span>stack</span>. And when we are done with that, we pop
the larger interval again from the <span>stack</span>. This way the worst case, where we pick each time a
min or max value as median, has the smallest <span>stack</span> consumption, that is one entry.
We push the large interval with size <span>n - 1</span> on the stack, continue with the tiny one entry
range, which signals that we are done with that interval in the next loop iteration and
so the just pushed <span>n - 1</span> interval is popped from the stack again. This continues in this way. Slow, but
minimal stack consumption.</p>
<p>From the above code it becomes clear that for our initial recursive <span>qsort()</span> function
changing the order in which we process the partitions would not really help, as
we continue the recursion until all is processed. There is no intermediate <span>pop()</span>
involved.</p>
<p>Maybe you still wonder why the tiny inner loops use the conditions
<span>while s[i] &lt; x:</span> and not <span>while s[i] &lt;= x:</span> as we said that both partitions
are allowed to contain the median element. Well with &lt;= there would be no guaranteed
stop condition for the interval, so indices could run out of the interval. Using
an additional condition like <span>and i &lt;= b</span> would make it slower. Another possible modification
would be to not use inner while loops at all. Tiny while loops with only one simple
termination condition are fast, but the inner while loops would always terminate fast for random data.
So we may try instead something like</p>
<div>
<div>
<pre><code data-lang="nim">    <span>while</span> <span>true</span><span>:</span>
      <span>if</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>x</span><span>:</span>
        <span>inc</span><span>(</span><span>i</span><span>)</span>
      <span>elif</span> <span>s</span><span>[</span><span>j</span><span>]</span> <span>&gt;</span> <span>x</span><span>:</span>
        <span>dec</span><span>(</span><span>j</span><span>)</span>
      <span>else</span><span>:</span>
        <span>if</span> <span>i</span> <span>&lt;</span> <span>j</span><span>:</span>
          <span>swap</span><span>(</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>j</span><span>]</span><span>)</span>
          <span>inc</span><span>(</span><span>i</span><span>);</span> <span>dec</span><span>(</span><span>j</span><span>)</span>
        <span>else</span><span>:</span>
          <span>break</span>
    <span>dec</span><span>(</span><span>i</span><span>);</span> <span>inc</span><span>(</span><span>j</span><span>)</span></code></pre>
</div>
</div>
<p>You may try that variant yourself, or maybe look for other variants in internet sources or
textbooks. Our intention in this section was not to present a perfect sorting function,
but to teach you some basic coding strategies and related traps.</p>
</div>
</div>
<div>
<h3 id="_merge_sort">Merge Sort</h3>
<p>Initially we did not intend to discuss the actual MergeSort algorithm at all, as it is a bit more complicated and
whenever we may have seen a sketch of it somewhere, it is generally
not easy to remember details.
But MergeSort is indeed an important algorithm, it is used by default in Nim’s standard library
and as we have discussed QuickSort already in some detail, we should be prepared for
MergeSort now. When we regard the name Merge, which is some form of joining multiple sources to one destination,
we may begin to remember the idea of MergeSort: The trick of QuickSort was, that we tried to split
in a recursive manner the set of all container elements into two subsets, which we can process separately.
That improves performance, as sorting is basically an O(n^2) process, and <span>2 * (n/2)^2</span> is only half of <span>n^2</span>.
For QuickSort we partitioned the initial range into two ranges <span>a</span> and <span>b</span>, where all elements of range <span>a</span> are
less or equal to a median element <span>x</span>, and all elements of range <span>b</span> are greater or equal to the median <span>x</span>.
That way we decoupled the two ranges, we can sort <span>a</span> and <span>b</span> independently and get a fully sorted range.
MergeSort starts also with splitting the full range into two parts, but it really only splits, without
any form of rearrangement. Then it continues with sorting each part independently.
That sounds strange at first, as we get two sorted parts <span>a</span> and <span>b</span>, but of course we can not
simple append one to the other. The idea of the whole algorithm become clear immediately
when we think about how we can find the smallest elements of the joined content from <span>a</span> and <span>b</span>.
That one is obviously the smallest value of <span>a</span>, or the smallest value of <span>b</span>, <span>min(a, b) = min(min(a), min(b))</span>.
But when <span>a</span> and <span>b</span> are already sorted, then the minimal value of each is the first element, and so
one of these elements at index position zero is the smallest one for <span>a</span> and <span>b</span> joined. And this condition
holds even when we pick and remove the smallest element from <span>a</span> or <span>b</span>.</p>
<p>So the basic algorithm is this: Split the whole container in parts <span>a</span> and <span>b</span>, sort them separately. Then create a new, sorted
container by iterative picking the first elements from <span>a</span> or <span>b</span>, which ever is actually the smaller one.</p>
<p>Unfortunately it seems to be impossible to sort the initially container in place in this way, as
we would take always elements from the front from both and put them at the front of the destination, so
that newly inserted elements could overwrite still unprocessed elements. So we will
try to give a sketch of an very slow unoptimized algorithm which creates and returns a new sorted container first
to lean the fundamental idea of the algorithm:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>msort</span><span>(</span><span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>;</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>):</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span>
  <span>assert</span><span>(</span><span>b</span> <span>-</span> <span>a</span> <span>&gt;=</span> <span>0</span><span>)</span>
  <span>if</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>0</span><span>:</span>
    <span>result</span><span>.</span><span>add</span><span>(</span><span>s</span><span>[</span><span>a</span><span>]</span><span>)</span>
    <span>return</span>
  <span>elif</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>1</span><span>:</span>
    <span>var</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=</span> <span>(</span><span>s</span><span>[</span><span>a</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>)</span>
    <span>if</span> <span>a</span> <span>&gt;</span> <span>b</span><span>:</span>
      <span>swap</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>result</span><span>.</span><span>add</span><span>(</span><span>a</span><span>)</span>
    <span>result</span><span>.</span><span>add</span><span>(</span><span>b</span><span>)</span>
    <span>return</span>
  <span>result</span> <span>=</span> <span>newSeq</span><span>[</span><span>int</span><span>]</span><span>(</span><span>b</span> <span>-</span> <span>a</span> <span>+</span> <span>1</span><span>)</span>
  <span>var</span> <span>sl</span> <span>=</span> <span>result</span><span>.</span><span>len</span>
  <span>assert</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span>
  <span>var</span> <span>m</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span>
  <span>assert</span> <span>m</span> <span>&gt;=</span> <span>a</span>
  <span>assert</span> <span>m</span> <span>&lt;</span> <span>b</span>
  <span>var</span> <span>s1</span><span>,</span> <span>s2</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>s1</span> <span>=</span> <span>msort</span><span>(</span><span>s</span><span>,</span> <span>a</span><span>,</span> <span>m</span><span>)</span>
  <span>var</span> <span>(</span><span>i</span><span>,</span> <span>j</span><span>)</span> <span>=</span> <span>(</span><span>a</span><span>,</span> <span>m</span><span>)</span>
  <span>s2</span> <span>=</span> <span>msort</span><span>(</span><span>s</span><span>,</span> <span>m</span> <span>+</span> <span>1</span><span>,</span> <span>b</span><span>)</span>
  <span>assert</span> <span>s1</span><span>.</span><span>len</span> <span>+</span> <span>s2</span><span>.</span><span>len</span> <span>==</span> <span>result</span><span>.</span><span>len</span>
  <span>var</span> <span>(</span><span>k</span><span>,</span> <span>l</span><span>)</span> <span>=</span> <span>(</span><span>m</span> <span>+</span> <span>1</span><span>,</span> <span>b</span><span>)</span>
  <span>var</span> <span>l1</span> <span>=</span> <span>s1</span><span>.</span><span>high</span>
  <span>var</span> <span>l2</span> <span>=</span> <span>s2</span><span>.</span><span>high</span>
  <span>while</span> <span>sl</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>dec</span><span>(</span><span>sl</span><span>)</span>
    <span>if</span> <span>l1</span> <span>&gt;=</span> <span>0</span> <span>and</span> <span>l2</span> <span>&gt;=</span> <span>0</span><span>:</span> <span># merge</span>
      <span>if</span> <span>s1</span><span>[</span><span>l1</span><span>]</span> <span>&gt;</span> <span>s2</span><span>[</span><span>l2</span><span>]</span><span>:</span>
        <span>result</span><span>[</span><span>sl</span><span>]</span> <span>=</span> <span>s1</span><span>[</span><span>l1</span><span>]</span>
        <span>dec</span><span>(</span><span>l1</span><span>)</span>
      <span>else</span><span>:</span>
        <span>result</span><span>[</span><span>sl</span><span>]</span> <span>=</span> <span>s2</span><span>[</span><span>l2</span><span>]</span>
        <span>dec</span><span>(</span><span>l2</span><span>)</span>
    <span>else</span><span>:</span> <span># plain copy</span>
      <span>while</span> <span>l1</span> <span>&gt;=</span> <span>0</span><span>:</span>
        <span>result</span><span>[</span><span>sl</span><span>]</span> <span>=</span> <span>s1</span><span>[</span><span>l1</span><span>]</span>
        <span>dec</span><span>(</span><span>sl</span><span>);</span> <span>dec</span><span>(</span><span>l1</span><span>)</span>
      <span>while</span> <span>l2</span> <span>&gt;=</span> <span>0</span><span>:</span>
        <span>result</span><span>[</span><span>sl</span><span>]</span> <span>=</span> <span>s2</span><span>[</span><span>l2</span><span>]</span>
        <span>dec</span><span>(</span><span>sl</span><span>);</span> <span>dec</span><span>(</span><span>l2</span><span>)</span>

<span>proc </span><span>mergeSort</span><span>(</span><span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>):</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>&lt;</span> <span>2</span><span>:</span>
    <span>return</span> <span>s</span>
  <span>msort</span><span>(</span><span>s</span><span>,</span> <span>s</span><span>.</span><span>low</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)</span>

<span>import</span> <span>random</span><span>,</span> <span>algorithm</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>,</span> <span>st</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>randomize</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>100</span><span>))</span>
  <span>st</span> <span>=</span> <span>s</span>
  <span>echo</span> <span>s</span><span>.</span><span>mergeSort</span>
  <span>assert</span><span>(</span><span>s</span><span>.</span><span>mergeSort</span> <span>==</span> <span>st</span><span>.</span><span>sorted</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The example above is indeed not very complicated, the most daunting task is
to get all the indices right. Due to the involved recursion and the fact that we
have to do the sorting of the two parts first, before we can join them, debugging
would be not easy. So we added many asserts to early find stupid errors.</p>
<p>The function <span>mSort()</span> starts by checking if the range to sort has only one or two
entries and handles this simple case directly. Then we allocate the result
sequence, find the center position <span>m</span> of the interval <span>a</span> and <span>b</span> and sort
the intervals <span>a .. m</span> and <span>m + 1 .. b</span> each into a new sequence <span>s1</span> and <span>s2</span>.
We have decided that we will do the merging of <span>s1</span> and <span>s2</span> into the result
sequence from the back, starting with the largest elements. This way we can
count down to zero, which is a bit faster and simpler. We do an actual merging as long as
<span>s1</span> and <span>s2</span> have still elements left. An we do the merge from end to start, we have to always pick the largest
element from <span>s1</span> or <span>s2</span>. If we have used all the elements from at least one of the
sequences <span>s1</span> or <span>s2</span>, then there is nothing more to merge, we can just copy
the remaining elements from the other <span>seq</span> that has elements left.
Of course the above example is very slow, as we allocate the result
and additional the sequences <span>s1</span> and <span>s2</span>, and as we have to copy many elements.</p>
<p>When we now think again about the problem, we get the feeling
that allocating three sequences is really too much. When we regard
both, in place sorting and sorting with a return value, we may discover
that in place sorting allows us to partly reuse the passed container, and we have
only to allocate one additional <span>seq</span> with half the size of the passed container.
We copy the second half of the passed container into a newly allocated <span>seq</span>, and then can merge
values from the new <span>seq</span> and from the first half of the passed <span>seq</span> to positions starting at the end
of the passed <span>seq</span>, without overwriting values that we still have to process.</p>
<p>This way our code becomes even shorter and basically simpler — we have only to
care very exactly to use the right index positions.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>msort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>;</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>)</span> <span>=</span>
  <span>assert</span><span>(</span><span>b</span> <span>-</span> <span>a</span> <span>&gt;=</span> <span>0</span><span>)</span>
  <span>if</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>0</span><span>:</span>
    <span>return</span>
  <span>elif</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>1</span><span>:</span>
    <span>if</span> <span>s</span><span>[</span><span>a</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>:</span>
      <span>swap</span><span>(</span><span>s</span><span>[</span><span>a</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>)</span>
    <span>return</span>
  <span>var</span> <span>m</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span>
  <span>assert</span><span>(</span><span>m</span> <span>&gt;=</span> <span>a</span> <span>and</span> <span>m</span> <span>&lt;</span> <span>b</span> <span>and</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>)</span>
  <span>var</span> <span>sh</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span> <span>=</span> <span>s</span><span>[</span><span>(</span><span>m</span> <span>+</span> <span>1</span><span>)</span> <span>..</span> <span>b</span><span>]</span>
  <span>var</span> <span>ls</span> <span>=</span> <span>b</span> <span>+</span> <span>1</span>
  <span>msort</span><span>(</span><span>s</span><span>,</span> <span>a</span><span>,</span> <span>m</span><span>)</span>
  <span>msort</span><span>(</span><span>sh</span><span>,</span> <span>sh</span><span>.</span><span>low</span><span>,</span> <span>sh</span><span>.</span><span>high</span><span>)</span>
  <span>var</span> <span>lh</span> <span>=</span> <span>sh</span><span>.</span><span>high</span>
  <span>var</span> <span>lm</span> <span>=</span> <span>m</span>
  <span>while</span> <span>ls</span> <span>&gt;</span> <span>a</span><span>:</span>
    <span>dec</span><span>(</span><span>ls</span><span>)</span>
    <span>if</span> <span>lh</span> <span>&lt;</span> <span>0</span><span>:</span>
      <span>assert</span> <span>ls</span> <span>==</span> <span>lm</span>
      <span>break</span>
    <span>elif</span>  <span>lm</span> <span>&lt;</span> <span>a</span><span>:</span>
      <span>while</span> <span>lh</span> <span>&gt;=</span> <span>0</span><span>:</span>
        <span>s</span><span>[</span><span>ls</span><span>]</span> <span>=</span> <span>sh</span><span>[</span><span>lh</span><span>]</span>
        <span>dec</span><span>(</span><span>ls</span><span>);</span> <span>dec</span><span>(</span><span>lh</span><span>)</span>
    <span>else</span><span>:</span>
      <span>if</span> <span>sh</span><span>[</span><span>lh</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>lm</span><span>]</span><span>:</span>
        <span>s</span><span>[</span><span>ls</span><span>]</span> <span>=</span> <span>sh</span><span>[</span><span>lh</span><span>]</span>
        <span>dec</span><span>(</span><span>lh</span><span>)</span>
      <span>else</span><span>:</span>
        <span>s</span><span>[</span><span>ls</span><span>]</span> <span>=</span> <span>s</span><span>[</span><span>lm</span><span>]</span>
        <span>dec</span><span>(</span><span>lm</span><span>)</span>

<span>proc </span><span>mergeSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>msort</span><span>(</span><span>s</span><span>,</span> <span>s</span><span>.</span><span>low</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)</span>

<span>import</span> <span>random</span><span>,</span> <span>algorithm</span><span>,</span> <span>std</span><span>/</span><span>monotimes</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>var</span> <span>start</span><span>:</span> <span>MonoTime</span>
  <span>randomize</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e5.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>shuffle</span>
    <span>s</span><span>.</span><span>mergeSort</span>
    <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e7.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>var</span> <span>st</span> <span>=</span> <span>s</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>mergeSort</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>st</span><span>.</span><span>sort</span><span>()</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>assert</span> <span>s</span> <span>==</span> <span>st</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>For the merging process, we
first test if one of the source areas is already exhausted. If all entries
from the newly allocated <span>seq</span> <span>sh</span> are consumed, then we can just stop, as
continuing would only copy elements of the passed container with
equal index positions. And if all elements from the first half of the passed container are
consumed, we can just copy the elements from <span>sh</span> into the passed <span>var</span> container.
Only if both sources have elements to process left, we have to do the actual
merging.</p>
<p>When we run the program above, we may find that it is about 50% slower
than our QuickSort functions. The reason for that may be that we have to
allocate the temporary <span>seq</span> <span>sh</span>, fill it with values, and merge it back.
And the total memory consumption is high, our recursive function calls consumes
for the buffers <span>sh</span> totally the same amount as the initial container. The advantages of MergeSort is that
there is no worst case as for QuickSort, as we have not to select a median but
can split the range just at the center, and that the sort is stable, that is
merging does not exchange the position of elements with same value.footnote[
Well to ensure this, we may have to check the actual merge condition, do we have
to test for &lt; or &lt;=. Currently we do not really care for that, but is is clear
and well known that merge sort can be stable.]</p>
<p>When we think a bit more about the algorithm above and maybe try to
sketch the recursive steps for a short sequence with pencil and paper we
get the strong feeling that the additional buffer <span>sh</span> is only needed for the
merging step, and as the merging process occurs from bottom to top
(containers with only one or two entries are returned immediately, which
are merged to a larger section, and these larger section is again merged …​)
one single buffer could be used. So we have modified our example again.
Now the <span>quicksort()</span> <span>proc</span> allocates the buffer <span>seq</span> with half the size of the actual
data container, and we pass that buffer recursively to the <span>qsort()</span> <span>proc</span> and
use it for the merging only. We call recursively <span>qsort()</span> on the first and second half
of the full range that we have to sort, then copy the sorted second half into
the buffer and merge the fist half and the buffer into the final
location.</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>msort</span><span>(</span><span>s</span><span>,</span> <span>sh</span><span>:</span> <span>var</span> <span>openArray</span><span>[</span><span>int</span><span>]</span><span>;</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span><span>)</span> <span>=</span>
  <span>assert</span><span>(</span><span>b</span> <span>-</span> <span>a</span> <span>&gt;=</span> <span>0</span><span>)</span>
  <span>if</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>0</span><span>:</span>
    <span>return</span>
  <span>elif</span> <span>b</span> <span>-</span> <span>a</span> <span>==</span> <span>1</span><span>:</span>
    <span>if</span> <span>s</span><span>[</span><span>a</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>:</span>
      <span>swap</span><span>(</span><span>s</span><span>[</span><span>a</span><span>]</span><span>,</span> <span>s</span><span>[</span><span>b</span><span>]</span><span>)</span>
    <span>return</span>
  <span>var</span> <span>m</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span>
  <span>assert</span> <span>(</span><span>m</span> <span>&gt;=</span> <span>a</span> <span>and</span> <span>m</span> <span>&lt;</span> <span>b</span> <span>and</span> <span>b</span> <span>-</span> <span>a</span> <span>&gt;</span> <span>1</span><span>)</span>
  <span>msort</span><span>(</span><span>s</span><span>,</span> <span>sh</span><span>,</span> <span>a</span><span>,</span> <span>m</span><span>)</span>
  <span>msort</span><span>(</span><span>s</span><span>,</span> <span>sh</span><span>,</span> <span>m</span> <span>+</span> <span>1</span><span>,</span> <span>b</span><span>)</span>

  <span>var</span> <span>ls</span> <span>=</span> <span>b</span> <span>+</span> <span>1</span>
  <span>var</span> <span>lh</span> <span>=</span> <span>b</span> <span>-</span> <span>m</span> <span>-</span> <span>1</span>
  <span>var</span> <span>lm</span> <span>=</span> <span>m</span>
  <span>#sh[sh.low .. lh] = s[m + 1 .. b]</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>lh</span><span>:</span> <span># a bit faster</span>
    <span>sh</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>s</span><span>[</span><span>m</span> <span>+</span> <span>1</span> <span>+</span> <span>i</span><span>]</span>
  <span>while</span> <span>ls</span> <span>&gt;</span> <span>a</span><span>:</span>
    <span>dec</span><span>(</span><span>ls</span><span>)</span>
    <span>if</span> <span>lh</span> <span>&lt;</span> <span>0</span><span>:</span>
      <span>assert</span> <span>ls</span> <span>==</span> <span>lm</span>
      <span>break</span>
    <span>elif</span>  <span>lm</span> <span>&lt;</span> <span>a</span><span>:</span>
      <span>while</span> <span>lh</span> <span>&gt;=</span> <span>0</span><span>:</span>
        <span>s</span><span>[</span><span>ls</span><span>]</span> <span>=</span> <span>sh</span><span>[</span><span>lh</span><span>]</span>
        <span>dec</span><span>(</span><span>ls</span><span>);</span> <span>dec</span><span>(</span><span>lh</span><span>)</span>
    <span>else</span><span>:</span>
      <span>if</span> <span>sh</span><span>[</span><span>lh</span><span>]</span> <span>&gt;</span> <span>s</span><span>[</span><span>lm</span><span>]</span><span>:</span>
        <span>s</span><span>[</span><span>ls</span><span>]</span> <span>=</span> <span>sh</span><span>[</span><span>lh</span><span>]</span>
        <span>dec</span><span>(</span><span>lh</span><span>)</span>
      <span>else</span><span>:</span>
        <span>s</span><span>[</span><span>ls</span><span>]</span> <span>=</span> <span>s</span><span>[</span><span>lm</span><span>]</span>
        <span>dec</span><span>(</span><span>lm</span><span>)</span>

<span>proc </span><span>mergeSort</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>==</span> <span>0</span><span>:</span> <span>return</span>
  <span>var</span> <span>sh</span> <span>=</span> <span>newSeq</span><span>[</span><span>int</span><span>]</span><span>(</span><span>s</span><span>.</span><span>len</span> <span>div</span> <span>2</span><span>)</span>
  <span>msort</span><span>(</span><span>s</span><span>,</span> <span>sh</span><span>,</span> <span>s</span><span>.</span><span>low</span><span>,</span> <span>s</span><span>.</span><span>high</span><span>)</span>

<span>import</span> <span>random</span><span>,</span> <span>algorithm</span><span>,</span> <span>std</span><span>/</span><span>monotimes</span>
<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>
  <span>var</span> <span>start</span><span>:</span> <span>MonoTime</span>
  <span>randomize</span><span>()</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e5.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>9</span><span>:</span>
    <span>s</span><span>.</span><span>shuffle</span>
    <span>s</span><span>.</span><span>mergeSort</span>
    <span>assert</span><span>(</span><span>isSorted</span><span>(</span><span>s</span><span>))</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1e7.</span><span>int</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>rand</span><span>(</span><span>1e8.</span><span>int</span><span>))</span>
  <span>var</span> <span>st</span> <span>=</span> <span>s</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>s</span><span>.</span><span>mergeSort</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>start</span> <span>=</span> <span>getMonotime</span><span>()</span>
  <span>st</span><span>.</span><span>sort</span><span>()</span>
  <span>echo</span> <span>getMonotime</span><span>()</span> <span>-</span> <span>start</span>
  <span>assert</span> <span>s</span> <span>==</span> <span>st</span>
<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>An additional tiny performance improvement results from the fact that we now pass the <span>seq</span> <span>s</span>
and the buffer <span>sh</span> as <span>openArrays</span>. This is generally a good idea, as we can so sort
<span>arrays</span> also with the same sorting <span>proc</span>, and it improves performance, as
this way the actual data buffer is directly passed to the <span>qsort()</span> <span>proc</span>, while passing
a <span>seq</span> means that we pass the opaque <span>seq</span> structure which contains a pointer to the
actual data. In the example above we do not only call <span>isSorted()</span> to prove
our result, but we really sort a copy of our data with a sorting routine from Nim’s standard lib
to ensure that our result is not only sorted data, but that it is indeed based on the
actual values. That is a good idea, because although the algorithm is simple, getting
some indices wrong may give us wrong results.</p>
<p>Our recursive merge sort routine is really not that bad. It does a fast stable sort and
needs only a single buffer of half the size of our actual data. As the interval
size is halved in each recursion step, the max recursion depth should be only <span>64</span>
for a gigantic container with <span>2^64</span> elements. As the recursion occurs in a dept first
fashion, that is <span>msort()</span> calls itself until range size is only one or two elements, then
recursion continues in other branches of the whole sorting three, there should be
never more than <span>log2(n)</span> actual recursion steps stored on the CPU stack.
Non recursive, iterative merge sort algorithm exists, but converting the
recursive algorithm in an iterative one is not that simple as for the QuickSort case.
The reason is that <span>qsort()</span> has first to partition the input range, then call
<span>msort()</span> on both subranges and finally do the merging. We will not try
to present in this book an iterative <span>msort()</span>, which you may find in textbooks or somewhere in the internet,
as that would be a bit too much for an introducing course.</p>
<p>We did the QuickSort and the MergeSort in a top down fashion, that is we split
the initial container in two subpartitions and continue in this way until
we have only ranges with one or two entries, and than do the merging from bottom
to top. For MergeSort we could just start from the bottom joining single adjacent elements
to sorted tuples of two entries, when done with that merging the tuples of two to sorted tuples of <span>4</span> and
so on. This would work really well when the initial number of elements in our container is
a power of two, and it would work well iterative without recursion. Unfortunately in most
cases the container size is not a power of two, so such a bottom up merge sort needs
some math to get all the ranges sizes right. But the bottom up process has a big disadvantage
on modern hardware, as it has no locality for element access operations: We would iterate
repeatedly over all the container entries in sequential order, so the CPU cache can
not support our element access operation that well.</p>
<p>Other known sorting algorithms are
the easy, funny and slow BubbleSort, or Shell- and Shaker-Sort. But these are not used
in practice. As an exercise you can try to make our QuickSort or MergeSort generic and pass a <span>cmp()</span>
proc, and make it work for sorting in ascending and descending order. Or, you may
try to fall back to selection sort when the partitions become small. In theory
SelectionSort is faster for ranges of only a few dozen elements, but when we
have to do a decision which one to use inside of the <span>qsort()</span> or <span>msort()</span> <span>proc</span>, then this decision
compensates generally the advantages again, so that the net benefit is tiny.
Of course we would have to test all of our sorting <span>procs</span> for special cases, that is
for <span>seqs</span> of length <span>0</span>, <span>1</span> or two, and for sequences with all entries equal, all inversely sorted
or presorted. And we would have to check how performance is when we sort not containers containing plain data
like numbers, but containers which elements are <span>objects</span>, <span>strings</span> or again <span>arrays</span> or sequences.
<span>string</span> sorting is special for various reasons: <span>strings</span> in Nim
are an opaque <span>object</span> with a pointer to the actual data. This is some indirection, and the actual data
can be located somewhere in the RAM in a cache unfriendly manner, so the actual comparison process
can be slow. Swapping of strings is also special, as <span>swap()</span> generally just does a pointer exchange for
the data areas, and does not have to copy the actual data. For sorting containers where each entry is
an <span>array</span> (of characters), swap would have to copy the data content.</p>
<p>Finally we should mention that the Python language uses a complicated sorting algorithm
called TimSort which is a smart mix of various sorting algorithm.</p>
<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_some_small_exercises"><span>Some small exercises</span></h2>
<div>
<div>
<h3 id="_removing_adjacent_duplicates">Removing adjacent duplicates</h3>
<p>Removing duplicates from containers is a common programming task.
When we know in advance, that we do not want to store the same data value
more than once, and that the order of the stored values does not matter, then
we may consider using some form of <span>sets</span> or hash <span>sets</span>. If insertion order matters, then
the standard library may provide some form of ordered or sorted <span>sets</span> for us. But for this exercise we  will assume
that we have values stored in a sequence, and we want to remove the adjacent duplicates.
A typical use case for that is when we have stored a path of 2D or 3D positions. When we insert, move or
delete a position value, it may occur that we get duplicates, with zero spatial distance between the two
neighbored positions. In that case it is generally desired to remove the duplicate. A similar use case
may be a text file stored as a sequence of words, where adjacent duplicated words may indicate
a typo. To keep our example short and simple, we will use as data type a <span>seq</span>[int]. Using other data
types or creating a generic <span>proc</span> should be not difficult for the reader.</p>
<div>
<div>
<pre><code># [1, 4, 4, 2, 5, 5, 5, 1] ==&gt; [1, 4, 2, 5, 1]</code></pre>
</div>
</div>
<p>Before you continue looking at our provided example code, you may think about this task yourself,
maybe take a piece of paper and a pencil and sketch the algorithm. It is really not difficult, maybe too
easy for you when you have carefully studied the proceeding sections of the book or when you have already
some programming experience. When we create a <span>proc</span> for this task we have to decide first if the <span>proc</span> should work on the
passed in <span>seq</span> in-place or if it should return the processed result and leave the original data unchanged.
Often returning a copy is easier, but for our task the common use case seems to be more an algorithm that works in place.
So we will provide the in place algorithm here and leave the version returning a processed result as an optional
exercise to the reader. Note that returning a processed copy needs to allocate the <span>seq</span> for the result, and maybe later the memory management system has to free
the result data again, which is some additional effort. So we may guess that the in-place <span>proc</span> is faster, as long as we do not really need
the copy. When needed we can use the <span>dup()</span> macro of the <span>sugar</span> module to use our in place <span>proc</span> as one that works on a copy and returns this copy, without modifying the input.</p>
<p>The basic idea of our algorithm is that we iterate through the whole <span>seq</span> and pick an element at the current location
only if it is not identical to the proceeding element. For the case that our <span>seq</span> is empty or contains only one single element, we have obviously noting to do
and can return immediately. So our code may look like</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>deTwin</span><span>(</span><span>s</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>int</span><span>]</span><span>)</span> <span>=</span>
  <span>if</span> <span>s</span><span>.</span><span>len</span> <span>&lt;</span> <span>2</span><span>:</span>
    <span>return</span>
  <span>var</span> <span>i</span><span>,</span> <span>d</span><span>:</span> <span>int</span> <span># d is the position where we copy the elements that we want to keep</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>s</span><span>.</span><span>high</span><span>:</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
    <span>if</span> <span>s</span><span>[</span><span>d</span><span>]</span> <span>!=</span> <span>s</span><span>[</span><span>i</span><span>]</span><span>:</span>
      <span>inc</span><span>(</span><span>d</span><span>)</span>
      <span>s</span><span>[</span><span>d</span><span>]</span> <span>=</span> <span>s</span><span>[</span><span>i</span><span>]</span>
  <span>s</span><span>.</span><span>setLen</span><span>(</span><span>d</span> <span>+</span> <span>1</span><span>)</span>

<span>var</span> <span>h</span> <span>=</span> <span>@[</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>1</span><span>]</span>
<span>detwin</span><span>(</span><span>h</span><span>)</span>
<span>echo</span> <span>h</span> <span># [1, 4, 2, 5, 1]</span></code></pre>
</div>
</div>
<p>We use two positions, the actual position in the input data denoted as <span>i</span>, and the destination
position <span>d</span>. Both start with the default value zero. To keep full control over the iterating process,
we do not use a for iterator in this case, but a plain while loop for the index of the actual position.
In the while loop body we compare the value at the current index position <span>s[i]</span> with the value that
we picked before, which is <span>s[d]</span>. If the values are not identical, we pick the current value <span>s[i]</span>, otherwise
we just skip it. With picking a value we mean that we copy it from index position <span>i</span> to index position <span>d</span>.
Of course this can only work, when <span>d</span> is never larger than <span>i</span>, as otherwise we would destroy our
still unprocessed input data at positions <span>s[i + 1]</span>. The loop body is really simple, but getting the indices
right needs some care: We have to ensure that <span>i</span> and <span>d</span> starts at the right positions, that we increase
<span>i</span> and <span>d</span> when necessary, and that the loop terminates when all input data is processed. Obviously
the first comparison should compare <span>s[d == 0]</span> with <span>s[i == 1]</span>. So <span>d</span> and <span>i</span> can get initial values zero each, when
we increase <span>i</span> already each time at the start of the loop. The destination position <span>d</span> starts with zero, as
we always accept the first element, and <span>d</span> increases only when we have accepted one more element.
The loop is executed as long as <span>i</span> is less than <span>s.high</span>. Finally we have to set the new length of <span>s</span> to <span>d + 1</span>.
The value <span>d + 1</span> results from the fact that we always accept the first element, and for each more accepted
element <span>d</span> is increased, so the total number of accepted elements is <span>d + 1</span>. The carefully reader may wonder
if the first two lines of the <span>proc</span>, where we test for the trivial case, are really necessary, or if
these cases can be covered by our while loop already. Well, generally it is a good idea to avoid unnecessary tests
for trivial cases when possible, as that tests may increase code size and cost some tiny bit of performance.
But in this case we have two trivial cases — empty seq and seq with only one element, which can be not covered well
with a loop with only one simple termination condition. And of course we should try to make the condition
of the while loop as simple as possible, that is avoid additional boolean conditions with <span>and</span> or <span>or</span> operators
for best performance. Further you may wonder if our picking strategy is really optimal, as for a <span>seq</span>
with no adjacent duplicates we still copy all the elements. Yes indeed, but for the general case with
duplicates we have to do the copy, and such a copy operation is really fast. And additional tests with an <span>if</span>
condition should cost some performance. Maybe we could have used two loops in the <span>proc</span> body, one that
just accepts elements without a copy operation as long as no duplicates are found, and a second loop like the
one from above which then has to do copy operations to move the elements to the front. You may try that
yourself and measure the performance for various input data.</p>
</div>
<div>
<h3 id="_array_difference">Array difference</h3>
<p>The difference of two arrays or sequences A and B is the set (A - B) of values that are contained in A but not in B.</p>
<div>
<div>
<pre><code>[1, 2, 5, 2, 9, 7, 0] - [7, 4, 1, 10, 7] == [2, 5, 2, 9, 0]</code></pre>
</div>
</div>
<p>Actually such difference of array or seq containers is not needed that often, that is why that function may not be provided by the
Nim standard library.
Building such kind of differences is much easier and faster with sets or hash sets, so whenever possible we should
use these containers from the beginning when we know in advance that we have to build differences.
But sometimes we just have arrays or sequences, and then we may notice that we need the difference. When the order of the elements does not matter,
we may just convert both containers to sets or hash sets, build the difference and then maybe convert that difference back to a
seq. But there are use cases where we really want to work with array or seq containers, maybe because we want to iterate over the container,
want that values can be contained multiple times or always keep the insertion order.</p>
<p>So let’s create an algorithm to do this task. A naive strategy would be to iterate over container A and delete each element that is also contained in B.
But that would be slow, and may not work at all, as deleting elements while we iterate over the seq does generally not work at all.
We will create a <span>proc</span> called <span>`-`</span> which can be used as an operator to build the difference of two arrays or sequences and which returns
the difference as a new seq, and a <span>`-=`</span> <span>proc</span> which removes the elements of <span>b</span> from <span>a</span> in place and is also used as an operator.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sets</span>

<span>proc </span><span>`-`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>:</span> <span>openArray</span><span>[</span><span>T</span><span>]</span><span>):</span> <span>seq</span><span>[</span><span>T</span><span>]</span> <span>=</span>
  <span>let</span> <span>s</span> <span>=</span> <span>b</span><span>.</span><span>toHashSet</span>
  <span>result</span> <span>=</span> <span>newSeq</span><span>[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>.</span><span>len</span><span>)</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>for</span> <span>el</span> <span>in</span> <span>a</span><span>:</span>
    <span>if</span> <span>el</span> <span>notin</span> <span>s</span><span>:</span>
      <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>el</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>result</span><span>.</span><span>setLen</span><span>(</span><span>i</span><span>)</span>

<span>proc </span><span>`-=`</span><span>*[</span><span>T</span><span>]</span><span>(</span><span>a</span><span>:</span> <span>var</span> <span>seq</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>b</span><span>:</span> <span>openArray</span><span>[</span><span>T</span><span>]</span><span>)</span> <span>=</span>
  <span>let</span> <span>s</span> <span>=</span> <span>b</span><span>.</span><span>toHashSet</span>
  <span>var</span> <span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span> <span># both start with default value zero</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>a</span><span>.</span><span>len</span><span>:</span>
    <span>if</span> <span>a</span><span>[</span><span>i</span><span>]</span> <span>notin</span> <span>s</span><span>:</span>
      <span>a</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>a</span><span>[</span><span>i</span><span>]</span>
      <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>a</span><span>.</span><span>setLen</span><span>(</span><span>j</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>let</span> <span>a</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>,</span> <span>7</span><span>,</span> <span>0</span><span>]</span>
  <span>let</span> <span>b</span> <span>=</span> <span>[</span><span>7</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>7</span><span>]</span>
  <span>echo</span> <span>a</span> <span>-</span> <span>b</span> <span># @[2, 5, 2, 9, 0]</span>
  <span>echo</span> <span>b</span> <span>-</span> <span>a</span> <span># @[4, 10]</span>

  <span>var</span> <span>x</span> <span>=</span> <span>@</span><span>a</span>
  <span>x</span> <span>-=</span> <span>b</span>
  <span>echo</span> <span>x</span> <span># @[2, 5, 2, 9, 0]</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>To make the lookup for elements contained in <span>b</span> fast, we convert <span>b</span> to a <span>hash set</span>, for which lookup time is in principle
independent of the size of the container, which is called O(1) in the big O notation. We make the two <span>procs</span> generic and
use the data type <span>open array</span> for the two passed arguments so that our <span>procs</span> can be used for arrays as well as for sequences.
The exception is the first var parameter of the <span>`-=`</span> <span>proc</span>, which has to be a seq obviously, as arrays have a fixed size and can not shrink.
For the <span>`-`</span> <span>proc</span> we pre-allocate the returned <span>result</span> variable with a size of <span>a.len</span>, so that we can avoid re-allocations.
Then we iterate over <span>a</span> with a for loop, and copy the current element to the result seq when the value in not contained
in the hash set. We use the subscript operator <span>[]</span> to copy the picked elements at position <span>i</span> in the <span>result</span> seq, which is faster than
starting with an empty <span>result</span> seq and appending the picked elements. As we initialize the <span>result</span> seq with the size
of container <span>a</span>, we have finally to call <span>result.setLen(i)</span> to shrink the size to the number of actually picked elements.
The presented <span>`-=`</span> <span>proc</span> is a bit more complicated, as we process seq <span>a</span> in place. We use an approach similar
as we did in the <span>deTwin()</span> <span>proc</span> in the previous section, that is we use two index positions <span>i</span> and <span>j</span>, and copy elements from current position <span>i</span>
to position <span>j</span> if the value is not contained in the lookup set. Again finally we have to set the size of seq <span>a</span> to the
number of picked elements.</p>
<p>While the two presented <span>procs</span> may be actually useful in same cases, they are more presented as an exercise here.
As a smart user of the Nim forum showed us, we can get a very similar behaviour by use of the <span>filter()</span> <span>proc</span> in
combination with the <span>=&gt;</span> operator of the <span>sugar</span> module:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>sequtils</span><span>,</span> <span>sets</span><span>,</span> <span>sugar</span>

<span>let</span> <span>a</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>,</span> <span>7</span><span>,</span> <span>0</span><span>]</span>
<span>let</span> <span>b</span> <span>=</span> <span>[</span><span>7</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>10</span><span>,</span> <span>7</span><span>]</span>

<span>let</span> <span>bSet</span> <span>=</span> <span>b</span><span>.</span><span>toHashSet</span><span>()</span>
<span>echo</span> <span>a</span><span>.</span><span>filter</span><span>((</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>notin</span> <span>bSet</span><span>)</span></code></pre>
</div>
</div>
<p>References:</p>

</div>
<div>
<h3 id="_binary_search">Binary search</h3>
<p>Maybe you can remember that some decades ago your parents have used phone books
and dictionaries build of paper sheets, filled with printed text sorted alphabetically?
Well, that alphabetically ordering was done with a purpose: When searching for a name or
a word, we could just open the book somewhere in the middle. If the name or word that we searched for
was ordered alphabetically before the content of the current page, then we continued searching
for that term in the lower half, otherwise in the upper half. That procedure was continued
until the searched entry was found, or until it was observed that it was not available at all.
This type of search in an ordered data set is called <span>binary search</span>, <span>half-interval search</span>, <span>logarithmic</span> search or <span>binary chop</span>.
As each repetition halves the remaining data set, it is much faster than a linear search in unordered
data.</p>
<p>To use this type of search strategy on the computer, we store our data sorted in an array or a seq.
Creating a <span>proc</span> to do the search is basically very easy, but we have to care for some details:</p>
<div>
<div>
<pre><code data-lang="nim"><span># 1 2 3 4 5 6 7 8 # search for v == 7</span>
<span># a     p       b</span>
<span>#         a p   b</span>
<span>proc </span><span>binarySearch</span><span>(</span><span>s</span><span>:</span> <span>openArray</span><span>[</span><span>int</span><span>]</span><span>;</span> <span>v</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>var</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>p</span><span>:</span> <span>int</span>
  <span>a</span> <span>=</span> <span>s</span><span>.</span><span>low</span>
  <span>b</span> <span>=</span> <span>s</span><span>.</span><span>high</span>
  <span>while</span> <span>a</span> <span>&lt;=</span> <span>b</span><span>:</span>
    <span>p</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span>
    <span>if</span> <span>v</span> <span>&gt;</span> <span>s</span><span>[</span><span>p</span><span>]</span><span>:</span> <span># continue search in the upper partition</span>
      <span>a</span> <span>=</span> <span>p</span> <span>+</span> <span>1</span>
    <span>elif</span> <span>v</span> <span>&lt;</span> <span>s</span><span>[</span><span>p</span><span>]</span><span>:</span> <span># continue search in the lower partition</span>
      <span>b</span> <span>=</span> <span>p</span> <span>-</span> <span>1</span>
    <span>else</span><span>:</span> <span># we have a match</span>
      <span>return</span> <span>p</span>
  <span>return</span> <span>-</span><span>1</span> <span># indicate no match</span>

<span>var</span> <span>d</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>]</span>

<span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>15</span><span>:</span>
  <span>let</span> <span>res</span> <span>=</span> <span>binarySearch</span><span>(</span><span>d</span><span>,</span> <span>i</span><span>)</span>
  <span>if</span> <span>res</span> <span>&gt;=</span> <span>0</span><span>:</span>
    <span>echo</span> <span>&#34;Found value &#34;</span><span>,</span> <span>i</span><span>,</span> <span>&#34; at position &#34;</span><span>,</span> <span>res</span></code></pre>
</div>
</div>
<p>To keep our example code as simple as possible, we do our search on an ordered array or seq of integers.
The value which we search for is passed as second integer argument to the <span>proc</span> called <span>binarySearch()</span>.
The first tree lines of the example program shows some example data consisting of the ordered numbers
<span>1 .. 8</span>. Here we use a consecutive sequence of numbers, but the actual numbers are fully arbitrary, as long as
the sequence is ordered by the value of the numbers in ascending order. Let <span>a</span> be the index of the lowest number in the seq, and
<span>b</span> be the index of the largest number. If the number we search for is contained in the seq, than that number must
be located at an index position greater or equal to <span>a</span> and an index position less or equal to index position <span>b</span>. For the index position <span>p</span> near the
center the obvious choice is <span>(a + b) mod 2</span>. For our example, we assume that we search for a value of <span>7</span>. The first
index position of <span>p</span> is <span>(0 + 7) div 2</span>, which is <span>3</span> containing value <span>4</span>, which is lower than the searched value <span>7</span>.
So we would have to continue our search in the upper half, setting the new lower bound of the range to
search to <span>p</span> or <span>p+1</span>. The upper boundary remains unchanged for this case, and we continue with a new value <span>p = (a + b) mod 2</span>.</p>
<p>The program code follows this strategy in a straight way.
We start with <span>a == s.low</span> and <span>b == s.high</span>, and the loop continues as long as
<span>a &lt;= b</span>. Note that we use as new boundaries not the value of <span>p</span>, but <span>p + 1</span> if we continue
with the upper half, and <span>p - 1</span> when we continue with the lower half of our data. We can do
that offset of one, as we have investigated position <span>p</span> already. This offset of one does not only speed up
things, as the new interval is smaller by one this way, but actually guarantees that the
interval size permanently shrinks and the algorithm terminates always. Without that offset, for the
case <span>b == (a+1)</span> we would get a value <span>p == (a + a + 1) mod 2</span>, which is again <span>a</span>, and we might set the new <span>a</span> then to <span>p</span>,
which is again the previous <span>a</span>. So the range would not always shrink, and our algorithm would not really terminate
for some data values. You may test that yourself when you remove the offset — the algorithm would not terminate
for some data. And finally you should try to make that <span>proc</span> generic, and then maybe search for a word
in an ordered list of words.</p>
<details>
<summary>Click to see a possible solution</summary>
<div>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>binarySearch</span><span>[</span><span>T</span><span>]</span><span>(</span><span>s</span><span>:</span> <span>openArray</span><span>[</span><span>T</span><span>]</span><span>;</span> <span>v</span><span>:</span> <span>T</span><span>):</span> <span>int</span> <span>=</span>
  <span>var</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>p</span><span>:</span> <span>int</span>
  <span>a</span> <span>=</span> <span>s</span><span>.</span><span>low</span>
  <span>b</span> <span>=</span> <span>s</span><span>.</span><span>high</span>
  <span>while</span> <span>a</span> <span>&lt;=</span> <span>b</span><span>:</span>
    <span>p</span> <span>=</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>div</span> <span>2</span>
    <span>if</span> <span>v</span> <span>&gt;</span> <span>s</span><span>[</span><span>p</span><span>]</span><span>:</span> <span># continue search in the upper partition</span>
      <span>a</span> <span>=</span> <span>p</span> <span>+</span> <span>1</span>
    <span>elif</span> <span>v</span> <span>&lt;</span> <span>s</span><span>[</span><span>p</span><span>]</span><span>:</span> <span># continue search in the lower partition</span>
      <span>b</span> <span>=</span> <span>p</span> <span>-</span> <span>1</span>
    <span>else</span><span>:</span> <span># we have a match</span>
      <span>return</span> <span>p</span>
  <span>return</span> <span>-</span><span>1</span> <span># indicate no match</span>

<span>var</span> <span>d</span> <span>=</span> <span>[</span><span>&#34;Algol&#34;</span><span>,</span> <span>&#34;Basic&#34;</span><span>,</span> <span>&#34;C&#34;</span><span>,</span> <span>&#34;D&#34;</span><span>,</span> <span>&#34;Elexir&#34;</span><span>,</span> <span>&#34;Erlang&#34;</span><span>,</span> <span>&#34;F#&#34;</span><span>,</span> <span>&#34;Haskell&#34;</span><span>]</span> <span># sorted!</span>

<span>for</span> <span>i</span> <span>in</span> <span>[</span><span>&#34;Oberon&#34;</span><span>,</span> <span>&#34;Nim&#34;</span><span>,</span> <span>&#34;Basic&#34;</span><span>,</span> <span>&#34;Ada&#34;</span><span>,</span> <span>&#34;Erlang&#34;</span><span>]</span><span>:</span>
  <span>let</span> <span>res</span> <span>=</span> <span>binarySearch</span><span>(</span><span>d</span><span>,</span> <span>i</span><span>)</span>
  <span>if</span> <span>res</span> <span>&gt;=</span> <span>0</span><span>:</span>
    <span>echo</span> <span>&#34;Found value &#34;</span><span>,</span> <span>i</span><span>,</span> <span>&#34; at position &#34;</span><span>,</span> <span>res</span></code></pre>
</div>
</div>
</div>
</details>
<p>References</p>

</div>
<div>
<h3 id="_integer_to_string_conversion">Integer to string conversion</h3>
<p>Have you ever asked yourself what actually is happening when we print the value of an integer
variable on the screen, maybe by use of the <span>echo()</span> procedure? Before <span>echo()</span> can print the value,
the integer has to be converted to a text string somehow. Some people may think that this conversion
is trivial. But as we know already that in our computer all the data is stored in abstract binary form,
we know better. But maybe there is some magic available to do this task? Well when we regard
the existence of C libs or the Nim standard library as that magic solution, then the answer is yes.
But in this section we will assume that we will not use a C library or a function of the Nim standard
library for the conversion of integers to strings, but do it our self. Indeed this conversion task is an interesting
exercise, from which we can learn a lot, much more than from using a gaming lib and moving some sprites over
the screen. Even when you already know how to do it, you may learn some new.
We will start with the question, how we can convert an int <span>i</span> with a numeric value <span>0 &lt;= i &lt;= 9</span> to a single character
digit matching this value, and then we will present a first
procedure to convert larger integers to strings. After that we will try to improve that first procedure, we will make it
generic and will investigate which problems may occur on restricted hardware like small microcontrollers and embedded systems.</p>
<p>As there is no magic available, let us recall how we can print the characters <span>0 .. 9</span>: Well,
first we have to remember that the 256 ASCII characters maps directly to the integers <span>0 .. 255</span>, e.g. the character <span>A</span> is mapped
to the integer value <span>65</span>. We can use the conversion functions <span>int()</span> or <span>ord()</span>, and <span>char()</span> to convert between the two data types,
where these conversion functions does no real work at all, the content of the variable is just interpreted as a different type.
That is, a plain cast would do the same for us:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>i</span><span>:</span> <span>int8</span> <span>=</span> <span>65</span>
<span>echo</span> <span>char</span><span>(</span><span>i</span><span>)</span>
<span>echo</span> <span>cast</span><span>[</span><span>char</span><span>]</span><span>(</span><span>i</span><span>)</span>
<span>var</span> <span>c</span><span>:</span> <span>char</span> <span>=</span> <span>&#39;A&#39;</span>
<span>echo</span> <span>ord</span><span>(</span><span>c</span><span>)</span>
<span>echo</span> <span>int8</span><span>(</span><span>c</span><span>)</span>
<span>echo</span> <span>cast</span><span>[</span><span>int8</span><span>]</span><span>(</span><span>c</span><span>)</span></code></pre>
</div>
</div>

<p>The same conversions work of course for all the 256 ASCII characters, which includes the decimal
digits <span>0 .. 9</span>. So one way to print the 10 digits is</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>startPos</span> <span>=</span> <span>int</span><span>(</span><span>&#39;0&#39;</span><span>)</span>
<span>var</span> <span>i</span><span>:</span> <span>int</span>
<span>while</span> <span>i</span> <span>&lt;</span> <span>10</span><span>:</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>char</span><span>(</span><span>startPos</span> <span>+</span> <span>i</span><span>))</span>
  <span>inc</span><span>(</span><span>i</span><span>)</span>
<span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span></code></pre>
</div>
</div>
<p>This works,because the 10 decimal digits follow each other in the ASCII table. As we can not
remember the position of the digit &#39;0&#39; in that table, we get the position by int(&#39;0&#39;).
Note that int(&#39;0&#39;) and ord(&#39;0&#39;) is basically the same here, we have no real preference and use both alternately.
The <span>ord()</span> function is generic, always returns an int and works for ordinal types, enums with holes and distinct ordinal types,
while the int() functions
have the advantage that we have them for different sizes like int8() and also for unsigned results.
We strongly hope that you know well the difference between the int value <span>0</span> and the
decimal character digit <span>&#39;0&#39;</span> — if not you may read again the section about characters in part II
of the book, see <a href="#_characters">Characters</a>.</p>
<p>With these introduction, you may already have an idea how we can get the decimal digit
for the lowest decimal place of an arbitrary integer value <span>v</span>: <span>char(v mod 10 + ord(&#39;0&#39;))</span>.
This works, because <span>v mod 10</span> is the numeric value of the lowest decimal place, that is a value
between <span>0</span> and <span>9</span>, and when we add <span>ord(&#39;0&#39;)</span> we get the corresponding position in the ASCII table.
Finally we use <span>char()</span> to convert that numeric value to a char data type, which is only a plain cast,
the compiler reinterprets the bit pattern as a character. So we are mostly done. To get the following digits,
we just divide the initial integer value by ten to move all one position to the right, and then we
continue with the initial step. We repeat that until the division by ten gives zero, then we are done.
That division by ten may be still confusing for you — we know that in decimal notation a division by ten
is a shift right, but why does that work for a number which is stored in binary form in the computer memory?
Indeed it is a bit confusing. The division by ten works, because it is a pure mathematical, abstract division operation,
fully independent from the actual representation of the number. Imagine you have a number in the range <span>10 .. 19</span>.
Now divide that number by ten. Independent how the number is stored, we will get a new number in the range
<span>0 .. 9</span>, and that value we can convert to a digit with the method shown above.</p>
<p>So following this strategy, we may get a first <span>intToStr()</span> procedure that may look like this one:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>intToStr</span><span>(</span><span>a</span><span>:</span> <span>int</span><span>):</span> <span>string</span> <span>=</span>
  <span>var</span> <span>v</span> <span>=</span> <span>a</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>result</span><span>.</span><span>add</span><span>(</span><span>char</span><span>(</span><span>v</span> <span>mod</span> <span>10</span> <span>+</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>)))</span>
    <span>v</span> <span>=</span> <span>v</span> <span>div</span> <span>10</span>
    <span>if</span> <span>v</span> <span>==</span> <span>0</span><span>:</span>
      <span>break</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>1234</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>12345678901234.</span><span>int</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>int</span><span>.</span><span>high</span><span>)</span></code></pre>
</div>
</div>
<p>As output we would get</p>
<div>
<div>
<pre>0
4321
43210987654321
7085774586302733229</pre>
</div>
</div>
<p>Not that bad, but unfortunately we get the digits in reversed order. And for
negative numbers it would not work yet. But that can be easily fixed.
What above code does should be obvious from the discussion before:
We copy the passed integer argument <span>a</span> into a local variable <span>v</span> of same data type, so that we can modify it,
and in the while loop body we extract the lowest digit and then divide the value by ten to shift it down to the right.
We have to use a <span>while true:</span>
loop with a break statement, because we need at least one loop execution to get at least
one digit, but Nim does not support repeat loops as known from languages like Pascal.
In the loop body we apply the discussed operation to get the digit of the lowest place, then
divide the actual value by ten and continue, as long that value is not already zero.
When it is zero we can leave the loop, as we do not intend to print leading zeros.</p>
<p>Creating a <span>proc</span> that prints the digits in the correct order and that can print the minus
sign for negative values is straight forward:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>intToStr</span><span>(</span><span>a</span><span>:</span> <span>int</span><span>):</span> <span>string</span> <span>=</span>
  <span>if</span> <span>a</span> <span>==</span> <span>int</span><span>.</span><span>low</span><span>:</span>
    <span>return</span> <span>&#34;-9223372036854775808&#34;</span>
  <span>var</span> <span>v</span> <span>=</span> <span>a</span><span>.</span><span>abs</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span>
  <span>var</span> <span>res</span><span>:</span> <span>array</span><span>[</span><span>20</span><span>,</span> <span>char</span><span>]</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>char</span><span>(</span><span>v</span> <span>mod</span> <span>10</span> <span>+</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>))</span>
    <span>v</span> <span>=</span> <span>v</span> <span>div</span> <span>10</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
    <span>if</span> <span>v</span> <span>==</span> <span>0</span><span>:</span>
      <span>break</span>
  <span>if</span> <span>a</span> <span>&lt;</span> <span>0</span><span>:</span>
    <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;-&#39;</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>result</span> <span>=</span> <span>newString</span><span>(</span><span>i</span><span>)</span>
  <span>let</span> <span>j</span> <span>=</span> <span>i</span> <span>-</span> <span>1</span>
  <span>while</span> <span>i</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>dec</span><span>(</span><span>i</span><span>)</span>
    <span>result</span><span>[</span><span>j</span> <span>-</span> <span>i</span><span>]</span> <span>=</span> <span>res</span><span>[</span><span>i</span><span>]</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>1234</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>int</span><span>.</span><span>high</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>-</span><span>0</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>-</span><span>1234</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>int</span><span>.</span><span>low</span> <span>+</span> <span>1</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>int</span><span>.</span><span>low</span><span>)</span></code></pre>
</div>
</div>
<p>We use an array of character for temporary storing the decimal places, and finally
copy the digits into the <span>result</span> string. We pre-allocate the string with the correct size, and
use the subscript operator <span>[]</span> instead of <span>add()</span> to insert the digits for performance reasons.
Initially we create a copy <span>v</span> with positive sign of the passed integer argument <span>a</span>, and when the
argument was initially negative, then we add an additional minus sign to the temporary array,
which is finally also copied to the result string. All this is not difficult, we have only to care that we get all
the indices right. A tiny problem is, that when the passed integer argument has the value <span>low(int)</span>, then applying
<span>abs()</span> would generate an overflow error, see section <a href="#_binary_numbers">Binary Numbers</a> in part II of the book if you forgot it. We fix for that
by returning just the correct string for that unique negative value for now.</p>
<p>The above <span>proc</span> looks not that bad, but maybe we can improve it, maybe we can avoid the
temporary array? The actual problem is, that we do not know how many total digits
the integer argument will need in advance, and so it is impossible to position
all the digits at the correct position in the result string. A possible solution is to use
a function that gives us the the number of decimal places of an integer number. Indeed we have such a function
available, it is <span>math.log10()</span>. Remember, log10(1) is zero, log10(10) is one, log10(100) is two and so on.
So basically what we need. The logarithm function is not that slow on modern desktop computers, so
it should be OK to use it. At the end of this section we will consider how we may replace it for tiny
microcontrollers which do not provide a FPU. The improved intToStr() <span>proc</span> may look like this one:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>math</span>

<span>proc </span><span>intToStr</span><span>(</span><span>a</span><span>:</span> <span>int</span><span>):</span> <span>string</span> <span>=</span>
  <span>if</span> <span>a</span> <span>==</span> <span>int</span><span>.</span><span>low</span><span>:</span>
    <span>return</span> <span>&#34;-9223372036854775808&#34;</span>
  <span>var</span> <span>v</span> <span>=</span> <span>a</span><span>.</span><span>abs</span>
  <span>var</span> <span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span>
  <span>if</span> <span>v</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>i</span> <span>=</span> <span>math</span><span>.</span><span>log10</span><span>(</span><span>v</span><span>.</span><span>float</span><span>).</span><span>int</span>
  <span>if</span> <span>a</span> <span>&lt;</span> <span>0</span><span>:</span>
    <span>j</span> <span>=</span> <span>1</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>result</span> <span>=</span> <span>newString</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>)</span>
  <span>result</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;-&#39;</span>
  <span>while</span> <span>i</span> <span>&gt;=</span> <span>j</span><span>:</span>
    <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>char</span><span>(</span><span>v</span> <span>mod</span> <span>10</span> <span>+</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>))</span>
    <span>v</span> <span>=</span> <span>v</span> <span>div</span> <span>10</span>
    <span>dec</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>This <span>proc</span> is very similar to the one before. We call <span>log10()</span> to get a measure for
the number of needed digits. Remember that the logarithm is undefined for the
argument value zero, for that value we use the default value <span>i == 0</span>. Actually
in all cases <span>i + 1</span> is the total number of digits that we have to generate — for the case that we
have to generate a minus sign we increase <span>i</span> by one. We pre-allocate a <span>result</span> string
with <span>i + 1</span> positions, and put a minus sign at position zero, which is overwritten in the while
loop when the argument was not negative. As we know the the total number of digits of our number
we can use the variable <span>i</span> to put the digits at the correct positions in the while loop.
The careful reader may wonder if <span>log10(v.float).int</span> will really work for sure
for all integer arguments of <span>v</span>, or if we better should round the argument like
<span>log10(v.float + 0.5).int</span>. Indeed, with that rounding we should be save.</p>
<p>The next task is to avoid the initial test for <span>int.low</span>. We really should remove that special
case when we prepare to make the <span>proc</span> generic later. A possible solution is, that we work
with <span>uint64</span> instead with <span>int</span> in the <span>proc</span> body, as in</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>math</span>

<span>proc </span><span>intToStr</span><span>(</span><span>a</span><span>:</span> <span>int</span><span>):</span> <span>string</span> <span>=</span>
  <span>var</span> <span>v</span><span>:</span> <span>uint64</span>
  <span>if</span> <span>a</span> <span>==</span> <span>int</span><span>.</span><span>low</span><span>:</span>
    <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>-</span><span>(</span><span>a</span> <span>+</span> <span>1</span><span>))</span> <span>+</span> <span>1</span>
  <span>elif</span> <span>a</span> <span>&lt;</span> <span>0</span><span>:</span>
    <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>-</span><span>a</span><span>)</span>
  <span>else</span><span>:</span>
    <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>a</span><span>)</span>
  <span>var</span> <span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span>
  <span>if</span> <span>v</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>i</span> <span>=</span> <span>math</span><span>.</span><span>log10</span><span>(</span><span>v</span><span>.</span><span>float</span> <span>+</span> <span>0.5</span><span>).</span><span>int</span>
  <span>if</span> <span>a</span> <span>&lt;</span> <span>0</span><span>:</span>
    <span>j</span> <span>=</span> <span>1</span>
    <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>result</span> <span>=</span> <span>newString</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>)</span>
  <span>result</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;-&#39;</span>
  <span>while</span> <span>i</span> <span>&gt;=</span> <span>j</span><span>:</span>
    <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>char</span><span>(</span><span>v</span> <span>mod</span> <span>10</span> <span>+</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>))</span>
    <span>v</span> <span>=</span> <span>v</span> <span>div</span> <span>10</span>
    <span>dec</span><span>(</span><span>i</span><span>)</span></code></pre>
</div>
</div>
<p>When we add 1 to int.low, then we can invert the sign, and convert the value to <span>unit64</span>.
To the <span>uint64</span> value we have to add again <span>1</span> to get the initial sequence of digits.
And now we can make the <span>proc</span> generic:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>math</span>

<span>proc </span><span>intToStr</span><span>(</span><span>a</span><span>:</span> <span>SomeInteger</span><span>):</span> <span>string</span> <span>=</span>
  <span>var</span> <span>v</span><span>:</span> <span>uint64</span>
  <span>when</span> <span>a</span> <span>is</span> <span>SomeSignedInt</span><span>:</span>
    <span>if</span> <span>int</span><span>(</span><span>a</span><span>)</span> <span>==</span> <span>int</span><span>.</span><span>low</span><span>:</span>
      <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>-</span><span>(</span><span>a</span> <span>+</span> <span>1</span><span>))</span> <span>+</span> <span>1</span>
    <span>elif</span> <span>a</span> <span>&lt;</span> <span>0</span><span>:</span>
      <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>-</span><span>a</span><span>)</span>
    <span>else</span><span>:</span>
      <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>a</span><span>)</span>
  <span>else</span><span>:</span>
      <span>v</span> <span>=</span> <span>uint64</span><span>(</span><span>a</span><span>)</span>
  <span>var</span> <span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span>
  <span>if</span> <span>v</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>i</span> <span>=</span> <span>math</span><span>.</span><span>log10</span><span>(</span><span>v</span><span>.</span><span>float</span> <span>+</span> <span>0.5</span><span>).</span><span>int</span>
  <span>when</span> <span>a</span> <span>is</span> <span>SomeSignedInt</span><span>:</span>
    <span>if</span> <span>a</span> <span>&lt;</span> <span>0</span><span>:</span>
      <span>j</span> <span>=</span> <span>1</span>
      <span>inc</span><span>(</span><span>i</span><span>)</span>
  <span>result</span> <span>=</span> <span>newString</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>)</span>
  <span>result</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;-&#39;</span>
  <span>while</span> <span>i</span> <span>&gt;=</span> <span>j</span><span>:</span>
    <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>char</span><span>(</span><span>v</span> <span>mod</span> <span>10</span> <span>+</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>))</span>
    <span>v</span> <span>=</span> <span>v</span> <span>div</span> <span>10</span>
    <span>dec</span><span>(</span><span>i</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>1234</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>int</span><span>.</span><span>high</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>-</span><span>0</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>-</span><span>1234</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>int</span><span>.</span><span>low</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0.</span><span>uint8</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>123.</span><span>uint8</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>uint8</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0.</span><span>uint64</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>123.</span><span>uint64</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>uint64</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0.</span><span>uint</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>123.</span><span>uint</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>uint</span><span>.</span><span>high</span><span>)</span></code></pre>
</div>
</div>
<p>We use as parameter type <span>SomeInteger</span>, which allows signed and unsigned ints
of all byte sizes, and in the <span>proc</span> we test with <span>is SomeSignedInt:</span> if
we have to care for the sign and in case of value <span>int.low</span> for overflow.
The advantage of this <span>proc</span> is, that it works for all integer types, signed and unsigned.
But one disadvantage is, that always the data type <span>uint64</span> is used, which may be not available
on microcontroller CPUs. Let us see how a <span>proc</span> for only unsigned types may look:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>math</span>

<span>proc </span><span>intToStr</span><span>(</span><span>a</span><span>:</span> <span>SomeUnsignedInt</span><span>):</span> <span>string</span> <span>=</span>
  <span>var</span> <span>i</span><span>:</span> <span>int</span>
  <span>var</span> <span>v</span> <span>=</span> <span>a</span>
  <span>if</span> <span>v</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>i</span> <span>=</span> <span>math</span><span>.</span><span>log10</span><span>(</span><span>v</span><span>.</span><span>float</span> <span>+</span> <span>0.5</span><span>).</span><span>int</span>
  <span>result</span> <span>=</span> <span>newString</span><span>(</span><span>i</span> <span>+</span> <span>1</span><span>)</span>
  <span>while</span> <span>i</span> <span>&gt;=</span> <span>0</span><span>:</span>
    <span>result</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>char</span><span>(</span><span>v</span> <span>mod</span> <span>10</span> <span>+</span> <span>ord</span><span>(</span><span>&#39;0&#39;</span><span>))</span>
    <span>v</span> <span>=</span> <span>v</span> <span>div</span> <span>10</span>
    <span>dec</span><span>(</span><span>i</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0.</span><span>uint8</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>123.</span><span>uint8</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>uint8</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0.</span><span>uint64</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>123.</span><span>uint64</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>uint64</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>intToStr</span><span>(</span><span>0.</span><span>uint</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>123.</span><span>uint</span><span>)</span>
<span>echo</span> <span>intToStr</span><span>(</span><span>uint</span><span>.</span><span>high</span><span>)</span></code></pre>
</div>
</div>
<p>That one is really simple and short, so maybe it would indeed make sense to
use this one for the unsigned types. And we do not need the <span>unit64</span> type, so on a system
with no native 8 byte integers that <span>proc</span> should work fine.</p>

<p>All the previous examples have used <span>log10()</span> to determine the number of digits
for the passed argument value. On microcontrollers <span>log10()</span> may be not available at all, or may be
very slow. So let us investigate at the end of this section how we can replace it.
The basic idea is, that we repeatedly divide the argument by ten, until we get the result
zero, counting the number of needed divisions. An equally approach is to start with a variable
with start value one and multiply with ten, until the result is larger than our function argument.
As division is generally slower than multiplication, and on microcontrollers a native <span>div</span> operation may be
not available at all, we will try to use multiply operations.
So we may start with a <span>proc</span> like</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>digits0</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>assert</span> <span>i</span> <span>&gt;=</span> <span>0</span>
  <span>result</span> <span>=</span> <span>1</span>
  <span>var</span> <span>d</span> <span>=</span> <span>10</span>
  <span>while</span> <span>d</span> <span>&lt;=</span> <span>i</span><span>:</span>
    <span>d</span> <span>*=</span> <span>10</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span></code></pre>
</div>
</div>
<p>Can you see the problem? What will happen when we pass <span>int.high</span> as argument?</p>
<p>So a working <span>proc</span> is this:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>digits</span><span>(</span><span>a</span><span>:</span> <span>SomeInteger</span><span>):</span> <span>int</span> <span>=</span>
  <span>assert</span> <span>a</span> <span>&gt;=</span> <span>0</span>
  <span>var</span> <span>i</span><span>:</span> <span>uint64</span> <span>=</span> <span>a</span><span>.</span><span>uint64</span>
  <span>result</span> <span>=</span> <span>1</span>
  <span>when</span> <span>sizeof</span><span>(</span><span>a</span><span>)</span> <span>==</span> <span>8</span><span>:</span>
    <span>const</span> <span>c</span> <span>=</span> <span>10</span>
    <span>if</span> <span>i</span> <span>&gt;=</span> <span>c</span><span>:</span>
      <span>i</span> <span>=</span> <span>i</span> <span>div</span> <span>c</span>
      <span>result</span> <span>=</span> <span>2</span>
  <span>var</span> <span>d</span><span>:</span> <span>typeof</span><span>(</span><span>i</span><span>)</span> <span>=</span> <span>10</span>
  <span>while</span> <span>d</span> <span>&lt;=</span> <span>i</span><span>:</span>
    <span>d</span> <span>*=</span> <span>10</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span></code></pre>
</div>
</div>
<p>We do the math with an <span>uint64</span> type in the <span>proc</span>. For the case
that the argument is an 8 byte type, we may get an overflow in the
while loop, which we prevent by doing one division before the loop already. Actually
for improved performance instead of a division by ten we may do a division
by a larger power of ten, and fix the start value for <span>result</span> accordingly.
One disadvantage of that generic <span>proc</span> is again, that an <span>uint64</span> type is
used for the math, which is fine on a desktop PC, but may work bad on
restricted hardware. So this variant seems to be a better solution:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>digits</span><span>(</span><span>a</span><span>:</span> <span>SomeInteger</span><span>):</span> <span>int8</span> <span>=</span>
  <span>assert</span> <span>a</span> <span>&gt;=</span> <span>0</span>
  <span>var</span> <span>i</span> <span>=</span> <span>a</span>
  <span>result</span> <span>=</span> <span>1</span>
  <span>if</span> <span>i</span> <span>&gt;=</span> <span>10</span><span>:</span>
    <span>i</span> <span>=</span> <span>i</span> <span>div</span> <span>10</span>
    <span>result</span> <span>=</span> <span>2</span>
  <span>var</span> <span>d</span><span>:</span> <span>typeof</span><span>(</span><span>i</span><span>)</span> <span>=</span> <span>10</span>
  <span>while</span> <span>d</span> <span>&lt;=</span> <span>i</span><span>:</span>
    <span>d</span> <span>*=</span> <span>10</span>
    <span>inc</span><span>(</span><span>result</span><span>)</span>

<span>echo</span> <span>digits</span><span>(</span><span>0</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>9</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>10</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>99</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>int</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>digits</span><span>(</span><span>0.</span><span>int8</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>int8</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>digits</span><span>(</span><span>0.</span><span>uint8</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>uint8</span><span>.</span><span>high</span><span>)</span>

<span>echo</span> <span>digits</span><span>(</span><span>0.</span><span>uint</span><span>)</span>
<span>echo</span> <span>digits</span><span>(</span><span>uint</span><span>.</span><span>high</span><span>)</span></code></pre>
</div>
</div>
<p>Here we do a single <span>div</span> operation if the argument is larger than <span>9</span>, but
do all the math with the same type as the argument type.
The <span>div</span> operation may be still slow on a microcontroller, but our <span>intToStr()</span>
proc has also used <span>div</span> operations. Indeed doing <span>intToStr()</span>
conversions on a tiny 8 bit microcontroller is not really a good idea.</p>
<p>For determining the number of digits of integer numbers, you will
find many more solution in the internet. Sometimes this is
called <span>log10()</span> for integer numbers. Some functions try to use
the logarithm with base 2, which is related to finding the highest set bit of
a number, some other functions use tabular data or a sequence of <span>if</span> or <span>case</span>
statements. As the performance of that functions depends on the actual hardware,
there exists not really the best solution for all cases.</p>
<p>For the <span>intToStr()</span> function you should also find very good solutions in Nim’s standard library.
Note that it was not our goal in this section to present a really good solution, the idea was more
to show you how such a tasks can be solved in principle, and how we can improve
or modify solutions, and how we can use Nim’s generics to get one function for multiple
data types. Note that the presented <span>procs</span> are only minimal tested, and are tested only on a
64 bit desktop OS. So they may not work on systems where Nim’s int type is 32 bit, or for
microcontrollers and embedded systems. But you have learned enough now so you could fix it for that cases.</p>
<p>As possible exercises for the reader we may suggest to create a similar <span>proc</span> called <span>strToInt()</span>
that converts a numeric string to an integer number, or to convert between <span>strings</span> and <span>float</span> numbers.
The first one is easy, you would build the <span>int</span> value by continuously multiplying the digit value
with its correct power of ten matching its position in the string. The float conversion
is more difficult, in one weekend you may get some working code, but perfect solutions
like the <span>ryu</span> or <span>dragonbox</span> algorithm are very complicated.</p>
</div>
<div>
<h3 id="_no_game_programming">No Game Programming?</h3>
<p>No, not yet. We know that for many people game programming
is the initial motivation to start with computer programming at all,
and so a larger section about this topic would make indeed some sense.
But there are some reasons why we do not have this section currently.
Most important reason is, that we try to present in this book that stuff,
that is very fundamental and that is not presented at other freely accessible
places in a beginner friendly fashion. And there is a lot of this which seems to
be more important than games. The other reason is, that for a section about
games we would have to make a lot of decisions in advance: 2D or 3D game,
action game or strategy game. Using a game engine, or only a simple
libraray like cairo, sdl2, raylib or gogot? When using a game engine, then the decision
which one we should use, and which Nim bindings set is not a simple decision, and
we should try to ensure that the bindings are actively developed and so should
work in a few years with Nim 2.0 still. And finally there are already some nice tutorials
for game programming available, see for example</p>

<p>Actually game programming is not that difficult, when we have a nice library with a good tutorial
available. Game programming can be much fun, which is great, but actually we do not learn that
much when we move some sprites over the screen. On the other hand, advanced game programming,
by using a big library like Godot, doing all with basic libs like SDL2 or Raylib, or developing your
own game engine based on OpenGL or Vulkan, is a very demanding task.</p>
<p>So maybe we will add a section about game programming at the end, when the rest of the book
is done, or maybe when the next edition of the book is published.</p>
</div>
</div>
</div>

<div>
<div>
<p>In this part of the book we will present you some external packages, which
can easily be installed with Nim’s package manager(s).</p>
<p>For packages registered in the <span>Nimble</span> data base, executing the <span>nimble install</span> command</p>
<div>
<div>
<pre>nimble install packageName</pre>
</div>
</div>
<p>is sufficient, and you can also install unregistered packages, which may be hosted at <span>github.com</span>
or another platform with a command like</p>
<div>
<div>
<pre>nimble install https://github.com/user/packageName</pre>
</div>
</div>
<p>Note that we call <span>nimble</span> commands like <span>install</span> generally as ordinary user, not as <span>admin</span> or <span>root</span> with
administrator privileges.
We told you already in the introduction to this book, that we do not intend to discuss the detailed
use of <span>nimble</span> in this book, at least not for the first edition. The <span>Nimble</span> package manager
is described in detail in <a href="https://github.com/nim-lang/nimble">https://github.com/nim-lang/nimble</a> and also in the Manning book.
There you can also learn how you can create <span>Nimble</span> packages yourself, and how you can register
your own packages in <span>Nimble’s</span> database so that other people can find them more easy. While <span>Nimble</span> is
<span>Nim’s</span> default package manager which is currently used by the majority of the user base, there exist
also the alternative implementation <a href="https://github.com/disruptek/nimph">https://github.com/disruptek/nimph</a>, and some lesser known
ones like <span>Nimp</span>, <span>Slim</span> or <span>Nifty</span>.</p>
<p>We have already a few thousand external packages for <span>Nim</span> — you may use commands
like <span>nimble list</span> or <span>nimble search</span> to list all registered packages,
or to search in the database for entries, or you can use <a href="https://nimble.directory/">https://nimble.directory/</a> or the <span>Github</span> online search to
find more packages. You can also consult the list of curated <span>Nim</span> packages at  <a href="https://github.com/xflywind/awesome-nim">https://github.com/xflywind/awesome-nim</a>.</p>
<p>While the use of external packages is really easy, there are some important points to consider:
External packages are not audited by the <span>Nim</span> core team, so the quality of external packages can vary, and
in principle external packages can even contain malicious code which may damage your
computer when you install and use that package. Well, as we use the <span>nim</span> and <span>nimble</span> commands as plain user without
administrator privileges, there is no real danger that the computer OS can be damaged — only
our own user data may get corrupted or damaged. But as we backup all of our important data regularly,
there is not that much danger, a SSD hardware crash seems to be more likely.
A more serious issue with external
packages arise from the fact that the packages may get outdated and abandoned and may stop working
with recent versions of the <span>Nim</span> compiler, or even may get totally removed from the internet
without prior announcements. So when you should create a larger software project that depends on
external packages, then you should save a local copy of that package, or you may even consider to
make a private fork of that <span>Github</span> package.</p>
<p>Some programming languages like Python are shipped already with a very large collection of
libraries, so that external packages are not that often required at all. Other languages
like C++ come basically without any packages or a language specific package manager,
so we would use the package manager provided by the operating system to install important
C++ packages like <span>Boost</span> or <span>CGAL</span>, or install needed libraries manually.
<span>Nim</span> is between these two extremes — it provides already a large collection
of modules with its standard library, but has also a lot of external packages.
Both, internal core modules, and external packages have its merits.
We mentioned already some disadvantages of external packages, but actually
they have also benefits: They may be developed, updated and improved very fast, as
they are not strongly coupled to compiler release updates, and one external package
can easily be replaced by another similar one. A large set of internal packages can
on the other hand be a large maintainment burden for the language core team — the
packages have to be tested and maybe fixed for each new compiler version, and
replacing or removing legacy internal core packages can lead to a lot of problems.</p>
<p>In this part of the book we will present a very small set of external packages only.
This is mostly done to tell you about the existence and usefulness, and for some package
because the currently available documentation is not really beginner friendly.</p>
<p>We will start with a powerful package for the use of the <span>Parsing Expression Grammar</span> (PEG),
which is some form of an alternative to the use of <span>regular expressions</span> for parsing tasks.</p>
</div>
</div>
<div>
<h2 id="_parsing_expression_grammars">Parsing Expression Grammars</h2>
<div>
<p>Parsing whole text files or single strings is a common programming task, e.g. to process textual user input
or to extract data from HTML or CSV files. Traditional this is often done by the use of <span>regular expresions</span> — in part III of the book we show how it can be done by use of the <span>regex</span> module.</p>
<p><span>PEGs</span>, or <span>Parsing Expression Grammars</span>, are another formalism for recognizing patterns in text by use of a set of rules.
A PEG can be used as an alternative to <span>regular expressions</span> for parsing, pattern matching and text processing.
The  <span>Parsing Expression Grammar</span> was introduced by Bryan Ford in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s.
PEGs are a derivative of the <span>Extended Backus-Naur Form</span> (EBNF) with a different interpretation, designed to represent a recursive descent parser.</p>
<p>PEGs are not unlike regular expressions, but offer more power and flexibility, and have less ambiguities.
For example, a regular expression inherently cannot find an arbitrary number of matched pairs of parentheses, because it is not recursive, but a PEG can.</p>
<p>As PEGs can be constructed in a hierarchical way from individual
rules, it can be easier to create or understand them compared to regular expressions.</p>
<p>While the use of regular expressions is very similar in different programming languages or
external tools like <span>sed</span> and <span>grep</span>, the API for PEG libraries can be very different, and even the actual
syntax for building parsing rules can differ.</p>
<p>Nim’s standard library includes already a simple <span>pegs</span> module, but we will use the more advanced external <span>NPeg</span> package
of Ico Doornekamp instead.
<span>NPeg</span> is a pure <span>Nim</span> library, that provides macros to compile PEGs to Nim procedures which can parse strings and collect selected parts of the input.</p>
<p>In this section we will try to explain the basic concepts of the PEG use and give some examples.
For a more formal and complete description, you should refer to the linked Wikipedia article
and consult the API documentation of the <span>npeg</span> module.</p>
<p>Formally, a <span>parsing expression grammar</span> consists of a starting expression, a set of parsing rules, and finite sets of terminal and nonterminal symbols.</p>
<p>Each parsing rule has the form <span>A ← e</span>, where <span>A</span> is a nonterminal symbol and <span>e</span> is a parsing expression.
An (atomic) parsing expression consists of terminal or nonterminal symbols or an empty string.
New parsing expression can be constructed from existing ones by concatenation (sequence), an ordered choice,
by repetitions (zero-or more, one-or-more, optional) of an existing expression, and by
use of the <span>and</span> and <span>not</span> predicate.
The <span>and-predicate</span> expression <span>&amp;e</span> invokes the sub-expression <span>e</span>, and then succeeds if <span>e</span> succeeds and fails
if <span>e</span> fails, but in either case never consumes any input.
The <span>not-predicate</span> expression <span>!e</span> succeeds if <span>e</span> fails and fails if <span>e</span> succeeds, again consuming no input in either case.
Because these two predicates can use an arbitrarily complex sub-expression to <span>&#34;look ahead&#34;</span> into the input string without actually consuming it, they provide a powerful syntactic look-ahead and disambiguation facility, in particular when reordering the alternatives cannot specify the exact parse tree desired.</p>
<p><span>NPeg</span> is a pure <span>Nim</span> pattern matching library. It provides macros to compile patterns and grammars (PEGs)
to Nim procedures which will parse a string and collect selected parts of the input.
In this way <span>npeg</span> is an alternative to the use of the <span>regex</span> module, but <span>npeg</span> does not support
the optional replacement of matched patterns.</p>
<p>As understanding and using the PEG is really not that easy, and as most readers may never have heard about PEG
at all, we will start with a few very simple examples. First let us parse just a few decimal digits:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>npeg</span>

<span>let</span> <span>p</span> <span>=</span> <span>peg</span><span>(</span><span>&#34;str&#34;</span><span>):</span>
  <span>str</span> <span>&lt;-</span> <span>+</span><span>{</span><span>&#39;0&#39;</span><span>..</span><span>&#39;9&#39;</span><span>}</span>

<span>echo</span> <span>p</span><span>.</span><span>match</span><span>(</span><span>&#34;123&#34;</span><span>).</span><span>ok</span></code></pre>
</div>
</div>
<p>The <span>npeg</span> module defines a few macros for processing PEG patterns. One of them is
the <span>peg()</span> macro, to which we pass as argument a starting expression
in form of a string, and which creates and return a <span>Parser</span> object.
In the body of the <span>peg()</span> macro we have to define all the grammar rules that our PEG
is built of. For our example we only need one simple rule that is a repetition of the
decimal digits zero to nine.</p>
<p>The <span>npeg</span> module uses as terminal symbols single characters enclosed in single quotes
or strings enclosed in double quotes.</p>
<p>In the original PEG syntax a pair of square brackets is used to specify character ranges
like [&#39;a&#39;..&#39;z&#39;] for the lower case letters of the alphabet, but the <span>npeg</span> module uses
curly braces instead.</p>
<p>So in the <span>npeg</span> syntax <span>{&#39;0&#39;..&#39;9&#39;}</span> stands for a single decimal digit, and the leading <span>*</span> indicates
one or more repetitions. In the original PEG syntax we would use square brackets instead and
put the <span>*</span> after the closing square bracket, that is <span>[&#39;0&#39;..&#39;9&#39;]*</span>.
We can also list the characters of a character class separated by commas, e.g. {&#39;a&#39;, &#39;z&#39;} for &#39;a&#39; or &#39;z&#39;.
The symbol <span>←</span> assigns the parsing rule to the nonterminal symbol <span>str</span>, which is already
identical with the starting expression.</p>
<p>The <span>peg()</span> macro returns a <span>Parser</span> object, which we can pass together with a
string
that should be parsed to the <span>match()</span> function. The function <span>match()</span> returns an instance of a <span>MatchObject</span> — we use the <span>ok</span> field of this object to check if the match was successful.</p>

<p>As next example we will create a PEG pattern that can match a simple mathematical term
built from decimal digits and the two operators <span>+</span> and <span>-</span> for addition and subtraction:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>npeg</span>

<span>let</span> <span>p2</span> <span>=</span> <span>peg</span><span>(</span><span>&#34;term&#34;</span><span>):</span>
  <span>term</span> <span>&lt;-</span> <span>dig</span> <span>*</span> <span>*</span><span>(</span><span>op</span> <span>*</span> <span>dig</span><span>)</span>
  <span>dig</span> <span>&lt;-</span> <span>+</span><span>{</span><span>&#39;0&#39;</span><span>..</span><span>&#39;9&#39;</span><span>}</span>
  <span>op</span> <span>&lt;-</span> <span>{</span><span>&#39;+&#39;</span><span>,</span> <span>&#39;-&#39;</span><span>}</span>

<span>echo</span> <span>p2</span><span>.</span><span>match</span><span>(</span><span>&#34;1+23&#34;</span><span>).</span><span>ok</span></code></pre>
</div>
</div>
<p>We said that the symbol <span>*</span> is used to indicate zero or more repetitions of an expression.
But for the <span>npeg</span> module this <span>*</span> is used at the same time to construct sequences of expressions,
that is to concatenate expressions. In the code above we pass the string &#34;term&#34; as starting expression to the <span>peg()</span> macro.
In the macro body we define three rules, which each assign an expression to the nonterminal symbols
<span>term</span>, <span>dig</span> and <span>op</span>. In the expression <span>dig * *(op * dig)</span> the second <span>*</span>
in front of the opening brace indicates an arbitrary number of repetitions of the expression
enclosed by the round brackets, while the first and third <span>*</span> indicate the sequence or concatenation
operation. The following two rules just define a sequence of one or more decimal digits, and
the operator for addition or subtraction.</p>
<div>
<h3 id="_capturing_data">Capturing data</h3>
<p>The <span>npeg</span> module offers plain string captures and more flexible code block captures.</p>
<div>
<h4 id="_string_captures">String Captures</h4>
<p>Let us assume that we want to split a line of text into words:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>npeg</span>

<span>let</span> <span>p</span> <span>=</span> <span>peg</span><span>(</span><span>&#34;line&#34;</span><span>):</span>
  <span>line</span> <span>&lt;-</span> <span>+</span><span>(</span><span>space</span> <span>*</span> <span>&gt;</span><span>word</span><span>)</span>
  <span>word</span> <span>&lt;-</span> <span>+</span><span>{</span><span>&#39;a&#39;</span><span>..</span><span>&#39;z&#39;</span><span>}</span>
  <span>space</span> <span>&lt;-</span> <span>*</span><span>&#39; &#39;</span>

<span>let</span> <span>m</span> <span>=</span> <span>p</span><span>.</span><span>match</span><span>(</span><span>&#34; one   two three    &#34;</span><span>)</span>
<span>if</span> <span>m</span><span>.</span><span>ok</span><span>:</span>
  <span>echo</span> <span>m</span><span>.</span><span>matchLen</span>
  <span>echo</span> <span>m</span><span>.</span><span>captures</span></code></pre>
</div>
</div>
<div>
<div>
<pre>16
@[&#34;one&#34;, &#34;two&#34;, &#34;three&#34;]</pre>
</div>
</div>
<p>The <span>MatchResult</span> returned by the <span>peg()</span> macro has the exported fields <span>matchLen</span> and <span>captures</span>,
which we can read out in case of a successful match. <span>MatchLen</span> tells us how many characters
of the string has been captured, and <span>captures</span> is a <span>seq[string]</span> containing the captured strings.</p>
</div>
<div>
<h4 id="_code_block_captures">Code Block Captures</h4>
<p>Code block captures offer the most flexibility for accessing matched data in NPeg. This allows you to define a grammar with embedded Nim code for handling the data during parsing.</p>
<p>When a grammar rule ends with a colon <span>:</span>, the next indented block in the grammar is interpreted as Nim code, which gets executed when the rule has been matched. Any string captures that were made inside the rule are available to the Nim code in the injected variable <span>capture[]</span> of type <span>seq[Capture]</span>.
<span>Capture</span> is an object with field <span>s</span> containing the captured string and field <span>si</span> containing the index position of the capture inside the
original string.</p>
<p>The total sub-string matched by the code block rule is available as <span>capture[0]</span>, and the individual
captured strings are available with indices &gt; <span>0</span>. In the indented code block, we can also use <span>$n</span> instead of
<span>capture[n].s</span> and <span>@n</span> instead of <span>capture[n].si</span>.</p>
<p>We could use the seq of captures to print the captured strings or to copy it into some global variable.
To avoid the need of global variables, we can pass to the <span>peg()</span> macro a second argument, which
is a name and a data type separated by a colon, like <span>peg(name, identifier: Type)</span>.
The second parameter is then available as an ordinary variable in the code block.</p>
<p>For our next example we will assume that we have written a plain CAD tool, that allows the user
to enter textual commands like <span>moveTo(x, y)</span>.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>npeg</span><span>,</span> <span>tables</span>

<span>type</span> <span>T</span> <span>=</span> <span>Table</span><span>[</span><span>string</span><span>,</span> <span>string</span><span>]</span>

<span>let</span> <span>p</span> <span>=</span> <span>peg</span><span>(</span><span>&#34;command&#34;</span><span>,</span> <span>t</span><span>:</span> <span>T</span><span>):</span>
  <span>command</span> <span>&lt;-</span> <span>&gt;</span><span>com</span> <span>*</span> <span>&#39;(&#39;</span> <span>*</span> <span>&gt;</span><span>pos</span> <span>*</span> <span>&#39;,&#39;</span> <span>*</span> <span>&gt;</span><span>pos</span> <span>*</span> <span>&#39;)&#39;</span><span>:</span>
    <span># echo $1, $2, $3</span>
    <span>t</span><span>[</span><span>&#34;action&#34;</span><span>]</span> <span>=</span> <span>$</span><span>1</span>
    <span>t</span><span>[</span><span>&#34;x&#34;</span><span>]</span> <span>=</span> <span>$</span><span>2</span>
    <span>t</span><span>[</span><span>&#34;y&#34;</span><span>]</span> <span>=</span> <span>$</span><span>3</span>
  <span>com</span> <span>&lt;-</span> <span>&#34;moveTo&#34;</span> <span>|</span> <span>&#34;lineTo&#34;</span>
  <span>pos</span> <span>&lt;-</span> <span>+</span><span>{</span><span>&#39;0&#39;</span><span>..</span><span>&#39;9&#39;</span><span>}</span>


<span>var</span> <span>input</span><span>:</span> <span>T</span>
<span>if</span> <span>p</span><span>.</span><span>match</span><span>(</span><span>&#34;moveTo(12,20)&#34;</span><span>,</span> <span>input</span><span>).</span><span>ok</span><span>:</span>
  <span>echo</span> <span>input</span><span>[</span><span>&#34;action&#34;</span><span>]</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>input</span><span>[</span><span>&#34;x&#34;</span><span>]</span><span>,</span> <span>&#34;, &#34;</span><span>,</span> <span>input</span><span>[</span><span>&#34;y&#34;</span><span>]</span></code></pre>
</div>
</div>
<p>To keep the example simple and short, we assume that we have to process only
two different command, <span>moveTo()</span> and <span>lineTo()</span>, each accepting <span>x</span>, <span>y</span> coordinates of integer
form. We pass to the <span>peg()</span> macro a second argument, which is the name and the data type
of a <span>Table</span> instance. We have chosen for the key and value type of that table the <span>string</span> data type,
as we want to store the command name as well as the <span>x/y</span> coordinates, so an integer value
type would not work. The macro body defines three rules — <span>command</span>, <span>com</span> and <span>pos</span>.
For the <span>command</span> rule we use an expression which starts with the command name, followed
in round brackets, the <span>x/y</span> coordinate pair. In front of the nonterminal symbols <span>com</span> and <span>pos</span>
we put the <span>&gt;</span> operator to capture these values. We put a colon after the command rule and
can access the captured values in the indented block, by use of the <span>$N</span> symbol.
For the <span>com</span> rule we specify the literal terminal symbols <span>&#34;moveTo&#34;</span> or <span>&#34;lineTo&#34;</span> as
ordered choice with the <span>|</span> operator. Finally, the expression for the <span>pos</span> rule is just a
sequence of one or more decimal digits.</p>
</div>
<div>
<h4 id="_simple_patterns">Simple patterns</h4>
<p>For simple patterns it may be not necessary to define multiple parsing rules. In that case
we can use the <span>patt()</span> macro instead of <span>peg()</span> and pass just a single one line pattern as argument.</p>
<p>For example, the pattern below splits a string by white space:</p>
<div>
<div>
<pre><code data-lang="nim"><span>let</span> <span>parser</span> <span>=</span> <span>patt</span> <span>*</span><span>(</span><span>*</span><span>&#39; &#39;</span> <span>*</span> <span>&gt;</span> <span>+</span><span>(</span><span>1</span><span>-</span><span>&#39; &#39;</span><span>))</span>
<span>echo</span> <span>parser</span><span>.</span><span>match</span><span>(</span><span>&#34;   one two three &#34;</span><span>).</span><span>captures</span></code></pre>
</div>
</div>
<p>We took this example from the <span>npeg</span> API documentation verbatim. Here the <span>patt()</span> macro uses
Nim’s command invocation syntax, so there is no outer bracket after the macro name.
The innermost bracket uses the notation (1-&#39; &#39;) to match everything but a space, and
the content of the outer bracket starts with an arbitrary number of uncaptured spaces.</p>
</div>
<div>
<h4 id="_look_ahead_operators">&#34;Look ahead&#34; operators</h4>
<p>The PEG syntax defines also the two noncapturing <span>and</span> and <span>not</span> syntactic predicates,
which uses the symbols <span>&amp;</span> and <span>!</span> and provide a powerful syntactic lookahead and disambiguation facility.
A common use of the <span>!</span> predicate is to terminate a parsing expression with <span>!1</span>. Here the <span>1</span> matches everything, and <span>!1</span>
would only match when there is nothing left to match, that is the string end is reached.</p>
<p>We will end our introduction to the parsing expression grammar and the use of the <span>npeg</span> module here.
To learn all the details about PEG like restrictions, performance and memory consumption you should
consult the Wikipedia article or other dedicated literature. And for advanced uses of the <span>npeg</span> module
including the use of back references, and all the available syntax elements, you
have to study its API documentation carefully.</p>
<p>References:</p>

</div>
</div>
</div>
</div>

<div>
<p>
In this part of the book we will try to explain the more difficult parts of the Nim programming language:
Macros and meta-programming, asynchronous code, threading and parallel processing, and finally
the use of Nim’s concepts. We will start with macros and meta-programming, as that seems to
be a really stable part of Nim’s advanced features. Nim’s concepts just got a redesign, and for
the use of asynchronous code, threading and parallel processing there exists currently
various implementations, and all that may change again when the Nim core devs should decide
to actually use the CPS (Continuation-Passing Style) based programming style for the implementation of this.
</p>
</div>
<div>

<div>
<div>
<h3 id="_introduction_2">Introduction</h3>
<p>In computer science a macro (short for &#34;macro instruction&#34;) is a rule or pattern that specifies how a certain input should be mapped to a replacement output.
Meta-programming is a programming technique in which computer programs have the ability to treat other programs as their data. It means that a program can read, generate, analyze or transform other programs, and even modify itself while running.</p>
<p>Legacy programming languages like C or assembly languages support already some form of macros, which generally work directly
on the textual representation of the source code.</p>
<p>A common use of textual macros in assembly languages was to group sequences of instructions, like
reading data from a file or from the keyboard, to make that operations easily accessible. The C programming
language uses the #define pre-processor directive to introduce textual macros. Macros in C are generally single line
text substitutions which are processed by a pre-processor program before the actual compiling process. Some examples of
common C macros are</p>
<div>
<div>
<pre><code data-lang="c"><span>#define PI 3.1415
#define sqr(x) (x)*(x)</span></code></pre>
</div>
</div>
<p>The basic C macro syntax is that the first continues character sequence after the #define directive is replaced by
the C pre-processor with the rest of that line. The #define directive has some basic parameter support which
was used for the <span>sqr()</span> macro above. C macros have the purpose to support named constants and to support
simple parameterized expressions like the <span>sqr()</span> from above, avoiding the need to create actual functions.
The C pre-processor would substitute each occurrence of the string <span>PI</span> in the C source file with the float literal
<span>3.1415</span> and the term <span>sqr(1+2)</span> with <span>(1+2)*(1+2)</span>.</p>
<p>A Nim macro is a function that is executed at compile-time and transforms a Nim syntax tree into a different tree.
This can be used to add custom language features and implement domain-specific languages (DSL).
While macros enable advanced compile-time code transformations, they cannot change Nim’s syntax.</p>
<p>The macro keyword is used similar to <span>proc</span>, func and template to define a parameterized code block which is executed at compile time
and consists of ordinary Nim code and meta-programming instructions. The meta-programming instructions are imported from the <span>macros</span>
module and are used to construct an Abstract Syntax Tree (AST) of the Nim language. This AST is created by the macro body at compile time
and is returned by the macro as untyped data type. The parameter list of macros accept ordinary (static) Nim data types and additional the data types
typed and untyped, which we already used for templates. We will explain the differences of the various possible data types
for macro parameters later in more detail, after we have given a first simple macro example. Note that Nim macros are hygienic by default, that
is symbols defined inside the macro body are local and do not pollute the name space of the environment.
As macros are executed at compile time, the use of macros may increase the compile time, but their use
does not impact the performance of the final executable — in some cases the use of clever macros may even
improve the performance of our final program.</p>

<p>To verify that macros are really executed at compile time, we will start with a tiny macro that contains only an echo statement in its body:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>s</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>echo</span> <span>&#34;calling macro m1&#34;</span>
  <span>m1</span><span>(</span><span>&#34;Macro argument&#34;</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we compile above code the compiler prints the message <span>&#34;Macro argument&#34;</span>, as it processes the macro body.
When we run the program, we get only the output <span>&#34;calling macro m1&#34;</span> from the <span>main()</span> <span>proc</span>, as the macro <span>m1()</span>
does return an empty AST only. The carefully reader may wonder, why the <span>echo()</span> statement in the macro body above
works at all, as the parameter of macro <span>m1()</span> is specified as ordinary <span>string</span>, not as <span>static[string]</span>. So the type
of <span>s</span> in the macro body should be a NimNode. Well, maybe an <span>echo()</span> overload exists that can work with NimNodes,
or maybe, as we pass a <span>string</span> constant to macro <span>m1()</span>, in this concrete case s is indeed an ordinary string
in the macro body. Maybe we should have used <span>s: static[string]</span> as parameter type, which would give
us the exact same results.</p>

<p>As macros are executed at compile time, we can not really pass runtime variables to it. When we try, we would
expect a compiler error:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>s</span><span>:</span> <span>string</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>s</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>str</span> <span>=</span> <span>&#34;non static string&#34;</span>
  <span>m1</span><span>(</span><span>str</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>But with the current compiler version 1.5.1 that code compiles and prints the message <span>&#34;str&#34;</span>, which is a bit surprising.
To fix this, we can change the parameter type to <span>static[string]</span>, which guarantees that we can indeed pass only compile time constants.
Our last example would give a compile error in this case, while the one before with the
<span>string</span> constant would work as expected.</p>
<p>Now let us create macros which actually creates an AST which is returned by the macro and executed when we run our program.
For creating an AST in the macro body we have various options: we can use the <span>parseStmt()</span> function or the <span>&#34;quote do:&#34;</span> notation
to generate the AST from regular program code in text form, or we can create the syntax tree directly with expressions provided by the <span>macros</span> module, e.g.
by calls like <span>newTree()</span> or <span>newLit()</span> and such. The later gives us the best control over the AST generation process, but is not easy for beginners. The good news
is that Nim now provides a set of helper functions like <span>dumpTree()</span> or <span>dumpAstGen()</span> which shows us the AST representation of a Nim source code
block as well as the commands which we can use to create that AST. This makes it for beginners much easier to learn the basic instructions necessary
to create valid syntax trees and to create useful macros.</p>
<p>We will start with the simple <span>parseStmt()</span> function which generates the syntax tree from the source code text string that we pass it
as argument. This seems to be very restricted, and maybe even useless, as we can write the source code just as ordinary
program text outside of the macro body. That is true, but we can construct the text string argument that we pass to the
<span>parseStmt()</span> function with regular Nim code at compile time. That is similar as having one program, which
generates a new source code string, saves that string to disk, and finally compiles and runs that created program. Let us check
with a fully <span>static</span> string that <span>parseStmt()</span> actually works:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>s</span><span>:</span> <span>static</span><span>[</span><span>string</span><span>]</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>result</span> <span>=</span> <span>parseStmt</span><span>(</span><span>s</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>

  <span>const</span> <span>str</span> <span>=</span> <span>&#34;echo </span><span>\&#34;</span><span>We like Nim</span><span>\&#34;</span><span>&#34;</span>
  <span>m1</span><span>(</span><span>str</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>When we compile and run above program, we get the output
<span>&#34;We like Nim&#34;</span>. The macro <span>m1()</span> is called at compile time with the <span>static</span>
parameter <span>str</span> and returns an AST which represents the passed
program code fragment. That AST is inserted into our program at the location
of the macro call, and when we run our program the compiled AST is executed and
produces the output.</p>
<p>Of course executing a fully <span>static</span> <span>string</span> this way is useless, as we could have used
regular program code instead. Now let us investigate how we can construct some
program code at compile time. Let us assume that we have an <span>object</span> with multiple
fields, and we want to print the field contents. A sequence of <span>echo()</span> statements would do
that for us, or we may use only one <span>echo()</span> statement, when we separate the field arguments each
by <span>&#34;\n&#34;</span>. The <span>with</span> module may further simplify our task. But as we have to print multiple fields, not
an <span>array</span> or a <span>seq</span>, we can not directly iterate over the values to process them. Let us see how
a simple text string based macro can solve the task:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>:</span> <span>float</span>

<span>macro</span> <span>m1</span><span>(</span><span>objName</span><span>:</span> <span>static</span><span>[</span><span>string</span><span>]</span><span>;</span> <span>fields</span><span>:</span> <span>varargs</span><span>[</span><span>untyped</span><span>]</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>var</span> <span>s</span><span>:</span> <span>string</span>
  <span>for</span> <span>x</span> <span>in</span> <span>fields</span><span>:</span>
    <span>s</span><span>.</span><span>add</span><span>(</span><span>&#34;echo &#34;</span> <span>&amp;</span> <span>objName</span> <span>&amp;</span> <span>&#34;.&#34;</span> <span>&amp;</span> <span>x</span><span>.</span><span>repr</span> <span>&amp;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>)</span>
  <span>echo</span> <span>s</span> <span># verify the constructed string</span>
  <span>result</span> <span>=</span> <span>parseStmt</span><span>(</span><span>s</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>o</span> <span>=</span> <span>O</span><span>(</span><span>x</span><span>:</span> <span>1.0</span><span>,</span> <span>y</span><span>:</span> <span>2.0</span><span>,</span> <span>z</span><span>:</span> <span>3.0</span><span>)</span>
  <span>m1</span><span>(</span><span>&#34;o&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>In this example we pass the name of our <span>object</span> instance as <span>static</span> <span>string</span> to the macro, while we pass
the fields not as <span>string</span>, but as list of <span>untyped</span> values. The passed <span>static</span> <span>string</span> is indeed an ordinary Nim <span>string</span>
inside the <span>macro</span>, we can apply sting operations on it. But the field names passed as <span>untyped</span> parameters
appear as so called NimNodes inside the macro. We can use the <span>repr()</span> function to convert the NimNodes to
ordinary <span>strings</span>, so that we can use <span>string</span> operations on them. We iterate with a <span>for</span> loop over all the passed
field names, and generate <span>echo()</span> statements from the <span>object</span> instance name and the field names, each separated
by a newline character. Then all the statements are collected in a multi-line <span>string</span> <span>s</span> and are finally converted
to the final AST by the <span>parseStmt()</span> function. In the macro body we use the <span>echo()</span> statement to verify the
content of that <span>string</span>. As the <span>macro</span> is executed during compile time, we get this output
when we compile our program:</p>
<div>
<div>
<pre>echo o.x
echo o.y
echo o.z</pre>
</div>
</div>
<p>And when we run it we get:</p>

<p>Well, not a really great result for this concrete use case: We have replaced three <span>echo()</span> commands with a five lines <span>macro</span>.
But at least you got a feeling what <span>macros</span> can do for use.</p>
</div>
<div>
<h3 id="_types_of_macro_parameters">Types of macro parameters</h3>
<p>As Nim is a statically typed programming language, all variables and <span>proc</span> parameters have a well defined
data type. There is some form of exception from this rule for OR-types, <span>object</span> variants and <span>object</span> references:
OR-types are indeed no real exception, as whenever we use an OR-type as the type of a <span>proc</span> parameter, multiple instances
of the <span>proc</span> with different parameter types are created when necessary. That is very similar to generic <span>procs</span>.
<span>object</span> variants and <span>object</span> references built indeed some form of exception, as instances of these types can have
different runtime types that we can query with the <span>case</span> or with the <span>of</span> keyword at runtime. Note that <span>object</span>
variants and references (the managed pointers itself, not the actual data allocated on the heap) occupy always the same amount of RAM, independent of the actual runtime type.
(That is why we can store object variants with different content or references to objects of different runtime types using inheritance in
<span>arrays</span> and sequences.)</p>
<p>For the C <span>sqr()</span> macro from the beginning of this section, there is no real restriction for the argument data types.
The <span>sqr()</span> C macro would work for all numeric types that support the multiply operation, from <span>char</span> data type over
various <span>int</span> types to <span>float</span>, <span>double</span> and <span>long double</span>. This behaviour is not really surprising, as C macros are only a
text substitution — by the * multiply operator for our <span>sqr()</span> <span>macro</span>. Actually the C pre-processor would even accept
all data types and even undefined symbols for its substitution process. But then the C compiler would complain later.</p>
<p>Nim <span>macros</span> and Nim <span>templates</span> do also some form of code substitution, so it is not really surprising that they accept not
only well defined data types, but also the relaxed types <span>typed</span> and <span>untyped</span>.</p>
<p>As parameters for Nim’s <span>macros</span> we can use ordinary Nim data types like <span>int</span> or <span>string</span>, compile time constants denoted with the
<span>static</span> keyword like <span>static[int]</span>, or the <span>typed</span> and <span>untyped</span> data types. When we call <span>macros</span> then the data types of the parameters are used in the same way for overload resolution
as it is done for <span>procs</span> and templates. For example, if a macro defined as <span>foo(arg: int)</span> is called as <span>foo(x)</span>, then <span>x</span> has to be of a type compatible to <span>int</span>.</p>
<p>What may be surprising at first is, that inside the <span>macro</span> body all parameter types have not the data type of the actual
argument that we have passed to the <span>macro</span>, but the special <span>macro</span> data type <span>NimNode</span> which is defined in the <span>macros</span> module.
The predefined result variable of the <span>macro</span> has the type <span>NimNode</span> as well. The only exception are <span>macro</span> parameters
which are explicitly marked with the <span>static</span> keyword to be compile time constants like <span>static[string]</span>, these parameters
are not NimNodes in the <span>macro</span> body, but have their ordinary data types in the <span>macro</span> body.
Variables that we define inside the <span>macro</span> body have exactly that type that we give to then, e.g. when we define a
variable as <span>s: string</span> then this is an ordinary Nim <span>string</span> variable, for which we can use the common <span>string</span> operations.
But of course we have always to remember that <span>macros</span> are executed at compile time, and so the operations
on variables defined in the <span>macro</span> body occur at compile time, which may restrict a few operations.
Currently <span>macros</span> are evaluated at compile time by the Nim compiler in the NimVM (Vitual Machine) and so
share all the limitations of the NimVM: <span>Macros</span> have to be implemented in pure Nim code and can currently not
call C functions except those that are built in the compiler.</p>
<p>In the Nim macros tutorial the <span>static</span>, <span>typed</span> and <span>untyped</span> <span>macro</span> parameters are described in some detail. We will
follow that description, as it is more detailed as the current description in the Nim compiler manual. As these
descriptions are very abstract, we will give some simple examples later.</p>
<div>
<h4 id="_static_macro_parameters">Static Macro Parameters</h4>
<p><span>static</span> arguments are a way to pass compile time constants not as a <span>NimNode</span> but as an ordinary value to a <span>macro</span>.
These values can then be used in the <span>macro</span> body like ordinary Nim variables. For example, when we have
a <span>macro</span> defined as <span>m1(num: static[int])</span>, then we can pass it constants values compatible with the
<span>int</span> data type, and in the <span>macro</span> body we can use that parameter as ordinary integer variable.</p>
</div>
<div>
<h4 id="_untyped_macro_parameters">Untyped Macro Parameters</h4>
<p><span>untyped</span> <span>macro</span> arguments are passed to the <span>macro</span> before they are semantically checked. This means that the syntax tree that is passed down to the <span>macro</span> does not need
to make sense for the Nim compiler yet, the only limitation is that it needs to be parsable. Usually, the <span>macro</span> does not check the argument either but uses it in the
transformation’s result somehow. The result of a <span>macro</span> expansion is always checked by the compiler,
so apart from weird error messages, nothing bad can happen.
The downside for an <span>untyped</span> <span>macro</span> argument is that these do not play well with Nim’s overloading resolution.
The upside for <span>untyped</span> arguments is that the syntax tree is quite predictable and less complex compared to its <span>typed</span> counterpart.</p>
</div>
<div>
<h4 id="_typed_macro_parameters">Typed Macro Parameters</h4>
<p>For <span>typed</span> arguments, the semantic checker runs on the argument and does transformations on it, before it is passed to the macro.
Here identifier nodes are resolved as symbols, implicit type conversions are visible in the tree as calls, <span>templates</span> are expanded,
and probably most importantly, nodes have type information. Typed arguments can have the type <span>typed</span> in the arguments list.
But all other types, such as <span>int</span>, <span>float</span> or <span>MyObjectType</span> are typed arguments as well, and they are passed to the macro as a syntax tree.</p>
</div>
<div>
<h4 id="_code_blocks_as_arguments">Code Blocks as Arguments</h4>
<p>In Nim it is possible to pass the last argument of a <span>proc</span>, <span>template</span> or <span>macro</span> call as
an indented code block following a colon, instead of an ordinary argument enclosed
in the parentheses following the function name. For example instead of <span>echo(&#34;1 + 2 = &#34;, 1 + 2)</span>
we can also write</p>

<p>For <span>procs</span> this notation makes not much sense, but for
<span>macros</span> this notation can be useful, as syntax trees of arbitrary complexity can be passed as arguments.</p>
<p>Now let us investigate in some more detail which data types
a <span>macro</span> accepts. This way we hopefully get more comfortable with all these strange <span>macro</span> stuff.
For our test we create a few tiny <span>macros</span> with only one parameter which does noting more than
printing a short message when we compile our program:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>x</span><span>:</span> <span>static</span><span>[</span><span>int</span><span>]</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>&#34;executing macro body&#34;</span>

<span>m1</span><span>(</span><span>3</span><span>)</span></code></pre>
</div>
</div>
<p>This code should compile fine and print the message <span>&#34;executing macro body&#34;</span> during the compile process,
and indeed it does. The next example is not that easy:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>x</span><span>:</span> <span>int</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>&#34;executing macro body&#34;</span>
  <span>echo</span> <span>x</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>

<span>var</span> <span>y</span><span>:</span> <span>int</span>
<span>y</span> <span>=</span> <span>7</span>
<span>m1</span><span>(</span><span>y</span><span>)</span></code></pre>
</div>
</div>
<p>This compiles, but as the assignment [.code]y = 7 is executed at program runtime, while the <span>macro</span> body
is already executed at compile time, we should not expect that the <span>echo()</span> statement in the <span>macro</span> body
prints the value <span>7</span>. Instead we get just <span>y</span> for both <span>echo()</span> calls. Now let us investigate what happens when we use
<span>typed</span> instead of <span>int</span> for the <span>macro</span> parameter:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>x</span><span>:</span> <span>typed</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>&#34;executing macro body&#34;</span>
  <span>echo</span> <span>x</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>

<span>var</span> <span>y</span><span>:</span> <span>int</span>
<span>y</span> <span>=</span> <span>7</span>
<span>m1</span><span>(</span><span>y</span><span>)</span></code></pre>
</div>
</div>
<p>We get the same result again, both <span>echo()</span> statements prints <span>y</span>. The advantage of the use of <span>typed</span> here is, that
we can change the data type of <span>y</span> from <span>int</span> to <span>float</span> and our program still compiles. So the <span>typed</span> parameter type
just enforces that the parameter has a well defined type, but it does not restrict the actual data type
to a special value. The previous <span>macro</span> with <span>int</span> parameter type would obviously not accept a <span>float</span> value.</p>
<p>Now let us see what happens when we pass an undefined symbol to this <span>macro</span> with <span>typed</span> parameter:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>x</span><span>:</span> <span>typed</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>&#34;executing macro body&#34;</span>
  <span>echo</span> <span>x</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>

<span>m1</span><span>(</span><span>y</span><span>)</span></code></pre>
</div>
</div>
<p>This will not compile, as the <span>macro</span> expects a parameter with a well defined type. But we can make it compile
by replacing <span>typed</span> with <span>untyped</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m1</span><span>(</span><span>x</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>&#34;executing macro body&#34;</span>
  <span>echo</span> <span>x</span>
  <span>echo</span> <span>x</span><span>.</span><span>repr</span>

<span>m1</span><span>(</span><span>y</span><span>)</span></code></pre>
</div>
</div>
<p>So <span>untyped</span> <span>macro</span> parameters are the most flexible ones, and actually they are the most used.
But in some situations it is necessary to use <span>typed</span> parameters, e.g. when we need to know
the parameter type in the <span>macro</span> body.</p>
</div>
</div>
<div>
<h3 id="_quote_and_the_quote_do_construct">Quote and the quote do: construct</h3>
<p>In the section before we learned about the <span>parseStmt()</span> function which is used in a <span>macro</span> body to compile
Nim code represented as a multi-line <span>string</span>
to an abstract syntax tree representation. <span>Macros</span> uses as return type the <span>&#34;untyped&#34;</span> data type, which is compatible with the <span>NimNode</span> type
returned by the <span>parseStmt()</span> function.</p>
<p>The <span>quote()</span> function and the <span>quote do:</span> construct has some similarity with the <span>parseStmt()</span> function: It accepts an expression or a block of Nim code as argument
and compiles that Nim code to an abstract syntax tree representation. The advantage of <span>quote()</span> is that the passed Nim code can contain <span>NimNode</span> expressions from the surrounding scope.
The <span>NimNode</span> expressions have to be quoted using backticks.</p>
<p>As a first very simple example for the use of the <span>quote do:</span> construct we will present a way to print some debugging output.</p>
<p>Assume we have a larger Nim program which works not in the way that we expected, so we would add some
<span>echo()</span> statements like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>currentSpeed</span><span>:</span> <span>float</span> <span>=</span> <span>calcSpeed</span><span>(</span><span>t</span><span>)</span>
<span>echo</span> <span>&#34;currentSpeed: &#34;</span><span>,</span> <span>currentSpeed</span></code></pre>
</div>
</div>
<p>Instead of the <span>echo()</span> statement we would like to just write <span>show(currentSpeed)</span>
to get exactly the same output. For that we need access not only to the actual value
of a variable, but also to its name. Nim <span>macros</span> can give us this information, and
by using the <span>quote do:</span> construct it is very easy to create our desired <span>showMe()</span> <span>macro</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>show</span><span>(</span><span>x</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>let</span> <span>n</span> <span>=</span> <span>x</span><span>.</span><span>toStrLit</span>
  <span>result</span> <span>=</span> <span>quote</span> <span>do</span><span>:</span>
    <span>echo</span> <span>`</span><span>n</span><span>`,</span><span>&#34;: &#34;</span><span>,</span> <span>`</span><span>x</span><span>`</span>

<span>import</span> <span>math</span>
<span>var</span> <span>a</span> <span>=</span> <span>7.0</span>
<span>var</span> <span>b</span> <span>=</span> <span>9.0</span>
<span>show</span><span>(</span><span>a</span> <span>*</span> <span>sqrt</span><span>(</span><span>b</span><span>))</span></code></pre>
</div>
</div>
<p>When we compile and run that code we get:</p>

<p>In the <span>macro</span> body we use the <span>proc</span> <span>toStrLit()</span> from the <span>macros</span> module which is
described with this comment: &#34;Converts the AST n to the concrete Nim code and wraps that in a string literal node&#34;
So our local variable <span>n</span> in the <span>macro</span> body is a <span>NimNode</span> that now contains the <span>string</span> representation of the <span>macro</span>
argument <span>x</span>. We use the <span>NimNode</span> <span>n</span> enclosed with backtics in the <span>quote do:</span> construct.
It seems that writing this <span>macro</span> was indeed not that difficult, but actually it was only that easy because we have
basically copied the <span>dump()</span> <span>macro</span>
from the <span>sugar</span> module of Nim’s standard library.</p>
<p>Let us investigate our <span>show()</span> <span>macro</span> in some more detail to learn more about the inner working of
Nim <span>macros</span>. First recall that <span>macros</span> always have a return value of data type <span>untyped</span>, which is actually a <span>NimNode</span>.
The <span>quote do:</span> construct gives us a result which we can use as return value of our <span>macro</span>.
Sometimes
we may see macros with no result type at all, which is currently identical to the <span>untyped</span> result type.
As the macro body is executed at compile time, the <span>quote do:</span> construct
is executed at compile time as well, that is that the code block which we pass to the <span>quote do:</span> construct is processed
at compile time and the quoted <span>NimNodes</span> in the block are interpolated at compile time. For our program from above the
actual <span>echo()</span> statement in the block is then finally executed at program runtime. To prove how this final <span>echo()</span> statement looks we may
add as last line of our <span>macro</span> the statement <span>&#34;echo result.repr&#34;</span> and we would then get the <span>string</span> &#34;echo &#34;a * sqrt(b)&#34;, &#34;: &#34;, a * sqrt(b)&#34; when we compile our program again.</p>
</div>
<div>
<h3 id="_building_the_ast_manually">Building the AST manually</h3>
<p>In the two sections before we used the functions <span>parseStmt()</span> and <span>quote()</span> to build the AST from a
textual representation of Nim code. That can be convenient, but is not very flexible.
In this section we will learn how we can build a valid AST from scratch by calling
functions of the <span>macros</span> module. That is not that easy, but this way we have the full power of
the Nim meta-programming available.</p>
<p>Luckily the <span>macros</span> module provides some macros like <span>dumpTree()</span> and <span>dumpAstGen()</span> which can help
us get started. We will create again a macro similar to the <span>show()</span> <span>macro</span> that we created before with the
<span>quote do:</span> construct, but now with elementary instructions from the <span>macros</span> module. This may look a bit boring,
but this plain example is already complicated enough for the beginning, and it shows use the basics to construct much more powerful <span>macros</span> later.</p>
<p>The core code of our <span>debug()</span> <span>macro</span> would look in textual representation like</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span><span>int</span>
<span>echo</span> <span>&#34;a + b&#34;</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>a</span> <span>+</span> <span>b</span></code></pre>
</div>
</div>
<p>That is for debugging we would like to print an expression first in its <span>string</span> representation, and
divided by a colon the evaluated expression. The <span>dumpTree()</span> <span>macro</span> can show us how the Nim syntax tree
for such a print debug statement should look:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span>

<span>dumptree</span><span>:</span>
  <span>echo</span> <span>&#34;a + b&#34;</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>a</span> <span>+</span> <span>b</span></code></pre>
</div>
</div>
<p>When we compile this code we get as output:</p>
<div>
<div>
<pre> StmtList
  Command
    Ident &#34;echo&#34;
    StrLit &#34;a + b&#34;
    StrLit &#34;: &#34;
    Infix
      Ident &#34;+&#34;
      Ident &#34;a&#34;
      Ident &#34;b&#34;</pre>
</div>
</div>
<p>So the Nim syntax tree for the <span>echo()</span> statement from above is a statement list
consisting of an <span>echo()</span> command with two <span>string</span> literal arguments and a last argument which
is built with the infix + operator and the two arguments <span>a</span> and <span>b</span>. So we can see how the
AST that we would have to construct would have to look, but we still have no idea how
we could construct such an AST in detail. Well, the <span>macros</span> module would contain the functions what we
need for that, but it is not easy to find the right functions there. The <span>dumpAstGen()</span> <span>macro</span>
can list us exactly the needed functions:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span>

<span>dumpAstGen</span><span>:</span>
  <span>echo</span> <span>&#34;a + b&#34;</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>a</span> <span>+</span> <span>b</span></code></pre>
</div>
</div>
<div>
<div>
<pre>Compiling that code gives us:</pre>
</div>
</div>
<div>
<div>
<pre> nnkStmtList.newTree(
  nnkCommand.newTree(
    newIdentNode(&#34;echo&#34;),
    newLit(&#34;a + b&#34;),
    newLit(&#34;: &#34;),
    nnkInfix.newTree(
      newIdentNode(&#34;+&#34;),
      newIdentNode(&#34;a&#34;),
      newIdentNode(&#34;b&#34;)
    )
  )
)</pre>
</div>
</div>
<p>This is a nested construct. The most outer instruction constructs a new tree of Nim Nodes with the node type statement list.
The next construct creates a tree with node kind command, which again contains the ident node with name <span>echo</span>,
which again contains two literals and the infix + operator.</p>
<p>Indeed we can use the output of the <span>dumpAstGen()</span> <span>macro</span> directly to create a working Nim program:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span>

<span>#dumpAstGen:</span>
<span>#  echo &#34;a + b&#34;, &#34;: &#34;, a + b</span>

<span>macro</span> <span>m</span><span>():</span> <span>untyped</span> <span>=</span>
  <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span>
    <span>nnkCommand</span><span>.</span><span>newTree</span><span>(</span>
      <span>newIdentNode</span><span>(</span><span>&#34;echo&#34;</span><span>),</span>
      <span>newLit</span><span>(</span><span>&#34;a + b&#34;</span><span>),</span>
      <span>newLit</span><span>(</span><span>&#34;: &#34;</span><span>),</span>
      <span>nnkInfix</span><span>.</span><span>newTree</span><span>(</span>
        <span>newIdentNode</span><span>(</span><span>&#34;+&#34;</span><span>),</span>
        <span>newIdentNode</span><span>(</span><span>&#34;a&#34;</span><span>),</span>
        <span>newIdentNode</span><span>(</span><span>&#34;b&#34;</span><span>)</span>
      <span>)</span>
    <span>)</span>
  <span>)</span>

<span>m</span><span>()</span></code></pre>
</div>
</div>
<p>When we compile and run that code, we get the output:</p>

<p>So the AST from above is fully equivalent to the one line <span>echo()</span> statement.
But now we would have to investigate how we can pass an actual expression
to our <span>macro</span> and how we can use that passed argument in the <span>macro</span> body — first print its textual form, and then the evaluated value separated by a colon.
And there is one more problem: That nested <span>macro</span> body from above is not really useful for
our final <span>dump()</span> <span>macro</span>, as we would like to be able to construct the <span>NimNode</span>, that is
returned by the <span>dump()</span> <span>macro</span> step wise: Add the <span>echo()</span> command, then the passed expression
in <span>string</span> form, and finally the evaluated expression. So let us first rewrite above <span>macro</span> in a form
where the AST is constructed step by step. That may look difficult, but when we know that
we can call the <span>newTree()</span> function with only one node kind parameter to create a empty tree
of that kind, and that we can later use the overloaded <span>add()</span> <span>proc</span> to add new nodes to that tree, then
it is easy to guess how we can construct the macro body:</p>
<div>
<div>
<pre><code data-lang="nim"> <span>import</span> <span>macros</span>

<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span>

<span>#dumpAstGen:</span>
<span>#  echo &#34;a + b&#34;, &#34;: &#34;, a + b</span>

<span>macro</span> <span>m</span><span>():</span> <span>untyped</span> <span>=</span>
  <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span>
    <span>nnkCommand</span><span>.</span><span>newTree</span><span>(</span>
      <span>newIdentNode</span><span>(</span><span>&#34;echo&#34;</span><span>),</span>
      <span>newLit</span><span>(</span><span>&#34;a + b&#34;</span><span>),</span>
      <span>newLit</span><span>(</span><span>&#34;: &#34;</span><span>),</span>
      <span>nnkInfix</span><span>.</span><span>newTree</span><span>(</span>
        <span>newIdentNode</span><span>(</span><span>&#34;+&#34;</span><span>),</span>
        <span>newIdentNode</span><span>(</span><span>&#34;a&#34;</span><span>),</span>
        <span>newIdentNode</span><span>(</span><span>&#34;b&#34;</span><span>)</span>
      <span>)</span>
    <span>)</span>
  <span>)</span>

<span>macro</span> <span>m2</span><span>():</span> <span>untyped</span> <span>=</span>
  <span>result</span> <span>=</span> <span>nnkStmtList</span><span>.</span><span>newTree</span><span>()</span>
  <span>let</span> <span>c</span> <span>=</span> <span>nnkCommand</span><span>.</span><span>newTree</span><span>()</span>
  <span>let</span> <span>i</span> <span>=</span> <span>nnkInfix</span><span>.</span><span>newTree</span><span>()</span>
  <span>i</span><span>.</span><span>add</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;+&#34;</span><span>))</span>
  <span>i</span><span>.</span><span>add</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;a&#34;</span><span>))</span>
  <span>i</span><span>.</span><span>add</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;b&#34;</span><span>))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;echo&#34;</span><span>))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>newLit</span><span>(</span><span>&#34;a + b&#34;</span><span>))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>newLit</span><span>(</span><span>&#34;: &#34;</span><span>))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>i</span><span>)</span>
  <span>result</span><span>.</span><span>add</span><span>(</span><span>c</span><span>)</span>

<span>m2</span><span>()</span></code></pre>
</div>
</div>
<p>First we create the tree empty three structures of node kinds
statement list, command and infix operator. Then we use the overloaded <span>add()</span>
proc to populate the threes, using <span>procs</span> like <span>newIdentNode()</span> or <span>newLit()</span> to
create the nodes of matching types as before. When we run our program with the modified
<span>macro</span> version <span>m2()</span> we get again the same output:</p>

<p>The next step to create our actual <span>dump()</span> macro is again easy — we pass the expression to <span>dump()</span>
as an <span>untyped</span> <span>macro</span> parameter to the <span>macro</span>, convert it to a <span>NimNode</span> of <span>string</span> type and use that
instead of the <span>newLit(&#34;a + b&#34;)</span> from above. In our second <span>macro</span>, where we used the <span>quote do:</span> construct,
we applied already <span>toStrLit()</span> on an <span>untyped</span> <span>macro</span> parameter, so we should be able to reuse that
to get the <span>string</span> <span>NimNode</span>. Instead we would have to apply the stringify operator additional
on that value. But a simpler way is to just apply <span>repr()</span> on the <span>untyped</span> <span>macro</span> argument to
get a <span>NimNode</span> of <span>string</span> type. And finally, to get the value of the evaluated expression in our <span>dump()</span>
macro, we <span>add()</span> the <span>untyped</span> <span>macro</span> parameter directly in the command three — that value is
evaluated when we run the <span>macro</span> generated code.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>var</span> <span>a</span><span>,</span> <span>b</span><span>:</span> <span>int</span>

<span>macro</span> <span>m2</span><span>(</span><span>x</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>var</span> <span>s</span> <span>=</span> <span>x</span><span>.</span><span>toStrLit</span>
  <span>result</span> <span>=</span> <span>nnkStmtList</span><span>.</span><span>newTree</span><span>()</span>
  <span>let</span> <span>c</span> <span>=</span> <span>nnkCommand</span><span>.</span><span>newTree</span><span>()</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;echo&#34;</span><span>))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>newLit</span><span>(</span><span>x</span><span>.</span><span>repr</span><span>))</span>
  <span>#c.add(newLit($s))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>newLit</span><span>(</span><span>&#34;: &#34;</span><span>))</span>
  <span>c</span><span>.</span><span>add</span><span>(</span><span>x</span><span>)</span>
  <span>result</span><span>.</span><span>add</span><span>(</span><span>c</span><span>)</span>

<span>m2</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span></code></pre>
</div>
</div>
<p>Again, we get the desired output:</p>

<p>So our <span>dump()</span> <span>macro</span> called still <span>m2()</span> is complete and can be used
to debug arbitrary expression. Note that this <span>macro</span> works for arbitrary expressions, not only
for numerical ones. We may use it like</p>
<div>
<div>
<pre><code data-lang="nim"><span>m2</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span>
<span>let</span> <span>what</span> <span>=</span> <span>&#34;macros&#34;</span>
<span>m2</span><span>(</span><span>&#34;Nim &#34;</span> <span>&amp;</span> <span>what</span> <span>&amp;</span> <span>&#34; are not that easy&#34;</span><span>)</span></code></pre>
</div>
</div>

<div>
<div>
<pre>a + b: 0
&#34;Nim &#34; &amp; what &amp; &#34; are not that easy&#34;: Nim macros are not that easy</pre>
</div>
</div>
<p>Now let us extend our <span>debug()</span> <span>macro</span> so that it can accept multiple arguments.
The needed modifications are tiny, we just pass instead of a single <span>untyped</span>
argument an argument of type <span>varargs[untyped]</span> to the debug macro, and iterate
in the <span>macro</span> body with a <span>for</span> loop over the <span>varargs</span> argument:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>macros</span>

<span>macro</span> <span>m2</span><span>(</span><span>args</span><span>:</span> <span>varargs</span><span>[</span><span>untyped</span><span>]</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>result</span> <span>=</span> <span>nnkStmtList</span><span>.</span><span>newTree</span><span>()</span>
  <span>for</span> <span>x</span> <span>in</span> <span>args</span><span>:</span>
    <span>let</span> <span>c</span> <span>=</span> <span>nnkCommand</span><span>.</span><span>newTree</span><span>()</span>
    <span>c</span><span>.</span><span>add</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;echo&#34;</span><span>))</span>
    <span>c</span><span>.</span><span>add</span><span>(</span><span>newLit</span><span>(</span><span>x</span><span>.</span><span>repr</span><span>))</span>
    <span>c</span><span>.</span><span>add</span><span>(</span><span>newLit</span><span>(</span><span>&#34;: &#34;</span><span>))</span>
    <span>c</span><span>.</span><span>add</span><span>(</span><span>x</span><span>)</span>
    <span>result</span><span>.</span><span>add</span><span>(</span><span>c</span><span>)</span>

<span>var</span>
  <span>a</span> <span>=</span> <span>2</span>
  <span>b</span> <span>=</span> <span>3</span>
<span>m2</span><span>(</span><span>a</span> <span>+</span> <span>b</span><span>,</span> <span>a</span> <span>*</span> <span>b</span><span>)</span></code></pre>
</div>
</div>
<p>When we compile and run that code we get:</p>

</div>
<div>
<h3 id="_the_assert_macro">The Assert Macro</h3>
<p>As one more simple example we will show how we can create our own
<span>assert()</span> <span>macro</span>. The <span>assert()</span> has only one argument, which is a expression with
a boolean result. If the expression evaluates to <span>true</span> at program runtime, then
the <span>assert()</span> <span>macro</span> should do nothing. But when the expression evaluates to
<span>false</span>, then this indicates a serious error and the <span>macro</span> shall print the
expression which evaluated to <span>false</span>, and then terminate the program execution.
This is basically what the <span>assert()</span> <span>macro</span> in the Nim standard library already does,
and the official Nim macros tutorial contains such an <span>assert()</span> <span>macro</span> as well.</p>
<p>Arguments for our <span>assert()</span> <span>macro</span> may look like <span>&#34;x == 1 +2&#34;</span>, containing one infix
operator and one left-hand and one right-hand operand. We will show how we can use
subscript <span>[]</span> operators on the <span>NimNode</span> argument to access each operand.</p>
<p>As a first step, we use the <span>treeRepr()</span> function from the <span>macros</span> module to show us the
Nim tree structure of a boolean expression with an infix operator:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>macros</span>

<span>macro</span> <span>myAssert</span><span>(</span><span>arg</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>echo</span> <span>arg</span><span>.</span><span>treeRepr</span>

<span>let</span> <span>a</span> <span>=</span> <span>1</span>
<span>let</span> <span>b</span> <span>=</span> <span>2</span>

<span>myAssert</span><span>(</span><span>a</span> <span>!=</span> <span>b</span><span>)</span></code></pre>
</div>
</div>
<p>When we compile that program, then the output of the <span>treeRepr()</span> function
shows us, that we have passed as argument an infix operator with two operands at index position 1 and 2.</p>
<div>
<div>
<pre>Infix
  Ident &#34;!=&#34;
  Ident &#34;a&#34;
  Ident &#34;b&#34;</pre>
</div>
</div>
<p>Now let us create an <span>assert()</span> macro which accept such a boolean expression with
an infix operator and two operands:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>macros</span>

<span>macro</span> <span>myAssert</span><span>(</span><span>arg</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>arg</span><span>.</span><span>expectKind</span><span>(</span><span>nnkInfix</span><span>)</span> <span># NimNodeKind enum value</span>
  <span>arg</span><span>.</span><span>expectLen</span><span>(</span><span>3</span><span>)</span>
  <span>let</span> <span>op</span> <span>=</span> <span>newLit</span><span>(</span><span>&#34; &#34;</span> <span>&amp;</span> <span>arg</span><span>[</span><span>0</span><span>]</span><span>.</span><span>repr</span> <span>&amp;</span> <span>&#34; &#34;</span><span>)</span> <span># operator as string literal NimNode</span>
  <span>let</span> <span>lhs</span> <span>=</span> <span>arg</span><span>[</span><span>1</span><span>]</span> <span># left hand side as NimNode</span>
  <span>let</span> <span>rhs</span> <span>=</span> <span>arg</span><span>[</span><span>2</span><span>]</span> <span># right hand side as NimNode</span>
  <span>result</span> <span>=</span> <span>quote</span> <span>do</span><span>:</span>
    <span>if</span> <span>not</span> <span>`</span><span>arg</span><span>`:</span>
      <span>raise</span> <span>newException</span><span>(</span><span>AssertionDefect</span><span>,</span><span>$</span><span>`</span><span>lhs</span><span>`</span> <span>&amp;</span> <span>`</span><span>op</span><span>`</span> <span>&amp;</span> <span>$</span><span>`</span><span>rhs</span><span>`)</span>

<span>let</span> <span>a</span> <span>=</span> <span>1</span>
<span>let</span> <span>b</span> <span>=</span> <span>2</span>

<span>myAssert</span><span>(</span><span>a</span> <span>!=</span> <span>b</span><span>)</span>
<span>myAssert</span><span>(</span><span>a</span> <span>==</span> <span>b</span><span>)</span></code></pre>
</div>
</div>
<p>The first two function calls <span>expectKind()</span> and <span>expectLen()</span> verify that the <span>macro</span> argument
is indeed an infix operator with two operands, that is the total length of the argument is 3.
The symbol nnkInfix is an <span>enum</span> value of the <span>NimNodeKind</span> data type defined in the <span>macros</span> module — that
module follows the convention to prepend <span>enum</span> values with a prefix, which is <span>nnk</span> for <span>NimNodeType</span> in this case.
In the <span>macro</span> body we use the subscript operator <span>[0]</span> to access the operator, and then apply
<span>repr()</span> on it to get its string representation. Further we use the subscript operators <span>[1]</span> and <span>[2]</span>
to extract the two operands from the macro argument and store the result each in a <span>NimNode</span>
<span>lhs</span> and <span>rhs</span>. Finally we create the <span>quote do:</span> construct with its indented multi-line
<span>string</span> argument and the interpolated <span>NimNode</span> values enclosed in backtics. The
block after the <span>quote do:</span> construct checks if the passed <span>arg</span> <span>macro</span> argument evaluates
to <span>false</span> at runtime, and raises an exception in that case displaying the reconstructed
argument.</p>
<p>We have to admit that this <span>macro</span> is not really useful in real life, as it is restricted to
simple boolean expressions with a single infix operator. And what it does in its body
makes not much sense: The original <span>macro</span> argument is split in tree parts, the
infix operator and the two operands, which are then just joined again to show
the exception message. But at least we have learned how we can access the various
parts of a <span>macro</span> argument by use of subscript operators, how we can use the <span>treeRepr()</span>
function from the <span>macros</span> module to inspect a <span>macros</span> argument, and how we can
ensure that the <span>macro</span> argument has the right shape for our actual <span>macro</span> by applying
functions like <span>expectKind()</span> and <span>expectLen()</span> early in the <span>macro</span> body.</p>
</div>
<div>
<h3 id="_pragma_macros">Pragma Macros</h3>
<p>All <span>macros</span> and <span>templates</span> can also be used as pragmas. They can be attached to routines (procs, iterators, etc), type names, or type expressions.
In this section we will show a small example how a <span>proc</span> pragma can be used to print
the <span>proc</span> name whenever a <span>proc</span> annotated with that pragma is called:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>macros</span>

<span>dumpAstGen</span><span>:</span> <span># let us see how the NimNode for an echo statement has to look</span>
  <span>proc </span><span>test</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>=</span>
    <span>var</span> <span>thisProcName</span> <span>=</span> <span>&#34;test&#34;</span>
    <span>echo</span> <span>thisProcname</span>
    <span>echo</span> <span>2</span> <span>*</span> <span>i</span>

<span>macro</span> <span>pm</span><span>(</span><span>arg</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span> <span># a pragma macro</span>
  <span>expectKind</span><span>(</span><span>arg</span><span>,</span> <span>nnkProcDef</span><span>)</span> <span># assert that macro is applied on a proc</span>
  <span>let</span> <span>node</span> <span>=</span> <span>nnkCommand</span><span>.</span><span>newTree</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;echo&#34;</span><span>),</span> <span>newLit</span><span>(</span><span>$</span><span>name</span><span>(</span><span>arg</span><span>)))</span>
  <span>insert</span><span>(</span><span>body</span><span>(</span><span>arg</span><span>),</span> <span>0</span><span>,</span> <span>node</span><span>)</span>
  <span>result</span> <span>=</span> <span>arg</span>

<span>proc </span><span>myProc</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>{.</span><span>pm</span><span>.}</span> <span>=</span>
  <span>echo</span> <span>2</span> <span>*</span> <span>i</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>myProc</span><span>(</span><span>7</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>We start with the <span>dumpAstGen()</span> <span>macro</span> applied on a <span>test()</span> <span>proc</span> which contains an <span>echo()</span> statement.
So when we compile that code, we get an initial idea how a <span>NimNode</span> that shall print the
proc name should look. To use pragma macros, we annotate the <span>proc</span> with the <span>macro</span> name enclosed
in the pragma symbols {..}. The annotated <span>proc</span> is then passed to the pragma with that name in form
of a syntax tree. Our goal is to to add a <span>NimNode</span> to this tree that prints the <span>proc</span> name of the passed AST.
To do that we have to know two important points: For the proc that is passed as <span>untyped</span> data type to our
<span>macro</span>, we can use the function <span>body()</span> to get the AST representation of the body of the passed <span>proc</span>,
and we can use <span>name()</span> to get the name of that <span>proc</span>. The functions <span>body()</span> and <span>name()</span> are provided
by the <span>macros</span> module of Nim’s standard library. In our <span>macro</span> <span>pm()</span> we first verify, that the passed
argument is really of node kind ProcDef. Then we create a new <span>NimNode</span>, which calls the <span>echo()</span> function
with the <span>proc</span> name as parameter. And we insert that node at position 0 into the body of the passed <span>proc</span>.
Finally we return the modified AST.</p>
<p>When we run our program, we get this output in the terminal window:</p>

</div>
<div>
<h3 id="_pragma_macro_for_iterator">Pragma Macro for Iterator</h3>
<p>Let us assume we have an <span>object</span> type which has some fields which are all sequences with the same base type, and we need
an iterator to iterate over all the container elements. Indeed this may happen when the different <span>seqs</span> contain
subclasses of the same parent class as in</p>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>Group</span> <span>=</span> <span>ref</span> <span>object</span> <span>of</span> <span>Element</span>
    <span>lines</span><span>:</span> <span>seq</span><span>[</span><span>Line</span><span>]</span>
    <span>circs</span><span>:</span> <span>seq</span><span>[</span><span>Circ</span><span>]</span>
    <span>texts</span><span>:</span> <span>seq</span><span>[</span><span>Text</span><span>]</span>
    <span>rects</span><span>:</span> <span>seq</span><span>[</span><span>Rect</span><span>]</span>
    <span>pads</span><span>:</span> <span>seq</span><span>[</span><span>Pad</span><span>]</span>
    <span>holes</span><span>:</span> <span>seq</span><span>[</span><span>Hole</span><span>]</span>
    <span>paths</span><span>:</span> <span>seq</span><span>[</span><span>Path</span><span>]</span>
    <span>pins</span><span>:</span> <span>seq</span><span>[</span><span>Pin</span><span>]</span>
    <span>traces</span><span>:</span> <span>seq</span><span>[</span><span>Trace</span><span>]</span>

<span>iterator</span> <span>items</span><span>(</span><span>g</span><span>:</span> <span>Group</span><span>):</span> <span>Element</span> <span>=</span>
  <span>for</span> <span>el</span> <span>in</span> <span>g</span><span>.</span><span>lines</span><span>:</span>
    <span>yield</span> <span>el</span>
  <span>for</span> <span>el</span> <span>in</span> <span>g</span><span>.</span><span>rects</span><span>:</span>
    <span>yield</span> <span>el</span>
  <span>for</span> <span>el</span> <span>in</span> <span>g</span><span>.</span><span>circs</span><span>:</span>
    <span>yield</span> <span>el</span>
  <span>....</span></code></pre>
</div>
</div>
<p>Maybe we do not want to write all the <span>for</span> loops in the iterator body manually.
One solution is to create a pragma <span>macro</span>, which creates the for
loops in the iterator body for us:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>macros</span>

<span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>

<span>macro</span> <span>addItFields</span><span>(</span><span>o</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>const</span> <span>fields</span> <span>=</span> <span>[</span><span>&#34;a&#34;</span><span>,</span> <span>&#34;b&#34;</span><span>,</span> <span>&#34;c&#34;</span><span>]</span>
  <span>expectKind</span><span>(</span><span>o</span><span>,</span> <span>nnkIteratorDef</span><span>)</span>
  <span># echo o.treeRepr</span>
  <span># echo o.params.treeRepr</span>
  <span>let</span> <span>objName</span> <span>=</span> <span>o</span><span>.</span><span>params</span><span>[</span><span>1</span><span>][</span><span>0</span><span>]</span>
  <span>for</span> <span>f</span> <span>in</span> <span>fields</span><span>:</span>
    <span>let</span> <span>node</span> <span>=</span>
      <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span>
        <span>nnkForStmt</span><span>.</span><span>newTree</span><span>(</span>
          <span>newIdentNode</span><span>(</span><span>&#34;el&#34;</span><span>),</span>
          <span>nnkDotExpr</span><span>.</span><span>newTree</span><span>(</span>
            <span>#newIdentNode(&#34;o&#34;),</span>
            <span>newIdentNode</span><span>(</span><span>$</span><span>objName</span><span>),</span>
            <span># newIdentNode(&#34;b&#34;)</span>
            <span>newIdentNode</span><span>(</span><span>f</span><span>)</span>
          <span>),</span>
          <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span>
            <span>nnkYieldStmt</span><span>.</span><span>newTree</span><span>(</span>
              <span>newIdentNode</span><span>(</span><span>&#34;el&#34;</span><span>)</span>
            <span>)</span>
          <span>)</span>
        <span>)</span>
      <span>)</span>
    <span>insert</span><span>(</span><span>body</span><span>(</span><span>o</span><span>),</span> <span>body</span><span>(</span><span>o</span><span>).</span><span>len</span><span>,</span> <span>node</span><span>)</span>
  <span>result</span> <span>=</span> <span>o</span>
  <span>#echo result.repr</span>

<span>iterator</span> <span>items</span><span>(</span><span>o</span><span>:</span> <span>O</span><span>):</span> <span>int</span> <span>{.</span><span>addItFields</span><span>.}</span> <span>=</span>
  <span>discard</span>

<span>#dumpAstGen:</span>
<span>#  iterator xitems(o: O): int =</span>
<span>#    for el in o.a:</span>
<span>#      yield el</span>

<span>var</span> <span>ox</span><span>:</span> <span>O</span>
<span>ox</span><span>.</span><span>a</span><span>.</span><span>add</span><span>(</span><span>1</span><span>)</span>
<span>ox</span><span>.</span><span>b</span><span>.</span><span>add</span><span>(</span><span>2</span><span>)</span>
<span>ox</span><span>.</span><span>c</span> <span>=</span> <span>@[</span><span>5</span><span>,</span> <span>7</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>]</span>

<span>for</span> <span>l</span> <span>in</span> <span>ox</span><span>.</span><span>items</span><span>:</span>
  <span>echo</span> <span>l</span></code></pre>
</div>
</div>
<p>We start again with a <span>dumpAstGen()</span> call which shows us the shape of the <span>for</span> loop node.
In that node we only have to replace two <span>newIdentNode()</span> calls so that the fields names can be provided
by iterating over an <span>array</span> of <span>strings</span>, and the <span>object</span> name is taken from the iterator parameter.
To get the object name, we first use <span>o.treeRepr</span> to see the whole parameter structure, and then
<span>params.treeRepr</span> to get the structure of the parameters passed to our iterator. Using subscript operators
we get the actual <span>object</span> name. We insert each new node that we create in the for loop with a call of
<span>insert(body(o), body(o).len, node)</span> as new last node in the body of the iterator.
We can create a more flexible variant of our above <span>macro</span>, when we pass
the actual field names as additional parameter to the pragma <span>macro</span>:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>macros</span>

<span>type</span>
  <span>O</span> <span>=</span> <span>object</span>
    <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>:</span> <span>seq</span><span>[</span><span>int</span><span>]</span>

<span>macro</span> <span>addItFields</span><span>(</span><span>fields</span><span>:</span> <span>openArray</span><span>[</span><span>string</span><span>]</span><span>;</span> <span>o</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>expectKind</span><span>(</span><span>o</span><span>,</span> <span>nnkIteratorDef</span><span>)</span>
  <span>let</span> <span>objName</span> <span>=</span> <span>o</span><span>.</span><span>params</span><span>[</span><span>1</span><span>][</span><span>0</span><span>]</span>
  <span>for</span> <span>f</span> <span>in</span> <span>fields</span><span>:</span>
    <span>let</span> <span>node</span> <span>=</span>
      <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span><span>nnkForStmt</span><span>.</span><span>newTree</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;el&#34;</span><span>),</span>
          <span>nnkDotExpr</span><span>.</span><span>newTree</span><span>(</span><span>newIdentNode</span><span>(</span><span>$</span><span>objName</span><span>),</span><span>newIdentNode</span><span>(</span><span>$</span><span>f</span><span>)),</span>
          <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span><span>nnkYieldStmt</span><span>.</span><span>newTree</span><span>(</span><span>newIdentNode</span><span>(</span><span>&#34;el&#34;</span><span>)))))</span>
    <span>insert</span><span>(</span><span>body</span><span>(</span><span>o</span><span>),</span> <span>body</span><span>(</span><span>o</span><span>).</span><span>len</span><span>,</span> <span>node</span><span>)</span>
  <span>result</span> <span>=</span> <span>o</span>

<span>iterator</span> <span>items</span><span>(</span><span>o</span><span>:</span> <span>O</span><span>):</span> <span>int</span> <span>{.</span><span>addItFields</span><span>(</span><span>[</span><span>&#34;a&#34;</span><span>,</span> <span>&#34;b&#34;</span><span>,</span> <span>&#34;c&#34;</span><span>]</span><span>).}</span> <span>=</span>
  <span>discard</span>

<span>var</span> <span>ox</span><span>:</span> <span>O</span>
<span>ox</span><span>.</span><span>a</span><span>.</span><span>add</span><span>(</span><span>1</span><span>)</span>
<span>ox</span><span>.</span><span>b</span><span>.</span><span>add</span><span>(</span><span>2</span><span>)</span>
<span>ox</span><span>.</span><span>c</span> <span>=</span> <span>@[</span><span>5</span><span>,</span> <span>7</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>]</span>

<span>for</span> <span>l</span> <span>in</span> <span>ox</span><span>.</span><span>items</span><span>:</span>
  <span>stdout</span><span>.</span><span>write</span> <span>l</span><span>,</span> <span>&#39; &#39;</span></code></pre>
</div>
</div>
<p>When we run this macro or the one before, we get</p>

</div>
<div>
<h3 id="_macros_to_generate_new_operator_symbols">Macros to generate new operator symbols</h3>
<p>Earlier in the book we have already learned how we can define
new <span>procs</span> and templates which can be used as operators.
In this section we will learn how we can create a <span>macro</span> that does not
only create an operator that can work on existing variables, but that can be used
to create new variables. In Nim we use the <span>var</span> or <span>let</span> keyword to
create new variables. Some other languages allow to create new variables on the fly
by using just &#34;=&#34;, &#34;:=&#34; or &#34;!=&#34; to create new variables.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>macros</span>

<span>dumpAstGen</span><span>:</span>
  <span>var</span> <span>xxx</span><span>:</span> <span>float</span>

<span>macro</span> <span>`</span><span>!=</span><span>`(</span><span>n</span><span>,</span> <span>t</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>let</span> <span>nn</span> <span>=</span> <span>n</span><span>.</span><span>repr</span>
  <span>let</span> <span>tt</span> <span>=</span> <span>t</span><span>.</span><span>repr</span>
  <span>nnkStmtList</span><span>.</span><span>newTree</span><span>(</span>
    <span>nnkVarSection</span><span>.</span><span>newTree</span><span>(</span>
      <span>nnkIdentDefs</span><span>.</span><span>newTree</span><span>(</span>
        <span># newIdentNode(&#34;xxx&#34;),</span>
        <span>newIdentNode</span><span>(</span><span>nn</span><span>),</span>
        <span># newIdentNode(&#34;float&#34;),</span>
        <span>newIdentNode</span><span>(</span><span>tt</span><span>),</span>
        <span>newEmptyNode</span><span>()</span>
      <span>)</span>
    <span>)</span>
  <span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>myVar</span> <span>!=</span> <span>int</span>
  <span>myVar</span> <span>=</span> <span>13</span>
  <span>echo</span> <span>myVar</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>typeof</span><span>(</span><span>myVar</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Again <span>dumpAstGen()</span> shows us the structure of the needed AST.
We use <span>repr()</span> to get the <span>string</span> representation of the two
<span>macro</span> arguments and replace in the <span>dumpAstGen()</span> output the arguments of the <span>newIdentNode()</span>
calls with that values. When we compile and run above program we get</p>

<p>For the case that we should really intend to use such a <span>macro</span> in our own
code, we should of course add some code to the <span>macro</span> to check that
the passed arguments have the correct content.</p>
<p>References:</p>

</div>
</div>
</div>
<div>
<h2 id="_process_execution">Process execution</h2>
<div>
<p>In this section we will discuss how we can use multiple threads or Nim’s async/await
framework to avoid blocking IO (input/output) operations and to enable parallel code
execution on multiple physical CPU cores. The various forms of not strictly linear
and sequential program execution are also called multitasking or multi-threading.
Threading is generally the splitting of one path of actions into various sub-parts,
which can be processed in parallel or concurrent. On a CPU with multiple physical
cores, threads can be distributed between them, while on a CPU with only one core,
all threads have to run obviously alternating on that single core, which is called
concurrency. Parallel processing requires always dedicated physical hardware, that
is multiple CPUs, or a multi-core CPU consisting of two or more independent units
called cores.</p>
<p>As the CPUs of recent desktop computers often have already a few dozen of cores, and
GPUs may have thousands of them, it has become more and more important to distribute
computing tasks between all these cores to gain optimal performance. Dedicated
programming languages like <span>Chapel</span> or <span>Pony</span> have been developed for
this task, and most modern programming languages supports it. For older languages
like C extension like <span>OpenMP</span> for threading support have been developed.</p>
<p>The various forms of asynchronous operation were introduced due to the fact that some
input and output operations and network requests can be very slow compared to the
data processing rate of the CPU. It would be very wasteful when the CPU has to be
idle while a slow network data transfer or a floppy disk operation is performed.
Actually asynchronous operation was already done long before the first multi-core
CPUs were available.</p>
<p>While Nim has already good support for threading and asynchronous- and parallel
processing, all this is still some work in progress, so things may further improve in
future.</p>
<p>When we launch a computer program on our desktop PC, then the operating system creates an
instance of a new process, sometimes also called a task, to execute the application.
Each process is strongly separated from other processes that may also running on the
computer, each process has its own memory regions (RAM) that it may use, and when one
process should crash for some reason other processes are not concerned. Processes
can have various states defined by the OS, this includes some form of running, idle,
ready, waiting or halted. A process executes one or multiple threads, which can run
concurrent or parallel on multiple physical CPU cores. All the threads of one single
process can use common resources and access common variables, which enables data
exchange between threads, with some restrictions. Data exchange between different,
separated processes is not that easy, but it is also possible by use of
<span>inter-process-communication</span> protocols. Early PC operating systems executed only one
process at a time, sometimes the user was able to switch between multiple launched
processes. Modern operating systems do a fast switching between all the ready processes, so that
the user gets the feeling that all of them are running in parallel, even when the CPU
has only one physical core. The fast switching between processes is called
multitasking or concurrent execution. Unfortunately these two terms are a bit
misleading, as they seems to imply true parallel execution on multiple physical CPU
cores. But the term concurrency actually only indicates the fast switching process — for a few micro-second one process may be executed, then an automatic task switch occurs,
which includes saving and restoring of all the CPU registers and states, and the next
process is executed again for a few micro-second. This form of concurrency was already a big
progress for the desktop PC, as it was possible to run processes with a heavy work
load, like a compiler, while the user was still able to use his text editor or web
browser without noticing serious delays for key and mice input or display updates.
Concurrency is generally supported by smart hardware which can interrupt the current
work of the CPU to temporary execute a different code segment. Hardware like disc
controllers or network cards have its own data buffers or can access parts of the RAM
directly by <span>DMA (Direct Memory Access)</span> and notice the CPU by so called
<span>interrupt signals</span> when a buffer is full (or empty) or when another condition
is met, e.g. when new network data are available. This interrupt system can
drastically improve performance and throughput, as active waiting in polling busy
loops for new network or disk data can be avoided — the CPU is free to process one
of the other waiting processes until interrupt signals indicate filled/empty data
buffers or other conditions that needs active CPU intervention.</p>
<p>This form of (hardware interrupt driven) concurrency needs generally some software
support, e.g. the Linux kernel may use the <span>epoll</span> system for I/O event
notifications. Initially it was a common practice to connect so called
<span>callback functions</span> to interrupt driven signals, e.g. a callback function was
invoked whenever some network data packages has arrived. Some C programs and system
libraries work still this way, for example the <span>glib</span> library of the
<span>GTK GUI</span> toolkit. But use of callbacks can become difficult and confusing for
large applications, sometimes it was called a <span>&#34;callback hell&#34;</span>. So languages
like Java, JavaScript or Python introduced a framework called <span>async/await</span> to
simplify the process of writing non blocking asynchronous software. The async/await
framework actually hides the use of callbacks or use of system functions like epoll
from the user. This asynchronous programming style has gained some popularity due to
the fact that many programs perform a lot of network communication, where data is
transferred often slow compared to the processing power of the CPU. The Nim standard
library provides an async/await framework which can be used in a similar way as that
of Python, and the external Chronos package of <span>Status corp.</span> offers one more
similar package. Additional, there was a discussion of some of the Nim developers to
support or replace the async/await framework with a more flexible CPS based one. We
should mention, that async/await has it drawbacks — its internal working is
difficult, its usage is not always easy, and the user has to be careful when using
asynchronous and synchronous functions together. Async/await was definitely the best
option when desktop PCs had only one single CPU core, but with the arrival of
multi-core CPUs the importance of asynchronous operations has become less important,
as using many threads running in parallel has become an alternative solution. It is
said that asynchronous program execution has less overhead than just using parallel
processing on multiple cores, that may be one reason why asynchronous programming is
still very popular.</p>

<p>For Nim we have many different ways to do parallel program execution, and for the
async/await framework of Nim’s standard library the <span>chronos</span> alternative
implementation is available. Creating new threads, which are executed in parallel
when the CPU has multiple physical cores, is supported by the <span>threads</span> module.
Additional the Nim standard library provides the <span>threadpool</span> module, which can
create a pool of threads, which may be used by the <span>spawn</span> construct or the
<span>parallel</span> keyword. Additional, external packages like <span>weave</span> can be
used for high performance parallel processing. And finally, when we use the C
compiler backend, we may also use the parallel construct of the OpenMP C library.</p>
<p>Some other programming languages like Lua or Go offer also virtually (green) threads,
or coroutines and fibers, and some languages use the CPS system for a very flexible
parallel and asynchronous framework. Maybe Nim will support that also in the future.</p>
<p>The biggest problem of high performance parallel data processing is the exchange of
data between threads, which has to be performed with much care to avoid data
corruption by uncoordinated random access or race conditions. For this mutexes, locks
and atomic operations can be used to control the access of common variables, or
<span>Channels</span> can be used to send data from one thread to another one. Another
problem for parallel thread execution can result from the Garbage Collector. For a
system design, where a single GC accesses all data of a process, it can be necessary
to stop all the threads of a process while the GC does its work. Nim is using for
each thread a separate heap area and a thread local GC, so other threads can continue
their work while the GC cleans up the data of one single thread. The problem of
passing data between treads still exists, but the new ARC/ORC memory management
system may further improve the situation.</p>
<p>In the following sections of the book, we will first demonstrate a few ways to use
multiple threads, which will run in parallel when there are more than one physical
CPU core available. After that, we will investigate basic async/await operations and
show how we can send data from one thread to another by use of the <span>channels</span> module.</p>

<div>
<h3 id="_module_threadpool">Module threadpool</h3>
<p>Creating new threads is always some overhead, so it can make sense to create a pool
of threads, which we then can use to executes parts of our program.</p>
<div>
<h4 id="_using_spawn_to_execute_a_proc_by_one_thread_of_the_pool">Using spawn to execute a proc by one thread of the pool</h4>
<p>As a first very simple example we will show how we can use the <span>spawn</span>
procedure of the <span>threadpool</span> module to request the execution of a regular
proc. This way we create not really a new thread, but we add our <span>proc</span> to a list of
<span>procs</span> to execute. When one of the threads in the pool is idle, then our <span>proc</span> is
immediately executed by a thread, otherwise the execution of our <span>proc</span> may be delayed
until a thread is ready to execute it. All the threads of the pool are distributed
among the physical cores of the CPU, so we can really execute <span>procs</span> in parallel. We
have to compile the code using <span>spawn()</span> with the <span>--d:threads=on</span>
option:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>threadpool</span>
<span>proc </span><span>sum</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>):</span> <span>int</span> <span>=</span>
  <span>var</span> <span>j</span> <span>=</span> <span>0</span>
  <span>while</span> <span>j</span> <span>&lt;</span> <span>i</span><span>:</span>
    <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span>result</span> <span>+=</span> <span>j</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>a</span><span>:</span> <span>FlowVar</span><span>[</span><span>int</span><span>]</span> <span>=</span> <span>spawn</span> <span>sum</span><span>(</span><span>1e7.</span><span>int</span><span>)</span>
  <span>var</span> <span>b</span> <span>=</span> <span>spawn</span> <span>sum</span><span>(</span><span>1e7.</span><span>int</span><span>)</span>
  <span>echo</span> <span>^</span><span>a</span> <span>,</span> <span>&#34; &#34;</span><span>,</span> <span>^</span><span>b</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The <span>spawn()</span> function executes an ordinary Nim function by a thread of the
pool. Note that syntactically we do not pass a function and the functions arguments
to <span>spawn</span>, but an expression, which is the the actual call of the <span>proc</span>!
<span>Spawn()</span> returns immediately a variable of <span>FlowVar[T]</span> type, which is
a container type that can store the result of our passed function. In the example
above we used FlowVar[int] as our <span>proc</span> <span>sum</span> returns an integer value, but of
course the generic <span>FlowVar[T]</span> type works for other data types as well,
including sequence and object types. As the instances of <span>FlowVar[T]</span> type
are returned immediately by <span>spawn()</span>, these container variables may be empty
initially. We may then use functions like <span>isReady()</span> from the
<span>threadpool</span> module to test if the <span>FlowVar[T]</span> variable contains
already the result data, or we can do a blocking wait for the result of our <span>proc</span> with
the <span>^</span> operator. The <span>^</span> operator applied to the <span>FlowVar[T]</span>
variable waits for the thread to finish the execution of our <span>proc</span> and then returns
the actual result. If the thread is already finished when we apply the <span>^</span>
operator, we get the result immediately. As <span>^</span> does a blocking wait, it may
look as there would not be much benefit, but of course we can launch a number of
threads with <span>spawn</span>, which can be processed in parallel, and then we wait
with <span>^</span> on all of the results.</p>
<p>In the example above we use a plain <span>proc</span> which sums up the first <span>i</span> natural
numbers, very similar to our very first example program in part I of the book. We
use <span>spawn()</span> to launch two instances of that <span>proc</span>, and then wait for the
results with the <span>^</span> operator applied on the flowvar. If your PC has more than
one physical CPU core, then both <span>proc</span> instances should be running in parallel, taking
only the total time of one single run. You may compile and launch above code with
<span>nim c --threads:on t.nim; time ./t</span> to see the execution time, then comment
out the second <span>spawn</span> call as well as the <span>echo()</span> call for
<span>Flowvar</span> <span>b</span> and compile and run timed again. Times should be nearly
identical when your PC has at least two CPU cores, indicating true parallel
execution. Of course, launching multiple times the same <span>proc</span> with the same data makes
not much sense, but in real life we could launch it with different data, or we could
use different <span>procs</span>.</p>
<p>As one more example for the use of <span>spawn()</span>, let us investigate how we can
avoid the blocking behaviour of the <span>readLine()</span> <span>proc</span> that we used earlier in
the book. Without special care, a call of <span>readLine()</span> blocks the main thread
of our process, so our program would not be able to do some useful work or to update
the display until the user terminates his textual input request by pressing the
return key. One possible option to avoid a blocking request for user input may be
the use of the async/await framework, but that may not work well for the current Nim
implementation. So let us just use <span>spawn</span> to execute <span>readLine()</span> on
one of the threads of the pool:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>threadpool</span>
<span>from</span> <span>std</span><span>/</span><span>os</span> <span>import</span> <span>sleep</span>
<span>proc </span><span>doSomeWork</span> <span>=</span>
  <span>echo</span> <span>&#34;not really working that hard...&#34;</span>
  <span>sleep</span><span>(</span><span>1000</span><span>)</span> <span># sleep 1000 ms</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>userInput</span><span>:</span> <span>FlowVar</span><span>[</span><span>string</span><span>]</span> <span>=</span> <span>spawn</span> <span>readLine</span><span>(</span><span>stdin</span><span>)</span>
  <span>while</span> <span>not</span> <span>userInput</span><span>.</span><span>isReady</span><span>:</span>
    <span>doSomeWork</span><span>()</span>
  <span>echo</span> <span>&#34;You finally entered: &#34;</span><span>,</span> <span>^</span><span>userInput</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>In this example we use <span>spawn()</span> to execute the <span>readLine()</span> function
of Nim’s standard library by a thread of the <span>treadpool</span> module. We use the
function <span>isReady()</span> to test if the user input is already available, and call
a worker procedure if there is no input yet. As we have no real work to do, that
proc just echos a messages and calls <span>os.sleep()</span> to create a delay. Note that
we use the <span>echo()</span> call in <span>doSomeWork()</span> only to show what is going
on — it is obvious that the repeated printed message would interfere with the user
input echoed by the terminal window. Actually this example is not really that nice,
but it shows you the use of <span>isReady()</span> and at least one possible way to
request user input without blocking the whole app.</p>
</div>
<div>
<h4 id="_the_parallel_statement">The parallel statement</h4>
<p>With the <span>parallel</span> statement the <span>threadpool</span> module offers one more way
to use threads to process data in parallel. While the <span>parallel</span> statement is
already available in Nim since many years, it was recently labeled as
<span>experimental feature</span>, so we have to use the <span>{.experimental.}</span> pragma
to use it. And the detailed description is currently only available in the
experimental section of the manual:
<a href="https://nim-lang.org/docs/manual_experimental.html#parallel-amp-spawn-parallel-statement">https://nim-lang.org/docs/manual_experimental.html#parallel-amp-spawn-parallel-statement</a></p>
<p>With the <span>parallel</span> statement is is easily possible to process large data, e.g.
arrays or sequences, in parallel. The compiler proves the data access for us to
avoid data races or otherwise invalid operations. As a very simple example we will
sum up the elements of an integer <span>array</span> by use of two threads running in
parallel — when more then one physical CPU core is available:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>threadpool</span>
<span>{.</span><span>experimental</span><span>:</span> <span>&#34;parallel&#34;</span><span>.}</span>

<span>proc </span><span>sum</span><span>(</span><span>i</span><span>,</span> <span>j</span><span>:</span> <span>int</span><span>;</span> <span>a</span><span>:</span> <span>array</span><span>[</span><span>8</span><span>,</span> <span>int</span><span>]</span><span>):</span> <span>int</span> <span>=</span>
  <span>for</span> <span>k</span> <span>in</span> <span>i</span> <span>..</span> <span>j</span><span>:</span>
    <span>result</span> <span>+=</span> <span>a</span><span>[</span><span>k</span><span>]</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>a</span><span>:</span> <span>array</span><span>[</span><span>8</span><span>,</span> <span>int</span><span>]</span>
  <span>for</span> <span>i</span> <span>in</span> <span>a</span><span>.</span><span>low</span> <span>..</span> <span>a</span><span>.</span><span>high</span><span>:</span>
    <span>a</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>i</span>

  <span>var</span> <span>s1</span><span>,</span> <span>s2</span><span>:</span> <span>int</span>
  <span>parallel</span><span>:</span>
    <span>s1</span> <span>=</span> <span>spawn</span> <span>sum</span><span>(</span><span>0</span><span>,</span> <span>3</span><span>,</span> <span>a</span><span>)</span>
    <span>s2</span> <span>=</span> <span>spawn</span> <span>sum</span><span>(</span><span>4</span><span>,</span> <span>7</span><span>,</span> <span>a</span><span>)</span>
  <span>echo</span> <span>s1</span><span>,</span> <span>&#34; + &#34;</span><span>,</span> <span>s2</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>Inside the parallel block, we use again <span>spawn</span> to launch a function which is
then executed by a thread of the threadpool. The <span>sum()</span> function in our
example code sums up a range of <span>array</span> elements. When <span>spawn()</span> is
used inside a <span>parallel</span> block, then its semantic is different: Instead of a
<span>FlowVar[T]</span> <span>spawn()</span> now returns directly the result of the called
proc. We can save these results in ordinary variables and access them freely after
the parallel block. In the above case we would finally sum up the individual result
to get the total sum of all the array elements.</p>
<p>Our example code above is kept very simple by intent to clearly show the principle
use. You may try to modify it to work on sequences with arbitrary runtime sizes
instead of a fixed sized array, and to use more than two threads. For all the details
of the <span>threadpool</span> module you should of course consult is documentation.</p>
</div>
</div>
<div>
<h3 id="_using_the_threads_module_to_create_new_threads">Using the threads module to create new threads</h3>
<p>When for some reason we can not use the <span>threadpool</span> module, or we need more
control over the various threads, then we can create our own treads:</p>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>sum</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>{.</span><span>thread</span><span>.}</span> <span>=</span>
  <span>var</span> <span>j</span><span>,</span> <span>result</span><span>:</span> <span>int</span>
  <span>while</span> <span>j</span> <span>&lt;</span> <span>i</span><span>:</span>
    <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span>result</span> <span>+=</span> <span>j</span>
  <span>echo</span> <span>result</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>th1</span><span>,</span> <span>th2</span><span>:</span> <span>Thread</span><span>[</span><span>int</span><span>]</span>
  <span>createThread</span><span>(</span><span>th1</span><span>,</span> <span>sum</span><span>,</span> <span>1e7.</span><span>int</span><span>)</span>
  <span>createThread</span><span>(</span><span>th2</span><span>,</span> <span>sum</span><span>,</span> <span>1e7.</span><span>int</span><span>)</span>
  <span>joinThreads</span><span>(</span><span>th1</span><span>,</span> <span>th2</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<p>The <span>createThread()</span> procedure is provided by the <span>threads</span> module,
which is part of the <span>system</span> module — for that reason we do not have to
explicitly import it. The <span>proc</span> that we want to execute in its own, newly created
thread has to be annotated with the {.thread.} pragma and has to use one single
parameter. We pass the generic <span>Thread[T]</span> variable, the <span>proc</span> to execute and
the <span>proc</span> parameter to <span>createThread()</span>. The <span>Thread</span> variable must
have the same generic type as the parameter of the <span>proc</span> that we want to execute. In
our example that parameter type is a plain integer, but of course we can use other
data types including objects, tuples or container types like sequences.</p>
<p>As <span>createThread()</span> does not return a result, we call <span>echo()</span> in our
<span>sum()</span> <span>proc</span> to show what is going on. Actually calling <span>echo()</span> from
within a <span>proc</span> running as a thread may be not a good idea, as multiple <span>echo()</span>
calls from different threads may interfere. We may use the <span>locks</span> module to
make the output operation atomic, but to keep our example short and simple we ignore
that problem for now. The code above creates two newly created threads, which in our
case run the same <span>proc</span> with the same data. If there is more than one CPU core
available, then the two threads should be executed in parallel by the OS. After
launching our new treads, we can use the <span>joinThreads()</span> procedure to wait for
the termination of all treads — we should generally do that before our app
terminates itself.</p>
</div>
<div>
<h3 id="_using_channels_for_communication_between_threads">Using Channels for communication between Threads</h3>
<p>When we use the <span>threadpool</span> and <span>spawn()</span> to execute a function by one
of the threads of the pool, we get immediately the result of the executed function
back when the work of the function is done.</p>
<p><span>Threads</span> created with the <span>createThread()</span> function of the
<span>threads</span> module do not directly return a result but may be executed for a long
time period, often for the whole lifetime of the main process. Generally it is
necessary to exchange messages and data between these types of threads — among
multiple child threads themselves or among them and the process’s main thread. For
this message- and data-exchange <span>Channels</span> can be used. Nim’s Channels use
internally a <span>queue</span> for sending data from one thread to another thread. A
<span>queue</span> is a first-in-first-out (FIFO) data structure — items put in first
will also be extracted first. That way the receiving thread will receive the items
in the same order as the sending thread has sent them.</p>
<p>The generic <span>Channel[T]</span> data type and the functions to use it are provided by
the <span>system</span> module, so we do not need to import them. Channels should be used only for
<span>Threads</span> of the <span>threads</span> module, but not for the hidden threads of the
<span>threadpool</span> module. <span>Channels</span> allow to send messages and data only in
one direction, for bidirectional communication we would need two separate channels.
Variables of the <span>Channel</span> data type are generally defined at the global
scope, to avoid problems with the thread local garbage collector, and the generic
type of the <span>Channels</span> determines the data type of the messages that we can
send through the <span>Channel</span>. The sent data is deeply copied by the Channel,
which may be not that efficient for large data packages.</p>
<p>In the code below we will present a very simple example for the use of one single
<span>Channel</span>. The <span>proc</span> <span>sum()</span> sums up again the first <span>n</span> natural
integer numbers, but this time the function sums up the numbers in chunks, and send
the sum of each chunk over the <span>Channel</span> to the parent thread:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>ch</span><span>:</span> <span>Channel</span><span>[</span><span>int</span><span>]</span>
<span>proc </span><span>sum</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>{.</span><span>thread</span><span>.}</span> <span>=</span>
  <span>var</span> <span>j</span><span>,</span> <span>res</span><span>:</span> <span>int</span>
  <span>while</span> <span>j</span> <span>&lt;</span> <span>i</span><span>:</span>
    <span>inc</span><span>(</span><span>j</span><span>)</span>
    <span>res</span> <span>+=</span> <span>j</span>
    <span>if</span> <span>j</span> <span>mod</span> <span>4</span> <span>==</span> <span>0</span><span>:</span>
      <span>ch</span><span>.</span><span>send</span><span>(</span><span>res</span><span>)</span>
      <span>res</span> <span>=</span> <span>0</span>
  <span>ch</span><span>.</span><span>send</span><span>(</span><span>res</span><span>)</span> <span># send the remainder</span>
  <span>ch</span><span>.</span><span>send</span><span>(</span><span>0</span><span>)</span> <span># send zero to indicate termination</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>th</span><span>:</span> <span>Thread</span><span>[</span><span>int</span><span>]</span>
  <span>ch</span><span>.</span><span>open</span><span>()</span>
  <span>createThread</span><span>(</span><span>th</span><span>,</span> <span>sum</span><span>,</span> <span>10</span><span>)</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>let</span> <span>r</span> <span>=</span> <span>ch</span><span>.</span><span>recv</span><span>()</span>
    <span>if</span> <span>r</span> <span>==</span> <span>0</span><span>:</span>
      <span>break</span>
    <span>echo</span> <span>&#34;Received: &#34;</span><span>,</span> <span>r</span>
  <span>joinThreads</span><span>(</span><span>th</span><span>)</span>
  <span>ch</span><span>.</span><span>close</span><span>()</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
<div>
<div>
<pre># Expected output:
Received: 10
Received: 26
Received: 19</pre>
</div>
</div>
<p>The <span>proc</span> <span>sum()</span> sums up continuously 4 more numbers, and then sends the
partial sum into the channel. The generic <span>Channel[int]</span> variable <span>ch</span>
is defined in global scope. In the <span>main()</span> <span>proc</span> we create the child thread,
open the <span>Channel</span> and read the <span>Channel</span> data with calls to
<span>recv()</span> until we get a zero value as terminating condition. Finally we call
<span>joinThreads()</span> to ensure that the child thread was really terminated and call
<span>close()</span> on the channel to close it. Note that in <span>sum()</span> we use an
additional <span>send()</span> call to send the last partial sum which may have less than
4 sumands and so may not have been sent. Instead of this additional <span>send()</span>
call in the <span>while</span> loop a condition like <span>if j mod 4 == 0 or i == j:</span>
could be used of course. When we are done we send the zero value to indicate to the
parent thread that we are done. This way the parent thread will not wait for more
data that never got send. In the <span>main()</span> <span>proc</span> we use <span>recv()</span> to read
the data from the <span>Channel</span>. <span>Recv()</span> would block if data is not yet
available. Instead we could use <span>tryRecv()</span> with returns a tuple, with the
field dataAvailable indicating if there is already something to read available. The
<span>open()</span> function accepts as second optional argument the number of items that
can be buffered in the internal items queue of the channel. If that limit is reached,
further calls to <span>send()</span> would block until the reading thread has read the
next item. If we restrict the maximum number of items in the <span>Channel</span>, we
may use instead of <span>send()</span> which may block when the channel is full,
<span>trySend()</span> which just returns <span>false</span> for this case without blocking.</p>
<p>Of course the code example from above makes not much sense, as there is no real
useful work done in parallel, and as there is no reason for <span>sum()</span> to not
just sum up all the elements immediately. But the example should show you the basic
use of <span>Channels</span>, including the need for having a terminating condition.</p>
</div>
<div>
<h3 id="_race_conditions">Race conditions</h3>
<p>A race condition may occurs when two or more threads attempt to read and write to a
shared resource at the same time. Such behavior can result in data corruption or
unpredictable results that are difficult to debug. Let us consider this tiny
example, where two threads increase the value of a global integer variable:</p>
<div>
<div>
<pre><code data-lang="nim"><span>var</span> <span>counter</span><span>:</span> <span>int</span>

<span>proc </span><span>incCounter</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>{.</span><span>thread</span><span>.}</span> <span>=</span>
  <span>for</span> <span>j</span> <span>in</span> <span>0</span> <span>..</span><span>&lt;</span> <span>i</span><span>:</span>
    <span>var</span> <span>local</span> <span>=</span> <span>counter</span>
    <span>local</span> <span>+=</span> <span>1</span>
    <span>counter</span> <span>=</span> <span>local</span>

<span>const</span> <span>N</span> <span>=</span> <span>1000</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>th1</span><span>,</span> <span>th2</span><span>:</span> <span>Thread</span><span>[</span><span>int</span><span>]</span>
  <span>createThread</span><span>(</span><span>th1</span><span>,</span> <span>incCounter</span><span>,</span> <span>N</span><span>)</span>
  <span>createThread</span><span>(</span><span>th2</span><span>,</span> <span>incCounter</span><span>,</span> <span>N</span><span>)</span>
  <span>joinThreads</span><span>(</span><span>th1</span><span>,</span> <span>th2</span><span>)</span>

<span>main</span><span>()</span>
<span>echo</span> <span>N</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>counter</span></code></pre>
</div>
</div>
<p>In the code above the two threads are running concurrent, and in parallel when your
CPU has at least two physical cores. Each thread increases the global counter
variable <span>N</span> times, so one may expect a final result of <span>2 * N</span>. But at
least when the threads are running in parallel the actual result will be a random
value between <span>N</span> and <span>2 *N</span>. The problem is, that the threads do not
increase the global counter in one atomic step, but create a local copy, increase the
value of the copy and write the value back. When the other thread had modified the
global counter variable in between, that modification is overwritten. When the two
threads would run not in parallel but concurrent on only one CPU core, then the
actual result may depend on the way how the OS does the actual task switching.</p>
<p>These kind of problems are sometimes called race conditions, because the actual
behaviour is determined by the order in which the various threads access the data.
In the example code the actual problem results from the copying into the local
variable and later copying the value back — a plain inc() executed on the global
variable may work. We used the local copy here to make the problem visible. Whenever
we would work in such an unordered way onto more complicated data like strings or
objects, we would get corrupted data. This example should raise your awareness to all
the problems which may occur when multiple threads access global data in an
uncontrolled way.</p>
<p>We have already learned about Channels, which provide a way to exchange data between
threads without the use of global variables. Other methods to protect global
variables from uncontrolled access which can lead to corrupted states are locks,
mutexes or semaphores. We will give an example to due access control by use of Locks
in the next section. In the example above we used as global data a primitive value
data type. Even more problems may occur, when we try to use global references data
types: In the past the Nim standard library provided special functions like
allocShared() to allocate pointer and reference data types that can be accessed from
multiple treads. But as Nim’s thread handling may change and improve in the future
further, we will not try to discuss all these details here. It should be enough that
you have a feeling for the problems that my arise from executing multiple threads
with shared data — for the details you should consult the documentation of Nim’s
standard library and the compiler manual.</p>
</div>
<div>
<h3 id="_guards_and_locks">Guards and Locks</h3>
<p>While Nim’s <span>Lock</span> data type and the corresponding functions are defined in
the <span>locks</span> module of the standard library, that module contains only minimal
explanations, so we have to consult the experimental section of the compiler manual.</p>
<p>In computer science, a lock or mutex (from mutual exclusion) is a synchronization
primitive that enforces limits on access to a resource when there are many threads of
execution. Before that resource is accessed, the lock is acquired, and after the
resource is accessed, it’s released. The simplest type of lock is a binary
semaphore. It provides exclusive access to the locked data. Following this
definition from Wikipedia, Nim’s locks seems to be actually binary semaphores.</p>
<p>Nim’s <span>Locks</span> are generally used together with the <span>guard</span> pragma, which
we can attach to a global variable that is accessed from more than one thread. With
the guard pragma attached, each thread has to first acquire the lock before it is
allowed to access that variable. If the lock is already acquired by another thread,
acquire blocks until that other thread releases the lock to indicate that it is done
with its access. Of course these possible blocking can decrease the total
performance, so each thread should acquire the lock only when it needs really access
to the protected data and release the lock as soon as possible.</p>
<p>We can use the template <span>withLock</span> to access the guarded global variable in a
block — <span>withLock()</span> acquires the given lock, and releases the lock again at
the end of the block. Accessing a guarded variable outside a <span>withLock()</span>
block would give a compile time error.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>locks</span>
<span>var</span> <span>lock</span><span>:</span> <span>Lock</span>
<span>var</span> <span>counter</span> <span>{.</span><span>guard</span><span>:</span> <span>lock</span><span>}:</span> <span>int</span>

<span>proc </span><span>incCounter</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>{.</span><span>thread</span><span>.}</span> <span>=</span>
  <span>for</span> <span>j</span> <span>in</span> <span>0</span> <span>..</span><span>&lt;</span> <span>i</span><span>:</span>
    <span>withLock</span> <span>lock</span><span>:</span>
      <span>var</span> <span>local</span> <span>=</span> <span>counter</span>
      <span>local</span> <span>+=</span> <span>1</span>
      <span>counter</span> <span>=</span> <span>local</span>

<span>const</span> <span>N</span> <span>=</span> <span>1000</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>var</span> <span>th1</span><span>,</span> <span>th2</span><span>:</span> <span>Thread</span><span>[</span><span>int</span><span>]</span>
  <span>createThread</span><span>(</span><span>th1</span><span>,</span> <span>incCounter</span><span>,</span> <span>N</span><span>)</span>
  <span>createThread</span><span>(</span><span>th2</span><span>,</span> <span>incCounter</span><span>,</span> <span>N</span><span>)</span>
  <span>joinThreads</span><span>(</span><span>th1</span><span>,</span> <span>th2</span><span>)</span>

<span>main</span><span>()</span>
<span>echo</span> <span>N</span><span>,</span> <span>&#34;: &#34;</span><span>,</span> <span>counter</span></code></pre>
</div>
</div>
<p>When you now run the above code, <span>counter</span> should always have the desired value
<span>2 * N</span>. Note that replacing the <span>withLock</span> with a plain
<span>acquire()</span> and <span>release()</span> pair seems not to work for locks that are
used as guards — but actually there is no reason to do that, the <span>withLock</span>
block is easier to use and ensures that <span>acquire()</span> and <span>release()</span> is
always used in matching pairs.</p>
</div>
<div>
<h3 id="_exceptions_in_threads">Exceptions in Threads</h3>
<p>Whenever a <span>proc</span> that is running as its own thread is raising an uncaught exception,
then the whole process is terminated and a stack trace with the corresponding error
message is displayed in the terminal window. This applies not only to the threads of
the <span>threads</span> module, but also when the <span>spawn()</span> function is applied to
run functions by one of the threads in the pool.</p>
<p>References</p>

</div>
</div>
</div>
<div>
<h2 id="_code_execution_with_asyncawait">Code execution with async/await</h2>
<div>
<p>The <span>async/await</span> framework allows asynchronous code execution by use of only
one single thread — the currently active thread can suspend itself when waiting for
data or other events.</p>
<p>Async/await is mostly used for IO bound tasks, where a significant amount of time is
spent by waiting for data to become available. In such a scenario multi-threading,
even when the various threads run parallel on multiple physical CPU cores, would not
really help to improve the throughput or performance.</p>
<p>The initial idea of asynchronous operations was to avoid blocking the CPU for longer
time periods during slow network and IO (input/output) requests. Indeed that made
much sense in times when we read data from floppy disks or magnetic tapes, and send
data with 300 baud modems. And when true parallel thread execution was not possible
at all as CPUs had only one core, and computers with more than one CPU where very
expensive and not used by ordinary people.</p>
<p>Today, with network data rates of up to one Gbit/s for our smartphones or home
networks, and SSD devices which have data transfer rates of multiple Gbit/s, it is
not that easy to motivate the use of asynchronous operations at all. Still for server
applications like online shops or communication platforms used by thousands of people
simultaneously, where network throughput is the limiting factor and delays have to be
avoided, the use of async/await may actually provide the best performance. And it can
be combined with threading and parallel program execution when needed.</p>
<p>Asynchronous program execution can work with only one thread running on a single CPU
core due to the fact that some hardware like network cards or disk controllers can
read or write small data blocks autonomously without active CPU support, using their
own data buffers or writing to parts of the system RAM by use of DMA (direct memory
access). These hardware can signal to the CPU when buffers are full or empty, or when
all data transfer is completed, so that the CPU may copy the buffer content or start
to process or display the data. As this way the external hardware interrupts the
current CPU work, these signals are called hardware interrupts. Operation systems
generally provide various levels of support for these interrupt-driven data transfer
operations, e.g. the epoll framework of the Linux kernel or Kqueue, the scalable
event notification interface in FreeBSD.</p>
<p>For user programs, one solution for doing asynchronous IO by watching for hardware
interrupt signals is to connect callback functions to these interrupt signal. That
way the program can launch an IO operation, and perform other work, until that work
is interrupted by a call of the callback function. As most programming languages
support the use of callback functions, these form of asynchronous IO is widely
supported by software libraries, e.g. the glib library of the GTK GUI toolkit. As
doing asynchronous IO with callback can get complicated when we have a lot of nested
IO operations, the async/await workflow was introduced, which allows asynchronous
code to be written in a synchronous style.</p>
<p>The async/await pattern is a syntactic feature of many programming languages that
allows an asynchronous, non-blocking function to be structured in a way similar to an
ordinary synchronous function. It is semantically related to the concept of a
coroutine and is often implemented using similar techniques, and is primarily
intended to provide opportunities for the program to execute other code while waiting
for a long-running, asynchronous task to complete, usually represented by promises or
similar data structures. The
programming language F# (pronounced F sharp) introduced a asynchronous workflows with
await points already in 2007 for the version 2.0 of the language. And in 2012
Microsoft released C# in version 5 with async/await support. Later languages like
Haskell, Python, JavaScript and TypeScript, Kotlin, Dart, Julia, Zig, Swift and Rust
used the async/await pattern, and since 2020 it is also available for C++.</p>
<div>
<h3 id="_is_asyncawait_faster_than_multi_threading">Is async/await faster than multi-threading?</h3>
<p>For IO-bound task the use of async/await can actually have performance benefits.</p>
<p>The multi-threaded program execution, that we described in the previous sections, is
some form of preemptive multitasking, where switching between the active threads
occurs at arbitrary time intervals controlled by the OS. But the async/await pattern
is a form of co-operative multitasking, which provides the user with full control of
the code execution. We can pause the code execution by using the <span>await</span>
keyword when it really makes sense. e.g. when we have to wait for new data packets or
events, and immediately enable execution of a different code path.</p>
<p>As for this form of co-operative multitasking only the code execution path is
changed, but no switching between threads is necessary, additional overhead can be
avoided, and typical problems of multi-threading, like the passing of data between
different threads or race conditions do no exist.</p>
<p>So at least in theory the co-operative multitasking controlled by the async/await
pattern is more efficient, and for maximum performance it can be combined with
threading and parallel program execution.</p>
</div>
<div>
<h3 id="_nims_asynchronous_dispatcher">Nim’s asynchronous dispatcher</h3>
<p>The core elements of Nim’s async/await framework are provided by the modules
<span>std/asyncdispatch</span> and <span>std/asyncfutures</span>.</p>
<p>These modules provide a <span>dispatcher</span>, a generic <span>Future[T]</span> type
implementation, and the <span>async</span> macro which allows asynchronous code to be
written in a synchronous style with the <span>await</span> keyword.</p>
<p>The <span>asyncdispatch</span> module implements a global dispatcher (technically one per
thread) that is responsible for running the procedures that are registered with
it.</p>
<p>Build on top of these two modules there exists various modules for asynchronous
communication: Module <span>std/asyncnet</span> implements a high-level asynchronous
sockets API and <span>std/asynchttpserver</span> implements a high performance
asynchronous HTTP server. Some other modules like <span>std/httpclient</span> support
synchronous and asynchronous data transfers.</p>
<p>Nim’s async/await framework is not part of the language itself, but implemented with
macros and meta-programming and use of Nim’s iterators. The underlying
implementation is based on <span>epoll</span> on Linux, IO Completion Ports on Windows
and <span>select</span> on other operating systems.</p>
<p>Currently Nim’s async/await uses only one single thread on its own, but applications
can combine it with multiple parallel running threads. As an alternative
implementation we could use <a href="https://github.com/status-im/nim-chronos">https://github.com/status-im/nim-chronos</a>, which provides
similar functionality.</p>
</div>
<div>
<h3 id="_asynchronous_procedures">Asynchronous procedures</h3>
<p>Asynchronous procedures are marked by the {.async.} pragma and must return a generic
<span>Future[T]</span> type or return no result at all. In the later case a <span>Future[void]</span> is assumed.
A <span>Future</span>, also called <span>Promise</span> in other languages, is a generic container type which holds a value
which is not yet available, but which may be available in the future.
So a <span>Future</span> has some similarity with the generic <span>FlowVar</span> type that we used as return types for
threads of Nim’s threadpool.</p>
<p>Inside asynchronous procedures the keyword <span>await</span> can be used to call other
asynchronous procedures or procedures which return a <span>Future</span> type.</p>
<p>The <span>await</span> keyword will suspend the code execution until the awaited
<span>Future</span> completes. After completion the asynchronous procedure will resume
its execution. During the period when an asynchronous procedure is suspended other
asynchronous procedures will be run by the dispatcher.</p>
<div>
<h4 id="_the_generic_futuret_data_type">The generic Future[T] data type</h4>
<p>The <span>Future[T]</span> data type, which is also called <span>Promise</span>,
<span>Delay</span> or <span>Deferred</span> in other programming languages, acts as a proxy
for a result that is initially unknown or unavailable.</p>
<p>We can think of a <span>Future[T]</span> as a container; initially it’s empty, and while
it remains empty we can’t retrieve its value. At some unknown point in time,
something is placed in the container and it is no longer empty and we can read out
its value. That is where the name <span>Future</span> comes from.</p>
<p>Every asynchronous operation in Nim returns a <span>Future[T]</span> object, where the
<span>T</span> corresponds to the type of value that the <span>Future</span> promises to
store in the future. We don’t have to know that many details of the internal
structure or behaviour of the <span>Future[T]</span> data type, but we can easily
experiment with it without involving any actual asynchronous I/O operations. The code
below shows the behavior of a simple <span>Future[string]</span> object:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>asyncdispatch</span>

<span>proc </span><span>cb</span><span>(</span><span>f</span><span>:</span> <span>Future</span><span>[</span><span>string</span><span>]</span><span>)</span> <span>=</span>
  <span>echo</span> <span>&#34;executing callback: &#34;</span><span>,</span> <span>f</span><span>.</span><span>read</span>

<span>let</span> <span>f1</span><span>:</span> <span>Future</span><span>[</span><span>string</span><span>]</span> <span>=</span> <span>newFuture</span><span>[</span><span>string</span><span>]</span><span>()</span>
<span>echo</span> <span>f1</span><span>.</span><span>finished</span>

<span>f1</span><span>.</span><span>callback</span> <span>=</span> <span>cb</span>

<span>f1</span><span>.</span><span>complete</span><span>(</span><span>&#34;Nim and its future&#34;</span><span>)</span>
<span>#f1.fail(newException(ValueError, &#34;Future failed&#34;))</span></code></pre>
</div>
</div>
<p>We can create a new instance of the generic <span>Future[T]</span> data type with the
<span>newFuture[T]()</span> constructor, we can query if the instance variable is already
finished, and we can attach a callback function. Finally, we can call
<span>complete()</span> on it to set its value, which then automatically calls the
attached callback function. Or we can call <span>fail()</span> on it to set an exception,
which later is raised when someone tries to read its value.</p>
</div>
</div>
<div>
<h3 id="_simple_example">Simple example</h3>
<p>We will start our explanations with a very simple asynchronous program, which will
not do an actual asynchronous data transfer yet, but an asynchronous sleep (wait).
The asynchronous sleep called <span>sleepAsync()</span> actually behaves very similar to
the asynchronous data transfer functions, that is the execution of the actual code
path is suspended until a hardware condition is fulfilled, and the dispatcher
continues with the code execution.</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncdispatch</span><span>,</span> <span>times</span><span>]</span>
<span>from</span> <span>std</span><span>/</span><span>os</span> <span>import</span> <span>sleep</span>

<span>let</span> <span>to</span> <span>=</span> <span>epochTime</span><span>()</span>

<span>proc </span><span>tick</span><span>(</span><span>t</span><span>:</span> <span>string</span><span>):</span> <span>Future</span><span>[</span><span>void</span><span>]</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1</span><span>:</span>
    <span>os</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span> <span># sleep 100 ms</span>
    <span>echo</span> <span>&#34;tick &#34;</span><span>,</span> <span>t</span><span>,</span> <span>((</span><span>epochTime</span><span>()</span> <span>-</span> <span>to</span><span>)</span> <span>*</span> <span>1000</span><span>).</span><span>int</span><span>,</span> <span>&#34;ms&#34;</span>

<span>let</span> <span>f1</span><span>:</span> <span>Future</span><span>[</span><span>void</span><span>]</span> <span>=</span> <span>tick</span><span>(</span><span>&#34; AAA &#34;</span><span>)</span>
<span>let</span> <span>f2</span> <span>=</span> <span>tick</span><span>(</span><span>&#34; BBB &#34;</span><span>)</span>

<span>echo</span> <span>&#34;total time elapsed: &#34;</span><span>,</span> <span>epochTime</span><span>()</span> <span>-</span> <span>to</span></code></pre>
</div>
</div>
<p>In the code example above we import the <span>asyncdispatch</span> module and have
attached the {.async.} pragma to our <span>tick()</span> procedure. As the
<span>tick()</span> <span>proc</span> does not return any actual data, we use <span>Future[void]</span> as
return type — actually we could leave out the return type for this case. We call
<span>tick()</span> two times with different <span>string</span> arguments and use the
function <span>epochTime()</span> to measure the total execution time of our program.
When we compile and run the code we get this output:</p>
<div>
<div>
<pre>tick  AAA 100ms
tick  AAA 200ms
tick  BBB 300ms
tick  BBB 400ms
total time elapsed: 0.4007678031921387</pre>
</div>
</div>
<p>The result is not really surprising, as for each call of <span>proc</span> <span>tick()</span> the
loop in its body is executed two times, generating a <span>100 ms</span> delay for each
iteration. But the output will drastically change when we call instead of the
ordinary <span>sleep()</span> function the function <span>sleepAsync()</span> provided by the
<span>asyncdispatch</span> module:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncdispatch</span><span>,</span> <span>times</span><span>]</span>
<span>from</span> <span>std</span><span>/</span><span>os</span> <span>import</span> <span>sleep</span>

<span>let</span> <span>to</span> <span>=</span> <span>epochTime</span><span>()</span>

<span>proc </span><span>tick</span><span>(</span><span>t</span><span>:</span> <span>string</span><span>):</span> <span>Future</span><span>[</span><span>void</span><span>]</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>1</span><span>:</span>
    <span>await</span> <span>sleepAsync</span><span>(</span><span>100</span><span>)</span> <span># suspend code execution for 100 ms</span>
    <span>echo</span> <span>&#34;tick &#34;</span><span>,</span> <span>t</span><span>,</span> <span>((</span><span>epochTime</span><span>()</span> <span>-</span> <span>to</span><span>)</span> <span>*</span> <span>1000</span><span>).</span><span>int</span><span>,</span> <span>&#34;ms&#34;</span>

<span>let</span> <span>f1</span><span>:</span> <span>Future</span><span>[</span><span>void</span><span>]</span> <span>=</span> <span>tick</span><span>(</span><span>&#34; AAA &#34;</span><span>)</span>
<span>let</span> <span>f2</span> <span>=</span> <span>tick</span><span>(</span><span>&#34; BBB &#34;</span><span>)</span>

<span>echo</span> <span>f1</span><span>.</span><span>finished</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>f2</span><span>.</span><span>finished</span>
<span>echo</span> <span>&#34;time: &#34;</span><span>,</span> <span>epochTime</span><span>()</span> <span>-</span> <span>to</span>

<span>waitFor</span> <span>f1</span>
<span># waitFor f1 and f2 # wait for both futures to finish</span>

<span>echo</span> <span>f1</span><span>.</span><span>finished</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>f2</span><span>.</span><span>finished</span>
<span>echo</span> <span>&#34;total time elapsed: &#34;</span><span>,</span> <span>epochTime</span><span>()</span> <span>-</span> <span>to</span></code></pre>
</div>
</div>
<div>
<div>
<pre>false false
time: 9.72e-05
tick  AAA 100ms
tick  BBB 100ms
tick  AAA 200ms
tick  BBB 200ms
true true
total time elapsed: 0.20061</pre>
</div>
</div>
<p>The two calls of the <span>tick()</span> <span>proc</span> each returns nearly instantly a
<span>Future[void]</span> object, no waiting happens here. The use of the <span>await</span>
keyword in the <span>proc</span> body causes the <span>proc</span> to suspend its execution and control flow
returns to the calls site immediately. But at the same time the asynchronous
<span>tick()</span> <span>proc</span> got registered by the dispactcher loop, so that it can resume
its execution.</p>
<p>The returned <span>Future</span> object encapsulates the actual return type of the call — in this case only void — and gives us a reference that we can use to ask the
dispatcher whether our call has completed or not.</p>
<p>But futures can’t get resolved by themselves, we need to actually run the dispatcher
in order for any of the code registered with it to resume its execution. Remember all
of this is still running in a single thread of execution. There are many ways to run
the dispatcher, but in this case it is done by the <span>waitFor</span> call. When we
run <span>waitFor</span>, the dispatcher will run in a loop until the given future is
completed, and the <span>proc</span> which has returned that future is removed from the dispatcher
loop. <span>WaitFor</span> actually calls <span>poll()</span> in a loop until the future is
finished, and then returns the generic value of the future — in the code above
<span>waitFor</span> returns no actual result, as we used a <span>Future</span> of
<span>void</span> type.</p>
<p>We can use the operators <span>and</span> or <span>or</span> to combine multiple futures, in this
way we can wait until all of them or at least one of them completes. Note that the
dispatcher loops stops when waitFor() succeeds, so when we wait only for one future
and that one finished, then the dispatcher loop stops and other futures may stay
unfinished.</p>
<p>We can use the function <span>finished()</span> to check if a future variable is already
finished. When a future is finished it means that either the value that it holds is
now available or it holds an error instead. The latter situation occurs when the
operation to complete a future fails with an exception. We can distinguish between
the two situations with the <span>failed()</span> function. Future objects can also
store a callback procedure which will be called automatically once the future
completes, see the example in the previous section.</p>
<p>In our example code above we called <span>waitFor f1</span> — this is necessary to
actually execute the dispatcher loop, and to wait for the future <span>f1</span> to
complete. We could have used <span>waitFor f1 and f2</span>, or <span>waitFor f1 or f2</span>
to wait for completion of both futures or one of them. The result would be identical
in this case, as the <span>proc</span> that returns <span>f1</span> and <span>f2</span> is identical and
returns always after 2 loop iterations.</p>
<p>The important result of this modified code is, that the <span>proc</span> execution alternates,
and the total runtime of the program is only <span>0.2 ms</span>. The reason for this is,
as we already explained, that the use of the <span>await</span> keyword in our
<span>tick()</span> <span>proc</span> suspends the execution, and so immediately the next call of
<span>tick()</span> with <span>&#34;BBB&#34;</span> as argument is executed.</p>
<p>As one more simple example let us investigate this code, where two different
asynchronous <span>procs</span> are executed:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncdispatch</span><span>,</span> <span>times</span><span>]</span>

<span>let</span> <span>to</span> <span>=</span> <span>epochTime</span><span>()</span>

<span>proc </span><span>numbers</span><span>()</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>1</span> <span>..</span> <span>3</span><span>:</span>
    <span>await</span> <span>sleepAsync</span><span>(</span><span>250</span><span>)</span>
    <span>echo</span> <span>i</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>((</span><span>epochTime</span><span>()</span> <span>-</span> <span>to</span><span>)</span> <span>*</span> <span>1000</span><span>).</span><span>int</span><span>,</span> <span>&#34; ms&#34;</span>

<span>proc </span><span>letters</span><span>()</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>for</span> <span>i</span> <span>in</span> <span>&#39;a&#39;</span> <span>..</span> <span>&#39;e&#39;</span><span>:</span>
    <span>await</span> <span>sleepAsync</span><span>(</span><span>400</span><span>)</span>
    <span>echo</span> <span>i</span><span>,</span> <span>&#39; &#39;</span><span>,</span> <span>((</span><span>epochTime</span><span>()</span> <span>-</span> <span>to</span><span>)</span> <span>*</span> <span>1000</span><span>).</span><span>int</span><span>,</span> <span>&#34; ms&#34;</span>

<span>var</span>
  <span>n</span> <span>=</span> <span>numbers</span><span>()</span>
  <span>l</span> <span>=</span> <span>letters</span><span>()</span>
<span>echo</span> <span>&#34;start: &#34;</span><span>,</span> <span>((</span><span>epochTime</span><span>()</span> <span>-</span> <span>to</span><span>)</span> <span>*</span> <span>1000</span><span>).</span><span>int</span><span>,</span> <span>&#34; ms&#34;</span>
<span>waitFor</span> <span>sleepAsync</span><span>(</span><span>1500</span><span>)</span>
<span>echo</span> <span>&#34;done: &#34;</span><span>,</span> <span>((</span><span>epochTime</span><span>()</span> <span>-</span> <span>to</span><span>)</span> <span>*</span> <span>1000</span><span>).</span><span>int</span><span>,</span> <span>&#34; ms&#34;</span></code></pre>
</div>
</div>
<p>As both asynchronous <span>procs</span> use different arguments when they call
<span>sleepAsync()</span>, they are not executed strictly alternating, so the numbers 2
and 3 are printed with no letter in between:</p>
<div>
<div>
<pre>start: 0 ms
1 250 ms
a 400 ms
2 500 ms
3 751 ms
b 801 ms
c 1202 ms
done: 1501 ms</pre>
</div>
</div>
<p>In this example we do not call <span>waitFor()</span> directly on our actual asynchronous
<span>procs</span>, but on <span>sleepAsync()</span> from <span>asyncdispatch</span>. As the <span>procs</span>
<span>numbers()</span> and <span>letters()</span> got registered by the dispatcher, they are
executed by the dispatcher loop, but only as long as determined by <span>waitFor
sleepAsync(1500)</span>. So the execution of the dispatcher loops stops already before
<span>letters()</span> is really done, and letters <span>d</span> and <span>e</span> got never
printed. The fact that the printed time values can be a few ms larger than the
actual specified sleep times should not surprise us, as some more code is executed in
our <span>procs</span>, and as the dispatcher loop itself may need some tiny execution time. When
an exact timing should be required, we may use the <span>std/times</span> module to read
the exact time and adjust the actual delays. Also note that async/await as a
co-operative approach of multitasking also means that long running tasks can delay
the execution of other tasks unexpectedly: Imaging that in our code above the numbers
proc would contain a lot of additional code that takes more than 250 ms to run — that would confuse the whole timing scheme. As async/await is most often not used to
create actual delays, but for asynchronous network and IO operations, we will not
discuss the problems of exact timing here in detail. The linked paper of P. Munch
discusses this topic in some more detail and offers some possible solutions for more
accurate timings.</p>
</div>
<div>
<h3 id="_file_download">File download</h3>
<p>The module <span>std/httpclient</span> of Nim’s standard library provides procedures for
synchronous and asynchronous file transfer. Let us start with this simple synchronous
example to download two small text files from an URI:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/</span><span>httpclient</span>
<span>let</span> <span>client</span> <span>=</span> <span>newHttpClient</span><span>()</span>
<span>echo</span> <span>client</span><span>.</span><span>getContent</span><span>(</span><span>&#34;http://ssalewski.de/tmp/texttestpage1.txt&#34;</span><span>)</span>
<span>echo</span> <span>client</span><span>.</span><span>getContent</span><span>(</span><span>&#34;http://ssalewski.de/tmp/texttestpage2.txt&#34;</span><span>)</span></code></pre>
</div>
</div>
<p>We have uploaded the two plain text files to that location in advance, and when we
compile and run above code we should get:</p>
<div>
<div>
<pre>This is a plain two
lines test page.

This is one more two
lines test page.</pre>
</div>
</div>
<p>Nim’s API documentation for <span>std/httpclient</span> shows us how we can do the
download in an asynchronous way — at least for one single file:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncdispatch</span><span>,</span> <span>httpclient</span><span>]</span>
<span>proc </span><span>asyncProc</span><span>():</span> <span>Future</span><span>[</span><span>string</span><span>]</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>let</span> <span>client</span> <span>=</span> <span>newAsyncHttpClient</span><span>()</span>
  <span>return</span> <span>await</span> <span>client</span><span>.</span><span>getContent</span><span>(</span><span>&#34;http://ssalewski.de/tmp/texttestpage1.txt&#34;</span><span>)</span>
<span>echo</span> <span>waitFor</span> <span>asyncProc</span><span>()</span></code></pre>
</div>
</div>
<p>In this example we use an asynchronous HTTP client, for which the overloaded <span>proc</span>
<span>getContent()</span> returns a <span>Future[string]</span> in this case. The call of
<span>waitFor</span> waits for the download to finish and returns the actual content of
the future, which is a string containing the page content.</p>
<p>With the knowledge which we get from our previous example with <span>sleepAsync()</span>,
we can easily modify above code to download two files asynchronous:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncdispatch</span><span>,</span> <span>httpclient</span><span>]</span>
<span>proc </span><span>asyncProc</span><span>(</span><span>url</span><span>:</span> <span>string</span><span>):</span> <span>Future</span><span>[</span><span>string</span><span>]</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>return</span> <span>await</span> <span>newAsyncHttpClient</span><span>().</span><span>getContent</span><span>(</span><span>url</span><span>)</span>

<span>let</span> <span>f1</span> <span>=</span> <span>asyncProc</span><span>(</span><span>&#34;http://ssalewski.de/tmp/texttestpage1.txt&#34;</span><span>)</span>
<span>let</span> <span>f2</span> <span>=</span> <span>asyncProc</span><span>(</span><span>&#34;http://ssalewski.de/tmp/texttestpage2.txt&#34;</span><span>)</span>

<span>waitFor</span> <span>f1</span> <span>and</span> <span>f2</span> <span># this returns Future[void]</span>
<span>echo</span> <span>f1</span><span>.</span><span>read</span>
<span>echo</span> <span>f2</span><span>.</span><span>read</span></code></pre>
</div>
</div>
<p>The combination <span>f1 and f2</span> actually creates a new future of void type. We use
two variables <span>f1</span> and <span>f2</span> of string type, and read the content with the
<span>read()</span> <span>proc</span> when both futures are completed.</p>
</div>
<div>
<h3 id="_a_chat_server_application">A chat server application</h3>
<p>In the API documentation of the <span>std/asyncnet</span> module we find this example for
a very basic chat server application:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncnet</span><span>,</span> <span>asyncdispatch</span><span>]</span>

<span>var</span> <span>clients</span> <span>{.</span><span>threadvar</span><span>.}:</span> <span>seq</span><span>[</span><span>AsyncSocket</span><span>]</span>

<span>proc </span><span>processClient</span><span>(</span><span>client</span><span>:</span> <span>AsyncSocket</span><span>)</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>let</span> <span>line</span> <span>=</span> <span>await</span> <span>client</span><span>.</span><span>recvLine</span><span>()</span>
    <span>if</span> <span>line</span><span>.</span><span>len</span> <span>==</span> <span>0</span><span>:</span> <span>break</span>
    <span>for</span> <span>c</span> <span>in</span> <span>clients</span><span>:</span>
      <span>await</span> <span>c</span><span>.</span><span>send</span><span>(</span><span>line</span> <span>&amp;</span> <span>&#34;</span><span>\c</span><span>\L&#34;</span><span>)</span>

<span>proc </span><span>serve</span><span>()</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>clients</span> <span>=</span> <span>@[]</span>
  <span>var</span> <span>server</span> <span>=</span> <span>newAsyncSocket</span><span>()</span>
  <span>server</span><span>.</span><span>setSockOpt</span><span>(</span><span>OptReuseAddr</span><span>,</span> <span>true</span><span>)</span>
  <span>server</span><span>.</span><span>bindAddr</span><span>(</span><span>Port</span><span>(</span><span>12345</span><span>))</span>
  <span>server</span><span>.</span><span>listen</span><span>()</span>

  <span>while</span> <span>true</span><span>:</span>
    <span>let</span> <span>client</span> <span>=</span> <span>await</span> <span>server</span><span>.</span><span>accept</span><span>()</span>
    <span>clients</span><span>.</span><span>add</span> <span>client</span>

    <span>asyncCheck</span> <span>processClient</span><span>(</span><span>client</span><span>)</span>

<span>asyncCheck</span> <span>serve</span><span>()</span>
<span>runForever</span><span>()</span></code></pre>
</div>
</div>
<p>The purpose of a chat server is, that multiple clients can connect to a running
server, and then all messages that a client sends to the server got resend to all
other connected clients. So one user can talk to all the other connected users.</p>
<p>A chat server has to perform two primary tasks:</p>
<div>
<ul>
<li>
<p>Listen for new connections from potential clients</p>
</li>
<li>
<p>Listen for new messages from clients that have already connected to the server</p>
</li>
</ul>
</div>
<p>All the messages that the server receive will need to be sent to every other client
that is currently connected to it.</p>
<p>We have not a working client app yet, but in the case that you have the
<span>telnet</span> program installed on you computer, you can already use that one to
test this server. Telnet sends messages unencrypted , so its use is generally not
recommended to send messages over the internet, but for testing purposes on the local
net we may use it. If the telnet app is not installed on your computer, you may
install it with the package manager of your OS — for Gentoo Linux we would run
&#34;emerge -av telnet-bsd&#34;. An alternative may be the use of the <span>busybox</span> app,
which provides the telnet functionality as well.</p>
<p>If you have a telnet app available, you may open three terminal windows: On the first
one you compile and run the server app — you will see no output in that window. In
the two other terminals you type <span>telnet localhost 12345</span> each. That should
start the telnet app which connects to our running server. When you now type in some
text, that text is echoed to both telnet windows:</p>
<div>
<div>
<pre>$ telnet localhost 12345
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.
We use Nim.
We use Nim.

^]
telnet&gt; quit
Connection closed.</pre>
</div>
</div>
<p>Note that terminating the telnet app is not that simple — you may have to type
<span>CTRL ]</span> first, then you get the telnet prompt, where you type <span>quit</span>
to terminate the app.</p>
<p>Before we will try to explain the details of above server app, we should summarize a
few facts about network communication. Then, at the end of this section, we will
create a simple client app, which you can use instead of telnet to send messages to
the server.</p>
<div>
<h4 id="_data_transfer_over_a_network">Data transfer over a network</h4>
<p>For our chat application we will use the <span>TCP</span> protocol, with so called
network sockets as endpoints. The use of sockets and the TCP protocol is a common
practice in network communication. We will not try to explain any details here, so
citing some definitions from Wikipedia should be enough for now:</p>
<p>A computer network is a set of computers sharing resources located on or provided by
network nodes. The computers use common communication protocols over digital
interconnections to communicate with each
other.</p>
<p>The <span>Internet protocol suite</span>, commonly known as <span>TCP/IP</span>, is the set
of communications protocols used in the Internet and similar computer networks. The
current foundational protocols in the suite are the <span>Transmission Control
Protocol</span> (TCP) and the <span>Internet Protocol</span> (IP). The Internet protocol suite
provides end-to-end data communication specifying how data should be packetized,
addressed, transmitted, routed, and
received.</p>
<p>A <span>network socket</span> is a software structure within a network node of a computer
network that serves as an endpoint for sending and receiving data across the
network.</p>
<p>In Nim, a network socket is represented by the <span>Socket</span> data type, defined in
the <span>std/net</span> module. We can create new <span>Socket</span> instances with a call
of <span>newSocket()</span> or <span>newAsyncSocket()</span> for synchronous or asynchronous
communication.</p>
<p><span>Sockets</span> have some similarity with file descriptors — instead file
operations like read, write and open, for socket instances we have the operations
<span>recv()</span>, <span>send()</span>, <span>connect()</span>, <span>bindAddr()</span> and
<span>listen()</span>. The functions <span>recv()</span> and <span>send()</span> are used to
receive or to send data packages.</p>
<p>TCP is a connection-oriented transport protocol that allows the socket to be used as
a server or as a client. A newly created TCP socket is neither until the
<span>bindAddr()</span> or <span>connect()</span> procedure is called. The former transforms
it into a server socket, and the latter into a client socket.</p>
<p>By default, the <span>newSocket()</span> constructor will create a TCP socket, but we
could pass more options to the <span>newSocket()</span> constructor for other socket
types or to customize the socket instance.</p>
<p>As we want to create a non blocking, asynchronous server app, we create our socket
instance with a call to <span>newAsyncSocket()</span> of default TCP type, and then bind
it with a call of <span>bindAddr()</span> to a socket address, that is the combination of
an IP address and a port number. The IP address is a string, it may consist of four
or six 8-bit numbers each separated by a period, or of a symbolic name like
<span>&#34;google.com&#34;</span>. As we want to test our server only on our local network, we use
the default IP address <span>&#34;localhost&#34;</span>. The port numbers are unsigned 16 bit
numbers in the range from <span>0</span> to <span>2^16-1</span>, where the numbers <span>0 ..
1023</span> are reserved for special tasks and can generally be used only with
administrator privileges. For a real world app the used port numbers are important,
as server-client communication works only when both use the same port number. For our
experiments we will use the number <span>12345</span> from the initial example, as this
one is easily to remember. As the <span>Port</span> type is a distinct unsigned 16 bit
data type, we have to use the notation <span>Port(12345)</span> for the second parameter
of <span>bindAddr()</span>.</p>
<p>We will start our explanations with a simplified code example, where we have removed
the sending of messages to all the clients, and we have replaced some new function
calls like <span>runForever()</span> or <span>asyncCheck()</span> with similar substitutes
that we already know:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>asyncnet</span><span>,</span> <span>asyncdispatch</span><span>]</span>

<span>proc </span><span>processClient</span><span>(</span><span>client</span><span>:</span> <span>AsyncSocket</span><span>)</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>let</span> <span>line</span> <span>=</span> <span>await</span> <span>client</span><span>.</span><span>recvLine</span><span>()</span>
    <span>if</span> <span>line</span><span>.</span><span>len</span> <span>==</span> <span>0</span><span>:</span> <span>break</span>
    <span>echo</span> <span>line</span>

<span>proc </span><span>serve</span><span>()</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>echo</span> <span>&#34;start serve()&#34;</span>
  <span>let</span> <span>server</span> <span>=</span> <span>newAsyncSocket</span><span>()</span>
  <span>server</span><span>.</span><span>setSockOpt</span><span>(</span><span>OptReuseAddr</span><span>,</span> <span>true</span><span>)</span>
  <span>server</span><span>.</span><span>bindAddr</span><span>(</span><span>Port</span><span>(</span><span>12345</span><span>))</span>
  <span>server</span><span>.</span><span>listen</span><span>()</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>let</span> <span>client</span> <span>=</span> <span>await</span> <span>server</span><span>.</span><span>accept</span><span>()</span>
    <span>let</span> <span>f1</span><span>:</span> <span>Future</span><span>[</span><span>void</span><span>]</span> <span>=</span> <span>processClient</span><span>(</span><span>client</span><span>)</span>

<span>let</span> <span>f</span><span>:</span> <span>Future</span><span>[</span><span>void</span><span>]</span> <span>=</span> <span>serve</span><span>()</span>
<span>echo</span> <span>&#34;back at main scope&#34;</span>
<span>waitFor</span> <span>sleepAsync</span><span>(</span><span>320000</span><span>)</span></code></pre>
</div>
</div>
<p>We have two asynchronous <span>procs</span>, <span>serve()</span> and <span>processClient()</span>, which
are both marked with the <span>{.async.}</span> pragma and return a <span>Future[void]</span>
instance each. Our program starts by calling the <span>serve()</span> <span>proc</span>. That <span>proc</span>
creates an asynchronous socket, binds it to <span>localhost</span> and port <span>12345</span>,
and starts listening for new connections. At the beginning of the infinite
<span>while true</span> loop <span>await server.accept()</span> is called to accept new
client connections. As no client tries to connect to the server yet, control is
immediately returned back, and the message <span>&#34;back at main scope&#34;</span> is printed.
Without the last line in our code with the <span>waitFor</span> statement our program
would terminate now. It is very important that we remember that the call of
<span>serve()</span> does not only call that asynchronous <span>proc</span>, but also add it to the
global dispatcher loop. And with the last line in our code we actually run this
dispatcher loop. We have used <span>waitFor sleepAsync(320000)</span> instead the
original <span>runForever()</span> to make the code look not too foreign — running
<span>320</span> seconds should be good enough for our initial tests. Note that as long
as no client connects to the server, <span>proc</span> <span>processClient()</span> is not executed at
all. But when a client connects, then <span>processClient()</span> is called for that
client, and an instance of this <span>processClient()</span> <span>proc</span> with the current client
as argument is added to the global dispatcher loop. This way a new instance of the
<span>processClient()</span> <span>proc</span> is added to the dispatcher loop whenever one more
client connects to the server. This results to the fact that we have for each client
its own instance of a <span>processClient()</span> <span>proc</span> in the dispatcher loop, that is
executed periodically and so can receive data for that client. This way all connected
clients are served, although we do not have an actual list of all the clients that we
iterate!</p>
<p>The actual code in <span>proc</span> <span>processClient()</span> is not difficult: <span>await
client.recvLine()</span> tries to receive a textual message from the client, and gives
control back to the dispatcher loop when there is no data available. And when there
is data, then we just print it for now. The test for line length zero makes some
sense and is necessary to determine when a client disconnects.</p>
<p>When we have managed to understand the simplified code from above, understanding the
original example is easy: We use a sequence with all the connected clients, as we
want to forward each message that we get from one client to all other connected
clients. So the <span>serve()</span> <span>proc</span> adds each new client to that seq, and <span>proc</span>
<span>processClient()</span> iterates over that seq and send the received message to all
the connected clients, followed by a <span>&#34;\c\L&#34;</span> to separate the messages. And
instead of <span>waitFor sleepAsync()</span> <span>runForever()</span> is used, and instead
of assigning the results of the <span>procs</span> <span>serve()</span> and <span>processClient()</span>
of <span>Future[void]</span> type to an unused variable, or to discarding them, these
results are passed to <span>asyncCheck</span>. <span>AsyncCheck</span> is used to provide us
with some error messages if something goes wrong — it sets a callback on the future
argument which raises an exception if the future should finish with an error state.</p>
<p>We hope that you do not wonder about the two infinite &#34;while true&#34; loops any more — for the async/await pattern such loops makes sense of course, as each await returns
control back to the global dispatcher loop. And the server would run this loop until
it is terminated by <span>CTRL-C</span> or another OS intervention.</p>

</div>
</div>
<div>
<h3 id="_the_client_application">The client application</h3>
<p>The client has to connect to the server, and then to watch for keyboard input from
the user and for arrival of new messages from the server at the same time. So again
we have to care to prevent blocking operations. Unfortunately reading user input in a
terminal window is always blocking, and there is currently no input method available
that is directly supported by Nim’s async/await framework. But we presented earlier
in the book already a way to avoid the blocking behavior of the <span>readLine()</span>
proc by use of Nim’s <span>threadpool</span> library. We will use that method again for
the <span>realLine()</span> calls, and combine it with the async/await pattern for
sending messages to the server and for watching for other messages from the server.
Actually our client example program follows closely the client program from
<span>Mr. Picheta</span>, the creator of Nim’s async/await framework, which he sketched
in the <span>Manning</span> book years ago:</p>
<div>
<div>
<pre><code data-lang="nim"><span>import</span> <span>std</span><span>/[</span><span>threadpool</span><span>,</span> <span>asyncdispatch</span><span>,</span> <span>asyncnet</span><span>]</span>

<span>proc </span><span>doConnect</span><span>(</span><span>socket</span><span>:</span> <span>AsyncSocket</span><span>,</span> <span>serverAddr</span><span>:</span> <span>string</span><span>)</span> <span>{.</span><span>async</span><span>.}</span> <span>=</span>
  <span>echo</span><span>(</span><span>&#34;Connecting to &#34;</span><span>,</span> <span>serverAddr</span><span>)</span>
  <span>await</span> <span>socket</span><span>.</span><span>connect</span><span>(</span><span>serverAddr</span><span>,</span> <span>Port</span><span>(</span><span>12345</span><span>))</span>
  <span>echo</span><span>(</span><span>&#34;Connected!&#34;</span><span>)</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>let</span> <span>line</span> <span>=</span> <span>await</span> <span>socket</span><span>.</span><span>recvLine</span><span>()</span>
    <span>echo</span> <span>&#34;Received Message: &#34;</span><span>,</span> <span>line</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>echo</span><span>(</span><span>&#34;Chat application started&#34;</span><span>)</span>
  <span>var</span> <span>socket</span> <span>=</span> <span>newAsyncSocket</span><span>()</span>
  <span>asyncCheck</span> <span>doConnect</span><span>(</span><span>socket</span><span>,</span> <span>&#34;localhost&#34;</span><span>)</span>
  <span>var</span> <span>messageFlowVar</span> <span>=</span> <span>spawn</span> <span>stdin</span><span>.</span><span>readLine</span><span>()</span>
  <span>while</span> <span>true</span><span>:</span>
    <span>if</span> <span>messageFlowVar</span><span>.</span><span>isReady</span><span>():</span>
      <span>asyncCheck</span> <span>socket</span><span>.</span><span>send</span><span>(^</span><span>messageFlowVar</span> <span>&amp;</span> <span>&#34;</span><span>\c\l</span><span>&#34;</span><span>)</span>
      <span>messageFlowVar</span> <span>=</span> <span>spawn</span> <span>stdin</span><span>.</span><span>readLine</span><span>()</span>
    <span>asyncdispatch</span><span>.</span><span>poll</span><span>()</span></code></pre>
</div>
</div>
<p>The structure of this client implementation is a bit different from the server one.
The main reason is, that we have to use Nim’s <span>threadpool</span> and <span>spawn</span> to
avoid the blocking behaviour of the <span>readLine()</span> <span>proc</span>. Note that our
<span>main()</span> <span>proc</span> is not marked with the [.var]{.async.} pragma and contains no
<span>await</span> statement. Only the <span>doConnect()</span> <span>proc</span>, which connects to the
server and then watches for messages send by the server is marked with the
<span>async</span> pragma and awaits the new messages. The <span>main()</span> <span>proc</span> creates
the new asynchronous socket and then calls the asynchronous <span>proc</span>
<span>doConnect()</span>, which actually connects to the server and enters an infinite
loop watching for messages from the server. When <span>doConnect()</span> calls
<span>await</span>, control flow returns immediately to our <span>main()</span> <span>proc</span>. But
<span>doConnect()</span> has become a component of the dispatcher loop, so its infinite
<span>while loop</span> with the <span>await</span> statement will gain control back later.
In the <span>main()</span> <span>proc</span> we then use <span>spawn</span> to execute <span>readLine()</span>
on one thread of the <span>threadpool</span>, and enter a different infinite <span>while
loop</span>. This loops checks if user input is available, and calls poll() to ensure that
the global dispatcher loop is executed. If there is user input available, that
message is send to the server, and <span>spawn</span> is called again waiting for the
next user input.</p>
<p>Of course you may wonder of this client structure really makes sense. At least it
seems to work. But you may be right — the use of <span>spawn</span> is an important
component to avoid the blocking terminal input issue, and the dispatcher loop seems
to do not that much contribution.</p>
<p>Feel free to experiment with modified client app structures yourself.</p>
<div>

<p>Of course, whenever you should intent to create a real world chat application there
are a lot of other task to solve and points to discuss: Is the client/server
architecture really the best solution, or may the clients just talk directly to each
other, without the use of a central server? Then there is the problem with the actual
port numbers, as routers and firewalls may block that ports. And finally, you may
intent to send not only plain strings as we did, but structured message — maybe add
a time and sender name to each message, and send the content encrypted over the
internet. For encrypting the messages you should find some ideas in Nim&#39; standard
library or in external packages, and sending structured messages is not difficult:
For example we used the JSON format in an earlier section of the book to save
structured objects to disk and reload it later. The object content was encoded as
human readable text, which you can send of course over the net without any problems.
You just have to define a protocol for the message exchange: Create Nim objects that
contain all the data you want to exchange, like sender name, time, and the actual
message content. Then use one of the <span>procs</span> provided by the <span>json</span> module to
encode the object before you send it, and encode it again on the receiving side. The
<span>json</span> module provides for example the <span>%</span> operator to convert various
data types to JSON strings or JSON objects, and the <span>parseJson()</span> <span>proc</span> to
convert the text string back into Nim data types. When you have some free time and
are interested in that topic, you can try that yourself, it should be not difficult.
Maybe we will give later in the last part of the book a concrete example for such an
app — but maybe that is just too trivial and boring? What you may try as a small
exercise is this: We send the verbatim message over the net, that is exactly what the
user typed in, and we send it to all clients, including the one who initially send
it. So the sender always gets a echoed copy of its input. A simple exercise for you
would be to add a user name to each message, so that all clients can see who wrote
it. And you can use that user name to identify messages that you send yourself, to
suppress the echoed copy.</p>
<p>Another interesting point is, what happens actually when connected clients
disconnect. There should be at least one serious problem: The server stores all the
connected clients in a list, and sends messages to all of them. But what happens when
a client vanished? Sending messages to disconnected clients is not really a good
idea, so the server may remove clients from the list when they disconnect, or at
least mark them as disconnected. And when do we have to call <span>close()</span> on a
client that is disconnecting? We have not used <span>close()</span> at all now, should we
use it in the server or in the client app? We will not try to cover all these details
in this book — when you really should intent to do some form of network programming,
you should consult some dedicated literature.</p>
<p>For a real world Nim application for network data exchange you may also investigate
this Twitter clone: <a href="https://github.com/zedeus/nitter">https://github.com/zedeus/nitter</a></p>
<p>References:</p>

</div>
</div>
</div>
</div>


<div>
<h2 id="_acknowledgments">Acknowledgments</h2>
<div>
<p>Special thanks go to Mr. Jim Wilcoxson (<a href="https://github.com/hashbackup">https://github.com/hashbackup</a>) who did proof
reading of the first dozen pages of the book and gave some advice for English grammar
and spelling. Thanks go also to Mr. Marek Ľach (<a href="https://github.com/marek-lach">https://github.com/marek-lach</a>) for fixing some more spelling and grammar
errors.</p>
</div>
</div>
<div>
<h2 id="_ascii_table">ASCII Table</h2>
<div>
<div>
<div>
<pre><code data-lang="nim"><span>proc </span><span>print</span><span>(</span><span>i</span><span>:</span> <span>int</span><span>)</span> <span>=</span>
  <span>let</span> <span>c</span> <span>=</span>
    <span>if</span> <span>i</span> <span>&gt;</span> <span>31</span> <span>and</span> <span>i</span> <span>&lt;</span> <span>128</span><span>:</span> <span>char</span><span>(</span><span>i</span><span>)</span> <span>else</span><span>:</span> <span>&#39; &#39;</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;  &#34;</span><span>,</span> <span>c</span><span>,</span> <span>&#34;  &#34;</span><span>)</span>

<span>proc </span><span>main</span> <span>=</span>
  <span>echo</span> <span>&#34;Visible ASCII Characters</span><span>\n</span><span>&#34;</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;     &#34;</span><span>)</span>
  <span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>15</span><span>:</span>
    <span>if</span> <span>i</span> <span>&lt;</span> <span>10</span><span>:</span>
       <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34; +&#34;</span><span>)</span>
    <span>else</span><span>:</span>
      <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;+&#34;</span><span>)</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>i</span><span>,</span> <span>&#34;  &#34;</span><span>)</span>
  <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>
  <span>var</span> <span>i</span> <span>=</span> <span>0</span>
  <span>while</span> <span>i</span> <span>&lt;</span> <span>128</span><span>:</span>
    <span>if</span> <span>i</span> <span>&lt;</span> <span>10</span><span>:</span>
      <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;  &#34;</span><span>)</span>
    <span>elif</span> <span>i</span> <span>&lt;</span> <span>100</span><span>:</span>
      <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34; &#34;</span><span>)</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>i</span><span>,</span> <span>&#39; &#39;</span><span>)</span>
    <span>for</span> <span>j</span> <span>in</span> <span>0</span> <span>..</span> <span>15</span><span>:</span>
      <span>print</span><span>(</span><span>i</span> <span>+</span> <span>j</span><span>)</span>
    <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n</span><span>&#39;</span><span>)</span>
    <span>inc</span><span>(</span><span>i</span><span>,</span> <span>16</span><span>)</span>

<span>main</span><span>()</span></code></pre>
</div>
</div>
</div>
</div>
<div>
<h2 id="_div_and_mod_operation">Div and Mod operation</h2>
<div>
<div>
<div>
<pre><code data-lang="nim"><span>type</span>
  <span>T</span> <span>=</span> <span>array</span><span>[-</span><span>5</span> <span>..</span> <span>4</span><span>,</span> <span>int</span><span>]</span>
  <span>T2</span> <span>=</span> <span>array</span><span>[-</span><span>5</span> <span>..</span> <span>4</span><span>,</span> <span>T</span><span>]</span>

<span>var</span> <span>t</span><span>:</span> <span>T2</span>

<span>for</span> <span>d</span> <span>in</span> <span>0</span> <span>..</span> <span>1</span><span>:</span>
  <span>if</span> <span>d</span> <span>==</span> <span>0</span><span>:</span>
    <span>echo</span> <span>&#34;</span><span>\n</span><span>Result of i div j&#34;</span>
  <span>else</span><span>:</span>
    <span>echo</span> <span>&#34;</span><span>\n</span><span>Result of i mod j&#34;</span>
  <span>for</span> <span>i</span> <span>in</span> <span>-</span><span>5</span> <span>..</span> <span>4</span><span>:</span> <span># row</span>
    <span>for</span> <span>j</span> <span>in</span> <span>-</span><span>5</span> <span>..</span> <span>4</span><span>:</span> <span># col</span>
      <span>if</span> <span>i</span> <span>==</span> <span>-</span><span>5</span> <span>and</span> <span>j</span> <span>==</span> <span>-</span><span>5</span><span>:</span>
          <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>int</span><span>.</span><span>high</span>
      <span>elif</span> <span>i</span> <span>==</span> <span>-</span><span>5</span><span>:</span>
        <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>j</span>
      <span>elif</span> <span>j</span> <span>==</span> <span>-</span><span>5</span><span>:</span>
        <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>i</span>
      <span>else</span><span>:</span>
        <span>if</span> <span>j</span> <span>==</span> <span>0</span><span>:</span>
          <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>int</span><span>.</span><span>high</span>
        <span>else</span><span>:</span>
          <span>if</span> <span>d</span> <span>==</span> <span>0</span><span>:</span>
            <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>i</span> <span>div</span> <span>j</span>
          <span>else</span><span>:</span>
            <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>i</span> <span>mod</span> <span>j</span>

  <span>for</span> <span>i</span> <span>in</span> <span>-</span><span>5</span> <span>..</span> <span>4</span><span>:</span>
    <span>for</span> <span>j</span> <span>in</span> <span>-</span><span>5</span> <span>..</span> <span>4</span><span>:</span>
      <span>if</span> <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>&gt;=</span> <span>0</span><span>:</span>
        <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34; &#34;</span><span>)</span>
      <span>if</span> <span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>==</span> <span>int</span><span>.</span><span>high</span><span>:</span>
        <span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#34;  &#34;</span><span>)</span>
      <span>else</span><span>:</span>
        <span>stdout</span><span>.</span><span>write</span><span>(</span><span>t</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span>,</span> <span>&#34; &#34;</span><span>)</span>
    <span>echo</span> <span>&#34;&#34;</span></code></pre>
</div>
</div>
</div>
</div>
<div>
<h2 id="_text_styles">Text styles</h2>
<div>
<p>We use semantic markup with these text styles:</p>
<div>
<ul>
<li>
<p>New text: <span>This is new stuff</span></p>
</li>
<li>
<p>Recent text: <span>This was recently updated</span></p>
</li>
<li>
<p>First use: <span>term</span></p>
</li>
<li>
<p>Italic: <span>This is italic</span></p>
</li>
<li>
<p>Operators: <span>+ - &amp; shl</span></p>
</li>
<li>
<p>Keywords: <span>var ref object import while</span></p>
</li>
<li>
<p>Use of proc in text: <span>proc</span></p>
</li>
<li>
<p>Use of macro in text: <span>macro</span></p>
</li>
<li>
<p>Data types: <span>float int Table</span></p>
</li>
<li>
<p>String data type: <span>string</span></p>
</li>
<li>
<p>Array data type: <span>array</span></p>
</li>
<li>
<p>Function calls: <span>setLen()</span></p>
</li>
<li>
<p>Variables: <span>i, j, length</span></p>
</li>
<li>
<p>Module names: <span>strutils, system, io</span></p>
</li>
<li>
<p>Literals: <span>100, false, 3.14</span></p>
</li>
<li>
<p>Constants: <span>fmWrite</span></p>
</li>
<li>
<p>Code in text: <span>while a &gt; 0 and not done:</span></p>
</li>
<li>
<p>Terminal text: <span>nim c -gc:arc test.nim</span></p>
</li>
</ul>
</div>
<p>For the term &#34;proc&#34;, which is a Nim keyword, we use no keyword markup, as
it occurs so often. Maybe we will later write just procedure instead.
And we do the same for the macro keyword.</p>
</div>
</div>
<div>
<h2 id="_changelog">ChangeLog</h2>
<div>
<div>
<h3 id="_november_2021">November 2021</h3>
<p>We have added a few more simple examples and exercises:</p>

</div>

</div>
</div>
</div></div>
  </body>
</html>
