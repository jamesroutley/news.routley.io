<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nathanjaremko.com/deploying-an-ihp-project-to-flyio/">Original</a>
    <h1>Deploying an IHP Project to Fly.io</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><time datetime="2022-06-13">Jun 13, 2022</time>
</p>

<p>Learning Haskell the conventional way can be difficult, so I’m going to recommend a different path, you can dive in head-first with the “Ruby on Rails” of Haskell: IHP.</p>
</div><section>
<p><a href="https://www.haskell.org/" rel="nofollow ugc noopener">Haskell</a> is awesome. If you haven’t used it, you should give it a shot. There are a few paths to learning Haskell. You could read <a href="https://haskellbook.com/" rel="nofollow ugc noopener">the book</a>, but that’s &gt;1000 pages of knowledge that will probably scare you off if you’re just getting into it. So I’m going to recommend a different path, you can dive in head-first with the “Ruby on Rails” of Haskell: <a href="https://ihp.digitallyinduced.com/" rel="nofollow ugc noopener">IHP</a>.</p><p>After you’ve got everything working, and you’ve made your first Haskell web application. You’ll probably be thinking to yourself “they’ve been talking up nix so much, so how do I deploy this?”. I’ve got good news. It’s actually very easy to create an optimized, many-layered, reproducible docker image with nix, and I’m going to show you how. Then we’re going to:</p><ul><li>Deploy it for free on <a href="https://fly.io/" rel="nofollow ugc noopener">fly.io</a></li><li>Setup CI/CD to deploy every commit automatically with github actions.</li></ul><h2 id="making-an-ihp-docker-image">Making an IHP docker image</h2><p>First things first, you’re going to follow the <a href="https://ihp.digitallyinduced.com/Guide/installation.html" rel="nofollow ugc noopener">IHP setup instructions</a>. Come back when you’ve got everything working.</p><p>Welcome back!</p><p>At the time of me writing this, in your newly created IHP project, you’ll find a <code>default.nix</code> file with the following contents:</p><pre><code>let
    ihp = builtins.fetchGit {
        url = &#34;https://github.com/digitallyinduced/ihp.git&#34;;
        ref = &#34;refs/tags/v0.19.0&#34;;
    };
    haskellEnv = import &#34;${ihp}/NixSupport/default.nix&#34; {
        ihp = ihp;
        haskellDeps = p: with p; [
            cabal-install
            base
            wai
            text
            hlint
            p.ihp
        ];
        otherDeps = p: with p; [
            # Native dependencies, e.g. imagemagick
        ];
        projectPath = ./.;
    };
in
    haskellEnv</code></pre><p>With that, if you were to run the following command in the project directory:</p><pre><code>nix-build —option sandbox false</code></pre><p>you’d end up with a <code>result/bin</code> folder in your current directory containing a binary to run your IHP project. You might be thinking “Cool! Now how do I ship this on Fly.io?”</p><p>We’ll get there, but first I’m going to explain what each of these blocks are doing:</p><pre><code>ihp = builtins.fetchGit {
    url = &#34;https://github.com/digitallyinduced/ihp.git&#34;;
    ref = &#34;refs/tags/v0.19.0&#34;;
};</code></pre><p>This block downloads a copy of the IHP git repo, specifically the 0.19.0 tag and stores it in the <code>ihp</code> variable.</p><pre><code>haskellEnv = import &#34;${ihp}/NixSupport/default.nix&#34; {
    ihp = ihp;
    haskellDeps = p: with p; [
        cabal-install
        base
        wai
        text
        hlint
        p.ihp
    ];
    otherDeps = p: with p; [
        # Native dependencies, e.g. imagemagick
    ]; 
    projectPath = ./.;
};</code></pre><p>This block imports a nix function from the IHP git repo we just fetched, and passes some named arguments to the function. <code>ihp</code> is just passing in the repo, <code>haskellDeps</code> is a list of haskell dependencies that we need to build the project, <code>otherDeps</code> is a list of native dependencies we need to build the project, and <code>projectPath</code> is the path to copy all your files from.</p><p>To facilitate making our docker image, we need to make a new file <code>app.nix</code> that defines a function that returns a similar value to our current <code>default.nix</code></p><pre><code># app.nix

{ additionalNixpkgsOptions ? {}, optimized ? false }:

let
    ihp = builtins.fetchGit {
        url = &#34;https://github.com/digitallyinduced/ihp.git&#34;;
        ref = &#34;refs/tags/v0.19.0&#34;;
    };
    haskellEnv = import &#34;${ihp}/NixSupport/default.nix&#34; {
        ihp = ihp;
        haskellDeps = p: with p; [
            cabal-install
            base
            wai
            text
            hlint
            p.ihp
        ];
        otherDeps = p: with p; [
            # Native dependencies, e.g. imagemagick
        ];
        additionalNixpkgsOptions = additionalNixpkgsOptions; 
        projectPath = ./.;
        optimized = optimized;
    };
in
    haskellEnv</code></pre><p>With that file created, we can update our <code>default.nix</code> file like so:</p><pre><code># default.nix

let
    haskellEnv = import ./app.nix {};
in
    haskellEnv</code></pre><p>Now, for the good part, let’s make a docker image. Create a new file <code>docker.nix</code> like so:</p><pre><code># docker.nix

{ localPkgs ? import &lt;nixpkgs&gt; {}
, imagePkgs ? import &lt;nixpkgs&gt; { system = &#34;x86_64-linux&#34;; }
, ihpApp ? import ./app.nix { 
    additionalNixpkgsOptions = { system = &#34;x86_64-linux&#34;; }; 
    optimized = true; 
  }
}:

localPkgs.dockerTools.buildLayeredImage {
  name = &#34;app&#34;;
  contents = [ imagePkgs.cacert ];
  config = {
    Cmd = [ &#34;${ihpApp}/bin/RunProdServer&#34; ];
    WorkingDir = &#34;${ihpApp}/lib&#34;;
    ExposedPorts = {
      &#34;8000&#34; = {};
    };
  };
  maxLayers = 120;
}</code></pre><p>You can now, if you’re running linux, you can run the following command to create an optimized linux build of the IHP project and load it into docker:</p><pre><code>docker load &lt; $(nix-build ./docker.nix --option sandbox false)</code></pre><p>If you have the misfortune of using Windows or MacOS, you’ll need to use the following <code>Dockerfile</code> to build the image:</p><pre><code># This file lets you build the image on windows/mac
# Run `docker build . -t app`
# Then run `docker run -d -t app` to run the image
# Then run `docker ps` to get the hash of the running container
# Then use that and run `docker cp -L TheContainerHash:/app/result ./app.tar.gz`
# Then run `docker load &lt; ./app.tar.gz`

FROM nixos/nix

RUN nix-channel --update

WORKDIR /app

RUN nix-env -iA cachix -f https://cachix.org/api/v1/install
RUN cachix use digitallyinduced

ADD . .

RUN nix-build ./docker.nix --option sandbox false</code></pre><h2 id="deploying-on-flyio">Deploying on Fly.io</h2><p>Now we’ll get started with deploying to fly.io!</p><ol><li>Go follow the instructions on their website to get their CLI setup.</li><li>Run <code>flyctl apps create</code> and create an app named “app”</li><li>Follow <a href="https://fly.io/docs/reference/postgres/" rel="nofollow ugc noopener">the instructions</a> to create and attach a postgres instance to your app</li></ol><p>Make a <code>fly.toml</code> file in your project like so:</p><pre><code># fly.toml file generated for app on 2022-06-10T20:32:18-07:00

app = &#34;app&#34;

kill_signal = &#34;SIGINT&#34;
kill_timeout = 5
processes = []

[build]
  image = &#34;app&#34;

[env]
  PORT = &#34;8000&#34;
  IHP_REQUEST_LOGGER_IP_ADDR_SOURCE = &#34;FromHeader&#34;
  IHP_BASEURL = &#34;https://YOURURLHERE.com&#34;

[experimental]
  allowed_public_ports = []
  auto_rollback = true

[[services]]
  http_checks = []
  internal_port = 8000
  processes = [&#34;app&#34;]
  protocol = &#34;tcp&#34;
  script_checks = []

  [services.concurrency]
    hard_limit = 25
    soft_limit = 20
    type = &#34;connections&#34;

  [[services.ports]]
    force_https = true
    handlers = [&#34;http&#34;]
    port = 80

  [[services.ports]]
    handlers = [&#34;tls&#34;, &#34;http&#34;]
    port = 443

  [[services.tcp_checks]]
    grace_period = &#34;1s&#34;
    interval = &#34;15s&#34;
    restart_limit = 0
    timeout = &#34;2s&#34;
</code></pre><p>You’ll need to create a secret <code>IHP_SESSION_SECRET</code> , I used <code>pwgen -s 128 1</code> to generate one:</p><pre><code>flyctl secrets set IHP_SESSION_SECRET=$(pwgen -s 128 1)</code></pre><p>Now find the image in your local docker</p><pre><code>docker image ls</code></pre><p>and finally run</p><pre><code>flyctl deploy -i app:theTagFromThePreviousCommand</code></pre><h2 id="deploying-automatically-with-github-actions">Deploying automatically with Github Actions</h2><p>If you want to have it automatically deployed to fly every commit in your repo, you’ll need to go <a href="https://fly.io/user/personal_access_tokens" rel="nofollow ugc noopener">create an API token</a> and add it as a secret in your repo settings, then you can create <code>.github/workflows/deploy.yml</code> like so</p><pre><code>name: &#34;Build Image&#34;
on:
  pull_request:
  push:
env:
  FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
  # This should be of the form postgresql://username:<a href="https://nathanjaremko.com/cdn-cgi/l/email-protection" data-cfemail="3f4f5e4c4c48504d5b7f53505c5e5357504c4b">[email protected]</a>/db_name
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/<a href="https://nathanjaremko.com/cdn-cgi/l/email-protection" data-cfemail="84e7ece1e7efebf1f0c4f2b6aab0aab4">[email protected]</a>
      - uses: cachix/<a href="https://nathanjaremko.com/cdn-cgi/l/email-protection" data-cfemail="bed7d0cdcadfd2d293d0d7c693dfddcad7d1d0fec88f89">[email protected]</a>
        with:
          nix_path: nixpkgs=channel:nixos-unstable
      - uses: cachix/<a href="https://nathanjaremko.com/cdn-cgi/l/email-protection" data-cfemail="84e7e5e7ecedfca9e5e7f0edebeac4f2b5b4">[email protected]</a>
        with:
          name: digitallyinduced
      - uses: superfly/flyctl-actions/<a href="https://nathanjaremko.com/cdn-cgi/l/email-protection" data-cfemail="0d7e6879787d206b61746e79614d606c7e79687f">[email protected]</a>
      - run: docker load &lt; $(nix-build ./docker.nix --option sandbox false)
      - run: flyctl proxy 5432 -a app-db &amp;
      # Give 10 seconds for the proxy to start up, 5 seconds would probably work too
      - run: sleep 10 &amp;&amp; nix-shell --run migrate
      - run: flyctl deploy -i app:$(docker image ls &#34;app:*&#34; -a --format &#39;table {{.Tag}}&#39; | sed -sn 2p)
</code></pre>
</section></div>
  </body>
</html>
