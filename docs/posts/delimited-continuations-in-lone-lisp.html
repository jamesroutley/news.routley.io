<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.matheusmoreira.com/articles/delimited-continuations-in-lone-lisp">Original</a>
    <h1>Delimited Continuations in Lone Lisp</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <a href="https://github.com/lone-lang/lone/commit/02f8ff3dc97b8a59be2b4d2e2ac947c1f5c41e64">Lone now supports delimited continuations!</a>
        <p>
          It took me a long time but it&#39;s finally here: lone now supports one of
          the most powerful control mechanisms there is.
        </p>
        <pre><code><span>(</span><span>import</span> <span>(</span><span>lone</span> print lambda control transfer<span>)</span> <span>(</span><span>math</span> +<span>)</span><span>)</span>

<span>(</span><span>print</span>
  <span>(</span><span>+</span> <span>1</span>
    <span>(</span><span>control</span>
      <span>(</span><span>+</span> <span>98</span> <span>(</span><span>transfer</span> <span>41</span><span>)</span><span>)</span>
      <span>(</span><span><span>lambda</span> <span>(</span><span><span>value</span> <span>continuation</span></span><span>)</span></span>
        <span>(</span><span>continuation</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


</code></pre>
        <p>
          Implementing this feature will pave the way to many others, such as
          exception handling and generators. However, before moving on with
          development, I thought it would be worthwhile to write down the story
          of this feature&#39;s implementation. I want to write the article I wish I
          had read before I began. If nothing else, this will serve as
          documentation for the future version of myself whose brain has deleted
          all this context.
        </p>
        <h2>Iteration</h2>
        <p>
          Lone was growing in complexity. I already had all these data types,
          all of these <em>collections</em>. I was having quite a lot of fun
          implementing these things. I was learning so much. Hash tables?
          Powerful stuff.
        </p>
        <p>
          However, there was something I was secretly avoiding:
          <strong>iteration</strong>.
        </p>
        <p>
          Well, that&#39;s not entirely true. I didn&#39;t <em>completely</em> avoid the
          issue. Inspired by Ruby, I added some <code>each</code>
          primitives to the intrinsic modules.
        </p>
        <pre><code><span>(</span><span>import</span> <span>(</span><span>lone</span> lambda print<span>)</span> <span>(</span><span>vector</span> each<span>)</span><span>)</span>

<span>(</span><span>each</span> <span>[</span><span>10</span> <span>20</span> 30<span>]</span>
  <span>(</span><span><span>lambda</span> <span>(</span><span><span>value</span></span><span>)</span></span>
    <span>(</span><span>print</span> value<span>)</span><span>)</span><span>)</span>
</code></pre>
        <p>
          The way the <code>each</code> function works internally is it iterates
          over the contents of the vector and calls the provided function with
          each element as its sole argument.
        </p>
        <pre><code><span>LONE_LISP_PRIMITIVE</span><span>(</span>vector_each<span>)</span>
<span>{</span>
    <span>struct</span> <span>lone_lisp_value</span> vector<span>,</span> f<span>,</span> entry<span>;</span>
    <span>size_t</span> i<span>;</span>

    

    <span>LONE_LISP_VECTOR_FOR_EACH</span><span>(</span>entry<span>,</span> vector<span>,</span> i<span>)</span> <span>{</span>
        arguments <span>=</span> <span>lone_lisp_list_build</span><span>(</span>lone<span>,</span> <span>1</span><span>,</span> <span>&amp;</span>entry<span>)</span><span>;</span>
        <span>lone_lisp_apply</span><span>(</span>lone<span>,</span> module<span>,</span> environment<span>,</span> f<span>,</span> arguments<span>)</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>lone_lisp_nil</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
        <p>
          I cheated a little: I left the <em>actual</em> iteration up to the C
          compiler. That <code>FOR_EACH</code> macro simply evaluates to a good
          old <code>for</code> loop. The C code iterates on behalf of lone,
          applying the current element to the provided function.
        </p>
        <p>
          So what is the issue? I mean, this works.
          <em>This actually works</em> just fine!
        </p>
        <p>
          The problem is this made one of lone&#39;s limitations painfully obvious:
          lone lacked the ability to control the flow of the program. The only
          thing it knew how to do was call functions. That&#39;s why I had to
          implement iteration in terms of function calls.
        </p>
        <p>
          I couldn&#39;t even begin to imagine how to implement something simple
          like a <code>while</code> primitive, to say nothing of magical stuff
          like generators. Clearly this was going to take a lot more effort than
          it initially seemed.
        </p>
        <p>
          So I started reading all I could about iteration. The ergonomics of
          it. The design of the interfaces. I wanted to do The Right Thing right
          off the bat. I didn&#39;t really know what to look for, I just knew Ruby&#39;s
          iteration was nice and so lone&#39;s should be equally nice.
        </p>
        <p>
          The very first result I found while searching was
          <a href="https://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/">Bob Nystrom&#39;s article</a>. I wasn&#39;t even surprised. I mean <em>of course</em>
          he has written about iteration.
          <a href="https://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/">Two articles, even.</a>
          First he taught me
          <a href="https://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/">how to collect garbage</a>, now he&#39;s going to teach me how to iterate properly.
        </p>
        <p>
          These beautifully written articles demonstrate exactly why Ruby is
          nice. Ruby lets programmers write nice code that passes values to
          blocks, just like my <code>each</code> function. Whenever that fails
          to compose, concurrency comes to the rescue: Ruby somehow suspends the
          code in the middle of the iteration and yields control back to the
          caller, letting them resume whenever they want. This way, multiple
          iterative processes can be composed, interleaved or even interrupted.
          <em>Good.</em>
        </p>
        <p>
          My sense of wonder quickly gave way to horror once I realized what was
          necessary to have such goodness. It turned out lone needed the one
          thing it did not have at the time:
          <em>control over the call stack</em>. Lone was a
          <em>recursive tree-walking interpreter</em>. The call stack, too, was
          managed by the C compiler.
        </p>
        <p>
          I was going to have to bite the bullet. I was going to have to convert
          lone&#39;s recursive evaluator into a proper machine with registers and a
          stack.
        </p>
        <h2>Reifying the stack</h2>
        <p>
          I considered my options. I explored the code bases of popular
          programming language virtual machines. They all had bytecode virtual
          machines. How did they implement, say, generators? Copy the code,
          stack and instruction pointer into a callable heap allocated object.
          Makes sense, it&#39;s just that lone doesn&#39;t have an instruction pointer.
          I didn&#39;t want to transform the lisp code into bytecode. Is it really
          lisp if I get rid of the lists? I didn&#39;t think so.
        </p>
        <p>
          How do I do this <em>without</em> transforming the code? I decided to
          ask around in Programming Language Design and Implementation
          communities.
          <a href="https://langdev.stackexchange.com/q/3547">I asked this question</a>
          on the Stack Exchange. I also asked about it on a Discord server. I
          was told about continuation passing style, yet another code
          transformation which I wanted to avoid... I <em>really</em> like those
          lists!
        </p>
        <p>
          One particular reference kept popping up though: Structure and
          Interpretation of Computer Programs.
          <abbr title="Structure and Interpretation of Computer Programs">SICP</abbr>, for short. <strong>THE</strong> book of the Scheme programming
          language. One of the most classic books in the field. Science? Nah,
          we&#39;re more like wizards casting spells, computers are merely the runes
          upon which we inscribe our programs. As awesome as that is, the book
          is not an easy read, especially for someone like me who doesn&#39;t have a
          background in mathematics or engineering. I&#39;ve tried to read this book
          a few times by now but I never made it through the entire thing. So
          imagine my embarrassment when I realized it contained the exact answer
          to my question all along!
        </p>
        <p>
          <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-34.html">Chapter 5.4</a>, one of the very last chapters, describes the explicit-control
          evaluator, a register and stack machine which evaluates lisp
          expressions <em>without</em> converting them into something else
          first.
        </p>
        <h3>The explicit-control evaluator</h3>
        <p>
          So I read the chapter a few times to make sure I had gotten it down
          and once I was somewhat confident in my understanding of the machine
          it was describing I went ahead and translated the entire thing to C,
          modifying it as I went along.
        </p>
        <p>
          Lone&#39;s evaluator did not have many special cases. Things like
          <code>if</code> are traditionally implemented as special cases in the
          evaluator, but since lone has FEXPRs I was able to factor them out
          into the intrinsic <code>lone</code> module. In lone, programmers
          import <code>if</code> as though it was some random function instead
          of a core part of the language.
        </p>
        <p>
          The result was a machine that implements what I have come to believe
          to be the <em>true</em> essence of lisp: self-evaluating values, and
          function application. A lisp machine, if you will.
        </p>
        <p>
          It starts with an arbitrary lisp expression and attempts to reduce it
          to a single value. If the expression is something like a number then
          it cannot be reduced any further. The machine just returns it. Easy.
        </p>
        <pre><code>expression_evaluation<span>:</span>
    <span>switch</span> <span>(</span><span>lone_lisp_type_of</span><span>(</span>machine<span>-&gt;</span>expression<span>)</span><span>)</span> <span>{</span>
    <span>case</span> LONE_LISP_TYPE_NIL<span>:</span>
    <span>case</span> LONE_LISP_TYPE_FALSE<span>:</span>
    <span>case</span> LONE_LISP_TYPE_TRUE<span>:</span>
    <span>case</span> LONE_LISP_TYPE_INTEGER<span>:</span>
        machine<span>-&gt;</span>value <span>=</span> machine<span>-&gt;</span>expression<span>;</span>
        
</code></pre>
        <p>
          If it&#39;s a symbol, the machine looks up the value of the symbol in the
          current environment instead. Also easy.
        </p>
        <pre><code><span>case</span> LONE_LISP_TYPE_SYMBOL<span>:</span>
    machine<span>-&gt;</span>value <span>=</span> <span>lone_lisp_table_get</span><span>(</span>lone<span>,</span> machine<span>-&gt;</span>environment<span>,</span> machine<span>-&gt;</span>expression<span>)</span><span>;</span>
    
</code></pre>
        <p>
          Only when the machine runs into a list does it <em>really</em> start
          processing.
        </p>
        <p>
          Lists represent <em>function application</em> in the form
          <code>(f x y z ...)</code>. The first thing that needs to happen is
          evaluation of the function itself. It&#39;s probably a variable pointing
          to the actual function value. It could also be a lambda expression.
          Whatever it is, it must be evaluated. So the machine loops back into
          the expression evaluation logic, this time with <code>f</code> as the
          expression.
        </p>
        <pre><code><span>case</span> LONE_LISP_TYPE_LIST<span>:</span>
    
    machine<span>-&gt;</span>expression <span>=</span> <span>lone_lisp_list_first</span><span>(</span>machine<span>-&gt;</span>expression<span>)</span><span>;</span>
    <span>lone_lisp_machine_push_step</span><span>(</span>lone<span>,</span> machine<span>,</span> LONE_LISP_MACHINE_STEP_EVALUATED_OPERATOR<span>)</span><span>;</span>
    <span>goto</span> expression_evaluation<span>;</span>
</code></pre>
        <p>
          Once this is done, it&#39;s time to figure out what to do with the
          arguments. This depends on the function.
        </p>
        <pre><code><span>if</span> <span>(</span><span>should_evaluate_operands</span><span>(</span>machine<span>-&gt;</span>applicable<span>,</span> machine<span>-&gt;</span>unevaluated<span>)</span><span>)</span> <span>{</span>
    
    machine<span>-&gt;</span>step <span>=</span> LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION<span>;</span>
<span>}</span> <span>else</span> <span>{</span>
    machine<span>-&gt;</span>list <span>=</span> machine<span>-&gt;</span>unevaluated<span>;</span>
    machine<span>-&gt;</span>step <span>=</span> LONE_LISP_MACHINE_STEP_APPLICATION<span>;</span>
<span>}</span>
</code></pre>
        <p>
          Normal functions evaluate all arguments. In these cases the machine
          loops back and forth, evaluating each argument and accumulating the
          results in a list. It&#39;s this list that gets passed to the function in
          the end. FEXPRs just skip this step, the arguments are passed to the
          function unevaluated.
        </p>
        <pre><code><span>case</span> LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION<span>:</span>
    
    machine<span>-&gt;</span>expression <span>=</span> <span>lone_lisp_list_first</span><span>(</span>machine<span>-&gt;</span>unevaluated<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>lone_lisp_list_has_rest</span><span>(</span>machine<span>-&gt;</span>unevaluated<span>)</span><span>)</span> <span>{</span>
        
        <span>lone_lisp_machine_push_step</span><span>(</span>lone<span>,</span> machine<span>,</span> LONE_LISP_MACHINE_STEP_OPERAND_ACCUMULATION<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        
        <span>lone_lisp_machine_push_step</span><span>(</span>lone<span>,</span> machine<span>,</span> LONE_LISP_MACHINE_STEP_LAST_OPERAND_ACCUMULATION<span>)</span><span>;</span>
    <span>}</span>
    <span>goto</span> expression_evaluation<span>;</span>
<span>case</span> LONE_LISP_MACHINE_STEP_OPERAND_ACCUMULATION<span>:</span>
    
    <span>lone_lisp_list_append</span><span>(</span>lone<span>,</span> <span>&amp;</span>machine<span>-&gt;</span>list<span>,</span> <span>&amp;</span>head<span>,</span> machine<span>-&gt;</span>value<span>)</span><span>;</span>
    
    machine<span>-&gt;</span>step <span>=</span> LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION<span>;</span>
    
<span>case</span> LONE_LISP_MACHINE_STEP_LAST_OPERAND_ACCUMULATION<span>:</span>
    
    machine<span>-&gt;</span>applicable <span>=</span> <span>lone_lisp_machine_pop_value</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
    <span>lone_lisp_list_append</span><span>(</span>lone<span>,</span> <span>&amp;</span>machine<span>-&gt;</span>list<span>,</span> <span>&amp;</span>head<span>,</span> machine<span>-&gt;</span>value<span>)</span><span>;</span>
    machine<span>-&gt;</span>step <span>=</span> LONE_LISP_MACHINE_STEP_APPLICATION<span>;</span>
    
</code></pre>
        
        <p>The next step is to actually apply the arguments to the function.</p>
        <p>
          When it&#39;s a lisp function, a new environment is created where the
          variables in the function&#39;s list of arguments are bound to their
          values, thereby allowing the function to reference them. This
          environment also inherits from the function&#39;s closure, allowing it to
          reference variables that were live when it was defined. Pretty
          standard stuff. All that&#39;s left to do is evaluate the function&#39;s body.
        </p>
        <pre><code><span>switch</span> <span>(</span><span>lone_lisp_heap_value_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>-&gt;</span>type<span>)</span> <span>{</span>
<span>case</span> LONE_LISP_TYPE_FUNCTION<span>:</span>
    machine<span>-&gt;</span>environment <span>=</span> <span>bind_arguments</span><span>(</span>
        lone<span>,</span>
        machine<span>-&gt;</span>environment<span>,</span>
        machine<span>-&gt;</span>applicable<span>,</span>
        machine<span>-&gt;</span>list
    <span>)</span><span>;</span>
    machine<span>-&gt;</span>unevaluated <span>=</span> <span>lone_lisp_heap_value_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>-&gt;</span>as<span>.</span>function<span>.</span>code<span>;</span>
    machine<span>-&gt;</span>step <span>=</span> LONE_LISP_MACHINE_STEP_SEQUENCE_EVALUATION<span>;</span>
    
</code></pre>
        <p>
          Primitives are just C functions and some metadata. The machine just
          calls them. There is no way to automatically assign the lisp values to
          C variables, so the arguments list gets passed whole to the primitive.
          It gets to unpack the values however it wants.
        </p>
        <p>
          It was at this point that I realized an interesting situation
          involving these C functions was developing: the primitives are going
          to want to call back into lisp. For example, <code>if</code> needs the
          machine to evaluate the condition and one of two expressions.
        </p>
        <p>
          This doesn&#39;t sound so bad at first but it in fact spells doom for my
          ultimate goal of controlling the flow of the program:
        </p>
        <figure>
          <blockquote cite="https://www.wingolog.org/archives/2010/02/26/guile-and-delimited-continuations">
            The second (and deeper) implication is that if any intervening code
            does recurse through a foreign function, the resulting partial
            continuation cannot be reinstated.
          </blockquote>
          <figcaption>
            <cite><a href="https://www.wingolog.org/archives/2010/02/26/guile-and-delimited-continuations">Andy Wingo, wingolog,
                <time datetime="2010-02-26 20:39">26 February 2010 8:39 PM</time>
              </a></cite>
          </figcaption>
        </figure>
        <p>
          How can I possibly capture and manipulate the lisp stack when it&#39;s in
          fact interleaving with the C stack? I can&#39;t.
        </p>
        <p>
          So after going through <em>all this trouble</em> to convert the
          recursive evaluator into a machine just to expose the lisp stack so
          that I could manipulate it, I end up in this sorry situation where
          lisp calls C which calls lisp again.
        </p>
        <p>
          Clearly, the primitives cannot be allowed to recurse back into the
          machine... But how could this work? Many of them <em>need</em> to do
          this just to work at all!
        </p>
        <p>
          I entertained the idea of just saving the entire C stack instead. I
          quickly gave up on this approach but not before I
          <a href="https://langdev.stackexchange.com/q/4204">asked a question about it</a>
          on Stack Exchange which produced a very interesting answer. So it
          <em>was</em> possible... Probably not wise but still. I always find it
          reassuring when I discover I&#39;m not the first person who tried to do
          something that normal people clearly consider to be
          <em>completely insane</em>.
        </p>
        <h3>Integrating the primitives into the machine</h3>
        <p>
          Enough. No more of this C stack business. The primitives
          <em>cannot be allowed</em>
          to recurse back into lisp. That&#39;s the end of it. There&#39;s gotta be a
          way to solve this even with this constraint.
        </p>
        <p>
          Inspiration came when I remembered
          <a href="https://langdev.stackexchange.com/q/820">this Stack Exchange thread</a>
          I read while researching generators. Turns out generators are just
          perfectly normal functions that got mangled into state machines by the
          language.
        </p>
        <figure>
          <blockquote cite="https://langdev.stackexchange.com/a/834">
            <pre><code><span>struct</span> <span>fibState</span> <span>{</span>
    a<span>,</span>
    b<span>,</span>
    position
<span>}</span>

<span>int</span> <span>fib</span><span>(</span>fibState state<span>)</span> <span>{</span>
    <span>switch</span> <span>(</span>fibState<span>.</span>postion<span>)</span> <span>{</span>
    <span>case</span> <span>0</span><span>:</span>
        fibState<span>.</span>a<span>,</span> fibState<span>.</span>b <span>=</span> <span>1</span><span>,</span><span>2</span>
        <span>while</span> <span>(</span>a<span>&lt;</span><span>100</span><span>)</span> <span>{</span>
            fibState<span>.</span>b<span>,</span> fibState<span>.</span>a <span>=</span> fibState<span>.</span>a<span>,</span> fibState<span>.</span>a<span>+</span>fibState<span>.</span>b
            
            fibState<span>.</span>position <span>=</span> <span>1</span><span>;</span>
            <span>return</span> fibState<span>.</span>a<span>;</span>
    <span>case</span> <span>1</span><span>:</span>
        <span>}</span>

        fibState<span>.</span>position <span>=</span> <span>2</span><span>;</span>
        <span>return</span> fibState<span>.</span>a<span>-</span><span>1</span>
    <span>case</span> <span>2</span><span>:</span>
        fibState<span>.</span>position <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre>
          </blockquote>
          <figcaption>
            <cite><a href="https://langdev.stackexchange.com/a/834">mousetail, Programming Language Design and Implementation Stack
                Exchange,
                <time datetime="2023-05-20 14:06">May 20, 2023 at 14:06</time>
              </a></cite>
          </figcaption>
        </figure>
        <p>
          It&#39;s got an initial state and it transitions to new states as it
          progresses through its code, returning multiple values along the way.
          Could even be made to loop depending on how it&#39;s set up. Oddly similar
          to the lisp machine, now that I think about it. Could these two
          concepts work together?
        </p>
        <p>
          The answer turned out to be a resounding <strong>yes</strong>! I
          rewrote all of lone&#39;s primitives to be state machines instead, just
          like the example in the answer to the question. The aforementioned
          <code>each</code> primitive, for example, which once upon a time was
          relatively simple function, turned into this monstrosity:
        </p>
        <pre><code><span>LONE_LISP_PRIMITIVE</span><span>(</span>vector_each<span>)</span>
<span>{</span>
    <span>struct</span> <span>lone_lisp_value</span> arguments<span>,</span> vector<span>,</span> function<span>,</span> entry<span>,</span> expression<span>;</span>
    lone_lisp_integer i<span>;</span>

    <span>switch</span> <span>(</span>step<span>)</span> <span>{</span>
    <span>case</span> <span>0</span><span>:</span> 

        

        i <span>=</span> <span>0</span><span>;</span>

    iteration<span>:</span>

        entry <span>=</span> <span>lone_lisp_vector_get_value_at</span><span>(</span>vector<span>,</span> i<span>)</span><span>;</span>

        
        expression <span>=</span> <span>lone_lisp_list_build</span><span>(</span>lone<span>,</span> <span>2</span><span>,</span> <span>&amp;</span>function<span>,</span> <span>&amp;</span>entry<span>)</span><span>;</span>
        lone<span>-&gt;</span>machine<span>.</span>step <span>=</span> LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION<span>;</span>
        lone<span>-&gt;</span>machine<span>.</span>expression <span>=</span> expression<span>;</span>

        

        <span>return</span> <span>1</span><span>;</span>

    <span>case</span> <span>1</span><span>:</span> 

        

        <span>++</span>i<span>;</span>

        <span>if</span> <span>(</span>i <span>&lt;</span> <span>lone_lisp_vector_count</span><span>(</span>vector<span>)</span><span>)</span> <span>{</span>
            <span>goto</span> iteration<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> <span>lone_lisp_nil</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
        <p>
          The machine now passes to the primitive an integer that represents the
          current step in its program. The primitive in turn returns to the
          machine the next step in its program. Lisp arguments and return values
          are now passed on the lisp stack.
        </p>
        <p>
          Other than the calling convention, pretty much nothing changed for
          simple primitives that do nothing special. The initial and final steps
          are both zero. They receive zero, do their thing and return zero.
          Done. They don&#39;t even need to deal with all this step stuff at all.
        </p>
        <p>
          Special primitives, on the other hand, gain the ability to interface
          with the machine. Whenever the primitive wants the machine to do
          something such as evaluate an expression, it rigs machine so that it
          does it and returns a non-zero integer. This indicates to the machine
          that it should be resumed later at that exact point. The machine goes
          off and does whatever it is that it was asked to do and then it calls
          the primitive again to resume it at the designated step. This way, the
          lisp and C stacks do not ever interleave. The C stack is simply not
          allowed to build up. The C function returns instead of calling back
          into lisp.
        </p>
        <p>
          Inversion of control. Don&#39;t call the machine, the machine will call
          you. Let it know what you need and it will get back to you when it&#39;s
          done.
        </p>
        <p>
          Or maybe it won&#39;t! Maybe the machine will ghost the primitive and keep
          it waiting until the end of time for a value that will never come.
          When the primitives were simply calling evaluator functions, the C
          compiler guaranteed those functions would always return their results
          to them. That&#39;s no longer the case.
          <em>The lisp machine is in control now.</em>
        </p>
        <pre><code><span>case</span> LONE_LISP_TYPE_PRIMITIVE<span>:</span>
    
    <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> machine<span>-&gt;</span>list<span>)</span><span>;</span>
    machine<span>-&gt;</span>primitive<span>.</span>step <span>=</span> <span>0</span><span>;</span>
resume_primitive<span>:</span>
    machine<span>-&gt;</span>primitive<span>.</span>step <span>=</span>
        <span>lone_lisp_heap_value_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>-&gt;</span>as<span>.</span>primitive<span>.</span><span>function</span><span>(</span>
            lone<span>,</span> machine<span>,</span> machine<span>-&gt;</span>primitive<span>.</span>step
        <span>)</span><span>;</span>
    <span>if</span> <span>(</span>machine<span>-&gt;</span>primitive<span>.</span>step<span>)</span> <span>{</span>
        
        <span>lone_lisp_machine_save_primitive_step</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
        <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> machine<span>-&gt;</span>applicable<span>)</span><span>;</span>
        <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> machine<span>-&gt;</span>environment<span>)</span><span>;</span>
        <span>lone_lisp_machine_push_step</span><span>(</span>lone<span>,</span> machine<span>,</span> LONE_LISP_MACHINE_STEP_RESUME_PRIMITIVE<span>)</span><span>;</span>
        
    <span>}</span> <span>else</span> <span>{</span>
        
        machine<span>-&gt;</span>value <span>=</span> <span>lone_lisp_machine_pop_value</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
        
    <span>}</span>
<span>case</span> LONE_LISP_MACHINE_STEP_RESUME_PRIMITIVE<span>:</span>
    
    machine<span>-&gt;</span>environment <span>=</span> <span>lone_lisp_machine_pop_value</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
    machine<span>-&gt;</span>applicable <span>=</span> <span>lone_lisp_machine_pop_value</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
    <span>lone_lisp_machine_restore_primitive_step</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
    <span>goto</span> resume_primitive<span>;</span>
</code></pre>
        <p>
          This works and is surprisingly neat. Sure, all my primitives turned
          into weird state machines but it&#39;s not really a big deal. By now I&#39;ve
          debugged this stuff so much I actually started liking it.
        </p>
        <h2>Manipulating the stack</h2>
        <p>
          What was the point of going through all this trouble again? Ah yes. I
          remember now. The stack. There it is. Reified. Just
          <em>sitting</em> there. Right in the middle of the structure.
          Literally one pointer away. Just waiting to be smashed and overflown
          all night long.
        </p>
        <p>
          So what am I going to do with this thing? What <em>can</em> I do with
          it?
        </p>
        <p>Can I return early from functions?</p>
        <pre><code><span>(</span><span>import</span> <span>(</span><span>lone</span> set print lambda return<span>)</span><span>)</span>

<span>(</span><span>set</span> f
  <span>(</span><span><span>lambda</span> <span>(</span><span><span>x</span></span><span>)</span></span>
    <span>(</span><span>return</span> <span>42</span><span>)</span>
    x<span>)</span><span>)</span>

<span>(</span><span>print</span> <span>(</span><span>f</span> <span>100</span><span>)</span><span>)</span>
</code></pre>
        <p>
          To return, I need to find where on the stack the function starts. I
          need to put some kind of marker on the stack. <em>A delimiter.</em>
          It shall be pushed onto the stack before the function is called and
          popped off the stack when it has finished executing.
        </p>
        <pre><code>    <span>case</span> LONE_LISP_TYPE_FUNCTION<span>:</span>
        
        <span>lone_lisp_machine_push_function_delimiter</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
        
        
    <span>case</span> LONE_LISP_TYPE_PRIMITIVE<span>:</span>
        <span>lone_lisp_machine_push_function_delimiter</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
        
        <span>if</span> <span>(</span>machine<span>-&gt;</span>primitive<span>.</span>step<span>)</span> <span>{</span>
            
        <span>}</span> <span>else</span> <span>{</span>
            
            machine<span>-&gt;</span>value <span>=</span> <span>lone_lisp_machine_pop_value</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
            <span>goto</span> after_application<span>;</span>
        <span>}</span>

<span>case</span> LONE_LISP_MACHINE_STEP_AFTER_APPLICATION<span>:</span>
after_application<span>:</span>
    <span>lone_lisp_machine_pop_function_delimiter</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
    
</code></pre>
        <p>
          Now <code>return</code> can just unwind the stack until it finds this
          marker. To unwind the stack, simply pop off frames until you reach the
          frame you were looking for. Once the delimiter is on top of the stack,
          the stack discipline matches that of primitives. The return value can
          simply be pushed onto the stack.
        </p>
        <pre><code><span>LONE_LISP_PRIMITIVE</span><span>(</span>lone_return<span>)</span>
<span>{</span>
    <span>struct</span> <span>lone_lisp_machine_stack_frame</span> frame<span>;</span>
    <span>struct</span> <span>lone_lisp_value</span> return_value<span>;</span>

    return_value <span>=</span> <span>;</span>

    <span>lone_lisp_machine_pop_function_delimiter</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span> 

    
    <span>while</span> <span>(</span>LONE_LISP_MACHINE_STACK_FRAME_TYPE_FUNCTION_DELIMITER <span>!=</span>
           <span>(</span>frame <span>=</span> <span>lone_lisp_machine_pop</span><span>(</span>lone<span>,</span> machine<span>)</span><span>)</span><span>.</span>type<span>)</span><span>;</span>
    <span>lone_lisp_machine_push</span><span>(</span>lone<span>,</span> machine<span>,</span> frame<span>)</span><span>;</span>

    <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> return_value<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
        <p>So <em>this</em> is the power of the call stack...</p>
        <h2>Delimited continuations</h2>
        <p>
          So completely drunk on the <em>power</em> of the dark side was I, that
          I decided to go from the humble <code>return</code> primitive to one
          of the most powerful control mechanisms there is: delimited
          continuations. They say it is the one control to rule them all, one
          control to implement them, one control to bring them all, and in the
          stack unwind them.
        </p>
        <p>
          But first I had to wrap my head around plain simple continuations.
          What even <em>are</em> these things? I knew of their existence because
          of my admittedly shallow knowledge of the Scheme programming language
          but I sure as hell didn&#39;t understand them.
          <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation">Wikipedia</a>
          has the following example:
        </p>
        <pre><code><span>(</span><span>define</span> <span>(</span><span>f</span> return<span>)</span>
  <span>(</span><span>return</span> <span>2</span><span>)</span>
  <span>3</span><span>)</span>

<span>(</span><span>f</span> <span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> x<span>)</span><span>)</span>
<span>(</span><span>call-with-current-continuation</span> f<span>)</span>
</code></pre>
        <p>
          It&#39;s not immediately apparent what&#39;s going on here. Let&#39;s unpack it
          step by step.
        </p>
        <p>
          <code>f</code> takes a function, an applicable value really. Nothing
          special happens when a normal function is passed: it gets called,
          returns, and the program continues on.
        </p>
        <p>
          Passing <code>f</code> to <code>call-with-current-continuation</code>,
          which by the way is commonly abbreviated as <code>call/cc</code>,
          causes it to be called with the <em>current continuation</em>, as the
          name implies. This current continuation is a super special callable
          value that, when called, somehow causes the <code>call/cc</code> call
          itself to return the value passed to it.
        </p>
        <p>
          This really flips my bits. I simply have no idea how to use this. It
          sorta looks like my <code>return</code> primitive from earlier, but
          the function&#39;s gotta be threaded through <code>call/cc</code>?
        </p>
        <p>
          The community once again comes to my rescue. A kind soul on Discord
          pointed me towards
          <a href="https://youtu.be/TE48LsgVlIU">a wonderful presentation</a>
          about delimited continuations. The keynote was given by
          <a href="https://lexi-lambda.github.io/">Alexis King</a>, the same
          person who answered one of my Stack Exchange questions I mentioned
          earlier. It&#39;s an incredibly insightful presentation that&#39;s worth
          watching in its entirety. It really does demystify the topic.
        </p>
        <p>
          <code>call/cc</code> is briefly mentioned in the talk and it&#39;s
          explained how totally backwards and mind bending it is. It&#39;s sorta
          like exceptions but backwards, as if the <code>catch</code> was next
          to the <code>throw</code>? I think? I&#39;m not even sure.
        </p>
        <p>
          Let&#39;s just forget about <code>call/cc</code>.
          <a href="https://okmij.org/ftp/continuations/against-callcc.html">Plenty of reasons</a>
          not to insist on this thing anyway. Continuations should be
          <em>delimited</em>. I have learned at least this much.
        </p>
        <p>
          The link between delimited continuations and exception handling is
          another key point. It&#39;s the mother of all insights, the one idea that
          brings this mystical continuation business to the unwashed masses:
          delimited continuations are just <em>resumable exceptions</em>.
        </p>
        <p>It&#39;s as if Python could do this:</p>
        <pre><code><span>try</span><span>:</span>
    <span>print</span><span>(</span><span>10</span> <span>+</span> throw<span>(</span><span>&#34;error&#34;</span><span>)</span><span>)</span>
<span>except</span> error<span>,</span> continuation<span>:</span>
    continuation<span>(</span><span>10</span><span>)</span>    
</code></pre>
        <p>
          The <code>throw</code> breaks out of the <code>try</code> block and
          enters the <code>except</code> block, which is like a function with
          two arguments: the value thrown and the continuation at the moment it
          was thrown.
        </p>
        <p>
          The exception handler code can just ignore the continuation and do
          nothing with it, which is what normally happens when exceptions are
          handled in pretty much every other language.
        </p>
        <p>
          However, the callable continuation value allows another possibility:
          it allows the handler code to plug a value back into the code being
          tried, as though the <code>throw</code> primitive had returned it! So
          in this example, after <code>throw</code> breaks out of
          <code>try</code> and passes control to <code>except</code>, the
          exception handler code <em>goes back into</em> the
          <code>try</code> block with a new value, allowing it to finish as if
          it hadn&#39;t thrown an exception in the first place!
        </p>
        <p>
          OK, that&#39;s not entirely accurate: calling the continuation doesn&#39;t
          actually go back in there. By the time the exception handler is in
          control, the <code>try</code> block is no more. The stack has been
          unwound and the code has reached a completely different function. What
          actually happens when the continuation is called is it
          <em>brings over</em> the <code>try</code> block to the call site.
        </p>
        <pre><code><span>try</span><span>:</span>
  
<span>except</span> error<span>,</span> continuation<span>:</span>
    <span>try</span><span>:</span>
        <span>print</span><span>(</span><span>10</span> <span>+</span> <span>10</span><span>)</span>
    <span>except</span> error<span>,</span> continuation<span>:</span>
        continuation<span>(</span><span>10</span><span>)</span>    
</code></pre>
        <p>
          It&#39;s as if the <code>throw</code> primitive
          <em>captured all the pending computations</em>,
          <code>try</code> block, exception handler and all, at its call site
          and reified them into a callable value. When called, the value gets
          replaced with those exact computations but with the <code>throw</code>
          primitive replaced with some real value.
        </p>
        <p>
          Let&#39;s go back to the lisp machine. It&#39;s got a stack onto which it
          pushes lots of data as it executes. The stack is not made up of just
          data, however. Machine steps are also pushed onto the stack. The stack
          is full of values which direct the machine to do things in a specific
          order. <strong>The stack is a form of code.</strong>
        </p>
        <p>
          It&#39;s this code that forms the &#34;current continuation&#34;. It&#39;s this code
          that&#39;s being captured.
        </p>
        <h3>Capturing the continuation</h3>
        <p>
          Another key insight in the keynote: continuations turn out to be just
          <code>memcpy</code>ing the stack back and forth.
        </p>
        <p>The stack is just memory. We&#39;re going to need a buffer.</p>
        <pre><code><span>struct</span> <span>lone_lisp_continuation</span> <span>{</span>
    <span>size_t</span> frame_count<span>;</span>
    <span>struct</span> <span>lone_lisp_machine_stack_frame</span> <span>*</span>frames<span>;</span>
<span>}</span><span>;</span>
</code></pre>
        <p>
          We&#39;re going to need delimiters too. The <code>return</code> primitive
          makes use of an implicit delimiter managed by the lisp machine itself.
          This general <code>control</code> primitive will manage the delimiter
          all by itself.
        </p>
        <pre><code><span>LONE_LISP_PRIMITIVE</span><span>(</span>lone_control<span>)</span>
<span>{</span>
    <span>struct</span> <span>lone_lisp_value</span> arguments<span>,</span> body<span>,</span> handler<span>;</span>

    <span>switch</span> <span>(</span>step<span>)</span> <span>{</span>

    <span>case</span> <span>0</span><span>:</span> 

        

        <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> handler<span>)</span><span>;</span>
        <span>lone_lisp_machine_push_continuation_delimiter</span><span>(</span>lone<span>)</span><span>;</span>

        machine<span>-&gt;</span>step <span>=</span> LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION<span>;</span>
        machine<span>-&gt;</span>expression <span>=</span> body<span>;</span>

        <span>return</span> <span>1</span><span>;</span>

    <span>case</span> <span>1</span><span>:</span> 

        <span>lone_lisp_machine_pop_continuation_delimiter</span><span>(</span>lone<span>)</span><span>;</span>
        <span>lone_lisp_machine_pop_value</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span> 
        <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> machine<span>-&gt;</span>value<span>)</span><span>;</span> 
        <span>return</span> <span>0</span><span>;</span>

    <span>default</span><span>:</span>
        <span>linux_exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
        <p>
          This primitive pushes the handler function and a continuation
          delimiter onto the stack. Then it evaluates the body of code. Once
          that&#39;s done, the primitive discards the handler function and the
          continuation delimiter and simply returns the result. So by itself it
          does nothing special. It&#39;s a glorified <code>begin</code> primitive.
        </p>
        <p>Enter the <code>transfer</code> primitive.</p>
        <pre><code><span>LONE_LISP_PRIMITIVE</span><span>(</span>lone_transfer<span>)</span>
<span>{</span>
    <span>struct</span> <span>lone_lisp_machine_stack_frame</span> <span>*</span>delimiter<span>,</span> <span>*</span>frames<span>;</span>
    <span>struct</span> <span>lone_lisp_value</span> arguments<span>,</span> value<span>,</span> continuation<span>,</span> handler<span>;</span>
    <span>size_t</span> frame_count<span>;</span>

    <span>switch</span> <span>(</span>step<span>)</span> <span>{</span>
    <span>case</span> <span>0</span><span>:</span> 

        

        
        <span>for</span> <span>(</span>frame <span>=</span> lone<span>-&gt;</span>machine<span>.</span>stack<span>.</span>top <span>-</span> <span>1</span> <span>-</span> <span>2</span><span>,</span>
             frame_count <span>=</span> <span>1</span><span>;</span>
             frame <span>&gt;=</span> machine<span>-&gt;</span>stack<span>.</span>base <span>&amp;&amp;</span>
             frame<span>-&gt;</span>type <span>!=</span> LONE_LISP_MACHINE_STACK_FRAME_TYPE_CONTINUATION_DELIMITER<span>;</span>
             <span>--</span>frame<span>,</span> <span>++</span>frame_count<span>)</span><span>;</span>

        
        <span>--</span>frame<span>;</span> <span>++</span>frame_count<span>;</span>
        handler <span>=</span> frame<span>-&gt;</span>as<span>.</span>value<span>;</span>

        
        <span>--</span>frame<span>;</span> <span>++</span>frame_count<span>;</span>
        frames <span>=</span> <span>lone_memory_array</span><span>(</span>lone<span>-&gt;</span>system<span>,</span> <span>0</span><span>,</span> frame_count<span>,</span> <span>sizeof</span><span>(</span><span>*</span>frames<span>)</span><span>)</span><span>;</span>
        <span>lone_memory_move</span><span>(</span>frame<span>,</span> frames<span>,</span> frame_count <span>*</span> <span>sizeof</span><span>(</span><span>*</span>frames<span>)</span><span>)</span><span>;</span>

        
        continuation <span>=</span> <span>lone_lisp_continuation_create</span><span>(</span>lone<span>,</span> frame_count<span>,</span> frames<span>)</span><span>;</span>

        
        lone<span>-&gt;</span>machine<span>.</span>stack<span>.</span>top <span>=</span> frame <span>+</span> <span>1</span><span>;</span>

        
        lone<span>-&gt;</span>machine<span>.</span>expression <span>=</span> <span>lone_lisp_list_build</span><span>(</span>lone<span>,</span> <span>3</span><span>,</span> <span>&amp;</span>handler<span>,</span> <span>&amp;</span>value<span>,</span> <span>&amp;</span>continuation<span>)</span><span>;</span>
        lone<span>-&gt;</span>machine<span>.</span>step <span>=</span> LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION<span>;</span>

        <span>return</span> <span>1</span><span>;</span>

    <span>case</span> <span>1</span><span>:</span>

        
        <span>lone_lisp_machine_push_value</span><span>(</span>lone<span>,</span> machine<span>,</span> lone<span>-&gt;</span>machine<span>.</span>value<span>)</span><span>;</span>
        <span>return</span> <span>0</span><span>;</span>

    <span>default</span><span>:</span>
        <span>linux_exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
        <p>
          The first thing it does is find the continuation delimiter by looping
          over the stack frames and looking for it.
        </p>
        
        <p>
          It knows that just below the delimiter it can find the handler
          function that was passed to <code>control</code>. It will be calling
          that function shortly so it recovers that function into a variable.
        </p>
        <p>
          Then it finds the function delimiter of the <code>control</code>
          primitive and copies all the stack frames between it and the top of
          the stack into a heap allocated buffer. Then it creates a lisp value
          that just holds this buffer.
          <em>That&#39;s the continuation.</em>
        </p>
        <p>
          Then it unwinds the stack to the function delimiter, effectively
          popping off the entire segment of the stack that was just copied into
          the heap. At this point the stack discipline matches the initial state
          of the <code>control</code> primitive. We&#39;ve really gone back in
          there! From the lisp machine&#39;s perspective, we&#39;re inside
          <code>control</code> right now, and if we return a value it will be as
          though <code>control</code> had returned it.
        </p>
        <p>
          <code>transfer</code> now has the value, the continuation and the
          handler function. There is but one thing left to do: evaluate
          <code>(handler value continuation)</code>. The return value of that
          expression becomes the result of <code>control</code>.
        </p>
        <p>
          I could stop here and call this an exceptions mechanism. If I deleted
          the continuation capture code, it <em>would</em>
          be just like the exceptions in every other language!
        </p>
        <h3>Making continuations callable</h3>
        <p>I&#39;m not gonna stop there though. I&#39;m so close!</p>
        <p>
          My continuation value is just a structure that holds an array of stack
          frames. This is a new value type which must be properly handled in
          various parts of the system, <em>especially</em> in the garbage
          collector. Fail to mark and sweep these things and memory leaks will
          be the least of your problems.
        </p>
        <p>
          The lisp machine must also be taught how to handle these objects. In
          particular, it must be taught how to apply a value to it.
        </p>
        <p>Like functions, continuations evaluate to themselves.</p>
        <pre><code><span>case</span> LONE_LISP_TYPE_CONTINUATION<span>:</span>
    machine<span>-&gt;</span>value <span>=</span> machine<span>-&gt;</span>expression<span>;</span>
    
</code></pre>
        <p>Continuations don&#39;t fail the applicable type test.</p>
        <pre><code><span>case</span> LONE_LISP_MACHINE_STEP_EVALUATED_OPERATOR<span>:</span>
    
    <span>switch</span> <span>(</span><span>lone_lisp_type_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>)</span> <span>{</span>
        
        <span>case</span> LONE_LISP_TYPE_CONTINUATION<span>:</span>
            <span>break</span><span>;</span>
        

    <span>if</span> <span>(</span><span>should_evaluate_operands</span><span>(</span>machine<span>-&gt;</span>applicable<span>,</span> machine<span>-&gt;</span>unevaluated<span>)</span><span>)</span>
    
</code></pre>
        <p>Continuations always have their arguments evaluated.</p>
        <pre><code><span>static</span> bool <span>should_evaluate_operands</span><span>(</span><span>)</span>
<span>{</span>
    
    <span>switch</span> <span>(</span><span>lone_lisp_heap_value_of</span><span>(</span>applicable<span>)</span><span>-&gt;</span>type<span>)</span> <span>{</span>
    
    <span>case</span> LONE_LISP_TYPE_CONTINUATION<span>:</span>
        <span>return</span> true<span>;</span>
</code></pre>
        <p>
          <strong>And finally...</strong>
          When a value is applied to it, the machine spills the captured stack
          frames on top of the stack and sets the machine registers so that the
          argument flows into the computation.
        </p>
        <pre><code><span>case</span> LONE_LISP_MACHINE_STEP_APPLICATION<span>:</span>
    <span>switch</span> <span>(</span><span>lone_lisp_heap_value_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>-&gt;</span>type<span>)</span> <span>{</span>
        
        <span>case</span> LONE_LISP_TYPE_CONTINUATION<span>:</span>
            <span>if</span> <span>(</span><span>lone_lisp_list_has_rest</span><span>(</span>machine<span>-&gt;</span>list<span>)</span><span>)</span> <span>{</span> <span>goto</span> too_many_arguments<span>;</span> <span>}</span>
            <span>lone_lisp_machine_push_frames</span><span>(</span>
                lone<span>,</span>
                <span>lone_lisp_heap_value_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>-&gt;</span>as<span>.</span>continuation<span>.</span>frame_count<span>,</span>
                <span>lone_lisp_heap_value_of</span><span>(</span>machine<span>-&gt;</span>applicable<span>)</span><span>-&gt;</span>as<span>.</span>continuation<span>.</span>frames
            <span>)</span><span>;</span>
            <span>lone_lisp_machine_restore_step</span><span>(</span>lone<span>,</span> machine<span>)</span><span>;</span>
            machine<span>-&gt;</span>value <span>=</span> <span>lone_lisp_list_first</span><span>(</span>machine<span>-&gt;</span>list<span>)</span><span>;</span>
</code></pre>
        <p>
          The continuation is carefully captured so as to ensure the machine&#39;s
          next step is on top of the stack. The machine simply restores that
          value and off it goes. When it&#39;s done, the result flows naturally into
          the caller.
        </p>
        <p>
          And just like that, lone has gained native first class delimited
          continuations!
        </p>
      </article>
    </div></div>
  </body>
</html>
