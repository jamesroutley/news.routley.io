<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hakibenita.com/postgresql-get-or-create">Original</a>
    <h1>How to Get or Create in PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><article data-progress-indicator="">
        <hr/>
<p>&#34;Get or create&#34; is a very common operation for syncing data in the database, but implementing it correctly may be trickier than you may expect. If you ever had to implement it in a real system with real-life load, you may have overlooked potential race conditions, concurrency issues and even bloat!</p>
<p><strong>In this article I explore ways to &#34;get ot create&#34; in PostgresSQL.</strong></p>
<div>
<figure><img alt="&lt;small&gt;Illustration by Abstrakt Design&lt;/small&gt;" src="https://hakibenita.com/images/00-postgresql-get-or-create.png"/><figcaption><small>Illustration by Abstrakt Design</small></figcaption>
</figure>
</div>
<details open="">
    <summary>Table of Contents</summary>

</details>
<hr/>
<h2 id="implementing-get-or-create"><a href="#implementing-get-or-create">Implementing &#34;Get or Create&#34;</a></h2>
<p>Say you have a system that allows users to tag items. You set up the following tags table:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span> </span><span>(</span>
<span>  </span><span>id</span><span> </span><span>INT</span><span> </span><span>GENERATED</span><span> </span><span>BY</span><span> </span><span>DEFAULT</span><span> </span><span>AS</span><span> </span><span>IDENTITY</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>,</span>
<span>  </span><span>name</span><span> </span><span>VARCHAR</span><span>(</span><span>50</span><span>)</span><span> </span><span>NOT</span><span> </span><span>NULL</span>
<span>);</span>
<span>CREATE</span><span> </span><span>TABLE</span>
</pre></div>


<p>The table contains an auto incrementing primary key and a name. To make sure tags are reused, you add a unique constraint on the name:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span> </span><span>ADD</span><span> </span><span>CONSTRAINT</span><span> </span><span>tags_name_unique</span><span> </span><span>UNIQUE</span><span>(</span><span>name</span><span>);</span>
<span>ALTER</span><span> </span><span>TABLE</span>
</pre></div>


<p>Adding tags to the table is simple:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;A&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>)</span><span> </span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>

<span>INSERT</span><span> </span><span>0</span><span> </span><span>2</span>
</pre></div>


<p>If someone tries to add a tag with a name which already exists, they will get an error:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>)</span><span> </span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
<span>ERROR</span><span>:</span><span>  </span><span>duplicate</span><span> </span><span>key</span><span> </span><span>value</span><span> </span><span>violates</span><span> </span><span>unique</span><span> </span><span>constraint</span><span> </span><span>&#34;tags_name_key&#34;</span>
<span><span>DETAIL</span><span>:</span><span>  </span><span>Key</span><span> </span><span>(</span><span>name</span><span>)</span><span>=</span><span>(</span><span>B</span><span>)</span><span> </span><span>already</span><span> </span><span>exists</span><span>.</span>
</span></pre></div>


<p>The tag &#34;B&#34; already exists, so the command failed due to unique constraint violation.</p>
<p>When our application tags an item it doesn&#39;t care if the tag already exists or not in the database. The application wants the process to be <em>idempotent</em> - providing the same input (tag names) should always produce the same output (the tag objects). A plain <code>INSERT</code> is not idempotent because executing the command with the same input for the second time will trigger an error:</p>
<ul>
<li>❌ The process is not idempotent</li>
</ul>
<p>To provide idempotency we need to handle two situations:</p>
<ul>
<li>If the tag already exists - return the existing tag.</li>
<li>If the tag does not already exist - create it and return the name and the newly assigned ID.</li>
</ul>
<p>This type of syncing functionality is often called &#34;get or create&#34;.</p>
<div>
<p>&#34;UPSERT&#34; vs. &#34;get or create&#34;</p>
<p>&#34;update or insert&#34; (aka &#34;upsert&#34;) is different from &#34;get or create&#34;. In an &#34;upsert&#34; we update matching row that already exist in the table, while in &#34;get or create&#34; we want to avoid changing existing data. As we&#39;ll see in this article, this restriction has significant implications on the implementation.</p>
</div>
<h3 id="providing-idempotency"><a href="#providing-idempotency">Providing Idempotency</a></h3>
<p>As we&#39;ve already seen, if we try to insert a tag which already exists we fail with a unique constraint violation. To make the process idempotent we need to only create tags that don&#39;t already exist, and return any tags that do.</p>
<p>Let&#39;s adjust our process to check if a tag already exist before we create it:</p>
<div><pre><span></span><span>CREATE</span><span> </span><span>OR</span><span> </span><span>REPLACE</span><span> </span><span>FUNCTION</span><span> </span><span>get_or_create_tag</span><span>(</span><span>tag_name</span><span> </span><span>tags</span><span>.</span><span>name</span><span>%TYPE</span><span>)</span>
<span>RETURNS</span><span> </span><span>SETOF</span><span> </span><span>tags</span><span> </span><span>AS</span><span> </span><span>$$</span>
<span>DECLARE</span>
<span>  </span><span>tag_to_return</span><span> </span><span>tags</span><span>%ROWTYPE</span><span>;</span>
<span>BEGIN</span>
<span><span>  </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>INTO</span><span> </span><span>tag_to_return</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>tag_name</span><span>;</span>
</span><span>  </span><span>IF</span><span> </span><span>FOUND</span><span> </span><span>THEN</span>
<span>    </span><span>RETURN</span><span> </span><span>NEXT</span><span> </span><span>tag_to_return</span><span>;</span>
<span>  </span><span>ELSE</span>
<span><span>    </span><span>RETURN</span><span> </span><span>QUERY</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>tag_name</span><span>)</span><span> </span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
</span><span>  </span><span>END</span><span> </span><span>IF</span><span>;</span>
<span>END</span><span>;</span>
<span>$$</span><span> </span><span>LANGUAGE</span><span> </span><span>plpgsql</span><span>;</span>
</pre></div>


<p>The function first looks for an existing tag with the same name. If it finds a tag it returns it, otherwise it create it and then returns it. The function returns a set of rows and it can be used like this:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>get_or_create_tag</span><span>(</span><span>&#39;C&#39;</span><span>);</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>get_or_create_tag</span><span>(</span><span>&#39;C&#39;</span><span>);</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>The first time we execute the function with the tag name &#34;C&#34;, the tag is created and assigned ID 3. The second time we attempt to get or create &#34;C&#34;, the tag already exists and we get the same tag with ID 3. The function is idempotent!</p>
<p>This function can be written in any language really, but thanks to the magic of <a href="https://www.postgresql.org/docs/current/plpgsql.html" rel="noopener">plpgsql</a> <a href="https://www.postgresql.org/docs/current/xfunc-sql.html#XFUNC-SQL-FUNCTIONS-RETURNING-SET" rel="noopener">set returning functions</a> we can also use this function to &#34;get or create&#34; multiple tags at once:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>tags</span><span>.</span><span>*</span>
<span>FROM</span>
<span>  </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;D&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>new</span><span>(</span><span>tag</span><span>),</span>
<span>  </span><span>get_or_create_tag</span><span>(</span><span>tag</span><span>)</span><span> </span><span>AS</span><span> </span><span>tags</span><span>;</span>

<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>  </span><span>5</span><span> </span><span>│</span><span> </span><span>D</span>
<span>(</span><span>3</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>To create multiple tags at once we produce a set of rows using a <code>VALUES</code> clause, and then join it to our function using the tag name as parameter.</p>
<p>This approach achieves our first goal:</p>
<ul>
<li>✅ The process is idempotent</li>
</ul>
<p>Executing this function with the same input will always produce the same output. However, there is one subtle issue that can easily go unnoticed.</p>
<h3 id="handling-a-potential-race"><a href="#handling-a-potential-race">Handling a Potential Race</a></h3>
<p>The function we came up with looks innocent enough to pass most code reviews, but in-fact, there is a subtle edge case that can cause this function to fail.</p>
<p>If two concurrent processes attempt to use the function to &#34;get or create&#34; the same tag at the same time, we can end up getting a unique constraint violation. Consider the following scenario where two processes, A and B, attempt to insert a new tag &#34;foo&#34;:</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Process A</th>
<th>Process B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>Check if &#34;foo&#34; exists</td>
<td></td>
</tr>
<tr>
<td>T + 1</td>
<td></td>
<td>Check if &#34;foo&#34; exists</td>
</tr>
<tr>
<td>T + 2</td>
<td>Insert &#34;foo&#34;</td>
<td></td>
</tr>
<tr>
<td>T + 3</td>
<td></td>
<td>Insert &#34;foo&#34;</td>
</tr>
</tbody>
</table>
<p>In the race described above, both processes check if the tag exists and finds that it does not exists. Then, both processes proceed to create the tag name. Process A creates the tag first and as a result, process B fails with a unique constraint violation.</p>
<p>Inspired by <a href="https://github.com/django/django/blob/a190c03afec0feef27e097727569ba064b97ac7a/django/db/models/query.py#L938-L961" rel="noopener">Django&#39;s <code>get_or_create</code> implementation</a>, we can handle the potential unique constraint violation:</p>
<div><pre><span></span><span>CREATE</span><span> </span><span>OR</span><span> </span><span>REPLACE</span><span> </span><span>FUNCTION</span><span> </span><span>get_or_create_tag</span><span>(</span><span>tag_name</span><span> </span><span>tags</span><span>.</span><span>name</span><span>%TYPE</span><span>)</span>
<span>RETURNS</span><span> </span><span>SETOF</span><span> </span><span>tags</span><span> </span><span>AS</span><span> </span><span>$$</span>
<span>DECLARE</span>
<span>  </span><span>tag_to_return</span><span> </span><span>tags</span><span>%ROWTYPE</span><span>;</span>
<span>BEGIN</span>
<span>  </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>INTO</span><span> </span><span>tag_to_return</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>tag_name</span><span>;</span>
<span>  </span><span>IF</span><span> </span><span>FOUND</span><span> </span><span>THEN</span>
<span>    </span><span>RETURN</span><span> </span><span>NEXT</span><span> </span><span>tag_to_return</span><span>;</span>
<span>  </span><span>ELSE</span>
<span><span>    </span><span>BEGIN</span>
</span><span><span>      </span><span>RETURN</span><span> </span><span>QUERY</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>tag_name</span><span>)</span><span> </span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
</span><span><span>    </span><span>EXCEPTION</span><span> </span><span>WHEN</span><span> </span><span>unique_violation</span><span> </span><span>THEN</span>
</span><span><span>      </span><span>RETURN</span><span> </span><span>QUERY</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>tag_name</span><span>;</span>
</span><span><span>    </span><span>END</span><span>;</span>
</span><span>  </span><span>END</span><span> </span><span>IF</span><span>;</span>
<span>END</span><span>;</span>
<span>$$</span><span> </span><span>LANGUAGE</span><span> </span><span>plpgsql</span><span>;</span>
</pre></div>


<p>To address the potential race we now catch an exception in the insert command. If a unique constraint violation occurred we assume another process had already inserted the row, so we fetch and return it from the table.</p>
<p>This approach provides us with idempotency and addresses potential races:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process is safe to execute concurrently</li>
</ul>
<p>However, under some circumstances this approach may be wasteful.</p>
<h3 id="using-unique-constraint-violations"><a href="#using-unique-constraint-violations">Using Unique Constraint Violations</a></h3>
<p>Our previous approach is idempotent and safe to execute by multiple processes at the same time, but it comes at a cost. When we add a tag that already exists we only run one query - this is good. However, for <em>new</em> tags we run at least two queries - one to check if it already exists and another to insert it. If most tags are new, this approach is wasteful.</p>
<p>If we expect most tags to be new tags, we can adjust our implementation to remove the initial check:</p>
<div><pre><span></span><span>CREATE</span><span> </span><span>OR</span><span> </span><span>REPLACE</span><span> </span><span>FUNCTION</span><span> </span><span>get_or_create_tag</span><span>(</span><span>tag_name</span><span> </span><span>tags</span><span>.</span><span>name</span><span>%TYPE</span><span>)</span>
<span>RETURNS</span><span> </span><span>SETOF</span><span> </span><span>tags</span><span> </span><span>AS</span><span> </span><span>$$</span>
<span>BEGIN</span>
<span>  </span><span>RETURN</span><span> </span><span>QUERY</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>tag_name</span><span>)</span><span> </span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
<span>EXCEPTION</span><span> </span><span>WHEN</span><span> </span><span>unique_violation</span><span> </span><span>THEN</span>
<span>  </span><span>RETURN</span><span> </span><span>QUERY</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>tag_name</span><span>;</span>
<span>END</span><span>;</span>
<span>$$</span><span> </span><span>LANGUAGE</span><span> </span><span>plpgsql</span><span>;</span>
</pre></div>


<p>The function now attempts to insert a new tag straight away. If the insert fail due to unique constraint violation, it looks for the matching tag in the table and returns it:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>get_or_create_tag</span><span>(</span><span>&#39;D&#39;</span><span>);</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>D</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>get_or_create_tag</span><span>(</span><span>&#39;D&#39;</span><span>);</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>D</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>This approach achieve both our previous goals:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process is safe to execute concurrently</li>
</ul>
<p>One unfortunate nuisance of this approach is that every unique constraint violation is logged. If you are in the habit of skimming the database logs this can be very annoying.</p>
<p>Attempting to insert a tag and handle a potential unique constraint violation is idempotent and safe when executed by concurrent processes, but there is a hidden downside.</p>
<h3 id="abusing-unique-constraint-violations"><a href="#abusing-unique-constraint-violations">Abusing Unique Constraint Violations</a></h3>
<p>To demonstrate the potential issue of relaying on unique constraint violations we start by checking the current size of the table:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>));</span>
<span> </span><span>pg_size_pretty</span>
<span>────────────────</span>
<span> </span><span>8192</span><span> </span><span>bytes</span>
</pre></div>


<p>Very small. Next, disable &#34;autovacuum&#34; on the table (more on that later) and insert 50K tags that already exist:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span> </span><span>SET</span><span> </span><span>(</span><span>autovacuum_enabled</span><span> </span><span>=</span><span> </span><span>false</span><span>);</span>
<span>SET</span>

<span>db</span><span>=#</span><span> </span><span>\</span><span>timing</span><span> </span><span>on</span>
<span>Timing</span><span> </span><span>is</span><span> </span><span>on</span><span>.</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>get_or_create_tag</span><span>(</span><span>&#39;A&#39;</span><span>)</span><span> </span><span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>1</span><span>,</span><span> </span><span>50000</span><span>);</span>
<span> </span><span>get_or_create_tag</span>
<span>───────────────────</span>
<span> </span><span>(</span><span>1</span><span>,</span><span>A</span><span>)</span>
<span> </span><span>(</span><span>1</span><span>,</span><span>A</span><span>)</span>
<span>...</span>
<span> </span><span>(</span><span>1</span><span>,</span><span>A</span><span>)</span>
<span> </span><span>(</span><span>1</span><span>,</span><span>A</span><span>)</span>
<span>(</span><span>50000</span><span> </span><span>rows</span><span>)</span>
<span>Time</span><span>:</span><span> </span><span>12077</span><span>.</span><span>786</span><span> </span><span>ms</span><span> </span><span>(</span><span>00</span><span>:</span><span>12</span><span>.</span><span>078</span><span>)</span>
</pre></div>


<p>Attempting to insert 50K tags which already exist in the table took ~12 seconds to complete, pretty slow. Check the size of the table again:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>));</span>
<span> </span><span>pg_size_pretty</span>
<span>────────────────</span>
<span> </span><span>1776</span><span> </span><span>kB</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>The table is now more than 200 times bigger! Keep in mind that we only attempted to insert tags that were already there, meaning no new data was actually added to the table. So where did this extra size comes from? Querying the number of dead tuples in the table provides a hint:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>relname</span><span>,</span><span> </span><span>n_dead_tup</span><span>,</span><span> </span><span>n_live_tup</span>
<span>FROM</span><span> </span><span>pg_stat_user_tables</span>
<span>WHERE</span><span> </span><span>relname</span><span> </span><span>=</span><span> </span><span>&#39;tags&#39;</span><span>;</span>
<span> </span><span>relname</span><span> </span><span>│</span><span> </span><span>n_dead_tup</span><span> </span><span>│</span><span> </span><span>n_live_tup</span>
<span>─────────┼────────────┼────────────</span>
<span> </span><span>tags</span><span>    </span><span>│</span><span>      </span><span>50000</span><span> </span><span>│</span><span>          </span><span>3</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>The table contains a dead tuple for every attempt to insert a tag that already existed. <a href="https://aws.amazon.com/blogs/database/hidden-dangers-of-duplicate-key-violations-in-postgresql-and-how-to-avoid-them/" rel="noopener">This article by the Amazon RDS team</a> explains the issue pretty well - in an INSERT command, the row is first added to the table (heap), and only then checked for potential unique constraint violations. If a duplicate is found, an exception is raised and the row is marked dead. When a row is marked dead it occupies space until the table is vacuumed. These dead rows cause &#34;bloat&#34; which makes the table swell beyond its intrinsic size.</p>
<p>To clear the bloat we can manually vacuum the table:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>VACUUM</span><span> </span><span>tags</span><span>;</span>
<span>VACUUM</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>relname</span><span>,</span><span> </span><span>n_dead_tup</span><span>,</span><span> </span><span>n_live_tup</span>
<span>FROM</span><span> </span><span>pg_stat_user_tables</span>
<span>WHERE</span><span> </span><span>relname</span><span> </span><span>=</span><span> </span><span>&#39;tags&#39;</span><span>;</span>
<span> </span><span>relname</span><span> </span><span>│</span><span> </span><span>n_dead_tup</span><span> </span><span>│</span><span> </span><span>n_live_tup</span>
<span>─────────┼────────────┼────────────</span>
<span> </span><span>tags</span><span>    </span><span>│</span><span>          </span><span>0</span><span> </span><span>│</span><span>          </span><span>2</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>));</span>
<span> </span><span>pg_size_pretty</span>
<span>────────────────</span>
<span> </span><span>8192</span><span> </span><span>bytes</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>After vacuuming, the dead rows are cleared and the table goes back to its original size. The database has a background process called &#34;autovacuum&#34; which triggers vacuum automatically when certain thresholds are met. We disabled it for our experiment to demonstrate the issue.</p>

<p>This approach now achieves our first goals but suffers from a new issue:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process is safe to execute concurrently</li>
<li>❌ The process generates bloat</li>
</ul>
<p>Bloat is something we want to avoid, so next, we&#39;ll explore ways to &#34;get or create&#34; without generating bloat.</p>
<h3 id="understanding-sub-statement-visibility"><a href="#understanding-sub-statement-visibility">Understanding Sub-Statement Visibility</a></h3>
<p>In processes where duplicates rarely happen, it&#39;s perfectly fine to rely on catching unique constraint violations to implement &#34;get or create&#34; functionality. However, in processes where duplicates happen a lot, the bloat can end up consuming a lot of space and put strain on the database.</p>
<p>To avoid the unnecessary bloat in this case we can avoid triggering unique constraint violations in the first place. In our first attempt we did that by checking if the tag exists before we tried to insert it. We did that using a separate query, but there is another way.</p>
<p>Consider the following query to create tags <em>only</em> if they don&#39;t already exist:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>SELECT</span><span> </span><span>name</span>
<span>    </span><span>FROM</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>)</span>
<span><span>    </span><span>WHERE</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
</span><span><span>        </span><span>SELECT</span><span> </span><span>1</span>
</span><span><span>        </span><span>FROM</span><span> </span><span>tags</span>
</span><span><span>        </span><span>WHERE</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
</span><span><span>    </span><span>)</span>
</span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>The tag &#34;B&#34; already exist in the table so we don&#39;t try to insert it. As a result, we only get the tag that did not already exist, the tag &#34;C&#34;.</p>
<p>To get both existing <em>and</em> new tags, we can execute <code>INSERT</code> in a <code>WITH</code> clause (aka common table expression, CTE) and then query the table for both the new and existing tags:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>WITH</span><span> </span><span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>SELECT</span><span> </span><span>name</span>
<span>    </span><span>FROM</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>WHERE</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>1</span>
<span>        </span><span>FROM</span><span> </span><span>tags</span>
<span>        </span><span>WHERE</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
<span>    </span><span>)</span>
<span>)</span>
<span><span>SELECT</span><span> </span><span>*</span>
</span><span><span>FROM</span><span> </span><span>tags</span>
</span><span><span>WHERE</span><span> </span><span>name</span><span> </span><span>IN</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>,</span><span> </span><span>&#39;C&#39;</span><span>);</span>
</span><span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
</pre></div>


<p>This is strange! In the <code>WITH</code> clause we insert the tag &#34;C&#34;, but when we query the tags table immediately after, we only get the tag &#34;B&#34;. Does this mean tag &#34;C&#34; was not inserted? Let&#39;s check:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span><span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
</span><span>(</span><span>3</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>Selecting from the table <em>after</em> the command completed shows both tags &#34;B&#34; and &#34;C&#34; are present in the table, so why did we only get &#34;B&#34;? <a href="https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING" rel="noopener">The documentation explains</a>:</p>
<blockquote>
<p>The sub-statements in <code>WITH</code> are executed <em>concurrently</em> with each other and with the main query.</p>
</blockquote>
<p>Our &#34;main&#34; <code>SELECT</code> can&#39;t &#34;see&#34; modifications we made in the <code>WITH</code> clause - this is why we didn&#39;t get the new tag &#34;C&#34;, only the existing tag &#34;B&#34;. The documentation continue to explain the risks of relying on the results of data-modifying statements executed in <code>WITH</code>:</p>
<blockquote>
<p>Therefore, when using data-modifying statements in <code>WITH</code>, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same <em>snapshot</em> [...], so they cannot “see” one another&#39;s effects on the target tables.</p>
</blockquote>
<p>This means that any changes to the <code>tags</code> table is not visible to other parts of the query until the query completes. However, this dosen&#39;t mean we can&#39;t use the results of <code>WITH</code> sub-statements:</p>
<blockquote>
<p><code>RETURNING</code> data is the only way to communicate changes between different WITH sub-statements and the main query.</p>
</blockquote>
<p>Consider the following example:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>WITH</span><span> </span><span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>SELECT</span><span> </span><span>name</span>
<span>    </span><span>FROM</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>WHERE</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>1</span>
<span>        </span><span>FROM</span><span> </span><span>tags</span>
<span>        </span><span>WHERE</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
<span>    </span><span>)</span>
<span><span>    </span><span>RETURNING</span><span> </span><span>*</span>
</span><span>)</span>
<span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span><span>;</span>
</span><span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span> </span><span>3</span><span>  </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>The main <code>SELECT</code> query references the result of the <code>WITH</code> clause instead of querying <code>tags</code> again, and we see the newly added tag &#34;C&#34;. If we adjust the query to get new tags from the result of the <code>WITH</code>, and existing tags from the target table, we should get what we want:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>WITH</span>
<span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>SELECT</span><span> </span><span>name</span>
<span>    </span><span>FROM</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>WHERE</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>1</span>
<span>        </span><span>FROM</span><span> </span><span>tags</span>
<span>        </span><span>WHERE</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
<span>    </span><span>)</span>
<span>    </span><span>RETURNING</span><span> </span><span>*</span>
<span>)</span>
<span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>IN</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>,</span><span> </span><span>&#39;C&#39;</span><span>)</span>
</span><span><span>UNION</span><span> </span><span>ALL</span>
</span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span><span>;</span>

<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>Let&#39;s break it down:</p>
<ol>
<li>
<p>Insert the new tags into the table: exclude existing tags to avoid unique constraint violations, create new tags and return the inserted rows. The result from <code>WITH</code> depends on the data - it may result in multiple rows, one row or none if all the tags already exist.</p>
</li>
<li>
<p>Query existing tags: we don&#39;t know in advance which tags already exist, so we query for all matching tags.</p>
</li>
<li>
<p>Query new tags: new tags that were added during the query are not visible yet so we use the results of the <code>WITH</code> clause.</p>
</li>
</ol>
<div>
<p>UNION vs. UNION ALL</p>
<p>Both <code>UNION</code> and <code>UNION ALL</code> concatenate results but <code>UNION</code> also eliminate duplicates which often require a <a href="https://hakibenita.com/sql-dos-and-donts#know-the-difference-between-union-and-union-all">potentially expensive sort or hash operation</a>. Our query already guarantees there can&#39;t be duplicates in the concatenated result sets, so <code>UNION ALL</code> is more efficient.</p>
</div>
<p>This query now achieves two of our goals:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process doesn&#39;t generate bloat</li>
<li>⚠️ Is the process safe to execute concurrently?</li>
</ul>
<p>Next, we&#39;ll check how this approach holds up when executed by multiple concurrency processes.</p>
<h3 id="avoiding-concurrency-issues"><a href="#avoiding-concurrency-issues">Avoiding Concurrency Issues</a></h3>
<p>So far we were able to avoid bloat by preventing unique constraint violations, and worked around visibility issues by concatenating results from the target table itself and the results of a <code>WITH</code> clause using <code>RETURNING</code>. To be honest, when I <a href="https://x.com/be_haki/status/1718993194938187935" rel="noopener">originally tackled this issue</a> I stopped here, but then smarter people <a href="https://x.com/samokhvalov/status/1719635712545591630" rel="noopener">pointed out</a> that there might be some concurrency issues with this approach as well. In other words, if many users will attempt to &#34;get or create&#34; at the same time using this approach, they may encounter unexpected errors.</p>
<p>To test concurrent execution, we adjust the command to insert multiple random tags:</p>
<div><pre><span></span><span>-- get_or_create.sql</span>
<span>WITH</span>
<span>-- Generate a random amount of random tags</span>
<span><span>tags_to_insert</span><span> </span><span>AS</span><span> </span><span>(</span>
</span><span><span>    </span><span>SELECT</span><span> </span><span>&#39;tag&#39;</span><span> </span><span>||</span><span> </span><span>round</span><span>(</span><span>random</span><span>()</span><span> </span><span>*</span><span> </span><span>1000</span><span>)</span><span> </span><span>AS</span><span> </span><span>name</span>
</span><span><span>    </span><span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>0</span><span>,</span><span> </span><span>(</span><span>random</span><span>()</span><span> </span><span>*</span><span> </span><span>10</span><span>)::</span><span>int</span><span>)</span>
</span><span><span>),</span>
</span><span>-- From here on it&#39;s roughly the same...</span>
<span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>        </span><span>SELECT</span><span> </span><span>name</span>
<span>        </span><span>FROM</span><span> </span><span>tags_to_insert</span><span> </span><span>t</span>
<span>        </span><span>WHERE</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>            </span><span>SELECT</span><span> </span><span>1</span>
<span>            </span><span>FROM</span><span> </span><span>tags</span>
<span>            </span><span>WHERE</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
<span>        </span><span>)</span>
<span>    </span><span>RETURNING</span><span> </span><span>*</span>
<span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span>
<span>UNION</span><span> </span><span>ALL</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>IN</span><span> </span><span>(</span>
<span>    </span><span>SELECT</span><span> </span><span>name</span>
<span>    </span><span>FROM</span><span> </span><span>new_tags</span>
<span>);</span>
</pre></div>


<p>We generate a random number of random tags to insert - some already exist in the table and some don&#39;t. This is supposed to mimic the behavior of real users in a real busy system. Next, use <a href="https://www.postgresql.org/docs/current/pgbench.html" rel="noopener"><code>pgbench</code></a> to execute this concurrently:</p>
<div><pre><span></span>$<span> </span>pgbench<span> </span>--client<span>=</span><span>4</span><span> </span>--time<span>=</span><span>30</span><span> </span>-f<span> </span>get_or_create.sql
pgbench<span> </span><span>(</span><span>15</span>.4<span>)</span>
pgbench:<span> </span>error:<span> </span>client<span> </span><span>1</span><span> </span>script<span> </span><span>0</span><span> </span>aborted<span> </span><span>in</span><span> </span><span>command</span><span> </span><span>0</span><span> </span>query<span> </span><span>0</span>:<span> </span>ERROR:<span>  </span>duplicate<span> </span>key<span> </span>value<span> </span>violates<span> </span>unique<span> </span>constraint<span> </span><span>&#34;tags_name_key&#34;</span>
DETAIL:<span>  </span>Key<span> </span><span>(</span>name<span>)=(</span>tag625<span>)</span><span> </span>already<span> </span>exists.
pgbench:<span> </span>error:<span> </span>client<span> </span><span>0</span><span> </span>script<span> </span><span>0</span><span> </span>aborted<span> </span><span>in</span><span> </span><span>command</span><span> </span><span>0</span><span> </span>query<span> </span><span>0</span>:<span> </span>ERROR:<span>  </span>duplicate<span> </span>key<span> </span>value<span> </span>violates<span> </span>unique<span> </span>constraint<span> </span><span>&#34;tags_name_key&#34;</span>
DETAIL:<span>  </span>Key<span> </span><span>(</span>name<span>)=(</span>tag950<span>)</span><span> </span>already<span> </span>exists.
pgbench:<span> </span>error:<span> </span>client<span> </span><span>3</span><span> </span>script<span> </span><span>0</span><span> </span>aborted<span> </span><span>in</span><span> </span><span>command</span><span> </span><span>0</span><span> </span>query<span> </span><span>0</span>:<span> </span>ERROR:<span>  </span>duplicate<span> </span>key<span> </span>value<span> </span>violates<span> </span>unique<span> </span>constraint<span> </span><span>&#34;tags_name_key&#34;</span>
DETAIL:<span>  </span>Key<span> </span><span>(</span>name<span>)=(</span>tag522<span>)</span><span> </span>already<span> </span>exists.
pgbench:<span> </span>error:<span> </span>client<span> </span><span>2</span><span> </span>script<span> </span><span>0</span><span> </span>aborted<span> </span><span>in</span><span> </span><span>command</span><span> </span><span>0</span><span> </span>query<span> </span><span>0</span>:<span> </span>ERROR:<span>  </span>duplicate<span> </span>key<span> </span>value<span> </span>violates<span> </span>unique<span> </span>constraint<span> </span><span>&#34;tags_name_key&#34;</span>
DETAIL:<span>  </span>Key<span> </span><span>(</span>name<span>)=(</span>tag869<span>)</span><span> </span>already<span> </span>exists.
<span>[</span>...<span>]</span>
pgbench:<span> </span>error:<span> </span>Run<span> </span>was<span> </span>aborted<span>;</span><span> </span>the<span> </span>above<span> </span>results<span> </span>are<span> </span>incomplete.
</pre></div>


<p>It took just a fraction of a second before the script started failing with unique constraint violations! In a real system, this can cause some very strange errors.</p>
<p>We constructed our query to make sure that unique constraint violations can never happen, so how come they did? Apparently, it is possible that in the fraction of a millisecond between the time we checked that the tag does not exist and the time we actually inserted it into the table, another process managed to insert the same value, causing a unique constraint violation. This is similar to what we experienced in one of our first attempts, only this time it happens within a single query!</p>
<p>To recap, this approach achieves two goals but it suffers from one significant issue:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process doesn&#39;t generate bloat</li>
<li>❌ The process is not safe to execute concurrently</li>
</ul>
<p>Next, we&#39;ll explore ways to make the process safe when executed by many users at the same time.</p>
<h3 id="handling-conflicts-gracefully"><a href="#handling-conflicts-gracefully">Handling Conflicts Gracefully</a></h3>
<p>In procedural programming languages there are two prominent coding styles:</p>
<ul>
<li>
<p><strong>&#34;Look before you leap&#34; (LBYL)</strong> dictates that you should explicitly test for pre-conditions before executing an operation. This style is popular in languages such as Java and C.</p>
</li>
<li>
<p><strong>&#34;Easier to ask for forgiveness than permission&#34; (EAFP)</strong> suggests that it is better to attempt an operation and then handle any possible exception. This approach is encouraged in languages such as Python.</p>
</li>
</ul>
<p>SQL is rarely talked about in terms of traditional programming languages but we can actually classify both of our previous approaches to these coding styles:</p>
<ul>
<li>
<p><code>INSERT</code>, <code>EXCEPT</code>, <code>SELECT</code>: In our first approach we tried to insert a new tag without checking anything in advance, and then handled a unique constraint violation. This is &#34;asking for forgiveness&#34;.</p>
</li>
<li>
<p><code>INSERT WHERE NOT EXISTS</code>: In our second approach we tried to avoid unique constraint violations by checking that values don&#39;t exist before we attempted to insert. This is &#34;look before you leap&#34;.</p>
</li>
</ul>
<p>&#34;Look before you leap&#34; approaches often suffer from an issue called <a href="https://hakibenita.com/django-concurrency#time-of-check-to-time-of-use" rel="noopener">&#34;time-of-check to time-of-use&#34;</a>. This issue arises when the underlying data changes between the time we check a certain condition and the time we rely on it. In our case, we check that the tag don&#39;t already exists (<em>&#34;time-of-check&#34;</em>) and then rely on this check when we attempt to create it (<em>&#34;time-of-use&#34;</em>), but another process changed the underlying data in the meantime (added a tag by the same name), causing our process to fail.</p>

<p>If that&#39;s the case then, what would be the equivalent of &#34;asking for forgiveness&#34; in SQL?</p>
<p>To handle our &#34;TOC-TOU&#34; problem, we can resort to a special clause in the <code>INSERT</code> statement for handling conflicts:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>)</span>
<span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span><span>;</span>
</span>
<span>INSERT</span><span> </span><span>0</span><span> </span><span>1</span>
</pre></div>


<p>The <code>ON CONFLICT</code> clause allows us to declare what should happen in case a row we are trying to insert encounters a conflict. In this case, we declared that if we encounter a conflict in a tag&#39;s name, we should <code>DO NOTHING</code>. By ignoring conflicting rows our command did&#39;t fail with a unique constraint violation. Instead, it completed successfully and inserted 1 row.</p>
<p>Next, let&#39;s try to add a <code>RETURNING</code> clause:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>)</span>
<span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
<span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
</span><span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>

<span>INSERT</span><span> </span><span>0</span><span> </span><span>1</span>
</pre></div>


<p>Two important things to notice here:</p>
<ol>
<li>
<p><strong>Only modified data is returned</strong>: the new tag &#34;C&#34; was returned but the existing tag &#34;B&#34; was not.</p>
</li>
<li>
<p><strong>We have a gap in the sequence</strong>: PostgresSQL fetched the next value 3 from the sequence when it attempted to insert the value &#34;B&#34;. A tag &#34;B&#34; already exists so there is a conflict. Because we defined <code>ON CONFLICT DO NOTHING</code>, the statement carried on, discarded the sequence value 3 and did not fail. The next value to insert was &#34;C&#34; and the next value 4 was taken from the sequence. The value &#34;C&#34; does not exist in the table so a new tag with id 4 was created, and we are left with a gap.</p>
</li>
</ol>
<div>
<p>Gap-less Sequences in PostgreSQL</p>
<p>PostgreSQL sequences are not guaranteed to be gap-less. This is just an observation, not a strict downside to this approach.</p>
</div>
<p>From the last attempt we reckon that PostgreSQL will not return a row that was not modified by the statement. The <a href="https://www.postgresql.org/docs/current/sql-insert.html" rel="noopener">documentation for <code>INSERT</code></a> confirms:</p>
<blockquote>
<p>Only rows that were successfully inserted or updated will be returned.</p>
</blockquote>
<p>We already worked around this issue, so let&#39;s adjust the query to execute the <code>INSERT</code> in a <code>WITH</code> clause and then append the existing tags in the main query:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>WITH</span>
<span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>)</span>
<span>    </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
<span>    </span><span>RETURNING</span><span> </span><span>*</span>
<span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>IN</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>,</span><span> </span><span>&#39;C&#39;</span><span>)</span>
<span>UNION</span><span> </span><span>ALL</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span><span>;</span>

<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>This works as expected and achieves our first goal of providing idempotency - no matter how many times we execute this, we&#39;ll always get the same output.</p>
<p>To check if our second goal of preventing unnecessary bloat is achieved we once again disable &#34;autovacuum&#34; and insert 50K tags that already exist:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span> </span><span>SET</span><span> </span><span>(</span><span>autovacuum_enabled</span><span> </span><span>=</span><span> </span><span>false</span><span>);</span>
<span>SET</span>

<span>-- Generate an array with 50K values &#39;A&#39; and store it in a psql variable called &#34;names&#34;</span>
<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>array_agg</span><span>(</span><span>&#39;A&#39;</span><span>::</span><span>text</span><span>)</span><span> </span><span>AS</span><span> </span><span>names</span><span> </span><span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>1</span><span>,</span><span> </span><span>50000</span><span>)</span><span> </span><span>\</span><span>gset</span>

<span>db</span><span>=#</span><span> </span><span>\</span><span>timing</span><span> </span><span>on</span>
<span>Timing</span><span> </span><span>is</span><span> </span><span>on</span><span>.</span>

<span>db</span><span>=#</span><span> </span><span>WITH</span>
<span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>    </span><span>SELECT</span><span> </span><span>unnest</span><span>(:</span><span>&#39;names&#39;</span><span>::</span><span>text</span><span>[])</span>
<span>    </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
<span>    </span><span>RETURNING</span><span> </span><span>*</span>
<span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>ANY</span><span>(:</span><span>&#39;names&#39;</span><span>::</span><span>text</span><span>[])</span>
<span>UNION</span><span> </span><span>ALL</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span><span>;</span>

<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>

<span>Time</span><span>:</span><span> </span><span>96</span><span>.</span><span>028</span><span> </span><span>ms</span>
</pre></div>


<p>No tags were actually added and the statement completed very quickly. Check the size and the number of dead tuples:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>));</span>
<span> </span><span>pg_size_pretty</span>
<span>────────────────</span>
<span> </span><span>8192</span><span> </span><span>bytes</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>relname</span><span>,</span><span> </span><span>n_dead_tup</span><span>,</span><span> </span><span>n_live_tup</span>
<span>FROM</span><span> </span><span>pg_stat_user_tables</span>
<span>WHERE</span><span> </span><span>relname</span><span> </span><span>=</span><span> </span><span>&#39;tags&#39;</span><span>;</span>
<span> </span><span>relname</span><span> </span><span>│</span><span> </span><span>n_dead_tup</span><span> </span><span>│</span><span> </span><span>n_live_tup</span>
<span>─────────┼────────────┼────────────</span>
<span> </span><span>tags</span><span>    </span><span>│</span><span>          </span><span>0</span><span> </span><span>│</span><span>          </span><span>2</span>
</pre></div>


<p>Size is the same and no dead tuples - our second goal of preventing unnecessary bloat is also achieved.</p>
<div>
<p>speculative insertion</p>
<p>The <code>ON CONFLICT</code> clause is using a different infrastructure for handling conflicts called &#34;speculative insertion&#34;. Unlike &#34;regular&#34; insertion, using &#34;speculative insertion&#34; a pre-check of unique and exclusion constraints is made <em>before</em> the row is inserted into the table, thus preventing bloat in case of violation. The <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=168d5805e4c08bed7b95d351bf097cff7c07dd65" rel="noopener">original commit message</a> offers more details about this infrastructure.</p>
</div>
<p>Finally, To check if the process is also safe when executed by many users concurrently, we prepare a script to insert random amount of random tags into the table:</p>
<div><pre><span></span><span>-- get_or_create_on_conflict.sql</span>
<span>WITH</span>
<span>-- Generate a random amount of random tags</span>
<span>tags_to_insert</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>SELECT</span><span> </span><span>&#39;tag&#39;</span><span> </span><span>||</span><span> </span><span>round</span><span>(</span><span>random</span><span>()</span><span> </span><span>*</span><span> </span><span>1000</span><span>)</span><span> </span><span>AS</span><span> </span><span>name</span>
<span>    </span><span>FROM</span><span> </span><span>generate_series</span><span>(</span><span>0</span><span>,</span><span> </span><span>(</span><span>random</span><span>()</span><span> </span><span>*</span><span> </span><span>10</span><span>)::</span><span>int</span><span>)</span>
<span>),</span>
<span>-- From here on it&#39;s roughly the same...</span>
<span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>    </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>      </span><span>SELECT</span><span> </span><span>name</span><span> </span><span>FROM</span><span> </span><span>tags_to_insert</span>
<span>    </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
<span>    </span><span>RETURNING</span><span> </span><span>*</span>
<span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span>
<span>UNION</span><span> </span><span>ALL</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>IN</span><span> </span><span>(</span><span>SELECT</span><span> </span><span>name</span><span> </span><span>FROM</span><span> </span><span>tags_to_insert</span><span>);</span>
</pre></div>


<p>Execute with <code>pgbench</code>:</p>
<div><pre><span></span>$<span> </span>pgbench<span> </span>--client<span>=</span><span>4</span><span> </span>--time<span>=</span><span>30</span><span> </span>-f<span> </span>get_or_create_on_conflict.sql
pgbench<span> </span><span>(</span><span>15</span>.4<span>)</span>
end.
transaction<span> </span>type:<span> </span>get_or_create_on_conflict.sql
scaling<span> </span>factor:<span> </span><span>1</span>
query<span> </span>mode:<span> </span>simple
number<span> </span>of<span> </span>clients:<span> </span><span>4</span>
number<span> </span>of<span> </span>threads:<span> </span><span>1</span>
maximum<span> </span>number<span> </span>of<span> </span>tries:<span> </span><span>1</span>
duration:<span> </span><span>30</span><span> </span>s
number<span> </span>of<span> </span>transactions<span> </span>actually<span> </span>processed:<span> </span><span>109499</span>
number<span> </span>of<span> </span>failed<span> </span>transactions:<span> </span><span>0</span><span> </span><span>(</span><span>0</span>.000%<span>)</span>
latency<span> </span><span>average</span><span> </span><span>=</span><span> </span><span>1</span>.095<span> </span>ms
initial<span> </span>connection<span> </span><span>time</span><span> </span><span>=</span><span> </span><span>24</span>.556<span> </span>ms
<span>tps</span><span> </span><span>=</span><span> </span><span>3652</span>.536348<span> </span><span>(</span>without<span> </span>initial<span> </span>connection<span> </span><span>time</span><span>)</span>
</pre></div>


<p>Great! Using <code>ON CONFLICT</code> we achieve 3 of our goals:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process doesn&#39;t generate bloat</li>
<li>✅ The process is safe to execute concurrently</li>
</ul>
<p>Next we&#39;ll look into a few more aspects of &#34;get or create&#34;.</p>
<h3 id="taking-a-wrong-turn"><a href="#taking-a-wrong-turn">Taking a Wrong Turn</a></h3>
<p>In all the solutions we came up with so far we essentially hit the table twice - once to insert new values and ignore conflicts, and another to get existing values. If you are anything like me, this really bugs you.</p>
<p>At some point I thought to myself <em>&#34;Hey! <code>ON CONFLICT</code> only return rows that were affected by the command, so what if instead of ignoring conflicts, I&#39;ll perform some meaningless update to &#34;affect&#34; them so they will be returned.&#34;</em>. This is what I came up with:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>)</span>
<span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>UPDATE</span><span> </span><span>SET</span><span> </span><span>id</span><span> </span><span>=</span><span> </span><span>EXCLUDED</span><span>.</span><span>id</span>
</span><span>RETURNING</span><span> </span><span>*</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>

<span>INSERT</span><span> </span><span>0</span><span> </span><span>2</span>
</pre></div>


<p>Look at that... so elegant <em>and</em> gets the job done! Now, when we encounter a tag that already exist we update the id to its current value, a meaningless update that will never actually change the data, <em>BUT</em>, will cause every affected row to be updated and returned by <code>RETURNING *</code>.</p>
<p>This approach supposedly touches a row just once, but it has a very significant downside!</p>
<p>In PostgreSQL, when you update a row you essentially delete and insert a new row. The deleted row is marked as dead and consumes space until it is cleaned up by a vacuum process. We once again have a bloat issue!</p>
<p>To demonstrate how this approach can cause significant bloat, get the size of the table and its indexes <em>before</em> we do anything:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span>
<span>    </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>))</span><span> </span><span>table_size</span><span>,</span>
<span>    </span><span>pg_size_pretty</span><span>(</span><span>pg_total_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>)</span><span> </span><span>-</span><span> </span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>))</span><span> </span><span>indexes_size</span><span>;</span>
<span> </span><span>table_size</span><span> </span><span>│</span><span> </span><span>indexes_size</span>
<span>────────────┼──────────────</span>
<span> </span><span>8192</span><span> </span><span>bytes</span><span> </span><span>│</span><span> </span><span>32</span><span> </span><span>kB</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>Next, &#34;get or create&#34; tags 50K times using our &#34;elegant&#34; approach:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span> </span><span>SET</span><span> </span><span>(</span><span>autovacuum_enabled</span><span> </span><span>=</span><span> </span><span>false</span><span>);</span>
<span>ALTER</span><span> </span><span>TABLE</span>

<span>db</span><span>=#</span><span> </span><span>DO</span><span> </span><span>$$</span>
<span>BEGIN</span>
<span>    </span><span>FOR</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>1</span><span>..</span><span>50000</span><span> </span><span>loop</span>
<span>        </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;D&#39;</span><span>)</span>
<span>        </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span>
<span><span>        </span><span>DO</span><span> </span><span>UPDATE</span><span> </span><span>SET</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>EXCLUDED</span><span>.</span><span>name</span><span>;</span>
</span><span>    </span><span>END</span><span> </span><span>LOOP</span><span>;</span>
<span>END</span><span> </span><span>$$</span><span>;</span>

<span>Time</span><span>:</span><span> </span><span>57331</span><span>.</span><span>141</span><span> </span><span>ms</span><span> </span><span>(</span><span>00</span><span>:</span><span>57</span><span>.</span><span>331</span><span>)</span>
</pre></div>


<p>This took a very long time (~1 minute), but the data barely changed:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>D</span>
</pre></div>


<p>Next, check the sizes of the table and its indexes <em>after</em> the operation:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>SELECT</span>
<span>    </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>))</span><span> </span><span>table_size</span><span>,</span>
<span>    </span><span>pg_size_pretty</span><span>(</span><span>pg_total_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>)</span><span> </span><span>-</span><span> </span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>))</span><span> </span><span>indexes_size</span><span>;</span>
<span> </span><span>table_size</span><span> </span><span>│</span><span> </span><span>indexes_size</span>
<span>────────────┼──────────────</span>
<span> </span><span>3544</span><span> </span><span>kB</span><span>    </span><span>│</span><span> </span><span>64</span><span> </span><span>kB</span>
</pre></div>


<p>That&#39;s a big difference! The size of the table is now ~50 times bigger and the indexes are twice as big. To clear up that bloat we need to vacuum the table and reindex the indexes:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>VACUUM</span><span> </span><span>FULL</span><span> </span><span>tags</span><span>;</span>
<span>VACUUM</span>

<span>db</span><span>=#</span><span> </span><span>REINDEX</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span>REINDEX</span>

<span>db</span><span>=#</span><span> </span><span>SELECT</span>
<span>    </span><span>pg_size_pretty</span><span>(</span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>))</span><span> </span><span>table_size</span><span>,</span>
<span>    </span><span>pg_size_pretty</span><span>(</span><span>pg_total_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>)</span><span> </span><span>-</span><span> </span><span>pg_relation_size</span><span>(</span><span>&#39;tags&#39;</span><span>))</span><span> </span><span>indexes_size</span><span>;</span>
<span> </span><span>table_size</span><span> </span><span>│</span><span> </span><span>indexes_size</span>
<span>────────────┼──────────────</span>
<span> </span><span>8192</span><span> </span><span>bytes</span><span> </span><span>│</span><span> </span><span>32</span><span> </span><span>kB</span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span>
</pre></div>


<p>This approach takes us back:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>❌ The process generates bloat</li>
<li>✅ The process is safe to execute concurrently</li>
</ul>
<p>To recap, <strong>don&#39;t do it!</strong></p>
<h3 id="avoiding-schema-changes"><a href="#avoiding-schema-changes">Avoiding Schema Changes</a></h3>
<p><code>INSERT ON CONFLICT</code> is a very powerful command, but it does have one limitation that&#39;s worth mentioning. To match rows, <code>INSERT ON CONFLICT</code> requires that the target table will have either a unique constraint or an exclusion constraint on the matched columns.</p>
<p>Imagine we don&#39;t have a unique constraint on the tag name:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span> </span><span>DROP</span><span> </span><span>CONSTRAINT</span><span> </span><span>tags_name_key</span><span>;</span>
<span>ALTER</span><span> </span><span>TABLE</span>
</pre></div>


<p>Now, if we try to sync tags using <code>INSERT ON CONFLICT</code> we&#39;ll get an error:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>)</span><span> </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span><span>;</span>
<span>ERROR</span><span>:</span><span>  </span><span>there</span><span> </span><span>is</span><span> </span><span>no</span><span> </span><span>unique</span><span> </span><span>or</span><span> </span><span>exclusion</span><span> </span><span>constraint</span><span> </span><span>matching</span><span> </span><span>the</span><span> </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>specification</span>
</pre></div>


<p>In some situations we do have a unique constraint on the columns we match by. In other situations we don&#39;t, or we are unable to because we want to match by complicated conditions that are hard to express using constraints. Exclusion constraints are useful for enforcing constraint on complicated conditions, but they also come with their own cost, namely having to maintain an index to enforce the constraint. In some environments such as data warehouses, maintaining indexes just to enforce constraints may be undesirable.</p>
<p>Starting with PostgreSQL 15 there is another option to sync data, the <code>MERGE</code> statement. There are some subtle differences between <code>MERGE</code> and <code>INSERT ON CONFLICT</code> which are relevant to this type of tasks:</p>
<ul>
<li><code>INSERT ON CONFLICT</code> can only insert or update, <code>MERGE</code> can also delete.</li>
</ul>
<p>Imagine your input was a list of tags <em>and</em> an indication whether they were deleted or not in the source. You want to sync the data such that if a tag was deleted in the source, you either delete it from your target table or avoid creating it in the first place. Using <code>INSERT ON CONFLICT</code> you would have to break this up into multiple <code>WITH</code> clauses, but using <code>MERGE</code> it&#39;s possible with just one statement:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>(</span><span> </span><span>2</span><span> </span><span>rows</span><span>)</span>

<span>db</span><span>=#</span><span> </span><span>MERGE</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>USING</span><span> </span><span>(</span><span>VALUES</span>
<span>    </span><span>(</span><span>&#39;A&#39;</span><span>,</span><span> </span><span>false</span><span>),</span>
<span>    </span><span>(</span><span>&#39;B&#39;</span><span>,</span><span> </span><span>true</span><span>),</span>
<span>    </span><span>(</span><span>&#39;C&#39;</span><span>,</span><span> </span><span>false</span><span>),</span>
<span>    </span><span>(</span><span>&#39;D&#39;</span><span>,</span><span> </span><span>true</span><span>)</span>
<span>)</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>,</span><span> </span><span>deleted</span><span>)</span>
<span>    </span><span>ON</span><span> </span><span>t</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>tags</span><span>.</span><span>name</span>
<span><span>    </span><span>WHEN</span><span> </span><span>MATCHED</span><span> </span><span>AND</span><span> </span><span>deleted</span><span> </span><span>THEN</span><span> </span><span>DELETE</span>
</span><span><span>    </span><span>WHEN</span><span> </span><span>MATCHED</span><span> </span><span>AND</span><span> </span><span>NOT</span><span> </span><span>deleted</span><span> </span><span>THEN</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
</span><span><span>    </span><span>WHEN</span><span> </span><span>NOT</span><span> </span><span>MATCHED</span><span> </span><span>AND</span><span> </span><span>deleted</span><span> </span><span>THEN</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
</span><span><span>    </span><span>WHEN</span><span> </span><span>NOT</span><span> </span><span>MATCHED</span><span> </span><span>AND</span><span> </span><span>NOT</span><span> </span><span>deleted</span><span> </span><span>THEN</span><span> </span><span>INSERT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>t</span><span>.</span><span>name</span><span>);</span>
</span><span>MERGE</span><span> </span><span>1</span>

<span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>3</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>That is beautiful! We handle four different scenarios in this <code>MERGE</code> command:</p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>Source</th>
<th>Target</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#34;A&#34;</td>
<td>deleted</td>
<td>present</td>
<td>delete</td>
</tr>
<tr>
<td>&#34;B&#34;</td>
<td>not deleted</td>
<td>present</td>
<td>skip (do nothing)</td>
</tr>
<tr>
<td>&#34;C&#34;</td>
<td>not deleted</td>
<td>not present</td>
<td>insert</td>
</tr>
<tr>
<td>&#34;D&#34;</td>
<td>deleted</td>
<td>not present</td>
<td>ignore (do nothing)</td>
</tr>
</tbody>
</table>
<p>This type of syncing logic is very common in ETL processes so <code>MERGE</code> comes in very handy.</p>
<ul>
<li><code>INSERT ON CONFLICT</code> requires a unique constraint on the matched rows, <code>MERGE</code> does not.</li>
</ul>
<p>As we already saw, if we try to use <code>INSERT ON CONFLICT</code> without a constraint on the column we match by we&#39;ll get an error:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>(</span><span>name</span><span>)</span>
<span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>)</span>
<span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>DO</span><span> </span><span>NOTHING</span>
<span><span>ERROR</span><span>:</span><span> </span><span>there</span><span> </span><span>is</span><span> </span><span>no</span><span> </span><span>unique</span><span> </span><span>or</span><span> </span><span>exclusion</span><span> </span><span>constraint</span>
</span><span><span>matching</span><span> </span><span>the</span><span> </span><span>ON</span><span> </span><span>CONFLICT</span><span> </span><span>specification</span>
</span></pre></div>


<p><code>MERGE</code> dosen&#39;t have this limitation:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>MERGE</span><span> </span><span>INTO</span><span> </span><span>tags</span><span> </span><span>USING</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>)</span>
<span><span>ON</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
</span><span>WHEN</span><span> </span><span>NOT</span><span> </span><span>MATCHED</span><span> </span><span>THEN</span><span> </span><span>INSERT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>t</span><span>.</span><span>name</span><span>);</span>
<span>MERGE</span><span> </span><span>0</span>

<span>db</span><span>=#</span><span> </span><span>TABLE</span><span> </span><span>tags</span><span>;</span>
<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>1</span><span> </span><span>│</span><span> </span><span>A</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>(</span><span>3</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p><code>MERGE</code> allows us to provide a condition to match by while <code>INSERT ON CONFLICT</code> only accepts columns or a constraint name. The ability to provide a condition rather than relaying on a constraint is very powerful - it allows us to match on complicated conditions that cannot always be (easily) expressed using a unique or exclusion constraint. One example which comes to mind is syncing data into a <a href="https://en.wikipedia.org/wiki/Slowly_changing_dimension" rel="noopener">slowly changing dimension</a>.</p>
<p>Moving back to our tags table. The <code>MERGE</code> statement is not providing anything we can&#39;t do with <code>INSERT ON CONFLICT</code>. However, under some real-life circumstances we might want to use it if the syncing logic gets complicated. Unfortunately, the <code>MERGE</code> statement as of PostgreSQL 16 does not include a <code>RETURNING</code> clause so we can&#39;t use it in a <code>WITH</code> clause with <code>RETURNING</code>. This is about to change in PostgreSQL 17, when <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=c649fa24a42ba89bf5460c7110e4fc8eeca65959" rel="noopener"><code>MERGE</code> gains support for the <code>RETURNING</code> clause</a>.</p>
<p>Starting at PostgreSQL 17 we should be able to use <code>MERGE</code> with <code>RETURNING</code>:</p>
<div><pre><span></span><span>db</span><span>=#</span><span> </span><span>WITH</span>
<span>new_tags</span><span> </span><span>AS</span><span> </span><span>(</span>
<span>  </span><span>MERGE</span><span> </span><span>INTO</span><span> </span><span>tags</span>
<span>  </span><span>USING</span><span> </span><span>(</span><span>VALUES</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>),</span><span> </span><span>(</span><span>&#39;C&#39;</span><span>))</span><span> </span><span>AS</span><span> </span><span>t</span><span>(</span><span>name</span><span>)</span>
<span>  </span><span>ON</span><span> </span><span>tags</span><span>.</span><span>name</span><span> </span><span>=</span><span> </span><span>t</span><span>.</span><span>name</span>
<span>  </span><span>WHEN</span><span> </span><span>NOT</span><span> </span><span>MATCHED</span><span> </span><span>THEN</span><span> </span><span>INSERT</span><span> </span><span>(</span><span>name</span><span>)</span><span> </span><span>VALUES</span><span> </span><span>(</span><span>t</span><span>.</span><span>name</span><span>)</span>
<span><span>  </span><span>RETURNING</span><span> </span><span>*</span>
</span><span>)</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>tags</span><span> </span><span>WHERE</span><span> </span><span>name</span><span> </span><span>IN</span><span> </span><span>(</span><span>&#39;B&#39;</span><span>,</span><span> </span><span>&#39;C&#39;</span><span>)</span>
<span>UNION</span><span> </span><span>ALL</span>
<span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> </span><span>new_tags</span><span>;</span>

<span> </span><span>id</span><span> </span><span>│</span><span> </span><span>name</span>
<span>────┼──────</span>
<span>  </span><span>4</span><span> </span><span>│</span><span> </span><span>C</span>
<span>  </span><span>2</span><span> </span><span>│</span><span> </span><span>B</span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span>
</pre></div>


<p>The main advantage of using <code>MERGE</code> instead of <code>INSERT ON CONFLICT</code> is that it doesn&#39;t require any constraints on the target table. Here is a recap of this approach:</p>
<ul>
<li>✅ The process is idempotent</li>
<li>✅ The process doesn&#39;t generate bloat</li>
<li>✅ The process is safe to execute concurrently</li>
<li>✅ The process doesn&#39;t require constraints</li>
</ul>
<hr/>
<h2 id="summary"><a href="#summary">Summary</a></h2>
<p>&#34;Get or create&#34; is a very common operation in both OLTP and data warehouse systems. However, as we&#39;ve seen in this article, implementing it correctly may be trickier than you might think.</p>
<h3 id="comparison"><a href="#comparison">Comparison</a></h3>
<p>We covered the following aspects of implementing &#34;get or create&#34; in PostgreSQL:</p>
<ul>
<li>
<p><strong>Idempotency</strong>: The process should provide the same output regardless of the state of the data. If the tags we wish to insert exist or not in the table, should not affect the outcome of the operation.</p>
</li>
<li>
<p><strong>Concurrency</strong>: The process should be safe to execute under heavy load. The fact many connections are executing the process at the same time should not affect the outcome of the operation.</p>
</li>
<li>
<p><strong>Bloat</strong>: The process should produce the desired result with as little side effects as possible. Generating bloat has significant affect on overall performance and may come at a significant storage and maintenance cost.</p>
</li>
<li>
<p><strong>Constraints</strong>: The process should require as little schema changes as possible. As we&#39;ve seen, some operations require unique or exclusion constraints which may be undesirable or even impossible.</p>
</li>
</ul>
<p>Here is a table to summarize the approaches we presented:</p>

<h3 id="takeaways"><a href="#takeaways">Takeaways</a></h3>
<p>Here are some of the takeaways from our process to find the ideal &#34;get or create&#34; solution in PostgreSQL:</p>
<ul>
<li>
<p><strong>Unique constraint violations can cause bloat</strong>: new or updated rows are first written to the table and only then checked for duplicates. If there is a violation, the row is marked as dead which causes bloat. To avoid bloat use <code>INSERT ON CONFLICT</code> instead.</p>
</li>
<li>
<p><strong><code>WITH</code> clauses are not executed in the order in which they are written</strong>: they are executed concurrently with each other.</p>
</li>
<li>
<p><strong><code>WITH</code> clauses do not guarantee complete consistency</strong>: changes to the underlying data between different <code>WITH</code> clauses can cause concurrency issues.</p>
</li>
<li>
<p><strong>Changes to the table in a <code>WITH</code> clause are not visible to other parts of the query</strong>: due to visibility rules, all parts of the query see the table as is was when the query began. The only way to communicate changes between parts of a query is using the <code>RETURNING</code> clause.</p>
</li>
<li>
<p><strong><code>INSERT ON CONFLICT</code> requires unique or exclusion constraint on the matching columns</strong>: to make use of the <code>ON CONFLICT</code> cause you must have either a unique or an exclusion constraint on the fields you match by. If this is not the case, use <code>MERGE</code> instead.</p>
</li>
</ul>
    </article></div>
  </body>
</html>
