<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dylanj.xyz/posts/rust-coq-opaque-types/">Original</a>
    <h1>Formally Verifying Rust&#39;s Opaque Types</h1>
    
    <div id="readability-page-1" class="page"><div><p>The other day I was reading <a href="https://varkor.github.io/blog/2018/07/03/existential-types-in-rust.html">this blog post</a> covering existential types in Rust (also known as <code>impl Trait</code> or opaque types). In that blog post, the author makes the following claim.</p><blockquote><p>We‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type.</p></blockquote><p>In particular the <code>((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))</code> caught my eye. While I was working for <a href="https://www.originate.com/">Originate</a> in San Francisco back in 2017 I used my 20% time project to study Benjamin C. Pierce‚Äôs excellent <a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a> series which teaches how to structure and formally verify software using the Coq Proof Assistant <a href="https://www.theregister.com/2021/06/15/coq_programming_language_change/">(yes, it‚Äôs pronounced exactly how you think, üôÑ)</a>. It completely changed the way I look at programming for the better but it‚Äôs not a skill that I get to practice regularly and as you get older you have to either use it or lose it. So I thought I‚Äôd try my hand at seeing if I remembered enough of Coq to be able to prove the above statement.</p><p>To understand why we even care about the above proposition, it‚Äôs worth taking a moment to understand how <code>impl Trait</code> is used in Rust, if you‚Äôre not interested in Rust and just want to get to the Coq tutorial you should skip this section and jump head to <a href="#coq">#Coq</a></p><p>In Rust, to abstract over common functionality, we have Traits (interfaces in most other languages). Below is the simple <code>ToString</code> trait from the standard library.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>trait</span><span> </span><span>ToString</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>fn</span> <span>to_string</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>String</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>If we want to write a function that accepts things that can be turned into strings we have a few different options depending on whether we want static or dynamic dispatch. To demonstrate the available options we‚Äôll use a contrived toy function <code>yell</code> which turns the input into a string, convert it to all caps, and prints it to stdout.</p><h2 id="static-dispatch">Static Dispatch</h2><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>yell</span><span>&lt;</span><span>S</span>: <span>ToString</span><span>&gt;</span><span>(</span><span>stringable</span>: <span>S</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>println!</span><span>(</span><span>stringable</span><span>.</span><span>to_string</span><span>().</span><span>to_uppercase</span><span>())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>In Rust, generics are monomorphised. The compiler will create a copy and unique name for each type the function is called with, meaning each method call on the trait points to one, and only one function so the call can be statically dispatched. For example</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>yell</span><span>(</span><span>42</span><span>);</span><span>
</span></span></span><span><span><span></span><span>yell</span><span>(</span><span>&#34;According to all known laws of aviation ...&#34;</span><span>);</span><span>
</span></span></span></code></pre></div><p>This will result in the creation of two functions for each call</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>yell__i32</span><span>(</span><span>stringable</span>: <span>i32</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>println!</span><span>(</span><span>stringable</span><span>.</span><span>to_string</span><span>().</span><span>to_uppercase</span><span>())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>yell__at_str</span><span>(</span><span>stringable</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>println!</span><span>(</span><span>stringable</span><span>.</span><span>to_string</span><span>().</span><span>to_uppercase</span><span>())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>transforming the call site also into their respective monomorphised functions</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>yell__i32</span><span>(</span><span>42</span><span>);</span><span>
</span></span></span><span><span><span></span><span>yell__at_str</span><span>(</span><span>&#34;According to all known laws of aviation ...&#34;</span><span>);</span><span>
</span></span></span></code></pre></div><p>So when we call the trait method <code>to_string()</code> in each of those monomorphised functions, the rust compiler knows precisely which function call to make and doesn‚Äôt require chasing pointers (dynamic dispatch). It also means the stack layouts of calling those functions can differ but we‚Äôll get into that in a moment when talking about trait objects and object safety (spoilers!).</p><h2 id="dynamic-dispatch">Dynamic Dispatch</h2><p>Another way to write our yell function is</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>yell</span><span>(</span><span>stringable</span>: <span>&amp;</span><span>dyn</span><span> </span><span>ToString</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>println!</span><span>(</span><span>stringable</span><span>.</span><span>to_string</span><span>().</span><span>to_uppercase</span><span>())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>which from the name of this subsection and the use of the <code>dyn</code> keyword may have tipped you off to the fact it uses dynamic dispatch. If you‚Äôre familiar with how interfaces work in Golang then you already know what‚Äôs going on here.</p><p>In this case, rust doesn‚Äôt copy the yell method for each type it‚Äôs called with but instead <code>&amp;dyn ToString</code> is often what‚Äôs known as a ‚Äúfat pointer‚Äù. In that, it contains two pointers, one to the data, and one to the vtable for the methods of the trait.</p><p><svg xmlns="http://www.w3.org/2000/svg" font-family="Menlo,Lucida Console,monospace" viewBox="0 0 368 265"><g transform="translate(8,16)"><path d="M96 16H232" fill="none" stroke="currentcolor"></path><path d="M40 32H96" fill="none" stroke="currentcolor"></path><path d="M96 48H232" fill="none" stroke="currentcolor"></path><path d="M232 64h64" fill="none" stroke="currentcolor"></path><path d="M96 80H232" fill="none" stroke="currentcolor"></path><path d="M0 96H32" fill="none" stroke="currentcolor"></path><path d="M48 96H80" fill="none" stroke="currentcolor"></path><path d="M248 96h40" fill="none" stroke="currentcolor"></path><path d="M304 96h48" fill="none" stroke="currentcolor"></path><path d="M0 128H80" fill="none" stroke="currentcolor"></path><path d="M248 128H352" fill="none" stroke="currentcolor"></path><path d="M0 160H80" fill="none" stroke="currentcolor"></path><path d="M248 160H352" fill="none" stroke="currentcolor"></path><path d="M248 192H352" fill="none" stroke="currentcolor"></path><path d="M248 224H352" fill="none" stroke="currentcolor"></path><path d="M0 96v32" fill="none" stroke="currentcolor"></path><path d="M0 128v32" fill="none" stroke="currentcolor"></path><path d="M40 32V96" fill="none" stroke="currentcolor"></path><path d="M80 96v32" fill="none" stroke="currentcolor"></path><path d="M80 128v32" fill="none" stroke="currentcolor"></path><path d="M96 16V32" fill="none" stroke="currentcolor"></path><path d="M96 32V48" fill="none" stroke="currentcolor"></path><path d="M96 48V80" fill="none" stroke="currentcolor"></path><path d="M232 16V48" fill="none" stroke="currentcolor"></path><path d="M232 48V64" fill="none" stroke="currentcolor"></path><path d="M232 64V80" fill="none" stroke="currentcolor"></path><path d="M248 96v32" fill="none" stroke="currentcolor"></path><path d="M248 128v32" fill="none" stroke="currentcolor"></path><path d="M248 160v32" fill="none" stroke="currentcolor"></path><path d="M248 192v32" fill="none" stroke="currentcolor"></path><path d="M296 64V96" fill="none" stroke="currentcolor"></path><path d="M352 96v32" fill="none" stroke="currentcolor"></path><path d="M352 128v32" fill="none" stroke="currentcolor"></path><path d="M352 160v32" fill="none" stroke="currentcolor"></path><path d="M352 192v32" fill="none" stroke="currentcolor"></path><polygon points="48.000000,96.000000 36.000000,90.400002 36.000000,101.599998" fill="currentcolor" transform="rotate(90.000000, 40.000000, 96.000000)"></polygon><polygon points="304.000000,96.000000 292.000000,90.400002 292.000000,101.599998" fill="currentcolor" transform="rotate(90.000000, 296.000000, 96.000000)"></polygon><text text-anchor="middle" x="16" y="116" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="16" y="148" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="24" y="116" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="24" y="148" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="32" y="116" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="32" y="148" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="32" y="180" fill="currentcolor" style="font-size:1em">&amp;</text><text text-anchor="middle" x="40" y="116" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="40" y="148" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="40" y="180" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="48" y="116" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="48" y="148" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="48" y="180" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="56" y="116" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="56" y="148" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="56" y="180" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="64" y="116" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="112" y="68" fill="currentcolor" style="font-size:1em">v</text><text text-anchor="middle" x="120" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="120" y="68" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="128" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="128" y="68" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="68" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="144" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="144" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="152" y="68" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="160" y="36" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="168" y="36" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="168" y="68" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="176" y="36" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="176" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="184" y="36" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="184" y="68" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="192" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="192" y="68" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="200" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="200" y="68" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="208" y="36" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="208" y="68" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="216" y="68" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="264" y="116" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="264" y="148" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="264" y="180" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="264" y="212" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="272" y="116" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="272" y="148" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="272" y="180" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="272" y="212" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="280" y="116" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="280" y="148" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="280" y="180" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="280" y="212" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="280" y="244" fill="currentcolor" style="font-size:1em">v</text><text text-anchor="middle" x="288" y="116" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="288" y="148" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="288" y="180" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="288" y="212" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="288" y="244" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="296" y="116" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="296" y="180" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="296" y="212" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="296" y="244" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="304" y="116" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="304" y="180" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="304" y="212" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="304" y="244" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="312" y="116" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="312" y="180" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="312" y="212" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="312" y="244" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="320" y="116" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="320" y="180" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="320" y="212" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="320" y="244" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="328" y="116" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="328" y="180" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="328" y="212" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="336" y="116" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="336" y="212" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="344" y="212" fill="currentcolor" style="font-size:1em">)</text></g></svg></p><p>It‚Äôs called ‚Äúdynamic dispatch‚Äù because we don‚Äôt know which function we‚Äôre going to call until runtime when we follow the vtable pointer to find the particular <code>to_string()</code> method we‚Äôre going to call. Most of the time the overhead of this pointer chasing doesn‚Äôt matter and your application probably has performance bottlenecks elsewhere, but sometimes every pointer dereference counts.</p><h2 id="object-saftey">Object Saftey</h2><p>Beyond questionably legitimate concerns about performance, when you stop to think about how the compiler would layout the stack to call a dynamically dispatched function you may realise a fairly large limitation on what kinds of traits can be dynamically dispatched. <strong>They have to be the same size!</strong> Or more precisely, the function inputs and outputs must all be of the same size!</p><p>Think about the following trait from the standard library</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>trait</span><span> </span><span>Clone</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>clone</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>Self</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>What is the amount of space we need to leave on the stack when calling <code>clone()</code>? Well, it returns Self, which is whatever the type that implements clone is, so i32, i64, or String all take up different amounts of space on the stack so it‚Äôs impossible for us to figure out how to layout the stack at compile time when we don‚Äôt know the size of the type until runtime! This is what‚Äôs known in rust as <strong>Object Saftey</strong>. A trait that is <strong>not</strong> Object Safe contains methods with either its arguments or return values that do not have a constant size across all their possible implementations and therefore it is not safe to turn them into a <strong>Trait Object</strong> for dynamic dispatch.</p><p>In addition to trait methods that return Self, trait methods involving generic arguments or return values are also not ‚Äúobject safe‚Äù because the generic methods cannot be monomorphised behind a dynamic dispatch as it brushes up against the halting problem trying to figure how many entries of the monomorphised method are required in the vtable. If you tried to populate the vtable with every possible type in your application for each generic method it would grow enormous!</p><h2 id="impl-trait"><code>impl Trait</code></h2><p>So now we understand that sometimes we cannot even use dynamic dispatch even if we don‚Äôt care about the overhead from pointer chasing. We‚Äôre stuck with going back to our static dispatch approach of monomorphising generic functions.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>yell</span><span>&lt;</span><span>S</span>: <span>ToString</span><span>&gt;</span><span>(</span><span>stringable</span>: <span>S</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>println!</span><span>(</span><span>stringable</span><span>.</span><span>to_string</span><span>().</span><span>to_uppercase</span><span>())</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The additional syntactic and mental overhead of tracking those generic parameters isn‚Äôt so bad with a single generic parameter, but as the number of generic parameters grows, it can become unwieldy. For example, this function is taken from an application I‚Äôm working on that connects several different financial applications and follows the Ports and Adapters (also known as Clean or Hexagonal architecture) pattern of hiding concrete side effects behind simple interfaces and injecting them as needed.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>process</span><span>&lt;</span><span>E</span><span>,</span><span> </span><span>B</span><span>,</span><span> </span><span>S</span><span>&gt;</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>config</span>: <span>transformer</span>::<span>Config</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>expense_tracker</span>: <span>E</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>budget</span>: <span>B</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>state</span>: <span>S</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span>
</span></span></span><span><span><span></span><span>where</span><span>
</span></span></span><span><span><span>  </span><span>E</span>: <span>ExpenseTracker</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>B</span>: <span>Budget</span><span>,</span><span>
</span></span></span><span><span><span>  </span><span>S</span>: <span>State</span><span>,</span><span>
</span></span></span><span><span><span>   </span><span>{</span><span> </span><span>..</span><span>.</span><span> </span><span>}</span><span>
</span></span></span></code></pre></div><p>I don‚Äôt know about you, but I find that kind of hard to read, especially since we‚Äôre introducing generic parameters, E, B, and S and only at the end of the function definition are we giving them proper constraints. Luckily Rust has an answer! <code>impl Trait</code>. We can instead rewrite the above function as.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>process</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>config</span>: <span>transformer</span>::<span>Config</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>expense_tracker</span>: <span>impl</span><span> </span><span>ExpenseTracker</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>budget</span>: <span>impl</span><span> </span><span>Budget</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>state</span>: <span>impl</span><span> </span><span>State</span><span>,</span><span>
</span></span></span><span><span><span></span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span><span>
</span></span></span></code></pre></div><p>With this in mind you might be asking yourself why would you ever using dynamic dispatch over static. The main reason is when the dispatch is well, dynamic! Such as when you have a collection of trait objects.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>example</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>string</span><span> </span><span>=</span><span> </span><span>&#34;hello&#34;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>integer</span><span> </span><span>=</span><span> </span><span>3</span><span> </span><span>as</span><span> </span><span>i32</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>collection</span>: <span>Vec</span><span>&lt;&amp;</span><span>dyn</span><span> </span><span>ToString</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span><span>&amp;</span><span>string</span><span>,</span><span> </span><span>&amp;</span><span>integer</span><span>];</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Comparatively it is not possible to create a collection using <code>impl Trait</code>, nor is it possible to express this with generic constraints because the underlying opaque but concrete types are of different sizes.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>first</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>ToString</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>   </span><span>&#34;According to all known laws of aviation ...&#34;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>second</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>ToString</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>42</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>example</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>vec!</span><span>[</span><span>first</span><span>(),</span><span> </span><span>second</span><span>()];</span><span>
</span></span></span><span><span><span>    </span><span>//      Error ^^^
</span></span></span><span><span><span></span><span>    </span><span>// mismatched types
</span></span></span><span><span><span></span><span>    </span><span>// expected opaque type `impl ToString` (opaque type at &lt;src/main.rs:1:15&gt;)
</span></span></span><span><span><span></span><span>    </span><span>// found opaque type `impl ToString` (opaque type at &lt;src/main.rs:4:16&gt;)
</span></span></span><span><span><span></span><span>    </span><span>// distinct uses of `impl Trait` result in different opaque types
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>But how to understand what <code>impl Trait</code> means? One way to understand it is it‚Äôs saying that there exists a type (unnamed) that implements the trait, the fact that it‚Äôs unnamed is why <code>impl Trait</code> is often referred to as <strong>opaque types</strong>, or <strong>existential types</strong>. We‚Äôre taking for granted that a type, some type, exists that satisfies this trait, but is it always safe to take the prior generic function and transform it into the existential form and vice versa? The introductory paragraph claims that it always is <code>((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))</code>, but let‚Äôs not take some guy‚Äôs word for it, we can do better! Let‚Äôs prove it!</p><p>The Coq toolchain is a bit tricky to set up locally, but luckily we don‚Äôt have to as there‚Äôs an excellent <a href="https://coq.vercel.app/scratchpad.html">online IDE</a> that you can use instead. To translate our position into a form that Coq understands we can write</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span>
</span></span><span><span><span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span></code></pre></div><p>First, let‚Äôs take a second to understand our proposed theorem.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span></code></pre></div><p>Firstly <code>forall (Trait: Type -&gt; Prop) (Result: Prop)</code> is saying that what we want to prove should be true for every possible Trait method, and any possible return value of that Trait method, we can‚Äôt rely on anything true about any particular trait, our results are universal.</p><h3 id="split">split</h3><p>Our proposition is then broken into two halves separated by <code>&lt;-&gt;</code>. This is known as <a href="https://en.wikipedia.org/wiki/If_and_only_if">material equivalence</a>, or ‚Äúif and only if‚Äù, which is to say the left is true, if and only if the right is true, and visa versa. Therefore to prove it, we have to prove that the left proposition implies the right proposition, and also prove that the right proposition implies the left proposition. So we started trying to prove one thing, and now we have to prove two things! This process is very common in formal verification. To prove your goal, you have to break it apart and prove sub-sections of it. To prove the <code>A &amp; B</code> you have to prove <code>A</code>, and you have to prove <code>B</code>, to prove <code>A | B</code> you can take your pick of <code>A</code> or <code>B</code> whichever you think is easier to prove.</p><p>So now we have to prove</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>-</span> <span>(</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)</span>
</span></span><span><span><span>-</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>-&gt;</span> <span>(</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span>
</span></span></code></pre></div><p>A transformation in Coq is called a Tactic. The tactic for splitting our goal into two separate goals like this is unsurprisingly called <code>split</code>. To evaluate your proof up to where your cursor is press <code>CMD+Enter</code>. You should see the goals screen on the right update to reflect the new state of trying to prove our theorem.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span></code></pre></div><p>Should give the output in the goals panel of</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>2</span> <span>goals</span>
</span></span><span><span>  <span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span>  <span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>(</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>-&gt;</span> <span>forall</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span> <span>-&gt;</span> <span>Result</span>
</span></span><span><span>
</span></span><span><span><span>subgoal</span> <span>2</span> <span>is</span><span>:</span>
</span></span><span><span><span>(</span><span>forall</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>-&gt;</span> <span>(</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span>
</span></span></code></pre></div><h3 id="first-goal">First Goal</h3><p>To focus on one goal at a time we use <code>-</code> to denote each branch of the proof. We‚Äôll use it to focus on the first part of our proof.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span>
</span></span></code></pre></div><h3 id="tactic-intros">Tactic <code>intros</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>1</span> <span>goal</span>
</span></span><span><span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span><span>:</span> <span>Prop</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>((</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span> <span>,</span> <span>Trait</span> <span>t</span><span>)</span>  <span>-&gt;</span> <span>Result</span><span>)</span> <span>-&gt;</span> <span>forall</span> <span>t</span> <span>:</span> <span>Type</span> <span>,</span> <span>Trait</span> <span>t</span> <span>-&gt;</span> <span>Result</span>
</span></span></code></pre></div><p>The way to understand trying to prove an implication like <code>A -&gt; B -&gt; C</code>, is that we get to assume, <code>A</code>, and <code>B</code>, when trying to prove <code>C</code>. So with the above goal, we get to assume we already have the two antecedent terms <code>((exists t : Type , Trait t) -&gt; Result)</code> and <code>forall t : Type , Trait t</code>. The tactic that lets us do this is called <code>intro</code> for one variable at a time, or <code>intros</code> if you want to ‚Äúintroduce‚Äù multiple at the same time. Naming these implied assumptions is hard so feel free to name them however you want or leave it blank and let Coq auto name them.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>trait</span><span>.</span>
</span></span></code></pre></div><h3 id="tactic-apply">Tactic <code>apply</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>1</span> <span>goal</span>
</span></span><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>existsTrait</span> <span>:</span> <span>(</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span>
</span></span><span><span><span>type</span> <span>:</span> <span>Type</span>
</span></span><span><span><span>trait</span> <span>:</span> <span>Trait</span> <span>type</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>Result</span>
</span></span></code></pre></div><p>Implications work the opposite way when they‚Äôre in our assumptions. Right now our goal is to make a <code>Result</code>, in our assumptions we have an implication <code>existsTrait : (exists t : Type, Trait t) -&gt; Result</code> which can give us a <code>Result</code> if we‚Äôre able to prove its antecedent. So by ‚Äúapplying‚Äù our assumption, we can shift our goal to trying to prove the assumptions antecedent. Maybe it‚Äôs a dead end and we‚Äôll have to backtrack, but <code>Result</code> doesn‚Äôt appear anywhere else in our assumptions so it‚Äôs worth a try. The tactic to do this is unsurprisingly called <strong>apply</strong>.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>trait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span></code></pre></div><h3 id="tactic-exists">Tactic <code>exists</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>1</span> <span>goal</span>
</span></span><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>existsTrait</span> <span>:</span> <span>(</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span>
</span></span><span><span><span>type</span> <span>:</span> <span>Type</span>
</span></span><span><span><span>trait</span> <span>:</span> <span>Trait</span> <span>type</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span>
</span></span></code></pre></div><p>Now our goal is <code>exists t : Type, Trait t</code>, much like <code>forall</code> and <code>intros</code>, there exists a tactic for dealing with existentially quantified variables, called <code>exists</code>. Although unlike intros, which give us new assumptions, <code>exists</code> demands that we prove that a term exists. It is in some sense the opposite of <code>forall/intros</code>, it consumes a term rather than giving us one. Luckily, after examining our assumptions, we can see that our previous <code>intros</code> gave us an assumption of kind <code>type : Type</code> that matches the kind demanded by the ‚Äúexists‚Äù. So we can get rid of it with <code>exists</code>.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>trait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span></code></pre></div><h3 id="tactic-assumption">Tactic <code>assumption</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>1</span> <span>goal</span>
</span></span><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>exists</span> <span>:</span> <span>Trait</span><span>(</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span>
</span></span><span><span><span>type</span> <span>:</span> <span>Type</span>
</span></span><span><span><span>trait</span> <span>:</span> <span>Trait</span> <span>type</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>Trait</span> <span>type</span>
</span></span></code></pre></div><p>Now you may notice that our goal exactly matches one of our assumptions. So we can use the tactic <code>assumption</code> to finish this branch of the proof! One down and one to go!</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>trait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span>  <span>-</span>
</span></span></code></pre></div><h3 id="second-goal">Second Goal</h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>1</span> <span>goal</span>
</span></span><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>(</span><span>forall</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>-&gt;</span> <span>(</span><span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span>
</span></span></code></pre></div><p>Now we‚Äôre proving that the material equivalence holds in the other direction, and just like the first branch we use <code>intros</code> to move the left-hand side of the implications into our assumptions.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>concreteTrait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>anyTrait</span> <span>existsTrait</span><span>.</span>
</span></span></code></pre></div><h3 id="tactic-destruct">Tactic <code>destruct</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>1</span> <span>goal</span>
</span></span><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>anyTrait</span> <span>:</span> <span>forall</span> <span>t</span> <span>:</span> <span>Type</span> <span>,</span> <span>Trait</span> <span>t</span>  <span>-&gt;</span> <span>Result</span>
</span></span><span><span><span>existsTrait</span> <span>:</span> <span>exists</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>Result</span>
</span></span></code></pre></div><p>At this point you might be tempted to try and apply <code>anyTrait</code> just like we did for our first goal, trying to switch the goal from result to <code>forall t : Type , Trait t</code>, however, this doesn‚Äôt work with Coq complaining that <code>Unable to find an instance for the variable t</code>. This is because t is still universally quantified right now, whereas in our first goal t was existentially quantified. So we‚Äôre going to need to find ourselves a <code>t: Type</code> before we can shift our goal.</p><p>We also have the <code>existsTrait: exists t : Type, Trait t</code> assumption. Luckily, when we have a term like this, we can ask Coq if this expression implies anything else that is not currently in our assumptions. We do this with the <code>inversion</code> or <code>destruct</code> tactics. Coq will auto-name the new assumptions but we can also give them meaningful names with <code>as</code>.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>concreteTrait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>anyTrait</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>destruct</span> <span>existsTrait</span> <span>as</span> <span>(</span><span>t</span><span>,</span> <span>trait</span><span>).</span>
</span></span></code></pre></div><h3 id="tactic-apply-_-with-_">Tactic <code>apply _ with _</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>anyTrait</span> <span>:</span> <span>forall</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span> <span>-&gt;</span> <span>Result</span>
</span></span><span><span><span>t</span> <span>:</span> <span>Type</span>
</span></span><span><span><span>trait</span> <span>:</span> <span>Trait</span> <span>type</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>Result</span>
</span></span></code></pre></div><p>Coq has broken apart <code>existsTrait</code> into its two assumptions. So now we have an assumption of kind <code>Type</code>! We can now solve the problem we had before about applying <code>anyTrait</code>.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>concreteTrait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>anyTrait</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>destruct</span> <span>existsTrait</span> <span>as</span> <span>(</span><span>t</span><span>,</span> <span>trait</span><span>).</span>
</span></span><span><span>    <span>apply</span> <span>anyTrait</span> <span>with</span> <span>t</span><span>.</span>
</span></span></code></pre></div><h3 id="tactic-assumption-1">Tactic <code>assumption</code></h3><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Trait</span> <span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span>
</span></span><span><span><span>Result</span> <span>:</span> <span>Prop</span>
</span></span><span><span><span>anyTrait</span> <span>:</span> <span>forall</span> <span>t</span> <span>:</span> <span>Type</span><span>,</span> <span>Trait</span> <span>t</span> <span>-&gt;</span> <span>Result</span>
</span></span><span><span><span>t</span> <span>:</span> <span>Type</span>
</span></span><span><span><span>trait</span> <span>:</span> <span>Trait</span> <span>t</span>
</span></span><span><span><span>------------------------</span>
</span></span><span><span><span>Trait</span> <span>t</span>
</span></span></code></pre></div><p>Now just like before, our goal matches one of our assumptions, so we can finish up this branch with <code>assumption</code>.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>concreteTrait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>anyTrait</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>destruct</span> <span>existsTrait</span> <span>as</span> <span>(</span><span>t</span><span>,</span> <span>trait</span><span>).</span>
</span></span><span><span>    <span>apply</span> <span>anyTrait</span> <span>with</span> <span>t</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span></code></pre></div><h3 id="qed">QED</h3><p>Now that we‚Äôve proved all of our goals, we get to do the best thing about formal verification. The sweet three-letter acronym. <strong>QED</strong>.</p><div><pre tabindex="0"><code data-lang="coq"><span><span><span>Theorem</span> <span>impl_trait_transform</span><span>:</span> <span>forall</span> <span>(</span><span>Trait</span><span>:</span> <span>Type</span> <span>-&gt;</span> <span>Prop</span><span>)</span> <span>(</span><span>Result</span><span>:</span> <span>Prop</span><span>),</span>
</span></span><span><span>  <span>((</span><span>exists</span> <span>t</span><span>,</span> <span>Trait</span><span>(</span><span>t</span><span>))</span> <span>-&gt;</span> <span>Result</span><span>)</span> <span>&lt;-&gt;</span> <span>(</span><span>forall</span> <span>t</span><span>,</span> <span>(</span><span>Trait</span><span>(</span><span>t</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>)).</span>
</span></span><span><span><span>Proof</span><span>.</span>
</span></span><span><span>  <span>split</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>existsTrait</span> <span>type</span> <span>concreteTrait</span><span>.</span>
</span></span><span><span>    <span>apply</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>exists</span> <span>type</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span>  <span>-</span> <span>intros</span> <span>anyTrait</span> <span>existsTrait</span><span>.</span>
</span></span><span><span>    <span>destruct</span> <span>existsTrait</span> <span>as</span> <span>(</span><span>t</span><span>,</span> <span>trait</span><span>).</span>
</span></span><span><span>    <span>apply</span> <span>anyTrait</span> <span>with</span> <span>t</span><span>.</span>
</span></span><span><span>    <span>assumption</span><span>.</span>
</span></span><span><span><span>Qed</span><span>.</span>
</span></span></code></pre></div><p>And there you go, we‚Äôve formally verified that our transformation from generic arguments with trait bounds into existential <code>impl Trait</code> arguments is always valid. Of course, Rust would not have implemented the feature had it not made sense, but I think it‚Äôs gratifying to be able to prove such a cryptic statement like <code>((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))</code></p><p>Hopefully, this has given you a bit of a taste of how to reason when it comes to formally verify programs which is such an alien style of programming. I‚Äôve always likened it to playing with Legos where the bricks are parts of your program. You know the final shape you want, you just have to keep exploring how they combine to get there.</p><p>If you‚Äôd like to explore more formal verification I‚Äôd highly recommend checking out <a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a> or Edwin Brady‚Äôs <a href="https://www.manning.com/books/type-driven-development-with-idris">Type-Driven Development with Idris</a>.</p></div></div>
  </body>
</html>
