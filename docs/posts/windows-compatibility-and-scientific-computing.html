<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgoswami.me/posts/windows-compat-sci-cpp/">Original</a>
    <h1>Windows Compatibility and Scientific Computing</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote><p>Notes on cross-platform portability for scientific codes with legacy
components.</p></blockquote><h2 id="background">Background</h2><p>Most computational chemistry codes are developed on Linux. macOS shows
up in CI matrices or in workshops, a <a href="https://github.com/TheochemUI/eon-feedstock">conda-forge
feedstock</a> might cover the
major platforms, but Windows tends to be tested last and debugged
reluctantly <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. This is simply a consequence of the platforms
available in most research groups and the priorities of the people
writing the code <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p><p>I have been maintaining <a href="https://eondocs.org">eOn</a> <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> for a while
now, through a GPR-dimer implementation (<a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#ref-goswamiEfficientImplementationGaussian2025b">Goswami et al.
2025</a>), an on-the-go
variant (<a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#ref-goswamiAdaptivePruningIncreased2025b">Goswami and Jónsson
2025</a>), the NEB-MMF work
(<a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#ref-goswamiEnhancedClimbingImage2026">Goswami, Gunde, and Jónsson
2026</a>), my thesis (<a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#ref-goswamiEfficientExplorationChemical2025">Goswami
2025</a>), and more recently
the <a href="https://github.com/metatensor/ecosystem-article/tree/main/eon">metatensor ecosystem
integration</a>
(<a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#ref-bigiMetatensorMetatomicFoundational2026">Bigi et al. 2026</a>)
<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> and an <a href="https://atomistic-cookbook.org/examples/eon-pet-neb/eon-pet-neb.html">atomistic cookbook
recipe</a>
for NEB with machine learning potentials. Along the way, and through
contributions to <a href="https://chemfiles.org">chemfiles</a> and
<a href="https://asv.readthedocs.io/en/stable/">asv</a>, I have collected a tidy
set of Windows-specific failure modes. Each has cost at least one CI
cycle and occasionally an afternoon.</p><h2 id="reserved-filenames">Reserved Filenames</h2><p>Windows inherits from DOS a set of <a href="https://stackoverflow.com/questions/1976007/what-characters-are-forbidden-in-windows-and-linux-directory-names">reserved device
names</a>
that cannot be used as filenames, regardless of extension: <code>CON</code>, <code>PRN</code>,
<code>AUX</code>, <code>NUL</code>, <code>COM1</code> through <code>COM9</code>, <code>LPT1</code> through <code>LPT9</code>.
Case-insensitive, naturally. The <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file">Microsoft
documentation</a>
is comprehensive, but in practice most people discover these constraints
from a CI failure rather than from reading the docs.</p><h3 id="fn:aux-dot-py-in-asv-runner--2023"><code>aux.py</code> in <code>asv_runner</code> (2023)</h3><p>When writing
<a href="https://github.com/airspeed-velocity/asv_runner">asv_runner</a>, the
runner component for the <code>asv</code> benchmarking tool, I had a perfectly
reasonable file called <code>asv_runner/aux.py</code> for auxiliary benchmark
configuration <sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>. On Linux, no problem. On Windows:</p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>ERROR: For req: asv-runner. The wheel has a file &#39;asv_runner/aux.py&#39;
</span></span><span><span>2</span><span>trying to install outside the target directory
</span></span></code></pre></div><p>The wheel could not even be <em>installed</em>, let alone the repository
cloned <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>. Since <code>asv</code> is used by NumPy, SciPy, and friends for
performance tracking, this surfaced quickly. The
<a href="https://github.com/airspeed-velocity/asv_runner/issues/3">fix</a> was to
rename the file. The same issue appeared in
<a href="https://github.com/TheochemUI/pypotlib/issues/1">pypotlib</a> shortly
after, because apparently one lesson is never enough.</p><h3 id="fn:con-dot-cpp-in-chemfiles--2026"><code>CON.cpp</code> in <code>chemfiles</code> (2026)</h3><p>Three years later, while adding <code>.con</code> file support to
<a href="https://github.com/chemfiles/chemfiles/pull/527">chemfiles</a>, I named
the implementation files <code>CON.hpp</code> and <code>CON.cpp</code> after the format they
implement <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>. <code>CON</code> is of course also a reserved device name.</p><p>The files were renamed to <code>_CON.hpp</code> and <code>_CON.cpp</code>. The list of
reserved names is short enough to memorize, but apparently long enough
to forget between projects. The divergence in kernel handling is shown
in Figure <a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#figure--fig:win-filename-clash">1</a>.</p><figure><img src="https://rgoswami.me/ox-hugo/win-filename-clash.png" alt="Figure 1: The OS kernel divergence: Windows blocks the request before it even reaches the disk if a reserved name is detected."/><figcaption><p><span>Figure 1: </span>The OS kernel divergence: Windows blocks the request before it even reaches the disk if a reserved name is detected.</p></figcaption></figure><h2 id="stack-sizes-and-legacy-fortran">Stack Sizes and Legacy Fortran</h2><p>The default stack size on Linux is typically 8 MB (<code>ulimit -s</code>). On
Windows, it is 1 MB. This is rarely a problem for modern C++ since
<code>Eigen::MatrixXd</code> and friends allocate on the heap, but it matters
enormously for legacy Fortran, where local arrays live on the stack by
default.</p><h3 id="the-gagafe-subroutine">The GAGAFE Subroutine</h3><p>The eOn code includes Embedded Atom Model potentials implemented in
Fortran 77. The core routine is called <code>GAGAFE</code>, and I rather enjoy
knowing where the name comes from <sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>:</p><blockquote><p>GAGAFE stands for ‘group of atoms, group of atoms, force and energy’.
In a system with two types of atoms, A and B, GAGAFE needed to be
called three times, once for the A-A interactions, then for the B-B
interactions and finally for the A-B interactions. This is coming from
the code written in the H. C. Andersen group at Stanford (starting
around 1980 when he wrote his famous paper on the velocity Verlet
algorithm and the isobaric simulations with the extended Lagrangian).
The code ran on a PDP-11 computer in combination with an array
processor. I was a post-doc in the group 1986-1988 and kept this basic
structure in the F77 code I wrote when I moved to Seattle in 1988.</p><p>– <a href="https://hj.hi.is/indexE.html">Hannes Jónsson</a> (private
communication)</p></blockquote><p>There is something appealing about a subroutine name with a provenance
older than most of its users. The code has been running continuously for
over four decades, and it still works.. except on Windows, where the
local arrays blow the stack.</p><p>The subroutine declares arrays dimensioned with compile-time constants:</p><div><pre tabindex="0"><code data-lang="fortran"><span><span>1</span><span><span>c</span><span> </span><span>parameters</span><span>.</span><span>cmn</span><span>
</span></span></span><span><span>2</span><span><span>      </span><span>parameter</span><span> </span><span>(</span><span>MAXPRS</span><span> </span><span>=</span><span> </span><span>200000</span><span>)</span><span>
</span></span></span><span><span>3</span><span><span>
</span></span></span><span><span>4</span><span><span></span><span>c</span><span> </span><span>gagafeDblexp</span><span>.</span><span>f</span><span>
</span></span></span><span><span>5</span><span><span>      </span><span>DIMENSION</span><span> </span><span>phi</span><span>(</span><span>MAXPRS</span><span>),</span><span> </span><span>phivirst</span><span>(</span><span>MAXPRS</span><span>)</span><span>
</span></span></span><span><span>6</span><span><span>      </span><span>DIMENSION</span><span> </span><span>RA1</span><span>(</span><span>MAXCOO</span><span>),</span><span> </span><span>RA2</span><span>(</span><span>MAXCOO</span><span>),</span><span> </span><span>FA1</span><span>(</span><span>MAXCOO</span><span>),</span><span> </span><span>FA2</span><span>(</span><span>MAXCOO</span><span>)</span><span>
</span></span></span></code></pre></div><p><code>phi</code> and <code>phivirst</code> alone consume around 3 MB. Including the remaining
arrays, the total stack footprint is roughly around 3.6 MB which is well
beyond the 1 MB Windows default. The client crashes on entry to the
potential routine with exit code <code>3221225725</code> (decimal), which is
<code>0xC00000FD</code>: <code>STATUS_STACK_OVERFLOW</code> (see Figure
<a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#figure--fig:win-stack-overflow">2</a>).</p><figure><img src="https://rgoswami.me/ox-hugo/win-stack-overflow.png" alt="Figure 2: Visualizing the stack overflow: The legacy Fortran arrays fit comfortably within the Linux 8 MB default but exceed the Windows 1 MB limit."/><figcaption><p><span>Figure 2: </span>Visualizing the stack overflow: The legacy Fortran arrays fit comfortably within the Linux 8 MB default but exceed the Windows 1 MB limit.</p></figcaption></figure><h3 id="the-fix">The Fix</h3><p>For Meson-based builds, the linker can request a larger stack:</p><div><pre tabindex="0"><code data-lang="meson"><span><span>1</span><span><span>if</span><span> </span><span>is_windows</span><span>
</span></span></span><span><span>2</span><span><span>    </span><span>if</span><span> </span><span>is_mingw</span><span>
</span></span></span><span><span>3</span><span><span>        </span><span>_linkargs</span><span> </span><span>+=</span><span> </span><span>[</span><span>&#39;-Wl,--stack,16777216&#39;</span><span>]</span><span>  </span><span># 16 MB</span><span>
</span></span></span><span><span>4</span><span><span>    </span><span>elif</span><span> </span><span>cppc</span><span>.</span><span>get_id</span><span>()</span><span> </span><span>==</span><span> </span><span>&#39;msvc&#39;</span><span>
</span></span></span><span><span>5</span><span><span>        </span><span>_linkargs</span><span> </span><span>+=</span><span> </span><span>[</span><span>&#39;/STACK:16777216&#39;</span><span>]</span><span>
</span></span></span><span><span>6</span><span><span>    </span><span>endif</span><span>
</span></span></span><span><span>7</span><span><span></span><span>endif</span><span>
</span></span></span></code></pre></div><p>The alternative is refactoring the Fortran to use <code>ALLOCATABLE</code> arrays
or <code>COMMON</code> blocks. For code with this kind of lineage, the linker flag
is less invasive. More on working with inherited Fortran in general can
be found in an <a href="https://rgoswami.me/posts/handling-legacy-fortran-code/">earlier post</a>.</p><h2 id="stdout-redirection-and-spdlog">Stdout Redirection and <code>spdlog</code></h2><p>The <code>spdlog</code> logging library provides <code>stdout_color_sink_mt</code>, which uses
ANSI escape codes on Linux and <code>WriteConsole</code> on Windows for colored
output. The catch: <code>WriteConsole</code> <a href="https://github.com/gabime/spdlog/issues/1147">only
works</a> when the output
handle is an actual console <sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup>. When a parent process redirects
stdout to a file as the eOn Python server does for every client job,
<code>WriteConsole</code> fails silently.</p><p>The symptom is that the client produces no stdout whatsoever. stderr is
empty. The exit code may or may not be informative depending on what
else breaks downstream. The fix is to select the non-color sink:</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>#ifdef _WIN32
</span></span></span><span><span>2</span><span><span></span>  <span>auto</span> <span>console_sink</span> <span>=</span>
</span></span><span><span>3</span><span>      <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>spdlog</span><span>::</span><span>sinks</span><span>::</span><span>stdout_sink_mt</span><span>&gt;</span><span>();</span>
</span></span><span><span>4</span><span><span>#else
</span></span></span><span><span>5</span><span><span></span>  <span>auto</span> <span>console_sink</span> <span>=</span>
</span></span><span><span>6</span><span>      <span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>spdlog</span><span>::</span><span>sinks</span><span>::</span><span>stdout_color_sink_mt</span><span>&gt;</span><span>();</span>
</span></span><span><span>7</span><span><span>#endif
</span></span></span></code></pre></div><p>This took longer to diagnose than it should have, mostly because “no
output” does not immediately suggest “color codes”, a mechanism detailed
in Figure <a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#figure--fig:spdlog-sink-flow">3</a>.</p><figure><img src="https://rgoswami.me/ox-hugo/spdlog-sink-flow.png" alt="Figure 3: The silent failure mechanism: WriteConsole bypasses standard I/O and fails when the handle is a file, whereas standard sinks use file-compatible APIs."/><figcaption><p><span>Figure 3: </span>The silent failure mechanism: <code>WriteConsole</code> bypasses standard I/O and fails when the handle is a file, whereas standard sinks use file-compatible APIs.</p></figcaption></figure><p>This has <strong>been fixed</strong> in recent versions of <code>spdlog</code>, and was likely
simply masking errors from the <code>gagafe</code> issue.</p><h2 id="fn:the-mingw-msvc-abi-boundary">The MinGW/MSVC ABI Boundary</h2><p>On conda-forge, Fortran libraries are built with MinGW (<code>m2w64</code>) because
there is no MSVC Fortran compiler. The entire grimme-lab stack (<code>xtb</code>,
<code>tblite</code>, <code>dftd4</code>, <code>mctc-lib</code>) uses MinGW consistently, so internally
there is no mismatch. The problem appears when a C++ project built with
MSVC needs to link against one of these libraries.</p><p>This surfaced while enabling Windows builds for the <a href="https://eondocs.org/releases/v2.10.0/release-notes#v2-10-0-2026-02-15">eOn
v2.10.0</a>
conda-forge
<a href="https://github.com/conda-forge/eon-feedstock/pull/18">feedstock</a>. eOn
links against <code>libxtb</code> for the tight-binding potential, and against
<code>libtorch</code> and <code>libmetatensor</code> for machine learning potentials. The
latter two come from the MSVC ecosystem. There is no world in which
everything uses the same compiler <sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>.</p><h3 id="the-import-library-problem">The Import Library Problem</h3><p>MinGW produces <code>libxtb.dll.a</code> (a GNU-style import library). MSVC’s
linker does not understand this format; it expects <code>xtb.lib</code>. The xtb
conda package does not ship one because it has no reason to <sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup>.</p><p>The workaround is to generate an MSVC-compatible import library from the
DLL exports:</p><div><pre tabindex="0"><code data-lang="bat"><span><span>1</span><span>dumpbin /EXPORTS <span>&#34;</span><span>%LIBRARY_BIN%</span><span>\libxtb-6.dll&#34;</span> <span>&gt;</span> xtb_exports.txt
</span></span><span><span>2</span><span><span>echo</span> LIBRARY libxtb-6.dll <span>&gt;</span> xtb.def
</span></span><span><span>3</span><span><span>echo</span> EXPORTS <span>&gt;&gt;</span> xtb.def
</span></span><span><span>4</span><span><span>for</span> <span>/f</span> <span>&#34;skip=19 tokens=4&#34;</span> <span>%%</span>A <span>in</span> <span>(</span>xtb_exports.txt<span>)</span> <span>do</span> <span>(</span>
</span></span><span><span>5</span><span>    <span>if</span> <span>not</span> <span>&#34;</span><span>%%</span><span>A&#34;</span><span>==</span><span>&#34;&#34;</span> <span>echo</span>     <span>%%</span>A <span>&gt;&gt;</span> xtb.def
</span></span><span><span>6</span><span><span>)</span>
</span></span><span><span>7</span><span>lib /DEF:xtb.def /OUT:<span>&#34;</span><span>%LIBRARY_LIB%</span><span>\xtb.lib&#34;</span> /MACHINE:X64
</span></span></code></pre></div><p>This works because <code>xtb</code> exposes a pure C API (<code>xtb.h</code>), and the C ABI
is compatible between MinGW and MSVC. C++ name mangling would be fatal
here, but <code>xtb</code> <sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup> provide a C interface. The dependency chain is
illustrated in Figure <a href="https://rgoswami.me/posts/windows-compat-sci-cpp/#figure--fig:mingw-msvc-abi">4</a>.</p><figure><img src="https://rgoswami.me/ox-hugo/mingw-msvc-abi.png" alt="Figure 4: The ABI bridge: generating an MSVC import library from a MinGW-built DLL allows a single executable to link against both toolchain ecosystems."/><figcaption><p><span>Figure 4: </span>The ABI bridge: generating an MSVC import library from a MinGW-built DLL allows a single executable to link against both toolchain ecosystems.</p></figcaption></figure><h3 id="fn:find-library-and-missing-import-libraries"><code>find_library</code> and Missing Import Libraries</h3><p>A related pattern appears in the <code>libtorch</code> integration from the same
<a href="https://github.com/conda-forge/eon-feedstock/pull/18">feedstock PR</a>.
The meson build finds torch libraries with <code>find_library</code>, which
defaults to <code>required: true</code>:</p><div><pre tabindex="0"><code data-lang="meson"><span><span>1</span><span><span>lib_torch_list</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;c10&#39;</span><span>,</span><span> </span><span>&#39;torch&#39;</span><span>,</span><span> </span><span>&#39;torch_cpu&#39;</span><span>,</span><span> </span><span>&#39;torch_global_deps&#39;</span><span>]</span><span>
</span></span></span><span><span>2</span><span><span></span><span>tdeps</span><span> </span><span>=</span><span> </span><span>[]</span><span>
</span></span></span><span><span>3</span><span><span></span><span>foreach</span><span> </span><span>lib_name</span><span> </span><span>:</span><span> </span><span>lib_torch_list</span><span>
</span></span></span><span><span>4</span><span><span>    </span><span>tdeps</span><span> </span><span>+=</span><span> </span><span>cppc</span><span>.</span><span>find_library</span><span>(</span><span>lib_name</span><span>,</span><span> </span><span>dirs</span><span>:</span><span> </span><span>[</span><span>LIB_TORCH_LIB_PATH</span><span>])</span><span>
</span></span></span><span><span>5</span><span><span></span><span>endforeach</span><span>
</span></span></span></code></pre></div><p>On Windows, <code>torch_global_deps</code> ships as a DLL with no corresponding
<code>.lib</code> import library. It exists solely to set up runtime library search
paths for CUDA and has no exported symbols needed at link time. The
equivalent CMake build handles this gracefully:</p><div><pre tabindex="0"><code data-lang="cmake"><span><span>1</span><span><span>foreach</span><span>(</span><span>lib</span> <span>c10</span> <span>torch</span> <span>torch_cpu</span> <span>torch_global_deps</span><span>)</span><span>
</span></span></span><span><span>2</span><span><span></span>  <span>find_library</span><span>(</span><span>${</span><span>lib</span><span>}</span><span>_LIB</span> <span>${</span><span>lib</span><span>}</span> <span>PATHS</span> <span>${</span><span>LIB_TORCH_LIB_PATH</span><span>}</span> <span>NO_DEFAULT_PATH</span><span>)</span><span>
</span></span></span><span><span>3</span><span><span></span>  <span>if</span><span>(</span><span>${</span><span>lib</span><span>}</span><span>_LIB</span><span>)</span><span>
</span></span></span><span><span>4</span><span><span></span>    <span>target_link_libraries</span><span>(</span><span>eonclib</span> <span>PUBLIC</span> <span>${</span><span>${lib</span><span>}</span><span>_LIB}</span><span>)</span><span>
</span></span></span><span><span>5</span><span><span></span>  <span>endif</span><span>()</span><span>
</span></span></span><span><span>6</span><span><span></span><span>endforeach</span><span>()</span><span>
</span></span></span></code></pre></div><p>The CMake version silently skips missing libraries. The meson version
treats every entry as mandatory. The fix is to add <code>required: false</code> and
check <code>.found()</code>, which is the meson equivalent of the CMake
pattern <sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup>.</p><p>None of these issues are particularly deep. The reserved filenames have
been documented since DOS. The 1 MB stack has been the default for
decades. The MinGW/MSVC split has been the status quo on conda-forge for
as long as Fortran has been involved. The common thread is that they
surface only when CI runs on a platform the developer does not use
daily, with error messages ranging from cryptic (<code>0xC00000FD</code>) to absent
(<code>WriteConsole</code>) to quietly fatal linker errors.</p><p>The practical advice is simple: add Windows to the CI matrix early, pay
extra attention to legacy Fortran components where stack allocation is
the default, and do not assume that “requires library X” implies
“requires the toolchain that built library X”. And perhaps keep a list
of DOS device names somewhere visible.</p><h2 id="references">References</h2><div id="refs" entry-spacing="0"><p>Bigi, Filippo, Joseph W. Abbott, Philip Loche, Arslan Mazitov, Davide
Tisi, Marcel F. Langer, Alexander Goscinski, et al. 2026. “Metatensor
and Metatomic : Foundational Libraries for Interoperable Atomistic
Machine Learning.” <em>Journal of Chemical Physics</em> 164 (6): 64113.
<a href="https://doi.org/10.1063/5.0304911">https://doi.org/10.1063/5.0304911</a>.</p><div id="ref-goswamiEfficientExplorationChemical2025"><p>Goswami, Rohit. 2025. “Efficient Exploration of Chemical Kinetics.”
October 24, 2025. <a href="https://doi.org/10.48550/arXiv.2510.21368">https://doi.org/10.48550/arXiv.2510.21368</a>.</p></div><p>Goswami, Rohit, Miha Gunde, and Hannes Jónsson. 2026. “Enhanced Climbing
Image Nudged Elastic Band Method with Hessian Eigenmode Alignment.”
January 22, 2026. <a href="https://doi.org/10.48550/arXiv.2601.12630">https://doi.org/10.48550/arXiv.2601.12630</a>.</p><p>Goswami, Rohit, and Hannes Jónsson. 2025. “Adaptive Pruning for
Increased Robustness and Reduced Computational Overhead in Gaussian
Process Accelerated Saddle Point Searches.” <em>ChemPhysChem</em>, November.
<a href="https://doi.org/10.1002/cphc.202500730">https://doi.org/10.1002/cphc.202500730</a>.</p><p>Goswami, Rohit, Maxim Masterov, Satish Kamath, Alejandro Pena-Torres,
and Hannes Jónsson. 2025. “Efficient Implementation of Gaussian Process
Regression Accelerated Saddle Point Searches with Application to
Molecular Reactions.” <em>Journal of Chemical Theory and Computation</em>,
July. <a href="https://doi.org/10.1021/acs.jctc.5c00866">https://doi.org/10.1021/acs.jctc.5c00866</a>.</p></div><hr/><div><h2>Series info</h2><h3>EON series</h3><ol><li><a href="https://rgoswami.me/posts/eon-acad-foss/">Reconciling eOn for Academia and Open Source</a></li><li><b>Windows Compatibility and Scientific Computing</b> &lt;-- You are here!</li></ol><h2>Series info</h2><h3>Fortran Frontiers: Bridging Legacy to Modernity series</h3><ol><li><a href="https://rgoswami.me/posts/handling-legacy-fortran-code/">Handling Legacy Fortran Code</a></li><li><b>Windows Compatibility and Scientific Computing</b> &lt;-- You are here!</li></ol></div></div></div>
  </body>
</html>
