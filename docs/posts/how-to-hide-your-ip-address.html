<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://educatedguesswork.org/posts/traffic-relaying/">Original</a>
    <h1>How to hide your IP address</h1>
    
    <div id="readability-page-1" class="page"><div>
          <main>
            
<div>
  <div>
    <article>
        <p>A field guide to VPNs, proxies, and traffic relaying
        </p>

        <p>As I mentioned previously in my posts on
<a href="https://educatedguesswork.org/posts/private-browsing">private browsing</a> and <a href="https://educatedguesswork.org/posts/public-wifi">public WiFi</a>,
if you really want to keep your activity on the Internet private, you
need some way to protect your IP address (i.e., the address that machines
on the Internet use to talk to your computer)
and the IP addresses of the servers
you are going to. There are a variety of different technologies
you can use for this purpose, with somewhat different properties.
This post provides a perhaps over-long description of the various
options.</p>
<h2 id="the-basics">The Basics <a href="#the-basics">#</a></h2>
<p>As usual, with any security problem, we need to start with the
threat model. We are concerned with two primary modes of attack:</p>
<ol>
<li>The server learning the user&#39;s IP address and using it to
identify them or correlate their activity.</li>
<li>The local network learning which servers the user is going to.</li>
<li>The server using your
apparent geolocation as determined from your IP address to
restrict access to certain kinds of content (soccer, BBC, whatever).</li>
</ol>
<p>Of course, whether you think this last item is actually a form of attack that should be
defended against depends on your perspective and maybe how big a Doctor
Who fan you are.</p>
<p>The basic technique for defending against threats (1) and (3) is to
push the traffic through some kind of anonymizing relay:</p>
<p><img src="https://educatedguesswork.org/img/relay-basic.png" alt="A basic anonymizing relay"/></p>
<p>As shown in the diagram above, the client connects to the relay and
tells it where to connect. It then sends traffic to the relay,
which forwards it to the server. The relay replaces the client&#39;s
IP address with its own, so the server just sees the relay&#39;s
address. In general, the relay will be serving quite a few
clients, so the server will find it hard to distinguish which
one is which (<a href="https://en.wikipedia.org/w/index.php?title=K-anonymity&amp;oldid=1108999307">k-anonymity</a>).
This simple version clearly addresses threat (1), and, if the relay operator lets
you select an IP address outside your own geographic region,
threat (3). In order to defend against threat (2) you also need
to encrypt the traffic to the relay so that an attacker on
your network can&#39;t see which server you are connecting to and
the traffic you are sending to it (see <a href="https://educatedguesswork.org/posts/public-wifi/#routes-for-browsing-behavior-leakage">here</a>
for more on this form of data leakage). Ideally, you would also encrypt
the traffic <em>end-to-end</em> to the server (using TLS or QUIC), but
that&#39;s just generally good practice, not required for the privacy
provided by the relay.</p>
<h2 id="relaying-options">Relaying Options <a href="#relaying-options">#</a></h2>
<p>This basic design is at the heart of every relaying system,
but the details vary in important ways. There are three
major axes of variation:</p>
<ul>
<li>The network <em>layer</em> at which relaying happens</li>
<li>The number of <em>hops</em> in the network</li>
<li>Business model</li>
</ul>
<p>We cover each of these below.</p>
<h3 id="network-layer">Network Layer <a href="#network-layer">#</a></h3>
<p>The first major point of variation is the <em>layer</em> at which the relaying
happens. Understanding this requires a bit of background on how
the Internet networking protocols work.</p>
<h4 id="ip">IP <a href="#ip">#</a></h4>
<p>The most basic protocol on the Internet is what&#39;s called, somewhat
unsurprisingly, <a href="https://en.wikipedia.org/w/index.php?title=Internet_Protocol&amp;oldid=1115350518">Internet Protocol (IP)</a>. IP is what&#39;s called a &#34;packet switching&#34; protocol, which means
that the basic unit is a self-contained message called a <strong>packet</strong>.
A packet is like a letter in that it has a source address and a
destination address. This means that when you send an IP packet on
the network, the Internet can automatically route the packet to the
destination address by looking at the packet with no other state
about either computer. A simplified IP packet looks like this:</p>
<p><img src="https://educatedguesswork.org/img/IP-packet.png" alt="IP Packet"/></p>
<p>The main thing in the packet is the actually <em>data</em> to be delivered
from the source to the destination, also called the <em>payload</em>.
The payload is variable length with a maximum typically
around 1500 bytes.
The packet also has a <em>next protocol</em> field which tells the
receiver how to interpret the payload (more on this later)
and a <em>length</em> field so that it is possible to tell how
long the entire packet is, including the variable length
payload.</p>
<p>Using IP is very simple: your computer transmits an IP
packet on the wire and the Internet uses the destination
address to figure out where to route it. When someone
wants to transmit to you, they do the same thing.</p>
<h4 id="tcp">TCP <a href="#tcp">#</a></h4>
<p>If all you want to do is send a thousand or so bytes from one
machine to the other, a single IP packet might be OK, but
in practice this is almost never what you want to do.
In particular, it&#39;s very common to want to send
a stream of data (e.g., a file) which is much longer than
1500 bytes. At a high level, this is done by breaking up the
data into a series of smaller chunks and sending each one
in a single packet. But of course, life isn&#39;t so simple.
For instance:</p>
<ul>
<li>Packets might be lost, and must be retransmitted so that
the receiver gets them.</li>
<li>Packets might be reordered, and the receiver must know
which order to put them in.</li>
<li>In general, the network will not be able to handle an
entire large file at once, so the data must be gradually
transmitted over time. The sender must have some way to
determine the appropriate sending rate.</li>
</ul>
<p>The <a href="https://en.wikipedia.org/w/index.php?title=Transmission_Control_Protocol&amp;oldid=1114104762">Transmission Control Protocol (TCP)</a> is responsible for taking care of these issues.
The details of TCP are far too complicated to fit in this
blog post, but at a high level, the data stream is broken up
into <em>segments</em>, each of which has a length and a sequence number,
which tells you where it goes in the stream. Each segment
is sent in an IP packet. When the receiver gets a segment
it can look at the sequence number to reconstruct the stream
and is able to detect gaps where packets are missing.
TCP also includes an <em>acknowledgment</em> mechanism in which the
receiver tells the sender which segments it has received;
this allows the sender to retransmit packets which were
lost as well as to adjust its sending rate appropriately.
TCP requires setting up state between the two endpoints;
this state is termed a &#34;TCP connection.&#34;</p>
<p>There are of course other protocols besides TCP which can run over
IP (for instance, UDP, mentioned later). This is why you
need the &#34;next protocol&#34; field in IP: to tell the receiver what
protocol is in the IP payload.</p>
<h3 id="tls">TLS <a href="#tls">#</a></h3>
<p>TCP is a very old protocol and like most of the older Internet
protocols, it was designed before widespread use of encryption
was practical. This is obviously bad news from a security
perspective, and eventually people got around to fixing it. The standard solution is to carry the
data over <a href="https://en.wikipedia.org/w/index.php?title=Transport_Layer_Security&amp;oldid=1110721112">Transport Layer Security (TLS)</a>. TLS basically provides the abstraction of an encrypted
and authenticated stream of data on top of a TCP connection.
As with TCP, you need to set up some state to use TLS,
and that&#39;s called a &#34;TLS connection&#34;. I can talk endlessly
about TLS but I won&#39;t do so here.</p>
<h3 id="udp-and-quic">UDP and QUIC <a href="#udp-and-quic">#</a></h3>
<p>Applications do not implement TCP themselves. Instead it&#39;s
built into the operating system, specifically in what&#39;s
called the operating system <em>kernel</em>, i.e., the
piece of the OS that&#39;s always running and is responsible
for managing the computer as a whole.
The client application tells the operating system to
create a TCP connection to the server, which creates what&#39;s
called &#34;socket&#34; on the client side. The client writes data
to the socket and the kernel automatically packages
it up into TCP segments and transmits it to the other side,
taking care of retransmission, rate control, etc.
The kernel also reads TCP segments from the other side and makes
them available to the application to read. Typically, the
application implements TLS itself or more likely, uses
some existing TLS library.</p>
<div>
<h4 id="why-can&#39;t-you-write-your-own-tcp-stack%3F">Why can&#39;t you write your own TCP stack? <a href="#why-can&#39;t-you-write-your-own-tcp-stack%3F">#</a></h4>
<p>Obviously, you <em>can</em> write your own TCP stack (it&#39;s just software,
after all) but the problem is that you can&#39;t <em>install</em> it,
because on most operating systems, ordinary applications aren&#39;t allowed to write or receive raw IP
datagrams. This is one of a number of restrictions on networking
behavior that used to be used for security enforcement in
a pre-cryptographic era. For instance, at one time it was
assumed that if a packet came from a given machine address
with a given &#34;port number&#34; (a field in the UDP/TCP header)
it came from a privileged process (one that had operating
systems privileges). There was even a whole <a href="https://en.wikipedia.org/w/index.php?title=Remote_Shell&amp;oldid=1070274903">system for remote login</a> based on this where you could be on machine A
and execute commands on machine B without authenticating.
I know this sounds absurd now, but this was the situation
from the early 80s to the late 90s, when we finally
got proper cryptographic authentication (at least some
of the time.)</p>
</div>
<p>This is convenient in that the application doesn&#39;t need to carry
around its own TCP implementation, but inconvenient in that
it&#39;s inflexible: suppose the application wants to make some
change to TCP to make it more efficient? There&#39;s no way to
do this without changing the operating system. By contrast,
it&#39;s easy to change TLS behavior just by shipping a new
version of the application. This became particularly salient
in the late 2010s when people wanted to make performance
enhancements to TCP but were unable to because the operating
system didn&#39;t move fast enough.
The solution was to invent a new protocol that could be
implemented entirely in the application: <a href="https://en.wikipedia.org/w/index.php?title=QUIC&amp;oldid=1114290192">QUIC</a>.</p>
<p>QUIC is sort of like a combination of a fancier version of
TCP and the cryptography of TLS (in fact, it uses many pieces
of TLS internally). However, because it can be
implemented entirely in the application, it can be
changed very rapidly. Unfortunately, in most operating systems,
applications are not allowed to write IP packets directly,
and so QUIC runs over a protocol called the <a href="https://en.wikipedia.org/w/index.php?title=User_Datagram_Protocol&amp;oldid=1112673995">User Datagram Protocol (UDP)</a>. UDP is
a very simple protocol which just lets applications send
single units of data (datagrams) over IP. So, QUIC runs
over UDP and UDP runs over IP.</p>
<h3 id="the-protocol-stack">The protocol stack <a href="#the-protocol-stack">#</a></h3>
<p>It&#39;s conventional to talk about this as a &#34;stack&#34; of protocols
and visualize it in a picture called a &#34;layer diagram&#34;,
like so:</p>
<p><img src="https://educatedguesswork.org/img/TCPIP-layer.png" alt="TCP/IP Layer Diagram"/></p>
<p>I&#39;ve also drawn on this diagram which pieces are implemented
in the application and which are typically part of the operating
system. When the application wants to write
data, it starts at the top of the stack and data moves down to
the network. As data comes in from the network, it moves up the
stack towards the application.</p>
<p>In terms of the way the data appears on the network, each
layer adds its own encapsulation, typically either before
or after the data. The diagram below shows two examples.
The first is data being sent over TCP, in this case the string
&#34;Four score and seven years ago&#34;. TCP adds its own header
with the sequence number, etc. and then passes it to the
IP layer, which adds the IP header with the source and destination
addresses.
The second example is the same data being sent over TLS.
The TLS layer encrypts the data (shown by the crosshatching)
and adds its own header. It then passes it to TCP, which adds
its own header, etc.
The receiving process reverses these operations.</p>
<p><img src="https://educatedguesswork.org/img/tcp-tls-packets.png" alt="TCP and TLS packets"/></p>
<div>
<h4 id="naming-chunks-of-data">Naming chunks of data <a href="#naming-chunks-of-data">#</a></h4>
<p>You&#39;ll probably notice that I&#39;ve been using the terms
&#34;packet&#34;, &#34;record&#34;, etc. These are not interchangeable.
One of the most annoying problems in networking is how
to name a single unit of data like a packet (sometimes
called generically a <em>protocol data unit (PDU)</em>). Each protocol
tends to have its own term for this, partly just due to
being defined by different people and partly because when
you are working at multiple layers of the protocol stack
it&#39;s a pain to talk about &#34;IP datagrams&#34;, &#34;UDP datagrams&#34;, etc.
Here&#39;s my incomplete table of names for PDUs in different
protocols:</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ethernet</td>
<td>Frame</td>
</tr>
<tr>
<td>IP</td>
<td>Packet (datagram)</td>
</tr>
<tr>
<td>UDP</td>
<td>Datagram</td>
</tr>
<tr>
<td>TCP</td>
<td>Segment</td>
</tr>
<tr>
<td>TLS</td>
<td>Record</td>
</tr>
<tr>
<td>QUIC</td>
<td>Packet (but it has things inside it called frames)</td>
</tr>
<tr>
<td>HTTP</td>
<td>Message</td>
</tr>
<tr>
<td>RTP</td>
<td>Packet (but they carry media frames)</td>
</tr>
<tr>
<td>OpenPGP</td>
<td>Packet</td>
</tr>
<tr>
<td>XMPP</td>
<td>Stanza</td>
</tr>
</tbody>
</table>
</div>
<p>One thing that&#39;s important to know is that TCP and
TLS provide the abstraction of a stream of data, not
a set of records. What this means is that the application
just writes data and the TLS stack or the TCP stack
coalesces those chunks into one record (packet) or
breaks them up at its convenience. The TCP stack
might even send the same data twice with two different
framings. For instance, suppose that the application
writes &#34;Hello&#34; and then the kernel sends it in a single
packet. While the packet is in flight, the application
writes &#34;Again&#34;. If both packets get lost, and the kernel
kernel has to retransmit them, it might write them as
a single TCP segment (&#34;HelloAgain&#34;).</p>
<h3 id="which-layer">Which Layer <a href="#which-layer">#</a></h3>
<p>With this as background, we are ready to talk about one of the
big points of diversity: what layer are we relaying the traffic
at? There are two main options, at least for relaying encrypted
traffic.</p>
<ol>
<li>Relay the IP-layer traffic</li>
<li>Relay the application layer traffic (i.e., the data that would
go over UDP or TCP)</li>
</ol>
<p>I cover both of these below.</p>
<h4 id="relaying-ip-traffic">Relaying IP Traffic <a href="#relaying-ip-traffic">#</a></h4>
<p>Encrypting traffic at the network layer (IP) is one of the obvious
ways to address network security issues, as it has the important
advantage that once you have set it up, it secures <em>all</em>
communications between two endpoints. Work on this goes all
the way back to the 1970s, but the IETF started standardizing
technology for this purpose in 1992 under the name
<a href="https://en.wikipedia.org/w/index.php?title=IPsec&amp;oldid=1115277463">IPsec</a>.
The original idea was actually not so much the kind of relaying
system that I discussed above but rather that you would
encrypt traffic between the two machines that were
communicating with each other. So, for instance, say my client
wanted to communicate with your server, we would take the
IP packets we wanted to send, encrypt them, and send them directly.</p>
<p>Like the protocols we discussed above, IPsec is an <em>encapsulation</em>
protocol, which means that to encrypt an IP packet from A to B
we take the entire original packet, encrypt it, and then stuff
it in another IP packet, like so:</p>
<p><img src="https://educatedguesswork.org/img/ipsec1.png" alt="IPsec encapsulation"/></p>
<p>In the scenario I was discussing above, the inner (encrypted)
IP header and the outer (plaintext) IP header will have the same
addressing information, but it&#39;s of course possible to have them
have different addressing information, which is useful for creating
what&#39;s called a <em>Virtual Private Network (VPN)</em>. The motivating
idea here is that you have two networks (say two offices from
the same company) and you want to connect them as if they were
in the same location. Inside the office, you trust that the
wires haven&#39;t been tampered with (this is before WiFi)
and so you don&#39;t encrypt all your data (I know, this sounds
naive now), and so what you really want is just a wire
connecting office 1 and office 2. This kind of private
connection—what used to be called a &#34;leased line&#34;—is very expensive
to buy and what you actually have is an Internet connection which
lets you connect to everyone. But if you encrypt the traffic
between office 1 and office 2, then you can simulate having
your own private wire. Hence <em>virtual</em> private network. The
typical topology looks like this:</p>
<p><img src="https://educatedguesswork.org/img/enterprise-vpn.png" alt="An enterprise VPN"/></p>
<p>In this scenario, you have two offices, each of which has a
&#34;VPN gateway&#34; which detects traffic that is destined from office
1 to office 2 and encrypts it before sending it along. Other
traffic, say to Facebook, is left untouched. When the
packets are received at the far VPN gateway, it just removes
the encapsulation and drops them on the network. The effect is
as if there were a single network rather than two networks.</p>
<p>It&#39;s also possible to deploy this kind of thing in a simpler
scenario where a single user VPNs into their office network,
for instance if you are in a hotel working remotely, as shown
in the diagram below:</p>
<p><img src="https://educatedguesswork.org/img/remote-access-vpn.png" alt="A remote access VPN"/></p>
<p>The effect here is that it&#39;s like you were in the office, but you&#39;re
actually not. But this brings up a real problem, which is that the
remote user&#39;s machine doesn&#39;t have the right IP address:
it has an IP address associated with the user&#39;s home or office (192.0.2.1 in the
diagram above) but you want it to appear to be in the office, which
means it has to have an office IP address (something starting
with 203.0.112).</p>
<p>There are two major ways to make this work. In the first, the
VPN gateway tells the user&#39;s device what IP address it wants
it to have, and then the user&#39;s device puts that in the <em>inner</em>
IP header, while having the outer IP header having the actual
address. For instance, the inner (encrypted) IP header would
have 203.0.11.50 and the outer (plaintext) IP header would
have 192.0.2.1.
The alternative is to have both headers have the user&#39;s
actual IP address and to have the VPN gateway <em>translate</em>
that address into an appropriate local address for the
office network (and translate in the other way on the return trip). Note that in both cases, the gateway
needs to do some work, in the first case to keep track of
what addresses were assigned and to enforce that the client
uses the right one, and in the second case to do the translation.</p>
<p>With that background, we can finally get to the problem statement
that we started with, namely concealing user behavior. Unsurprisingly
you can use the same technology as you use for remote access, with
the difference that the VPN gateway is on the Internet directly
rather than on some enterprise network, as shown below:</p>
<p><img src="https://educatedguesswork.org/img/consumer-vpn.png" alt="Consumer VPN"/></p>
<p>To the server, this just looks like the user is connecting from
the VPN gateway, with whatever the IP address of the VPN gateway
is. The client&#39;s local network just sees a connection to the
VPN server, but doesn&#39;t know where the data is eventually going.</p>
<p>Here I&#39;ve focused on IPsec, but it doesn&#39;t really matter which
encryption layer protocol you use to carry the IP packets:
they&#39;re just being encapsulated and transported end-to-end.
In practice, one sees VPNs deployed with a variety of
transport protocols, including
<a href="https://en.wikipedia.org/w/index.php?title=Datagram_Transport_Layer_Security&amp;oldid=1115742845">DTLS</a>,
<a href="https://en.wikipedia.org/w/index.php?title=OpenVPN&amp;oldid=1107224624">OpenVPN</a>,
<a href="https://en.wikipedia.org/w/index.php?title=WireGuard&amp;oldid=1113944737">WireGuard</a>
and <a href="https://en.wikipedia.org/w/index.php?title=QUIC&amp;oldid=1114290192">QUIC</a>.
From the user&#39;s perspective, the properties of these protocols are largely
the same.
Most products that are labeled &#34;VPN&#34; protect traffic at the IP
layer using one or more of these protocols.</p>
<h4 id="relaying-application-layer-traffic">Relaying Application Layer Traffic <a href="#relaying-application-layer-traffic">#</a></h4>
<p>As mentioned above, the nice thing about protecting traffic at the
IP layer is that it protects all the traffic on the system. However,
the bad thing is that protecting
IP layer traffic requires cooperation from the operating system.
This has several undesirable consequences:</p>
<ol>
<li>Your code isn&#39;t portable between operating systems.</li>
<li>Many operating systems require some kind of administrator
access in order to install or configure something that
acts at the IP layer.</li>
<li>You are often limited to whatever affordances the OS
offers you. For instance, you may not easily be able to
protect some traffic and not other types of traffic.</li>
</ol>
<p>These issues can be addressed by relaying at the application
layer rather than the IP layer. This can be implemented entirely
in the application without touching the operating system;
the application just connects to the relay (e.g., over TCP)
and sends the traffic to the relay (hopefully encrypted to the
server). The relay makes its own transport-level connection
to the server and sends the application level traffic to the
server, as shown below.</p>
<p><img src="https://educatedguesswork.org/img/application-relay.png" alt="Application Level Relaying"/></p>
<p>Note that in this diagram there are two TCP connections,
one between the client and the relay and one between
the relay and the server. The client connects to the relay over
TLS and then over top of that creates an end-to-end TLS
connection to the server (you could of course not encrypt
your data to the server, but don&#39;t do that).</p>
<p>One of the big advantages of this design is that it makes it
easy to relay some kinds of traffic and not others. As a concrete
example, consider <a href="https://educatedguesswork.org/posts/safe-browsing">Safe Browsing</a>, which
leaks information about the user&#39;s browsing history to the
Safe Browsing server. You might want to proxy Safe Browsing
checks (which can be done very cheaply because there isn&#39;t
much traffic) but not generic browsing traffic (which is
much higher volume and hence more expensive). This is easy
for the browser to do because it knows which traffic is which
but is more difficult for an IP-layer system, which has to
somehow distinguish different types of traffic. It&#39;s not
necessarily impossible but it&#39;s significantly more work.
For instance, if Safe Browsing uses a separate IP address
from the rest of Google, then you could just relay that
traffic, but if it shares the same IP address, then you
will be encrypting people&#39;s search traffic as well.</p>
<p>A number of IP concealment systems relay at the application
layer, including <a href="https://torproject.org">Tor</a>,
Apple&#39;s <a href="https://support.apple.com/en-us/HT212614">iCloud Private Relay</a>,
and <a href="https://fpn.firefox.com/">Firefox Private Network</a>.
Typically, systems like this are referred to as &#34;proxies&#34;.
Apple&#39;s system is interesting in that it&#39;s implemented
in the operating system mostly by hooking Apple&#39;s higher
level networking APIs. Even so, it only works on Safari not
other applications.</p>
<h3 id="how-many-hops%3F">How many hops? <a href="#how-many-hops%3F">#</a></h3>
<p>Whatever the relaying technology, at the end of the day the
relay needs to send traffic to the server, which means it
has to know what server you&#39;re connecting to. But this
creates a new privacy problem: you&#39;re connecting to the
relay and then telling it which server to connect to.
This means that while you&#39;ve prevented the server from
learning your identity, you still have a privacy problem
with respect to the relay itself. The
relay will have some privacy policy about how it handles
this information (ideally, not keeping logs at all),
but that&#39;s just something you have to trust them on.
Even better would be to have some form of a technical protection.</p>
<p>The standard approach to providing technical protection here is to have multiple layers
of relaying, as shown in the diagram below:</p>
<p><img src="https://educatedguesswork.org/img/multi-hop-relay.png" alt="A multi-hop relay system"/></p>
<p>The way this works is that the client connects to Relay 1.
It then tells Relay 1 to connect it to Relay 2. As with
our single-hop system, that data is sent over the encrypted
channel to Relay 1 and is itself encrypted to Relay 2.
The client then tells Relay 2 to connect it to the server.
The data to the server is thus encrypted three times by
the client, in a nested fashion: once to the server, then
to Relay 2, and then to Relay 1.
Each hop strips off one
layer of encryption and passes it to the next hop.</p>
<p>The result is that no single entity (other than the client)
gets to see <em>both</em>
the user&#39;s identity and the identity of the server it&#39;s
connecting to. Here&#39;s what each sees:</p>
<table>
<thead>
<tr>
<th>Entity</th>
<th>Knowledge</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relay 1</td>
<td>Client address, Relay 2 address</td>
</tr>
<tr>
<td>Relay 2</td>
<td>Relay 1 address, Server address</td>
</tr>
<tr>
<td>Server</td>
<td>Relay 2 address, Server address</td>
</tr>
</tbody>
</table>
<p>Note that if the two relays collude, they can together
uncover the client&#39;s address and the server&#39;s address. However,
if either is honest, then the client&#39;s privacy should be
protected, as
neither can easily collude with the server to learn this
information:
relay 2 because it does not know the client&#39;s address
and relay 1 because (hopefully) the client&#39;s connection
to relay 2 is one of many connections it has made to
relay 2 during this time period. How well this last part
works depends on the scale of operation of the system,
how long the client leaves the connection up,
whether it reuses the connection to relay 2 for
connections to multiple servers, etc.</p>
<p>Of course, in order for this to work, the relays need
to be operated by different entities.
Otherwise there&#39;s no meaningful guarantee of non-collusion.
This includes
not being run on the same cloud service provider
(e.g., AWS).
Sometimes you&#39;ll hear about <a href="https://www.comparitech.com/blog/vpn-privacy/multi-hop-vpn/">multi-hop VPNs</a> but
if the same company is providing both VPN servers, then
this doesn&#39;t really help. One nice feature of iCloud
Private Relay is that your account is with Apple but they
arrange for multiple hops with different providers, so
you don&#39;t need to worry about the details.</p>
<p>One important limitation of multiple hops is that it
can have a negative impact on performance. In general,
the routing algorithms that run the Internet try to
find a reasonably efficient route between two locations
and so you should expect that if instead of routing between
point A and point B you route from A to C to B, then this
will be somewhat slower (you&#39;ll often hear people use
the term <a href="https://en.wikipedia.org/w/index.php?title=Triangle_inequality&amp;oldid=1100229250">triangle inequality</a>
as shorthand for this). The more hops you do, the more
likely it is you will have some kind of performance impact.
This isn&#39;t a precise effect, but in general, you should expect to have some
impact.</p>
<p>iCloud Private Relay is a <a href="https://support.apple.com/en-us/HT212614">two hop network</a>, with the
first hope being operated by Apple and the second
hop being a large provider that Apple has contracted with
(mostly Content Delivery Networks (CDN) like Cloudflare or Akamai).
Both Apple and these CDNs have fast connectivity and good
geographic distribution, which is intended to ensure
high performance. Tor uses <a href="https://support.torproject.org/glossary/circuit/">three hops</a>,
a &#34;guard node&#34;, a &#34;middle relay&#34; and an &#34;exit node&#34;. As discussed below,
Tor relays are effectively volunteer services, so performance varies in
practice.</p>
<h3 id="business-model">Business Model <a href="#business-model">#</a></h3>
<p>Your typical VPN has a simple business model: you pay the VPN provider
and then authenticate to them (e.g., with a password) when you connect.
This isn&#39;t ideal for privacy because they know your name, contact
information, and credit card number.
On the other hand, as described above, they already know your IP address and which
sites you&#39;re going to, so it&#39;s not clear how much worse this makes things.</p>
<p>With Private Relay, however, this would create a real problem:
it&#39;s not so bad with the first hop relay because that gets your IP
address anyway, but if you authenticate to the second relay with
your identity, then you&#39;ve ruined everything and you might as well
be back with a single hop system. In order to address this problem,
Apple uses anonymous credentials generated using <a href="https://en.wikipedia.org/w/index.php?title=Blind_signature&amp;oldid=1088007463">blind signatures</a> to authenticate to the proxy,
as shown below:</p>
<p><img src="https://educatedguesswork.org/img/anonymous-proxy.png" alt="Anonymous Authentication"/></p>
<p>Briefly, the way this works is that the client connects to
Apple and authenticates to it using its iCloud account.
Apple then issues an anonymous credential that doesn&#39;t
contain the user&#39;s identity. This credential can
be provided to the relay to authorize use of the service.
In order to prevent Apple from linking up these two activities
the credential is <em>blinded</em> (essentially encrypted)
when Apple generates it, and then the client unblinds
it before sending it to the relay
(see <a href="https://educatedguesswork.org/posts/vaccine-passport-anon/#digression%3A-anonymous-credentials">here</a> for more
detail on how this kind of credential works).
This design allows the
proxy to know that you are authorized to use the service but
not to see who you are.</p>
<p>Tor is different from either of these because it&#39;s a free service,
operated by members of the community (you can <a href="https://support.torproject.org/faq/relay-donations/">donate</a>
to people who run relays). This creates some unpredictable
performance consequences because there really isn&#39;t much
in the way of a <em>Service Level Agreement (SLA)</em>. It also
makes it somewhat hard to assess the actual privacy guarantees,
because some of the Tor nodes might be run by people you don&#39;t
trust or who are actively malicious. Obviously, with iCloud Private Relay
you have to judge for yourself how much you trust Apple and its partners,
but at least you have some idea who they are.</p>
<h2 id="summary-and-final-thoughts">Summary and Final Thoughts <a href="#summary-and-final-thoughts">#</a></h2>
<p>IP addresses are an important and highly effective tracking vector and
if you want to browse privately you need to do something to conceal
your IP, and this mostly means relaying. Any relaying system
will conceal your identity from the server, as long as your
provider isn&#39;t colluding with the server.
Any one hop system necessarily means that you are trusting
the provider not to track your behavior and not to collude
with the server. Depending on how you feel about your local network
and its privacy policies, a single hop system might or might not
be an improvement (see Yael Grauer&#39;s <a href="https://www.consumerreports.org/vpn-services/mullvad-ivpn-mozilla-vpn-top-consumer-reports-vpn-testing-a9588707317/">article in Consumer Reports</a> for more on this). A multi-hop
system has a much better privacy story because misbehavior by
a single relay is not sufficient to compromise your privacy.</p>
<p>The technical details of how the system works (IP versus application
layer, mostly) don&#39;t matter that much for privacy but do matter
for functionality, with application layer systems being more
flexible but providing less complete coverage for other applications
on your device. In addition, all of the multi-hop systems that I know
are at the application layer, so as a practical matter if you
want a multi-hop system you probably will be using an application
layer system.</p>
<p>Finally, it&#39;s important to know that even the best system
provides only limited protection. An attacker who has a complete
view of the network can often do enough traffic analysis to
determine who is on each end of the traffic. Fortunately, most
of us do not need to worry about this powerful an attacker.</p>



    </article>

    
      
  </div>
  
</div>

<!-- Cloudflare Web Analytics --><!-- End Cloudflare Web Analytics -->


          </main>
        </div></div>
  </body>
</html>
