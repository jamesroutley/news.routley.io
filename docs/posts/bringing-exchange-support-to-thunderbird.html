<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.thunderbird.net/2024/04/adventures-in-rust-bringing-exchange-support-to-thunderbird/">Original</a>
    <h1>Bringing Exchange Support to Thunderbird</h1>
    
    <div id="readability-page-1" class="page"><div>
								<img src="https://blog.thunderbird.net/files/2024/04/Tb-rust1.png" alt="featured post title image"/>
						<section>
												

				
<p>Microsoft Exchange is a popular choice of email service for corporations and educational institutions, and so it’s no surprise that there’s demand among Thunderbird users to support Exchange. Until recently, this functionality was only available through an add-on. But, in the next ESR (Extended Support) release of Thunderbird in July 2024, we expect to provide this support natively within Thunderbird. Because of the size of this undertaking, the first roll-out of the Exchange support will <a href="https://youtu.be/7jNV1J2pdPc">initially cover only email</a>, with calendar and address book support coming at a later date.</p>



<p>This article will go into technical detail on how we are implementing support for the Microsoft Exchange Web Services mail protocol, and some idea of where we’re going next with the knowledge gained from this adventure.</p>



<p><em>Before we dive in, just a quick note that <strong>Brendan Abolivier, Ikey Doherty</strong>, and <strong>Sean Burke</strong> are the developers behind this effort, and are the authors of this post.</em></p>



<figure></figure>







<p>Thunderbird is a long-lived project, which means there’s lots of old code. The current architecture for supporting mail protocols predates Thunderbird itself, having been developed more than 20 years ago as part of Netscape Communicator. There was also no paid maintainership from about 2012 — when Mozilla divested and  transferred ownership of Thunderbird to its community — until 2017, when Thunderbird rejoined the Mozilla Foundation. That means years of ad hoc changes without a larger architectural vision and a lot of decaying C++ code that was not using modern standards.</p>



<p>Furthermore, in the entire 20 year lifetime of the Thunderbird project, no one has added support for a new mail protocol before. As such, no one has updated the architecture as mail protocols change and adapt to modern usage patterns, and a great deal of institutional knowledge has been lost. Implementing this much-needed feature is the first organization-led effort to actually understand and address limitations of Thunderbird’s architecture in an incremental fashion.</p>







<p>Thunderbird is a large project maintained by a small team, so choosing a language for new work cannot be taken lightly. We need powerful tools to develop complex features relatively quickly, but we absolutely must balance this with long-term maintainability. Selecting Rust as the language for our new protocol support brings some important benefits:</p>



<ol>
<li><strong>Memory safety.</strong> Thunderbird takes input from anyone who sends an email, so we need to be diligent about keeping security bugs out.</li>



<li><strong>Performance.</strong> Rust runs as native code with all of the associated performance benefits.</li>



<li><strong>Modularity and Ecosystem.</strong> The built-in modularity of Rust gives us access to a large ecosystem where there are already a lot of people doing things related to email which we can benefit from.</li>
</ol>



<p>The above are all on the standard list of benefits when discussing Rust. However, there are some additional considerations for Thunderbird:</p>



<ol>
<li><strong>Firefox.</strong> Thunderbird is built on top of Firefox code and we use a shared CI infrastructure with Firefox which already enables Rust. Additionally, Firefox provides a language interop layer called XPCOM (Cross-Platform Component Object Model), which has Rust support and allows us to call between Rust, C++, and JavaScript.</li>



<li><strong>Powerful tools.</strong> Rust gives us a large toolbox for building APIs which are difficult to misuse by pushing logical errors into the domain of the compiler. We can easily avoid circular references or provide functions which simply cannot be called with values which don’t make sense, letting us have a high degree of confidence in features with a large scope. Rust also provides first-class tooling for documentation, which is critically important on a small team.</li>



<li><strong>Addressing architectural technical debt.</strong> Introducing a new language gives us a chance to reconsider some aging architectures while benefiting from a growing language community.</li>



<li><strong>Platform support and portability.</strong> Rust supports a broad set of host platforms. By building modular crates, we can reuse our work in other projects, such as Thunderbird for Android/K-9 Mail.</li>
</ol>



<h2>Some mishaps along the way</h2>



<p>Of course, the endeavor to introduce our first Rust component in Thunderbird is not without its challenges, mostly related to the size of the Thunderbird codebase. For example, there is a lot of existing code with idiosyncratic asynchronous patterns that don’t integrate nicely with idiomatic Rust. There are also lots of features and capabilities in the Firefox and Thunderbird codebase that don’t have any existing Rust bindings.</p>



<h3>The first roadblock: the build system</h3>



<p>Our first hurdle came with getting any Rust code to run in Thunderbird at all. There are two things you need to know to understand why:</p>



<p>First, since the Firefox code is a dependency of Thunderbird, you might expect that we pull in their code as a subtree of our own, or some similar mechanism. However, for historical reasons, it’s the other way around: building Thunderbird requires fetching Firefox’s code, fetching Thunderbird’s code as a subtree of Firefox’s, and using a build configuration file to point into that subtree.</p>



<p>Second, because Firefox’s entrypoint is written in C++ and Rust calls happen via an interoperability layer, there is no single point of entry for Rust. In order to create a tree-wide dependency graph for Cargo and avoid duplicate builds or version/feature conflicts, Firefox introduced a hack to generate a single Cargo workspace which aggregates all the individual crates in the tree.</p>



<p>In isolation, neither of these is a problem in itself. However, in order to build Rust into Thunderbird, we needed to define our own Cargo workspace which lives in our tree, and Cargo does not allow nesting workspaces. To solve this issue, we had to define our own workspace and add configuration to the upstream build tool, <code>mach</code>, to build from this workspace instead of Firefox’s. We then use a newly-added <code>mach</code> subcommand to sync our dependencies and lockfile with upstream and to vendor the resulting superset.</p>



<h3>XPCOM</h3>



<p>While the availability of language interop through XPCOM is important for integrating our frontend and backend, the developer experience has presented some challenges. Because XPCOM was originally designed with C++ in mind, implementing or consuming an XPCOM interface requires a lot of boilerplate and prevents us from taking full advantage of tools like rust-analyzer. Over time, Firefox has significantly reduced its reliance on XPCOM, making a clunky Rust+XPCOM experience a relatively minor consideration. However, as part of the previously-discussed maintenance gap, Thunderbird never undertook a similar project, and supporting a new mail protocol requires implementing hundreds of functions defined in XPCOM.</p>



<p>Existing protocol implementations ease this burden by inheriting C++ classes which provide the basis for most of the shared behavior. Since we can’t do this directly, we are instead implementing our protocol-specific logic in Rust and communicating with a bridge class in C++ which combines our Rust implementations (an internal crate called <code>ews_xpcom</code>) with the existing code for shared behavior, with as small an interface between the two as we can manage.</p>



<p>Please visit our <a href="https://source-docs.thunderbird.net/en/latest/rust/index.html" target="_blank" rel="noreferrer noopener">documentation</a> to learn more about how to create Rust components in Thunderbird.</p>







<p>Despite the technical hiccups experienced along the way, we were able to clear the hurdles, use, and build Rust within Thunderbird. Now we can talk about how we’re using it and the tools we’re building. Remember all the way back to the beginning of this blog post, where we stated that our goal is to support Microsoft’s Exchange Web Services (EWS) API. EWS communicates over HTTP with request and response bodies in XML.</p>



<h2>Sending HTTP requests</h2>



<p>Firefox already includes a full-featured HTTP stack via its <code>necko</code> networking component. However, <code>necko</code> is written in C++ and exposed over XPCOM, which as previously stated does not make for nice, idiomatic Rust. Simply sending a GET request requires a great deal of boilerplate, including nasty-looking unsafe blocks where we call into XPCOM. (XPCOM manages the lifetime of pointers and their referents, ensuring memory safety, but the Rust compiler doesn’t know this.) Additionally, the interfaces we need are callback-based. For making HTTP requests to be simple for developers, we need to do two things:</p>



<ol>
<li><strong>Support native Rust async/await syntax.</strong> For this, we added a new Thunderbird-internal crate, <code>xpcom_async</code>. This is a low-level crate which translates asynchronous operations in XPCOM into Rust’s native async syntax by defining callbacks to buffer incoming data and expose it by implementing Rust’s <code>Future</code> trait so that it can be awaited by consumers. (If you’re not familiar with the <code>Future</code> concept in Rust, it is similar to a JS <code>Promise</code> or a Python coroutine.)</li>



<li><strong>Provide an idiomatic HTTP API.</strong> Now that we had native <code>async</code>/<code>await</code> support, we created another internal crate (<code>moz_http</code>) which provides an HTTP client inspired by <code>reqwest</code>. This crate handles creating all of the necessary XPCOM objects and providing Rustic error handling (much nicer than the standard XPCOM error handling).</li>
</ol>



<h2>Handling XML requests and responses</h2>



<p>The hardest task in working with EWS is translating between our code’s own data structures and the XML expected/provided by EWS. Existing crates for serializing/deserializing XML didn’t meet our needs. <code>serde</code>’s data model doesn’t align well with XML, making distinguishing XML attributes and elements difficult. EWS is also sensitive to XML namespaces, which are completely foreign to <code>serde</code>. Various <code>serde</code>-inspired crates designed for XML exist, but these require explicit annotation of how to serialize every field. EWS defines hundreds of types which can have dozens of fields, making that amount of boilerplate untenable.</p>



<p>Ultimately, we found that existing <code>serde</code>-based implementations worked fine for deserializing XML into Rust, but we were unable to find a satisfactory tool for serialization. To that end, we introduced another new crate, <code>xml_struct</code>. This crate defines traits governing serialization behavior and uses Rust’s procedural derive macros to automatically generate implementations of these traits for Rust data structures. It is built on top of the existing <code>quick_xml</code> crate and designed to create a low-boilerplate, intuitive mapping between XML and Rust.  While it is in the early stages of development, it does not make use of any Thunderbird/Firefox internals and is <a href="https://github.com/thunderbird/xml-struct-rs">available on GitHub</a>.</p>



<p>We have also introduced one more new crate, <code>ews</code>, which defines types for working with EWS and an API for XML serialization/deserialization, based on <code>xml_struct</code> and <code>serde</code>. Like <code>xml_struct</code>, it is in the early stages of development, but is <a href="https://github.com/thunderbird/ews-rs">available on GitHub</a>.</p>



<h2>Overall flow chart</h2>



<p>Below, you can find a handy flow chart to help understand the logical flow for making an Exchange request and handling the response. </p>



<figure><a href="https://blog.thunderbird.net/files/2024/04/pasted-image-.png"><img decoding="async" fetchpriority="high" width="1600" height="716" src="https://blog.thunderbird.net/files/2024/04/pasted-image-.png" alt="A bird&#39;s eye view of the flow" title="A bird’s eye view of the flow" srcset="https://blog.thunderbird.net/files/2024/04/pasted-image-.png 1600w, https://blog.thunderbird.net/files/2024/04/pasted-image--252x113.png 252w, https://blog.thunderbird.net/files/2024/04/pasted-image--600x269.png 600w, https://blog.thunderbird.net/files/2024/04/pasted-image--768x344.png 768w, https://blog.thunderbird.net/files/2024/04/pasted-image--1536x687.png 1536w" sizes="(max-width: 1600px) 100vw, 1600px"/></a></figure>



<p>Fig 1. A bird’s eye view of the flow</p>







<h2>Testing all the things</h2>



<p>Before landing our next major features, we are taking some time to build out our automated tests. In addition to unit tests, we just landed a mock EWS server for integration testing. The current focus on testing is already paying dividends, having exposed a couple of crashes and some double-sync issues which have since been rectified. Going forward, new features can now be easily tested and verified.</p>



<h2>Improving error handling</h2>



<p>While we are working on testing, we are also busy improving the story around error handling. EWS’s error behavior is often poorly documented, and errors can occur at multiple levels (e.g., a request may fail as a whole due to throttling or incorrect structure, or parts of a request may succeed while other parts fail due to incorrect IDs). Some errors we can handle at the protocol level, while others may require user intervention or may be intractable. In taking the time now to improve error handling, we can provide a more polished implementation and set ourselves up for easier long-term maintenance.</p>



<h2>Expanding support</h2>



<p>We are working on expanding protocol support for EWS (via <code>ews</code> and the internal <code>ews_xpcom</code> crate) and hooking it into the Thunderbird UI. Earlier this month, we landed a series of patches which allow adding an EWS account to Thunderbird, syncing the account’s folder hierarchy from the remote server, and displaying those folders in the UI. (At present, this alpha-state functionality is gated behind a build flag and a preference.) Next up, we’ll work on fetching message lists from the remote server as well as generalizing outgoing mail support in Thunderbird.</p>



<h2>Documentation</h2>



<p>Of course, all of our work on maintainability is for naught if no one understands what the code does. To that end, we’re producing documentation on how all of the bits we have talked about here come together, as well as describing the existing architecture of mail protocols in Thunderbird and thoughts on future improvements, so that once the work of supporting EWS is done, we can continue building and improving on the Thunderbird you know and love.</p>
				

			</section>
			

			
			</div></div>
  </body>
</html>
