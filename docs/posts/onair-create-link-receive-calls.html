<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://onair.io/">Original</a>
    <h1>Show HN: OnAir â€“ create link, receive calls</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is a post about effectively using Erlang records in Elixir code.</p><p>Lately I&#39;ve been working on an Elixir project that uses a few Erlang libraries that represent data using the record data type.</p><p><a href="https://www.erlang.org/doc/system/data_types.html#record" rel="noopener" target="_blank">Here&#39;s how Erlang&#39;s documentation describes records:</a></p><blockquote><p>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. [...] record expressions are translated to tuple expressions during compilation</p></blockquote><p>Records exist in Elixir too but are mostly there for compatibility with Erlang (for a variety of reasons you&#39;re better off using a struct or a map than a record in pure Elixir code). <a href="https://hexdocs.pm/elixir/main/Record.html" rel="noopener" target="_blank">The official Elixir docs about records</a> are brief and left me unsure about how to actually use them, so after some experimenting I&#39;ve made this brief guide for reference. I hope you find it useful!</p><p>This guide assumes basic familiarity with Elixir&#39;s syntax, pattern matching, and tooling. While no prior Erlang experience is required, you should be comfortable working with Elixir&#39;s basic data types like tuples and maps.</p><p>Broadly, Elixir&#39;s Record module lets you do two things:</p><p><strong>1. Extract Definitions</strong></p><p>Extract definitions of records from existing Erlang header files into an Elixir module as tuples. The functions <code>extract/2</code> and <code>extract_all/1</code> are used for this.</p><p><strong>2. Generate Helpers</strong></p><p>Generate helpers for creating, accessing, and pattern matching record data types from tuples describing records. The macros <code>defrecord/3</code> and <code>defrecordp/3</code> are used for this.</p><p>It&#39;s crucial to note that you need to do both steps (extract and define) to actually use the records defined in Erlang files inside Elixir code. Extracting record definitions from Erlang headers results in tuples describing the records, but does not generate the helpers for creating, accessing, and pattern matching on records.</p><p>Simply put, you need to plumb the output of <code>extract/2</code> or <code>extract_all/1</code> into <code>defrecord/2</code> (or <code>defrecordp/3</code>) to use Erlang records in Elixir code.</p><p>As an example, the code below extracts the <code>:gtp</code> record type from the library <code>gtp_packet.hrl</code> and puts a tuple defining the record into <code>gtp_def</code>. Then, <code>:gtp</code> and <code>gtp_def</code> are passed to <code>Record.defrecord/3</code> to generate code for using the <code>gtp</code> record type:</p><pre data-lang="elixir"><code data-lang="elixir"><span>  gtp_def = </span><span>Record</span><span>.extract(</span><span>:gtp</span><span>, </span><span>from_lib: </span><span>&#34;</span><span>gtplib/include/gtp_packet.hrl</span><span>&#34;)
</span><span>  </span><span>Record</span><span>.defrecord(</span><span>:gtp</span><span>, gtp_def) </span><span># generates the macros gtp/0, gtp/1, gtp/2
</span></code></pre><p>Extracting and defining records can get really tedious if you find yourself working with many different record types. Thankfully, Elixir also provides a way to extract records in bulk from Erlang headers. Unfortunately, there&#39;s no way to define record helpers in bulk. However, the <code>Enum</code> module and a simple lambda function comes to the rescue!</p><pre data-lang="elixir"><code data-lang="elixir"><span>  # Define helpers dynamically based on the extracted records
</span><span>  </span><span>Enum</span><span>.each(</span><span>Record</span><span>.extract_all(</span><span>from_lib: </span><span>&#34;</span><span>gtplib/include/gtp_packet.hrl</span><span>&#34;), </span><span>fn </span><span>{name, fields} -&gt;
</span><span>    </span><span>Record</span><span>.defrecord(name, fields)
</span><span>  </span><span>end</span><span>)
</span></code></pre><p>Each tuple from <code>extract_all/2</code> of <code>{name, fields}</code>, where <code>name</code> is simply the name of the record and <code>fields</code> is a tuple describing the record&#39;s fields is passed into <code>defrecord/3</code> just as in the manually-done first example we saw earlier. I think it&#39;s kind of strange there&#39;s no <code>extract_and_define</code> function in Elixir that does this all for you, but whatever, this way gives you a little more control over things (for example, you could modify the names, such as putting a prefix on them, to avoid a collision if you&#39;re importing records from several different Erlang libraries into the same Elixir module).</p><p>After you&#39;ve managed to generate code for working with records using <code>defrecord/3</code> you can finally use them! If you called <code>defrecord(:foo, foo_defs)</code> (where <code>foo_defs</code> was returned from <code>extract/2</code>) you&#39;d end up with three new macros all named <code>foo</code>. Let&#39;s imagine the record type <code>foo</code> contains the fields <code>bar</code> and <code>baz</code>. In fact, you can do all this in <code>iex</code> as long as you wrap in inside a module definition:</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; </span><span>defmodule </span><span>Foo </span><span>do
</span><span>...&gt; </span><span>Record</span><span>.defrecord(</span><span>:foo</span><span>, [</span><span>bar: </span><span>:undefined</span><span>, </span><span>baz: </span><span>:undefined</span><span>])
</span><span>...&gt; </span><span>end
</span></code></pre><h2 id="creating-records">Creating Records</h2><p>Now let&#39;s use <code>foo/0</code> to create a <code>foo</code> record with default values (spoiler: it&#39;s boring, but it&#39;s a start):</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; </span><span>Foo</span><span>.foo()
</span><span>{</span><span>:foo</span><span>, </span><span>:undefined</span><span>, </span><span>:undefined</span><span>}
</span></code></pre><p>Notice the result is a tuple starting with <code>:foo</code>.</p><p>To make things a little more interesting we can set values in the <code>foo</code> we&#39;re creating:</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; </span><span>Foo</span><span>.foo(</span><span>bar: </span><span>:asdf</span><span>, </span><span>baz: 1234</span><span>)
</span><span>{</span><span>:foo</span><span>, </span><span>:asdf</span><span>, </span><span>1234</span><span>}
</span></code></pre><p>Let&#39;s say we have a record like <code>{:foo, :asdf, 1234}</code> and that we&#39;re forgetful and can&#39;t remember the order of <code>bar</code> and <code>baz</code> inside the record. We can use the <code>foo/1</code> macro generated by <code>defrecord/2</code> earlier to see the keys and the values laid out clearly:</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; </span><span>Foo</span><span>.foo({</span><span>:foo</span><span>, </span><span>:asdf</span><span>, </span><span>1234</span><span>})
</span><span>[</span><span>bar: </span><span>:asdf</span><span>, </span><span>baz: 1234</span><span>]
</span></code></pre><h2 id="accessing-a-field-within-records">Accessing a Field within Records</h2><p>You can access individual fields within a record using square brackets, similarly to a Map. To do this, you pass the tuple representation of a record into the generated function with 1-arity, here <code>foo/1</code>.</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; my_foo = </span><span>Foo</span><span>.foo(</span><span>bar: </span><span>:asdf</span><span>, </span><span>baz: 1234</span><span>)
</span><span>{</span><span>:foo</span><span>, </span><span>:asdf</span><span>, </span><span>1234</span><span>}
</span><span>iex&gt; </span><span>Foo</span><span>.foo(my_foo)[</span><span>:bar</span><span>]
</span><span>:asdf
</span><span>iex&gt; </span><span>Foo</span><span>.foo(my_foo)[</span><span>:baz</span><span>]
</span><span>1234
</span></code></pre><p>The generated 2-arity function <code>foo/2</code> allows for the same with slightly different syntax:</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; </span><span>Foo</span><span>.foo(my_foo, </span><span>:bar</span><span>)
</span><span>:asdf
</span><span>iex&gt; </span><span>Foo</span><span>.foo(my_foo, </span><span>:baz</span><span>)
</span><span>1234
</span></code></pre><p>Now we can clearly see that <code>bar</code> is set to <code>asdf</code> and <code>baz</code> is set to <code>1234</code>. This technique can come in really handy for working with records in the repl if you want to inspect them.</p><h2 id="pattern-matching-on-records">Pattern Matching on Records</h2><p>However, we can go further and even pattern match on fields within records with similar syntax to pattern matching on Maps. Taking the same <code>foo</code> example record as before, <code>bar</code> and <code>baz</code> can be pattern matched into their own variables:</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; my_foo = </span><span>Foo</span><span>.foo(</span><span>bar: </span><span>:asdf</span><span>, </span><span>baz: 1234</span><span>)
</span><span>{</span><span>:foo</span><span>, </span><span>:asdf</span><span>, </span><span>1234</span><span>}
</span><span>iex&gt; </span><span>Foo</span><span>.foo(</span><span>bar:</span><span> bar, </span><span>baz:</span><span> baz) = my_foo
</span><span>{</span><span>:foo</span><span>, </span><span>:asdf</span><span>, </span><span>1234</span><span>}
</span><span>iex&gt; bar
</span><span>:asdf
</span><span>iex&gt; baz
</span><span>1234
</span></code></pre><p>Pattern matching is very useful if an Erlang library hands you a record from which you want to concisely extract multiple values. Pattern matching can also be done in function heads to select a specific implementation of a function based on the values of its inputs. For more details on pattern matching see the Elixir docs.</p><h2 id="updating-records">Updating Records</h2><p>Finally, you can update fields in an existing record (leaving other fields untouched) using the 2-arity version of the generated macro, again <code>foo/2</code> here:</p><pre data-lang="elixir"><code data-lang="elixir"><span>iex&gt; my_foo = </span><span>Foo</span><span>.foo(</span><span>bar: </span><span>:asdf</span><span>, </span><span>baz: 1234</span><span>)
</span><span>{</span><span>:foo</span><span>, </span><span>:asdf</span><span>, </span><span>1234</span><span>}
</span><span>iex&gt; </span><span>Foo</span><span>.foo(my_foo, </span><span>bar: </span><span>:qwerty</span><span>)
</span><span>{</span><span>:foo</span><span>, </span><span>:qwerty</span><span>, </span><span>1234</span><span>}
</span><span>iex&gt; </span><span>Foo</span><span>.foo(my_foo, </span><span>bar: </span><span>:qwerty</span><span>, </span><span>baz: 5678</span><span>)
</span><span>{</span><span>:foo</span><span>, </span><span>:qwerty</span><span>, </span><span>5678</span><span>}
</span></code></pre><p>I&#39;ve tried to show in detail with plenty of examples how to use the functionality of Elixir&#39;s <code>Record</code> module. This includes extracting record definitions from Erlang header files using <code>extract/2</code> and <code>extract_all/2</code>, generating macros for working with records via <code>defrecord/3</code> and <code>defrecordp/3</code>, and examples of how to read, write, and update record data types in the previous few subsections.</p><p>Hopefully this guide fills in the gaps in the official documentation and makes at least one other person&#39;s life a little easier.</p></div></div>
  </body>
</html>
