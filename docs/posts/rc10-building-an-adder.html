<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC10/">Original</a>
    <h1>RC10. Building an Adder</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-05-29T00:00:00-07:00">May 29, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>A while back I built a 4-bit adder on a breadboard and managed to reduce each full adder component to five logic gates. In truth I’m not sure how I managed it, since I didn’t know about boolean algebra. From what I can deduce from the long series of deranged-looking and often-abandoned schematics I discovered in my notebook, it took quite a bit of trial and error.</p>

<p>Well, I’m building another adder (and eventually an ALU), and this time I’m determined to derive the logic using boolean algebra. Thanks to some collaboration from a fellow recurser, I’ve figured it out.</p>



<p>First things first: The number system we normally use is base 10, or decimal, or denary. That means we have 10 digital to choose from: your friends and mine, <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, and <code>9</code>. But we can count to higher than <code>9</code>, can’t we? When we run out of digits, we carry over the 1 from the ones place to the tens place and keep going.</p>

<p>Same idea with binary, except that it’s base-2, which means we have two digits to choose from, <code>0</code> and <code>1</code>. And <em>that</em> means that we have to carry over once we exhause those two digits. So counting from 0 to 10 looks more like this:</p>

<div><div><pre><code>   0 =&gt; 0
   1 =&gt; 1
  10 =&gt; 2
  11 =&gt; 3
 100 =&gt; 4
 101 =&gt; 5
 110 =&gt; 6
 111 =&gt; 7
1000 =&gt; 8
1001 =&gt; 9
1010 =&gt; 10
</code></pre></div></div>

<p>In a base-10 number system, each place value represents \(10^n\), where \(n\) is the place from right to left. Hence the ones place, the tens place, the hundreds place, etc. In base-2, each place value represents instead \(2^n\).</p>


<p>When it comes to addition, well, binary addition once again follows the same logic and rules used in denary addition, except with fewer available digits.</p>

<div><div><pre><code>0 + 0 = 0
1 + 0 = 1
0 + 1 = 1
1 + 1 = 10 =&gt; carry the one
</code></pre></div></div>

<p>Here’s a slightly more complicated example. Let’s say we’re adding 21 and 19 in decimal. We start with the digits on the right – the least significant ones since they’re the ones place – and we add them up. If they exceed 9, what do we do? Carry the one! And repeat.</p>

\[\begin{array}{r@{\hskip 0em}r@{\hskip 0em}r}
 &amp; ^1 &amp; \\
 &amp; 2 &amp; 1 \\
+ &amp; 1 &amp; 9 \\
\hline
 &amp; 4 &amp; 0 \\
\end{array}\]

<p>In binary it’s pretty much the drill, except for the fewer available digits thing. So if we want to add 21 (10101 in binary) and 19 (10011), it would look a little like this:</p>

\[\begin{array}{r}
&amp; &amp;  ^1  &amp;   &amp; ^1 &amp; ^1 &amp; ^1 \\
    &amp; &amp; &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
  + &amp; &amp; &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
  \hline
  &amp; &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0
\end{array}\]



<p>This is all well and good, but the question is how to combine logic gates to produces this behavior. What we need is to combine two input bits, <code>a</code> and <code>b</code>, and somehow spit out both a sum bit <code>y</code> and a carry bit <code>c</code>.</p>

<h4 id="the-sum-bit">The Sum Bit</h4>
<p>If we’re adding two bits, there are only four possible combinations of digits we can add together – <code>0 + 0</code>, <code>0 + 1</code>, <code>1 + 0</code>, and <code>1 + 1</code>. A truth table makes clear what we would expect from each of these combinations:</p>

<table>
  <tbody><tr>
    <th>a</th>
    <th>b</th>
    <th>sum y</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<p>It seems, then, that the sum bit is the logical combination of <code>a XOR b</code>. Or to put it formally:
\(y_{i} = a_{i} \oplus b_{i}\)
where <em>i</em> is the bit place.</p>

<h4 id="the-carry-bit">The Carry Bit</h4>
<p>The truth table for the carry bit, alternatively, would look like this:</p>

<table>
  <tbody><tr>
    <th>a</th>
    <th>b</th>
    <th>carry bit c</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
  </tr>
</tbody></table>

<p>In this case, the carry bit is the logical combination of a AND b. Formally:
\(c_{i+1} = a_{i} \cap b_{i}\)
where <em>i</em> is the bit place. (Note that the carry bit is at place <em>i + 1</em> since it will be summed along with the next most significant digits.)</p>



<p>This is all well and good, but as we saw in the sample binary addition equation above, we’re acutally always dealing with three terms: not only input <code>a</code> and input <code>b</code>, but also carry bit <code>c</code> from the next least significant digit.</p>

<p>The logic table for a full adder, then – one which takes inputs <code>a</code> and <code>b</code> <em>and</em> a carry bit <code>c</code> – would look like this:</p>

<table>
  <tbody><tr>
    <th>a<sub>i</sub></th>
    <th>b<sub>i</sub></th>
    <th>c<sub>i</sub></th>
    <th>sum y<sub>i</sub></th>
    <th>carry c<sub>i+1</sub></th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
  </tr>
</tbody></table>



<p>The first step in figuring out how to build an adder is to sort out the logic for the sum bit. I’ll follow the approach of constructing a logical statement for each <code>True</code>, or <code>1</code>, output, <code>OR</code>ing the results together, and simplifying.</p>

<table>
  <tbody><tr>
    <th>a<sub>i</sub></th>
    <th>b<sub>i</sub></th>
    <th>c<sub>i</sub></th>
    <th>sum y<sub>i</sub></th>
    <th>Logic</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>NOT(A) AND NOT(B) AND C</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>NOT(A) AND B AND NOT(C)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>A AND NOT(B) AND NOT(C)</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>A AND B AND C</td>
  </tr>
</tbody></table>

<p><code>OR</code>ing it all together, the full expression is as follows:</p>

\[\begin{array}{llr}
  &amp; (\lnot a \land \lnot b \land c) \lor (\lnot a \land b \land \lnot c) \lor (a \land \lnot b \land \lnot c) \lor (a \land b \land c) \\
= &amp; (\lnot a \land (\lnot c \land b) \lor (c \land \lnot b)) \lor (a \land (\lnot c \land \lnot b) \lor (c \land b)) &amp;\Leftarrow \text{by distributive law}\\
\end{array}\]

<p>At this point, we might recognize that the first half of the equation has an <code>XOR</code> expression lurking within: \((\lnot c \land b) \lor (c \land \lnot b) = c \oplus b\). And the second half of the equation has a negated <code>XOR</code>, or <code>XNOR</code>, expression in it: \((\lnot c \land \lnot b) \lor (c \land b) = c \odot b = \lnot (c \oplus b)\)</p>

<p>Substituing the somewhat simpler notation in, our equation looks like this:</p>

\[\begin{array}{l}
  &amp; (\lnot a \land (c \oplus b)) \lor (a \land \lnot (c \oplus b)) \\
\end{array}\]

<p>If we temporarily replace the \((c \oplus b)\) <code>XOR</code> statements with a new variable, our expression suddenly becomes:</p>

\[\begin{array}{l}
  &amp; (\lnot a \land x) \lor (a \land \lnot x) \\
\end{array}\]

<p>which, we should recognize, is another <code>XOR</code> expression:</p>

\[\begin{array}{l}
  &amp; (a \oplus x) \\
\end{array}\]

<p>Expanding our <code>x</code> variable, the final logical expression looks like this:</p>

\[\begin{array}{l}
  &amp; a \oplus (c \oplus b) \\
\end{array}\]

<p><img src="https://www.datadoodad.com/assets/images/RC10_sum-bit.png" alt="Sum bit logic"/></p>



<p>Now that we’ve sorted out the sum bit, the next step is designing the logic for the carry bit. Once agan, I’ll take the approach of constructing a logical statement for each <code>True</code>, or <code>1</code>, output from the truth table, <code>OR</code>ing the results together, and simplifying.</p>

<p>The logic table for a full adder, then – one which takes inputs <code>a</code> and <code>b</code> <em>and</em> a carry bit <code>c</code> – would look like this:</p>

<table>
  <tbody><tr>
    <th>a<sub>i</sub></th>
    <th>b<sub>i</sub></th>
    <th>C<sub>i</sub></th>
    <th>c<sub>i+1</sub></th>
    <th>Logic</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>NOT(A) AND B AND C</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td></td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>A AND NOT(B) AND C</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>A AND B AND NOT(C)</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>A AND B AND C</td>
  </tr>
</tbody></table>

<p>Thus our starting equation is:</p>

\[\begin{array}{llr}
  &amp; (\lnot a \land b \land c) \lor (a \land \lnot b \land c) \lor (a \land b \land \lnot c) \lor (a \land b \land c) \\
= &amp; (c \land ((\lnot a \land b) \lor (a \land \lnot b) \lor (a \land b)) \lor (a \land b \land \lnot c ) &amp;\Leftarrow \text{by distributive law}\\
\end{array}\]

<p>This is complicated-looking, but as with the sum bit logic, there’s a major simplification that can happen once we recognize that the term \((\lnot a \land b) \lor (a \land \lnot b) \lor (a \land b) = a \lor b\). This becomes clear just from thinking about the three terms making up the equation, but it can also be derived like so:</p>

\[\begin{array}{llr}
  &amp; (\lnot a \land b) \lor (a \land \lnot b) \lor (a \land b) \\
= &amp; (\lnot a \land b) \lor (a \land ( \lnot b \lor b)) &amp;\Leftarrow \text{by distributive law}\\
= &amp; (\lnot a \land b) \lor (a \land 1)  &amp;\Leftarrow \text{by compliment law}\\
= &amp; (\lnot a \land b) \lor a  &amp;\Leftarrow \text{by identity law}\\
= &amp; \lnot \lnot ((\lnot a \land b) \lor a)  &amp;\Leftarrow \text{by double negation law}\\
= &amp; \lnot ( \lnot (\lnot a \land b) \land (\lnot a))  &amp;\Leftarrow \text{by de Morgan&#39;s theorem}\\
= &amp; \lnot (( \lnot \lnot a \lor \lnot b) \land (\lnot a)) &amp;\Leftarrow \text{by de Morgan&#39;s theorem}\\
= &amp; \lnot (( a \lor \lnot b) \land (\lnot a)) &amp;\Leftarrow \text{by double negation law}\\
= &amp; \lnot (( a \land \lnot a) \lor (\lnot b \land \lnot a)) &amp;\Leftarrow \text{by distributive law}\\
= &amp; \lnot (0 \lor (\lnot b \land \lnot a)) &amp;\Leftarrow \text{by compliment law}\\
= &amp; \lnot (\lnot b \land \lnot a) &amp;\Leftarrow \text{by identity law}\\
= &amp; \lnot \lnot b \lor \lnot \lnot a &amp;\Leftarrow \text{by de Morgan&#39;s theorem} \\
= &amp; b \lor a &amp;\Leftarrow \text{by double negation law}\\
\end{array}\]

<p>Picking up from where we left off, then:</p>

\[\begin{array}{llr}
  &amp; (c \land ((\lnot a \land b) \lor (a \land \lnot b) \lor (a \land b)) \lor (a \land b \land \lnot c )\\
= &amp; (c \land (a \lor b)) \lor (a \land b \land \lnot c ) &amp;\Leftarrow \text{by derivation above}\\
= &amp; (c \land a ) \lor (c \land b) \lor (a \land b \land \lnot c ) &amp;\Leftarrow \text{by distributive law}\\
= &amp; a \land (c  \lor (b \land \lnot c) \lor (b \land c ) &amp;\Leftarrow \text{by distributive law}\\
= &amp; a \land (c  \lor b) \lor (b \land c ) &amp;\Leftarrow \text{by redundancy law}\\
\end{array}\]

<p><img src="https://www.datadoodad.com/assets/images/RC10_carry-bit.png" alt="Carry bit logic"/></p>



<p>Put it all together and it looks something like this:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC10_adder-schematic.jpg" alt="Adder Schematic"/></p>

<p>Or, if you’re slightly masochistic and would prefer exclusively <code>NAND</code> gates, like this:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC10_adder-schematic-nand.jpg" alt="Adder Schematic with NAND only"/></p>


<p>Besides working on simplifying these boolean equations, the only other thing I did RC-wise on this Memorial Day was meet with my BYOL groupmates (actually groupmate today because of the holiday) and talked C and parsers. We made great progress contending with a few bugs that turned out to just be quirks of C. Ya live ya learn!</p>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
