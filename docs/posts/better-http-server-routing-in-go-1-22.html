<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2023/better-http-server-routing-in-go-122/">Original</a>
    <h1>Better HTTP server routing in Go 1.22</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>An <a href="https://github.com/golang/go/issues/61410">exciting proposal</a> is
expected to land in Go 1.22 - enhancing the pattern-matching capabilities of
the default HTTP serving multiplexer in the <tt>net/http</tt> package.</p>
<p>The existing multiplexer (<a href="https://pkg.go.dev/net/http#ServeMux">http.ServeMux</a>) offers rudimentary path matching, but
not much beyond that. This led to a cottage industry of 3rd party libraries
to implement more powerful capabilities. I&#39;ve explored these options in my
<em>REST Servers in Go</em> series, in parts <a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-1-standard-library/">1</a>
and <a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-2-using-a-router-package/">2</a>.</p>
<p>The new multiplexer in 1.22 is going to significantly bridge the gap from 3rd
party packages by providing advanced matching. In this short post
I&#39;ll provide a quick introduction to the new multiplexer (mux).
I&#39;ll also revisit the example from the <em>REST Servers in
Go</em> series and compare how the new stdlib mux fares against <tt>gorilla/mux</tt>.</p>
<p><img alt="A cartoony go gopher holding a multiplexer" src="https://eli.thegreenplace.net/images/2023/cartoony-gopher-multiplexer.png"/></p><div id="using-the-new-mux">
<h2>Using the new mux</h2>
<p>If you&#39;ve ever used a 3rd party mux / router package for Go (like
<tt>gorilla/mux</tt>), using the new standard mux is going to be straightforward and
familiar. Start by reading <a href="https://pkg.go.dev/net/http@master#ServeMux">its documentation</a> - it&#39;s short and sweet.</p>
<p>Let&#39;s look at a couple of basic usage examples. Our first example demonstrates
some of the new pattern matching capabilities of the mux:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>(</span><span></span>
<span>  </span><span>&#34;fmt&#34;</span><span></span>
<span>  </span><span>&#34;net/http&#34;</span><span></span>
<span>)</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>mux</span><span> </span><span>:=</span><span> </span><span>http</span><span>.</span><span>NewServeMux</span><span>()</span><span></span>
<span>  </span><span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /path/&#34;</span><span>,</span><span> </span><span>func</span><span>(</span><span>w</span><span> </span><span>http</span><span>.</span><span>ResponseWriter</span><span>,</span><span> </span><span>r</span><span> </span><span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>fmt</span><span>.</span><span>Fprint</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;got path\n&#34;</span><span>)</span><span></span>
<span>  </span><span>})</span><span></span>

<span>  </span><span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/task/{id}/&#34;</span><span>,</span><span> </span><span>func</span><span>(</span><span>w</span><span> </span><span>http</span><span>.</span><span>ResponseWriter</span><span>,</span><span> </span><span>r</span><span> </span><span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>id</span><span> </span><span>:=</span><span> </span><span>r</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;id&#34;</span><span>)</span><span></span>
<span>    </span><span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;handling task with id=%v\n&#34;</span><span>,</span><span> </span><span>id</span><span>)</span><span></span>
<span>  </span><span>})</span><span></span>

<span>  </span><span>http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;localhost:8090&#34;</span><span>,</span><span> </span><span>mux</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Experienced Go programmers will notice two new features right away:</p>
<ol>
<li>In the first handler, the HTTP method (<tt>GET</tt> in this case) is specified
explicitly as part of the pattern. This means that this handler will only
trigger for <tt>GET</tt> requests to paths beginning with <tt>/path/</tt>, not for
other HTTP methods.</li>
<li>In the second handler, there&#39;s a wildcard in the second path component
- <tt>{id}</tt>, something that wasn&#39;t supported before. The wildcard will match
a single path component and the handler can then access the matched value
through the <tt>PathValue</tt> method of the request.</li>
</ol>
<p>Since Go 1.22 hasn&#39;t been released yet, I recommend running this sample with
<tt>gotip</tt>. Please see the <a href="https://github.com/eliben/code-for-blog/tree/master/2023/http-newmux-samples">complete code sample</a>
with full instructions for running this. Let&#39;s take this server for a ride:</p>

<p>And in a separate terminal we can issue some <tt>curl</tt> calls to test it:</p>
<div><pre><span></span>$ curl localhost:8090/what/
<span>404</span> page not found

$ curl localhost:8090/path/
got path

$ curl -X POST localhost:8090/path/
Method Not Allowed

$ curl localhost:8090/task/f0cd2e/
handling task with <span>id</span><span>=</span>f0cd2e
</pre></div>
<p>Note how the server rejects a <tt>POST</tt> request to <tt>/path/</tt>, while the (default
for <tt>curl</tt>) <tt>GET</tt> request is allowed. Note also how the <tt>id</tt> wildcard gets
assigned a value when the request matches. Once again, I encourage you to review
the <a href="https://pkg.go.dev/net/http@master#ServeMux">documentation of the new ServeMux</a>. You&#39;ll learn about additional
capabilities like matching trailing paths to a wildcard with <tt><span>{id}...</span></tt>,
strict matching of a path end with <tt>{$}</tt>, and other rules.</p>
<p>Particular care in the proposal was given to potential conflicts between
different patterns. Consider this setup:</p>
<div><pre><span></span><span>mux</span><span> </span><span>:=</span><span> </span><span>http</span><span>.</span><span>NewServeMux</span><span>()</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/task/{id}/status/&#34;</span><span>,</span><span> </span><span>func</span><span>(</span><span>w</span><span> </span><span>http</span><span>.</span><span>ResponseWriter</span><span>,</span><span> </span><span>r</span><span> </span><span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>id</span><span> </span><span>:=</span><span> </span><span>r</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;id&#34;</span><span>)</span><span></span>
<span>        </span><span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;handling task status with id=%v\n&#34;</span><span>,</span><span> </span><span>id</span><span>)</span><span></span>
<span>})</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/task/0/{action}/&#34;</span><span>,</span><span> </span><span>func</span><span>(</span><span>w</span><span> </span><span>http</span><span>.</span><span>ResponseWriter</span><span>,</span><span> </span><span>r</span><span> </span><span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>action</span><span> </span><span>:=</span><span> </span><span>r</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;action&#34;</span><span>)</span><span></span>
<span>        </span><span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;handling task 0 with action=%v\n&#34;</span><span>,</span><span> </span><span>action</span><span>)</span><span></span>
<span>})</span><span></span>
</pre></div>
<p>And suppose the server receives a request for <tt>/task/0/status/</tt> -- which
handler should it go to? It matches both! Therefore, the new <tt>ServeMux</tt>
documentation meticulously describes the <em>precedence rules</em> for patterns, along
with potential conflicts. In case of a conflict, the registration panics.
Indeed, for the example above we get something like:</p>
<div><pre><span></span>panic: pattern &#34;/task/0/{action}/&#34; (registered at sample-conflict.go:14) conflicts with pattern &#34;/task/{id}/status/&#34; (registered at sample-conflict.go:10):
/task/0/{action}/ and /task/{id}/status/ both match some paths, like &#34;/task/0/status/&#34;.
But neither is more specific than the other.
/task/0/{action}/ matches &#34;/task/0/action/&#34;, but /task/{id}/status/ doesn&#39;t.
/task/{id}/status/ matches &#34;/task/id/status/&#34;, but /task/0/{action}/ doesn&#39;t.
</pre></div>
<p>The message is detailed and helpful. If we encounter conflicts in complex
registration schemes (especially when patterns are registered in multiple places
in the source code), such details will be much appreciated.</p>
</div>
<div id="redoing-my-task-server-with-the-new-mux">
<h2>Redoing my task server with the new mux</h2>
<p>The <em>REST Servers in Go</em> series implements a simple server for a task/todo-list
application in Go, using several different approaches. <a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-1-standard-library/">Part 1</a>
starts with a &#34;vanilla&#34; standard library approach, and <a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-2-using-a-router-package/">Part 2</a>
reimplements the same server using the <a href="https://github.com/gorilla/mux">gorilla/mux</a> router.</p>
<p>Now is a great time to reimplement it once again, but with the enhanced mux
from Go 1.22; it will be particularly interesting to compare the solution to
the one using <tt>gorilla/mux</tt>.</p>
<p>The full code for this project is <a href="https://github.com/eliben/code-for-blog/tree/master/2021/go-rest-servers/stdlib-newmux">available here</a>.
Let&#39;s look at a few representative code samples, starting with the pattern
registration <a href="#footnote-1" id="footnote-reference-1">[1]</a>:</p>
<div><pre><span></span><span>mux</span><span> </span><span>:=</span><span> </span><span>http</span><span>.</span><span>NewServeMux</span><span>()</span><span></span>
<span>server</span><span> </span><span>:=</span><span> </span><span>NewTaskServer</span><span>()</span><span></span>

<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;POST /task/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>createTaskHandler</span><span>)</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /task/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>getAllTasksHandler</span><span>)</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;DELETE /task/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>deleteAllTasksHandler</span><span>)</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /task/{id}/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>getTaskHandler</span><span>)</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;DELETE /task/{id}/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>deleteTaskHandler</span><span>)</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /tag/{tag}/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>tagHandler</span><span>)</span><span></span>
<span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;GET /due/{year}/{month}/{day}/&#34;</span><span>,</span><span> </span><span>server</span><span>.</span><span>dueHandler</span><span>)</span><span></span>
</pre></div>
<p>Just like in the <tt>gorilla/mux</tt> sample, here we use specific HTTP methods
to route requests (with the same path) to different handlers; with the older
<tt>http.ServeMux</tt>, such matchers had to go to the same handler, which would then
decide what to do based on the method.</p>
<p>Let&#39;s also look at one of the handlers:</p>
<div><pre><span></span><span>func</span><span> </span><span>(</span><span>ts</span><span> </span><span>*</span><span>taskServer</span><span>)</span><span> </span><span>getTaskHandler</span><span>(</span><span>w</span><span> </span><span>http</span><span>.</span><span>ResponseWriter</span><span>,</span><span> </span><span>req</span><span> </span><span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;handling get task at %s\n&#34;</span><span>,</span><span> </span><span>req</span><span>.</span><span>URL</span><span>.</span><span>Path</span><span>)</span><span></span>

<span>  </span><span>id</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>strconv</span><span>.</span><span>Atoi</span><span>(</span><span>req</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;id&#34;</span><span>))</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>http</span><span>.</span><span>Error</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;invalid id&#34;</span><span>,</span><span> </span><span>http</span><span>.</span><span>StatusBadRequest</span><span>)</span><span></span>
<span>    </span><span>return</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>task</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>ts</span><span>.</span><span>store</span><span>.</span><span>GetTask</span><span>(</span><span>id</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>http</span><span>.</span><span>Error</span><span>(</span><span>w</span><span>,</span><span> </span><span>err</span><span>.</span><span>Error</span><span>(),</span><span> </span><span>http</span><span>.</span><span>StatusNotFound</span><span>)</span><span></span>
<span>    </span><span>return</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>renderJSON</span><span>(</span><span>w</span><span>,</span><span> </span><span>task</span><span>)</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>It extracts the ID value from <tt><span>req.PathValue(&#34;id&#34;)</span></tt>, similarly to the Gorilla
approach; however, since we don&#39;t have a regexp specifying that <tt>{id}</tt> only
matches integers, we have to pay attention to errors returned from
<tt>strconv.Atoi</tt>.</p>
<p>All and all, the end result is remarkably similar to the solution that uses
<tt>gorilla/mux</tt> from <a href="https://eli.thegreenplace.net/2021/rest-servers-in-go-part-2-using-a-router-package/">part 2</a>.
The handlers are much better separated than in the vanilla stdlib approach,
because the mux now can do much more sophisticated routing, without leaving many
of the routing decisions to the handlers themselves.</p>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>&#34;Which router package should I use?&#34; has always been a FAQ for beginner Go
programmers. I believe the common answers to this question will shift after
Go 1.22 is released, as many will find the new stdlib mux sufficient for their
needs without resorting to 3rd party packages.</p>
<p>Others will stick to familiar 3rd party packages, and that&#39;s totally fine.
Routers like <tt>gorilla/mux</tt> still provide more capabilities than the standard
library; on top of it, many Go programmers opt for lightweight frameworks like
Gin, which provide a router but also additional tools for building web backends.</p>
<p>All in all, this is certainly a positive change for all Go users. Making the
standard library more capable is a net positive for the entire community,
whether people use 3rd party packages or stick to just the standard library.</p>
<hr/>

</div>

            </div></div>
  </body>
</html>
