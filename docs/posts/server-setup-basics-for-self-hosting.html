<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://becomesovran.com/blog/server-setup-basics.html">Original</a>
    <h1>Server Setup Basics for Self Hosting</h1>
    
    <div id="readability-page-1" class="page"><div>
              <p>This is a post I&#39;ve been meaning to do for a while. While it&#39;s simple to
                explain how to set up an app for self-hosting, it&#39;s pointless to host an app on a weak foundation.
                It&#39;s a massive pain in my ass to start every how to with a section on server setup, so I&#39;m
                also making this post for myself as a reference on how I like to set up a server for apps I&#39;m
                hosting. I&#39;ll start with basic stuff like proper login with SSH and non-root user set up and making
                users for each app. I&#39;ll also touch on NGINX setup, some quality of life tools that make server
                management easier, log management and basic network security.</p>
              <ul role="list">
                <li>
                  <a href="#ssh">SSH</a>
                </li>
                <li>
                  <a href="#users">Users</a>
                </li>
                <li>
                  <a href="#logs">Logs</a>
                </li>
                <li>
                  <a href="#backups">Backups</a>
                </li>
                <li>
                  <a href="#network">Basic Network Safety</a>
                </li>
                <li>
                  <a href="#nginx">NGINX</a>
                </li>
                <li>
                  <a href="#qol">Quality of Life Tools</a>
                </li>
                <li>
                  <a href="#dns">DNS</a>
                </li>
                <li>
                  <a href="#docker">Docker</a>
                </li>
              </ul>
              <h2 id="ssh"></h2>
              <p>First is login. You’ll need a way to access your device securely. Don&#39;t even
                mess with username and password. You want to use SSH (Secure Shell) and make sure that SSH is the only
                way to log in. To do that, you’ll need an SSH key and a new user account. On a newly provisioned VPS,
                you&#39;ll be logged in as root, and you want to protect the root account. First off on the VPS or
                remote machine make a new regular user with and add them to the “sudo” group with:</p>
              <pre contenteditable="false"><code><span>sudo adduser newuser
</span>
sudo usermod -aG sudo newuser</code></pre>
              
              <pre contenteditable="false"><code><span>ssh-keygen -t ed25519 -C </span><span>&#34;your_email@example.com&#34;</span></code></pre>
              
              <pre contenteditable="false"><code><span>ssh-copy-id -i ~/.ssh/id_ed25519.pub newuser@your_server_ip</span></code></pre>
              
              <pre contenteditable="false"><code><span>sudo nano /etc/ssh/sshd_config</span></code></pre>
              
              <pre contenteditable="false"><code><span>Port 2222     </span><span># Change default port (use a number between 1024 and 65535)</span><span>
</span><span>PermitRootLogin no                 </span><span># Disable root login</span><span>
</span><span>PasswordAuthentication no          </span><span># Disable password authentication</span><span>
</span><span>PubkeyAuthentication yes           </span><span># Enable public key authentication</span><span>
</span><span>AuthorizedKeysFile .ssh/authorized_keys </span><span># Specify authorized_keys file location</span><span>
</span><span>AllowUsers newuser                 </span><span># Only allow specific users to login</span></code></pre>
              
              <pre contenteditable="false"><code><span>sudo service ssh restart</span></code></pre>
              
              <pre contenteditable="false"><code><span>Protocol 2                 </span><span># Use only SSH protocol version 2</span><span>
</span><span>MaxAuthTries 3             </span><span># Limit authentication attempts</span><span>
</span><span>ClientAliveInterval 300    </span><span># Client alive interval in seconds</span><span>
</span><span>ClientAliveCountMax 2      </span><span># Maximum client alive count</span></code></pre>
              
              <h2 id="users"></h2>
              
              <pre contenteditable="false"><code><span>sudo useradd -rms /usr/sbin/nologin -c </span><span>&#34;a comment&#34;</span><span> youruser</span></code></pre>
              
              <pre contenteditable="false"><code><span>sudo mkdir /opt/myapp</span></code></pre>
              
              <pre contenteditable="false"><code><span>sudo chown appuser:appuser /opt/myapp</span></code></pre>
              
              <h2 id="logs"><strong></strong></h2>
              
              <pre contenteditable="false"><code><span>/var/</span><span>log</span><span>/nginx/*.</span><span>log</span><span> {
</span>    weekly
    missingok
    rotate 52
    compress
    delaycompress
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
<span>        [ -f /var/run/nginx.pid ] &amp;&amp; </span><span>kill</span><span> -USR1 `cat /var/run/nginx.pid`
</span>    endscript
}
</code></pre>
              
              <pre contenteditable="false"><code><span>sudo logrotate -d /etc/logrotate.conf</span></code></pre>
              
              <h2 id="backups"><strong></strong></h2>
              


              <h2 id="network"><strong></strong></h2>
              
              <pre contenteditable="false"><code><span>sudo apt install ufw
</span>
sudo apt install fail2ban</code></pre>
              <h3 id="ufw"><strong></strong></h3>
              
              <pre contenteditable="false"><code><span>sudo ufw default deny incoming
</span> 
sudo ufw allow outgoing</code></pre>
              
              <pre contenteditable="false"><code><span>sudo ufw allow ssh
</span>sudo ufw allow 80
sudo ufw allow 443</code></pre>
              
              <pre contenteditable="false"><code><span>#List rules with numbers:</span><span>
</span>sudo ufw status numbered
<span></span><span>#Delete by number:</span><span>
</span>sudo ufw delete NUMBER
<span></span><span>#Delete by rule specification:</span><span>
</span>sudo ufw delete allow 80
<span></span><span>#You can allow connections from specific IP addresses:</span><span>
</span>sudo ufw allow from 192.168.1.100
<span></span><span>#You can also only allow an IP to connect to a specfic port with: </span><span>
</span>sudo ufw allow from 192.168.1.100 to any port 22
<span></span><span>#If you neeed to allow a range of ports: </span><span>
</span>sudo ufw allow 6000:6007/tcp
<span></span><span>#To further protect from brut force attacks you can rate limit specific ports with: </span><span>
</span><span>sudo ufw </span><span>limit</span><span> ssh
</span><span></span><span>#This would limit port 22 to 6 connections in 30 seconds from a single IP. To see the status of the firewall you can use: </span><span>
</span>
<span></span><span>#Adding this goves you more info</span><span>
</span>sudo ufw status verbose
<span></span><span>#and to reset incase you need to start over: </span><span>
</span>sudo ufw reset
<span></span><span>#and to enable and disable: </span><span>
</span><span>sudo ufw </span><span>enable</span><span> 
</span><span>sudo ufw </span><span>disable</span><span> 
</span>
<span></span><span>#finaly to enable logging and adjusting the log level: </span><span>
</span>sudo ufw logging on
<span>sudo ufw logging medium </span><span># levels are low, medium, high, full </span><span>
</span></code></pre>
              
              <h3 id="ban"><strong></strong></h3>
              <p>‍</p>
              <pre contenteditable="false"><code><span>sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
</span>
sudo nano /etc/fail2ban/jail.local</code></pre>
              <p>‍</p>
              <pre contenteditable="false"><code><span>bantime = 10m
</span>findtime = 10m
maxretry = 5</code></pre>
              <p>‍</p>
              <h3 id="nginx"><strong></strong></h3>
              
              <pre contenteditable="false"><code><span>ln -s /etc/nginx/sites-available/yoursitefile /etc/nginx/sites-enabled</span></code></pre>
              
              <pre contenteditable="false"><code><span>sudo systemctl reload nginx
</span>
sudo systemctl status nginx</code></pre>
              
              
              <pre contenteditable="false"><code><span>server {
</span>    listen 80;
    listen [::]:80;
    server_name example.com www.example.com;
    root /var/www/example.com/html;
    index index.html index.htm;
    location / {
<span>        try_files </span><span>$uri</span><span> </span><span>$uri</span><span>/ =404;
</span>    }
<span>    </span><span># Security headers</span><span>
</span><span>    add_header X-Frame-Options </span><span>&#34;SAMEORIGIN&#34;</span><span> always;
</span><span>    add_header X-XSS-Protection </span><span>&#34;1; mode=block&#34;</span><span> always;
</span><span>    add_header X-Content-Type-Options </span><span>&#34;nosniff&#34;</span><span> always;
</span><span>    add_header Referrer-Policy </span><span>&#34;no-referrer-when-downgrade&#34;</span><span> always;
</span><span>    add_header Content-Security-Policy </span><span>&#34;default-src &#39;self&#39; http: https: data: blob: &#39;unsafe-inline&#39;&#34;</span><span> always;
</span>
<span>    </span><span># Logging</span><span>
</span><span>    access_log /var/</span><span>log</span><span>/nginx/example.com.access.log;
</span><span>    error_log /var/</span><span>log</span><span>/nginx/example.com.error.log warn;
</span>
<span>    </span><span># SSL configuration (uncomment after running Certbot)</span><span>
</span><span>    </span><span># listen 443 ssl http2;</span><span>
</span><span>    </span><span># listen [::]:443 ssl http2;</span><span>
</span><span>    </span><span># ssl_protocols TLSv1.2 TLSv1.3;</span><span>
</span><span>    </span><span># ssl_prefer_server_ciphers on;</span><span>
</span><span>    </span><span># ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span><span>
</span>
<span>    </span><span># Certbot will add its own SSL certificate paths</span><span>
</span><span>    </span><span># ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span><span>
</span><span>    </span><span># ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><span>
</span>}</code></pre>
              
              <pre contenteditable="false"><code><span>server {
</span>    listen 80;
    listen [::]:80;
    server_name app.example.com;
    location / {
        proxy_pass http://localhost:3000;
<span>        proxy_set_header Host </span><span>$host</span><span>;
</span><span>        proxy_set_header X-Real-IP </span><span>$remote_addr</span><span>;
</span><span>        proxy_set_header X-Forwarded-For </span><span>$proxy_add_x_forwarded_for</span><span>;
</span><span>        proxy_set_header X-Forwarded-Proto </span><span>$scheme</span><span>;
</span>    }
<span>    </span><span># Security headers</span><span>
</span><span>    add_header X-Frame-Options </span><span>&#34;SAMEORIGIN&#34;</span><span> always;
</span><span>    add_header X-XSS-Protection </span><span>&#34;1; mode=block&#34;</span><span> always;
</span><span>    add_header X-Content-Type-Options </span><span>&#34;nosniff&#34;</span><span> always;
</span><span>    add_header Referrer-Policy </span><span>&#34;no-referrer-when-downgrade&#34;</span><span> always;
</span><span>    add_header Content-Security-Policy </span><span>&#34;default-src &#39;self&#39; http: https: data: blob: &#39;unsafe-inline&#39;&#34;</span><span> always;
</span>
<span>    </span><span># Logging</span><span>
</span><span>    access_log /var/</span><span>log</span><span>/nginx/app.example.com.access.log;
</span><span>    error_log /var/</span><span>log</span><span>/nginx/app.example.com.error.log warn;
</span>
<span>    </span><span># SSL configuration (uncomment after running Certbot)</span><span>
</span><span>    </span><span># listen 443 ssl http2;</span><span>
</span><span>    </span><span># listen [::]:443 ssl http2;</span><span>
</span><span>    </span><span># ssl_protocols TLSv1.2 TLSv1.3;</span><span>
</span><span>    </span><span># ssl_prefer_server_ciphers on;</span><span>
</span><span>    </span><span># ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span><span>
</span>
<span>    </span><span># Certbot will add its own SSL certificate paths</span><span>
</span><span>    </span><span># ssl_certificate /etc/letsencrypt/live/app.example.com/fullchain.pem;</span><span>
</span><span>    </span><span># ssl_certificate_key /etc/letsencrypt/live/app.example.com/privkey.pem;</span><span>
</span>}</code></pre>
              
              <pre contenteditable="false"><code><span>server {
</span>    listen 80;
    listen [::]:80;
    server_name ws.example.com;
    location / {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
<span>        proxy_set_header Upgrade </span><span>$http_upgrade</span><span>;
</span><span>        proxy_set_header Connection </span><span>&#34;upgrade&#34;</span><span>;
</span><span>        proxy_set_header Host </span><span>$host</span><span>;
</span><span>        proxy_set_header X-Real-IP </span><span>$remote_addr</span><span>;
</span><span>        proxy_set_header X-Forwarded-For </span><span>$proxy_add_x_forwarded_for</span><span>;
</span><span>        proxy_set_header X-Forwarded-Proto </span><span>$scheme</span><span>;
</span>    }
<span>    </span><span># Security headers</span><span>
</span><span>    add_header X-Frame-Options </span><span>&#34;SAMEORIGIN&#34;</span><span> always;
</span><span>    add_header X-XSS-Protection </span><span>&#34;1; mode=block&#34;</span><span> always;
</span><span>    add_header X-Content-Type-Options </span><span>&#34;nosniff&#34;</span><span> always;
</span><span>    add_header Referrer-Policy </span><span>&#34;no-referrer-when-downgrade&#34;</span><span> always;
</span><span>    add_header Content-Security-Policy </span><span>&#34;default-src &#39;self&#39; http: https: data: blob: &#39;unsafe-inline&#39;&#34;</span><span> always;
</span>
<span>    </span><span># WebSocket timeout settings</span><span>
</span>    proxy_read_timeout 300s;
    proxy_send_timeout 300s;
<span>    </span><span># Logging</span><span>
</span><span>    access_log /var/</span><span>log</span><span>/nginx/ws.example.com.access.log;
</span><span>    error_log /var/</span><span>log</span><span>/nginx/ws.example.com.error.log warn;
</span>
<span>    </span><span># SSL configuration (uncomment after running Certbot)</span><span>
</span><span>    </span><span># listen 443 ssl http2;</span><span>
</span><span>    </span><span># listen [::]:443 ssl http2;</span><span>
</span><span>    </span><span># ssl_protocols TLSv1.2 TLSv1.3;</span><span>
</span><span>    </span><span># ssl_prefer_server_ciphers on;</span><span>
</span><span>    </span><span># ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span><span>
</span>
<span>    </span><span># Certbot will add its own SSL certificate paths</span><span>
</span><span>    </span><span># ssl_certificate /etc/letsencrypt/live/ws.example.com/fullchain.pem;</span><span>
</span><span>    </span><span># ssl_certificate_key /etc/letsencrypt/live/ws.example.com/privkey.pem;</span><span>
</span>}</code></pre>
              
              <pre contenteditable="false"><code><span>sudo apt install certbot python3-certbot-nginx</span></code></pre>
              
              <pre contenteditable="false"><code><span>sudo systemctl status certbot.timer</span></code></pre>
              
              <h2 id="qol"><strong></strong></h2>
              <p>On the topic of tools that make managing your system easier, I&#39;m
                going to present some tools I use on my servers that I think make management just a bit nicer. Not going
                to do a deep dive on any tool. All of these are optional and in no particular order. A lot of these I
                found on the site <a href="https://terminaltrove.com" target="_blank">terminal trove</a>, a great site
                to browse if you&#39;re a terminal junkie like me. </p>
              <h2 id="dns"><strong></strong></h2>
              <p>DNS or The Domain Name System is a core part of how the internet as we
                know it works. Love it or hate it, it&#39;s what we have to work with If you want to be accessible to
                the wider internet. (I dislike what it currently is it, but I’m not opening that can of worms here.)
                Basically, Think of DNS like a phone book. It’s what allows you to type duckduckgo.com instead of
                “52.250.42.157” every time you need to search the internet. It translates something easy for humans to
                remember into the information needed by computers to actually reach “duckduckgo.com”</p>
              <h2 id="docker"><strong></strong></h2>
              <p>I&#39;m not gonna cover how to install docker here. It&#39;s best to
                follow <a href="https://docs.docker.com/engine/install/debian/" target="_blank">the official
                  installation</a> guide anyway. But I want to touch on a few things. First off, docker is useful as
                hell for testing new apps. But that&#39;s about as far as I take it. I personally do not like using
                docker all that much, and where possible run applications directly. Here are some pros and cons to keep
                in mind.<br/></p>
              <h3><strong>Docker Pros</strong></h3>
              <p>Consistency is a big one it can make things more constant between
                development, testing, and deploying if your system can run docker you can run most docker apps. It can
                help with isolation, reducing conflicts between apps. In some cases it can help with efficiency as it
                takes less resources than traditional VM’s. It can help with scaling as it&#39;s pretty easy to spin up
                more containers and the microservice architecture can be useful because you can break down an
                application into smaller manageable services, allowing for independent scaling of said services. Lastly
                the community is large, so the documentation is good, and community support is always helpful, plus
                there is a wide range of ready to go docker images for deployment.<br/></p>
              <h3><strong>Docker Cons</strong></h3>
              <p>I’ll start with overhead. While it&#39;s better than a traditional VM,
                it uses more resources than running something directly on the host, and I/O operations can be slower.
                The fact that docker shares the system&#39;s kernel means that a compromised app could affect the
                system. Persistent data is doable but adds a layer of complexity that can cause data loss with new
                users, it also makes backups more complex. Networking can also be more complex with docker, making it
                not as straightforward. It&#39;s also good to note that if you use UFW or firewalld for a firewall,
                docker bypasses those rules. Docker is only compatible with iptables. Also, while a well managed docker
                container can help manage server resources, an improperly manged on can be detrimental to resources as
                well. Containers can get too large, effecting disk size, and misconfiguration can use too many of your
                servers resources. It also adds extra layers of complexity when monitoring and debugging applications,
                especially across multiple containers.</p>
              <h2><strong></strong></h2>
              <p>Well, that about does it for the basics of server setup and tools. There
                is a <a href="https://git.sovbit.dev/Enki/sovran-scripts" target="_blank"> a script that I wrote</a> that will do most of this for you. I wrote it to make my own server setup faster.
                You can get that here, it includes all of my must-haves and does some basic configuration. Tweak it to
                your own needs, and as always stay safe out there and ping me on nostr or simplex if you have questions
                or if I fucked something up in this post.<br/></p>
              
              
            </div></div>
  </body>
</html>
