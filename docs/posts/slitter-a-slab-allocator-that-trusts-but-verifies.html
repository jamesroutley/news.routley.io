<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pvk.ca/Blog/2021/08/01/slitter-a-less-footgunny-slab-allocator/">Original</a>
    <h1>Slitter: A slab allocator that trusts, but verifies</h1>
    
    <div id="readability-page-1" class="page"><div><p><small>Originally posted on the <a href="https://engineering.backtrace.io/2021-08-04-slitter-a-slab-allocator-that-trusts-but-verifies/">Backtrace I/O tech blog</a>.</small></p>
<p><a href="https://github.com/backtrace-labs/slitter">Slitter</a> is Backtrace’s
deliberately middle-of-the-road
<a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix01/full_papers/bonwick/bonwick.pdf">thread-caching</a>
<a href="https://people.eecs.berkeley.edu/~kubitron/courses/cs194-24-S13/hand-outs/bonwick_slab.pdf">slab allocator</a>,
with <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/include/slitter.h#L7-L44">explicit allocation class tags</a>
(rather than derived from the object’s size class).
It’s mostly written in Rust, and we use it in our C backend server.</p>
<p><a href="https://crates.io/crates/slitter">Slitter</a>’s design is about as
standard as it gets: we hope to dedicate the project’s complexity
budget to always-on “observability” and safety features. We don’t
wish to detect all or even most memory management errors, but we
should statistically catch a small fraction (enough to help pinpoint
production issues) of such bugs, and <em>always</em> constrain their scope to
the mismanaged allocation class.<sup id="fnref:blast-radius" role="doc-noteref"><a href="#fn:blast-radius" rel="footnote">1</a></sup></p>
<p>We decided to code up Slitter last April, when we noticed
that we would immediately benefit from backing allocation with
temporary file mappings:<sup id="fnref:when-does-it-flush" role="doc-noteref"><a href="#fn:when-does-it-flush" rel="footnote">2</a></sup>
the bulk of our data is mapped from
persistent data files, but we also regenerate some cold metadata
during startup, and accesses to that metadata have amazing locality,
both temporal and spatial (assuming bump allocation). We don’t want the OS
to swap out all the heap–that way lie <a href="https://blog.acolyer.org/2017/06/15/gray-failure-the-achilles-heel-of-cloud-scale-systems/">grey failures</a>–so
we opt specific allocation classes into it.</p>
<p>By itself, this isn’t a reason to write a slab allocator: we could
easily have configured <a href="http://jemalloc.net/jemalloc.3.html#arena.i.extent_hooks">specialised arenas in jemalloc</a>,
for example. However, we also had eyes on longer term improvements to
observability and debugging or mitigation of memory management errors in
production, and those could only be unlocked by migrating to an
interface with explicit tags for each allocation class (type).</p>
<p>Classic mallocs like <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>
and <a href="https://github.com/google/tcmalloc">tcmalloc</a> are fundamentally
unable to match that level of integration: we can’t tell <code>malloc(3)</code>
what we’re trying to allocate (e.g., a <code>struct request</code> in the HTTP
module), only its size. It’s still possible to wrap malloc in a richer
interface, and, e.g., track heap consumption by tag. Unfortunately,
the result is slower than a native solution, and, without help from
the underlying allocator, it’s easy to incorrectly match tags between
<code>malloc</code> and <code>free</code> calls. In my experience, this frequently leads to
useless allocation statistics, usually around the very faulty code
paths one is attempting to debug.</p>
<p>Even once we have built detailed statistics on top of a regular
malloc, it’s hard to convince the underlying allocator to only recycle
allocations within an object class: not only do mallocs eagerly
recycle allocations of similar sizes regardless of their type, but
they will also release unused runs of address space, or repurpose them
for totally different size classes. That’s what mallocs are supposed
to do… it just happens to also make debugging a lot harder when
things inevitably go wrong.<sup id="fnref:ub" role="doc-noteref"><a href="#fn:ub" rel="footnote">3</a></sup></p>
<p>Slab allocators work with semantically richer allocation tags: an
allocation tag describes its objects’ size, but can also specify how
to initialise, recycle, or deinitialise them. The problem is that
slab allocators tend to focus exclusively on speed.</p>
<p><a href="https://github.com/omniti-labs/portableumem">Forks of libumem</a>
may be the exception, thanks to the Solaris culture of pervasive
hooking. However, <code>umem</code>’s design reflects the sensibilities of the
00s, when it was written: threads share a few caches, and the
allocator tries to reuse address space. In contrast, Slitter assumes memory
is plentiful enough for thread-local caches and type-stable
allocations.<sup id="fnref:not-as-configurable" role="doc-noteref"><a href="#fn:not-as-configurable" rel="footnote">4</a></sup></p>
<h2 id="our-experience-so-far">Our experience so far</h2>
<p>We have been running <a href="https://crates.io/crates/slitter">Slitter</a> in
production for over two months, and rely on it to:</p>
<ul>
<li>detect when an allocation is freed with the wrong allocation class
tag (i.e., detect type confusion on free).</li>
<li>avoid any in-band metadata: there are guard pages between
allocations and allocator metadata, and no intrusive freelist for
use-after-frees to stomp over.</li>
<li>guarantee <a href="https://www.usenix.org/legacy/publications/library/proceedings/osdi96/full_papers/greenwald/node2.html">type stable allocations</a>:
once an address has been used to fulfill a request for a certain
allocation class, it will only be used for that class. Slitter
doesn’t overlay intrusive lists on top of freed allocations, so the
data always reflects what the application last stored there. This
means that double-frees and use-after-frees only affect the faulty
allocation class. An application could even rely on
read-after-free being benign to simplify non-blocking algorithms.<sup id="fnref:but-we-dont-depend-on-it-too-much" role="doc-noteref"><a href="#fn:but-we-dont-depend-on-it-too-much" rel="footnote">5</a></sup></li>
<li>let each allocation class specify how its backing memory should
be mapped in (e.g., plain 4 KB pages or file-backed swappable pages).</li>
</ul>
<p>Thanks to extensive contracts and a mix of hardcoded and random tests,
we encountered only two issues during the initial rollout, both in the
small amount of lock-free C code that is hard to test.<sup id="fnref:legacy-gcc" role="doc-noteref"><a href="#fn:legacy-gcc" rel="footnote">6</a></sup></p>
<p>Type stability exerts a heavy influence all over Slitter’s design, and
has obvious downsides. For example, a short-lived application that
progresses through a pipeline of stages, where each stage allocates
different types, would definitely waste memory if it were to replace a
regular malloc with a type-stable allocator like Slitter. We believe
the isolation benefits are more than worth the trouble, at least for
long-lived servers that quickly enter a steady state.</p>
<p>In the future, we hope to also:</p>
<ul>
<li>detect when an interior pointer is freed.</li>
<li>detect simple<sup id="fnref:jump" role="doc-noteref"><a href="#fn:jump" rel="footnote">7</a></sup> buffer overflows that cross allocation classes, by inserting guard pages.</li>
<li>always detect frees of addresses Slitter does not manage.</li>
<li>detect most back-to-back double-frees.</li>
<li>detect a random fraction of buffer overflows, with a sampling <a href="https://en.wikipedia.org/wiki/Electric_Fence">eFence</a>.</li>
</ul>
<p>In addition to these safety features, we plan to rely on the allocator
to improve observability into the calling program, and wish to:</p>
<ul>
<li>track the number of objects allocated and recycled in each
allocation class.</li>
<li>sample the call stack when the heap grows.</li>
<li>track allocation and release call stacks for a small fraction of objects.</li>
</ul>
<p>Here’s how it currently works, and why we wrote it in Rust, with dash
of C.</p>
<h2 id="the-high-level-design-of-slitter">The high level design of Slitter</h2>
<p>At a <a href="https://github.com/backtrace-labs/slitter/blob/fa8629989cb63ca5a4acdc2d26741bccda79aac0/doc/design.md">high level</a>,
Slitter</p>
<ol>
<li>reserves shared 1 GB <code>Chunk</code>s of memory via the <a href="https://github.com/backtrace-labs/slitter/blob/fa8629989cb63ca5a4acdc2d26741bccda79aac0/src/mapper.rs"><code>Mapper</code> trait</a></li>
<li>carves out smaller type-specific <code>Span</code>s from each chunk with <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/mill.rs"><code>Mill</code> objects</a></li>
<li>bump-allocates objects from <code>Span</code>s with <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/press.rs"><code>Press</code> objects</a>, into <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/magazine.rs">allocation <code>Magazines</code></a></li>
<li>pushes and pops objects into/from <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/c/cache.c">thread-local magazines</a></li>
<li>caches populated magazines in global <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/class.rs#L62-L67">type-specific lock-free stacks</a></li>
<li>manages empty magazines with a global <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/rack.rs">mostly lock-free <code>Rack</code></a></li>
</ol>
<p>Many general purpose memory allocators implement strategies similarly
inspired by <a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix01/full_papers/bonwick/bonwick.pdf">Bonwick’s slab allocator</a>,
and time-tested mallocs may well provide better performance
and lower fragmentation than Slitter.<sup id="fnref:type-stable" role="doc-noteref"><a href="#fn:type-stable" rel="footnote">8</a></sup>
The primary motivation for designing Slitter is that having explicit
allocation classes in the API makes it easier for the allocator to
improve the debuggability and resilience of the calling program.<sup id="fnref:also-good-for-perf" role="doc-noteref"><a href="#fn:also-good-for-perf" rel="footnote">9</a></sup>
For example, most allocators can tell you the size of your program’s
heap, but that data is much more useful when broken down by struct
type or program module.</p>
<p>Most allocators try to minimise accesses to the metadata associated with
allocations. In fact, that’s often seen as a strength of the slab
interface: the allocator can just rely on the caller to pass the
correct allocation class tag, instead of hitting metadata to figure
out there the freed address should go.</p>
<p>We went in the opposite direction with Slitter. We still rely on the
allocation class tag for speed, but also actively look for mismatches
before returning from deallocation calls. Nothing depends on
values computed by the mismatch detection logic, and the resulting
branch is trivially predictable (the tag always matches), so we can
hope that wide out-of-order CPUs will hide most of the checking
code, if it’s simple enough.</p>
<p>This concern (access to metadata in few instructions) combined with
our goal of avoiding in-band metadata lead to a
<a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/mill.rs#L6-L19">simple layout for each chunk’s data and metadata</a>.</p>
<pre><code>.-------.------.-------|---------------.-------.
| guard | meta | guard | data ... data | guard |
&#39;-------&#39;------&#39;-------|---------------&#39;-------&#39;
  2 MB    2 MB   2 MB  |      1 GB        2 MB
                       v
               Aligned to 1 GB
</code></pre>
<p>A chunk’s data is always a 1 GB address range, aligned to 1 GB: the
underlying mapper doesn’t have to immediately back that with memory,
but it certainly can, e.g., in order to use gigantic pages. The chunk
is preceded and followed by 2 MB guard pages. The metadata for the
chunk’s data lives in a 2 MB range, just before the preceding guard
page (i.e., 4 MB to 2 MB before the beginning of the aligned 1 GB
range). Finally, the 2 MB metadata range is itself preceded by a 2MB
guard page.</p>
<p>Each chunk is statically divided in 65536 spans of 16 KB each. We can
thus map a span to its slot in the metadata block with a shifts,
masks, and some address arithmetic. <a href="https://github.com/backtrace-labs/slitter/blob/7afb9781fd25b8cee62afa555b9d38f391131044/src/mill.rs">Mill</a>s
don’t have to hand out individual 16 KB spans at a time, they simply
have to work in multiples of 16 KB, and never split a span in two.</p>
<h2 id="why-we-wrote-slitter-in-rust-and-c">Why we wrote Slitter in Rust and C</h2>
<p>We call Slitter from C, but wrote it in Rust, despite the
more painful build<sup id="fnref:uber-crate" role="doc-noteref"><a href="#fn:uber-crate" rel="footnote">10</a></sup> process: that pain isn’t going
anywhere, since we expect our backend to be in a mix of C, C++, and
Rust for a long time. We also sprinkled in some C when the
alternative would have been to pull in a crate just to make a couple
syscalls, or to enable unstable Rust features: we’re not
“rewrite-it-in-Rust” absolutists, and merely wish to use Rust for its
strengths (control over data layout, support for domain-specific
invariants, large ecosystem for less performance-sensitive logic, ability to
lie to the compiler where necessary, …), while avoiding its
weaknesses (interacting with Linux interfaces defined by C headers, or
fine-tuning code generation).</p>
<p>The majority of allocations only interact with the thread-local
magazines. That’s why we <a href="https://github.com/backtrace-labs/slitter/blob/main/c/cache.c">wrote that code in C</a>:
stable Rust doesn’t (yet) let us access <a href="https://doc.rust-lang.org/std/intrinsics/fn.likely.html">likely/unlikely annotations</a>,
nor <a href="https://www.akkadia.org/drepper/tls.pdf#page=35">fast “initial-exec”</a> <a href="https://github.com/rust-lang/rust/issues/29594">thread-local storage</a>.
Of course, allocation and deallocation are the main entry points into
a memory allocation library, so this creates a bit of friction with
Rust’s linking process.<sup id="fnref:bad-linker" role="doc-noteref"><a href="#fn:bad-linker" rel="footnote">11</a></sup></p>
<p>We also had to implement our <a href="https://github.com/backtrace-labs/slitter/blob/main/c/stack.c">lock-free multi-popper Treiber stack</a>
in C: x86-64 doesn’t have anything like LL/SC, so we instead pair
the top-of-stack pointer with a generation counter… and
<a href="https://github.com/rust-lang/rust/issues/32976#issuecomment-641360955">Rust hasn’t stabilised 128-bit atomics</a> yet.</p>
<p>We chose to use atomics in C instead of a simple lock in Rust because
the lock-free stack (and the atomic bump pointer, which Rust handles
fine) are important for our use case: when we rehydrate cold metadata
at startup, we do so from multiple I/O-bound threads, and we have
observed hiccups due to lock contention in malloc. At some point,
lock acquisitions are rare enough that contention isn’t an issue;
that’s why we’re comfortable with locks when refilling bump allocation
regions.</p>
<h2 id="come-waste-performance-on-safety">Come waste performance on safety!</h2>
<p>A recurring theme in the design of <a href="https://github.com/backtrace-labs/slitter">Slitter</a>
is that we find ways to make the core (de)allocation logic slightly
faster, and immediately spend that efficiency on safety, debuggability
or, eventually, observability. For a lot of code, performance is a
constraint to satisfy, not a goal to maximise; once we’re close to
good enough, it makes sense to trade performance
away.<sup id="fnref:even-works-for-perf" role="doc-noteref"><a href="#fn:even-works-for-perf" rel="footnote">12</a></sup> I also believe that there are
<a href="https://research.google/pubs/pub50370/">lower hanging fruits in memory placement</a>
than shaving a few nanoseconds from the allocation path.</p>
<p><a href="https://crates.io/crates/slitter">Slitter</a> also focuses on
instrumentation and debugging features that are always active, even in
production, instead of leaving that to development tools, or to logic
that must be explicitly enabled. In a SaaS world, development and
debugging is never done. Opt-in tools are definitely useful, but
always-on features are much more likely to help developers catch
the rarely occurring bugs on which they tend to spend an inordinate
amount of investigation effort (and if a debugging feature can be
safely enabled in production at a large scale, why not leave it
enabled forever?).</p>
<p>If that sounds like an interesting philosophy for a slab allocator,
<a href="https://github.com/backtrace-labs/slitter">come hack on Slitter</a>!
Admittedly, the value of Slitter isn’t as clear for pure Rust hackers
as it is for those of us who blend C and Rust, but per-class allocation
statistics and placement decisions should be useful, even in safe
Rust, especially for larger programs with long runtimes.</p>
<p>Our <a href="https://github.com/backtrace-labs/slitter">MIT-licensed code is on github</a>,
there are <a href="https://github.com/backtrace-labs/slitter/issues">plenty of small improvements to work on</a>,
and, while we still have to re-review the documentation, it has decent
test coverage, and we try to write straightforward code.</p>
<p><small>This post was much improved by feedback from my beta readers, Barkley, David,
Eloise, Mark, Per, Phil, Ruchir, and Samy.</small></p>
<hr/>

</div></div>
  </body>
</html>
