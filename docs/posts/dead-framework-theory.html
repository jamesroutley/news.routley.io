<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aifoc.us/dead-framework-theory/">Original</a>
    <h1>Dead Framework Theory</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>These are my opinions and are ruminations on what might be happening as more and more developers use LLMs and Frameworks to build on the web.</em></p><p>In October last year I wrote “<a href="https://paul.kinlan.me/will-we-care-about-frameworks-in-the-future/">will developers care about frameworks in the future?</a>” predicting that LLMs would abstract away framework choice. I was wrong—or at least, wrong about the timeline.</p><p>The reality is more interesting and more permanent: <strong>React isn’t competing with other frameworks anymore. React has become the platform.</strong> And if you’re building a new framework, library or browser feature today, you need to understand that you’re not just competing with React—you’re competing against a self-reinforcing feedback loop between LLM training data, system prompts, and developer output that makes displacing React functionally impossible.</p><p>If you look at what Replit, Bolt, and similar tools are doing, they’re not trying to abstract away frameworks—they’re <a href="https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools/blob/7e9f6102c7d164dfdbfca3bfd66f3d8ad5c0b2cc/Open%20Source%20prompts/Bolt/Prompt.txt#L275">explicitly hardcoding React into their system prompts</a>. They have to. If you’re building a tool today to attract developers, you need to give them code they can maintain. And “code developers can maintain” now means “React” for the vast majority of web developers.</p><p><a href="https://trends.builtwith.com/javascript/React">According to builtwith.com, there were +13m sites outside of the top 1m deployed with React in the last 12 months</a>. Look at these curves:</p><figure><img src="https://blog.veitheller.de/images/react-builtwith-all-time.png" alt="React usage over time"/><figcaption><p>React usage over time</p></figcaption></figure><figure><img src="https://blog.veitheller.de/images/react-builtwith-12mo.png" alt="React usage over the last 12 months"/><figcaption><p>React usage over the last 12 months</p></figcaption></figure><p>However, looking at <a href="https://httparchive.org/reports/techreport/tech?tech=ALL#adoption">HTTP Archive</a>, it tells a different story. React usage has stalled at 1.2 million mobile origins on mobile vs 55 million origins as reported by Builtwith.</p><figure><img src="https://blog.veitheller.de/images/react-http-archive-all.png" alt="HTTP Archive. React usage over the last 6 months"/><figcaption><p>HTTP Archive. React usage over the last 6 months</p></figcaption></figure><p>The dataset sizes are vastly different. HTTP Archive looks over <a href="https://blog.veitheller.de/images/http-archive-origins-over-time.png">some 12-16 million origins</a>, while <a href="https://trends.builtwith.com/javascript/React">Builtwith is reportedly looking</a> at some <a href="https://blog.veitheller.de/images/built-with-coverage.png">414 million <em>root domains</em></a>. Sites also don’t get into HTTP Archive unless there is some amount of usage and many sites in Builtwith might be parked domains or sites that are not actively being used.</p><p>Looking at the top 1m, the detection rate is more aligned: 140k vs 160k.</p><figure><img src="https://blog.veitheller.de/images/react-http-archive-top-1m.png" alt="HTTP Archive. React usage in the top 1m"/><figcaption><p>HTTP Archive. React usage in the top 1m</p></figcaption></figure><figure><img src="https://blog.veitheller.de/images/react-builtwith-top-1m.png" alt="Builtwith React usage in the top 1m"/><figcaption><p>Builtwith React usage in the top 1m</p></figcaption></figure><p>We’re looking at about 12-18% of sites in the top 1m. Take all these numbers with a pinch of salt. The detection can be broken, the datasets are different sizes and the definitions of what is being measured are different. But the trends feel undeniable: React’s growth continues while competitors <a href="https://blog.veitheller.de/images/builtwith-angular-12mo.png">like Angular, sadly stagnate</a>.</p><p>So what has driven the uptick in React sites? My read of the data suggests LLM tools over the last 12-18 months are preferring to output React code.</p><p>Look at token growth on OpenRouter. Programming tools are <a href="https://aifoc.us/token-slinging">burning through billions of tokens a day</a> via just one gateway. The curves look similar:</p><figure><img src="https://blog.veitheller.de/images/open-router-tokens-oct.png" alt="OpenRouter token usage over time"/><figcaption><p>OpenRouter token usage over time</p></figcaption></figure><p>Correlation is not causation, and only the tool creators see the full picture as tokens flow through their systems. But the timing is striking: massive token growth coinciding with massive React deployment growth.</p><p>The models and the tools are preferring the tools that developers are already using, and it’s driving a self-reinforcing cycle of adoption. If you are launching a new API or tool today, you need to consider how it will be adopted by the ecosystem and how to get it into the training corpus of the LLMs.</p><p>We have two loops of feedback in play here:</p><ol><li>React dominates the existing web (~13M+ new sites in 12 months)</li><li>LLMs train on the existing web</li><li>LLMs output React by default</li><li>New sites built with LLMs use React</li><li>More React sites exist for future training</li><li>Go to step 2</li></ol><p>And…</p><ol><li>React dominates the developer ecosystem</li><li>IDEs and tools that developers preferntially output React</li><li>Tools ask LLMs to output React by default</li><li>New sites built are using React</li><li>More React sites exist to increase demand for tools to output React</li><li>Go to step 1</li></ol><p>I don’t actually know if this is bad or good. We’re getting more sites on the web and they’re all pretty high quality. But it does create barriers for new frameworks, tools and web platform features that we need to understand. Specifically when:</p><ol><li>Your framework isn’t in the training data because it’s new</li><li>Tool creators hardcode React because that’s what developers know today</li><li>Developers expect React output because that’s what works</li><li>Companies won’t use your framework if their developers can’t maintain it</li><li>React has thousands of libraries; you have dozens</li></ol><p>If you launch a new framework, library or browser feature today, even if it’s technically superior, you need to:</p><ul><li>Get into LLM training data (12-18 month lag minimum)</li><li>Convince tool creators to modify system prompts (requires existing adoption)</li><li>Build a comprehensive library ecosystem (years of development)</li><li>Overcome developer inertia and get developers to ask for it</li></ul><p>By the time you’ve done step 1, the ecosystem using React has generated another 10M+ sites. You might flip that order, and do a massive campaign to get developer mind share, and supplement it with paid integrations in to the library ecosystem. We might even see new business models where framework and library authors pay tooling providers to include their framework in system prompts. But even then, you’re fighting against entrenched patterns in both React libraries AND LLM training data.</p><p>This isn’t about React being the best tool or that it’s Model is good for LLMs (I don’t see any evidence there at all). It’s about React being past the point where network effects make alternatives viable.</p><p>Here’s what brought this home for me: Last week I used Claude to build a Chrome Extension using Chrome’s built-in <code>prompt</code> API. Claude dutifully wrote the entire extension, but used <code>self.ai.languageModel</code>—the API from 6 months ago. The current API is <code>LanguageModel.create()</code>, but that wasn’t in the training corpus.</p><p>Add in the fact that it can take years of <a href="https://web.dev/blog/interop-2025">Interop</a> work to get a feature to the point it becomes “<a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility#:~:text=Features%20listed%20as%20newly%20available%20work%20in%20at%20least%20the%20latest%20stable%20version%20of%20each%20of%20the%20Baseline%20browsers%2C%20but%20may%20not%20work%20with%20older%20browsers%20and%20devices.">Baseline newly-available</a>” and then another 30 months for it to reach a point where it’s “<a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility#:~:text=Features%20listed%20as%20widely%20available%20have%20a%20consistent%20history%20of%20support%20in%20each%20of%20the%20Baseline%20browsers%20for%20at%20least%202.5%20years.">Baseline widely-available</a>”. By that time, the ecosystem has moved on, and the feature is competing against entrenched patterns in both React libraries AND LLM training data.</p><p>This is the new reality: <strong>If it’s not in the LLM training data, it doesn’t exist.</strong> Not for 12-18 months, at least not until the next model training cycle and not until enough examples exist in the wild to statistically matter.</p><p>Now apply this to frameworks:</p><ul><li><strong>Web platform APIs</strong>: 0-6 months of real-world usage before training cutoff</li><li><strong>New frameworks</strong>: 0-6 months of real-world usage before training cutoff</li><li><strong>React patterns</strong>: 10+ years of accumulated examples</li></ul><p>Today, if your framework or documentation isn’t in the training corpus of the LLM, then it won’t be output. If the system prompt of the tool a developer uses doesn’t have your API, library or framework, then it’s not in the output. And if the user of a tool doesn’t ask for a specific API, library or framework, then it won’t be output. Model providers are skewing it so the model prefers a certain style, or framework or library.</p><p>The same dynamic applies to new web platform APIs designed to replace framework features. Consider the typical pattern:</p><ol><li>Browser teams identify a common pattern in frameworks (e.g., CSS Nesting instead of Sass)</li><li>Multi-year standardization process begins</li><li>Feature ships in browsers</li><li>Developers… keep using the framework pattern</li></ol><p>Why? Because:</p><ul><li><strong>The LLM learned the old pattern</strong>: Sass has 15 years of examples; CSS Nesting has 1 or 2 years</li><li><strong>The framework already works</strong>: React developers use styled-components, Tailwind, CSS modules</li><li><strong>The ecosystem is built</strong>: Thousands of React component libraries use existing CSS patterns</li><li><strong>There’s no incentive to switch</strong>: The new platform feature doesn’t make the site better for users</li></ul><p>For example:</p><ul><li>People loved <a href="https://sass-lang.com/">Sass</a>, but you need a build-step, so we have <a href="https://developer.chrome.com/docs/css-ui/css-nesting">CSS Nesting</a>. However its rarely output because preprocessor patterns are more common in the corpus and also React developers already have CSS-in-JS solutions that LLMs know how to output.</li><li>Carousels are hard to build, so maybe we should have them as an intrinsic part of the platform. But there are <a href="https://flowbite.com/docs/components/carousel/#:~:text=Create%20a%20new%20carousel%20object%20using%20the%20options%20set%20above.">tons</a> of <a href="https://daisyui.com/components/carousel/?lang=en">libraries</a> that <a href="https://getbootstrap.com/docs/4.0/components/carousel/">create</a> great <a href="https://www.npmjs.com/package/react-multi-carousel">carousels</a> that are already in LLM training data.</li></ul><p>As an author of many sites, I love these features. CSS Nesting alone lets me structure my CSS in a way that I personally find easier to read and maintain. But it doesn’t really change the quality of the experience of the site for the person using my site. It doesn’t change the performance of the site. It doesn’t change how accessible my site is. It just makes it easier for me to write and maintain.</p><p>The only new platform features that matter are ones that <em>can’t be built in user-space</em>, like:</p><ul><li>Multi-page view transitions (new navigation capabilities)</li><li>WebGPU (fundamentally new compute access)</li><li>WebAuthN and PassKeys (security primitives)</li></ul><p>Everything else is competing against entrenched patterns in both React libraries AND LLM training data.</p><p>There’s at least 3 constituencies to consider here:</p><ol><li><p>The “head” businesses building on the web - The top 1000 sites take the lion’s share of traffic and revenue on the web, and we don’t see massive technology shifts in the top 1000 through to top 1 million because these are established sites with established teams and shifting technology is hard with often unclear benefit outside of potential improvements to product velocity. They are likely to be using LLM based tooling to help increase velocity, but they are not going to be switching frameworks or libraries lightly.</p></li><li><p>The “middle” businesses building on the web - The next 10 million sites are being built by small teams and individuals and will likely be using LLMs to build new sites completely and unless they prompt will use the defaults the tools output</p></li><li><p>The “long tail” - These are people who are not formal web developers who will use tools like Loveable, Replit, or even directly in a chat app. They may never need to look at the code, so what do any of these new APIs do to help them build better sites? and they represent the growth in the platform and we have an <a href="https://blog.veitheller.de/transition/">opportunity for millions more people to deploy on to the web</a></p></li></ol><p>The people in groups 2 and 3 are the ones driving the growth in sites on the web and are unlikely to be building with these tools don’t know about Passkeys, WebAuthn, Web Components, CSS Nesting, View Transitions, or any of the other new features being added to the platform. They just want a site created that does what they need it to do.</p><p>The thing is, the normal people using the web don’t care about the tools, frameworks and libraries are not something that concerns a normal person using the web. What concerns people is the experience of using the page. Does it load quickly enough? Are the interactions smooth? Does the site actually do what I need it to do?</p><p>Today, if you are a company targeting developers in any of those categories (LLM or a tool that outputs code from an LLM), to not output React by default is to limit your potential audience as your competitors are serving the current demand.</p><p>Now consider the current working model for code-generating LLM tools which reflect the ecosystem that they are trained on. This means that any new API, framework or library has a large hurdle to get over in terms of being something that will be output by the tool. The fact that <em>any</em> new feature might not be in the training corpus <em>and</em> will not be prevalent enough to have its usage patterns and idioms ingrained in the training and by extension the output of an LLM should be a concern to the people building new platform features.</p><p>Looking at today’s trend of tools primarily outputting React code, the comprehensive ecosystem of user-space libraries can do almost everything from custom select boxes, specialized date components and everything else. I can’t see a world where a new platform feature is going to displace the libraries in use nor can I see a world where a new framework is going to displace React in the short to medium term—I really love what the Remix folks are doing with Remix 3 and I will keenly watch how it is adopted and how LLMs might pick this up to see how this post plays out in the real world. I’d love to see how long it takes for LLMs to start outputting Remix code without specific prompting or including docs in the context.</p><p><strong>For framework authors:</strong> Building a new framework is building a product that LLMs won’t output for 12-18 months minimum, that has no library ecosystem, that developers don’t know, and that companies won’t adopt. You’re not competing with React’s technical merits—you’re competing with React’s statistical dominance in every LLM training corpus and every tools providers preference for their customer.</p><p><strong>For platform developers:</strong> Developer experience features (syntactic sugar, convenience APIs) are competing against established React patterns in LLM training data. They will not be adopted at scale. Focus on fundamental capabilities that can’t be built in user-space. For features that browser developers are creating today, we need to take a long hard look at the benefits that they will bring to the user and not the developer. To that extent, many of the platform features ranging from Web Components through to syntactical changes are just not needed by the vast majority of people building sites in the coming years.</p><p><strong>For tool creators (e.g, IDEs):</strong> If you’re not outputting React by default, you’re limiting your addressable market. Your competitors are serving current demand. You can’t afford to be principled about framework diversity.</p><p>Dead framework theory isn’t about frameworks dying. It’s about new frameworks being dead on arrival in a world where React has become the platform (at least as long as people need to maintain code.)</p><p>As an industry we should absolutely innovate and build new frameworks, libraries and platform features. We need innovation to push the web forward and create competition. But we need to be aware of the dynamics at play and have clear strategies to get our work into LLM training corpus, system prompts, and developer minds.</p><p>If the industry continues its current focus on maintainability and developer experience, we’ll end up in a world where the web is built by LLMs using React and a handful of libraries entrenched in the training data. Framework innovation stagnates. Platform innovation focuses elsewhere. React becomes infrastructure—invisible and unchangeable.</p><p>But here’s the optimistic take: If LLM usage continues to grow, tooling vendors will have to compete with each other on this homogenized ecosystem. When everyone outputs React by default, you can’t differentiate on framework choice. You have to compete on output quality. Market forces shift the focus from developer experience to user experience.</p><p>For either scenario, we need to start competing on user outcomes. I really want to see Evals and Benchmarks that focus on quality outcomes like Core Web Vitals did for performance. When tools compete to attract users, the ones that output meaningfully better experiences will win. This competitive pressure will incentivize the entire ecosystem to optimize for users, not developers.</p><p>And if we succeed? Then in the long run, <a href="https://paul.kinlan.me/will-we-care-about-frameworks-in-the-future/">the framework will become irrelevant</a> as the models improve to the point people <a href="https://blog.almaer.com/english-will-become-the-most-popular-development-language-in-6-years/">manipulate sites by words alone</a> and the LLM providers believe they can create better outcomes with their own frameworks or tuning (hat tip to Ade). The delivery technology becomes an optimized compiled output that meets user needs—whether it’s “React” or something else stops mattering.</p><p>As for the raw, naked, web platform? Focus on fundamentally new capabilities—the things that can’t be built in user-space, or where there’s clear user-experience benefit that can’t be achieved with libraries.</p></div></div>
  </body>
</html>
