<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dthompson.us/guix-for-development.html">Original</a>
    <h1>Guix for Development</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://gexp.no/blog/hacking-anything-with-gnu-guix.html">This wonderful
article</a> by
Marius Bakke (thanks for using
<a href="https://dthompson.us/projects/haunt.html">Haunt</a> btw!) about <code>guix shell</code> hit the orange website front page recently.  I left a comment
to the effect of “hell yeah I use it for all my projects!” and someone
asked me for an example of what I do.  I sent them some links but I
thought hey, this could be a blog post and I haven&#39;t written one of
those in <em>years</em>!</p><p>The tl;dr is that <a href="https://guix.gnu.org">Guix</a> is a fantastic
developer productivity tool that can easily automate development
environment creation and pre-release build testing and you should give
it a try but if you like what you already use then that&#39;s fine, too.</p><h2>There&#39;s gotta be a better way!</h2><p>This is the “Are you tired of <em>this</em>?” part of the infomercial.  Read
the next few paragraphs and picture me, in black and white, struggling
to hold a large stack of boxes, all labeled “software.”  I continue
struggling to balance the boxes as you read.  When you&#39;ve reached the
last paragraph of the section, I fall over, the boxes land on top of
me and all over the floor, I&#39;m covered in spaghetti, and in an
exasperated voice I shout &#34;There&#39;s gotta be a better way!&#34;</p><p>When setting up a new computer for software development, I want to go
from <code>git clone</code> to <code>make</code> in as little time as possible (adjust that
for your VCS and build system of choice.)  In the old days, this meant
manually installing the dependencies through the distro package
manager.  If things are organized, the project README will have a list
of what is needed and it&#39;s not so bad.  If things are less organized,
it&#39;s a cycle of installing packages and running <code>./configure</code> or
whatever until it succeeds.  Hopefully none of the dependencies are
too new to be found in the distro.  And when working on multiple
projects, hopefully there&#39;s no conflicts between the dependencies
required for each of them, because your development environment is the
entire system and there&#39;s no way to isolate different projects from
each other.</p><p>Of course, different programming languages provide their own sets of
tools for managing multiple projects.  Python has virtualenv, Ruby has
rvm and bundler, Node has nvm and npm, etc.  But their domain is
restricted to only the dependencies for that language and their
runtimes.  A system package manager is needed to bootstrap their use.</p><p>Nowadays it&#39;s “just use Docker.”  Docker&#39;s take is that all this
package management stuff is just too complicated.  Instead, just
create a disk image per project that encapsulates this hodgepodge of
package managers and bespoke, artisinal, small-batch builds that gets
run in isolation via Linux namespace magic.  It works, of course, but
I think Dockerfiles are clunky and the rather extreme level of
isolation is usually unnecessary and makes things overly complicated
for projects that need to interact with, say, the windowing system of
the host computer.  A lot of people are happy with Docker, though.
Maybe you are, too.  That&#39;s fine!</p><p>What I really want to say is “Computer, provision a development
environment containing Guile 3, SDL2, make, and texinfo!” and have
Majel Barrett-Roddenberry tell me that all of those things have been
made available to me on my host system.  No container, no virtual
machine.  It shouldn&#39;t matter if I have Guile 2 installed system-wide,
Guile 3 should still be what&#39;s used in the context of the project.
This is how Guix works and it&#39;s very good and cool and I&#39;m going to
tell you all about how I use it.</p><h2>Two easy payments and one complicated payment</h2><p>Guix is a general-purpose package manager that can be used on top of
any distro and also <em>it is a distro</em>.  I use it both on Ubuntu and as
a standalone distro.  It takes a few minutes to <a href="https://guix.gnu.org/manual/en/html_node/Binary-Installation.html">install on top of an
existing
distro</a>
but once it&#39;s there the magic begins.  Software installed with Guix is
not installed globally (<code>/usr</code>), which allows it to act like a
<code>virtualenv</code> for everything.  Guix provides the <a href="https://guix.gnu.org/en/manual/devel/en/html_node/Invoking-guix-shell.html">guix
shell</a>
tool for creating temporary environments with an arbitrary set of
software inside.</p><p>Let&#39;s start with a real world example.  Here&#39;s how to build Guile&#39;s
SDL2 bindings from a Git checkout using Guix:</p><pre><code>git clone https://git.dthompson.us/guile-sdl2.git
cd guile-sdl2
echo $PWD &gt;&gt; $HOME/.config/guix/shell-authorized-directories
guix shell
./configure
make</code></pre><p>Looks pretty straightforward except for that third line, which
whitelists the project directory as a place that <code>guix shell</code> can be
used for security reasons (though I think the potential risk is not
worth this extra step that I&#39;m now burdened with explaining!)  I don&#39;t
have to look at a <code>README</code> to know what software I need to install.
The project is pre-configured to work with Guix and the software it
installs does not affect the whole system.</p><p>So what&#39;s happening?  Well, <code>guix shell</code> automatically searches the
current directory for a <code>guix.scm</code> file and loads it.  Inside that
file is all the information needed to construct an environment that
can build the source code:</p><pre><code><span>(</span><span>use-modules</span> <span>(</span><span>guix</span> <span>git</span><span>)</span>
             <span>(</span><span>guix</span> <span>packages</span><span>)</span>
             <span>(</span><span>guix</span> <span>licenses</span><span>)</span>
             <span>(</span><span>guix</span> <span>build-system</span> <span>gnu</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>autotools</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>guile</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>pkg-config</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>sdl</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>texinfo</span><span>)</span><span>)</span>

<span>(</span><span>package</span>
  <span>(</span><span>name</span> <span>&#34;guile-sdl2&#34;</span><span>)</span>
  <span>(</span><span>version</span> <span>&#34;0.7.0&#34;</span><span>)</span>
  <span>(</span><span>source</span> <span>(</span><span>git-checkout</span> <span>(</span><span>url</span> <span>(</span><span>dirname</span> <span>(</span><span>current-filename</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>build-system</span> <span>gnu-build-system</span><span>)</span>
  <span>(</span><span>arguments</span>
   <span>&#39;</span><span>(</span><span>#:make-flags</span> <span>&#39;</span><span>(</span><span>&#34;GUILE_AUTO_COMPILE=0&#34;</span><span>)</span>
     <span>#:phases</span>
     <span>(</span><span>modify-phases</span> <span>%standard-phases</span>
       <span>(</span><span>add-after</span> <span>&#39;unpack</span> <span>&#39;bootstrap</span>
         <span>(</span><span>lambda</span> <span>_</span> <span>(</span><span>invoke</span> <span>&#34;sh&#34;</span> <span>&#34;bootstrap&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>native-inputs</span> <span>(</span><span>list</span> <span>autoconf</span> <span>automake</span> <span>pkg-config</span> <span>texinfo</span><span>)</span><span>)</span>
  <span>(</span><span>inputs</span> <span>(</span><span>list</span> <span>guile-3.0-latest</span> <span>sdl2</span> <span>sdl2-image</span> <span>sdl2-mixer</span> <span>sdl2-ttf</span><span>)</span><span>)</span>
  <span>(</span><span>synopsis</span> <span>&#34;Guile bindings for SDL2&#34;</span><span>)</span>
  <span>(</span><span>description</span> <span>&#34;Guile-SDL2 provides pure Guile Scheme bindings to the SDL2 C shared
library via the foreign function interface.&#34;</span><span>)</span>
  <span>(</span><span>home-page</span> <span>&#34;https://git.dthompson.us/guile-sdl2.git&#34;</span><span>)</span>
  <span>(</span><span>license</span> <span>lgpl3+</span><span>)</span><span>)</span></code></pre><p>This is what&#39;s known as “configuration as code” and it looks kinda
like a <code>package.json</code> (not code) or a <code>.gemspec</code> (code) file.
<code>guix.scm</code> contains not just inert data, but a small Scheme program
that returns a Guix package.  <code>guix shell</code> sees to it that all of the
dependencies (listed in the <code>inputs</code> and <code>native-inputs</code> sections) are
available within the shell session it creates by downloading (or
building, if necessary) the entire dependency tree.  Going back to the
earlier example, <code>./configure</code> and <code>make</code> run in the context of that
new shell session and are thus able to complete successfully.</p><p>Should you want/need more isolation from the host system, <code>guix shell</code>
has you covered.  The <code>--pure</code> flag will clear out most existing
environments variables, such as <code>$PATH</code>, so that the resulting
environment does not contain pointers to places like <code>/usr</code>.  For more
Docker-like isolation, the <code>--container</code> flag can be used, which will
run the new shell session within a set of Linux namespaces so that the
host system is inaccessible.  I rarely use either flag.</p><p><code>guix shell</code> runs pretty fast after it downloads all the required
software the first time, and it can be run non-interactively, so it&#39;s
pretty handy to use in scripts.  It can even be used with
<a href="https://direnv.net/">direnv</a> by adding this to <code>.envrc</code>:</p><pre><code>eval $(guix shell --search-paths)</code></pre><p>I&#39;m an Emacs user, so I want to integrate <code>guix shell</code> there, as well.
Turns out that&#39;s pretty easy via the
<a href="https://github.com/wbolster/emacs-direnv">emacs-direnv</a> extension.
With <code>direnv-mode</code> enabled, I can run <code>M-x compile</code>, enter <code>make</code> as
the compilation command, and build my project from within Emacs using
the environment built by <code>guix shell</code>.  Pretty fancy!  Thanks to
Andrew Whatson for teaching me about this.</p><p>The same <code>guix.scm</code> file can be used with more than just <code>guix shell</code>.
For example, <code>guix build -f guix.scm</code> will build the project from
scratch outside of your project directory, which could reveal issues
like forgetting to commit a new file (something I&#39;ve done too many
times.)  <code>guix package -f guix.scm</code> will build <em>and</em> install the
package, which could be used to confirm that a “real” build works the
same as the version in the development environment.</p><h2>Supplies are limited, order today!</h2><p>I hope this helps someone out there considering a Guix-based
development workflow or is just wondering what the deal is.  I haven&#39;t
come across too many people in this <a href="https://www.youtube.com/watch?v=84Y9PjfLZZE">wild
world</a> that use <code>guix shell</code> the same way I do, so part of the motivation behind this post
is an attempt to get more Guix users to adopt this pattern.</p><p>Oh and finally I should say that I&#39;m not trying to convince anyone to
give up what works for them, be it Docker, Nix, or whatever else.  I
don&#39;t think anyone is “doing it wrong.”  Use what makes you feel
productive and hack the good hack.  This is just how I do it.</p></div></div>
  </body>
</html>
