<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ralfj.de/blog/2023/06/02/tree-borrows.html">Original</a>
    <h1>From Stacks to Trees: A new aliasing model for Rust</h1>
    
    <div id="readability-page-1" class="page"><article id="-content">
      <header>
    
    
</header>

<p>Since last fall, <a href="https://perso.crans.org/vanille/">Neven</a> has been doing an internship to develop a new aliasing model for Rust: Tree Borrows.
Hang on a second, I hear you say – doesn’t Rust already have an aliasing model?
Isn’t there this “Stacked Borrows” that Ralf keeps talking about?
Indeed there is, but Stacked Borrows is just one proposal for a possible aliasing model – and it <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues?q=is%3Aopen+is%3Aissue+label%3AA-stacked-borrows">has its problems</a>.
The purpose of Tree Borrows is to take the lessons learned from Stacked Borrows to build a new model with fewer issues, and to take some different design decisions such that we get an idea of some of the trade-offs and fine-tuning we might do with these models before deciding on the official model for Rust.</p>

<p>Neven has written a detailed introduction to Tree Borrows <a href="https://perso.crans.org/vanille/treebor/">on his blog</a>, which you should go read first.
He presented this talk at a recent RFMIG meeting, so you can also <a href="https://www.youtube.com/watch?v=zQ76zLXesxA">watch his talk here</a>.
In this post, I will focus on the differences to Stacked Borrows.
I assume you already know Stacked Borrows and want to understand what changes with Tree Borrows and why.</p>

<!-- MORE -->

<p>As a short-hand, I will sometimes write SB for Stacked Borrows and TB for Tree Borrows.</p>

<h2 id="two-phase-borrows">Two-phase borrows</h2>

<p>The main novelty in Tree Borrows is that it comes with proper support for two-phase borrows.
Two-phase borrows are a mechanism introduced with NLL which allows code like the following to be accepted:</p>

<div><div><pre><code><span>fn</span> <span>two_phase</span><span>(</span><span>mut</span> <span>x</span><span>:</span> <span>Vec</span><span>&lt;</span><span>usize</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>x</span><span>.push</span><span>(</span><span>x</span><span>.len</span><span>());</span>
<span>}</span>
</code></pre></div></div>

<p>The reason this code is tricky is that it desugars to something like this:</p>

<div><div><pre><code><span>fn</span> <span>two_phase</span><span>(</span><span>mut</span> <span>x</span><span>:</span> <span>Vec</span><span>&lt;</span><span>usize</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>let</span> <span>arg0</span> <span>=</span> <span>&amp;</span><span>mut</span> <span>x</span><span>;</span>
    <span>let</span> <span>arg1</span> <span>=</span> <span>Vec</span><span>::</span><span>len</span><span>(</span><span>&amp;</span><span>x</span><span>);</span>
    <span>Vec</span><span>::</span><span>push</span><span>(</span><span>arg0</span><span>,</span> <span>arg1</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This code clearly violates the regular borrow checking rules since <code>x</code> is mutably borrowed to <code>arg0</code> when we call <code>x.len()</code>!
And yet, the compiler will accept this code.
The way this works is that the <code>&amp;mut x</code> stored in <code>arg0</code> is split into two phases:
in the <em>reservation</em> phase, <code>x</code> can still be read via other references.
Only when we actually need to write to <code>arg0</code> (or call a function that might write to it) will the reference be “activated”, and it is from that point onwards (until the end of the lifetime of the borrow) that no access via other references is allowed.
For more details, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/2025-nested-method-calls.md">the RFC</a> and <a href="https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html">the rustc-dev-guide chapter on two-phase borrows</a>.
The only point relevant for this blog post is that when borrowing happens implicitly for a method call (such as <code>x.push(...)</code>), Rust will treat this as a two-phase borrow.
When you write <code>&amp;mut</code> in your code, it is treated as a regular mutable reference without a “reservation” phase.</p>

<p>For the aliasing model, two-phase borrows are a big problem: by the time <code>x.len()</code> gets executed, <code>arg0</code> already exists, and as a mutable reference it really isn’t supposed to allow reads through other pointers.
Therefore Stacked Borrows just <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/85">gives up</a> here and basically treats two-phase borrows like raw pointers.
That is of course unsatisfying, so for Tree Borrows we are adding proper support for two-phase borrows.
What’s more, we are treating <em>all</em> mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly.
(This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.)</p>

<p>This is why we need a tree in the first place: <code>arg0</code> and the reference passed to <code>Vec::len</code> are both children of <code>x</code>.
A stack is no longer sufficient to represent the parent-child relationships here.
Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a <code>Reserved</code> state which tolerates reads from other, unrelated pointers.
Only when the reference (or one of its children) is written to for the first time, its state transitions to <code>Active</code> and now reads from other, unrelated pointers are not accepted any more.
(See Neven’s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are <code>UnsafeCell</code> involved, then a reserved mutable reference actually has to tolerate <em>mutation</em> via unrelated pointers!
In other words, the aliasing rules of <code>&amp;mut T</code> are now affected by the presence of <code>UnsafeCell</code>. I don’t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)</p>

<h2 id="delayed-uniqueness-of-mutable-references">Delayed uniqueness of mutable references</h2>

<p>One of the most common source of Stacked Borrows issues is its <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/133">very eager enforcement of uniqueness of mutable references</a>.
For example, the following code is illegal under Stacked Borrows:</p>

<div><div><pre><code><span>let</span> <span>mut</span> <span>a</span> <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>];</span>
<span>let</span> <span>from</span> <span>=</span> <span>a</span><span>.as_ptr</span><span>();</span>
<span>let</span> <span>to</span> <span>=</span> <span>a</span><span>.as_mut_ptr</span><span>()</span><span>.add</span><span>(</span><span>1</span><span>);</span> <span>// `from` gets invalidated here</span>
<span>std</span><span>::</span><span>ptr</span><span>::</span><span>copy_nonoverlapping</span><span>(</span><span>from</span><span>,</span> <span>to</span><span>,</span> <span>1</span><span>);</span>
</code></pre></div></div>

<p>The reason it is illegal is that <code>as_mut_ptr</code> takes <code>&amp;mut self</code>, which asserts unique access to the entire array, therefore invalidating the previously created <code>from</code> pointer.
In Tree Borrows, however, that <code>&amp;mut self</code> is a two-phase borrow! <code>as_mut_ptr</code> does not actually perform any writes, so the reference remains reserved and never gets activated.
That means the <code>from</code> pointer remains valid and the entire program is well-defined.
The call to <code>as_mut_ptr</code> is treated like a read of <code>*self</code>, but <code>from</code> (and the shared reference it is derived from) are perfectly fine with reads via unrelated pointers.</p>

<p>It happens to be the case that swapping the <code>from</code> and <code>to</code> lines actually makes this code work in Stacked Borrows.
However, this is not for a good reason: this is a consequence of the rather not-stack-like rule in SB which says that on a read, we merely <em>disable all <code>Unique</code></em> above the tag used for the access, but we keep raw pointers derived from those <code>Unique</code> pointers enabled.
Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses.
With TB, the swapped program is still fine, but for a different reason:
when <code>to</code> gets created first, it remains a reserved two-phase borrow.
This means that creating a shared reference and deriving <code>from</code> from it (which acts like a read on <code>self</code>) is fine; reserved two-phase borrows tolerate reads via unrelated pointers.
Only when <code>to</code> is written to does it (or rather the <code>&amp;mut self</code> it was created from) become an active mutable reference that requires uniqueness, but that is after <code>as_ptr</code> returns so there is no conflicting <code>&amp;self</code> reference.</p>

<p>It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB.
I didn’t expect this at all, so this is a happy little accident. :)</p>

<p>However, note that the following program is fine under SB but invalid under TB:</p>

<div><div><pre><code><span>let</span> <span>mut</span> <span>a</span> <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>];</span>
<span>let</span> <span>to</span> <span>=</span> <span>a</span><span>.as_mut_ptr</span><span>()</span><span>.add</span><span>(</span><span>1</span><span>);</span>
<span>to</span><span>.write</span><span>(</span><span>0</span><span>);</span>
<span>let</span> <span>from</span> <span>=</span> <span>a</span><span>.as_ptr</span><span>();</span>
<span>std</span><span>::</span><span>ptr</span><span>::</span><span>copy_nonoverlapping</span><span>(</span><span>from</span><span>,</span> <span>to</span><span>,</span> <span>1</span><span>);</span>
</code></pre></div></div>

<p>Here, the write to <code>to</code> activates the two-phase borrow, so uniqueness is enforced.
That means the <code>&amp;self</code> created for <code>as_ptr</code> (which is considered reading all of <code>self</code>) is incompatible with <code>to</code>, and so <code>to</code> is invalidated (well, it is made read-only) when <code>from</code> gets created.
So far, we do not have evidence that this pattern is common in the wild.
The way to avoid issues like the code above is to <em>set up all your raw pointers before you start doing anything</em>.
Under TB, calling reference-receiving methods like <code>as_ptr</code> and <code>as_mut_ptr</code> and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer.
Once the first write happens, creating more references can cause aliasing violations.</p>

<h2 id="no-strict-confinement-of-the-accessible-memory-range">No strict confinement of the accessible memory range</h2>

<p>The other major source of trouble with Stacked Borrows is <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/134">restricting raw pointers to the type and mutability they are initially created with</a>.
Under SB, when a reference is cast to <code>*mut T</code>, the resulting raw pointer is confined to access only the memory covered by <code>T</code>.
This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements.
Moreover, when a reference is cast to <code>*const T</code>, it is actually read-only, even if the reference was mutable!
Many people expect <code>*const</code> vs <code>*mut</code> not to matter for aliasing, so this is a regular source of confusion.</p>

<p>Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.
A raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access.
Moreover, references are not strictly confined to the memory range described by their type:
when an <code>&amp;mut T</code> (or <code>&amp;T</code>) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by <code>T</code> (and we consider this a read access for that memory range).
However, we also perform <em>lazy initialization</em>: when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access.
This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree.</p>

<p>This means TB is compatible with <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/243"><code>container_of</code>-style pointer arithmetic</a> and <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/276"><code>extern</code> types</a>, overcoming two more SB limitations.</p>

<p>This also means that the following code becomes legal under TB:</p>

<div><div><pre><code><span>let</span> <span>mut</span> <span>x</span> <span>=</span> <span>0</span><span>;</span>
<span>let</span> <span>ptr</span> <span>=</span> <span>std</span><span>::</span><span>ptr</span><span>::</span><span>addr_of_mut!</span><span>(</span><span>x</span><span>);</span>
<span>x</span> <span>=</span> <span>1</span><span>;</span>
<span>ptr</span><span>.read</span><span>();</span>
</code></pre></div></div>

<p>Under SB, <code>ptr</code> and direct access to the local <code>x</code> used two different tags, so writing to the local invalidated all pointers to it.
Under TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local.</p>

<p>Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated.
However, note that TB only allows this if there is an <code>addr_of_mut</code> (or <code>addr_of</code>) immediately in the body of a function!
If a reference <code>&amp;mut x</code> is created, and then some other function derives a raw pointer from that, those raw pointers <em>do</em> get invalidated on the next write to <code>x</code>.
So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB.</p>

<p>Note that this entire approach in TB relies on TB <em>not</em> needing the stack-violating hack mentioned in the previous section.
If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support.
This means that backporting these improvements to SB is unlikely to be possible.</p>

<h2 id="unsafecell"><code>UnsafeCell</code></h2>

<p>The handling of <code>UnsafeCell</code> also changed quite a bit with TB.
First of all, another <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/303">major issue</a> with SB was fixed: turning an <code>&amp;i32</code> into an <code>&amp;Cell&lt;i32&gt;</code> <em>and then never writing to it</em> is finally allowed.
This falls out of how TB handles the aliasing allowed with <code>UnsafeCell</code>: they are treated like casts to raw pointers, so reborrowing an <code>&amp;Cell&lt;i32&gt;</code> just inherits the tag (and therefore the permissions) of the parent pointer.</p>

<p>More controversially, TB also changes how precisely things become read-only when an <code>&amp;T</code> involves <code>UnsafeCell</code> somewhere inside <code>T</code>.
In particular, for <code>&amp;(i32, Cell&lt;i32&gt;)</code>, TB allows mutating <em>both</em> fields, including the first field which is a regular <code>i32</code>, since it just treats the entire reference as “this allows aliasing”.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>
In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers.</p>

<p>The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB).
This is a deliberate choice to uncover as much of the design space as we can with these two models.
Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates – those were our “lower bounds” for the minimum amount of UB we need.
And it turns out that under these constraints, we can support <code>UnsafeCell</code> with a fairly simple approach: for the aliasing rules of <code>&amp;T</code>, there are only 2 cases.
Either there is no <code>UnsafeCell</code> anywhere, then this reference is read-only, or else the reference allows aliasing.
As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)</p>

<p>I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising.
The good news is that this is far from set in stone: we can <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/403">change TB to treat <code>UnsafeCell</code> more like SB did</a>.
Unlike the previously described differences, this one is entirely independent of our other design choices.
While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like <code>UnsafeCell</code> treatment eventually.</p>

<h2 id="what-about-optimizations">What about optimizations?</h2>

<p>I have written a lot about how TB differs from SB in terms of which coding patterns are UB.
But what about the other side of the coin, the optimizations?
Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations.
And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.
This is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be “immediately unique”.
Given how common of a problem “overeager uniqueness” is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes.
We still have extremely powerful optimization principles around reads, and when the code <em>does</em> perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far.</p>

<p>On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads!
The issue with SB is that if we start with “read mutable reference, then read shared reference”, and then reorder to “read shared reference, then read mutable reference”, then in the new program, reading the shared reference might invalidate the mutable reference – so the reordering might have introduced UB!
This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem.
If it weren’t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.
Meanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only.
This means that “read shared reference, then read mutable reference” is equivalent to “read mutable reference, then read shared reference” and the optimization is saved.
(A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.)</p>

<h2 id="future-possibility-unique">Future possibility: <code>Unique</code></h2>

<p>Tree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to <code>Unique</code>.
<code>Unique</code> is a private type in the Rust standard library that was originally meant to express <code>noalias</code> requirements.
However, it was never actually wired up to emit that attribute on the LLVM level.
<code>Unique</code> is mainly used in two places in the standard library: <code>Box</code> and <code>Vec</code>.
SB (and TB) treat <code>Box</code> special (matching rustc itself), but not <code>Unique</code>, so <code>Vec</code> does not come with any aliasing requirements.
And indeed the SB approach totally does not work for <code>Vec</code>, since we don’t actually know how much memory to make unique here.
However, with TB we have lazy initialization, so we don’t need to commit to a memory range upfront – we can make it unique “when accessed”.
This means we can explore giving meaning to the <code>Unique</code> in <code>Vec</code>.</p>

<p>Now, this might not actually work.
People actually do blatantly-aliasing things with <code>Vec</code>, e.g. to implement arenas.
On the other hand, <code>Vec</code>’s uniqueness would only come in when it is moved or passed <em>by value</em>, and only for the memory ranges that are actually being accessed.
So it is quite possible that this is compatible with arenas.
I think the best way to find out is to implement <code>Unique</code> semantics behind a flag and experiment.
If that works out, we might even be able to remove all special handling of <code>Box</code> and rely on the fact that <code>Box</code> is defined as a newtype over <code>Unique</code>.
This would slightly reduce the optimization potential (<code>Box&lt;T&gt;</code> is known to point to a memory range at least the size of <code>T</code>, whereas <code>Unique</code> has no such information), but making <code>Box</code> less magic is a long-standing quest so this might be an acceptable trade-off.</p>

<p>I should note that there are many people who think neither <code>Box</code> nor <code>Vec</code> should have any aliasing requirements. I think it’s worth first exploring whether we can have aliasing requirements which are sufficiently light-weight that they are compatible with common coding patterns, but even if we end up saying <code>Box</code> and <code>Vec</code> behave like raw pointers, it can still be useful to have <code>Unique</code> in our toolbox and expose it for unsafe code authors to eke out the last bits of performance.</p>

<h2 id="conclusion">Conclusion</h2>

<p>These are the major differences between Stacked Borrows and Tree Borrows.
As you can see, almost all of them are cases where TB allows more code than SB, and indeed TB fixes what I consider to be SB’s two biggest problems: overeager uniqueness for mutable references, and confining references and raw pointers to the size of the type they are created with.
These are great news for unsafe code authors!</p>

<p>What TB <em>doesn’t</em> change is the presence of “protectors” to enforce that certain references remain valid for the duration of an entire function call (whether they are used again or not); protectors are absolutely required to justify the LLVM <code>noalias</code> annotations we would like to emit and they also do enable some stronger optimizations than what would otherwise be possible.
I do expect protectors to be the main remaining source of unexpected UB from Tree Borrows, and I don’t think there is a lot of wiggle-room that we have here, so this might just be a case where we have to tell programmers to adjust their code, and invest in documentation material to make this subtle issue as widely known as possible.</p>

<p>Neven has implemented Tree Borrows in Miri, so you can play around with it and check your own code by setting <code>MIRIFLAGS=-Zmiri-tree-borrows</code>.
If you run into any surprises or concerns, please let us know!
The <a href="https://rust-lang.zulipchat.com/#narrow/stream/136281-t-opsem">t-opsem Zulip</a> and the <a href="https://github.com/rust-lang/unsafe-code-guidelines/">UCG issue tracker</a> are good places for such questions.</p>

<p>That’s all I got, thanks for reading – and a shout out to Neven for doing all the actual work here (and for giving feedback on this blog post), supervising this project has been a lot of fun!
Remember to read <a href="https://perso.crans.org/vanille/treebor/">his write up</a> and <a href="https://www.youtube.com/watch?v=zQ76zLXesxA">watch his talk</a>.</p>





    </article></div>
  </body>
</html>
