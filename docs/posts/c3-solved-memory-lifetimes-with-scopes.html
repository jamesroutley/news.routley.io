<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://c3-lang.org/blog/forget-borrow-checkers-c3-solved-memory-lifetimes-with-scopes/">Original</a>
    <h1>C3 solved memory lifetimes with scopes</h1>
    
    <div id="readability-page-1" class="page"><div id="child_slots">  <p>Modern languages offer a variety of techniques to help with dynamic memory management, each one a different tradeoff in terms of performance, control and complexity. In this post we’ll look at an old idea, memory allocation regions or arenas, implemented via the C3 Temp allocator, which is the new default for C3.</p>
<p>The Temp allocator combines the ease of use of garbage collection with C3’s unique features to give a simple and (semi)-automated solution within a manual memory management language. The Temp allocator helps you avoid memory leaks, improve performance, and simplify code compared to traditional approaches.</p>
<p>Memory allocations come in two broad types <a href="https://en.wikipedia.org/wiki/Stack_register">stack</a> allocations which are compact, efficient and automatic and heap allocations which are much larger and have <a href="https://en.wikipedia.org/wiki/Memory_management">customisable organisation</a>. Custom organisation allows both innovation and footguns in equal measure, let’s explore those.</p>
<h3 id="memory-leaks">Memory Leaks</h3>
<p>When we dynamically allocate memory, with say <code dir="auto">malloc()</code> typically we need to <code dir="auto">free()</code> it afterwards, otherwise we can’t use that memory until the OS process exits. If that memory isn’t being used and it has not been freed this is called a <a href="https://en.wikipedia.org/wiki/Memory_leak">memory leak</a> and can lead to restricting or running out of available system memory.</p>
<h3 id="avoiding-memory-leaks">Avoiding Memory Leaks</h3>
<p>Common solutions are <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>, <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> or <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collection</a> which automatically free those variables.</p>
<p>Each method has different tradeoffs.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> needs classes or structs to manage their own memory cleanup with a lot of extra code.</li>
<li><a href="https://en.wikipedia.org/wiki/Reference_counting">Reference counting</a> counts how many users each memory allocation has, when this hits zero the memory is freed. Reference counting is expensive with multiple CPU cores as we need to synchronise these counts and share information between cores.</li>
<li><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Garbage collection</a> competes with the program for both memory and CPU time, reducing program performance and increasing memory usage.</li>
</ul>
<h3 id="memory-allocation-regions">Memory Allocation Regions</h3>
<p>Memory allocation regions, go by various names: arenas, pools, contexts; The idea dates back to the 1960’s with the IBM OS/360 mainframes having a similar system. Memory regions are efficient for managing many memory allocations and can be freed in a single operation, and are particularly effective when we know the memory will not be needed later. That is, we know the memory’s lifetime. This idea is powerful and used in many applications like web server request handlers or database transactions, as used by the <a href="https://httpd.apache.org/">Apache webserver</a> and the <a href="https://www.postgresql.org/">Postgres database</a>.</p>
<p>Memory allocation regions use a single buffer so have good locality because all the allocations are closely associated together, making it more efficient for CPU access, compared to traditional <code dir="auto">malloc</code> where allocations are spread throughout the heap.</p>
<p>Memory allocation regions may make it easier to manage memory, however you still need to <em>remember</em> to free them, and if you forget to do call free, then that memory will still leak.</p>
<h3 id="enter-the-temp-allocator">Enter The Temp Allocator</h3>
<p>The Temp allocator in C3 is a region based allocator which is <em>automatically</em> reset once execution leaves its scope, so you cannot forget to free the memory and can’t leak memory. The Temp allocator in C3 is a builtin in the standard library, called <code dir="auto">@pool()</code> and using it you can define the scope where the allocated variables are available, for example:</p>
<div><figure><pre data-language="c"><code><div><p><span>fn </span><span>int</span><span> </span><span>example</span><span>(</span><span>int</span><span><span> </span><span>input</span><span>)</span></span></p></div><div><p><span>{</span></p></div><div><p><span><span>    </span></span><span>@</span><span>pool()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// Allocate temp_variable on the heap with Temp allocator</span></p></div><div><p><span>        </span><span>int</span><span>*</span><span> temp_variable </span><span>=</span><span> </span><span>mem::tnew(</span><span>int</span><span>)</span><span>;</span></p></div><div><p><span>        </span><span>*</span><span>temp_variable </span><span>=</span><span> </span><span>56</span><span>;</span></p></div><div><p><span><span>        </span></span><span>input </span><span>=</span><span> input </span><span>+</span><span> temp_variable;</span></p></div><div><p><span>        </span><span>return</span><span> input;</span></p></div><div><p><span><span>    </span></span><span>};</span><span> // Automatically cleanup temp_variable</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn </span><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>int</span><span> result </span><span>=</span><span> </span><span>example(</span><span>1</span><span>)</span><span>;</span></p></div><div><p><span>    </span><span>assert(result </span><span>==</span><span> </span><span>57</span><span>, </span><span>&#34;</span><span>The result should be 57</span><span>&#34;</span><span>)</span><span>;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h3 id="check-with-valgrind">Check With Valgrind</h3>
<p>Valgrind is a tool which detects memory leaks and we can use it to show the temp allocator managed the memory for us automatically.</p>
<div><figure><pre data-language="bash"><code><div><p><span>valgrind</span><span> </span><span>./pool_example</span><span> </span><span>|</span><span>&amp; </span><span>grep</span><span> </span><span>&#34;</span><span>All heap blocks were freed</span><span>&#34;</span></p></div><div><p><span>==129129==</span><span> </span><span>All</span><span> </span><span>heap</span><span> </span><span>blocks</span><span> </span><span>were</span><span> </span><span>freed</span><span> </span><span>--</span><span> </span><span>no</span><span> </span><span>leaks</span><span> </span><span>are</span><span> </span><span>possible</span></p></div></code></pre></figure></div>
<h3 id="success">Success!</h3>
<p>We have relatively performant memory allocations managed automatically without needing <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>, <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collection</a> or <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a>.</p>
<h3 id="controlling-variable-cleanup">Controlling Variable Cleanup</h3>
<p>Normally temp allocated variables are cleaned up at the end of the closest <code dir="auto">@pool</code> scope, but what if you have nested <code dir="auto">@pool</code> and want explicit control over when it’s cleaned up? Simple: assign the temp allocator with the scope you need to a variable, and use it explicitly. The temp allocator in a scope is a global variable called <code dir="auto">tmem</code>.</p>
<div><figure><pre data-language="c"><code><div><p><span>fn String</span><span>*</span><span> </span><span>example</span><span>(</span><span>int</span><span><span> </span><span>input</span><span>)</span></span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// previous global temp allocator from main() scope</span></p></div><div><p><span><span>    </span></span><span>Allocator temp_allocator </span><span>=</span><span> tmem;</span></p></div><div></div><div><p><span><span>    </span></span><span>@</span><span>pool()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// Allocate on the global temp allocator</span></p></div><div><p><span><span>        </span></span><span>String</span><span>*</span><span> returned </span><span>=</span><span> </span><span>allocator::new(temp_allocator, String)</span><span>;</span></p></div><div><p><span>        </span><span>*</span><span>returned </span><span>=</span><span> </span><span>string::format(temp_allocator, </span><span>&#34;</span><span>modified </span><span>%s</span><span>&#34;</span><span>, input)</span><span>;</span></p></div><div><p><span>        </span><span>return</span><span> returned;</span></p></div><div><p><span><span>    </span></span><span>};</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>fn </span><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// top-most temp allocator, tmem created here</span></p></div><div><p><span><span>    </span></span><span>@</span><span>pool()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span><span>        </span></span><span>String</span><span>*</span><span> returned </span><span>=</span><span> </span><span>example(</span><span>42</span><span>)</span><span>;</span></p></div><div><p><span>        </span><span>// &#34;modified 42&#34; string returned</span></p></div><div><p><span>        </span><span>io::printn(</span><span>*</span><span>returned)</span><span>;</span></p></div><div><p><span><span>    </span></span><span>};</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h3 id="a-handy-shorthand">A Handy Shorthand</h3>
<p>We can reduce the code’s nesting using short function declaration syntax <code dir="auto">=&gt;</code> making it even simpler as:</p>
<div><figure><pre data-language="c"><code><div><p><span>fn </span><span>int</span><span> </span><span>example</span><span>(</span><span>int</span><span><span> </span><span>input</span><span>) </span></span><span>=&gt;</span><span> @</span><span>pool</span><span>(reserve: </span><span>2048</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// Allocate temp_variable on the heap</span></p></div><div><p><span>    </span><span>int</span><span>*</span><span> temp_variable </span><span>=</span><span> </span><span>mem::tnew(</span><span>int</span><span>)</span><span>;</span></p></div><div><p><span>    </span><span>*</span><span>temp_variable </span><span>=</span><span> </span><span>56</span><span>;</span></p></div><div><p><span><span>    </span></span><span>input </span><span>=</span><span> input </span><span>+</span><span> </span><span>*</span><span>temp_variable;</span></p></div><div><p><span>    </span><span>return</span><span> input;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h3 id="in-simple-cases-omit-pool">In Simple Cases Omit @pool()</h3>
<p>Happy with the defaults? We can actually omit the <code dir="auto">@pool()</code> in <code dir="auto">main()</code> all together!</p>
<p>The compiler automatically adds a <code dir="auto">@pool()</code> scope to the <code dir="auto">main()</code> function for us, once it finds a temp allocation function like <code dir="auto">mem::tnew()</code>, without an enclosing <code dir="auto">@pool()</code> scope. That simplifies our code to:</p>
<div><figure><pre data-language="c"><code><div><p><span>fn </span><span>int</span><span> </span><span>example</span><span>(</span><span>int</span><span><span> </span><span>input</span><span>)</span></span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// Allocate temp_variable on the heap</span></p></div><div><p><span>    </span><span>// @pool() temp allocator created for us by the compiler</span></p></div><div><p><span>    </span><span>int</span><span>*</span><span> temp_variable </span><span>=</span><span> </span><span>mem::tnew(</span><span>int</span><span>)</span><span>;</span></p></div><div><p><span>    </span><span>*</span><span>temp_variable </span><span>=</span><span> </span><span>56</span><span>;</span></p></div><div><p><span><span>    </span></span><span>input </span><span>=</span><span> input </span><span>+</span><span> </span><span>*</span><span>temp_variable;</span></p></div><div><p><span>    </span><span>return</span><span> input;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h3 id="conclusion">Conclusion</h3>
<p>The Temp allocator has landed in C3; combining scoped compile time known memory lifetimes, ease of use and performance. Tying memory lifetimes to scope and automating cleanup, you get the benefits of manual control without the risks. No more memory leaks, use after free, or slow compile times with complex ownership tracking.</p>
<p>Whether you’re building low-latency systems or just want more explicit code without garbage collection overhead, the C3 Temp allocator is a powerful tool to have in your arsenal, making memory management nearly effortless.</p>
<h3 id="want-to-dive-into-c3">Want To Dive Into C3?</h3>
<p>Check out the <a href="https://c3-lang.org/getting-started">documentation</a> or <a href="https://c3-lang.org/getting-started/prebuilt-binaries">download it and try it out</a>.</p>
<p>Have questions? Come and chat with us on <a href="https://discord.gg/qN76R87">Discord</a>.</p>  <!-- Markdown will be inserted here --> </div></div>
  </body>
</html>
