<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://patrickthebold.github.io/posts/what-color-is-your-monad/">Original</a>
    <h1>What Color Is Your Monad</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>There’s a lovely old blog post <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"><em>What Color is Your Function</em></a> (<em>WCIYF</em>).
If you haven’t read that, please do so instead of reading this one.</p>
<p>Since you are here, you should understand the <em>colored function</em> problem described in that post. I’d like to explore how that problem generalized beyond
async concerns and how it connects to the much bemoaned <em>monad</em>.</p>
<p>You don’t really need to know what a monad is to start reading this post, but you <em>should</em> understand the colored function problem described in the linked post.</p>
<h2 id="recap">Recap</h2>
<p>To recap <em>WCIYF</em>: Red functions are the async ones. If a blue (synchronous) function needs
to be updated to call a red one, the blue one needs to be changed to red, which in turn, causes a <em>proliferation of redness</em>. Also, the red functions
are more painful to call. I’ll mostly be concerned with the <em>proliferation of redness</em>, but we’ll discuss the pain as well.</p>
<p>The author mentions Promises as a mitigation, but ultimately decides using threads (green or os) is a better solution.</p>
<h2 id="thesis">Thesis</h2>
<p>Promises are an example of a monad. There <em>is</em> pain in using them, but I’ll
argue it is worth it: you should just bite the bullet and make everything red.
When everything is red, you don’t have to think about color, and the problem
goes away.</p>
<p>I’ll give a few alternative definitions of “red function”, we will
have roughly the same problem, and the solution will always be some monad.</p>
<h2 id="the-big-reveal">The Big Reveal</h2>
<p>The big reveal in <em>WCIYF</em> is that “Red functions are asynchronous ones”. Consider instead, functions that throw exceptions.
Could we consider those “red”? If you have a function that does not throw (blue) and you need to edit it to call a function that throws, then your function
will also become one that throws, <em>unless</em> you are able to handle the exception. In practice, there will be times where you can handle the exception and times
that you can’t, so the redness really only <em>proliferates</em> when you can’t handle the exception. Catching an exception is the analogue waiting on a promise,
and it’s much more reasonable to have code that handles exceptions than code that waits on promises. Nevertheless, let’s focus on the case where we are <em>not</em> able
to handle the exceptions and so the redness does proliferate like the async case.</p>
<p>Side note: some languages like Java have <em>checked</em> exceptions, in this case you really do need to update you method signatures and explicitly change your blue
function to red by declaring that the exception is thrown. This fits a bit better with the async case since there are actual (mechanical) code changes.
In the unchecked case, all the pain falls on whoever is getting paged because of new exceptions being thrown at runtime.</p>
<h2 id="either">Either</h2>
<p>Exceptions separate the happy path from the sad path, the typical from the atypical, the unexceptional from the exceptional.
They come with their own control flow mechanism as an implementation detail<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p>
<p>As an alternative, many languages or libraries define a type <code>Either&lt;SomeErrorType, DesiredType&gt;</code>,
where you can specify that your function returns one of two things. You have to
choose your preferred error type, which doesn’t matter for this article, so let’s
just say we have chosen “<code>SomeErrorType</code>”.</p>
<p><em>WCIYF</em> explains promises as <em>reifying</em> the concept of passing a callback/errorback. Likewise, <code>Either&lt;SomeErrorType, *&gt;</code> reifies the concept of typical/atypical outcomes.
In both cases, your function now returns a <em>value</em> that represents the control flow, and <em>values</em> tend to be easier to reason about than behaviors.</p>
<h2 id="promises-can-fail">Promises Can Fail</h2>
<p>Side note: In every language I’ve seen, a Promise/Future has a success and failure case built in. So it essentially has <code>Either</code> built into it. I <em>think</em>
this is because languages that have exceptions often have no way of guaranteeing that an exception <em>won’t</em> happen. This feels a lot like languages where anything
<em>could</em> be null. I’d be interested in a language that forces the use of <code>Optional</code>, <code>Either</code> instead of allowing for <code>null</code>, <code>exceptions</code>. Maybe Haskell does this?!</p>
<h2 id="sugar-and-pain">Sugar and Pain</h2>
<p><em>WCIYF</em> sort of admits that promises are less painful than callbacks, but also pooh-poohs them as being a half solution. I just want to point out
that some languages have <code>for expressions</code> (e.g. Scala) or <code>do notation</code> (e.g. Haskell), which further lessens the pain<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. A rough example:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getFriends<span>(</span>userId<span>)</span> <span>=</span> 
  <span>for</span> <span>{</span>
    user <span>&lt;-</span> asyncGetUser<span>(</span>userId<span>)</span>
    friends <span>&lt;-</span> user<span>.</span>friendIds<span>.</span>traverse<span>(</span>asyncGetUser<span>)</span>
  <span>}</span> <span>yield</span> friends
</code></pre></div><p>That’s some made up code to asynchronously get a user from their id and then get all their friends by id. Allow me to repeat the code with the
types specified (typescript style) after all the values:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getFriends<span>(</span>userId<span>)</span><span>:</span> <span>Promise&lt;User</span><span>[]&gt;</span> <span>=</span> 
  <span>for</span> <span>{</span>
    user<span>:</span> <span>User</span> <span>&lt;-</span> <span>asyncGetUser</span><span>(</span><span>userId</span><span>)</span><span>:</span> <span>Promise&lt;User&gt;</span>
    friends<span>:</span> <span>User</span><span>[]</span> <span>&lt;-</span> user<span>.</span>friendIds<span>.</span>traverse<span>(</span>asyncGetUser<span>)</span><span>:</span> <span>Promise&lt;User</span><span>[]&gt;</span>
  <span>}</span> <span>yield</span> friends
</code></pre></div><p>Notice how on the left of the <code>&lt;-</code> we always have <code>T</code> whenever the right is <code>Promise&lt;T&gt;</code>. Also notice the <em>proliferatation</em> of the <code>Promise</code>, <code>getFriends</code> returns a <code>Promise</code> because
<code>asyncGetUser</code> does. <code>.traverse</code> is a a combination of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all</code></a>, and it does the only thing that makes sense for this code.</p>
<p>Now instead, suppose we have <code>syncGetUser</code> which returns <code>Either&lt;SomeErrorType, User&gt;</code>. The code is the same, except the types: <code>Either&lt;SomeErrorType, T&gt;</code> replaces <code>Promise&lt;T&gt;</code> .</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getFriends<span>(</span>userId<span>)</span><span>:</span> <span>Either&lt;SomeErrorType</span><span>,</span> <span>User</span><span>[]&gt;</span> <span>=</span> 
  <span>for</span> <span>{</span>
    user<span>:</span> <span>User</span> <span>&lt;-</span> <span>syncGetUser</span><span>(</span><span>userId</span><span>)</span><span>:</span> <span>Either&lt;SomeErrorType</span><span>,</span> <span>User</span><span>&gt;</span>
    friends<span>:</span> <span>User</span><span>[]</span> <span>&lt;-</span> user<span>.</span>friendIds<span>.</span>traverse<span>(</span>asyncGetUser<span>)</span><span>:</span> <span>Either&lt;SomeErrorType</span><span>,</span> <span>User</span><span>[]&gt;</span>
  <span>}</span> <span>yield</span> friends
</code></pre></div><p>Compare that with the synchronous (blue) case where <code>getUser</code> returns <code>User</code>.</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getFriends<span>(</span>userId<span>)</span> <span>=</span> <span>{</span>
  user <span>=</span> getUser<span>(</span>userId<span>)</span>
  user<span>.</span>friendIds<span>.</span>map<span>(</span>getUser<span>)</span>
<span>}</span>
</code></pre></div><h2 id="another-example">Another Example</h2>
<p>I’ll start with a concrete example: For some context, suppose you have a single page app with micro-services all making http calls sending json to and from the browser and between services.
It’s nice to have a per-request “correlation id” that is included in all the log statements. In order for this to work, the correct id needs to be available
whenever you log something. It also needs to be available whenever you make and http call to another service. So let’s say “red functions” are functions that need to know the correlation id. Given that
we need the id for logging and http calls we expect the redness to quickly proliferate almost everywhere.</p>
<p>The naive<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> thing to do is to add <code>correlationId</code> as a parameter everywhere:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getUser<span>(</span>userId<span>,</span> correlationId<span>)</span> <span>=</span> <span>{</span>
 log<span>.</span>info<span>(</span><span>&#34;getting user&#34;</span><span>,</span> correlationId<span>)</span>
 <span>...</span>
<span>}</span>
</code></pre></div><p>Recall however, that we were able to solve our other problems be returning a value that better represents our needs. So, in this case,
we need to return a value that represents “the need for a correlation id”. For this, we can use a function, i.e.</p>
<p>With this change the signature of <code>getUser</code> is:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getUser<span>(</span>userId<span>)</span><span>:</span> <span>CorrelationId</span> <span>=&gt;</span> <span>User</span>
</code></pre></div><p>We can repeat the same example above without any changes:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getFriends<span>(</span>userId<span>)</span><span>:</span> <span>CorrelationId</span> <span>=&gt;</span> <span>User</span><span>[]</span> <span>=</span> 
  <span>for</span> <span>{</span>
    user<span>:</span> <span>User</span> <span>&lt;-</span> <span>syncGetUser</span><span>(</span><span>userId</span><span>)</span><span>:</span> <span>CorrelationId</span> <span>=&gt;</span> <span>User</span>
    friends<span>:</span> <span>User</span><span>[]</span> <span>&lt;-</span> user<span>.</span>friendIds<span>.</span>traverse<span>(</span>asyncGetUser<span>)</span><span>:</span> <span>CorrelationId</span> <span>=&gt;</span> <span>User</span><span>[]</span>
  <span>}</span> <span>yield</span> friends
</code></pre></div><p>Note that this code doesn’t deal with the correlation Id. (It also didn’t deal with asynchronicity, or errors).</p>
<h3 id="a-pattern-emerges">A Pattern Emerges?</h3>
<p>Now that we’ve written essentially the same code three times, let’s pull out the different part as a variable:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getFriends<span>&lt;</span>F<span>:</span> <span>Monad&gt;</span><span>(</span><span>userId</span><span>)</span><span>:</span> <span>F&lt;User</span><span>[]&gt;</span> <span>=</span> 
  <span>for</span> <span>{</span>
    user<span>:</span> <span>User</span> <span>&lt;-</span> <span>syncGetUser</span><span>(</span><span>userId</span><span>)</span><span>:</span> <span>F&lt;User&gt;</span>
    friends<span>:</span> <span>User</span><span>[]</span> <span>&lt;-</span> user<span>.</span>friendIds<span>.</span>traverse<span>(</span>asyncGetUser<span>)</span><span>:</span> <span>F&lt;User</span><span>[]&gt;</span>
  <span>}</span> <span>yield</span> friends
</code></pre></div><p>Here my method is parameterized by <code>F</code> with the restriction that <code>F</code> is a monad<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> (<code>F: Monad</code>). You can get all the previous examples
by replacing <code>F&lt;*&gt;</code> with <code>Promise&lt;*&gt;</code>, <code>Either&lt;SomeErrorType, *&gt;</code>, or <code>CorrelationId =&gt; *</code>. (The <code>*</code> being the spot where you have to substitute the type you <em>actually</em> care about).</p>
<p>We can even combine things, so <code>F</code> could be <code>CorrelationId =&gt; Promise&lt;*&gt;</code> if <code>getUser</code> needed a <code>CorrelationId</code> <em>and</em> we wanted it to be async.</p>
<h3 id="a-note-on-generics">A Note on Generics</h3>
<p>Many languages have generic types. Take <code>Array&lt;Int&gt;</code>, I’ll refer to <code>Array</code> as the <em>outside</em> and <code>Int</code> as the <em>inside</em>. Often a language will
let you make the inside a variable <code>Array&lt;T&gt;</code> is an array, but I don’t know or care what is inside it. It’s less common to be able to put a variable on the <em>outside</em>.
<code>F&lt;Int&gt;</code> is a bit odd, you don’t really have any idea what it is, there’s only a suggestion that is has something to do with <code>Int</code>. Nevertheless, that is precisely
the thing that changes across our three examples<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p>
<h3 id="generalizing-our-example">Generalizing our Example.</h3>
<p>In our example we needed a <code>CorrelationId</code>, but the same pattern can be used for other things you need, but don’t really want to explicitly pass. For example,
database connections, user session ids, user authorization info. Any time you want something available but don’t really want to pass it around.</p>
<h2 id="one-last-example">One Last Example</h2>
<p>A bug comes in. A number is wrong in the UI. The backend that <em>my</em> team is responsible for really just calls other APIs that other teams are responsible for.
The first thing we’d want to look at
is the request and response we made to these external APIs (after all, we want
to pass the blame as quickly as possible if it’s an upstream error). Now, for
various reasons we didn’t want to log all the requests and responses. So,
for every external API call, we returned the full request/response in addition
to whatever we wanted to. At least, in QA environments.</p>
<p>Consider the following return type:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getUser<span>(</span>userId<span>)</span><span>:</span> <span>[</span><span>DiagnosticData</span><span>[],</span> <span>User</span><span>]</span>
</code></pre></div><p>Here, <code>DiagnosticData</code> is the request/response or anything else we want to also return to help diagnose issues. It’s an array because we need to allow for multiple things coming back.
Then the json coming back to the browser would always be an object and it would contain one extra field with the <code>diagnosticData</code> serialized in the response.</p>
<p>The hope would be that anyone doing QA could copy the json from the dev tools in the browser and any bug ticket would include all of the
API calls we made. Often that’s enough to figure out which team needs to take action.</p>
<p>In this case <code>F</code> is <code>[DiagnosticData[], *]</code> and it <em>proliferates</em> precisely because we need to bubble up the extra data to the controller.</p>
<h2 id="the-value-of-monads">The Value of Monads</h2>
<p>There’s no denying that the blue functions are nicer. The best signature for <code>getUser</code> is</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getUser<span>(</span>userId<span>)</span><span>:</span> <span>User</span>
</code></pre></div><p>But that is not always practical: You often have other <em>cross cutting</em> concerns: resource usage, error handling, code cleanliness, monitoring.
So if, instead, you return:</p>
<div><pre tabindex="0"><code data-lang="scala"><span>def</span> getUser<span>&lt;</span>F<span>&gt;(</span>userId<span>)</span><span>:</span> <span>F</span><span>[</span><span>User</span><span>]</span>
</code></pre></div><p>You are giving yourself a lot of flexibility to not exactly return a <code>User</code>. We saw different examples where we did not exactly return a <code>User</code>. You can even vary <code>F</code> based on context, only return extra data outside of production, or be synchronous<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> in unit tests but async when actually running.</p>
<h2 id="are-you-serious">Are you Serious?</h2>
<p>No, not really. I mean, I think it was fun to think about colored functions and monads, but most languages don’t support these features that make this practical. Also, it’s going to be hard to get your whole team (including future teammates) on board with coding like this. So <em>don’t</em> actually do this.</p>


</div></div>
  </body>
</html>
