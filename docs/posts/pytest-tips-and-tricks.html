<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pythontest.com/pytest-tips-tricks/">Original</a>
    <h1>Pytest Tips and Tricks</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is a set of tips/tricks for learning and using pytest.</p>
<p>Note: I’m not numbering these, because I don’t want to keep track of order. Also, this is more of a brain dump, and not a prioritized list.</p>
<p>Special thanks to Michael Kennedy for prodding me into making this, and contributing to the initial list.</p>
<h2 id="general-tips">General tips</h2>
<ul>
<li>pytest is really easy to use simply, but don’t stop there.
<ul>
<li>“Write test modules and functions starting with <code>test_</code> and use <code>assert</code>” is about all you need to know to get started.</li>
<li>It doesn’t take a lot of study to get tons more power out of pytest</li>
<li>The <a href="https://training.talkpython.fm/courses/getting-started-with-testing-in-python-using-pytest">pytest course</a> is a few hours.</li>
<li>The <a href="https://pythontest.com/pytest-book/">pytest book</a> can be read in a weekend, easily.</li>
<li>Especially with teams, the book or course can provide common context about what you all know.</li>
</ul>
</li>
<li>pytest has a lot of power
<ul>
<li>Don’t try to use it all at once.</li>
</ul>
</li>
<li>Keep tests simple
<ul>
<li>add fixtures, parametrization, etc as necessary</li>
</ul>
</li>
<li>Remember <code>--help</code>.
<ul>
<li>It expands to include plugin help and your own extensions.</li>
<li>The starter default list is online under <a href="https://docs.pytest.org/en/latest/reference/reference.html#command-line-flags">Command-line Flags</a></li>
</ul>
</li>
<li>pytest reference pages are darned good.
<ul>
<li><a href="https://docs.pytest.org/en/latest/reference/reference.html">API reference</a></li>
<li><a href="https://docs.pytest.org/en/latest/reference/fixtures.html">Fixture reference</a></li>
</ul>
</li>
</ul>
<h2 id="structuring-test-functions">Structuring test functions</h2>
<ul>
<li>Arrange/Act/Assert or Given/When/Then are great templates for most of your tests.
<ul>
<li>The best “template” is just:</li>
</ul>
<div><pre><code data-lang="python"><span>def</span> <span>test_something</span>():
    <span># get stuff ready for action</span>
    <span>...</span>
    <span># do action</span>
    <span>...</span>
    <span># assert the acction worked</span>
    <span>...</span>
</code></pre></div></li>
<li>Workflow tests with interleaved assertions aren’t evil
<ul>
<li>They’re just trickier to deal with.</li>
</ul>
</li>
</ul>
<h2 id="structuring-a-test-suite">Structuring a test suite</h2>
<ul>
<li>Utilize a directory structure to match how you like to run your code.
<ul>
<li>Because running a full subdirectory is easy.</li>
<li>I like to separate into functionality and features.</li>
<li>Some people like test structures based on subsystems.</li>
<li>Some based on the code structure.</li>
</ul>
</li>
<li>You can also use <code>-k sometext</code> to filter directories or classes or test prefixes.
<ul>
<li><code>-k</code> has logic. Examples:
<ul>
<li><code>-k &#34;sometext and not othertext&#34;</code></li>
<li><code>-k &#34;(this or that) and not unwanted&#34;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fixtures">Fixtures</h2>
<ul>
<li>Use <code>--fixtures</code>.
<ul>
<li>It lists available fixtures, their scope, and where they’re defined.</li>
<li>You can specify a directory, file, or even class or function to find out fixtures available to just that bit of code.</li>
</ul>
</li>
<li>Move complex setup into fixtures, especially when re-usable for other tests.</li>
<li>Use <code>yield</code> to separate setup and teardown.</li>
<li>The setup and teardown sections can be empty.</li>
<li>Beware <code>addfinalizer()</code>.
<ul>
<li>It’s still supported, but will confuse people.</li>
</ul>
</li>
<li>Leverage fixture scopes to improve performance.
<ul>
<li>Ex:
<ul>
<li>session scope for setting up a resource</li>
<li>function scope for setting resource to known state</li>
</ul>
</li>
</ul>
</li>
<li>Share fixtures between test modules/directories with conftest.py files.</li>
</ul>
<h2 id="built-in-fixtures">Built in fixtures</h2>
<ul>
<li><a href="https://docs.pytest.org/en/latest/reference/fixtures.html">Fixtures reference</a></li>
<li>There’s a few that everyone will eventually use.
<ul>
<li><code>tmp_path</code> - Provide a pathlib.Path object to a temporary directory which is unique to each test function.</li>
<li><code>tmp_path_factory</code> - Make session-scoped temporary directories and return pathlib.Path objects.
<ul>
<li>use <code>tmp_path</code>/<code>tmp_path_factory</code> instead of <code>tmpdir</code>/<code>tmpdir_factory</code>.
<ul>
<li>The path versions are <code>pathlib.Path</code> objects.</li>
<li>The dir versions are <code>py.path.local</code> objects, a legacy type.</li>
</ul>
</li>
</ul>
</li>
<li><code>capsys</code> - to check stdout/stderr and to disable capturing.</li>
<li><code>monkeypatch</code> - Temporarily modify classes, functions, dictionaries, os.environ, and other objects.</li>
<li><code>pytestconfig</code> - Access configuration values and command line flags.</li>
<li><code>request</code> - Provide information on the executing test function.
<ul>
<li><code>request.node.name</code> is the test function name.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="markers">Markers</h2>
<ul>
<li>Use your own <code>@pytest.mark.foo</code> custom markers to group tests or selectively disable tests or lots of other fun tricks.
<ul>
<li>But don’t go too crazy with this.</li>
<li>Remember to register markers in <code>pytest.ini</code> file.</li>
<li>Run with <code>--strict-markers</code> to turn marker typos (unregistered markers) into errors.</li>
</ul>
</li>
<li>You can mark all tests in a file with <code>pytestmark</code>
<div><pre><code data-lang="python"><span>import</span> pytest
pytestmark <span>=</span> pytest<span>.</span>mark<span>.</span>foo
</code></pre></div><ul>
<li>or multiples</li>
</ul>
<div><pre><code data-lang="python"><span>import</span> pytest
pytestmark <span>=</span> [pytest<span>.</span>mark<span>.</span>foo, pytest<span>.</span>mark<span>.</span>bar, pytest<span>.</span>mark<span>.</span>baz]
</code></pre></div></li>
<li>Use <code>--markers</code> to see available markers.</li>
<li>Play with built-in markers <code>skip</code>, <code>skipif</code>, and <code>xfail</code>.
<ul>
<li>they are useful when you need them.</li>
</ul>
</li>
<li><code>xfail</code>
<ul>
<li><code>xfail</code> results in either xpass or xfail if non-strict.
<ul>
<li>fail or xfail if strict</li>
</ul>
</li>
<li>strict can be set at decorator or globally in pytes.ini</li>
<li>You can set <code>xfail_strict = True</code> in pytest.ini to turn all <code>xpass</code> results into failures.</li>
<li>Use <code>xfail_strict</code>.</li>
<li>Link a defect number to the reason.</li>
<li>Use <code>-ra</code>, or at least <code>-rxX</code> to see reasons.
<ul>
<li>But really, just use <code>-ra</code> to see all non-passing reasons.</li>
</ul>
</li>
<li><code>--runxfail</code> basically ignores <code>xfail</code> marks.
<ul>
<li>Very useful for final stages of pre-production testing.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="parametrization">Parametrization</h2>
<ul>
<li>Learn parametrization and when to use it effectively.</li>
<li>When you find yourself using “copy/paste/modify” to create new test cases, parametrization may be called for.</li>
<li>Prefer function parametrization.</li>
<li>Use fixture parametrization if work per parameter is needed.</li>
<li>Use <code>pytest_generate_tests</code> based parametrization when you absolutely know it’s the only way to solve your needs.</li>
<li>Utilize <code>ids</code> functions to get more human readable parametrized test cases.</li>
<li>Parameters can be marked.</li>
</ul>
<h2 id="plugins">Plugins</h2>
<ul>
<li>Plugins are awesome.
<ul>
<li>Search for <code>pytest-</code> at <a href="https://pypi.org/search/?q=pytest-">pypi.org</a></li>
<li>There’s also list updated regularly at <a href="https://docs.pytest.org/en/latest/reference/plugin_list.html#plugin-list">pytest.org</a></li>
</ul>
</li>
<li>Writing your own plugins isn’t too hard, but can be confusing at first.
<ul>
<li>pytest.org has a <a href="https://docs.pytest.org/en/latest/how-to/writing_plugins.html">tutorial</a></li>
<li>The <a href="https://pythontest.com/book">pytest book</a> has a chapter on it.</li>
<li>I’m talking about the process during a talk at PyCascades:
<ul>
<li><a href="https://pythontest.com/pycascades-2023/">Sharing is caring - Sharing pytest Fixtures</a></li>
</ul>
</li>
<li>I’m planning a mini-course around it, not recorded yet.</li>
<li>The complicated bits
<ul>
<li>Testing your plugin - see pytester or book or talk.</li>
<li>Packaging - same woes as the rest of Python, plus remember the pytest entry point, noted in the pytest.org tutorial, book, talk, etc.</li>
</ul>
</li>
<li>But seriously, it’s not that bad. :)</li>
</ul>
</li>
<li>Some of my favorites:
<ul>
<li><a href="https://pypi.org/project/pytest-cov/">pytest-cov</a> - Run coverage with tests</li>
<li><a href="https://pypi.org/project/pytest-xdist">pytest-xdist</a> - Run tests in parallel</li>
</ul>
</li>
<li>A few by me
<ul>
<li>More useful:
<ul>
<li><a href="https://pypi.org/project/pytest-check/">pytest-check</a> - Allows multiple failures per test.</li>
<li><a href="https://pypi.org/project/pytest-skip-slow/">pytest-skip-slow</a> - Skip <code>@pytest.mark.slow</code> tests by default.
<ul>
<li>written as a demo for <a href="https://pythontest.com/book">Python Testing with pytest, 2nd edition</a></li>
</ul>
</li>
<li><a href="https://pypi.org/project/pytest-runtime-xfail/">pytest-runtime-xfail</a> - Call runtime_xfail() to mark running test as xfail.</li>
</ul>
</li>
<li>More for fun:
<ul>
<li><a href="https://pypi.org/project/pytest-crayons">pytest-crayons</a> - Colorful print statements
<ul>
<li>written as a demo for building pytest plugins for PyCascades 2023</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="configuration">Configuration</h2>
<ul>
<li>You should have a config file, either <code>pytest.ini</code>, or <code>tox.ini</code>, <code>pyproject.toml</code>, <code>setup.cfg</code> with a pytest section.
<ul>
<li>The config file determines the root for testing.</li>
<li>Stick it at the topmost point you’re likely to every run pytest from.</li>
<li>See <a href="https://docs.pytest.org/en/latest/reference/customize.html">Configuration</a> for more info</li>
</ul>
</li>
<li>I put this in almost every project:
<div><pre><code data-lang="ini"><span>addopts</span> <span>=</span><span>
</span><span>    --strict-markers
</span><span>    --strict-config
</span><span>    -ra</span>
</code></pre></div></li>
<li>Book mark the reference to config options: <a href="https://docs.pytest.org/en/latest/reference/reference.html#configuration-options">Configuration Options</a></li>
</ul>
<h2 id="debugging">Debugging</h2>
<ul>
<li>Great debugging flags:
<ul>
<li><code>-s</code> - turn off output capture</li>
<li><code>-v</code> - verbose</li>
<li><code>-vv</code> - more verbose</li>
<li><code>--tb</code> - traceback style: auto/long/short/line/native/no
<ul>
<li>I like <code>--tb=short</code> for default setting in config file, then others for debugging.</li>
</ul>
</li>
<li><code>-x</code> - stop on first failure</li>
<li><code>--lf</code> - run the last failed tests</li>
<li><code>--ff</code> - failed first. Start with the failures, then run everything</li>
<li><code>--nf</code> - run new test files first, then the rest sorted by file modification time</li>
<li><code>--sw</code> - run last failed, then stop on first failure, then next time continue from last failing.
<ul>
<li>kinda like combining <code>--lf -x</code> but even cooler.</li>
</ul>
</li>
<li><code>--sw-skip</code> - just like above, but skip one failed test.</li>
<li><code>--pdb</code> - start Python debugger on error.
<ul>
<li>Super useful for debugging with tox.</li>
</ul>
</li>
</ul>
</li>
</ul>


  </div></div>
  </body>
</html>
