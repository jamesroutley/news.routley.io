<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hazyresearch.stanford.edu/blog/2023-07-25-m2-bert">Original</a>
    <h1>How to scale LLMs better with an alternative to transformers</h1>
    
    <div id="readability-page-1" class="page"><div><figure><img src="https://hazyresearch.stanford.edu/static/posts/2023-07-25-m2-bert/m2-bert-logo.png"/></figure>
<p><a href="https://github.com/HazyResearch/m2">Code</a> | Checkpoints <a href="https://huggingface.co/danfu09/m2-bert-80M">80M</a>, <a href="https://huggingface.co/danfu09/m2-bert-110M">110M</a> | arXiv coming soon! | <a href="#ack">Full Author List</a></p>
<p>Over the past six years, we’ve seen Transformers take the world by storm. Transformers have been the workhorse architecture behind modern foundation models and have seen impressive empirical success across diverse applications – from pretrained language models like <a href="https://arxiv.org/abs/1810.04805">BERT</a>, <a href="https://chat.openai.com/">ChatGPT</a>, and <a href="https://arxiv.org/abs/2210.11416">Flan-T5</a>, to image models like <a href="https://arxiv.org/abs/2304.02643">SAM</a> and <a href="https://arxiv.org/abs/2112.10752">stable diffusion</a>. We think Transformers are great (and have had lots of fun <a href="https://arxiv.org/abs/2205.14135">optimizing</a> <a href="https://crfm.stanford.edu/2023/07/17/flash2.html">them</a>), but we’ve also been thinking about a deeper <a href="https://hazyresearch.stanford.edu/blog/2023-03-23-ai-everywhere">question</a>:</p>
<blockquote>
<p><em>Are Transformers the only way to get this amazing performance?</em></p>
</blockquote>
<p>Now, the first reason we’ve been poking around at this is because it’s really interesting! Diving into the inner workings of the architectures could help us understand what makes our current generation of models really tick and learn how to train or use them better. And we’ve been really excited by a lot of the work looking into new architectures, from <a href="https://arxiv.org/abs/2111.00396">S4</a> to <a href="https://arxiv.org/abs/2212.10544">BiGS</a>, <a href="https://arxiv.org/abs/2209.10655">Mega</a>, <a href="https://arxiv.org/abs/2209.12951">Liquid</a>, and more. It’s great to live in a world where there are so many great ideas!</p>
<p>But we’re also interested in this question for some core efficiency reasons. Ideally, an alternative to Transformers would scale more efficiently while still matching in quality. One strong motivation for us has been scaling in sequence length – hence the line of work in our lab looking into replacing attention with a sub-quadratic operator (<a href="https://arxiv.org/abs/2111.00396">S4</a>, <a href="https://arxiv.org/abs/2212.14052">H3</a>, <a href="https://arxiv.org/abs/2302.10866">Hyena</a>, <a href="https://arxiv.org/abs/2306.15794">HyenaDNA</a>). And we’re encouraged by the groundswell of work into new architectures for long sequences, from <a href="https://arxiv.org/abs/2307.08621">RetNet</a> to <a href="https://arxiv.org/abs/2305.13048">RWKV</a>, and <a href="https://arxiv.org/abs/2306.15595">positional interpolation</a> – just to name a few!</p>
<p>MLPs – the other core building block of Transformers – also introduce an efficiency bottleneck, which becomes more acute as we continue to optimize attention. MLPs are quadratic in the model width, which means they grow more expensive as you make models wider. This is why models like GPT-3 are so expensive, and why GPT-4 has allegedly started using techniques like mixtures of experts.</p>
<blockquote>
<p><em>What if there were a model that were sub-quadratic along both sequence length and model dimension, and could match Transformers in quality?</em></p>
</blockquote>
<p>Today we’re excited to present a little teaser of some work in this direction – Monarch Mixer BERT (M2-BERT). M2-BERT is sub-quadratic in sequence length and model dimension, has 25% fewer parameters/FLOPs than BERT, and matches in quality (potentially exceeding a little bit when parameter-matched). We’re still very early days, so come talk to us if you find these questions exciting! And if you’re reading this the week of release, we’ll be at ICML – come find us in Hawaii, we’ll be putting up a poster at the <a href="https://es-fomo.com/">ES-FoMo</a> workshop!</p>
<p>This blog post highlights a small portion of the Monarch Mixer line of work. Full arXiv coming soon, and this would not have been possible without the <a href="#ack">full team</a>!</p>

<p>Our basic idea is to replace the major elements of a Transformer with Monarch matrices — which are a class of structured matrices that generalize the FFT and are sub-quadratic, hardware-efficient, and expressive. A key property of Monarch matrices is that they can be computed using a series of <em>block-diagonal</em> matrices, interleaved with permutations:</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2023-07-25-m2-bert/m2-diagram.png"/></figure>
<p>In Monarch Mixer (M2), we use layers built up from Monarch matrices to do both mixing across the sequence (what attention does in Transformers) and mixing across the model dimension (what the MLP does in Transformers). This is similar in spirit to great work like <a href="https://arxiv.org/abs/2105.01601">MLP Mixer</a> and <a href="https://arxiv.org/abs/2201.09792">ConvMixer</a>, which similarly replaced everything with a single primitive for vision tasks (but went for quadratic primitives).</p>
<p>Why go for a fully sub-quadratic architecture now? We’re continuing off a recent line of work in our lab (<a href="https://arxiv.org/abs/2212.10544">and</a> <a href="https://arxiv.org/abs/2206.13947">elsewhere</a>) that replaces attention with long convolutions – which is implemented efficiently with the FFT. Critically, Monarch matrices can implement the FFT – which gives us hope that a fully Monarch-based architecture can get there.</p>

<p>As a first proof-of-concept of our ideas, we’re going to roll the clock back to 2018, and look at one of the first big applications of pretrained Transformers – language modeling with BERT! Despite its (relative) age, BERT is still a workhorse model for applications such as text classification, retrieval, search, and more (see <a href="https://sayanchak.medium.com/practical-uses-of-bert-c384ae3a5c2a">this</a> great summary – and this great <a href="https://twitter.com/marktenenholtz/status/1682436003158433816">tweet</a> on why we love BERT).</p>
<p>For our model, we’ll replace the attention block with a layer inspired by previous work in attention-free models (<a href="https://arxiv.org/abs/2212.14052">H3</a> &amp; <a href="https://arxiv.org/abs/2302.10866">Hyena</a>), and replace the fully-connected layers in the MLP with some simple block-diagonal matrices. All of these operations can be implemented with Monarchs, and the rest is standard stuff like element-wise multiplication, and simple pointwise operators.</p>
<p>Our sequence mixer block builds off H3 and Hyena. Our <a href="https://hazyresearch.stanford.edu/blog/2023-01-20-h3">previous</a> <a href="https://hazyresearch.stanford.edu/blog/2023-03-07-hyena">blogs</a> give some intuition about what the architecture is doing – in brief, the short convolutions allow the model to do a quick lookup of nearby tokens, while the long convolutions allow global information to pass over the sequence.</p>
<figure><img src="https://hazyresearch.stanford.edu/static/posts/2023-07-25-m2-bert/m2-arch.png"/></figure>
<p>The deltas between our sequence mixer the original H3/Hyena layer are a bit interesting, so we’ll go over them briefly:</p>
<ul>
<li><strong>FFT -&gt; Monarch:</strong> in H3 and Hyena, the long convs are computed using the FFT, e.g. <code>iFFT(FFT(x) * FFT(k))</code>. In M2-BERT, we compute these FFTs with Monarchs!</li>
<li><strong>Causal vs. bidirectional:</strong> in H3 and Hyena, the long convs are <em>causal</em> (for the autoregressive language modeling loss). This is done by padding the inputs of the FFTs with zeros, since the FFT implements a <a href="https://en.wikipedia.org/wiki/Convolution_theorem">circular</a> convolution. In M2-BERT, we make the convolutions <em>non-causal</em> by making the convolution kernel twice the length of the input, which makes the weights wrap around.</li>
<li><strong>Convolution kernel:</strong> For the actual kernels <code>k</code>, we use a CKConv parameterization with an exponential, similar to Hyena! In our bidirectional setup, this makes the convolution kernels focus on nearby tokens in the input.</li>
<li><strong>Extra convolution connection:</strong> for BERT, we found that adding an extra convolution (a “residual” so to speak) improved performance on synthetic tasks and pretraining loss.</li>
<li><strong>Average pooling in fine-tuning:</strong> Transformer-based BERT models are traditionally fine-tuned using the embedding of the CLS token. We find that taking the average pool of the embeddings in the input can work a bit better for M2-BERT on downstream tasks that require comparing information spread across multiple sentences such as GLUE NLI tasks (one intuition is that the convolutions spread the information across more tokens).</li>
</ul>
<p>Lastly, the dimension mixer looks a lot like a normal MLP with GLU, but replaces the fully-connected layers with block-diagonal layers – which drastically reduces the parameters and makes the model more efficient!</p>
<p>So then the natural questions are – given the drastic parameter reduction, how does quality compare to a standard BERT model, and how much faster is it?</p>

<p>So our first evaluation was pretraining some M2-BERT models and comparing their downstream GLUE scores after fine-tuning.</p>
<p>When we take our M2-BERT models with the same model width and depth as a standard BERT model, we get some pretty decent parameter savings – M2-BERT-base with 12 layers and model with 768 has 80M parameters, compared to a standard BERT-base of 110M parameters. We pretrained M2-BERT-base (80M) on 36.5B tokens of C4, at sequence length 128, as well as an M2-BERT parameter-matched to BERT-base.</p>
<p>Surprisingly, we can get pretty decent results, even with fewer parameters – M2-BERT-base (80M) matching the original BERT-base scores from Devlin 2018 BERT, and the parameter-matched M2-BERT-base sees further lift (see the end of the blog post for full numbers):</p>
<table><thead><tr><th><strong>Model</strong></th><th>Average GLUE Score</th></tr></thead><tbody><tr><td>BERT-base (110M)</td><td>79.6</td></tr><tr><td>Crammed BERT-base (110M)</td><td>79.1</td></tr><tr><td>M2-BERT-base (80M)</td><td>79.9</td></tr><tr><td>M2-BERT-base (110M)</td><td><strong>80.9</strong></td></tr></tbody></table>
<p>There’s still a lot we don’t know about these models, so quality could get even better. We mostly took standard Transformer BERT-base hyperparameters, besides some basic hyperparameter sweeps on fine-tuning. The Transformer hyperparameters have been optimized by the community in tons of ways over the past five years, so there’s a lot still to learn about what the best hyperparameters and training formulae are for M2 (e.g., we observed up to half-point swings in average GLUE score during our sweeps). And there’s been great work in the community about exactly how much gating you need for different tasks (e.g., <a href="https://arxiv.org/abs/2212.10544">BiGS, section 7.2</a>, so lots more to explore here).</p>

<p>So what does this new architecture buy us? One possibility is speed, and scaling to longer sequences. Since M2 is sub-quadratic in model dimension, we see a FLOP reduction (which is reflected in the lower parameter count). But the sequence mixer is also sub-quadratic in sequence length, which means the potential to scale to longer sequences.</p>
<p>We’ll be exploring long-sequence M2-BERT models more in-depth in the coming weeks, but for now here’s a simple preview of throughput at different sequence lengths, compared to the HuggingFace BERT-base and a more optimized FlashAttention BERT-base, for various sequence lengths. Here, we’re looking at throughput in terms of tokens/ms, on a single A100.</p>
<table><thead><tr><th>Model</th><th>512</th><th>1024</th><th>2048</th></tr></thead><tbody><tr><td>HF BERT-base (110M)</td><td>206.5</td><td>130.8</td><td>71.3</td></tr><tr><td>FlashAttention BERT-base (110M)</td><td>380.7</td><td>359.7</td><td>265.3</td></tr><tr><td>M2-BERT-base (80M)</td><td><strong>386.3</strong></td><td><strong>380.7</strong></td><td><strong>378.9</strong></td></tr></tbody></table>
<p>Today we’re releasing two initial M2-BERT checkpoints pretrained on short sequences, but M2-BERT has the potential to scale to much longer sequences. We’ve started using these scaling properties to experiment with data recipes for long-sequence M2-BERT’s – stay tuned!</p>

<ul>
<li>We are releasing code for BERT and checkpoints for 80M and 110M models today, pretrained using a standard recipe at sequence length 128 – stay tuned for longer sequences! Check out our <a href="https://github.com/HazyResearch/m2">code</a> and checkpoints (<a href="https://huggingface.co/danfu09/m2-bert-80M">80M</a>, <a href="https://huggingface.co/danfu09/m2-bert-110M">110M</a>).</li>
<li>In the coming weeks, watch out for further releases, as we train up long-sequence BERT’s and start tracing the history of Transformers forward – on ImageNet, causal language modeling, T5-style models, as well as explorations of the long sequence capabilities</li>
<li>As part of this release, you’ll find some optimized CUDA code for the forward pass of the M2 layer (which we used for the benchmarks) – we’ll continue to optimize and release updates over the coming weeks. Expect another series of blogs and materials on these soon as we explore the computational tradeoff space!</li>
<li>And of course, full arXiv coming soon!</li>
</ul>

<p>This work would not have been possible without the full Monarch Mixer team!</p>
<p>Full author list: <a href="https://www.danfu.org/">Daniel Y. Fu</a>, <a href="https://arorasimran.com/">Simran Arora</a>*, <a href="https://sabrieyuboglu.com/">Sabri Eyuboglu</a>*, <a href="https://jessicagrogan.github.io/">Jessica Grogan</a>*, <a href="https://cse.buffalo.edu/~isysjohn/">Isys Johnson</a>*, <a href="https://athms.me/">Armin W. Thomas</a>*, <a href="https://benjaminfspector.com/">Benjamin F. Spector</a>, <a href="https://zymrael.github.io/">Michael Poli</a>, <a href="https://cse.buffalo.edu/faculty/atri/">Atri Rudra</a>, <a href="https://cs.stanford.edu/~chrismre/">Christopher Ré</a>.</p>
<p>This research was conducted with the support of Together AI and would not have been possible without them – thank you! Check out the Together’s blog post about their mission to support the world’s best open source models <a href="https://together.ai/blog/monarch-mixer">here</a>.</p>

<table><thead><tr><th></th><th>M2-BERT, 80M</th><th>M2-BERT, 110M</th></tr></thead><tbody><tr><td>MNLI</td><td>78.4 / 78.6 (78.5)</td><td>(79.6 / 80.5) 80.1</td></tr><tr><td>RTE</td><td>68.5</td><td>69.3</td></tr><tr><td>QNLI</td><td>84.6</td><td>86.0</td></tr><tr><td>QQP</td><td>86.7</td><td>87.0</td></tr><tr><td>SST2</td><td>92.0</td><td>92.3</td></tr><tr><td>STS-B</td><td>86.3</td><td>86.9</td></tr><tr><td>CoLA</td><td>53.0</td><td>56.0</td></tr><tr><td>MRPC</td><td>89.8</td><td>89.2</td></tr><tr><td><strong>Average</strong></td><td><strong>79.9</strong></td><td><strong>80.9</strong></td></tr></tbody></table></div></div>
  </body>
</html>
