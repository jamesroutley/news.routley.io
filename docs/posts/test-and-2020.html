<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jmmv.dev/2020/03/test-bracket.html">Original</a>
    <h1>Test, [, and [[ (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><p>Did you know that Unix systems have a binary whose name is a single symbol?</p><p>Go and look for it. Run <code>ls /bin/?</code> and behold:</p><pre tabindex="0"><code>$ ls /bin/?
/bin/[
</code></pre><p>Uh huh. <code>[</code>? The square bracket? That’s a program?!</p><p>But wait, it gets more interesting:</p><pre tabindex="0"><code>$ ls -li /bin/[ /bin/test
834 -rwxr-xr-x  2 root  wheel  35824 Jan 23 08:59 /bin/[
834 -rwxr-xr-x  2 root  wheel  35824 Jan 23 08:59 /bin/test
</code></pre><p>The two names, <code>[</code> and <code>test</code>, point to the same binary<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. But why? What are these?</p><p>The <code>test</code> program is what you use in the shell to evaluate an expression. You can use this to compare strings, compare numbers, and to check various conditions on files. If you have written a shell script—any shell script really—you certainly have used either of these variants.</p><p>The way this works is simple: the <code>test</code> program takes a bunch of arguments, evaluates the expression represented by them, and returns 0 if the expression is true or 1 if it is false. This then lets you do things like:</p><pre tabindex="0"><code>if test a = b; then
    echo &#34;The two strings were the same! Oops!&#34;
fi
</code></pre><p>So why do we have two names for this helper tool? I haven’t been able to find the definitive answer, but my guess is simply: because the above “looks ugly”, and the “obvious” solution to make it look nicer is to introduce <code>[</code> as a command. With it, you can express the same logic from above as:</p><pre tabindex="0"><code>if [ a = b ]; then
    echo &#34;The two strings were the same! Oops!&#34;
fi
</code></pre><p>Yup. Exact same code as above. The only difference here is that the <code>test</code> binary checks its <code>argv[0]</code> to see if it’s invoked as <code>test</code> or as <code>[</code>. If the invocation happens to use the latter, then the program ensures that the last argument is the matching <code>]</code> to keep things balanced.</p><p>With that, you can deduce that you don’t even need the conditional statement to use either of these commands and see what’s going on:</p><pre tabindex="0"><code>$ test a = a; echo $?
0
$ test a = b; echo $?
1
$ [ a = a ]; echo $?
0
$ [ a = b ]; echo $?
1
</code></pre><p>That’s right. The <code>if</code> statement we used in the previous examples just takes <em>a command</em> as its argument and runs it to get its exit code. (And with this, you can “guess” that <code>true</code> and <code>false</code> are… yup, yup… also helper binaries.)</p><p>To make things more confusing, though, pay attention to the following:</p><pre tabindex="0"><code>$ /bin/test a b
test: a: unexpected operator
$ test a b
dash: 2: test: a: unexpected operator
</code></pre><p>Why did we get different outputs there? Well… as it so happens, <code>test</code> and <code>[</code> appear <em>a lot</em> in shell scripts. Invoking them as separate binaries would be very inefficient, so the vast majority of the shells implement these commands as built-ins <em>too</em>. You may get different behavior depending on whether you run the external binary or the builtin, which means you easily get different behavior across different shells. (And that’s true for many other things like the innocent-looking <code>echo</code>.)</p><hr/><p>So what about <code>[[</code>? This is <a href="https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html#index-_005b_005b">a Bash extension</a> and replaces the use of <code>[</code>. The key difference, however, is that <code>[[</code> is <em>guaranteed</em> to be a builtin and therefore it can change, and it does change, the fundamental rules of the language within the expression it evaluates. To illustrate this, let’s look at an example with globs:</p><pre tabindex="0"><code>$ touch long-name
$ [ long* = long-name ] &amp;&amp; echo match
match
$ [[ long* = long-name ]] &amp;&amp; echo match
</code></pre><p>The first command shown here is an invocation of the <code>[</code> tool, which may or may not be a builtin. No matter what, all arguments are subject to the regular shell expansion rules, so <code>long*</code> is matched against the directory contents, is then expanded to <code>long-name</code>, and thus the test succeeds. But, in contrast, <code>[[</code> produces a different result because it treats the <code>long*</code> as a literal string, so all this is doing is comparing <code>long*</code> against <code>long-name</code> verbatim, and therefore failing.</p><p>What should you use, then? If you are writing a portable shell script (please do), then stick to <code>[</code>. You can also use <code>test</code>, but I don’t think that’s too common. But if you know your script is going to be Bash-specific anyway, you are probably better served by using <code>[[</code> unconditionally and consistently, as it provides a lot of nice features (like regular expression matches via <code>=~</code>).</p><hr/><p>And now for the final lolz. I’ve said above that these are the commands you use to evaluate expressions… but the shell <em>also</em> has expressions of its own via the <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code> operators—all of which work on command exit statuses. That is:</p><pre tabindex="0"><code>$ grep ^hello$ /usr/share/dict/words &amp;&amp; grep ^bye$ /usr/share/dict/words
hello
bye
$ echo $?
0
$ grep ^tyop$ /usr/share/dict/words &amp;&amp; grep ^bye$ /usr/share/dict/words
$ echo $?
1
</code></pre><p>Which means… that you can combine <code>test</code> expressions and shell expressions in one invocation:</p><pre tabindex="0"><code>if [ a = b ] || grep -q ^hello$ /usr/share/dict/words; then
  echo &#34;test failed and grep succeeded&#34;
fi
</code></pre><p>You pick whether to be amused or horrified. I don’t know how exactly my coworker reacted when I hinted at this during a recent code review I did for them.</p></article></div></div></div>
  </body>
</html>
