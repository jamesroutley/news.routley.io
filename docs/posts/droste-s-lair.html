<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vezwork.github.io/drostes-lair-post/">Original</a>
    <h1>Droste’s Lair</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <p>
        Droste&#39;s Lair is an unusual programming environment for
        building and counting mathematical structures, built in a
        two-week sprint. In Droste&#39;s Lair, the user manipulates
        mathematical structures through direct interactions: dropping
        dominoes on chessboards and dragging items between lists. The
        system&#39;s power comes from two forms of abstraction on top of
        this foundation: an &#34;amb&#34; mechanism that allows strands of
        execution to branch from one another, and a procedure-calling
        mechanism that enables recursion.
      </p>
      <p>
        Also, Droste&#39;s Lair is a swords-and-sorcery-style
        point-and-click adventure game. (Sort of.)
      </p>
      
      <h2>Walkthrough</h2>
      <p>
        To get you up to speed with the gameplay of Droste&#39;s Lair,
        we&#39;ll take you on three quick jaunts into the caverns. We
        invite you to join us on this walkthrough – links to the game
        are available at the top and bottom of each journey so you can
        play along from the beginning or jump to the conclusion.
      </p>
      <p>
        The lair is a work in progress. If something feels confusing,
        it&#39;s not you, it&#39;s us.
      </p>
      <p>
        Pan by scrolling, dragging the background, or moving the
        cursor with shift held. Undo is available with ctrl-z. Powers
        beyond these will be introduced in time, or kept
        <a href="https://raw.githubusercontent.com/joshuahhh/drostes-lair/refs/heads/main/src/ui.ts#:~:text=window.addEventListener(%22keydown%22">deeply secret</a>.
      </p>
      <h3>The Reversal of Fortune</h3>
      <a href="https://joshuahhh.com/drostes-lair/#?example=reverseBlank">
        <video autoplay="" muted="" loop="">
          <source src="candle.webm" type="video/webm"/>
        </video>
        Join from the start
        <span>⟿</span>
      </a>
      <p>
        A piece of parchment is against the dungeon wall, dimly lit by
        flickering candelight. On it is a list:
        <code>[a, b, c, d]</code>.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-1.jpg"/>
      </p>
      <p>
        Your teacher (who&#39;s also a cool wizard) has tasked you with
        reversing the elements of this list. You first try to do this
        by moving elements one by one. Clicking an element...
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-2a.jpg"/>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-2b.jpg"/>
      </p>
      <p>
        ...picks it up, and reveals places it could go. You add it to
        the start of the second, currently empty list.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-3.jpg"/>
      </p>
      <p>
        Your action has magically created a second square of parchment
        on the wall showing its effect. You could almost think of this
        as a &#34;comic book&#34;, though the damp air and clink of chains in
        the distance make the situation anything but comical.
      </p>
      <p>
        You could continue moving items one by one, and it wouldn&#39;t
        take long with a list this short. But you know that sooner
        than you would like, you will face far greater foes. Moving
        items by hand, you&#39;d only make it through a handful of items
        before being knocked out by some orcish cudgel. You need a way
        to automate these motions, a sorceror&#39;s apprentise of sorts.
      </p>
      <p>
        The spell to cast has been with you the whole time, in the
        top-left:
        <span>♌︎</span>. This sigil marks the script you are writing. With it, you
        can take what you&#39;ve done so far, and cast it again, as a
        spell of its own.
      </p>
      <p>
        With some trepidation (you&#39;re playing with recursion, after
        all!), you grab the sigil and cast it onto the latest panel...
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-4.jpg"/>
      </p>
      <p>
        Your trepidation was called for. The effect of your spell is
        simply astonishing.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-5.jpg"/>
      </p>
      <p>
        Portals into the wall have opened up, deep holes with deeper
        holes beyond. Inside each hole the sigil
        <span>♌︎</span>
        does its work. So each begins with the &#34;start&#34; parchment, and
        then has a &#34;move item 1&#34; parchment, just like the script
        outside the hole. But each starts with the outcome of the
        previous hole. So while the top level moves an &#34;a&#34;, the next
        level moves a &#34;b&#34;, and so on.
      </p>
      <p>
        Where will this madness end? At the bottom, in a fateful
        encounter with the eldrich consequences of your sigilic
        incantation: the base case. You were never far from it. A
        short pan takes you over to the deepest hole, four levels
        below the surface.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-6.jpg"/>
      </p>

      <p>
        In this deepest level, the first list has been exhasted. All
        items have been moved to the second list, in reverse order.
        This is great progress, but we&#39;re not done yet. Though our
        answer lurks in the depths of the the recursive holes, nothing
        is coming out to the surface. Yet.
      </p>
      <p>
        The problem is that our parchment is getting stuck. The
        spirits of the parchment call out to us: &#34;list is empty!&#34;. We
        know that, actually, the first list being empty isn&#39;t a
        problem at all – it just means that we are ready to call our
        answer back from the world of spirits. So we guide the
        parchment along by giving it an escape route. Clicking the
        double-dagger mark (<span>‡</span>) creates one.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/1-7.jpg"/>
      </p>
      <p>
        The escape route guides the parchment from the deepest level,
        where it ran into the obstacle of the empty list. At each
        higher level, the escape route is available, but the parchment
        doesn&#39;t take it, since it can happily proceed through the item
        movement and the recursive call. At last, we have a final
        answer on the far right. Our strange recipe is complete. We
        are ready to face far larger lists, and the monstrous beings
        that might bring them to us with nefarious intent.
      </p>
      <a href="https://joshuahhh.com/drostes-lair/#?example=reverseDone">
        <span>⟿</span>
        Witness the conclusion
        <video autoplay="" muted="" loop="">
          <source src="candle.webm" type="video/webm"/>
        </video>
      </a>

      <h3>The Everbranching</h3>
      <a href="https://joshuahhh.com/drostes-lair/#?example=cardsBlank">
        <video autoplay="" muted="" loop="">
          <source src="candle.webm" type="video/webm"/>
        </video>
        Join from the start
        <span>⟿</span>
      </a>
      <p>
        You&#39;ve done well in your first test, but your teacher reminds
        you that you are still a novice. After all, your first spell
        only traced one timeline. At each point, it did one thing,
        made one decision, defined one strand of possibility. The
        greatest spells dissolve the bounds of decision. These spells,
        when confronted with the question &#34;yes or no?&#34; respond &#34;yes
        AND no&#34;, becoming the branching limbs of a tree reaching ever
        towards an infinite sky.
      </p>
      <p>
        To learn this art, you take upon a simple task: generate every
        face card in the deck. You begin with the raw material: a list
        of ranks and a list of suits.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/2-1.jpg"/>
      </p>
      <p>
        A face card is formed by combining a rank with a suit. So
        first, you pick a rank.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/2-2.jpg"/>
      </p>
      <p>
        You do this just the same as when reversing the list: pluck
        out an item from the list of ranks and add it to a new list.
        So you&#39;ve picked a particular rank. But that isn&#39;t what you
        really want. You really want to, you know, dissolve the bounds
        of decision, and pick <i>all</i> possible ranks.
      </p>
      <p>
        To do this, you click the &#34;move item 1&#34; heading. It cycles
        through a few different headings (&#34;move first item&#34;, &#34;move
        last item&#34;) before landing on &#34;move any item&#34;. That&#39;s the
        ticket!
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/2-3.jpg"/>
      </p>
      <p>
        Now there&#39;s a stack of three parchments, three parallel
        universes of action. They&#39;re fanned out because you&#39;re hovered
        over them, but moving away for a moment shrinks them into a
        compact stack.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/2-4.jpg"/>
      </p>
      <p>
        Finishing the job means doing the same thing with the suits,
        creating branches on top of branches. You pick a suit off one
        of the panels on the right and put it next to the selected
        rank.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/2-5.jpg"/>
      </p>
      <p>
        And you turn this step from &#34;move item 2&#34; into &#34;move any
        item&#34;.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/2-6.jpg"/>
      </p>
      <p>
        Your 12 face cards are all here. Fanned out in the
        candlelight, they&#39;re beautiful.
      </p>
      <a href="https://joshuahhh.com/drostes-lair/#?example=cardsDone">
        <span>⟿</span>
        Witness the conclusion
        <video autoplay="" muted="" loop="">
          <source src="candle.webm" type="video/webm"/>
        </video>
      </a>
      <h3>The Enumeration</h3>
      <a href="https://joshuahhh.com/drostes-lair/#?example=dominoesBlank">
        <video autoplay="" muted="" loop="">
          <source src="candle.webm" type="video/webm"/>
        </video>
        Join from the start
        <span>⟿</span>
      </a>
      <p>
        You&#39;ve learned the rudiments of casting recursive spells and
        splitting worlds into swarms of possibilities. Now it&#39;s time
        to put these arcane arts to use on a real challenge.
      </p>
      <p>
        An evil sorceror is tormenting a nearby village with an
        insidious puzzle: How many ways, he asks, can a 2xN
        checkerboard be covered completely with dominoes?
      </p>
      <p>
        What!? N isn&#39;t a <i>number</i>! That&#39;s a letter! There&#39;s no
        chance you&#39;ll be able to grapple with this sorcerer&#39;s
        &#34;pretending letters are numbers&#34; hocus-pocus quite yet. But
        you can start to get a feel by replacing N with a number.
        Let&#39;s say, 4.
      </p>
      <p>You prepare a 2x4 checkerboard.</p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-1.jpg"/>
      </p>
      <p>
        How to fill it? Well, you can try just putting a domino down.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-2.jpg"/>
      </p>
      <p>
        Ah, now maybe we could fill the rest of the board with
        vertical dominoes like this. You realize you want to repeat a
        step over and over again, sort of like the reversal exercise
        you were trained on... but this is a little different. Before,
        you casted a recursive spell onto an entire panel of
        parchment. Here, that would cause the next dominoes to stack
        on top of the first domino in the same squares over and over
        again. We need to cast the spell so that it acts on the
        <i>rest</i> of the checkerboard, leaving out the first domino.
      </p>
      <p>Maybe you can just... point your wand over a little?</p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-3.jpg"/>
      </p>
      <p>
        You cast the spell onto the subgrid, and breathe a sigh of
        relief. It seems to have worked!
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-4.jpg"/>
      </p>
      <p>
        Deep in the recursion, your &#34;place domino&#34; action is failing,
        since it&#39;s going off the board. That&#39;s ok though; that just
        means the board has been filled. So you activate the escape
        route.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-5.jpg"/>
      </p>
      <p>
        You&#39;ve successfully found one way to fill the board with
        dominoes, using only vertical dominoes. Now you should explore
        using horizontal dominoes instead. Starting again from the
        blank board at the far left, you create a second branch to
        place two horizontal dominoes.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-6.jpg"/>
      </p>
      <p>
        Once again, you&#39;re left with board to fill after your first
        two dominoes. You decide to once again cast a recursive spell,
        asing your top-level procedure how it might choose to fill the
        remainder of the board.
      </p>
      <p>
        You expect to get another simple loop, showing how two more
        horizontal dominoes could be added to fill the board. But
        something extraordinary happens.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-7.jpg"/>
      </p>
      <p>
        The two-way branching you defined at the top level has been
        replicated inside every level of your recursive spells! There
        are no simple one-way loops anymore – instead, with every
        deeper hole there are new branching possibilities.
      </p>
      <p>
        You check the final output. Giving it a bit of thought, it
        seems like these five coverings are the only ones possible.
        Have you somehow stumbled onto a fully general program?
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-8.jpg"/>
      </p>
      <p>
        It&#39;s difficult to make sense of it all at once. Fortunately,
        your teacher taught you a &#34;collapse calls beyond depth 1
        spell&#34; (hitting &#34;2&#34; on the keyboard), so you use it now. A
        great many of the holes before you shrink, leaving only the
        highest-level structure visible.
      </p>
      <p>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-walkthrough/3-x.jpg"/>
      </p>
      <p>
        Ah, of course. After adding a vertical domino, you can add
        either a second vertical domino OR two horizontal dominoes.
        Similarly, after adding horizontal dominoes, you can add
        either a vertical domino OR two more horizontal dominoes. It
        does seem like following this branching pattern, always adding
        either a vertical or two horizontal dominoes, would get you
        every possible covering.
      </p>
      <p>
        You&#39;ve conquered the problem of the 2x4 checkerboard! But some
        mysteries remain... What did that evil sorceror mean by &#34;N&#34;,
        anyway? Finding out will be journey for another day.
      </p>

      <a href="https://joshuahhh.com/drostes-lair/#?example=dominoesDone">
        <span>⟿</span>
        Witness the conclusion
        <video autoplay="" muted="" loop="">
          <source src="candle.webm" type="video/webm"/>
        </video>
      </a>
      
      <h2>
        Exegesis
        <span>(a.k.a. Discussion &amp; Future Work)</span>
      </h2>
      <p>
        Now that you&#39;ve returned from your travails in the caverns,
        we&#39;d like to tell you a bit about how Droste&#39;s Lair came to
        be. Grab a mug of spiced mead and take a seat.
      </p>
      <p>
        Hi! We&#39;re Elliot and Josh. We met earlier this year through
        Internet circles like
        <a href="https://www.inkandswitch.com/">Ink &amp; Switch</a>. We
        discovered that we shared a lot of interests, especially
        around visualizing math. So we decided to embark on a little
        project together which ended up taking about two weeks.
      </p>
      <p>
        We took the tight time-boxing of our project as an excuse to
        be indulgent and follow our whims. Droste&#39;s Lair is definitely
        an artistic investigation. It might also be a research
        project. We feel great about where it ended up. It&#39;s a
        genuinely weird little creation that combines some of our
        long-held principles with some out-on-a-limb experiments. It
        was really fun to make and it may even be fun to play with.
        We&#39;re not sure what it&#39;s
        <i>good for</i>, exactly, but we&#39;re fine with that.
      </p>
      <p>
        For the rest of this &#34;exegesis&#34;, we&#39;ll talk about the ideas
        that braided together to form Droste&#39;s Lair, some tensions we
        thought through, and some open questions that remain.
      </p>
      <h3>Programming model &amp; origins thereof</h3>
      <p>
        This project fits into a lineage of projects that co-design an
        underlying programming model with a visual interface for
        viewing and interacting with that model. Of course we draw on
        ideas from traditional programming languages, but always while
        asking &#34;what does this <i>look</i> like?&#34; and &#34;how does it
        <i>feel</i> to edit this?&#34;.
      </p>
      <p>
        We were influenced by a few prior projects in this vein. Josh
        was interested in revisiting an old idea: a live-programming
        interface for building trees to solve combinatorial counting
        problems. His original prototype, called &#34;Construct &#39;n&#39;
        Count&#34;, adopted a functional-programming structure where each
        level of a branching tree acted like a &#34;map&#34; operation,
        defining a new variable that could be referred to deeper in
        the tree.
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/construct-n-count.png"/>
        <figcaption>
          Terminally juiceless &#34;Construct &#39;n&#39; Count&#34; prototype, 2015
        </figcaption>
      </figure>
      <p>
        Marcel Goethals&#39; recent Subsequently prototype offered an
        exciting alternative to this functional nested-scope vibe. In
        Subsequently, each comic pane contains the full state of the
        world at a point in time. You act directly on a pane&#39;s
        contents. There are no variables buried in some other pane;
        everything you need is right where you are. Subsequently also
        demonstrated that some processes (like picking elements out of
        arrays) feel more natural as <i>imperative processes</i> which
        mutate a world state, rather than as
        <i>functional processes</i>.
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/subsequently.png"/>
        <figcaption>
          <a href="https://www.youtube.com/watch?v=4GOeYylCMJI&amp;t=9116s">Subsequently</a>
          by Marcel Goethals, 2024
        </figcaption>
      </figure>
      <p>
        Subsequently&#39;s lack of &#34;spooky action at a distance&#34; and its
        imperative model felt appealing to us. They added up to a
        physical feeling that seemed appropriate for a live,
        interactive, visual programming system. Also, they were weird
        by conventional CS standards, which is always a good sign.
      </p>
      <p>
        In order to extend the Subseqently model to work for
        Construct-&#39;n&#39;-Count-style counting problems, we had to add
        branching. Sure, Subsequently has conditional branches, as
        shown in the shot above, but we needed <i>unconditional</i>
        branches – branches that are all taken simultaneously,
        &#34;dissolving the bounds of decision&#34;. This sounds fancy, but
        it&#39;s straightforward to build. It is also well-trodden ground
        in computer science, also known as
        <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-28.html">
          &#34;amb&#34;
        </a>
        or
        <a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/13-the-list-monad">&#34;the list monad&#34;</a>
        or &#34;nondeterminism&#34;. Admittedly, it&#39;s less common to see this
        kind of thing in an imperative environment like Droste&#39;s Lair,
        which is exciting.
      </p>
      <img src="https://g-w1.github.io/blog/ml/2024/12/12/potion.png"/>
      <p>
        The Subsequently-plus-branching potion we brewed up was enough
        to cover some simple counting problems, like the cards we made
        in the Everbranching walkthrough. But some of the most
        interesting counting problems were still out of our grasp.
        These were the ones involving recursion: where counting
        possibilities for a larger structure involves splitting it
        into pieces, counting possibilities for each piece, and then
        recombining the possibilities of the pieces into possibilities
        for the whole. In the walkthrough, we showed how to use
        recursion to count ways to cover a checkerboard with dominoes.
        We were actually originally motivated by a more complicated
        question: counting paths on the fractal Sierpinski graph (also
        known as the Hanoi graph, since it maps out states in the
        Towers of Hanoi puzzle). We weren&#39;t able to get to this
        problem in our short sprint, but dominoes were a nice
        alternative.
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/sierpinski.png"/>
        <figcaption>
          Some flavor of our Sierpinski investigations
        </figcaption>
      </figure>
      <p>
        Aside from the applicability of recursion to counting
        problems, we were also just plain curious about how to make
        recursive structures comprehensible in a visual programming
        interface. (Elliot in particular has been investigating this
        strand for some time.)
      </p>
      <p>
        With that, we had the basic formula for the programming model
        in Droste&#39;s Lair:
      </p>
      <ul>
        <li>Subsequently-style imperative flowcharts</li>
        <li>... plus branching paths</li>
        <li>... plus recursion.</li>
      </ul>
      <p>
        That&#39;s basically it, as long as you ignore (as we do for the
        moment) that Droste&#39;s Lair is also a point-and-click adventure
        game.
      </p>
      <h3>Branching</h3>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/branch.png"/>
        <figcaption>
          1. invoking multiple actions on a panel
        </figcaption>
      </figure>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/stack.png"/>
        <figcaption>
          2. &#34;move any item&#34; has multiple outputs
        </figcaption>
      </figure>
      <p>
        Droste&#39;s Lair provides two ways to produce branching
        computation:
      </p>
      <ol>
        <li>
          invoking multiple actions or procedures off of a single
          panel, or
        </li>
        <li>
          invoking an action or procedure that has multiple outputs.
        </li>
      </ol>

      <p>
        When multiple distinct actions are invoked on a panel, they
        are shown branching from it (1). But when a single action or
        procedure has multiple outputs, we group those outputs into a
        stack of panels in the interface (2). It would have
        alternatively been possible to not group those outputs and to
        instead display them as branching paths.
      </p>
      <p>
        There&#39;s a tradeoff involved in putting multiple outputs into a
        stack. The stack visualization we chose keeps the interface
        closer to the structure of an underlying flowchart: each
        action added by the user is depicted in one place. If &#34;move
        any item&#34; and actions like it instead produced branches in the
        interface, these actions would be depicted multiple times,
        making the interface less directly match the underlying
        program. But in some ways, the run-time behavior of the
        program would be more clear.
      </p>
      <p>
        This tension between highlighting static and dynamic
        structures is common when building live-programming systems.
        The dynamic execution of a program is an &#34;unfolding&#34; (by loops
        / calls) and &#34;slicing&#34; (by conditionals) of the program&#39;s
        static specification. It is challenging to show both static
        and dynamic layers at once.
      </p>
      <p>
        But there are techniques that can help. Thoughtful visual
        design can go a long way. And, lucky for us, computers are
        interactive, so we can use interactive techniques too. Future
        work on Droste&#39;s Lair could could let users switch between
        stacked and branched views as they please. Or perhaps hovering
        a panel could reveal, through highlights, other elements on
        the screen less obviously connected to it.
      </p>
      <h3>Recursion</h3>
      <p>
        Unlike Droste&#39;s Lair, Subsequently doesn&#39;t have recursion. To
        loop in Subsequently, you make an arrow from a step back to a
        previous step, essentially a &#34;goto&#34;. Although goto is out of
        fashion these days, it is honestly a pretty great way to loop,
        for a certain range of situations.
      </p>
      <p>
        Some of the problems we wanted our system to handle seemed to
        lie outside this range, like the Sierpinski problem alluded to
        earlier. We knew there was good reason to resist whole-hog
        recursion, which is notoriously difficult to learn and work
        with, especially for those who aren&#39;t committed programmers.
        So we spent some time sketching to see if we could find an
        alternative to recursion that gave us the expressivity we
        wanted while fitting better into Subsequently&#39;s model.
      </p>
      <p>
        In the end, we couldn&#39;t make anything work, and we went for
        fairly traditional recursion. We still feel there could be
        something interesting down this road. For instance, we spent
        some time thinking about what it would mean for a flowchart
        arrow to flow not out of an entire panel of a flowchart, but
        out of a piece of a panel. In our imagination, this could let
        a flowchart express the &#34;divide-and-conquer&#34; structure of a
        recursion. (One way to look at this: Flowchart arrows roughly
        correspond to tail-recursive calls. What we have here suggests
        a gentle loosening of this constraint to allow making multiple
        simultaneous tail-recursive calls that commute with each other
        because they operate on different parts of a structure.)
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/blue-arrows.png"/>
        <figcaption>
          Whiteboard sketch of multiple arrows from individual
          flowchart panels
        </figcaption>
      </figure>
      <p>
        Putting wild alternatives aside, it was now our job to bring
        recursive calls (procedure calls in general) into the
        Subsequently model. In Subsequently, an action is represented
        as a comic panel that shows a picture of the world after the
        action, annotated with graphics that illustrate the action
        itself and descriptive text above the panel.
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/subsequently-action.png"/>
        <figcaption>
          Subsequently&#39;s comic-panel representation of an action,
          photographed with a potato
        </figcaption>
      </figure>
      <p>
        We took this design and extended it to our depiction of
        procedure calls. Calls in our system are represented as a
        <b>hole</b> containing the body of the called procedure
        followed by an &#34;after the &#39;procedure call&#39; action&#34; panel.
      </p>

      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/hole.jpg"/>
        <figcaption>The world&#39;s simplest procedure call</figcaption>
      </figure>
      <p>
        Visually representing a call as a physical hole in the cobbled
        floor of the editor was inspired by metaphors of &#34;depth&#34; in
        recursion, and by the spooky, disorienting feeling of crawling
        deeper and deeper into caves and/or recursive functions.
      </p>
      <p>
        In Droste&#39;s Lair, you can call a procedure on an entire panel
        or on a piece of a panel&#39;s contents that you select.
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/hole-sub.jpg"/>
        <figcaption>
          The same procedure call as above, but restricted to a
          sub-grid, producing a different effect
        </figcaption>
      </figure>
      <p>
        A note on how we visualized panel contents inside of holes:
        The most straightforward move would have been to show a called
        procedure operating only on the piece it was given, without
        any reference on the parchments to the larger whole they came
        from. But we reckoned that doing this would give up a lot of
        the physical, &#34;object-permanent&#34; feeling that we were striving
        for in our design. Passing into and out of procedure calls
        would require reorientation. To maintain the feeling of
        grounding we wanted, we instead chose to always show parts in
        the context of the whole. We use a color-coded outline to show
        what part is actively focused by the procedure call, and fade
        out the rest.
      </p>
      <p>
        (We maintain a conceptual color scheme throughout the
        interface of Droste&#39;s Lair:
        <span>yellow</span>
        for actions,
        <span>purple</span>
        for procedures &amp; calls, and
        <span>red</span>
        for trouble.)
      </p>

      <p>
        Although we&#39;ve tried in this project to visualize recursion as
        concretely and understandably as possible, building a
        recursive procedure is still an immensely &#34;programmer-brained&#34;
        activity. It won&#39;t feel natural to most people, even with our
        visualizations. But we aren&#39;t ready to give up on recursion
        yet! What could we do to make building recursion in our system
        less programmer-brained? Maybe users could start by building
        concrete trees by hand, and then our system could help them
        build recursive functions to match these?
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/dominoes-by-hand.jpg"/>
        <figcaption>
          A concrete tree of domino coverings built by hand
        </figcaption>
      </figure>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/dominoes-by-procedure.jpg"/>
        <figcaption>
          For visual comparison, a (zoomed out) procedurely
          constructed tree of domino coverings... How could we make
          this easier to build from the concrete tree?
        </figcaption>
      </figure>

      <h3>Conditionals</h3>
      <p>
        Our design naturally diverged from Subsequently&#39;s when it came
        to flow control. We were looking for ways to make recursion
        less &#34;programmer-brained&#34;; we gravitated towards letting the
        user do whatever they wanted, and then letting them handle the
        ensuing errors as a post-hoc reaction to the situation.
      </p>
      <p>
        Leaving behind traditional, if-then-style conditionals opened
        up a large space of designs. We went through several
        iterations of error handling, during both the initial design
        process and early implementation. The first design that worked
        for all our examples was allowing the user to attach an error
        handler panel to any other panel as a &#34;catch&#34; for that panel&#39;s
        action. In the end we landed on a different mechanism that
        felt a bit more natural for our examples: attaching an
        &#34;escape&#34; panel for when <i>all</i> possible actions from a
        panel result in error.
      </p>
      <figure>
        <img src="https://g-w1.github.io/blog/ml/2024/12/12/img-exegesis/escape.jpg"/>
        <figcaption>
          All actions from the start panel fail, and the escape route
          is triggered
        </figcaption>
      </figure>
      <p>
        We don&#39;t have much confidence that this is the &#34;right&#34; way to
        handle errors or other conditions in a system like this. More
        exploration is needed!
      </p>

      <h3>Juice &amp; Aesthetics</h3>
      <p>
        So far in this exegesis, we haven&#39;t acknowledged the dragon in
        the room: Droste&#39;s Lair isn&#39;t just a visual programming
        system. It&#39;s also a swords-and-sorcery-style point-and-click
        adventure game. Kind of... Maybe not really, but it&#39;s
        certainly inspired by the aesthetics and design of those
        games.
      </p>
      <p>
        This strange decision came from our hankering to dip our toes
        into
        <a href="https://www.youtube.com/watch?v=Fy0aCDmgnxg"><span>Juice</span>
          (a term from game development)</a>. Droste&#39;s Lair may not be the juiciest thing you&#39;ve ever
        encountered. But we&#39;re used to making 0%-juice programming
        systems, so this is a big step into the juice for us.
      </p>
      <p>
        Juice is cool</p>
      <p>
        Elliot came to code</p>
      <p>
        A crafted object</p>
      <p>
        Why do we make things?</p>
      <p>
        Could Juice help a pink brain</p>

      <p>
        Making things less abstract</p>

      <p>
        Encourage game-like patterns of thought</p>

      <h3>Even More Future Directions</h3>
      <p>
        We&#39;ve already highlighted some limitations &amp; open questions in
        the discussion above. But here are some more!
      </p>
      <ul>
        <li>
          <strong>More microworlds</strong>: The demos in the
          walkthroughs used two simple &#34;microworlds&#34; – lists and
          domino tilings. We&#39;ve been been able to get a bit of fun out
          of these microworlds, but we wonder what other simple
          domains of state and action could be even more generative.
        </li>
        <li>
          <strong>Mixing microworlds</strong>: Why can&#39;t I drag a card
          suit into the domino grid? Why can&#39;t I place a domino in a
          list? Mashing worlds together could multiply the
          possibilities, but it&#39;s not at all clear what underlying
          models would make that work.
        </li>
        <li>
          <strong>Scaling</strong>: For this prototype, we&#39;ve stuck to
          small toy examples – neither the data nor the flow charts
          get very large. When they do, the way we visualize things
          begins to break down. This dovetails with a common critique
          of visual programming – a failure to scale to larger
          situations. But we&#39;re not worrying much yet. When the time
          comes to scale up, we will have so many techniques to draw
          from! Expanding and collapsing, minimaps, outline views,
          more compact graphic design, and on and on. We&#39;ve already
          dipped our toes into this space with the recursion-depth
          filter we showed in the Enumeration walkthrough.
        </li>
        <li>
          <strong>Learnability</strong>: If you&#39;ve taken the plunge to
          actually spend some time in Droste&#39;s Lair, we applaud your
          courage. You may have noticed – it&#39;s tough to work with, in
          so many ways. What could we do to guide people in their
          explorations? Could we borrow narrative techniques from
          games? Could new mechanisms in our programming model give
          people a gentle ramp from concrete actions into abstract
          concepts like recursion?
        </li>
        <li>
          <strong>Representation of action</strong>: Following
          Subsequently&#39;s example, we&#39;ve added visual representations
          of actions themselves to Droste&#39;s Lair. Rather than just
          seeing the states of the world before and after an action,
          annotations are added to the state to show what&#39;s happened.
          There are at least four hypothetical views relevant to an
          action: a &#34;before&#34; view, an &#34;after&#34; view, an annotated view
          of &#34;before&#34; showing what is about to happen, and an
          annotated view of &#34;after&#34; showing what just happened. In our
          current system, we focus on the annotated view of &#34;after&#34;.
          Is this the best focus to have? Are there ways to include
          more views, or to allow moving between views?
        </li>
        <li>
          <strong>What do we do with it</strong>: We built Droste&#39;s
          Lair as a short experiment. We are, honestly, pretty
          delighted with it. But some may wonder: what good is this
          thing anyway? We wonder that too, although we&#39;d phrase it
          less confrontationally. Could this project grow into an
          educational tool? A mathematical laboratory? An
          honest-to-goodness game? A programming environment for data
          integration workflows? Hmmmm.
        </li>
      </ul>

      
      <h2>Thanks to...</h2>
      <ul>
        <li>
          Marcel Goethels, for the lovely inspiration of Subsequently.
        </li>
        <li>
          Ink &amp; Switch and the Pacific Programming Interfaces
          Confab, for motivating us with venues for sharing.
        </li>
        <li>
          Ivan Reese, for play-testing &amp; insightful feedback.
        </li>
        <li>
          Andrew Blinn, for play-testing, insightful feedback, and his
          championing of juice.
        </li>
        <li>
          Rocky430, for inspiring conversation with Elliot about
          Aesthetics such as Frutiger Aero and PSX.
        </li>
        <li>Nick Joliat, for fractal inspiration.</li>
        <li>Todd Matthews, for the brilliant name.</li>
      </ul>

      

      <p>
        <a href="https://github.com/joshuahhh/drostes-lair">
          Droste&#39;s Lair</a>
      </p>
      <p>
        <a href="mailto:vez@duck.com,joshuah@alum.mit.edu">Please get in touch!</a>
      </p>
      <p>
        MMXXIV
      </p>
    </div></div>
  </body>
</html>
