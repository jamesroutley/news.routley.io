<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janestreet.com/what-the-interns-have-wrought-2022/">Original</a>
    <h1>What the interns have wrought, 2022 edition</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>We’re once again at the end of our internship season, and it’s my task
to provide a few highlights of what the interns accomplished while
they were here.</p>

<p>And once again, the program was bigger than ever.  We had 122 dev
interns globally, coming from 42 different schools and 13
countries. As the program grows, it gets harder and harder to
summarize it with any degree of fidelity by picking just three
projects.</p>

<p>But, choose we must! So here are my somewhat arbitrarily chosen
example projects:</p>

<ul>
  <li>
    <p>Aaron Lamoreaux extended <a href="http://magic-trace.org">magic-trace</a> to
support a sampling mode, along with several other improvements.</p>
  </li>
  <li>
    <p>Matthew Sirman worked on integrating Datafetcher, a library for
writing testable and efficient data-loading-and-transformation
tasks, with
<a href="https://opensource.janestreet.com/incremental/">Incremental</a>, a
library for building on-line algorithms.</p>
  </li>
  <li>
    <p>David Vulakh extended our
<a href="https://opensource.janestreet.com/base_quickcheck/">Quickcheck</a>
property-based testing library with a convenient syntax for
specifying contracts to simplify the testing of complex APIs.</p>
  </li>
</ul>

<p>Now, let’s dive in to the details!</p>



<p>magic-trace is an open-source tool we built that takes advantage of
Intel Processor Trace (Intel PT) to provide hyper-detailed traces of
everything a program did for a small window of time, around 10ms.</p>

<p>The initial version of magic-trace was implemented as an intern
project (briefly mentioned
<a href="https://blog.janestreet.com/what-the-interns-have-wrought-2021/">here</a>),
and we’ve since <a href="https://blog.janestreet.com/magic-trace/">open-sourced
it</a> and made it available on
<a href="https://github.com/janestreet/magic-trace">Github</a>.</p>

<p>Part of what makes magic-trace great is the enormous detail afforded
by Intel PT’s ability to cheaply write down every branch taken by a
process. But another one of magic-trace’s super-powers is its extreme
ease-of-use.  Lots of performance analysis tools require you to figure
out the right arcane invocation, and then stare at some confusing text
output to divine what’s going on.</p>

<p>magic-trace tries really hard to get rid of all that noise.  The
command-line tool does sensible things by default, and instead of
staring at an arcane blog of text, it’s integrated with a modified
version of <a href="https://perfetto.dev/">Perfetto</a>, a pretty and intuitive
trace-viewer from Google.</p>

<p>Aaron Lamoreaux’s primary project was to extend magic-trace to cover
more territory, while still maintaining magic-trace’s great
user-experience.  In particular, Aaron added a sampling mode to
magic-trace, so, rather than being able to see everything that
happened in the 10ms leading up to a given event, you could instead
get sampled data for the last 20 seconds before an interesting event,
or even 20 minutes.  Another win is that sampling can be done on AMD
boxes, while Intel PT is an Intel-only feature.</p>

<p><img src="https://blog.janestreet.com/what-the-interns-have-wrought-2022/magic-trace-httpd-zoomed-out.png" alt="magic-trace in sampling mode"/></p>

<p>A lot of the hard work here about getting the user experience right,
and in particular figuring out how to pick good default behaviors
depending on what users are doing and what hardware they’re running
on.  E.g., picking a reasonable sampling rate, or deciding whether to
use <a href="https://lwn.net/Articles/680985/">LBR</a> or
<a href="https://dwarfstd.org/#:~:text=DWARF%20is%20a%20debugging%20file,be%20extensible%20to%20other%20languages.">DWARF</a>
when interpreting stack traces.</p>

<p>The end result hasn’t yet been rolled into production, but some folk
from our Marketdata team have already put it to good use, figuring out
that one of our packet-processing applications was wasting a lot of
time in the GC due to allocating something on each packet.
magic-trace made it trivial to see the problem, and to figure out
where the stray allocation was coming from.</p>

<p>While sampling was his main project, Aaron got some other magic-trace
improvements out too, like:</p>

<ul>
  <li>
    <p>multi-process tracing, so you could see combined traces from two
applications running on the same box, and see what happens as data
flows from one to the other.</p>
  </li>
  <li>
    <p>CPU-frequency transition reporting, so you can see when a use of
<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX2</a>
instructions causes you to stall for 14µs!</p>
  </li>
  <li>
    <p>Optimizing magic-trace’s trace decoding step by 10%-50% (depending
on the trace) by writing a <a href="https://man7.org/linux/man-pages/man1/perf-dlfilter.1.html">dlfilter
back-end</a>
for perf.</p>
  </li>
</ul>



<p>Datafetcher is a library that we talked about in <a href="https://blog.janestreet.com/what-the-interns-have-wrought-2021/">last year’s
“wrought”
post</a>,
which is designed to help you write jobs that fetch and transform
data. Critically, it understands the structure of the job its running,
which lets it both optimize the execution, e.g., by batching requests,
and helps you build tests by automatically recording external data so
that you can replay it in your tests.</p>

<p>A traditional datafetcher program is a batch job: E.g., grab a bunch
of data from different services, munge it all together, and produce
configs for your desk’s trading infrastructure.</p>

<p>But sometimes, we want to build systems that look at both static data
sources and live marketdata.  Today, if we build such a computation in
Datafetcher, we’d have to run it over and over in a loop, which is
really slow!</p>

<p>Matthew Sirman’s task was to figure out how we could make Datafetcher
jobs that could respond efficiently to live data, without having to be
rerun from scratch.  In particular, he did that by combining
Datafetcher with a library called Incremental.</p>

<p>We’ve <a href="https://blog.janestreet.com/introducing-incremental/">talked</a>
<a href="https://blog.janestreet.com/incrementality-and-the-web/">about</a>
<a href="https://blog.janestreet.com/seven-implementations-of-incremental/">Incremental</a>
<a href="https://blog.janestreet.com/self-adjusting-dom/">a</a>
<a href="https://blog.janestreet.com/self-adjusting-dom-and-diffable-data/">lot</a>
<a href="https://blog.janestreet.com/what-the-interns-have-wrought-2018/">over</a>
<a href="https://blog.janestreet.com/breaking-down-frp/">the</a>
<a href="https://blog.janestreet.com/what-the-interns-have-wrought-2016/">years</a>,
but the basic point of Incremental is to help you build programs that
can be refreshed cheaply when their inputs change.</p>

<p>Incremental and Datafetcher are in some ways pretty similar: they both
organize your computation as a graph, tracking dependencies between
different stages of the work; and they use similar APIs for doing so,
both taking advantage of our <a href="https://github.com/janestreet/ppx_let">syntax
extension</a> for making such
computations easier to read and write.</p>

<p>But they’re also really different!</p>

<ul>
  <li>Datafetcher provides <strong>batched</strong> and <strong>testable</strong> all-at-once execution of
an <strong>asynchronous</strong> programs</li>
  <li>Incremental provides <strong>incremental</strong> execution of <strong>synchronous</strong>
programs.</li>
</ul>

<p>Why not both? Can we build a system that gives us <strong>batched</strong>,
<strong>testable</strong>, and <strong>incremental</strong> execution of an <strong>asynchronous</strong>
program, by essentially compiling a Datafetcher program into an
Incremental computation?</p>

<p>We can, and doing that was the core of Matthew’s project.</p>

<p>There were a lot of things to do along the way. One step was to figure
out how to write an incremental computation that could deal with
asynchrony. This required a way of representing an in-process
Incremental computations.  The solution here was to add a new type
(called <code>Response_or_waiting</code>) that represented the current state of
an asynchronous computation.</p>

<p>Figuring out when and where to memoize was another challenge.  For
intermediate spots in the computation, the decision was to give users
the ability to explicitly decide where memoization should occur.  For
fetch-nodes, memoization was important for correctness and so was not
optional, so that computations would behave consistently, even in
cases where re-issuing the same fetch request could lead to different
results.</p>

<p>There were other issues too, like figuring out how to conveniently
test incremental datafetcher jobs, and how to automatically convert
ordinary datafetcher jobs (which get the data just once) into
incremental ones, which will continue to update via polling.</p>

<p>In addition to working on extensions to the Datafetcher library,
Matthew got to utilize those extensions to improve the
desk-application that motivated this work in the first place, getting
to see the end-to-end application of his work.  It’s not quite in
production yet, but the results look good so far.</p>



<p>Testing is something we spend a lot of time on here, and over the
years, we’ve built a lot of tools to make testing easier and more
pleasant.</p>

<p>One of those tools is our
<a href="https://opensource.janestreet.com/base_quickcheck/">Quickcheck</a>
library.  Quickcheck helps you with <em>property-based testing</em>, which is
a style of testing where you marry together a collection of properties
you want to test with a mechanism for generating random examples to
test with.</p>

<p>Quickcheck aims to make this kind of testing easy. It does this
primarily by providing libraries for building probability
distributions, combined with a syntax extension that obviates most of
the boilerplate of using those libraries.  Here’s an example.</p>

<div><pre><code><span>type</span> <span>shape</span> <span>=</span>
  <span>|</span> <span>Circle</span> <span>of</span> <span>{</span> <span>radius</span><span>:</span> <span>float</span> <span>}</span>
  <span>|</span> <span>Rect</span> <span>of</span> <span>{</span> <span>height</span><span>:</span> <span>float</span><span>;</span> <span>width</span><span>:</span> <span>float</span> <span>}</span>
  <span>|</span> <span>Poly</span> <span>of</span> <span>(</span><span>float</span> <span>*</span> <span>float</span><span>)</span> <span>list</span>
<span>[@@</span><span>deriving</span> <span>quickcheck</span><span>];;</span>
</code></pre>
</div>

<p>Given the above, <code>ppx_quickcheck</code> will generate a probability
distribution automatically.  That distribution makes a bunch of
choices (like equiprobably returning a <code>Circle</code>, <code>Rect</code>, or <code>Poly</code>),
but you can add more annotations to tweak the distribution if you need
to.</p>

<p>Even with all this, there’s still a decent amount of work required to
set up each test for each property you want to validate.  That’s where
David Vulakh’s project came in.  David added a new syntax for
reducing the boilerplate further.  In particular, his syntax extension
lets you specify explicit contracts associated with each call in an
interface, and the rest of the test generation can be driven from
that.</p>

<p>This is maybe easiest to explain with an example.  Here’s a subset of
the <code>String</code> API in <a href="https://github.com/janestreet/base">Base</a>, to
which this contract syntax has been applied:</p>

<div><pre><code><span>val</span> <span>to_list</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>char</span> <span>list</span>
<span>[@@</span><span>contract</span> <span>fun</span> <span>t</span> <span>-&gt;</span> <span>equal</span> <span>t</span> <span>(</span><span>t</span> <span>|&gt;</span> <span>to_list</span> <span>|&gt;</span> <span>of_char_list</span><span>)]</span>

<span>val</span> <span>length</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>int</span>
<span>[@@</span><span>contract</span> <span>fun</span> <span>t</span> <span>-&gt;</span> <span>length</span> <span>t</span> <span>=</span> <span>List</span><span>.</span><span>length</span> <span>(</span><span>to_list</span> <span>t</span><span>)]</span>
</code></pre>
</div>

<p>Note that contracts can use multiple functions from the same API to
express their property.  In the case of <code>to_list</code>, the contract checks
that if you take a string, convert it to a list of characters, and
then back into a string, the result is equal to the string you started
with.</p>

<p>The way in which these contracts are exercised is pretty simple:
regular Quickcheck generators are used to create all of the inputs for
a given function, and then the function is called on them, and the
property is checked, signaling an error if the property fails.</p>

<p>This use-case is pretty simple, but there are some complicated corners
that needed to be figured out, like providing more annotations to
allow customizing the probability distributions used for particular
arguments.</p>

<p>After finishing up the contract work, David then worked on another
extension to Quickcheck, which is support for
<a href="https://en.wikipedia.org/wiki/Bisimulation">bisimulation</a>-style
tests.  The idea of bisimulation is to have two different
implementations of the same API, and to test them against each other.
What’s tricky here is that it’s not enough to generate random inputs
and call each function; you actually need to call sequences of
operations to build up the values that you’re operating on.  This is
especially useful for tricky, performance sensitive data-structures,
where it’s easy to write a correct-but-slow version, and really quite
hard to write a correct and well-optimized one.</p>

<p>There’s a bit more work to do to get the bisimulation mode to the
point where it really covers everything we need, but it’s already at a
stage where it’s useful for real examples.</p>



<p>Summarizing the whole summer in just a handful of projects is an
impossible task, but I hope this gives you a flavor of the kinds of
things that our interns are able to accomplish.  (And I should
mention: this work only reflects part of their work! Each intern
actually works in two different areas over the course of the summer.)</p>

<p>If this sounds like the kind of work you’d like to do, then you should
<a href="https://www.janestreet.com/join-jane-street/open-roles/?type=students-and-new-grads&amp;location=new-york&amp;department=software-engineering">apply</a>.
The internship is a great chance to learn, both about software
engineering, and about the world of trading.  And if you’re curious
about our interview process, check
<a href="https://blog.janestreet.com/applying-to-jane-street/">this</a> out.</p>

    </div></div>
  </body>
</html>
