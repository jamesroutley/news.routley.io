<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kristoff.it/blog/improving-your-zls-experience/">Original</a>
    <h1>Improving your Zig language server experience</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body"><p>The Zig ecosystem is still growing and a lot of important building blocks have not yet reached their final form.</p><p>One notable example is the current language server situation: <a href="https://github.com/zigtools/zls">ZLS</a> is a brilliant community effort, capable of keeping up with language changes (they have a few clever ways to automate the process), but that has one big flaw: it is not able to resolve complex comptime expressions.</p><p>The result is that ZLS is able to give you parser-level diagnostics (which go from syntax errors up to unused variable errors), but it&#39;s not able to show you errors when you try to pass an argument of the wrong type to a function or try to assign a <code>usize</code> to a <code>f64</code>...</p><p>...or does it?</p><h2>Getting Build-On-Save Diagnostics From ZLS</h2><p>ZLS can be configured to run your build script on save. If that results in build errors, ZLS will be able to display those in your editor like any other diagnostic.</p><p><strong>With this system in place you won&#39;t need to alt-tab into another terminal tab to see build errors anymore.</strong></p><p>Here&#39;s how to do it.</p><h3>1. Configure ZLS to run a build step on save</h3><blockquote><p><strong>WARNING</strong>: note that if you get ZLS through your editor&#39;s package manager, you might need to see how you&#39;re expected to provide your config options, as that might differ from the normal procedure described below.</p></blockquote><p>Run the ZLS executable and have it tell you where the config file is located:</p><pre><code>$ zls --show-config-path
/home/kristoff/.config/zls.json
</code></pre><p>Note that on other OSs you might get a radically different answer (eg on macOS the config file is under &#34;Application Support&#34;).</p><p>Once you have the path, edit your config file to include the following keys:</p><pre><code><span>{</span>
  <span>&#34;enable_build_on_save&#34;</span><span>: true</span><span>,</span>
  <span>&#34;build_on_save_step&#34;</span><span>:</span> <span>&#34;check&#34;</span>
<span>}</span>
</code></pre>
<p>The second setting doesn&#39;t have to be necessarily <code>&#34;check&#34;</code>, and in fact not defining it will default to running the <code>install</code> step of your build script, but we&#39;ll see in a moment why it&#39;s convenient to have a dedicated step for this.</p><h3>2. Add a check step to your build.zig</h3><p>This part is more deeply tied to your specific project but the gist is the following: whatever you do to define your main executable / module / library, you do it again in a new step named check.</p><p>I&#39;ll use for this example the executable definiton step you get generated automatically from <code>zig init</code>.</p><pre><code>

<span>const</span> <span>exe</span> = <span>b</span><span>.</span><span>addExecutable</span><span>(</span><span>.</span><span>{</span>
    <span>.</span><span>name</span> = <span>&#34;foo&#34;</span><span>,</span>
    <span>.</span><span>root_source_file</span> = <span>b</span><span>.</span><span>path</span><span>(</span><span>&#34;src/main.zig&#34;</span><span>)</span><span>,</span>
    <span>.</span><span>target</span> = <span>target</span><span>,</span>
    <span>.</span><span>optimize</span> = <span>optimize</span><span>,</span>
<span>}</span><span>)</span><span>;</span>




<span>b</span><span>.</span><span>installArtifact</span><span>(</span><span>exe</span><span>)</span><span>;</span>






<span>const</span> <span>exe_check</span> = <span>b</span><span>.</span><span>addExecutable</span><span>(</span><span>.</span><span>{</span>
    <span>.</span><span>name</span> = <span>&#34;foo&#34;</span><span>,</span>
    <span>.</span><span>root_source_file</span> = <span>b</span><span>.</span><span>path</span><span>(</span><span>&#34;src/main.zig&#34;</span><span>)</span><span>,</span>
    <span>.</span><span>target</span> = <span>target</span><span>,</span>
    <span>.</span><span>optimize</span> = <span>optimize</span><span>,</span>
<span>}</span><span>)</span><span>;</span>







<span>const</span> <span>check</span> = <span>b</span><span>.</span><span>step</span><span>(</span><span>&#34;check&#34;</span><span>,</span> <span>&#34;Check if foo compiles&#34;</span><span>)</span><span>;</span>
<span>check</span><span>.</span><span>dependOn</span><span>(</span><span>&amp;</span><span>exe_check</span><span>.</span><span>step</span><span>)</span><span>;</span>
</code></pre>
<p>The most important part about this second executable definition is that we ask to build it, <strong>but we never install it</strong>. If you look at the final line of the first section, you will see that we call <code>b.installArtifact</code> on the original executable, but for the executable bound to the &#34;check&#34; step, we don&#39;t.</p><p>This one-line difference will have a big impact on the resulting behavior of the build as it will add the <code>-fno-emit-bin</code> flag to the compiler invocation which, in other words, means that Zig will analyze your code (and report any error) but it won&#39;t bother calling into LLVM since you don&#39;t plan to install the executable anyway.</p><p>The result is that you will get diagnostics pretty fast since you won&#39;t have to go through the &#34;LLVM Emit Code...&#34; phase.</p><p>Once you&#39;re done with this, restart your editor (or at least ZLS), <strong>save your file with an error in it</strong>, and enjoy your new spiffy diagnostics.</p><h2>It Only Gets Better</h2><p>With a handful of changes you can get closer to a complete developer experience, but this is not the end.</p><p>The Zig project is still busy working on key compiler infrastructure and it will take a bit more time before we&#39;ll be able to do better than what ZLS can already do today, but <strong>it&#39;s definitely on our roadmap to give developers best in class dev tools, just like Zig is already providing you with a state of the art compiler toolchain</strong>.</p><p>The next big item on our roadmap is removing LLVM from our debug build pipeline to <strong>massively</strong> speed up debug builds. After that, incremental compilation will turn those speed ups into instant rebuilds of arbitrarily big projects. To achieve this second goal we plan to have the compiler stay on between compilations in order to keep in memory all the necessary state to re-analyze, re-compile and patch into the final executable only the parts of your project that changed.</p><p>Once this system is in place, we plan to have the Zig compiler answer all kinds of questions about the compiled project including (but definitely not limited to) what an LSP would need to provide code intelligence features.</p><p>Until we get there, ZLS is filling in the void in a beautiful manner and I&#39;m personally deeply thankful to all the community members who have worked on it over time, starting from the late Alex Naskos.</p><p>If you want to help us get faster to a complete developer experience, <a href="https://ziglang.org/zsf/">consider donating to the Zig Software Foundation</a>. Earlier this year Andrew <a href="https://ziglang.org/news/2024-financials/">published our finances</a> and more than 90% of our income goes to paying developers working on the Zig project, making your donation a genuinely effective way to get us faster to v1.0.</p></div></div>
  </body>
</html>
