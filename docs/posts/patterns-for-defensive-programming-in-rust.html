<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://corrode.dev/blog/defensive-programming/">Original</a>
    <h1>Patterns for Defensive Programming in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <div>
    

      <p>I have a hobby.</p>
<p>Whenever I see the comment <code>// this should never happen</code> in code, I try to find out the exact conditions under which <em>it could</em> happen.
And in 90% of cases, I find a way to do just that.
More often than not, the developer just hasn’t considered all edge cases or future code changes.</p>
<p>In fact, the reason why I like this comment so much is that it often <strong>marks the exact spot</strong> where strong guarantees fall apart.
Often, violating implicit invariants that aren’t enforced by the compiler are the root cause.</p>
<p>Yes, the compiler prevents memory safety issues, and the standard library is best-in-class.
But even the standard library <a href="https://ntietz.com/blog/pitfalls-of-safe-rust">has its warts</a> and bugs in business logic can still happen.</p>
<p>All we can work with are hard-learned patterns to write more defensive Rust code, learned throughout years of shipping Rust code to production.
I’m not talking about design patterns here, but rather small idioms, which are rarely documented, but make a big difference in the overall code quality.</p>
<h2 id="code-smell-indexing-into-a-vector"><a href="#code-smell-indexing-into-a-vector" aria-label="Anchor link for: code-smell-indexing-into-a-vector">Code Smell: Indexing Into a Vector</a></h2>
<p>Here’s some innocent-looking code:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>if</span> <span>!</span>matching_users<span>.</span><span>is_empty</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span><span><span>    <span>let</span> existing_user <span>=</span> <span>&amp;</span>matching_users<span><span>[</span><span>0</span><span>]</span></span><span>;</span>
</span></span><span><span>    </span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>What if you refactor it and forget to keep the <code>is_empty()</code> check?
The problem is that the vector indexing is decoupled from checking the length.
So <code>matching_users[0]</code> can panic at runtime if the vector is empty.</p>
<p>Checking the length and indexing are two separate operations, which can be changed independently.
That’s our first implicit invariant that’s not enforced by the compiler.</p>
<p>If we use slice pattern matching instead, we’ll only get access to the element if the correct <code>match</code> arm is executed.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>match</span> matching_users<span>.</span><span>as_slice</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span><span><span>    <span><span>[</span><span>]</span></span> <span>=&gt;</span> <span>todo!</span><span><span>(</span><span><span>&#34;</span>What to do if no users found!?<span>&#34;</span></span></span><span><span>)</span></span><span>,</span>
</span></span><span><span>    <span><span>[</span>existing_user<span>]</span></span> <span>=&gt;</span> <span><span>{</span>  </span></span></span><span><span><span>        </span></span></span><span><span><span>        </span></span></span><span><span><span>    </span><span><span>}</span></span>
</span></span><span><span>    <span>_</span> <span>=&gt;</span> <span>Err</span><span><span>(</span><span>RepositoryError<span>::</span></span>DuplicateUsers</span><span><span>)</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>Note how this automatically uncovered one more edge case: what if the list is empty?
We hadn’t explicitly considered this case before.
The compiler-enforced pattern matching requires us to think about all possible states!
This is a common pattern in all robust Rust code: putting the compiler in charge of enforcing invariants.</p>
<h2 id="code-smell-lazy-use-of-default"><a href="#code-smell-lazy-use-of-default" aria-label="Anchor link for: code-smell-lazy-use-of-default">Code Smell: Lazy use of <code>Default</code></a></h2>
<p>When initializing an object with many fields, it’s tempting to use <code>..Default::default()</code> to fill in the rest.
In practice, this is a common source of bugs.
You might forget to explicitly set a new field later when you add it to the struct (thus using the default value instead, which might not be what you want), or you might not be aware of all the fields that are being set to default values.</p>
<p>Instead of this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> foo <span>=</span> Foo <span><span>{</span>
</span></span><span><span>    field1<span>:</span> value1<span>,</span>
</span></span><span><span>    field2<span>:</span> value2<span>,</span>
</span></span><span><span>    <span>..</span><span>Default</span><span><span>::</span></span>default<span><span>(</span></span><span><span>)</span></span>  </span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>Do this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> foo <span>=</span> Foo <span><span>{</span>
</span></span><span><span>    field1<span>:</span> value1<span>,</span>
</span></span><span><span>    field2<span>:</span> value2<span>,</span>
</span></span><span><span>    field3<span>:</span> value3<span>,</span> </span></span><span><span>    field4<span>:</span> value4<span>,</span>
</span></span><span><span>    </span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>Yes, it’s slightly more verbose, but what you gain is that the compiler will force you to handle all fields explicitly.
Now when you add a new field to <code>Foo</code>, the compiler will remind you to set it here as well and reflect on which value makes sense.</p>
<p>If you still prefer to use <code>Default</code> but don’t want to lose compiler checks, you can also destructure the default instance:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> Foo <span><span>{</span> field1<span>,</span> field2<span>,</span> field3<span>,</span> field4 </span><span><span>}</span></span> <span>=</span> <span>Foo<span>::</span></span>default<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>This way, you get all the default values assigned to local variables and you can still override what you need:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> foo <span>=</span> Foo <span><span>{</span>
</span></span><span><span>    field1<span>:</span> value1<span>,</span>    </span></span><span><span>    field2<span>:</span> value2<span>,</span>    </span></span><span><span>    field3<span>,</span>            </span></span><span><span>    field4<span>,</span>            </span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>This pattern gives you the best of both worlds:</p>
<ul>
<li>You get default values without duplicating default logic</li>
<li>The compiler will complain when new fields are added to the struct</li>
<li>Your code automatically adapts when default values change</li>
<li>It’s clear which fields use defaults and which have custom values</li>
</ul>
<h2 id="code-smell-fragile-trait-implementations"><a href="#code-smell-fragile-trait-implementations" aria-label="Anchor link for: code-smell-fragile-trait-implementations">Code Smell: Fragile Trait Implementations</a></h2>
<p>Completely destructuring a struct into its components can also be a defensive strategy for API adherence.
For example, let’s say you’re building a pizza ordering system and have an order type like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>PizzaOrder</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>size</span><span>:</span> PizzaSize,
</span></span></span><span><span><span>    <span>toppings</span><span>:</span> <span><span>Vec</span><span>&lt;</span>Topping<span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>crust_type</span><span>:</span> CrustType,
</span></span></span><span><span><span>    <span>ordered_at</span><span>:</span> SystemTime,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>For your order tracking system, you want to compare orders based on what’s actually on the pizza - the <code>size</code>, <code>toppings</code>, and <code>crust_type</code>. The <code>ordered_at</code> timestamp shouldn’t affect whether two orders are considered the same.</p>
<p>Here’s the problem with the obvious approach:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span>PartialEq <span>for</span></span><span> <span>PizzaOrder</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>eq</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>other</span><span>:</span> <span>&amp;</span><span>Self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>size <span>==</span> other<span>.</span>size 
</span></span></span></span></span><span><span><span><span><span>            <span>&amp;&amp;</span> <span>self</span><span>.</span>toppings <span>==</span> other<span>.</span>toppings 
</span></span></span></span></span><span><span><span><span><span>            <span>&amp;&amp;</span> <span>self</span><span>.</span>crust_type <span>==</span> other<span>.</span>crust_type
</span></span></span></span></span><span><span><span><span><span>            </span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Now imagine your team adds a field for customization options:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>PizzaOrder</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>size</span><span>:</span> PizzaSize,
</span></span></span><span><span><span>    <span>toppings</span><span>:</span> <span><span>Vec</span><span>&lt;</span>Topping<span>&gt;</span></span>,
</span></span></span><span><span><span>    <span>crust_type</span><span>:</span> CrustType,
</span></span></span><span><span><span>    <span>ordered_at</span><span>:</span> SystemTime,
</span></span></span><span><span><span>    <span>extra_cheese</span><span>:</span> <span>bool</span>, </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Your <code>PartialEq</code> implementation still compiles, but is it correct?
Should <code>extra_cheese</code> be part of the equality check?
Probably yes - a pizza with extra cheese is a different order!
But you’ll never know because the compiler won’t remind you to think about it.</p>
<p>Here’s the defensive approach using destructuring:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span>PartialEq <span>for</span></span><span> <span>PizzaOrder</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>eq</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>other</span><span>:</span> <span>&amp;</span><span>Self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>let</span> <span>Self</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            size<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            toppings<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            crust_type<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            ordered_at<span>:</span> <span>_</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span> <span>=</span> <span>self</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>let</span> <span>Self</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            size<span>:</span> other_size<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            toppings<span>:</span> other_toppings<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            crust_type<span>:</span> other_crust<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            ordered_at<span>:</span> <span>_</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span> <span>=</span> other<span>;</span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        size <span>==</span> other_size <span>&amp;&amp;</span> toppings <span>==</span> other_toppings <span>&amp;&amp;</span> crust_type <span>==</span> other_crust
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Now when someone adds the <code>extra_cheese</code> field, this code won’t compile anymore.
The compiler forces you to decide: should <code>extra_cheese</code> be included in the comparison or explicitly ignored with <code>extra_cheese: _</code>?</p>
<p>This pattern works for any trait implementation where you need to handle struct fields: <code>Hash</code>, <code>Debug</code>, <code>Clone</code>, etc.
It’s especially valuable in codebases where structs evolve frequently as requirements change.</p>
<h2 id="code-smell-from-impls-that-are-really-tryfrom"><a href="#code-smell-from-impls-that-are-really-tryfrom" aria-label="Anchor link for: code-smell-from-impls-that-are-really-tryfrom">Code Smell: <code>From</code> Impls That Are Really <code>TryFrom</code></a></h2>
<p>Sometimes there’s no conversion that will work 100% of the time.
That’s fine.
When that’s the case, resist the temptation to offer a <code>From</code> implementation out of habit; use <code>TryFrom</code> instead.</p>
<p>Here’s an example of <code>TryFrom</code> in disguise:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>&amp;</span>DetectorStartupErrorReport<span>&gt;</span></span> <span>for</span></span><span> <span>DetectorStartupErrorSubject</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>report</span><span>:</span> <span>&amp;</span>DetectorStartupErrorReport</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>let</span> postfix <span>=</span> report
</span></span></span></span></span><span><span><span><span><span>            <span>.</span><span>get_identifier</span><span><span>(</span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>            <span>.</span><span>or_else</span><span><span>(</span>get_binary_name</span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>            <span>.</span><span>unwrap_or_else</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>|</span></span> </span><span><span>UNKNOWN_DETECTOR_SUBJECT</span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>Self</span><span><span>(</span><span>StreamSubject<span>::</span></span>from<span><span>(</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>format!</span><span><span>(</span></span><span><span><span>&#34;</span>apps.errors.detectors.startup.<span>{postfix}</span><span>&#34;</span></span></span><span><span>)</span></span><span>.</span><span>as_str</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The <code>unwrap_or_else</code> is a hint that this conversion can fail in some way.
We set a default value instead, but is it really the right thing to do for all callers?
This should be a <code>TryFrom</code> implementation instead, making the fallible nature explicit.
We fail fast instead of continuing with a potentially flawed business logic.</p>
<h2 id="code-smell-non-exhaustive-matches"><a href="#code-smell-non-exhaustive-matches" aria-label="Anchor link for: code-smell-non-exhaustive-matches">Code Smell: Non-Exhaustive Matches</a></h2>
<p>It’s tempting to use <code>match</code> in combination with a catch-all pattern like <code>_ =&gt; {}</code>, but this can haunt you later.
The problem is that you might forget to handle a new case that was added later.</p>
<p>Instead of:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>match</span> <span>self</span> <span><span>{</span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant1 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant2 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>_</span> <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>Use:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>match</span> <span>self</span> <span><span>{</span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant1 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant2 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant3 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant4 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>By spelling out all variants explicitly, the compiler will warn you when a new variant is added, forcing you to handle it.
Another case of putting the compiler to work.</p>
<p>If the code for two variants is the same, you can group them:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>match</span> <span>self</span> <span><span>{</span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant1 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant2 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Variant3 <span>|</span> <span>Self</span><span><span>::</span></span>Variant4 <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<h2 id="code-smell-placeholders-for-unused-variables"><a href="#code-smell-placeholders-for-unused-variables" aria-label="Anchor link for: code-smell-placeholders-for-unused-variables">Code Smell: <code>_</code> Placeholders for Unused Variables</a></h2>
<p>Using <code>_</code> as a placeholder for unused variables can lead to confusion.
For example, you might get confused about which variable was skipped.
That’s especially true for boolean flags:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>match</span> <span>self</span> <span><span>{</span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Rocket <span><span>{</span> <span>_</span><span>,</span> <span>_</span><span>,</span> <span>..</span> </span><span><span>}</span></span> <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>In the above example, it’s not clear which variables were skipped and why.
Better to use descriptive names for the variables that are not used:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>match</span> <span>self</span> <span><span>{</span>
</span></span><span><span>    <span>Self</span><span><span>::</span></span>Rocket <span><span>{</span> has_fuel<span>:</span> <span>_</span><span>,</span> has_crew<span>:</span> <span>_</span><span>,</span> <span>..</span> </span><span><span>}</span></span> <span>=&gt;</span> <span><span>{</span>  </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>Even if you don’t use the variables, it’s clear what they represent and the code becomes more readable and easier to review without inline type hints.</p>
<h2 id="pattern-temporary-mutability"><a href="#pattern-temporary-mutability" aria-label="Anchor link for: pattern-temporary-mutability">Pattern: Temporary Mutability</a></h2>
<p>If you only want your data to be mutable temporarily, make that explicit.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>mut</span> data <span>=</span> <span>get_vec</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span>data<span>.</span><span>sort</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span><span>let</span> data <span>=</span> data<span>;</span>  </span><span>
</span><span></span></code></pre>
<p>This pattern is often called “temporary mutability” and helps prevent accidental modifications after initialization.
See the <a rel="noopener noreferrer" target="_blank" href="https://rust-unofficial.github.io/patterns/idioms/temporary-mutability.html">Rust unofficial patterns book</a> for more details.</p>
<p>You can go one step further and do the initialization part in a scope block:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> data <span>=</span> <span><span>{</span>
</span></span><span><span>    <span>let</span> <span>mut</span> data <span>=</span> <span>get_vec</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span><span><span>    data<span>.</span><span>sort</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span><span><span>    data  </span></span><span><span></span><span><span>}</span></span><span>;</span>
</span><span></span></code></pre>
<p>This way, the mutable variable is confined to the inner scope, making it clear that it’s only used for initialization.
In case you use any temporary variables during initialization, they won’t leak into the outer scope.
In our case above, there were none, but imagine if we had a temporary vector to hold intermediate results:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> data <span>=</span> <span><span>{</span>
</span></span><span><span>    <span>let</span> <span>mut</span> data <span>=</span> <span>get_vec</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span><span><span>    <span>let</span> temp <span>=</span> <span>compute_something</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span><span><span>    data<span>.</span><span>extend</span><span><span>(</span>temp</span><span><span>)</span></span><span>;</span>
</span></span><span><span>    data<span>.</span><span>sort</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span><span><span>    data  </span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>Here, <code>temp</code> is only accessible within the inner scope, which prevents it from accidental use later on.</p>
<p>This is especially useful when you have multiple temporary variables during initialization that you don’t want accessible in the rest of the function.
The scope makes it crystal clear that these variables are only meant for initialization.</p>
<h2 id="pattern-defensively-handle-constructors"><a href="#pattern-defensively-handle-constructors" aria-label="Anchor link for: pattern-defensively-handle-constructors">Pattern: Defensively Handle Constructors</a></h2>
<div>
  
  
  
  <p>The following pattern is only truly helpful for libraries and APIs that need to be robust against future changes.
In such a case, you want to ensure that all instances of a type are created through a constructor function that enforces validation logic.
Because without that, future refactorings can easily lead to invalid states.</p>
<p>For application code, it’s probably best to keep things simple.
You typically have all the call sites under control and can ensure that validation logic is always called.</p>

</div>
<p>Let’s say you have a simple type like the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>pub</span> <span>struct</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>pub</span> <span>field1</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>field2</span><span>:</span> <span>u32</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Now you want to add validation logic to ensure invalid states are never created.
One pattern is to return a <code>Result</code> from the constructor:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>field1</span><span>:</span> String, <span>field2</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>if</span> field1<span>.</span><span>is_empty</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field1 cannot be empty<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        <span>if</span> field2 <span>==</span> <span>0</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field2 cannot be zero<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        <span>Ok</span><span><span>(</span><span>Self</span> <span><span>{</span> field1<span>,</span> field2 </span><span><span>}</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>But nothing stops someone from bypassing your validation by creating an instance directly:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> s <span>=</span> S <span><span>{</span>
</span></span><span><span>    field1<span>:</span> <span><span>&#34;</span><span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span><span><span>    field2<span>:</span> <span>0</span><span>,</span>
</span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>This should not be possible!
It is our implicit invariant that’s not enforced by the compiler: the validation logic is decoupled from struct construction.
These are two separate operations, which can be changed independently and the compiler won’t complain.</p>
<p>To force <strong>external code</strong> to go through your constructor, add a private field:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>pub</span> <span>struct</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>pub</span> <span>field1</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>field2</span><span>:</span> <span>u32</span>,
</span></span></span><span><span><span>    <span>_private</span><span>:</span> <span>(</span><span>)</span>, </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>field1</span><span>:</span> String, <span>field2</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>if</span> field1<span>.</span><span>is_empty</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field1 cannot be empty<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        <span>if</span> field2 <span>==</span> <span>0</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field2 cannot be zero<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        <span>Ok</span><span><span>(</span><span>Self</span> <span><span>{</span> field1<span>,</span> field2<span>,</span> _private<span>:</span> <span><span>(</span></span><span><span>)</span></span> </span><span><span>}</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Now code outside your module cannot construct <code>S</code> directly because it cannot access the <code>_private</code> field.
The compiler enforces that all construction must go through your <code>new()</code> method, which includes your validation logic!</p>
<div>
  
  
  
  <p>Note that the underscore prefix is just a <strong>naming convention</strong> to indicate the field is intentionally unused; it’s the lack of <code>pub</code> that makes it private and prevents external construction.</p>

</div>
<p>For libraries that need to evolve over time, you can also use the <code>#[non_exhaustive]</code> attribute instead:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>non_exhaustive</span><span>]</span></span>
</span><span><span><span>pub</span> <span>struct</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>pub</span> <span>field1</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>field2</span><span>:</span> <span>u32</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>This has the same effect of preventing construction outside your crate, but also signals to users that you might add more fields in the future.
The compiler will prevent them from using struct literal syntax, forcing them to use your constructor.</p>
<div>
  
  
  
  <p>There’s a big difference between these two approaches:</p>
<ul>
<li><code>#[non_exhaustive]</code> only works across crate boundaries. <strong>It prevents construction outside your crate.</strong></li>
<li><code>_private</code> works at the module boundary. <strong>It prevents construction outside the module</strong>, but within the same crate.</li>
</ul>
<p>On top of that, some developers find <code>_private: ()</code> more explicit about intent: “this struct has a private field that prevents construction.”</p>
<p>With <code>#[non_exhaustive]</code>, the primary intent is signaling that fields might be added in the future, and preventing construction is more of a side effect.</p>

</div>
<p>But what about code within the <strong>same module</strong>?
With the patterns above, code in the same module can still bypass your validation:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span>let</span> s <span>=</span> S <span><span>{</span>
</span></span><span><span>    field1<span>:</span> <span><span>&#34;</span><span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span><span><span>    field2<span>:</span> <span>0</span><span>,</span>
</span></span><span><span>    _private<span>:</span> <span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>Rust’s privacy works at the module level, not the type level.
Anything in the same module can access private items.</p>
<p>If you need to enforce constructor usage even within your own module, you need a more defensive approach using nested private modules:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>mod</span> <span>inner</span> <span><span>{</span>
</span></span></span><span><span><span>    <span><span>pub</span> <span>struct</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>pub</span> <span>field1</span><span>:</span> String,
</span></span></span></span></span><span><span><span><span><span>        <span>pub</span> <span>field2</span><span>:</span> <span>u32</span>,
</span></span></span></span></span><span><span><span><span><span>        <span>_seal</span><span>:</span> Seal,
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span><span>struct</span> </span><span><span>Seal</span></span><span>;</span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span><span>impl</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>field1</span><span>:</span> String, <span>field2</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>if</span> field1<span>.</span><span>is_empty</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field1 cannot be empty<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>if</span> field2 <span>==</span> <span>0</span> <span><span>{</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field2 cannot be zero<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>Ok</span><span><span>(</span><span>Self</span> <span><span>{</span> field1<span>,</span> field2<span>,</span> _seal<span>:</span> Seal </span><span><span>}</span></span></span><span><span>)</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span>pub</span> <span>use</span> <span>inner<span>::</span></span>S<span>;</span>
</span></code></pre>
<p>Now even code in your outer module cannot construct <code>S</code> directly because <code>Seal</code> is trapped in the private <code>inner</code> module.
Only the <code>new()</code> method, which lives in the same module as <code>Seal</code>, can construct it.
The compiler guarantees that all construction, even internal construction, goes through your validation logic.</p>
<p>You could still access the public fields directly, though.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> s <span>=</span> <span>S<span>::</span></span>new<span><span>(</span><span><span>&#34;</span>valid<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>,</span> <span>42</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span>s<span>.</span>field1 <span>=</span> <span><span>&#34;</span><span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>;</span> </span></code></pre>
<p>To prevent that, you can make the fields private and provide getter methods instead:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>mod</span> <span>inner</span> <span><span>{</span>
</span></span></span><span><span><span>    <span><span>pub</span> <span>struct</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>field1</span><span>:</span> String,
</span></span></span></span></span><span><span><span><span><span>        <span>field2</span><span>:</span> <span>u32</span>,
</span></span></span></span></span><span><span><span><span><span>        <span>_seal</span><span>:</span> Seal,
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span><span>struct</span> </span><span><span>Seal</span></span><span>;</span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span><span>impl</span> </span><span><span>S</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>field1</span><span>:</span> String, <span>field2</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>if</span> field1<span>.</span><span>is_empty</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field1 cannot be empty<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>if</span> field2 <span>==</span> <span>0</span> <span><span>{</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>                <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>field2 cannot be zero<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>Ok</span><span><span>(</span><span>Self</span> <span><span>{</span> field1<span>,</span> field2<span>,</span> _seal<span>:</span> Seal </span><span><span>}</span></span></span><span><span>)</span></span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span></span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span><span><span>pub</span> <span>fn</span> </span><span>field1</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>&amp;</span><span>str</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>&amp;</span><span>self</span><span>.</span>field1
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span></span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span><span><span>pub</span> <span>fn</span> </span><span>field2</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>u32</span></span> </span><span><span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            <span>self</span><span>.</span>field2
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>        </span><span><span>}</span></span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Now the only way to create an instance of <code>S</code> is through the <code>new()</code> method, and the only way to access its fields is through the getter methods.</p>
<h3 id="when-to-use-each"><a href="#when-to-use-each" aria-label="Anchor link for: when-to-use-each">When to Use Each</a></h3>
<p>To enforce validation through constructors:</p>
<ul>
<li><strong>For external code</strong>: Add a private field like <code>_private: ()</code> or use <code>#[non_exhaustive]</code></li>
<li><strong>For internal code</strong>: Use nested private modules with a private “seal” type</li>
<li><strong>Choose based on your needs</strong>: Most code only needs to prevent external construction; forcing internal construction is more defensive but also more complex</li>
</ul>
<p>The key insight is that by making construction impossible without access to a private type, you turn your validation logic from a convention into a guarantee enforced by the compiler.
So let’s put that compiler to work!</p>
<h2 id="pattern-use-must-use-on-important-types"><a href="#pattern-use-must-use-on-important-types" aria-label="Anchor link for: pattern-use-must-use-on-important-types">Pattern: Use <code>#[must_use]</code> on Important Types</a></h2>
<p>The <code>#[must_use]</code> attribute is often neglected.
That’s sad, because it’s such a simple yet powerful mechanism to prevent callers from accidentally ignoring important return values.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>must_use</span> <span>=</span> <span><span>&#34;</span>Configuration must be applied to take effect<span>&#34;</span></span><span>]</span></span>
</span><span><span><span>pub</span> <span>struct</span> </span><span><span>Config</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>Config</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>with_timeout</span></span><span><span><span>(</span><span>mut</span> <span>self</span>, <span>timeout</span><span>:</span> Duration</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>timeout <span>=</span> timeout<span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Now if someone creates a <code>Config</code> but forgets to use it, the compiler will warn them
(even with a custom message!):</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> config <span>=</span> <span>Config<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span></span><span>config<span>.</span><span>with_timeout</span><span><span>(</span><span>Duration<span>::</span></span>from_secs<span><span>(</span><span>30</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span> 
</span><span>
</span><span></span><span><span>let</span> config <span>=</span> <span>Config<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span>
</span><span>    <span>.</span><span>with_timeout</span><span><span>(</span><span>Duration<span>::</span></span>from_secs<span><span>(</span><span>30</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span><span><span>apply_config</span><span><span>(</span>config</span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>This is especially useful for guard types that need to be held for their lifetime and results from operations that must be checked.
The standard library uses this extensively.
For example, <code>Result</code> is marked with <code>#[must_use]</code>, which is why you get warnings if you don’t handle errors.</p>
<h2 id="code-smell-boolean-parameters"><a href="#code-smell-boolean-parameters" aria-label="Anchor link for: code-smell-boolean-parameters">Code Smell: Boolean Parameters</a></h2>
<p>Boolean parameters make code hard to read at the call site and are error-prone.
We all know the scenario where we’re sure this will be the last boolean parameter we’ll ever add to a function.</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span><span><span>fn</span> </span><span>process_data</span></span><span><span><span>(</span><span>data</span><span>:</span> <span>&amp;</span>[<span>u8</span>], <span>compress</span><span>:</span> <span>bool</span>, <span>encrypt</span><span>:</span> <span>bool</span>, <span>validate</span><span>:</span> <span>bool</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span>process_data</span><span><span>(</span><span>&amp;</span>data<span>,</span> <span>true</span><span>,</span> <span>false</span><span>,</span> <span>true</span></span><span><span>)</span></span><span>;</span>  </span></code></pre>
<p>It’s impossible to understand what this code does without looking at the function signature.
Even worse, it’s easy to accidentally swap the boolean values.</p>
<p>Instead, use enums to make the intent explicit:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>enum</span> <span>Compression</span> <span><span>{</span>
</span></span></span><span><span><span>    Strong<span>,</span>
</span></span></span><span><span><span>    Medium<span>,</span>
</span></span></span><span><span><span>    <span>None</span><span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>enum</span> <span>Encryption</span> <span><span>{</span>
</span></span></span><span><span><span>    <span>AES</span><span>,</span>
</span></span></span><span><span><span>    ChaCha20<span>,</span>
</span></span></span><span><span><span>    <span>None</span><span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>enum</span> <span>Validation</span> <span><span>{</span>
</span></span></span><span><span><span>    Enabled<span>,</span>
</span></span></span><span><span><span>    Disabled<span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>process_data</span></span><span><span><span>(</span>
</span></span></span><span><span><span>    <span>data</span><span>:</span> <span>&amp;</span>[<span>u8</span>],
</span></span></span><span><span><span>    <span>compression</span><span>:</span> Compression,
</span></span></span><span><span><span>    <span>encryption</span><span>:</span> Encryption,
</span></span></span><span><span><span>    <span>validation</span><span>:</span> Validation,
</span></span></span><span><span><span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span>process_data</span><span><span>(</span>
</span></span><span><span>    <span>&amp;</span>data<span>,</span>
</span></span><span><span>    <span>Compression<span>::</span></span>Strong<span>,</span>
</span></span><span><span>    <span>Encryption<span>::</span></span>None<span>,</span>
</span></span><span><span>    <span>Validation<span>::</span></span>Enabled
</span></span><span><span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>This is much more readable and the compiler will catch mistakes if you pass the wrong enum type.
You will notice that the enum variants can be more descriptive than just <code>true</code> or <code>false</code>.
And more often than not, there are more than two meaningful options; especially for programs which grow over time.</p>
<p>For functions with many options, you can configure them using a parameter struct:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>ProcessDataParams</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>compression</span><span>:</span> Compression,
</span></span></span><span><span><span>    <span>encryption</span><span>:</span> Encryption,
</span></span></span><span><span><span>    <span>validation</span><span>:</span> Validation,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>ProcessDataParams</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>production</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>Self</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            compression<span>:</span> <span>Compression<span>::</span></span>Strong<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            encryption<span>:</span> <span>Encryption<span>::</span></span><span>AES</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            validation<span>:</span> <span>Validation<span>::</span></span>Enabled<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>development</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>Self</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            compression<span>:</span> <span>Compression<span>::</span></span>None<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            encryption<span>:</span> <span>Encryption<span>::</span></span>None<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            validation<span>:</span> <span>Validation<span>::</span></span>Enabled<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>process_data</span></span><span><span><span>(</span><span>data</span><span>:</span> <span>&amp;</span>[<span>u8</span>], <span>params</span><span>:</span> ProcessDataParams</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span>process_data</span><span><span>(</span><span>&amp;</span>data<span>,</span> <span>ProcessDataParams<span>::</span></span>production<span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span><span>
</span><span></span><span><span>process_data</span><span><span>(</span><span>&amp;</span>data<span>,</span> ProcessDataParams <span><span>{</span>
</span></span></span><span><span><span>    compression<span>:</span> <span>Compression<span>::</span></span>Medium<span>,</span>
</span></span></span><span><span><span>    encryption<span>:</span> <span>Encryption<span>::</span></span>ChaCha20<span>,</span>
</span></span></span><span><span><span>    validation<span>:</span> <span>Validation<span>::</span></span>Enabled<span>,</span> 
</span></span></span><span><span><span></span><span><span>}</span></span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>This approach scales much better as your function evolves.
Adding new parameters doesn’t break existing call sites, and you can easily add defaults or make certain fields optional.
The preset methods also document common use cases and make it easy to use the right configuration for different scenarios.</p>
<p>Rust is often criticized for not having named parameters, but using a parameter struct is arguably even better for larger functions with many options.</p>
<h2 id="clippy-lints-for-defensive-programming"><a href="#clippy-lints-for-defensive-programming" aria-label="Anchor link for: clippy-lints-for-defensive-programming">Clippy Lints for Defensive Programming</a></h2>
<p>Many of these patterns can be enforced automatically using Clippy lints.
Here are the most relevant ones:</p>
<table><thead><tr><th>Lint</th><th>Description</th></tr></thead><tbody>
<tr><td><a rel="noopener noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing"><code>clippy::indexing_slicing</code></a></td><td>Prevents direct indexing into slices and vectors</td></tr>
<tr><td><a rel="noopener noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#fallible_impl_from"><code>clippy::fallible_impl_from</code></a></td><td>Warns about <code>From</code> implementations that can panic and should be <code>TryFrom</code> instead.</td></tr>
<tr><td><a rel="noopener noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_enum_match_arm"><code>clippy::wildcard_enum_match_arm</code></a></td><td>Disallows wildcard <code>_</code> patterns.</td></tr>
<tr><td><a rel="noopener noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern"><code>clippy::unneeded_field_pattern</code></a></td><td>Identifies when you’re ignoring too many struct fields with <code>..</code> unnecessarily.</td></tr>
<tr><td><a rel="noopener noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#fn_params_excessive_bools"><code>clippy::fn_params_excessive_bools</code></a></td><td>Warns when a function has too many boolean parameters (4 or more by default).</td></tr>
<tr><td><a rel="noopener noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#must_use_candidate"><code>clippy::must_use_candidate</code></a></td><td>Suggests adding <code>#[must_use]</code> to types that are good candidates for it.</td></tr>
</tbody></table>
<p>You can enable these in your project by adding them at the top of your crate, e.g.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::indexing_slicing</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::fallible_impl_from</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::wildcard_enum_match_arm</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::unneeded_field_pattern</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::fn_params_excessive_bools</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::must_use_candidate</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span></code></pre>
<p>Or in your <code>Cargo.toml</code>:</p>
<pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>lints</span><span>.</span><span>clippy</span></span><span>]</span>
</span><span><span><span>indexing_slicing</span></span> <span>=</span> <span><span>&#34;</span>deny<span>&#34;</span></span>
</span><span><span><span>fallible_impl_from</span></span> <span>=</span> <span><span>&#34;</span>deny<span>&#34;</span></span>
</span><span><span><span>wildcard_enum_match_arm</span></span> <span>=</span> <span><span>&#34;</span>deny<span>&#34;</span></span>
</span><span><span><span>unneeded_field_pattern</span></span> <span>=</span> <span><span>&#34;</span>deny<span>&#34;</span></span>
</span><span><span><span>fn_params_excessive_bools</span></span> <span>=</span> <span><span>&#34;</span>deny<span>&#34;</span></span>
</span><span><span><span>must_use_candidate</span></span> <span>=</span> <span><span>&#34;</span>deny<span>&#34;</span></span>
</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>Defensive programming in Rust is about leveraging the type system and compiler to catch bugs before they happen.
By following these patterns, you can:</p>
<ul>
<li>Make implicit invariants explicit and compiler-checked</li>
<li>Future-proof your code against refactoring mistakes</li>
<li>Reduce the surface area for bugs</li>
</ul>
<p>It’s a skill that doesn’t come naturally and it’s not covered in most Rust books, but knowing these patterns can make the difference between code that works but is brittle, and code that is robust and maintainable for years to come.</p>
<p>Remember: if you find yourself writing <code>// this should never happen</code>, take a step back and ask how the compiler could enforce that invariant for you instead.
The best bug is the one that never compiles in the first place.</p>

    </div>
  </div></div>
  </body>
</html>
