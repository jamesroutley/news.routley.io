<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://x86.lol/generic/2025/12/19/polyglot.html">Original</a>
    <h1>The Polyglot NixOS</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>Recently a <a href="https://github.com/samueldr">colleague</a> mentioned building
NixOS images that run unchanged on multiple architectures. Given the past
adventures on this blog with <a href="https://x86.lol/generic/2024/08/28/systemd-sysupdate.html">systemd-repart</a> and
<a href="https://x86.lol/generic/2024/09/21/cross-compile-riscv.html">cross-compiling NixOS</a>, I decide to give this a
go.</p>

<p><strong>tl;dr</strong> You can find a quick’n’dirty implementation
<a href="https://github.com/blitz/polyglot-image">here</a>. Check the repo for
details on how to build and run it.</p>

<p>So do we want to do: We want to build <em>one</em> disk image that boots on
x86_64, ARM AArch64, and RISC-V 64-bit. We limit ourselves here to
UEFI platforms, which makes this pretty straight forward.</p>

<p>From a high-level we need to:</p>

<ol>
  <li>Have a NixOS configuration.</li>
  <li>Build the system closure for each target.</li>
  <li>Throw everything into one <code>/nix/store</code> partition.</li>
  <li>Populate the <a href="https://en.wikipedia.org/wiki/EFI_system_partition">ESP</a> to
boot the right closure depending on the architecture.</li>
</ol>

<p>All of this is surprisingly straight-forward. The ESP has
architecture-dependent default filenames for what the firmware should
boot, given no other configuration. This means we can build an
<a href="https://wiki.archlinux.org/title/Unified_kernel_image">UKI</a> per
architecture and drop it at the right place in the ESP
(<code>/EFI/BOOT/BOOTX64.EFI</code> for 64-bit x86) and we are done!</p>

<p>By linking the system’s UKI in these locations on the ESP, we skip
over having an actual bootloader and thus can’t have multiple
generations, but it makes for a much leaner example!</p>

<p>The <a href="https://github.com/blitz/polyglot-image">example repo</a> puts the
closure for each architecture in a single Nix store partition. I
<em>thought</em> this would bring some space savings, because files that are
not binary code should be largely the same. This doesn’t really pan
out in this small example and we only save a couple of percent. Maybe
it makes a bigger difference for larger closures.</p>

<p>If you want to dig into the details, the <a href="https://github.com/blitz/polyglot-image">example
repo</a> has the instructions
how to build and boot the image. I’m also eager to see someone
building a more comprehensive version of this that includes a fully
functioning bootloader and multiple generations!</p>

  </div></div>
  </body>
</html>
