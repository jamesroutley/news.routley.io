<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mtlynch.io/notes/gleam-first-impressions/">Original</a>
    <h1>My first impressions of gleam</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’m <a href="https://mtlynch.io/notes/which-new-language/">looking for a new programming language</a> to learn this year, and <a href="https://gleam.run">Gleam</a> looks like the most fun. It’s an Elixir-like language that supports static typing.</p><p>I read the <a href="https://tour.gleam.run/">language tour</a>, and it made sense to me, but I need to build something before I can judge a programming language well.</p><p>I’m sharing some notes on my first few hours using Gleam in case they’re helpful to others learning Gleam or to the team developing the language.</p><h2 id="my-project-parsing-old-aim-logs">My project: Parsing old AIM logs<a href="#my-project-parsing-old-aim-logs" arialabel="Anchor"> 🔗︎</a></h2><p>I used AOL Instant Messenger from about 1999 to 2007. For most of that time, I used AIM clients that logged my conversations, but they varied in formats. Most of the log formats are XML or HTML, which make re-reading those logs a pain.</p><p>The simplest AIM logs are the plaintext logs, which look like this:</p><div><pre tabindex="0"><code data-lang="text"><span><span>Session Start (DumbAIMScreenName:Jane): Mon Sep 12 18:44:17 2005
</span></span><span><span>[18:44] Jane: hi
</span></span><span><span>[18:55] Me: hey whats up
</span></span><span><span>Session Close (Jane): Mon Sep 12 18:56:02 2005
</span></span></code></pre></div><p>Every decade or so, I try writing a universal AIM log parser to get all of my old logs into a consistent, readable format. Unfortunately, I always get bored and give up partway through. My last attempt was <a href="https://github.com/mtlynch/chat_unifier">seven years ago</a>, when I tried doing it in Python 2.7.</p><p>Parsing logs is a great match for Gleam because some parts of the project are easy (e.g., parsing the plaintext logs), so I can do the easy parts while I get the hang of Gleam as a language and gradually build up to the harder log formats and adding a web frontend.</p><p>I’ve also heard that functional languages lend themselves especially well to parsing tasks, and I’ve never understood why, so it’s a good opportunity to learn.</p><h2 id="my-background-in-programming-languages">My background in programming languages<a href="#my-background-in-programming-languages" arialabel="Anchor"> 🔗︎</a></h2><p>I’ve been a programmer for 20 years, but I’m no language design connoisseur. I’m sharing things about Gleam I find unintuitive or difficult to work with, but they’re not language critiques, just candid reactions.</p><p>I’ve never worked in a langauge that’s designed for functional programming. The closest would be JavaScript. The <a href="https://mtlynch.io/notes/which-new-language/#how-much-i-enjoy-various-languages">languages I know best</a> are Go and Python.</p><h2 id="how-do-i-parse-command-line-args">How do I parse command-line args?<a href="#how-do-i-parse-command-line-args" arialabel="Anchor"> 🔗︎</a></h2><p>The first thing I wanted to do was figure out how to parse a command-line argument so I could call my app like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>./log-parser ~/logs/aim/plaintext
</span></span></code></pre></div><p>But there’s no Gleam standard library module for reading command-line arguments. I found <a href="https://hexdocs.pm/glint/">glint</a>, and it felt super complicated for just reading one command-line argument. Then, I realized there’s a simpler third-party library called <a href="https://hexdocs.pm/argv/">argv</a>.</p><p>I can parse the command-line argument like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span>()<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>argv.<span>load</span>().arguments<span> </span>{<span>
</span></span></span><span><span><span>    </span>[path]<span> </span>-&gt;<span> </span>io.<span>println</span>(<span>&#34;command-line arg is &#34;</span><span> </span>&lt;&gt;<span> </span>path)<span>
</span></span></span><span><span><span>    </span>_<span> </span>-&gt;<span> </span>io.<span>println</span>(<span>&#34;Usage: gleam run &lt;directory_path&gt;&#34;</span>)<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam run ~/whatever
</span></span><span><span>   Compiled in 0.01s
</span></span><span><span>    Running log_parser.main
</span></span><span><span>command-line arg is /home/mike/whatever
</span></span></code></pre></div><p>Cool, easy enough!</p><h2 id="what-does-gleam-build-do">What does <code>gleam build</code> do?<a href="#what-does-gleam-build-do" arialabel="Anchor"> 🔗︎</a></h2><p>I got my program to run with <code>gleam run</code>, but I was curious if I could compile an executable like <code>go build</code> or <code>zig build</code> does.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam build
</span></span><span><span>   Compiled in 0.01s
</span></span></code></pre></div><p>Hmm, compiled what? I couldn’t see a binary anywhere.</p><p>The <a href="https://gleam.run/command-line-reference/#build">documentation for <code>gleam build</code></a> just says “Build the project” but doesn’t explain <em>what</em> it builds or where it stores the build artifact.</p><p>There’s a <code>build</code> directory, but it doesn’t produce an obvious executable.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ rm -rf build &amp;&amp; gleam build
</span></span><span><span>Downloading packages
</span></span><span><span> Downloaded <span>5</span> packages in 0.00s
</span></span><span><span>  Compiling argv
</span></span><span><span>  Compiling gleam_stdlib
</span></span><span><span>  Compiling filepath
</span></span><span><span>  Compiling gleeunit
</span></span><span><span>  Compiling simplifile
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.52s
</span></span><span><span>
</span></span><span><span>$ ls -1 build/
</span></span><span><span>dev
</span></span><span><span>gleam-dev-erlang.lock
</span></span><span><span>gleam-dev-javascript.lock
</span></span><span><span>gleam-lsp-erlang.lock
</span></span><span><span>gleam-lsp-javascript.lock
</span></span><span><span>gleam-prod-erlang.lock
</span></span><span><span>gleam-prod-javascript.lock
</span></span><span><span>packages
</span></span></code></pre></div><p>From poking around, I think the executables are under <code>build/dev/erlang/log_parser/ebin/</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ ls -1 build/dev/erlang/log_parser/ebin/
</span></span><span><span>log_parser.app
</span></span><span><span>log_parser.beam
</span></span><span><span>log_parser@@main.beam
</span></span><span><span>log_parser_test.beam
</span></span><span><span>plaintext_logs.beam
</span></span><span><span>plaintext_logs_test.beam
</span></span></code></pre></div><p>Those appear to be BEAM bytecode, so I can’t execute them directly. I assume I could get run the BEAM VM manually and execute those files somehow, but that doesn’t sound appealing.</p><p>So, I’ll stick to <code>gleam run</code> to run my app, but I wish <code>gleam build</code> had a better explanation of what it produced and what the developer can do with it.</p><h2 id="let-me-implement-the-simplest-possible-parser">Let me implement the simplest possible parser<a href="#let-me-implement-the-simplest-possible-parser" arialabel="Anchor"> 🔗︎</a></h2><p>To start, I decided to write a function that does basic parsing of plaintext logs.</p><p>So, I wrote a test with what I wanted.</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse_simple_plaintext_log_test</span>()<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>&#34;
</span></span></span><span><span><span>Session Start (DumbAIMScreenName:Jane): Mon Sep 12 18:44:17 2005
</span></span></span><span><span><span>[18:44] Jane: hi
</span></span></span><span><span><span>[18:55] Me: hey whats up
</span></span></span><span><span><span>Session Close (Jane): Mon Sep 12 18:56:02 2005
</span></span></span><span><span><span>&#34;</span><span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>string.trim<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>plaintext_logs.parse<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>should.<span>equal</span>([<span>&#34;hi&#34;</span>,<span> </span><span>&#34;hey whats up&#34;</span>])<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Eventually, I want to parse all the metadata in the conversation, including names, timestamps, and session information. But as a first step, all my function has to do is read an AIM chat log as a string and emit a list of the chat messages as separate strings.</p><p>That meant my actual function would look like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>// Note: todo is a Gleam language keyword to indicate unfinished code.
</span></span></span><span><span><span></span><span>  </span><span>todo</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Just to get it compiling, I add in a dummy implementation:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>[<span>&#34;fake&#34;</span>,<span> </span><span>&#34;data&#34;</span>]<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>And I can test it like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>warning: Unused variable
</span></span><span><span>  ┌─ /home/mike/code/gleam-log-parser2/src/plaintext_logs.gleam:1:14
</span></span><span><span>  │
</span></span><span><span><span>1</span> │ pub fn parse(contents: String) -&gt; List(String) {
</span></span><span><span>  │              ^^^^^^^^^^^^^^^^ This variable is never used
</span></span><span><span>
</span></span><span><span>Hint: You can ignore it with an underscore: <span>`</span>_contents<span>`</span>.
</span></span><span><span>
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;fake&#34;</span>, <span>&#34;data&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.008 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Cool, that’s what I expected. The test is failing because it’s returning hardcoded dummy results that don’t match my test.</p><h2 id="adjusting-my-brain-to-a-functional-language">Adjusting my brain to a functional language<a href="#adjusting-my-brain-to-a-functional-language" arialabel="Anchor"> 🔗︎</a></h2><p>Okay, now it’s time to implement the parsing for real. I need to implement this function:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>todo</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>At this point, I kind of froze up. It struck me that Gleam excludes so many of the tools I’m used to in other languages:</p><ul><li>There are no <code>if</code> statements</li><li>There are no loops</li><li>There’s no <code>return</code> keyword</li><li>There are no list index accessors<ul><li>e.g., you can’t access the n-th element of a <code>List</code></li></ul></li></ul><p>What do I even do? Split the string into tokens and then do something with that?</p><p>Eventually, I realized for a simple implementation, I wanted to just split the string into lines, so I want to do this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I test again, I get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.21s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;Session Start (DumbAIMScreenName:Jane): Mon Sep 12 18:44:17 2005&#34;</span>, <span>&#34;[18:44] Jane: hi&#34;</span>, <span>&#34;[18:55] Me: hey whats up&#34;</span>, <span>&#34;Session Close (Jane): Mon Sep 12 18:56:02 2005&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.009 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Okay, now I’m a little closer.</p><h2 id="how-do-i-iterate-over-a-list-in-a-language-with-no-loops">How do I iterate over a list in a language with no loops?<a href="#how-do-i-iterate-over-a-list-in-a-language-with-no-loops" arialabel="Anchor"> 🔗︎</a></h2><p>I turned my logs into a list of lines, but that’s where I got stuck again.</p><p>I’m so used to <code>for</code> loops that my brain kept thinking, “How do I do a <code>for</code> loop to iterate over the elements?”</p><p>I realized I needed to call <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#map"><code>list.map</code></a>. I need to define a function that acts on each element of the list.</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>import</span><span> </span>gleam/list<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam/string<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>line<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>map</span>(parse_line)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>This is my first time using pattern matching in any language, and it’s neat, though it’s still so unfamiliar that I find it hard to recognize when to use it.</p><p>Zooming in a bit on the pattern matching, it’s here:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>line<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span></code></pre></div><p>It evaluates the <code>line</code> variable and matches it to one of the subsequent patterns within the braces. If the line starts with <code>&#34;Session Start&#34;</code> (the <code>&lt;&gt;</code> means the preceding string is a prefix), then Gleam executes the code after the <code>-&gt;</code>, which in this case is just the empty string. Same for <code>&#34;Session Close&#34;</code>.</p><p>If the line doesn’t match the <code>&#34;Session Start&#34;</code> or <code>&#34;Session Close&#34;</code> patterns, Gleam executes the last line in the <code>case</code> which just matches any string. In that case, it evaluates to the same string. Meaning <code>&#34;hi&#34;</code> would evaluate to just <code>&#34;hi&#34;</code>.</p><p>This is where it struck me how strange it feels to not have a <code>return</code> keyword. In every other language I know, you have to explicitly return a value from a function with a <code>return</code> keyword, but in Gleam, the return value is just the value from the last line that Gleam executes in the function.</p><p>If I run my test, I get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;&#34;</span>, <span>&#34;[18:44] Jane: hi&#34;</span>, <span>&#34;[18:55] Me: hey whats up&#34;</span>, <span>&#34;&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.009 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Again, this is what I expected, and I’m a bit closer to my goal.</p><p>I’ve converted the <code>&#34;Session Start&#34;</code> and <code>&#34;Session End&#34;</code> lines to empty strings, and the middle two elements of the list are the lines that have AIM messages in them.</p><p>The remaining work is:</p><ul><li>Strip out the time and sender parts of the log lines.</li><li>Filter out empty strings.</li></ul><h2 id="scraping-an-aim-message-from-a-line">Scraping an AIM message from a line<a href="#scraping-an-aim-message-from-a-line" arialabel="Anchor"> 🔗︎</a></h2><p>At this point, I have a string like this:</p><p>And I need to extract just the portion after the sender’s name to this:</p><p>My instinct is to use a string split function and split on the <code>:</code> character. I see that there’s <a href="https://hexdocs.pm/gleam_stdlib/gleam/string.html#split"><code>string.split</code></a> which returns <code>List(String)</code>.</p><p>There’s also a <a href="https://hexdocs.pm/gleam_stdlib/gleam/string.html#split_once"><code>string.split_once</code></a> function, which should work because I can split once on <code>: </code>(note the trailing space after the colon).</p><p>The problem is that <code>split_once</code> returns <code>Result(#(String, String), Nil)</code>, a type that feels scarier to me. It’s a two-tuple wrapped in a <code>Result</code>, which means that the function can return an error on failure. It’s confusing that <code>split_once</code> can fail whereas <code>split</code> cannot, so for simplicity, I’ll go with <code>split</code>.</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>      </span><span>echo</span><span> </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>      </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I run my test, I get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>warning: Todo found
</span></span><span><span>   ┌─ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:10:7
</span></span><span><span>   │
</span></span><span><span><span>10</span> │       todo
</span></span><span><span>   │       ^^^^ This code is incomplete
</span></span><span><span>
</span></span><span><span>This code will crash <span>if</span> it is run. Be sure to finish it before
</span></span><span><span>running your program.
</span></span><span><span>
</span></span><span><span>Hint: I think its <span>type</span> is <span>`</span>String<span>`</span>.
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>   Compiled in 0.01s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>src/plaintext_logs.gleam:9
</span></span><span><span>[<span>&#34;[18:44] Jane&#34;</span>, <span>&#34;hi&#34;</span>]
</span></span></code></pre></div><p>Good. That’s doing what I want. I’m successfully isolating the <code>&#34;hi&#34;</code> part, so now I just have to return it.</p><h2 id="how-do-i-access-the-last-element-of-a-list">How do I access the last element of a list?<a href="#how-do-i-access-the-last-element-of-a-list" arialabel="Anchor"> 🔗︎</a></h2><p>At this point, I feel close to victory. I’ve converted the line to a list of strings, and I know the string I want is the last element of the list, but how do I grab it?</p><p>In most other languages, I’d just say <code>line_parts[1]</code>, but Gleam’s lists have no accessors by index.</p><p>Looking at the <code>gleam/list</code> module, I see a <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#last"><code>list.last</code></a> function, so I try that:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span>list.last<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span><span>echo</span><span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I run that, I get:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>warning: Todo found
</span></span><span><span>   ┌─ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:12:11
</span></span><span><span>   │
</span></span><span><span><span>12</span> │        |&gt; todo
</span></span><span><span>   │           ^^^^ This code is incomplete
</span></span><span><span>
</span></span><span><span>This code will crash <span>if</span> it is run. Be sure to finish it before
</span></span><span><span>running your program.
</span></span><span><span>
</span></span><span><span>Hint: I think its <span>type</span> is <span>`</span>fn(Result(String, Nil)) -&gt; String<span>`</span>.
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>   Compiled in 0.24s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>src/plaintext_logs.gleam:11
</span></span><span><span>Ok(<span>&#34;hi&#34;</span>)
</span></span></code></pre></div><p>A bit closer! I’ve extracted the last element of the list to find <code>&#34;hi&#34;</code>, but now it’s wrapped in a <a href="https://tour.gleam.run/data-types/results/"><code>Result</code> type</a>.</p><p>I can unwrap it with <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#unwrap"><code>result.unwrap</code></a></p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span>list.last<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span>result.<span>unwrap</span>(<span>&#34;&#34;</span>)<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Re-running <code>gleam test</code> yields:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;&#34;</span>, <span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>, <span>&#34;&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.008 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Great! That did what I wanted. I reduced the messages lines to just the contents of the messages.</p><h2 id="filtering-out-empty-strings">Filtering out empty strings<a href="#filtering-out-empty-strings" arialabel="Anchor"> 🔗︎</a></h2><p>The only thing that’s left is to filter the empty strings out of the list, which is straightforward enough with <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#filter"><code>list.filter</code></a>:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>map</span>(parse_line)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>filter</span>(<span>fn</span>(s)<span> </span>{<span> </span>!string.<span>is_empty</span>(s)<span> </span>})<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>And I re-run the tests:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>.
</span></span><span><span>Finished in 0.007 seconds
</span></span><span><span><span>1</span> tests, <span>0</span> failures
</span></span></code></pre></div><p>Voilà! The tests now pass!</p><h2 id="tidying-up-string-splitting">Tidying up string splitting<a href="#tidying-up-string-splitting" arialabel="Anchor"> 🔗︎</a></h2><p>My tests are now passing, so theoretically, I’ve achieved my initial goal.</p><p>I could declare victory and call it a day. Or, I could refactor!</p><p>I’ll refactor.</p><p>I feel somewhat ashamed of my string splitting logic, as it didn’t feel like idiomatic Gleam. Can I do it without getting into result unwrapping?</p><p>Re-reading it, I realize I can solve it with this newfangled pattern matching thing. I know that the string will split into a list with two elements, so I can create a pattern for a two-element list:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>case</span><span> </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>          </span>[_,<span> </span>message]<span> </span>-&gt;<span> </span>message<span>
</span></span></span><span><span><span>          </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>       </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>That feels a little more elegant than calling <code>result.last</code>.</p><p>Can I tidy this up further? I avoided <code>string.split_once</code> because the type was too confusing, but it’s probably the better option if I expect only one split, so what does that look like?</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>echo</span><span> </span>string.<span>split_once</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>       </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>To inspect the data, I run my test again:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>[...]
</span></span><span><span>src/plaintext_logs.gleam:9
</span></span><span><span>Ok(<span>#(&#34;[18:44] Jane&#34;, &#34;hi&#34;))</span>
</span></span></code></pre></div><p>Okay, that doesn’t look as scary as I thought. Even though my first instinct is to unwrap the error and access the last element in the tuple (which actually is easy for tuples, just not lists), I know at this point that there’s probably a pattern-matchy way. And there is:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>case</span><span> </span>string.<span>split_once</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>Ok</span>(#(_,<span> </span>message))<span> </span>-&gt;<span> </span>message<span>
</span></span></span><span><span><span>        </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>       </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>Ok(#(_, message))</code> pattern will match a successful result from <code>split_once</code>, which is a two-tuple of <code>String</code> wrapped in an <code>Ok</code> result. The other <code>case</code> option is the catchall that returns an empty string.</p><h2 id="getting-rid-of-the-empty-string-hack">Getting rid of the empty string hack<a href="#getting-rid-of-the-empty-string-hack" arialabel="Anchor"> 🔗︎</a></h2><p>One of the compelling features of Gleam for me is its static typing, so it feels hacky that I’m abusing the empty string to represent a lack of message on a particular line. Can I use the type system instead of using empty strings as sentinel values?</p><p>The pattern in Gleam for indicating that something might fail but the failure isn’t necessarily an error is <code>Result(&lt;type&gt;, Nil)</code>, so let me try to rewrite it that way:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>import</span><span> </span>gleam/list<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam/result<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam/string<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>Result</span>(<span>String</span>,<span> </span><span>Nil</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>Error</span>(<span>Nil</span>)<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>Error</span>(<span>Nil</span>)<span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>case</span><span> </span>string.<span>split_once</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>Ok</span>(#(_,<span> </span>message))<span> </span>-&gt;<span> </span><span>Ok</span>(message)<span>
</span></span></span><span><span><span>        </span>_<span> </span>-&gt;<span> </span><span>Error</span>(<span>Nil</span>)<span>
</span></span></span><span><span><span>       </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>map</span>(parse_line)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>result.values<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Great! I like being more explicit that the lines without messages return <code>Error(Nil)</code> rather than an empty string. Also, <code>result.values</code> is more succinct for filtering empty lines than the previous <code>list.filter(fn(s) { !string.is_empty(s) })</code>.</p><h2 id="overall-reflections">Overall reflections<a href="#overall-reflections" arialabel="Anchor"> 🔗︎</a></h2><p>After spending a few hours with Gleam, I’m enjoying it. It pushes me out of my comfort zone the right amount where I feel like I’m learning new ways of thinking about programming but not so much that I’m too overwhelmed to learn anything.</p><p>The biggest downside I’m finding with Gleam is that it’s a young language with a relatively small team. It <a href="https://lpil.uk/blog/hello-gleam/">just turned six years old</a>, but it looks like the founder was working on it solo <a href="https://github.com/gleam-lang/gleam/graphs/contributors?selectedMetric=additions">until a year ago</a>. There are now a handful of core maintainers, but I don’t know if any of them work on Gleam full-time, so the ecosystem is a bit limited. I’m looking ahead to parsing other log formats that are in HTML and XML, and there are Gleam HTML and XML parsers, but they don’t seem widely used, so I’m not sure how well they’ll work.</p><h3 id="love-pipelines">Love: Pipelines<a href="#love-pipelines" arialabel="Anchor"> 🔗︎</a></h3><p>I love love love Gleam’s pipeline syntax. You can see me using it in the test with the <code>|&gt;</code> characters:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span> </span><span>&#34;...&#34;</span><span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>string.trim<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>plaintext_logs.parse<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>should.<span>equal</span>([<span>&#34;hi&#34;</span>,<span> </span><span>&#34;hey whats up&#34;</span>])<span>
</span></span></span></code></pre></div><p>The non-pipeline equivalent of the test would look like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse_simple_plaintext_log_test</span>()<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>input<span> </span>=<span> </span><span>&#34;...&#34;</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>trimmed<span> </span>=<span> </span>string.<span>trim</span>(input)<span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>parsed<span> </span>=<span> </span>plaintext_logs.<span>parse</span>(trimmed)<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span>should.<span>equal</span>(parsed,<span> </span>[<span>&#34;hi&#34;</span>,<span> </span><span>&#34;hey whats up&#34;</span>])<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>It looks like wet garbage by comparison.</p><p>Now that I’ve seen pipelines, they feel so obvious and conspicuously missing in every other programming language I use.</p><p>I’ve enjoyed pipelining in bash, but it never occurred to me how strange it is that other programming languages never adopted it.</p><h3 id="like-example-centric-documentation">Like: Example-centric documentation<a href="#like-example-centric-documentation" arialabel="Anchor"> 🔗︎</a></h3><p>The Gleam documentation is a bit terse, but I like that it’s so example-heavy.</p><p>I learn best by reading examples, so I appreciate that so much of the Gleam standard library is documented with examples showing simple usage of each API function.</p><h3 id="like-built-in-unused-symbol-warnings">Like: Built-in unused symbol warnings<a href="#like-built-in-unused-symbol-warnings" arialabel="Anchor"> 🔗︎</a></h3><p>I like that the Gleam compiler natively warns about unused functions, variables, and imports. And I like that these are warnings rather than errors.</p><p>In Go, I get frustrated during debugging when I temporarily comment something out and then the compiler stubbornly refuses to do anything until I fix the stupid import, which I then have to un-fix when I finish whatever I was debugging.</p><h3 id="like-todo-keyword">Like: <code>todo</code> keyword<a href="#like-todo-keyword" arialabel="Anchor"> 🔗︎</a></h3><p>One of my favorite dumb programming jokes happened at my first programming job about 15 years ago. On a group email thread with several C++ developers, my friend shared a hot tip about C++ development.</p><p>He said that if we were ever got fed up with arcane C++ compilation errors, we could just add a special line to our source code, and then even invalid C++ code would compile successfully:</p><p>Spoiler alert: it’s not a real C++ preprocessor directive.</p><p>But I’ve found myself occasionally wishing languages had something like this when I’m in the middle of development and don’t care about whatever bugs the compiler is trying to protect me from.</p><p>Gleam’s <code>todo</code> is almost like a <code>#pragma always_compile</code>. Even if your code is invalid, the Gleam compiler just says, “Okay, fine. I’ll run it anyway.”</p><p>You can see this when I was in the middle of implementing <code>parse_line</code>:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>      </span><span>echo</span><span> </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>      </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I take out the <code>todo</code>, Gleam refuses to run the code at all:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>error: Type mismatch
</span></span><span><span>   ┌─ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:8:5
</span></span><span><span>   │
</span></span><span><span> <span>8</span> │ ╭     line -&gt; {
</span></span><span><span> <span>9</span> │ │       <span>echo</span> string.split(line, on: <span>&#34;: &#34;</span>)
</span></span><span><span><span>10</span> │ │     }
</span></span><span><span>   │ ╰─────^
</span></span><span><span>
</span></span><span><span>This <span>case</span> clause was found to <span>return</span> a different <span>type</span> than the previous
</span></span><span><span>one, but all <span>case</span> clauses must <span>return</span> the same type.
</span></span><span><span>
</span></span><span><span>Expected type:
</span></span><span><span>
</span></span><span><span>    String
</span></span><span><span>
</span></span><span><span>Found type:
</span></span><span><span>
</span></span><span><span>    List(String)
</span></span></code></pre></div><p>Right, I’m returning an incorrect type, so why would the compiler cooperate with me?</p><p>But adding <code>todo</code> lets me run the function anyway, which helps me understand what the code is doing even though I haven’t finished implementing it:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>warning: Todo found
</span></span><span><span>   ┌─ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:10:7
</span></span><span><span>   │
</span></span><span><span><span>10</span> │       todo
</span></span><span><span>   │       ^^^^ This code is incomplete
</span></span><span><span>
</span></span><span><span>This code will crash <span>if</span> it is run. Be sure to finish it before
</span></span><span><span>running your program.
</span></span><span><span>
</span></span><span><span>Hint: I think its <span>type</span> is <span>`</span>String<span>`</span>.
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.21s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>src/plaintext_logs.gleam:9
</span></span><span><span>[<span>&#34;[18:44] Jane&#34;</span>, <span>&#34;hi&#34;</span>]
</span></span><span><span>F
</span></span><span><span>[...]
</span></span><span><span>Finished in 0.007 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><h3 id="like-pattern-matching">Like: Pattern matching<a href="#like-pattern-matching" arialabel="Anchor"> 🔗︎</a></h3><p>I find pattern matching elegant and concise, though it’s the part of Gleam I find hardest to adjust to. It feels so different from procedural style of programming I’m accustomed to in other languages I know.</p><p>The downside is that I have a hard time recognizing when pattern matching is the right tool, and I also find pattern matching harder to read. But I think that’s just inexperience, and I think with more practice, I’ll be able to think in pattern matching.</p><h3 id="dislike-error-handling">Dislike: Error handling<a href="#dislike-error-handling" arialabel="Anchor"> 🔗︎</a></h3><p>I find Gleam’s error handling pretty awkward, especially because errors ruin the beauty of nice, tidy pipelines.</p><p>For example, if I had a string processing pipeline like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;-&#34;</span>)<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>list.last<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>result.<span>unwrap</span>(<span>&#34;&#34;</span>)<span> </span><span>// Ugly!
</span></span></span><span><span><span></span>|&gt;<span> </span>string.uppercase<span>
</span></span></span></code></pre></div><p>That <code>result.unwrap</code> line feels so ugly and out of place to me. I wish the syntax was like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>try<span> </span>list.last<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>string.uppercase<span>
</span></span></span><span><span><span></span>|&gt;<span> </span><span>Ok</span><span>
</span></span></span></code></pre></div><p>Where <code>try</code> causes the function to return an error, kind of like <a href="https://ziglang.org/documentation/0.14.1/#try">in Zig</a>.</p><h3 id="dislike-small-core-language">Dislike: Small core language<a href="#dislike-small-core-language" arialabel="Anchor"> 🔗︎</a></h3><p>I don’t know if this is a long-term design choice or if it’s just small for now because it’s an indie-developed language, but the first thing about Gleam that stood out to me is how few built-in features there are.</p><p>For example, there’s no built-in feature for iterating over the elements of a <a href="https://tour.gleam.run/everything/#basics-lists"><code>List</code> type</a>, and the type itself doesn’t expose a function to iterate it, so you have to use <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html">the <code>gleam/list</code> module</a> in the standard library.</p><p>Similarly, if a function can fail, it returns a <a href="https://tour.gleam.run/everything/#data-types-results"><code>Result</code> type</a>, and there are no built-in functions for handling a <code>Result</code>, so you have to use the <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html"><code>gleam/result</code> module</a> to check if the function succeeded.</p><p>To me, that functionality feels so core to the language that it would be part of the language itself, not the standard library.</p><h3 id="dislike-limited-standard-library">Dislike: Limited standard library<a href="#dislike-limited-standard-library" arialabel="Anchor"> 🔗︎</a></h3><p>In addition to the language feeling small, the standard library feels pretty limited as well.</p><p>There are currently only 19 modules in <a href="https://hexdocs.pm/gleam_stdlib/">the Gleam standard library</a>. Conspicuously absent are modules for working with the filesystem (the de facto standard seems to be the third-party <a href="https://hexdocs.pm/simplifile/">simplifile</a> module).</p><p>For comparison, the standard libraries for <a href="https://docs.python.org/3/library/index.html">Python</a> and <a href="https://pkg.go.dev/std">Go</a> each have about 250 modules. Although, in fairness, those languages have about 1000x the resources as Gleam.</p><h2 id="source-code">Source code<a href="#source-code" arialabel="Anchor"> 🔗︎</a></h2><p>The source code for this project is available on Codeberg:</p><ul><li><a href="https://codeberg.org/mtlynch/gleam-chat-log-parser">https://codeberg.org/mtlynch/gleam-chat-log-parser</a></li></ul><p>Commit <a href="https://codeberg.org/mtlynch/gleam-chat-log-parser/src/commit/291e6d77a0ae00e4962f12253c356568b679aab6">291e6d</a> is the version that matches this blog post.</p><hr/><p><em>Thanks to <a href="https://www.ihh.dev/">Isaac Harris-Holt</a> for helpful feedback on this post.</em></p></div></div>
  </body>
</html>
