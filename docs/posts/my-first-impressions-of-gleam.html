<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mtlynch.io/notes/gleam-first-impressions/">Original</a>
    <h1>My first impressions of gleam</h1>
    
    <div id="readability-page-1" class="page"><div><p>Iâ€™m <a href="https://mtlynch.io/notes/which-new-language/">looking for a new programming language</a> to learn this year, and <a href="https://gleam.run">Gleam</a> looks like the most fun. Itâ€™s an Elixir-like language that supports static typing.</p><p>I read the <a href="https://tour.gleam.run/">language tour</a>, and it made sense to me, but I need to build something before I can judge a programming language well.</p><p>Iâ€™m sharing some notes on my first few hours using Gleam in case theyâ€™re helpful to others learning Gleam or to the team developing the language.</p><h2 id="my-project-parsing-old-aim-logs">My project: Parsing old AIM logs<a href="#my-project-parsing-old-aim-logs" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>I used AOL Instant Messenger from about 1999 to 2007. For most of that time, I used AIM clients that logged my conversations, but they varied in formats. Most of the log formats are XML or HTML, which make re-reading those logs a pain.</p><p>The simplest AIM logs are the plaintext logs, which look like this:</p><div><pre tabindex="0"><code data-lang="text"><span><span>Session Start (DumbAIMScreenName:Jane): Mon Sep 12 18:44:17 2005
</span></span><span><span>[18:44] Jane: hi
</span></span><span><span>[18:55] Me: hey whats up
</span></span><span><span>Session Close (Jane): Mon Sep 12 18:56:02 2005
</span></span></code></pre></div><p>Every decade or so, I try writing a universal AIM log parser to get all of my old logs into a consistent, readable format. Unfortunately, I always get bored and give up partway through. My last attempt was <a href="https://github.com/mtlynch/chat_unifier">seven years ago</a>, when I tried doing it in Python 2.7.</p><p>Parsing logs is a great match for Gleam because some parts of the project are easy (e.g., parsing the plaintext logs), so I can do the easy parts while I get the hang of Gleam as a language and gradually build up to the harder log formats and adding a web frontend.</p><p>Iâ€™ve also heard that functional languages lend themselves especially well to parsing tasks, and Iâ€™ve never understood why, so itâ€™s a good opportunity to learn.</p><h2 id="my-background-in-programming-languages">My background in programming languages<a href="#my-background-in-programming-languages" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>Iâ€™ve been a programmer for 20 years, but Iâ€™m no language design connoisseur. Iâ€™m sharing things about Gleam I find unintuitive or difficult to work with, but theyâ€™re not language critiques, just candid reactions.</p><p>Iâ€™ve never worked in a langauge thatâ€™s designed for functional programming. The closest would be JavaScript. The <a href="https://mtlynch.io/notes/which-new-language/#how-much-i-enjoy-various-languages">languages I know best</a> are Go and Python.</p><h2 id="how-do-i-parse-command-line-args">How do I parse command-line args?<a href="#how-do-i-parse-command-line-args" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>The first thing I wanted to do was figure out how to parse a command-line argument so I could call my app like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>./log-parser ~/logs/aim/plaintext
</span></span></code></pre></div><p>But thereâ€™s no Gleam standard library module for reading command-line arguments. I found <a href="https://hexdocs.pm/glint/">glint</a>, and it felt super complicated for just reading one command-line argument. Then, I realized thereâ€™s a simpler third-party library called <a href="https://hexdocs.pm/argv/">argv</a>.</p><p>I can parse the command-line argument like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span>()<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>argv.<span>load</span>().arguments<span> </span>{<span>
</span></span></span><span><span><span>    </span>[path]<span> </span>-&gt;<span> </span>io.<span>println</span>(<span>&#34;command-line arg is &#34;</span><span> </span>&lt;&gt;<span> </span>path)<span>
</span></span></span><span><span><span>    </span>_<span> </span>-&gt;<span> </span>io.<span>println</span>(<span>&#34;Usage: gleam run &lt;directory_path&gt;&#34;</span>)<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam run ~/whatever
</span></span><span><span>   Compiled in 0.01s
</span></span><span><span>    Running log_parser.main
</span></span><span><span>command-line arg is /home/mike/whatever
</span></span></code></pre></div><p>Cool, easy enough!</p><h2 id="what-does-gleam-build-do">What does <code>gleam build</code> do?<a href="#what-does-gleam-build-do" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>I got my program to run with <code>gleam run</code>, but I was curious if I could compile an executable like <code>go build</code> or <code>zig build</code> does.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam build
</span></span><span><span>   Compiled in 0.01s
</span></span></code></pre></div><p>Hmm, compiled what? I couldnâ€™t see a binary anywhere.</p><p>The <a href="https://gleam.run/command-line-reference/#build">documentation for <code>gleam build</code></a> just says â€œBuild the projectâ€ but doesnâ€™t explain <em>what</em> it builds or where it stores the build artifact.</p><p>Thereâ€™s a <code>build</code> directory, but it doesnâ€™t produce an obvious executable.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ rm -rf build &amp;&amp; gleam build
</span></span><span><span>Downloading packages
</span></span><span><span> Downloaded <span>5</span> packages in 0.00s
</span></span><span><span>  Compiling argv
</span></span><span><span>  Compiling gleam_stdlib
</span></span><span><span>  Compiling filepath
</span></span><span><span>  Compiling gleeunit
</span></span><span><span>  Compiling simplifile
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.52s
</span></span><span><span>
</span></span><span><span>$ ls -1 build/
</span></span><span><span>dev
</span></span><span><span>gleam-dev-erlang.lock
</span></span><span><span>gleam-dev-javascript.lock
</span></span><span><span>gleam-lsp-erlang.lock
</span></span><span><span>gleam-lsp-javascript.lock
</span></span><span><span>gleam-prod-erlang.lock
</span></span><span><span>gleam-prod-javascript.lock
</span></span><span><span>packages
</span></span></code></pre></div><p>From poking around, I think the executables are under <code>build/dev/erlang/log_parser/ebin/</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ ls -1 build/dev/erlang/log_parser/ebin/
</span></span><span><span>log_parser.app
</span></span><span><span>log_parser.beam
</span></span><span><span>log_parser@@main.beam
</span></span><span><span>log_parser_test.beam
</span></span><span><span>plaintext_logs.beam
</span></span><span><span>plaintext_logs_test.beam
</span></span></code></pre></div><p>Those appear to be BEAM bytecode, so I canâ€™t execute them directly. I assume I could get run the BEAM VM manually and execute those files somehow, but that doesnâ€™t sound appealing.</p><p>So, Iâ€™ll stick to <code>gleam run</code> to run my app, but I wish <code>gleam build</code> had a better explanation of what it produced and what the developer can do with it.</p><h2 id="let-me-implement-the-simplest-possible-parser">Let me implement the simplest possible parser<a href="#let-me-implement-the-simplest-possible-parser" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>To start, I decided to write a function that does basic parsing of plaintext logs.</p><p>So, I wrote a test with what I wanted.</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse_simple_plaintext_log_test</span>()<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>&#34;
</span></span></span><span><span><span>Session Start (DumbAIMScreenName:Jane): Mon Sep 12 18:44:17 2005
</span></span></span><span><span><span>[18:44] Jane: hi
</span></span></span><span><span><span>[18:55] Me: hey whats up
</span></span></span><span><span><span>Session Close (Jane): Mon Sep 12 18:56:02 2005
</span></span></span><span><span><span>&#34;</span><span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>string.trim<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>plaintext_logs.parse<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>should.<span>equal</span>([<span>&#34;hi&#34;</span>,<span> </span><span>&#34;hey whats up&#34;</span>])<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Eventually, I want to parse all the metadata in the conversation, including names, timestamps, and session information. But as a first step, all my function has to do is read an AIM chat log as a string and emit a list of the chat messages as separate strings.</p><p>That meant my actual function would look like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>// Note: todo is a Gleam language keyword to indicate unfinished code.
</span></span></span><span><span><span></span><span>  </span><span>todo</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Just to get it compiling, I add in a dummy implementation:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>[<span>&#34;fake&#34;</span>,<span> </span><span>&#34;data&#34;</span>]<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>And I can test it like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>warning: Unused variable
</span></span><span><span>  â”Œâ”€ /home/mike/code/gleam-log-parser2/src/plaintext_logs.gleam:1:14
</span></span><span><span>  â”‚
</span></span><span><span><span>1</span> â”‚ pub fn parse(contents: String) -&gt; List(String) {
</span></span><span><span>  â”‚              ^^^^^^^^^^^^^^^^ This variable is never used
</span></span><span><span>
</span></span><span><span>Hint: You can ignore it with an underscore: <span>`</span>_contents<span>`</span>.
</span></span><span><span>
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;fake&#34;</span>, <span>&#34;data&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.008 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Cool, thatâ€™s what I expected. The test is failing because itâ€™s returning hardcoded dummy results that donâ€™t match my test.</p><h2 id="adjusting-my-brain-to-a-functional-language">Adjusting my brain to a functional language<a href="#adjusting-my-brain-to-a-functional-language" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>Okay, now itâ€™s time to implement the parsing for real. I need to implement this function:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>todo</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>At this point, I kind of froze up. It struck me that Gleam excludes so many of the tools Iâ€™m used to in other languages:</p><ul><li>There are no <code>if</code> statements</li><li>There are no loops</li><li>Thereâ€™s no <code>return</code> keyword</li><li>There are no list index accessors<ul><li>e.g., you canâ€™t access the n-th element of a <code>List</code></li></ul></li></ul><p>What do I even do? Split the string into tokens and then do something with that?</p><p>Eventually, I realized for a simple implementation, I wanted to just split the string into lines, so I want to do this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I test again, I get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.21s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;Session Start (DumbAIMScreenName:Jane): Mon Sep 12 18:44:17 2005&#34;</span>, <span>&#34;[18:44] Jane: hi&#34;</span>, <span>&#34;[18:55] Me: hey whats up&#34;</span>, <span>&#34;Session Close (Jane): Mon Sep 12 18:56:02 2005&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.009 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Okay, now Iâ€™m a little closer.</p><h2 id="how-do-i-iterate-over-a-list-in-a-language-with-no-loops">How do I iterate over a list in a language with no loops?<a href="#how-do-i-iterate-over-a-list-in-a-language-with-no-loops" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>I turned my logs into a list of lines, but thatâ€™s where I got stuck again.</p><p>Iâ€™m so used to <code>for</code> loops that my brain kept thinking, â€œHow do I do a <code>for</code> loop to iterate over the elements?â€</p><p>I realized I needed to call <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#map"><code>list.map</code></a>. I need to define a function that acts on each element of the list.</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>import</span><span> </span>gleam/list<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam/string<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>line<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>map</span>(parse_line)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>This is my first time using pattern matching in any language, and itâ€™s neat, though itâ€™s still so unfamiliar that I find it hard to recognize when to use it.</p><p>Zooming in a bit on the pattern matching, itâ€™s here:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>line<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span></code></pre></div><p>It evaluates the <code>line</code> variable and matches it to one of the subsequent patterns within the braces. If the line starts with <code>&#34;Session Start&#34;</code> (the <code>&lt;&gt;</code> means the preceding string is a prefix), then Gleam executes the code after the <code>-&gt;</code>, which in this case is just the empty string. Same for <code>&#34;Session Close&#34;</code>.</p><p>If the line doesnâ€™t match the <code>&#34;Session Start&#34;</code> or <code>&#34;Session Close&#34;</code> patterns, Gleam executes the last line in the <code>case</code> which just matches any string. In that case, it evaluates to the same string. Meaning <code>&#34;hi&#34;</code> would evaluate to just <code>&#34;hi&#34;</code>.</p><p>This is where it struck me how strange it feels to not have a <code>return</code> keyword. In every other language I know, you have to explicitly return a value from a function with a <code>return</code> keyword, but in Gleam, the return value is just the value from the last line that Gleam executes in the function.</p><p>If I run my test, I get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;&#34;</span>, <span>&#34;[18:44] Jane: hi&#34;</span>, <span>&#34;[18:55] Me: hey whats up&#34;</span>, <span>&#34;&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.009 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Again, this is what I expected, and Iâ€™m a bit closer to my goal.</p><p>Iâ€™ve converted the <code>&#34;Session Start&#34;</code> and <code>&#34;Session End&#34;</code> lines to empty strings, and the middle two elements of the list are the lines that have AIM messages in them.</p><p>The remaining work is:</p><ul><li>Strip out the time and sender parts of the log lines.</li><li>Filter out empty strings.</li></ul><h2 id="scraping-an-aim-message-from-a-line">Scraping an AIM message from a line<a href="#scraping-an-aim-message-from-a-line" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>At this point, I have a string like this:</p><p>And I need to extract just the portion after the senderâ€™s name to this:</p><p>My instinct is to use a string split function and split on the <code>:</code> character. I see that thereâ€™s <a href="https://hexdocs.pm/gleam_stdlib/gleam/string.html#split"><code>string.split</code></a> which returns <code>List(String)</code>.</p><p>Thereâ€™s also a <a href="https://hexdocs.pm/gleam_stdlib/gleam/string.html#split_once"><code>string.split_once</code></a> function, which should work because I can split once on <code>: </code>(note the trailing space after the colon).</p><p>The problem is that <code>split_once</code> returns <code>Result(#(String, String), Nil)</code>, a type that feels scarier to me. Itâ€™s a two-tuple wrapped in a <code>Result</code>, which means that the function can return an error on failure. Itâ€™s confusing that <code>split_once</code> can fail whereas <code>split</code> cannot, so for simplicity, Iâ€™ll go with <code>split</code>.</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>      </span><span>echo</span><span> </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>      </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I run my test, I get this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>warning: Todo found
</span></span><span><span>   â”Œâ”€ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:10:7
</span></span><span><span>   â”‚
</span></span><span><span><span>10</span> â”‚       todo
</span></span><span><span>   â”‚       ^^^^ This code is incomplete
</span></span><span><span>
</span></span><span><span>This code will crash <span>if</span> it is run. Be sure to finish it before
</span></span><span><span>running your program.
</span></span><span><span>
</span></span><span><span>Hint: I think its <span>type</span> is <span>`</span>String<span>`</span>.
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>   Compiled in 0.01s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>src/plaintext_logs.gleam:9
</span></span><span><span>[<span>&#34;[18:44] Jane&#34;</span>, <span>&#34;hi&#34;</span>]
</span></span></code></pre></div><p>Good. Thatâ€™s doing what I want. Iâ€™m successfully isolating the <code>&#34;hi&#34;</code> part, so now I just have to return it.</p><h2 id="how-do-i-access-the-last-element-of-a-list">How do I access the last element of a list?<a href="#how-do-i-access-the-last-element-of-a-list" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>At this point, I feel close to victory. Iâ€™ve converted the line to a list of strings, and I know the string I want is the last element of the list, but how do I grab it?</p><p>In most other languages, Iâ€™d just say <code>line_parts[1]</code>, but Gleamâ€™s lists have no accessors by index.</p><p>Looking at the <code>gleam/list</code> module, I see a <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#last"><code>list.last</code></a> function, so I try that:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span>list.last<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span><span>echo</span><span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I run that, I get:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>warning: Todo found
</span></span><span><span>   â”Œâ”€ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:12:11
</span></span><span><span>   â”‚
</span></span><span><span><span>12</span> â”‚        |&gt; todo
</span></span><span><span>   â”‚           ^^^^ This code is incomplete
</span></span><span><span>
</span></span><span><span>This code will crash <span>if</span> it is run. Be sure to finish it before
</span></span><span><span>running your program.
</span></span><span><span>
</span></span><span><span>Hint: I think its <span>type</span> is <span>`</span>fn(Result(String, Nil)) -&gt; String<span>`</span>.
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>   Compiled in 0.24s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>src/plaintext_logs.gleam:11
</span></span><span><span>Ok(<span>&#34;hi&#34;</span>)
</span></span></code></pre></div><p>A bit closer! Iâ€™ve extracted the last element of the list to find <code>&#34;hi&#34;</code>, but now itâ€™s wrapped in a <a href="https://tour.gleam.run/data-types/results/"><code>Result</code> type</a>.</p><p>I can unwrap it with <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#unwrap"><code>result.unwrap</code></a></p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span>list.last<span>
</span></span></span><span><span><span>       </span>|&gt;<span> </span>result.<span>unwrap</span>(<span>&#34;&#34;</span>)<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Re-running <code>gleam test</code> yields:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>F
</span></span><span><span>Failures:
</span></span><span><span>
</span></span><span><span>  1) plaintext_logs_test.parse_simple_plaintext_log_test: module <span>&#39;plaintext_logs_test&#39;</span>
</span></span><span><span>     Values were not equal
</span></span><span><span>     expected: [<span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>]
</span></span><span><span>          got: [<span>&#34;&#34;</span>, <span>&#34;hi&#34;</span>, <span>&#34;hey whats up&#34;</span>, <span>&#34;&#34;</span>]
</span></span><span><span>     output:
</span></span><span><span>
</span></span><span><span>Finished in 0.008 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><p>Great! That did what I wanted. I reduced the messages lines to just the contents of the messages.</p><h2 id="filtering-out-empty-strings">Filtering out empty strings<a href="#filtering-out-empty-strings" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>The only thing thatâ€™s left is to filter the empty strings out of the list, which is straightforward enough with <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#filter"><code>list.filter</code></a>:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>map</span>(parse_line)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>filter</span>(<span>fn</span>(s)<span> </span>{<span> </span>!string.<span>is_empty</span>(s)<span> </span>})<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>And I re-run the tests:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.22s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>.
</span></span><span><span>Finished in 0.007 seconds
</span></span><span><span><span>1</span> tests, <span>0</span> failures
</span></span></code></pre></div><p>VoilÃ ! The tests now pass!</p><h2 id="tidying-up-string-splitting">Tidying up string splitting<a href="#tidying-up-string-splitting" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>My tests are now passing, so theoretically, Iâ€™ve achieved my initial goal.</p><p>I could declare victory and call it a day. Or, I could refactor!</p><p>Iâ€™ll refactor.</p><p>I feel somewhat ashamed of my string splitting logic, as it didnâ€™t feel like idiomatic Gleam. Can I do it without getting into result unwrapping?</p><p>Re-reading it, I realize I can solve it with this newfangled pattern matching thing. I know that the string will split into a list with two elements, so I can create a pattern for a two-element list:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>case</span><span> </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>          </span>[_,<span> </span>message]<span> </span>-&gt;<span> </span>message<span>
</span></span></span><span><span><span>          </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>       </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>That feels a little more elegant than calling <code>result.last</code>.</p><p>Can I tidy this up further? I avoided <code>string.split_once</code> because the type was too confusing, but itâ€™s probably the better option if I expect only one split, so what does that look like?</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>echo</span><span> </span>string.<span>split_once</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>       </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>To inspect the data, I run my test again:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>[...]
</span></span><span><span>src/plaintext_logs.gleam:9
</span></span><span><span>Ok(<span>#(&#34;[18:44] Jane&#34;, &#34;hi&#34;))</span>
</span></span></code></pre></div><p>Okay, that doesnâ€™t look as scary as I thought. Even though my first instinct is to unwrap the error and access the last element in the tuple (which actually is easy for tuples, just not lists), I know at this point that thereâ€™s probably a pattern-matchy way. And there is:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>case</span><span> </span>string.<span>split_once</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>Ok</span>(#(_,<span> </span>message))<span> </span>-&gt;<span> </span>message<span>
</span></span></span><span><span><span>        </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>       </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>Ok(#(_, message))</code> pattern will match a successful result from <code>split_once</code>, which is a two-tuple of <code>String</code> wrapped in an <code>Ok</code> result. The other <code>case</code> option is the catchall that returns an empty string.</p><h2 id="getting-rid-of-the-empty-string-hack">Getting rid of the empty string hack<a href="#getting-rid-of-the-empty-string-hack" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>One of the compelling features of Gleam for me is its static typing, so it feels hacky that Iâ€™m abusing the empty string to represent a lack of message on a particular line. Can I use the type system instead of using empty strings as sentinel values?</p><p>The pattern in Gleam for indicating that something might fail but the failure isnâ€™t necessarily an error is <code>Result(&lt;type&gt;, Nil)</code>, so let me try to rewrite it that way:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>import</span><span> </span>gleam/list<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam/result<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam/string<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>Result</span>(<span>String</span>,<span> </span><span>Nil</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>Error</span>(<span>Nil</span>)<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>Error</span>(<span>Nil</span>)<span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>       </span><span>case</span><span> </span>string.<span>split_once</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span> </span>{<span>
</span></span></span><span><span><span>        </span><span>Ok</span>(#(_,<span> </span>message))<span> </span>-&gt;<span> </span><span>Ok</span>(message)<span>
</span></span></span><span><span><span>        </span>_<span> </span>-&gt;<span> </span><span>Error</span>(<span>Nil</span>)<span>
</span></span></span><span><span><span>       </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse</span>(contents:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>List</span>(<span>String</span>)<span> </span>{<span>
</span></span></span><span><span><span>  </span>string.<span>split</span>(contents,<span> </span>on:<span> </span><span>&#34;</span><span>\n</span><span>&#34;</span>)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>list.<span>map</span>(parse_line)<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>result.values<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>Great! I like being more explicit that the lines without messages return <code>Error(Nil)</code> rather than an empty string. Also, <code>result.values</code> is more succinct for filtering empty lines than the previous <code>list.filter(fn(s) { !string.is_empty(s) })</code>.</p><h2 id="overall-reflections">Overall reflections<a href="#overall-reflections" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>After spending a few hours with Gleam, Iâ€™m enjoying it. It pushes me out of my comfort zone the right amount where I feel like Iâ€™m learning new ways of thinking about programming but not so much that Iâ€™m too overwhelmed to learn anything.</p><p>The biggest downside Iâ€™m finding with Gleam is that itâ€™s a young language with a relatively small team. It <a href="https://lpil.uk/blog/hello-gleam/">just turned six years old</a>, but it looks like the founder was working on it solo <a href="https://github.com/gleam-lang/gleam/graphs/contributors?selectedMetric=additions">until a year ago</a>. There are now a handful of core maintainers, but I donâ€™t know if any of them work on Gleam full-time, so the ecosystem is a bit limited. Iâ€™m looking ahead to parsing other log formats that are in HTML and XML, and there are Gleam HTML and XML parsers, but they donâ€™t seem widely used, so Iâ€™m not sure how well theyâ€™ll work.</p><h3 id="love-pipelines">Love: Pipelines<a href="#love-pipelines" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>I love love love Gleamâ€™s pipeline syntax. You can see me using it in the test with the <code>|&gt;</code> characters:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span> </span><span>&#34;...&#34;</span><span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>string.trim<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>plaintext_logs.parse<span>
</span></span></span><span><span><span>  </span>|&gt;<span> </span>should.<span>equal</span>([<span>&#34;hi&#34;</span>,<span> </span><span>&#34;hey whats up&#34;</span>])<span>
</span></span></span></code></pre></div><p>The non-pipeline equivalent of the test would look like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse_simple_plaintext_log_test</span>()<span> </span>{<span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>input<span> </span>=<span> </span><span>&#34;...&#34;</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>trimmed<span> </span>=<span> </span>string.<span>trim</span>(input)<span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>parsed<span> </span>=<span> </span>plaintext_logs.<span>parse</span>(trimmed)<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span>should.<span>equal</span>(parsed,<span> </span>[<span>&#34;hi&#34;</span>,<span> </span><span>&#34;hey whats up&#34;</span>])<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>It looks like wet garbage by comparison.</p><p>Now that Iâ€™ve seen pipelines, they feel so obvious and conspicuously missing in every other programming language I use.</p><p>Iâ€™ve enjoyed pipelining in bash, but it never occurred to me how strange it is that other programming languages never adopted it.</p><h3 id="like-example-centric-documentation">Like: Example-centric documentation<a href="#like-example-centric-documentation" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>The Gleam documentation is a bit terse, but I like that itâ€™s so example-heavy.</p><p>I learn best by reading examples, so I appreciate that so much of the Gleam standard library is documented with examples showing simple usage of each API function.</p><h3 id="like-built-in-unused-symbol-warnings">Like: Built-in unused symbol warnings<a href="#like-built-in-unused-symbol-warnings" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>I like that the Gleam compiler natively warns about unused functions, variables, and imports. And I like that these are warnings rather than errors.</p><p>In Go, I get frustrated during debugging when I temporarily comment something out and then the compiler stubbornly refuses to do anything until I fix the stupid import, which I then have to un-fix when I finish whatever I was debugging.</p><h3 id="like-todo-keyword">Like: <code>todo</code> keyword<a href="#like-todo-keyword" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>One of my favorite dumb programming jokes happened at my first programming job about 15 years ago. On a group email thread with several C++ developers, my friend shared a hot tip about C++ development.</p><p>He said that if we were ever got fed up with arcane C++ compilation errors, we could just add a special line to our source code, and then even invalid C++ code would compile successfully:</p><p>Spoiler alert: itâ€™s not a real C++ preprocessor directive.</p><p>But Iâ€™ve found myself occasionally wishing languages had something like this when Iâ€™m in the middle of development and donâ€™t care about whatever bugs the compiler is trying to protect me from.</p><p>Gleamâ€™s <code>todo</code> is almost like a <code>#pragma always_compile</code>. Even if your code is invalid, the Gleam compiler just says, â€œOkay, fine. Iâ€™ll run it anyway.â€</p><p>You can see this when I was in the middle of implementing <code>parse_line</code>:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span><span>fn</span><span> </span><span>parse_line</span>(line:<span> </span><span>String</span>)<span> </span>-&gt;<span> </span><span>String</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>line<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>&#34;Session Start&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span><span>&#34;Session Close&#34;</span><span> </span>&lt;&gt;<span> </span>_<span> </span>-&gt;<span> </span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>    </span>line<span> </span>-&gt;<span> </span>{<span>
</span></span></span><span><span><span>      </span><span>echo</span><span> </span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span>      </span><span>todo</span><span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>  </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>If I take out the <code>todo</code>, Gleam refuses to run the code at all:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>error: Type mismatch
</span></span><span><span>   â”Œâ”€ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:8:5
</span></span><span><span>   â”‚
</span></span><span><span> <span>8</span> â”‚ â•­     line -&gt; {
</span></span><span><span> <span>9</span> â”‚ â”‚       <span>echo</span> string.split(line, on: <span>&#34;: &#34;</span>)
</span></span><span><span><span>10</span> â”‚ â”‚     }
</span></span><span><span>   â”‚ â•°â”€â”€â”€â”€â”€^
</span></span><span><span>
</span></span><span><span>This <span>case</span> clause was found to <span>return</span> a different <span>type</span> than the previous
</span></span><span><span>one, but all <span>case</span> clauses must <span>return</span> the same type.
</span></span><span><span>
</span></span><span><span>Expected type:
</span></span><span><span>
</span></span><span><span>    String
</span></span><span><span>
</span></span><span><span>Found type:
</span></span><span><span>
</span></span><span><span>    List(String)
</span></span></code></pre></div><p>Right, Iâ€™m returning an incorrect type, so why would the compiler cooperate with me?</p><p>But adding <code>todo</code> lets me run the function anyway, which helps me understand what the code is doing even though I havenâ€™t finished implementing it:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gleam <span>test</span>
</span></span><span><span>warning: Todo found
</span></span><span><span>   â”Œâ”€ /home/mike/code/gleam-log-parser/src/plaintext_logs.gleam:10:7
</span></span><span><span>   â”‚
</span></span><span><span><span>10</span> â”‚       todo
</span></span><span><span>   â”‚       ^^^^ This code is incomplete
</span></span><span><span>
</span></span><span><span>This code will crash <span>if</span> it is run. Be sure to finish it before
</span></span><span><span>running your program.
</span></span><span><span>
</span></span><span><span>Hint: I think its <span>type</span> is <span>`</span>String<span>`</span>.
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>  Compiling log_parser
</span></span><span><span>   Compiled in 0.21s
</span></span><span><span>    Running log_parser_test.main
</span></span><span><span>src/plaintext_logs.gleam:9
</span></span><span><span>[<span>&#34;[18:44] Jane&#34;</span>, <span>&#34;hi&#34;</span>]
</span></span><span><span>F
</span></span><span><span>[...]
</span></span><span><span>Finished in 0.007 seconds
</span></span><span><span><span>1</span> tests, <span>1</span> failures
</span></span></code></pre></div><h3 id="like-pattern-matching">Like: Pattern matching<a href="#like-pattern-matching" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>I find pattern matching elegant and concise, though itâ€™s the part of Gleam I find hardest to adjust to. It feels so different from procedural style of programming Iâ€™m accustomed to in other languages I know.</p><p>The downside is that I have a hard time recognizing when pattern matching is the right tool, and I also find pattern matching harder to read. But I think thatâ€™s just inexperience, and I think with more practice, Iâ€™ll be able to think in pattern matching.</p><h3 id="dislike-error-handling">Dislike: Error handling<a href="#dislike-error-handling" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>I find Gleamâ€™s error handling pretty awkward, especially because errors ruin the beauty of nice, tidy pipelines.</p><p>For example, if I had a string processing pipeline like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;-&#34;</span>)<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>list.last<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>result.<span>unwrap</span>(<span>&#34;&#34;</span>)<span> </span><span>// Ugly!
</span></span></span><span><span><span></span>|&gt;<span> </span>string.uppercase<span>
</span></span></span></code></pre></div><p>That <code>result.unwrap</code> line feels so ugly and out of place to me. I wish the syntax was like this:</p><div><pre tabindex="0"><code data-lang="gleam"><span><span>string.<span>split</span>(line,<span> </span>on:<span> </span><span>&#34;: &#34;</span>)<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>try<span> </span>list.last<span>
</span></span></span><span><span><span></span>|&gt;<span> </span>string.uppercase<span>
</span></span></span><span><span><span></span>|&gt;<span> </span><span>Ok</span><span>
</span></span></span></code></pre></div><p>Where <code>try</code> causes the function to return an error, kind of like <a href="https://ziglang.org/documentation/0.14.1/#try">in Zig</a>.</p><h3 id="dislike-small-core-language">Dislike: Small core language<a href="#dislike-small-core-language" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>I donâ€™t know if this is a long-term design choice or if itâ€™s just small for now because itâ€™s an indie-developed language, but the first thing about Gleam that stood out to me is how few built-in features there are.</p><p>For example, thereâ€™s no built-in feature for iterating over the elements of a <a href="https://tour.gleam.run/everything/#basics-lists"><code>List</code> type</a>, and the type itself doesnâ€™t expose a function to iterate it, so you have to use <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html">the <code>gleam/list</code> module</a> in the standard library.</p><p>Similarly, if a function can fail, it returns a <a href="https://tour.gleam.run/everything/#data-types-results"><code>Result</code> type</a>, and there are no built-in functions for handling a <code>Result</code>, so you have to use the <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html"><code>gleam/result</code> module</a> to check if the function succeeded.</p><p>To me, that functionality feels so core to the language that it would be part of the language itself, not the standard library.</p><h3 id="dislike-limited-standard-library">Dislike: Limited standard library<a href="#dislike-limited-standard-library" arialabel="Anchor"> ğŸ”—ï¸</a></h3><p>In addition to the language feeling small, the standard library feels pretty limited as well.</p><p>There are currently only 19 modules in <a href="https://hexdocs.pm/gleam_stdlib/">the Gleam standard library</a>. Conspicuously absent are modules for working with the filesystem (the de facto standard seems to be the third-party <a href="https://hexdocs.pm/simplifile/">simplifile</a> module).</p><p>For comparison, the standard libraries for <a href="https://docs.python.org/3/library/index.html">Python</a> and <a href="https://pkg.go.dev/std">Go</a> each have about 250 modules. Although, in fairness, those languages have about 1000x the resources as Gleam.</p><h2 id="source-code">Source code<a href="#source-code" arialabel="Anchor"> ğŸ”—ï¸</a></h2><p>The source code for this project is available on Codeberg:</p><ul><li><a href="https://codeberg.org/mtlynch/gleam-chat-log-parser">https://codeberg.org/mtlynch/gleam-chat-log-parser</a></li></ul><p>Commit <a href="https://codeberg.org/mtlynch/gleam-chat-log-parser/src/commit/291e6d77a0ae00e4962f12253c356568b679aab6">291e6d</a> is the version that matches this blog post.</p><hr/><p><em>Thanks to <a href="https://www.ihh.dev/">Isaac Harris-Holt</a> for helpful feedback on this post.</em></p></div></div>
  </body>
</html>
