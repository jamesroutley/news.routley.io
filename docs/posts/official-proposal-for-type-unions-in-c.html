<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/TypeUnions.md">Original</a>
    <h1>Official proposal for Type Unions in C#</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text">
<ul>
<li> Proposed</li>
<li> Prototype: <a href="https://www.bryanbraun.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/pr/1">Not Started</a></li>
<li> Implementation: <a href="https://www.bryanbraun.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/pr/1">Not Started</a></li>
<li> Specification: <a href="https://www.bryanbraun.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/pr/1">Not Started</a></li>
</ul>

<p dir="auto">A proposal for type unions (aka discriminated unions) in C#.</p>

<p dir="auto">When developing software you may encounter situations where the values that you want to store in a variable are not always the same kind each time through. While you are usually not concerned about storing strings and numbers in the same spot, you may need to store one of a few related types depending on what that data is meant to represent at that moment.</p>
<p dir="auto">For example, your application may have both a customer and a supplier definition that share only some of the same properties and you may need to perform a similar operation on both in a fashion that depends on the differences.</p>
<p dir="auto">Typically, this is where you might choose to distribute those specialized implementations into the types themselves and expose them through common abstract methods or interfaces. However, this is only good practice when those types exist primarily for the purpose of the operation or it makes sense for the operation to appear as an intrinsic part of the type. If the types have a broader purpose, polluting them with methods like this can be undesirable.</p>
<p dir="auto">The alternative is to make the same logic handle both types, and if you do this, at some point you will need to declare a parameter or variable that can contain either.</p>
<p dir="auto">You might think you can still solve this through inheritance, by defining both <code>Customer</code> and <code>Supplier</code> as classes in a hierarchy with a common base type like <code>Contact</code>. However, if you are not able to define such a relationship, because either you don&#39;t own the definition of these types, or you have too many similar situations and can only solve one of them through inheritance or you choose to not leak the requirements of the specific operation into the definition of the data, the only easy choice you have is to declare the variable as object and let it be just anything.</p>
<p dir="auto">While this may work, it leaves you policing your code through documentation and comments. If you are brave, you can devise such things as special-case hierarchies of wrapper types to put around your values, or custom aggregate types that act as guardians around all the kinds of values you want to possibly store in the variable,
which is time consuming and cumbersome, especially if you have many similar situations but they all involve different sets of types.</p>
<p dir="auto">It would be better if C# gave you a way to declare a type that allows you to store one of a limited number of other types in the same place, and let it do all the hard work guarding the variables for you.</p>
<p dir="auto">Many other languages already do this. They typically call these special types discriminated unions, tagged unions, sum types or type unions.
All of them solve the problem of allowing a single variable to hold values of one or more limited forms.</p>
<p dir="auto">It is time C# had a feature that did this too.</p>

<p dir="auto">You might imagine that the most appropriate implementation for union types in C# is as a hierarchy of classes with an abstract base representing the union itself and all the specific cases of the union as derived classes, just like you or I might make to solve the problem on our own, because it fits really well with the concepts already in the language. This usually works well when you have a specific use case in mind as you design a specific set of classes to solve that specific problem. However, there are some drawbacks to implementing unions as class hierarchies.</p>
<p dir="auto">One is the inability to constrain the hierarchy, as object-oriented languages are usually open for inheritance.</p>
<blockquote>
<p dir="auto">I know there are only three possible subtypes, why does the compiler require me to have a default in my switch expression?</p>
</blockquote>
<p dir="auto">Another is the inability to represent unions of unrelated types that exist outside a single hierarchy or even to restrict values to a subset of types from within the same hierarchy.</p>
<blockquote>
<p dir="auto">I want this parameter to be restricted to only Cats and Dogs, not all Animals.</p>
</blockquote>
<p dir="auto">Because of the class hierarchy implementation, the only way to include a value from a type that already exists is to use a class that is part of the union hierarchy to wrap the value.</p>
<blockquote>
<p dir="auto">I either have to type these fields as object and trust myself and my team to always do the right thing, or wrap my values in new class instances each time I want to store them in the variable.</p>
</blockquote>
<p dir="auto">And lastly, classes in C# require allocation to represent and cannot contain values such as ref types, which may be requirements for specific scenarios.</p>
<blockquote>
<p dir="auto">I wish I could use unions in my graphics pipeline, but they cause too much gen 0.</p>
</blockquote>
<p dir="auto">For these reasons, it may be necessary to have more than one kind of union,
as it may not be possible to satisfy some use cases without compromising others, and if there are multiple kinds it is best to strive to make them appear to look and work the same as as much as possible.</p>
<p dir="auto">This proposal attempts to provide solutions to all use cases by declaring four categories for them to fall into, listing some examples for each.</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="#standard---union-classes">Standard</a> - Use cases where the union and its members can be defined together, because they have a predominant reason to belong together and you intend to use the members as classes on their own. Allocation is not a problem because you would have been allocating the classes regardless.</p>
<ul dir="auto">
<li>Protocols, serialization and data transfer types</li>
<li>UI data models (XAML)</li>
<li>Syntax trees</li>
<li>Infrequently changed state machine states</li>
<li>Other polymorphic data models</li>
<li>Values that last a while in union form (fields/properties)</li>
</ul>
</li>
<li>
<p dir="auto"><a href="#specialized---union-structs">Specialized</a> - Use cases that need to avoid allocations or require use of special types and are willing to accept some limitations to achieve it.</p>
<ul dir="auto">
<li>Allocated in contiguous arrays</li>
<li>Mapped over blocks of memory (interop)</li>
<li>Frequently changed state machine states</li>
<li>Values that last briefly in union form (arguments/return values)</li>
<li>Library types with potentially specialized uses</li>
</ul>
</li>
<li>
<p dir="auto"><a href="#ad-hoc---ad-hoc-unions">Ad Hoc</a> - Use cases that require unions to be formed from existing, possibly unrelated, types and where similarly declared unions with the same member types are interchangeable with one another.</p>
<ul dir="auto">
<li>Same examples as standard.</li>
</ul>
</li>
<li>
<p dir="auto"><a href="#custom-unions">Custom</a> - Use cases that do not fit well with the other categories.</p>
<ul dir="auto">
<li>Already existing types and hierarchies that cannot easily be redefined.</li>
<li>Custom storage layouts.</li>
<li>Custom API shapes and behaviors.</li>
</ul>
</li>
</ul>
<p dir="auto"><em>Note: Pre-declared unions like Option and Result are proposed in the <a href="#common-unions">Common Unions</a> section.</em></p>
<p dir="auto"><em>Note: Many of the examples are written in a shorthand syntax made possible by related proposals
briefly described in the <a href="#related-proposals">Related Proposals</a> section.</em></p>
<hr/>

<p dir="auto">A union class is a named type union that declares all its member types in a single self-contained declaration.</p>

<p dir="auto">A union class is declared similar to an enum,
except each member is a type that itself can hold state in one or more state variables.</p>
<div data-snippet-clipboard-copy-content="union U 
{
    A(int x, string y);
    B(int z);
    C;
}"><pre><code>union U 
{
    A(int x, string y);
    B(int z);
    C;
}
</code></pre></div>
<p dir="auto">For each member, only the name and the list of state variables may be specified.</p>

<p dir="auto">Union classes are constructed via allocation of the member type.</p>

<p dir="auto">The type of the constructed member is the member type <code>A</code>.
It is converted to type <code>U</code> when assigned to variable <code>u</code>.</p>

<p dir="auto">Union classes are deconstructed by type tests and pattern matching.</p>
<div data-snippet-clipboard-copy-content="if (u is A a) { ... }

if (u is A(var x, var y)) { ... }

if (u is A { y: var y }) { ... }"><pre><code>if (u is A a) { ... }

if (u is A(var x, var y)) { ... }

if (u is A { y: var y }) { ... }
</code></pre></div>

<p dir="auto">Union classes are considered exhaustive.
If all member types are accounted for in a switch expression or statement, no default case is needed.</p>
<div data-snippet-clipboard-copy-content="var x = u switch { 
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
    };"><pre><code>var x = u switch { 
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
    };
</code></pre></div>

<p dir="auto">Nulls can be included in a union class variable using the standard nullability notation.</p>


<p dir="auto">A union class is implemented as an abstract record class with the member types as nested derived record classes.</p>
<div data-snippet-clipboard-copy-content="[Closed]
abstract record U 
{
    public record A(int x, string y) : U;
    public record B(int z) : U;
    public record C : U { public static C Singleton = new C(); };
}"><pre><code>[Closed]
abstract record U 
{
    public record A(int x, string y) : U;
    public record B(int z) : U;
    public record C : U { public static C Singleton = new C(); };
}
</code></pre></div>
<p dir="auto"><em>Note: The <code>Closed</code> attribute allows the language to understand that the type hierarchy is closed to sub-types declared outside the base type&#39;s module.
See the following section <a href="#related-proposals">Related Proposals</a>.</em></p>
<p dir="auto"><em>Note: Nested member types may be referred to without qualification using related proposal.</em></p>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Specialized - Union Structs</h2><a id="user-content-specialized---union-structs" aria-label="Permalink: Specialized - Union Structs" href="#specialized---union-structs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Similar to a union class, a union struct is also a named type union that declares all its member types in a single self-contained declaration, except the union and the member types are all structs and are able to be used without heap allocation.</p>

<p dir="auto">A union struct is declared similarly to a union class, with the addition of the <code>struct</code> keyword.</p>
<div data-snippet-clipboard-copy-content="union struct U 
{
    A(int x, string y);
    B(int z);
    C;
}"><pre><code>union struct U 
{
    A(int x, string y);
    B(int z);
    C;
}
</code></pre></div>
<p dir="auto">For each member, only the name and the list of state variables may be specified.</p>

<p dir="auto">Union structs are constructed via allocation of the member type.</p>

<p dir="auto">The type of the constructed member is the member type <code>A</code>.
It is converted to type <code>U</code> when assigned to variable <code>u</code>.</p>

<p dir="auto">Union structs are deconstructed by type tests and pattern matching.</p>
<div data-snippet-clipboard-copy-content="if (u is A a) { ... }

if (u is A(var x, var y)) { ... }

if (u is A { y: var y }) { ... }"><pre><code>if (u is A a) { ... }

if (u is A(var x, var y)) { ... }

if (u is A { y: var y }) { ... }
</code></pre></div>

<p dir="auto">Union structs are considered exhaustive.
If all member types are accounted for in a switch expression or statement, no default case is needed.</p>
<div data-snippet-clipboard-copy-content="var x = u switch { 
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
    };"><pre><code>var x = u switch { 
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
    };
</code></pre></div>

<p dir="auto">Nulls can be included in a union struct variable using the standard nullability notation.</p>


<p dir="auto">Union structs can be in an undefined state due to being unassigned or assigned default. This state will not correspond to any declared member type,
leading to a runtime exception in a switch that relies on exhaustiveness.</p>
<div data-snippet-clipboard-copy-content="U u = default;  

// switch throws, since not A, B or C
var x = u switch 
{
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
}"><pre><code>U u = default;  

// switch throws, since not A, B or C
var x = u switch 
{
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
}
</code></pre></div>
<p dir="auto">To help avoid this, the compiler will produce a warning when a struct union is assigned default.</p>
<div data-snippet-clipboard-copy-content="// warning: default not a valid state
U u = default;  "><pre><code>// warning: default not a valid state
U u = default;  
</code></pre></div>
<p dir="auto">You may also avoid the warning by declaring a default state for the union struct,
associating a member type as the default.</p>
<div data-snippet-clipboard-copy-content="union struct U
{
    A(int x, string y);
    B(int z);
    C = default;
}"><pre><code>union struct U
{
    A(int x, string y);
    B(int z);
    C = default;
}
</code></pre></div>

<p dir="auto">A union struct is implemented as a struct with nested record structs as member types and an API that converts the member types to and from the aggregate union struct. The interior layout of the union struct is chosen to allow for efficient storage of the data found within the different possible member types with tradeoffs between speed and size chosen by the compiler.</p>
<div data-snippet-clipboard-copy-content="[Union]
struct U 
{
    public record struct A(int x, string y);
    public record struct B(int z);
    public record struct C { public static C Singleton = default; };

    public static implicit operator U(A value) {...};
    public static implicit operator U(B value) {...};
    public static implicit operator U(C value) {...};

    public static explicit operator A(U union) {...};
    public static explicit operator B(U union) {...};
    public static explicit operator C(U union) {...};

    public bool TryGetA(out A value) {...};
    public bool TryGetB(out B value) {...};
    public bool TryGetC(out C value) {...};

    public enum UnionKind { A = 1, B = 2, C = 3 };
    public UnionKind Kind =&gt; {...};
}"><pre><code>[Union]
struct U 
{
    public record struct A(int x, string y);
    public record struct B(int z);
    public record struct C { public static C Singleton = default; };

    public static implicit operator U(A value) {...};
    public static implicit operator U(B value) {...};
    public static implicit operator U(C value) {...};

    public static explicit operator A(U union) {...};
    public static explicit operator B(U union) {...};
    public static explicit operator C(U union) {...};

    public bool TryGetA(out A value) {...};
    public bool TryGetB(out B value) {...};
    public bool TryGetC(out C value) {...};

    public enum UnionKind { A = 1, B = 2, C = 3 };
    public UnionKind Kind =&gt; {...};
}
</code></pre></div>
<p dir="auto"><em>Note: The <code>Union</code> attribute identifies this type as a union struct type.</em></p>
<p dir="auto"><em>Note: A union struct with a default state has its corresponding <code>UnionKind</code> declared as 0.</em></p>
<p dir="auto"><em>Note: this full generated API of the union struct is not shown.</em></p>

<p dir="auto">Whenever a type test is made against a known union struct, the union structs API is invoked to determine the outcome instead of
testing the union struct&#39;s type itself.</p>
<p dir="auto">For example, the expression:</p>

<p dir="auto">is translated to:</p>

<p dir="auto">And the switch expression:</p>
<div data-snippet-clipboard-copy-content="u switch {
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
}"><pre><code>u switch {
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
}
</code></pre></div>
<p dir="auto">translates to:</p>
<div data-snippet-clipboard-copy-content="u.Kind switch {
   U.UnionKind.A when u.TryGetA(out var a) =&gt; a.x,
   U.UnionKind.B when u.TryGetB(out var b) =&gt; b.z,
   U.UnionKind.C when u.TryGetC(out var c) =&gt; 0,
   _ =&gt; throw ...;
}"><pre><code>u.Kind switch {
   U.UnionKind.A when u.TryGetA(out var a) =&gt; a.x,
   U.UnionKind.B when u.TryGetB(out var b) =&gt; b.z,
   U.UnionKind.C when u.TryGetC(out var c) =&gt; 0,
   _ =&gt; throw ...;
}
</code></pre></div>

<p dir="auto">A union struct that is boxed is a boxed union struct, not the boxed value of one of its member types. You may never need to be concerned about this since the primary use case for a union struct is to avoid boxing. However, it may be necessary on occasion to box a union struct.</p>
<p dir="auto">Normally, type tests for two unrelated structs would never succeed when the boxed value is one type and the test is for the other. However, union struct types and their members are related to each other and so it is possible to type test and unbox a boxed union struct into one of its member types.</p>
<div data-snippet-clipboard-copy-content="U u = ...;
object value = u;

// will succeed since A is known to be a member type of U
if (value is A a) {...}"><pre><code>U u = ...;
object value = u;

// will succeed since A is known to be a member type of U
if (value is A a) {...}
</code></pre></div>
<p dir="auto">Translates to:</p>
<div data-snippet-clipboard-copy-content="if (value is A a || (value is U u &amp;&amp; u.TryGetA(out a))) {...}"><pre><code>if (value is A a || (value is U u &amp;&amp; u.TryGetA(out a))) {...}
</code></pre></div>
<p dir="auto">Likewise, a boxed member type can be tested and unboxed into a union struct.</p>
<div data-snippet-clipboard-copy-content="A a = ...;
object value = a;

// will succeed since U is known to have member type A
if (value is U u) {...}"><pre><code>A a = ...;
object value = a;

// will succeed since U is known to have member type A
if (value is U u) {...}
</code></pre></div>
<p dir="auto">Translates to:</p>
<div data-snippet-clipboard-copy-content="if (value is U u || U.TryCreate(value, out u)) { ... }"><pre><code>if (value is U u || U.TryCreate(value, out u)) { ... }
</code></pre></div>
<p dir="auto">However, when neither type in the test is statically known to be related to a union struct, the type test will fail.</p>
<div data-snippet-clipboard-copy-content="bool IsType&lt;T&gt;(object value) =&gt; value is T;

U u = new A(...);

// always fails
if (IsType&lt;A&gt;(u)) {...}"><pre><code>bool IsType&lt;T&gt;(object value) =&gt; value is T;

U u = new A(...);

// always fails
if (IsType&lt;A&gt;(u)) {...}
</code></pre></div>
<p dir="auto">This is because the language will not special case the type test when no union struct members are involved, since its not clear which type to check for. Checks for a common union interface could be made to work, but that would unduly impact the vast majority of type tests that do not involve union structs.</p>

<p dir="auto">You may be required to interact with union structs when using reflection.</p>
<p dir="auto">For example, you may need to pass a union struct to a method, but you have a boxed instance of the member type <code>A</code> and not the union struct type <code>U</code>. You will need to convert the boxed <code>A</code> value to a boxed <code>U</code> value.</p>
<p dir="auto">The struct union feature provides utility methods to help convert between boxed union structs and boxed member types at runtime.</p>
<div data-snippet-clipboard-copy-content="public static class TypeUnion
{
    public bool TryConvert(Type unionType, object value, out object? boxedUnion);
    public bool TryConvert&lt;TUnion&gt;(object value, out TUnion union);
    public object? GetValue(object? boxedUnion);
}"><pre><code>public static class TypeUnion
{
    public bool TryConvert(Type unionType, object value, out object? boxedUnion);
    public bool TryConvert&lt;TUnion&gt;(object value, out TUnion union);
    public object? GetValue(object? boxedUnion);
}
</code></pre></div>
<p dir="auto"><em>Note: Union classes and ad hoc unions do not require conversion since they are already in the correct form for reflection use.</em></p>

<p dir="auto">A union struct with the <code>ref</code> modifier may contain state variables that are refs or ref structs.</p>
<div data-snippet-clipboard-copy-content="ref union struct U
{
    A(ref int x);
    B(ReadOnlySpan&lt;char&gt; y);
    C;
}"><pre><code>ref union struct U
{
    A(ref int x);
    B(ReadOnlySpan&lt;char&gt; y);
    C;
}
</code></pre></div>
<p dir="auto">In this case, both the implementation of the union and the member types with ref struct values
are translated to ref structs.</p>
<div data-snippet-clipboard-copy-content="ref struct U
{
    public ref struct A { public ref int x; public A(ref int x) {...}; }
    public ref struct B { public ReadOnlySpan&lt;char&gt; y; public B(ReadOnlySpan&lt;char&gt; y) {...} }
    public record struct C { public static C Singleton = default; }
    ...
}"><pre><code>ref struct U
{
    public ref struct A { public ref int x; public A(ref int x) {...}; }
    public ref struct B { public ReadOnlySpan&lt;char&gt; y; public B(ReadOnlySpan&lt;char&gt; y) {...} }
    public record struct C { public static C Singleton = default; }
    ...
}
</code></pre></div>
<p dir="auto"><em>Note: The impacted member types may be able to continue to be record structs if a ref record struct type is added to C#.</em></p>
<hr/>

<p dir="auto">Ad hoc unions are anonymous unions of types declared elsewhere.</p>

<p dir="auto">You refer to an ad hoc union using the <code>or</code> pattern syntax with parentheses.</p>


<p dir="auto">You may desire to refer to an ad hoc union using a common name.
To do this, use a file or global using alias.</p>
<div data-snippet-clipboard-copy-content="global using U = (A or B or C);"><pre><code>global using U = (A or B or C);
</code></pre></div>

<p dir="auto">Ad hoc unions are constructed by assigning an instance of one of the union&#39;s member types to a variable of the ad hoc union type.</p>
<div data-snippet-clipboard-copy-content="record A(int x, string y);
record B(int z);
record C() { public static C Singleton = new C(); };

(A or B or C) u = new A(10, &#34;ten&#34;);"><pre><code>record A(int x, string y);
record B(int z);
record C() { public static C Singleton = new C(); };

(A or B or C) u = new A(10, &#34;ten&#34;);
</code></pre></div>
<p dir="auto">The type of the constructed member is the member type <code>A</code>.
It is converted to type <code>(A or B or C)</code> when assigned to variable <code>u</code>.</p>

<p dir="auto">Ad hoc unions are deconstructed using type tests and pattern matching.</p>
<div data-snippet-clipboard-copy-content="if (u is A a) {...}

if (u is A(var x, var y)) { ... }"><pre><code>if (u is A a) {...}

if (u is A(var x, var y)) { ... }
</code></pre></div>

<p dir="auto">Ad hoc unions are considered exhaustive.
If all member types are accounted for in a switch expression or statement, no default case is needed.</p>
<div data-snippet-clipboard-copy-content="var x = u switch { 
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
    };"><pre><code>var x = u switch { 
    A a =&gt; a.x,
    B b =&gt; b.z,
    C c =&gt; 0
    };
</code></pre></div>

<p dir="auto">Nulls can be included in an ad hoc union using the standard nullability notation.</p>


<p dir="auto">Ad hoc unions with the same member types (regardless of order) are understood by the compiler to be the same type.</p>
<div data-snippet-clipboard-copy-content="(A or B) x = new A(10, &#34;ten&#34;);
(B or A) y = x;"><pre><code>(A or B) x = new A(10, &#34;ten&#34;);
(B or A) y = x;
</code></pre></div>

<div dir="auto"><h4 tabindex="-1" dir="auto">Super and subset assignability</h4><a id="user-content-super-and-subset-assignability" aria-label="Permalink: Super and subset assignability" href="#super-and-subset-assignability"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Ad hoc unions with the same or a subset of member types are assignable to ad hoc unions with a super set, without runtime checks.</p>
<div data-snippet-clipboard-copy-content="(A or B) x = new A(10, &#34;ten&#34;);
(A or B or C) y = x;"><pre><code>(A or B) x = new A(10, &#34;ten&#34;);
(A or B or C) y = x;
</code></pre></div>
<p dir="auto">Ad hoc unions with a superset of member types are assignable to ad hoc unions with a subset, with explicit coercions and runtime checks.</p>
<div data-snippet-clipboard-copy-content="(A or B or C) x = new A(10, &#34;ten&#34;);
var y = (A or B)x;"><pre><code>(A or B or C) x = new A(10, &#34;ten&#34;);
var y = (A or B)x;
</code></pre></div>

<p dir="auto">A value of one ad hoc union type can be implicitly coerced to a value of another ad hoc union type without runtime checks if all member types of the source union are the same type or a sub type of at least one of the target union&#39;s member types.</p>
<div data-snippet-clipboard-copy-content="(Chihuahua or Siamese) pet = ...;
(Cat or Dog) animal = pet;"><pre><code>(Chihuahua or Siamese) pet = ...;
(Cat or Dog) animal = pet;
</code></pre></div>
<p dir="auto">Otherwise an explicit coercion can be made involving runtime checks if at least one member type of the source union is a sub type of one of the member types of the target union.</p>
<div data-snippet-clipboard-copy-content="(Cat or Chihuahua) mostlyCats = ...;
(Dog or Siamese) mostlyDogs = (Dog or Siamese)mostlyCats;"><pre><code>(Cat or Chihuahua) mostlyCats = ...;
(Dog or Siamese) mostlyDogs = (Dog or Siamese)mostlyCats;
</code></pre></div>
<p dir="auto">For the purposes of assignability, you may consider a type that is not an ad hoc union to be an ad hoc union of a single type.</p>
<div data-snippet-clipboard-copy-content="Siamese pet = ...;
(Cat or Chihuahua) mostlyCats = pet;
Dog dog = (Dog)mostlyCats;"><pre><code>Siamese pet = ...;
(Cat or Chihuahua) mostlyCats = pet;
Dog dog = (Dog)mostlyCats;
</code></pre></div>
<p dir="auto"><em>Note: This works for implemented interfaces too.</em></p>

<p dir="auto">A value of a type can be implicitly coerced to a union type if an implicit coercion from that type to one of the union&#39;s member types exists.</p>
<div data-snippet-clipboard-copy-content="(string or double) value = 10;"><pre><code>(string or double) value = 10;
</code></pre></div>
<p dir="auto">A value of an ad hoc union can be implicitly coerced to a type if all member type&#39;s of the union can be implicitly coerced to the type.</p>
<div data-snippet-clipboard-copy-content="(int, short) value = 10;
double value2 = value;"><pre><code>(int, short) value = 10;
double value2 = value;
</code></pre></div>
<p dir="auto">A value of an ad hoc union can be explicitly coerced to a type if one of the member types is coercible to the type.</p>
<div data-snippet-clipboard-copy-content="(string or double) value = 10.0;
int value2 = (int)value;"><pre><code>(string or double) value = 10.0;
int value2 = (int)value;
</code></pre></div>
<p dir="auto">A value of an ad hoc union type can be implicitly coerced to another ad hoc union type if all member types of the source union type can be implicitly coerced to one of the member types of the target union type.</p>
<div data-snippet-clipboard-copy-content="(int or short) value = 10;
(float or double) value2 = value;"><pre><code>(int or short) value = 10;
(float or double) value2 = value;
</code></pre></div>
<p dir="auto">A value of an ad hoc union type can be explicitly coerced to another ad hoc union type if at least one member of the source union type can be explicitly coerced to one of the member types of the target union type.</p>
<div data-snippet-clipboard-copy-content="(float or double) value = 10.0;
(int or short) value2 = (int or short)value;"><pre><code>(float or double) value = 10.0;
(int or short) value2 = (int or short)value;
</code></pre></div>
<p dir="auto"><em>Note: Need rule for which coercion if multiple are possible.</em></p>
<p dir="auto"><em>Note: This assignability relationship is not intended to be a sub typing relationship. One ad hoc union is not a sub type of another ad hoc union.</em></p>

<p dir="auto">Ad hoc unions with the same member types are interchangeable through generics and array elements.</p>
<p dir="auto">For example, constructing an array of ad hoc unions of generic type parameters,
will return an array that is compatible with an array of ad hoc unions of concrete types.</p>
<div data-snippet-clipboard-copy-content="(T1 or T2)[] F&lt;T1, T2&gt;(T1 v1, T2 v2) =&gt; new (T1 or T2)[] { v1, v2 };

(Dog or Cat)[] pets = F&lt;Dog, Cat&gt;(rufus, petunia);"><pre><code>(T1 or T2)[] F&lt;T1, T2&gt;(T1 v1, T2 v2) =&gt; new (T1 or T2)[] { v1, v2 };

(Dog or Cat)[] pets = F&lt;Dog, Cat&gt;(rufus, petunia);
</code></pre></div>
<p dir="auto">Likewise,</p>
<div data-snippet-clipboard-copy-content="IReadOnlyList&lt;(Cat or Dog)&gt; pets = F&lt;Dog, Cat&gt;(rufus, petunia);"><pre><code>IReadOnlyList&lt;(Cat or Dog)&gt; pets = F&lt;Dog, Cat&gt;(rufus, petunia);
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Covariance and Contravariance</h3><a id="user-content-covariance-and-contravariance" aria-label="Permalink: Covariance and Contravariance" href="#covariance-and-contravariance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Ad hoc union types used as with generic type arguments can be used with covariance and contra-variance, if all member types of the two ad hoc unions involved have sub type relationships with members of the other.</p>
<p dir="auto">I&#39;d tell you the specific rules, but it hurts my head to think about it.</p>
<div data-snippet-clipboard-copy-content="void Groom(IEnumerable&lt;(Dog or Cat)&gt; animals) =&gt; ...;

List&lt;(Chihuahua or Siamese)&gt; pets = ...;
Groom(pet);"><pre><code>void Groom(IEnumerable&lt;(Dog or Cat)&gt; animals) =&gt; ...;

List&lt;(Chihuahua or Siamese)&gt; pets = ...;
Groom(pet);
</code></pre></div>
<p dir="auto"><em>Note: Have Mads write this part.</em></p>

<p dir="auto">Ad hoc unions may be used in pattern matching and behave similarly to the <code>or</code> pattern, and may also have a variable declaration.</p>
<div data-snippet-clipboard-copy-content="if (u is Dog or Cat) { ... }  // normal &#39;or&#39; pattern

if (u is (Dog or Cat)) { ... }  // type test with ad hoc union

if (u is (Dog or Cat) pet) {...}  // type test with ad hoc union and variable"><pre><code>if (u is Dog or Cat) { ... }  // normal &#39;or&#39; pattern

if (u is (Dog or Cat)) { ... }  // type test with ad hoc union

if (u is (Dog or Cat) pet) {...}  // type test with ad hoc union and variable
</code></pre></div>
<p dir="auto"><em>Note: assigning into an ad hoc union variable may cause boxing of value types</em></p>

<p dir="auto">Ad hoc unions can be inferred from context when that inference would not otherwise have been possible.</p>
<p dir="auto">The conditional and switch expressions can have result types inferred as ad hoc unions from the constituent expressions.</p>
<div data-snippet-clipboard-copy-content="Dog rufus = ...;
Cat petunia = ...;
Bird polly = ...;

// u : (Dog or Cat or Bird)
var u = 
      x == 1 ? rufus
    : x == 2 ? petunia
    : polly;"><pre><code>Dog rufus = ...;
Cat petunia = ...;
Bird polly = ...;

// u : (Dog or Cat or Bird)
var u = 
      x == 1 ? rufus
    : x == 2 ? petunia
    : polly;
</code></pre></div>
<p dir="auto">Likewise, the return type of a lambda expression can also be inferred using an ad hoc union of the return types of the lambda body.</p>
<div data-snippet-clipboard-copy-content="T M&lt;T&gt;(F&lt;int, T&gt; f) =&gt; f(2);

(Dog or Cat or Bird) pet = 
    M(x =&gt; 
    {
        if (x == 1)
            return rufus;
        else if (x == 2)
            return petunia;
        return polly;
    });"><pre><code>T M&lt;T&gt;(F&lt;int, T&gt; f) =&gt; f(2);

(Dog or Cat or Bird) pet = 
    M(x =&gt; 
    {
        if (x == 1)
            return rufus;
        else if (x == 2)
            return petunia;
        return polly;
    });
</code></pre></div>
<p dir="auto"><em>Note: this may cause boxing of value types</em></p>

<p dir="auto">Ad hoc unions are implemented through erasure and runtime checks.</p>
<div data-snippet-clipboard-copy-content="(A or B) ab = new A(10, &#34;ten&#34;);"><pre><code>(A or B) ab = new A(10, &#34;ten&#34;);
</code></pre></div>
<p dir="auto">translates to:</p>
<div data-snippet-clipboard-copy-content="object ab = new A(10, &#34;ten&#34;);"><pre><code>object ab = new A(10, &#34;ten&#34;);
</code></pre></div>

<p dir="auto">Assignments that are not statically known to be correct require runtime checks.
The compiler generates a custom method for each unique ad hoc union used in the module.</p>
<div data-snippet-clipboard-copy-content="object value = ...;
var ab = (A or B)value;"><pre><code>object value = ...;
var ab = (A or B)value;
</code></pre></div>
<p dir="auto">translates to:</p>
<div data-snippet-clipboard-copy-content="object value = ...;
object ab = &lt;ValidateAB&gt;(value);

object &lt;ValidateAB&gt;(object? value) =&gt;
    value is A or B ? value : throw ...;"><pre><code>object value = ...;
object ab = &lt;ValidateAB&gt;(value);

object &lt;ValidateAB&gt;(object? value) =&gt;
    value is A or B ? value : throw ...;
</code></pre></div>
<p dir="auto"><em>note: Parameters are not checked at entry of a method.</em></p>

<p dir="auto">The type of the ad hoc union is encoded in metadata using custom attributes.</p>

<p dir="auto">translates to:</p>
<div data-snippet-clipboard-copy-content="void M([AdHocUnion([typeof(A), typeof(B)])] object x);"><pre><code>void M([AdHocUnion([typeof(A), typeof(B)])] object x);
</code></pre></div>
<p dir="auto"><em>note: The details of this attribute are not yet specified.</em></p>

<p dir="auto">Since all ad hoc unions erase to the same type, true runtime overloading of methods with ad hoc union parameters is not possible.</p>
<div data-snippet-clipboard-copy-content="public void Wash((Cat or Dog) pet) { ... }
public void Wash((Compact or Sedan) car) { ... }"><pre><code>public void Wash((Cat or Dog) pet) { ... }
public void Wash((Compact or Sedan) car) { ... }
</code></pre></div>
<p dir="auto">This is still an open area of discussion.</p>
<hr/>

<p dir="auto">If you need to declare a union type that cannot be specified as a union class or a union struct,
due to specific behaviors that cannot be specified via the union syntax or for other reasons,
you may declare you own custom class or struct and have C# recognize it as a custom union type.</p>
<p dir="auto">For example, if your union is specified as a class hierarchy, you can give it the same exhaustiveness behavior
as union classes using the <code>Closed</code> attribute.  It will be functionally the same as a union class.</p>
<div data-snippet-clipboard-copy-content="[Closed]
public class U { ... }
public class A(int x, string y) : U { ... }
public class B(int z) : U { ... }"><pre><code>[Closed]
public class U { ... }
public class A(int x, string y) : U { ... }
public class B(int z) : U { ... }
</code></pre></div>
<p dir="auto">If your union is implemented as a struct wrapper with specialized storage rules, you can annotate your struct with the <code>Union</code> attribute
and as long as you provide API&#39;s following the union pattern, your struct will be functionally the same as a union struct.</p>
<div data-snippet-clipboard-copy-content="[Union]
public struct U    
{
    public record struct A(int x, string y);
    public record struct B(int z);

    public bool TryGetA(out var A a) { ... }
    public bool TryGetB(out var B b) { ... }
}"><pre><code>[Union]
public struct U    
{
    public record struct A(int x, string y);
    public record struct B(int z);

    public bool TryGetA(out var A a) { ... }
    public bool TryGetB(out var B b) { ... }
}
</code></pre></div>
<p dir="auto">If your union does not include member types or uses a different API pattern
you may provide the API the compiler is expecting via extensions.</p>
<div data-snippet-clipboard-copy-content="[Union]
public struct U
{
    public bool IsA { get; }
    public void GetA(out int x, out string y);
    public bool IsB { get; }
    public void GetB(out int z);
}

public implicit extension UX for U 
{
    public record struct A(int x, int y);
    public record struct B(int z);

    public bool TryGetA(out A a) { ... }
    public bool TryGetB(out B b) { ... }
}"><pre><code>[Union]
public struct U
{
    public bool IsA { get; }
    public void GetA(out int x, out string y);
    public bool IsB { get; }
    public void GetB(out int z);
}

public implicit extension UX for U 
{
    public record struct A(int x, int y);
    public record struct B(int z);

    public bool TryGetA(out A a) { ... }
    public bool TryGetB(out B b) { ... }
}
</code></pre></div>
<p dir="auto"><em>Note: The full union struct API pattern is not yet specified.</em></p>
<p dir="auto"><em>Note: You cannot customize the behavior of an ad hoc union, other than your ability to modify the behaviors of
the individual member types.</em></p>
<hr/>


<p dir="auto">Option is a struct union, similar to the type of the same name or purpose found in other languages.
It is used to represent a value that may exist or not.</p>
<div data-snippet-clipboard-copy-content="public union struct Option&lt;TValue&gt;
{
    Some(TValue value);
    None = default;
}"><pre><code>public union struct Option&lt;TValue&gt;
{
    Some(TValue value);
    None = default;
}
</code></pre></div>
<p dir="auto">usage:</p>
<div data-snippet-clipboard-copy-content="Option&lt;string&gt; x = new Some(&#34;text&#34;);
Option&lt;string&gt; y = None;

if (x is Some(var value)) {...}

var v = x is Some(var value) ? value : 0;"><pre><code>Option&lt;string&gt; x = new Some(&#34;text&#34;);
Option&lt;string&gt; y = None;

if (x is Some(var value)) {...}

var v = x is Some(var value) ? value : 0;
</code></pre></div>
<p dir="auto"><em>Note: Option type not fully specified.</em></p>

<p dir="auto">Result is a struct union, similar to the type of the same name or purpose found in other languages.
It is used to return either a successful result or an error from a function.</p>
<div data-snippet-clipboard-copy-content="public union struct Result&lt;TValue, TError&gt;
{
    Success(TValue value);
    Failure(TError error);
}"><pre><code>public union struct Result&lt;TValue, TError&gt;
{
    Success(TValue value);
    Failure(TError error);
}
</code></pre></div>
<p dir="auto">usage:</p>
<div data-snippet-clipboard-copy-content="Result&lt;string, string&gt; x = Success(&#34;hurray!&#34;);
Result&lt;string, string&gt; y = Failure(&#34;boo&#34;);

switch (x)
{
    case Success(var value): ...;
    case Failure(var error): ...;
}"><pre><code>Result&lt;string, string&gt; x = Success(&#34;hurray!&#34;);
Result&lt;string, string&gt; y = Failure(&#34;boo&#34;);

switch (x)
{
    case Success(var value): ...;
    case Failure(var error): ...;
}
</code></pre></div>
<p dir="auto"><em>Note: Result type not fully specified.</em></p>
<hr/>

<p dir="auto">These are proposed (or yet to be proposed) features that are presumed to exist by this proposal.</p>

<p dir="auto">A <code>Closed</code> attribute applied to an abstract base type declares the closed set of sub-types to be all the
sub-types in the declaring module.</p>
<p dir="auto">The compiler errors when sub types are declared outside the declaring module.</p>
<p dir="auto">A closed hierarchy is treated as exhaustive by the compiler.
If all sub-types are accounted for in a switch expression or statement, no default case is needed.</p>

<p dir="auto">Types that are singletons (with an static <code>Singleton</code>) property can used as values in non-type contexts by implicitly accessing the property.</p>
<p dir="auto">Instead of:</p>

<p dir="auto">You can write:</p>


<p dir="auto">Names that are otherwise not bound, can be bound to static members or nested types of the target type.</p>
<p dir="auto">Instead of:</p>

<p dir="auto">You can write:</p>

<p dir="auto">Instead of:</p>
<div data-snippet-clipboard-copy-content="U u = new U.A(10, &#34;ten&#34;);"><pre><code>U u = new U.A(10, &#34;ten&#34;);
</code></pre></div>
<p dir="auto">You can write:</p>

<hr/>

<p dir="auto">Q: If I can easily declare my own nested hierarchy of records, are union classes needed?</p>
<p dir="auto">Q: If union structs can use more kinds of types with little or no allocation why do union classes and ad hoc unions exist?</p>
<ul dir="auto">
<li>
<p dir="auto">They may not cause their own allocations but that does not mean they perform better.</p>
</li>
<li>
<p dir="auto">Union structs do not work well as a solution for anonymous ad hoc unions, since they are not easily interchangeable.</p>
</li>
<li>
<p dir="auto">Union structs have problems with type tests, casts and pattern matching when boxed or represented in code statically as a generic type parameter.</p>
</li>
</ul>
<p dir="auto">Q: Why are there no tagged unions?</p>
<p dir="auto">Q: Can the compiler skip constructing a union struct&#39;s member type if I immediately assign it to union struct variable?</p>
<p dir="auto">Q: Can the compiler skip copying my union struct state variables into a member type if I deconstruct my union directly to variables?</p>
<p dir="auto">Q: Is the union struct, like the union class, the base type of its member types?</p>
<p dir="auto">Q: Can I declare ad hoc unions with names?</p>
<p dir="auto">Q: Can I have an ad hoc union that does not box value types?</p>
<p dir="auto">Q: Can I have an ad hoc union that includes ref types?</p>
<p dir="auto">Q: If variables typed as object are bad, why are ad hoc unions erased to object?</p>
<p dir="auto">Q: Can I access common properties and methods of the ad hoc union without handling each type case?</p>
<p dir="auto">Q: Why don&#39;t you just use the same kinds of unions that are in F#?</p>
<p dir="auto">Q: Why do I need the <code>Option</code> type if I can do the same thing with nulls and nullable reference types?</p>
<p dir="auto">Q: Will the <code>Option</code> and <code>Result</code> type also include the monadic behaviors that these types enable in F#?</p>
<p dir="auto">Q: Why do I need the <code>Result</code> type when I already have exception handling?</p>
<p dir="auto">Q: Types similar to the <code>Option</code> and <code>Result</code> types are already available in other 3rd party libraries. Why are you adding them to the runtime?</p>
</article></div></section></div></div></div></div>
  </body>
</html>
